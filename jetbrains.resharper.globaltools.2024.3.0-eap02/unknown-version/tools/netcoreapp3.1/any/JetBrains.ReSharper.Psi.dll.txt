[SolutionComponentAttribute("0")]
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Feature.Services.SolutionFeaturePartsContainer : object {
    private IComponentContainer myContainer;
    public SolutionFeaturePartsContainer(NestedComponentContainerAllByPartAttribute`2<SolutionFeaturePartAttribute, ShellPartCatalogSet> nestedComponentContainer);
    public IEnumerable`1<T> GetFeatureParts(Func`2<T, bool> isApplicable);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.AccessibilityDomain : ValueType {
    [CompilerGeneratedAttribute]
private AccessibilityDomainType <DomainType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <Container>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    public AccessibilityDomainType DomainType { get; }
    [CanBeNullAttribute]
public ITypeElement Container { get; }
    [CanBeNullAttribute]
public IPsiSourceFile SourceFile { get; }
    public AccessibilityDomain(AccessibilityDomainType domainType, ITypeElement container);
    public AccessibilityDomain(IPsiSourceFile sourceFile);
    [CompilerGeneratedAttribute]
public AccessibilityDomainType get_DomainType();
    [CompilerGeneratedAttribute]
public ITypeElement get_Container();
    [CompilerGeneratedAttribute]
public IPsiSourceFile get_SourceFile();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.AccessorExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsExplicitAllowedAccessorModifierForPropertyWithAccess(AccessRights accessorRights, AccessRights ownerAccessRights);
}
public enum JetBrains.ReSharper.Psi.AccessorKind : Enum {
    public byte value__;
    public static AccessorKind UNKNOWN;
    public static AccessorKind GETTER;
    public static AccessorKind SETTER;
    public static AccessorKind ADDER;
    public static AccessorKind REMOVER;
    public static AccessorKind RAISER;
}
public enum JetBrains.ReSharper.Psi.AccessRights : Enum {
    public int value__;
    public static AccessRights PUBLIC;
    public static AccessRights INTERNAL;
    public static AccessRights PROTECTED;
    public static AccessRights PROTECTED_OR_INTERNAL;
    public static AccessRights PROTECTED_AND_INTERNAL;
    public static AccessRights PRIVATE;
    public static AccessRights FILE_LOCAL;
    public static AccessRights NONE;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.AccessRightsExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPublicOrProtected(AccessRights accessRights);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.ActionExtensions.ActionContextWrapper : object {
    private ISolution mySolution;
    public ActionContextWrapper(ActionEvents actionEvents, Lifetime lifetime, ISolution solution);
    private void WrapActionMitCookie(ActionEventArgs actionEventArgs);
    private IModuleReferenceResolveContext GetResolveContext(IActionDefWithId actionDef, IDataContext dataContext);
}
public class JetBrains.ReSharper.Psi.ActionExtensions.ActionDefWithContext : ActionDef {
    [CompilerGeneratedAttribute]
private CompilationContextKind <Kind>k__BackingField;
    public CompilationContextKind Kind { get; }
    public ActionDefWithContext(PartCatalogType part, PartCatalogAttribute attribute, int multiIndex);
    [CompilerGeneratedAttribute]
public sealed virtual CompilationContextKind get_Kind();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ActionExtensions.ActionWithPsiContextAttribute : ActionAttribute {
    [CompilerGeneratedAttribute]
private CompilationContextKind <Kind>k__BackingField;
    public static string ActionAttributeContextKind;
    public CompilationContextKind Kind { get; public set; }
    public ActionWithPsiContextAttribute(Type ResourceType, string TextResourceName, Instantiation instantiation);
    private static ActionWithPsiContextAttribute();
    [CompilerGeneratedAttribute]
public CompilationContextKind get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(CompilationContextKind value);
}
public interface JetBrains.ReSharper.Psi.ActionExtensions.IContextActionDefWithId {
    public CompilationContextKind Kind { get; }
    public abstract virtual CompilationContextKind get_Kind();
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.ActionExtensions.PsiContextActionDefFactory : object {
    [NullableContextAttribute("1")]
private sealed virtual override ActionDef JetBrains.Application.UI.ActionsRevised.Loader.ICustomActionDefFactory.Create(PartCatalogType part, PartCatalogAttribute attribute, int i);
    private sealed virtual override bool JetBrains.Application.UI.ActionsRevised.Loader.ICustomActionDefFactory.IsApplicable(PartCatalogType part, PartCatalogAttribute attribute);
}
public abstract class JetBrains.ReSharper.Psi.AggregatingTypeVisitor`2 : TypeVisitor`2<TContext, TResult> {
    [PureAttribute]
public virtual bool IsProcessingFinished(TResult result, TContext context);
    public virtual TResult Merge(TResult previous, TResult current, TContext context);
    public virtual TResult VisitTypeElement(ITypeElement typeElement, TContext context);
    public virtual TResult VisitUnresolvedTypeElement(IDeclaredType declaredType, TContext context);
    public virtual TResult VisitTypeArgument(ITypeElement typeElement, ITypeParameter typeParameter, IType typeArgument, TContext context);
    public virtual TResult VisitDeclaredType(IDeclaredType declaredType, TContext context);
    public virtual TResult VisitArrayType(IArrayType arrayType, TContext context);
    public virtual TResult VisitPointerType(IPointerType pointerType, TContext context);
    public virtual TResult VisitFunctionPointerType(IFunctionPointerType functionPointerType, TContext context);
    public virtual TResult VisitMultitype(IMultitype multitype, TContext context);
    public virtual TResult VisitAnonymousType(IAnonymousType anonymousType, TContext context);
}
public enum JetBrains.ReSharper.Psi.AliasPresentationStyle : Enum {
    public int value__;
    public static AliasPresentationStyle NAME;
    public static AliasPresentationStyle ALIASED_SYMBOL;
    public static AliasPresentationStyle NAME_EQUALS_ALIASED_SYMBOL;
    public static AliasPresentationStyle NAME_WITH_ALIASED_SYMBOL_IN_PARENTHESES;
    public static AliasPresentationStyle NAME_WITH_ALIASED_SYMBOL_WITH_KIND_IN_PARENTHESES;
}
public class JetBrains.ReSharper.Psi.AnonymousTypeDescriptor : ValueType {
    public string Name;
    public IType Type;
    public bool IsKey;
    public AnonymousTypeDescriptor(string name, IType type, bool isKey);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.AnonymousTypePropertyDescriptor : ValueType {
    public string Name;
    public bool IsKey;
    public AnonymousTypePropertyDescriptor(string name, bool isKey);
    public bool Equals(AnonymousTypePropertyDescriptor other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ArgumentsInfoExtension : object {
    [ExtensionAttribute]
[PureAttribute]
public static int IndexOf(IArgumentInfo argumentInfo);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ArrayTypeExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(IArrayType arrayType, IType& elementType);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(IArrayType arrayType, IType& elementType, Int32& rank);
}
public abstract class JetBrains.ReSharper.Psi.AsyncCommitService : object {
    [NotNullAttribute]
public static AsyncCommitService GetInstance(ISolution solution);
    public abstract virtual void RequestCommit(IAsyncCommitClient client, Nullable`1<int> delay);
    public abstract virtual void DropRequest(IAsyncCommitClient client);
    public abstract virtual bool HasOtherRequestsInQueue(IAsyncCommitClient client);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.AttributeInstanceExtensions : object {
    public static string ATTRIBUTE_SUFFIX;
    public static string TrimAttributeShortName(string value);
    [ExtensionAttribute]
[NotNullAttribute]
public static string DumpDescription(IAttributeInstance attributeInstance);
    [ExtensionAttribute]
public static void Dump(IAttributeInstance instance, TextWriter writer);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.AttributesSetExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IList`1<IAttributeInstance> GetAttributeInstances(IAttributesSet attributesSet, bool inherit);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IList`1<IAttributeInstance> GetAttributeInstances(IAttributesSet attributesSet, IClrTypeName clrName, bool inherit);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasAttributeInstance(IAttributesSet attributesSet, IClrTypeName clrName, bool inherit);
    [PureAttribute]
private static AttributesSource GetAttributesSource(bool inherit);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.AttributesSource : Enum {
    public int value__;
    public static AttributesSource Self;
    public static AttributesSource Inherited;
    public static AttributesSource Related;
    public static AttributesSource All;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.AttributesSourceExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IncludesSelf(AttributesSource attributesSource);
    [ExtensionAttribute]
[PureAttribute]
public static bool IncludesSuperMembers(AttributesSource attributesSource);
    [ExtensionAttribute]
[PureAttribute]
public static bool IncludesRelated(AttributesSource attributesSource);
}
public class JetBrains.ReSharper.Psi.AttributeValue : object {
    [NotNullAttribute]
public static AttributeValue BAD_VALUE;
    [CompilerGeneratedAttribute]
private ConstantValue <ConstantValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <TypeValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IArrayType <ArrayType>k__BackingField;
    [CompilerGeneratedAttribute]
private AttributeValue[] <ArrayValue>k__BackingField;
    public bool IsBadValue { get; }
    public bool IsConstant { get; }
    public bool IsType { get; }
    public bool IsArray { get; }
    [NotNullAttribute]
public ConstantValue ConstantValue { get; }
    [CanBeNullAttribute]
public IType TypeValue { get; }
    [CanBeNullAttribute]
public IArrayType ArrayType { get; }
    [CanBeNullAttribute]
public AttributeValue[] ArrayValue { get; }
    public AttributeValue(ConstantValue constantValue);
    public AttributeValue(IType typeof);
    public AttributeValue(IArrayType arrayType, AttributeValue[] values);
    private static AttributeValue();
    public bool get_IsBadValue();
    public bool get_IsConstant();
    public bool get_IsType();
    public bool get_IsArray();
    [CompilerGeneratedAttribute]
public ConstantValue get_ConstantValue();
    [CompilerGeneratedAttribute]
public IType get_TypeValue();
    [CompilerGeneratedAttribute]
public IArrayType get_ArrayType();
    [CompilerGeneratedAttribute]
public AttributeValue[] get_ArrayValue();
    public IType GetType(IPsiModule module);
    public void Dump(TextWriter writer);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.AttributeValueExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static string TryGetString(AttributeValue attributeValue);
    [ExtensionAttribute]
[PureAttribute]
public static bool TryGetType(AttributeValue attributeValue, IType& type);
    [ExtensionAttribute]
[PureAttribute]
public static bool TryGetBoolean(AttributeValue attributeValue, bool defaultValue);
    [ExtensionAttribute]
[PureAttribute]
public static int TryGetInt(AttributeValue attributeValue, int defaultValue);
}
public static class JetBrains.ReSharper.Psi.BadAncestorSubstitutionHandling : object {
    [CanBeNullAttribute]
[PureAttribute]
public static ISubstitution GetAncestorSubstitution(ITypeElement inheritor, ITypeElement base);
}
public class JetBrains.ReSharper.Psi.BoxedRefSafetyRulesVersion : object {
    public RefSafetyRulesVersion RulesVersion;
    public BoxedRefSafetyRulesVersion(RefSafetyRulesVersion rulesVersion);
}
public static class JetBrains.ReSharper.Psi.BuildScript.ExternalAnnotations.InstallAnnotations : object {
    public static RelativePath InPackageRelativeLocation;
    private static InstallAnnotations();
    [BuildStepAttribute]
public static IEnumerable`1<SubplatformFileForPackagingFast> DoInstallAnnotations(RetrievedPackageReferenceArtifact[] references);
}
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.CachedProjectFileLanguageService : object {
    private CachingProjectFileTypeServicesAccess`1<IProjectFileLanguageService> myCachedServicesAccess;
    public CachedProjectFileLanguageService(Lifetime lifetime, IProjectFileTypeServices projectFileTypeServices);
    [CanBeNullAttribute]
public IProjectFileLanguageService TryGetService(ProjectFileType type);
}
public class JetBrains.ReSharper.Psi.CachedPsiValue`1 : object {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myPsiTimeStamp;
    private T myValue;
    [MustUseReturnValueAttribute]
public T GetValue(ITreeNode element, Func`1<T> calculator);
    [MustUseReturnValueAttribute]
public T GetValue(TNode element, Func`2<TNode, T> calculator);
    [MustUseReturnValueAttribute]
public T GetValue(TNode element, TState state, Func`3<TNode, TState, T> calculator);
    [MustUseReturnValueAttribute]
public T GetValue(TNode element, TState1 state1, TState2 state2, Func`4<TNode, TState1, TState2, T> calculator);
    [PureAttribute]
[CanBeNullAttribute]
public T GetValue(ITreeNode element);
    public void SetValue(ITreeNode element, T value);
    public bool IsUpToDate(ITreeNode element);
    public T GetValueRaw();
    protected virtual int GetTimestamp(ITreeNode element);
    public void Invalidate();
    [NotNullAttribute]
public static CachedPsiValue`1<T> Create(ITreeNode element, T data);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CachedPsiValueExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static CachedPsiValue`1<T> CreateCachedValue(ITreeNode element, T data);
    [ExtensionAttribute]
public static T GetCachedValue(ITreeNode element, CachedPsiValue`1& data);
    [ExtensionAttribute]
public static void SetCachedValue(ITreeNode element, CachedPsiValue`1& data, T value);
}
public class JetBrains.ReSharper.Psi.CachedPsiValueWithOffsets`1 : CachedPsiValue`1<T> {
    protected virtual int GetTimestamp(ITreeNode element);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PsiComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Caches.AnnotatedEntities.AnnotatedEntitiesCache : SimpleICache`1<AnnotatedEntitiesSet> {
    private ReaderWriterLockSlim myReaderWriterLock;
    private Dictionary`2<string, Dictionary`2<IPsiSourceFile, HashSet`1<string>>> myTypesByAttributeName;
    private Dictionary`2<string, Dictionary`2<IPsiSourceFile, HashSet`1<string>>> myMembersByAttributeName;
    private Dictionary`2<string, Dictionary`2<IPsiSourceFile, HashSet`1<FullTypeMemberName>>> myFullMembersByAttributeName;
    private HashSet`1<string> myAnnotationAttributes;
    private IPsiFiles myPsiFiles;
    private Dictionary`2<PsiLanguageType, IAnnotatedEntitiesCacheProcessor> myCacheProcessors;
    private long myWatchedAttributesHash;
    private SynchronizedSet`1<IPsiSourceFile> myLocalDirtyFiles;
    public string Version { get; }
    public AnnotatedEntitiesCache(Lifetime lifetime, IShellLocks locks, IPsiFiles psiFiles, IPersistentIndexManager persistentIndexManager, LanguageManager languageManager, ExternalAnnotationsAttributesToWatchers watchers);
    public virtual string get_Version();
    public virtual void MergeLoaded(object data);
    private void UpdateValue(string attributeName, IPsiSourceFile currentFile, Dictionary`2<string, Dictionary`2<IPsiSourceFile, HashSet`1<TValue>>> localCache, IList`1<TValue> values, Func`1<HashSet`1<TValue>> createEmptySet);
    private void SetValue(IPsiSourceFile currentFile, Dictionary`2<string, Dictionary`2<IPsiSourceFile, HashSet`1<TValue>>> localCache, OneToListMap`2<string, TValue> values, Func`2<IEnumerable`1<TValue>, HashSet`1<TValue>> createEmptySet);
    public virtual bool UpToDate(IPsiSourceFile sourceFile);
    public virtual object Build(IPsiSourceFile sourceFile, bool isStartup);
    private object Build(IPsiSourceFile sourceFile);
    public virtual void Merge(IPsiSourceFile sourceFile, object builtPart);
    private void MergeLocal(IPsiSourceFile sourceFile, object builtPart);
    public virtual void Drop(IPsiSourceFile sourceFile);
    private void DropLocal(IPsiSourceFile sourceFile);
    protected virtual bool IsApplicable(IPsiSourceFile sourceFile);
    public virtual void MarkAsDirty(IPsiSourceFile sourceFile);
    protected virtual void RemoveFromDirty(IPsiSourceFile sf);
    internal void UpdateLocalDirtyFiles();
    public HashSet`1<string> TryGetTypesByAttributeName(string attributeName);
    public bool HasMemberWithAttribute(string memberName, string attributeName);
    public HashSet`1<string> TryGetMembersByAttributeName(string attributeName);
    public HashSet`1<FullTypeMemberName> TryGetFullTypeMemberNamesByAttributeName(string attributeName);
    private bool HasEntitiesWithAttribute(TValue entityName, string attributeName, Dictionary`2<string, Dictionary`2<IPsiSourceFile, HashSet`1<TValue>>> entitiesByAttributeName);
    private HashSet`1<TValue> TryGetEntitiesByAttributeName(string attributeName, IDictionary`2<string, Dictionary`2<IPsiSourceFile, HashSet`1<TValue>>> entitiesByAttributeName, IEqualityComparer`1<TValue> comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Caches.AnnotatedEntities.AnnotatedEntitiesSet : object {
    [CompilerGeneratedAttribute]
private OneToListMap`2<string, string> <AttributeToMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private OneToListMap`2<string, string> <AttributeToTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private OneToListMap`2<string, FullTypeMemberName> <AttributeToFullMembers>k__BackingField;
    public OneToListMap`2<string, string> AttributeToMembers { get; }
    public OneToListMap`2<string, string> AttributeToTypes { get; }
    public OneToListMap`2<string, FullTypeMemberName> AttributeToFullMembers { get; }
    public AnnotatedEntitiesSet(OneToListMap`2<string, string> attributeToMembers, OneToListMap`2<string, string> attributeToTypes, OneToListMap`2<string, FullTypeMemberName> attributeToFullMembers);
    [CompilerGeneratedAttribute]
public OneToListMap`2<string, string> get_AttributeToMembers();
    [CompilerGeneratedAttribute]
public OneToListMap`2<string, string> get_AttributeToTypes();
    [CompilerGeneratedAttribute]
public OneToListMap`2<string, FullTypeMemberName> get_AttributeToFullMembers();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.Caches.AnnotatedEntities.AnnotatedEntitiesSetMarshaller : object {
    public static AnnotatedEntitiesSetMarshaller Instance;
    private IUnsafeMarshaller`1<OneToListMap`2<string, FullTypeMemberName>> myMapToFullNameMarshaller;
    private IUnsafeMarshaller`1<OneToListMap`2<string, string>> myMapToStringMarshaller;
    private static AnnotatedEntitiesSetMarshaller();
    public sealed virtual void Marshal(UnsafeWriter writer, AnnotatedEntitiesSet value);
    public sealed virtual AnnotatedEntitiesSet Unmarshal(UnsafeReader reader);
    private static OneToListMap`2<string, string> CreateEmptyMapToString(int capacity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Caches.AnnotatedEntities.AssemblyAnnotatedEntitiesCache : object {
    private IPsiModules myPsiModules;
    private IPsiAssemblyFileLoader myPsiAssemblyFileLoader;
    private ExternalAnnotationsAttributesToWatchers myAnnotationsAttributesToWatchers;
    private ChangeManager myChangeManager;
    private OptimizedPersistentSortedMap`2<AssemblyId, AnnotatedEntitiesSet> myShellDataMap;
    private OptimizedPersistentSortedMap`2<AssemblyId, long> myShellTimestampMap;
    private OptimizedPersistentSortedMap`2<AssemblyId, AnnotatedEntitiesSet> mySolutionDataMap;
    private OptimizedPersistentSortedMap`2<AssemblyId, long> mySolutionTimestampMap;
    private static AnnotatedEntitiesSet NO_CHANGE;
    private ConcurrentDictionary`2<string, String[]> myMembersByAttributeName;
    private ConcurrentDictionary`2<string, String[]> myTypesByAttributeName;
    private ConcurrentDictionary`2<string, FullTypeMemberName[]> myFullTypeMembersByAttributeName;
    public string Version { get; }
    public bool ClearOnLoad { get; public set; }
    public string PersistentId { get; }
    public AssemblyAnnotatedEntitiesCache(Lifetime lifetime, IPsiModules psiModules, IPsiAssemblyFileLoader psiAssemblyFileLoader, ShellCaches shellCaches, ISolutionCaches solutionCaches, ExternalAnnotationsAttributesToWatchers annotationsAttributesToWatchers, ChangeManager changeManager);
    private static AssemblyAnnotatedEntitiesCache();
    private void GetCaches(Lifetime lifetime, IKeyValueDb db, OptimizedPersistentSortedMap`2& dataMap, OptimizedPersistentSortedMap`2& timestampMap);
    public sealed virtual string get_Version();
    public sealed virtual bool get_ClearOnLoad();
    public sealed virtual void set_ClearOnLoad(bool value);
    public sealed virtual string get_PersistentId();
    private sealed virtual override object JetBrains.ReSharper.Psi.Caches.ICache.Load(IProgressIndicator progress, bool enablePersistence);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.ICache.MergeLoaded(object data);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.ICache.Save(IProgressIndicator progress, bool enablePersistence);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.IAssemblyCache.Merge(IPsiAssembly assembly, object part, Func`1<bool> checkForTermination);
    private void Merge(IPsiAssembly assembly, object part, OptimizedPersistentSortedMap`2<AssemblyId, AnnotatedEntitiesSet> dataMap);
    [NullableContextAttribute("2")]
private void ClearCache(AnnotatedEntitiesSet assemblyData);
    private void Clear(OneToListMap`2<string, TValue> assemblyData, ConcurrentDictionary`2<string, TValue[]> localDictionary);
    private sealed virtual override object JetBrains.ReSharper.Psi.Caches.IAssemblyCache.Build(IPsiAssembly assembly);
    private static void AddAttributes(List`1<string> attributes, TValue entity, OneToListMap`2<string, TValue> entitiesByAttribute);
    private void CollectAnnotationsFromMetadata(AnnotatedEntitiesSet assemblyData, IMetadataAssembly metadataAssembly);
    private void CollectAnnotationsFromExternalAnnotations(AnnotatedEntitiesSet assemblyData, AssemblyExternalAnnotations assemblyExternalAnnotations, ExternalAnnotationsAttributesToWatchers externalAnnotationsAttributesToWatchers);
    private object Build(IPsiAssembly assembly, IPsiAssemblyFile assemblyFile, IMetadataAssembly metadataAssembly, OptimizedPersistentSortedMap`2<AssemblyId, long> timestampMap);
    private List`1<string> GetAttributes(IMetadataEntity metadataEntity);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.IAssemblyCache.Drop(IEnumerable`1<IPsiAssembly> assemblies);
    protected IReadOnlyCollection`1<TEntity> GetEntitiesByAttributeName(string shortAttributeName, ConcurrentDictionary`2<string, TEntity[]> entitiesByAttributeName, Func`2<AnnotatedEntitiesSet, OneToListMap`2<string, TEntity>> getEntities);
    public IReadOnlyCollection`1<string> GetMembersByAttributeName(string shortAttributeName);
    public IReadOnlyCollection`1<FullTypeMemberName> GetFullTypeMemberNamesByAttributeName(string shortAttributeName);
    public IReadOnlyCollection`1<string> GetTypesByAttributeName(string shortAttributeName);
    private sealed virtual override object JetBrains.Application.changes.IChangeProvider.Execute(IChangeMap changeMap);
    [CompilerGeneratedAttribute]
private void <CollectAnnotationsFromMetadata>g__FillPossibleMemberNames|27_0(IMetadataTypeMember typeMember, IMetadataTypeInfo typeInfo, <>c__DisplayClass27_0& );
    [CompilerGeneratedAttribute]
private void <CollectAnnotationsFromMetadata>g__ProcessMember|27_1(IMetadataTypeMember typeMember, IMetadataTypeInfo typeInfo, string memberName, <>c__DisplayClass27_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Caches.AnnotatedEntities.FullTypeMemberName : object {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    public string TypeName { get; }
    public string MemberName { get; }
    public FullTypeMemberName(string typeName, string memberName);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_MemberName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Caches.AnnotatedEntities.FullTypeMemberNameComparer : object {
    public static FullTypeMemberNameComparer Instance;
    private static FullTypeMemberNameComparer();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(FullTypeMemberName x, FullTypeMemberName y);
    public sealed virtual int GetHashCode(FullTypeMemberName obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.Caches.AnnotatedEntities.FullTypeMemberNameMarshaller : object {
    public static FullTypeMemberNameMarshaller Instance;
    private static FullTypeMemberNameMarshaller();
    public sealed virtual void Marshal(UnsafeWriter writer, FullTypeMemberName value);
    public sealed virtual FullTypeMemberName Unmarshal(UnsafeReader reader);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.Caches.AnnotatedEntities.IAnnotatedEntitiesCacheProcessor {
    public abstract virtual void Process(IFile psiFile, HashSet`1<string> attributeNames, AnnotatedEntitiesSet annotatedEntitiesSet);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Caches.AnnotatedMembersEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IReadOnlyCollection`1<string> GetMembersByAttributeName(ISolution solution, string shortAttributeName);
    [ExtensionAttribute]
[NotNullAttribute]
public static IReadOnlyCollection`1<FullTypeMemberName> GetFullTypeMembersByAttributeName(ISolution solution, string shortAttributeName);
    [ExtensionAttribute]
[NotNullAttribute]
public static IReadOnlyCollection`1<string> GetTypesByAttributeName(ISolution solution, string shortAttributeName);
    [NotNullAttribute]
private static IReadOnlyCollection`1<TEntity> GetEntitiesByAttributeName(ISolution solution, string shortAttributeName, Func`3<AssemblyAnnotatedEntitiesCache, string, IReadOnlyCollection`1<TEntity>> getFromAssemblyAnnotatedEntitiesCache, Func`3<AnnotatedEntitiesCache, string, HashSet`1<TEntity>> tryGetFromAnnotatedEntitiesCache);
    [ExtensionAttribute]
public static bool HasMemberWithAttribute(ISolution solution, string memberName, string shortAttributeName);
    [ExtensionAttribute]
public static bool HasMemberWithAttribute(IPsiServices psiServices, string memberName, string shortAttributeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PsiComponentAttribute("16")]
internal class JetBrains.ReSharper.Psi.Caches.AttributesCache : InvalidatingPsiCache {
    private Cache`2<ITypeElement, bool> myInheritedAttributesCache;
    private Cache`2<IClass, AttributeTargets> myAttributeTargetsCache;
    protected virtual void InvalidateOnPhysicalChange(PsiChangedElementType elementType);
    public sealed virtual bool IsInheritedAttribute(IAttributeInstance attributeInstance);
    public sealed virtual AttributeTargets GetAttributeTarget(IClass attributesClass);
    private static bool CalcIsInheritedAttribute(ITypeElement attrType);
    private static AttributeTargets CalcAttributeTarget(IClass attributeClass);
}
internal class JetBrains.ReSharper.Psi.Caches.CacheWorkItemSubprogress : object {
    private static double Epsilon;
    [NotNullAttribute]
private ObsoleteLifetimeAndDefinitionAtTheSameTime Disposables;
    [CanBeNullAttribute]
private ReadonlyToken myCacheNotifierOwnershipCookie;
    private Property`1<double> myDone;
    private bool myIsEnabled;
    private SpinWaitLock myLock;
    private double myRangeLength;
    private double myRangeStart;
    [NotNullAttribute]
private Thread myThread;
    private TaskThreadAffinity myThreadAffinity;
    [NotNullAttribute]
private Property`1<int> myTotal;
    [CompilerGeneratedAttribute]
private bool <IsStarted>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<bool> <FIsCanceled>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiCacheNotifier <Notifier>k__BackingField;
    public bool IsStarted { get; private set; }
    [NotNullAttribute]
internal Func`1<bool> FIsCanceled { get; }
    [NotNullAttribute]
internal PsiCacheNotifier Notifier { get; }
    public string CurrentItemText { get; public set; }
    public bool IsCanceled { get; }
    public string TaskName { get; public set; }
    public CacheWorkItemSubprogress(PsiCacheNotifier notifier, ReadonlyToken theCacheNotifierOwnershipCookie, Func`1<bool> FIsCanceled, TaskThreadAffinity threadaffinity);
    private static CacheWorkItemSubprogress();
    [CompilerGeneratedAttribute]
public bool get_IsStarted();
    [CompilerGeneratedAttribute]
private void set_IsStarted(bool value);
    [NotNullAttribute]
public IDisposable Enable(double rangestart, double rangelength, string sJobIdentity);
    [CompilerGeneratedAttribute]
internal Func`1<bool> get_FIsCanceled();
    [CompilerGeneratedAttribute]
internal PsiCacheNotifier get_Notifier();
    private void AssertApartmentThreadedCall();
    private void AssertFreeThreadedCall();
    public sealed virtual void Advance(double units);
    public sealed virtual void Dispose();
    public sealed virtual void Start(int totalWorkUnits);
    public sealed virtual void Stop();
    public sealed virtual string get_CurrentItemText();
    public sealed virtual void set_CurrentItemText(string value);
    public sealed virtual bool get_IsCanceled();
    public sealed virtual string get_TaskName();
    public sealed virtual void set_TaskName(string value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__11_0();
    [CompilerGeneratedAttribute]
private double <.ctor>b__11_2(double value);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.Caches.IAssemblyCache {
    public abstract virtual object Build(IPsiAssembly assembly);
    public abstract virtual void Merge(IPsiAssembly assembly, object part, Func`1<bool> checkForTermination);
    public abstract virtual void Drop(IEnumerable`1<IPsiAssembly> assemblies);
}
public interface JetBrains.ReSharper.Psi.Caches.IAttributesCache {
    [PureAttribute]
public abstract virtual bool IsInheritedAttribute(IAttributeInstance attributeInstance);
    [PureAttribute]
public abstract virtual AttributeTargets GetAttributeTarget(IClass attributesClass);
}
public interface JetBrains.ReSharper.Psi.Caches.IBackgroundCache {
    public ICollection`1<IPsiSourceFile> DirtyFiles { get; }
    public abstract virtual ICollection`1<IPsiSourceFile> get_DirtyFiles();
}
public interface JetBrains.ReSharper.Psi.Caches.ICache {
    [CanBeNullAttribute]
public abstract virtual object Load(IProgressIndicator progress, bool enablePersistence);
    public abstract virtual void MergeLoaded(object data);
    public abstract virtual void Save(IProgressIndicator progress, bool enablePersistence);
}
public interface JetBrains.ReSharper.Psi.Caches.ICacheAwaiter {
    public abstract virtual bool WaitForCaches(string reason);
}
public interface JetBrains.ReSharper.Psi.Caches.ICacheWithVersion {
    [NotNullAttribute]
public string PersistentId { get; }
    [NotNullAttribute]
public string Version { get; }
    public bool ClearOnLoad { get; public set; }
    public abstract virtual string get_PersistentId();
    public abstract virtual string get_Version();
    public abstract virtual bool get_ClearOnLoad();
    public abstract virtual void set_ClearOnLoad(bool value);
}
public interface JetBrains.ReSharper.Psi.Caches.ILibraryMemberNamesAccess {
    [NotNullAttribute]
public abstract virtual IEnumerable`1<string> GetAllMemberNames();
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IEnumerable`1<ITypeElement> GetTypesWithMember(string name);
    public abstract virtual int GetMembersCount();
}
public interface JetBrains.ReSharper.Psi.Caches.IMetadataTokenOwner {
    [NotNullAttribute]
public IPsiAssemblyFile PsiAssemblyFile { get; }
    public UInt32 Token { get; }
    public UInt32 ModuleToken { get; }
    public abstract virtual IPsiAssemblyFile get_PsiAssemblyFile();
    public abstract virtual UInt32 get_Token();
    public abstract virtual UInt32 get_ModuleToken();
}
[CounterUsagesCollectorAttribute("16")]
public class JetBrains.ReSharper.Psi.Caches.IndexingPerformanceCollector : CounterUsagesCollector {
    private EventLogGroup myGroup;
    private LongEventField myIdField;
    private EnumEventField`1<UpdateProjectFilesJobSource> mySourceField;
    private EventId2`2<long, UpdateProjectFilesJobSource> myUpdatePfStarted;
    private VarargEventId myUpdatePfFinished;
    private LongEventField myTotalWallField;
    private LongEventField myUpdateTimeField;
    private LongEventField myPsiTimeField;
    private LongEventField myMergeTimeField;
    private IntEventField myPsiItemsField;
    private IntEventField myMergeItemsField;
    private BooleanEventField myIsTerminatedField;
    public IndexingPerformanceCollector(FeatureUsageLogger featureUsageLogger);
    public virtual EventLogGroup GetGroup();
    public void RegisterProjectFilesStarted(ISolution solution, long id, UpdateProjectFilesJobSource source);
    public void RegisterProjectFilesFinished(ISolution solution, long id, UpdateProjectFilesJobSource source, long totalWallMs, long updateCpuMs, long psiCpuMs, int psiItemsCount, long mergeCpuMs, int mergeItems, bool isTerminated);
}
public class JetBrains.ReSharper.Psi.Caches.InvalidateCacheChange : object {
    [CompilerGeneratedAttribute]
private ICache <Cache>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IPsiSourceFile> <AffectedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DropPsiFiles>k__BackingField;
    [NotNullAttribute]
public ICache Cache { get; }
    [NotNullAttribute]
public IReadOnlyCollection`1<IPsiSourceFile> AffectedFiles { get; }
    public bool DropPsiFiles { get; }
    public InvalidateCacheChange(ICache cache, IReadOnlyCollection`1<IPsiSourceFile> affectedFiles, bool dropPsiFiles);
    [CompilerGeneratedAttribute]
public ICache get_Cache();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<IPsiSourceFile> get_AffectedFiles();
    [CompilerGeneratedAttribute]
public bool get_DropPsiFiles();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private static void AssertAllFilesAreValid(IReadOnlyCollection`1<IPsiSourceFile> affectedFiles);
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.Caches.InvalidatingPsiCache : object {
    public virtual void Invalidate(ITreeNode element, PsiChangedElementType elementType);
    protected virtual void InvalidateOnPhysicalChange(PsiChangedElementType elementType);
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.ReSharper.Psi.Caches.IPersistentIndexManager {
    [NotNullAttribute]
public ISolution Solution { get; }
    [NotNullAttribute]
public IUnsafeMarshaller`1<SourceFilePtr> SourceFilePtrMarshaller { get; }
    [NotNullAttribute]
public IUnsafeMarshaller`1<IPsiSourceFile> PsiSourceFileMarshaller { get; }
    [NotNullAttribute]
public IUnsafeMarshaller`1<IPsiModule> PsiModuleMarshaller { get; }
    [NotNullAttribute]
public IUnsafeMarshaller`1<PsiModulePtr> PsiModulePtrMarshaller { get; }
    [CanBeNullAttribute]
public IPsiSourceFile Item { get; }
    public OWORD Item { get; }
    [NotNullAttribute]
public IEqualityComparer`1<IPsiSourceFile> PsiSourceFilePersistentEqualityComparer { get; }
    [NotNullAttribute]
public IEqualityComparer`1<IPsiModule> PsiModulePersistentEqualityComparer { get; }
    public abstract virtual ISolution get_Solution();
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IPsiSourceFile> GetAllSourceFiles();
    public abstract virtual IUnsafeMarshaller`1<SourceFilePtr> get_SourceFilePtrMarshaller();
    public abstract virtual IUnsafeMarshaller`1<IPsiSourceFile> get_PsiSourceFileMarshaller();
    public abstract virtual IUnsafeMarshaller`1<IPsiModule> get_PsiModuleMarshaller();
    public abstract virtual IUnsafeMarshaller`1<PsiModulePtr> get_PsiModulePtrMarshaller();
    [CanBeNullAttribute]
public abstract virtual IPsiSourceFile get_Item(OWORD id);
    public abstract virtual OWORD get_Item(IPsiSourceFile id);
    public abstract virtual Nullable`1<long> GetPersistentTimestamp(IPsiSourceFile sf);
    public abstract virtual void OnCachesTimestampUpdated(IPsiSourceFile sourceFile, long timestamp, Nullable`1<long> textHashCode);
    [NotNullAttribute]
public abstract virtual IOptimizedPersistentSortedMap`2<IPsiSourceFile, TValue> GetPersistentMap(Lifetime lifetime, string uniqueId, IUnsafeMarshaller`1<TValue> valueMarshaller, Nullable`1<long> version);
    [NotNullAttribute]
public abstract virtual OptimizedPersistentSortedMap`2<TKey, TValue> GetPersistentMap(Lifetime lifetime, string uniqueId, IUnsafeMarshaller`1<TKey> keyMarshaller, IUnsafeMarshaller`1<TValue> valueMarshaller, IEqualityComparer`1<TKey> equalityComparer);
    [NotNullAttribute]
public abstract virtual OptimizedPersistentSortedMap`2<TKey, TValue> CreateTransientMap(Lifetime lifetime, IUnsafeMarshaller`1<TKey> keyMarshaller, IUnsafeMarshaller`1<TValue> valueMarshaller, IEqualityComparer`1<TKey> equalityComparer);
    public abstract virtual IEqualityComparer`1<IPsiSourceFile> get_PsiSourceFilePersistentEqualityComparer();
    public abstract virtual IEqualityComparer`1<IPsiModule> get_PsiModulePersistentEqualityComparer();
}
public interface JetBrains.ReSharper.Psi.Caches.IPsiAssemblyFile {
    public IPsiModule Module { get; }
    public DateTime Timestamp { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<CompiledTypeElement> Types { get; }
    [NotNullAttribute]
public ILibraryMemberNamesAccess MemberNamesAccess { get; }
    public AssemblyNameInfo[] ReferencedAssembliesNames { get; }
    [CanBeNullAttribute]
public AssemblyExternalAnnotations ExternalAnnotations { get; }
    public XmlDocIndex XmlDocIndex { get; }
    public abstract virtual IPsiModule get_Module();
    public abstract virtual DateTime get_Timestamp();
    public abstract virtual IEnumerable`1<CompiledTypeElement> get_Types();
    public abstract virtual ILibraryMemberNamesAccess get_MemberNamesAccess();
    public abstract virtual AssemblyNameInfo[] get_ReferencedAssembliesNames();
    public abstract virtual void LoadAllTypeMembers();
    public abstract virtual AssemblyExternalAnnotations get_ExternalAnnotations();
    [NotNullAttribute]
public abstract virtual IAttributesSet CreateAssemblyAttributes();
    public abstract virtual XmlDocIndex get_XmlDocIndex();
}
public interface JetBrains.ReSharper.Psi.Caches.IPsiCache {
    public abstract virtual void Invalidate(ITreeNode element, PsiChangedElementType elementType);
}
public interface JetBrains.ReSharper.Psi.Caches.IPsiCacheRegistry {
    public ViewableCollection`1<IPsiSourceFileCache> ActivePsiSourceFileCaches { get; }
    public ViewableCollection`1<IAssemblyCache> ActiveAssemblyCaches { get; }
    public ViewableCollection`1<ICache> ActiveCaches { get; }
    public ViewableCollection`1<IPsiSourceFileCache> ResolveCaches { get; }
    public ViewableCollection`1<IBackgroundCache> BackgroundCaches { get; }
    public IEnumerable`1<IPsiCache> InvalidatingPsiCaches { get; }
    public abstract virtual ViewableCollection`1<IPsiSourceFileCache> get_ActivePsiSourceFileCaches();
    public abstract virtual ViewableCollection`1<IAssemblyCache> get_ActiveAssemblyCaches();
    public abstract virtual ViewableCollection`1<ICache> get_ActiveCaches();
    public abstract virtual ViewableCollection`1<IPsiSourceFileCache> get_ResolveCaches();
    public abstract virtual ViewableCollection`1<IBackgroundCache> get_BackgroundCaches();
    public abstract virtual IEnumerable`1<IPsiCache> get_InvalidatingPsiCaches();
    public abstract virtual TPsiCache GetPsiCache();
}
public interface JetBrains.ReSharper.Psi.Caches.IPsiCaches {
    public bool HasDirtyFiles { get; }
    [NotNullAttribute]
public ISourceDeclaredElementsCache SourceDeclaredElementsCache { get; }
    public abstract virtual void EnqueueJob(Job job);
    public abstract virtual void EnqueueUpdateFiles(ICollection`1<IPsiSourceFile> projectFiles, ICollection`1<IPsiSourceFileCache> caches, bool forceSync, TaskPriority priority, Nullable`1<UpdateProjectFilesJobSource> source);
    public abstract virtual void EnqueueRemoveFiles(ICollection`1<IPsiSourceFile> projectFiles, ICollection`1<IPsiSourceFileCache> caches, bool forceSync, TaskPriority priority);
    public abstract virtual bool get_HasDirtyFiles();
    public abstract virtual bool WaitForCaches(string callerName, string cancelButtonContent);
    public abstract virtual ISourceDeclaredElementsCache get_SourceDeclaredElementsCache();
    public abstract virtual void Update();
    public abstract virtual void MarkAsDirty(IPsiSourceFile sourceFile);
    public abstract virtual TPsiCache GetPsiCache();
    public abstract virtual void SandBoxCreated(SandBox sandBox);
    public abstract virtual void WithSyncUpdateFiltered(IPsiSourceFile sourceFile, Action action);
}
public interface JetBrains.ReSharper.Psi.Caches.IPsiCachesState {
    public IProperty`1<bool> IsFileUpdateStarted { get; }
    public IProperty`1<bool> IsInitialUpdateFinished { get; }
    public IProperty`1<bool> IsIdle { get; }
    public IProperty`1<bool> IsPrimaryIdle { get; }
    public IProperty`1<bool> IsLoadEnqueued { get; }
    public IProperty`1<IPsiSourceFile> SyncUpdateFilter { get; }
    public bool CachesColdProcessingFinished { get; }
    public abstract virtual IProperty`1<bool> get_IsFileUpdateStarted();
    public abstract virtual IProperty`1<bool> get_IsInitialUpdateFinished();
    public abstract virtual IProperty`1<bool> get_IsIdle();
    public abstract virtual IProperty`1<bool> get_IsPrimaryIdle();
    public abstract virtual IProperty`1<bool> get_IsLoadEnqueued();
    public abstract virtual IProperty`1<IPsiSourceFile> get_SyncUpdateFilter();
    public abstract virtual bool get_CachesColdProcessingFinished();
}
public interface JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache {
    public bool HasDirtyFiles { get; }
    public abstract virtual void MarkAsDirty(IPsiSourceFile sourceFile);
    public abstract virtual bool get_HasDirtyFiles();
    public abstract virtual bool UpToDate(IPsiSourceFile sourceFile);
    [CanBeNullAttribute]
public abstract virtual object Build(IPsiSourceFile sourceFile, bool isStartup);
    public abstract virtual void Merge(IPsiSourceFile sourceFile, object builtPart);
    public abstract virtual void Drop(IPsiSourceFile sourceFile);
    public abstract virtual void OnPsiChange(ITreeNode elementContainingChanges, PsiChangedElementType type);
    public abstract virtual void OnDocumentChange(IPsiSourceFile sourceFile, ProjectFileDocumentCopyChange change);
    public abstract virtual void SyncUpdate(bool underTransaction);
    public abstract virtual void Dump(TextWriter writer, IPsiSourceFile sourceFile);
}
public interface JetBrains.ReSharper.Psi.Caches.IPsiSourceFileInvalidatingCache {
    public abstract virtual void Invalidate(IEnumerable`1<IPsiSourceFile> sourceFiles);
}
public interface JetBrains.ReSharper.Psi.Caches.IRarelyChangedTreeCachedData {
}
public interface JetBrains.ReSharper.Psi.Caches.ISandBoxCache {
    public abstract virtual void OnSandBoxCreated(SandBox sandBox);
    public abstract virtual void OnSandBoxPsiChange(ITreeNode elementContainingChanges);
}
public interface JetBrains.ReSharper.Psi.Caches.ISourceDeclaredElementsCache {
    [CanBeNullAttribute]
public abstract virtual IDeclaredElement GetOrCreateDeclaredElement(TDeclaration declaration, Func`2<TDeclaration, IDeclaredElement> factory);
}
public interface JetBrains.ReSharper.Psi.Caches.ISwitchingCache {
    public IProperty`1<bool> Active { get; }
    public abstract virtual IProperty`1<bool> get_Active();
    public abstract virtual void Initialize();
    public abstract virtual void Release();
}
[PublicAPIAttribute]
public interface JetBrains.ReSharper.Psi.Caches.ISymbolCache {
    public PartsMap Parts { get; }
    [NotNullAttribute]
public DataIntern`1<string> StringIntern { get; }
    public abstract virtual PartsMap get_Parts();
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IAssemblyPsiModule> GetForwardedToAssemblies(AssemblyNameInfo fromAssemblyName, IClrTypeName clrName);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IAssemblyPsiModule> GetForwardedToAssemblies(AssemblyNameInfo fromAssemblyName);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IAssemblyPsiModule> GetForwardedFromAssemblies(ITypeElement typeElement);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IAssemblyPsiModule> GetForwardedFromAssemblies(INamespace ns);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IAssemblyPsiModule> GetAssembliesWithForwardedNamespace(IPsiModule originModule, INamespace ns);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IClrTypeName> GetForwardedTypes(AssemblyNameInfo fromAssemblyName);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<AssemblyNameInfo> GetForwardedFromAssemblyNames(AssemblyNameInfo assemblyNameInfo, IClrTypeName clrTypeName);
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IEnumerable`1<IDeclaredElement> GetTypesAndNamespacesInFile(IPsiSourceFile sourceFile);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnAfterTypePartAdded(Action`1<TypePart> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnAfterTypePartAdded(Action`1<TypePart> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnBeforeTypePartRemoved(Action`1<TypePart> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnBeforeTypePartRemoved(Action`1<TypePart> value);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISymbolScope GetSymbolScope(LibrarySymbolScope librarySymbolScope, bool caseSensitive);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISymbolScope GetSymbolScope(IPsiModule module, bool withReferences, bool caseSensitive);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISymbolScope GetAlternativeNamesSymbolScope(LibrarySymbolScope librarySymbolScope);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISymbolScope GetAlternativeNamesSymbolScope(IPsiModule module, bool withReferences);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IAttributesSet GetModuleAttributes(IPsiModule module);
    [CanBeNullAttribute]
public abstract virtual IPsiAssemblyFile GetLibraryFile(IPsiAssembly assembly);
    [NotNullAttribute]
public abstract virtual IReadOnlyCollection`1<ITypeElement> GetPossibleInheritors(string shortName);
    public abstract virtual DataIntern`1<string> get_StringIntern();
    public abstract virtual AssemblyNameInfo AdjustReferencedAssemblyName(IModuleReferenceResolveContext resolveContext, AssemblyNameInfo assemblyNameInfo);
}
public interface JetBrains.ReSharper.Psi.Caches.ISymbolScope {
    [NotNullAttribute]
public INamespace GlobalNamespace { get; }
    public abstract virtual INamespace get_GlobalNamespace();
    [CanBeNullAttribute]
public abstract virtual INamespace GetNamespace(string fullyQualifiedName);
    [NotNullAttribute]
public abstract virtual ITypeElement[] GetTypeElementsByCLRName(string clrName);
    [NotNullAttribute]
public abstract virtual ITypeElement[] GetTypeElementsByCLRName(IClrTypeName clrName);
    [CanBeNullAttribute]
public abstract virtual ITypeElement GetTypeElementByCLRName(string clrName);
    [CanBeNullAttribute]
public abstract virtual ITypeElement GetTypeElementByCLRName(IClrTypeName clrName);
    [PureAttribute]
public abstract virtual bool Contains(ITypeElement typeElement);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICollection`1<IClrDeclaredElement> GetElementsByQualifiedName(string qualifiedName);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IEnumerable`1<IClrDeclaredElement> GetElementsAtQualifiedName(string qualifiedName);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IEnumerable`1<string> GetAllShortNamesSorted();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IEnumerable`1<string> GetAllShortNames();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IClrDeclaredElement[] GetElementsByShortName(string shortName);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICollection`1<ITypeElement> GetPossibleInheritors(string shortTypeName);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<string> GetAllTypeMemberNames();
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IEnumerable`1<ITypeElement> GetAllTypeElementsGroupedByName();
    [NotNullAttribute]
public abstract virtual IEnumerable`1<ITypeMember> GetSourceMembers(string name, Func`2<ITypeElement, bool> containingTypesFilter);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<ITypeMember> GetSourceMembers(string name);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<ITypeMember> GetCompiledMembers(string name);
    public abstract virtual bool Accepts(CacheTrieNode trieNode, ITypeElement typeElement);
}
public interface JetBrains.ReSharper.Psi.Caches.IWordIndex {
    [ObsoleteAttribute("Use 'GetFilesContainingAllSubwords(string query)'")]
public abstract virtual ICollection`1<IPsiSourceFile> GetFilesContainingWord(string word);
    [ObsoleteAttribute("Use 'GetFilesContainingAnySubword(IEnumerable<string> queries)'")]
public abstract virtual ICollection`1<IPsiSourceFile> GetFilesContainingWords(IEnumerable`1<string> words);
    [ObsoleteAttribute("Use 'CanContainAllSubwords(IPsiSourceFile sourceFile, string text)'")]
public abstract virtual bool CanContainWord(IPsiSourceFile sourceFile, string word);
    [ObsoleteAttribute("Use 'GetSubwords(string text)'")]
public abstract virtual IEnumerable`1<string> GetWords(string text);
    [ObsoleteAttribute("Use 'GetSubwordsFromFileName(VirtualFileSystemPath path)'")]
public abstract virtual IEnumerable`1<string> GetWordsFromFileName(VirtualFileSystemPath path);
    [NotNullAttribute]
public abstract virtual ICollection`1<IPsiSourceFile> GetFilesContainingAllSubwords(string query);
    [NotNullAttribute]
public abstract virtual ICollection`1<IPsiSourceFile> GetFilesContainingAnySubword(IEnumerable`1<string> queries);
    public abstract virtual bool CanContainAllSubwords(IPsiSourceFile sourceFile, string text);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<string> GetSubwords(string text);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<string> GetSubwordsFromFileName(VirtualFileSystemPath path);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IPsiSourceFile> GetFilesContainingAllWords(IEnumerable`1<string> queries);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IPsiSourceFile> GetFilesContainingAnyWords(IEnumerable`1<string> queries);
}
public abstract class JetBrains.ReSharper.Psi.Caches.Job : object {
    [CompilerGeneratedAttribute]
private bool <Done>k__BackingField;
    public static double ContinueProgressMarker;
    [CompilerGeneratedAttribute]
private double <ContinueProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<bool> <TerminationCondition>k__BackingField;
    [NotNullAttribute]
public string Description { get; }
    internal bool Done { get; internal set; }
    [NotNullAttribute]
public string GroupId { get; }
    [NotNullAttribute]
public string DebugComment { get; }
    public double ContinueProgress { get; public set; }
    [CanBeNullAttribute]
public Func`1<bool> TerminationCondition { get; public set; }
    public abstract virtual string get_Description();
    [CompilerGeneratedAttribute]
internal bool get_Done();
    [CompilerGeneratedAttribute]
internal void set_Done(bool value);
    public abstract virtual string get_GroupId();
    public virtual string get_DebugComment();
    public void AssertValid();
    public abstract virtual void Do(IProgressIndicator progress, bool sync, Func`1<bool> checkForTermination);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public double get_ContinueProgress();
    [CompilerGeneratedAttribute]
public void set_ContinueProgress(double value);
    [CompilerGeneratedAttribute]
public Func`1<bool> get_TerminationCondition();
    [CompilerGeneratedAttribute]
public void set_TerminationCondition(Func`1<bool> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Caches.Jobs.CacheJobService2 : CacheLogger {
    private static int MAX_CONCURRENT_DOCUMENTS_SIZE;
    private Lifetime myLifetime;
    private IShellLocks myLocks;
    private SingleThreadExecutor myJobExecutor;
    private PsiCacheNotifier myNotifier;
    private ProjectModelUpdateStates myProjectModelUpdateStates;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentQueue`1<Pair`2<Action, TaskPriority>> myDelayedTasks;
    private ReadonlyToken myOwnershipCookie;
    private double myCurrentJobProgressStart;
    private double myCurrentJobProgressLength;
    private IProperty`1<bool> myForceSync;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <IsIdle>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <IsPrimaryIdle>k__BackingField;
    private int myPrimaryJobsInQueueCounter;
    private object mySentry;
    [CompilerGeneratedAttribute]
private Func`1<bool> <CommonTerminationCondition>k__BackingField;
    [ThreadStaticAttribute]
private static bool ourIsCacheFiber;
    public IProperty`1<bool> IsIdle { get; }
    public IProperty`1<bool> IsPrimaryIdle { get; }
    public Func`1<bool> CommonTerminationCondition { get; }
    public bool IsCacheThread { get; }
    public CacheJobService2(Lifetime lifetime, SolutionManagerBase solutionManager, IShellLocks locks, PsiCacheNotifier notifier, ProjectModelUpdateStates projectModelUpdateStates);
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_IsIdle();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_IsPrimaryIdle();
    [CompilerGeneratedAttribute]
public Func`1<bool> get_CommonTerminationCondition();
    public bool get_IsCacheThread();
    public void EnqueueJob(TaskPriority priority, Job job, bool sync);
    public void EnqueueJobWithoutProgress(TaskPriority priority, Job job, bool sync);
    private void EnqueueJobImpl(TaskPriority priority, Job job, bool sync, bool setupProgress);
    public void ExecuteWithProgress(Job job, Action`1<IProgressIndicator> action);
    private void DoJobWithLogging(Job job, IProgressIndicator progress, bool sync);
    private void SetupProgress(Job job);
    private void CleanProgress();
    public void ExecuteWithPrerocessAndInterrupt(IList`1<T> items, bool synchronous, Func`2<T, ValueTuple`2<TPreprocessResult, int>> preprocess, Action`2<T, TPreprocessResult> process);
    public void ExecuteMulticoreWithInterrupt(IEnumerable`1<T> items, bool synchronous, Action`1<T> action);
    private static Action WrappedJob(Action`2<T1, T2> action, T1 item1, T2 item2);
    private Action WrappedJob(Action`1<T> action, T item);
    public void ExecuteMultiCore(IEnumerable`1<T> items, bool synchronous, Action`1<T> action);
    public Task ExecuteWriteActivity(InterruptionSet checkForInterrupt, Action mainThreadActivity);
    public Task ExecuteSplittedWriteActivity(Func`1<bool> checkForInterrupt, IEnumerable`1<T> keys, Action`1<T> mainThreadActivityProducer);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__23_0();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__23_3(Task _);
    [CompilerGeneratedAttribute]
private void <.ctor>b__23_1(Lifetime _);
    [CompilerGeneratedAttribute]
private void <.ctor>b__23_2(Lifetime lf);
}
public interface JetBrains.ReSharper.Psi.Caches.Jobs.IBackgroundJob {
}
public interface JetBrains.ReSharper.Psi.Caches.Jobs.ICanBeExecutedInHardUpdateState {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.Caches.Jobs.JobAddAssemblies : Job {
    private CacheJobService2 myJobService;
    private ICollection`1<IPsiAssembly> myAssemblies;
    private IShellLocks myShellLocks;
    private ICollection`1<IAssemblyCache> myCaches;
    public string GroupId { get; }
    public string Description { get; }
    public string DebugComment { get; }
    public JobAddAssemblies(CacheJobService2 thread, ICollection`1<IPsiAssembly> assemblies, IShellLocks shellLocks, ICollection`1<IAssemblyCache> caches);
    public virtual string get_GroupId();
    public virtual string get_Description();
    public virtual string get_DebugComment();
    public virtual void Do(IProgressIndicator progress, bool sync, Func`1<bool> checkForTermination);
    private IReadOnlyList`1<ValueTuple`2<IAssemblyCache, object>> Build(IPsiAssembly assembly);
    private static void Merge(IPsiAssembly assembly, IReadOnlyList`1<ValueTuple`2<IAssemblyCache, object>> builtPart, Func`1<bool> checkForTermination);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.Caches.Jobs.JobLoadCache : Job {
    private CacheJobService2 myJobService;
    private ICache[] myCaches;
    private bool myEnablePersistence;
    public string GroupId { get; }
    public string Description { get; }
    public string DebugComment { get; }
    public JobLoadCache(CacheJobService2 jobService, ICollection`1<ICache> caches, bool enablePersistence);
    public virtual string get_GroupId();
    public virtual string get_Description();
    public virtual string get_DebugComment();
    public virtual void Do(IProgressIndicator progress, bool sync, Func`1<bool> checkForTermination);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.Caches.Jobs.JobRemoveAssembly : Job {
    private ICollection`1<IPsiAssembly> myAssemblies;
    private ICollection`1<IAssemblyCache> myCaches;
    private CacheJobService2 myCacheJobService;
    public string DebugComment { get; }
    public string GroupId { get; }
    public string Description { get; }
    public JobRemoveAssembly(ICollection`1<IPsiAssembly> assemblies, ICollection`1<IAssemblyCache> caches, CacheJobService2 cacheJobService);
    public virtual string get_DebugComment();
    public virtual string get_GroupId();
    public virtual string get_Description();
    public virtual void Do(IProgressIndicator progress, bool sync, Func`1<bool> checkForTermination);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.Caches.Jobs.JobRemoveProjectFiles : Job {
    private List`1<IPsiSourceFile> mySourceFiles;
    private ICollection`1<IPsiSourceFileCache> myCaches;
    private PersistentIndexManager myPersistentIndexManager;
    private CacheJobService2 myCacheJobService;
    public string GroupId { get; }
    public string Description { get; }
    public string DebugComment { get; }
    public JobRemoveProjectFiles(IEnumerable`1<IPsiSourceFile> projectFiles, ICollection`1<IPsiSourceFileCache> caches, PersistentIndexManager persistentIndexManager, CacheJobService2 cacheJobService);
    public virtual string get_GroupId();
    public virtual string get_Description();
    public virtual string get_DebugComment();
    public virtual void Do(IProgressIndicator progress, bool sync, Func`1<bool> checkForTermination);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <Do>b__11_0(IPsiSourceFile sourceFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.Caches.Jobs.JobSaveCaches : Job {
    private Action myAfterSaveCallback;
    private ICache[] myCaches;
    private bool myEnablePersistence;
    private CacheJobService2 myJobService;
    private IShellLocks myShellLocks;
    public string GroupId { get; }
    public string Description { get; }
    public string DebugComment { get; }
    public JobSaveCaches(CacheJobService2 jobService, ICollection`1<ICache> caches, Action onAfterSave, IShellLocks shellLocks, bool enablePersistence);
    public virtual string get_GroupId();
    public virtual string get_Description();
    public virtual string get_DebugComment();
    public virtual void Do(IProgressIndicator progress, bool sync, Func`1<bool> checkForTermination);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.Caches.Jobs.JobUpdateAllProjectFiles : JobUpdateProjectFiles {
    private CacheJobService2 myJobService;
    private IPsiModules myPsiModules;
    private IShellLocks myShellLocks;
    private Func`2<IPsiSourceFile, bool> myCachesParticipantFilter;
    public JobUpdateAllProjectFiles(IPsiCachesState cachesState, CacheJobService2 jobService, IPsiModules psiModules, ICollection`1<IPsiSourceFileCache> caches, IShellLocks shellLocks, PersistentIndexManager persistentIndexManager, IPsiFiles psiFiles, Func`2<IPsiSourceFile, bool> cachesParticipantFilter, UpdateProjectFilesStatistics statistics);
    private List`1<IPsiSourceFile> EnumerateAllFiles(IProgressIndicator progress, Func`1<bool> checkForTermination, bool synchronous);
    private bool ProcessModule(IPsiModule module, List`1<IPsiSourceFile> res, Int32& totalFilesCount);
    public virtual void Do(IProgressIndicator progress, bool sync, Func`1<bool> checkForTermination);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.Caches.Jobs.JobUpdateProjectFiles : Job {
    private static int MaxPartsSize;
    internal IPsiCachesState CachesState;
    private CacheJobService2 myJobService;
    protected ICollection`1<IPsiSourceFileCache> Caches;
    private IPsiFiles myPsiFiles;
    private IShellLocks myShellLocks;
    internal PersistentIndexManager PersistentIndexManager;
    protected bool IsForegroundJob;
    private UpdateProjectFilesStatistics myStatistics;
    [CompilerGeneratedAttribute]
private string <GroupId>k__BackingField;
    public string GroupId { get; }
    public string Description { get; }
    protected JobUpdateProjectFiles(IPsiCachesState cachesState, CacheJobService2 jobService, ICollection`1<IPsiSourceFileCache> caches, IShellLocks shellLocks, PersistentIndexManager persistentIndexManager, IPsiFiles psiFiles, bool isForegroundJob, UpdateProjectFilesStatistics statistics);
    [CompilerGeneratedAttribute]
public virtual string get_GroupId();
    public virtual string get_Description();
    protected void ExecuteUpdate(IProgressIndicator progress, bool sync, Func`1<bool> terminated, List`1<IPsiSourceFile> filesToRescan);
    private Nullable`1<ValueTuple`3<long, Nullable`1<long>, IList`1<Pair`2<IPsiSourceFileCache, object>>>> BuildSourceFile(IPsiSourceFile sourceFile);
    private bool MergeProjectFile(IPsiSourceFile sourceFile, long timestamp, Nullable`1<long> contentHash, IList`1<Pair`2<IPsiSourceFileCache, object>> part);
    private bool IsActiveCache(ICache cache);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Caches.Jobs.JobUpdateProjectFilesList : JobUpdateProjectFiles {
    private List`1<IPsiSourceFile> myProjectFiles;
    public string DebugComment { get; }
    public JobUpdateProjectFilesList(IPsiCachesState cachesState, CacheJobService2 jobService, ICollection`1<IPsiSourceFile> projectFiles, ICollection`1<IPsiSourceFileCache> caches, IShellLocks shellLocks, PersistentIndexManager persistentIndexManager, IPsiFiles psiFiles, bool isForegroundJob, UpdateProjectFilesStatistics updateProjectFilesStatistics);
    public virtual string get_DebugComment();
    public virtual void Do(IProgressIndicator progress, bool sync, Func`1<bool> checkForTermination);
}
public enum JetBrains.ReSharper.Psi.Caches.LibrarySymbolScope : Enum {
    public int value__;
    public static LibrarySymbolScope NONE;
    public static LibrarySymbolScope REFERENCED;
    public static LibrarySymbolScope TRANSITIVE;
    public static LibrarySymbolScope FULL;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Caches.Persistence.ContentKey : ValueType {
    private OWORD myPersistentFileIndex;
    private long myContentHash;
    internal long ContentHash { get; }
    internal OWORD PersistentFileIndex { get; }
    private ContentKey(OWORD persistentFileIndex, long contentHash);
    public IPsiSourceFile GetPsiSourceFile(IPersistentIndexManager persistentIndexManager);
    internal long get_ContentHash();
    internal OWORD get_PersistentFileIndex();
    public static ContentKey FromPsiSourceFile(IPsiSourceFile sourceFile);
    public static ContentKey FromPsiSourceFileAndContentHash(IPsiSourceFile sourceFile, long contentHash);
    public virtual int GetHashCode();
    public static void Marshal(UnsafeWriter writer, ContentKey value);
    public static void Marshal(UnsafeWriter writer, ContentKey value, long version);
    public static ContentKey Unmarshal(UnsafeReader reader);
    public static ContentKey Unmarshal(UnsafeReader reader, long version);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ContentKey left, ContentKey right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ContentKey left, ContentKey right);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ContentKey other);
}
[NullableContextAttribute("1")]
internal interface JetBrains.ReSharper.Psi.Caches.Persistence.ISourceFilePersistentMap {
    public abstract virtual void Init(IDictionary`2<IPsiSourceFile, long> initialHashes);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.Caches.Persistence.ITransientSourceFilesProvider {
    public Signal`1<IPsiSourceFile> Added { get; }
    public Signal`1<IPsiSourceFile> Removed { get; }
    public abstract virtual Signal`1<IPsiSourceFile> get_Added();
    public abstract virtual Signal`1<IPsiSourceFile> get_Removed();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Caches.Persistence.PersistentIndexManager : object {
    private bool myProjectModelLoaded;
    private ILogger myLogger;
    private SolutionCaches mySolutionCaches;
    private PsiModules myPsiModules;
    private IKeyValueDb myPersistentCachesDb;
    private OptimizedPersistentSortedMap`2<IPsiSourceFile, long> myCachesTimestamp;
    private OptimizedPersistentSortedMap`2<IPsiSourceFile, long> myTextHashes;
    [CompilerGeneratedAttribute]
private IUnsafeMarshaller`1<SourceFilePtr> <SourceFilePtrMarshaller>k__BackingField;
    [CompilerGeneratedAttribute]
private IUnsafeMarshaller`1<IPsiSourceFile> <PsiSourceFileMarshaller>k__BackingField;
    [CompilerGeneratedAttribute]
private IUnsafeMarshaller`1<ContentKey> <ContentKeyMarshaller>k__BackingField;
    [CompilerGeneratedAttribute]
private IUnsafeMarshaller`1<IPsiModule> <PsiModuleMarshaller>k__BackingField;
    [CompilerGeneratedAttribute]
private IUnsafeMarshaller`1<PsiModulePtr> <PsiModulePtrMarshaller>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<OWORD, IPsiSourceFile> myIndexToFileMap;
    private static string TransientMapPrefix;
    private static UniversalMarshaller`1<OWORD> ourOwordMarshaller;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    public IUnsafeMarshaller`1<SourceFilePtr> SourceFilePtrMarshaller { get; }
    public IUnsafeMarshaller`1<IPsiSourceFile> PsiSourceFileMarshaller { get; }
    public IUnsafeMarshaller`1<ContentKey> ContentKeyMarshaller { get; }
    public IUnsafeMarshaller`1<IPsiModule> PsiModuleMarshaller { get; }
    public IUnsafeMarshaller`1<PsiModulePtr> PsiModulePtrMarshaller { get; }
    private string MaxClearedTransientMapKey { get; }
    private string LastTransientMapKey { get; }
    public IEqualityComparer`1<IPsiSourceFile> PsiSourceFilePersistentEqualityComparer { get; }
    public IEqualityComparer`1<IPsiModule> PsiModulePersistentEqualityComparer { get; }
    public ISolution Solution { get; }
    [NullableAttribute("2")]
private IPsiSourceFile JetBrains.ReSharper.Psi.Caches.IPersistentIndexManager.Item { get; }
    private OWORD JetBrains.ReSharper.Psi.Caches.IPersistentIndexManager.Item { get; }
    public PersistentIndexManager(ILogger logger, Lifetime lifetime, ISolution solution, SolutionCaches solutionCaches, IPsiConfiguration psiConfiguration, PsiModules psiModules, ChangeManager changeManager, ISolutionLoadTasksScheduler loadTasksScheduler, IEnumerable`1<ITransientSourceFilesProvider> transientSourceFilesProvider);
    private static PersistentIndexManager();
    [CompilerGeneratedAttribute]
public sealed virtual IUnsafeMarshaller`1<SourceFilePtr> get_SourceFilePtrMarshaller();
    [CompilerGeneratedAttribute]
public sealed virtual IUnsafeMarshaller`1<IPsiSourceFile> get_PsiSourceFileMarshaller();
    [CompilerGeneratedAttribute]
public IUnsafeMarshaller`1<ContentKey> get_ContentKeyMarshaller();
    [CompilerGeneratedAttribute]
public sealed virtual IUnsafeMarshaller`1<IPsiModule> get_PsiModuleMarshaller();
    [CompilerGeneratedAttribute]
public sealed virtual IUnsafeMarshaller`1<PsiModulePtr> get_PsiModulePtrMarshaller();
    private string get_MaxClearedTransientMapKey();
    private string get_LastTransientMapKey();
    private string TransientMapId(int index);
    private int GetPersistentProperty(string key);
    private void SetPersistentProperty(string key, int value);
    public sealed virtual IEqualityComparer`1<IPsiSourceFile> get_PsiSourceFilePersistentEqualityComparer();
    public sealed virtual IEqualityComparer`1<IPsiModule> get_PsiModulePersistentEqualityComparer();
    public sealed virtual object Execute(IChangeMap changeMap);
    private void LoadProjectModel();
    public void SynchronizeTimeStampAndContentHash(IPsiSourceFile sourceFile);
    private void OnAdded(IPsiSourceFile sourceFile);
    private bool IsBadFile(IPsiSourceFile sourceFile, string methodName);
    public sealed virtual void OnCachesTimestampUpdated(IPsiSourceFile sourceFile, long timestamp, Nullable`1<long> textHashCode);
    public void OnRemoved(IPsiSourceFile sourceFile);
    public sealed virtual IOptimizedPersistentSortedMap`2<IPsiSourceFile, TValue> GetPersistentMap(Lifetime lifetime, string mapId, IUnsafeMarshaller`1<TValue> valueMarshaller, Nullable`1<long> version);
    public sealed virtual OptimizedPersistentSortedMap`2<TKey, TValue> GetPersistentMap(Lifetime lifetime, string mapId, IUnsafeMarshaller`1<TKey> keyMarshaller, IUnsafeMarshaller`1<TValue> valueMarshaller, IEqualityComparer`1<TKey> equalityComparer);
    public sealed virtual OptimizedPersistentSortedMap`2<TKey, TValue> CreateTransientMap(Lifetime lifetime, IUnsafeMarshaller`1<TKey> keyMarshaller, IUnsafeMarshaller`1<TValue> valueMarshaller, IEqualityComparer`1<TKey> equalityComparer);
    [CompilerGeneratedAttribute]
public sealed virtual ISolution get_Solution();
    public sealed virtual IEnumerable`1<IPsiSourceFile> GetAllSourceFiles();
    internal OWORD GetIdBySourceFile(IPsiSourceFile sourceFile);
    [NullableContextAttribute("2")]
private IPsiSourceFile GetSourceFileById(OWORD index);
    [NullableContextAttribute("2")]
private sealed virtual override IPsiSourceFile JetBrains.ReSharper.Psi.Caches.IPersistentIndexManager.get_Item(OWORD index);
    private sealed virtual override OWORD JetBrains.ReSharper.Psi.Caches.IPersistentIndexManager.get_Item(IPsiSourceFile id);
    private sealed virtual override Nullable`1<long> JetBrains.ReSharper.Psi.Caches.IPersistentIndexManager.GetPersistentTimestamp(IPsiSourceFile file);
}
internal class JetBrains.ReSharper.Psi.Caches.Persistence.PsiModulePersistentEqualityComparer : object {
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IPsiModule x, IPsiModule y);
    [NullableContextAttribute("1")]
public sealed virtual int GetHashCode(IPsiModule m);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.Caches.Persistence.SourceFilePersistentEqualityComparer : object {
    private PersistentIndexManager myPersistentIndexManager;
    public SourceFilePersistentEqualityComparer(PersistentIndexManager persistentIndexManager);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IPsiSourceFile x, IPsiSourceFile y);
    public sealed virtual int GetHashCode(IPsiSourceFile sourceFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Caches.Persistence.SourceFilePersistentMap`1 : object {
    private OptimizedPersistentSortedMap`2<ContentKey, TValue> myMap;
    private PersistentIndexManager myPersistentIndexManager;
    private IDictionary`2<OWORD, long> myLastSavedHashes;
    [CompilerGeneratedAttribute]
private IDictionaryBasedCache`2<IPsiSourceFile, TValue> <Cache>k__BackingField;
    public IDictionaryBasedCache`2<IPsiSourceFile, TValue> Cache { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TValue Item { get; public set; }
    public ICollection`1<IPsiSourceFile> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public bool UseCachingEnumerator { get; public set; }
    public CachingStrategy CachingStrategy { get; public set; }
    internal SourceFilePersistentMap`1(Lifetime& lifetime, IPersistentSortedMap`2<ContentKey, TValue> map, PersistentIndexManager persistentIndexManager);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionaryBasedCache`2<IPsiSourceFile, TValue> get_Cache();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Cache(IDictionaryBasedCache`2<IPsiSourceFile, TValue> value);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.Persistence.ISourceFilePersistentMap.Init(IDictionary`2<IPsiSourceFile, long> initialHashesCopy);
    public sealed virtual IKeyValueDb GetDb();
    public sealed virtual IKeyValueEnumerator`2<IPsiSourceFile, TValue> GetEnumerator(bool reversedOrder);
    public sealed virtual IKeyValueEnumerator`2<IPsiSourceFile, TValue> GetEnumerator(bool reversedOrder, IPsiSourceFile fromKey);
    public sealed virtual IPersistentSortedMap`2<IPsiSourceFile, TValue> GetInSnapshot(IKeyValueDb snapshot);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Caches.Persistence.SourceFilePersistentMap`1/<GetEnumerator>d__13")]
public sealed virtual IEnumerator`1<KeyValuePair`2<IPsiSourceFile, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<IPsiSourceFile, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<IPsiSourceFile, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<IPsiSourceFile, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool ContainsKey(IPsiSourceFile key);
    public sealed virtual void Add(IPsiSourceFile key, TValue value);
    public sealed virtual bool Remove(IPsiSourceFile key);
    public sealed virtual bool TryGetValue(IPsiSourceFile key, TValue& value);
    public sealed virtual bool TryGetCachedValue(IPsiSourceFile key, TValue& value);
    public sealed virtual TValue get_Item(IPsiSourceFile key);
    public sealed virtual void set_Item(IPsiSourceFile key, TValue value);
    public sealed virtual ICollection`1<IPsiSourceFile> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual bool get_UseCachingEnumerator();
    public sealed virtual void set_UseCachingEnumerator(bool value);
    public sealed virtual CachingStrategy get_CachingStrategy();
    public sealed virtual void set_CachingStrategy(CachingStrategy value);
    public sealed virtual IKeyValueEnumerator`2<IPsiSourceFile, TValue> GetCleaningEnumerator(Func`2<IPsiSourceFile, bool> func);
    public sealed virtual long SizeInBytes();
    public sealed virtual void Dump(TextWriter writer, Func`2<IPsiSourceFile, string> renderKey, Func`2<TValue, string> renderValue);
    [CompilerGeneratedAttribute]
private bool <GetEnumerator>b__10_0(ContentKey contentKey);
    [CompilerGeneratedAttribute]
private IPsiSourceFile <GetEnumerator>b__10_1(ContentKey contentKey);
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Caches.PsiCacheNotifier : object {
    protected Lifetime Lifetime;
    protected IPsiCachesState CachesState;
    private IPsiFiles myPsiFiles;
    protected ReadonlyToken ExternalOwnershipCookie;
    [NotNullAttribute]
private Property`1<string> myDescription;
    [NotNullAttribute]
private Property`1<string> myHeader;
    [NotNullAttribute]
private Property`1<bool> myIsActive;
    [NotNullAttribute]
private Property`1<double> myProgress;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    protected ISolution Solution { get; }
    [NotNullAttribute]
public IProperty`1<string> Description { get; }
    [NotNullAttribute]
public IProperty`1<string> Header { get; }
    [NotNullAttribute]
public IProperty`1<bool> IsActive { get; }
    [NotNullAttribute]
public IProperty`1<double> Progress { get; }
    public bool CachesAreReady { get; }
    [NotNullAttribute]
public IShellLocks Locks { get; }
    public PsiCacheNotifier(Lifetime lifetime, ISolution solution, IPsiCachesState cachesState, IPsiFiles psiFiles);
    [CompilerGeneratedAttribute]
protected ISolution get_Solution();
    public IProperty`1<string> get_Description();
    public IProperty`1<string> get_Header();
    public IProperty`1<bool> get_IsActive();
    public IProperty`1<double> get_Progress();
    public bool get_CachesAreReady();
    public IShellLocks get_Locks();
    [NotNullAttribute]
public static PsiCacheNotifier GetInstance(ISolution solution);
    public void TakeOwnership(ReadonlyToken ownertoken);
    public virtual bool WaitForCaches(string callerName, string cancelButtonContent);
    [CompilerGeneratedAttribute]
private bool <WaitForCaches>b__26_0();
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Caches.PsiCacheRegistry : object {
    [NotNullAttribute]
private Dictionary`2<Type, IPsiCache> myPsiCaches;
    [NotNullAttribute]
private IShellLocks myLocks;
    [NotNullAttribute]
private PsiFiles myPsiFiles;
    [NotNullAttribute]
private ILogger myLogger;
    [CompilerGeneratedAttribute]
private ViewableCollection`1<IBackgroundCache> <BackgroundCaches>k__BackingField;
    [CompilerGeneratedAttribute]
private ViewableCollection`1<IPsiSourceFileCache> <ResolveCaches>k__BackingField;
    [CompilerGeneratedAttribute]
private ViewableCollection`1<ICache> <ActiveCaches>k__BackingField;
    [CompilerGeneratedAttribute]
private ViewableCollection`1<IPsiSourceFileCache> <ActivePsiSourceFileCaches>k__BackingField;
    [CompilerGeneratedAttribute]
private ViewableCollection`1<IAssemblyCache> <ActiveAssemblyCaches>k__BackingField;
    public IEnumerable`1<IPsiCache> InvalidatingPsiCaches { get; }
    [NotNullAttribute]
public ViewableCollection`1<IBackgroundCache> BackgroundCaches { get; }
    [NotNullAttribute]
public ViewableCollection`1<IPsiSourceFileCache> ResolveCaches { get; }
    [NotNullAttribute]
public ViewableCollection`1<ICache> ActiveCaches { get; }
    [NotNullAttribute]
public ViewableCollection`1<IPsiSourceFileCache> ActivePsiSourceFileCaches { get; }
    [NotNullAttribute]
public ViewableCollection`1<IAssemblyCache> ActiveAssemblyCaches { get; }
    public PsiCacheRegistry(Lifetime lifetime, IShellLocks locks, IEnumerable`1<ICache> caches, IEnumerable`1<IPsiCache> psiCaches, PsiFiles psiFiles, SolutionCaches solutionCaches);
    private void SubscribeToSwitchingCache(Lifetime lifetime, ISwitchingCache switchingCache);
    private void ToggleCache(ICache cache, bool add);
    public sealed virtual IEnumerable`1<IPsiCache> get_InvalidatingPsiCaches();
    [CompilerGeneratedAttribute]
public sealed virtual ViewableCollection`1<IBackgroundCache> get_BackgroundCaches();
    [CompilerGeneratedAttribute]
public sealed virtual ViewableCollection`1<IPsiSourceFileCache> get_ResolveCaches();
    [CompilerGeneratedAttribute]
public sealed virtual ViewableCollection`1<ICache> get_ActiveCaches();
    [CompilerGeneratedAttribute]
public sealed virtual ViewableCollection`1<IPsiSourceFileCache> get_ActivePsiSourceFileCaches();
    [CompilerGeneratedAttribute]
public sealed virtual ViewableCollection`1<IAssemblyCache> get_ActiveAssemblyCaches();
    public sealed virtual TPsiCache GetPsiCache();
}
[PsiComponentAttribute("10")]
internal class JetBrains.ReSharper.Psi.Caches.PsiCaches : object {
    private IPsiFiles myPsiFiles;
    private IPsiTransactions myPsiTransactions;
    private PersistentIndexManager myPersistentIndexManager;
    private IPsiCacheRegistry myCacheRegistry;
    private CacheJobService2 myJobService;
    private DocumentManager myDocumentManager;
    private DocumentTransactionManager myDocumentTransactionManager;
    private PsiModules myPsiModules;
    private PsiCacheNotifier myCacheNotifier;
    private IShellLocks myLocks;
    private IPsiConfiguration myPsiConfiguration;
    private StubTreeNodeCache myStubTreeNodeCache;
    [NotNullAttribute]
private IndexingPerformanceCollector myIndexingPerformanceCollector;
    private SynchronizationPoints mySynchronizationPoints;
    private IPsiCachesState myState;
    private ILogger myLogger;
    private GroupingEvent myUpdateBackgroundEvent;
    [CompilerGeneratedAttribute]
private ISourceDeclaredElementsCache <SourceDeclaredElementsCache>k__BackingField;
    private static int BackgroundFilesSyncUpdateThreshold;
    public ISourceDeclaredElementsCache SourceDeclaredElementsCache { get; }
    public bool HasDirtyFiles { get; }
    public PsiCaches(IPsiCachesState state, ILogger logger, IShellLocks locks, IPsiCacheRegistry cacheRegistry, IPsiTransactions psiTransactions, IPsiFiles psiFiles, PersistentIndexManager persistentIndexManager, PsiModules psiModules, PsiCacheNotifier cacheNotifier, ChangeManager changeManager, DocumentManager documentManager, DocumentTransactionManager documentTransactionManager, IPsiConfiguration psiConfiguration, ISolutionLoadTasksScheduler loadTasksScheduler, ISourceDeclaredElementsCache sourceDeclaredElementsCache, CacheJobService2 cacheJobService, StubTreeNodeCache stubTreeNodeCache, ProjectFilePrimaryPsiLanguageTypeCache projectFilePrimaryPsiLanguageTypeCache, ProjectPropertiesListener projectPropertiesListener, IndexingPerformanceCollector indexingPerformanceCollector, SynchronizationPoints synchronizationPoints);
    private void NotifyPsiChange(ITreeNode node, PsiChangedElementType elementType);
    [CompilerGeneratedAttribute]
public sealed virtual ISourceDeclaredElementsCache get_SourceDeclaredElementsCache();
    public sealed virtual bool get_HasDirtyFiles();
    public sealed virtual void WithSyncUpdateFiltered(IPsiSourceFile sourceFile, Action action);
    public sealed virtual bool WaitForCaches(string callerName, string cancelButtonContent);
    public sealed virtual void EnqueueUpdateFiles(ICollection`1<IPsiSourceFile> projectFiles, ICollection`1<IPsiSourceFileCache> caches, bool forceSync, TaskPriority priority, Nullable`1<UpdateProjectFilesJobSource> source);
    private UpdateProjectFilesStatistics StartNewUpdateStatistics(Nullable`1<UpdateProjectFilesJobSource> source);
    public sealed virtual void EnqueueRemoveFiles(ICollection`1<IPsiSourceFile> projectFiles, ICollection`1<IPsiSourceFileCache> caches, bool forceSync, TaskPriority priority);
    private void EnqueueLoad(ICollection`1<ICache> caches);
    public sealed virtual void MarkAsDirty(IPsiSourceFile sourceFile);
    public bool BadMomentToStartBackgroundCaches();
    public sealed virtual void Update();
    private void UpdateBackgroundCaches();
    [NotNullAttribute]
private HashSet`1<IPsiSourceFile> BackgroundFilesToUpdate();
    private bool ShouldBuildCaches(IPsiSourceFile sourceFile);
    private void Log(bool additionalCondition, string action, string additionalInfo);
    private void Trace(bool additionalCondition, string action, string additionalInfo);
    public sealed virtual object Execute(IChangeMap changeMap);
    private void OnPsiModulesChange(PsiModuleChange psiModuleChange, bool forceSyncUpdate, HashSet`1<IPsiSourceFile> filesToRemove, HashSet`1<IPsiSourceFile> filesToAdd);
    private void ProcessAssemblyChanges(PsiModuleChange psiModuleChange, bool forceSyncUpdate);
    public sealed virtual TPsiCache GetPsiCache();
    public sealed virtual void SandBoxCreated(SandBox sandBox);
    public sealed virtual void EnqueueJob(Job job);
}
[PsiComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Caches.PsiCachesAwaiter : object {
    private ISolution mySolution;
    private IPsiCaches myCaches;
    public PsiCachesAwaiter(ISolution solution, IPsiCaches caches);
    public sealed virtual bool WaitForCaches(string reason);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Caches.PsiCachesRepairService : object {
    private static int GROUPING_EVENT_INTERVAL_IN_SECONDS;
    private static Key`1<Boxed`1<long>> ourLastForceUpdateAggregatedTimestamp;
    private Lifetime myLifetime;
    private IPsiCaches myPsiCaches;
    private IPsiFiles myPsiFiles;
    private ILogger myLogger;
    private IShellLocks myLocks;
    private bool myIsEnabled;
    private IGroupingEvent myForceUpdateFilesEvent;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<IPsiSourceFile, long>> myForceUpdateFiles;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<ICollection`1<IPsiSourceFile>> OnAfterFilesForceUpdated;
    public PsiCachesRepairService(Lifetime lifetime, ISolution solution, IPsiCaches psiCaches, IPsiFiles psiFiles, IShellLocks locks, IGroupingEventFactory groupingEventFactory, ISettingsStore settingsStore, ILogger logger);
    private static PsiCachesRepairService();
    [CompilerGeneratedAttribute]
public void add_OnAfterFilesForceUpdated(Action`1<ICollection`1<IPsiSourceFile>> value);
    [CompilerGeneratedAttribute]
public void remove_OnAfterFilesForceUpdated(Action`1<ICollection`1<IPsiSourceFile>> value);
    public virtual void ForceUpdateFile(IPsiSourceFile sourceFile, string reason);
    protected virtual void ForceUpdateFilesHandler();
}
[PsiComponentAttribute("10")]
internal class JetBrains.ReSharper.Psi.Caches.PsiCachesState : object {
    private SolutionCaches mySolutionCaches;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <IsIdle>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <IsPrimaryIdle>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <IsInitialUpdateFinished>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <IsLoadEnqueued>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<IPsiSourceFile> <SyncUpdateFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <IsFileUpdateStarted>k__BackingField;
    private static string CachesColdProcessingFinishedKey;
    public IProperty`1<bool> IsIdle { get; }
    public IProperty`1<bool> IsPrimaryIdle { get; }
    public IProperty`1<bool> IsInitialUpdateFinished { get; }
    public IProperty`1<bool> IsLoadEnqueued { get; }
    public IProperty`1<IPsiSourceFile> SyncUpdateFilter { get; }
    public IProperty`1<bool> IsFileUpdateStarted { get; }
    public bool CachesColdProcessingFinished { get; private set; }
    public PsiCachesState(Lifetime lifetime, SynchronizationPoints synchronizationPoints, IShellLocks locks, SolutionCaches solutionCaches);
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<bool> get_IsIdle();
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<bool> get_IsPrimaryIdle();
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<bool> get_IsInitialUpdateFinished();
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<bool> get_IsLoadEnqueued();
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<IPsiSourceFile> get_SyncUpdateFilter();
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<bool> get_IsFileUpdateStarted();
    public sealed virtual bool get_CachesColdProcessingFinished();
    private void set_CachesColdProcessingFinished(bool value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__20_1(Lifetime _);
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Caches.PsiModuleAttributesCache : object {
    private Lifetime myLifetime;
    private ISolution mySolution;
    private ChangeManager myChangeManager;
    private IPsiModules myPsiModules;
    private ISymbolCache mySymbolCache;
    private IShellLocks myLocks;
    private ILogger myLogger;
    private SynchronizationPoints mySyncPoints;
    private ISolutionLoadTasksScheduler mySolutionLoadTasksScheduler;
    private IPersistentIndexManager myPersistentIndexManager;
    private List`1<IPsiModuleAttributesChangeProvider> myRegisterAttributesChangeProviders;
    private Dictionary`2<IPsiModule, ChangeType> myDirtyPsiModules;
    private SequentialLifetimes myUpdateCachesLifetimes;
    private SynchronizationPoint mySynchronizationPoint;
    private long myUpdateCounter;
    [CanBeNullAttribute]
private LifetimeDefinition myInitialUpdateLifetimeDefinition;
    protected bool IsAsyncBehaviorProhibited { get; }
    public PsiModuleAttributesCache(Lifetime lifetime, ISolution solution, ChangeManager changeManager, IPsiModules psiModules, ISymbolCache symbolCache, IPsiCachesState psiCachesState, IShellLocks locks, ILogger logger, SynchronizationPoints syncPoints, ISolutionLoadTasksScheduler solutionLoadTasksScheduler, IPersistentIndexManager persistentIndexManager);
    private void ScheduleUpdateCaches(Lifetime cachesIsIsleLifetime);
    [StringFormatMethodAttribute("format")]
private void OnUpdateCachesCompleted(LifetimeDefinition queueDefinition, string format, Object[] args);
    [NotNullAttribute]
public Func`2<IPsiModule, TValueAgg> Register(Lifetime lifetime, IClrTypeName clrTypeName, Func`2<IAttributeInstance, TValue> value, Func`3<TValueAgg, TValue, TValueAgg> agg1, Func`3<TValueAgg, TValueAgg, TValueAgg> agg2, IEqualityComparer`1<TValueAgg> equalityComparer, IUnsafeMarshaller`1<TValueAgg> valueMarshaller, IChangeProvider& changeProvider);
    private sealed virtual override object JetBrains.Application.changes.IChangeProvider.Execute(IChangeMap changeMap);
    private void QueueUpdateCaches(Lifetime lifetime, TimeSpan timeout, LifetimeDefinition syncPointReasonDefinition);
    protected virtual bool get_IsAsyncBehaviorProhibited();
    private void UpdateCaches(IDictionary`2<IPsiModule, ChangeType> dirtyPsiModules, IDictionary`2<IPsiModuleAttributesChangeProvider, IDictionary`2<IPsiModule, object>> changesToFire);
}
public static class JetBrains.ReSharper.Psi.Caches.PsiModuleAttributesCacheUtil : object {
    public static string GetSingleStringParameterFromAttribute(IAttributeInstance attributeInstance);
    public static Func`2<IPsiModule, TCollection> RegisterSingleStringParameterAttribute(Lifetime lifetime, PsiModuleAttributesCache psiModuleAttributesCache, IClrTypeName attributeName, IChangeProvider& changeProvider, Func`2<string, string> converter);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Caches.RarelyChangedTreeCachedDataExtensions : object {
    [NotNullAttribute]
private static Key`1<IRarelyChangedTreeCachedData> outDataKey;
    private static RarelyChangedTreeCachedDataExtensions();
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IRarelyChangedTreeCachedData GetRarelyChangedTreeCachedData(IFile file);
}
public class JetBrains.ReSharper.Psi.Caches.SearchSymbolsCache.CacheEvent : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private EventType <Type>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Id { get; public set; }
    public EventType Type { get; public set; }
    public CacheEvent(string Id, EventType Type);
    [CompilerGeneratedAttribute]
protected CacheEvent(CacheEvent original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Id(string value);
    [CompilerGeneratedAttribute]
public EventType get_Type();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Type(EventType value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(CacheEvent left, CacheEvent right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(CacheEvent left, CacheEvent right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(CacheEvent other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual CacheEvent <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Id, EventType& Type);
}
public class JetBrains.ReSharper.Psi.Caches.SearchSymbolsCache.CacheEvents : object {
    [CompilerGeneratedAttribute]
private CacheType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<CacheEvent> <Events>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public CacheType Type { get; public set; }
    public IList`1<CacheEvent> Events { get; public set; }
    public CacheEvents(CacheType Type, IList`1<CacheEvent> Events);
    [CompilerGeneratedAttribute]
protected CacheEvents(CacheEvents original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public CacheType get_Type();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Type(CacheType value);
    [CompilerGeneratedAttribute]
public IList`1<CacheEvent> get_Events();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Events(IList`1<CacheEvent> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(CacheEvents left, CacheEvents right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(CacheEvents left, CacheEvents right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(CacheEvents other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual CacheEvents <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(CacheType& Type, IList`1& Events);
}
public enum JetBrains.ReSharper.Psi.Caches.SearchSymbolsCache.CacheType : Enum {
    public int value__;
    public static CacheType Classes;
    public static CacheType Symbols;
}
public enum JetBrains.ReSharper.Psi.Caches.SearchSymbolsCache.EventType : Enum {
    public int value__;
    public static EventType Add;
    public static EventType Remove;
}
public interface JetBrains.ReSharper.Psi.Caches.SearchSymbolsCache.ICacheEventsService {
    public abstract virtual void UpdateEventsNotPersisted(CacheType cacheType, long diff);
    public abstract virtual long GetEventsNotPersisted(CacheType cacheType);
    public abstract virtual void ResetCounters(CacheType cacheType);
    public abstract virtual AsyncChannel`1<CacheEvents> GetEventChannel();
    public abstract virtual void ProcessEvents(CacheEvents events);
}
public abstract class JetBrains.ReSharper.Psi.Caches.SearchSymbolsCache.SemanticSearchCacheBase : SimpleICache`1<SearchEntities> {
    private ILogger myLogger;
    private IPsiModules myModules;
    private IPsiFiles myPsiFiles;
    private ICacheEventsService myCacheEventsService;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <Blocked>k__BackingField;
    public IProperty`1<bool> Active { get; }
    public IProperty`1<bool> Blocked { get; }
    public SemanticSearchCacheBase(ILogger logger, Lifetime lifetime, IShellLocks locks, IPsiModules modules, IPersistentIndexManager persistentIndexManager, ICacheEventsService cacheEventsService, IPsiFiles psiFiles);
    protected abstract virtual string GetName();
    private void UpdateIndex(ICollection`1<string> indexes, EventType updateType);
    protected abstract virtual CacheType GetCacheType();
    protected abstract virtual IEnumerable`1<string> ParseEntities(LanguageService languageService, IFile file);
    protected abstract virtual bool IsLanguageSupported(PsiLanguageType language);
    public virtual object Build(IPsiSourceFile sourceFile, bool isStartup);
    public virtual void Merge(IPsiSourceFile sourceFile, object builtPart);
    private void NotifyChanges(SearchEntities oldData, SearchEntities newData);
    protected static string GetEntityIdPrefix(IFile file);
    private static string GetPersistentIdHash(string persistentId);
    private static string GetShortHash(string text, int len);
    public abstract virtual IProperty`1<bool> get_Active();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_Blocked();
    public sealed virtual void Initialize();
    public sealed virtual void Release();
}
public abstract class JetBrains.ReSharper.Psi.Caches.SimpleICache`1 : object {
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private IShellLocks <Locks>k__BackingField;
    [NotNullAttribute]
protected IPersistentIndexManager PersistentIndexManager;
    [NotNullAttribute]
protected SynchronizedSet`1<IPsiSourceFile> Dirty;
    protected bool LoadCompleted;
    [CompilerGeneratedAttribute]
private IOptimizedPersistentSortedMap`2<IPsiSourceFile, T> <Map>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ClearOnLoad>k__BackingField;
    protected Lifetime Lifetime { get; }
    [NotNullAttribute]
protected IShellLocks Locks { get; }
    [NotNullAttribute]
public IOptimizedPersistentSortedMap`2<IPsiSourceFile, T> Map { get; }
    public bool ClearOnLoad { get; public set; }
    public string PersistentId { get; }
    public string Version { get; }
    public bool HasDirtyFiles { get; }
    protected SimpleICache`1(Lifetime lifetime, IShellLocks locks, IPersistentIndexManager persistentIndexManager, IUnsafeMarshaller`1<T> valueMarshaller, Nullable`1<long> version);
    [CompilerGeneratedAttribute]
protected Lifetime get_Lifetime();
    [CompilerGeneratedAttribute]
protected IShellLocks get_Locks();
    [CompilerGeneratedAttribute]
public IOptimizedPersistentSortedMap`2<IPsiSourceFile, T> get_Map();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ClearOnLoad();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ClearOnLoad(bool value);
    public sealed virtual string get_PersistentId();
    public virtual string get_Version();
    public virtual void MarkAsDirty(IPsiSourceFile sourceFile);
    protected virtual void RemoveFromDirty(IPsiSourceFile sf);
    public virtual object Load(IProgressIndicator progress, bool enablePersistence);
    public virtual void MergeLoaded(object data);
    public virtual void Save(IProgressIndicator progress, bool enablePersistence);
    public sealed virtual bool get_HasDirtyFiles();
    protected virtual bool IsApplicable(IPsiSourceFile sourceFile);
    public virtual bool UpToDate(IPsiSourceFile sourceFile);
    public abstract virtual object Build(IPsiSourceFile sourceFile, bool isStartup);
    public virtual void Merge(IPsiSourceFile sourceFile, object builtPart);
    public virtual void Drop(IPsiSourceFile sourceFile);
    public virtual void OnPsiChange(ITreeNode elementContainingChanges, PsiChangedElementType type);
    public virtual void OnDocumentChange(IPsiSourceFile sourceFile, ProjectFileDocumentCopyChange change);
    public virtual void SyncUpdate(bool underTransaction);
    [NotNullAttribute]
protected string Render(T value);
    public sealed virtual void Dump(TextWriter writer, IPsiSourceFile sourceFile);
    protected virtual void ProcessDirty();
    protected virtual void ProcessDirtyFile(IPsiSourceFile psiSourceFile);
    [CompilerGeneratedAttribute]
private bool <Load>b__23_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class JetBrains.ReSharper.Psi.Caches.StubTreeNodeCache.BufferMarshaller : object {
    [CompilerGeneratedAttribute]
private static BufferMarshaller <Instance>k__BackingField;
    public static BufferMarshaller Instance { get; }
    private static BufferMarshaller();
    [CompilerGeneratedAttribute]
public static BufferMarshaller get_Instance();
    public sealed virtual void Marshal(UnsafeWriter writer, IBuffer buffer);
    public sealed virtual IBuffer Unmarshal(UnsafeReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.Caches.StubTreeNodeCache.ShrinkedTreeNodesInMemoryCache : object {
    [CompilerGeneratedAttribute]
private IOptimizedPersistentSortedMap`2<IPsiSourceFile, IFile> <readOnlyPersistentMap>P;
    private LazyForkedContentModelData`1<DirectMappedCache`2<IPsiSourceFile, IFile>> myInMemoryCache;
    public ShrinkedTreeNodesInMemoryCache(IOptimizedPersistentSortedMap`2<IPsiSourceFile, IFile> readOnlyPersistentMap);
    [MustUseReturnValueAttribute]
public IFile TryGetShrinkedTreeNode(IPsiSourceFile sourceFile);
    public void Remove(IPsiSourceFile sourceFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Caches.StubTreeNodeCache.StubTreeNodeCache : object {
    private static CachingStrategy OptStrategy;
    private static int MAX_PERSISTED_FILE_SIZE;
    private Lifetime myLifetime;
    private ILogger myLogger;
    private IPersistentIndexManager myPersistentIndexManager;
    private Dictionary`2<PsiLanguageType, IOptimizedPersistentSortedMap`2<IPsiSourceFile, IArrayOfTokens>> myTokenCaches;
    private Dictionary`2<PsiLanguageType, IOptimizedPersistentSortedMap`2<IPsiSourceFile, IBuffer>> myBufferCaches;
    private Dictionary`2<PsiLanguageType, IOptimizedPersistentSortedMap`2<IPsiSourceFile, IFile>> myTreeNodeCaches;
    private Dictionary`2<PsiLanguageType, ShrinkedTreeNodesInMemoryCache> myShrinkedTreeNodeCache;
    private IPsiFiles myPsiFiles;
    private ILanguages myLanguages;
    private CommonIdentifierIntern myCommonIdentifierIntern;
    private CacheJobService2 myCacheJobService;
    private ILanguageManager myLanguageManager;
    private IShellLocks myLocks;
    private HashSet`1<IPsiSourceFile> myDirtyFiles;
    private bool myIsLoaded;
    [CompilerGeneratedAttribute]
private bool <EnabledFullPsiTreeCache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnabledTokensAndBuffersCache>k__BackingField;
    [PublicAPIAttribute]
public bool EnabledFullPsiTreeCache { get; private set; }
    [PublicAPIAttribute]
public bool EnabledTokensAndBuffersCache { get; private set; }
    private bool JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.HasDirtyFiles { get; }
    public StubTreeNodeCache(Lifetime lifetime, ILogger logger, IPersistentIndexManager persistentIndexManager, IPsiFiles psiFiles, ILanguages languages, CommonIdentifierIntern commonIdentifierIntern, CacheJobService2 cacheJobService, ILanguageManager languageManager, ISettingsStore settingsStore, ISolution solution, IShellLocks locks);
    [CompilerGeneratedAttribute]
public bool get_EnabledFullPsiTreeCache();
    [CompilerGeneratedAttribute]
private void set_EnabledFullPsiTreeCache(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnabledTokensAndBuffersCache();
    [CompilerGeneratedAttribute]
private void set_EnabledTokensAndBuffersCache(bool value);
    [PureAttribute]
private bool IsCacheParticipant(IPsiSourceFile sourceFile);
    [MustUseReturnValueAttribute]
internal IFileImpl TryGetFullPsiFileNoParse(IPsiSourceFile sourceFile, PsiLanguageType language);
    [MustUseReturnValueAttribute]
internal IFileImpl TryGetFullPsiFile(IPsiSourceFile sourceFile, PsiLanguageType language);
    [MustUseReturnValueAttribute]
private IFileImpl TryGetFullPsiFileImpl(IPsiSourceFile sourceFile, PsiLanguageType language, bool parseOnCacheMiss);
    private int EstimateFileSize(FileElementBase file, PsiLanguageType language);
    [MustUseReturnValueAttribute]
public IFile TryGetShrinkedPsiFile(IPsiSourceFile sourceFile, PsiLanguageType language);
    [PureAttribute]
internal bool IsCacheable(PsiLanguageType language);
    [PureAttribute]
private bool IsCacheable(IPsiSourceFile sourceFile, PsiLanguageType language);
    private sealed virtual override object JetBrains.ReSharper.Psi.Caches.ICache.Load(IProgressIndicator progress, bool enablePersistence);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.ICache.MergeLoaded(object data);
    private void CleanCachesForRemovedFiles();
    private static void CleanCacheForRemovedFiles(IOptimizedPersistentSortedMap`2<IPsiSourceFile, T> persistentSortedMap);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.Drop(IPsiSourceFile sourceFile);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.ICache.Save(IProgressIndicator progress, bool enablePersistence);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.MarkAsDirty(IPsiSourceFile sourceFile);
    internal void Drop(IPsiSourceFile sourceFile);
    private void Drop(IPsiSourceFile sourceFile, bool dropTokenBuffer);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.get_HasDirtyFiles();
    private sealed virtual override bool JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.UpToDate(IPsiSourceFile sourceFile);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.SyncUpdate(bool underTransaction);
    public sealed virtual void Dump(TextWriter writer, IPsiSourceFile sourceFile);
    [PureAttribute]
private static bool IsValidContentHash(FileElementBase file);
    [NullableContextAttribute("2")]
private sealed virtual override void JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.OnPsiChange(ITreeNode elementContainingChanges, PsiChangedElementType elementType);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.OnDocumentChange(IPsiSourceFile sourceFile, ProjectFileDocumentCopyChange change);
    private sealed virtual override object JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.Build(IPsiSourceFile sourceFile, bool isStartup);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.Merge(IPsiSourceFile sourceFile, object builtPart);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.IPsiSourceFileInvalidatingCache.Invalidate(IEnumerable`1<IPsiSourceFile> sourceFiles);
    [MustUseReturnValueAttribute]
internal IBuffer TryGetBuffer(IPsiSourceFile sourceFile, PsiLanguageType language);
    [MustUseReturnValueAttribute]
internal IArrayOfTokens TryGetTokens(IPsiSourceFile sourceFile, PsiLanguageType language);
    private IOptimizedPersistentSortedMap`2<IPsiSourceFile, IBuffer> CreateBufferCache(ILanguageTreeNodeCacheProvider languageCacheProvider);
    private IOptimizedPersistentSortedMap`2<IPsiSourceFile, IArrayOfTokens> CreateTokenCache(ILanguageTreeNodeCacheProvider languageCacheProvider);
    private ValueTuple`2<IOptimizedPersistentSortedMap`2<IPsiSourceFile, IFile>, IOptimizedPersistentSortedMap`2<IPsiSourceFile, IFile>> CreateTreeNodeCaches(ILanguageTreeNodeCacheProvider languageCacheProvider);
    private void UpdateCacheSettings(IContextBoundSettingsStoreLive contextBoundSettingsStore);
    [CompilerGeneratedAttribute]
private bool <JetBrains.ReSharper.Psi.Caches.ICache.Load>b__34_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Caches.StubTreeNodeCache.StubTreeNodesMapReader : object {
    [CompilerGeneratedAttribute]
private ILanguageManager <languageManager>P;
    [CompilerGeneratedAttribute]
private ILanguages <languages>P;
    [CompilerGeneratedAttribute]
private CommonIdentifierIntern <commonIdentifierIntern>P;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Func`2<int, bool> <deserializeFilter>P;
    private static ObjectPool`1<PooledList`1<NodeType>> ourSeenNodeTypesPool;
    public StubTreeNodesMapReader(ILanguageManager languageManager, ILanguages languages, CommonIdentifierIntern commonIdentifierIntern, Func`2<int, bool> deserializeFilter);
    private static StubTreeNodesMapReader();
    public FileElementBase ReadTreeNode(UnsafeReader reader);
    public static TreeElement ReadTreeNode(UnsafeReader reader, ILanguageTreeNodeCacheProvider languageCacheProvider, InternedStringsReaderContext internedStringsReaderContext, ITokenIntern tokenIntern, Func`2<int, bool> deserializeFilter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Caches.StubTreeNodeCache.StubTreeNodesMapWriter : object {
    [CompilerGeneratedAttribute]
private ILanguageManager <languageManager>P;
    [CompilerGeneratedAttribute]
private bool <SerializeChameleonInClosedForm>k__BackingField;
    private static ObjectPool`1<PooledDictionary`2<int, int>> ourSmallNodeTypesMapPool;
    internal static byte EndOfCompositeNodeSlotIndex;
    internal static byte ClosedChameleonNodeSlotIndex;
    internal static byte OpenChameleonNodeSlotIndex;
    internal static int SpecialSlotsCount;
    public bool SerializeChameleonInClosedForm { get; public set; }
    public StubTreeNodesMapWriter(ILanguageManager languageManager);
    private static StubTreeNodesMapWriter();
    [CompilerGeneratedAttribute]
public bool get_SerializeChameleonInClosedForm();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SerializeChameleonInClosedForm(bool value);
    public void WriteFileTreeNode(UnsafeWriter writer, IFile file);
    public static void WriteTreeNode(TreeElement rootElement, ILanguageTreeNodeCacheProvider languageCacheProvider, InternedStringsWriterContext internedStringsWriterContext, UnsafeWriter writer, bool serializeChameleonsInClosedForm);
    public static void AssertTreesAreEqual(ITreeNode parsedFile, ITreeNode deserializedFile, Func`2<int, bool> deserializeFilter);
    [CompilerGeneratedAttribute]
internal static void <AssertTreesAreEqual>g__SkipByFilter|13_0(Boolean& parsedMoved, <>c__DisplayClass13_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class JetBrains.ReSharper.Psi.Caches.StubTreeNodeCache.TokenMarshaller : object {
    [CompilerGeneratedAttribute]
private ILanguageTreeNodeCacheProvider <languageCacheProvider>P;
    public TokenMarshaller(ILanguageTreeNodeCacheProvider languageCacheProvider);
    public sealed virtual void Marshal(UnsafeWriter writer, IArrayOfTokens tokens);
    public sealed virtual IArrayOfTokens Unmarshal(UnsafeReader reader);
}
public class JetBrains.ReSharper.Psi.Caches.SymbolCache.AlternativeNameSymbolScope : CaseSensitiveSymbolScope {
    public AlternativeNameSymbolScope(IPsiModules psiModules, IDeclarationsScope scope, SymbolCache symbolCache, CaseSensitiveSymbolScopeRequestCache symbolScopeRequestCache, CacheTrieNode trieRoot);
    public virtual ITypeElement[] GetTypeElementsByCLRName(IClrTypeName clrTypeName);
    public virtual ITypeElement GetTypeElementByCLRName(IClrTypeName clrTypeName);
    protected virtual ITrieCursor CreateTraverser();
    public virtual bool Accepts(CacheTrieNode trieNode, ITypeElement typeElement);
    private static string GetName(ITypeElement typeElement);
}
public class JetBrains.ReSharper.Psi.Caches.SymbolCache.AlternativeNameTrieTraverser : CaseSensitiveTrieTraverser {
    public AlternativeNameTrieTraverser(CacheTrieNode root);
    public virtual bool Contains(TypeElement element);
}
internal class JetBrains.ReSharper.Psi.Caches.SymbolCache.CacheBuilder : object {
    private Part myCurrentRoot;
    private PartsTree myPartsTree;
    private DataIntern`1<string> myIntern;
    private WalkingStack myMemberNameStack;
    public CacheBuilder(PartsTree tree, DataIntern`1<string> intern);
    public sealed virtual void CreateProjectFilePart(ProjectFilePart projectFilePart);
    public void CreateSandboxPart();
    public sealed virtual void AddDeclaredMemberName(string name);
    public sealed virtual void AddImplicitMemberName(string name);
    public sealed virtual void StartPart(Part part);
    public sealed virtual void EndPart();
    public sealed virtual string Intern(string str);
}
public static class JetBrains.ReSharper.Psi.Caches.SymbolCache.CachedDeclarationsCollector : object {
    [NotNullAttribute]
[ItemNotNullAttribute]
public static IList`1<TTreeNode> Run(IFile file);
}
public class JetBrains.ReSharper.Psi.Caches.SymbolCache.CacheLogger : object {
    private Type myPhase;
    private IDisposable myPhaseTimingCookie;
    private ILogger myLogger;
    internal ILogger Log { get; }
    internal ILogger get_Log();
    protected static string CachePhaseToString(Type phaseType);
    private string CachePhaseToString();
    public void StartPhase(Job job);
    public void EndPhase(Exception ex);
    public void LogFile(IPsiSourceFile file, string comment);
    public void LogAssembly(IPsiAssembly assembly, string comment);
    public void LogException(Exception ex);
}
public class JetBrains.ReSharper.Psi.Caches.SymbolCache.CacheTrieNode : object {
    private int myDepthLevel;
    [CanBeNullAttribute]
private SubNodesCollection mySubNodes;
    [CanBeNullAttribute]
private Namespace modreq(System.Runtime.CompilerServices.IsVolatile) myNamespace;
    private HybridDistinctCollection`1<ITypeElement> mySourceTypeElements;
    private HybridDistinctCollection`1<ICompiledTypeElement> myCompiledTypeElements;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CacheTrieNode <Parent>k__BackingField;
    public bool IsPhysical { get; }
    [CanBeNullAttribute]
internal Namespace Namespace { get; }
    internal bool HasNamespace { get; }
    public string QualifiedName { get; }
    public string Name { get; }
    [CanBeNullAttribute]
internal ICaseInsensitiveNamespace CaseInsensitiveNamespace { get; }
    public bool HasChildren { get; }
    private bool IsEmpty { get; }
    public CacheTrieNode Parent { get; }
    private CacheTrieNode(CacheTrieNode parent, string name);
    private CaseInsensitiveNamespaceRegistrar GetCaseInsensitiveNamespaceRegistrar();
    [CanBeNullAttribute]
private PhysicalRoot GetPhysicalRoot();
    [CanBeNullAttribute]
private NonPhysicalRoot GetNonPhysicalRoot();
    public bool get_IsPhysical();
    protected virtual void AddSubNode(CacheTrieNode child);
    public sealed virtual void Dispose();
    private void RemoveSubNode(CacheTrieNode node);
    internal Namespace get_Namespace();
    [NotNullAttribute]
internal Namespace GetOrCreateNamespace();
    internal bool get_HasNamespace();
    [CanBeNullAttribute]
internal CacheTrieNode GetSubNodeCaseSensitive(string name);
    public string get_QualifiedName();
    [NotNullAttribute]
internal static PhysicalRoot CreatePhysicalRoot(SymbolCache symbolCache);
    [NotNullAttribute]
public CacheTrieNode GetOrCreateSubNode(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [NotNullAttribute]
public virtual IPsiServices GetPsiServices();
    public void RemoveNamespace();
    internal ICaseInsensitiveNamespace get_CaseInsensitiveNamespace();
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<CacheTrieNode> GetSubNodes();
    internal void AppendSubNodes(List`1<CacheTrieNode> children);
    internal bool ForAllSubNodes(TState state, Func`3<TState, CacheTrieNode, bool> processor);
    public bool get_HasChildren();
    private bool get_IsEmpty();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Caches.SymbolCache.CacheTrieNode/<GetAllTypeElements>d__39")]
[NotNullAttribute]
public IEnumerable`1<ITypeElement> GetAllTypeElements();
    public void ConsumeAllTypeElements(ISymbolScope scope, FrugalLocalHashSet`1& result);
    [CompilerGeneratedAttribute]
public CacheTrieNode get_Parent();
    internal void CheckConsistency();
    private bool IsBoundToTypeElement(TypeElement element);
    public virtual string ToString();
    public string Dump(bool dumpModules);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Caches.SymbolCache.CacheTrieNode/<DumpNodeContents>d__48")]
[ItemNotNullAttribute]
private IEnumerable`1<string> DumpNodeContents(bool dumpModules);
    private static string DumpTypeElement(ITypeElement element, bool dumpModules);
    public void AddCompiledTypeElement(ICompiledTypeElement typeElement, bool alternativeName);
    public void RemoveCompiledTypeElement(ICompiledTypeElement typeElement, bool alternativeName);
    public void AddTypeElement(TypeElement element, bool alternativeName);
    public void RemoveTypeElement(TypeElement element, bool alternativeName);
    [NotNullAttribute]
public IList`1<ITypeElement> GetNestedTypes(TypeElement element);
    public void ResurrectNamespace(Namespace element);
    [NotNullAttribute]
public static CacheTrieNode CreateNonPhysicalRoot(CacheTrieNode physicalRoot);
    public void FillDeclaredElements(IDeclarationsScope scope, Func`2<IClrDeclaredElement, bool> predicate, LocalList`1& result);
    public bool ForAllDeclaredElements(IDeclarationsScope scope, TState state, Func`3<TState, IClrDeclaredElement, bool> processor);
    public void BeforeTypePartRemoved(TypePart removedPart);
    internal void AfterTypePartAdded(TypePart part);
    internal void UpdateTypeElementIndices(TypeElement element);
    private void UpdateTypeElementIndices(ICompiledTypeElement element);
    [NotNullAttribute]
public IEnumerable`1<ITypeElement> GetTypeElements(TypeElementOrigin origin);
    public HybridDistinctCollection`1<CacheTrieNode> GetSubNodesCaseInsensitive(string name);
    public bool ForAllSubNodesCaseInsensitive(string shortName, TState state, Func`3<TState, CacheTrieNode, bool> processor);
}
public class JetBrains.ReSharper.Psi.Caches.SymbolCache.CachingConverter`2 : object {
    private Dictionary`2<TInput, TOutput> myCache;
    private Converter`2<TInput, TOutput> myConverter;
    private CachingConverter`2(Lifetime lifetime, Converter`2<TInput, TOutput> converter);
    [CanBeNullAttribute]
private TOutput Convert(TInput input);
    [NotNullAttribute]
public static Converter`2<TInput, TOutput> CreateForLifetime(Lifetime lifetime, Converter`2<TInput, TOutput> converter);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0();
}
public class JetBrains.ReSharper.Psi.Caches.SymbolCache.CaseInsensitiveSymbolScope : SymbolScopeBase {
    public CaseInsensitiveSymbolScope(IPsiModules psiModules, IDeclarationsScope scope, SymbolCache symbolCache, CacheTrieNode trieRoot);
    protected virtual ITrieCursor CreateTraverser();
    public virtual bool Accepts(CacheTrieNode trieNode, ITypeElement typeElement);
    protected virtual IEnumerable`1<string> GetAllShortNames(bool sorted);
    protected virtual IReadOnlyCollection`1<ITypeElement> GetAllPossibleInheritors(string shortName);
    protected virtual IEnumerable`1<CacheTrieNode> GetTrieNodesByShortName(string shortName);
    protected virtual INamespace GetNamespace(CacheTrieNode trieNode);
    protected virtual void ConsumeVisibleElementsFromTrieNode(CacheTrieNode trieNode, FrugalLocalHashSet`1& result);
    public virtual ITypeElement[] GetTypeElementsByCLRName(IClrTypeName clrTypeName);
    public virtual ITypeElement GetTypeElementByCLRName(IClrTypeName clrTypeName);
}
internal class JetBrains.ReSharper.Psi.Caches.SymbolCache.CaseInsensitiveTrieTraverser : object {
    [NotNullAttribute]
private Stack`1<Pair`2<CacheTrieNode, ICollection`1<CacheTrieNode>>> myNodesStack;
    private Pair`2<CacheTrieNode, ICollection`1<CacheTrieNode>> myCurrentNodes;
    public ITrieView CurrentView { get; }
    public CaseInsensitiveTrieTraverser(CacheTrieNode root);
    public sealed virtual void Up();
    public sealed virtual void GotoOrCreateSubNode(string name);
    public sealed virtual IEnumerable`1<CacheTrieNode> GetSubNodes();
    public sealed virtual bool GotoSubNode(string name);
    public sealed virtual Namespace GetOrCreateNamespace();
    public sealed virtual bool Contains(TypeElement element);
    public sealed virtual bool Contains(Namespace element);
    public sealed virtual ITrieView get_CurrentView();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Caches.SymbolCache.CaseInsensitiveTrieTraverser/<GetTypeElements>d__12")]
public sealed virtual IEnumerable`1<ITypeElement> GetTypeElements(ISymbolScope symbolScope, TypeElementOrigin origin);
    public sealed virtual IEnumerable`1<ITypeElement> GetTypeElements(TypeElementOrigin origin);
    public sealed virtual INamespace GetNamespace();
    public sealed virtual void AddTypeElement(TypeElement element);
    public sealed virtual void ResurrectNamespace(Namespace element);
}
public class JetBrains.ReSharper.Psi.Caches.SymbolCache.CaseSensitiveSymbolScope : SymbolScopeBase {
    private CaseSensitiveSymbolScopeRequestCache myScopeRequestCache;
    public CaseSensitiveSymbolScope(IPsiModules psiModules, IDeclarationsScope scope, SymbolCache symbolCache, CaseSensitiveSymbolScopeRequestCache symbolScopeRequestCache, CacheTrieNode trieRoot);
    protected virtual ITrieCursor CreateTraverser();
    public virtual bool Accepts(CacheTrieNode trieNode, ITypeElement typeElement);
    protected virtual INamespace GetNamespace(CacheTrieNode trieNode);
    protected virtual IEnumerable`1<string> GetAllShortNames(bool sorted);
    protected virtual IEnumerable`1<CacheTrieNode> GetTrieNodesByShortName(string shortName);
    protected virtual IReadOnlyCollection`1<ITypeElement> GetAllPossibleInheritors(string shortName);
    protected virtual void ConsumeVisibleElementsFromTrieNode(CacheTrieNode trieNode, FrugalLocalHashSet`1& result);
    public virtual ITypeElement[] GetTypeElementsByCLRName(IClrTypeName clrTypeName);
    public virtual ITypeElement GetTypeElementByCLRName(IClrTypeName clrTypeName);
    [ItemNotNullAttribute]
public static ITypeElement[] GetTypeElementsByClrNameInternal2(IModuleReferenceResolveContext moduleReferenceResolveContext, IPsiModule scopeModule, IClrTypeName clrTypeName);
}
public class JetBrains.ReSharper.Psi.Caches.SymbolCache.CaseSensitiveTrieTraverser : object {
    protected CacheTrieNode CurrentNode;
    public ITrieView CurrentView { get; }
    public CaseSensitiveTrieTraverser(CacheTrieNode root);
    public sealed virtual void Up();
    public sealed virtual void GotoOrCreateSubNode(string name);
    public sealed virtual bool GotoSubNode(string name);
    public sealed virtual IEnumerable`1<CacheTrieNode> GetSubNodes();
    public sealed virtual ITrieView get_CurrentView();
    public sealed virtual Namespace GetOrCreateNamespace();
    public sealed virtual void ResurrectNamespace(Namespace element);
    public sealed virtual void AddTypeElement(TypeElement element);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Caches.SymbolCache.CaseSensitiveTrieTraverser/<GetTypeElements>d__11")]
public sealed virtual IEnumerable`1<ITypeElement> GetTypeElements(ISymbolScope symbolScope, TypeElementOrigin origin);
    public sealed virtual IEnumerable`1<ITypeElement> GetTypeElements(TypeElementOrigin origin);
    public virtual bool Contains(TypeElement element);
    public sealed virtual bool Contains(Namespace element);
    public sealed virtual INamespace GetNamespace();
}
internal class JetBrains.ReSharper.Psi.Caches.SymbolCache.CompiledDynamicInheritorsIndex : object {
    private OneToListMultimap`2<string, ICompiledTypeElement> myInheritors;
    private DataIntern`1<string> myIntern;
    public void RemoveLibraries(ICollection`1<AssemblyPsiFile> assemblies, ICollection`1<ICompiledTypeElement> types);
    public void Add(ICompiledTypeElement typeElement);
    public MultimapValueCollection`2<string, ICompiledTypeElement> GetPossibleInheritors(string shortName);
    public void Compact();
}
public class JetBrains.ReSharper.Psi.Caches.SymbolCache.DeclarationScopeInlineCache : ValueType {
    public FrugalLocalHashSet`1<IAssemblyPsiModule> VisitedModules;
    [CanBeNullAttribute]
private Queue`1<IAssemblyPsiModule> myPooledQueue;
    [CanBeNullAttribute]
private IModuleReferenceResolveContext myContext;
    [NotNullAttribute]
[PureAttribute]
public Queue`1<IAssemblyPsiModule> GetOrCreatePooledQueue();
    [NotNullAttribute]
[PureAttribute]
public IModuleReferenceResolveContext GetOrCreateResolveContext();
}
public abstract class JetBrains.ReSharper.Psi.Caches.SymbolCache.DeclarationsScopeBase : object {
    public virtual bool Accepts(INamespace namespace);
    public virtual bool Accepts(INamespace namespace, DeclarationScopeInlineCache& cache);
    public virtual bool Accepts(ITypeElement typeElement);
    public virtual bool Accepts(ITypeElement typeElement, DeclarationScopeInlineCache& cache);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Caches.SymbolCache.DeclarationsScopeBase/<FilterTypeElementsWithTheSameClrName>d__4")]
[ItemNotNullAttribute]
[NotNullAttribute]
public virtual IEnumerable`1<ITypeElement> FilterTypeElementsWithTheSameClrName(IEnumerable`1<ITypeElement> candidates);
    public abstract virtual bool Accepts(IPsiModule module);
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.Caches.SymbolCache.DynamicInheritorsIndex : object {
    private OneToListMultimap`2<ITypeElement, string> myBases;
    private OneToListMultimap`2<string, ITypeElement> myInheritors;
    private DataIntern`1<string> myIntern;
    public MultimapValueCollection`2<string, ITypeElement> GetPossibleInheritors(string shortName);
    public void Remove(ITypeElement typeElement);
    public void Compact();
    public void Add(ITypeElement typeElement, IEnumerable`1<string> bases);
}
internal class JetBrains.ReSharper.Psi.Caches.SymbolCache.ForwardedTypesTable : object {
    private IShellLocks myLocks;
    private OneToSetMap`2<IClrTypeName, Pair`2<AssemblyNameInfoWithId, AssemblyNameInfoWithId>> myForwardedTypesByClrName;
    private OneToSetMap`2<string, Pair`2<AssemblyNameInfoWithId, AssemblyNameInfoWithId>> myForwardedNamespaces;
    private OneToSetMap`3<AssemblyNameInfo, AssemblyId, string> myForwardedFromNamespaces;
    private OneToSetMap`3<AssemblyNameInfo, AssemblyId, AssemblyNameInfoWithId> myForwardedFromAssemblies;
    private OneToSetMap`3<AssemblyNameInfo, AssemblyId, IClrTypeName> myForwardedTypes;
    private Converter`2<string, IClrTypeName> myClrTypeNameFactory;
    private Converter`2<string, AssemblyNameInfo> myAssemblyNameInfoFactory;
    public ForwardedTypesTable(Lifetime lifetime, IShellLocks locks);
    public void AddLibraryFile(AssemblyPsiFile file, Action`2<IClrTypeName, AssemblyPsiFile> onToNamespaceHandler);
    public void RemoveLibraryFile(AssemblyPsiFile file);
    [NotNullAttribute]
private static IEnumerable`1<string> EnumerateNamespaces(IClrTypeName clrTypeName);
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<AssemblyNameInfo> GetForwardedToAssemblies(AssemblyNameInfo fromAssemblyName, IClrTypeName clrName);
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<AssemblyNameInfo> GetForwardedFromAssemblies(AssemblyNameInfo toAssemblyName, IClrTypeName clrName);
    [NotNullAttribute]
public IEnumerable`1<AssemblyNameInfo> GetNamespaceForwardedFromAssemblies(AssemblyNameInfo toAssemblyName, string ns);
    [NotNullAttribute]
public IEnumerable`1<AssemblyNameInfo> GetNamespaceForwardedToAssemblies(string ns);
    [NotNullAttribute]
public Func`2<AssemblyNameInfo, AssemblyNameInfo[]> GetForwardingFromAssembliesFilterFunction(IClrTypeName clrName);
    [NotNullAttribute]
[ItemNotNullAttribute]
public ICollection`1<AssemblyNameInfo> GetForwardedToAssemblies(AssemblyNameInfo fromAssemblyName);
    [NotNullAttribute]
public ICollection`1<IClrTypeName> GetForwardedTypes(AssemblyNameInfo fromAssemblyName);
}
public interface JetBrains.ReSharper.Psi.Caches.SymbolCache.IAlternativeNameCacheTrieNodeOwner {
    [CanBeNullAttribute]
public CacheTrieNode AlternativeNameTrieNode { get; public set; }
    public abstract virtual CacheTrieNode get_AlternativeNameTrieNode();
    public abstract virtual void set_AlternativeNameTrieNode(CacheTrieNode value);
}
public interface JetBrains.ReSharper.Psi.Caches.SymbolCache.ICacheTrieNodeOwner {
    public CacheTrieNode TrieNode { get; public set; }
    public abstract virtual CacheTrieNode get_TrieNode();
    public abstract virtual void set_TrieNode(CacheTrieNode value);
}
public interface JetBrains.ReSharper.Psi.Caches.SymbolCache.IDeclarationsScope {
    [PureAttribute]
public abstract virtual bool Accepts(IPsiModule module);
    [PureAttribute]
public abstract virtual bool Accepts(INamespace namespace);
    [PureAttribute]
public abstract virtual bool Accepts(INamespace namespace, DeclarationScopeInlineCache& cache);
    [PureAttribute]
public abstract virtual bool Accepts(ITypeElement typeElement);
    [PureAttribute]
public abstract virtual bool Accepts(ITypeElement typeElement, DeclarationScopeInlineCache& cache);
}
public interface JetBrains.ReSharper.Psi.Caches.SymbolCache.ITrieCursor {
    [NotNullAttribute]
public ITrieView CurrentView { get; }
    public abstract virtual ITrieView get_CurrentView();
    public abstract virtual void Up();
    public abstract virtual void GotoOrCreateSubNode(string name);
    public abstract virtual bool GotoSubNode(string name);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<CacheTrieNode> GetSubNodes();
}
public interface JetBrains.ReSharper.Psi.Caches.SymbolCache.ITrieView {
    [NotNullAttribute]
public abstract virtual Namespace GetOrCreateNamespace();
    public abstract virtual void ResurrectNamespace(Namespace element);
    public abstract virtual void AddTypeElement(TypeElement element);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<ITypeElement> GetTypeElements(ISymbolScope symbolScope, TypeElementOrigin origin);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<ITypeElement> GetTypeElements(TypeElementOrigin origin);
    public abstract virtual bool Contains(TypeElement element);
    public abstract virtual bool Contains(Namespace element);
    [CanBeNullAttribute]
public abstract virtual INamespace GetNamespace();
}
internal class JetBrains.ReSharper.Psi.Caches.SymbolCache.ModuleDeclarationsScope : DeclarationsScopeBase {
    [NotNullAttribute]
private SymbolCache mySymbolCache;
    [CanBeNullAttribute]
private HashSet`1<IPsiModule> myReferencedModules;
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWithReferences>k__BackingField;
    [NotNullAttribute]
internal IPsiModule Module { get; }
    public bool IsWithReferences { get; }
    public ModuleDeclarationsScope(IPsiModule module, bool withReferences);
    [CompilerGeneratedAttribute]
internal IPsiModule get_Module();
    [CompilerGeneratedAttribute]
public bool get_IsWithReferences();
    public virtual bool Accepts(IPsiModule module);
    [NotNullAttribute]
private static HashSet`1<IPsiModule> CalculateReferencedModules(IPsiModule module);
    [PureAttribute]
private bool HasReference(IPsiModule module);
    public virtual bool Accepts(INamespace ns);
    public virtual bool Accepts(INamespace ns, DeclarationScopeInlineCache& cache);
    public virtual bool Accepts(ITypeElement typeElement);
    public virtual bool Accepts(ITypeElement typeElement, DeclarationScopeInlineCache& cache);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Caches.SymbolCache.ModuleDeclarationsScope/<FilterTypeElementsWithTheSameClrName>d__16")]
public virtual IEnumerable`1<ITypeElement> FilterTypeElementsWithTheSameClrName(IEnumerable`1<ITypeElement> candidates);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private bool <>n__0(ITypeElement typeElement);
}
public class JetBrains.ReSharper.Psi.Caches.SymbolCache.OneToSetMap`3 : object {
    [NotNullAttribute]
private Dictionary`2<TFirstKey, OneToSetMap`2<TSecondKey, TValue>> myData;
    [CanBeNullAttribute]
private IEqualityComparer`1<TSecondKey> mySecondKeyComparer;
    public OneToSetMap`3(IEqualityComparer`1<TFirstKey> firstKeyComparer, IEqualityComparer`1<TSecondKey> secondKeyComparer);
    public void Add(TFirstKey firstKey, TSecondKey secondKey, TValue value);
    public bool Remove(TFirstKey firstKey, TSecondKey secondKey, TValue value);
    public void RemoveKey(TFirstKey firstKey);
    public void RemoveKey(TFirstKey firstKey, TSecondKey secondKey);
    [NotNullAttribute]
public ICollection`1<TValue> GetValues(TFirstKey firstKey);
    [NotNullAttribute]
public ICollection`1<TValue> GetValues(TFirstKey firstKey, TSecondKey secondKey);
    public bool ContainsKey(TFirstKey firstKey);
    public bool ContainsKey(TFirstKey firstKey, TSecondKey secondKey);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Caches.SymbolCache.PartsMap : object {
    [NotNullAttribute]
private IOptimizedPersistentSortedMap`2<IPsiSourceFile, IList`1<ProjectFilePartsTree>> myPersistentMap;
    [NotNullAttribute]
private ProjectIndices myProjectIndices;
    [NotNullAttribute]
private IPersistentIndexManager myPersistentIndexManager;
    [NotNullAttribute]
private ILanguages myLanguages;
    [NotNullAttribute]
private CommonIdentifierIntern myCommonIdentifierIntern;
    [CanBeNullAttribute]
public ProjectFilePartsTree Item { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IList`1<ProjectFilePartsTree> Item { get; public set; }
    public PartsMap(Lifetime lifetime, IShellLocks shellLocks, ISolution solution, IPersistentIndexManager persistentIndexManager, ILanguages languages, CommonIdentifierIntern commonIdentifierIntern);
    private void WritePartsTree(UnsafeWriter writer, IList`1<ProjectFilePartsTree> partsList);
    private IList`1<ProjectFilePartsTree> ReadPartsTree(UnsafeReader reader);
    public ProjectFilePartsTree get_Item(IPsiSourceFile sourceFile, PsiLanguageType languageType);
    [CanBeNullAttribute]
private static ProjectFilePartsTree FindProjectFilePartsTree(IList`1<ProjectFilePartsTree> partsTreeList, PsiLanguageType languageType);
    public IList`1<ProjectFilePartsTree> get_Item(IPsiSourceFile sourceFile);
    public void set_Item(IPsiSourceFile sourceFile, IList`1<ProjectFilePartsTree> value);
    [ContractAnnotationAttribute("=>true,partsTreeList:notnull; =>false,partsTreeList:null")]
public bool TryGetPartsTrees(IPsiSourceFile sourceFile, IList`1& partsTreeList);
    public bool ContainsKey(IPsiSourceFile sourceFile);
    public void Remove(IPsiSourceFile sourceFile);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Caches.SymbolCache.PartsMap/<EnumerateContent>d__17")]
[NotNullAttribute]
public IEnumerable`1<KeyValuePair`2<IPsiSourceFile, IList`1<ProjectFilePartsTree>>> EnumerateContent();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Caches.SymbolCache.PartsMap/<Load>d__18")]
[NotNullAttribute]
public IEnumerable`1<KeyValuePair`2<IPsiSourceFile, IList`1<ProjectFilePartsTree>>> Load();
    public void Dump(TextWriter builder);
    [NotNullAttribute]
public IAttributesSet GetSourceModuleAttributes(IPsiModule module);
    [CompilerGeneratedAttribute]
internal static bool <ReadPartsTree>g__IsValidContentHash|7_1(Nullable`1<long> unmarshalledContentHash, Nullable`1<long> currentContentHash);
}
internal class JetBrains.ReSharper.Psi.Caches.SymbolCache.SolutionDeclarationsScope : DeclarationsScopeBase {
    [NotNullAttribute]
private IPsiModules myPsiModules;
    private LibrarySymbolScope myLibrariesSymbolScope;
    [CanBeNullAttribute]
private HashSet`1<IAssemblyPsiModule> myModulesTransitiveClosure;
    public SolutionDeclarationsScope(IPsiModules psiModules, LibrarySymbolScope librarySymbolScope);
    public virtual bool Accepts(IPsiModule module);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal static void <.ctor>g__CollectClosure|3_0(IPsiModule sourceModule, HashSet`1<IAssemblyPsiModule> closure, <>c__DisplayClass3_0& );
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Caches.SymbolCache.SolutionDeclarationsScopeCache : object {
    [NotNullAttribute]
private JetFastSemiReenterableRWLock myReaderWriterLock;
    [NotNullAttribute]
private Dictionary`2<Key, SolutionDeclarationsScope> myCache;
    [NotNullAttribute]
private IPsiModules myPsiModules;
    public SolutionDeclarationsScopeCache(Lifetime lifetime, ChangeManager changeManager, IPsiModules psiModules);
    private void OnChange(ChangeEventArgs args);
    [NotNullAttribute]
internal IDeclarationsScope GetOrCreateScope(LibrarySymbolScope librarySymbolScope);
}
[ThreadSafeAttribute]
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Caches.SymbolCache.SourceTypeNamesCatalog : object {
    private CountingSet`1<int> mySourceShortTypeNames;
    private JetFastSemiReenterableRWLock myReaderWriterLock;
    internal void Remove(ITypeElement typeElement);
    private void RemoveName(string shortName);
    internal void Add(ITypeElement typeElement);
    public bool HasName(string shortName);
}
internal abstract class JetBrains.ReSharper.Psi.Caches.SymbolCache.StringToSourceFileIndex : object {
    [NotNullAttribute]
private OneToSetMap`2<string, IPsiSourceFile> myDictionary;
    [NotNullAttribute]
[ItemNotNullAttribute]
protected ValuesCollection<string, IPsiSourceFile> SourceFiles { get; }
    protected bool ContainsKey(string name);
    protected ValuesCollection<string, IPsiSourceFile> get_SourceFiles();
    [NotNullAttribute]
[ItemNotNullAttribute]
protected ICollection`1<IPsiSourceFile> GetSourceFiles(string s);
    [NotNullAttribute]
[ItemNotNullAttribute]
protected abstract virtual String[] GetData(ProjectFilePartsTree projectFilePart);
    public void ProjectFileAdded(ProjectFilePartsTree projectFilePart);
    public void ProjectFileRemoved(ProjectFilePartsTree projectFilePart);
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Caches.SymbolCache.SymbolCache : object {
    private Lifetime myLifetime;
    [NotNullAttribute]
private ILogger myLogger;
    [NotNullAttribute]
private ISolution mySolution;
    [NotNullAttribute]
private IPsiCachesState myPsiCachesState;
    [NotNullAttribute]
private PhysicalRoot myPublicRoot;
    [NotNullAttribute]
private PhysicalRoot myWorkingRoot;
    [NotNullAttribute]
private PartsMap myPartsMap;
    [NotNullAttribute]
private DataIntern`1<string> myStringIntern;
    [NotNullAttribute]
private Dictionary`2<IPsiSourceFile, bool> myDirtyFiles;
    [NotNullAttribute]
private HashSet`1<IPsiSourceFile> myFilesThatHadPsiAtDocumentChange;
    [NotNullAttribute]
private IPsiTransactions myPsiTransactions;
    [NotNullAttribute]
private IPsiFiles myPsiFiles;
    [NotNullAttribute]
private IPsiModules myPsiModules;
    [NotNullAttribute]
private IGeneratedDocumentsManager myGeneratedDocumentsManager;
    [NotNullAttribute]
private IPsiAssemblyFileLoader myPsiAssemblyFileLoader;
    [NotNullAttribute]
private CompactMap`2<string, Boxed`1<HybridDistinctCollection`1<TypePart>>> mySourceMembersIndex;
    [NotNullAttribute]
private DynamicInheritorsIndex mySourceInheritorsIndex;
    [NotNullAttribute]
private CompiledDynamicInheritorsIndex myCompiledInheritorsIndex;
    [NotNullAttribute]
private ForwardedTypesTable myForwardedTypesTable;
    [NotNullAttribute]
private IShellLocks myLocks;
    [NotNullAttribute]
private SolutionDeclarationsScopeCache mySolutionDeclarationsScopeCache;
    [NotNullAttribute]
private SourceTypeNamesCatalog myTypeNamesCatalog;
    [NotNullAttribute]
private CaseSensitiveSymbolScopeRequestCache mySymbolScopeRequestCache;
    [NotNullAttribute]
private CommonIdentifierIntern myCommonIdentifierIntern;
    [NotNullAttribute]
private ILanguageManager myLanguageManager;
    [NotNullAttribute]
private IEnumerable`1<IAliasProvider> myAliasProviders;
    [NotNullAttribute]
private ResolveContextManager myResolveContextManager;
    [NotNullAttribute]
private ConcurrentDictionary`2<Pair`2<IModuleReferenceResolveContext, AssemblyNameInfo>, AssemblyNameInfo> myAdjustmentCache;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myIsLoaded;
    [CompilerGeneratedAttribute]
private Action`1<TypePart> OnAfterTypePartAdded;
    [CompilerGeneratedAttribute]
private Action`1<TypePart> OnBeforeTypePartRemoved;
    [CanBeNullAttribute]
internal INamespace GlobalNamespace { get; }
    public PartsMap Parts { get; }
    public bool HasDirtyFiles { get; }
    public DataIntern`1<string> StringIntern { get; }
    public SymbolCache(Lifetime lifetime, ILogger logger, ISolution solution, IPsiCachesState psiCachesState, IPsiFiles psiFiles, IPsiModules psiModules, IPsiTransactions psiTransactions, IGeneratedDocumentsManager generatedDocumentsManager, IPsiAssemblyFileLoader psiAssemblyFileLoader, ILanguages languages, IShellLocks locks, IPersistentIndexManager persistentIndexManager, ChangeManager changeManager, SolutionDeclarationsScopeCache solutionDeclarationsScopeCache, SourceTypeNamesCatalog typeNamesCatalog, CaseSensitiveSymbolScopeRequestCache symbolScopeRequestCache, CommonIdentifierIntern commonIdentifierIntern, ILanguageManager languageManager, IEnumerable`1<IAliasProvider> aliasProviders, ResolveContextManager resolveContextManager);
    public sealed virtual ISymbolScope GetSymbolScope(LibrarySymbolScope librarySymbolScope, bool caseSensitive);
    public sealed virtual ISymbolScope GetSymbolScope(IPsiModule module, bool withReferences, bool caseSensitive);
    public sealed virtual ISymbolScope GetAlternativeNamesSymbolScope(LibrarySymbolScope librarySymbolScope);
    public sealed virtual ISymbolScope GetAlternativeNamesSymbolScope(IPsiModule module, bool withReferences);
    [NotNullAttribute]
internal IEnumerable`1<string> GetAllShortNames(bool caseSensitive, bool sorted);
    internal INamespace get_GlobalNamespace();
    [NotNullAttribute]
internal IEnumerable`1<ITypeElement> GetAllTypeElements();
    public sealed virtual void OnSandBoxPsiChange(ITreeNode elementContainingChanges);
    public sealed virtual void OnPsiChange(ITreeNode elementContainingChanges, PsiChangedElementType elementType);
    private void AddToDirty(IPsiSourceFile sourceFile, bool needCacheUpdate);
    private void BindDeclarationsOnPsiFileCreated(IPsiSourceFile sourceFile, IReadOnlyList`1<IFile> newFiles);
    public sealed virtual PartsMap get_Parts();
    private void CommitPartsTree(IPsiSourceFile sourceFile, IList`1<ProjectFilePartsTree> newPartsTrees, IList`1<PsiLanguageType> languagesToRemove, bool isRollback, bool underTransaction, bool fireEvent);
    private void RollbackTrie(CacheTrieNode root, PsiLanguageType languageType, IPsiModule psiModule, PartsTree oldTree, PartsTree newTree);
    private void UpdateTrie(CacheTrieNode root, PsiLanguageType languageType, IPsiModule psiModule, PartsTree oldTree, PartsTree newTree, bool initialLoad);
    private void BuildPartTree(IPsiSourceFile sourceFile, IList`1& newPartsTrees, IList`1& languagesToRemove);
    [CanBeNullAttribute]
private static SandBoxPartsTree BuildPartTree(SandBox sandBox);
    public sealed virtual void SyncUpdate(bool underTransaction);
    public sealed virtual void Dump(TextWriter writer, IPsiSourceFile sourceFile);
    private bool SyncUpdateCacheForFile(IPsiSourceFile sourceFile, bool isRollback, bool underTransaction, bool fireEvent);
    public sealed virtual void OnDocumentChange(IPsiSourceFile sourceFile, ProjectFileDocumentCopyChange args);
    [NotNullAttribute]
public string DumpCacheForFile(IPsiSourceFile file);
    private void BindDeclarations(IFile psiFile);
    private void BindDeclarations(IPsiSourceFile sourceFile, PsiLanguageType language);
    private void Trace(IPsiSourceFile sourceFile);
    public sealed virtual void MarkAsDirty(IPsiSourceFile sourceFile);
    public sealed virtual bool UpToDate(IPsiSourceFile sourceFile);
    private static bool UpToDatePart(IPsiSourceFile sourceFile, ProjectFilePartsTree part);
    public object Build(IPsiSourceFile sourceFile);
    public sealed virtual object Build(IPsiSourceFile sourceFile, bool isStartup);
    public sealed virtual void Merge(IPsiSourceFile sourceFile, object builtPart);
    public sealed virtual object Build(IPsiAssembly assembly);
    public sealed virtual void Merge(IPsiAssembly assembly, object part, Func`1<bool> checkForTermination);
    private void RegisterForwardedToNamespace(IClrTypeName fullName, AssemblyPsiFile file);
    private void RemoveCompiledCache(ICollection`1<AssemblyPsiFile> files);
    private void RemoveType(ICompiledTypeElement typeElement, IList`1<ICompiledTypeElement> removedTypes);
    private void BuildCacheForCompiledType(ICompiledTypeElement typeElement, AssemblyPsiFile file, CacheTrieNode root);
    public sealed virtual void Drop(IEnumerable`1<IPsiAssembly> assemblies);
    public sealed virtual void OnSandBoxCreated(SandBox sandBox);
    private void UpdateCacheForSandBox(SandBox holder);
    public sealed virtual IEnumerable`1<IDeclaredElement> GetTypesAndNamespacesInFile(IPsiSourceFile sourceFile);
    private static void CollectElementsInPart(Part part, HashSet`1<IDeclaredElement> result);
    [NotNullAttribute]
internal IEnumerable`1<CacheTrieNode> TrieNodesByShortName(string shortName, bool caseSensitive);
    public sealed virtual IReadOnlyCollection`1<ITypeElement> GetPossibleInheritors(string shortName);
    internal void UpdateTypeElementIndices(TypeElement element);
    internal void BeforeTypePartRemoved(TypePart removedPart);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnAfterTypePartAdded(Action`1<TypePart> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnAfterTypePartAdded(Action`1<TypePart> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnBeforeTypePartRemoved(Action`1<TypePart> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnBeforeTypePartRemoved(Action`1<TypePart> value);
    internal void AfterTypePartAdded(TypePart part);
    internal void UpdateTypeElementIndices(ICompiledTypeElement element);
    public sealed virtual IAttributesSet GetModuleAttributes(IPsiModule module);
    public sealed virtual IPsiAssemblyFile GetLibraryFile(IPsiAssembly assembly);
    public sealed virtual void Drop(IPsiSourceFile sourceFile);
    [NotNullAttribute]
public sealed virtual object Load(IProgressIndicator progress, bool enablePersistence);
    public sealed virtual void MergeLoaded(object data);
    public sealed virtual void Save(IProgressIndicator progress, bool enablePersistence);
    public sealed virtual bool get_HasDirtyFiles();
    private void ProcessAffectedFiles(IEnumerable`1<PsiLanguageType> psiLanguages, HashSet`1<IPsiSourceFile> affectedFiles, IPsiModule psiModule);
    [NotNullAttribute]
private IAttributesSet GetSourceModuleAttributes(IPsiModule module);
    [NotNullAttribute]
public IEnumerable`1<string> GetSourceTypeMemberNames();
    [CanBeNullAttribute]
public ILibraryMemberNamesAccess GetCompiledTypeMemberNames(IPsiAssembly assembly);
    [NotNullAttribute]
public IEnumerable`1<ITypeElement> GetSourceTypeElementsContainingMember(string name);
    [NotNullAttribute]
[ItemNotNullAttribute]
private ICollection`1<IAssemblyPsiModule> GetForwardedToAssembliesWithoutTransitives(AssemblyNameInfo fromAssemblyName, IClrTypeName clrName);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Caches.SymbolCache.SymbolCache/<GetForwardedToAssemblies>d__101")]
public sealed virtual IEnumerable`1<IAssemblyPsiModule> GetForwardedToAssemblies(AssemblyNameInfo fromAssemblyName, IClrTypeName clrName);
    private LocalList`1<IAssemblyPsiModule> GetForwardedToAssembliesWithoutTransitives(AssemblyNameInfo fromAssemblyName);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Caches.SymbolCache.SymbolCache/<GetForwardedToAssemblies>d__103")]
public sealed virtual IEnumerable`1<IAssemblyPsiModule> GetForwardedToAssemblies(AssemblyNameInfo fromAssemblyName);
    private AssemblyNameInfo GetActualAssemblyName(AssemblyNameInfo forwardedToAssembly);
    public sealed virtual AssemblyNameInfo AdjustReferencedAssemblyName(IModuleReferenceResolveContext resolveContext, AssemblyNameInfo assemblyNameInfo);
    private void ClearAdjustmentCache(object sender, BeforeAcquiringWriteLockEventArgs e);
    public sealed virtual IEnumerable`1<AssemblyNameInfo> GetForwardedFromAssemblyNames(AssemblyNameInfo assemblyNameInfo, IClrTypeName clrTypeName);
    public sealed virtual IEnumerable`1<IAssemblyPsiModule> GetForwardedFromAssemblies(ITypeElement typeElement);
    internal LocalList`1<IAssemblyPsiModule> GetForwardedFromAssembliesImpl(ITypeElement typeElement, DeclarationScopeInlineCache& inlineCache);
    public sealed virtual IEnumerable`1<IAssemblyPsiModule> GetForwardedFromAssemblies(INamespace ns);
    internal LocalList`1<IAssemblyPsiModule> GetForwardedFromAssembliesImpl(INamespace ns, DeclarationScopeInlineCache& inlineCache);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Caches.SymbolCache.SymbolCache/<GetAssembliesWithForwardedNamespace>d__112")]
public sealed virtual IEnumerable`1<IAssemblyPsiModule> GetAssembliesWithForwardedNamespace(IPsiModule originModule, INamespace ns);
    [NotNullAttribute]
public Func`2<ITypeElement, bool> GetForwardedTypeElementsFinder(IClrTypeName clrName, Func`2<IPsiModule, bool> isModuleAcceptedByScope, IModuleReferenceResolveContext moduleReferenceResolveContext);
    private bool IsForwardReachable(IAssemblyPsiModule forwardTargetModule, Func`2<AssemblyNameInfo, AssemblyNameInfo[]> forwardSourceAssembliesFilter, Func`2<IPsiModule, bool> isModuleAcceptedByScope, IModuleReferenceResolveContext moduleReferenceResolveContext);
    public sealed virtual IEnumerable`1<IClrTypeName> GetForwardedTypes(AssemblyNameInfo fromAssemblyName);
    public sealed virtual object Execute(IChangeMap changeMap);
    [NotNullAttribute]
[ItemNotNullAttribute]
private HashSet`1<IPsiSourceFile> ProcessAffectedModules(HashSet`1<IPsiModule> changedModulesToProcess);
    public void TestDump(TextWriter writer, bool onlySourceTrie);
    public void TestDumpModule(TextWriter writer, IPsiModule psiModule, Predicate`1<ITypeElement> typeElementPredicate);
    private static void DumpTrie(TextWriter builder, CacheTrieNode node, int indent, Predicate`1<CacheTrieNode> childrenPredicate, bool dumpModules);
    [NotNullAttribute]
internal ITrieCursor CreateTrieTraverser(bool caseSensitive);
    [NotNullAttribute]
public IPsiServices GetPsiServices();
    public bool IsValidAssembly(IPsiAssembly assembly);
    public sealed virtual DataIntern`1<string> get_StringIntern();
    [ConditionalAttribute("JET_MODE_ASSERT")]
internal void AssertIsWorkingRoot(PhysicalRoot root);
    [CompilerGeneratedAttribute]
private bool <Load>b__90_0();
    [CompilerGeneratedAttribute]
internal static bool <TestDump>g__Predicate|118_0(CacheTrieNode n);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Caches.SymbolCache.SymbolCacheEx : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITypeElement TryFindTypeElement(ISymbolCache symbolCache, LibrarySymbolScope librarySymbolScope);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.Caches.SymbolCache.SymbolCacheUnsafeReader : object {
    [CompilerGeneratedAttribute]
private UnsafeReader <unsafeReader>P;
    [CompilerGeneratedAttribute]
private ILanguages <languages>P;
    [CompilerGeneratedAttribute]
private ITokenIntern <intern>P;
    public SymbolCacheUnsafeReader(UnsafeReader unsafeReader, ILanguages languages, ITokenIntern intern);
    public sealed virtual PsiLanguageType ReadLanguageType();
    public sealed virtual int ReadInt();
    public sealed virtual int ReadOftenSmallPositiveInt();
    public sealed virtual ushort ReadUShort();
    public sealed virtual byte ReadByte();
    public sealed virtual bool ReadBool();
    public sealed virtual string ReadString();
    public sealed virtual String[] ReadStringArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Caches.SymbolCache.SymbolCacheUnsafeWriter : object {
    [CompilerGeneratedAttribute]
private UnsafeWriter <unsafeWriter>P;
    public SymbolCacheUnsafeWriter(UnsafeWriter unsafeWriter);
    public sealed virtual void WriteLanguageType(PsiLanguageType languageType);
    public sealed virtual void WriteInt(int value);
    public sealed virtual void WriteOftenSmallPositiveInt(int value);
    public sealed virtual void WriteUShort(ushort value);
    public sealed virtual void WriteByte(byte value);
    public sealed virtual void WriteBool(bool value);
    public sealed virtual void WriteString(string value);
    public sealed virtual void WriteStringArray(String[] array);
}
public abstract class JetBrains.ReSharper.Psi.Caches.SymbolCache.SymbolScopeBase : object {
    [NotNullAttribute]
private IPsiModules myPsiModules;
    private Dictionary`2<IPsiAssembly, ILibraryMemberNamesAccess> myLibraryMemberNamesAccesses;
    [CompilerGeneratedAttribute]
private CacheTrieNode <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolCache <SymbolCache>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclarationsScope <Scope>k__BackingField;
    [NotNullAttribute]
protected CacheTrieNode Root { get; }
    [NotNullAttribute]
protected SymbolCache SymbolCache { get; }
    [NotNullAttribute]
internal IDeclarationsScope Scope { get; }
    public INamespace GlobalNamespace { get; }
    protected SymbolScopeBase(IPsiModules psiModules, IDeclarationsScope scope, SymbolCache symbolCache, CacheTrieNode trieRoot);
    [CompilerGeneratedAttribute]
protected CacheTrieNode get_Root();
    [CompilerGeneratedAttribute]
protected SymbolCache get_SymbolCache();
    [CompilerGeneratedAttribute]
internal IDeclarationsScope get_Scope();
    public sealed virtual INamespace get_GlobalNamespace();
    public sealed virtual bool Contains(ITypeElement typeElement);
    public sealed virtual INamespace GetNamespace(string fullyQualifiedName);
    public sealed virtual ITypeElement[] GetTypeElementsByCLRName(string clrName);
    public abstract virtual ITypeElement[] GetTypeElementsByCLRName(IClrTypeName clrTypeName);
    [NotNullAttribute]
public ITypeElement[] GetTypeElementsByClrNameInternal(ITrieCursor node, DeclarationsScopeBase scope, IClrTypeName clrTypeName);
    [NotNullAttribute]
protected ITypeElement[] GetTypeElementsByClrNameInternal(IClrTypeName clrTypeName);
    public sealed virtual ICollection`1<IClrDeclaredElement> GetElementsByQualifiedName(string qualifiedName);
    public sealed virtual IEnumerable`1<IClrDeclaredElement> GetElementsAtQualifiedName(string qualifiedName);
    public sealed virtual IClrDeclaredElement[] GetElementsByShortName(string shortName);
    public sealed virtual IEnumerable`1<string> GetAllShortNamesSorted();
    public sealed virtual IEnumerable`1<string> GetAllShortNames();
    [NotNullAttribute]
protected abstract virtual IEnumerable`1<string> GetAllShortNames(bool sorted);
    [NotNullAttribute]
protected abstract virtual IEnumerable`1<CacheTrieNode> GetTrieNodesByShortName(string shortName);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Caches.SymbolCache.SymbolScopeBase/<GetVisibleElementsFromTrieNode>d__27")]
[NotNullAttribute]
[ItemNotNullAttribute]
protected IEnumerable`1<IClrDeclaredElement> GetVisibleElementsFromTrieNode(CacheTrieNode trieNode);
    protected abstract virtual void ConsumeVisibleElementsFromTrieNode(CacheTrieNode trieNode, FrugalLocalHashSet`1& result);
    public sealed virtual ITypeElement GetTypeElementByCLRName(string clrName);
    public abstract virtual ITypeElement GetTypeElementByCLRName(IClrTypeName clrTypeName);
    [CanBeNullAttribute]
protected ITypeElement GetTypeElementByCLRNameInternal(IClrTypeName clrTypeName);
    public sealed virtual ICollection`1<ITypeElement> GetPossibleInheritors(string shortTypeName);
    [NotNullAttribute]
protected abstract virtual IReadOnlyCollection`1<ITypeElement> GetAllPossibleInheritors(string shortName);
    [NotNullAttribute]
protected abstract virtual ITrieCursor CreateTraverser();
    [CanBeNullAttribute]
private ILibraryMemberNamesAccess GetLibraryMemberNamesAccess(IPsiAssembly assembly);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Caches.SymbolCache.SymbolScopeBase/<GetAllTypeMemberNames>d__36")]
public sealed virtual IEnumerable`1<string> GetAllTypeMemberNames();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Caches.SymbolCache.SymbolScopeBase/<GetAllTypeElementsGroupedByName>d__37")]
public sealed virtual IEnumerable`1<ITypeElement> GetAllTypeElementsGroupedByName();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Caches.SymbolCache.SymbolScopeBase/<GetSourceMembers>d__38")]
public sealed virtual IEnumerable`1<ITypeMember> GetSourceMembers(string name, Func`2<ITypeElement, bool> containingTypesFilter);
    public sealed virtual IEnumerable`1<ITypeMember> GetSourceMembers(string name);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Caches.SymbolCache.SymbolScopeBase/<GetCompiledMembers>d__40")]
public sealed virtual IEnumerable`1<ITypeMember> GetCompiledMembers(string name);
    public virtual bool Accepts(CacheTrieNode trieNode, ITypeElement typeElement);
    protected abstract virtual INamespace GetNamespace(CacheTrieNode trieNode);
}
internal class JetBrains.ReSharper.Psi.Caches.SymbolCache.TrieAdder : TrieAdderBase {
    private SourceTypeNamesCatalog myTypeNamesCatalog;
    public TrieAdder(PartsTree oldTree, CacheTrieNode root, bool caseSensitive, SourceTypeNamesCatalog typeNamesCatalog);
    protected virtual void ProcessTypePart(ITrieView view, TypePart part);
    protected virtual void ProcessNamespacePart(NamespacePart namespacePart, ITrieView view);
}
internal abstract class JetBrains.ReSharper.Psi.Caches.SymbolCache.TrieAdderBase : object {
    private PartsTree myOldTree;
    private bool myCaseSensitive;
    private bool myIsPhysical;
    private Dictionary`2<Part, int> myDepthFirstIndex;
    private ITrieCursor myCursor;
    private FrugalLocalHashSet`1<TypePart> myTakenOldTreeTypeParts;
    protected TrieAdderBase(PartsTree oldTree, CacheTrieNode root, bool caseSensitive);
    public void Process(PartsTree partsTree);
    private void Process(Part part);
    protected abstract virtual void ProcessTypePart(ITrieView view, TypePart part);
    protected abstract virtual void ProcessNamespacePart(NamespacePart namespacePart, ITrieView view);
    protected void CreateAndAddTypeElement(ITrieView node, TypePart part);
    [CanBeNullAttribute]
private TypeElement TryFindTypeElementToMergeWithInSandBox(TypePart part);
    [CanBeNullAttribute]
private TypeElement TryFindTypeElementToMergeWith(IEnumerable`1<ITypeElement> types, TypePart part);
    private bool IsFromOldTree(TypePart otherPart);
    private static bool IsFileLocalTypePart(TypePart part);
    private static bool CheckTypeParameters(TypePart part, TypeElement typeElement);
    private bool AreAllPartsFromOldTree(TypeElement typeElement);
    private bool IsPartFromFile(TypePart otherPart, IPsiSourceFile sourceFile);
    private bool IsFromSameFile(TypePart part, TypePart otherPart);
}
internal class JetBrains.ReSharper.Psi.Caches.SymbolCache.TrieRemover : object {
    private SourceTypeNamesCatalog myTypeNamesCatalog;
    private bool myRemoveReferencesFromDeclarations;
    public TrieRemover(SourceTypeNamesCatalog typeNamesCatalog, bool removeReferencesFromDeclarations);
    public void Process(PartsTree partsTree);
    private void VisitTypePart(TypePart part);
    private void VisitNamespacePart(NamespacePart part);
}
internal class JetBrains.ReSharper.Psi.Caches.SymbolCache.TrieRollback : TrieAdderBase {
    private SourceTypeNamesCatalog myTypeNamesCatalog;
    public TrieRollback(PartsTree oldTree, CacheTrieNode root, bool caseSensitive, SourceTypeNamesCatalog typeNamesCatalog);
    protected virtual void ProcessNamespacePart(NamespacePart namespacePart, ITrieView view);
    protected virtual void ProcessTypePart(ITrieView view, TypePart part);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Caches.SymbolCache.TypeElementOrigin : Enum {
    public int value__;
    public static TypeElementOrigin None;
    public static TypeElementOrigin Source;
    public static TypeElementOrigin Compiled;
    public static TypeElementOrigin Any;
}
public class JetBrains.ReSharper.Psi.Caches.SymbolCache.TypeMembersBucket : object {
    [NotNullAttribute]
private CompactOneToListMap`2<TreeOffset, CachedTypeMemberBase> myOffsetToMembers;
    [NotNullAttribute]
private Dictionary`2<CachedTypeMemberBase, TreeOffset> myMembers;
    [CompilerGeneratedAttribute]
private byte <CreationReason>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UpdateCachesInProgress>k__BackingField;
    public byte CreationReason { get; }
    public long Timestamp { get; }
    internal bool UpdateCachesInProgress { get; internal set; }
    public bool IsEmpty { get; }
    public TypeMembersBucket(long timestamp, byte createReason);
    [CompilerGeneratedAttribute]
public byte get_CreationReason();
    [CompilerGeneratedAttribute]
public long get_Timestamp();
    [CompilerGeneratedAttribute]
internal bool get_UpdateCachesInProgress();
    [CompilerGeneratedAttribute]
internal void set_UpdateCachesInProgress(bool value);
    public void Add(CachedTypeMemberBase member, TreeOffset offset);
    [PureAttribute]
public bool Contains(CachedTypeMemberBase member);
    [NotNullAttribute]
public IEnumerable`1<KeyValuePair`2<CachedTypeMemberBase, TreeOffset>> Members();
    [NotNullAttribute]
public IEnumerable`1<CachedTypeMemberBase> Members(TreeOffset offset);
    public bool get_IsEmpty();
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Caches.SymbolCache.TypeMembersCache : object {
    [NotNullAttribute]
private HashSet`1<IPsiSourceFile> myDirtySourceFiles;
    [NotNullAttribute]
private object myNonPhysicalSyncRoot;
    [NotNullAttribute]
private ReaderWriterLockSlim myReadWriterLock;
    [NotNullAttribute]
private ILogger myLogger;
    [NotNullAttribute]
private IPsiTransactions myPsiTransactions;
    [NotNullAttribute]
private IPsiFiles myPsiFiles;
    private bool JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.HasDirtyFiles { get; }
    public TypeMembersCache(Lifetime lifetime, ILogger logger, IPsiTransactions psiTransactions, IPsiFiles psiFiles);
    private void RollbackTransaction(IPsiTransaction transaction);
    private sealed virtual override object JetBrains.ReSharper.Psi.Caches.ICache.Load(IProgressIndicator progress, bool enablePersistence);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.ICache.MergeLoaded(object data);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.ICache.Save(IProgressIndicator progress, bool enablePersistence);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.get_HasDirtyFiles();
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.OnPsiChange(ITreeNode elementContainingChanges, PsiChangedElementType type);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.Drop(IPsiSourceFile sourceFile);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.Merge(IPsiSourceFile sourceFile, object builtPart);
    private sealed virtual override object JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.Build(IPsiSourceFile sourceFile, bool isStartup);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.OnDocumentChange(IPsiSourceFile sourceFile, ProjectFileDocumentCopyChange change);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.MarkAsDirty(IPsiSourceFile sourceFile);
    private sealed virtual override bool JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.UpToDate(IPsiSourceFile sourceFile);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.SyncUpdate(bool underTransaction);
    public sealed virtual void Dump(TextWriter writer, IPsiSourceFile sourceFile);
    private bool UpdateCacheForProjectFile(IPsiSourceFile sourceFile, bool fromRollback);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.IPsiSourceFileInvalidatingCache.Invalidate(IEnumerable`1<IPsiSourceFile> sourceFiles);
    private void Invalidate(IPsiSourceFile sourceFile);
    private static void BindMembersOnPsiFileCreated(IPsiSourceFile sourceFile, IReadOnlyList`1<IFile> newFiles);
    public static void BindDeclarationsToExistingMembers(IPsiSourceFile sourceFile, IReadOnlyList`1<IFile> newFiles);
    private void ResurrectTypeMembersFromCachedPsiFiles(IPsiSourceFile sourceFile);
    private static void InvalidateCachedDeclaredElements(IEnumerable`1<IFile> cachedPsiFiles);
    [NotNullAttribute]
internal static object GetBucketLock(IPsiSourceFile sourceFile);
    [CanBeNullAttribute]
internal static TypeMembersBucket GetBucket(IPsiSourceFile sourceFile);
    private static void SetBucket(IPsiSourceFile sourceFile, TypeMembersBucket bucket);
    public sealed virtual IDeclaredElement GetOrCreateDeclaredElement(TDeclaration declaration, Func`2<TDeclaration, IDeclaredElement> factory);
    [CanBeNullAttribute]
private static IDeclaredElement CreateDeclaredElement(TDeclaration declaration, Func`2<TDeclaration, IDeclaredElement> factory, TreeOffset offset);
    [CanBeNullAttribute]
private static IDeclaredElement TryGetElementFromBucket(TDeclaration declaration, TreeOffset offset);
}
internal class JetBrains.ReSharper.Psi.Caches.SymbolCache.WalkingStack : object {
    private Stack`1<SlimHashSet`1<string>> myStack;
    public void Enter();
    [CanBeNullAttribute]
public SlimHashSet`1<string> Leave();
    public void AddMemberName(string name);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Caches.SymbolCacheExtension : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<IAssemblyPsiModule> GetForwardedToAssemblies(ISymbolCache cache, IPsiModule fromModule, IClrTypeName clrName);
}
public enum JetBrains.ReSharper.Psi.Caches.UpdateProjectFilesJobSource : Enum {
    public int value__;
    public static UpdateProjectFilesJobSource OnLoad;
    public static UpdateProjectFilesJobSource UpdateBackground;
    public static UpdateProjectFilesJobSource UpdateOnChange;
}
public class JetBrains.ReSharper.Psi.Caches.UpdateProjectFilesStatistics : object {
    private ISolution mySolution;
    private Nullable`1<UpdateProjectFilesJobSource> mySource;
    private IndexingPerformanceCollector myCollector;
    private static object ourLock;
    private static long ourNextStatisticsId;
    private long myId;
    private Stopwatch myTotalWallWatch;
    private Stopwatch myUpdateWatch;
    private long myPsiBuildTicks;
    private long myMergeTicks;
    private int myPsiBuildItems;
    private int myMergeItems;
    public UpdateProjectFilesStatistics(ISolution solution, Nullable`1<UpdateProjectFilesJobSource> source, IndexingPerformanceCollector collector);
    private static UpdateProjectFilesStatistics();
    public void RegisterUpdateStart();
    public void RegisterUpdateStop();
    public void RegisterJobDone(bool terminated);
    public void RegisterPsiBuilt(long ticks);
    public void RegisterMerge(long ticks);
}
public abstract class JetBrains.ReSharper.Psi.CachingLexers.CachingLexerService : object {
    private DocumentManager myDocumentManager;
    private IPsiModules myPsiModules;
    protected CachingLexerService(DocumentManager documentManager, IPsiModules psiModules);
    [ObsoleteAttribute("Inject CachingLexerService")]
public static CachingLexerService GetInstance(ISolution solution);
    [CanBeNullAttribute]
public CachingLexer GetCachingLexer(ITextControl textControl);
    public abstract virtual CachingLexer GetCachingLexer(ITextControl textControl, IPsiSourceFile sourceFile);
    public abstract virtual CachingLexer GetCachingLexer(ITextControl textControl, ProjectFileType projectFileType);
    public abstract virtual object Execute(IChangeMap changeMap);
}
[SolutionComponentAttribute("10")]
internal class JetBrains.ReSharper.Psi.CachingLexers.CachingLexerServiceImpl : CachingLexerService {
    private static int CacheSize;
    private static Key`1<DocumentUpdatesAccumulator> ourDocumentUpdatesAccumulator;
    private static Key`1<ProjectFileType> ourProjectFileType;
    private WeakCollection`1<ITextControl> myEditorsWithLexers;
    private object myLock;
    private ISolution mySolution;
    private DocumentManager myDocumentManager;
    private DocumentChangeManager myDocumentChangeManager;
    private PsiProjectFileTypeCoordinator myPsiProjectFileTypeCoordinator;
    private ILanguageManager myLanguageManager;
    public CachingLexerServiceImpl(Lifetime lifetime, ISolution solution, DocumentManager documentManager, ChangeManager changeManager, DocumentChangeManager documentChangeManager, PsiProjectFileTypeCoordinator psiProjectFileTypeCoordinator, ILanguageManager languageManager, IPsiModules psiModules);
    private static CachingLexerServiceImpl();
    [CanBeNullAttribute]
private ICustomCachingLexerService GetCustomService(ITextControl textControl, ProjectFileType projectFileType);
    public virtual object Execute(IChangeMap changeMap);
    private void DropLexerFor(IProjectFile projectFile);
    [CanBeNullAttribute]
private CachingLexer GetCachingLexerImpl(ITextControl textControl, ProjectFileType projectFileType, IPsiSourceFile sourceFile);
    public virtual CachingLexer GetCachingLexer(ITextControl textControl, IPsiSourceFile sourceFile);
    public virtual CachingLexer GetCachingLexer(ITextControl textControl, ProjectFileType projectFileType);
    private void DropLexerFor(ITextControl first, ProjectFileType projectFileType);
}
public interface JetBrains.ReSharper.Psi.CachingLexers.ICustomCachingLexerService {
    public abstract virtual CachingLexer Resync(ISolution solution, DocumentUpdatesAccumulator updatesAccumulator, ProjectFileType projectFileType, ITextControl textControl, PsiProjectFileTypeCoordinator projectFileTypeCoordinator, IPsiSourceFile sourceFile);
    [CanBeNullAttribute]
public abstract virtual CachingLexer CreateCachingLexer(ISolution solution, ProjectFileType projectFileType, ITextControl textControl, PsiProjectFileTypeCoordinator projectFileTypeCoordinator, IPsiSourceFile sourceFile);
    public abstract virtual void Drop(ITextControl textControl);
}
public class JetBrains.ReSharper.Psi.CachingLexers.MixedCachingLexerService : UniversalCachingLexerService {
    private static Key`1<MixedLexer> ourCodeBehindLexerKey;
    private static MixedCachingLexerService();
    public virtual CachingLexer Resync(ISolution solution, DocumentUpdatesAccumulator updatesAccumulator, ProjectFileType projectFileType, ITextControl textControl, PsiProjectFileTypeCoordinator projectFileTypeCoordinator, IPsiSourceFile sourceFile);
    public virtual CachingLexer CreateCachingLexer(ISolution solution, ProjectFileType projectFileType, ITextControl textControl, PsiProjectFileTypeCoordinator projectFileTypeCoordinator, IPsiSourceFile sourceFile);
    public virtual void Drop(ITextControl textControl);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.KnownLanguage", "16")]
public class JetBrains.ReSharper.Psi.CachingLexers.UniversalCachingLexerService : object {
    private static Key`1<TokenBuffer> ourTokenBufferKey;
    private static UniversalCachingLexerService();
    public virtual CachingLexer Resync(ISolution solution, DocumentUpdatesAccumulator updatesAccumulator, ProjectFileType projectFileType, ITextControl textControl, PsiProjectFileTypeCoordinator projectFileTypeCoordinator, IPsiSourceFile sourceFile);
    protected static TokenBuffer GetTokenBuffer(ITextControl textControl);
    protected static CachingLexer Resync(ITextControl textControl, Func`1<TokenBuffer> action);
    public virtual CachingLexer CreateCachingLexer(ISolution solution, ProjectFileType projectFileType, ITextControl textControl, PsiProjectFileTypeCoordinator projectFileTypeCoordinator, IPsiSourceFile sourceFile);
    protected static CachingLexer CreateTokenBufferFromLexer(ITextControl textControl, ILexer lexer);
    public virtual void Drop(ITextControl textControl);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CallingConvention : ValueType {
    [CanBeNullAttribute]
private IReadOnlyList`1<string> mySortedUnmanagedCallingConventions;
    public static CallingConvention Managed;
    public bool IsUnmanaged { get; }
    [NotNullAttribute]
public IReadOnlyList`1<string> UnmanagedCallingConventions { get; }
    private CallingConvention(IReadOnlyList`1<string> unmanagedCallingConventions);
    private static CallingConvention();
    public bool get_IsUnmanaged();
    public IReadOnlyList`1<string> get_UnmanagedCallingConventions();
    [PureAttribute]
public static CallingConvention Unmanaged(IReadOnlyList`1<string> unmanagedCallingConventions);
    [PureAttribute]
public static CallingConvention Unmanaged();
    public sealed virtual bool Equals(CallingConvention other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.ClrConstantValueFactory : object {
    [PureAttribute]
public static ConstantValue CreatePureNullValue(IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateSbyteValue(sbyte x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateByteValue(byte x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateShortValue(short x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateUshortValue(ushort x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateIntValue(int x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateUintValue(UInt32 x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateLongValue(long x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateUlongValue(ulong x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateDecimalValue(decimal x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateFloatValue(float x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateDoubleValue(double x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateCharValue(char x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateBoolValue(bool x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateStringValue(string x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateNintValue(int x, IPsiModule module);
    [PureAttribute]
public static ConstantValue CreateNuintValue(UInt32 x, IPsiModule module);
    [PureAttribute]
public static ConstantValue Create(object value, IType type);
    [PureAttribute]
public static ConstantValue CreateDefaultValue(IType type);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.KnownLanguage", "16")]
public class JetBrains.ReSharper.Psi.ClrConstantValuePresenter : object {
    public virtual RichText Present(PsiLanguageType language, ConstantValue constantValue, TypePresentationStyle typePresentationStyle);
    [NotNullAttribute]
[PureAttribute]
private static string PresentChar(char character);
    public sealed virtual string Present(ConstantValue constantValue);
    [PureAttribute]
protected string FixFormattable(string formattable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[LanguageAttribute("JetBrains.ReSharper.Psi.KnownLanguage", "16")]
public class JetBrains.ReSharper.Psi.ClrConstantValueService : object {
    [CompilerGeneratedAttribute]
private IConstantValuePresenter <Presenter>k__BackingField;
    public IConstantValuePresenter Presenter { get; }
    public ClrConstantValueService(IConstantValuePresenter constantValuePresenter);
    [CompilerGeneratedAttribute]
public sealed virtual IConstantValuePresenter get_Presenter();
    public virtual ConstantValue GetDefaultValue(IType type);
    public virtual bool IsLegalConstantType(IType type);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ClrDeclaredElementExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static ISubstitution GetIdSubstitutionSafe(IDeclaredElement declaredElement);
}
public class JetBrains.ReSharper.Psi.CLRDeclaredElementType : DeclaredElementTypeBase {
    [NotNullAttribute]
public static DeclaredElementType NAMESPACE;
    [NotNullAttribute]
public static DeclaredElementType CLASS;
    [NotNullAttribute]
public static DeclaredElementType INTERFACE;
    [NotNullAttribute]
public static DeclaredElementType STRUCT;
    [NotNullAttribute]
public static DeclaredElementType ENUM;
    [NotNullAttribute]
public static DeclaredElementType DELEGATE;
    [NotNullAttribute]
public static DeclaredElementType CONSTRUCTOR;
    [NotNullAttribute]
public static DeclaredElementType FIELD;
    [NotNullAttribute]
public static DeclaredElementType CONSTANT;
    [NotNullAttribute]
public static DeclaredElementType ENUM_MEMBER;
    [NotNullAttribute]
public static DeclaredElementType EVENT;
    [NotNullAttribute]
public static DeclaredElementType PROPERTY;
    [NotNullAttribute]
public static DeclaredElementType METHOD;
    [NotNullAttribute]
public static DeclaredElementType SIGN_OPERATOR;
    [NotNullAttribute]
public static DeclaredElementType CONVERSION_OPERATOR;
    [NotNullAttribute]
public static DeclaredElementType PARAMETER;
    [NotNullAttribute]
public static DeclaredElementType TYPE_PARAMETER;
    [NotNullAttribute]
public static DeclaredElementType LABEL;
    [NotNullAttribute]
public static DeclaredElementType LOCAL_VARIABLE;
    [NotNullAttribute]
public static DeclaredElementType LOCAL_CONSTANT;
    [NotNullAttribute]
public static DeclaredElementType MODULE;
    [NotNullAttribute]
public static DeclaredElementType TUPLE_COMPONENT;
    protected internal IDeclaredElementPresenter DefaultPresenter { get; }
    private CLRDeclaredElementType(string name, IconId imageName);
    private static CLRDeclaredElementType();
    protected internal virtual IDeclaredElementPresenter get_DefaultPresenter();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ClrTypeConstraintsVerifier : object {
    [NullableAttribute("1")]
public static ClrTypeConstraintsVerifier Instance;
    private static ClrTypeConstraintsVerifier();
    [NullableContextAttribute("1")]
public virtual TypeArgumentValidationResult ValidateTypeArgument(ITypeParameter typeParameter, ISubstitution constraintsSubstitution, IType typeArgument, bool isExplicitTypeArgument);
    [NullableContextAttribute("1")]
public virtual TypeArgumentValidationResult ValidateTypeCanBeUsedAsTypeArgument(IType typeArgument, bool allowByRefLikeType);
    public virtual bool SatisfiesReferenceTypeConstraint(IType typeArgument);
    public virtual bool SatisfiesValueTypeConstraint(IDeclaredType typeArgument);
    public virtual bool SatisfiesUnmanagedTypeConstraint(IDeclaredType typeArgument);
    public virtual bool SatisfiesDefaultConstructorConstraint(IDeclaredType typeArgument);
    public virtual bool SatisfiesSuperTypeConstraint(IType typeArgument, IType superType);
    [NullableContextAttribute("1")]
private static bool SatisfiesSuperTypeConstraint(IType argumentType, IType superType, HashSet`1<IType> visited);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Psi.CodeAnnotations.<SimpleCodeAnnotationProvider>F35126B1363F2A0327772AEB9481F1133895282A555CA0F6928A6BA254FE8F60C__Packed32BitAnnotationProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, UInt32> {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, int> <attributeShortNameToIndexMap>P;
    public <SimpleCodeAnnotationProvider>F35126B1363F2A0327772AEB9481F1133895282A555CA0F6928A6BA254FE8F60C__Packed32BitAnnotationProvider(Dictionary`2<string, int> attributeShortNameToIndexMap, AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    protected virtual UInt32 CalculateInfo(IAttributesOwner attributesOwner, IAttributeInstanceCollection attributesInstanceCollection);
    protected virtual UInt32 CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    [NullableContextAttribute("2")]
protected virtual UInt32 GetDefaultInfo(IAttributesOwner attributesOwner);
    public sealed virtual bool GetInfo(IAttributesOwner attributesOwner, int index);
    [CompilerGeneratedAttribute]
private void <CalculateInfo>g__AddFlagIfMatches|2_0(IAttributeInstance attributeInstance, <>c__DisplayClass2_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Psi.CodeAnnotations.<SimpleCodeAnnotationProvider>F35126B1363F2A0327772AEB9481F1133895282A555CA0F6928A6BA254FE8F60C__Packed64BitAnnotationProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, ulong> {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, int> <attributeShortNameToIndexMap>P;
    public <SimpleCodeAnnotationProvider>F35126B1363F2A0327772AEB9481F1133895282A555CA0F6928A6BA254FE8F60C__Packed64BitAnnotationProvider(Dictionary`2<string, int> attributeShortNameToIndexMap, AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    protected virtual ulong CalculateInfo(IAttributesOwner attributesOwner, IAttributeInstanceCollection attributesInstanceCollection);
    protected virtual ulong CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    [NullableContextAttribute("2")]
protected virtual ulong GetDefaultInfo(IAttributesOwner attributesOwner);
    public sealed virtual bool GetInfo(IAttributesOwner attributesOwner, int index);
    [CompilerGeneratedAttribute]
private void <CalculateInfo>g__AddFlagIfMatches|2_0(IAttributeInstance attributeInstance, <>c__DisplayClass2_0& );
}
[CodeAnnotationProviderAttribute("16")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.AspDefaultRouteValuesAnnotationProvider : SimpleCodeAnnotationProvider {
}
[CodeAnnotationProviderAttribute("16")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.AspRouteOrderAnnotationProvider : SimpleCodeAnnotationProvider {
}
[CodeAnnotationProviderAttribute("16")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.AspRouteValuesConstraintsAnnotationProvider : SimpleCodeAnnotationProvider {
}
[CodeAnnotationProviderAttribute("16")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.AspRouteVerbsAnnotationProvider : SimpleCodeAnnotationProvider {
}
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.AssertionConditionAnnotationProvider : CodeAnnotationInfoProvider`2<IParameter, Nullable`1<AssertionConditionType>> {
    public static string AssertionConditionAttributeShortName;
    public AssertionConditionAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static AssertionConditionAnnotationProvider();
    protected virtual Nullable`1<AssertionConditionType> CalculateInfo(IParameter attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    protected virtual Nullable`1<AssertionConditionType> GetDefaultInfo(IParameter attributesOwner);
}
[CodeAnnotationProviderAttribute("16")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.AssertionMethodAnnotationProvider : SimpleCodeAnnotationProvider {
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.AttributeInstanceCollection : object {
    [NotNullAttribute]
public static AttributeInstanceCollection Empty;
    [NotNullAttribute]
[ItemNotNullAttribute]
private IReadOnlyList`1<IAttributeInstance> mySelfAttributes;
    [NotNullAttribute]
[ItemNotNullAttribute]
private IReadOnlyList`1<IAttributeInstance> myInheritedAttributes;
    [NotNullAttribute]
[ItemNotNullAttribute]
private IReadOnlyList`1<IAttributeInstance> myRelatedAttributes;
    [NotNullAttribute]
[ItemNotNullAttribute]
private IReadOnlyList`1<IAttributeInstance> myReturnTypeAttributes;
    [NotNullAttribute]
[ItemNotNullAttribute]
private IReadOnlyList`1<IAttributeInstance> myInheritedReturnTypeAttributes;
    public bool IsEmpty { get; }
    public IEnumerable`1<IAttributeInstance> Item { get; }
    private AttributeInstanceCollection(IReadOnlyList`1<IAttributeInstance> selfAttributes, IReadOnlyList`1<IAttributeInstance> inheritedAttributes, IReadOnlyList`1<IAttributeInstance> relatedAttributes, IReadOnlyList`1<IAttributeInstance> returnTypeAttributes, IReadOnlyList`1<IAttributeInstance> inheritedReturnTypeAttributes);
    private static AttributeInstanceCollection();
    [NotNullAttribute]
public static AttributeInstanceCollection Create(IReadOnlyList`1<IAttributeInstance> selfAttributes, IReadOnlyList`1<IAttributeInstance> inheritedAttributes, IReadOnlyList`1<IAttributeInstance> relatedAttributes, IReadOnlyList`1<IAttributeInstance> returnTypeAttributes, IReadOnlyList`1<IAttributeInstance> inheritedReturnTypeAttributes);
    public sealed virtual bool get_IsEmpty();
    public sealed virtual IEnumerable`1<IAttributeInstance> get_Item(AttributeInstancesSource source);
    public sealed virtual IEnumerable`1<IAttributeInstance> GetAllOwnAttributes();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CodeAnnotations.AttributeInstanceCollection/<IterateAllMatchingAttributes>d__13")]
[NotNullAttribute]
[ItemNotNullAttribute]
private IEnumerable`1<IAttributeInstance> IterateAllMatchingAttributes(AttributeInstancesSource source);
}
[PsiComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.AttributeInstancesProvider : InvalidatingPsiCache {
    [CompilerGeneratedAttribute]
private IEnumerable`1<ICustomCodeAnnotationProvider> <customProviders>P;
    private static int MAX_ELEMENTS_IN_COMPILED_CACHE;
    private static int MAX_ELEMENTS_IN_SOURCE_CACHE;
    private SynchronizedSet`1<ICompiledElement> myCompiledElementsNoAttributesCache;
    private LazyForkedContentModelData`1<SynchronizedSet`1<IAttributesOwner>> mySourceElementsNotAttributesCache;
    public AttributeInstancesProvider(IEnumerable`1<ICustomCodeAnnotationProvider> customProviders);
    [NotNullAttribute]
public IAttributeInstanceCollection GetAndProcessAttributeInstances(IAttributesOwner attributesOwner, IAttributeInstancesConsumer requestor);
    [NotNullAttribute]
public IAttributeInstanceCollection GetAttributeInstances(IAttributesOwner attributesOwner);
    private void AddToNoAttributesCache(IAttributesOwner attributesOwner);
    protected virtual void InvalidateOnPhysicalChange(PsiChangedElementType elementType);
    private bool IsInNoAttributesCache(IAttributesOwner attributesOwner);
    [CompilerGeneratedAttribute]
internal static IReadOnlyList`1<IAttributeInstance> <GetAttributeInstances>g__CollectAttributes|7_0(AttributesSource attributesSource, <>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<IReadOnlyList`1<IAttributeInstance>, IReadOnlyList`1<IAttributeInstance>> <GetAttributeInstances>g__CollectReturnTypeAttributes|7_1(IAttributesOwner attributesOwner);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CodeAnnotations.AttributeInstancesSource : Enum {
    public int value__;
    public static AttributeInstancesSource Self;
    public static AttributeInstancesSource Inherited;
    public static AttributeInstancesSource Related;
    public static AttributeInstancesSource AllOwn;
    public static AttributeInstancesSource Return;
    public static AttributeInstancesSource InheritedReturn;
    public static AttributeInstancesSource AllReturn;
}
internal class JetBrains.ReSharper.Psi.CodeAnnotations.AttributeInstanceWithCachedShortName : object {
    private IAttributeInstance myAttributeInstance;
    private string myShortName;
    public IConstructor Constructor { get; }
    public int PositionParameterCount { get; }
    public int NamedParameterCount { get; }
    public AttributeInstanceWithCachedShortName(IAttributeInstance attributeInstance);
    public sealed virtual IClrTypeName GetClrName();
    public sealed virtual string GetAttributeShortName();
    public sealed virtual IDeclaredType GetAttributeType();
    public sealed virtual IConstructor get_Constructor();
    public sealed virtual int get_PositionParameterCount();
    public sealed virtual AttributeValue PositionParameter(int paramIndex);
    public sealed virtual IEnumerable`1<AttributeValue> PositionParameters();
    public sealed virtual int get_NamedParameterCount();
    public sealed virtual AttributeValue NamedParameter(string name);
    public sealed virtual IEnumerable`1<Pair`2<string, AttributeValue>> NamedParameters();
}
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.BaseTypeRequiredAnnotationProvider : CodeAnnotationInfoProvider`2<ITypeElement, IType[]> {
    public static string BaseTypeRequiredAttributeShortName;
    public BaseTypeRequiredAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static BaseTypeRequiredAnnotationProvider();
    protected virtual IType[] CalculateInfo(ITypeElement attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    protected virtual IType[] GetDefaultInfo(ITypeElement attributesOwner);
    public IEnumerable`1<IType> GetRequiredBaseTypes(IAttributeInstance instance);
}
[CodeAnnotationProviderAttribute("16")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.CannotApplyEqualityOperatorAnnotationProvider : SimpleCodeAnnotationProvider {
}
public abstract class JetBrains.ReSharper.Psi.CodeAnnotations.CodeAnnotationComplexInfoProvider`3 : CodeAnnotationInfoProviderBase`2<TAttributesOwner, Pair`2<TResult1, TResult2>> {
    protected CodeAnnotationComplexInfoProvider`3(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration, bool shouldProvideInlayHints);
    public virtual TResult1 GetInfo(TAttributesOwner attributesOwner, TResult2& additionalInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class JetBrains.ReSharper.Psi.CodeAnnotations.CodeAnnotationInfoProvider`2 : CodeAnnotationInfoProviderBase`2<TAttributesOwner, TResult> {
    protected CodeAnnotationInfoProvider`2(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration, bool shouldProvideInlayHints);
    public virtual TResult GetInfo(TAttributesOwner attributesOwner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.CodeAnnotations.CodeAnnotationInfoProviderBase`2 : object {
    private static int MAX_SIZE_OF_CACHE;
    private AttributeInstancesProvider myAttributeInstancesProvider;
    private CodeAnnotationsConfiguration myCodeAnnotationsConfiguration;
    private bool myShouldProvideInlayHints;
    private DirectMappedCache`2<TAttributesOwner, TResult> myCompiledElementsCache;
    private LazyForkedContentModelData`1<DirectMappedCache`2<TAttributesOwner, TResult>> mySourceElementsCache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private DirectMappedCache`2<TAttributesOwner, string> myCompiledElementsDescriptionsCache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private LazyForkedContentModelData`1<DirectMappedCache`2<TAttributesOwner, string>> mySourceElementsDescriptionsCache;
    protected CodeAnnotationInfoProviderBase`2(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration, bool shouldProvideInlayHints);
    protected virtual TResult GetInfoInternal(TAttributesOwner attributesOwner);
    private TResult GetInfoFromTreeNode(TAttributesOwner attributesOwner);
    protected abstract virtual TResult CalculateInfo(TAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    protected abstract virtual TResult GetDefaultInfo(TAttributesOwner attributesOwner);
    protected virtual bool Accepts(IAttributesOwner attributesOwner);
    protected virtual bool ComputeWithoutAttributes();
    protected virtual TResult CalculateInfo(TAttributesOwner attributesOwner, IAttributeInstanceCollection attributesInstanceCollection);
    private sealed virtual override void JetBrains.ReSharper.Psi.CodeAnnotations.IAttributeInstancesConsumer.ProcessAttributeInstances(IAttributesOwner attributesOwner, IAttributeInstanceCollection attributesInstanceCollection);
    protected bool IsAnnotationAttribute(IAttributeInstance instance, string shortName);
    protected bool IsAnnotationType(IClrTypeName clrName, string shortName);
    protected string TrimAttributeShortName(string value);
    protected string DoGetDefaultDescription(TAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> relatedInstances, IEnumerable`1<IAttributeInstance> excludeInstances, string attributeShortName);
    protected bool ContainsAnnotationAttribute(IEnumerable`1<IAttributeInstance> attributeInstances, string attributeShortName);
    protected virtual string DoGetDescription(TAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> relatedInstances, IEnumerable`1<IAttributeInstance> excludeInstances);
    public sealed virtual string GetRelatedAndInheritedAnnotationsDescription(IAttributesOwner attributesOwner);
    public sealed virtual void Invalidate(PsiChangedElementType changeType);
    [CompilerGeneratedAttribute]
internal static IReadOnlyList`1<IAttributeInstance> <GetInfoFromTreeNode>g__CollectAttributes|10_0(IAttributesSet attributesSet, AttributesSource attributesSource);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class JetBrains.ReSharper.Psi.CodeAnnotations.CodeAnnotationInfoProviderForDerivableAttribute`2 : CodeAnnotationInfoProvider`2<TAttributesOwner, TResult> {
    protected IClrTypeName AttributeClrTypeName { get; }
    protected CodeAnnotationInfoProviderForDerivableAttribute`2(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration, bool shouldProvideInlayHints);
    protected abstract virtual IClrTypeName get_AttributeClrTypeName();
    protected abstract virtual bool CanBeDerivedAttributeName(string attributeShortName);
    protected abstract virtual TResult CalculateInfoForMatchingAttribute(IAttributeInstance attributeInstance);
    protected virtual TResult CalculateInfo(TAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
}
public enum JetBrains.ReSharper.Psi.CodeAnnotations.CodeAnnotationNullableValue : Enum {
    public int value__;
    public static CodeAnnotationNullableValue NOT_NULL;
    public static CodeAnnotationNullableValue CAN_BE_NULL;
}
[AttributeUsageAttribute("4")]
[MeansImplicitUseAttribute]
[PublicAPIAttribute]
[ComponentInstantiationAttribute("-32758")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.CodeAnnotationProviderAttribute : ComponentAttribute {
    public CodeAnnotationProviderAttribute(Instantiation instantiation);
}
[PsiComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.CodeAnnotationsCache : InvalidatingPsiCache {
    [NotNullAttribute]
private ComponentContainer myComponentContainer;
    [NotNullAttribute]
private Lazy`1<IJetReadonlyList`1<IInvalidatingCache>> myProvidersWithCache;
    [NotNullAttribute]
private Lazy`1<IJetReadonlyList`1<ICodeAnnotationDescriptionProvider>> myDescriptionProviders;
    [NotNullAttribute]
private ConcurrentDictionary`2<Type, object> myProviders;
    public CodeAnnotationsCache(NestedComponentContainerAllByPartAttribute`2<CodeAnnotationProviderAttribute, ShellPartCatalogSet> nestedComponentContainer);
    protected virtual void InvalidateOnPhysicalChange(PsiChangedElementType elementType);
    [NotNullAttribute]
[PureAttribute]
public TProvider GetProvider();
    [NotNullAttribute]
[PureAttribute]
public Lazy`1<TProvider> GetLazyProvider();
    [NotNullAttribute]
[PureAttribute]
public IEnumerable`1<ICodeAnnotationDescriptionProvider> GetDescriptionProviders();
    [CompilerGeneratedAttribute]
private IJetReadonlyList`1<IInvalidatingCache> <.ctor>b__4_0();
    [CompilerGeneratedAttribute]
private IJetReadonlyList`1<ICodeAnnotationDescriptionProvider> <.ctor>b__4_1();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CodeAnnotations.CodeAnnotationsCacheEx : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static CodeAnnotationsCache GetCodeAnnotationsCache(IPsiServices psiServices);
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.CodeAnnotationsConfiguration : object {
    private static string NotNullAttributeShortName;
    private static string CanBeNullAttributeShortName;
    private IList`1<string> myAnnotationNamespaces;
    private string myDefaultNamespace;
    private ISettingsStore mySettingsStore;
    private ISolution mySolution;
    public CodeAnnotationsConfiguration(ISolution solution, Lifetime lifetime, ISettingsStore settingsStore);
    public void UpdateAnnotationNamespaces();
    [NotNullAttribute]
public IEnumerable`1<IClrTypeName> GetAnnotationAttributes(string shortName);
    [PureAttribute]
public bool IsAnnotationAttribute(IAttributeInstance instance, string shortName);
    [PureAttribute]
public bool IsAnnotationType(IClrTypeName clrName, string shortName);
    public bool IsAnnotationsNamespace(INamespace ns);
    [CanBeNullAttribute]
public ITypeElement GetAttributeTypeForElement(ITreeNode ownerElement, string shortName);
    [CanBeNullAttribute]
private static ITypeElement GetAttributeTypeByTypeName(ISymbolScope symbolScope, string typeName, JetHashSet`1<ITypeElement> visitedTypes, CodeAnnotationAccessContext accessContext);
    [CanBeNullAttribute]
public ITypeElement GetNullableAttributeTypeForElement(ITreeNode ownerElement, CodeAnnotationNullableValue mark);
}
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeInspectionSettings", "JetBrains.ReSharper.Psi.Resources.Strings", "CodeAnnotationSettingsSettingDescription")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.CodeAnnotationsSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "DefaultNamespaceSettingDescription")]
public string DefaultNamespace;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "AnnotationNamespacesSettingDescription")]
public IIndexedEntry`2<string, bool> NamespacesWithAnnotations;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "PropagateAnnotationsSettingDescription")]
public bool PropagateAnnotations;
}
public static class JetBrains.ReSharper.Psi.CodeAnnotations.CodeAnnotationsSettingsAccessor : object {
    [NotNullAttribute]
public static Expression`1<Func`2<CodeAnnotationsSettings, string>> DefaultNamespace;
    [NotNullAttribute]
public static Expression`1<Func`2<CodeAnnotationsSettings, bool>> PropagateAnnotations;
    [NotNullAttribute]
public static Expression`1<Func`2<CodeAnnotationsSettings, IIndexedEntry`2<string, bool>>> Namespaces;
    private static CodeAnnotationsSettingsAccessor();
}
[SolutionSettingsUpgraderAttribute("16")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.CodeAnnotationsSettingsUpgrader : object {
    private IContextBoundSettingsStore myStore;
    public sealed virtual void Upgrade(IComponentSettingsProvider legacySettingsProvider, IContextBoundSettingsStore boundSettingsStore, Lifetime upgradeLifetime);
    private sealed virtual override void JetBrains.Application.Configuration.IXmlReadable.ReadFromXml(XmlElement element);
}
public static class JetBrains.ReSharper.Psi.CodeAnnotations.CodeAnnotationsUtil : object {
    [NotNullAttribute]
private static Key`1<NullabilityAnnotationsCache> CacheKey;
    private static Key`1<InterpolatedStringAnnotationsCache> ourInterpolatedStringAnnotationsCacheKey;
    private static CodeAnnotationsUtil();
    [PureAttribute]
public static NullableAttributeUsage CheckNullableAttributeUsage(CodeAnnotationNullableValue value, IAttributesOwner attributesOwner, NullnessProvider nullnessProvider);
    [PureAttribute]
public static NullableAttributeUsage CheckContainerNullableAttributeUsage(CodeAnnotationNullableValue value, IAttributesOwner attributesOwner, ContainerElementNullnessProvider containerElementNullnessProvider);
    [NotNullAttribute]
[PureAttribute]
private static IReadOnlyList`1<ValueTuple`2<CodeAnnotationNullableValue, TypeParameterVariance>> GetAllSuperAnnotationsForMember(IOverridableMember overridableMember, INullnessProvider nullnessProvider);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.CodeAnnotations.CodeAnnotationsUtil/<GetAllSuperAnnotationsForParameter>d__4")]
[NotNullAttribute]
[PureAttribute]
private static IEnumerable`1<CodeAnnotationNullableValue> GetAllSuperAnnotationsForParameter(IParameter parameter, INullnessProvider nullnessProvider);
    [PureAttribute]
private static NullableAttributeUsage CheckAnnotationVariance(IEnumerable`1<CodeAnnotationNullableValue> superAnnotations, CodeAnnotationNullableValue currentValue, TypeParameterVariance variance);
    public static NullableAttributeUsage CheckAttributeUsageInHierarchy(IAttributesOwner attributesOwner, INullnessProvider nullnessProvider, CodeAnnotationNullableValue value);
    [CanBeNullAttribute]
[PureAttribute]
public static IType GetContainerElementType(IType type, PredefinedType predefinedType, bool allowIEnumeratorOfT);
    [PureAttribute]
public static bool IsNullableTypeMakeSenseToAnnotate(IType type, bool allowUnresolved);
    [NotNullAttribute]
[PureAttribute]
public static NullabilityAnnotationsCache GetNullabilityCache(IUserDataHolder cacheHolder, ITreeNode context);
    [NotNullAttribute]
public static InterpolatedStringAnnotationsCache GetInterpolatedStringAnnotationsCache(IPsiModule psiModule);
    [NotNullAttribute]
public static InterpolatedStringAnnotationsCache GetInterpolatedStringAnnotationsCache(IUserDataHolder cacheHolder, IPsiServices psiServices);
    [PureAttribute]
public static Nullable`1<TypeParameterVariance> GetNullnessVariance(IAttributesOwner attributesOwner, IAccessContext accessContext);
    public static Nullable`1<CodeAnnotationNullableValue> GetVarianceTopValue(TypeParameterVariance variance);
    [PureAttribute]
public static bool IsAnnotationsPropagationEnabled(ITreeNode context);
    [PureAttribute]
public static bool IsAnnotationsPropagationEnabled(IContextBoundSettingsStore settingsStore);
    public static void CopyNullabilityAnnotation(IAttributesOwner from, IDeclaration to);
    [PureAttribute]
[ContractAnnotationAttribute("element: null => false")]
public static bool MakeSenseToAnnotate(IDeclaredElement element, CodeAnnotationNullableValue nullability, bool isContainerNullability);
}
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.CodeTemplateAnnotationProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, IReadOnlyList`1<CodeTemplateInfo>> {
    private static string CodeTemplateAttributeShortName;
    public CodeTemplateAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    [NotNullAttribute]
protected virtual IReadOnlyList`1<CodeTemplateInfo> CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    [NotNullAttribute]
private static string BakeSuppressionKey(IAttributesOwner attributesOwner);
    [NotNullAttribute]
protected virtual IReadOnlyList`1<CodeTemplateInfo> GetDefaultInfo(IAttributesOwner attributesOwner);
}
[RequiredMemberAttribute]
public class JetBrains.ReSharper.Psi.CodeAnnotations.CodeTemplateInfo : object {
    [CompilerGeneratedAttribute]
private string <SearchTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplaceTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplaceMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FormatAfterReplace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MatchSimilarConstructs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShortenReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SuppressionKey>k__BackingField;
    [RequiredMemberAttribute]
public string SearchTemplate { get; public set; }
    [RequiredMemberAttribute]
public string Message { get; public set; }
    [RequiredMemberAttribute]
public string ReplaceTemplate { get; public set; }
    [RequiredMemberAttribute]
public string ReplaceMessage { get; public set; }
    [RequiredMemberAttribute]
public bool FormatAfterReplace { get; public set; }
    [RequiredMemberAttribute]
public bool MatchSimilarConstructs { get; public set; }
    [RequiredMemberAttribute]
public bool ShortenReferences { get; public set; }
    [RequiredMemberAttribute]
public string SuppressionKey { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SearchTemplate();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SearchTemplate(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_ReplaceTemplate();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ReplaceTemplate(string value);
    [CompilerGeneratedAttribute]
public string get_ReplaceMessage();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ReplaceMessage(string value);
    [CompilerGeneratedAttribute]
public bool get_FormatAfterReplace();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FormatAfterReplace(bool value);
    [CompilerGeneratedAttribute]
public bool get_MatchSimilarConstructs();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MatchSimilarConstructs(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShortenReferences();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShortenReferences(bool value);
    [CompilerGeneratedAttribute]
public string get_SuppressionKey();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SuppressionKey(string value);
}
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.CollectionAccessTypeAnnotationProvider : CollectionAccessTypeAnnotationProviderBase {
    public CollectionAccessTypeAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
}
public class JetBrains.ReSharper.Psi.CodeAnnotations.CollectionAccessTypeAnnotationProviderBase : CodeAnnotationInfoProvider`2<IAttributesOwner, Nullable`1<CollectionAccessType>> {
    private static string CollectionAccessAttributeShortName;
    private static string CollectionAccessTypeFlagsShortName;
    public CollectionAccessTypeAnnotationProviderBase(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    protected virtual Nullable`1<CollectionAccessType> CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    protected virtual Nullable`1<CollectionAccessType> GetDefaultInfo(IAttributesOwner attributesOwner);
    private Nullable`1<int> ToEnumValue(AttributeValue value, string enumShortName);
}
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.CollectionAccessTypeReturnValueAnnotationProvider : CollectionAccessTypeAnnotationProviderBase {
    public CollectionAccessTypeReturnValueAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    protected virtual Nullable`1<CollectionAccessType> CalculateInfo(IAttributesOwner attributesOwner, IAttributeInstanceCollection attributesInstanceCollection);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.CollectionBuilderAnnotationProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, CollectionBuilderAttributeValue> {
    private static string CollectionBuilderAttributeShortName;
    private static IClrTypeName ourCollectionBuilderAttribute;
    public CollectionBuilderAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static CollectionBuilderAnnotationProvider();
    protected virtual CollectionBuilderAttributeValue CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    [NullableContextAttribute("2")]
protected virtual CollectionBuilderAttributeValue GetDefaultInfo(IAttributesOwner attributesOwner);
    public bool IsCollectionBuilderAttribute(IClrTypeName attributeTypeName);
    public bool IsCollectionBuilderAttribute(IAttributeInstance instance);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.CollectionBuilderAttributeValue : object {
    public IType BuilderType;
    public string MethodName;
    public CollectionBuilderAttributeValue(IType builderType, string methodName);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.ColumnAnnotationProvider : CodeAnnotationInfoProvider`2<IProperty, string> {
    private static ClrTypeName ourAttributeName;
    public ColumnAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static ColumnAnnotationProvider();
    [NullableContextAttribute("2")]
protected virtual string GetDefaultInfo(IProperty attributesOwner);
    protected virtual string CalculateInfo(IProperty attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
}
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.CompilerFlowAnnotationProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, FlowAnalysisAnnotations> {
    private static string FlowAnnotationsNamespace;
    private static string AllowNullAttributeShortName;
    private static string DisallowNullAttributeShortName;
    private static string MaybeNullAttributeShortName;
    private static string MaybeNullWhenAttributeShortName;
    private static string NotNullAttributeShortName;
    private static string NotNullIfNotNullAttributeShortName;
    private static string NotNullWhenAttributeShortName;
    private static string DoesNotReturnIfAttributeShortName;
    private static string DoesNotReturnAttributeShortName;
    private static FlowAnalysisAnnotations GetterOnlyAnnotations;
    private static FlowAnalysisAnnotations SetterOnlyAnnotations;
    public CompilerFlowAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    protected virtual FlowAnalysisAnnotations GetDefaultInfo(IAttributesOwner attributesOwner);
    public virtual FlowAnalysisAnnotations GetInfo(IAttributesOwner attributesOwner);
    protected virtual FlowAnalysisAnnotations CalculateInfo(IAttributesOwner attributesOwner, IAttributeInstanceCollection attributesInstanceCollection);
    protected virtual FlowAnalysisAnnotations CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    [PureAttribute]
public static FlowAnalysisAnnotations CalculateInfo(IAttributeInstance attributeInstance);
    private static FlowAnalysisAnnotations GetAnnotationByAttributeName(IAttributeInstance attributeInstance);
    [CanBeNullAttribute]
private static Nullable`1<bool> GetSingleBooleanArgument(IAttributeInstance attributeInstance);
    [CompilerGeneratedAttribute]
private FlowAnalysisAnnotations <GetInfo>g__GetInfo|14_0(IAttributesOwner attributesOwner, HashSet`1<IAttributesOwner> processedElements);
    [CompilerGeneratedAttribute]
private FlowAnalysisAnnotations <GetInfo>g__CombineAnnotationsWithBaseNotOverridenAccessor|14_1(FlowAnalysisAnnotations allowedBaseAnnotations, <>c__DisplayClass14_0& , <>c__DisplayClass14_1& );
    [CompilerGeneratedAttribute]
internal static bool <CalculateInfo>g__IsDuplicatedConditionalAttribute|16_0(FlowAnalysisAnnotations unconditionalAnnotation, <>c__DisplayClass16_0& , <>c__DisplayClass16_1& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.ComplexTypeAnnotationProvider : CodeAnnotationInfoProvider`2<ITypeElement, bool> {
    private static ClrTypeName ourAttributeName;
    public ComplexTypeAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static ComplexTypeAnnotationProvider();
    protected virtual bool CalculateInfo(ITypeElement attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    [NullableContextAttribute("2")]
protected virtual bool GetDefaultInfo(ITypeElement attributesOwner);
}
[TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.ContainerElementNullnessProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, ValueTuple`2<Nullable`1<CodeAnnotationNullableValue>, NullableStateSource>> {
    public static string ItemNotNullAttributeShortName;
    public static string ItemCanBeNullAttributeShortName;
    private IEnumerable`1<ICustomCodeAnnotationProvider> myCustomProviders;
    public ContainerElementNullnessProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration, IEnumerable`1<ICustomCodeAnnotationProvider> customProviders);
    private static ContainerElementNullnessProvider();
    public sealed virtual Nullable`1<CodeAnnotationNullableValue> GetNullableState(IAttributesOwner attributesOwner);
    public sealed virtual ValueTuple`2<Nullable`1<CodeAnnotationNullableValue>, NullableStateSource> GetNullableStateWithSource(IAttributesOwner attributesOwner);
    public virtual ValueTuple`2<Nullable`1<CodeAnnotationNullableValue>, NullableStateSource> GetInfo(IAttributesOwner attributesOwner);
    [CanBeNullAttribute]
private static IAttributesOwner GetAnnotationSource(IAttributesOwner attributesOwner);
    protected virtual ValueTuple`2<Nullable`1<CodeAnnotationNullableValue>, NullableStateSource> CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    protected virtual ValueTuple`2<Nullable`1<CodeAnnotationNullableValue>, NullableStateSource> GetDefaultInfo(IAttributesOwner attributesOwner);
    protected virtual string DoGetDescription(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> relatedInstances, IEnumerable`1<IAttributeInstance> excludeInstances);
    private Nullable`1<CodeAnnotationNullableValue> GetContainerElementNullableAttributeValueForSpecialValues(IAttributesOwner attributesOwner);
    public Nullable`1<CodeAnnotationNullableValue> GetContainerElementNullableAttributeMark(IAttributeInstance attributeInstance);
    public bool IsContainerElementNullableAttribute(IAttributeInstance attributeInstance);
    [PureAttribute]
public static Nullable`1<CodeAnnotationNullableValue> GetNullableValueByNullableAnnotationOfTypeArgument(IType type, bool shouldProcessUnconstrainedGenericType);
}
public static class JetBrains.ReSharper.Psi.CodeAnnotations.ContractAnnotationParser : object {
    [NotNullAttribute]
private static Char[] Semicolon;
    [NotNullAttribute]
private static Char[] Comma;
    private static Dictionary`2<string, ContractAnnotationValue> InputValues;
    private static Dictionary`2<string, ContractAnnotationValue> OutputValues;
    private static Dictionary`2<string, ContractAnnotationValue> ReturnValues;
    private static ContractAnnotationParser();
    [CanBeNullAttribute]
public static FunctionDefinitionTable Parse(IAttributeInstance attributeInstance, String& errorMessage);
    [CanBeNullAttribute]
public static FunctionDefinitionTable Parse(string fdtString, bool forceFullStates);
    [CanBeNullAttribute]
public static FunctionDefinitionTable Parse(string fdtString, bool forceFullStates, String& errorMessage);
    [NotNullAttribute]
private static FunctionDefinitionTableRow ParseRow(string rowString, bool forceFullStates);
    [NotNullAttribute]
private static FunctionDefinitionTableRow ParseRow(string inputString, string outputString, bool forceFullStates);
    [NotNullAttribute]
private static IReadOnlyList`1<ParameterAnnotation> ParseInput(string inputString);
    [PureAttribute]
private static ValueTuple`2<IReadOnlyList`1<ParameterAnnotation>, Nullable`1<ContractAnnotationValue>> ParseOutput(string outputString);
    [PureAttribute]
private static ParameterAnnotation ParseInputParameterNameAndValue(string value, int colonIndex);
    [PureAttribute]
private static ParameterAnnotation ParseOutputParameterNameAndValue(string value, int colonIndex);
    [PureAttribute]
private static ContractAnnotationValue ParseInputParameterValue(string value);
    [PureAttribute]
private static ContractAnnotationValue ParseOutputParameterValue(string value);
    [PureAttribute]
private static ContractAnnotationValue ParseFunctionValue(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.ContractAnnotationProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, FunctionDefinitionTable> {
    public static string ContractAnnotationAttributeShortName;
    private ParameterContractFromFlowAnnotationsProvider myParameterContractProvider;
    public ContractAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration, ParameterContractFromFlowAnnotationsProvider parameterContractProvider);
    private static ContractAnnotationProvider();
    [NullableContextAttribute("2")]
public virtual FunctionDefinitionTable GetInfo(IAttributesOwner attributesOwner);
    protected virtual FunctionDefinitionTable CalculateInfo(IAttributesOwner attributesOwner, IAttributeInstanceCollection attributesInstanceCollection);
    protected virtual FunctionDefinitionTable CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    [NullableContextAttribute("2")]
protected virtual FunctionDefinitionTable GetDefaultInfo(IAttributesOwner attributesOwner);
    protected virtual string DoGetDescription(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> relatedInstances, IEnumerable`1<IAttributeInstance> excludeInstances);
    [PureAttribute]
private static FunctionDefinitionTable BuildFunctionDefinitionTableFromCompilerFlowAnnotations(IParametersOwner parametersOwner, IAttributeInstanceCollection attributesInstanceCollection);
    [CompilerGeneratedAttribute]
internal static void <BuildFunctionDefinitionTableFromCompilerFlowAnnotations>g__HandleAnnotationsOnReturnValue|8_0(FlowAnalysisAnnotations annotations, IAttributeInstance attributeInstance, <>c__DisplayClass8_0& );
}
public enum JetBrains.ReSharper.Psi.CodeAnnotations.ContractAnnotationValue : Enum {
    public int value__;
    public static ContractAnnotationValue TRUE;
    public static ContractAnnotationValue FALSE;
    public static ContractAnnotationValue NULL;
    public static ContractAnnotationValue NOT_NULL;
    public static ContractAnnotationValue CAN_BE_NULL;
    public static ContractAnnotationValue HALT;
}
[PsiComponentAttribute("16")]
internal class JetBrains.ReSharper.Psi.CodeAnnotations.CustomImplicitNullabilityProvider : object {
    [CompilerGeneratedAttribute]
private IImmutableList`1<ICustomImplicitNullabilityProvider> <customProviders>P;
    public CustomImplicitNullabilityProvider(IImmutableList`1<ICustomImplicitNullabilityProvider> customProviders);
    [PureAttribute]
public bool HasImplicitNullability(IDeclaredElement element, CodeAnnotationNullableValue nullability, bool isContainer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.DatabaseGeneratedAnnotationProvider : CodeAnnotationInfoProvider`2<IProperty, Nullable`1<EfValueGenerationStrategy>> {
    private static ClrTypeName ourAttributeName;
    public DatabaseGeneratedAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static DatabaseGeneratedAnnotationProvider();
    protected virtual Nullable`1<EfValueGenerationStrategy> CalculateInfo(IProperty attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    [NullableContextAttribute("2")]
protected virtual Nullable`1<EfValueGenerationStrategy> GetDefaultInfo(IProperty attributesOwner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.DbFunctionAnnotationProvider : DbFunctionAnnotationProviderBase {
    public static ClrTypeName AttributeName;
    protected IClrTypeName AttributeClrTypeName { get; }
    public DbFunctionAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static DbFunctionAnnotationProvider();
    protected virtual IClrTypeName get_AttributeClrTypeName();
    protected virtual string CalculateInfoForMatchingAttribute(IAttributeInstance attributeInstance);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class JetBrains.ReSharper.Psi.CodeAnnotations.DbFunctionAnnotationProviderBase : CodeAnnotationInfoProviderForDerivableAttribute`2<IMethod, string> {
    protected DbFunctionAnnotationProviderBase(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    protected virtual bool CanBeDerivedAttributeName(string attributeShortName);
    [NullableContextAttribute("2")]
protected virtual string GetDefaultInfo(IMethod attributesOwner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.DbFunctionFrameworkAnnotationProvider : DbFunctionAnnotationProviderBase {
    public static ClrTypeName AttributeName;
    protected IClrTypeName AttributeClrTypeName { get; }
    public DbFunctionFrameworkAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static DbFunctionFrameworkAnnotationProvider();
    protected virtual IClrTypeName get_AttributeClrTypeName();
    protected virtual string CalculateInfoForMatchingAttribute(IAttributeInstance attributeInstance);
}
[CodeAnnotationProviderAttribute("16")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.DefaultEqualityUsageAnnotationProvider : SimpleCodeAnnotationProvider {
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CodeAnnotations.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
    public static DynamicallyAccessedMemberTypes All;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CodeAnnotations.DynamicallyAccessedMemberTypesExtensions : object {
    [ExtensionAttribute]
public static ImplicitUseKindFlags ToImplicitUseKindFlags(DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes, ITypeMember member);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CodeAnnotations.EfValueGenerationStrategy : Enum {
    public int value__;
    public static EfValueGenerationStrategy Never;
    public static EfValueGenerationStrategy OnAdd;
    public static EfValueGenerationStrategy OnUpdate;
    public static EfValueGenerationStrategy OnAddOrUpdate;
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.CodeAnnotations.FlowAnalysisAnnotations : Enum {
    public int value__;
    public static FlowAnalysisAnnotations None;
    public static FlowAnalysisAnnotations AllowNull;
    public static FlowAnalysisAnnotations DisallowNull;
    public static FlowAnalysisAnnotations MaybeNullWhenTrue;
    public static FlowAnalysisAnnotations MaybeNullWhenFalse;
    public static FlowAnalysisAnnotations MaybeNull;
    public static FlowAnalysisAnnotations NotNullWhenTrue;
    public static FlowAnalysisAnnotations NotNullWhenFalse;
    public static FlowAnalysisAnnotations NotNull;
    public static FlowAnalysisAnnotations DoesNotReturnIfFalse;
    public static FlowAnalysisAnnotations DoesNotReturnIfTrue;
    public static FlowAnalysisAnnotations DoesNotReturn;
    public static FlowAnalysisAnnotations NotNullIfNotNull;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CodeAnnotations.FlowAnalysisAnnotationsExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool HasFlagFast(FlowAnalysisAnnotations value, FlowAnalysisAnnotations flag);
}
public class JetBrains.ReSharper.Psi.CodeAnnotations.FunctionDefinitionTable : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<FunctionDefinitionTableRow> <Rows>k__BackingField;
    [NotNullAttribute]
public IReadOnlyList`1<FunctionDefinitionTableRow> Rows { get; }
    public FunctionDefinitionTable(IReadOnlyList`1<FunctionDefinitionTableRow> rows);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FunctionDefinitionTableRow> get_Rows();
    [PureAttribute]
[CanBeNullAttribute]
public static FunctionDefinitionTable Merge(FunctionDefinitionTable table1, FunctionDefinitionTable table2);
    [CanBeNullAttribute]
[PureAttribute]
private static FunctionDefinitionTableRow TryMerge(FunctionDefinitionTableRow x, FunctionDefinitionTableRow y);
}
public class JetBrains.ReSharper.Psi.CodeAnnotations.FunctionDefinitionTableRow : object {
    [CompilerGeneratedAttribute]
private Nullable`1<ContractAnnotationValue> <FunctionReturn>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ParameterAnnotation> <Input>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ParameterAnnotation> <OutParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceFullStates>k__BackingField;
    public Nullable`1<ContractAnnotationValue> FunctionReturn { get; }
    public IReadOnlyList`1<ParameterAnnotation> Input { get; }
    public IReadOnlyList`1<ParameterAnnotation> OutParameters { get; }
    public bool ForceFullStates { get; }
    public FunctionDefinitionTableRow(IReadOnlyList`1<ParameterAnnotation> input, IReadOnlyList`1<ParameterAnnotation> outParameters, Nullable`1<ContractAnnotationValue> functionReturn, bool forceFullStates);
    [CompilerGeneratedAttribute]
public Nullable`1<ContractAnnotationValue> get_FunctionReturn();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ParameterAnnotation> get_Input();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ParameterAnnotation> get_OutParameters();
    [CompilerGeneratedAttribute]
public bool get_ForceFullStates();
    private bool Equals(FunctionDefinitionTableRow other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.HandlesResourceDisposalAnnotationProvider : CodeAnnotationInfoProviderBase`2<IAttributesOwner, bool> {
    public static string HandlesResourceDisposalAttributeShortName;
    public HandlesResourceDisposalAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    [NullableContextAttribute("2")]
public bool GetInfo(IAttributesOwner attributesOwner);
    [NullableContextAttribute("2")]
protected virtual bool GetDefaultInfo(IAttributesOwner attributesOwner);
    protected virtual bool ComputeWithoutAttributes();
    protected virtual bool CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    protected virtual string DoGetDescription(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> relatedInstances, IEnumerable`1<IAttributeInstance> excludeInstances);
    [CompilerGeneratedAttribute]
internal static bool <CalculateInfo>g__OverridesOrIsMemberFrom|5_0(IOverridableMember member, string containingTypeClrName);
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.ReSharper.Psi.CodeAnnotations.IAttributeInstanceCollection {
    public bool IsEmpty { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IAttributeInstance> Item { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual IEnumerable`1<IAttributeInstance> get_Item(AttributeInstancesSource source);
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IEnumerable`1<IAttributeInstance> GetAllOwnAttributes();
}
public interface JetBrains.ReSharper.Psi.CodeAnnotations.IAttributeInstancesConsumer {
    public abstract virtual void ProcessAttributeInstances(IAttributesOwner attributesOwner, IAttributeInstanceCollection attributeInstanceCollection);
}
public interface JetBrains.ReSharper.Psi.CodeAnnotations.ICodeAnnotationDescriptionProvider {
    public abstract virtual string GetRelatedAndInheritedAnnotationsDescription(IAttributesOwner attributesOwner);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.CodeAnnotations.ICodeAnnotationInfoProvider`2 {
    public abstract virtual TResult GetInfo(TAttributesOwner attributesOwner);
}
public interface JetBrains.ReSharper.Psi.CodeAnnotations.ICustomCodeAnnotationProvider {
    public abstract virtual Nullable`1<CodeAnnotationNullableValue> GetNullableAttribute(IDeclaredElement element);
    public abstract virtual Nullable`1<CodeAnnotationNullableValue> GetContainerElementNullableAttribute(IDeclaredElement element);
    public abstract virtual ICollection`1<IAttributeInstance> GetSpecialAttributeInstances(IClrDeclaredElement element, AttributeInstanceCollection attributeInstanceCollection);
}
public interface JetBrains.ReSharper.Psi.CodeAnnotations.ICustomImplicitNullabilityProvider {
}
[CodeAnnotationProviderAttribute("16")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.IgnoreSpellingAndGrammarErrorsAnnotationProvider : SimpleCodeAnnotationProvider {
}
public interface JetBrains.ReSharper.Psi.CodeAnnotations.IInvalidatingCache {
    public abstract virtual void Invalidate(PsiChangedElementType changeType);
}
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.ImplicitUseAnnotationProvider : object {
    private static int MAX_CACHE_SIZE;
    private static string MeansImplicitUseAttributeShortName;
    public static string UsedImplicitlyAttributeShortName;
    private static string ImplicitUseKindFlagsShortName;
    private static string ImplicitUseTargetFlagsShortName;
    private static string DynamicallyAccessedMembersShortName;
    private static string ModuleInitializerAttributeShortName;
    private AttributeInstancesProvider myAttributeInstancesProvider;
    private CodeAnnotationsConfiguration myCodeAnnotationsConfiguration;
    private DirectMappedCache`2<IAttributesOwner, ImplicitUseFlags> myMeansImplicitUseCache;
    private DirectMappedCache`2<ITypeElement, ImplicitUseFlags> myTypeImplicitlyUsedCache;
    private DirectMappedCache`2<IAttributesOwner, ImplicitUseFlags> myTypeMemberImplicitlyUsedCache;
    public ImplicitUseAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    public Nullable`1<ImplicitUseKindFlags> IsImplicitlyUsed(IAttributesOwner element);
    private Nullable`1<ImplicitUseFlags> IsImplicitlyUsed(IAttributesOwner element, bool isMembersCheck);
    private ImplicitUseFlags CalculateTypeMemberImplicitlyUsedFlags(IAttributesOwner attributesOwner);
    private ImplicitUseFlags CalculateTypeImplicitlyUsedFlags(ITypeElement typeElement);
    private ImplicitUseFlags UsageAttributeUnion(IEnumerable`1<IAttributeInstance> selfAttributeInstances, IEnumerable`1<IAttributeInstance> inheritedAttributeInstances);
    private ImplicitUseFlags CalculateMeansImplicitUsed(IAttributeInstance attributeInstance);
    private ImplicitUseFlags CalculateMeansImplicitUsed(IAttributesOwner attributesOwner);
    private static ImplicitUseFlags UsageUnion(ImplicitUseFlags use1, ImplicitUseFlags use2);
    private ImplicitUseFlags GetImplicitUseFlagsFromAttributes(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    public sealed virtual void Invalidate(PsiChangedElementType changeType);
    public bool IsMeansImplicitUse(IAttributesOwner attributesOwner, ImplicitUseFlags& implicitUseKind);
    private static bool CheckTarget(ImplicitUseFlags flags, bool isMembersTarget);
    private ImplicitUseFlags UsedImplicitlyFlagsByAttributeInstance(IAttributeInstance attr);
    private Nullable`1<ImplicitUseKindFlags> ToImplicitUseKindFlags(AttributeValue value);
    private Nullable`1<ImplicitUseTargetFlags> ToImplicitUseTargetFlags(AttributeValue value);
    private Nullable`1<int> ToEnumValue(AttributeValue attributeValue, string enumShortName);
    private static DynamicallyAccessedMemberTypes DynamicallyAccessedMembersFlagsByAttributeInstance(IAttributeInstance attr);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CodeAnnotations.ImplicitUseFlags : ValueType {
    public ImplicitUseKindFlags UseKindFlags;
    public ImplicitUseTargetFlags UseTargetFlags;
    public DynamicallyAccessedMemberTypes DynamicallyAccessedMemberTypes;
    public static ImplicitUseFlags Empty;
    public ImplicitUseFlags(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags useTargetFlags, DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes);
    private static ImplicitUseFlags();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.InjectionAnnotationInfo : object {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Suffix>k__BackingField;
    public static InjectionAnnotationInfo Css;
    public static InjectionAnnotationInfo Html;
    public static InjectionAnnotationInfo JavaScript;
    public static InjectionAnnotationInfo Json;
    public static InjectionAnnotationInfo Xml;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Language { get; public set; }
    [NullableAttribute("2")]
public string Prefix { get; public set; }
    [NullableAttribute("2")]
public string Suffix { get; public set; }
    [NullableContextAttribute("2")]
public InjectionAnnotationInfo(string Language, string Prefix, string Suffix);
    [CompilerGeneratedAttribute]
protected InjectionAnnotationInfo(InjectionAnnotationInfo original);
    private static InjectionAnnotationInfo();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Language(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Prefix();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Prefix(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Suffix();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Suffix(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(InjectionAnnotationInfo left, InjectionAnnotationInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(InjectionAnnotationInfo left, InjectionAnnotationInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(InjectionAnnotationInfo other);
    [CompilerGeneratedAttribute]
public virtual InjectionAnnotationInfo <Clone>$();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void Deconstruct(String& Language, String& Prefix, String& Suffix);
}
[CodeAnnotationProviderAttribute("16")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.InstantHandleAnnotationProvider : SimpleCodeAnnotationProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.CodeAnnotations.InterpolatedStringHandlerArgumentAnnotation : object {
    public bool IsValid { get; }
    public IReadOnlyList`1<int> ParameterIndexes { get; }
    public abstract virtual bool get_IsValid();
    public abstract virtual IReadOnlyList`1<int> get_ParameterIndexes();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.InterpolatedStringHandlerArgumentProvider : CodeAnnotationInfoProvider`2<IParameter, InterpolatedStringHandlerArgumentAnnotation> {
    public static IClrTypeName AttributeName;
    public InterpolatedStringHandlerArgumentProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static InterpolatedStringHandlerArgumentProvider();
    protected virtual InterpolatedStringHandlerArgumentAnnotation CalculateInfo(IParameter attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    [PureAttribute]
private static InterpolatedStringHandlerArgumentAnnotation GetAnnotationData(IParameter parameter, IReadOnlyList`1<string> parameterNames);
    [NullableContextAttribute("2")]
protected virtual InterpolatedStringHandlerArgumentAnnotation GetDefaultInfo(IParameter attributesOwner);
    [PureAttribute]
public static bool IsInterpolatedStringArgumentAttribute(IAttributeInstance attributeInstance);
    [PureAttribute]
public static bool CanUseReceiverArgument(IParametersOwner parametersOwner);
}
public interface JetBrains.ReSharper.Psi.CodeAnnotations.INullabilityAnnotator {
    public abstract virtual void Annotate(IDeclaration declaration, IAttributeInstance annotation);
}
public interface JetBrains.ReSharper.Psi.CodeAnnotations.INullnessProvider {
    public abstract virtual Nullable`1<CodeAnnotationNullableValue> GetNullableState(IAttributesOwner attributesOwner);
    public abstract virtual ValueTuple`2<Nullable`1<CodeAnnotationNullableValue>, NullableStateSource> GetNullableStateWithSource(IAttributesOwner attributesOwner);
}
[CodeAnnotationProviderAttribute("16")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.InvokerParameterNameAnnotationProvider : object {
    public static string InvokerParameterNameAttributeShortName;
    private CodeAnnotationsConfiguration myCodeAnnotationsConfiguration;
    public InvokerParameterNameAnnotationProvider(CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static InvokerParameterNameAnnotationProvider();
    public bool IsInvokerParameterName(IParameter parameter);
}
internal interface JetBrains.ReSharper.Psi.CodeAnnotations.IPackedSimpleAnnotationInfoProvider {
    [NullableContextAttribute("1")]
public abstract virtual bool GetInfo(IAttributesOwner attributesOwner, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.JetBrains.ReSharper.Psi.CodeAnnotations.MessageTemplateFormatMethodAnnotationsProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, string> {
    private static string MessageTemplateFormatMethodAnnotation;
    public MessageTemplateFormatMethodAnnotationsProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    protected virtual string CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    [NullableContextAttribute("2")]
protected virtual string GetDefaultInfo(IAttributesOwner attributesOwner);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
internal class JetBrains.ReSharper.Psi.CodeAnnotations.JetBrainsStringFormatAnnotationProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, string> {
    private static string StringFormatAttributeShortName;
    public JetBrainsStringFormatAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    protected virtual string CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    [NullableContextAttribute("2")]
protected virtual string GetDefaultInfo(IAttributesOwner attributesOwner);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.LanguageInjectionAnnotationProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, InjectionAnnotationInfo> {
    private static string AnnotatedInjectionAttributeShortName;
    private ILanguages myLanguages;
    [CompilerGeneratedAttribute]
private String[] <AttributeShortNames>k__BackingField;
    public String[] AttributeShortNames { get; }
    public LanguageInjectionAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration, ILanguages languages);
    [CompilerGeneratedAttribute]
public String[] get_AttributeShortNames();
    protected virtual InjectionAnnotationInfo CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    [NullableContextAttribute("2")]
protected virtual InjectionAnnotationInfo GetDefaultInfo(IAttributesOwner attributesOwner);
}
[CodeAnnotationProviderAttribute("16")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.LinqTunnelAnnotationProvider : SimpleCodeAnnotationProvider {
}
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.LocalizationRequiredAnnotationProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, Nullable`1<bool>> {
    public static IClrTypeName ComponentLocalizableAttribute;
    public static string ComponentLocalizableAttributeShortName;
    public static string LocalizationRequiredAttributeShortName;
    public LocalizationRequiredAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static LocalizationRequiredAnnotationProvider();
    protected virtual Nullable`1<bool> CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    [NotNullAttribute]
private static AttributeValue GetParameterValue(int paramIndex, string name, IAttributeInstance attribute);
    protected virtual Nullable`1<bool> GetDefaultInfo(IAttributesOwner attributesOwner);
    protected virtual string DoGetDescription(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> relatedInstances, IEnumerable`1<IAttributeInstance> excludeInstances);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.MaxLengthAnnotationProvider : CodeAnnotationInfoProviderForDerivableAttribute`2<IProperty, Nullable`1<int>> {
    private static ClrTypeName ourAttributeName;
    protected IClrTypeName AttributeClrTypeName { get; }
    public MaxLengthAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static MaxLengthAnnotationProvider();
    protected virtual IClrTypeName get_AttributeClrTypeName();
    protected virtual bool CanBeDerivedAttributeName(string attributeShortName);
    [NullableContextAttribute("2")]
protected virtual Nullable`1<int> GetDefaultInfo(IProperty attributesOwner);
    protected virtual Nullable`1<int> CalculateInfoForMatchingAttribute(IAttributeInstance attributeInstance);
}
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.MemberNotNullAnnotationProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, MemberNotNullInfo> {
    private static string FlowAnnotationsNamespace;
    private static string MemberNotNullShortName;
    private static string MemberNotNullWhenShortName;
    public MemberNotNullAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    public static bool IsMemberNotNullAttribute(IAttributeInstance attributeInstance);
    public virtual MemberNotNullInfo GetInfo(IAttributesOwner attributesOwner);
    protected virtual bool Accepts(IAttributesOwner attributesOwner);
    [NotNullAttribute]
protected virtual MemberNotNullInfo CalculateInfo(IAttributesOwner attributesOwner, IAttributeInstanceCollection attributesInstanceCollection);
    public static FrugalLocalHashSet`1<string> CollectMemberNamesFrom(IAttributeInstance attribute);
    private bool HasMemberNotNullAttributes(IEnumerable`1<IAttributeInstance> attributeInstances);
    protected virtual MemberNotNullInfo CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    protected virtual MemberNotNullInfo GetDefaultInfo(IAttributesOwner attributesOwner);
    [CompilerGeneratedAttribute]
internal static void <CalculateInfo>g__AddMemberNamesTo|7_0(LocalHashSet`1& targetSet, IAttributeInstance attributeInstance);
    [CompilerGeneratedAttribute]
internal static void <CollectMemberNamesFrom>g__CollectMemberNamesFrom|8_0(AttributeValue attributeValue, <>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
internal static void <CollectMemberNamesFrom>g__CollectMemberNamesFrom|8_1(ConstantValue constantValue, <>c__DisplayClass8_0& );
}
public class JetBrains.ReSharper.Psi.CodeAnnotations.MemberNotNullInfo : object {
    public static MemberNotNullInfo Empty;
    [CompilerGeneratedAttribute]
private bool <HasAnnotationsInHierarchy>k__BackingField;
    [CompilerGeneratedAttribute]
private JetHashSet`1<string> <WhenAny>k__BackingField;
    [CompilerGeneratedAttribute]
private JetHashSet`1<string> <WhenTrue>k__BackingField;
    [CompilerGeneratedAttribute]
private JetHashSet`1<string> <WhenFalse>k__BackingField;
    public bool HasAnnotationsInHierarchy { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public JetHashSet`1<string> WhenAny { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public JetHashSet`1<string> WhenTrue { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public JetHashSet`1<string> WhenFalse { get; }
    public MemberNotNullInfo(bool hasAnnotationsInHierarchy, JetHashSet`1<string> whenAny, JetHashSet`1<string> whenTrue, JetHashSet`1<string> whenFalse);
    private static MemberNotNullInfo();
    [CompilerGeneratedAttribute]
public bool get_HasAnnotationsInHierarchy();
    [CompilerGeneratedAttribute]
public JetHashSet`1<string> get_WhenAny();
    [CompilerGeneratedAttribute]
public JetHashSet`1<string> get_WhenTrue();
    [CompilerGeneratedAttribute]
public JetHashSet`1<string> get_WhenFalse();
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<string> IterateMembersEffectivelyNotNullWhen(Nullable`1<bool> condition);
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<string> IterateMembersDeclaredNotNullWhen(Nullable`1<bool> condition);
    [NotNullAttribute]
[PureAttribute]
public MemberNotNullInfo Union(MemberNotNullInfo other);
    [CompilerGeneratedAttribute]
internal static JetHashSet`1<string> <Union>g__Union|16_0(JetHashSet`1<string> first, JetHashSet`1<string> second);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.MustDisposeResourceAnnotationProvider : CodeAnnotationInfoProviderBase`2<IAttributesOwner, Nullable`1<bool>> {
    public static string MustDisposeResourceAttributeShortName;
    public static ClrTypeName MustDisposeResourceAttributeClrTypeName;
    public MustDisposeResourceAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static MustDisposeResourceAnnotationProvider();
    [NullableContextAttribute("2")]
public Nullable`1<bool> GetInfo(IAttributesOwner attributesOwner);
    [NullableContextAttribute("2")]
protected virtual Nullable`1<bool> GetDefaultInfo(IAttributesOwner attributesOwner);
    protected virtual bool ComputeWithoutAttributes();
    protected virtual Nullable`1<bool> CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    protected virtual string DoGetDescription(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> relatedInstances, IEnumerable`1<IAttributeInstance> excludeInstances);
}
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.MustUseReturnValueAnnotationProvider : CodeAnnotationComplexInfoProvider`3<IAttributesOwner, bool, string> {
    public static string MustUseReturnValueAttributeShortName;
    public MustUseReturnValueAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static MustUseReturnValueAnnotationProvider();
    protected virtual Pair`2<bool, string> CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    protected virtual Pair`2<bool, string> GetDefaultInfo(IAttributesOwner attributesOwner);
    protected virtual string DoGetDescription(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> relatedInstances, IEnumerable`1<IAttributeInstance> excludeInstances);
}
[CodeAnnotationProviderAttribute("16")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.NoEnumerationAnnotationProvider : SimpleCodeAnnotationProvider {
}
[TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.NotifyPropertyChangedAnnotationProvider : CodeAnnotationInfoProvider`2<IMethod, ValueTuple`2<bool, string>> {
    public static string NotifyPropertyChangedInvocatorAttributeShortName;
    public NotifyPropertyChangedAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    [PureAttribute]
public bool HasNotifyPropertyChangedInvocatorAttribute(IMethod method);
    [PureAttribute]
public bool IsNotifyPropertyChangedParameter(IParameter parameter);
    protected virtual ValueTuple`2<bool, string> CalculateInfo(IMethod attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    protected virtual ValueTuple`2<bool, string> GetDefaultInfo(IMethod attributesOwner);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.NotMappedAnnotationProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, bool> {
    private static ClrTypeName ourAttributeName;
    public NotMappedAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static NotMappedAnnotationProvider();
    protected virtual bool CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    [NullableContextAttribute("2")]
protected virtual bool GetDefaultInfo(IAttributesOwner attributesOwner);
}
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.NotNullIfNotNullAnnotationProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, IReadOnlyList`1<string>> {
    private static string FlowAnnotationsNamespace;
    private static string NotNullIfNotNullAttributeShortName;
    public NotNullIfNotNullAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    protected virtual bool Accepts(IAttributesOwner attributesOwner);
    public virtual IReadOnlyList`1<string> GetInfo(IAttributesOwner attributesOwner);
    protected virtual IReadOnlyList`1<string> CalculateInfo(IAttributesOwner attributesOwner, IAttributeInstanceCollection attributesInstanceCollection);
    protected virtual IReadOnlyList`1<string> CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    protected virtual IReadOnlyList`1<string> GetDefaultInfo(IAttributesOwner attributesOwner);
    [CanBeNullAttribute]
public static string GetRelatedParameterName(IAttributeInstance attribute);
    public static bool IsNotNullIfNotNullAttribute(IAttributeInstance attribute);
}
public enum JetBrains.ReSharper.Psi.CodeAnnotations.NullableStateSource : Enum {
    public int value__;
    public static NullableStateSource None;
    public static NullableStateSource CompilerNullableAnnotation;
    public static NullableStateSource Other;
}
[TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.NullnessProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, ValueTuple`3<Nullable`1<CodeAnnotationNullableValue>, NullableStateSource, bool>> {
    private CompilerFlowAnnotationProvider myCompilerFlowAnnotationProvider;
    public static string NotNullAttributeShortName;
    public static string CanBeNullAttributeShortName;
    private IEnumerable`1<ICustomCodeAnnotationProvider> myCustomProviders;
    public NullnessProvider(AttributeInstancesProvider attributeInstancesProvider, IEnumerable`1<ICustomCodeAnnotationProvider> customProviders, CompilerFlowAnnotationProvider compilerFlowAnnotationProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    public sealed virtual Nullable`1<CodeAnnotationNullableValue> GetNullableState(IAttributesOwner attributesOwner);
    [NullableContextAttribute("0")]
public sealed virtual ValueTuple`2<Nullable`1<CodeAnnotationNullableValue>, NullableStateSource> GetNullableStateWithSource(IAttributesOwner attributesOwner);
    private Nullable`1<CodeAnnotationNullableValue> GetAnnotationFromCompilerAttributes(IAttributesOwner attributesOwner);
    [NullableContextAttribute("0")]
public virtual ValueTuple`3<Nullable`1<CodeAnnotationNullableValue>, NullableStateSource, bool> GetInfo(IAttributesOwner attributesOwner);
    [NullableContextAttribute("2")]
private static IAttributesOwner GetAnnotationSource(IAttributesOwner attributesOwner);
    [NullableContextAttribute("0")]
protected virtual ValueTuple`3<Nullable`1<CodeAnnotationNullableValue>, NullableStateSource, bool> CalculateInfo(IAttributesOwner attributesOwner, IAttributeInstanceCollection attributesInstanceCollection);
    protected virtual ValueTuple`3<Nullable`1<CodeAnnotationNullableValue>, NullableStateSource, bool> CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    [NullableContextAttribute("0")]
protected virtual ValueTuple`3<Nullable`1<CodeAnnotationNullableValue>, NullableStateSource, bool> GetDefaultInfo(IAttributesOwner attributesOwner);
    protected virtual bool ComputeWithoutAttributes();
    protected virtual string DoGetDescription(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> relatedInstances, IEnumerable`1<IAttributeInstance> excludeInstances);
    private Nullable`1<CodeAnnotationNullableValue> GetNullableAttributeValueForSpecialCases(IAttributesOwner attributesOwner);
    public bool IsNullableAttribute(IAttributeInstance attributeInstance);
    public Nullable`1<CodeAnnotationNullableValue> GetNullableAttributeMark(IAttributeInstance attributeInstance);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Nullable`1<CodeAnnotationNullableValue> GetNullableValueByNullableAnnotationOfType(IType type, bool shouldProcessUnconstrainedGenericType);
    [CompilerGeneratedAttribute]
internal static TypeParameterVariance <GetAnnotationFromCompilerAttributes>g__GetVariance|7_0(IAttributesOwner owner);
    [CompilerGeneratedAttribute]
internal static bool <CalculateInfo>g__MergeWithCurrentValue|10_0(CodeAnnotationNullableValue newValue, <>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static bool <CalculateInfo>g__InitializeTopValueIfExists|10_1(<>c__DisplayClass10_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.ObsoleteInfoProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, ObsoleteAnnotationInfo> {
    [CompilerGeneratedAttribute]
private String[] <AttributeShortNames>k__BackingField;
    public String[] AttributeShortNames { get; }
    public ObsoleteInfoProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    [CompilerGeneratedAttribute]
public String[] get_AttributeShortNames();
    protected virtual ObsoleteAnnotationInfo CalculateInfo(IAttributesOwner attributesOwner, IAttributeInstanceCollection attributesInstanceCollection);
    protected virtual ObsoleteAnnotationInfo CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    protected virtual ObsoleteAnnotationInfo GetDefaultInfo(IAttributesOwner attributesOwner);
    [CompilerGeneratedAttribute]
internal static void <CalculateInfo>g__UpdateInfoIfNeed|5_0(IClrTypeName expectedName, AttributesPriority priority, Func`3<IAttributeInstance, IAttributesOwner, ObsoleteAnnotationInfo> obsoleteInfoFactory, <>c__DisplayClass5_0& , <>c__DisplayClass5_1& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.OwnedAnnotationProvider : CodeAnnotationInfoProvider`2<ITypeElement, bool> {
    private static ClrTypeName ourAttributeName;
    public OwnedAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static OwnedAnnotationProvider();
    protected virtual bool CalculateInfo(ITypeElement attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    [NullableContextAttribute("2")]
protected virtual bool GetDefaultInfo(ITypeElement attributesOwner);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CodeAnnotations.ParameterAnnotation : ValueType {
    [CanBeNullAttribute]
public string ParameterName;
    public ContractAnnotationValue Value;
    public ParameterAnnotation(string parameterName, ContractAnnotationValue value);
    public void Deconstruct(String& parameterName, ContractAnnotationValue& value);
    public bool Equals(ParameterAnnotation other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.PathAnnotationInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <BasePath>k__BackingField;
    public string BasePath { get; public set; }
    public PathAnnotationInfo(string BasePath);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_BasePath();
    [CompilerGeneratedAttribute]
public void set_BasePath(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(PathAnnotationInfo left, PathAnnotationInfo right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(PathAnnotationInfo left, PathAnnotationInfo right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(PathAnnotationInfo other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& BasePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.PathReferenceAnnotationProvider : CodeAnnotationInfoProvider`2<IParameter, Nullable`1<PathAnnotationInfo>> {
    public static string PathReferenceAttributeName;
    public PathReferenceAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    public bool TryGetBasePathFromAnnotation(IParameter parameter, String& basePath);
    protected virtual Nullable`1<PathAnnotationInfo> CalculateInfo(IParameter parameter, IEnumerable`1<IAttributeInstance> attributeInstances);
    [NullableContextAttribute("2")]
protected virtual Nullable`1<PathAnnotationInfo> GetDefaultInfo(IParameter attributesOwner);
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.ProjectOutputCodeAnnotationProvider : object {
    private AnnotationsIndex myAnnotationsIndex;
    private ExternalAnnotationsManager myExternalAnnotationsManager;
    private static Key`1<AssemblyExternalAnnotations> ourAssemblyExternalAnnotations;
    public ProjectOutputCodeAnnotationProvider(AnnotationsIndex annotationsIndex, ExternalAnnotationsManager externalAnnotationsManager);
    private static ProjectOutputCodeAnnotationProvider();
    public sealed virtual Nullable`1<CodeAnnotationNullableValue> GetNullableAttribute(IDeclaredElement element);
    public sealed virtual Nullable`1<CodeAnnotationNullableValue> GetContainerElementNullableAttribute(IDeclaredElement element);
    public sealed virtual ICollection`1<IAttributeInstance> GetSpecialAttributeInstances(IClrDeclaredElement element, AttributeInstanceCollection attributeInstanceCollection);
    public ICollection`1<IAttributeInstance> GetSpecialAttributeInstances(IClrDeclaredElement element, bool inherit);
    private static IList`1<IAttributeInstance> GetParameterExternalAttributes(AssemblyExternalAnnotations assemblyExternalAnnotations, IParameter parameter);
}
public enum JetBrains.ReSharper.Psi.CodeAnnotations.ProtobufImplicitFields : Enum {
    public int value__;
    public static ProtobufImplicitFields None;
    public static ProtobufImplicitFields AllPublic;
    public static ProtobufImplicitFields AllFields;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.ProtoContractImplicitFieldsAnnotationProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, ProtobufImplicitFields> {
    public static string ProtoContractAttributeShortName;
    private static ClrTypeName ourProtoContractAttributeTypeName;
    public ProtoContractImplicitFieldsAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration configuration);
    private static ProtoContractImplicitFieldsAnnotationProvider();
    [NullableContextAttribute("2")]
protected virtual ProtobufImplicitFields GetDefaultInfo(IAttributesOwner attributesOwner);
    protected virtual ProtobufImplicitFields CalculateInfo(IAttributesOwner attributesOwner, IAttributeInstanceCollection attributesInstanceCollection);
    protected virtual ProtobufImplicitFields CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    protected virtual bool Accepts(IAttributesOwner attributesOwner);
    [CompilerGeneratedAttribute]
internal static ProtobufImplicitFields <CalculateInfo>g__Calculate|4_0(IAttributeInstance attributeInstance);
}
public class JetBrains.ReSharper.Psi.CodeAnnotations.ProvidesContextAnnotationProvider : SimpleCodeAnnotationProvider {
}
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.PureAnnotationProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, bool> {
    public static string PureAttributeShortName;
    public static IClrTypeName CodeContractsPureAttribute;
    public PureAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static PureAnnotationProvider();
    protected virtual bool CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    protected virtual bool GetDefaultInfo(IAttributesOwner attributesOwner);
    protected virtual string DoGetDescription(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> relatedInstances, IEnumerable`1<IAttributeInstance> excludeInstances);
    public bool IsPureAttribute(IClrTypeName attributeTypeName);
    private bool IsPureAttribute(IAttributeInstance instance);
}
[CodeAnnotationProviderAttribute("16")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.RazorLayoutAnnotationProvider : SimpleCodeAnnotationProvider {
}
[CodeAnnotationProviderAttribute("16")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.RazorSectionAnnotationProvider : SimpleCodeAnnotationProvider {
}
[CodeAnnotationProviderAttribute("16")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.RegexPatternAnnotationProvider : SimpleCodeAnnotationProvider {
}
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.RequireStaticDelegateAnnotationProvider : CodeAnnotationInfoProvider`2<IParameter, StaticRequirement> {
    public static string RequireStaticDelegateAttributeShortName;
    private static string IsErrorPropertyName;
    public RequireStaticDelegateAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static RequireStaticDelegateAnnotationProvider();
    private static AttributeValue GetIsErrorAttributeValue(IAttributeInstance attribute);
    protected virtual StaticRequirement CalculateInfo(IParameter attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    protected virtual StaticRequirement GetDefaultInfo(IParameter attributesOwner);
}
[CodeAnnotationProviderAttribute("16")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.RouteTemplateAnnotationProvider : SimpleCodeAnnotationProvider {
}
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.SetsRequiredMembersAnnotationProvider : CodeAnnotationInfoProvider`2<IConstructor, bool> {
    private static IClrTypeName ourAttributeFqn;
    public SetsRequiredMembersAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static SetsRequiredMembersAnnotationProvider();
    protected virtual bool CalculateInfo(IConstructor attributesOwner, IAttributeInstanceCollection attributesInstanceCollection);
    protected virtual bool CalculateInfo(IConstructor constructor, IEnumerable`1<IAttributeInstance> attributeInstances);
    protected virtual bool GetDefaultInfo(IConstructor constructor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.CodeAnnotations.SimpleCodeAnnotationProvider : object {
    [CompilerGeneratedAttribute]
private string <CodeAnnotationShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackedSimpleAnnotationInfoProvider <PackedAnnotationInfoProvider>k__BackingField;
    public string CodeAnnotationShortName { get; }
    internal int Index { get; internal set; }
    internal IPackedSimpleAnnotationInfoProvider PackedAnnotationInfoProvider { get; internal set; }
    protected SimpleCodeAnnotationProvider(string codeAnnotationShortName);
    [CompilerGeneratedAttribute]
public string get_CodeAnnotationShortName();
    [CompilerGeneratedAttribute]
internal int get_Index();
    [CompilerGeneratedAttribute]
internal void set_Index(int value);
    [CompilerGeneratedAttribute]
internal IPackedSimpleAnnotationInfoProvider get_PackedAnnotationInfoProvider();
    [CompilerGeneratedAttribute]
internal void set_PackedAnnotationInfoProvider(IPackedSimpleAnnotationInfoProvider value);
    [NullableContextAttribute("2")]
public sealed virtual bool GetInfo(IAttributesOwner attributesOwner);
}
[CodeAnnotationProviderAttribute("0")]
internal class JetBrains.ReSharper.Psi.CodeAnnotations.SimpleCodeAnnotationsAggregator : object {
    [NullableAttribute("1")]
private IPackedSimpleAnnotationInfoProvider myProvider;
    [NullableContextAttribute("1")]
public SimpleCodeAnnotationsAggregator(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration, IReadyImmutableList`1<SimpleCodeAnnotationProvider> simpleCodeAnnotationProviders);
    public sealed virtual void Invalidate(PsiChangedElementType changeType);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.SourceTemplateAnnotationProvider : CodeAnnotationInfoProvider`2<IMethod, SourceTemplateConfig> {
    private static string SourceTemplateAttributeShortName;
    private static string SourceTemplateExAttributeShortName;
    public SourceTemplateAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static SourceTemplateAnnotationProvider();
    protected virtual SourceTemplateConfig CalculateInfo(IMethod attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    [NullableContextAttribute("2")]
protected virtual SourceTemplateConfig GetDefaultInfo(IMethod attributesOwner);
}
public class JetBrains.ReSharper.Psi.CodeAnnotations.SourceTemplateConfig : object {
    [CompilerGeneratedAttribute]
private TargetExpression <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumVersion>k__BackingField;
    public TargetExpression Target { get; }
    public int MinimumVersion { get; }
    public SourceTemplateConfig(TargetExpression target, int minimumVersion);
    [CompilerGeneratedAttribute]
public TargetExpression get_Target();
    [CompilerGeneratedAttribute]
public int get_MinimumVersion();
}
public enum JetBrains.ReSharper.Psi.CodeAnnotations.StaticRequirement : Enum {
    public byte value__;
    public static StaticRequirement NoRequirement;
    public static StaticRequirement MustBeStatic;
    public static StaticRequirement MustBeStaticError;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.StringFormatAnnotationProvider : object {
    private JetBrainsStringFormatAnnotationProvider myStringFormatAnnotationProvider;
    private StringSyntaxAnnotationProvider myStringSyntaxAnnotationProvider;
    private MessageTemplateFormatMethodAnnotationsProvider myMessageTemplateFormatMethodAnnotationsProvider;
    private StructuredMessageTemplateAnnotationProvider myStructuredMessageTemplateAnnotationProvider;
    public StringFormatAnnotationProvider(IPsiServices psiServices);
    [PureAttribute]
public static StringFormatAnnotationProvider GetInstance(ITreeNode context);
    [PureAttribute]
public static StringFormatAnnotationProvider GetInstance(IPsiModule psiModule);
    [NullableContextAttribute("2")]
[PureAttribute]
public IParameter GetStringFormatMethodParameter(IParametersOwner parametersOwner);
    [PureAttribute]
public bool IsStructuredMessageTemplateParameter(IParameter parameter);
    [MustUseReturnValueAttribute]
public bool IsStructuredMessageTemplateParameter(IParameter parameter, Boolean& canHavePositionalArguments);
    [PureAttribute]
private bool IsMessageTemplateFormatParameter(IParameter parameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.StringLengthAnnotationProvider : CodeAnnotationInfoProviderForDerivableAttribute`2<IProperty, Nullable`1<int>> {
    public static ClrTypeName AttributeName;
    protected IClrTypeName AttributeClrTypeName { get; }
    public StringLengthAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static StringLengthAnnotationProvider();
    protected virtual IClrTypeName get_AttributeClrTypeName();
    protected virtual bool CanBeDerivedAttributeName(string attributeShortName);
    internal static Nullable`1<int> GetStringLengthFromAttribute(IAttributeInstance attributeInstance);
    [NullableContextAttribute("2")]
protected virtual Nullable`1<int> GetDefaultInfo(IProperty attributesOwner);
    protected virtual Nullable`1<int> CalculateInfoForMatchingAttribute(IAttributeInstance attributeInstance);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.StringSyntaxAnnotationProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, string> {
    public static string CompositeFormat;
    public static string DateOnlyFormat;
    public static string DateTimeFormat;
    public static string EnumFormat;
    public static string GuidFormat;
    public static string Json;
    public static string NumericFormat;
    public static string Regex;
    public static string TimeOnlyFormat;
    public static string TimeSpanFormat;
    public static string Uri;
    public static string Xml;
    private static HashSet`1<string> ourWellKnownSyntaxSet;
    public static string StringSyntaxAttributeShortName;
    private static ClrTypeName ourStringSyntaxAttributeTypeName;
    private ILanguages myLanguages;
    [CompilerGeneratedAttribute]
private String[] <AttributeShortNames>k__BackingField;
    public String[] AttributeShortNames { get; }
    public StringSyntaxAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration, ILanguages languages);
    private static StringSyntaxAnnotationProvider();
    [CompilerGeneratedAttribute]
public String[] get_AttributeShortNames();
    protected virtual string CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    [NullableContextAttribute("2")]
protected virtual string GetDefaultInfo(IAttributesOwner attributesOwner);
    private string GetLanguageName(IAttributeInstance attributeInstance);
}
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.StructuredMessageTemplateAnnotationProvider : CodeAnnotationInfoProvider`2<IParameter, bool> {
    private static string StructuredMessageTemplateAttributeShortName;
    public StructuredMessageTemplateAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    protected virtual bool CalculateInfo(IParameter parameter, IEnumerable`1<IAttributeInstance> attributeInstances);
    protected virtual bool GetDefaultInfo(IParameter parameter);
    [CompilerGeneratedAttribute]
private bool <CalculateInfo>b__2_0(IAttributeInstance attributeInstance);
}
[CodeAnnotationProviderAttribute("16")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.TerminatesMethodAnnotationProvider : SimpleCodeAnnotationProvider {
}
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.UnscopedRefAnnotationProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, bool> {
    private static IClrTypeName UnscopedRefAttribute;
    private static string UnscopedRefAttributeShortName;
    public UnscopedRefAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static UnscopedRefAnnotationProvider();
    public static bool HasUnscopedRefAnnotation(IParameter parameter);
    protected virtual bool CalculateInfo(IAttributesOwner attributesOwner, IAttributeInstanceCollection attributesInstanceCollection);
    protected virtual bool CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    protected virtual bool GetDefaultInfo(IAttributesOwner attributesOwner);
    protected virtual string DoGetDescription(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> relatedInstances, IEnumerable`1<IAttributeInstance> excludeInstances);
}
[CodeAnnotationProviderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeAnnotations.ValueProviderAnnotationProvider : CodeAnnotationInfoProvider`2<IAttributesOwner, String[]> {
    private static string ValueProviderAttributeShortName;
    public ValueProviderAnnotationProvider(AttributeInstancesProvider attributeInstancesProvider, CodeAnnotationsConfiguration codeAnnotationsConfiguration);
    private static ValueProviderAnnotationProvider();
    protected virtual String[] CalculateInfo(IAttributesOwner attributesOwner, IEnumerable`1<IAttributeInstance> attributeInstances);
    protected virtual String[] GetDefaultInfo(IAttributesOwner attributesOwner);
}
public class JetBrains.ReSharper.Psi.CodeStyle.AdditionalFormatterParameters : object {
    [CompilerGeneratedAttribute]
private IProgressIndicator <ProgressIndicator>k__BackingField;
    [CompilerGeneratedAttribute]
private IContextBoundSettingsStore <OverrideSettingsStore>k__BackingField;
    [CompilerGeneratedAttribute]
private IPotentSettingsTracker <SettingsTracker>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutodetectIndentSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableIndentingInsideComments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableFormatterDisabling>k__BackingField;
    [CompilerGeneratedAttribute]
private IFormatterDaemon <FormatterDaemon>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TreatTextAfterLastNodeAsIncorrect>k__BackingField;
    [CompilerGeneratedAttribute]
private MultilanguageAutodetectSessionForSourceFile <DetectSession>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SolutionWideOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForCombiningWithFrontendFormattersInRider>k__BackingField;
    public static AdditionalFormatterParameters Empty;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IProgressIndicator ProgressIndicator { get; public set; }
    public IContextBoundSettingsStore OverrideSettingsStore { get; public set; }
    public IPotentSettingsTracker SettingsTracker { get; public set; }
    public bool AutodetectIndentSettings { get; public set; }
    public bool DisableIndentingInsideComments { get; public set; }
    public bool DisableFormatterDisabling { get; public set; }
    public IFormatterDaemon FormatterDaemon { get; public set; }
    public bool TreatTextAfterLastNodeAsIncorrect { get; public set; }
    public MultilanguageAutodetectSessionForSourceFile DetectSession { get; public set; }
    public bool SolutionWideOperation { get; public set; }
    public bool ForCombiningWithFrontendFormattersInRider { get; public set; }
    public AdditionalFormatterParameters(IProgressIndicator ProgressIndicator, IContextBoundSettingsStore OverrideSettingsStore, IPotentSettingsTracker SettingsTracker, bool AutodetectIndentSettings, bool DisableIndentingInsideComments, bool DisableFormatterDisabling, IFormatterDaemon FormatterDaemon, bool TreatTextAfterLastNodeAsIncorrect, MultilanguageAutodetectSessionForSourceFile DetectSession, bool SolutionWideOperation, bool ForCombiningWithFrontendFormattersInRider);
    [CompilerGeneratedAttribute]
protected AdditionalFormatterParameters(AdditionalFormatterParameters original);
    private static AdditionalFormatterParameters();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IProgressIndicator get_ProgressIndicator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ProgressIndicator(IProgressIndicator value);
    [CompilerGeneratedAttribute]
public IContextBoundSettingsStore get_OverrideSettingsStore();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OverrideSettingsStore(IContextBoundSettingsStore value);
    [CompilerGeneratedAttribute]
public IPotentSettingsTracker get_SettingsTracker();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SettingsTracker(IPotentSettingsTracker value);
    [CompilerGeneratedAttribute]
public bool get_AutodetectIndentSettings();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AutodetectIndentSettings(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableIndentingInsideComments();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DisableIndentingInsideComments(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableFormatterDisabling();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DisableFormatterDisabling(bool value);
    [CompilerGeneratedAttribute]
public IFormatterDaemon get_FormatterDaemon();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FormatterDaemon(IFormatterDaemon value);
    [CompilerGeneratedAttribute]
public bool get_TreatTextAfterLastNodeAsIncorrect();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TreatTextAfterLastNodeAsIncorrect(bool value);
    [CompilerGeneratedAttribute]
public MultilanguageAutodetectSessionForSourceFile get_DetectSession();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DetectSession(MultilanguageAutodetectSessionForSourceFile value);
    [CompilerGeneratedAttribute]
public bool get_SolutionWideOperation();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SolutionWideOperation(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForCombiningWithFrontendFormattersInRider();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ForCombiningWithFrontendFormattersInRider(bool value);
    public static AdditionalFormatterParameters FormatAfterModifications();
    public bool ReallyFormat();
    public AdditionalFormatterParameters ChangeProgressIndicator(IProgressIndicator fmtProgress);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(AdditionalFormatterParameters left, AdditionalFormatterParameters right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(AdditionalFormatterParameters left, AdditionalFormatterParameters right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(AdditionalFormatterParameters other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual AdditionalFormatterParameters <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(IProgressIndicator& ProgressIndicator, IContextBoundSettingsStore& OverrideSettingsStore, IPotentSettingsTracker& SettingsTracker, Boolean& AutodetectIndentSettings, Boolean& DisableIndentingInsideComments, Boolean& DisableFormatterDisabling, IFormatterDaemon& FormatterDaemon, Boolean& TreatTextAfterLastNodeAsIncorrect, MultilanguageAutodetectSessionForSourceFile& DetectSession, Boolean& SolutionWideOperation, Boolean& ForCombiningWithFrontendFormattersInRider);
}
public enum JetBrains.ReSharper.Psi.CodeStyle.AlignmentTabFillStyle : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("Use spaces (looks aligned on any tab size)")]
public static AlignmentTabFillStyle USE_SPACES;
    [LocalizedDescriptionAttribute("Only use tabs (inaccurate)")]
public static AlignmentTabFillStyle USE_TABS_ONLY;
    [LocalizedDescriptionAttribute("Mix tabs and spaces for optimal fill")]
public static AlignmentTabFillStyle OPTIMAL_FILL;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CodeStyle.AutoDetectFormatHelper : object {
    public static OneToSetMap`2<IScalarSetting, object> GetAllSettings(FormattingRangeContext formattingStageContext, List`1<IFormattingRule`2<TSettingsKey, TOptionValue>> rules, AutodetectSession autodetectSession, CodeFormattingContext context, bool canSkipRules);
    public static void AddAllSettings(FormattingRangeContext formattingStageContext, List`1<IFormattingRule`2<TSettingsKey, TOptionValue>> rules, AutodetectSession autodetectSession, CodeFormattingContext context, OneToSetMap`2<IScalarSetting, object> allSettings, bool canSkipRules, Nullable`1<FormattingStageAcceptanceType> stage);
    [ExtensionAttribute]
public static TResultMap[] CartesianProduct(OneToSetMap`2<TIndex, TValue> sourceSets);
    [ExtensionAttribute]
public static void RemoveIrrelevantIndices(OneToSetMap`2<IScalarSetting, object> sourceSets, FormatterSettingValues[]& settingValueSet, TValue[]& results, bool copy);
    [ExtensionAttribute]
public static int CalcCardinality(OneToSetMap`2<TIndex, TValue> sourceSets);
}
public class JetBrains.ReSharper.Psi.CodeStyle.AutodetectSession : object {
    private static int MaxValueCount;
    [NotNullAttribute]
private ILogger myLogger;
    [NotNullAttribute]
private ISolution mySolution;
    [NotNullAttribute]
private IFormatterInfoProvider myProvider;
    [NotNullAttribute]
private Dictionary`2<FormatterSettingSet, ISettingsDetectionResult> myNonTrivialSettings;
    [NotNullAttribute]
private FormatterSettingSet myAllNonTrivialSettings;
    [NotNullAttribute]
private Dictionary`2<object, SettingsPreference> myValuePreferences;
    [NotNullAttribute]
private Dictionary`2<object, SettingsPreference> myValuePreferencesForLineBreaks;
    [NotNullAttribute]
private Dictionary`2<IScalarSetting, int> mySettingPriorities;
    [NotNullAttribute]
private HashSet`1<IScalarSetting> mySettingsEntriesToIgnore;
    [NotNullAttribute]
private HashSet`1<IScalarSetting> mySettingsEntriesNotToDetect;
    [NotNullAttribute]
private HashSet`1<IScalarSetting> myPotentiallyStrictSettings;
    [NotNullAttribute]
private CachedSettings myInitialSettings;
    [NotNullAttribute]
private FormatterSettingValues myStrictSettings;
    private Dictionary`2<FormatterSettingValues, int> mySettingValueSets;
    private List`1<SettingSetStatistic> myStatistics;
    private Dictionary`2<IScalarSetting, IList`1<object>> mySettingValues;
    private JetHashSet`1<IScalarSetting> myUsedSettings;
    private Dictionary`2<IScalarSetting, IntegerSettingValue> myIntSettingValues;
    private Dictionary`2<FormatterSettingValue, OneToSetMap`2<FormatterSettingSet, int>> mySetsByValue;
    public IReadOnlyDictionary`2<FormatterSettingSet, ISettingsDetectionResult> NonTrivialSettings { get; }
    public AutodetectSession(CachedSettings initialSettings, ILogger logger, ISolution solution, IFormatterInfoProvider provider);
    public IReadOnlyDictionary`2<FormatterSettingSet, ISettingsDetectionResult> get_NonTrivialSettings();
    public AutodetectSession Copy();
    public bool ShouldIgnoreSetting(IScalarSetting setting);
    public void EnsureNonEnumSettingValue(IScalarSetting setting, object value);
    private void SetProvider(IFormatterInfoProvider provider);
    public void AddSetting(IScalarSetting setting);
    public void AddValueForIntSetting(IScalarSetting setting, int value, bool max);
    public IList`1<object> GetValuesForSetting(ISelectorOptionNode optionNode);
    public IList`1<object> GetValuesForSetting(IScalarSetting setting);
    private IList`1<object> GetValuesForSetting(IScalarSetting setting, ISelectorOptionNode optionNode);
    public void AddCases(OneToSetMap`2<IScalarSetting, object> settings, FormatterSettingValues[] valueSets, FormatComparisonResult[] results);
    public void AddCase(FormatterSettingSet settingSet, IDetectionContext context, Func`2<IDetectionContext, ISettingsDetectionResult> creator);
    private void AssertCanAddNewNontrivialSettings(FormatterSettingSet settingsToAdd);
    public void AddCase(FormatterSettingValues valueSet, FormatComparisonResult result, int number);
    public void AddCase(FormatterSettingSet set, FormatterSettingValues valueSet, FormatComparisonResult result, int number);
    public FormatterSettingValues CalculateOptimal(IProgressIndicator progress);
    private static void ProcessSyntheticSettings(FormatterSettingValues result);
    private void ProcessIndentFromVs(FormatterSettingValues result);
    private void ProcessForking(SettingMetadata metadata, Score[] scoresTmp, int optimalIndex, Score bestScore, Stack`1<ForkingPoint> forkingStack, List`1<SettingMetadata> settingsList, Int32& pass, Int32& settingIndex, FormatterSettingValues& result, Score& currentScoreSum);
    private void PrepareSettingLists(FrugalLocalHashSet`1<IScalarSetting> indentSettings, List`1& settingsList, List`1& potentiallyStrictSettingsList);
    private void ProcessIndentSize(IScalarSetting indentSizeSetting, FormatterSettingValues result, IProgressIndicator progressIndicator);
    public void CalculateIntSettingValues(FormatterSettingValues result);
    private ValueTuple`2<Score, int> FindOptimalSettingValue(IScalarSetting key, IList`1<object> values, FormatterSettingValues result, Score[] scoresTmp);
    private void AddPreference(IScalarSetting key, SettingsPreference settingsPreference, object value, Int32& preference);
    public StringBuilder Dump();
    [CompilerGeneratedAttribute]
private bool <AssertCanAddNewNontrivialSettings>b__34_0(IScalarSetting setting);
    [CompilerGeneratedAttribute]
internal static int <PrepareSettingLists>g__Comparison|41_0(SettingMetadata firstMetadata, SettingMetadata secondMetadata);
}
public enum JetBrains.ReSharper.Psi.CodeStyle.BraceFormatStyle : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("At end of line (K&R style)")]
public static BraceFormatStyle END_OF_LINE;
    [LocalizedDescriptionAttribute("At end of line (no space)")]
public static BraceFormatStyle END_OF_LINE_NO_SPACE;
    [LocalizedDescriptionAttribute("At next line (BSD style)")]
public static BraceFormatStyle NEXT_LINE;
    [LocalizedDescriptionAttribute("At next line indented (Whitesmiths style)")]
public static BraceFormatStyle NEXT_LINE_SHIFTED;
    [LocalizedDescriptionAttribute("At next line indented 2 (GNU style)")]
public static BraceFormatStyle NEXT_LINE_SHIFTED_2;
}
public enum JetBrains.ReSharper.Psi.CodeStyle.BraceFormatStyleEx : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("At end of line (K&R style)")]
public static BraceFormatStyleEx END_OF_LINE;
    [LocalizedDescriptionAttribute("At end of line (no space)")]
public static BraceFormatStyleEx END_OF_LINE_NO_SPACE;
    [LocalizedDescriptionAttribute("At next line (BSD style)")]
public static BraceFormatStyleEx NEXT_LINE;
    [LocalizedDescriptionAttribute("At next line indented (Whitesmiths style)")]
public static BraceFormatStyleEx NEXT_LINE_SHIFTED;
    [LocalizedDescriptionAttribute("At next line indented 2 (GNU style)")]
public static BraceFormatStyleEx NEXT_LINE_SHIFTED_2;
    [LocalizedDescriptionAttribute("Compact (Pico style)")]
public static BraceFormatStyleEx PICO;
}
public enum JetBrains.ReSharper.Psi.CodeStyle.Casing : Enum {
    public int value__;
    public static Casing AsEntered;
    public static Casing UpperCase;
    public static Casing LowerCase;
    public static Casing AsDefined;
}
public enum JetBrains.ReSharper.Psi.CodeStyle.CodeFormatProfile : Enum {
    public int value__;
    public static CodeFormatProfile DEFAULT;
    public static CodeFormatProfile INDENT;
    public static CodeFormatProfile GENERATOR;
    public static CodeFormatProfile SOFT;
    public static CodeFormatProfile STRICT;
    public static CodeFormatProfile SPACIOUS;
    public static CodeFormatProfile COMPACT;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CodeStyle.CodeFormatterHelper : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICodeFormatter GetCodeFormatter(ITreeNode root);
    [ExtensionAttribute]
public static void FormatNode(ITreeNode root, IProgressIndicator progressIndicator);
    [ExtensionAttribute]
public static void FormatNode(ITreeNode root, CodeFormatProfile profile, IProgressIndicator progressIndicator);
    [ExtensionAttribute]
public static void Format(ICodeFormatter formatter, ITreeNode root, IProgressIndicator progressIndicator, IContextBoundSettingsStore overrideSettingsStore);
    [ExtensionAttribute]
public static void Format(ICodeFormatter formatter, FormatTask firstTask, FormatTask secondTask, AdditionalFormatterParameters parameters);
    [ExtensionAttribute]
public static void FormatNodeWithIntAlignDisabled(ITreeNode root, IProgressIndicator progressIndicator);
    [ExtensionAttribute]
public static void FormatFile(ICodeFormatter formatter, IFile file, CodeFormatProfile profile, IProgressIndicator progressIndicator);
    [ExtensionAttribute]
public static void FormatFileRange(IFile file, TreeTextRange range, CodeFormatProfile profile, IProgressIndicator progressIndicator, OuterSpaceFormatType formatSpacesBefore, OuterSpaceFormatType formatSpacesAfter);
    [ExtensionAttribute]
public static void Format(ICodeFormatter formatter, ITreeNode root, CodeFormatProfile profile, IProgressIndicator progressIndicator, IContextBoundSettingsStore overrideSettingsStore);
    [ExtensionAttribute]
public static void Format(ICodeFormatter formatter, ITreeNode firstElement, ITreeNode lastElement, IProgressIndicator progressIndicator);
    [ExtensionAttribute]
public static ITreeRange Format(ICodeFormatter formatter, ITreeNode firstElement, ITreeNode lastElement, CodeFormatProfile profile, IProgressIndicator progressIndicator);
    [ExtensionAttribute]
public static bool HasNewLineBefore(ITreeNode node);
    [ExtensionAttribute]
public static bool HasNewLineAfter(ITreeNode node);
    [ExtensionAttribute]
public static T AddLineBreakAfter(T node, CodeFormatProfile profile, int minLineBreaks);
    [ExtensionAttribute]
public static T AddLineBreakBefore(T node, CodeFormatProfile profile, int minLineBreaks);
    public static void Format(PsiLanguageType languageType, ISolution solution, DocumentRange docRange, CodeFormatProfile profile, bool formatSpacesBefore, bool formatSpacesAfter, IProgressIndicator progressIndicator);
    public static void Format(PsiLanguageType languageType, ISolution solution, DocumentRange docRange, CodeFormatProfile profile, bool formatSpacesBefore, bool formatSpacesAfter, AdditionalFormatterParameters parameters);
    public static AsteriskType IsAsterisked(string comment);
}
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeStyleSettings", "JetBrains.ReSharper.Psi.Resources.Strings", "CodeFormatterSettingsSettingDescription")]
public class JetBrains.ReSharper.Psi.CodeStyle.CodeFormattingSettingsKey : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.CodeStyle.CodeStyleInspectorBase`1 : object {
    private sealed virtual override ICodeStyleSuggestion JetBrains.ReSharper.Psi.CodeStyle.ICodeStyleInspector.TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IReadOnlyCollection`1<ICodeStyleAdviser> advisers);
    public abstract virtual TCodeStyleSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
    public virtual void DetectSettings(IDetectionContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class JetBrains.ReSharper.Psi.CodeStyle.CodeStyleRecursiveElementModifier : RecursiveElementModifier`1<Unit> {
    [CompilerGeneratedAttribute]
private IEnumerable`1<ICodeStyleInspector> <codeStyleInspectors>P;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IContextBoundSettingsStore <boundSettingsStore>P;
    [CompilerGeneratedAttribute]
private ICodeStyleAdviser[] <advisers>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ModificationMode<Unit> Mode { get; }
    public CodeStyleRecursiveElementModifier(IEnumerable`1<ICodeStyleInspector> codeStyleInspectors, IContextBoundSettingsStore boundSettingsStore, ICodeStyleAdviser[] advisers);
    protected virtual ModificationMode<Unit> get_Mode();
    protected virtual bool Modify(ITreeNode element, Unit context);
}
public abstract class JetBrains.ReSharper.Psi.CodeStyle.CodeStyleSuggestion`1 : object {
    [CompilerGeneratedAttribute]
private TNode <TargetNode>k__BackingField;
    private bool myIsApplied;
    [NotNullAttribute]
protected TNode TargetNode { get; }
    protected CodeStyleSuggestion`1(TNode targetNode);
    [CompilerGeneratedAttribute]
protected TNode get_TargetNode();
    public sealed virtual bool IsValid();
    public sealed virtual ITreeNode Apply();
    protected abstract virtual bool CanBeApplied();
    [CanBeNullAttribute]
protected abstract virtual ITreeNode ApplySuggestion(TNode targetNode);
}
public static class JetBrains.ReSharper.Psi.CodeStyle.CodeStyleUtil : object {
    [NotNullAttribute]
private static ILogger ourLogger;
    private static CodeStyleUtil();
    public static void ApplyRecursive(ITreeNode node, IContextBoundSettingsStore settingsStore, ICodeStyleAdviser[] advisersOverride);
    public static void ApplyRecursive(IEnumerable`1<ICodeStyleInspector> inspectors, ITreeNode node, IContextBoundSettingsStore settingsStore);
    public static void ApplyRecursive(ITreeNode node, IContextBoundSettingsStore settingsStore, ICodeStyleAdviser[] advisersOverride);
    public static void ApplyStyle(ITreeNode node, ICodeStyleAdviser[] advisersOverride);
    [NotNullAttribute]
public static ITreeNode ApplyStyle(ITreeNode node, ICodeStyleAdviser[] advisersOverride);
    public static void ApplyStyle(ITreeNode node, IContextBoundSettingsStore settingsStore, ICodeStyleAdviser[] advisersOverride);
    [CanBeNullAttribute]
public static TCodeStyleSuggestion SuggestStyle(ITreeNode node, ICodeStyleAdviser[] advisersOverride);
    [CanBeNullAttribute]
public static TCodeStyleSuggestion SuggestStyle(ITreeNode node, ILanguageManager languageManager, IContextBoundSettingsStore settingsStore, ICodeStyleAdviser[] advisersOverride);
    public static void ApplyStylesForRange(IRangeMarker rangeMarker, ISolution solution, IContextBoundSettingsStore settingsStore, ILanguageManager languageManager, PsiLanguageType languageType, IReadOnlyList`1<ICodeStyleInspector> inspectors);
    private static void ExecuteActionOverNodes(IFile file, IRangeMarker originalRange, bool leaveOnlyTopmostNodes, Action`1<IEnumerable`1<ITreeNode>> actionWithNodes);
    [NotNullAttribute]
private static ITreeNode FindTopmostContainedInRangeParent(ITreeNode node, TreeTextRange range);
    [CanBeNullAttribute]
private static IPsiSourceFile TryGetPsiSourceFile(IRangeMarker rangeMarker, ISolution solution);
    [NotNullAttribute]
private static IEnumerable`1<IFile> GetPsiFiles(ISolution solution, IRangeMarker rangeMarker, PsiLanguageType languageType, IPsiSourceFile psiSourceFile);
    public static void DetectSettings(IRangeMarker rangeMarker, ISolution solution, ILanguageManager languageManager, PsiLanguageType languageType, object contextObject, IContextBoundSettingsStore settingsStore);
    [CanBeNullAttribute]
private static INodeChangeableDetectionContext TryGetContextFrom(object contextObject, PsiLanguageType languageType, IFormatterInfoProvider provider, ISolution solution, IContextBoundSettingsStore settingsStore);
    private static void DetectSettings(IRangeMarker rangeMarker, ISolution solution, ILanguageManager languageManager, PsiLanguageType languageType, IPsiSourceFile psiSourceFile, INodeChangeableDetectionContext context);
    public static void DetectSettings(IFile file, ISolution solution, ILanguageManager languageManager, object contextObject);
}
[SettingsKeyAttribute("JetBrains.ReSharper.Psi.CodeStyle.CodeFormattingSettingsKey", "JetBrains.ReSharper.Psi.Resources.Strings", "CommonFormatterSettingsSettingDescription")]
[EditorConfigKeyAttribute("")]
public class JetBrains.ReSharper.Psi.CodeStyle.CommonFormatterSettingsKey : object {
    public static string ENFORCE_LINE_ENDING_STYLE_NAME;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "UseIndentSettingsFromMainLanguageInFileAsVisualStudioDoesSettingDescription")]
public bool USE_INDENTS_FROM_MAIN_LANGUAGE_IN_FILE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "AutoDetectIndentSizeAndIndentStyleSettingDescription")]
public bool AUTODETECT_INDENT_SETTINGS;
    [EditorConfigEntryAliasAttribute("", "1")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "DefaultLineEndingStyleSettingDescription")]
public LineEndingStyle END_OF_LINE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "EnforceLineEndingStyleOnFullReformatSettingDescription")]
public bool ENFORCE_LINE_ENDING_STYLE;
    [ObsoleteAttribute]
[ExcludeFromEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "HowToAlignWhenTabsAreUsedForIndentsSettingDescription")]
public AlignmentTabFillStyle ALIGNMENT_TAB_FILL_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "ShowAutodetectAndConfigureFormattingTipSettingDescription")]
public bool SHOW_AUTODETECT_CONFIGURE_FORMATTING_TIP;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Enable formatter control markers")]
public bool FORMATTER_TAGS_ENABLED;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "Treat formatter control markers as regexps")]
public bool FORMATTER_TAGS_ACCEPT_REGEXP;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "ON formatter control marker (usually it equals '@formatter:on')")]
public string FORMATTER_ON_TAG;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "OFF formatter control marker (usually it equals '@formatter:off')")]
public string FORMATTER_OFF_TAG;
    private static CommonFormatterSettingsKey();
}
public class JetBrains.ReSharper.Psi.CodeStyle.Contexts.AutodetectSessionDetectionContext : DetectionContextBase {
    [NotNullAttribute]
protected AutodetectSession Session;
    public AutodetectSessionDetectionContext(ISolution solution, IContextBoundSettingsStore store, AutodetectSession session);
    public sealed virtual void AddCase(IScalarSetting setting, object value);
    public virtual void AddCase(FormatterSettingSet settingSet, Func`2<IDetectionContext, ISettingsDetectionResult> creator);
    public virtual void AddCase(FormatterSettingValues formatterSettingValues);
    public sealed virtual void AddFlagsEnumCase(SyntheticEnumSettingMetadata metadata);
    public sealed virtual void AddFlagsEnumCase(FormatterSettingValues formatterSettingValues, IEnumerable`1<SyntheticEnumSettingMetadata> syntheticSettingsMetadata);
}
public abstract class JetBrains.ReSharper.Psi.CodeStyle.Contexts.DetectionContextBase : object {
    [NotNullAttribute]
private Dictionary`2<IScalarSetting, Dictionary`2<long, SyntheticEnumOptionSetting>> myFlagsEnumSettings;
    [NotNullAttribute]
private IDictionary`2<object, IScalarSetting> myCachedSettings;
    [NotNullAttribute]
private ICalculatedSettingsSchema mySchema;
    [CompilerGeneratedAttribute]
private IContextBoundSettingsStore <Store>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <Node>k__BackingField;
    public IContextBoundSettingsStore Store { get; }
    public ITreeNode Node { get; private set; }
    protected DetectionContextBase(ISolution solution, IContextBoundSettingsStore store);
    [CompilerGeneratedAttribute]
public sealed virtual IContextBoundSettingsStore get_Store();
    [CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_Node();
    [CompilerGeneratedAttribute]
private void set_Node(ITreeNode value);
    public sealed virtual TSettingValue TryGetSettingValue(IScalarSetting setting);
    public sealed virtual IScalarSetting`1<TEntryValue> GetSetting(Expression`1<Func`2<TKeyClass, TEntryValue>> lambdaExpression);
    [CanBeNullAttribute]
protected ISyntheticSetting GetFlagsEnumSyntheticSetting(SyntheticEnumSettingMetadata metadata);
    public sealed virtual void UpdateNode(ITreeNode node);
}
public interface JetBrains.ReSharper.Psi.CodeStyle.Contexts.IDetectionContext {
    public abstract virtual void AddCase(IScalarSetting setting, object value);
    public abstract virtual void AddCase(FormatterSettingSet settingSet, Func`2<IDetectionContext, ISettingsDetectionResult> creator);
    public abstract virtual void AddCase(FormatterSettingValues formatterSettingValues);
    public abstract virtual void AddFlagsEnumCase(SyntheticEnumSettingMetadata metadata);
    public abstract virtual void AddFlagsEnumCase(FormatterSettingValues formatterSettingValues, IEnumerable`1<SyntheticEnumSettingMetadata> syntheticSettingsMetadata);
}
internal interface JetBrains.ReSharper.Psi.CodeStyle.Contexts.INodeChangeableDetectionContext {
    public abstract virtual void UpdateNode(ITreeNode newNode);
}
public interface JetBrains.ReSharper.Psi.CodeStyle.Contexts.IReadOnlyDetectionContext {
    [NotNullAttribute]
public IContextBoundSettingsStore Store { get; }
    [CanBeNullAttribute]
public ITreeNode Node { get; }
    public abstract virtual IContextBoundSettingsStore get_Store();
    public abstract virtual ITreeNode get_Node();
    [CanBeNullAttribute]
public abstract virtual TSettingValue TryGetSettingValue(IScalarSetting setting);
    [NotNullAttribute]
public abstract virtual IScalarSetting`1<TEntryValue> GetSetting(Expression`1<Func`2<TKeyClass, TEntryValue>> lambdaExpression);
}
public class JetBrains.ReSharper.Psi.CodeStyle.Contexts.SettingsTrackerDetectionContext : DetectionContextBase {
    [NotNullAttribute]
private IPotentSettingsTracker mySettingsTracker;
    public SettingsTrackerDetectionContext(ISolution solution, IContextBoundSettingsStore store, IPotentSettingsTracker settingsTracker);
    public sealed virtual void AddCase(IScalarSetting setting, object value);
    public sealed virtual void AddCase(FormatterSettingSet settingSet, Func`2<IDetectionContext, ISettingsDetectionResult> creator);
    public sealed virtual void AddCase(FormatterSettingValues formatterSettingValues);
    public sealed virtual void AddFlagsEnumCase(SyntheticEnumSettingMetadata metadata);
    public sealed virtual void AddFlagsEnumCase(FormatterSettingValues formatterSettingValues, IEnumerable`1<SyntheticEnumSettingMetadata> syntheticSettingsMetadata);
}
public enum JetBrains.ReSharper.Psi.CodeStyle.ContinuousLineIndent : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("None")]
public static ContinuousLineIndent None;
    [LocalizedDescriptionAttribute("Single")]
public static ContinuousLineIndent Single;
    [LocalizedDescriptionAttribute("Double")]
public static ContinuousLineIndent Double;
}
public enum JetBrains.ReSharper.Psi.CodeStyle.CustomIndentType : Enum {
    public int value__;
    public static CustomIndentType RelativeLineCalculation;
    public static CustomIndentType RelativeNodeCalculation;
    public static CustomIndentType DirectCalculation;
}
public class JetBrains.ReSharper.Psi.CodeStyle.DisableLineBreakChangesInCodeFormatterCookie : object {
    [CompilerGeneratedAttribute]
private ITreeNode <Node>k__BackingField;
    public ITreeNode Node { get; }
    public DisableLineBreakChangesInCodeFormatterCookie(ITreeNode node);
    [CompilerGeneratedAttribute]
public ITreeNode get_Node();
    public static IDisposable CreateForEntireLine(ITreeNode node);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CodeStyle.DocumentRangeFormatTask : ValueType {
    [CompilerGeneratedAttribute]
private DocumentRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeFormatProfile <Profile>k__BackingField;
    public DocumentRange Range { get; public set; }
    public CodeFormatProfile Profile { get; public set; }
    public DocumentRangeFormatTask(DocumentRange Range, CodeFormatProfile Profile);
    [CompilerGeneratedAttribute]
public DocumentRange get_Range();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Range(DocumentRange value);
    [CompilerGeneratedAttribute]
public CodeFormatProfile get_Profile();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Profile(CodeFormatProfile value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DocumentRangeFormatTask left, DocumentRangeFormatTask right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DocumentRangeFormatTask left, DocumentRangeFormatTask right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DocumentRangeFormatTask other);
    [CompilerGeneratedAttribute]
public void Deconstruct(DocumentRange& Range, CodeFormatProfile& Profile);
}
public enum JetBrains.ReSharper.Psi.CodeStyle.EmptyBlockStyle : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("On different lines")]
public static EmptyBlockStyle MULTILINE;
    [LocalizedDescriptionAttribute("Place braces together")]
public static EmptyBlockStyle TOGETHER;
    [LocalizedDescriptionAttribute("Together on the same line")]
public static EmptyBlockStyle TOGETHER_SAME_LINE;
    [LocalizedDescriptionAttribute("Do not change")]
public static EmptyBlockStyle DO_NOT_CHANGE;
}
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeStyleSettings", "JetBrains.ReSharper.Psi.Resources.Strings", "DefaultFileHeaderSettingDescription")]
public class JetBrains.ReSharper.Psi.CodeStyle.FileHeaderSettingsKey : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "FileHeaderTextSettingDescription")]
public string FileHeaderText;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "FileHeaderRegionNameSettingDescription")]
public string FileHeaderRegionName;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "FileHeaderRegexSettingDescription")]
public string FileHeaderRegex;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "FileHeaderVariablesSettingDescription")]
public IIndexedEntry`2<string, string> FileHeaderVariables;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "FileHeaderDecorationSettingDescription")]
public string FileHeaderDecoration;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "UseStyleCopStyleXmlHeaderSettingDescription")]
public bool UseStyleCopStyleXmlHeader;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "IsDocumentHeaderParserTriggeredDescription")]
public bool IsDocumentHeaderParserTriggered;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "IsIndentationParserTriggeredDescription")]
public bool IsIndentationParserTriggered;
}
public enum JetBrains.ReSharper.Psi.CodeStyle.FormatComparisonResult : Enum {
    public int value__;
    public static FormatComparisonResult False;
    public static FormatComparisonResult True;
    public static FormatComparisonResult TrueWithLineBreaks;
}
public class JetBrains.ReSharper.Psi.CodeStyle.FormatTask : object {
    private ITreeNode myFirstElement;
    [CompilerGeneratedAttribute]
private ITreeNode <LastElement>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtNode <VirtFirstElement>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtNode <VirtLastElement>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeFormatProfile <Profile>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeRangePointer <Pointer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FromFileStart>k__BackingField;
    [CompilerGeneratedAttribute]
private IFile <File>k__BackingField;
    public ITreeNode FirstElement { get; public set; }
    public ITreeNode LastElement { get; public set; }
    public VirtNode VirtFirstElement { get; public set; }
    public VirtNode VirtLastElement { get; public set; }
    public ITreeNode AnyElement { get; }
    public CodeFormatProfile Profile { get; }
    private ITreeRangePointer Pointer { get; private set; }
    public bool FromFileStart { get; public set; }
    public IFile File { get; }
    public FormatTask(ITreeNode firstElement, ITreeNode lastElement, CodeFormatProfile profile);
    public void Save();
    public bool IsValid();
    public void Restore();
    public void FreeRangeMarkers();
    public void Adjust(ICodeFormatterImpl codeFormatter);
    public ITreeNode get_FirstElement();
    public void set_FirstElement(ITreeNode value);
    [CompilerGeneratedAttribute]
public ITreeNode get_LastElement();
    [CompilerGeneratedAttribute]
public void set_LastElement(ITreeNode value);
    [CompilerGeneratedAttribute]
public VirtNode get_VirtFirstElement();
    [CompilerGeneratedAttribute]
public void set_VirtFirstElement(VirtNode value);
    [CompilerGeneratedAttribute]
public VirtNode get_VirtLastElement();
    [CompilerGeneratedAttribute]
public void set_VirtLastElement(VirtNode value);
    public ITreeNode get_AnyElement();
    [CompilerGeneratedAttribute]
public CodeFormatProfile get_Profile();
    [CompilerGeneratedAttribute]
private ITreeRangePointer get_Pointer();
    [CompilerGeneratedAttribute]
private void set_Pointer(ITreeRangePointer value);
    [CompilerGeneratedAttribute]
public bool get_FromFileStart();
    [CompilerGeneratedAttribute]
public void set_FromFileStart(bool value);
    [CompilerGeneratedAttribute]
public IFile get_File();
    public sealed virtual int CompareTo(FormatTask other);
    public sealed virtual int CompareTo(object obj);
}
public enum JetBrains.ReSharper.Psi.CodeStyle.FormatterDirectiveType : Enum {
    public int value__;
    public static FormatterDirectiveType Start;
    public static FormatterDirectiveType End;
}
public class JetBrains.ReSharper.Psi.CodeStyle.FormatterSettingSet : HashSet`1<IScalarSetting> {
    public FormatterSettingSet(IEnumerable`1<IScalarSetting> collection);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.CodeStyle.FormatterSettingValues : Dictionary`2<IScalarSetting, object> {
    public FormatterSettingValues(IDictionary`2<IScalarSetting, object> formatterSettingValues);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public void Add(KeyValuePair`2<IScalarSetting, object> setting);
    public bool IsCompatibleWith(FormatterSettingValues settings);
    public bool IsCompatibleWith(FormatterSettingValues settings, IScalarSetting ignore);
    public void MergeWith(FormatterSettingValues settings);
    public string FormatValues(FormatterSettingSet set);
    public virtual string ToString();
    public void IntersectWith(FormatterSettingValues settings);
    public void SetValuesToSettings(FmtSettingsHolder`1<TKey> settings);
}
public class JetBrains.ReSharper.Psi.CodeStyle.GlobalFormatSettings : object {
    [CompilerGeneratedAttribute]
private bool <InsertTabs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndentSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TabSize>k__BackingField;
    public bool InsertTabs { get; }
    public int IndentSize { get; }
    public int TabSize { get; }
    public GlobalFormatSettings(bool insertTabs, int indentSize, int tabSize);
    [CompilerGeneratedAttribute]
public bool get_InsertTabs();
    [CompilerGeneratedAttribute]
public int get_IndentSize();
    [CompilerGeneratedAttribute]
public int get_TabSize();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.CodeStyle.GlobalFormatSettingsHelper : object {
    [NotNullAttribute]
public static IGlobalFormatSettingsService GetService(ISolution solution);
    [ExtensionAttribute]
[NotNullAttribute]
public static FormatSettingsKeyBase GetFormatterSettings(IPsiSourceFile sourceFile, PsiLanguageType languageType, ISolution solution, IContextBoundSettingsStore store);
    [ExtensionAttribute]
public static IFormatSettingsService GetFormatSettingsService(PsiLanguageType languageType, ISolution solution);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IProperty`1<FormatSettingsKeyBase> GetFormatterSettingWithEditorConfig(IDocument document, Lifetime lifetime, ISolution solution);
    [ExtensionAttribute]
public static Whitespace GetIndentWhitespace(FmtCachedSettings`1<TKey> settings);
    [ExtensionAttribute]
public static Whitespace GetIndentWhitespace(CachedSettings settings, IFormatterInfoProvider provider);
    [ExtensionAttribute]
public static Whitespace GetIndentWhitespace(FormatSettingsKeyBase settings);
    [ExtensionAttribute]
public static string GetIndentStr(FormatSettingsKeyBase settings);
}
public interface JetBrains.ReSharper.Psi.CodeStyle.ICodeFormatter {
    public PsiLanguageType LanguageType { get; }
    public bool SupportsSettingsTracking { get; }
    public bool SupportsAdditionalProfiles { get; }
    public bool SupportsWrapping { get; }
    public bool SupportsAutoDetect { get; }
    public bool SupportsReindenting { get; }
    public bool PotentiallySupportsFormatterDaemon { get; }
    public bool SupportsFormattingWithAccu { get; }
    public abstract virtual PsiLanguageType get_LanguageType();
    public abstract virtual void FormatFile(IFile file, CodeFormatProfile profile, AdditionalFormatterParameters parameters);
    public abstract virtual void Format(ITreeNode root, CodeFormatProfile profile, AdditionalFormatterParameters parameters);
    public abstract virtual ITreeRange Format(ITreeNode firstElement, ITreeNode lastElement, CodeFormatProfile profile, AdditionalFormatterParameters parameters);
    public abstract virtual void Format(FormatTask[] formatTasks, AdditionalFormatterParameters parameters);
    public abstract virtual void FormatInsertedNodes(ITreeNode nodeFirst, ITreeNode nodeLast, bool formatSurround, bool indentSurround);
    public abstract virtual ITreeRange FormatInsertedRange(ITreeNode nodeFirst, ITreeNode nodeLast, ITreeRange origin);
    public abstract virtual void FormatReplacedNode(ITreeNode oldNode, ITreeNode newNode);
    public abstract virtual void FormatReplacedRange(ITreeNode first, ITreeNode last, ITreeRange oldNodes);
    public abstract virtual void FormatDeletedNodes(ITreeNode parent, ITreeNode prevNode, ITreeNode nextNode);
    public abstract virtual void InsertLineFeedAtFileEndIfNeeded(IFile fileNode, IContextBoundSettingsStore overrideSettingsStore);
    public abstract virtual Pair`2<string, FormatterDirectiveType> GetFormatterRegionTypeFromComment(IComment comment);
    public abstract virtual Pair`2<string, string> GenerateOverrideComments(Pair`2[] settings, string lineEnding);
    public abstract virtual bool get_SupportsSettingsTracking();
    public abstract virtual bool get_SupportsAdditionalProfiles();
    public abstract virtual bool get_SupportsWrapping();
    public abstract virtual bool get_SupportsAutoDetect();
    public abstract virtual bool get_SupportsReindenting();
    public abstract virtual bool get_PotentiallySupportsFormatterDaemon();
    public abstract virtual bool get_SupportsFormattingWithAccu();
    public abstract virtual bool SupportsFormatterDaemon(IFile fileNode, IContextBoundSettingsStore overrideSettingsStore);
    public abstract virtual FileChangeAccu CalculateFormattingChanges(DocumentRangeFormatTask[] formatTasks, IPsiSourceFile sourceFile, AdditionalFormatterParameters parameters);
}
public interface JetBrains.ReSharper.Psi.CodeStyle.ICodeStyleAdviser {
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.CodeStyle.ICodeStyleInspector {
    public abstract virtual void DetectSettings(IDetectionContext context);
    public abstract virtual ICodeStyleSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IReadOnlyCollection`1<ICodeStyleAdviser> advisers);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.CodeStyle.ICodeStyleInspector`1 {
    public abstract virtual TCodeStyleSuggestion TrySuggest(ITreeNode node, IContextBoundSettingsStore boundSettingsStore, IEnumerable`1<ICodeStyleAdviser> advisers);
}
[NullableContextAttribute("2")]
public interface JetBrains.ReSharper.Psi.CodeStyle.ICodeStyleSuggestion {
    public abstract virtual bool IsValid();
    public abstract virtual ITreeNode Apply();
}
[NullableContextAttribute("2")]
public interface JetBrains.ReSharper.Psi.CodeStyle.ICodeStyleSuggestionPointer {
    public abstract virtual ICodeStyleSuggestion Find();
}
public interface JetBrains.ReSharper.Psi.CodeStyle.IFormatSettingsService {
    [NotNullAttribute]
public abstract virtual FormatSettingsKeyBase GetFormatterSettings(ISolution solution, IPsiSourceFile sourceFile, IContextBoundSettingsStore settingsStore, bool autodetectIndentSettings);
    public abstract virtual IProperty`1<FormatSettingsKeyBase> GetFormatterSettingsLive(Lifetime lifetime, ISolution solution, IPsiSourceFile sourceFile);
    public abstract virtual Type GetSettingsKeyType();
}
public interface JetBrains.ReSharper.Psi.CodeStyle.IGlobalFormatSettingsService {
    public abstract virtual GlobalFormatSettings GetDefaultSettings();
    public abstract virtual GlobalFormatSettings GetLangSettings(PsiLanguageType languageType);
    public abstract virtual GlobalFormatSettings GetLangSettings(ProjectFileType projectFileType);
}
public interface JetBrains.ReSharper.Psi.CodeStyle.IPotentSettingsTracker {
    public abstract virtual void RegisterUsedSettings(IEnumerable`1<IScalarSetting> settings);
    public abstract virtual void RegisterUsedSetting(IScalarSetting setting);
}
public interface JetBrains.ReSharper.Psi.CodeStyle.ISettingsDetectionResult {
    public abstract virtual FormatterSettingValues GetSettings(ICalculatedSettingsSchema schema);
    public abstract virtual void UpdateWith(IDetectionContext context);
}
public interface JetBrains.ReSharper.Psi.CodeStyle.ISupportsCodeStyleSuggestionPointer {
    [NullableContextAttribute("1")]
public abstract virtual ICodeStyleSuggestionPointer CreatePointer();
}
public interface JetBrains.ReSharper.Psi.CodeStyle.ISyntheticSetting {
    [NotNullAttribute]
public IScalarSetting ParentSetting { get; }
    public abstract virtual IScalarSetting get_ParentSetting();
    [NotNullAttribute]
public abstract virtual object ComputeParentSettingValue(IEnumerable`1<ISyntheticSetting> otherSyntheticSettings, IReadOnlyDictionary`2<IScalarSetting, object> detectionResult);
}
public enum JetBrains.ReSharper.Psi.CodeStyle.LineEndingStyle : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("LF (Unix, Mac OS X)")]
public static LineEndingStyle LF;
    [LocalizedDescriptionAttribute("CR+LF (Windows)")]
public static LineEndingStyle CRLF;
    [LocalizedDescriptionAttribute("CR (Mac OS classic)")]
public static LineEndingStyle CR;
    [LocalizedDescriptionAttribute("System-dependent (native for OS)")]
public static LineEndingStyle NATIVE;
}
public class JetBrains.ReSharper.Psi.CodeStyle.MultilanguageAutodetectSession : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<PsiLanguageType, AutodetectSession> <SessionsPerLanguage>k__BackingField;
    private Dictionary`2<PsiLanguageType, AutodetectSession> SessionsPerLanguage { get; }
    [CompilerGeneratedAttribute]
private Dictionary`2<PsiLanguageType, AutodetectSession> get_SessionsPerLanguage();
    public AutodetectSession GetLanguageSession(PsiLanguageType languageType, IFormatterInfoProvider provider, CachedSettings initialSettings, ILogger logger, ISolution solution);
    public MultilanguageAutodetectSessionForSourceFile CreateFileSession();
    public void AcceptFileSession(MultilanguageAutodetectSessionForSourceFile childSession);
    public IEnumerable`1<PsiLanguageType> GetLanguages();
    public FormatterSettingValues CalculateOptimal(IProgressIndicator progress);
}
public class JetBrains.ReSharper.Psi.CodeStyle.MultilanguageAutodetectSessionForSourceFile : object {
    [CompilerGeneratedAttribute]
private MultilanguageAutodetectSession <ParentSession>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<PsiLanguageType, AutodetectSession> <SessionsPerLanguage>k__BackingField;
    public MultilanguageAutodetectSession ParentSession { get; }
    internal Dictionary`2<PsiLanguageType, AutodetectSession> SessionsPerLanguage { get; }
    public MultilanguageAutodetectSessionForSourceFile(MultilanguageAutodetectSession parentSession);
    [CompilerGeneratedAttribute]
public MultilanguageAutodetectSession get_ParentSession();
    [CompilerGeneratedAttribute]
internal Dictionary`2<PsiLanguageType, AutodetectSession> get_SessionsPerLanguage();
    public AutodetectSession GetLanguageSession(PsiLanguageType languageType, IFormatterInfoProvider provider, CachedSettings initialSettings, ILogger logger, ISolution solution);
    public FormatterSettingValues CalculateOptimal();
}
public enum JetBrains.ReSharper.Psi.CodeStyle.NestedTernaryExpressionStyle : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("Simple wrap/Do not change")]
public static NestedTernaryExpressionStyle SIMPLE_WRAP;
    [LocalizedDescriptionAttribute("Chop in existing style")]
public static NestedTernaryExpressionStyle AUTODETECT;
    [LocalizedDescriptionAttribute("Chop in compact style")]
public static NestedTernaryExpressionStyle COMPACT;
    [LocalizedDescriptionAttribute("Chop in expanded style")]
public static NestedTernaryExpressionStyle EXPANDED;
}
public enum JetBrains.ReSharper.Psi.CodeStyle.OuterSpaceFormatType : Enum {
    public int value__;
    public static OuterSpaceFormatType DoNotFormat;
    public static OuterSpaceFormatType AlwaysFormat;
    public static OuterSpaceFormatType FormatIfBoundTokenIsSpaceSafe;
    public static OuterSpaceFormatType FormatIfBoundTokenIsSpace;
}
public enum JetBrains.ReSharper.Psi.CodeStyle.ParsFormatStyle : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("Inside parenthesis (BSD/K&R style)")]
public static ParsFormatStyle INSIDE;
    [LocalizedDescriptionAttribute("Parenthesis and inside equally (Whitesmiths style)")]
public static ParsFormatStyle OUTSIDE;
    [LocalizedDescriptionAttribute("Parenthesis 1x, inside 2x (GNU style)")]
public static ParsFormatStyle OUTSIDE_AND_INSIDE;
    [LocalizedDescriptionAttribute("No indent")]
public static ParsFormatStyle NONE;
}
public enum JetBrains.ReSharper.Psi.CodeStyle.PlaceOnSameLineAsOwner : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("Never")]
[EditorConfigValueAliasAttribute("false", "True")]
public static PlaceOnSameLineAsOwner NEVER;
    [LocalizedDescriptionAttribute("If owner is singleline")]
public static PlaceOnSameLineAsOwner IF_OWNER_IS_SINGLE_LINE;
    [LocalizedDescriptionAttribute("Always")]
[EditorConfigValueAliasAttribute("true", "True")]
public static PlaceOnSameLineAsOwner ALWAYS;
}
public enum JetBrains.ReSharper.Psi.CodeStyle.Position : Enum {
    public int value__;
    public static Position Before;
    public static Position Inside;
    public static Position After;
}
[MeansImplicitUseAttribute("3")]
[BaseTypeRequiredAttribute("JetBrains.Application.Configuration.IXmlReadable")]
public class JetBrains.ReSharper.Psi.CodeStyle.SettingsUpgrade.CodeStyleSettingsAttribute : PartAttribute {
    private string myTagName;
    public string TagName { get; }
    public CodeStyleSettingsAttribute(string tagName);
    public string get_TagName();
}
[ObsoleteAttribute("Deprecated settings, use new classes like CSharpMemberOrderPatternSettings and his friends")]
public class JetBrains.ReSharper.Psi.CodeStyle.SettingsUpgrade.CodeStyleSettingsObsolete : object {
    private static string EXPORTED_ROOT_ELEMENT_NAME;
    private Dictionary`2<Type, ExternalizableInfo> mySettings;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
private bool myCopyXMLCommentsOnOverride;
    private string myFileHeaderRegionName;
    private string myFileHeaderText;
    private GenerateMemberBodySettings myGenerateMemberBodySettings;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
private String[] myGeneratedCodeRegions;
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
private String[] myGeneratedFileMasks;
    private CodeStyleSettingsManager myCodeStyleSettingsManager;
    public string FileHeaderText { get; public set; }
    public string FileHeaderRegionName { get; public set; }
    public bool CopyXmlCommentsOnOverride { get; public set; }
    public String[] GeneratedCodeRegionsObsolete { get; public set; }
    public String[] GeneratedFileMasksObsolete { get; public set; }
    public MethodImplementationKind MethodImplementationKind { get; }
    public AccessorImplementationKind AccessorImplementationKind { get; }
    public CodeStyleSettingsObsolete(CodeStyleSettingsManager codeStyleSettingsManager);
    public string get_FileHeaderText();
    public void set_FileHeaderText(string value);
    public string get_FileHeaderRegionName();
    public void set_FileHeaderRegionName(string value);
    public bool get_CopyXmlCommentsOnOverride();
    public void set_CopyXmlCommentsOnOverride(bool value);
    public String[] get_GeneratedCodeRegionsObsolete();
    public void set_GeneratedCodeRegionsObsolete(String[] value);
    public String[] get_GeneratedFileMasksObsolete();
    public void set_GeneratedFileMasksObsolete(String[] value);
    public MethodImplementationKind get_MethodImplementationKind();
    public AccessorImplementationKind get_AccessorImplementationKind();
    private sealed virtual override object System.ICloneable.Clone();
    public CodeStyleSettingsObsolete Clone();
    public sealed virtual void ReadFromXml(XmlElement element);
    public T Get();
    public void ReadFromXmlFile(VirtualFileSystemPath filename);
    public void UpgradeFromXml(XmlElement element, Version version);
}
public enum JetBrains.ReSharper.Psi.CodeStyle.SettingsUpgrade.CodeStyleSettingsSharing : Enum {
    public int value__;
    public static CodeStyleSettingsSharing USER;
    public static CodeStyleSettingsSharing SOLUTION;
    public static CodeStyleSettingsSharing EXTERNAL;
}
[GlobalSettingsUpgraderAttribute("0")]
[SolutionSettingsUpgraderAttribute("0")]
public class JetBrains.ReSharper.Psi.CodeStyle.SettingsUpgrade.FileHeaderSettingUpgrade : CodeStyleSettingsUpgrade {
    public FileHeaderSettingUpgrade(ShellPartCatalogSet partsSet, ISolution solution);
    protected virtual void DoUpgrade(CodeStyleSettingsObsolete codeStyleSettings, IContextBoundSettingsStore contextBoundSettingsStore);
}
public enum JetBrains.ReSharper.Psi.CodeStyle.SimpleEmbeddedStatementStyle : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("Do not change")]
public static SimpleEmbeddedStatementStyle DO_NOT_CHANGE;
    [LocalizedDescriptionAttribute("Force put on single line")]
public static SimpleEmbeddedStatementStyle ON_SINGLE_LINE;
    [LocalizedDescriptionAttribute("Force line breaks")]
public static SimpleEmbeddedStatementStyle LINE_BREAK;
}
public enum JetBrains.ReSharper.Psi.CodeStyle.SpecialIndent : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("No indent")]
public static SpecialIndent NO_INDENT;
    [LocalizedDescriptionAttribute("Indent as usual")]
public static SpecialIndent USUAL_INDENT;
    [LocalizedDescriptionAttribute("Outdent")]
public static SpecialIndent OUTDENT;
    [LocalizedDescriptionAttribute("Do not change")]
public static SpecialIndent DO_NOT_CHANGE;
}
internal class JetBrains.ReSharper.Psi.CodeStyle.SyntaxStyleElementProcessor : object {
    [NotNullAttribute]
private ICodeStyleInspector[] myInspectors;
    [NotNullAttribute]
private INodeChangeableDetectionContext myContext;
    public bool ProcessingIsFinished { get; }
    public SyntaxStyleElementProcessor(ICodeStyleInspector[] inspectors, INodeChangeableDetectionContext context);
    public sealed virtual bool get_ProcessingIsFinished();
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
}
public class JetBrains.ReSharper.Psi.CodeStyle.SyntheticEnumOptionSetting : object {
    [NotNullAttribute]
private IContextBoundSettingsStore myContextBoundSettingsStore;
    [NotNullAttribute]
private IProperty`1<bool> myValueLive;
    [CompilerGeneratedAttribute]
private IScalarSetting <ParentSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EnumValueName>k__BackingField;
    public IScalarSetting ParentSetting { get; }
    public string Name { get; }
    public string LocalName { get; }
    public Type ResultType { get; }
    public string Description { get; }
    public string EnumValueName { get; }
    public SyntheticEnumOptionSetting(IContextBoundSettingsStore settingsStore, IScalarSetting parentSetting, string enumValueName, bool initialValue);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting get_ParentSetting();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_LocalName();
    public sealed virtual Type get_ResultType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public string get_EnumValueName();
    public sealed virtual object ComputeParentSettingValue(IEnumerable`1<ISyntheticSetting> otherSyntheticSettings, IReadOnlyDictionary`2<IScalarSetting, object> detectionResult);
    internal static long GetEnumLongValue(object enumValue, Type underlyingType);
    public sealed virtual object GetValueUntyped(IContextBoundSettingsStore store, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual void SetValueUntyped(object value, IContextBoundSettingsStore store, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual void AdviseChange(IContextBoundSettingsStoreLive store, Lifetime lifetime, Action onChange, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual IUntypedProperty GetValueLiveUntyped(IContextBoundSettingsStoreLive store, Lifetime lifetime, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual IUntypedProperty GetValueLiveUntyped2(IContextBoundSettingsStoreLive store, Lifetime lifetime, ApartmentForNotifications apartmentForNotifications, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual IProperty`1<object> GetValueAsObjectLive(IContextBoundSettingsStoreLive store, Lifetime lifetime, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual IProperty`1<object> GetValueAsObjectLive2(IContextBoundSettingsStoreLive store, Lifetime lifetime, ApartmentForNotifications apartmentForNotifications, IDictionary`2<SettingsKey, object> keyIndices);
    public sealed virtual ISettingsStorageMountPoint FindLayerWhereSettingValueComeFrom(IContextBoundSettingsStore store, IDictionary`2<SettingsKey, object> keyIndices);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CodeStyle.SyntheticEnumSettingMetadata : ValueType {
    [CompilerGeneratedAttribute]
private IScalarSetting <ParentSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsChecked>k__BackingField;
    [CompilerGeneratedAttribute]
private object <EnumValue>k__BackingField;
    public IScalarSetting ParentSetting { get; }
    public bool IsChecked { get; }
    public object EnumValue { get; }
    public SyntheticEnumSettingMetadata(IScalarSetting parentSetting, object enumValue, bool isChecked);
    [CompilerGeneratedAttribute]
public IScalarSetting get_ParentSetting();
    [CompilerGeneratedAttribute]
public bool get_IsChecked();
    [CompilerGeneratedAttribute]
public object get_EnumValue();
}
public enum JetBrains.ReSharper.Psi.CodeStyle.TernaryOperatorAlign : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("Align")]
public static TernaryOperatorAlign ALIGN_ALL;
    [LocalizedDescriptionAttribute("Align except when nested")]
public static TernaryOperatorAlign ALIGN_NOT_NESTED;
    [LocalizedDescriptionAttribute("No align")]
public static TernaryOperatorAlign NONE;
}
public enum JetBrains.ReSharper.Psi.CodeStyle.WrapStyle : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("Simple wrap")]
public static WrapStyle WRAP_IF_LONG;
    [LocalizedDescriptionAttribute("Chop if long or multiline")]
public static WrapStyle CHOP_IF_LONG;
    [LocalizedDescriptionAttribute("Chop always")]
public static WrapStyle CHOP_ALWAYS;
}
public enum JetBrains.ReSharper.Psi.CodeStyle.WrapStyleExpanded : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("Simple wrap")]
public static WrapStyleExpanded WRAP_IF_LONG;
    [LocalizedDescriptionAttribute("Chop if long or multiline")]
public static WrapStyleExpanded CHOP_IF_LONG;
    [LocalizedDescriptionAttribute("Do not wrap even if long")]
public static WrapStyleExpanded NO_WRAP;
}
public enum JetBrains.ReSharper.Psi.CodeStyle.WrapStyleSimple : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("Simple wrap")]
public static WrapStyleSimple WRAP_IF_LONG;
    [LocalizedDescriptionAttribute("Chop if long or multiline")]
public static WrapStyleSimple CHOP_IF_LONG;
}
public class JetBrains.ReSharper.Psi.Colors.ColorBindOptions : ValueType {
    public bool BindsToValue;
    public bool BindsToName;
    public bool IsBindable { get; }
    public bool get_IsBindable();
}
public class JetBrains.ReSharper.Psi.Colors.ColorDeclaredElement : object {
    private ISolution mySolution;
    private IColorElement myColorElement;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiLanguageType <PresentationLanguage>k__BackingField;
    public IColorElement ColorElement { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public ColorDeclaredElement(ISolution solution, IColorElement colorElement, PsiLanguageType presentationLanguage);
    public sealed virtual IColorElement get_ColorElement();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    [CompilerGeneratedAttribute]
public sealed virtual PsiLanguageType get_PresentationLanguage();
    protected bool Equals(IColorDeclaredElement other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool IsValid();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsSynthetic();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
}
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.Colors.ColorDeclaredElementPresenter : object {
    [NotNullAttribute]
public static ColorDeclaredElementPresenter Instance { get; }
    public static ColorDeclaredElementPresenter get_Instance();
    public virtual RichText Format(DeclaredElementPresenterStyle style, IDeclaredElement element, ISubstitution substitution, DeclaredElementPresenterMarking& marking);
    public virtual string Format(ParameterKind parameterKind);
    public virtual string Format(AccessRights accessRights);
    public virtual string GetEntityKind(IDeclaredElement declaredElement);
    private static TextRange AppendString(StringBuilder sb, string substr);
    private static void TrimString(StringBuilder str);
}
public class JetBrains.ReSharper.Psi.Colors.ColorDeclaredElementType : DeclaredElementTypeBase {
    protected internal IDeclaredElementPresenter DefaultPresenter { get; }
    public ColorDeclaredElementType(IconId imageName);
    protected internal virtual IDeclaredElementPresenter get_DefaultPresenter();
}
public class JetBrains.ReSharper.Psi.Colors.ColorElement : object {
    [CompilerGeneratedAttribute]
private JetRgbaColor <RGBColor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    public JetRgbaColor RGBColor { get; }
    public string ShortName { get; }
    public ColorElement(JetRgbaColor color);
    public ColorElement(JetRgbaColor color, string shortName);
    [CompilerGeneratedAttribute]
public sealed virtual JetRgbaColor get_RGBColor();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ShortName();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Colors.ColorReferenceEx : object {
    [ExtensionAttribute]
public static bool IsValid(IColorReference reference);
}
public interface JetBrains.ReSharper.Psi.Colors.IColorDeclaredElement {
    [NotNullAttribute]
public IColorElement ColorElement { get; }
    public abstract virtual IColorElement get_ColorElement();
}
public interface JetBrains.ReSharper.Psi.Colors.IColorElement {
    [CanBeNullAttribute]
public string ShortName { get; }
    public JetRgbaColor RGBColor { get; }
    public abstract virtual string get_ShortName();
    public abstract virtual JetRgbaColor get_RGBColor();
}
public interface JetBrains.ReSharper.Psi.Colors.IColorReference {
    [NotNullAttribute]
public ITreeNode Owner { get; }
    public Nullable`1<DocumentRange> ColorConstantRange { get; }
    [CanBeNullAttribute]
public IColorElement ColorElement { get; }
    public ColorBindOptions BindOptions { get; }
    public abstract virtual ITreeNode get_Owner();
    public abstract virtual Nullable`1<DocumentRange> get_ColorConstantRange();
    public abstract virtual IColorElement get_ColorElement();
    public abstract virtual void Bind(IColorElement colorElement);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IColorElement> GetColorTable();
    public abstract virtual ColorBindOptions get_BindOptions();
}
public class JetBrains.ReSharper.Psi.Colors.PredefinedColorTypes : object {
    private static IClrTypeName WinFormsColorTypeName;
    private static IClrTypeName WinFormsPredefinedBrushesTypeName;
    private static IClrTypeName WinFormsBrushTypeName;
    private static IClrTypeName WinFormsPenTypeName;
    private static IClrTypeName WinFormsPredefinedPensTypeName;
    private static IClrTypeName KnownColorTypeName;
    private static IClrTypeName XamlColorTypeName;
    private static IClrTypeName XamlSolidColorBrushTypeName;
    private static IClrTypeName XamlPredefinedColorsTypeName;
    private static IClrTypeName XamlPredefinedBrushesTypeName;
    private static IClrTypeName WinRTColorTypeName;
    private static IClrTypeName WinRTPredefinedColorsTypeName;
    private static IClrTypeName XamarinColorTypeName;
    private static IClrTypeName ConsoleColorTypeName;
    private static IClrTypeName SkiaSharpColorTypeName;
    private static IClrTypeName SkiaSharpPredefinedColorsTypeName;
    private static IClrTypeName AvaloniaColorTypeName;
    private static IClrTypeName AvaloniaSolidColorBrushTypeName;
    private static IClrTypeName AvaloniaPredefinedColorsTypeName;
    private static IClrTypeName AvaloniaPredefinedBrushesTypeName;
    private static IClrTypeName MauiColorTypeName;
    private static IClrTypeName MauiColorsTypeName;
    [CompilerGeneratedAttribute]
private ITypeElement <WinFormsColorType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <WinFormsPenType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <WinFormsPredefinedPensType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <WinFormsPredefinedBrushesType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <XamlColorType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <XamlSolidColorBrushType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <XamlPredefinedColorsType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <XamlPredefinedBrushesType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <WinFormsBrushType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <WinRTColorType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <WinRTPredefinedColorsType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <XamarinColorType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <ConsoleColorType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <SkiaSharpColorType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <SkiaSharpPredefinedColorsType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <KnownColorType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <AvaloniaColorType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <AvaloniaSolidColorBrushType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <AvaloniaPredefinedColorsType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <AvaloniaPredefinedBrushesType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <MauiColorType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeElement <MauiColorsType>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ColorDefiningType> <ColorDefiningTypes>k__BackingField;
    [CanBeNullAttribute]
public ITypeElement WinFormsColorType { get; }
    [CanBeNullAttribute]
public ITypeElement WinFormsPenType { get; }
    [CanBeNullAttribute]
public ITypeElement WinFormsPredefinedPensType { get; }
    [CanBeNullAttribute]
public ITypeElement WinFormsPredefinedBrushesType { get; }
    [CanBeNullAttribute]
public ITypeElement XamlColorType { get; }
    [CanBeNullAttribute]
public ITypeElement XamlSolidColorBrushType { get; }
    [CanBeNullAttribute]
public ITypeElement XamlPredefinedColorsType { get; }
    [CanBeNullAttribute]
public ITypeElement XamlPredefinedBrushesType { get; }
    [CanBeNullAttribute]
public ITypeElement WinFormsBrushType { get; }
    [CanBeNullAttribute]
public ITypeElement WinRTColorType { get; }
    [CanBeNullAttribute]
public ITypeElement WinRTPredefinedColorsType { get; }
    [CanBeNullAttribute]
public ITypeElement XamarinColorType { get; }
    [CanBeNullAttribute]
public ITypeElement ConsoleColorType { get; }
    [CanBeNullAttribute]
public ITypeElement SkiaSharpColorType { get; }
    [CanBeNullAttribute]
public ITypeElement SkiaSharpPredefinedColorsType { get; }
    [CanBeNullAttribute]
public ITypeElement KnownColorType { get; }
    [CanBeNullAttribute]
public ITypeElement AvaloniaColorType { get; }
    [CanBeNullAttribute]
public ITypeElement AvaloniaSolidColorBrushType { get; }
    [CanBeNullAttribute]
public ITypeElement AvaloniaPredefinedColorsType { get; }
    [CanBeNullAttribute]
public ITypeElement AvaloniaPredefinedBrushesType { get; }
    [CanBeNullAttribute]
public ITypeElement MauiColorType { get; }
    [CanBeNullAttribute]
public ITypeElement MauiColorsType { get; }
    public ICollection`1<ColorDefiningType> ColorDefiningTypes { get; }
    internal PredefinedColorTypes(IPsiModule module);
    private static PredefinedColorTypes();
    [CompilerGeneratedAttribute]
public ITypeElement get_WinFormsColorType();
    [CompilerGeneratedAttribute]
public ITypeElement get_WinFormsPenType();
    [CompilerGeneratedAttribute]
public ITypeElement get_WinFormsPredefinedPensType();
    [CompilerGeneratedAttribute]
public ITypeElement get_WinFormsPredefinedBrushesType();
    [CompilerGeneratedAttribute]
public ITypeElement get_XamlColorType();
    [CompilerGeneratedAttribute]
public ITypeElement get_XamlSolidColorBrushType();
    [CompilerGeneratedAttribute]
public ITypeElement get_XamlPredefinedColorsType();
    [CompilerGeneratedAttribute]
public ITypeElement get_XamlPredefinedBrushesType();
    [CompilerGeneratedAttribute]
public ITypeElement get_WinFormsBrushType();
    [CompilerGeneratedAttribute]
public ITypeElement get_WinRTColorType();
    [CompilerGeneratedAttribute]
public ITypeElement get_WinRTPredefinedColorsType();
    [CompilerGeneratedAttribute]
public ITypeElement get_XamarinColorType();
    [CompilerGeneratedAttribute]
public ITypeElement get_ConsoleColorType();
    [CompilerGeneratedAttribute]
public ITypeElement get_SkiaSharpColorType();
    [CompilerGeneratedAttribute]
public ITypeElement get_SkiaSharpPredefinedColorsType();
    [CompilerGeneratedAttribute]
public ITypeElement get_KnownColorType();
    [CompilerGeneratedAttribute]
public ITypeElement get_AvaloniaColorType();
    [CompilerGeneratedAttribute]
public ITypeElement get_AvaloniaSolidColorBrushType();
    [CompilerGeneratedAttribute]
public ITypeElement get_AvaloniaPredefinedColorsType();
    [CompilerGeneratedAttribute]
public ITypeElement get_AvaloniaPredefinedBrushesType();
    [CompilerGeneratedAttribute]
public ITypeElement get_MauiColorType();
    [CompilerGeneratedAttribute]
public ITypeElement get_MauiColorsType();
    [CompilerGeneratedAttribute]
public ICollection`1<ColorDefiningType> get_ColorDefiningTypes();
    [NotNullAttribute]
public static PredefinedColorTypes Get(IPsiModule module);
    public bool IsXamlColorType(ITypeElement typeElement);
    public bool IsAvaloniaColorType(ITypeElement typeElement);
    public bool IsMauiColorType(ITypeElement typeElement);
    public bool IsXamlSolidColorBrushType(ITypeElement typeElement);
    public bool IsWinFormsBrushType(ITypeElement typeElement);
    public bool IsXamlPredefinedColorsType(ITypeElement typeElement);
    public bool IsWinFormsColorType(ITypeElement typeElement);
    public bool IsWinFormsPredefinedBrushesType(ITypeElement typeElement);
    public bool IsXamlPredefinedBrushesType(ITypeElement typeElement);
    public bool IsWinFormsPenType(ITypeElement typeElement);
    public bool IsWinFormsPredefinedPensType(ITypeElement typeElement);
    public bool IsWinRTColorType(ITypeElement typeElement);
    public bool IsXamarinColorType(ITypeElement typeElement);
    private bool IsSkiaSharpColorType(ITypeElement typeElement);
    [CanBeNullAttribute]
public ITypeElement UnderlyingColorType(ITypeElement qualifierType);
    [CanBeNullAttribute]
public ITypeElement PredefinedColorsTypeForUnderlying(ITypeElement underlying);
    public bool IsColorUnderlyingType(ITypeElement type);
    public bool HasPredefinedColorMembers(ITypeElement containingType);
    [CanBeNullAttribute]
public static ITypeMember AsColorProperty(ITypeMember member);
    [CanBeNullAttribute]
public static ITypeMember AsColorProperty(PredefinedColorTypes predefinedColorTypes, ITypeMember member);
    [NotNullAttribute]
public IList`1<ITypeMember> GetStaticColorProperties(ITypeElement typeElement);
    public bool HasColorBuildingFunctionByUnderlying(ITypeElement underlying);
    [NotNullAttribute]
public static IEnumerable`1<IColorElement> ColorElementsByType(IPsiModule psiModule, ITypeElement containingType);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Colors.PredefinedColorTypes/<ColorElementsByType>d__117")]
[NotNullAttribute]
public IEnumerable`1<IColorElement> ColorElementsByType(ITypeElement containingType);
    [CanBeNullAttribute]
public static IColorReference ColorReferenceFromInvocation(StringComparer comparer, IReference quailifierReference, IReference methodReference, IArgument[] args, Func`3<ITypeElement, IColorElement, IColorReference> factory);
    [CanBeNullAttribute]
private static ITypeElement GetQualifierType(IReference quailifierReference);
    private static Nullable`1<ValueTuple`2<Nullable`1<int>, JetRgbaColor>> BuildBaseColorWithAlpha(IList`1<IArgument> args);
    private static Nullable`1<int> GetArgumentAsIntConstant(IEnumerable`1<IArgument> args, string parameterName, int min, int max);
    public ColorBindOptions BindingOptions(ITypeElement qualifierType);
    public Nullable`1<Pair`2<ITypeElement, ITypeMember>> PropertyFromColorElement(ITypeElement qualifier, IColorElement colorElement);
    public void TryReplaceAsInvocation(ITypeElement qualifierType, IColorElement colorElement, LanguageSpecificReplaceInvocation replace);
    private static bool TryBindArgb(LanguageSpecificReplaceInvocation replace, JetRgbaColor color, ITypeElement type, string replaceAll, string r, string g, string b, string a);
}
public class JetBrains.ReSharper.Psi.CommentDeclaredElement : UserDataHolder {
    private static CommentDeclaredElementType ourElementType;
    [NotNullAttribute]
private IPsiServices myPsiServices;
    [NotNullAttribute]
private IRangeMarker mySource;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiLanguageType <PresentationLanguage>k__BackingField;
    public DocumentRange SourceRange { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public CommentDeclaredElement(IPsiServices psiServices, IRangeMarker source);
    private static CommentDeclaredElement();
    public DocumentRange get_SourceRange();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    [CompilerGeneratedAttribute]
public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IDeclaredElement FindDeclaredElement();
    public IDeclaredElementPointer`1<TDeclaredElement> CreateElementPointer();
}
public class JetBrains.ReSharper.Psi.CommonDeclaredElementType : DeclaredElementTypeBase {
    public static DeclaredElementType AnonymousTypeProperty;
    protected internal IDeclaredElementPresenter DefaultPresenter { get; }
    public CommonDeclaredElementType(string name, IconId imageName);
    private static CommonDeclaredElementType();
    protected internal virtual IDeclaredElementPresenter get_DefaultPresenter();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.CompilationContextCookie : ValueType {
    [ThreadStaticAttribute]
private static ContextData ourCurrentContextData;
    private static Key`1<ContextData> ourCurrentCompilationContext;
    private ContextData myContextData;
    private static int TaskId { get; }
    private static CompilationContextCookie();
    private CompilationContextCookie(ContextData contextData);
    private static int get_TaskId();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private static void AssertIsValid(ContextData data);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private static void AssertIsValid(IModuleReferenceResolveContext context);
    [MustDisposeResourceAttribute]
public static CompilationContextCookie GetOrCreate(IModuleReferenceResolveContext moduleReferenceResolveContext);
    [MustDisposeResourceAttribute]
public static CompilationContextCookie GetExplicitUniversalContextIfNotSet();
    [MustDisposeResourceAttribute]
public static CompilationContextCookie OverrideOrCreate(IModuleReferenceResolveContext moduleReferenceResolveContext);
    private static ContextData AddNewContext(IModuleReferenceResolveContext moduleReferenceResolveContext, ContextData currentContext);
    private static void RemoveContext(ContextData contextData);
    [CanBeNullAttribute]
private static ContextData GetStoredContextData();
    private static ContextData StoreContextData(ContextData newData);
    private static void DecrementContextCounter(ContextData contextData);
    private static void IncrementContextCounter(ContextData contextData);
    private static void ClearStoredData();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertCorrectStackState(ContextData contextData);
    public sealed virtual void Dispose();
    [ConditionalAttribute("JET_MODE_ASSERT")]
[ContractAnnotationAttribute("null => halt")]
private static void AssertDataNotNull(ContextData data);
    public static bool IsContextExplicit();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertIsExplicit();
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public static IModuleReferenceResolveContext GetContext();
}
public enum JetBrains.ReSharper.Psi.CompilationContextKind : Enum {
    public int value__;
    public static CompilationContextKind CurrentProject;
    public static CompilationContextKind Global;
    public static CompilationContextKind Assert;
}
internal class JetBrains.ReSharper.Psi.CompiledTypeElementPartIterator : object {
    private ITypeElement myTypeElement;
    private INamespace myNamespace;
    public CompiledTypeElementPartIterator(CompiledTypeElement element);
    internal static int GetPartCount(CompiledTypeElement typeElement);
    public sealed virtual bool GetNextPart(TypeNameAndTypeParameterNumber& name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebugView,nq}")]
public abstract class JetBrains.ReSharper.Psi.ConstantValue : object {
    public static ConstantValue PURE_NULL_VALUE;
    public static ConstantValue BAD_VALUE;
    public static ConstantValue OVERFLOW_VALUE;
    public static ConstantValue ARITHMETIC_PROBLEM_VALUE;
    public static ConstantValue CYCLE_IN_COMPUTATION;
    [CodeTemplateAttribute("$this$.Equals($member$)")]
[CodeTemplateAttribute("$this$ == $member$")]
public static ConstantValue NOT_COMPILE_TIME_CONSTANT;
    public ConstantValueKind Kind { get; }
    [NullableAttribute("2")]
[ObsoleteAttribute("Use strongly typed properties (e.g. 'IntValue', 'BoolValue', 'StringValue' etc.) whenever is possible")]
public object Value { get; }
    [NullableAttribute("2")]
public IType Type { get; }
    [DebuggerBrowsableAttribute("0")]
protected string DebugView { get; }
    [NullableAttribute("2")]
[DebuggerBrowsableAttribute("0")]
public string StringValue { get; }
    [DebuggerBrowsableAttribute("0")]
public bool BoolValue { get; }
    [DebuggerBrowsableAttribute("0")]
public sbyte SbyteValue { get; }
    [DebuggerBrowsableAttribute("0")]
public byte ByteValue { get; }
    [DebuggerBrowsableAttribute("0")]
public short ShortValue { get; }
    [DebuggerBrowsableAttribute("0")]
public ushort UshortValue { get; }
    [DebuggerBrowsableAttribute("0")]
public int IntValue { get; }
    [DebuggerBrowsableAttribute("0")]
public UInt32 UintValue { get; }
    [DebuggerBrowsableAttribute("0")]
public long LongValue { get; }
    [DebuggerBrowsableAttribute("0")]
public ulong UlongValue { get; }
    [DebuggerBrowsableAttribute("0")]
public double DoubleValue { get; }
    [DebuggerBrowsableAttribute("0")]
public float FloatValue { get; }
    [DebuggerBrowsableAttribute("0")]
public char CharValue { get; }
    [DebuggerBrowsableAttribute("0")]
public decimal DecimalValue { get; }
    [DebuggerBrowsableAttribute("0")]
public DateTime DateTimeValue { get; }
    [DebuggerBrowsableAttribute("0")]
public IType TypeValue { get; }
    private static ConstantValue();
    [PureAttribute]
public static ConstantValue Null(IType type);
    [PureAttribute]
public static ConstantValue Bool(bool value, IPsiModule psiModule);
    [PureAttribute]
public static ConstantValue Char(char value, IPsiModule psiModule);
    [PureAttribute]
public static ConstantValue Sbyte(sbyte value, IPsiModule psiModule);
    [PureAttribute]
public static ConstantValue Byte(byte value, IPsiModule psiModule);
    [PureAttribute]
public static ConstantValue Short(short value, IPsiModule psiModule);
    [PureAttribute]
public static ConstantValue Ushort(ushort value, IPsiModule psiModule);
    [PureAttribute]
public static ConstantValue Int(int value, IPsiModule psiModule);
    [PureAttribute]
public static ConstantValue Uint(UInt32 value, IPsiModule psiModule);
    [PureAttribute]
public static ConstantValue Long(long value, IPsiModule psiModule);
    [PureAttribute]
public static ConstantValue Ulong(ulong value, IPsiModule psiModule);
    [PureAttribute]
public static ConstantValue Decimal(decimal value, IPsiModule psiModule);
    [PureAttribute]
public static ConstantValue Float(float value, IPsiModule psiModule);
    [PureAttribute]
public static ConstantValue Double(double value, IPsiModule psiModule);
    [PureAttribute]
public static ConstantValue Nint(int value, IPsiModule psiModule);
    [PureAttribute]
public static ConstantValue Nuint(UInt32 value, IPsiModule psiModule);
    [PureAttribute]
public static ConstantValue DateTime(DateTime value, IPsiModule psiModule);
    [PureAttribute]
public static ConstantValue Enum(ConstantValue underlyingValue, IType type);
    [PureAttribute]
public static ConstantValue TypeOf(IType type);
    [PureAttribute]
public static ConstantValue String(string value, IPsiModule psiModule);
    [PureAttribute]
public static ConstantValue Nullable(ConstantValue underlyingValue, IType type);
    [PureAttribute]
public static ConstantValue Create(object value, IType type);
    [PureAttribute]
public static ConstantValue DefaultOf(IType type);
    public abstract virtual ConstantValueKind get_Kind();
    [NullableContextAttribute("2")]
public abstract virtual object get_Value();
    [NullableContextAttribute("2")]
public abstract virtual IType get_Type();
    protected virtual string get_DebugView();
    [CodeTemplateAttribute("$this$.IsBadValue()")]
[PureAttribute]
public bool IsBadValue();
    [PureAttribute]
public bool IsErrorOrNonCompileTimeConstantValue();
    [PureAttribute]
public bool IsValid();
    [NullableContextAttribute("2")]
public virtual string get_StringValue();
    public virtual bool get_BoolValue();
    public virtual sbyte get_SbyteValue();
    public virtual byte get_ByteValue();
    public virtual short get_ShortValue();
    public virtual ushort get_UshortValue();
    public virtual int get_IntValue();
    public virtual UInt32 get_UintValue();
    public virtual long get_LongValue();
    public virtual ulong get_UlongValue();
    public virtual double get_DoubleValue();
    public virtual float get_FloatValue();
    public virtual char get_CharValue();
    public virtual decimal get_DecimalValue();
    public virtual DateTime get_DateTimeValue();
    public virtual IType get_TypeValue();
    [PureAttribute]
public virtual sbyte ToSbyteChecked();
    [PureAttribute]
public virtual sbyte ToSbyteUnchecked();
    [PureAttribute]
public virtual byte ToByteChecked();
    [PureAttribute]
public virtual byte ToByteUnchecked();
    [PureAttribute]
public virtual short ToShortChecked();
    [PureAttribute]
public virtual short ToShortUnchecked();
    [PureAttribute]
public virtual ushort ToUshortChecked();
    [PureAttribute]
public virtual ushort ToUshortUnchecked();
    [PureAttribute]
public virtual int ToIntChecked();
    [PureAttribute]
public virtual int ToIntUnchecked();
    [PureAttribute]
public virtual UInt32 ToUintChecked();
    [PureAttribute]
public virtual UInt32 ToUintUnchecked();
    [PureAttribute]
public virtual long ToLongChecked();
    [PureAttribute]
public virtual long ToLongUnchecked();
    [PureAttribute]
public virtual ulong ToUlongChecked();
    [PureAttribute]
public virtual ulong ToUlongUnchecked();
    [PureAttribute]
public virtual double ToDoubleChecked();
    [PureAttribute]
public virtual double ToDoubleUnchecked();
    [PureAttribute]
public virtual float ToFloatChecked();
    [PureAttribute]
public virtual float ToFloatUnchecked();
    [PureAttribute]
public virtual decimal ToDecimalChecked();
    [PureAttribute]
public virtual decimal ToDecimalUnchecked();
    [PureAttribute]
public bool IsBoolean();
    [PureAttribute]
public bool IsString();
    [PureAttribute]
public bool IsChar();
    [PureAttribute]
public bool IsSbyte();
    [PureAttribute]
public bool IsByte();
    [PureAttribute]
public bool IsShort();
    [PureAttribute]
public bool IsUshort();
    [PureAttribute]
public bool IsInteger();
    [PureAttribute]
public bool IsUinteger();
    [PureAttribute]
public bool IsLong();
    [PureAttribute]
public bool IsUlong();
    [PureAttribute]
public bool IsDecimal();
    [PureAttribute]
public bool IsFloat();
    [PureAttribute]
public bool IsDouble();
    [PureAttribute]
public bool IsNativeInteger();
    [PureAttribute]
public bool IsNativeUnsignedInteger();
    [PureAttribute]
public bool IsDateTime();
    [PureAttribute]
public bool IsEnum();
    [PureAttribute]
public bool IsNullable();
    [PureAttribute]
public bool IsTypeOf();
    [PureAttribute]
public bool IsNull();
    [PureAttribute]
public bool IsPureNull();
    [PureAttribute]
public bool IsPureNull(PsiLanguageType language);
    [PureAttribute]
public bool IsZero();
    [PureAttribute]
public bool IsPureZero();
    [PureAttribute]
public bool IsPure();
    [PureAttribute]
public ConstantValue ToPureValue();
    [PureAttribute]
public ConstantValue ToNamedValue();
    [PureAttribute]
public ConstantValue ToEnumUnderlyingType();
    [PureAttribute]
public ConstantValue ToNullableUnderlyingType();
    [PureAttribute]
public abstract virtual ConstantValue Substitute(ISubstitution substitution);
    [PureAttribute]
public ConstantValue WithNullableAnnotation(NullableAnnotation nullableAnnotation);
    [PureAttribute]
public bool IsBoolean(Boolean& value);
    [NullableContextAttribute("2")]
[PureAttribute]
public bool IsString(String& value);
    [NullableContextAttribute("2")]
[PureAttribute]
[ContractAnnotationAttribute("=> true, value:notnull; => false, value:null")]
public bool IsNotNullString(String& value);
    [NullableContextAttribute("2")]
[PureAttribute]
public string AsString();
    [PureAttribute]
public bool IsInteger(Int32& value);
    [PureAttribute]
public bool IsLong(Int64& value);
    [PureAttribute]
public bool IsTrue();
    [PureAttribute]
public bool IsFalse();
    [PureAttribute]
[ObsoleteAttribute("Please, use the overload with TypePresentationStyle instead")]
public string GetPresentation(PsiLanguageType language);
    [PureAttribute]
public RichText GetPresentation(PsiLanguageType language, TypePresentationStyle typePresentationStyle);
    [PureAttribute]
public virtual string Dump(PsiLanguageType language);
    [NullableContextAttribute("2")]
public virtual bool Equals(ConstantValue other);
    [NullableContextAttribute("2")]
public static bool op_Equality(ConstantValue left, ConstantValue right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(ConstantValue left, ConstantValue right);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
}
public enum JetBrains.ReSharper.Psi.ConstantValueKind : Enum {
    public byte value__;
    public static ConstantValueKind NonCompileTimeConstant;
    public static ConstantValueKind Error;
    public static ConstantValueKind Null;
    public static ConstantValueKind Sbyte;
    public static ConstantValueKind Byte;
    public static ConstantValueKind Short;
    public static ConstantValueKind Ushort;
    public static ConstantValueKind Int;
    public static ConstantValueKind Uint;
    public static ConstantValueKind Long;
    public static ConstantValueKind Ulong;
    public static ConstantValueKind Nint;
    public static ConstantValueKind Nuint;
    public static ConstantValueKind Char;
    public static ConstantValueKind Bool;
    public static ConstantValueKind Float;
    public static ConstantValueKind Double;
    public static ConstantValueKind String;
    public static ConstantValueKind Decimal;
    public static ConstantValueKind Enum;
    public static ConstantValueKind DateTime;
    public static ConstantValueKind Nullable;
    public static ConstantValueKind TypeOf;
    public static ConstantValueKind Special;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ContentModel.ContentModelForkExtensions : object {
    private static Key`1<LazyForkedContentModelData`1<IUserDataHolder>> ourForkedUserDataHolderKey;
    private static ContentModelForkExtensions();
    [ExtensionAttribute]
[PureAttribute]
public static IUserDataHolder GetForkedPsiModuleUserDataHolder(IPsiModule psiModule);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ContentModel.ContentModelForkTranslator : object {
    private ForkedDocumentsManager myForkedDocumentsManager;
    public ContentModelForkTranslator(ISolution solution);
    public sealed virtual TTreeNode TryTranslateNodeToCurrentFork(TTreeNode node);
    public sealed virtual TReference TryTranslateReferenceToCurrentFork(TReference reference);
    public sealed virtual IFile TryTranslateFileToCurrentFork(IFile psiFile);
    public sealed virtual IDocument TranslateToCurrentFork(IDocument document);
    public sealed virtual DocumentRange TranslateToCurrentFork(DocumentRange documentRange);
    public sealed virtual DocumentOffset TranslateToCurrentFork(DocumentOffset documentOffset);
    private IFile TryTranslateInjectedPsiFile(IFile injectedPsiFile);
    public sealed virtual TDeclaredElement TryTranslateDeclaredElementToCurrentFork(TDeclaredElement declaredElement);
    public sealed virtual TType TryTranslateTypeToCurrentFork(TType type);
    public sealed virtual ITextControl TranslateTextControl(ITextControl textControl);
    [NullableContextAttribute("2")]
public sealed virtual object TryTranslateAnythingToCurrentFork(object obj);
    public sealed virtual IEnumerable`1<T> TryTranslateCollectionToCurrentFork(IEnumerable`1<T> enumerable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ContentModel.ForkedTextControl : object {
    private static LazyForkedContentModelData`1<Dictionary`2<IDocument, ForkedTextControl>> ourTextControlsPerFork;
    [CompilerGeneratedAttribute]
private RunningTextControlId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private IDocument <Document>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
private IProperty`1<ITextControlPos> myCaretPosition;
    [DebuggerBrowsableAttribute("0")]
private IProperty`1<IEquatableList`1<TextControlPosRange>> mySelectionRanges;
    private UserDataHolder myForkedDataHolder;
    public RunningTextControlId Id { get; }
    public Lifetime Lifetime { get; }
    public IDocument Document { get; }
    [DebuggerBrowsableAttribute("0")]
private ITextControlCaret JetBrains.TextControl.ITextControl.Caret { get; }
    [DebuggerBrowsableAttribute("0")]
private ITextControlSelection JetBrains.TextControl.ITextControl.Selection { get; }
    [DebuggerBrowsableAttribute("0")]
private ITextControlCoords JetBrains.TextControl.ITextControl.Coords { get; }
    [DebuggerBrowsableAttribute("0")]
private ITextControlScrolling JetBrains.TextControl.ITextControl.Scrolling { get; }
    [DebuggerBrowsableAttribute("0")]
private ITextControlWindow JetBrains.TextControl.ITextControl.Window { get; }
    [DebuggerBrowsableAttribute("0")]
private ITextControlOptions JetBrains.TextControl.ITextControl.Options { get; }
    [DebuggerBrowsableAttribute("0")]
private ITextControlPopupWindowContextFactory JetBrains.TextControl.ITextControl.PopupWindowContextFactory { get; }
    [DebuggerBrowsableAttribute("0")]
private ErrorStripeTransport JetBrains.TextControl.ITextControl.ErrorStripe { get; }
    [DebuggerBrowsableAttribute("0")]
private TransportTextControl JetBrains.TextControl.ITextControl.Transport { get; }
    private IProperty`1<ITextControlPos> JetBrains.TextControl.ITextControlCaret.Position { get; }
    [DebuggerBrowsableAttribute("0")]
private ITextControl JetBrains.TextControl.ITextControlCaret.TextControl { get; }
    private IProperty`1<IEquatableList`1<TextControlPosRange>> JetBrains.TextControl.ITextControlSelection.Ranges { get; }
    [DebuggerBrowsableAttribute("0")]
private ITextControl JetBrains.TextControl.ITextControlSelection.TextControl { get; }
    private ForkedTextControl(int nextId, IDocument forkedDocument, ITextControl probeTextControl);
    private static ForkedTextControl();
    [MustUseReturnValueAttribute]
public static ForkedTextControl GetOrOpenForkedTextControlFor(IDocument forkedDocument, ITextControl probeTextControl);
    [CompilerGeneratedAttribute]
public sealed virtual RunningTextControlId get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual Lifetime get_Lifetime();
    [CompilerGeneratedAttribute]
public sealed virtual IDocument get_Document();
    private sealed virtual override ITextControlCaret JetBrains.TextControl.ITextControl.get_Caret();
    private sealed virtual override ITextControlSelection JetBrains.TextControl.ITextControl.get_Selection();
    private sealed virtual override ITextControlCoords JetBrains.TextControl.ITextControl.get_Coords();
    private sealed virtual override ITextControlScrolling JetBrains.TextControl.ITextControl.get_Scrolling();
    private sealed virtual override ITextControlWindow JetBrains.TextControl.ITextControl.get_Window();
    private sealed virtual override ITextControlOptions JetBrains.TextControl.ITextControl.get_Options();
    private sealed virtual override ITextControlPopupWindowContextFactory JetBrains.TextControl.ITextControl.get_PopupWindowContextFactory();
    private sealed virtual override ErrorStripeTransport JetBrains.TextControl.ITextControl.get_ErrorStripe();
    private sealed virtual override TransportTextControl JetBrains.TextControl.ITextControl.get_Transport();
    private static Exception ShouldNotBeCalledInForks();
    private sealed virtual override void JetBrains.TextControl.ITextControl.EmulateAction(string actionid);
    private sealed virtual override void JetBrains.TextControl.ITextControl.EmulateTyping(char c);
    private sealed virtual override void JetBrains.TextControl.ITextControl.FillVirtualSpaceUntilCaret();
    private sealed virtual override IDisposable JetBrains.TextControl.ITextControl.GetUpdateCookie(string description);
    private sealed virtual override IProperty`1<ITextControlPos> JetBrains.TextControl.ITextControlCaret.get_Position();
    private sealed virtual override ITextControl JetBrains.TextControl.ITextControlCaret.get_TextControl();
    private sealed virtual override void JetBrains.TextControl.ITextControlCaret.MoveTo(ITextControlPos position, CaretVisualPlacement visualplace);
    private sealed virtual override void JetBrains.TextControl.ITextControlCaret.EnsureVisible();
    private sealed virtual override IProperty`1<IEquatableList`1<TextControlPosRange>> JetBrains.TextControl.ITextControlSelection.get_Ranges();
    private sealed virtual override ITextControl JetBrains.TextControl.ITextControlSelection.get_TextControl();
    private sealed virtual override ITextControlPos JetBrains.TextControl.Coords.ITextControlCoords.FromDocLineColumn(DocumentCoords doccoords);
    private sealed virtual override ITextControlPos JetBrains.TextControl.Coords.ITextControlCoords.FromDocOffset(DocOffset docoffset);
    private sealed virtual override ITextControlPos JetBrains.TextControl.Coords.ITextControlCoords.FromDocOffsetAndVirtual(DocOffsetAndVirtual docoffs);
    private sealed virtual override ITextControlPos JetBrains.TextControl.Coords.ITextControlCoords.FromScreen(JetPhysicalPoint ptScreen);
    private sealed virtual override ITextControlPos JetBrains.TextControl.Coords.ITextControlCoords.FromTextControlLineColumn(TextControlLineColumn textcoords);
    private sealed virtual override T JetBrains.Util.IUserDataHolder.GetData(Key`1<T> key);
    private sealed virtual override void JetBrains.Util.IUserDataHolder.PutData(Key`1<T> key, T value);
    private sealed virtual override T JetBrains.Util.IUserDataHolder.GetOrCreateDataUnderLock(Key`1<T> key, Func`1<T> factory);
    private sealed virtual override T JetBrains.Util.IUserDataHolder.GetOrCreateDataUnderLock(Key`1<T> key, TState state, Func`2<TState, T> factory);
    private sealed virtual override IEnumerable`1<KeyValuePair`2<object, object>> JetBrains.Util.IUserDataHolder.EnumerateData();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private TextControlPosRange <.ctor>b__0_0(TextControlPosRange range);
    [CompilerGeneratedAttribute]
private void <.ctor>b__0_1(PropertyChangedEventArgs`1<IEquatableList`1<TextControlPosRange>> args);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.ContentModel.IContentModelForkTranslator {
    [MustUseReturnValueAttribute]
public abstract virtual TTreeNode TryTranslateNodeToCurrentFork(TTreeNode node);
    [MustUseReturnValueAttribute]
public abstract virtual TReference TryTranslateReferenceToCurrentFork(TReference reference);
    [MustUseReturnValueAttribute]
public abstract virtual IFile TryTranslateFileToCurrentFork(IFile psiFile);
    [MustUseReturnValueAttribute]
public abstract virtual IDocument TranslateToCurrentFork(IDocument document);
    [MustUseReturnValueAttribute]
public abstract virtual DocumentRange TranslateToCurrentFork(DocumentRange documentRange);
    [MustUseReturnValueAttribute]
public abstract virtual DocumentOffset TranslateToCurrentFork(DocumentOffset documentOffset);
    [MustUseReturnValueAttribute]
public abstract virtual TDeclaredElement TryTranslateDeclaredElementToCurrentFork(TDeclaredElement declaredElement);
    [MustUseReturnValueAttribute]
public abstract virtual TType TryTranslateTypeToCurrentFork(TType type);
    [MustUseReturnValueAttribute]
public abstract virtual ITextControl TranslateTextControl(ITextControl textControl);
    [NullableContextAttribute("2")]
public abstract virtual object TryTranslateAnythingToCurrentFork(object obj);
    public abstract virtual IEnumerable`1<T> TryTranslateCollectionToCurrentFork(IEnumerable`1<T> enumerable);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.ContentModel.ISupportsContentModelForkTranslation`1 {
    [MustUseReturnValueAttribute]
public abstract virtual TSelf TryTranslateToCurrentFork(IContentModelForkTranslator translator);
}
public static class JetBrains.ReSharper.Psi.ControlFlow.ControlFlowBuilder : object {
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("graphOwner: null => null")]
public static IControlFlowGraph GetGraph(ITreeNode graphOwner, IResolveContext context, bool buildExpressions);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("treeNode: null => null")]
public static IControlFlowGraph GetContainingGraph(ITreeNode treeNode, IResolveContext context);
    [CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITreeNode GetContainingGraphOwner(ITreeNode treeNode);
}
public class JetBrains.ReSharper.Psi.ControlFlow.ControlFlowEdgesCollection : ValueType {
    [CanBeNullAttribute]
private object mySingleItemOrListOrNull;
    public void Add(IControlFlowEdge item);
    [PureAttribute]
public ControlFlowEdgesEnumerable AsEnumerable();
    public void RemoveWhere(Predicate`1<IControlFlowEdge> predicate);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.ControlFlow.ControlFlowEdgesEnumerable : ValueType {
    [CanBeNullAttribute]
private object mySingleItemOrListOrNull;
    public static ControlFlowEdgesEnumerable Empty;
    public int Count { get; }
    public ControlFlowEdgesEnumerable(IControlFlowEdge edge);
    public ControlFlowEdgesEnumerable(List`1<IControlFlowEdge> edges);
    internal ControlFlowEdgesEnumerable(object singleItemOrListOrNull);
    private static ControlFlowEdgesEnumerable();
    public int get_Count();
    [CanBeNullAttribute]
[PureAttribute]
public IControlFlowEdge SingleItem();
    [CanBeNullAttribute]
[PureAttribute]
public IControlFlowEdge SingleItem(Func`2<IControlFlowEdge, bool> predicate);
    [PureAttribute]
public bool Any(Func`2<IControlFlowEdge, bool> predicate);
    [PureAttribute]
public bool All(Func`2<IControlFlowEdge, bool> predicate);
    [PureAttribute]
[CanBeNullAttribute]
public IControlFlowEdge FirstOrDefault();
    public Enumerator GetEnumerator();
    [MustUseReturnValueAttribute]
[NotNullAttribute]
public PooledList`1<IControlFlowEdge> ToPooledList();
}
public enum JetBrains.ReSharper.Psi.ControlFlow.ControlFlowEdgeType : Enum {
    public int value__;
    public static ControlFlowEdgeType NEXT;
    public static ControlFlowEdgeType GOTO;
    public static ControlFlowEdgeType THROW;
    public static ControlFlowEdgeType RETURN;
    public static ControlFlowEdgeType PHANTOM_NEXT;
    public static ControlFlowEdgeType UNREACHABLE_NEXT;
    public static ControlFlowEdgeType COMPILER_SKIPPED_NEXT;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ControlFlow.ControlFlowElementExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool Contains(IControlFlowElement element, IControlFlowElement candidate);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static List`1<IControlFlowElement> Descendants(IControlFlowElement element);
    private static void CollectAllChildren(IControlFlowElement element, List`1<IControlFlowElement> result);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static List`1<IControlFlowEdge> ReachableExits(IControlFlowElement element);
    private static void CollectReachableExits(IControlFlowElement parent, List`1<IControlFlowEdge> result);
}
public interface JetBrains.ReSharper.Psi.ControlFlow.IControlFlowBuilder {
    public abstract virtual bool CanBuildFrom(ITreeNode treeNode);
    [CanBeNullAttribute]
public abstract virtual IControlFlowGraph GraphFromNode(ITreeNode graphOwner, IResolveContext context, bool buildExpressions);
}
public interface JetBrains.ReSharper.Psi.ControlFlow.IControlFlowContextFactory`1 {
    public T InitialContext { get; }
    public abstract virtual T get_InitialContext();
    public abstract virtual T CloneContext(T context);
    public abstract virtual T Merge(IList`1<T> contexts);
}
public interface JetBrains.ReSharper.Psi.ControlFlow.IControlFlowEdge {
    public ControlFlowEdgeType Type { get; public set; }
    [NotNullAttribute]
public IControlFlowElement Source { get; }
    [CanBeNullAttribute]
public IControlFlowElement Target { get; }
    public int Id { get; }
    public abstract virtual ControlFlowEdgeType get_Type();
    public abstract virtual void set_Type(ControlFlowEdgeType value);
    public abstract virtual IControlFlowElement get_Source();
    public abstract virtual IControlFlowElement get_Target();
    public abstract virtual int get_Id();
    [CanBeNullAttribute]
public abstract virtual ITreeNode GetSourceElement();
}
public interface JetBrains.ReSharper.Psi.ControlFlow.IControlFlowElement {
    [CanBeNullAttribute]
public IControlFlowElement Parent { get; }
    [CanBeNullAttribute]
public ITreeNode SourceElement { get; }
    public bool IsReachable { get; }
    public bool IsTraversable { get; }
    public bool IsDeadCode { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public ControlFlowEdgesEnumerable Entries { get; }
    public ControlFlowEdgesEnumerable Exits { get; }
    [CanBeNullAttribute]
public IControlFlowEdge PhantomExit { get; }
    public int Id { get; }
    public abstract virtual IControlFlowElement get_Parent();
    public abstract virtual ITreeNode get_SourceElement();
    public abstract virtual bool get_IsReachable();
    public abstract virtual bool get_IsTraversable();
    public abstract virtual bool get_IsDeadCode();
    public abstract virtual IReadOnlyList`1<IControlFlowElement> get_Children();
    public abstract virtual ControlFlowEdgesEnumerable get_Entries();
    public abstract virtual ControlFlowEdgesEnumerable get_Exits();
    public abstract virtual IControlFlowEdge get_PhantomExit();
    public abstract virtual int get_Id();
}
public interface JetBrains.ReSharper.Psi.ControlFlow.IControlFlowGraph {
    public ICollection`1<IControlFlowElement> AllElements { get; }
    public IEnumerable`1<IControlFlowElement> LeafElements { get; }
    [NotNullAttribute]
public IControlFlowElement BodyElement { get; }
    [NotNullAttribute]
public IControlFlowElement EntryElement { get; }
    public ICollection`1<ITreeNode> DeadCodeElements { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IControlFlowElement> ReachableSequence { get; }
    public int AllElementsCount { get; }
    public int EdgesCount { get; }
    public abstract virtual ICollection`1<IControlFlowElement> get_AllElements();
    public abstract virtual IEnumerable`1<IControlFlowElement> get_LeafElements();
    public abstract virtual IControlFlowElement get_BodyElement();
    public abstract virtual IControlFlowElement get_EntryElement();
    public abstract virtual ICollection`1<ITreeNode> get_DeadCodeElements();
    public abstract virtual IEnumerable`1<IControlFlowElement> get_ReachableSequence();
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IEnumerable`1<IControlFlowElement> GetLeafElementsFor(ITreeNode element);
    public abstract virtual int get_AllElementsCount();
    public abstract virtual int get_EdgesCount();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ControlFlow.Impl.AssignmentUsageTable : object {
    private Dictionary`2<ITreeNode, bool> myUsedAssignments;
    private OneToSetMap`2<ITreeNode, ITreeNode> myExplicitUsages;
    public KeyCollection<ITreeNode, bool> Assignments { get; }
    public void SetImplicitlyUsed(ITreeNode assignment);
    public void SetExplicitlyUsed(ITreeNode assignment, ITreeNode usage);
    public void SetMayBeUnused(ITreeNode assignment);
    [PureAttribute]
public bool IsUsed(ITreeNode assignment);
    public KeyCollection<ITreeNode, bool> get_Assignments();
    [PureAttribute]
public ICollection`1<ITreeNode> GetExplicitUsages(ITreeNode assignment);
}
public abstract class JetBrains.ReSharper.Psi.ControlFlow.Impl.ClosureExecutionBehaviorInspectorBase : object {
    public bool IsInstantExecute(ITreeNode closureNode);
    [PureAttribute]
protected abstract virtual ExecutionBehavior AnalyzeLambdaExecutionContext(ITreeNode closureNode, ITreeNode& contextNode, IMethod& contextMethod);
    [PureAttribute]
protected abstract virtual ExecutionBehavior NextTunnelClauseContext(ITreeNode contextNode, ITreeNode& nextContextNode, IMethod& nextContextMethod);
    [PureAttribute]
public ExecutionBehavior GetClosureExecutionBehavior(ITreeNode closureNode, IMethod& contextMethod, IMethod& nextContextMethod);
}
public abstract class JetBrains.ReSharper.Psi.ControlFlow.Impl.CommonLanguageControlFlowGraphInspector`3 : ControlFlowGraphInspector`1<TContext> {
    [CompilerGeneratedAttribute]
private Action`5<IControlFlowElement, TContext, TVariableInfo, ControlFlowAccessType, ITreeNode> PatchAccessInfo;
    protected AssignmentUsageTable myAssignmentUsageTable;
    protected OneToSetMap`2<ITreeNode, QualifiedDeclaredElementReference> myReadWithoutWriteExpressions;
    private HashSet`1<IDeclaredElement> myReadWithoutWriteExternalVariables;
    private Dictionary`2<ITreeNode, TVariableInfo> myAssignmentToInfo;
    private OneToSetMap`2<IDeclaredElement, ITreeNode> myInitializers;
    private OneToSetMap`2<ITreeNode, IDeclaredElement> myNestedClosuresNotInitializedVariables;
    private OneToSetMap`2<TVariableInfo, ITreeNode> myAccessToModifiedClosure;
    private OneToSetMap`2<TVariableInfo, ITreeNode> myAccessToDisposedClosure;
    private OneToSetMap`2<TVariableInfo, ITreeNode> myAccessToForEachVariableInClosure;
    private Dictionary`2<IDeclaredElement, bool> myFinalVariables;
    [NotNullAttribute]
protected TContextFactory ContextFactory { get; }
    public IDictionary`2<IDeclaredElement, IDictionary`2<ITreeNode, List`1<ITreeNode>>> AssignmentsUsage { get; }
    public IDictionary`2<IDeclaredElement, IList`1<IExpression>> AccessToExternalModifiedClosure { get; }
    public IDictionary`2<IDeclaredElement, IList`1<IExpression>> AccessToExternalDisposedClosure { get; }
    public IDictionary`2<IDeclaredElement, IList`1<IExpression>> AccessToForEachVariableInClosure { get; }
    public OneToSetMap`2<ITreeNode, QualifiedDeclaredElementReference> ReadWithoutWriteExpressions { get; }
    public ICollection`1<IDeclaredElement> ReadWithoutWriteExternalVariables { get; }
    public bool HasTooManyVariables { get; }
    public IDictionary`2<IDeclaredElement, List`1<ITreeNode>> ElementInitializers { get; }
    public OneToListMap`2<ITreeNode, IDeclaredElement> NotInitializedVariables { get; }
    public ICollection`1<IDeclaredElement> UsedFieldsWithTrackedAccessState { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<ICollection`1<ITypeMember>, ICollection`1<ITypeMember>> InitializedTypeMembers { get; }
    public ClassInitializationInfo InitializationInfo { get; }
    public IDictionary`2<IDeclaredElement, bool> FinalLocals { get; }
    protected CommonLanguageControlFlowGraphInspector`3(ControlFlowGraph controlFlowGraph, IControlFlowContextFactory`1<TContext> contextFactory);
    [CompilerGeneratedAttribute]
protected void add_PatchAccessInfo(Action`5<IControlFlowElement, TContext, TVariableInfo, ControlFlowAccessType, ITreeNode> value);
    [CompilerGeneratedAttribute]
protected void remove_PatchAccessInfo(Action`5<IControlFlowElement, TContext, TVariableInfo, ControlFlowAccessType, ITreeNode> value);
    protected TContextFactory get_ContextFactory();
    public virtual void Inspect();
    protected void FirePatchAccessInfo(IControlFlowElement controlFlowElement, TContext context, TVariableInfo info, ExpressionAccessType access, ITreeNode accessExpression);
    protected void FirePatchAccessInfo(IControlFlowElement controlFlowElement, TContext context, TVariableInfo info, ControlFlowAccessType access, ITreeNode accessExpression);
    private void OnInfoAccessed(IControlFlowElement controlFlowElement, TContext context, TVariableInfo info, ControlFlowAccessType access, ITreeNode accessExpression);
    protected void OnInfoDisposed(TContext context, TVariableInfo info);
    [NotNullAttribute]
[ItemNotNullAttribute]
protected virtual IEnumerable`1<ITreeNode> GetRecentAccessesInClosure(TContext context, TVariableInfo info);
    private static void PatchStructWhenFieldsWritten(TVariableInfo info, TContext context);
    private static void PatchFieldsWhenStructWritten(TVariableInfo info, TContext context);
    public sealed virtual IDictionary`2<IDeclaredElement, IDictionary`2<ITreeNode, List`1<ITreeNode>>> get_AssignmentsUsage();
    public sealed virtual IDictionary`2<IDeclaredElement, IList`1<IExpression>> get_AccessToExternalModifiedClosure();
    public sealed virtual IDictionary`2<IDeclaredElement, IList`1<IExpression>> get_AccessToExternalDisposedClosure();
    public sealed virtual IDictionary`2<IDeclaredElement, IList`1<IExpression>> get_AccessToForEachVariableInClosure();
    public sealed virtual OneToSetMap`2<ITreeNode, QualifiedDeclaredElementReference> get_ReadWithoutWriteExpressions();
    public sealed virtual ICollection`1<IDeclaredElement> get_ReadWithoutWriteExternalVariables();
    public abstract virtual bool get_HasTooManyVariables();
    public sealed virtual IDictionary`2<IDeclaredElement, List`1<ITreeNode>> get_ElementInitializers();
    public sealed virtual OneToListMap`2<ITreeNode, IDeclaredElement> get_NotInitializedVariables();
    public abstract virtual ICollection`1<IDeclaredElement> get_UsedFieldsWithTrackedAccessState();
    public virtual ValueTuple`2<ICollection`1<ITypeMember>, ICollection`1<ITypeMember>> get_InitializedTypeMembers();
    public virtual ClassInitializationInfo get_InitializationInfo();
    protected abstract virtual IEnumerable`1<TVariableInfo> EnumerateVariables();
    protected abstract virtual bool IsForeachVariableDeclaration(IDeclaredElement declaredElement);
    private void PostProcessAssignmentTable();
    public sealed virtual IDictionary`2<IDeclaredElement, bool> get_FinalLocals();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.ControlFlow.Impl.CommonLanguageControlFlowGraphInspector`3/<<PatchFieldsWhenStructWritten>g__GetVariableInfos|23_1>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<TVariableInfo> <PatchFieldsWhenStructWritten>g__GetVariableInfos|23_1(TVariableInfo info);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.ControlFlow.Impl.ControlFlowAccessType : Enum {
    public int value__;
    public static ControlFlowAccessType None;
    public static ControlFlowAccessType Read;
    public static ControlFlowAccessType Write;
    public static ControlFlowAccessType ReadWrite;
    public static ControlFlowAccessType Partial;
    public static ControlFlowAccessType NameCapture;
    public static ControlFlowAccessType DeclarationCapture;
    public static ControlFlowAccessType PossibleWrite;
    public static ControlFlowAccessType DefiniteAssignmentOnlyWrite;
}
public class JetBrains.ReSharper.Psi.ControlFlow.Impl.ControlFlowEdge : object {
    [DebuggerBrowsableAttribute("0")]
private int myId;
    [CompilerGeneratedAttribute]
private IControlFlowElement <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private IControlFlowElement <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowEdgeType <Type>k__BackingField;
    public IControlFlowElement Source { get; }
    public IControlFlowElement Target { get; public set; }
    public ControlFlowEdgeType Type { get; public set; }
    public int Id { get; public set; }
    protected ControlFlowEdge(ControlFlowEdgeType edgeType, IControlFlowElement source);
    public ControlFlowEdge(ControlFlowEdgeType edgeType, IControlFlowElement source, IControlFlowElement target);
    [CompilerGeneratedAttribute]
public sealed virtual IControlFlowElement get_Source();
    [CompilerGeneratedAttribute]
public sealed virtual IControlFlowElement get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(IControlFlowElement value);
    [CompilerGeneratedAttribute]
public sealed virtual ControlFlowEdgeType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Type(ControlFlowEdgeType value);
    public sealed virtual int get_Id();
    public void set_Id(int value);
    public virtual ITreeNode GetSourceElement();
}
public abstract class JetBrains.ReSharper.Psi.ControlFlow.Impl.ControlFlowElement : object {
    [DebuggerBrowsableAttribute("0")]
protected ControlFlowEdgesCollection EntriesCollection;
    [DebuggerBrowsableAttribute("0")]
protected ControlFlowEdgesCollection ExitsCollection;
    [DebuggerBrowsableAttribute("0")]
private int myId;
    [DebuggerBrowsableAttribute("0")]
private ElementFlags myFlags;
    [CompilerGeneratedAttribute]
private ControlFlowElement <Parent>k__BackingField;
    public int Id { get; public set; }
    private IControlFlowElement JetBrains.ReSharper.Psi.ControlFlow.IControlFlowElement.Parent { get; }
    public ControlFlowElement Parent { get; internal set; }
    public ControlFlowEdgesEnumerable Entries { get; }
    public ControlFlowEdgesEnumerable Exits { get; }
    public IControlFlowEdge PhantomExit { get; }
    public IReadOnlyList`1<IControlFlowElement> Children { get; }
    public ITreeNode SourceElement { get; }
    public bool IsTraversable { get; public set; }
    public bool IsReachable { get; public set; }
    public bool IsDeadCode { get; public set; }
    public sealed virtual int get_Id();
    public void set_Id(int value);
    private sealed virtual override IControlFlowElement JetBrains.ReSharper.Psi.ControlFlow.IControlFlowElement.get_Parent();
    [CompilerGeneratedAttribute]
public ControlFlowElement get_Parent();
    [CompilerGeneratedAttribute]
internal void set_Parent(ControlFlowElement value);
    public sealed virtual ControlFlowEdgesEnumerable get_Entries();
    public sealed virtual ControlFlowEdgesEnumerable get_Exits();
    public virtual IControlFlowEdge get_PhantomExit();
    public virtual IReadOnlyList`1<IControlFlowElement> get_Children();
    public virtual ITreeNode get_SourceElement();
    private void SetFlag(ElementFlags flag, bool value);
    public sealed virtual bool get_IsTraversable();
    public void set_IsTraversable(bool value);
    public sealed virtual bool get_IsReachable();
    public void set_IsReachable(bool value);
    public sealed virtual bool get_IsDeadCode();
    public void set_IsDeadCode(bool value);
    protected internal virtual void RemovePhantomEdges();
    public void AddEntry(IControlFlowEdge edge);
    public void AddExit(IControlFlowEdge edge);
}
public abstract class JetBrains.ReSharper.Psi.ControlFlow.Impl.ControlFlowGraph : object {
    [NotNullAttribute]
private List`1<IControlFlowElement> myAllElements;
    [NotNullAttribute]
private List`1<IControlFlowElement> myReachableSequence;
    [NotNullAttribute]
private OneToCompactListMap`2<ITreeNode, IControlFlowElement> myLeafElements;
    [NotNullAttribute]
private List`1<IControlFlowElement> myUnattachedLeafElements;
    [CompilerGeneratedAttribute]
private int <EdgesCount>k__BackingField;
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IControlFlowElement> LeafElements { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public ICollection`1<IControlFlowElement> AllElements { get; }
    public IControlFlowElement BodyElement { get; }
    public IControlFlowElement EntryElement { get; }
    public ICollection`1<ITreeNode> DeadCodeElements { get; }
    public IEnumerable`1<IControlFlowElement> ReachableSequence { get; }
    public int EdgesCount { get; private set; }
    public int AllElementsCount { get; }
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.ControlFlow.Impl.ControlFlowGraph/<get_LeafElements>d__5")]
public sealed virtual IEnumerable`1<IControlFlowElement> get_LeafElements();
    public sealed virtual IEnumerable`1<IControlFlowElement> GetLeafElementsFor(ITreeNode element);
    public sealed virtual ICollection`1<IControlFlowElement> get_AllElements();
    public abstract virtual IControlFlowElement get_BodyElement();
    public abstract virtual IControlFlowElement get_EntryElement();
    public sealed virtual ICollection`1<ITreeNode> get_DeadCodeElements();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.ControlFlow.Impl.ControlFlowGraph/<get_ReachableSequence>d__16")]
public sealed virtual IEnumerable`1<IControlFlowElement> get_ReachableSequence();
    [CompilerGeneratedAttribute]
public sealed virtual int get_EdgesCount();
    [CompilerGeneratedAttribute]
private void set_EdgesCount(int value);
    public sealed virtual int get_AllElementsCount();
    protected void FixUp();
    private void RemovePhantomExits();
    private void FixUpRecursive(ControlFlowElement element, Int32& nextNodeId, Int32& nextEdgeId);
    [CanBeNullAttribute]
private static IControlFlowElement FindDeepestFirstChild(IControlFlowElement element);
    [NotNullAttribute]
[ItemNotNullAttribute]
private List`1<IControlFlowElement> InvestigateReachabilityAndMakeSequence();
    private static void FindDeadCodeElements(HashSet`1<ITreeNode> deadCodeElements, HashSet`1<ITreeNode> reachableElements, IControlFlowElement element);
}
public abstract class JetBrains.ReSharper.Psi.ControlFlow.Impl.ControlFlowGraphInspector`1 : object {
    [NotNullAttribute]
private ControlFlowGraph myControlFlowGraph;
    [NotNullAttribute]
private IControlFlowContextFactory`1<TContext> myContextFactory;
    [NotNullAttribute]
private Int32[] myElementTimestamps;
    [NotNullAttribute]
private ContextAndTimeStamp[] myEdgeContexts;
    [NotNullAttribute]
private List`1<TContext> myInputContexts;
    [NotNullAttribute]
private List`1<ContextAndTimeStamp<TContext>> myOutputContexts;
    private int myModificationStamp;
    [NotNullAttribute]
protected IControlFlowContextFactory`1<TContext> ContextFactory { get; }
    public ControlFlowGraph ControlFlowGraph { get; }
    protected ControlFlowGraphInspector`1(ControlFlowGraph controlFlowGraph, IControlFlowContextFactory`1<TContext> contextFactory);
    protected IControlFlowContextFactory`1<TContext> get_ContextFactory();
    public ControlFlowGraph get_ControlFlowGraph();
    [CanBeNullAttribute]
[PureAttribute]
public virtual TContext GetContext(IControlFlowEdge edge);
    protected virtual void SetContext(IControlFlowEdge edge, TContext context, int timestamp);
    public virtual void Inspect();
    protected abstract virtual void InspectLeafElementAndSetContextToExits(IControlFlowElement element, TContext context);
    protected virtual bool InspectionPass(IEnumerable`1<IControlFlowElement> sequence);
    protected bool InspectSingleLeaf(ControlFlowElement element);
    protected virtual void CollectEntriesContexts(ControlFlowElement element, List`1<TContext> consumer);
    protected bool ShouldInspectSingleLeaf(ControlFlowElement element, List`1<IControlFlowEdge> controlFlowEdges);
    protected virtual bool ShouldInspectSingleLeaf(ControlFlowElement element, ControlFlowEdgesEnumerable controlFlowEdges);
    protected virtual bool ShouldProcessEdge(IControlFlowEdge edge);
    protected virtual bool ShouldInspectSingleLeaf(ControlFlowElement element);
}
public class JetBrains.ReSharper.Psi.ControlFlow.Impl.ControlFlowMultiplexor : ControlFlowElement {
    [CanBeNullAttribute]
private ITreeNode myReferencedElement;
    public ITreeNode SourceElement { get; }
    public ControlFlowMultiplexor(ITreeNode referencedElement);
    public virtual ITreeNode get_SourceElement();
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.ControlFlow.Impl.ControlFlowVariableAccessState : Enum {
    public ushort value__;
    public static ControlFlowVariableAccessState NONE;
    public static ControlFlowVariableAccessState INITIALIZED;
    public static ControlFlowVariableAccessState ASSIGNED;
    public static ControlFlowVariableAccessState ACCESSED;
    public static ControlFlowVariableAccessState RANDOM_ACCESSED;
    public static ControlFlowVariableAccessState ASSIGNED_IN_ANONYMOUS_METHOD;
    public static ControlFlowVariableAccessState ADDRESSOF_TAKEN;
    public static ControlFlowVariableAccessState DEFINITELY_ASSIGNED;
    public static ControlFlowVariableAccessState RANDOM_ASSIGNED;
    public static ControlFlowVariableAccessState ACCESSED_AS_ENUMERABLE;
    public static ControlFlowVariableAccessState INITIALIZED_OUTSIDE;
    public static ControlFlowVariableAccessState DECLARATION_ACCESSED;
    public static ControlFlowVariableAccessState AWAIT_OR_YIELD_CLOSURE;
    public static ControlFlowVariableAccessState ALL;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ControlFlow.Impl.ControlFlowVariableState : object {
    private ControlFlowVariableAccessState myAccessState;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ITreeNode, HashSet`1<ITreeNode>> myRecentAssignmentsAndUsages;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<ITreeNode> myRecentAccessInClosure;
    public IEnumerable`1<ITreeNode> RecentAssignments { get; }
    public IEnumerable`1<ITreeNode> RecentAccessInClosure { get; }
    public ControlFlowVariableAccessState Access { get; }
    public ControlFlowVariableState(ControlFlowVariableAccessState access);
    public ControlFlowVariableState(ICollection`1<ControlFlowVariableState> states);
    public IEnumerable`1<ITreeNode> get_RecentAssignments();
    public IEnumerable`1<ITreeNode> GetUsagesOfRecentAssignment(ITreeNode assignment);
    public IEnumerable`1<ITreeNode> get_RecentAccessInClosure();
    public ControlFlowVariableAccessState get_Access();
    [PureAttribute]
private ControlFlowVariableState Clone();
    public bool Compare(ControlFlowVariableState s);
    private static bool CompareSets(HashSet`1<ITreeNode> spec1, HashSet`1<ITreeNode> spec2);
    private static bool CompareSets(Dictionary`2<ITreeNode, HashSet`1<ITreeNode>> spec1, Dictionary`2<ITreeNode, HashSet`1<ITreeNode>> spec2);
    public ControlFlowVariableState SetAccessState(ControlFlowVariableAccessState accessState);
    public ControlFlowVariableState AddToRecentAssignments(ITreeNode node);
    public ControlFlowVariableState AddToRecentUsage(ITreeNode node);
    public ControlFlowVariableState ClearRecentAssignments();
    public ControlFlowVariableState AddToRecentAccessInClosure(ITreeNode node);
    public ControlFlowVariableState ClearRecentAccessInClosure();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.ControlFlow.Impl.ControlFlowVariableStateCollection : ValueType {
    [NotNullAttribute]
private ControlFlowVariableState[] myStates;
    public ControlFlowVariableState Item { get; }
    public object RawArray { get; }
    public ControlFlowVariableStateCollection(int count);
    private ControlFlowVariableStateCollection(ControlFlowVariableState[] states);
    public ControlFlowVariableState get_Item(int index);
    public object get_RawArray();
    public ControlFlowVariableStateCollection Modify(int index, Func`2<ControlFlowVariableState, ControlFlowVariableState> mutator);
    public ControlFlowVariableStateCollection Modify(int index, TState state, Func`3<TState, ControlFlowVariableState, ControlFlowVariableState> mutator);
    public ControlFlowVariableStateCollection Modify(IEnumerable`1<int> indices, Func`2<ControlFlowVariableState, ControlFlowVariableState> mutator);
    public bool Compare(ControlFlowVariableStateCollection other);
    public ControlFlowVariableStateCollection SetDefiniteAssignmentStateFrom(ControlFlowVariableStateCollection definiteAssignmentSourceState);
    public static ControlFlowVariableStateCollection Merge(IEnumerable`1<ControlFlowVariableStateCollection> collections);
}
public enum JetBrains.ReSharper.Psi.ControlFlow.Impl.ExecutionBehavior : Enum {
    public int value__;
    public static ExecutionBehavior RandomExecution;
    public static ExecutionBehavior InstantExecution;
    public static ExecutionBehavior Tunnel;
    public static ExecutionBehavior DeferredExecutionInsideMethod;
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.ReSharper.Psi.ControlFlow.Impl.ICommonLanguageControlFlowContext`2 {
    public TContext ParentContext { get; }
    public ControlFlowVariableAccessState Item { get; public set; }
    public ExecutionBehavior ExecutionBehavior { get; }
    public abstract virtual void AddToRecentAssignmentsList(TVariableInfo info, ITreeNode element);
    public abstract virtual void AddToRecentUsagesList(TVariableInfo info, ITreeNode element);
    public abstract virtual void AddRecentAccessInClosure(TVariableInfo info, ITreeNode element);
    public abstract virtual void ClearRecentAssignmentsList(TVariableInfo info);
    public abstract virtual void ClearRecentAccessInClosure(TVariableInfo info);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<ITreeNode> GetRecentAssignmentsList(TVariableInfo info);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<ITreeNode> GetUsagesOfRecentAssignments(TVariableInfo info, ITreeNode assignment);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<ITreeNode> GetRecentAccessInClosure(TVariableInfo info);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<TVariableInfo> EnumerateVariables();
    public abstract virtual TVariableInfo GetVariableInfoByVariableInfoInChildContext(TVariableInfo infoInChildContext);
    public abstract virtual TContext get_ParentContext();
    public abstract virtual ControlFlowVariableAccessState get_Item(TVariableInfo info);
    public abstract virtual void set_Item(TVariableInfo info, ControlFlowVariableAccessState value);
    public abstract virtual void SetAccessStates(IEnumerable`1<TVariableInfo> infos, Func`2<ControlFlowVariableAccessState, ControlFlowVariableAccessState> mutator);
    public abstract virtual ExecutionBehavior get_ExecutionBehavior();
}
public interface JetBrains.ReSharper.Psi.ControlFlow.Impl.IControlFlowAnalysisResult {
    [NotNullAttribute]
public OneToSetMap`2<ITreeNode, QualifiedDeclaredElementReference> ReadWithoutWriteExpressions { get; }
    [NotNullAttribute]
public OneToListMap`2<ITreeNode, IDeclaredElement> NotInitializedVariables { get; }
    [NotNullAttribute]
public IDictionary`2<IDeclaredElement, IDictionary`2<ITreeNode, List`1<ITreeNode>>> AssignmentsUsage { get; }
    [NotNullAttribute]
public IDictionary`2<IDeclaredElement, IList`1<IExpression>> AccessToExternalModifiedClosure { get; }
    [NotNullAttribute]
public IDictionary`2<IDeclaredElement, IList`1<IExpression>> AccessToExternalDisposedClosure { get; }
    [NotNullAttribute]
public IDictionary`2<IDeclaredElement, IList`1<IExpression>> AccessToForEachVariableInClosure { get; }
    [NotNullAttribute]
public IDictionary`2<IDeclaredElement, List`1<ITreeNode>> ElementInitializers { get; }
    [NotNullAttribute]
public IDictionary`2<IDeclaredElement, bool> FinalLocals { get; }
    public abstract virtual OneToSetMap`2<ITreeNode, QualifiedDeclaredElementReference> get_ReadWithoutWriteExpressions();
    public abstract virtual OneToListMap`2<ITreeNode, IDeclaredElement> get_NotInitializedVariables();
    public abstract virtual IDictionary`2<IDeclaredElement, IDictionary`2<ITreeNode, List`1<ITreeNode>>> get_AssignmentsUsage();
    public abstract virtual IDictionary`2<IDeclaredElement, IList`1<IExpression>> get_AccessToExternalModifiedClosure();
    public abstract virtual IDictionary`2<IDeclaredElement, IList`1<IExpression>> get_AccessToExternalDisposedClosure();
    public abstract virtual IDictionary`2<IDeclaredElement, IList`1<IExpression>> get_AccessToForEachVariableInClosure();
    public abstract virtual IDictionary`2<IDeclaredElement, List`1<ITreeNode>> get_ElementInitializers();
    public abstract virtual IDictionary`2<IDeclaredElement, bool> get_FinalLocals();
}
public interface JetBrains.ReSharper.Psi.ControlFlow.Impl.IControlFlowVariableInfo`1 {
    [CanBeNullAttribute]
public TVariableInfo Parent { get; }
    [CanBeNullAttribute]
public IClrDeclaredElement DeclaredElement { get; }
    public bool ShouldBeAssignedUponExit { get; }
    public ControlFlowVariableAccessState InitialAccessState { get; }
    [NotNullAttribute]
public IList`1<TVariableInfo> NestedVariableInfos { get; }
    public bool CanBeAssignedFromStructFields { get; }
    public bool IsTrackedInValueAnalysis { get; }
    public bool IsTrackedInAccessStateAnalysis { get; }
    public abstract virtual TVariableInfo get_Parent();
    public abstract virtual IClrDeclaredElement get_DeclaredElement();
    public abstract virtual bool get_ShouldBeAssignedUponExit();
    public abstract virtual ControlFlowVariableAccessState get_InitialAccessState();
    public abstract virtual IList`1<TVariableInfo> get_NestedVariableInfos();
    public abstract virtual bool get_CanBeAssignedFromStructFields();
    public abstract virtual bool get_IsTrackedInValueAnalysis();
    public abstract virtual bool get_IsTrackedInAccessStateAnalysis();
}
public class JetBrains.ReSharper.Psi.ControlFlow.Impl.QualifiedDeclaredElementReference : ValueType {
    [NotNullAttribute]
[ItemNotNullAttribute]
private IDeclaredElement[] myVariableAccessChain;
    [NotNullAttribute]
public IDeclaredElement DeclaredElement { get; }
    [NotNullAttribute]
public IDeclaredElement TopmostQualifier { get; }
    public Nullable`1<QualifiedDeclaredElementReference> Qualifier { get; }
    private QualifiedDeclaredElementReference(IDeclaredElement[] variableAccessChain);
    public IDeclaredElement get_DeclaredElement();
    public IDeclaredElement get_TopmostQualifier();
    public Nullable`1<QualifiedDeclaredElementReference> get_Qualifier();
    public bool IsValid();
    public bool Equals(QualifiedDeclaredElementReference other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static QualifiedDeclaredElementReference Create(IControlFlowVariableInfo`1<TVariableInfo> variableInfo);
    [NotNullAttribute]
public static IList`1<QualifiedDeclaredElementReference> Merge(IEnumerable`1<QualifiedDeclaredElementReference> references);
    [NotNullAttribute]
private static IList`1<QualifiedDeclaredElementReference> MergeImpl(IEnumerable`1<QualifiedDeclaredElementReference> references, int qualifierLevel);
    [NotNullAttribute]
public static string Present(IEnumerable`1<QualifiedDeclaredElementReference> references, PsiLanguageType languageType);
    public static string PresentAccess(QualifiedDeclaredElementReference reference, PsiLanguageType languageType);
    [NotNullAttribute]
private static string GetPresentationImpl(ElementKind kind, String[] accessExpressions);
    private ElementKind GetKind();
}
public enum JetBrains.ReSharper.Psi.ControlFlow.ValueAnalysisMode : Enum {
    public int value__;
    public static ValueAnalysisMode OFF;
    public static ValueAnalysisMode OPTIMISTIC;
    public static ValueAnalysisMode PESSIMISTIC;
    public static ValueAnalysisMode IMPLICIT_NOTNULL;
}
public static class JetBrains.ReSharper.Psi.ControlFlow2.ControlFlowUtil : object {
    public static IEnumerable`1<IControlFlowEdge> AllReachableEdges(IControlFlowElement element);
    private static bool EdgeTargetOfTypeNextContainsSource(ITreeNode sourceElement, IControlFlowEdge edge);
    public static ICollection`1<IControlFlowEdge> FindExitsFrom(ITreeNode owner, IControlFlowElement element);
    private static void FindExitsRecursive(ITreeNode owner, IControlFlowElement element, HashSet`1<IControlFlowEdge> exits);
}
internal class JetBrains.ReSharper.Psi.DataContext.EmptyPsiDocumentRangeView : object {
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    public DocumentRange DocumentRangeFromMainDocument { get; }
    public ISolution Solution { get; }
    public IReadOnlyCollection`1<IPsiSourceFile> SortedSourceFiles { get; }
    public EmptyPsiDocumentRangeView(ISolution solution);
    public sealed virtual IContextBoundSettingsStore GetSettingsStore();
    public sealed virtual DocumentRange get_DocumentRangeFromMainDocument();
    public sealed virtual IDocument TryGetSourceGeneratedFileAssociatedDocument();
    [CompilerGeneratedAttribute]
public sealed virtual ISolution get_Solution();
    public sealed virtual IReadOnlyCollection`1<IPsiSourceFile> get_SortedSourceFiles();
    public sealed virtual IPsiView View(PsiLanguageType languageType, PsiLanguageCategories languageCategories);
    public sealed virtual IPsiView View(PsiLanguageCategories languageCategories);
}
internal class JetBrains.ReSharper.Psi.DataContext.EmptyPsiSourceFilesView : object {
    [NotNullAttribute]
private ISolution mySolution;
    public ISolution Solution { get; }
    public IEnumerable`1<IPsiSourceFile> SortedSourceFiles { get; }
    public EmptyPsiSourceFilesView(ISolution solution);
    public sealed virtual ISolution get_Solution();
    public sealed virtual IEnumerable`1<IPsiSourceFile> get_SortedSourceFiles();
    public sealed virtual IPsiDocumentRangeView ObserveAt(DocumentRange documentRange);
}
internal class JetBrains.ReSharper.Psi.DataContext.EmptyPsiView : object {
    [NotNullAttribute]
public static IPsiView Instance;
    public IReadOnlyCollection`1<PsiLanguageType> Languages { get; }
    public IReadOnlyCollection`1<IFile> Files { get; }
    public IReadOnlyCollection`1<ITreeNode> ContainingNodes { get; }
    public IReadOnlyCollection`1<PsiTokensAtRange> Tokens { get; }
    public IReadOnlyCollection`1<IPsiSourceFile> SortedSourceFiles { get; }
    private static EmptyPsiView();
    public sealed virtual IReadOnlyCollection`1<PsiLanguageType> get_Languages();
    public sealed virtual IReadOnlyCollection`1<IFile> get_Files();
    public sealed virtual IReadOnlyCollection`1<ITreeNode> get_ContainingNodes();
    public sealed virtual TreeTextRange GetSelectedTreeRange(ITreeNode treeNode);
    public sealed virtual bool SelectionIsExactlyAtEdge(ITreeNode treeNode, bool before);
    public sealed virtual IReadOnlyCollection`1<PsiTokensAtRange> get_Tokens();
    public sealed virtual IReadOnlyCollection`1<IPsiSourceFile> get_SortedSourceFiles();
}
public interface JetBrains.ReSharper.Psi.DataContext.IPsiDocumentRangeView {
    public DocumentRange DocumentRangeFromMainDocument { get; }
    [NotNullAttribute]
public ISolution Solution { get; }
    [NotNullAttribute]
public IReadOnlyCollection`1<IPsiSourceFile> SortedSourceFiles { get; }
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IPsiView View(PsiLanguageType languageType, PsiLanguageCategories languageCategories);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IPsiView View(PsiLanguageCategories languageCategories);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public abstract virtual IContextBoundSettingsStore GetSettingsStore();
    public abstract virtual DocumentRange get_DocumentRangeFromMainDocument();
    [CanBeNullAttribute]
public abstract virtual IDocument TryGetSourceGeneratedFileAssociatedDocument();
    public abstract virtual ISolution get_Solution();
    public abstract virtual IReadOnlyCollection`1<IPsiSourceFile> get_SortedSourceFiles();
}
public interface JetBrains.ReSharper.Psi.DataContext.IPsiSourceFilesView {
    [NotNullAttribute]
public IEnumerable`1<IPsiSourceFile> SortedSourceFiles { get; }
    [NotNullAttribute]
public ISolution Solution { get; }
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IPsiDocumentRangeView ObserveAt(DocumentRange documentRange);
    public abstract virtual IEnumerable`1<IPsiSourceFile> get_SortedSourceFiles();
    public abstract virtual ISolution get_Solution();
}
public interface JetBrains.ReSharper.Psi.DataContext.IPsiView {
    [NotNullAttribute]
public IReadOnlyCollection`1<PsiLanguageType> Languages { get; }
    [NotNullAttribute]
public IReadOnlyCollection`1<IFile> Files { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyCollection`1<ITreeNode> ContainingNodes { get; }
    [NotNullAttribute]
public IReadOnlyCollection`1<PsiTokensAtRange> Tokens { get; }
    [NotNullAttribute]
public IReadOnlyCollection`1<IPsiSourceFile> SortedSourceFiles { get; }
    public abstract virtual IReadOnlyCollection`1<PsiLanguageType> get_Languages();
    public abstract virtual IReadOnlyCollection`1<IFile> get_Files();
    public abstract virtual IReadOnlyCollection`1<ITreeNode> get_ContainingNodes();
    [PureAttribute]
public abstract virtual TreeTextRange GetSelectedTreeRange(ITreeNode treeNode);
    [PureAttribute]
public abstract virtual bool SelectionIsExactlyAtEdge(ITreeNode treeNode, bool before);
    public abstract virtual IReadOnlyCollection`1<PsiTokensAtRange> get_Tokens();
    public abstract virtual IReadOnlyCollection`1<IPsiSourceFile> get_SortedSourceFiles();
}
internal class JetBrains.ReSharper.Psi.DataContext.MultiplePsiViews : object {
    [NotNullAttribute]
private PsiFileView[] myPsiViews;
    public IReadOnlyCollection`1<PsiLanguageType> Languages { get; }
    public IReadOnlyCollection`1<IFile> Files { get; }
    public IReadOnlyCollection`1<ITreeNode> ContainingNodes { get; }
    public IReadOnlyCollection`1<PsiTokensAtRange> Tokens { get; }
    public IReadOnlyCollection`1<IPsiSourceFile> SortedSourceFiles { get; }
    public MultiplePsiViews(PsiFileView[] psiViews);
    public sealed virtual IReadOnlyCollection`1<PsiLanguageType> get_Languages();
    public sealed virtual IReadOnlyCollection`1<IFile> get_Files();
    public sealed virtual IReadOnlyCollection`1<ITreeNode> get_ContainingNodes();
    public sealed virtual TreeTextRange GetSelectedTreeRange(ITreeNode treeNode);
    public sealed virtual bool SelectionIsExactlyAtEdge(ITreeNode treeNode, bool before);
    public sealed virtual IReadOnlyCollection`1<PsiTokensAtRange> get_Tokens();
    public sealed virtual IReadOnlyCollection`1<IPsiSourceFile> get_SortedSourceFiles();
}
public static class JetBrains.ReSharper.Psi.DataContext.PsiDataConstants : object {
    [NotNullAttribute]
public static DataConstant`1<PsiDocumentView> PSI_DOCUMENT_VIEW;
    [NotNullAttribute]
public static DataConstant`1<PsiEditorView> PSI_EDITOR_VIEW;
    [NotNullAttribute]
public static DataConstant`1<IClrDeclaredElement> TYPE_OR_TYPE_MEMBER;
    [NotNullAttribute]
[ObsoleteAttribute("Use DataConstants.DECLARED_ELEMENTS")]
public static DataConstant`1<IDeclaredElement> DECLARED_ELEMENT;
    [NotNullAttribute]
public static DataConstant`1<ICollection`1<IDeclaredElement>> DECLARED_ELEMENTS;
    [NotNullAttribute]
public static DataConstant`1<ICollection`1<IDeclaredElement>> DECLARED_ELEMENTS_FROM_ALL_CONTEXTS;
    [NotNullAttribute]
public static DataConstant`1<ICollection`1<IDeclaredElement>> DECLARED_ELEMENTS_BY_SIGNATURE;
    [NotNullAttribute]
public static DataConstant`1<IReference> REFERENCE;
    [NotNullAttribute]
public static DataConstant`1<ICollection`1<IReference>> REFERENCES;
    [NotNullAttribute]
public static DataConstant`1<ICollection`1<IReference>> REFERENCES_FROM_ALL_CONTEXTS;
    [NotNullAttribute]
public static DataConstant`1<ITreeNode> SELECTED_EXPRESSION;
    [NotNullAttribute]
public static DataConstant`1<IEnumerable`1<ITreeNode>> SELECTED_TREE_NODES;
    [NotNullAttribute]
public static DataConstant`1<IPsiSourceFile> SOURCE_FILE;
    private static PsiDataConstants();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.DataContext.PsiDataConstantsExtensions : object {
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
[PureAttribute]
public static ICollection`1<IDeclaredElement> ToDeclaredElementsDataConstant(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ICollection`1<IDeclaredElement> ToDeclaredElementsDataConstant(ICollection`1<IDeclaredElement> declaredElements);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IDataContext FromDeclaredElement(DataContexts dataContexts, Lifetime lifetime, IDeclaredElement element);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IDataContext FromDeclaredElement(DataContexts dataContexts, Lifetime lifetime, IClrDeclaredElement element);
}
public class JetBrains.ReSharper.Psi.DataContext.PsiDocumentRangeView : object {
    [NotNullAttribute]
private IPsiSourceFile[] mySourceFiles;
    [CanBeNullAttribute]
private ILanguages modreq(System.Runtime.CompilerServices.IsVolatile) myLanguages;
    [CanBeNullAttribute]
private PsiFiles[] modreq(System.Runtime.CompilerServices.IsVolatile) myRequestedPsiFiles;
    [NotNullAttribute]
private ConcurrentDictionary`2<IFile, IPsiView> myFileToView;
    [NotNullAttribute]
private ConcurrentDictionary`2<CacheKey, IPsiView> myAggregatedViews;
    [CompilerGeneratedAttribute]
private DocumentRange <DocumentRangeFromMainDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    public DocumentRange DocumentRangeFromMainDocument { get; }
    public ISolution Solution { get; }
    public IReadOnlyCollection`1<IPsiSourceFile> SortedSourceFiles { get; }
    [NotNullAttribute]
private ILanguages Languages { get; }
    internal PsiDocumentRangeView(ISolution solution, IPsiSourceFile[] sourceFiles, DocumentRange documentRange);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.DataContext.PsiDocumentRangeView/<GetOrRequestPsiFilesInTheAscendingOrderOfDocumentRange>d__6")]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
private IEnumerable`1<IReadOnlyCollection`1<IFile>> GetOrRequestPsiFilesInTheAscendingOrderOfDocumentRange(PsiLanguageCategories languageCategories);
    [PureAttribute]
private static bool DocumentFromFiles(IDocument document, IPsiSourceFile[] sourceFiles);
    [PureAttribute]
[NotNullAttribute]
public static PsiDocumentRangeView Create(IPsiSourceFile sourceFile, DocumentRange documentRange);
    public sealed virtual IContextBoundSettingsStore GetSettingsStore();
    [CompilerGeneratedAttribute]
public sealed virtual DocumentRange get_DocumentRangeFromMainDocument();
    public sealed virtual IDocument TryGetSourceGeneratedFileAssociatedDocument();
    [CompilerGeneratedAttribute]
public sealed virtual ISolution get_Solution();
    public sealed virtual IReadOnlyCollection`1<IPsiSourceFile> get_SortedSourceFiles();
    public sealed virtual IPsiView View(PsiLanguageType languageType, PsiLanguageCategories languageCategories);
    public sealed virtual IPsiView View(PsiLanguageCategories languageCategories);
    private ILanguages get_Languages();
    [NotNullAttribute]
[PureAttribute]
private IPsiView CreatePsiView(PsiLanguageCategories languageCategories, PsiLanguageType languageType);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.DataContext.PsiDocumentRangeViewExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IPsiView ViewAll(IPsiDocumentRangeView documentRangeView);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IPsiView View(IPsiDocumentRangeView documentRangeView);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IPsiView ViewDominant(IPsiDocumentRangeView documentRangeView);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IPsiView ViewDominant(IPsiDocumentRangeView documentRangeView);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IPsiView ViewPrimary(IPsiDocumentRangeView documentRangeView);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IPsiView ViewPrimary(IPsiDocumentRangeView documentRangeView);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IPsiView ViewSecondary(IPsiDocumentRangeView documentRangeView);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IPsiView ViewSecondary(IPsiDocumentRangeView documentRangeView);
}
public class JetBrains.ReSharper.Psi.DataContext.PsiDocumentView : object {
    [NotNullAttribute]
private IDocument myPrimaryDocument;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    private bool myProjectFileOfPrimaryDocumentRequested;
    [CanBeNullAttribute]
private IProjectFile modreq(System.Runtime.CompilerServices.IsVolatile) myProjectFileOfPrimaryDocument;
    [CanBeNullAttribute]
private IProjectFile[] modreq(System.Runtime.CompilerServices.IsVolatile) myAllProjectFilesForPhysicalFile;
    private bool myTargetFrameworkRequested;
    [CanBeNullAttribute]
private TargetFrameworkId modreq(System.Runtime.CompilerServices.IsVolatile) myCurrentTargetFrameworkId;
    [CanBeNullAttribute]
private IPsiSourceFile[] modreq(System.Runtime.CompilerServices.IsVolatile) mySortedSourceFilesOfCurrentProjectFile;
    [CanBeNullAttribute]
private IPsiSourceFile[] modreq(System.Runtime.CompilerServices.IsVolatile) mySortedSourceFilesOfAllProjectFilesForPhysicalFile;
    [CanBeNullAttribute]
private IPsiSourceFilesView modreq(System.Runtime.CompilerServices.IsVolatile) myDefaultSourceFileView;
    [CanBeNullAttribute]
private IPsiSourceFilesView modreq(System.Runtime.CompilerServices.IsVolatile) myAllSourceFilesView;
    [CanBeNullAttribute]
private SolutionComponents myComponents;
    [NotNullAttribute]
public ISolution Solution { get; }
    [NotNullAttribute]
internal IDocument PrimaryDocument { get; }
    [NotNullAttribute]
public IPsiSourceFilesView DefaultSourceFile { get; }
    [NotNullAttribute]
public IPsiSourceFilesView AllSourceFiles { get; }
    [NotNullAttribute]
private SolutionComponents Components { get; }
    public PsiDocumentView(IDocument primaryDocument, ISolution solution);
    [CompilerGeneratedAttribute]
public ISolution get_Solution();
    internal IDocument get_PrimaryDocument();
    [CanBeNullAttribute]
[PureAttribute]
private IProjectFile GetProjectFileOfPrimaryDocument();
    [NotNullAttribute]
[PureAttribute]
private IProjectFile[] GetAllProjectFilesForPhysicalFile();
    [CanBeNullAttribute]
[PureAttribute]
private TargetFrameworkId GetCurrentTargetFramework();
    [NotNullAttribute]
[PureAttribute]
private IPsiSourceFile[] GetOrCreateSortedSourceFilesOfCurrentProjectFile();
    [NotNullAttribute]
[PureAttribute]
private IPsiSourceFile[] GetOrCreateSortedSourceFilesOfAllProjectFilesFromPhysicalFile();
    public IPsiSourceFilesView get_DefaultSourceFile();
    public IPsiSourceFilesView get_AllSourceFiles();
    private SolutionComponents get_Components();
}
public class JetBrains.ReSharper.Psi.DataContext.PsiEditorView : object {
    [NotNullAttribute]
private PsiDocumentView myDocumentView;
    private DocumentRange myTextControlSelectionRange;
    [CanBeNullAttribute]
private IPsiDocumentRangeView modreq(System.Runtime.CompilerServices.IsVolatile) myDefaultSourceFileView;
    [CanBeNullAttribute]
private IPsiDocumentRangeView modreq(System.Runtime.CompilerServices.IsVolatile) myAllSourceFilesView;
    [NotNullAttribute]
public IPsiDocumentRangeView DefaultSourceFile { get; }
    [NotNullAttribute]
public IPsiDocumentRangeView AllSourceFiles { get; }
    [NotNullAttribute]
public ISolution Solution { get; }
    public PsiEditorView(ISolution solution, ITextControl textControl, bool mergeMultiSelection);
    private PsiEditorView(ISolution solution, DocumentRange documentRange);
    public PsiEditorView(PsiDocumentView documentView, DocumentEditorContext editorContext);
    public IPsiDocumentRangeView get_DefaultSourceFile();
    public IPsiDocumentRangeView get_AllSourceFiles();
    public ISolution get_Solution();
    [NotNullAttribute]
[PureAttribute]
public static PsiEditorView Create(ISolution solution, DocumentOffset documentOffset);
    [NotNullAttribute]
[PureAttribute]
public static PsiEditorView Create(ISolution solution, DocumentRange documentRange);
}
public class JetBrains.ReSharper.Psi.DataContext.PsiFileView : object {
    [CanBeNullAttribute]
private IReadOnlyCollection`1 modreq(System.Runtime.CompilerServices.IsVolatile) myContainingNodes;
    [CanBeNullAttribute]
private IReadOnlyCollection`1 modreq(System.Runtime.CompilerServices.IsVolatile) myTokens;
    [CompilerGeneratedAttribute]
private IFile <File>k__BackingField;
    [CompilerGeneratedAttribute]
private TreeTextRange <TreeRange>k__BackingField;
    [NotNullAttribute]
public IFile File { get; }
    public TreeTextRange TreeRange { get; }
    [NotNullAttribute]
public PsiLanguageType Language { get; }
    private IReadOnlyCollection`1<PsiLanguageType> JetBrains.ReSharper.Psi.DataContext.IPsiView.Languages { get; }
    public IReadOnlyCollection`1<IFile> Files { get; }
    public IReadOnlyCollection`1<ITreeNode> ContainingNodes { get; }
    public IReadOnlyCollection`1<PsiTokensAtRange> Tokens { get; }
    public IReadOnlyCollection`1<IPsiSourceFile> SortedSourceFiles { get; }
    public PsiFileView(IFile psiFile, TreeTextRange treeRange);
    [CompilerGeneratedAttribute]
public IFile get_File();
    [CompilerGeneratedAttribute]
public TreeTextRange get_TreeRange();
    public PsiLanguageType get_Language();
    private sealed virtual override IReadOnlyCollection`1<PsiLanguageType> JetBrains.ReSharper.Psi.DataContext.IPsiView.get_Languages();
    public sealed virtual IReadOnlyCollection`1<IFile> get_Files();
    public sealed virtual IReadOnlyCollection`1<ITreeNode> get_ContainingNodes();
    public sealed virtual TreeTextRange GetSelectedTreeRange(ITreeNode treeNode);
    public sealed virtual bool SelectionIsExactlyAtEdge(ITreeNode treeNode, bool before);
    public sealed virtual IReadOnlyCollection`1<PsiTokensAtRange> get_Tokens();
    [NotNullAttribute]
private IReadOnlyCollection`1<PsiTokensAtRange> ComputeTokens();
    [PureAttribute]
private PsiTokensAtOffset ComputeTokensAtOffsetFromContainingNodes(TreeOffset treeOffset);
    [PureAttribute]
private static PsiTokensAtRange ComputeTokensFromRangeInContainingToken(ITokenNode containingToken, TreeTextRange selectionRange);
    [PureAttribute]
private static PsiTokensAtOffset FindTokensByOffsetInContainingNode(ITreeNode nodeWithTokens, TreeOffset treeOffset);
    public sealed virtual IReadOnlyCollection`1<IPsiSourceFile> get_SortedSourceFiles();
    [NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public IReadOnlyList`1<IReference> FindContainingReferencesUnordered();
    [CanBeNullAttribute]
[PureAttribute]
public static PsiFileView TryCreate(IFile psiFile, DocumentOffset documentOffset);
    [CanBeNullAttribute]
[PureAttribute]
public static PsiFileView TryCreate(IFile psiFile, DocumentRange documentRange);
}
internal class JetBrains.ReSharper.Psi.DataContext.PsiSourceFilesView : object {
    [CompilerGeneratedAttribute]
private IPsiSourceFile[] <sourceFiles>P;
    [NotNullAttribute]
private ConcurrentDictionary`2<DocumentRange, IPsiDocumentRangeView> myViews;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    public ISolution Solution { get; }
    public IEnumerable`1<IPsiSourceFile> SortedSourceFiles { get; }
    public PsiSourceFilesView(ISolution solution, IPsiSourceFile[] sourceFiles);
    [CompilerGeneratedAttribute]
public sealed virtual ISolution get_Solution();
    public sealed virtual IEnumerable`1<IPsiSourceFile> get_SortedSourceFiles();
    public sealed virtual IPsiDocumentRangeView ObserveAt(DocumentRange documentRange);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.DataContext.PsiSourceFilesViewExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IPsiDocumentRangeView ObserveAt(IPsiSourceFilesView sourceFilesView, DocumentOffset documentOffset);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.DataContext.PsiTokensAtOffset : ValueType {
    [CanBeNullAttribute]
public ITokenNode LeftToken;
    [CanBeNullAttribute]
public ITokenNode RightToken;
    public TreeOffset OffsetInFile;
    [CanBeNullAttribute]
public ITokenNode UnderToken { get; }
    [CanBeNullAttribute]
public ITokenNode StrictlyLeftToken { get; }
    [CanBeNullAttribute]
public ITokenNode StrictlyRightToken { get; }
    private bool InTheMiddleOfToken { get; }
    public bool IsEmpty { get; }
    public PsiTokensAtOffset(ITokenNode leftToken, ITokenNode rightToken, TreeOffset offsetInFile);
    public ITokenNode get_UnderToken();
    public ITokenNode get_StrictlyLeftToken();
    public ITokenNode get_StrictlyRightToken();
    private bool get_InTheMiddleOfToken();
    public bool get_IsEmpty();
    [NotNullAttribute]
[PureAttribute]
public IReadOnlyList`1<ITokenNode> All();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.DataContext.PsiTokensAtRange : ValueType {
    public PsiTokensAtOffset AtStart;
    public PsiTokensAtOffset AtEnd;
    public bool IsAtSingleOffset { get; }
    public bool IsSingleTokenInRange { get; }
    public bool IsEmpty { get; }
    public PsiTokensAtRange(PsiTokensAtOffset tokens);
    public PsiTokensAtRange(PsiTokensAtOffset atStart, PsiTokensAtOffset atEnd);
    public bool get_IsAtSingleOffset();
    public bool get_IsSingleTokenInRange();
    public bool get_IsEmpty();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.DataContext.PsiViewExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IEnumerable`1<TTreeNode> ContainingNodes(IPsiView psiView);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasContainingNode(IPsiView psiView);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static TTreeNode GetSelectedTreeNode(IPsiView psiView);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITreeNode GetSelectedTreeNodeAnyOf(IPsiView psiView);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
[ContractAnnotationAttribute("=> null, anchor: null; => notnull, anchor: notnull")]
public static TTreeNode GetSelectedTreeNode(IPsiView psiView, ITreeNode& anchor);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("node: null => false")]
public static bool IsSelectedTreeNode(IPsiView psiView, ITreeNode node);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.DataContext.PsiViewExtensions/<GetContainingDeclarations>d__6")]
[ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IDeclaration> GetContainingDeclarations(IPsiView psiView);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.DataContext.PsiViewExtensions/<GetContainingDeclaredElements>d__7")]
[ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IDeclaredElement> GetContainingDeclaredElements(IPsiView psiView);
}
[ShellComponentAttribute("16")]
internal class JetBrains.ReSharper.Psi.DataContext.SourceFileDataContextCopierProvider : object {
    public sealed virtual void ProvideConstantsToCopy(DataContextCopier copier);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Psi.DebugTypePresenter : TypeVisitor`2<StringBuilder, Unit> {
    private static DebugTypePresenter ourInstance;
    private static DebugTypePresenter();
    [PureAttribute]
public static string Present(IType type);
    private static string GetSpecialPresentation(IType type);
    public virtual Unit VisitType(IType type, StringBuilder builder);
    public virtual Unit VisitDeclaredType(IDeclaredType declaredType, StringBuilder builder);
    public virtual Unit VisitArrayType(IArrayType arrayType, StringBuilder builder);
    public virtual Unit VisitPointerType(IPointerType pointerType, StringBuilder builder);
    public virtual Unit VisitFunctionPointerType(IFunctionPointerType functionPointerType, StringBuilder builder);
    public virtual Unit VisitMultitype(IMultitype multitype, StringBuilder builder);
    public virtual Unit VisitAnonymousType(IAnonymousType anonymousType, StringBuilder builder);
    internal static string TypeParameterToString(ITypeParameter typeParameter);
}
public static class JetBrains.ReSharper.Psi.DeclaredElementConstants : object {
    public static string CONSTRUCTOR_NAME;
    public static string STATIC_CONSTRUCTOR_NAME;
    public static string DEFAULT_PROPERTY_NAME;
    public static string DELEGATE_INVOKE_METHOD_NAME;
    public static string DELEGATE_BEGIN_INVOKE_METHOD_NAME;
    public static string DELEGATE_END_INVOKE_METHOD_NAME;
    public static string NAMEOF_NAME;
}
public class JetBrains.ReSharper.Psi.DeclaredElementEnvoy`1 : object {
    private DeclaredElementEnvoyCachedPresentation myPresentation;
    private IElementInstancePointer`1<T> myElementPointer;
    private List`1<OWORD> mySourceFilePersistentId;
    private int myMemberHashTimestamp;
    private Nullable`1<Hash> myHash;
    private int myCachedHashCode;
    private IPsiServices myPsiServices;
    private bool myHasSubstitution;
    private FrugalLocalList`1<IProjectFile> myProjectFiles;
    public bool IsValid { get; }
    public string Text { get; }
    public DeclaredElementEnvoy`1(T declaredElement, ISubstitution substitution);
    public bool get_IsValid();
    private sealed virtual override IDeclaredElement JetBrains.ReSharper.Psi.IDeclaredElementEnvoy.GetValidDeclaredElement();
    public T GetValidDeclaredElement();
    private sealed virtual override DeclaredElementInstance JetBrains.ReSharper.Psi.IDeclaredElementEnvoy.GetValidDeclaredElementInstance();
    public DeclaredElementInstance`1<T> GetValidDeclaredElementInstance();
    public sealed virtual string get_Text();
    public sealed virtual void Present(StructuredPresenter`2<TStructureElement, IPresentableItem> presenter, TStructureElement structureElement, IPresentableItem item, PresentationState state);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.DeclaredElementEnvoy`1/<GetSourceFiles>d__19")]
private IEnumerable`1<IPsiSourceFile> GetSourceFiles();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void ResetCache();
    public virtual string ToString();
    private void RecalculateHash(IDeclaredElement declaredElement);
}
public class JetBrains.ReSharper.Psi.DeclaredElementEnvoyCachedPresentation : ValueType {
    private IPresentableItem myCache;
    private object myStructureElementWithCachedPresentation;
    private long myPresentationStamp;
    public string Text { get; }
    private IPresentableItem Cache { get; }
    public void Present(StructuredPresenter`2<TStructureElement, IPresentableItem> presenter, TStructureElement structureElement, IPresentableItem item, PresentationState state, IEnumerable`1<IPsiSourceFile> files, IDeclaredElementEnvoy owner);
    public void ResetCache();
    public string get_Text();
    private IPresentableItem get_Cache();
    private void PresentFromCache(IPresentableItem item, bool valid);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.DeclaredElementExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IModuleReferenceResolveContext GetResolveContext(IClrDeclaredElement element);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ISolution GetSolution(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertIsValid(IDeclaredElement element, string messageText);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertIsNullOrValid(IDeclaredElement element);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertCollectionIsValid(IDeclaredElement[] elements);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IDeclaration GetSingleDeclaration(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static TDeclaration GetSingleDeclaration(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static TDeclaration GetFirstDeclaration(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<TDeclaration> GetDeclarations(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanBeSynthetic(IDeclaredElement declaredElement);
    [ExtensionAttribute]
public static bool CanBeVisibleToSolution(IClrDeclaredElement declaredElement);
    [CompilerGeneratedAttribute]
internal static void <AssertIsNullOrValid>g__Throw|3_0(IDeclaredElement element);
}
[BaseTypeRequiredAttribute("JetBrains.ReSharper.Psi.IDeclaredElementIconExtensionProvider")]
[MeansImplicitUseAttribute]
public class JetBrains.ReSharper.Psi.DeclaredElementIconExtensionProviderAttribute : PsiSharedComponentWithPriorityAttribute {
    public DeclaredElementIconExtensionProviderAttribute(double priority, Instantiation instantiation);
}
[BaseTypeRequiredAttribute("JetBrains.ReSharper.Psi.IDeclaredElementIconProvider")]
[MeansImplicitUseAttribute]
public class JetBrains.ReSharper.Psi.DeclaredElementIconProviderAttribute : PsiSharedComponentWithPriorityAttribute {
    public DeclaredElementIconProviderAttribute(double priority, Instantiation instantiation);
}
[DebuggerDisplayAttribute("Element = {Element}, Substitution = {Substitution}")]
public class JetBrains.ReSharper.Psi.DeclaredElementInstance : object {
    [CompilerGeneratedAttribute]
private IDeclaredElement <Element>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubstitution <Substitution>k__BackingField;
    [NotNullAttribute]
public IDeclaredElement Element { get; }
    [NotNullAttribute]
public ISubstitution Substitution { get; }
    public DeclaredElementInstance(IDeclaredElement element, ISubstitution substitution);
    public DeclaredElementInstance(IDeclaredElement element);
    public DeclaredElementInstance(IClrDeclaredElement element);
    [CompilerGeneratedAttribute]
public IDeclaredElement get_Element();
    [CompilerGeneratedAttribute]
public ISubstitution get_Substitution();
    public void Deconstruct(IDeclaredElement& declaredElement, ISubstitution& substitution);
    [ContractAnnotationAttribute("i1: null, i2: null => true; i1: null => false; i2: null => false")]
public static bool op_Equality(DeclaredElementInstance i1, DeclaredElementInstance i2);
    [ContractAnnotationAttribute("i1: null, i2: null => false; i1: null => true; i2: null => true")]
public static bool op_Inequality(DeclaredElementInstance i1, DeclaredElementInstance i2);
    [CanBeNullAttribute]
public sealed virtual DeclaredElementInstance TryTranslateToCurrentFork(IContentModelForkTranslator translator);
    public virtual bool Equals(object obj);
    public bool Equals(DeclaredElementInstance instance, IEqualityComparer`1<IType> typeComparer);
    private static bool Compare(DeclaredElementInstance lhs, DeclaredElementInstance rhs, IEqualityComparer`1<IType> typeComparer);
    public virtual int GetHashCode();
    public bool IsValid();
}
public class JetBrains.ReSharper.Psi.DeclaredElementInstance`1 : DeclaredElementInstance {
    [NotNullAttribute]
public TDeclaredElement Element { get; }
    public DeclaredElementInstance`1(TDeclaredElement element);
    public DeclaredElementInstance`1(TDeclaredElement element, ISubstitution substitution);
    public TDeclaredElement get_Element();
    public void Deconstruct(TDeclaredElement& declaredElement, ISubstitution& substitution);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.DeclaredElementInstanceExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
[PureAttribute]
public static DeclaredElementInstance`1<TDeclaredElement> Cast(DeclaredElementInstance instance);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
[PureAttribute]
public static DeclaredElementInstance`1<TDeclaredElement> TryCast(DeclaredElementInstance instance);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IDeclaredType GetContainingType(DeclaredElementInstance instance);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static InvocableSignature GetInvokeMethodSignature(DeclaredElementInstance`1<IDelegate> instance);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static InvocableSignature GetSignature(DeclaredElementInstance`1<IMethod> instance);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IType GetReturnType(DeclaredElementInstance`1<IDelegate> instance);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IType GetReturnType(DeclaredElementInstance`1<IMethod> instance);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IType GetParameterType(DeclaredElementInstance`1<IParameter> instance);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IPsiServices GetPsiServices(DeclaredElementInstance instance);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasDeclarationsIn(DeclaredElementInstance instance, IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsMethodOfType(DeclaredElementInstance instance, string methodName, IDeclaredType declaringType);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.DeclaredElementInstanceSlim`1 : ValueType {
    [CompilerGeneratedAttribute]
private TDeclaredElement <Element>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubstitution <Substitution>k__BackingField;
    [NotNullAttribute]
public TDeclaredElement Element { get; }
    [NotNullAttribute]
public ISubstitution Substitution { get; }
    public DeclaredElementInstanceSlim`1(TDeclaredElement element);
    public DeclaredElementInstanceSlim`1(TDeclaredElement element, ISubstitution substitution);
    public void Deconstruct(TDeclaredElement& declaredElement, ISubstitution& substitution);
    [CompilerGeneratedAttribute]
public TDeclaredElement get_Element();
    [CompilerGeneratedAttribute]
public ISubstitution get_Substitution();
    public static bool op_Equality(DeclaredElementInstanceSlim`1<TDeclaredElement> i1, DeclaredElementInstanceSlim`1<TDeclaredElement> i2);
    public static bool op_Inequality(DeclaredElementInstanceSlim`1<TDeclaredElement> i1, DeclaredElementInstanceSlim`1<TDeclaredElement> i2);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DeclaredElementInstanceSlim`1<TDeclaredElement> other);
    public bool Equals(DeclaredElementInstanceSlim`1<TDeclaredElement> other, IEqualityComparer`1<IType> typeComparer);
    public virtual int GetHashCode();
    public bool IsValid();
}
public enum JetBrains.ReSharper.Psi.DeclaredElementPresentationPartKind : Enum {
    public int value__;
    public static DeclaredElementPresentationPartKind Keyword;
    public static DeclaredElementPresentationPartKind Namespace;
    public static DeclaredElementPresentationPartKind Type;
    public static DeclaredElementPresentationPartKind TypeUnresolved;
    public static DeclaredElementPresentationPartKind Path;
    public static DeclaredElementPresentationPartKind Method;
    public static DeclaredElementPresentationPartKind LocalFunction;
    public static DeclaredElementPresentationPartKind Field;
    public static DeclaredElementPresentationPartKind Property;
    public static DeclaredElementPresentationPartKind Event;
    public static DeclaredElementPresentationPartKind Constructor;
    public static DeclaredElementPresentationPartKind String;
    public static DeclaredElementPresentationPartKind Number;
    public static DeclaredElementPresentationPartKind Comment;
    public static DeclaredElementPresentationPartKind TupleComponent;
    public static DeclaredElementPresentationPartKind Attribute;
}
public static class JetBrains.ReSharper.Psi.DeclaredElementPresenter : object {
    public static DeclaredElementPresenterStyle KIND_PRESENTER;
    public static DeclaredElementPresenterStyle INKIND_PRESENTER;
    public static DeclaredElementPresenterStyle FROMKIND_PRESENTER;
    public static DeclaredElementPresenterStyle KIND_NAME_PRESENTER;
    public static DeclaredElementPresenterStyle KIND_QUOTED_NAME_PRESENTER;
    public static DeclaredElementPresenterStyle NAME_PRESENTER;
    public static DeclaredElementPresenterStyle NAME_OR_CONSTRUCTOR_TYPE_NAME_PRESENTER;
    public static DeclaredElementPresenterStyle FULL_NESTED_NAME_PRESENTER;
    public static DeclaredElementPresenterStyle KIND_QUALIFIED_NAME_PRESENTER;
    public static DeclaredElementPresenterStyle QUALIFIED_NAME_PRESENTER;
    private static DeclaredElementPresenter();
    public static bool MakeSmaller(RichText& str, DeclaredElementPresenterMarking& marking);
    [NotNullAttribute]
[PureAttribute]
public static RichText Format(PsiLanguageType languageType, DeclaredElementPresenterStyle style, IDeclaredElement element);
    [NotNullAttribute]
[PureAttribute]
public static RichText Format(PsiLanguageType languageType, DeclaredElementPresenterStyle style, IDeclaredElement element, DeclaredElementPresenterMarking& marking);
    [NotNullAttribute]
[PureAttribute]
public static RichText Format(PsiLanguageType languageType, DeclaredElementPresenterStyle style, IDeclaredElement element, ISubstitution substitution);
    [NotNullAttribute]
[PureAttribute]
public static RichText Format(PsiLanguageType languageType, DeclaredElementPresenterStyle style, DeclaredElementInstance instance);
    [NotNullAttribute]
[PureAttribute]
public static RichText Format(PsiLanguageType languageType, DeclaredElementPresenterStyle style, IDeclaredElement element, ISubstitution substitution, DeclaredElementPresenterMarking& marking);
    [PureAttribute]
public static string Format(PsiLanguageType languageType, ParameterKind parameterKind);
    [PureAttribute]
public static string Format(PsiLanguageType languageType, AccessRights accessRights);
    private static void ReplaceString(RichText& str, int s, int e, string substr, DeclaredElementPresenterMarking& marking);
}
public class JetBrains.ReSharper.Psi.DeclaredElementPresenterMarking : object {
    [CompilerGeneratedAttribute]
private TextRange <EntityKindRange>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRange <AccessRightsRange>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRange <ModifiersRange>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRange <TypeRange>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRange <ScalarTypeRange>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRange <ExplicitInterfaceRange>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRange <NameRange>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRange <ParameterListRange>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRange <TypeParameterListRange>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRange[] <TypeParameterRanges>k__BackingField;
    [CompilerGeneratedAttribute]
private Parameter[] <ParameterRanges>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRange <ContainerRange>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRange <ContainerNameRange>k__BackingField;
    [CompilerGeneratedAttribute]
private TextRange <ConstantValueRange>k__BackingField;
    public TextRange EntityKindRange { get; public set; }
    public TextRange AccessRightsRange { get; public set; }
    public TextRange ModifiersRange { get; public set; }
    public TextRange TypeRange { get; public set; }
    public TextRange ScalarTypeRange { get; public set; }
    public TextRange ExplicitInterfaceRange { get; public set; }
    public TextRange NameRange { get; public set; }
    public TextRange ParameterListRange { get; public set; }
    public TextRange TypeParameterListRange { get; public set; }
    [CanBeNullAttribute]
public TextRange[] TypeParameterRanges { get; public set; }
    [CanBeNullAttribute]
public Parameter[] ParameterRanges { get; public set; }
    public TextRange ContainerRange { get; public set; }
    public TextRange ContainerNameRange { get; public set; }
    public TextRange ConstantValueRange { get; public set; }
    internal static TextRange OffsetSingleRange(TextRange range, int startPos, int offset);
    public void Offset(int startPos, int offset);
    [CompilerGeneratedAttribute]
public TextRange get_EntityKindRange();
    [CompilerGeneratedAttribute]
public void set_EntityKindRange(TextRange value);
    [CompilerGeneratedAttribute]
public TextRange get_AccessRightsRange();
    [CompilerGeneratedAttribute]
public void set_AccessRightsRange(TextRange value);
    [CompilerGeneratedAttribute]
public TextRange get_ModifiersRange();
    [CompilerGeneratedAttribute]
public void set_ModifiersRange(TextRange value);
    [CompilerGeneratedAttribute]
public TextRange get_TypeRange();
    [CompilerGeneratedAttribute]
public void set_TypeRange(TextRange value);
    [CompilerGeneratedAttribute]
public TextRange get_ScalarTypeRange();
    [CompilerGeneratedAttribute]
public void set_ScalarTypeRange(TextRange value);
    [CompilerGeneratedAttribute]
public TextRange get_ExplicitInterfaceRange();
    [CompilerGeneratedAttribute]
public void set_ExplicitInterfaceRange(TextRange value);
    [CompilerGeneratedAttribute]
public TextRange get_NameRange();
    [CompilerGeneratedAttribute]
public void set_NameRange(TextRange value);
    [CompilerGeneratedAttribute]
public TextRange get_ParameterListRange();
    [CompilerGeneratedAttribute]
public void set_ParameterListRange(TextRange value);
    [CompilerGeneratedAttribute]
public TextRange get_TypeParameterListRange();
    [CompilerGeneratedAttribute]
public void set_TypeParameterListRange(TextRange value);
    [CompilerGeneratedAttribute]
public TextRange[] get_TypeParameterRanges();
    [CompilerGeneratedAttribute]
public void set_TypeParameterRanges(TextRange[] value);
    [CompilerGeneratedAttribute]
public Parameter[] get_ParameterRanges();
    [CompilerGeneratedAttribute]
public void set_ParameterRanges(Parameter[] value);
    [CompilerGeneratedAttribute]
public TextRange get_ContainerRange();
    [CompilerGeneratedAttribute]
public void set_ContainerRange(TextRange value);
    [CompilerGeneratedAttribute]
public TextRange get_ContainerNameRange();
    [CompilerGeneratedAttribute]
public void set_ContainerNameRange(TextRange value);
    [CompilerGeneratedAttribute]
public TextRange get_ConstantValueRange();
    [CompilerGeneratedAttribute]
public void set_ConstantValueRange(TextRange value);
}
public class JetBrains.ReSharper.Psi.DeclaredElementPresenterStyle : object {
    [CompilerGeneratedAttribute]
private GeneralPresentationFlags <PresentationFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private EntityKindForm <ShowEntityKind>k__BackingField;
    [CompilerGeneratedAttribute]
private NameStyle <ShowName>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeParameterStyle <ShowTypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeStyle <ShowType>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberContainerStyle <ShowMemberContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeContainerStyle <ShowTypeContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private NamespaceContainerStyle <ShowNamespaceContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterContainerStyle <ShowParameterContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private AliasPresentationStyle <AliasPresentationStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LengthLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<string, DeclaredElementPresenterMarking, int> <LengthCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private TypePresentationStyle <TypePresentationStyle>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public GeneralPresentationFlags PresentationFlags { get; public set; }
    public bool ShowAccessRights { get; public set; }
    public bool ShowModifiers { get; public set; }
    public bool ShowParametersForDelegates { get; public set; }
    public bool ShowAccessorsInCompiledForm { get; public set; }
    public bool ShowMSDNCompatibleConstructorName { get; public set; }
    public bool ShowContainingTypeInsteadOfConstructorName { get; public set; }
    public EntityKindForm ShowEntityKind { get; public set; }
    public NameStyle ShowName { get; public set; }
    public TypeParameterStyle ShowTypeParameters { get; public set; }
    public bool ShowExplicitInterfaceQualification { get; public set; }
    public bool ShowNameInQuotes { get; public set; }
    public TypeStyle ShowType { get; public set; }
    public bool ShowParameterNames { get; public set; }
    public bool ShowParameterTypes { get; public set; }
    public bool ShowParameterlessHint { get; public set; }
    public bool ShowTypesQualified { get; public set; }
    public MemberContainerStyle ShowMemberContainer { get; public set; }
    public TypeContainerStyle ShowTypeContainer { get; public set; }
    public bool MemberContainerQualified { get; public set; }
    public NamespaceContainerStyle ShowNamespaceContainer { get; public set; }
    public ParameterContainerStyle ShowParameterContainer { get; public set; }
    public AliasPresentationStyle AliasPresentationStyle { get; public set; }
    public int LengthLimit { get; public set; }
    public Func`3<string, DeclaredElementPresenterMarking, int> LengthCheck { get; public set; }
    public bool ShowConstantValue { get; public set; }
    public bool MakeUseOfNonBreakableSpace { get; public set; }
    public DeclaredElementPresenterTextStyles TextStyles { get; public set; }
    public TypePresentationStyle TypePresentationStyle { get; public set; }
    public DeclaredElementPresenterStyle(bool showAccessRights, bool showModifiers, bool showParametersForDelegates, EntityKindForm showEntityKind, NameStyle showName, bool showExplicitInterfaceQualification, bool showNameInQuotes, TypeStyle showType, bool showParameterTypes, bool showParameterNames, bool showTypesQualified, MemberContainerStyle showMemberContainer, TypeContainerStyle showTypeContainer, NamespaceContainerStyle showNamespaceContainer, ParameterContainerStyle showParameterContainer, bool showConstantValue, DeclaredElementPresenterTextStyles textStyles);
    [CompilerGeneratedAttribute]
private DeclaredElementPresenterStyle(DeclaredElementPresenterStyle original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public GeneralPresentationFlags get_PresentationFlags();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PresentationFlags(GeneralPresentationFlags value);
    public bool get_ShowAccessRights();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowAccessRights(bool value);
    public bool get_ShowModifiers();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowModifiers(bool value);
    public bool get_ShowParametersForDelegates();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowParametersForDelegates(bool value);
    public bool get_ShowAccessorsInCompiledForm();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowAccessorsInCompiledForm(bool value);
    public bool get_ShowMSDNCompatibleConstructorName();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowMSDNCompatibleConstructorName(bool value);
    public bool get_ShowContainingTypeInsteadOfConstructorName();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowContainingTypeInsteadOfConstructorName(bool value);
    [CompilerGeneratedAttribute]
public EntityKindForm get_ShowEntityKind();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowEntityKind(EntityKindForm value);
    [CompilerGeneratedAttribute]
public NameStyle get_ShowName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowName(NameStyle value);
    [CompilerGeneratedAttribute]
public TypeParameterStyle get_ShowTypeParameters();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowTypeParameters(TypeParameterStyle value);
    public bool get_ShowExplicitInterfaceQualification();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowExplicitInterfaceQualification(bool value);
    public bool get_ShowNameInQuotes();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowNameInQuotes(bool value);
    [CompilerGeneratedAttribute]
public TypeStyle get_ShowType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowType(TypeStyle value);
    public bool get_ShowParameterNames();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowParameterNames(bool value);
    public bool get_ShowParameterTypes();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowParameterTypes(bool value);
    public bool get_ShowParameterlessHint();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowParameterlessHint(bool value);
    public bool get_ShowTypesQualified();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowTypesQualified(bool value);
    [CompilerGeneratedAttribute]
public MemberContainerStyle get_ShowMemberContainer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowMemberContainer(MemberContainerStyle value);
    [CompilerGeneratedAttribute]
public TypeContainerStyle get_ShowTypeContainer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowTypeContainer(TypeContainerStyle value);
    public bool get_MemberContainerQualified();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MemberContainerQualified(bool value);
    [CompilerGeneratedAttribute]
public NamespaceContainerStyle get_ShowNamespaceContainer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowNamespaceContainer(NamespaceContainerStyle value);
    [CompilerGeneratedAttribute]
public ParameterContainerStyle get_ShowParameterContainer();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowParameterContainer(ParameterContainerStyle value);
    [CompilerGeneratedAttribute]
public AliasPresentationStyle get_AliasPresentationStyle();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AliasPresentationStyle(AliasPresentationStyle value);
    [CompilerGeneratedAttribute]
public int get_LengthLimit();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LengthLimit(int value);
    [CompilerGeneratedAttribute]
public Func`3<string, DeclaredElementPresenterMarking, int> get_LengthCheck();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LengthCheck(Func`3<string, DeclaredElementPresenterMarking, int> value);
    public bool get_ShowConstantValue();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShowConstantValue(bool value);
    public bool get_MakeUseOfNonBreakableSpace();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MakeUseOfNonBreakableSpace(bool value);
    public DeclaredElementPresenterTextStyles get_TextStyles();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TextStyles(DeclaredElementPresenterTextStyles value);
    [CompilerGeneratedAttribute]
public TypePresentationStyle get_TypePresentationStyle();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TypePresentationStyle(TypePresentationStyle value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(DeclaredElementPresenterStyle left, DeclaredElementPresenterStyle right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(DeclaredElementPresenterStyle left, DeclaredElementPresenterStyle right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(DeclaredElementPresenterStyle other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public DeclaredElementPresenterStyle <Clone>$();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.DeclaredElementPresenterStyleEx : object {
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithTextStyles(DeclaredElementPresenterStyle presenterStyle, DeclaredElementPresenterTextStyles textStyles);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithShowAccessRights(DeclaredElementPresenterStyle style, bool showAccessRights);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithShowParametersForDelegates(DeclaredElementPresenterStyle style, bool showParametersForDelegates);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithShowEntityKind(DeclaredElementPresenterStyle style, EntityKindForm showEntityKind);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithShowName(DeclaredElementPresenterStyle style, NameStyle showName);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithShowNameInQuotes(DeclaredElementPresenterStyle style, bool showNameInQuotes);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithShowConstantValue(DeclaredElementPresenterStyle style, bool showConstantValue);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithLengthLimit(DeclaredElementPresenterStyle style, int lengthLimit);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithLengthCheck(DeclaredElementPresenterStyle style, Func`3<string, DeclaredElementPresenterMarking, int> lengthCheck);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithShowModifiers(DeclaredElementPresenterStyle style, bool showModifiers);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithShowType(DeclaredElementPresenterStyle style, TypeStyle showType);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithShowTypesQualified(DeclaredElementPresenterStyle style, bool showTypesQualified);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithShowParameterTypes(DeclaredElementPresenterStyle style, bool showParameterTypes);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithShowParameterNames(DeclaredElementPresenterStyle style, bool showParameterNames);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithShowMemberContainer(DeclaredElementPresenterStyle style, MemberContainerStyle showMemberContainer);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithMemberContainerQualified(DeclaredElementPresenterStyle style, bool memberContainerQualified);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithShowTypeContainer(DeclaredElementPresenterStyle style, TypeContainerStyle showTypeContainer);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithShowNamespaceContainer(DeclaredElementPresenterStyle style, NamespaceContainerStyle showNamespaceContainer);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithShowParameterContainer(DeclaredElementPresenterStyle style, ParameterContainerStyle showParameterContainer);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithShowExplicitInterfaceQualification(DeclaredElementPresenterStyle style, bool showExplicitInterfaceQualification);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithShowAccessorsInCompiledForm(DeclaredElementPresenterStyle style, bool showAccessorsInCompiledForm);
    [ExtensionAttribute]
public static DeclaredElementPresenterStyle WithShowMSDNCompatibleConstructorName(DeclaredElementPresenterStyle style, bool showMSDNCompatibleConstructorName);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.DeclaredElementPresenterTextStyles : object {
    private Dictionary`2<DeclaredElementPresentationPartKind, TextStyle> myTextStyles;
    private bool myIsFrozen;
    internal static string GenericAttributeIdPrefix;
    private static Dictionary`2<string, DeclaredElementPresentationPartKind> ourGenericNamesToKind;
    public static DeclaredElementPresenterTextStyles Empty;
    public static DeclaredElementPresenterTextStyles Generic;
    public static DeclaredElementPresenterTextStyles ParameterInfoLightTheme;
    public static DeclaredElementPresenterTextStyles ParameterInfoDarkTheme;
    public static DeclaredElementPresenterTextStyles ParameterInfo;
    public TextStyle Item { get; public set; }
    private static DeclaredElementPresenterTextStyles();
    public TextStyle GetStyle(DeclaredElementPresentationPartKind kind);
    public TextStyle get_Item(DeclaredElementPresentationPartKind kind);
    public void set_Item(DeclaredElementPresentationPartKind kind, TextStyle value);
    public DeclaredElementPresenterTextStyles SetStyle(DeclaredElementPresentationPartKind kind, TextStyle textStyle);
    [PureAttribute]
public sealed virtual DeclaredElementPresenterTextStyles Clone();
    private sealed virtual override object System.ICloneable.Clone();
    [PureAttribute]
internal static Nullable`1<DeclaredElementPresentationPartKind> GetPartKindByAttributeId(string genericAttributeId);
    public DeclaredElementPresenterTextStyles Freeze();
    [PureAttribute]
public TextStyle ApplyOverGenericStyle(TextStyle textStyle);
    [PureAttribute]
public TextStyle GetDeclaredElementNameStyle(IDeclaredElement declaredElement);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.DeclaredElementPresenterTextStylesEx : object {
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => true")]
[PureAttribute]
public static bool IsNullOrEmpty(DeclaredElementPresenterTextStyles textStyles);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsGenericAttributeIdStyle(TextStyle textStyle);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsGenericAttributeIdStyle(TextStyle textStyle, DeclaredElementPresentationPartKind& partKind);
    [ExtensionAttribute]
[PureAttribute]
public static RichText GetFullNameRichText(DeclaredElementPresenterTextStyles textStyles, IClrTypeName clrTypeName);
    [ExtensionAttribute]
public static RichText GetShortNameRichText(DeclaredElementPresenterTextStyles textStyles, IClrTypeName clrTypeName);
    [ExtensionAttribute]
public static RichText GetNamespaceQualifiedName(DeclaredElementPresenterTextStyles textStyles, string namespaceQualifiedName);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.KnownLanguage", "16")]
[LanguageAttribute("JetBrains.ReSharper.Psi.UnknownLanguage", "16")]
public class JetBrains.ReSharper.Psi.DeclaredElementTextStylesPartService : object {
    [PureAttribute]
public virtual Nullable`1<DeclaredElementPresentationPartKind> TryGetPartKind(IDeclaredElement declaredElement);
}
public abstract class JetBrains.ReSharper.Psi.DeclaredElementType : EnumPattern {
    public string PresentableName { get; }
    [CanBeNullAttribute]
protected internal IDeclaredElementPresenter DefaultPresenter { get; }
    protected DeclaredElementType(string name);
    public abstract virtual string get_PresentableName();
    [CanBeNullAttribute]
public abstract virtual IconId GetImage();
    protected internal abstract virtual IDeclaredElementPresenter get_DefaultPresenter();
    public abstract virtual bool IsPresentable(PsiLanguageType language);
}
public abstract class JetBrains.ReSharper.Psi.DeclaredElementTypeBase : DeclaredElementType {
    [CanBeNullAttribute]
protected IconId ImageName;
    [CompilerGeneratedAttribute]
private string <PresentableName>k__BackingField;
    public string PresentableName { get; }
    protected DeclaredElementTypeBase(string name, IconId imageName);
    [CompilerGeneratedAttribute]
public virtual string get_PresentableName();
    public virtual IconId GetImage();
    public virtual bool IsPresentable(PsiLanguageType language);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.DeclaredTypeExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
[DebuggerStepThroughAttribute]
public static ISubstitution GetSubstitution(IDeclaredType type);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<IDeclaredType> GetSuperType(IDeclaredType derived, ITypeElement superTypeElement);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IDeclaredType> GetSuperTypes(IDeclaredType type);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(IDeclaredType declaredType, ITypeElement& typeElement);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(IDeclaredType declaredType, ITypeElement& typeElement, ISubstitution& substitution);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(IDeclaredType declaredType, ITypeElement& typeElement, ISubstitution& substitution, NullableAnnotation& nullableAnnotation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.DecoratedType`1 : ValueType {
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private TDecoration <Decoration>k__BackingField;
    public IType Type { get; }
    public TDecoration Decoration { get; }
    public IPsiModule Module { get; }
    private DecoratedType`1(IType type, TDecoration decoration);
    internal static DecoratedType`1<TDecoration> CreateUnsafe(IType type, TDecoration decoration);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Nullable`1<DecoratedType`1<TDecoration>> TryCreate(IType type);
    [CompilerGeneratedAttribute]
public IType get_Type();
    [CompilerGeneratedAttribute]
public TDecoration get_Decoration();
    public bool IsValid();
    public IPsiModule get_Module();
    public IPsiServices GetPsiServices();
    public ISymbolTable GetSymbolTable(IPsiModule module);
    [PureAttribute]
public RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle style);
    [PureAttribute]
public string GetPresentableName(PsiLanguageType languageType);
    [NullableContextAttribute("0")]
public Pointer<TDecoration> CreatePointer();
    public sealed virtual bool Equals(DecoratedType`1<TDecoration> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public abstract class JetBrains.ReSharper.Psi.DecoratedTypeBase`1 : object {
    protected TUnderlyingType UnderlyingType;
    [CompilerGeneratedAttribute]
private TypeDecorationSet <TypeDecorations>k__BackingField;
    public TypeDecorationSet TypeDecorations { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public IPsiModule Module { get; }
    public bool IsOpenType { get; }
    public TypeClassification Classify { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    protected DecoratedTypeBase`1(TUnderlyingType underlyingType, TypeDecorationSet typeDecorations);
    [CompilerGeneratedAttribute]
public sealed virtual TypeDecorationSet get_TypeDecorations();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    public sealed virtual IType WithTypeDecorations(TypeDecorationSet typeDecorations);
    public sealed virtual IType WithNullableAnnotation(NullableAnnotation nullableAnnotation);
    public sealed virtual ISymbolTable GetSymbolTable(IPsiModule module);
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual bool get_IsOpenType();
    public sealed virtual TypeClassification get_Classify();
    public virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual ITypePointer CreatePointer();
    public sealed virtual IType ToIType();
    [NullableContextAttribute("2")]
public virtual IDeclaredType GetScalarType();
    public sealed virtual bool IsWellFormed(ITypeConstraintsVerifier typeConstraintsVerifier);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual bool IsImplicitlyConvertibleTo(IType type, ITypeConversionRule conversionRule);
    public sealed virtual bool IsExplicitlyConvertibleTo(IType type, ITypeConversionRule conversionRule);
    public abstract virtual void Accept(TypeVisitor typeVisitor);
    public abstract virtual TResult Accept(TypeVisitor`2<TContext, TResult> typeVisitor, TContext context);
    public virtual IType MergeNullability(IType otherType, TypeParameterVariance variance);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object obj);
    public sealed virtual bool Equals(IType type, IEqualityComparer`1<IType> childrenComparer);
    public sealed virtual int GetHashCode();
    public virtual string ToString();
    private string get_DebuggerDisplay();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private RichText <GetPresentableName>g__GetSpecialPresentation|20_0(<>c__DisplayClass20_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.DefaultRegionsInfoProvider : object {
    public virtual IRegionsInfo GetCachedInfoForDocument(IDocument document);
    public virtual IRegionsInfo CreateInfoForDocument(IDocument document);
    public virtual IRegionsInfo GetOrCreateInfoForDocument(IDocument document);
}
public class JetBrains.ReSharper.Psi.DefaultValue : object {
    [NotNullAttribute]
public static DefaultValue BAD_VALUE;
    [NotNullAttribute]
private ConstantValue myConstantValue;
    [CanBeNullAttribute]
private IType myDefaultType;
    [CanBeNullAttribute]
private DeclaredElementInstance`1<IField> myLiteral;
    private int myQualifierDepth;
    [CompilerGeneratedAttribute]
private IType <ParameterType>k__BackingField;
    public IType ParameterType { get; }
    public bool IsBadValue { get; }
    public bool IsConstant { get; }
    public bool IsDefaultValue { get; }
    [NotNullAttribute]
public ConstantValue ConstantValue { get; }
    [CanBeNullAttribute]
public DeclaredElementInstance`1<IField> Literal { get; }
    [CanBeNullAttribute]
public IType DefaultTypeValue { get; }
    public int QualifierDepth { get; }
    public DefaultValue(IType parameterType, DeclaredElementInstance`1<IField> literal, int qualifierDepth);
    public DefaultValue(IType parameterType, ConstantValue constantValue, int qualifierDepth);
    public DefaultValue(IType parameterType, ConstantValue constantValue);
    public DefaultValue(IType parameterType, IType defaultType, ConstantValue constantValue);
    public DefaultValue(IType parameterType, IType defaultType);
    private static DefaultValue();
    [CompilerGeneratedAttribute]
public IType get_ParameterType();
    public bool get_IsBadValue();
    public bool get_IsConstant();
    public bool get_IsDefaultValue();
    public ConstantValue get_ConstantValue();
    public DeclaredElementInstance`1<IField> get_Literal();
    public IType get_DefaultTypeValue();
    public int get_QualifierDepth();
    public IType GetType(IPsiModule module);
    [NotNullAttribute]
public virtual DefaultValue Substitute(ISubstitution substitution);
    public virtual bool Equals(object obj);
    protected bool Equals(DefaultValue other);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.DelegatingTypeVisitor : TypeVisitor {
    [CompilerGeneratedAttribute]
private TypeProcessor <ProcessType>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclaredTypeProcessor <ProcessDeclaredType>k__BackingField;
    [CompilerGeneratedAttribute]
private ArrayTypeProcessor <ProcessArrayType>k__BackingField;
    [CompilerGeneratedAttribute]
private PointerTypeProcessor <ProcessPointerType>k__BackingField;
    [CompilerGeneratedAttribute]
private FunctionPointerTypeProcessor <ProcessFunctionPointerType>k__BackingField;
    [CompilerGeneratedAttribute]
private MultitypeProcessor <ProcessMultitype>k__BackingField;
    [CompilerGeneratedAttribute]
private AnonymousTypeProcessor <ProcessAnonymousType>k__BackingField;
    [CanBeNullAttribute]
public TypeProcessor ProcessType { get; public set; }
    [CanBeNullAttribute]
public DeclaredTypeProcessor ProcessDeclaredType { get; public set; }
    [CanBeNullAttribute]
public ArrayTypeProcessor ProcessArrayType { get; public set; }
    [CanBeNullAttribute]
public PointerTypeProcessor ProcessPointerType { get; public set; }
    [CanBeNullAttribute]
public FunctionPointerTypeProcessor ProcessFunctionPointerType { get; public set; }
    [CanBeNullAttribute]
public MultitypeProcessor ProcessMultitype { get; public set; }
    [CanBeNullAttribute]
public AnonymousTypeProcessor ProcessAnonymousType { get; public set; }
    [CompilerGeneratedAttribute]
public TypeProcessor get_ProcessType();
    [CompilerGeneratedAttribute]
public void set_ProcessType(TypeProcessor value);
    [CompilerGeneratedAttribute]
public DeclaredTypeProcessor get_ProcessDeclaredType();
    [CompilerGeneratedAttribute]
public void set_ProcessDeclaredType(DeclaredTypeProcessor value);
    [CompilerGeneratedAttribute]
public ArrayTypeProcessor get_ProcessArrayType();
    [CompilerGeneratedAttribute]
public void set_ProcessArrayType(ArrayTypeProcessor value);
    [CompilerGeneratedAttribute]
public PointerTypeProcessor get_ProcessPointerType();
    [CompilerGeneratedAttribute]
public void set_ProcessPointerType(PointerTypeProcessor value);
    [CompilerGeneratedAttribute]
public FunctionPointerTypeProcessor get_ProcessFunctionPointerType();
    [CompilerGeneratedAttribute]
public void set_ProcessFunctionPointerType(FunctionPointerTypeProcessor value);
    [CompilerGeneratedAttribute]
public MultitypeProcessor get_ProcessMultitype();
    [CompilerGeneratedAttribute]
public void set_ProcessMultitype(MultitypeProcessor value);
    [CompilerGeneratedAttribute]
public AnonymousTypeProcessor get_ProcessAnonymousType();
    [CompilerGeneratedAttribute]
public void set_ProcessAnonymousType(AnonymousTypeProcessor value);
    public virtual void VisitType(IType type);
    public virtual void VisitDeclaredType(IDeclaredType declaredType);
    public virtual void VisitArrayType(IArrayType arrayType);
    public virtual void VisitPointerType(IPointerType pointerType);
    public virtual void VisitFunctionPointerType(IFunctionPointerType functionPointerType);
    public virtual void VisitMultitype(IMultitype multitype);
    public virtual void VisitAnonymousType(IAnonymousType anonymousType);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Dependencies.Dependency : ValueType {
    [NotNullAttribute]
public static IUnsafeMarshaller`1<Dependency> Marshaller;
    [NotNullAttribute]
public static IEqualityComparer`1<Dependency> Comparer;
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; }
    public Dependency(int value);
    private static Dependency();
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public int get_Value();
    public bool Equals(Dependency dependency);
    public virtual bool Equals(object obj);
    public static bool op_Equality(Dependency left, Dependency right);
    public static bool op_Inequality(Dependency left, Dependency right);
    public virtual string ToString();
    public void WriteTo(UnsafeWriter writer);
    public static Dependency ReadFrom(UnsafeReader reader);
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Dependencies.DependencyFactory : object {
    private static int HashMultiplyConst;
    private static ILogger ourLogger;
    private static DependencyFactory();
    private static void Trace(int hash, string presentation);
    [PureAttribute]
public static Dependency Create(int hash, T x, Func`2<T, string> presentationFunc);
    [PureAttribute]
public static Dependency Create(int hash, T1 x, T2 y, Func`3<T1, T2, string> presentationFunc);
    [PureAttribute]
public static Dependency CreateDependency(string qualifierTypeClrName, string name);
    [PureAttribute]
public static Dependency CreateDependency(int typeNameHashCode, string name, Func`1<string> clrTypeNameProvider);
    [PureAttribute]
public static Dependency CreateDependency(SpecialDependencyKind kind);
    [PureAttribute]
public static Dependency CreateDependency(string qualifierTypeName, SpecialDependencyKind kind);
    [PureAttribute]
public static Dependency CreateFileDependency(IProjectFile projectFile);
    [PureAttribute]
public static Dependency CreateFileDependency(IProjectFolder folder, string fileName);
    [PureAttribute]
public static Dependency CreateNamespaceInFileDependency(IProjectFile projectFile);
    [PureAttribute]
private static Dependency CreateModuleDependency(IPsiModule module, string name);
    [PureAttribute]
public Dependency CreateConditionalCompilationConstantDependency(IPsiModule module, string name);
    [PureAttribute]
public Dependency CreateAllowUnsafeCodeDependency(IPsiModule module);
    [PureAttribute]
public Dependency CreateLanguageLevelDependency(IPsiModule module);
    [PureAttribute]
public Dependency CreateNullableContextDependency(IPsiModule module);
    [PureAttribute]
public Dependency CreatePreviewFeaturesDependency(IPsiModule module);
    [PureAttribute]
public Dependency CreateProjectReferencesDependency(IPsiModule module);
    [PureAttribute]
public Dependency CreateGlobalUsingsDependency(IPsiModule module);
    [PureAttribute]
public Dependency CreateSettingsChangedDependency(IPsiModule module);
    [PureAttribute]
public Dependency CreateShouldHaveMainMethodDependency(IProject project);
    [PureAttribute]
public static Dependency CreateUsingsDependency(UsingsTypeInfo type, string name);
    [PureAttribute]
public Dependency CreateInterceptorsPreviewNamespacesDependency(IPsiModule module);
    [PureAttribute]
public Dependency CreateInterceptorsDependency(IPsiModule module, string filePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Dependencies.DependencySet : object {
    private HashSet`1<Dependency> myDependencies;
    private bool myResultIsObtained;
    public void AddDependencies(IEnumerable`1<Dependency> dependencies);
    public void AddDependency(Dependency dependency);
    public ICollection`1<Dependency> GetResultingDependencies();
    internal void TestDump(TextWriter builder);
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Dependencies.DependencyStore : object {
    [CompilerGeneratedAttribute]
private IShellLocks <shellLocks>P;
    private object myDependencySetHolderLock;
    private ForkedContentModelData`1<DependencySetHolderForForkScope> myDependencySetHolder;
    [CompilerGeneratedAttribute]
private DependencyFactory <DependencyFactory>k__BackingField;
    public bool HasDependencySet { get; }
    public DependencyFactory DependencyFactory { get; }
    public DependencyStore(DependencyFactory dependencyFactory, IShellLocks shellLocks);
    [MustUseReturnValueAttribute]
[NotNullAttribute]
private DependencySetHolderForForkScope GetHolderForCurrentContentModelFork();
    public bool get_HasDependencySet();
    [CompilerGeneratedAttribute]
public DependencyFactory get_DependencyFactory();
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public IDependencySetHandle CreateDependencySet(IPsiSourceFile skipDependenciesToFile);
    [MustUseReturnValueAttribute]
public DependencySetOverrideCookie TemporaryOverride();
    private void SetDependencySet(IDependencySetHandle dependencySet);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public DependencySet ReleaseDependencySet(IDependencySetHandle handle);
    private bool ShouldAddDependency(DependencySetHolderForForkScope dependencySetHolder, IPsiSourceFile localToFile);
    private void AddDependencyImpl(DependencySetHolderForForkScope dependencySetHolder, Dependency dependency, IPsiSourceFile localToFile);
    public sealed virtual void AddDependency(Dependency dependency, IPsiSourceFile localToFile);
    public sealed virtual void AddUsingsDependency(UsingsTypeInfo type, string accessName, IPsiSourceFile localToFile);
    public void AddDependenciesOnSymbolTableAccess(ISymbolTable symbolTable, string name);
    public sealed virtual void AddTypeElementDependency(IClrTypeName typeName, string name, IPsiSourceFile localToFile);
    public sealed virtual void AddTypeElementDependency(int typeNameHashCode, string name, IPsiSourceFile localToFile, Func`1<string> clrTypeNameProvider);
    public sealed virtual void AddTypeElementDependency(IClrTypeName typeName, SpecialDependencyKind dependencyKind, IPsiSourceFile localToFile);
    public sealed virtual void AddNamespaceDependency(string qualifierNamespaceName, IPsiModule module, string name);
    public sealed virtual void AddNamespaceDependency(string qualifierNamespaceName, MetaModuleId moduleId, string name);
}
public class JetBrains.ReSharper.Psi.Dependencies.FolderQualifierInfo : object {
    private IProjectFolder myFolder;
    public FolderQualifierInfo(IProjectFolder folder);
    public void AddDependencies(IDependencyStore dependencyStore, string name);
    public bool Equals(FolderQualifierInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public interface JetBrains.ReSharper.Psi.Dependencies.IDependencyStore {
    public abstract virtual void AddDependency(Dependency dependency, IPsiSourceFile localToFile);
    public abstract virtual void AddTypeElementDependency(IClrTypeName typeName, string name, IPsiSourceFile localToFile);
    public abstract virtual void AddTypeElementDependency(IClrTypeName typeName, SpecialDependencyKind dependencyKind, IPsiSourceFile localToFile);
    public abstract virtual void AddNamespaceDependency(string qualifierNamespaceName, IPsiModule module, string name);
    public abstract virtual void AddNamespaceDependency(string qualifierNamespaceName, MetaModuleId moduleId, string name);
    public abstract virtual void AddUsingsDependency(UsingsTypeInfo info, string accessName, IPsiSourceFile localToFile);
    public abstract virtual void AddTypeElementDependency(int typeNameHashCode, string name, IPsiSourceFile localToFile, Func`1<string> clrTypeNameProvider);
}
public interface JetBrains.ReSharper.Psi.Dependencies.IFileImageContributor {
    public abstract virtual IEnumerable`1<KeyValuePair`2<Dependency, Hash>> SolutionDependencies(ISolution solution);
    public abstract virtual IEnumerable`1<KeyValuePair`2<Dependency, Hash>> ModuleDependencies(IPsiModule module);
    public abstract virtual IEnumerable`1<KeyValuePair`2<Dependency, Hash>> FileDependencies(IPsiSourceFile psiSourceFile);
}
public interface JetBrains.ReSharper.Psi.Dependencies.IFileWithDependencies {
    [NotNullAttribute]
public IEnumerable`1<ModuleProperty> ModulePropertyDependencies { get; }
    [NotNullAttribute]
public abstract virtual IEnumerable`1<Pair`2<object, IUsingsInfo>> GetTopLevelHashableEntities();
    [NotNullAttribute]
public abstract virtual ICollection`1<string> GetEmptyNamespaceDeclarations();
    public abstract virtual IEnumerable`1<ModuleProperty> get_ModulePropertyDependencies();
    [NotNullAttribute]
public abstract virtual IHashableEntityInfo[] CalcAllEntityHashes(object hashableEntity, string parentQualifiedName, String& qualifiedName);
    [NotNullAttribute]
public abstract virtual IEnumerable EntityChildren(object hashableEntity);
    public abstract virtual bool IsEntityInternal(object hashableEntity);
}
public interface JetBrains.ReSharper.Psi.Dependencies.IHashableDeclaration {
    public abstract virtual Hash CalcHash();
}
public interface JetBrains.ReSharper.Psi.Dependencies.IHashableEntityInfo {
    public Hash Hash { get; }
    public abstract virtual Hash get_Hash();
    public abstract virtual void AddDependenciesAndHashes(DependencyFactory dependencyFactory, OneToListMap`2<Dependency, Hash> dependencyToHashes);
}
public class JetBrains.ReSharper.Psi.Dependencies.InNamespaceHashableEntityInfo : object {
    private Hash myHash;
    public string QualifierNamespace;
    public string Name;
    public Hash Hash { get; }
    public InNamespaceHashableEntityInfo(Hash hash, string qualifierNamespace, string name);
    public sealed virtual Hash get_Hash();
    public sealed virtual void AddDependenciesAndHashes(DependencyFactory dependencyFactory, OneToListMap`2<Dependency, Hash> dependencyToHashes);
}
public interface JetBrains.ReSharper.Psi.Dependencies.ISpecialDependency {
    [NotNullAttribute]
public ISpecialDependencyContributor Contributor { get; }
    public abstract virtual ISpecialDependencyContributor get_Contributor();
    public abstract virtual void ProduceDependencies(ISpecialHash oldHash, ISpecialHash newHash, Dictionary`2<Dependency, HashPair> resultSet);
}
public interface JetBrains.ReSharper.Psi.Dependencies.ISpecialDependencyContributor {
    public abstract virtual ISpecialDependency ReadDepedency(UnsafeReader reader);
    public abstract virtual ISpecialHash ReadHash(UnsafeReader reader);
    public abstract virtual void WriteDependency(UnsafeWriter writer, ISpecialDependency dependency);
    public abstract virtual void WriteHash(UnsafeWriter writer, ISpecialHash hash);
}
public interface JetBrains.ReSharper.Psi.Dependencies.ISpecialHash {
    [NotNullAttribute]
public ISpecialDependencyContributor Contributor { get; }
    public abstract virtual ISpecialDependencyContributor get_Contributor();
    public abstract virtual ISpecialHash AddSub(ISpecialHash toSub, ISpecialHash toAdd);
    public abstract virtual bool IsEmpty();
}
public interface JetBrains.ReSharper.Psi.Dependencies.ISymbolTableDependencySet {
    public abstract virtual void AddDependenciesTo(IDependencyStore store, string accessName);
}
public interface JetBrains.ReSharper.Psi.Dependencies.IUsingsInfo {
    public List`1<string> ShortNames { get; public set; }
    public string FileName { get; }
    [NotNullAttribute]
public abstract virtual ISymbolTable GetSymbolTable(IPsiModule module);
    public abstract virtual List`1<string> get_ShortNames();
    public abstract virtual void set_ShortNames(List`1<string> value);
    public abstract virtual Hash GetHash();
    public abstract virtual string get_FileName();
    public abstract virtual void TestDump(TextWriter builder);
}
public class JetBrains.ReSharper.Psi.Dependencies.MainMethodHashableEntityInfo : object {
    private Hash myHash;
    private IProject myProject;
    public Hash Hash { get; }
    public MainMethodHashableEntityInfo(Hash hash, IProject project);
    public sealed virtual Hash get_Hash();
    public sealed virtual void AddDependenciesAndHashes(DependencyFactory dependencyFactory, OneToListMap`2<Dependency, Hash> dependencyToHashes);
}
public class JetBrains.ReSharper.Psi.Dependencies.MemberHashableEntityInfo : object {
    private Hash myHash;
    public string QualifierTypeCLRName;
    public string Name;
    public Hash Hash { get; }
    public MemberHashableEntityInfo(Hash hash, string qualifierTypeCLRName, string name);
    public sealed virtual Hash get_Hash();
    public sealed virtual void AddDependenciesAndHashes(DependencyFactory dependencyFactory, OneToListMap`2<Dependency, Hash> dependencyToHashes);
}
public class JetBrains.ReSharper.Psi.Dependencies.MetaModuleId : ValueType {
    public static MetaModuleId SOLUTION_ID;
    public static MetaModuleId Empty;
    private string myId;
    public string StringId { get; }
    public MetaModuleId(string id);
    private static MetaModuleId();
    public string get_StringId();
    [PureAttribute]
public void WriteTo(BinaryWriter writer);
    public static MetaModuleId ReadFrom(BinaryReader reader);
    public virtual bool Equals(object obj);
    public bool Equals(MetaModuleId other);
    public virtual int GetHashCode();
    public static bool op_Equality(MetaModuleId left, MetaModuleId right);
    public static bool op_Inequality(MetaModuleId left, MetaModuleId right);
    public virtual string ToString();
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Dependencies.ModuleIdFactory : object {
    private ISolution mySolution;
    private IPsiModules myPsiModules;
    private ProjectModelElementPointerManager myPointerManager;
    private IPsiConfiguration myPsiConfiguration;
    private object myLock;
    private bool myLoaded;
    private IEqualityComparer`1<MetaModuleId> myIdComparer;
    private Dictionary`2<IModule, MetaModuleId> myModuleToId;
    private Dictionary`2<MetaModuleId, IProjectModelElementPointer> myIdToModulePointer;
    private DataIntern`1<MetaModuleId> myInternedIds;
    private FileSystemPath CacheFilePath { get; }
    public ModuleIdFactory(ISolution solution, IViewableProjectsCollection projectsCollection, IPsiModules psiModules, ProjectModelElementPointerManager pointerManager, IPsiConfiguration psiConfiguration, Lifetime lifetime);
    public static ModuleIdFactory GetInstance(ISolution solution);
    private void Save();
    private void Load();
    private string GetPersistentId(IProjectModelElementPointer pointer);
    private string PersistentId(IAssembly assembly);
    private IModule FindModule(string persistentId);
    private FileSystemPath get_CacheFilePath();
    public MetaModuleId GetMetaModuleId(IPsiModule psiModule);
    public MetaModuleId GetModuleId(IModule module);
    public static string GetModuleId(IPsiModule psiModule);
    private MetaModuleId CalcModuleId(IModule module);
    private MetaModuleId GenerateUniqueId(string startId);
    private static string NextName(string name);
    public IPsiModule FindModuleById(MetaModuleId moduleId);
    public MetaModuleId InternModuleId(MetaModuleId id);
    [CompilerGeneratedAttribute]
private void <.ctor>b__11_0(Lifetime projectLifetime, IProject project);
    [CompilerGeneratedAttribute]
private bool <Save>b__12_0(KeyValuePair`2<IModule, MetaModuleId> pair);
}
public class JetBrains.ReSharper.Psi.Dependencies.ModuleProperty : object {
    public static ModuleProperty DEFAULT_NAMESPACE;
    public static ModuleProperty IMPORTED_NAMESPACES;
    private static Dictionary`2<int, ModulePropertyFactory> ourHashToFactory;
    private PropertyGetter myGetter;
    private int myExternalizableHash;
    private string myExternalizableParameter;
    private static ModuleProperty();
    private ModuleProperty(PropertyGetter getter, string externalizableName, string externalizableParameter);
    public static ModuleProperty CreateConditionalCompilationConstantProperty(string name);
    private static void RegisterSimpleModuleProperty(ModuleProperty property);
    public Hash GetValueHashByModule(IPsiModule module);
    public void WriteTo(UnsafeWriter writer);
    public static ModuleProperty ReadFrom(UnsafeReader reader);
}
public static class JetBrains.ReSharper.Psi.Dependencies.QualifierInfoExtensions : object {
}
public class JetBrains.ReSharper.Psi.Dependencies.SpecialDependencyKind : object {
    [NotNullAttribute]
private string myName;
    public static SpecialDependencyKind ALL_ABSTRACT_MEMBERS;
    public static SpecialDependencyKind FIELDS_CAN_AFFECT_UNMANAGED;
    public static SpecialDependencyKind ZONE_DEPENDENCY;
    public static SpecialDependencyKind MVC_SPECIFIC;
    private SpecialDependencyKind(string name);
    private static SpecialDependencyKind();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Dependencies.SpecialDependencyManager : object {
    [CompilerGeneratedAttribute]
private SpecialDependencyMarshaller <DependencyMarshaller>k__BackingField;
    [CompilerGeneratedAttribute]
private SpecialHashMarshaller <HashMarshaller>k__BackingField;
    private Dictionary`2<int, ISpecialDependencyContributor> myContributors;
    public SpecialDependencyMarshaller DependencyMarshaller { get; }
    public SpecialHashMarshaller HashMarshaller { get; }
    public int Item { get; }
    [NotNullAttribute]
public ISpecialDependencyContributor Item { get; }
    public SpecialDependencyManager(IEnumerable`1<ISpecialDependencyContributor> contributors);
    [CompilerGeneratedAttribute]
public SpecialDependencyMarshaller get_DependencyMarshaller();
    [CompilerGeneratedAttribute]
public SpecialHashMarshaller get_HashMarshaller();
    public static SpecialDependencyManager GetInstance(ISolution solution);
    private static string Hashable(ISpecialDependencyContributor contributor);
    public static int Id(ISpecialDependencyContributor contributor);
    public int get_Item(ISpecialDependencyContributor contributor);
    public ISpecialDependencyContributor get_Item(int id);
}
public class JetBrains.ReSharper.Psi.Dependencies.SpecialDependencyMarshaller : object {
    [CompilerGeneratedAttribute]
private SpecialDependencyManager <manager>P;
    public SpecialDependencyMarshaller(SpecialDependencyManager manager);
    public sealed virtual void Marshal(UnsafeWriter s, ISpecialDependency arg);
    public sealed virtual ISpecialDependency Unmarshal(UnsafeReader s);
}
public class JetBrains.ReSharper.Psi.Dependencies.SpecialHashableEntityInfo : object {
    private Hash myHash;
    private string myQualifierTypeCLRName;
    private string myName;
    private SpecialDependencyKind myKind;
    public Hash Hash { get; }
    public SpecialHashableEntityInfo(Hash hash, string qualifierTypeCLRName, string name, SpecialDependencyKind kind);
    public sealed virtual Hash get_Hash();
    public sealed virtual void AddDependenciesAndHashes(DependencyFactory dependencyFactory, OneToListMap`2<Dependency, Hash> dependencyToHashes);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Dependencies.SpecialHashEx : object {
    [ExtensionAttribute]
public static Hash ToHash(ISpecialHash specialHash, int mix);
}
public class JetBrains.ReSharper.Psi.Dependencies.SpecialHashMarshaller : object {
    [CompilerGeneratedAttribute]
private SpecialDependencyManager <manager>P;
    public SpecialHashMarshaller(SpecialDependencyManager manager);
    public sealed virtual void Marshal(UnsafeWriter writer, ISpecialHash arg);
    public sealed virtual ISpecialHash Unmarshal(UnsafeReader s);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Dependencies.UsingsTypeInfo : ValueType {
    public int myClrNameHash;
    public string ModuleId;
    private static ILogger myLogger;
    public UsingsTypeInfo(string clrName, IPsiModule module);
    public UsingsTypeInfo(IClrTypeName clrName, IPsiModule module);
    private UsingsTypeInfo(int clrNameHash, string moduleId);
    private static UsingsTypeInfo();
    private static void Trace(int hash, string presentation);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UsingsTypeInfo other);
    public static bool op_Equality(UsingsTypeInfo left, UsingsTypeInfo right);
    public static bool op_Inequality(UsingsTypeInfo left, UsingsTypeInfo right);
    public virtual string ToString();
    public void WriteTo(UnsafeWriter writer);
    public static UsingsTypeInfo ReadFrom(UnsafeReader reader);
}
[MustDisposeResourceAttribute]
public class JetBrains.ReSharper.Psi.DisposableMarker : object {
    [CanBeNullAttribute]
private ITreeNode myRoot;
    [CompilerGeneratedAttribute]
private TreeNodeMarker <Marker>k__BackingField;
    [NotNullAttribute]
public TreeNodeMarker Marker { get; }
    public DisposableMarker(ITreeNode root);
    [CompilerGeneratedAttribute]
public TreeNodeMarker get_Marker();
    public virtual void Dispose();
    [MustDisposeResourceAttribute]
public static DisposableMarker`1<TTreeNode> For(TTreeNode element);
}
public class JetBrains.ReSharper.Psi.DisposableMarker`1 : DisposableMarker {
    private FrugalLocalHashSet`1<ITreeNode> myRoots;
    public DisposableMarker`1(TTreeNode element);
    public virtual void Dispose();
    [CanBeNullAttribute]
[PureAttribute]
public TTreeNode Find(ITreeNode root);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public TTreeNode Get(ITreeNode root);
}
public enum JetBrains.ReSharper.Psi.DisposeAnalysisMode : Enum {
    public int value__;
    public static DisposeAnalysisMode OFF;
    public static DisposeAnalysisMode OPTIMISTIC;
    public static DisposeAnalysisMode PESSIMISTIC;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.DynamicTypeDecoration : TypeDecoration {
    public static DynamicTypeDecoration Instance;
    private static DynamicTypeDecoration();
    public virtual ITypeDecorationPointer CreatePointer();
    private sealed virtual override TypeDecoration JetBrains.ReSharper.Psi.ITypeDecorationPointer.Find();
    [NullableContextAttribute("2")]
public virtual bool Equals(TypeDecoration other);
    public virtual int GetHashCode();
    public virtual string PresentType(IType decoratedType);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.DynamicTypeExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("type:null => false")]
public static bool IsDynamicType(IType type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("type:null => false")]
public static bool IsDynamicType(IExpressionType type);
    [ExtensionAttribute]
[PureAttribute]
public static IType EraseDynamicTypeFromStructure(IType type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool HasDynamicTypeInStructure(IType type);
}
public class JetBrains.ReSharper.Psi.EditorConfig.ClangBasedOnStyleConfigFileSection : ClangConfigFileSection {
    [CompilerGeneratedAttribute]
private string <Style>k__BackingField;
    public string Style { get; }
    public ClangBasedOnStyleConfigFileSection(string name, string language, string style, IEnumerable`1<IConfigElement> elements);
    [CompilerGeneratedAttribute]
public string get_Style();
}
public class JetBrains.ReSharper.Psi.EditorConfig.ClangConfigFileProperty : ConfigFileProperty {
    [CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    private string Group { get; }
    private object JetBrains.ReSharper.Psi.EditorConfig.IConfigFileProperty.Key { get; }
    public ClangConfigFileProperty(string group, string name, string value, bool isNameSupported, bool isValueSupported, ConvertedSettingInfo[] convertedSettings, bool usedDefaultValue);
    [CompilerGeneratedAttribute]
private string get_Group();
    private sealed virtual override object JetBrains.ReSharper.Psi.EditorConfig.IConfigFileProperty.get_Key();
}
public class JetBrains.ReSharper.Psi.EditorConfig.ClangConfigFileSection : ConfigContainer {
    [CompilerGeneratedAttribute]
private object <FirstPassParseResult>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfigFileMask <FileMask>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public object FirstPassParseResult { get; }
    public IConfigFileMask FileMask { get; }
    public string Name { get; }
    [NotNullAttribute]
public string Language { get; }
    [NotNullAttribute]
public string BasedOnStyle { get; }
    public ClangConfigFileSection(string name, string language, IEnumerable`1<IConfigElement> elements);
    [CompilerGeneratedAttribute]
public sealed virtual object get_FirstPassParseResult();
    [CompilerGeneratedAttribute]
public sealed virtual IConfigFileMask get_FileMask();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public string get_Language();
    public string get_BasedOnStyle();
}
public class JetBrains.ReSharper.Psi.EditorConfig.ConfigChange : object {
    public string SectionName;
    public string PrecedingCommentText;
    public string PropertyName;
    public string OldPropertyName;
    public string PropertyValue;
    public ConfigChange(string sectionName, string precedingCommentText, string propertyName, string propertyValue, string oldPropertyName);
}
public class JetBrains.ReSharper.Psi.EditorConfig.ConfigComment : ConfigElement {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; }
    public ConfigComment(string text);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Text();
}
public abstract class JetBrains.ReSharper.Psi.EditorConfig.ConfigContainer : ConfigElement {
    private List`1<IConfigElement> myElements;
    public List`1<IConfigElement> Elements { get; }
    private IReadOnlyList`1<IConfigElement> JetBrains.ReSharper.Psi.EditorConfig.IConfigContainer.Elements { get; }
    private IList`1<IConfigElement> JetBrains.ReSharper.Psi.EditorConfig.IModifiableConfigContainer.Elements { get; }
    protected ConfigContainer(IEnumerable`1<IConfigElement> elements);
    public virtual IConfigElement Clone();
    public List`1<IConfigElement> get_Elements();
    private sealed virtual override IReadOnlyList`1<IConfigElement> JetBrains.ReSharper.Psi.EditorConfig.IConfigContainer.get_Elements();
    private sealed virtual override IList`1<IConfigElement> JetBrains.ReSharper.Psi.EditorConfig.IModifiableConfigContainer.get_Elements();
}
public abstract class JetBrains.ReSharper.Psi.EditorConfig.ConfigElement : object {
    public virtual IConfigElement Clone();
}
public class JetBrains.ReSharper.Psi.EditorConfig.ConfigError : ConfigElement {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; }
    public ConfigError(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
}
public class JetBrains.ReSharper.Psi.EditorConfig.ConfigFile : ConfigContainer {
    [CompilerGeneratedAttribute]
private bool <IsRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfigFileType <FileType>k__BackingField;
    public bool IsRoot { get; public set; }
    public VirtualFileSystemPath Location { get; }
    public string Description { get; }
    public IConfigFileType FileType { get; }
    public ConfigFile(VirtualFileSystemPath location, IConfigFileType fileType);
    public ConfigFile(bool isRoot, IEnumerable`1<IConfigElement> elements, VirtualFileSystemPath location, IConfigFileType fileType, string description);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRoot();
    [CompilerGeneratedAttribute]
public void set_IsRoot(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual VirtualFileSystemPath get_Location();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public sealed virtual IConfigFileType get_FileType();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.EditorConfig.ConfigFile/<FindSectionsByName>d__15")]
public IEnumerable`1<IConfigFileSection> FindSectionsByName(string name);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.EditorConfig.ConfigFile/<FindPropertiesByName>d__16")]
public IEnumerable`1<ConfigFileProperty> FindPropertiesByName(string name);
}
public class JetBrains.ReSharper.Psi.EditorConfig.ConfigFileProperty : ConfigElement {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommentText>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsedDefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNameSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValueSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private ConvertedSettingInfo[] <ConvertedSettings>k__BackingField;
    public string Name { get; }
    public string Value { get; public set; }
    [CanBeNullAttribute]
public string CommentText { get; }
    public bool UsedDefaultValue { get; }
    public bool IsNameSupported { get; }
    public bool IsValueSupported { get; }
    [CanBeNullAttribute]
public ConvertedSettingInfo[] ConvertedSettings { get; }
    public bool HasConvertedSettings { get; }
    private IReadOnlyList`1<ConvertedSettingInfo> JetBrains.ReSharper.Psi.EditorConfig.IConfigFileProperty.ConvertedSettings { get; }
    private object JetBrains.ReSharper.Psi.EditorConfig.IConfigFileProperty.Key { get; }
    public ConfigFileProperty(string name, string value, bool isNameSupported, bool isValueSupported, ConvertedSettingInfo[] convertedSettings, string commentText, bool usedDefaultValue);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public string get_CommentText();
    [CompilerGeneratedAttribute]
public bool get_UsedDefaultValue();
    [CompilerGeneratedAttribute]
public bool get_IsNameSupported();
    [CompilerGeneratedAttribute]
public bool get_IsValueSupported();
    [CompilerGeneratedAttribute]
public ConvertedSettingInfo[] get_ConvertedSettings();
    public bool get_HasConvertedSettings();
    private sealed virtual override IReadOnlyList`1<ConvertedSettingInfo> JetBrains.ReSharper.Psi.EditorConfig.IConfigFileProperty.get_ConvertedSettings();
    private sealed virtual override object JetBrains.ReSharper.Psi.EditorConfig.IConfigFileProperty.get_Key();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.EditorConfig.ConfigFileUtils : object {
    public static string EditorConfigName;
    public static string ClangFormatName;
    public static string ClangFormatDisplayName;
    public static PropertyId`1<IConfigFileType> ConfigFileType;
    public static PropertyId`1<string> SectionName;
    public static PropertyId`1<Nullable`1<DateTime>> LastSourceFileWriteTimeUtc;
    private static ConfigFileUtils();
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IContextBoundSettingsStoreLive BindToContextLiveWithEditorConfig(ISettingsStore settingsStore, Lifetime lifetime, IPsiSourceFile sourceFile, ISolution solution, BindToContextFlags flags);
    [ExtensionAttribute]
public static IContextBoundSettingsStore BindToContextTransientWithEditorConfig(ISettingsStore settingsStore, IPsiSourceFile sourceFile);
    [ExtensionAttribute]
public static IContextBoundSettingsStore BindToContextTransientWithEditorConfig(ISettingsStore settingsStore, IPsiSourceFile sourceFile, ISolution solution, BindToContextFlags flags);
    [ExtensionAttribute]
public static IContextBoundSettingsStore BindToContextTransientWithEditorConfig(ISettingsStore settingsStore, IProjectFile projectFile, ISolution solution, BindToContextFlags flags);
    public static ContextRange GetContextRange(IPsiSourceFile sourceFile, ISolution solution);
    public static ValueTuple`2<VirtualFileSystemPath, bool> GetLocationFromSourceFile(IPsiSourceFile sourceFile, ISolution solution);
    public static ValueTuple`2<VirtualFileSystemPath, bool> GetLocationFromProjectFile(IProjectFile projectFile, ISolution solution);
    public static bool CheckPathIsAbsolute(VirtualFileSystemPath location, IPsiSourceFile sourceFile, ILogger logger);
    public static bool CheckPathIsAbsolute(VirtualFileSystemPath location, IProjectFile projectFile, ILogger logger);
    public static bool CheckPathIsAbsolute(VirtualFileSystemPath location, string data, Func`1<object> dataValue, ILogger logger);
    [ExtensionAttribute]
public static bool IsAcceptable(IConfigElement element, VirtualFileSystemPath path);
    [ExtensionAttribute]
public static FrugalLocalList`1<Pair`2<IConfigContainer, IConfigFileProperty>> GetProperties(IConfigContainer container, VirtualFileSystemPath path);
    [ExtensionAttribute]
public static FrugalLocalList`1<Pair`2<IConfigContainer, T>> GetElements(IConfigContainer container, VirtualFileSystemPath path);
    [ExtensionAttribute]
public static ConfigFileProperty FindPropertyByName(IConfigFileSection section, string name);
    public static string TrimCommentText(string text);
}
public class JetBrains.ReSharper.Psi.EditorConfig.ConfigFileWithParseResults : ConfigFile {
    [CompilerGeneratedAttribute]
private object <FirstPassParseResult>k__BackingField;
    public object FirstPassParseResult { get; }
    public ConfigFileWithParseResults(bool isRoot, IEnumerable`1<IConfigElement> elements, VirtualFileSystemPath location, IConfigFileType fileType, object firstPassParseResult, string description);
    [CompilerGeneratedAttribute]
public sealed virtual object get_FirstPassParseResult();
}
public enum JetBrains.ReSharper.Psi.EditorConfig.ConfigProjectAvailability : Enum {
    public int value__;
    public static ConfigProjectAvailability Active;
    public static ConfigProjectAvailability Inactive;
    public static ConfigProjectAvailability ProjectIndependent;
}
public class JetBrains.ReSharper.Psi.EditorConfig.ConvertedSettingInfo : object {
    [CompilerGeneratedAttribute]
private SettingIndex <SettingIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AlsoDependsOn>k__BackingField;
    public SettingIndex SettingIndex { get; }
    public string Value { get; }
    public string AlsoDependsOn { get; }
    public ConvertedSettingInfo(SettingIndex settingIndex, string value, string alsoDependsOn);
    [CompilerGeneratedAttribute]
public SettingIndex get_SettingIndex();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public string get_AlsoDependsOn();
}
public class JetBrains.ReSharper.Psi.EditorConfig.ConverterLogger : object {
    private ILogger myLogger;
    public FrugalLocalList`1<ISettingsConverterError> Errors;
    [CompilerGeneratedAttribute]
private bool <HasFatalErrors>k__BackingField;
    public bool HasFatalErrors { get; private set; }
    public ConverterLogger(ILogger logger);
    [CompilerGeneratedAttribute]
public bool get_HasFatalErrors();
    [CompilerGeneratedAttribute]
private void set_HasFatalErrors(bool value);
    public void Clear();
    public sealed virtual void ReportError(ISettingsConverterError error);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.EditorConfig.DefaulterUtils : object {
    [ExtensionAttribute]
public static KeyPathComponents ToEntryValueComponentsWithSlot(SettingsScalarEntry entry, IExceptionThrowingLogger logger);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static object MountGetRawDeserialized(ISettingsStorageMountPoint mountPoint, SettingsScalarEntry entry, KeyPathComponents& keypathWithSlot, IExceptionThrowingLogger logger);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.EditorConfig.DocumentLineEndingsCacheUpdater : object {
    public DocumentLineEndingsCacheUpdater(Lifetime lifetime, IPsiFiles psiFiles, DocumentManager documentManager, DocumentLineEndingsDetector detector);
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.EditorConfig.DocumentLineEndingsDetector : ProductDefaultLineEndings {
    private Key`1<LineEndingBox> myKey;
    private Lifetime myLifetime;
    [NotNullAttribute]
private IShellLocks myThreading;
    [NotNullAttribute]
private WeakHashSet`1<IDocument> myChangedDocuments;
    private bool myUpdateScheduled;
    private ILogger myLogger;
    public DocumentLineEndingsDetector(Lifetime lifetime, IShellLocks threading, ILogger logger);
    protected internal virtual bool ShouldCacheLineEndings();
    public virtual LineEnding DetectLineEnding(ISolution solution, IPsiSourceFile sourceFile, IDocument document, bool prohibitAutodetection, IContextBoundSettingsStore store);
    private LineEnding DoDetectLineEnding(ISolution solution, IPsiSourceFile sourceFile, IDocument document, bool prohibitAutodetection, IContextBoundSettingsStore settingsStore);
    [CanBeNullAttribute]
private IContextBoundSettingsStore GetSettingsStore(ISolution solution, IPsiSourceFile sourceFile, IContextBoundSettingsStore store);
    private static LineEnding TakeFromSettings(IContextBoundSettingsStore store);
    private static LineEnding DefaultLineEndingType();
    [MustUseReturnValueAttribute]
protected LineEnding GetOrCalculatePopularLineEnding(IDocument document, bool ignoreDisable);
    internal void CacheLineEndings(IDocument document);
    private void ScheduleUpdate(IDocument document);
    private void UpdateSavedLineEndings();
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.EditorConfig.EditorConfigAliasType : Enum {
    public int value__;
    public static EditorConfigAliasType Standard;
    public static EditorConfigAliasType Generalized;
    public static EditorConfigAliasType LanguageSpecific;
    public static EditorConfigAliasType LanguageSpecificStandard;
    public static EditorConfigAliasType NoKeyPrefix;
    public static EditorConfigAliasType LanguageSpecificStandardGeneralized;
    public static EditorConfigAliasType ReSharperGeneralized;
    public static EditorConfigAliasType Rename;
    public static EditorConfigAliasType None;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.EditorConfig.EditorConfigAliasTypeEx : object {
    [ExtensionAttribute]
public static bool Has(EditorConfigAliasType a, EditorConfigAliasType b);
}
public class JetBrains.ReSharper.Psi.EditorConfig.EditorConfigConverter : ScalarSettingsConverter {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    public static string RoslynCategory;
    public static string ReSharperCategory;
    public static string StandardCategory;
    public static string StyleCopCategory;
    public string Category { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(string value);
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.EditorConfig.EditorConfigConverterCollection : object {
    [CompilerGeneratedAttribute]
private ICollectionEvents`1<IEditorConfigConverter> <StringConverters>k__BackingField;
    public ICollectionEvents`1<IEditorConfigConverter> StringConverters { get; public set; }
    public EditorConfigConverterCollection(Lifetime lifetime, IEnumerable`1<IProvider`1<IEditorConfigConverter>> stringConverters, ILogger logger);
    [CompilerGeneratedAttribute]
public ICollectionEvents`1<IEditorConfigConverter> get_StringConverters();
    [CompilerGeneratedAttribute]
public void set_StringConverters(ICollectionEvents`1<IEditorConfigConverter> value);
    internal bool IsPropertySupported(string propertyName);
    internal void Convert(VirtualFileSystemPath ecPath, IJetSortedStringDictionary`1<string> editorConfigData, ConvertedSettings convertedSettings, ILogger logger);
    public void ReverseConvert(string category, IContextBoundSettingsStore store, IJetSortedStringDictionary`1<string> editorConfigData, ILogger logger, ISettingsExportParameters parameters, IJetSortedStringDictionary`1<string> existingProperties, SettingsExportStatus settingsStatus, ICalculatedSettingsSchema schema);
}
[AttributeUsageAttribute("4")]
public class JetBrains.ReSharper.Psi.EditorConfig.EditorConfigCustomValueSerializerAttribute : PartAttribute {
    [CompilerGeneratedAttribute]
private Type <Serializer>k__BackingField;
    public Type Serializer { get; }
    public EditorConfigCustomValueSerializerAttribute(Type Serializer);
    [CompilerGeneratedAttribute]
public Type get_Serializer();
}
[AttributeUsageAttribute("384")]
public class JetBrains.ReSharper.Psi.EditorConfig.EditorConfigEntryAliasAttribute : PartAttribute {
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private EditorConfigAliasType <AliasType>k__BackingField;
    public string Alias { get; }
    public EditorConfigAliasType AliasType { get; }
    public EditorConfigEntryAliasAttribute(string Alias, EditorConfigAliasType AliasType);
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
public EditorConfigAliasType get_AliasType();
}
public class JetBrains.ReSharper.Psi.EditorConfig.EditorConfigFile : ConfigFile {
    [CompilerGeneratedAttribute]
private bool <SpaceAroundEq>k__BackingField;
    public bool SpaceAroundEq { get; public set; }
    public EditorConfigFile(VirtualFileSystemPath location, IConfigFileType fileType);
    [CompilerGeneratedAttribute]
public bool get_SpaceAroundEq();
    [CompilerGeneratedAttribute]
public void set_SpaceAroundEq(bool value);
}
public class JetBrains.ReSharper.Psi.EditorConfig.EditorConfigFileSection : ConfigContainer {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommentText>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfigFileMask <FileMask>k__BackingField;
    [CompilerGeneratedAttribute]
private object <FirstPassParseResult>k__BackingField;
    public string Name { get; }
    public string CommentText { get; }
    public IConfigFileMask FileMask { get; }
    public object FirstPassParseResult { get; }
    public EditorConfigFileSection(string name, IConfigFileMask fileMask, string commentText, object firstPassParseResult);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public string get_CommentText();
    [CompilerGeneratedAttribute]
public sealed virtual IConfigFileMask get_FileMask();
    [CompilerGeneratedAttribute]
public sealed virtual object get_FirstPassParseResult();
    public int FindCommentByText(string text);
}
[AttributeUsageAttribute("384")]
public class JetBrains.ReSharper.Psi.EditorConfig.EditorConfigIndexedEntryAttribute : PartAttribute {
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Suffix>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <IndexedEntryDescriptor>k__BackingField;
    public string Prefix { get; }
    public string Suffix { get; }
    public Type IndexedEntryDescriptor { get; }
    public EditorConfigIndexedEntryAttribute(string Prefix, string Suffix, Type IndexedEntryDescriptor);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public string get_Suffix();
    [CompilerGeneratedAttribute]
public Type get_IndexedEntryDescriptor();
}
[AttributeUsageAttribute("1036")]
public class JetBrains.ReSharper.Psi.EditorConfig.EditorConfigKeyAttribute : PartAttribute {
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    public string Alias { get; }
    public EditorConfigKeyAttribute(string Alias);
    [CompilerGeneratedAttribute]
public string get_Alias();
}
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeStyleSettings", "JetBrains.ReSharper.Psi.Resources.Strings", "SettingsForFormatConfigurationFilesSettingDescription")]
public class JetBrains.ReSharper.Psi.EditorConfig.EditorConfigSettingsKey : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "EnableEditorConfigSupportSettingDescription")]
public bool EnableEditorConfigSupport;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "EnableClangFormatSupportSettingDescription")]
public bool EnableClangFormatSupport;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "EnableStyleCopSupportSettingDescription")]
public bool EnableStyleCopSupport;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "ProvideReSharperIndentSettingsToVisualStudioSettingDescription")]
public bool SyncToVisualStudio;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "ShowIndicatorInStatusBarWhenEditorConfigIsPresentSettingDescription")]
public bool ShowEditorConfigStatusBarIndicator;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "ReadConfigFilesAboveSolutionLevelSettingDescription")]
public bool ReadConfigAboveSolution;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "AddSpacesAroundWhenWritingToANewEditorConfigSettingDescription")]
public bool SpacesAroundEq;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "AreStyleCopConversionsTriggeredDescription")]
public bool AreStyleCopSeverityConversionsTriggered;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "ShouldTriggerStyleCopSeverityConverters")]
public bool ShouldTriggerStyleCopSeverityConverters;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "Sa1633State")]
public bool IsSa1633NullifyFileHeaderConverterTriggered;
}
[AttributeUsageAttribute("256")]
public class JetBrains.ReSharper.Psi.EditorConfig.EditorConfigValueAliasAttribute : PartAttribute {
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseOriginalName>k__BackingField;
    public string Alias { get; }
    public bool UseOriginalName { get; }
    public EditorConfigValueAliasAttribute(string Alias, bool UseOriginalName);
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
public bool get_UseOriginalName();
}
[AttributeUsageAttribute("384")]
public class JetBrains.ReSharper.Psi.EditorConfig.ExcludeFromEditorConfigAttribute : PartAttribute {
}
public class JetBrains.ReSharper.Psi.EditorConfig.GlobalConfigFile : ConfigFileWithParseResults {
    [CompilerGeneratedAttribute]
private bool <SpaceAroundEq>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GlobalLevel>k__BackingField;
    public bool SpaceAroundEq { get; public set; }
    public int GlobalLevel { get; }
    public GlobalConfigFile(IEnumerable`1<IConfigElement> elements, VirtualFileSystemPath location, IConfigFileType fileType, object firstPassParseResult, int globalLevel, string description);
    [CompilerGeneratedAttribute]
public bool get_SpaceAroundEq();
    [CompilerGeneratedAttribute]
public void set_SpaceAroundEq(bool value);
    [CompilerGeneratedAttribute]
public int get_GlobalLevel();
}
[AttributeUsageAttribute("384")]
public class JetBrains.ReSharper.Psi.EditorConfig.HideInEditorConfigAttribute : PartAttribute {
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IConfigComment {
    public string Text { get; }
    public abstract virtual string get_Text();
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IConfigContainer {
    public IReadOnlyList`1<IConfigElement> Elements { get; }
    public abstract virtual IReadOnlyList`1<IConfigElement> get_Elements();
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IConfigDefaulter {
    public string Name { get; }
    public ConvertedSettings Defaults { get; }
    public abstract virtual string get_Name();
    public abstract virtual IConfigFileMountCollection CreateConfigCollection(Lifetime lifetime, ConfigFileService configFileService);
    public abstract virtual ConvertedSettings get_Defaults();
    public abstract virtual bool IsOverridenByConfig(IReadOnlyList`1<ISettingsStorageMountPoint> mountPoints);
    public abstract virtual bool DoesApplyToSourceFileContext(SourceFileDataForConfig sourceFileDataForConfig);
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IConfigElement {
    public abstract virtual IConfigElement Clone();
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IConfigElementWithParseResults {
    public object FirstPassParseResult { get; }
    public abstract virtual object get_FirstPassParseResult();
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IConfigElementWithProjectMask {
    public IConfigProjectMask ProjectMask { get; }
    public abstract virtual IConfigProjectMask get_ProjectMask();
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IConfigFile {
    public bool IsRoot { get; }
    public VirtualFileSystemPath Location { get; }
    public string Description { get; }
    public IConfigFileType FileType { get; }
    public abstract virtual bool get_IsRoot();
    public abstract virtual VirtualFileSystemPath get_Location();
    public abstract virtual string get_Description();
    public abstract virtual IConfigFileType get_FileType();
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IConfigFileInfo {
    public IConfigFileType FileType { get; }
    public IEnumerable`1<ISettingsStorageMountPoint> MountPoints { get; }
    [CanBeNullAttribute]
public ICollection`1<SettingIndex> Entries { get; }
    public abstract virtual IConfigFileType get_FileType();
    public abstract virtual bool HasNonEmptyConfig();
    public abstract virtual IEnumerable`1<ISettingsStorageMountPoint> get_MountPoints();
    public abstract virtual ICollection`1<SettingIndex> get_Entries();
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IConfigFileMask {
    public string SectionName { get; }
    public abstract virtual bool AcceptsFileName(VirtualFileSystemPath path);
    public abstract virtual bool IsSubsetOf(IConfigFileMask otherMask);
    public abstract virtual string get_SectionName();
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IConfigFileProperty {
    public object Key { get; }
    public string Name { get; }
    public string Value { get; }
    public IReadOnlyList`1<ConvertedSettingInfo> ConvertedSettings { get; }
    public abstract virtual object get_Key();
    public abstract virtual string get_Name();
    public abstract virtual string get_Value();
    public abstract virtual IReadOnlyList`1<ConvertedSettingInfo> get_ConvertedSettings();
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IConfigFileSection {
    public IConfigFileMask FileMask { get; }
    public string Name { get; }
    public abstract virtual IConfigFileMask get_FileMask();
    public abstract virtual string get_Name();
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IConfigFileService {
    public String[] FileNamesForPathBasedDetection { get; }
    public ConfigFileGroupAvailability GroupAvailability { get; }
    public Lifetime Lifetime { get; }
    public abstract virtual OneToListMultimap`2<SettingIndex, SettingSourceInfo> GetEntriesWithDetails(IContextBoundSettingsStore context, IPsiSourceFile psiSourceFile);
    public abstract virtual IListEvents`1<IConfigFileInfo> GetConfigInfoLive(Lifetime lifetime, IPsiSourceFile psiSourceFile);
    public abstract virtual IEnumerable`1<IConfigFileType> GetTypes();
    public abstract virtual IReadOnlyList`1<IConfigFile> GetInvolvedFilesAndProperties(IConfigFileType fileType, IPsiSourceFile psiSourceFile);
    public abstract virtual IProperty`1<IConfigFileInfo> GetConfigFileInfo(IConfigFileType fileType, Lifetime lifetime, IPsiSourceFile psiSourceFile);
    public abstract virtual IConfigFileMountCollection GetMountTree(IConfigFileType configFileType);
    public abstract virtual IConfigFileMountCollection TryGetMountDefault(IConfigFileType configFileType, IConfigDefaulter defaulter);
    public abstract virtual String[] get_FileNamesForPathBasedDetection();
    public abstract virtual ConfigFileGroupAvailability get_GroupAvailability();
    public abstract virtual Lifetime get_Lifetime();
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IConfigFileType {
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public string DisplayName { get; }
    public int Priority { get; }
    public bool InheritFromParentFile { get; }
    [CanBeNullAttribute]
public SettingsScalarEntry EnabledSetting { get; }
    public HelpId HelpTopicId { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_DisplayName();
    public abstract virtual int get_Priority();
    public abstract virtual bool get_InheritFromParentFile();
    public abstract virtual SettingsScalarEntry get_EnabledSetting();
    public abstract virtual HelpId get_HelpTopicId();
    [NotNullAttribute]
public abstract virtual String[] GetFileNamesForPathBasedDetection();
    [CanBeNullAttribute]
public abstract virtual IConfigFile ParseFile(VirtualFileSystemPath path, TextReader stream, bool details);
    [CanBeNullAttribute]
public abstract virtual IConfigFile GetDefaultFileForDetails(IEnumerable`1<IConfigFile> parsedFiles);
    [NotNullAttribute]
public abstract virtual ConvertedSettings ConvertSettings(Object[] firstPassParseResults, VirtualFileSystemPath path);
    [CanBeNullAttribute]
public abstract virtual IUnsafeMarshaller`1<IConfigFileMask> GetFileMaskMarshaller();
    [NotNullAttribute]
public abstract virtual IConfigFileMountCollection CreateConfigMountTree(Lifetime lifetime, ConfigFileService configFileService);
    public abstract virtual bool Accepts(IPsiSourceFile sourceFile);
    public abstract virtual object GetAdditionalDataToSave(IConfigElement element, IConfigFile configFile);
    public abstract virtual bool IsEnabled(IContextBoundSettingsStore context);
    public abstract virtual IProperty`1<bool> IsEnabled(Lifetime lifetime, IContextBoundSettingsStoreLive context, IThreading threading);
    public abstract virtual ConfigProjectAvailability GetProjectFileAvailability(IPsiSourceFile projectPsiFile);
    public abstract virtual ConfigProjectAvailability GetProjectAvailability(IProject project);
    public abstract virtual IProperty`1<ConfigProjectAvailability> GetProjectFileAvailabilityLive(IProperty`1<IPsiSourceFile> projectPsiFileProperty, Lifetime flowLifetime);
    public abstract virtual bool ShouldDisplayProjectAvailability();
    public abstract virtual IConfigFileInfo GetConfigFileInfo(ISolution solution, IPsiSourceFile psiSourceFile);
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IConfigFileTypeWithDefaulters {
    public IConfigDefaulter[] ConfigDefaulters { get; }
    public abstract virtual IConfigDefaulter[] get_ConfigDefaulters();
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IConfigProjectMask {
    public abstract virtual bool AcceptsProject(IProject project);
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IConvertedSetting {
    public SettingIndex[] Pairs { get; }
    public abstract virtual SettingIndex[] get_Pairs();
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IEditorConfigConverter {
    public string Category { get; }
    public abstract virtual string get_Category();
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IEditorConfigCustomSerializer {
    public abstract virtual ValueTuple`2<object, string> ConvertFromString(string str);
    public abstract virtual string ConvertToString(object value);
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IEditorConfigPropertyInfo {
    public string Alias { get; }
    public int Priority { get; }
    public IEnumerable`1<SettingIndex> Entries { get; }
    public bool HideThisProperty { get; }
    public bool IsGeneralized { get; }
    public bool IsLanguageSpecific { get; }
    public bool IsStandard { get; }
    public bool IsLanguageStandard { get; }
    public bool HasResharperPrefix { get; }
    public string Description { get; }
    public IEditorConfigPropertyInfo Grandparent { get; }
    public IEditorConfigValueTypeInfo ValueTypeInfo { get; }
    public abstract virtual string get_Alias();
    public abstract virtual int get_Priority();
    public abstract virtual IEnumerable`1<SettingIndex> get_Entries();
    public abstract virtual bool get_HideThisProperty();
    public abstract virtual bool get_IsGeneralized();
    public abstract virtual bool get_IsLanguageSpecific();
    public abstract virtual bool get_IsStandard();
    public abstract virtual bool get_IsLanguageStandard();
    public abstract virtual bool get_HasResharperPrefix();
    public abstract virtual string get_Description();
    public abstract virtual IEditorConfigPropertyInfo get_Grandparent();
    public abstract virtual IEditorConfigValueTypeInfo get_ValueTypeInfo();
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IEditorConfigSchema {
    public abstract virtual IEnumerable`1<IEditorConfigPropertyInfo> GetPropertiesForSettingsEntry(SettingsScalarEntry entry);
    public abstract virtual IEnumerable`1<IEditorConfigPropertyInfo> GetPropertiesForSettingsEntry(SettingIndex index);
    public abstract virtual IEditorConfigPropertyInfo GetSpecificPropertyForSettingsEntry(SettingsScalarEntry entry);
    public abstract virtual string GetPropertyNameForHighlightingId(string id);
    public abstract virtual IEnumerable`1<IEditorConfigPropertyInfo> GetPropertiesForSettingsEntry(Expression`1<Func`2<TKey, TValue>> entry);
    public abstract virtual IEditorConfigPropertyInfo GetSettingsForAlias(string name);
    public abstract virtual IEditorConfigValueTypeInfo GetValueTypeInfo(PartCatalogType partCatalogType);
    public abstract virtual HashSet`1<string> GetAllAliases(string propertyName);
    public abstract virtual IEnumerable`1<IEditorConfigPropertyInfo> GetAllProperties();
    public abstract virtual Dictionary`2<SettingsKey, string> GetSettingsKeyToEditorConfigAlias();
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IEditorConfigValueInfo {
    public string Alias { get; }
    public string Value { get; }
    public object ValueObj { get; }
    public string Description { get; }
    public abstract virtual string get_Alias();
    public abstract virtual string get_Value();
    public abstract virtual object get_ValueObj();
    public abstract virtual string get_Description();
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IEditorConfigValueTypeInfo {
    public IReadOnlyCollection`1<IEditorConfigValueInfo> Values { get; }
    public PartCatalogType ValueType { get; }
    public SettingsStoreSerializerType SerializerType { get; }
    public bool IsFlags { get; }
    public bool IsEnum { get; }
    public IEditorConfigCustomSerializer CustomSerializer { get; }
    public abstract virtual IReadOnlyCollection`1<IEditorConfigValueInfo> get_Values();
    public abstract virtual PartCatalogType get_ValueType();
    public abstract virtual SettingsStoreSerializerType get_SerializerType();
    public abstract virtual bool get_IsFlags();
    public abstract virtual bool get_IsEnum();
    public abstract virtual IEditorConfigCustomSerializer get_CustomSerializer();
    public abstract virtual string ConvertAndCheck(string value, Object& result, Boolean& isValueAcceptable);
    public abstract virtual string ConvertToString(object value);
    public abstract virtual string GetDescriptionForValue(object value);
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IIndentAutodetectService {
    public abstract virtual int GetAutodetectedIndent(IDocument document, int indentFromSettings, bool ignoreDisable);
    public abstract virtual IProperty`1<int> GetAutodetectedIndentLive(Lifetime lifetime, IDocument document, IProperty`1<int> baseIndent, bool ignoreDisable);
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IIndexedEntryDescriptor {
    public abstract virtual IEnumerable`1<object> EnumerateAllPossibleIndexValues();
    public abstract virtual object GetDefaultValueForKey(object keyValue);
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IModifiableConfigContainer {
    public IList`1<IConfigElement> Elements { get; }
    public abstract virtual IList`1<IConfigElement> get_Elements();
}
public interface JetBrains.ReSharper.Psi.EditorConfig.IModifiableConfigFileSection {
}
public interface JetBrains.ReSharper.Psi.EditorConfig.ISettingsConverter {
    public abstract virtual bool Convert(SettingsConvertContext`1<TValue> context);
    public abstract virtual bool ConvertAndCheck(SettingsConvertAndTraceContext`1<TValue> context);
    public abstract virtual bool ReverseConvert(SettingsReverseConvertContext`1<TValue> context);
    public abstract virtual bool IsPropertySupported(string property);
}
public interface JetBrains.ReSharper.Psi.EditorConfig.ISettingsConverterError {
    public string Message { get; }
    public bool IsFatal { get; }
    public abstract virtual string GetPropertyWithValueError(ISettingsConverter converter);
    public abstract virtual string get_Message();
    public abstract virtual bool get_IsFatal();
}
public interface JetBrains.ReSharper.Psi.EditorConfig.ISettingsConverterLogger {
    public abstract virtual void ReportError(ISettingsConverterError error);
}
public interface JetBrains.ReSharper.Psi.EditorConfig.ISettingsExportParameters {
    public bool ExportDefaultValues { get; }
    public bool RemoveAmbiguousProperties { get; }
    [CanBeNullAttribute]
public HashSet`1<SettingIndex> EntriesToExport { get; }
    public abstract virtual bool get_ExportDefaultValues();
    public abstract virtual bool get_RemoveAmbiguousProperties();
    public abstract virtual HashSet`1<SettingIndex> get_EntriesToExport();
}
public class JetBrains.ReSharper.Psi.EditorConfig.MappingConvertedSetting : object {
    [CompilerGeneratedAttribute]
private SettingIndex <IndexedSettingIndex>k__BackingField;
    public SettingIndex IndexedSettingIndex { get; }
    public SettingIndex[] Pairs { get; }
    public MappingConvertedSetting(SettingsIndexedEntry indexedEntry);
    [CompilerGeneratedAttribute]
public SettingIndex get_IndexedSettingIndex();
    public sealed virtual SettingIndex[] get_Pairs();
}
public class JetBrains.ReSharper.Psi.EditorConfig.MultipleConvertedSettings : object {
    [CompilerGeneratedAttribute]
private SettingIndex[] <Pairs>k__BackingField;
    public SettingIndex[] Pairs { get; }
    public MultipleConvertedSettings(SettingIndex[] pairs);
    [CompilerGeneratedAttribute]
public sealed virtual SettingIndex[] get_Pairs();
}
public class JetBrains.ReSharper.Psi.EditorConfig.RemovedConfigElement : ConfigElement {
    [CompilerGeneratedAttribute]
private IConfigElement <RemovedElement>k__BackingField;
    public IConfigElement RemovedElement { get; }
    public RemovedConfigElement(IConfigElement removedElement);
    [CompilerGeneratedAttribute]
public IConfigElement get_RemovedElement();
}
public class JetBrains.ReSharper.Psi.EditorConfig.ScalarConverterError : object {
    [CompilerGeneratedAttribute]
private int <PropertyNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFatal>k__BackingField;
    public int PropertyNumber { get; }
    public string Message { get; }
    public bool IsFatal { get; }
    public ScalarConverterError(int propertyNumber, string message, bool isFatal);
    [CompilerGeneratedAttribute]
public int get_PropertyNumber();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsFatal();
    public sealed virtual string GetPropertyWithValueError(ISettingsConverter converter);
}
public class JetBrains.ReSharper.Psi.EditorConfig.ScalarSettingsConverter : SettingsConverterBase`1<string> {
    private bool RunOneConverter(SettingsConvertContext`1<TValue> context);
    public sealed virtual bool Convert(SettingsConvertContext`1<TValueType> context);
    public sealed virtual bool ConvertAndCheck(SettingsConvertAndTraceContext`1<TValueType> context);
    public sealed virtual bool ReverseConvert(SettingsReverseConvertContext`1<TValueType> context);
    public sealed virtual bool IsPropertySupported(string property);
}
public class JetBrains.ReSharper.Psi.EditorConfig.SettingsConvertAndTraceContext`1 : SettingsConvertContext`1<TValue> {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <SupportedProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <UnsupportedValues>k__BackingField;
    [CompilerGeneratedAttribute]
private OneToListMultimap`2<string, ConvertedSettingInfo> <Settings>k__BackingField;
    public Dictionary`2<string, object> SupportedProperties { get; }
    public HashSet`1<string> UnsupportedValues { get; }
    public OneToListMultimap`2<string, ConvertedSettingInfo> Settings { get; }
    public SettingsConvertAndTraceContext`1(IJetSortedStringDictionary`1<TValue> sourceData, ConvertedSettings target, ILogger logger, bool shouldAlwaysRun);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_SupportedProperties();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_UnsupportedValues();
    [CompilerGeneratedAttribute]
public OneToListMultimap`2<string, ConvertedSettingInfo> get_Settings();
    public IConfigFileProperty[] CreatePropertyInfos(IEnumerable`1<ISettingsConverter> converters);
    public virtual bool CheckErrorsAndClear(ISettingsConverter converter);
}
public class JetBrains.ReSharper.Psi.EditorConfig.SettingsConvertContext`1 : object {
    [CompilerGeneratedAttribute]
private IJetSortedStringDictionary`1<TValue> <SourceData>k__BackingField;
    [CompilerGeneratedAttribute]
private ConvertedSettings <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldAlwaysRun>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <SourceValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <TargetValues>k__BackingField;
    [CompilerGeneratedAttribute]
private ConverterLogger <ConverterLogger>k__BackingField;
    public IJetSortedStringDictionary`1<TValue> SourceData { get; }
    public ConvertedSettings Target { get; }
    public ILogger Logger { get; }
    public bool ShouldAlwaysRun { get; }
    public Object[] SourceValues { get; }
    public Object[] TargetValues { get; }
    public ConverterLogger ConverterLogger { get; }
    public SettingsConvertContext`1(IJetSortedStringDictionary`1<TValue> sourceData, ConvertedSettings target, ILogger logger, bool shouldAlwaysRun);
    [CompilerGeneratedAttribute]
public IJetSortedStringDictionary`1<TValue> get_SourceData();
    [CompilerGeneratedAttribute]
public ConvertedSettings get_Target();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public bool get_ShouldAlwaysRun();
    [CompilerGeneratedAttribute]
public Object[] get_SourceValues();
    [CompilerGeneratedAttribute]
public Object[] get_TargetValues();
    [CompilerGeneratedAttribute]
public ConverterLogger get_ConverterLogger();
    public virtual bool CheckErrorsAndClear(ISettingsConverter converter);
    public void Convert(IEnumerable`1<ISettingsConverter> converters);
}
public class JetBrains.ReSharper.Psi.EditorConfig.SettingsConvertContextWithFilePath`1 : SettingsConvertContext`1<TValue> {
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <FilePath>k__BackingField;
    public VirtualFileSystemPath FilePath { get; }
    public SettingsConvertContextWithFilePath`1(IJetSortedStringDictionary`1<TValue> sourceData, ConvertedSettings target, ILogger logger, VirtualFileSystemPath filePath, bool shouldAlwaysRun);
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_FilePath();
}
public abstract class JetBrains.ReSharper.Psi.EditorConfig.SettingsConverterBase : object {
    [CompilerGeneratedAttribute]
private IConvertedSetting[] <ConvertedSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <DefaultOriginalValues>k__BackingField;
    [CompilerGeneratedAttribute]
private SettingsConverterHandler <ConversionHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private SettingsConverterHandler <ReverseConversionHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    public IConvertedSetting[] ConvertedSettings { get; private set; }
    public Object[] DefaultOriginalValues { get; public set; }
    public SettingsConverterHandler ConversionHandler { get; public set; }
    public SettingsConverterHandler ReverseConversionHandler { get; public set; }
    public int Priority { get; public set; }
    public int OriginalSettingsLength { get; }
    [CompilerGeneratedAttribute]
public IConvertedSetting[] get_ConvertedSettings();
    [CompilerGeneratedAttribute]
private void set_ConvertedSettings(IConvertedSetting[] value);
    [CompilerGeneratedAttribute]
public Object[] get_DefaultOriginalValues();
    [CompilerGeneratedAttribute]
public void set_DefaultOriginalValues(Object[] value);
    [CompilerGeneratedAttribute]
public SettingsConverterHandler get_ConversionHandler();
    [CompilerGeneratedAttribute]
public void set_ConversionHandler(SettingsConverterHandler value);
    [CompilerGeneratedAttribute]
public SettingsConverterHandler get_ReverseConversionHandler();
    [CompilerGeneratedAttribute]
public void set_ReverseConversionHandler(SettingsConverterHandler value);
    [CompilerGeneratedAttribute]
public int get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(int value);
    public abstract virtual int get_OriginalSettingsLength();
    public virtual void Convert(Object[] sourceValues, Object[] targetValues, ISettingsConverterLogger logger);
    public virtual void ReverseConvert(Object[] sourceValues, Object[] targetValues, ISettingsConverterLogger logger);
    public virtual void AddConvertedSettings(T[] settings, TParam param, Func`3<T, TParam, IConvertedSetting> converter);
}
public class JetBrains.ReSharper.Psi.EditorConfig.SettingsConverterBase`1 : SettingsConverterBase {
    [CompilerGeneratedAttribute]
private TOriginalType[] <OriginalSettings>k__BackingField;
    public TOriginalType[] OriginalSettings { get; private set; }
    public int OriginalSettingsLength { get; }
    [CompilerGeneratedAttribute]
public TOriginalType[] get_OriginalSettings();
    [CompilerGeneratedAttribute]
private void set_OriginalSettings(TOriginalType[] value);
    public virtual int get_OriginalSettingsLength();
    public virtual void DoAddOriginalSettings(TOriginalType[] settings);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.EditorConfig.SettingsConverterEx : object {
    public static int MaxSettingsForConverter;
    [ExtensionAttribute]
public static bool ShouldExportDefaultValue(ISettingsExportParameters parameters, SettingIndex index);
    [ExtensionAttribute]
public static T AddOriginalSettings(T converter, TOriginalType[] originalSettings);
    [ExtensionAttribute]
public static T SetDefaultOriginalValues(T converter, Object[] values);
    [ExtensionAttribute]
public static T SetHandler(T converter, SettingsConverterHandler handler);
    [ExtensionAttribute]
public static T SetReverseHandler(T converter, SettingsConverterHandler handler);
    [ExtensionAttribute]
public static T SetPriority(T converter, int priority);
    [ExtensionAttribute]
public static T AddConvertedSettings(T converter, ISettingsSchema schema, IEditorConfigSchema ecSchema, string alias, Type settingsKey);
    [ExtensionAttribute]
public static T AddConvertedSettings(T converter, ISettingsSchema schema, Expression`1[] settings);
    [ExtensionAttribute]
public static T AddConvertedSettings(T converter, ISettingsSchema schema, Expression`1[] settings);
    [ExtensionAttribute]
public static T AddConvertedIndexedSetting(T converter, ISettingsSchema schema, Expression`1[] settings);
    [ExtensionAttribute]
public static T AddConvertedSettings(T converter, ISettingsSchema schema, Expression`1<Func`2<TSettingsKey, IIndexedEntry`2<TIndex, TSettingsValue>>> setting, TIndex[] indices);
    [ExtensionAttribute]
public static OneToListMultimap`2<SettingIndex, string> GetSettingsWithAffectingProperties(IEnumerable`1<ISettingsConverter> converters);
    [ExtensionAttribute]
public static OneToListMultimap`2<string, SettingIndex> GetPropertiesWithAffectedSettings(IEnumerable`1<ISettingsConverter> converters);
    [ExtensionAttribute]
public static void ReportScalarError(ISettingsConverterLogger logger, int sourceValueIndex, string message);
    [ExtensionAttribute]
public static void ReportScalarNonFatalError(ISettingsConverterLogger logger, int sourceValueIndex, string message);
}
public class JetBrains.ReSharper.Psi.EditorConfig.SettingsConverterHandler : MulticastDelegate {
    public SettingsConverterHandler(object object, IntPtr method);
    public virtual void Invoke(Object[] sourceValues, Object[] targetValues, ISettingsConverterLogger logger);
    public virtual IAsyncResult BeginInvoke(Object[] sourceValues, Object[] targetValues, ISettingsConverterLogger logger, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.EditorConfig.SettingsConverterUtils : object {
    [ExtensionAttribute]
public static bool IsPropertySupported(IEnumerable`1<ISettingsConverter> converters, string propertyName);
    [ExtensionAttribute]
public static void ReverseConvert(IEnumerable`1<ISettingsConverter> converters, IContextBoundSettingsStore settingsStore, IJetSortedStringDictionary`1<string> target, ILogger logger, ISettingsExportParameters parameters, IJetSortedStringDictionary`1<string> existingProperties, SettingsExportStatus settingsStatus, ICalculatedSettingsSchema schema);
    [ExtensionAttribute]
public static IConfigFileProperty[] CreatePropertyInfos(IEnumerable`1<ISettingsConverter> converters, IJetSortedStringDictionary`1<TValue> editorConfigData, ILogger logger, bool shouldAlwaysRun);
}
public class JetBrains.ReSharper.Psi.EditorConfig.SettingsExportStatus : object {
    private Dictionary`2<SettingIndex, int> myMustOverrideWithPriority;
    private Dictionary`2<SettingIndex, int> myProcessedWithPriority;
    public void PleaseOverrideMe(SettingIndex setting, int priority);
    public bool MustOverride(SettingIndex setting, int priority);
    public void SettingProcessed(SettingIndex setting, int priority);
    public bool IsProcessed(SettingIndex setting);
}
public class JetBrains.ReSharper.Psi.EditorConfig.SettingSourceInfo : ValueType {
    [CanBeNullAttribute]
public IConfigFileType ConfigFileType;
    [CanBeNullAttribute]
public IConfigFile ConfigFile;
    [CanBeNullAttribute]
public IConfigFileProperty Property;
    [CanBeNullAttribute]
public object Value;
    public SettingSourceInfo(IConfigFileType configFileType, IConfigFile configFile, IConfigFileProperty property, object value);
}
public class JetBrains.ReSharper.Psi.EditorConfig.SettingsReverseConvertContext`1 : object {
    [CompilerGeneratedAttribute]
private IJetSortedStringDictionary`1<TValue> <ExistingProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IContextBoundSettingsStore <SettingsStore>k__BackingField;
    [CompilerGeneratedAttribute]
private IJetSortedStringDictionary`1<string> <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettingsExportParameters <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private SettingsExportStatus <SettingsStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private ICalculatedSettingsSchema <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <SourceValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <TargetValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <ValuesForRecheck>k__BackingField;
    [CompilerGeneratedAttribute]
private ConverterLogger <ConverterLogger>k__BackingField;
    public IJetSortedStringDictionary`1<TValue> ExistingProperties { get; }
    public ILogger Logger { get; }
    public IContextBoundSettingsStore SettingsStore { get; }
    public IJetSortedStringDictionary`1<string> Target { get; }
    public ISettingsExportParameters Parameters { get; }
    public SettingsExportStatus SettingsStatus { get; }
    public ICalculatedSettingsSchema Schema { get; }
    public Object[] SourceValues { get; }
    public Object[] TargetValues { get; }
    public Object[] ValuesForRecheck { get; }
    public ConverterLogger ConverterLogger { get; }
    public SettingsReverseConvertContext`1(IJetSortedStringDictionary`1<TValue> existingProperties, ILogger logger, IContextBoundSettingsStore settingsStore, IJetSortedStringDictionary`1<string> target, ISettingsExportParameters parameters, SettingsExportStatus settingsStatus, ICalculatedSettingsSchema schema);
    [CompilerGeneratedAttribute]
public IJetSortedStringDictionary`1<TValue> get_ExistingProperties();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public IContextBoundSettingsStore get_SettingsStore();
    [CompilerGeneratedAttribute]
public IJetSortedStringDictionary`1<string> get_Target();
    [CompilerGeneratedAttribute]
public ISettingsExportParameters get_Parameters();
    [CompilerGeneratedAttribute]
public SettingsExportStatus get_SettingsStatus();
    [CompilerGeneratedAttribute]
public ICalculatedSettingsSchema get_Schema();
    [CompilerGeneratedAttribute]
public Object[] get_SourceValues();
    [CompilerGeneratedAttribute]
public Object[] get_TargetValues();
    [CompilerGeneratedAttribute]
public Object[] get_ValuesForRecheck();
    [CompilerGeneratedAttribute]
public ConverterLogger get_ConverterLogger();
    public void Convert(IEnumerable`1<ISettingsConverter> converters);
}
public class JetBrains.ReSharper.Psi.EditorConfig.SimpleSettingsConverterError : object {
    [CompilerGeneratedAttribute]
private string <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFatal>k__BackingField;
    public string Property { get; }
    public string Value { get; }
    public string Message { get; }
    public bool IsFatal { get; }
    public SimpleSettingsConverterError(string property, string value, bool isFatal, string message);
    public sealed virtual string GetPropertyWithValueError(ISettingsConverter converter);
    [CompilerGeneratedAttribute]
public string get_Property();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsFatal();
}
public class JetBrains.ReSharper.Psi.EditorConfig.SingleConvertedSetting : object {
    [CompilerGeneratedAttribute]
private SettingIndex <SettingIndex>k__BackingField;
    public SettingIndex SettingIndex { get; }
    public SettingIndex[] Pairs { get; }
    public SingleConvertedSetting(SettingsIndexedEntry indexedEntry, object index);
    public SingleConvertedSetting(SettingsScalarEntry scalarEntry);
    [CompilerGeneratedAttribute]
public SettingIndex get_SettingIndex();
    public sealed virtual SettingIndex[] get_Pairs();
}
public class JetBrains.ReSharper.Psi.ElementFactoryException : Exception {
    public ElementFactoryException(string message);
    public ElementFactoryException(string message, Exception innerException);
    protected ElementFactoryException(SerializationInfo info, StreamingContext context);
}
[DebuggerDisplayAttribute("<empty attributes set>")]
public class JetBrains.ReSharper.Psi.EmptyAttributesSet : object {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
public static IAttributesSet Instance;
    private static EmptyAttributesSet();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
}
public class JetBrains.ReSharper.Psi.EmptyPsiModule : UserDataHolder {
    private ISolution mySolution;
    public string Name { get; }
    public string DisplayName { get; }
    public TargetFrameworkId TargetFrameworkId { get; }
    public PsiLanguageType PsiLanguage { get; }
    public ProjectFileType ProjectFileType { get; }
    public IModule ContainingProjectModule { get; }
    public IEnumerable`1<IPsiSourceFile> SourceFiles { get; }
    public EmptyPsiModule(ISolution solution);
    public sealed virtual bool IsValid();
    public sealed virtual string GetPersistentID();
    public sealed virtual string get_Name();
    public sealed virtual string get_DisplayName();
    public sealed virtual TargetFrameworkId get_TargetFrameworkId();
    public sealed virtual ISolution GetSolution();
    public sealed virtual PsiLanguageType get_PsiLanguage();
    public sealed virtual ProjectFileType get_ProjectFileType();
    public sealed virtual IEnumerable`1<IPsiModuleReference> GetReferences(IModuleReferenceResolveContext moduleReferenceResolveContext);
    public sealed virtual IModule get_ContainingProjectModule();
    public sealed virtual IEnumerable`1<IPsiSourceFile> get_SourceFiles();
    public sealed virtual ICollection`1<PreProcessingDirective> GetAllDefines();
    public sealed virtual IPsiServices GetPsiServices();
}
public enum JetBrains.ReSharper.Psi.EntityKindForm : Enum {
    public int value__;
    public static EntityKindForm NONE;
    public static EntityKindForm NORMAL;
    public static EntityKindForm NORMAL_IN_BRACKETS;
    public static EntityKindForm IN;
    public static EntityKindForm FROM;
    public static EntityKindForm LANGUAGE_KEYWORD;
}
public abstract class JetBrains.ReSharper.Psi.EntryPoints.EntryPointCheckResult : object {
    public bool IsEntryPoint { get; }
    public virtual bool get_IsEntryPoint();
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.EntryPoints.EntryPointFeatures : Enum {
    public int value__;
    public static EntryPointFeatures None;
    public static EntryPointFeatures CanBeTaskReturning;
    public static EntryPointFeatures CanBeInterfaceMember;
    public static EntryPointFeatures CanBeTopLevel;
}
public static class JetBrains.ReSharper.Psi.EntryPoints.EntryPointUtil : object {
    public static string MainMethodName;
    [PureAttribute]
public static EntryPointFeatures GetEntryPointFeatures(IProjectPsiModule projectPrimaryPsiModule);
    [PureAttribute]
public static EntryPointFeatures GetEntryPointFeatures(ITreeNode context);
    [PureAttribute]
public static EntryPointCheckResult IsEntryPoint(IMethod method, EntryPointFeatures entryPointFeatures);
    [PureAttribute]
private static EntryPointCheckResult IsEntryPointInternal(IMethod method, EntryPointFeatures entryPointFeatures, bool checkSyncCandidates);
    [PureAttribute]
public static EntryPointCheckResult CheckTopLevelEntryPointApplicability(IPsiModule psiModule);
    private static void AddDependencies(DependencyStore dependencyStore, IProject project, IPsiModule module);
    [PureAttribute]
[NotNullAttribute]
public static IReadOnlyList`1<IDeclaredElement> CollectEntryPoints(IPsiModule module, EntryPointFeatures entryPointFeatures);
    [PureAttribute]
public static bool CanContainGeneratedEntryPoint(IProject project, TargetFrameworkId targetFrameworkId);
    [PureAttribute]
private static EntryPointCheckResult CheckProjectTypeAndStartupObject(IPsiModule psiModule, IProject project, IMethod method);
    [PureAttribute]
public static bool HasEntryPointSignature(IParametersOwner method, bool canBeTaskReturning);
    [PureAttribute]
private static bool CheckReturnType(IType returnType, bool canBeTaskReturning);
}
public interface JetBrains.ReSharper.Psi.EntryPoints.IEntryPointFeaturesProvider {
    [PureAttribute]
public abstract virtual EntryPointFeatures GetEntryPointFeatures(IPsiModule module);
    [PureAttribute]
public abstract virtual EntryPointFeatures GetEntryPointFeatures(ITreeNode context);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class JetBrains.ReSharper.Psi.EqualitySubstitutionTypeParameterType : object {
    private ITypeParameter myTypeParameter;
    private int myIndex;
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public IPsiModule Module { get; }
    public bool IsOpenType { get; }
    public TypeClassification Classify { get; }
    public AssemblyNameInfo Assembly { get; }
    public TypeDecorationSet TypeDecorations { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public EqualitySubstitutionTypeParameterType(ITypeParameter typeParameter, int index);
    public sealed virtual IType ToIType();
    public virtual string ToString();
    private string get_DebuggerDisplay();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual bool IsImplicitlyConvertibleTo(IType type, ITypeConversionRule conversionRule);
    public sealed virtual bool IsExplicitlyConvertibleTo(IType type, ITypeConversionRule conversionRule);
    public sealed virtual void Accept(TypeVisitor typeVisitor);
    public sealed virtual TResult Accept(TypeVisitor`2<TContext, TResult> typeVisitor, TContext context);
    public sealed virtual IDeclaredType GetScalarType();
    public sealed virtual ISymbolTable GetSymbolTable(IPsiModule module);
    public sealed virtual bool get_IsOpenType();
    public sealed virtual TypeClassification get_Classify();
    public sealed virtual bool IsWellFormed(ITypeConstraintsVerifier typeConstraintsVerifier);
    public sealed virtual ITypePointer CreatePointer();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(IType type, IEqualityComparer`1<IType> childrenComparer);
    public sealed virtual ITypeElement GetTypeElement();
    public sealed virtual IClrTypeName GetClrName();
    public sealed virtual IResolveResult Resolve();
    public sealed virtual bool IsSubtypeOf(IDeclaredType to, ITypeConversionRule typeConversionRule);
    public sealed virtual AssemblyNameInfo get_Assembly();
    public sealed virtual TypeDecorationSet get_TypeDecorations();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    public sealed virtual IDeclaredType Retarget(IPsiModule psiModule);
    public sealed virtual IDeclaredType WithTypeDecorations(TypeDecorationSet typeDecorations);
    public sealed virtual IDeclaredType WithNullableAnnotation(NullableAnnotation nullableAnnotation);
    private sealed virtual override IType JetBrains.ReSharper.Psi.IType.WithTypeDecorations(TypeDecorationSet typeDecorations);
    private sealed virtual override IType JetBrains.ReSharper.Psi.IType.WithNullableAnnotation(NullableAnnotation nullableAnnotation);
    public sealed virtual IType MergeNullability(IType otherType, TypeParameterVariance variance);
}
public class JetBrains.ReSharper.Psi.ExpectedTypes.AnyTypeConstraint : object {
    [CanBeNullAttribute]
private IType myDefaultType;
    public AnyTypeConstraint(IType defaultType);
    public sealed virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    public sealed virtual IType GetDefaultType();
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
    public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
}
public class JetBrains.ReSharper.Psi.ExpectedTypes.ArrayTypeConstraint : object {
    [NotNullAttribute]
private IType myDefaultElementType;
    private Nullable`1<int> myExpectedRank;
    public ArrayTypeConstraint(IType defaultElementType);
    public ArrayTypeConstraint(IType defaultElementType, Nullable`1<int> expectedRank);
    public sealed virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    [NotNullAttribute]
public sealed virtual IType GetDefaultType();
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
    [NotNullAttribute]
public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.ExpectedTypes.CompositeConstraint : object {
    [NotNullAttribute]
[ItemNotNullAttribute]
private IReadOnlyList`1<IExpectedTypeConstraint> myConstraints;
    private CompositeConstraint(IEnumerable`1<IExpectedTypeConstraint> constraints);
    private CompositeConstraint(IExpectedTypeConstraint constraint1, IExpectedTypeConstraint constraint2);
    [NotNullAttribute]
public static IExpectedTypeConstraint Create(IExpectedTypeConstraint constraint1, IExpectedTypeConstraint constraint2);
    [NotNullAttribute]
public static IExpectedTypeConstraint Create(IEnumerable`1<IExpectedTypeConstraint> constraints);
    [NotNullAttribute]
public static IExpectedTypeConstraint Create(IEnumerable`1<ExpectedType> expectedTypes);
    private static void Linearize(IExpectedTypeConstraint constraint, List`1<IExpectedTypeConstraint> linearized);
    private static void Linearize(IEnumerable`1<IExpectedTypeConstraint> constraints, List`1<IExpectedTypeConstraint> linearized);
    [NotNullAttribute]
public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    [NotNullAttribute]
public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    public sealed virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    public sealed virtual IType GetDefaultType();
    private static bool CheckJoinConstraint(JoinConstraint joinConstraint, IType type);
    public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
    public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.ExpectedTypes.ConvertibleFromConstraint : object {
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [NotNullAttribute]
public IType Type { get; }
    protected ConvertibleFromConstraint(IType type);
    [CompilerGeneratedAttribute]
public IType get_Type();
    [NotNullAttribute]
protected abstract virtual IExpectedTypeConstraint CreateConvertibleFromConstraint(IType fromType);
    public abstract virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    public sealed virtual IType GetDefaultType();
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
    public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
}
public class JetBrains.ReSharper.Psi.ExpectedTypes.ConvertibleFromExpressionTypeConstraint : object {
    [NotNullAttribute]
private ITypeConversionRule myTypeConversionRule;
    [CompilerGeneratedAttribute]
private IExpressionType <ExpressionType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AcceptExplicit>k__BackingField;
    [NotNullAttribute]
public IExpressionType ExpressionType { get; }
    public bool AcceptExplicit { get; }
    public ConvertibleFromExpressionTypeConstraint(IExpressionType expressionType, ITypeConversionRule typeConversionRule, bool acceptExplicit);
    [CompilerGeneratedAttribute]
public IExpressionType get_ExpressionType();
    [CompilerGeneratedAttribute]
public bool get_AcceptExplicit();
    public sealed virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    public sealed virtual IType GetDefaultType();
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
    public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
    public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.ExpectedTypes.ConvertibleToConstraint`1 : object {
    [NotNullAttribute]
protected TTypeConstraintsVerifier TypeConstraintsVerifier;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    public IType Type { get; }
    protected ConvertibleToConstraint`1(IType type, TTypeConstraintsVerifier typeConstraintsVerifier);
    [CompilerGeneratedAttribute]
public sealed virtual IType get_Type();
    [NotNullAttribute]
protected abstract virtual IReadOnlyCollection`1<ISubstitution> SolveSubtypingForFrom(IType from, IType to, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters);
    [NotNullAttribute]
protected abstract virtual IExpectedTypeConstraint CreateImplicitlyConvertibleToConstraint(IType toType);
    [NotNullAttribute]
protected abstract virtual IExpectedTypeConstraint CreateImplicitlyConvertibleFromConstraint(IType fromType);
    [NotNullAttribute]
protected virtual IExpectedTypeConstraint CreateIdentityConvertibleToConstraint(IType toType);
    public abstract virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    public virtual IType GetDefaultType();
    public virtual IReadOnlyList`1<IType> GetDefaultTypes();
    public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
    public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
}
public abstract class JetBrains.ReSharper.Psi.ExpectedTypes.ConvertibleToWithTypeInference`2 : object {
    [NotNullAttribute]
protected IType myTargetType;
    protected bool myIsExactType;
    [NotNullAttribute]
protected ISubstitution myOwnerSubstitution;
    [NotNullAttribute]
protected IReadOnlyCollection`1<ITypeParameter> myInferrableTypeParameters;
    [NotNullAttribute]
private PsiLanguageType myLanguage;
    [NotNullAttribute]
protected TTypeConstraintsVerifier TypeConstraintsVerifier;
    [NotNullAttribute]
protected TTypeConversionRule TypeConversionRule { get; }
    public bool HasInferrableTypeParameters { get; }
    protected ConvertibleToWithTypeInference`2(IType targetType, bool isExactType, ISubstitution ownerSubstitution, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, PsiLanguageType language, TTypeConstraintsVerifier typeConstraintsVerifier);
    protected abstract virtual TTypeConversionRule get_TypeConversionRule();
    public sealed virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    protected abstract virtual bool IsImplicitlyConvertible(IType type, IType inferredType);
    [NotNullAttribute]
public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
    [NotNullAttribute]
protected abstract virtual IExpectedTypeConstraint CreateConvertibleFromConstraint(IType type);
    [NotNullAttribute]
protected abstract virtual IExpectedTypeConstraint CreateConvertibleToConstraint(IType type);
    [NotNullAttribute]
public sealed virtual IType GetDefaultType();
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
    public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    [NotNullAttribute]
protected abstract virtual IExpectedTypeConstraint CreateConstraintForDelegateReturnType(IDelegate delegate, ISubstitution substitution, ReferenceKind& returnKind);
    [NotNullAttribute]
protected abstract virtual IExpectedTypeConstraint CreateConstraintForArrayElementType(IType elementType);
    public sealed virtual bool get_HasInferrableTypeParameters();
    public virtual bool Equals(object obj);
    public bool Equals(ConvertibleToWithTypeInference`2<TTypeConstraintsVerifier, TTypeConversionRule> other);
    [PureAttribute]
private static bool EqualSubstitutions(ISubstitution left, ISubstitution right);
    private static bool EqualTypeParameters(IReadOnlyCollection`1<ITypeParameter> left, IReadOnlyCollection`1<ITypeParameter> right);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.ExpectedTypes.EmptyConstraint : object {
    [NotNullAttribute]
public static EmptyConstraint Instance;
    private static EmptyConstraint();
    public sealed virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    public sealed virtual IType GetDefaultType();
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
    public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
}
public class JetBrains.ReSharper.Psi.ExpectedTypes.ExactTypeConstraint : object {
    [NotNullAttribute]
private IType myType;
    public ExactTypeConstraint(IType type);
    public sealed virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    [NotNullAttribute]
public sealed virtual IType GetDefaultType();
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    [NotNullAttribute]
public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
    public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    [NotNullAttribute]
public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.ExpectedTypes.ExpectedType : object {
    [CompilerGeneratedAttribute]
private IExpectedTypeConstraint <Constraint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExpectedName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<NameRoot> <NameRoots>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpectedTypeModifiers <Modifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private HeadType <Head>k__BackingField;
    [CompilerGeneratedAttribute]
private TailType <Tail>k__BackingField;
    public IExpectedTypeConstraint Constraint { get; }
    [NotNullAttribute]
public string ExpectedName { get; }
    [CanBeNullAttribute]
public IEnumerable`1<NameRoot> NameRoots { get; }
    public ExpectedTypeModifiers Modifiers { get; }
    [NotNullAttribute]
public HeadType Head { get; }
    [NotNullAttribute]
public TailType Tail { get; }
    public ExpectedType(IExpectedTypeConstraint constraint, string expectedName, ExpectedTypeModifiers modifiers, HeadType headType, TailType tailType, IEnumerable`1<NameRoot> nameRoots);
    public ExpectedType(IExpectedTypeConstraint constraint);
    public ExpectedType(IExpectedTypeConstraint constraint, TailType tailType);
    public ExpectedType(IExpectedTypeConstraint constraint, string expectedName, ExpectedTypeModifiers modifiers);
    public ExpectedType(ExpectedType expectedType, TailType newTailType);
    [CompilerGeneratedAttribute]
public IExpectedTypeConstraint get_Constraint();
    [CompilerGeneratedAttribute]
public string get_ExpectedName();
    [CompilerGeneratedAttribute]
public IEnumerable`1<NameRoot> get_NameRoots();
    [CompilerGeneratedAttribute]
public ExpectedTypeModifiers get_Modifiers();
    [CompilerGeneratedAttribute]
public HeadType get_Head();
    [CompilerGeneratedAttribute]
public TailType get_Tail();
    public sealed virtual bool Equals(ExpectedType other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [PureAttribute]
[NotNullAttribute]
public ExpectedType WithJointConstraint(IExpectedTypeConstraint otherConstraint);
    [CompilerGeneratedAttribute]
internal static bool <Equals>g__RootEqual|23_0(IEnumerable`1<NameRoot> first, IEnumerable`1<NameRoot> second);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ExpectedTypes.ExpectedTypeConstraintExtensions : object {
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => true")]
[PureAttribute]
public static bool IsNullOrEmpty(IExpectedTypeConstraint constraint);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsUninferredTypeParameters(IExpectedTypeConstraint constraint);
}
public enum JetBrains.ReSharper.Psi.ExpectedTypes.ExpectedTypeMode : Enum {
    public int value__;
    public static ExpectedTypeMode Completion;
    public static ExpectedTypeMode BlackHole;
    public static ExpectedTypeMode Precise;
}
public enum JetBrains.ReSharper.Psi.ExpectedTypes.ExpectedTypeModifiers : Enum {
    public int value__;
    public static ExpectedTypeModifiers None;
    public static ExpectedTypeModifiers LValue;
    public static ExpectedTypeModifiers MutableReference;
    public static ExpectedTypeModifiers ReadonlyReference;
    public static ExpectedTypeModifiers Constant;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ExpectedTypes.ExpectedTypesUtil : object {
    [NotNullAttribute]
public static IReadOnlyList`1<ExpectedType> GetExpectedTypes(IExpression expression, ExpectedTypeMode expectedTypeMode);
    [NotNullAttribute]
public static IReadOnlyList`1<ExpectedType> GetExpectedTypesForArrayElement(IReadOnlyList`1<ExpectedType> expectedTypesForArray);
    [ExtensionAttribute]
[NotNullAttribute]
public static IReadOnlyList`1<IType> GetPossibleConcreteTypes(IExpectedTypeConstraint constraint);
    [ExtensionAttribute]
[NotNullAttribute]
public static IReadOnlyList`1<IType> GetPossibleConcreteTypesForUnion(IReadOnlyList`1<ExpectedType> expectedTypes);
    [NotNullAttribute]
public static IExpectedTypeConstraint GuessTypesIntersection(IEnumerable`1<IExpression> expressions);
    [NotNullAttribute]
public static IExpectedTypeConstraint GuessTypesComposition(IList`1<IExpression> expressions);
    [NotNullAttribute]
public static IExpectedTypeConstraint GuessTypesIntersectionOrComposition(IList`1<IExpression> expressions);
    private static IExpectedTypeConstraint CreateConstraintForBound(TypeInferenceBound bound, Func`2<IType, IExpectedTypeConstraint> createConvertibleTo, Func`2<IType, IExpectedTypeConstraint> createConvertibleFrom);
    [NotNullAttribute]
private static IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> ToConstraints(IList`1<Dictionary`2<ITypeParameter, TypeInferenceBoundsSet>> constraints, Func`2<IType, IExpectedTypeConstraint> createConvertibleTo, Func`2<IType, IExpectedTypeConstraint> createConvertibleFrom);
    [NotNullAttribute]
public static IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> GetSubtypingConstraintsForTo(IType from, IType to, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParametersOfTo, Func`2<IType, IExpectedTypeConstraint> createConvertibleTo, Func`2<IType, IExpectedTypeConstraint> createConvertibleFrom);
    [NotNullAttribute]
public static IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> GetSubtypingConstraintsForFrom(IType from, IType to, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParametersOfFrom, Func`2<IType, IExpectedTypeConstraint> createConvertibleTo, Func`2<IType, IExpectedTypeConstraint> createConvertibleFrom);
    [NotNullAttribute]
public static IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> GetEqualityConstraints(IType actualType, IType formalType, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters);
}
public class JetBrains.ReSharper.Psi.ExpectedTypes.HeadType : EnumPattern {
    [NotNullAttribute]
private string myText;
    [NotNullAttribute]
public static HeadType None;
    protected HeadType(string name, string text);
    private static HeadType();
    [NotNullAttribute]
public string GetText();
}
public interface JetBrains.ReSharper.Psi.ExpectedTypes.IConvertibleToConstraint {
    [NotNullAttribute]
public IType Type { get; }
    public abstract virtual IType get_Type();
}
public interface JetBrains.ReSharper.Psi.ExpectedTypes.IConvertibleToWithTypeInference {
    public bool HasInferrableTypeParameters { get; }
    public abstract virtual bool get_HasInferrableTypeParameters();
}
public interface JetBrains.ReSharper.Psi.ExpectedTypes.IExpectedTypeConstraint {
    [PureAttribute]
public abstract virtual bool Accepts(IType type);
    [PureAttribute]
public abstract virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    [ObsoleteAttribute("Use GetDefaultTypes instead")]
[CanBeNullAttribute]
[PureAttribute]
public abstract virtual IType GetDefaultType();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IReadOnlyList`1<IType> GetDefaultTypes();
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IReadOnlyList`1<IType> GetTypesEffectively();
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
}
public interface JetBrains.ReSharper.Psi.ExpectedTypes.IExpectedTypesProvider {
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<ExpectedType> GetExpectedTypes(IExpression expression, ExpectedTypeMode mode);
}
public class JetBrains.ReSharper.Psi.ExpectedTypes.InvocationCandidate : DeclaredElementInstance`1<IParametersOwner> {
    [CompilerGeneratedAttribute]
private bool <IsExtensionMethodInvocation>k__BackingField;
    public bool IsExtensionMethodInvocation { get; }
    public InvocationCandidate(IParametersOwner element);
    public InvocationCandidate(IParametersOwner element, ISubstitution substitution, bool isExtensionMethodInvocation);
    [CompilerGeneratedAttribute]
public bool get_IsExtensionMethodInvocation();
    [NotNullAttribute]
[PureAttribute]
public InvocationCandidate ApplySubstitution(ISubstitution substitution);
}
public class JetBrains.ReSharper.Psi.ExpectedTypes.IsEnumerableConstraint : object {
    [CompilerGeneratedAttribute]
private IPsiModule <module>P;
    [CompilerGeneratedAttribute]
private ITreeNode <context>P;
    [CompilerGeneratedAttribute]
private bool <isAsyncContext>P;
    private IReadOnlyList`1<IType> myPossibleElementTypes;
    private IExpectedTypeConstraint myCommonElementConstraint;
    public IsEnumerableConstraint(IPsiModule module, ITreeNode context, bool isAsyncContext, IReadOnlyList`1<IExpectedTypeConstraint> elementConstraints);
    public sealed virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    public sealed virtual IType GetDefaultType();
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    [NotNullAttribute]
public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
    public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
    public virtual string ToString();
    private static IReadOnlyList`1<IType> GetElementTypesFromConstraints(IReadOnlyList`1<IExpectedTypeConstraint> elementConstraints);
}
public class JetBrains.ReSharper.Psi.ExpectedTypes.IsSubtypeOfConstraint : object {
    private IType myType;
    private IType[] mySubTypes;
    private bool myInheritorsFound;
    public IsSubtypeOfConstraint(IType type);
    public sealed virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    public sealed virtual IType GetDefaultType();
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
    [NotNullAttribute]
public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
    public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.ExpectedTypes.JoinConstraint : object {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IExpectedTypeConstraint> <Constraints>k__BackingField;
    [CanBeNullAttribute]
private IType myDefaultType;
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyCollection`1<IExpectedTypeConstraint> Constraints { get; }
    private JoinConstraint(IReadOnlyCollection`1<IExpectedTypeConstraint> constraints);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<IExpectedTypeConstraint> get_Constraints();
    [NotNullAttribute]
[PureAttribute]
public static IExpectedTypeConstraint Create(IExpectedTypeConstraint constraint1, IExpectedTypeConstraint constraint2);
    [NotNullAttribute]
[PureAttribute]
public static IExpectedTypeConstraint Create(IEnumerable`1<IExpectedTypeConstraint> constraints);
    [NotNullAttribute]
public static IExpectedTypeConstraint Create(IReadOnlyList`1<ExpectedType> expectedTypes);
    public sealed virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    [NotNullAttribute]
public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    [NotNullAttribute]
public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
    public sealed virtual IType GetDefaultType();
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.ExpectedTypes.NullableTypeConstraint : object {
    [NotNullAttribute]
private IType mySystemObject;
    public NullableTypeConstraint(IPsiModule module);
    public sealed virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    public sealed virtual IType GetDefaultType();
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
    public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
}
public class JetBrains.ReSharper.Psi.ExpectedTypes.ReferenceTypeConstraint : object {
    public sealed virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
    public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    public sealed virtual IType GetDefaultType();
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
}
public class JetBrains.ReSharper.Psi.ExpectedTypes.SimpleTailType : TailType {
    private TokenNodeType[] myNodeTypes;
    public SimpleTailType(string name, TokenNodeType[] nodeTypes);
    public virtual TokenNodeType[] EvaluateTail(ISolution solution, IDocument document);
}
public abstract class JetBrains.ReSharper.Psi.ExpectedTypes.SuperTypeConstraint : object {
    [NotNullAttribute]
private IType myType;
    [NotNullAttribute]
private IType[] myBaseTypes;
    protected SuperTypeConstraint(IType type);
    [NotNullAttribute]
protected string GetPresentableName(PsiLanguageType psiLanguageType);
    public sealed virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    [NotNullAttribute]
protected abstract virtual IExpectedTypeConstraint CreateConvertibleFrom(IType type);
    [NotNullAttribute]
protected abstract virtual IExpectedTypeConstraint CreateConvertibleTo(IType type);
    [NotNullAttribute]
public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
    public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    [NotNullAttribute]
public sealed virtual IType GetDefaultType();
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    [NotNullAttribute]
public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
}
public class JetBrains.ReSharper.Psi.ExpectedTypes.TailType : EnumPattern {
    [NotNullAttribute]
public static TailType None;
    [CompilerGeneratedAttribute]
private String[] <SkipTypings>k__BackingField;
    [CanBeNullAttribute]
public String[] SkipTypings { get; public set; }
    public TailType(string name);
    private static TailType();
    [CompilerGeneratedAttribute]
public String[] get_SkipTypings();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SkipTypings(String[] value);
    [NotNullAttribute]
public virtual TokenNodeType[] EvaluateTail(ISolution solution, IDocument document);
}
public class JetBrains.ReSharper.Psi.ExpectedTypes.ValueTypeConstraint : object {
    public sealed virtual bool Accepts(IType type);
    public sealed virtual bool AcceptsWithTypeInference(IType type, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ISubstitution& inferredSubstitution);
    public sealed virtual IReadOnlyDictionary`2<ITypeParameter, IExpectedTypeConstraint> InferTypeArguments(IType typeToInfer, IReadOnlyList`1<ITypeParameter> inferrableTypeParameters);
    public sealed virtual IExpectedTypeConstraint GetConstraintForArrayElementType();
    public sealed virtual IExpectedTypeConstraint GetConstraintForDelegateReturnType(Nullable`1<int> parametersCount, ReferenceKind& returnKind);
    public sealed virtual IType GetDefaultType();
    public sealed virtual IReadOnlyList`1<IType> GetDefaultTypes();
    public sealed virtual IReadOnlyList`1<IType> GetTypesEffectively();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ExpressionTypeExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string GetLongPresentableName(IExpressionType expressionType, PsiLanguageType languageType);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string GetPresentableName(IExpressionType expressionType, PsiLanguageType languageType);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IType ToITypeOrUnknown(IExpressionType expressionType);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsImplicitlyConvertibleTo(IExpressionType expressionType, IType type, ITypeConversionRule conversionRule);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsExplicitlyConvertibleTo(IExpressionType expressionType, IType type, ITypeConversionRule conversionRule);
}
public interface JetBrains.ReSharper.Psi.ExtensionMethods.IExtensionMethodRegistry {
    [PureAttribute]
[NotNullAttribute]
public abstract virtual IExtensionMethodsQuery GetAllExtensionMethods();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Extensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use 'PsiTaskBarrier' instead")]
public static void EnqueueJobCaptureCurrentPsiContexts(ITaskBarrier taskBarrier, Action action);
    [ExtensionAttribute]
public static ReadResult`1<T> MainReadActionCaptureCurrentPsiContext(ReadAndWriteScope& scope, Func`1<T> mainReadAction);
    [ExtensionAttribute]
public static ReadResult MainReadActionCaptureCurrentPsiContext(ReadAndWriteScope& scope, Action mainReadAction);
    [ExtensionAttribute]
public static ReadResult`1<T> WriteActionCaptureCurrentPsiContext(ReadAndWriteScope& scope, Func`1<T> mainReadAction);
    [ExtensionAttribute]
public static ReadResult WriteActionCaptureCurrentPsiContext(ReadAndWriteScope& scope, Action mainReadAction);
    [ExtensionAttribute]
public static void EnqueueJob(ITaskBarrier taskBarrier, Action action, IModuleReferenceResolveContext resolveContext);
    [ExtensionAttribute]
[NotNullAttribute]
public static IModuleReferenceResolveContext GetContext(ITextControl textControl, ISolution solution);
    [ExtensionAttribute]
[NotNullAttribute]
public static IModuleReferenceResolveContext GetContext(IDocument document, ISolution solution);
    [ExtensionAttribute]
[NotNullAttribute]
public static IModuleReferenceResolveContext GetContext(IPsiFiles files, IPsiSourceFile sourceFile);
    [NotNullAttribute]
private static IModuleReferenceResolveContext GetContextFromDocument(IDocument document, ISolution solution);
    [ExtensionAttribute]
[NotNullAttribute]
public static IModuleReferenceResolveContext GetContext(IDataContext context);
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.AnonymousTypePointerBase : object {
    [CompilerGeneratedAttribute]
private IPsiModule <PsiModule>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Descriptor> <TypeDescriptor>k__BackingField;
    public IPsiModule PsiModule { get; }
    protected IList`1<Descriptor> TypeDescriptor { get; }
    protected AnonymousTypePointerBase(IAnonymousType anonymousType);
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_PsiModule();
    [CompilerGeneratedAttribute]
protected IList`1<Descriptor> get_TypeDescriptor();
    public abstract virtual IType FindType();
}
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.AttributeInstanceUtil : object {
    [NotNullAttribute]
public static IList`1<IAttributeInstance> Filter(IEnumerable`1<IAttributeInstance> attributes, IClrTypeName typeName);
    public static LocalList`1<IAttributeInstance> CollectFromSuperTypes(ITypeElement typeElement, AttributesSource attributesSource);
    public static LocalList`1<IAttributeInstance> CollectFromSuperTypes(ITypeElement typeElement, IClrTypeName typeName, AttributesSource attributesSource);
    public static LocalList`1<IAttributeInstance> CollectFromSuperTypes(ITypeElement typeElement, Func`2<ITypeElement, IList`1<IAttributeInstance>> attributesGetter, bool checkAttributeInheritance, AttributesSource attributesSource);
    public static IEnumerable`1<IAttributeInstance> CollectFromSuperMembers(IOverridableMember member, AttributesSource attributesSource);
    public static IEnumerable`1<IAttributeInstance> CollectFromSuperMembers(IOverridableMember member, IClrTypeName clrName, AttributesSource attributesSource);
    public static IEnumerable`1<IAttributeInstance> CollectFromSuperMembers(IOverridableMember member, IClrTypeName clrName, Func`2<IOverridableMember, IAttributesSet> attributesGetter, AttributesSource attributesSource);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.ExtensionsAPI.AttributeInstanceUtil/<CollectFromSuperMembers>d__7")]
public static IEnumerable`1<IAttributeInstance> CollectFromSuperMembers(IOverridableMember member, Func`2<IOverridableMember, IList`1<IAttributeInstance>> attributesGetter, AttributesSource attributesSource);
    public static bool HasAttributeInSuperMembers(IOverridableMember member, IClrTypeName clrName, AttributesSource attributesSource);
    public static bool HasAttributeInSuperMembers(IOverridableMember member, IClrTypeName clrName, Func`2<IOverridableMember, IAttributesSet> attributesGetter, AttributesSource attributesSource);
    private static bool HasAttributeInSuperMembersImpl(IOverridableMember member, IClrTypeName clrName, Func`2<IOverridableMember, IAttributesSet> attributesGetter, HashSet`1<ITypeElement> visited, AttributesSource attributesSource);
    public static bool HasAttributeInSuperTypes(ITypeElement typeElement, IClrTypeName clrName, AttributesSource attributesSource);
    public static void CollectFromSuperMemberParameters(IParameter parameter, LocalList`1& instances, Func`2<IParameter, IList`1<IAttributeInstance>> attributesGetter, AttributesSource attributesSource);
    public static bool HasAttributeInSuperMemberParameters(IParameter parameter, IClrTypeName clrName, AttributesSource attributesSource);
    private static bool IsInheritedAttribute(IAttributeInstance attributeInstance, IPsiServices psiServices);
    private static bool CanCollectFromSuperType(ITypeElement typeElement, AttributesSource attributesSource);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.ExtensionsAPI.BindableReferenceInfo : ValueType {
    [NotNullAttribute]
public IReference SourceReference;
    [NotNullAttribute]
public IResolveResult SourceResolveResult;
    [NotNullAttribute]
public IReference ClonedReference;
    public BindableReferenceInfo(IReference sourceReference, IResolveResult sourceResolveResult, IReference clonedReference);
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.CacheDeclaredElementBase : object {
    [CompilerGeneratedAttribute]
private CacheTrieNode <TrieNode>k__BackingField;
    internal CacheTrieNode TrieNode { get; internal set; }
    private CacheTrieNode JetBrains.ReSharper.Psi.Caches.SymbolCache.ICacheTrieNodeOwner.TrieNode { get; private set; }
    internal CacheDeclaredElementBase(CacheTrieNode trieNode);
    [CompilerGeneratedAttribute]
internal CacheTrieNode get_TrieNode();
    [CompilerGeneratedAttribute]
internal void set_TrieNode(CacheTrieNode value);
    private sealed virtual override CacheTrieNode JetBrains.ReSharper.Psi.Caches.SymbolCache.ICacheTrieNodeOwner.get_TrieNode();
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.SymbolCache.ICacheTrieNodeOwner.set_TrieNode(CacheTrieNode value);
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.CachedTypeMemberBase : object {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private object mySyncLock;
    [DebuggerBrowsableAttribute("0")]
[CanBeNullAttribute]
private object myNonPhysicalDeclarationOrWeakReferenceInSharedContext;
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private PsiLanguageType myOriginalDeclarationLanguage;
    [CanBeNullAttribute]
private TypeMembersBucket myBucket;
    [CanBeNullAttribute]
private ITypeElement myContainingTypeElement;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    private static ForkAttachedDataDescriptor ourWeakTypeMemberDeclarationFieldDescriptor;
    private static ForkAttachedDataDescriptor ourStrongTypeMemberDeclarationFieldDeclaration;
    [CanBeNullAttribute]
private IPsiSourceFile SourceFile { get; }
    [NotNullAttribute]
public PsiLanguageType PresentationLanguage { get; }
    [CanBeNullAttribute]
protected internal ICachedTypeMemberDeclaration WeakDeclaration { get; protected internal set; }
    [CanBeNullAttribute]
public ITypeElement ContainingType { get; }
    [NotNullAttribute]
public IPsiModule Module { get; }
    protected CachedTypeMemberBase(IDeclaration declaration);
    private static CachedTypeMemberBase();
    internal void SetBucket(TypeMembersBucket bucket);
    [CanBeNullAttribute]
public IPsiSourceFile GetSingleOrDefaultSourceFile();
    [CompilerGeneratedAttribute]
private IPsiSourceFile get_SourceFile();
    [CanBeNullAttribute]
protected ICachedTypeMemberDeclaration GetDeclaration();
    public PsiLanguageType get_PresentationLanguage();
    protected internal abstract virtual bool CanBindTo(IDeclaration declaration);
    protected internal ICachedTypeMemberDeclaration get_WeakDeclaration();
    protected internal void set_WeakDeclaration(ICachedTypeMemberDeclaration value);
    public virtual bool IsValid();
    private bool IsDeclarationValidOrNull(IPsiSourceFile sourceFile);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertIsValid();
    internal void ResetContainingTypeElement();
    internal void UpdateContainingTypeElement();
    public ITypeElement get_ContainingType();
    [CanBeNullAttribute]
public ITypeElement GetContainingType();
    [CanBeNullAttribute]
protected virtual ITypeElement GetTypeElement(IDeclaration declaration);
    [NotNullAttribute]
public virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    [NotNullAttribute]
public IPsiServices GetPsiServices();
    public IPsiModule get_Module();
    public virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    [NotNullAttribute]
public virtual IList`1<IDeclaration> GetDeclarations();
    public virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    [CanBeNullAttribute]
public sealed virtual IDeclaredElement TryTranslateToCurrentFork(IContentModelForkTranslator translator);
    public virtual Nullable`1<Hash> CalcHash();
}
internal class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.CaseInsensitiveNamespace : object {
    private HybridDistinctCollection`1<CacheTrieNode> myTrieNodes;
    private string myQualifiedName;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public string XMLDocId { get; }
    public IPsiModule Module { get; }
    public IEnumerable`1<IPsiModule> Modules { get; }
    public IReadOnlyCollection`1<ICaseSensitiveNamespace> Constituents { get; }
    public bool IsRootNamespace { get; }
    public string QualifiedName { get; }
    public bool HasNonSourceMembers { get; }
    public ISubstitution IdSubstitution { get; }
    public CaseInsensitiveNamespace(CacheTrieNode node);
    public void Register(CacheTrieNode node);
    public bool Unregister(CacheTrieNode node);
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual bool IsValid();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual string get_XMLDocId();
    public sealed virtual IPsiModule get_Module();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.CaseInsensitiveNamespace/<get_Modules>d__27")]
public sealed virtual IEnumerable`1<IPsiModule> get_Modules();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IReadOnlyCollection`1<ICaseSensitiveNamespace> get_Constituents();
    public sealed virtual bool get_IsRootNamespace();
    public sealed virtual string get_QualifiedName();
    [NotNullAttribute]
private ICollection`1<TDeclaredElement> GetNestedElementsImpl(ISymbolScope scope, bool addNamespace, bool addTypeElements);
    [NotNullAttribute]
private ICollection`1<TDeclaredElement> GetNestedElementsImpl(ISymbolScope scope, string name, bool caseSensitive, bool addNamespace, bool addTypeElements);
    private static void AddElementsFromNode(HashSet`1<TDeclaredElement> result, ISymbolScope scope, CacheTrieNode subNode, bool addNamespace, bool addTypeElements);
    public sealed virtual ICollection`1<ITypeElement> GetNestedTypeElements(ISymbolScope cache);
    public sealed virtual ICollection`1<ITypeElement> GetNestedTypeElements(ISymbolScope cache, string name, bool caseSensitive);
    public sealed virtual ICollection`1<IClrDeclaredElement> GetNestedElements(ISymbolScope cache);
    public sealed virtual ICollection`1<IClrDeclaredElement> GetNestedElements(ISymbolScope cache, string name, bool caseSensitive);
    public sealed virtual bool ForAllNestedElements(ISymbolScope symbolScope, TState state, Func`3<TState, IClrDeclaredElement, bool> processor);
    public sealed virtual bool ForAllNestedElements(ISymbolScope symbolScope, string shortName, bool caseSensitive, TState state, Func`3<TState, IClrDeclaredElement, bool> processor);
    public sealed virtual INamespace GetNestedNamespace(ISymbolScope cache, string name);
    public sealed virtual ICollection`1<INamespace> GetNestedNamespaces(ISymbolScope cache);
    public sealed virtual bool IsEmptyNamespace(ISymbolScope cache);
    [CanBeNullAttribute]
private static ICaseInsensitiveNamespace GetNamespace(CacheTrieNode node, IDeclarationsScope scope);
    public sealed virtual bool get_HasNonSourceMembers();
    [NotNullAttribute]
public sealed virtual ICaseInsensitiveNamespace TryTranslateToCurrentFork(IContentModelForkTranslator translator);
    public virtual string ToString();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual INamespace GetContainingNamespace();
    public sealed virtual ICaseInsensitiveNamespace GetCaseInsensitiveNamespace();
}
[DefaultMemberAttribute("Item")]
internal class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.CaseInsensitiveNamespaceRegistrar : object {
    private CompactMap`2<string, CaseInsensitiveNamespace> myMap;
    public CaseInsensitiveNamespace Item { get; }
    private static string NormalizeName(string s);
    public CaseInsensitiveNamespace get_Item(string s);
    public CaseInsensitiveNamespace OnNamespaceCreated(CacheTrieNode node);
    public void OnNamespaceRemoved(CacheTrieNode node);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.Class : ClassLikeTypeElement {
    public Class(IClassPart part);
    public sealed virtual IDeclaredType GetBaseClassType();
    public virtual IClass GetSuperClass();
    private bool IsSystemObjectClass();
    protected virtual LocalList`1<IDeclaredType> CalcSuperTypes();
    public virtual DeclaredElementType GetElementType();
    public virtual string ToString();
    public virtual IEnumerable`1<ITypeMember> GetMembers();
    public virtual MemberPresenceFlag GetMemberPresenceFlag();
    protected internal virtual bool AcceptsPart(TypePart part);
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ClassLikeTypeElement : TypeElement {
    [NotNullAttribute]
private static ObjectPool`1<PooledHashSet`1<IDeclaredType>> ourAddedSuperTypesPool;
    public IEnumerable`1<IField> Constants { get; }
    public IEnumerable`1<IField> Fields { get; }
    public IEnumerable`1<IConstructor> Constructors { get; }
    public IEnumerable`1<IOperator> Operators { get; }
    public IEnumerable`1<IMethod> Methods { get; }
    public IEnumerable`1<IProperty> Properties { get; }
    public IEnumerable`1<IEvent> Events { get; }
    protected ClassLikeTypeElement(IClassLikePart part);
    private static ClassLikeTypeElement();
    public virtual IEnumerable`1<IField> get_Constants();
    public virtual IEnumerable`1<IField> get_Fields();
    public virtual IEnumerable`1<IConstructor> get_Constructors();
    public virtual IEnumerable`1<IOperator> get_Operators();
    public virtual IEnumerable`1<IMethod> get_Methods();
    public virtual IEnumerable`1<IProperty> get_Properties();
    public virtual IEnumerable`1<IEvent> get_Events();
    public virtual IEnumerable`1<ITypeMember> GetMembers();
    public sealed virtual IList`1<IDeclaredType> GetSuperTypes();
    protected virtual LocalList`1<IDeclaredType> CalcSuperTypes();
    [NotNullAttribute]
protected virtual IEnumerable`1<IDeclaredType> CalcImplicitSuperTypes();
    protected internal MemberPresenceFlag GetMemberPresenceFlagByParts();
    [PureAttribute]
public virtual bool HasImplicitInstanceConstructor();
}
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.CloneableTypeElement : object {
    public static int AggregateCloneableMemberCount(TypePart firstTypePart);
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.DeclarationPart : Part {
    internal static Key`1<object> TRANSACTION_KEY;
    private TreeOffset myOffset;
    private WeaklyReferencedForkedContentModelData`1<ICachedDeclaration2> myCachedDeclaration;
    private static ForkAttachedDataDescriptor ourWeakCachedDeclarationFieldDescriptor;
    public TreeOffset Offset { get; protected set; }
    protected byte SerializationTag { get; }
    protected DeclarationPart(ICachedDeclaration2 cachedDeclaration, TreeOffset offset);
    protected DeclarationPart(IReader reader);
    private static DeclarationPart();
    protected static TreeOffset OffsetByDeclaration(ICachedDeclaration2 declaration);
    [CanBeNullAttribute]
internal CacheDeclaredElementBase GetRememberedDeclaredElement();
    protected void AssignDeclaredElement();
    protected abstract virtual void AssignDeclaredElement(ICachedDeclaration2 declaration);
    [CanBeNullAttribute]
public virtual IDeclaration GetDeclaration();
    [CanBeNullAttribute]
protected ICachedDeclaration2 TryGetValidDeclaration();
    [CanBeNullAttribute]
protected abstract virtual ICachedDeclaration2 FindDeclaration(IFile file, ICachedDeclaration2 candidateDeclaration);
    internal sealed virtual void AssignAllDeclaredElements(IFile file, IEnumeratorWithEnd`1<ICachedDeclaration2> declarations, bool bindDeclarations);
    [CanBeNullAttribute]
private ICachedDeclaration2 GetCandidate(IEnumeratorWithEnd`1<ICachedDeclaration2> declarations);
    private bool ShouldAssignDeclaration();
    public TreeOffset get_Offset();
    protected Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Offset(TreeOffset value);
    protected abstract virtual byte get_SerializationTag();
    protected internal virtual void Write(IWriter writer);
    protected void AssignToCachedDeclaration(ICachedDeclaration2 declaration, IDeclaredElement element);
    internal void ClearReferenceInDeclaration();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.Delegate : TypeElement {
    [CanBeNullAttribute]
private ITypeMember[] modreq(System.Runtime.CompilerServices.IsVolatile) myMembers;
    [CanBeNullAttribute]
private IMethod modreq(System.Runtime.CompilerServices.IsVolatile) myInvokeMethod;
    public IEnumerable`1<IConstructor> Constructors { get; }
    public IEnumerable`1<IEvent> Events { get; }
    public IMethod InvokeMethod { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public IEnumerable`1<IField> Constants { get; }
    public IEnumerable`1<IField> Fields { get; }
    public IEnumerable`1<IMethod> Methods { get; }
    public IEnumerable`1<IOperator> Operators { get; }
    public IEnumerable`1<IProperty> Properties { get; }
    public Delegate(IDelegatePart part);
    public virtual IEnumerable`1<IConstructor> get_Constructors();
    public virtual IEnumerable`1<IEvent> get_Events();
    public virtual MemberPresenceFlag GetMemberPresenceFlag();
    public virtual DeclaredElementType GetElementType();
    public virtual IEnumerable`1<ITypeMember> GetMembers();
    public sealed virtual IMethod get_InvokeMethod();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public virtual bool HasMemberWithName(string shortName, bool ignoreCase);
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual IList`1<IDeclaredType> GetSuperTypes();
    public virtual IEnumerable`1<IField> get_Constants();
    public virtual IEnumerable`1<IField> get_Fields();
    public virtual IEnumerable`1<IMethod> get_Methods();
    public virtual IEnumerable`1<IOperator> get_Operators();
    public virtual IEnumerable`1<IProperty> get_Properties();
    protected internal virtual bool AcceptsPart(TypePart part);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.Enum : TypeElement {
    public IEnumerable`1<IField> EnumMembers { get; }
    public IEnumerable`1<IField> Constants { get; }
    public IEnumerable`1<IField> Fields { get; }
    public IEnumerable`1<IConstructor> Constructors { get; }
    public IEnumerable`1<IMethod> Methods { get; }
    public IEnumerable`1<IProperty> Properties { get; }
    public IEnumerable`1<IOperator> Operators { get; }
    public IEnumerable`1<IEvent> Events { get; }
    public Enum(IEnumPart part);
    public virtual string ToString();
    public sealed virtual IType GetUnderlyingType();
    public virtual IList`1<IDeclaredType> GetSuperTypes();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.Enum/<get_EnumMembers>d__5")]
public sealed virtual IEnumerable`1<IField> get_EnumMembers();
    public virtual IEnumerable`1<ITypeMember> GetMembers();
    public virtual IEnumerable`1<IField> get_Constants();
    public virtual IEnumerable`1<IField> get_Fields();
    public virtual IEnumerable`1<IConstructor> get_Constructors();
    public virtual IEnumerable`1<IMethod> get_Methods();
    public virtual IEnumerable`1<IProperty> get_Properties();
    public virtual IEnumerable`1<IOperator> get_Operators();
    public virtual IEnumerable`1<IEvent> get_Events();
    public virtual MemberPresenceFlag GetMemberPresenceFlag();
    public virtual DeclaredElementType GetElementType();
    protected internal virtual bool AcceptsPart(TypePart part);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.AdditionalQueries : object {
    [ExtensionAttribute]
public static IEnumerable`1<IExtensionMemberProxy> Lookup(IExtensionMembersIndex index, IType type, bool isCaseSensitive);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.AnyCandidateType : ArrayElementCandidateType {
    [NotNullAttribute]
public static AnyCandidateType INSTANCE;
    public CandidateTypeKind Kind { get; }
    private static AnyCandidateType();
    public virtual CandidateTypeKind get_Kind();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.ArrayCandidateType : CandidateType {
    private ArrayElementCandidateType myElementType;
    public ArrayElementCandidateType ElementType { get; }
    public CandidateTypeKind Kind { get; }
    public ArrayCandidateType(ArrayElementCandidateType elementType);
    public ArrayCandidateType(IReader reader);
    public ArrayElementCandidateType get_ElementType();
    public virtual CandidateTypeKind get_Kind();
    public virtual void Write(IWriter writer);
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.ArrayElementCandidateType : CandidateType {
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.CandidateType : object {
    public CandidateTypeKind Kind { get; }
    public abstract virtual CandidateTypeKind get_Kind();
    public virtual void Write(IWriter writer);
    [NotNullAttribute]
public static CandidateType Read(IReader reader);
    public abstract virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.CandidateTypeKind : Enum {
    public byte value__;
    public static CandidateTypeKind ANY;
    public static CandidateTypeKind DECLARED;
    public static CandidateTypeKind ARRAY;
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.CompiledCandidateType : ValueType {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsArray>k__BackingField;
    [CanBeNullAttribute]
public string TypeName { get; }
    public bool IsArray { get; }
    public CompiledCandidateType(string typeName, bool isArray);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public bool get_IsArray();
}
internal class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.CompiledExtensionMembersIndex : ExtensionMembersIndex`2<CompiledCandidateType, ICompiledExtensionMemberProxy> {
    protected virtual bool TryGetCandidateType(ICompiledExtensionMemberProxy methodRepr, CompiledCandidateType& typeRepr);
    protected virtual bool IsAny(CompiledCandidateType type);
    protected virtual bool IsArray(CompiledCandidateType type);
    protected virtual IEnumerable`1<string> PossibleTypes(CompiledCandidateType type);
    protected virtual string GetTypeName(ITypeElement element);
    protected virtual CompiledCandidateType GetElementRepr(CompiledCandidateType type);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.DeclaredCandidateType : ArrayElementCandidateType {
    private String[] myPossibleNames;
    [NotNullAttribute]
public IEnumerable`1<string> PossibleNames { get; }
    public CandidateTypeKind Kind { get; }
    public DeclaredCandidateType(IEnumerable`1<string> possibleNames);
    public DeclaredCandidateType(FrugalLocalHashSet`1& possibleNames);
    public DeclaredCandidateType(IReader reader);
    public DeclaredCandidateType(string possibleName);
    public IEnumerable`1<string> get_PossibleNames();
    public virtual CandidateTypeKind get_Kind();
    public virtual void Write(IWriter writer);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.EmptyExtensionMembersIndex : object {
    [NotNullAttribute]
public static EmptyExtensionMembersIndex INSTANCE;
    private static EmptyExtensionMembersIndex();
    public sealed virtual IEnumerable`1<IExtensionMemberProxy> Lookup(ITypeElement typeElement, bool arrayType);
    public sealed virtual IEnumerable`1<IExtensionMemberProxy> Lookup(string shortName, ITypeElement typeElement, bool isArray, bool isCaseSensitive);
    public sealed virtual IEnumerable`1<IExtensionMemberProxy> Lookup();
    public sealed virtual bool HasExtensionMembers(string name, bool caseSensitive, ExtensionMemberKind kind);
    public sealed virtual IEnumerable`1<IExtensionMemberProxy> Lookup(string name);
    public sealed virtual IEnumerable`1<string> GetNames(bool isCaseSensitive);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.ExtensionMemberInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private CandidateType <CandidateType>k__BackingField;
    [CompilerGeneratedAttribute]
private TypePart <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionMemberKind <Kind>k__BackingField;
    public string ShortName { get; }
    public IPsiModule PsiModule { get; }
    public int Hash { get; }
    [NotNullAttribute]
public CandidateType CandidateType { get; }
    [NotNullAttribute]
private TypePart Owner { get; }
    public ExtensionMemberKind Kind { get; }
    public ExtensionMemberInfo(CandidateType candidateType, int hash, string shortName, ExtensionMemberKind kind, TypePart owner);
    public ExtensionMemberInfo(IReader reader, ExtensionMemberKind kind, TypePart owner);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ShortName();
    public sealed virtual IPsiModule get_PsiModule();
    [CompilerGeneratedAttribute]
public int get_Hash();
    [CompilerGeneratedAttribute]
public CandidateType get_CandidateType();
    [CompilerGeneratedAttribute]
private TypePart get_Owner();
    public virtual string ToString();
    public sealed virtual IPsiSourceFile TryGetSourceFile();
    public sealed virtual HybridCollection`1<ITypeMember> FindExtensionMember();
    public void Write(IWriter writer);
    [CompilerGeneratedAttribute]
public sealed virtual ExtensionMemberKind get_Kind();
    public sealed virtual bool Equals(ExtensionMemberInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.ExtensionMemberKind : EnumPattern {
    public static ExtensionMemberKind ExtensionMethod;
    public static ExtensionMemberKind ExtensionProperty;
    public ExtensionMemberKind(string name);
    private static ExtensionMemberKind();
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.ExtensionMembersIndex`2 : object {
    [NotNullAttribute]
private OneToSetMap`2<string, TMemberRepr> myMembersOfAllTypes;
    [NotNullAttribute]
private OneToSetMap`2<string, TMemberRepr> myMembersOfAllArrays;
    [NotNullAttribute]
private Dictionary`2<string, OneToSetMap`2<string, TMemberRepr>> myMembersOfDeclaredType;
    [NotNullAttribute]
private Dictionary`2<string, OneToSetMap`2<string, TMemberRepr>> myMembersOfSpecificArray;
    [NotNullAttribute]
private OneToListMap`2<string, ExtensionsCount<TTypeRepr, TMemberRepr>> myExtensionMemberCounts;
    public bool IsEmpty { get; }
    protected abstract virtual bool TryGetCandidateType(TMemberRepr methodRepr, TTypeRepr& typeRepr);
    public bool get_IsEmpty();
    private void Dispatch(TMemberRepr member, TTypeRepr candidateType, bool doRegister);
    private void DispatchToCollection(TMemberRepr member, TTypeRepr candidateType, OneToSetMap`2<string, TMemberRepr> allCollection, Dictionary`2<string, OneToSetMap`2<string, TMemberRepr>> declaredCollection, bool doRegister);
    protected abstract virtual bool IsAny(TTypeRepr type);
    [NotNullAttribute]
protected abstract virtual IEnumerable`1<string> PossibleTypes(TTypeRepr type);
    public sealed virtual IEnumerable`1<IExtensionMemberProxy> Lookup(string shortName, ITypeElement typeElement, bool arrayType, bool isCaseSensitive);
    public sealed virtual IEnumerable`1<IExtensionMemberProxy> Lookup(ITypeElement typeElement, bool arrayType);
    public sealed virtual IEnumerable`1<IExtensionMemberProxy> Lookup();
    public sealed virtual IEnumerable`1<IExtensionMemberProxy> Lookup(string name);
    public sealed virtual IEnumerable`1<string> GetNames(bool isCaseSensitive);
    [NotNullAttribute]
private IEnumerable`1<OneToSetMap`2<string, TMemberRepr>> LookupAllTables();
    [NotNullAttribute]
private IEnumerable`1<OneToSetMap`2<string, TMemberRepr>> LookupTables(ITypeElement typeElement, bool isArray);
    public void Add(TMemberRepr info);
    public void Remove(TMemberRepr info);
    private void RegisterExtensionMember(OneToSetMap`2<string, TMemberRepr> registry, TMemberRepr extensionMember);
    private void UnregisterExtensionMember(OneToSetMap`2<string, TMemberRepr> registry, TMemberRepr extensionMember);
    [NotNullAttribute]
protected abstract virtual string GetTypeName(ITypeElement element);
    protected abstract virtual bool IsArray(TTypeRepr type);
    protected abstract virtual TTypeRepr GetElementRepr(TTypeRepr type);
    public sealed virtual bool HasExtensionMembers(string name, bool caseSensitive, ExtensionMemberKind kind);
    protected virtual void CollectPossibleNames(ITypeElement typeElement, List`1<string> consumer);
}
public enum JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.ExtensionMethodAccessibility : Enum {
    public int value__;
    public static ExtensionMethodAccessibility Accessible;
    public static ExtensionMethodAccessibility AccessibleWithReference;
    public static ExtensionMethodAccessibility NotAccessible;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.ExtensionMethodsOfNamespace : object {
    private static HybridCollection`1<Namespace> GetConstitutients(INamespace namespace);
    [ExtensionAttribute]
public static void FillExtensionMethods(INamespace namespace, LocalList`1& result);
    [ExtensionAttribute]
public static IEnumerable`1<IExtensionMembersIndex> CompiledExtensionMethods(INamespace namespace);
    [ExtensionAttribute]
public static IEnumerable`1<IExtensionMembersIndex> SourceExtensionMethods(INamespace namespace);
    [ExtensionAttribute]
public static int Depth(INamespace namespace);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.ICompiledExtensionMemberProxy {
    public abstract virtual bool GetExtendedTypePattern(CompiledCandidateType& candidateType);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.IExtensionMemberProxy {
    [NotNullAttribute]
public string ShortName { get; }
    [NotNullAttribute]
public IPsiModule PsiModule { get; }
    public ExtensionMemberKind Kind { get; }
    public abstract virtual string get_ShortName();
    public abstract virtual IPsiModule get_PsiModule();
    [CanBeNullAttribute]
public abstract virtual IPsiSourceFile TryGetSourceFile();
    public abstract virtual HybridCollection`1<ITypeMember> FindExtensionMember();
    public abstract virtual ExtensionMemberKind get_Kind();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.IExtensionMembersIndex {
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IExtensionMemberProxy> Lookup();
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IExtensionMemberProxy> Lookup(string name);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IExtensionMemberProxy> Lookup(ITypeElement typeElement, bool arrayType);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IExtensionMemberProxy> Lookup(string shortName, ITypeElement typeElement, bool arrayType, bool isCaseSensitive);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<string> GetNames(bool isCaseSensitive);
    [PureAttribute]
public abstract virtual bool HasExtensionMembers(string name, bool caseSensitive, ExtensionMemberKind kind);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.Queries.ApplicableToTypeQuery : object {
    [NotNullAttribute]
private IExtensionMethodsQuery myBaseQuery;
    [NotNullAttribute]
private IType myExpressionType;
    [NotNullAttribute]
private PsiLanguageType myLanguage;
    [NotNullAttribute]
private ITypeConversionRule myConversionRule;
    [NotNullAttribute]
private ITypeConstraintsVerifier myTypeConstraintsVerifier;
    internal ApplicableToTypeQuery(IExtensionMethodsQuery baseQuery, IType expressionType, PsiLanguageType language, ITypeConversionRule conversionRule, ITypeConstraintsVerifier typeConstraintsVerifier);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.Queries.ApplicableToTypeQuery/<EnumerateMethods>d__6")]
public sealed virtual IEnumerable`1<IMethod> EnumerateMethods();
    [PureAttribute]
private bool IsApplicableGenericExtensionMethod(IType thisParameterType, IMethod method, ParameterKind thisParameterKind);
    [PureAttribute]
private bool IsApplicableGenericExtensionMethod(IType expressionType, IType thisParameterType, IReadOnlyCollection`1<ITypeParameter> typeParameters, ParameterKind thisParameterKind);
    public sealed virtual IEnumerable`1<string> GetAllExtensionNames();
    public sealed virtual bool HasExtensionMethods(string name, bool caseSensitive);
    public sealed virtual IExtensionMethodsQuery ByName(string name, bool caseSensitive);
    public sealed virtual IExtensionMethodsQuery OfExpressionType(IType expressionType);
    public sealed virtual IExtensionMethodsQuery ForModule(IPsiModule psiModule);
    public sealed virtual IExtensionMethodsQuery OfNamespaces(IReadOnlyList`1<INamespace> namespaces);
    public sealed virtual IExtensionMethodsQuery OfTypes(IReadOnlyList`1<ITypeElement> types);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.Queries.ClrRequest : object {
    public static IRequest Empty;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ExpressionType>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModule <ForModule>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<INamespace> <Namespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ITypeElement> <Types>k__BackingField;
    public string Name { get; }
    public IType ExpressionType { get; }
    public IPsiModule ForModule { get; }
    public IReadOnlyList`1<INamespace> Namespaces { get; }
    public IReadOnlyList`1<ITypeElement> Types { get; }
    public bool IsCaseSensitive { get; }
    public IReadOnlyList`1<IType> BaseExpressionTypes { get; }
    private ClrRequest(string name, IType expressionType, IReadOnlyList`1<INamespace> namespaces, IReadOnlyList`1<ITypeElement> types, IPsiModule forModule);
    private static ClrRequest();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_ExpressionType();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_ForModule();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<INamespace> get_Namespaces();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<ITypeElement> get_Types();
    public sealed virtual bool get_IsCaseSensitive();
    public sealed virtual IReadOnlyList`1<IType> get_BaseExpressionTypes();
    public sealed virtual IRequest WithName(string newName);
    public sealed virtual IRequest WithExpressionType(IType newType);
    public sealed virtual IRequest WithModule(IPsiModule psiModule);
    public sealed virtual IRequest WithNamespaces(IReadOnlyList`1<INamespace> newNamespaces);
    public sealed virtual IRequest WithTypes(IReadOnlyList`1<ITypeElement> newTypes);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.Queries.EmptyExtensionMethodsQuery : object {
    [NotNullAttribute]
public static IExtensionMethodsQuery INSTANCE;
    private static EmptyExtensionMethodsQuery();
    public sealed virtual IEnumerable`1<string> GetAllExtensionNames();
    public sealed virtual bool HasExtensionMethods(string name, bool caseSensitive);
    public sealed virtual IExtensionMethodsQuery ByName(string name, bool caseSensitive);
    public sealed virtual IExtensionMethodsQuery OfExpressionType(IType expressionType);
    public sealed virtual IExtensionMethodsQuery ForModule(IPsiModule psiModule);
    public sealed virtual IExtensionMethodsQuery OfNamespaces(IReadOnlyList`1<INamespace> namespaces);
    public sealed virtual IExtensionMethodsQuery OfTypes(IReadOnlyList`1<ITypeElement> types);
    public sealed virtual IEnumerable`1<IMethod> EnumerateMethods();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.Queries.ExtensionMethodQueryExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IExtensionMethodsQuery FilterBy(IExtensionMethodsQuery query, Func`2<IMethod, bool> predicate);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IExtensionMethodsQuery CandidatesApplicableForType(IExtensionMethodsQuery query, IType expressionType, PsiLanguageType language, ITypeConversionRule conversionRule, ITypeConstraintsVerifier typeConstraintsVerifier);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IExtensionMethodsQuery OfNamespace(IExtensionMethodsQuery query, INamespace nameSpace);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IExtensionMethodsQuery OfType(IExtensionMethodsQuery query, ITypeElement typeElement);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.Queries.ExtensionMethodsQuery : object {
    [NotNullAttribute]
private IPsiServices myPsiServices;
    [NotNullAttribute]
private IRequest myRequest;
    public ExtensionMethodsQuery(IPsiServices psiServices, IRequest request);
    public sealed virtual IExtensionMethodsQuery ByName(string name, bool caseSensitive);
    public sealed virtual IExtensionMethodsQuery OfExpressionType(IType expressionType);
    public sealed virtual IExtensionMethodsQuery ForModule(IPsiModule psiModule);
    public sealed virtual IExtensionMethodsQuery OfNamespaces(IReadOnlyList`1<INamespace> namespaces);
    public sealed virtual IExtensionMethodsQuery OfTypes(IReadOnlyList`1<ITypeElement> types);
    public sealed virtual IEnumerable`1<IMethod> EnumerateMethods();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.Queries.ExtensionMethodsQuery/<EnumerateExtensionMethodsFromIndexes>d__9")]
private IEnumerable`1<IMethod> EnumerateExtensionMethodsFromIndexes();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.Queries.ExtensionMethodsQuery/<EnumerableExtensionMethodsUnderTransaction>d__10")]
private IEnumerable`1<IMethod> EnumerableExtensionMethodsUnderTransaction();
    [PureAttribute]
private IDeclarationsScope GetRequestForModuleScope();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.Queries.ExtensionMethodsQuery/<EnumerateExtensionMethodsFromSourceFile>d__12")]
private IEnumerable`1<IMethod> EnumerateExtensionMethodsFromSourceFile(IPsiSourceFile sourceFile);
    public sealed virtual bool HasExtensionMethods(string name, bool caseSensitive);
    public sealed virtual IEnumerable`1<string> GetAllExtensionNames();
    private LocalList`1<IExtensionMembersIndex> GetExtensionMethodIndexes();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.Queries.ExtensionMethodsQuery/<EnumerateExtensionMethodsOfRequestedTypes>d__16")]
[PureAttribute]
[NotNullAttribute]
private IEnumerable`1<IMethod> EnumerateExtensionMethodsOfRequestedTypes(string name, bool isCaseSensitive);
    [NotNullAttribute]
private IEnumerable`1<IExtensionMemberProxy> EnumerateMethodsFromIndex(IExtensionMembersIndex extensionMembersIndex);
    [NotNullAttribute]
private IEnumerable`1<IExtensionMemberProxy> EnumerateForBaseExpressionTypes(IEnumerable`1<IType> baseTypes, IExtensionMembersIndex index, string caseSensitiveName);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.Queries.FilteringQuery : object {
    [NotNullAttribute]
private IExtensionMethodsQuery myBaseQuery;
    [NotNullAttribute]
private Func`2<IMethod, bool> myPredicate;
    internal FilteringQuery(IExtensionMethodsQuery baseQuery, Func`2<IMethod, bool> predicate);
    public sealed virtual IEnumerable`1<IMethod> EnumerateMethods();
    public sealed virtual IEnumerable`1<string> GetAllExtensionNames();
    public sealed virtual bool HasExtensionMethods(string name, bool caseSensitive);
    public sealed virtual IExtensionMethodsQuery ByName(string name, bool caseSensitive);
    public sealed virtual IExtensionMethodsQuery OfExpressionType(IType expressionType);
    public sealed virtual IExtensionMethodsQuery ForModule(IPsiModule psiModule);
    public sealed virtual IExtensionMethodsQuery OfNamespaces(IReadOnlyList`1<INamespace> namespaces);
    public sealed virtual IExtensionMethodsQuery OfTypes(IReadOnlyList`1<ITypeElement> types);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.Queries.IExtensionMethodsQuery {
    [NotNullAttribute]
public abstract virtual IEnumerable`1<string> GetAllExtensionNames();
    [PureAttribute]
public abstract virtual bool HasExtensionMethods(string name, bool caseSensitive);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IExtensionMethodsQuery ByName(string name, bool caseSensitive);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IExtensionMethodsQuery OfExpressionType(IType expressionType);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IExtensionMethodsQuery ForModule(IPsiModule psiModule);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IExtensionMethodsQuery OfNamespaces(IReadOnlyList`1<INamespace> namespaces);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IExtensionMethodsQuery OfTypes(IReadOnlyList`1<ITypeElement> types);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IMethod> EnumerateMethods();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.Queries.IRequest {
    [CanBeNullAttribute]
public string Name { get; }
    public bool IsCaseSensitive { get; }
    [CanBeNullAttribute]
public IPsiModule ForModule { get; }
    [CanBeNullAttribute]
public IType ExpressionType { get; }
    [NotNullAttribute]
public IReadOnlyList`1<IType> BaseExpressionTypes { get; }
    [NotNullAttribute]
public IReadOnlyList`1<INamespace> Namespaces { get; }
    [NotNullAttribute]
public IReadOnlyList`1<ITypeElement> Types { get; }
    public abstract virtual string get_Name();
    public abstract virtual bool get_IsCaseSensitive();
    public abstract virtual IPsiModule get_ForModule();
    public abstract virtual IType get_ExpressionType();
    public abstract virtual IReadOnlyList`1<IType> get_BaseExpressionTypes();
    public abstract virtual IReadOnlyList`1<INamespace> get_Namespaces();
    public abstract virtual IReadOnlyList`1<ITypeElement> get_Types();
    [NotNullAttribute]
public abstract virtual IRequest WithName(string newName);
    [NotNullAttribute]
public abstract virtual IRequest WithExpressionType(IType newType);
    [NotNullAttribute]
public abstract virtual IRequest WithModule(IPsiModule psiModule);
    [NotNullAttribute]
public abstract virtual IRequest WithNamespaces(IReadOnlyList`1<INamespace> newNamespaces);
    [NotNullAttribute]
public abstract virtual IRequest WithTypes(IReadOnlyList`1<ITypeElement> newTypes);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.SourceExtensionMembersIndex : ExtensionMembersIndex`2<CandidateType, ExtensionMemberInfo> {
    protected virtual bool TryGetCandidateType(ExtensionMemberInfo memberRepr, CandidateType& typeRepr);
    protected virtual bool IsAny(CandidateType type);
    protected virtual bool IsArray(CandidateType type);
    protected virtual CandidateType GetElementRepr(CandidateType type);
    protected virtual IEnumerable`1<string> PossibleTypes(CandidateType type);
    protected virtual string GetTypeName(ITypeElement element);
    public virtual void AddPsiModule(IPsiModule psiModule);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICacheBuilder {
    public abstract virtual void CreateProjectFilePart(ProjectFilePart projectFilePart);
    public abstract virtual void StartPart(Part part);
    public abstract virtual void EndPart();
    public abstract virtual void AddDeclaredMemberName(string name);
    public abstract virtual void AddImplicitMemberName(string name);
    public abstract virtual string Intern(string str);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedDeclaration2 {
    public IDeclaredElement CacheDeclaredElement { get; public set; }
    public abstract virtual IDeclaredElement get_CacheDeclaredElement();
    public abstract virtual void set_CacheDeclaredElement(IDeclaredElement value);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICachedTypeMemberDeclaration {
    public IDeclaredElement CachedDeclaredElement { get; public set; }
    public abstract virtual IDeclaredElement get_CachedDeclaredElement();
    public abstract virtual void set_CachedDeclaredElement(IDeclaredElement value);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ICloneableTypeElementPart {
    public int CloneableMemberCount { get; }
    public abstract virtual int get_CloneableMemberCount();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ILanguageCacheInvalidator {
    public abstract virtual bool NeedCacheUpdate(ITreeNode elementContainingChanges, PsiChangedElementType type);
    public abstract virtual IEnumerable`1<IPsiSourceFile> GetAffectedOnPsiModulePropertiesChange(IPsiModule module);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ILanguageCacheProvider {
    public abstract virtual bool IsCaseSensitive(IPsiModule module);
    public abstract virtual void BuildCache(IFile file, ICacheBuilder builder);
    public abstract virtual void BuildCache(ISandBox sandBox, ICacheBuilder builder);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ILanguageTreeNodeCacheProvider {
    public string TokenCacheUniqueId { get; }
    public string BufferCacheUniqueId { get; }
    public string TreeNodeCacheUniqueId { get; }
    public int NodeTypeCommonShift { get; }
    public abstract virtual string get_TokenCacheUniqueId();
    public abstract virtual string get_BufferCacheUniqueId();
    public abstract virtual string get_TreeNodeCacheUniqueId();
    [PureAttribute]
public abstract virtual bool IsShrinkableTreeNode(int childNodeTypeIndex);
    [PureAttribute]
public abstract virtual NodeType GetNodeType(int index);
    public abstract virtual Dictionary`2<int, TokenNodeType> GetIndexToTokenNodeTypeDictionary();
    public abstract virtual Dictionary`2<int, NodeType> GetIndexToNodeTypeDictionary();
    public abstract virtual NodeTypeDictionary`1<int> GetFixedTokenLengthsDictionary();
    public abstract virtual int get_NodeTypeCommonShift();
    [PureAttribute]
public abstract virtual bool IsCacheableInClosedForm(IChameleonNode node);
    [PureAttribute]
public abstract virtual TreeElement CreateClosedChameleonNode(NodeType nodeType, int textLength);
    [PureAttribute]
public abstract virtual TreeElement CreateOpenedChameleonNode(NodeType nodeType);
    public abstract virtual void SerializeMetadata(IFile file, UnsafeWriter bufferWriter);
    public abstract virtual void RestoreMetadata(IFile file, UnsafeReader bufferReader);
    public abstract virtual bool IsInternableToken(TokenNodeType tokenNodeType);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.Interface : ClassLikeTypeElement {
    protected MemberDecoration Modifiers { get; }
    public Interface(IInterfacePart part);
    protected virtual LocalList`1<IDeclaredType> CalcSuperTypes();
    protected virtual MemberDecoration get_Modifiers();
    public virtual string ToString();
    public virtual IEnumerable`1<ITypeMember> GetMembers();
    public virtual MemberPresenceFlag GetMemberPresenceFlag();
    public virtual DeclaredElementType GetElementType();
    protected internal virtual bool AcceptsPart(TypePart part);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.IPartReader {
    [NotNullAttribute]
public abstract virtual Part ReadPart(byte tag, IReader reader);
    [NotNullAttribute]
public abstract virtual ProjectFilePart LoadProjectFilePart(IPsiSourceFile sourceFile, ProjectFilePartsTree tree, IReader reader);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.IReader {
    public abstract virtual PsiLanguageType ReadLanguageType();
    public abstract virtual int ReadInt();
    public abstract virtual int ReadOftenSmallPositiveInt();
    public abstract virtual ushort ReadUShort();
    public abstract virtual byte ReadByte();
    public abstract virtual bool ReadBool();
    public abstract virtual string ReadString();
    public abstract virtual String[] ReadStringArray();
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.IWriter {
    public abstract virtual void WriteLanguageType(PsiLanguageType languageType);
    public abstract virtual void WriteInt(int value);
    public abstract virtual void WriteOftenSmallPositiveInt(int value);
    public abstract virtual void WriteUShort(ushort value);
    public abstract virtual void WriteByte(byte value);
    public abstract virtual void WriteBool(bool value);
    public abstract virtual void WriteString(string value);
    public abstract virtual void WriteStringArray(String[] array);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.Namespace : CacheDeclaredElementBase {
    private CaseInsensitiveNamespaceRegistrar myCaseInsensitiveNamespaceRegistrar;
    private OneToSetMap`2<IPsiModule, NamespacePart> myDeclarations;
    private HybridDistinctCollection`1<NamespacePart> myNonphysicalDeclarations;
    private JetHashSet`1<IPsiAssemblyFile> myAssemblies;
    [CanBeNullAttribute]
private Dictionary`2<PsiLanguageType, SourceExtensionMembersIndex> mySourceExtensionMethodsIndex;
    [CanBeNullAttribute]
private CompiledExtensionMembersIndex myCompiledExtensionMembersIndex;
    private CaseInsensitiveNamespace myCaseInsensitiveNamespace;
    private static Func`2<IClrDeclaredElement, bool> NestedElementsPredicate;
    public ISubstitution IdSubstitution { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public IEnumerable`1<IPsiModule> Modules { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public string XMLDocId { get; }
    public IPsiModule Module { get; }
    public bool IsRootNamespace { get; }
    public string QualifiedName { get; }
    public bool HasNonSourceMembers { get; }
    public ICaseInsensitiveNamespace CaseInsensitiveNamespace { get; }
    [CanBeNullAttribute]
public IExtensionMembersIndex CompiledExtensionMembers { get; }
    [NotNullAttribute]
public IEnumerable`1<IExtensionMembersIndex> SourceExtensionMethods { get; }
    internal Namespace(CacheTrieNode node, CaseInsensitiveNamespaceRegistrar caseInsensitiveNamespaceRegistrar);
    private static Namespace();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.Namespace/<get_Modules>d__15")]
public sealed virtual IEnumerable`1<IPsiModule> get_Modules();
    public sealed virtual INamespace GetNestedNamespace(ISymbolScope cache, string name);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual string get_XMLDocId();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual IPsiModule get_Module();
    public sealed virtual ICollection`1<INamespace> GetNestedNamespaces(ISymbolScope cache);
    public sealed virtual ICollection`1<ITypeElement> GetNestedTypeElements(ISymbolScope cache);
    public sealed virtual ICollection`1<ITypeElement> GetNestedTypeElements(ISymbolScope cache, string shortName, bool caseSensitive);
    public sealed virtual ICollection`1<IClrDeclaredElement> GetNestedElements(ISymbolScope cache);
    public sealed virtual bool ForAllNestedElements(ISymbolScope symbolScope, TState state, Func`3<TState, IClrDeclaredElement, bool> processor);
    public sealed virtual bool ForAllNestedElements(ISymbolScope symbolScope, string shortName, bool caseSensitive, TState state, Func`3<TState, IClrDeclaredElement, bool> processor);
    public sealed virtual ICollection`1<IClrDeclaredElement> GetNestedElements(ISymbolScope cache, string shortName, bool caseSensitive);
    public sealed virtual bool IsEmptyNamespace(ISymbolScope cache);
    public sealed virtual bool get_IsRootNamespace();
    public sealed virtual string get_QualifiedName();
    public sealed virtual bool get_HasNonSourceMembers();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public void AddPart(NamespacePart part);
    public void RemovePart(NamespacePart part);
    private void RemoveFromTriePossibly();
    public void Resurrect(CacheTrieNode node);
    internal void CheckConsistency();
    [NotNullAttribute]
public sealed virtual INamespace TryTranslateToCurrentFork(IContentModelForkTranslator translator);
    public virtual string ToString();
    internal void RegisterCompiledFile(AssemblyPsiFile file);
    internal void UnregisterCompiledFile(AssemblyPsiFile file);
    public sealed virtual ICaseInsensitiveNamespace get_CaseInsensitiveNamespace();
    public IExtensionMembersIndex get_CompiledExtensionMembers();
    public IEnumerable`1<IExtensionMembersIndex> get_SourceExtensionMethods();
    public sealed virtual INamespace GetContainingNamespace();
    public sealed virtual ICaseInsensitiveNamespace GetCaseInsensitiveNamespace();
    public void AddExtensionMethods(TypePart part);
    public void RemoveExtensionMethods(TypePart part);
    public void AddExtensionMethods(ICompiledTypeElement element);
    public void RemoveExtensionMethods(ICompiledTypeElement element);
    [CompilerGeneratedAttribute]
internal static bool <ForAllNestedElements>g__Consumer|39_1(ValueTuple`2<TState, Func`3<TState, IClrDeclaredElement, bool>> context, IClrDeclaredElement declaredElement);
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.NamespacePart : DeclarationPart {
    private string myShortName;
    private INamespace myNamespace;
    public string ShortName { get; }
    public INamespace Namespace { get; internal set; }
    protected NamespacePart(ICachedDeclaration2 declaration, TreeOffset offset, string shortName);
    protected NamespacePart(IReader reader);
    public string get_ShortName();
    public INamespace get_Namespace();
    internal void set_Namespace(INamespace value);
    protected virtual void AssignDeclaredElement(ICachedDeclaration2 declaration);
    protected internal virtual void Write(IWriter writer);
    public void Unbind();
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.Part : object {
    protected static ILogger ourLogger;
    internal PartsTree myOwner;
    internal ushort myDepth;
    public PsiLanguageType LanguageType { get; }
    public Part Parent { get; }
    private static Part();
    protected internal abstract virtual void Write(IWriter writer);
    public IPsiModule GetPsiModule();
    [CanBeNullAttribute]
public virtual IFile GetFile();
    [CanBeNullAttribute]
public IPsiSourceFile GetSourceFile();
    public PsiLanguageType get_LanguageType();
    internal virtual void AssignAllDeclaredElements(IFile file, IEnumeratorWithEnd`1<ICachedDeclaration2> declarations, bool bindDeclarations);
    [NotNullAttribute]
public Part GetRoot();
    public Part get_Parent();
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<Part> Children();
    public virtual void BuildStub(StringBuilder text, Func`2<Part, IEnumerable`1<Part>> childrenSelector, Dictionary`2<int, Pair`2<DeclarationPart, IDeclaredElement>> offsetMap);
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.PartsTree : object {
    [NotNullAttribute]
[ItemNotNullAttribute]
protected Part[] myParts;
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    public IPsiModule Module { get; }
    [NotNullAttribute]
public PsiLanguageType LanguageType { get; }
    internal IList`1<Part> AllParts { get; }
    [NotNullAttribute]
public Part Root { get; }
    public bool HasRoot { get; }
    protected PartsTree(PsiLanguageType languageType);
    public abstract virtual IPsiModule get_Module();
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    internal IList`1<Part> get_AllParts();
    public Part get_Root();
    public bool get_HasRoot();
    internal void AppendChild(Part parent, Part child);
    [CanBeNullAttribute]
internal Part GetParentOf(Part child);
    internal IEnumerable`1<Part> GetChildrenOf(Part parent);
}
public enum JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.PartType : Enum {
    public int value__;
    public static PartType TYPE;
    public static PartType NAMESPACE;
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ProjectFilePart : Part {
    private IPsiSourceFile mySourceFile;
    public IPsiSourceFile SourceFile { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public String[] AttributeClassNames { get; }
    protected ProjectFilePart(IPsiSourceFile sourceFile);
    protected ProjectFilePart(IPsiSourceFile sourceFile, IReader reader);
    public IPsiSourceFile get_SourceFile();
    public virtual IFile GetFile();
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IList`1<IAttributeInstance> GetAttributeInstances();
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName);
    public abstract virtual String[] get_AttributeClassNames();
    internal void AssignDeclaredElements(IFile psiFile, IEnumerable`1<ICachedDeclaration2> declarations, bool bindDeclarations);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ProjectFilePartsTree : PartsTree {
    [NotNullAttribute]
private JetWeakReference`1<IFile> myPsiFile;
    private bool myForceDirty;
    private long mySourceFileAggregatedTimeStamp;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <SourceFileContentHash>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    public Nullable`1<long> SourceFileContentHash { get; }
    [NotNullAttribute]
public ProjectFilePart Root { get; }
    [NotNullAttribute]
public IPsiModule Module { get; }
    [NotNullAttribute]
public IPsiSourceFile SourceFile { get; }
    [CanBeNullAttribute]
public IFile PsiFile { get; }
    public ProjectFilePartsTree(IPsiSourceFile sourceFile, PsiLanguageType languageType, IFile psiFile);
    private ProjectFilePartsTree(IPsiSourceFile sourceFile, PsiLanguageType languageType, bool isUpToDate);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_SourceFileContentHash();
    public ProjectFilePart get_Root();
    [CompilerGeneratedAttribute]
public virtual IPsiModule get_Module();
    public void SaveTree(IWriter writer);
    public static ProjectFilePartsTree ReadTree(IReader reader, IPsiSourceFile sourceFile, Nullable`1<long> contentHashOnCreation, bool isUpToDate);
    [CompilerGeneratedAttribute]
public IPsiSourceFile get_SourceFile();
    public void ForceDirty();
    public IFile get_PsiFile();
    internal bool IsUpToDate();
    [CanBeNullAttribute]
public TDeclaration BuildStub(DeclarationPart part);
    public string Dump(string indent, bool dumpHeader);
    [CompilerGeneratedAttribute]
internal static void <Dump>g__DumpTree|23_0(string partIndent, Part part, <>c__DisplayClass23_0& );
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.SandBoxPart : Part {
    public ISandBox SandBox { get; }
    protected internal virtual void Write(IWriter writer);
    public virtual IFile GetFile();
    public ISandBox get_SandBox();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.SandBoxPartsTree : PartsTree {
    [NotNullAttribute]
private ISandBox mySandBox;
    public IPsiModule Module { get; }
    public ISandBox SandBox { get; }
    public SandBoxPartsTree(SandBox sandBox, PsiLanguageType languageType);
    public virtual IPsiModule get_Module();
    public ISandBox get_SandBox();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.SerializationError : Exception {
    public SerializationError(string message);
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.SimpleProjectFilePart : ProjectFilePart {
    public String[] AttributeClassNames { get; }
    protected SimpleProjectFilePart(IPsiSourceFile sourceFile);
    protected SimpleProjectFilePart(IPsiSourceFile sourceFile, IReader reader);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances();
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName);
    public virtual String[] get_AttributeClassNames();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.Struct : ClassLikeTypeElement {
    protected MemberDecoration Modifiers { get; }
    public bool HasHiddenInstanceFields { get; }
    public bool HasCustomParameterlessConstructor { get; }
    public bool IsReadonly { get; }
    public bool IsByRefLike { get; }
    public Struct(IStructPart part);
    protected virtual LocalList`1<IDeclaredType> CalcSuperTypes();
    public virtual DeclaredElementType GetElementType();
    public virtual MemberPresenceFlag GetMemberPresenceFlag();
    protected virtual MemberDecoration get_Modifiers();
    public virtual IEnumerable`1<ITypeMember> GetMembers();
    public sealed virtual int TryGetCloneableMemberCount();
    public sealed virtual bool HasExplicitConstructorsInSuperTypes();
    public virtual bool get_HasHiddenInstanceFields();
    public sealed virtual bool get_HasCustomParameterlessConstructor();
    public virtual bool get_IsReadonly();
    public virtual bool get_IsByRefLike();
    protected internal virtual bool AcceptsPart(TypePart part);
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.TypeElement : CacheDeclaredElementBase {
    [NotNullAttribute]
private IList`1<ITypeParameter> myTypeParameters;
    [CanBeNullAttribute]
protected TypePart myParts;
    [NotNullAttribute]
private static ObjectPool`1<PooledHashSet`1<string>> ourCaseInsensitiveHashSetPool;
    public ISubstitution IdSubstitution { get; }
    internal bool IsPhysical { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    [CanBeNullAttribute]
public TypePart Parts { get; }
    public IPsiModule Module { get; }
    protected MemberDecoration Modifiers { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public IList`1<ITypeElement> NestedTypes { get; }
    public IEnumerable`1<IField> Constants { get; }
    public IEnumerable`1<IField> Fields { get; }
    public IEnumerable`1<IConstructor> Constructors { get; }
    public IEnumerable`1<IOperator> Operators { get; }
    public IEnumerable`1<IMethod> Methods { get; }
    public IEnumerable`1<IProperty> Properties { get; }
    public IEnumerable`1<IEvent> Events { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public MemberHidePolicy HidePolicy { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public string XMLDocId { get; }
    public ITypeElement ContainingType { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    [NotNullAttribute]
protected IConstructor DefaultConstructor { get; }
    [CanBeNullAttribute]
internal Namespace Namespace { get; }
    protected TypeElement(TypePart part);
    private static TypeElement();
    public sealed virtual ISubstitution get_IdSubstitution();
    internal bool get_IsPhysical();
    public sealed virtual IClrTypeName GetClrName();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public TypePart get_Parts();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.TypeElement/<EnumerateParts>d__15")]
[ItemNotNullAttribute]
public IEnumerable`1<TypePart> EnumerateParts();
    public sealed virtual IPsiModule get_Module();
    protected virtual MemberDecoration get_Modifiers();
    public void AddPart(TypePart part);
    internal void CheckConsistency();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public virtual bool HasMemberWithName(string shortName, bool ignoreCase);
    public virtual IEnumerable`1<string> get_MemberNames();
    public abstract virtual IList`1<IDeclaredType> GetSuperTypes();
    public virtual IList`1<ITypeElement> GetSuperTypeElements();
    public abstract virtual IEnumerable`1<ITypeMember> GetMembers();
    public virtual IList`1<ITypeElement> get_NestedTypes();
    public abstract virtual IEnumerable`1<IField> get_Constants();
    public abstract virtual IEnumerable`1<IField> get_Fields();
    public abstract virtual IEnumerable`1<IConstructor> get_Constructors();
    public abstract virtual IEnumerable`1<IOperator> get_Operators();
    public abstract virtual IEnumerable`1<IMethod> get_Methods();
    public abstract virtual IEnumerable`1<IProperty> get_Properties();
    public abstract virtual IEnumerable`1<IEvent> get_Events();
    public abstract virtual MemberPresenceFlag GetMemberPresenceFlag();
    public sealed virtual INamespace GetContainingNamespace();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public abstract virtual DeclaredElementType GetElementType();
    public sealed virtual bool IsValid();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual Nullable`1<Hash> CalcHash();
    public virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual string get_XMLDocId();
    public virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual ITypeElement get_ContainingType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual IPsiSourceFile GetSingleOrDefaultSourceFile();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public void RemovePart(TypePart part);
    [NotNullAttribute]
private string GetTypeParameterShortName(int index);
    private TypeParameterVariance GetTypeParameterVariance(int index);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    [PureAttribute]
[NotNullAttribute]
private IList`1<IType> GetTypeParameterSuperTypes(int index);
    [PureAttribute]
private bool HasTypeParameterSuperTypes(int index);
    [PureAttribute]
private bool HasTypeParameterConstraintFlags(int index, TypeParameterConstraintFlags flags);
    [PureAttribute]
private TypeParameterConstraintFlags GetTypeParameterConstraintFlags(int index);
    [PureAttribute]
private bool IsNullableContextEnabledForTypeParameter(int index);
    [NotNullAttribute]
internal IEnumerable`1<string> GetExtendsListShortNames(bool caseSensitive);
    [NotNullAttribute]
protected string BuildTypeParameterString();
    protected LocalList`1<TResult> ProcessParts(Func`2<TPart, IEnumerable`1<TResult>> converter, Func`2<TypeElement, IEnumerable`1<TResult>> additional, HashSet`1<TResult> added);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.TypeElement/<EnumerateParts>d__109`2")]
[NotNullAttribute]
[MustUseReturnValueAttribute]
protected IEnumerable`1<TResult> EnumerateParts(Func`2<TPart, IEnumerable`1<TResult>> iterator);
    protected IConstructor get_DefaultConstructor();
    internal Namespace get_Namespace();
    protected internal abstract virtual bool AcceptsPart(TypePart part);
    [NotNullAttribute]
public sealed virtual TypeElement TryTranslateToCurrentFork(IContentModelForkTranslator translator);
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.TypePart : DeclarationPart {
    private int myTypeParameterNumber;
    [CanBeNullAttribute]
private TypeElement myTypeElement;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private SlimHashSet`1<string> <MemberNames>k__BackingField;
    [CompilerGeneratedAttribute]
private TypePart <NextPart>k__BackingField;
    public string ShortName { get; }
    [CanBeNullAttribute]
public TypeElement TypeElement { get; internal set; }
    [CanBeNullAttribute]
public SlimHashSet`1<string> MemberNames { get; internal set; }
    public bool CanBePartial { get; }
    [CanBeNullAttribute]
public TypePart NextPart { get; public set; }
    public int TypeParameterNumber { get; }
    public MemberDecoration Modifiers { get; }
    [NotNullAttribute]
public String[] ExtendsListShortNames { get; }
    [NotNullAttribute]
public String[] AttributeClassNames { get; }
    [NotNullAttribute]
public ExtensionMemberInfo[] ExtensionMemberInfos { get; }
    protected TypePart(ICachedDeclaration2 declaration, string shortName, int typeParameters);
    protected TypePart(IReader reader);
    [CompilerGeneratedAttribute]
public string get_ShortName();
    public TypeElement get_TypeElement();
    internal void set_TypeElement(TypeElement value);
    [CompilerGeneratedAttribute]
public SlimHashSet`1<string> get_MemberNames();
    [CompilerGeneratedAttribute]
internal void set_MemberNames(SlimHashSet`1<string> value);
    protected virtual void AssignDeclaredElement(ICachedDeclaration2 declaration);
    public abstract virtual bool get_CanBePartial();
    [CompilerGeneratedAttribute]
public TypePart get_NextPart();
    [CompilerGeneratedAttribute]
public void set_NextPart(TypePart value);
    protected internal virtual void Write(IWriter writer);
    public int get_TypeParameterNumber();
    public abstract virtual MemberDecoration get_Modifiers();
    public abstract virtual String[] get_ExtendsListShortNames();
    public abstract virtual String[] get_AttributeClassNames();
    [NotNullAttribute]
public abstract virtual TypeElement CreateTypeElement();
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IDeclaration GetTypeParameterDeclaration(int index);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual string GetTypeParameterName(int index);
    [PureAttribute]
public abstract virtual TypeParameterVariance GetTypeParameterVariance(int index);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IEnumerable`1<IType> GetTypeParameterSuperTypes(int index);
    [PureAttribute]
public abstract virtual TypeParameterConstraintFlags GetTypeParameterConstraintFlags(int index);
    [PureAttribute]
public abstract virtual bool IsNullableContextEnabledForTypeParameter(int index);
    [NotNullAttribute]
public abstract virtual IList`1<IAttributeInstance> GetTypeParameterAttributeInstances(int index, IClrTypeName typeName);
    [PureAttribute]
public abstract virtual bool HasTypeParameterAttributeInstance(int index, IClrTypeName typeName);
    internal void Unbind();
    [NotNullAttribute]
public abstract virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName);
    public abstract virtual bool HasAttributeInstance(IClrTypeName clrTypeName);
    public virtual ExtensionMemberInfo[] get_ExtensionMemberInfos();
    public virtual HybridCollection`1<ITypeMember> FindExtensionMethod(ExtensionMemberInfo info);
    public virtual bool CanHaveAttribute(string shortName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.TypePartImplBase`1 : TypePart {
    protected TypePartImplBase`1(IReader reader);
    protected TypePartImplBase`1(TTypeDeclaration declaration, string shortName, int typeParameters);
    protected static bool CheckDeclaration(IDeclaration declaration);
    [NullableContextAttribute("2")]
protected virtual TTypeDeclaration GetDeclaration();
    [NullableContextAttribute("2")]
protected TTypeDeclaration TryGetStubDeclarationForSuperTypeResolve();
}
internal class JetBrains.ReSharper.Psi.ExtensionsAPI.CompoundSecondaryLexingProcess : object {
    private IList`1<ISecondaryLexingProcess> mySerives;
    public CompoundSecondaryLexingProcess(IList`1<ISecondaryLexingProcess> serives);
    public sealed virtual ILexer TryCreateCodeBehindLexer(ILexer baseLexer);
    public sealed virtual bool CanHandle(ProjectFileType projectFileType);
}
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.DebugUtil : object {
    public static string EscapeNodeText(string text);
    public static void DumpNode(ITreeNode treeNode, TextWriter writer);
    private static void DumpPsiInternal(TextWriter writer, ITreeNode root, Predicate`1<ITreeNode> filter, Action`2<ITreeNode, TextWriter> nodeDumper, int level);
    public static void DumpPsi(TextWriter writer, ITreeNode root);
    public static void DumpPsi(TextWriter writer, ITreeNode root, Action`2<ITreeNode, TextWriter> nodeDumper, Predicate`1<ITreeNode> filter);
    public static bool HasErrorElements(ITreeNode element);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.DeclaredElements.ArrayIndexer : SpecialIndexer {
    [NotNullAttribute]
private IArrayType myType;
    [NotNullAttribute]
private IType[] myParameterTypes;
    public IPsiModule Module { get; }
    [NotNullAttribute]
public IArrayType ArrayType { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public ArrayIndexer(IArrayType type);
    public ArrayIndexer(IArrayType type, IType[] parameterTypes);
    public virtual IPsiServices GetPsiServices();
    public virtual IPsiModule get_Module();
    public IArrayType get_ArrayType();
    public virtual ITypeElement GetContainingType();
    public virtual ITypeMember GetContainingTypeMember();
    public virtual IList`1<IParameter> get_Parameters();
    public virtual IType get_ReturnType();
    public virtual ReferenceKind get_ReturnKind();
    public virtual bool IsValid();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.DeclaredElements.FunctionPointerInvocationTarget : object {
    [NotNullAttribute]
private IFunctionPointerType myFunctionPointerType;
    [CanBeNullAttribute]
private IList`1<IParameter> myParameters;
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public string XMLDocId { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public ITypeElement ContainingType { get; }
    public IList`1<IParameter> Parameters { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public bool IsPredefined { get; }
    public bool IsIterator { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public MemberHidePolicy HidePolicy { get; }
    public FunctionPointerInvocationTarget(IFunctionPointerType functionPointerType);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual string get_XMLDocId();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual IPsiModule get_Module();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual ITypeElement get_ContainingType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual bool get_IsPredefined();
    public sealed virtual bool get_IsIterator();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual Nullable`1<Hash> CalcHash();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal static string <get_Parameters>g__ParameterName|30_0(int index);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Identity")]
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.DeclaredElements.IdSubstitution : object {
    public IList`1<ITypeParameter> Domain { get; }
    public IType Item { get; }
    public IType Item { get; }
    public sealed virtual IType Apply(ITypeParameter typeParameter);
    public sealed virtual IType Apply(IType type);
    public sealed virtual bool IsIdempotent(ITypeParameter typeParameter);
    [PureAttribute]
private static bool TypeParameterEquals(ITypeElement first, ITypeElement second);
    public abstract virtual IList`1<ITypeParameter> get_Domain();
    public sealed virtual bool HasInDomain(ITypeParameter typeParameter);
    public sealed virtual ISubstitution Apply(ISubstitution substitution);
    public sealed virtual IType get_Item(ITypeParameter tp);
    public sealed virtual IType get_Item(IType t);
    public abstract virtual bool IsEmpty();
    public abstract virtual bool IsValid();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual ISubstitution Extend(ITypeParameter typeParameter, IType value);
    public sealed virtual ISubstitution Extend(IList`1<ITypeParameter> typeParameters, IList`1<IType> values);
    public sealed virtual ISubstitution Extend(IDictionary`2<ITypeParameter, IType> map);
    public abstract virtual ISubstitution TryTranslateToCurrentFork(IContentModelForkTranslator translator);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.DeclaredElements.InlineArrayIndexer : SpecialIndexer {
    private IStruct myOwner;
    [CompilerGeneratedAttribute]
private IList`1<IParameter> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferenceKind <ReturnKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadonly>k__BackingField;
    public IPsiModule Module { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public bool IsReadonly { get; }
    public InlineArrayIndexer(IStruct owner, IType parameterType, IType returnType, ReferenceKind returnKind, bool isReadonly);
    public virtual bool IsValid();
    public virtual IPsiModule get_Module();
    public virtual IPsiServices GetPsiServices();
    public virtual ITypeElement GetContainingType();
    public virtual ITypeMember GetContainingTypeMember();
    [CompilerGeneratedAttribute]
public virtual IList`1<IParameter> get_Parameters();
    [CompilerGeneratedAttribute]
public virtual IType get_ReturnType();
    [CompilerGeneratedAttribute]
public virtual ReferenceKind get_ReturnKind();
    [CompilerGeneratedAttribute]
public virtual bool get_IsReadonly();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.DeclaredElements.MethodIdSubstitution : IdSubstitution {
    [NotNullAttribute]
private IMethod myMethod;
    [CanBeNullAttribute]
private IList`1<ITypeParameter> myTypeParameters;
    public IList`1<ITypeParameter> Domain { get; }
    private MethodIdSubstitution(IMethod method);
    [PureAttribute]
[NotNullAttribute]
private static IList`1<ITypeParameter> GetAllTypeParameters(IMethod method);
    [NotNullAttribute]
[PureAttribute]
public static ISubstitution Create(IMethod method);
    public virtual bool IsEmpty();
    public virtual bool IsValid();
    public virtual ISubstitution TryTranslateToCurrentFork(IContentModelForkTranslator translator);
    public virtual IList`1<ITypeParameter> get_Domain();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.DeclaredElements.PointerIndexer : SpecialIndexer {
    [NotNullAttribute]
private IPointerType myType;
    [NotNullAttribute]
private IType myArgumentType;
    public IPsiModule Module { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public PointerIndexer(IPointerType type, IType argumentType);
    public virtual IPsiServices GetPsiServices();
    public virtual IPsiModule get_Module();
    public virtual IList`1<IParameter> get_Parameters();
    public virtual IType get_ReturnType();
    public virtual ReferenceKind get_ReturnKind();
    public virtual ITypeElement GetContainingType();
    public virtual ITypeMember GetContainingTypeMember();
    public virtual string ToString();
    public virtual bool IsValid();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.DeclaredElements.SpecialIndexer : object {
    public ITypeElement ContainingType { get; }
    public IList`1<IParameter> Parameters { get; }
    public IAccessor Getter { get; }
    public IAccessor Setter { get; }
    public bool IsReadable { get; }
    public bool IsWritable { get; }
    public bool IsReadonly { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public string XMLDocId { get; }
    public ISubstitution IdSubstitution { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public bool CanBeImplicitImplementation { get; }
    public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    public bool IsExplicitImplementation { get; }
    public IType Type { get; }
    public bool IsAuto { get; }
    public bool IsDefault { get; }
    public bool IsRequired { get; }
    public MemberHidePolicy HidePolicy { get; }
    public abstract virtual IPsiServices GetPsiServices();
    public sealed virtual ITypeElement get_ContainingType();
    public abstract virtual ITypeElement GetContainingType();
    public abstract virtual ITypeMember GetContainingTypeMember();
    public abstract virtual IList`1<IParameter> get_Parameters();
    public virtual IAccessor get_Getter();
    public virtual IAccessor get_Setter();
    public virtual bool get_IsReadable();
    public virtual bool get_IsWritable();
    public virtual bool get_IsReadonly();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public virtual AccessRights GetAccessRights();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public abstract virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public abstract virtual IPsiModule get_Module();
    public sealed virtual string get_XMLDocId();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual ISubstitution get_IdSubstitution();
    public abstract virtual IType get_ReturnType();
    public abstract virtual ReferenceKind get_ReturnKind();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual bool get_CanBeImplicitImplementation();
    public sealed virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    public sealed virtual bool get_IsExplicitImplementation();
    public sealed virtual IType get_Type();
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool get_IsAuto();
    public sealed virtual bool get_IsDefault();
    public sealed virtual bool get_IsRequired();
    public sealed virtual string GetDefaultPropertyMetadataName();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual Nullable`1<Hash> CalcHash();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.DeclaredElements.TypeElementIdSubstitution : IdSubstitution {
    [NotNullAttribute]
private ITypeElement myTypeElement;
    [NotNullAttribute]
private IList`1<ITypeParameter> myParameters;
    public IList`1<ITypeParameter> Domain { get; }
    private TypeElementIdSubstitution(ITypeElement typeElement, IList`1<ITypeParameter> typeParameters);
    [NotNullAttribute]
[PureAttribute]
public static ISubstitution Create(ITypeElement typeElement);
    public virtual IList`1<ITypeParameter> get_Domain();
    public virtual bool IsEmpty();
    public virtual bool IsValid();
    public virtual ISubstitution TryTranslateToCurrentFork(IContentModelForkTranslator translator);
}
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.DeclaredElements.TypeElementImplUtil : object {
    public static HybridCollection`1<ISubstitution> ComputeSubstitution(ITypeElement subtype, ITypeElement type);
    public static int ComputeDistance(ITypeElement subtype, ITypeElement type);
    internal static List`1<ValueTuple`2<ISubstitution, int>> FindInheritancePathRecursive(ITypeElement subtype, ITypeElement type);
    private static void FindInheritancePathRecursive(HashSet`1<ITypeElement> visited, HashSet`1<IDeclaredType> done, IDeclaredType type, ITypeElement finish, List`1<ValueTuple`2<ISubstitution, int>> result, int depth);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.DeclaredElementsSet : DeclaredElementsSet`1<IDeclaredElement> {
    public static DeclaredElementsSet Empty;
    public DeclaredElementsSet(IDeclaredElement element);
    public DeclaredElementsSet(IEnumerable`1<IDeclaredElement> elements, IEqualityComparer`1<IDeclaredElement> comparer);
    public DeclaredElementsSet(IEnumerable`1<IDeclaredElement> elements);
    private static DeclaredElementsSet();
    public sealed virtual IDeclaredElementsSet`1<T> FilterByType();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.DeclaredElementsSet`1 : object {
    private JetHashSet`1<T> myElements;
    private bool myCaseSensitive;
    public bool CaseSensitive { get; }
    public int Count { get; }
    public DeclaredElementsSet`1(JetHashSet`1<T> elements);
    public sealed virtual bool get_CaseSensitive();
    public sealed virtual int get_Count();
    public sealed virtual bool Contains(T element);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.DerivedFindRequest : object {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IDeclaredElement> <TargetElements>k__BackingField;
    [CompilerGeneratedAttribute]
private Predicate`1<IFindResultReference> <Predicate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RelevantResult>k__BackingField;
    public IReadOnlyCollection`1<IDeclaredElement> TargetElements { get; }
    public Predicate`1<IFindResultReference> Predicate { get; }
    public bool RelevantResult { get; }
    public DerivedFindRequest(IReadOnlyCollection`1<IDeclaredElement> targetElements, Predicate`1<IFindResultReference> predicate, bool relevantResult);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<IDeclaredElement> get_TargetElements();
    [CompilerGeneratedAttribute]
public Predicate`1<IFindResultReference> get_Predicate();
    [CompilerGeneratedAttribute]
public bool get_RelevantResult();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.DisableCodeFormatter : object {
    private bool myDisableExpensiveFormattingOnly;
    [MustDisposeResourceAttribute]
private DisableCodeFormatter(bool disableExpensiveFormattingOnly);
    [MustDisposeResourceAttribute]
public static DisableCodeFormatter DisableExpensiveFormatting();
    public sealed virtual void Dispose();
}
[MustDisposeResourceAttribute]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.DisallowBindingExtenstionAsStaticCallCookie : object {
    [CanBeNullAttribute]
[ThreadStaticAttribute]
private static DisallowBindingExtenstionAsStaticCallCookie ourCookie;
    public static bool Exists();
    public sealed virtual void Dispose();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.DisallowBindingUsingNewImportsCookie : object {
    [CanBeNullAttribute]
[ThreadStaticAttribute]
private static DisallowBindingUsingNewImportsCookie ourCookie;
    public static bool Exists();
    public sealed virtual void Dispose();
}
[MustDisposeResourceAttribute]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.DisallowBindingUsingSymbolAliasCookie : object {
    [CanBeNullAttribute]
[ThreadStaticAttribute]
private static DisallowBindingUsingSymbolAliasCookie ourCookie;
    public static bool Exists();
    public sealed virtual void Dispose();
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.DomainSpecificSearcherFactoryBase : object {
    public abstract virtual bool IsCompatibleWithLanguage(PsiLanguageType languageType);
    public virtual IDomainSpecificSearcher CreateConstructorSpecialReferenceSearcher(ICollection`1<IConstructor> constructors);
    public virtual IDomainSpecificSearcher CreateMethodsReferencedByDelegateSearcher(IDelegate delegate);
    public virtual IDomainSpecificSearcher CreateReferenceSearcher(IDeclaredElementsSet elements, ReferenceSearcherParameters referenceSearcherParameters);
    public virtual IDomainSpecificSearcher CreateLateBoundReferenceSearcher(IDeclaredElementsSet elements, ReferenceSearcherParameters referenceSearcherParameters);
    public virtual IDomainSpecificSearcher CreateTextOccurrenceSearcher(IDeclaredElementsSet elements);
    public virtual IDomainSpecificSearcher CreateTextOccurrenceSearcher(string subject);
    public virtual IDomainSpecificSearcher CreateAnonymousTypeSearcher(IList`1<AnonymousTypeDescriptor> typeDescription, bool caseSensitive);
    public virtual IDomainSpecificSearcher CreateConstantExpressionSearcher(ConstantValue constantValue, bool onlyLiteralExpression);
    public virtual IEnumerable`1<ITwoPhaseDomainSpecificSearcher> CreateImplicitUsageSearchers(SearchPattern searchPattern, ICollection`1<IDeclaredElement> declaredElements);
    public virtual IEnumerable`1<string> GetAllPossibleWordsInFile(IDeclaredElement element);
    public virtual bool IsSpecialName(string name);
    public virtual IEnumerable`1<RelatedDeclaredElement> GetRelatedDeclaredElements(IDeclaredElement element);
    public virtual IEnumerable`1<FindResult> GetRelatedFindResults(IDeclaredElement element);
    public virtual DerivedFindRequest GetDerivedFindRequest(IFindResultReference result);
    public virtual NavigateTargets GetNavigateToTargets(IDeclaredElement element);
    public virtual ICollection`1<FindResult> TransformNavigationTargets(ICollection`1<FindResult> targets);
    public virtual ISearchDomain GetDeclaredElementSearchDomain(IDeclaredElement declaredElement);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.DoNotDecorateReferencesOnBindingCookie : object {
    [ThreadStaticAttribute]
private static int ourDepth;
    public static bool IsEnabled { get; }
    public static bool get_IsEnabled();
    public sealed virtual void Dispose();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.EmptyExplicitImplementation : object {
    [CompilerGeneratedAttribute]
private IDeclaredType <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    public IDeclaredType DeclaringType { get; }
    public string MemberName { get; }
    public EmptyExplicitImplementation(string shortName, IDeclaredType declaringType);
    [CompilerGeneratedAttribute]
public sealed virtual IDeclaredType get_DeclaringType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MemberName();
    public sealed virtual OverridableMemberInstance Resolve();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.EmptySecondaryLexingProcess : object {
    public static ISecondaryLexingProcess Instance;
    private static EmptySecondaryLexingProcess();
    public sealed virtual ILexer TryCreateCodeBehindLexer(ILexer baseLexer);
    public sealed virtual bool CanHandle(ProjectFileType projectFileType);
}
public enum JetBrains.ReSharper.Psi.ExtensionsAPI.EventAccessType : Enum {
    public int value__;
    public static EventAccessType None;
    public static EventAccessType Add;
    public static EventAccessType Remove;
    public static EventAccessType Raise;
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.EventAccessTypeProvider : object {
    public virtual EventAccessType GetEventAccessType(IReference reference);
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.ExpectedTypes.TypeArgumentAnalyzer`2 : object {
    protected TTypeUsageNode myTypeUsageNode;
    protected TypeArgumentAnalyzer`2(TTypeUsageNode node);
    [CanBeNullAttribute]
public ExpectedType[] Calc();
    [NotNullAttribute]
protected abstract virtual IExpectedTypeConstraint CreateConstraint(IType type);
    [NotNullAttribute]
protected abstract virtual IExpectedTypeConstraint[] GetAdditionalTypes(IType type, IReadOnlyList`1<ITypeParameter> typeParameters);
    [CanBeNullAttribute]
public abstract virtual TTypeArgumentList GetTypeArgumentList(TTypeUsageNode typeUsage, Int32& index);
    protected abstract virtual TailType GetTailType(int index, IReadOnlyList`1<ITypeParameter> typeParameters);
    [CanBeNullAttribute]
public abstract virtual IReadOnlyList`1<ExpectedType> GetTypeArgumentListContext(TTypeArgumentList typeArgumentList, List`1& types);
    protected static void AddAllParameterizedMethods(IQualifiableReference reference, List`1<ValueTuple`2<IType, IReadOnlyList`1<ITypeParameter>>> types, bool forReferenceName);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.ExplicitImplementation : object {
    [NotNullAttribute]
private IOverridableMember myMember;
    private bool myCaseSensitive;
    [CompilerGeneratedAttribute]
private IDeclaredType <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    public IDeclaredType DeclaringType { get; }
    public string MemberName { get; }
    public ExplicitImplementation(IOverridableMember member, IDeclaredType declaredType, string memberName, bool caseSensitive);
    [CompilerGeneratedAttribute]
public sealed virtual IDeclaredType get_DeclaringType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MemberName();
    public sealed virtual OverridableMemberInstance Resolve();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.ExternalAnnotations.IExternalAnnotationsFileProvider {
    public abstract virtual IEnumerable`1<VirtualFileSystemPath> GetAnnotationsFiles(AssemblyNameInfo assemblyName, VirtualFileSystemPath assemblyLocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.FileDependency : object {
    [CompilerGeneratedAttribute]
private ILogger <logger>P;
    private object mySync;
    private OneToSetMap`2<VirtualFileSystemPath, VirtualFileSystemPath> myIncludedOnes;
    private OneToSetMap`2<VirtualFileSystemPath, VirtualFileSystemPath> myContainerOnes;
    public FileDependency(ILogger logger);
    public void UpdateDependencies(OneToSetMap`2<VirtualFileSystemPath, VirtualFileSystemPath> immediateIncludes);
    private static void GetTransitive(VirtualFileSystemPath file, OneToSetMap`2<VirtualFileSystemPath, VirtualFileSystemPath> map, HashSet`1<VirtualFileSystemPath> result);
    public ICollection`1<VirtualFileSystemPath> GetIncludedFiles(VirtualFileSystemPath file);
    public ICollection`1<VirtualFileSystemPath> GetContainerFiles(VirtualFileSystemPath file);
    public bool HasContainerFiles(VirtualFileSystemPath file);
    public string Dump(Func`2<VirtualFileSystemPath, string> pathPresenter);
    public string DumpContainers(Func`2<VirtualFileSystemPath, string> pathPresenter);
    public void OnProjectFileRemoved(IProjectFile projectFile, VirtualFileSystemPath path);
    public bool CanHandle(IProjectFile projectFile);
    public bool Contains(VirtualFileSystemPath location);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.FileDependencyEx : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static bool IsFileIncluded(FileDependency fileDependency, IPsiSourceFile sourceFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.FileDependencyTracker : object {
    private Lifetime myLifetime;
    private FileDependency myDependency;
    private IPsiServices myPsiServices;
    private DocumentManager myDocumentManager;
    private ChangeManager myChangeManager;
    private DocumentTransactionManager myDocumentTransactionManager;
    private HashSet`1<VirtualFileSystemPath> myDirtyPaths;
    private ILogger myLogger;
    private static Key`1<Boxed`1<int>> ourTimestampKey;
    private static object ourFilesToRegenerateKey;
    private GroupingEvent myCommitDirtyPathsGroupingEvent;
    private SynchronizationPoint mySyncPoint;
    private SequentialLifetimes mySyncPointLifetimes;
    public FileDependencyTracker(Lifetime lifetime, FileDependency dependency, IPsiServices psiServices, DocumentManager documentManager, ChangeManager changeManager, DocumentTransactionManager documentTransactionManager, ILogger logger, SynchronizationPoints syncPoints);
    private static FileDependencyTracker();
    private void OnDocumentTransactionCommit(DocumentTransactionResult documentTransactionResult);
    private void Commit(string reason);
    [NullableContextAttribute("2")]
private void FilesAfterPsiChanged(ITreeNode node, PsiChangedElementType changedElementType);
    private void AddDirtyPaths(ICollection`1<VirtualFileSystemPath> locations);
    private void EnqueueProcessDirtyFiles(bool doCallCommitInSyncMode);
    private void OnPsiTransactionCommit(IPsiTransaction transaction);
    public void RegenerateFiles(ICollection`1<IProjectFile> filesToRegenerate);
    private void CommitAllDocuments();
    private bool MarkFilesForRegeneration(ICollection`1<IProjectFile> projectFiles);
    private void OnChangeManagerChanged(ChangeEventArgs changeEventArgs);
    private bool ProcessChangedFiles(HashSet`1<VirtualFileSystemPath> locations);
    private void ClearSolutionFiles();
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_1(Lifetime _);
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_2();
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_3(ChangeEventArgs args);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__9_4(DocumentTransactionResult result);
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_5();
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_6();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <OnChangeManagerChanged>b__23_0(IProjectFile projectFile);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <OnChangeManagerChanged>b__23_1(IProjectFile projectFile);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Finder.ISearchFilter {
    public SearchFilterKind Kind { get; }
    public abstract virtual SearchFilterKind get_Kind();
    [PureAttribute]
public abstract virtual bool IsAvailable(SearchPattern pattern);
    [PureAttribute]
public abstract virtual object TryGetKey(IDeclaredElement declaredElement);
    [PureAttribute]
public abstract virtual bool CanContainReferences(IPsiSourceFile sourceFile, object key);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Finder.LateBoundReferenceSourceFileProcessor`1 : NamedThingsSearchSourceFileProcessor {
    private IFindResultConsumer`1<TResult> myResultConsumer;
    public LateBoundReferenceSourceFileProcessor`1(ITreeNode treeNode, IFindResultConsumer`1<TResult> resultConsumer, IDeclaredElementsSet elements, ICollection`1<string> wordsInText, ICollection`1<string> referenceNames);
    protected virtual bool PreFilterReference(IReference reference);
    protected virtual FindExecution ProcessReference(IReference reference);
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Finder.NamedThingsSearchSourceFileProcessor : object {
    private ITreeNode myRoot;
    private IReferenceNameContainer myReferenceNameContainer;
    private IReadOnlyList`1<StringSearcher> myStringSearchers;
    private IDeclaredElementsSet myElements;
    private bool myCaseSensitive;
    private IReferenceProvider myReferenceProvider;
    private static Func`3<NamedThingsSearchSourceFileProcessor, IReference, bool> ourFilter;
    protected IDeclaredElementsSet Elements { get; }
    protected NamedThingsSearchSourceFileProcessor(ITreeNode root, ICollection`1<string> wordsInText, ICollection`1<string> referenceNames, IDeclaredElementsSet elements);
    protected NamedThingsSearchSourceFileProcessor(ITreeNode root, IReferenceProvider referenceProvider, ICollection`1<string> wordsInText, ICollection`1<string> referenceNames, IDeclaredElementsSet elements);
    private static NamedThingsSearchSourceFileProcessor();
    public FindExecution Run();
    private FindExecution RunForNamedReferences(ITreeNode scope);
    private FindExecution RunForAllReferences(ITreeNode scope);
    protected IDeclaredElementsSet get_Elements();
    protected abstract virtual FindExecution ProcessReference(IReference reference);
    protected abstract virtual bool PreFilterReference(IReference reference);
    private bool ReferenceNamePredicate(IReference reference);
    protected virtual bool ShouldVisitScope(ITreeNode element);
    protected virtual ReferenceCollection GetReferences(ITreeNode element);
    protected virtual bool SubTreeContainsText(ITreeNode node);
    protected bool BufferContainsText(IBuffer buffer);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Finder.ReferenceSearchSourceFileProcessor`1 : NamedThingsSearchSourceFileProcessor {
    private ReferenceSearcherParameters myReferenceSearcherParameters;
    [CompilerGeneratedAttribute]
private IFindResultConsumer`1<TResult> <ResultConsumer>k__BackingField;
    public IFindResultConsumer`1<TResult> ResultConsumer { get; }
    public ReferenceSearchSourceFileProcessor`1(ITreeNode treeNode, ReferenceSearcherParameters referenceSearcherParameters, IFindResultConsumer`1<TResult> resultConsumer, IDeclaredElementsSet elements, ICollection`1<string> wordsInText, ICollection`1<string> referenceNames);
    [CompilerGeneratedAttribute]
public IFindResultConsumer`1<TResult> get_ResultConsumer();
    protected virtual bool PreFilterReference(IReference reference);
    [NotNullAttribute]
protected virtual IResolveResult Resolve(IReference reference);
    protected virtual bool AcceptElement(IDeclaredElement resolvedElement);
    protected virtual FindExecution ProcessReference(IReference reference);
}
public enum JetBrains.ReSharper.Psi.ExtensionsAPI.Finder.SearchFilterKind : Enum {
    public int value__;
    public static SearchFilterKind Language;
    public static SearchFilterKind Cache;
    public static SearchFilterKind Other;
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Finder.TextOccurrenceSearcherBase`1 : object {
    private JetHashSet`1<string> myNames;
    protected ICollection`1<string> Names { get; }
    protected Predicate`1<ITreeNode> Predicate { get; }
    protected TextOccurrenceSearcherBase`1(IEnumerable`1<IDeclaredElement> elements);
    protected TextOccurrenceSearcherBase`1(IEnumerable`1<string> elements);
    protected TextOccurrenceSearcherBase`1(string subject);
    private JetHashSet`1<string> InitNames(IEnumerable`1<string> names);
    protected ICollection`1<string> get_Names();
    public virtual bool ProcessProjectItem(IPsiSourceFile sourceFile, IFindResultConsumer`1<TResult> consumer);
    protected bool ProcessProjectItemImpl(IPsiSourceFile sourceFile, IFindResultConsumer`1<TResult> consumer);
    public bool ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
    protected virtual bool ShouldIgnore(IFile file, ITreeNode treeNode, TreeTextRange treeRange);
    protected abstract virtual Predicate`1<ITreeNode> get_Predicate();
}
[MeansImplicitUseAttribute]
[BaseTypeRequiredAttribute("JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.GeneratedDocumentServiceAttribute : ProjectFileTypeAttribute {
    public GeneratedDocumentServiceAttribute(Type Type, Instantiation instantiation);
}
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.HashableEntityUtil : object {
    [PureAttribute]
public static Hash PutGetterSetter(Hash hash, IProperty property);
    public static Hash CalcHashesForEnumMembers(Dictionary`2<TEnumMember, Hash> map, IEnumerable`1<TEnumMember> enumMembers, TEnumMember selectedMember, Func`2<TEnumMember, IExpression> getInitializerHandler);
    private static Hash CalcEnumMemberValueHash(Hash prevMemberHash, IExpression initializer);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.IAttributesProvider {
    [NotNullAttribute]
public abstract virtual IList`1<IAttributeInstance> GetAttributeInstances(IFile file);
    [CanBeNullAttribute]
public abstract virtual ITreeNode GetAttribute(IAttributeInstance attribute);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.ICompiledElementXmlDocProvider {
    [CanBeNullAttribute]
[ThreadSafeAttribute]
public abstract virtual XmlNode GetXmlDoc(CompiledElementBase element, bool inherit);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.ICrossProjectAnonymousTypeImpl {
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.IDeclaredElementsSet {
    public abstract virtual IDeclaredElementsSet`1<T> FilterByType();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.IDeclaredElementsSet`1 {
    public bool CaseSensitive { get; }
    public int Count { get; }
    public abstract virtual bool get_CaseSensitive();
    public abstract virtual int get_Count();
    public abstract virtual bool Contains(T element);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.IDomainSpecificSearcher {
    public abstract virtual bool ProcessProjectItem(IPsiSourceFile sourceFile, IFindResultConsumer`1<TResult> consumer);
    public abstract virtual bool ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.IDomainSpecificSearcherFactory {
    public abstract virtual bool IsCompatibleWithLanguage(PsiLanguageType languageType);
    [CanBeNullAttribute]
public abstract virtual IDomainSpecificSearcher CreateConstructorSpecialReferenceSearcher(ICollection`1<IConstructor> constructors);
    [CanBeNullAttribute]
public abstract virtual IDomainSpecificSearcher CreateMethodsReferencedByDelegateSearcher(IDelegate delegate);
    [CanBeNullAttribute]
public abstract virtual IDomainSpecificSearcher CreateReferenceSearcher(IDeclaredElementsSet elements, ReferenceSearcherParameters referenceSearcherParameters);
    [CanBeNullAttribute]
public abstract virtual IDomainSpecificSearcher CreateLateBoundReferenceSearcher(IDeclaredElementsSet elements, ReferenceSearcherParameters referenceSearcherParameters);
    [CanBeNullAttribute]
public abstract virtual IDomainSpecificSearcher CreateTextOccurrenceSearcher(IDeclaredElementsSet elements);
    [CanBeNullAttribute]
public abstract virtual IDomainSpecificSearcher CreateTextOccurrenceSearcher(string subject);
    [CanBeNullAttribute]
public abstract virtual IDomainSpecificSearcher CreateAnonymousTypeSearcher(IList`1<AnonymousTypeDescriptor> typeDescription, bool caseSensitive);
    [CanBeNullAttribute]
public abstract virtual IDomainSpecificSearcher CreateConstantExpressionSearcher(ConstantValue constantValue, bool onlyLiteralExpression);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<ITwoPhaseDomainSpecificSearcher> CreateImplicitUsageSearchers(SearchPattern searchPattern, ICollection`1<IDeclaredElement> declaredElements);
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IEnumerable`1<string> GetAllPossibleWordsInFile(IDeclaredElement element);
    [PureAttribute]
public abstract virtual bool IsSpecialName(string name);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<RelatedDeclaredElement> GetRelatedDeclaredElements(IDeclaredElement element);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<FindResult> GetRelatedFindResults(IDeclaredElement element);
    [CanBeNullAttribute]
public abstract virtual DerivedFindRequest GetDerivedFindRequest(IFindResultReference result);
    public abstract virtual NavigateTargets GetNavigateToTargets(IDeclaredElement element);
    [CanBeNullAttribute]
public abstract virtual ICollection`1<FindResult> TransformNavigationTargets(ICollection`1<FindResult> targets);
    [NotNullAttribute]
public abstract virtual ISearchDomain GetDeclaredElementSearchDomain(IDeclaredElement declaredElement);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.IGeneratedDocumentService {
    public abstract virtual IEnumerable`1<PsiLanguageType> GetSecondaryPsiLanguageTypes(IProject project);
    public abstract virtual bool IsSecondaryPsiLanguageType(IProject project, PsiLanguageType language);
    public abstract virtual bool CanHandle(ProjectFileType projectFileType);
    [CanBeNullAttribute]
public abstract virtual ISecondaryDocumentGenerationResult Generate(PrimaryFileModificationInfo modificationInfo);
    [CanBeNullAttribute]
public abstract virtual ICollection`1<ICommitBuildResult> ExecuteSecondaryDocumentCommitWork(PrimaryFileModificationInfo primaryFileModificationInfo, CachedPsiFile cachedPsiFile, TreeTextRange oldTreeRange, string newText);
    public abstract virtual void ProcessChangeFromGeneratedToPrimary(IPsiSourceFile sourceFile, TextRange range, string oldText, string newText, PsiLanguageType language);
    public abstract virtual void ProcessChangeFromPrimaryToGenerated(TreeTextRange range, string oldText, string newText, ISecondaryRangeTranslator rangeTranslator, IFile file, IPsiTransactionAction transactionAction);
    public abstract virtual DocumentRange TryFindNavigationRangeInPrimaryDocument(ITreeNode element);
    public abstract virtual ISecondaryLexingProcess CreateSecondaryLexingService(ISolution solution, MixedLexer mixedLexer, IPsiSourceFile sourceFile);
    public abstract virtual ILexerFactory LexerFactoryWithPreprocessor(PsiLanguageType primaryLanguage);
    public abstract virtual void AssertValid(IFile generatedFile, ISecondaryRangeTranslator secondaryRangeTranslator);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.IIndependentInjectedPsiProvider {
    public abstract virtual void CleanupNodeContextOnDelete(IInjectedNodeContext nodeContext);
    [CanBeNullAttribute]
public abstract virtual IInjectedNodeContext CreateInjectedNodeContext(IInjectedFileContext fileContext, ITreeNode originalNode);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.IInjectedContextData {
    public bool CanInject { get; }
    public abstract virtual bool get_CanInject();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.IInjectedFileContext {
    public IInjectedPsiProvider Provider { get; }
    public IFile OriginalFile { get; }
    public IInjectedContextData Data { get; }
    public abstract virtual IInjectedPsiProvider get_Provider();
    public abstract virtual IFile get_OriginalFile();
    public abstract virtual bool HasInjectedNodes();
    [NotNullAttribute]
public abstract virtual ICollection`1<IInjectedNodeContext> GetAllInjects();
    [CanBeNullAttribute]
public abstract virtual IInjectedNodeContext GetInjectForNode(ITreeNode originalNode);
    public abstract virtual IInjectedContextData get_Data();
    public abstract virtual bool IsValid();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.IInjectedFileHolder {
    public IFile GeneratedFile { get; }
    public ITreeNode OriginalNode { get; }
    public IInjectedFileContext FileContext { get; }
    public abstract virtual IFile get_GeneratedFile();
    public abstract virtual ITreeNode get_OriginalNode();
    public abstract virtual IInjectedFileContext get_FileContext();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.IInjectedNodeContext {
    public IInjectedFileContext FileContext { get; }
    public ITreeNode OriginalContextNode { get; }
    public ITreeNode GeneratedNode { get; }
    public IFile GeneratedFile { get; }
    public ISecondaryRangeTranslator RangeTranslator { get; }
    public abstract virtual IInjectedFileContext get_FileContext();
    public abstract virtual ITreeNode get_OriginalContextNode();
    public abstract virtual ITreeNode get_GeneratedNode();
    public abstract virtual IFile get_GeneratedFile();
    public abstract virtual ISecondaryRangeTranslator get_RangeTranslator();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.IInjectedPsiProvider {
    public bool ProvidedLanguageCanHaveNestedInjects { get; }
    [NotNullAttribute]
public PsiLanguageType GeneratedLanguage { get; }
    public abstract virtual bool get_ProvidedLanguageCanHaveNestedInjects();
    public abstract virtual bool IsApplicable(PsiLanguageType originalLanguage);
    public abstract virtual bool IsApplicableToNode(ITreeNode node, IInjectedFileContext context);
    public abstract virtual bool CouldBeApplicableToDescendants(ITreeNode node);
    public abstract virtual PsiLanguageType get_GeneratedLanguage();
    [CanBeNullAttribute]
public abstract virtual IInjectedFileContext CreateInjectedFileContext(IFile originalFile, IInjectedContextData injectedContextData);
    public abstract virtual IInjectedContextData ComputeDataForFileContext(IFile originalFile);
    public abstract virtual void OriginalFileChanged(IInjectedFileContext fileContext, ITreeNode originalParent, IEnumerable`1<ITreeNode> deletedNodes, IEnumerable`1<ITreeNode> addedNodes, bool processImmediately, PsiChangedElementType elementType);
    public abstract virtual void GeneratedFileChanged(IInjectedFileContext fileContext, ITreeNode generatedParent, IEnumerable`1<ITreeNode> deletedNodes, IEnumerable`1<ITreeNode> addedNodes, bool processImmediately);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.IInjectedScopeData {
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.IInternalsVisibleToProvider {
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IReadOnlyList`1<string> GetInternalsVisibleToArguments(IFile file);
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.ImmediateChangeProcessingCookie : object {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.InjectedPsiExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IInjectedNodeContext GetInjectForNodeOrParents(IInjectedFileContext context, ITreeNode originalNode);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IInjectedNodeContext GetInjectAt(IInjectedFileContext context, TreeTextRange originalRange);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IInjectedNodeContext GetInjectAt(IInjectedFileContext context, DocumentRange range);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.IPsiModificationService {
    public PsiModificationServicePriority Priority { get; }
    public abstract virtual PsiModificationServicePriority get_Priority();
    public abstract virtual bool IsApplicable(ITreeNode originalNode, bool fromPhysicalTree, ITreeNode insertedCopyNode, bool toPhysicalTree);
    [CanBeNullAttribute]
public abstract virtual object CreateContext(ITreeNode originalNode, IReferenceContextCodec referenceContextCodec, ITreeNode insertedCopyNode);
    [CanBeNullAttribute]
public abstract virtual ITreeNode Apply(ITreeNode node, object context);
    [PureAttribute]
public abstract virtual bool ShouldApplyToDescendants(ITreeNode node, object context);
    public abstract virtual void CleanupContext(ITreeNode node, object context);
    public abstract virtual void OnCopyWithResolve(ITreeNode node, ITreeNode copy);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextCodec {
    [NotNullAttribute]
public abstract virtual IReferenceContextDecoder Encode(ITreeNode source, ITreeNode cloned);
    public abstract virtual void CopyWithResolve(ITreeNode source, ITreeNode cloned);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnSetReferenceIdentity(ReferenceContextCodecIdentityHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnSetReferenceIdentity(ReferenceContextCodecIdentityHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnReferenceBound(ReferenceContextCodeBindHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnReferenceBound(ReferenceContextCodeBindHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnSetDeclarationIdentity(ReferenceContextCodeSetDeclarationIdentityHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnSetDeclarationIdentity(ReferenceContextCodeSetDeclarationIdentityHandler value);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IEnumerable`1<IReference> ExtractBindableReferences(ITreeNode element);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.IReferenceContextDecoder {
    [NotNullAttribute]
public abstract virtual ITreeNode Decode();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.ISecondaryDocumentGenerationResult {
    public PsiLanguageType Language { get; }
    public ISecondaryRangeTranslator SecondaryRangeTranslator { get; }
    public IBuffer Buffer { get; }
    public ILexerFactory LexerFactory { get; }
    public abstract virtual PsiLanguageType get_Language();
    public abstract virtual ISecondaryRangeTranslator get_SecondaryRangeTranslator();
    public abstract virtual IBuffer get_Buffer();
    public abstract virtual ILexerFactory get_LexerFactory();
    public abstract virtual void CommitChanges();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.ISecondaryLexingProcess {
    [CanBeNullAttribute]
public abstract virtual ILexer TryCreateCodeBehindLexer(ILexer baseLexer);
    public abstract virtual bool CanHandle(ProjectFileType projectFileType);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.ITopLevelCodeCacheProvider {
    [PureAttribute]
public abstract virtual bool HasTopLevelCode(IFile psiFile);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IDeclaredElement TryGetTopLevelEntryPoint(IFile psiFile);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.ITwoPhaseDomainSpecificSearcher {
    [NullableContextAttribute("1")]
public abstract virtual ValueTuple`2<IDomainSpecificSearcher, ISearchDomain> TryCreateSecondPhaseInfo(SearchDomainFactory searchDomainFactory, ISearchDomain originalSearchDomain, HashSet`1<IPsiSourceFile> processedFiles);
}
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.LowLevelModificationUtil : object {
    [NotNullAttribute]
private static IPsiServices GetPsiServices(ITreeNode node);
    private static bool NeedAddTransactionAction(IPsiServices psiServices, ITreeNode node);
    private static PsiChangedElementType GetChangeType(ITreeNode node);
    private static PsiChangedElementType GetChangeType(IEnumerable`1<ITreeNode> nodes);
    public static void AddChildAfter(ITreeNode anchor, ITreeNode[] nodes);
    public static void AddChildBefore(ITreeNode anchor, ITreeNode[] nodes);
    public static void AddChild(ITreeNode root, ITreeNode[] nodes);
    public static void ReplaceChild(ITreeNode child, ITreeNode replaceWith);
    public static void ReplaceChildRange(ITreeNode first, ITreeNode last, ITreeNode[] nodes);
    public static void DeleteChildRange(ITreeNode first, ITreeNode last);
    public static void DeleteChild(ITreeNode node);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.NavigateTargets : ValueType {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IDeclaredElement> <TargetElements>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OriginalElementIsRelevant>k__BackingField;
    public static NavigateTargets Empty;
    public IReadOnlyCollection`1<IDeclaredElement> TargetElements { get; }
    public bool OriginalElementIsRelevant { get; }
    public NavigateTargets(IReadOnlyCollection`1<IDeclaredElement> targetElements, bool originalElementIsRelevant);
    public NavigateTargets(IDeclaredElement targetElement, bool originalElementIsRelevant);
    private static NavigateTargets();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<IDeclaredElement> get_TargetElements();
    [CompilerGeneratedAttribute]
public bool get_OriginalElementIsRelevant();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.PsiModificationScope : ValueType {
    [CanBeNullAttribute]
private Stack`1<IPsiModificationService> myModificationServices;
    [CanBeNullAttribute]
private Stack`1<Type> myDisabledModificationServiceTypes;
    [CanBeNullAttribute]
private ReferenceContextCodecFactory myReferenceContextCodecFactory;
    private bool myCodeFormatterDisabled;
    private bool myModificationServicesDisabled;
    [MustDisposeResourceAttribute]
[HandlesResourceDisposalAttribute]
public PsiModificationScope DisableReferenceRebinding();
    [MustDisposeResourceAttribute]
[HandlesResourceDisposalAttribute]
public PsiModificationScope OnlyBindFakeResolveReferences();
    [MustDisposeResourceAttribute]
[HandlesResourceDisposalAttribute]
public PsiModificationScope DisableCodeFormatter();
    [MustDisposeResourceAttribute]
[HandlesResourceDisposalAttribute]
public PsiModificationScope DisableModificationServices();
    [MustDisposeResourceAttribute]
public static PsiModificationScope CreateTrivial();
    [MustDisposeResourceAttribute]
[HandlesResourceDisposalAttribute]
public PsiModificationScope AddModificationService(IPsiModificationService service);
    [MustDisposeResourceAttribute]
[HandlesResourceDisposalAttribute]
public PsiModificationScope DisableModificationService();
    public sealed virtual void Dispose();
}
public enum JetBrains.ReSharper.Psi.ExtensionsAPI.PsiModificationServicePriority : Enum {
    public int value__;
    public static PsiModificationServicePriority BeforeStandard;
    public static PsiModificationServicePriority Standard;
    public static PsiModificationServicePriority AfterStandard;
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceContextCodeBindHandler : MulticastDelegate {
    public ReferenceContextCodeBindHandler(object object, IntPtr method);
    public virtual void Invoke(IReference oldReference, IReference newReference, DeclaredElementInstance target);
    public virtual IAsyncResult BeginInvoke(IReference oldReference, IReference newReference, DeclaredElementInstance target, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceContextCodec : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<IDeclaredElement, IDeclaration> <DeclarationsMap>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferenceContextCodecIdentityHandler OnSetReferenceIdentity;
    [CompilerGeneratedAttribute]
private ReferenceContextCodeBindHandler OnReferenceBound;
    [CompilerGeneratedAttribute]
private ReferenceContextCodeSetDeclarationIdentityHandler OnSetDeclarationIdentity;
    [ThreadStaticAttribute]
internal static bool EncodeOnlyFakeResolveReferences;
    [NotNullAttribute]
public Dictionary`2<IDeclaredElement, IDeclaration> DeclarationsMap { get; }
    [CompilerGeneratedAttribute]
public Dictionary`2<IDeclaredElement, IDeclaration> get_DeclarationsMap();
    public sealed virtual IReferenceContextDecoder Encode(ITreeNode source, ITreeNode cloned);
    public sealed virtual void CopyWithResolve(ITreeNode source, ITreeNode cloned);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnSetReferenceIdentity(ReferenceContextCodecIdentityHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnSetReferenceIdentity(ReferenceContextCodecIdentityHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnReferenceBound(ReferenceContextCodeBindHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnReferenceBound(ReferenceContextCodeBindHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnSetDeclarationIdentity(ReferenceContextCodeSetDeclarationIdentityHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnSetDeclarationIdentity(ReferenceContextCodeSetDeclarationIdentityHandler value);
    private void FireSetReferenceIdentity(IReference orgReference, IReference clnReference);
    private void FireReferenceBound(IReference oldReference, IReference newReference, DeclaredElementInstance target);
    private void CollectDeclarationsMap(ITreeNode source, ITreeNode cloned);
    public virtual IEnumerable`1<IReference> ExtractBindableReferences(ITreeNode element);
    [NotNullAttribute]
public virtual IReference MakeSafeReference(IReference reference);
    [PureAttribute]
protected virtual ReferenceCollection FindDependentReferences(IReference reference, bool strict);
    private void CollectBindableReferencesWithResolveResult(ITreeNode source, ITreeNode cloned, List`1<BindableReferenceInfo> collectedReferences);
    private void SetFakeResolve(BindableReferenceInfo referenceInfo, bool encodingPhysicalTree, bool decodingPhysicalTree);
    internal void SetFakeResolve(IReference reference, DeclaredElementInstance instance, IResolveResult resolveResult, bool isPhysical);
    internal void ClearFakeResolve(IReference reference);
    internal static Pair`2<DeclaredElementInstance, IResolveResult> GetFakeResolve(IReference reference);
    [CompilerGeneratedAttribute]
internal static bool <SetFakeResolve>g__ShouldEncodeSubstitution|22_0(<>c__DisplayClass22_0& );
}
[MustDisposeResourceAttribute]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceContextCodecFactory : object {
    [NullableAttribute("2")]
private ReferenceContextCodecFactory myPrevFactory;
    public virtual void Dispose();
    [NullableContextAttribute("1")]
protected IReferenceContextCodec DelegateToPreviousFactory(PsiLanguageType languageType);
    [NullableContextAttribute("1")]
[PureAttribute]
public virtual IReferenceContextCodec CreateCodec(PsiLanguageType languageType);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceContextCodecIdentityHandler : MulticastDelegate {
    public ReferenceContextCodecIdentityHandler(object object, IntPtr method);
    public virtual void Invoke(IReference orgReference, IReference clnReference);
    public virtual IAsyncResult BeginInvoke(IReference orgReference, IReference clnReference, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceContextCodecSubtreeInsertedHandler : MulticastDelegate {
    public ReferenceContextCodecSubtreeInsertedHandler(object object, IntPtr method);
    public virtual void Invoke(ITreeNode originalTree, ITreeNode copyTree);
    public virtual IAsyncResult BeginInvoke(ITreeNode originalTree, ITreeNode copyTree, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceContextCodeSetDeclarationIdentityHandler : MulticastDelegate {
    public ReferenceContextCodeSetDeclarationIdentityHandler(object object, IntPtr method);
    public virtual void Invoke(IDictionary`2<IDeclaredElement, IDeclaration> table);
    public virtual IAsyncResult BeginInvoke(IDictionary`2<IDeclaredElement, IDeclaration> table, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MustDisposeResourceAttribute]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceIdentitySaver : ReferenceContextCodecFactory {
    private BidirectionalMapOnDictionary`2<IReference, IReference> myReferenceMap;
    private Dictionary`2<IDeclaredElement, IDeclaration> myDeclarationIdentityMap;
    private Stack`1<EventsTransaction> myUnfinishedTransactions;
    private LifetimeDefinition myTransactionsLifetimeDefinition;
    public IDictionary`2<IReference, IReference> ReferenceMap { get; }
    public IDictionary`2<IDeclaredElement, IDeclaration> DeclarationIdentityMap { get; }
    public ReferenceIdentitySaver(IPsiServices psiServices, Nullable`1<Lifetime> parentLifetime);
    public IDictionary`2<IReference, IReference> get_ReferenceMap();
    public IDictionary`2<IDeclaredElement, IDeclaration> get_DeclarationIdentityMap();
    [PureAttribute]
public IReference ClosureRemap(IReference reference);
    public virtual IReferenceContextCodec CreateCodec(PsiLanguageType languageType);
    private void OnSetDeclarationIdentity(IDictionary`2<IDeclaredElement, IDeclaration> table);
    private void OnReferenceBound(IReference oldReference, IReference newReference, DeclaredElementInstance target);
    private void OnSetReferenceIdentity(IReference orgReference, IReference clnReference);
    public virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(IPsiTransaction _);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_1(IPsiTransaction _);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_2(IPsiTransaction _);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.ReferenceSearcherParameters : object {
    private List`1<DeclaredElementEnvoy`1<IDeclaredElement>> myElements;
    [CompilerGeneratedAttribute]
private bool <FindCandidates>k__BackingField;
    [CanBeNullAttribute]
public IReadOnlyList`1<DeclaredElementEnvoy`1<IDeclaredElement>> OriginalElements { get; }
    public bool FindCandidates { get; }
    public ReferenceSearcherParameters(IEnumerable`1<DeclaredElementEnvoy`1<IDeclaredElement>> originalElements, bool findCandidates);
    public IReadOnlyList`1<DeclaredElementEnvoy`1<IDeclaredElement>> get_OriginalElements();
    [CompilerGeneratedAttribute]
public bool get_FindCandidates();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.RelatedDeclaredElement : ValueType {
    private static IEqualityComparer`1<IDeclaredElement> ourEqualityComparer;
    private static Predicate`1<FindResult> ourDefaultPredicate;
    private static Func`2<ISearchDomain, ISearchDomain> ourDefaultSearchDomainTransformer;
    [CompilerGeneratedAttribute]
private IDeclaredElement <DeclaredElement>k__BackingField;
    [CompilerGeneratedAttribute]
private Predicate`1<FindResult> <FindResultValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ISearchDomain, ISearchDomain> <SearchDomainTransformer>k__BackingField;
    public IDeclaredElement DeclaredElement { get; }
    public Predicate`1<FindResult> FindResultValidator { get; }
    public Func`2<ISearchDomain, ISearchDomain> SearchDomainTransformer { get; }
    public RelatedDeclaredElement(IDeclaredElement declaredElement, Predicate`1<FindResult> findResultValidator, Func`2<ISearchDomain, ISearchDomain> searchDomainTransformer);
    private static RelatedDeclaredElement();
    [CompilerGeneratedAttribute]
public IDeclaredElement get_DeclaredElement();
    [CompilerGeneratedAttribute]
public Predicate`1<FindResult> get_FindResultValidator();
    [CompilerGeneratedAttribute]
public Func`2<ISearchDomain, ISearchDomain> get_SearchDomainTransformer();
    public sealed virtual bool Equals(RelatedDeclaredElement other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.CachingAccessContext : object {
    [NotNullAttribute]
private IAccessContext myContext;
    private Nullable`1<CachedValue`1<ITypeElement>> myAccessContainingTypeElement;
    private Nullable`1<CachedValue`1<Staticness>> myStaticness;
    private Nullable`1<CachedValue`1<QualifierKind>> myQualifierKind;
    private Nullable`1<CachedValue`1<ITypeElement>> myQualifierTypeElement;
    private Nullable`1<CachedValue`1<IPsiModule>> myPsiModule;
    private Nullable`1<CachedValue`1<IPsiSourceFile>> mySourceFile;
    public CachingAccessContext(IAccessContext context);
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
    public sealed virtual IPsiModule GetPsiModule();
    public sealed virtual IPsiSourceFile GetSourceFile();
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.CheckedReferenceBase`1 : TreeReferenceBase`1<TOwnerElement> {
    protected CheckedReferenceBase`1(TOwnerElement owner);
    public abstract virtual ISymbolFilter[] GetSymbolFilters();
    public virtual ResolveResultWithInfo GetResolveResult(ISymbolTable symbolTable, string referenceName);
}
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.CheckedReferenceImplUtil : object {
    [NotNullAttribute]
public static ResolveResultWithInfo Resolve(ICheckedReference reference, ISymbolTable symbolTable);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.DistinctSymbolTable : object {
    [CompilerGeneratedAttribute]
private ISymbolTable <BaseTable>k__BackingField;
    [CompilerGeneratedAttribute]
private IEqualityComparer`1<ISymbolInfo> <Comparer>k__BackingField;
    [NotNullAttribute]
private ISymbolTable BaseTable { get; }
    [NotNullAttribute]
public IEqualityComparer`1<ISymbolInfo> Comparer { get; }
    public DistinctSymbolTable(ISymbolTable baseTable, IEqualityComparer`1<ISymbolInfo> comparer);
    [CompilerGeneratedAttribute]
private ISymbolTable get_BaseTable();
    [CompilerGeneratedAttribute]
public IEqualityComparer`1<ISymbolInfo> get_Comparer();
    public sealed virtual IList`1<ISymbolInfo> GetSymbolInfos(string name);
    public sealed virtual void AppendSymbolInfos(string name, List`1<ISymbolInfo> consumer);
    public sealed virtual IList`1<ISymbolInfo> GetSymbolInfosConstitutingResolveResult(string name, IResolveInfo& resolveInfo);
    public sealed virtual void ForAllSymbolInfos(Action`1<ISymbolInfo> processor);
    public sealed virtual bool ForAllSymbolInfos(TState state, Func`3<TState, ISymbolInfo, bool> processor);
    public sealed virtual IEnumerable`1<string> Names();
    public sealed virtual ISymbolTableDependencySet GetDependencySet();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.EmptySymbolTable : object {
    [NotNullAttribute]
public static ISymbolTable INSTANCE;
    private static EmptySymbolTable();
    public sealed virtual IList`1<ISymbolInfo> GetSymbolInfos(string name);
    public sealed virtual void AppendSymbolInfos(string name, List`1<ISymbolInfo> consumer);
    public sealed virtual IList`1<ISymbolInfo> GetSymbolInfosConstitutingResolveResult(string name, IResolveInfo& resolveInfo);
    public sealed virtual void ForAllSymbolInfos(Action`1<ISymbolInfo> processor);
    public sealed virtual bool ForAllSymbolInfos(TState state, Func`3<TState, ISymbolInfo, bool> processor);
    public sealed virtual IEnumerable`1<string> Names();
    public sealed virtual ISymbolTableDependencySet GetDependencySet();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.AccessRightsFilter : SimpleSymbolFilter {
    [CompilerGeneratedAttribute]
private IAccessContext <Context>k__BackingField;
    [NotNullAttribute]
protected IAccessContext Context { get; }
    public ResolveErrorType ErrorType { get; }
    public AccessRightsFilter(IAccessContext context);
    [CompilerGeneratedAttribute]
protected IAccessContext get_Context();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.AttributeFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static SimpleSymbolFilter Instance;
    public ResolveErrorType ErrorType { get; }
    private static AttributeFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.BetterMembersFilterBase : BetterMembersSelector`1<ISymbolInfo> {
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.BetterMembersSelector`1 : object {
    protected abstract virtual OrderValues<TSymbol> IsBetterCandidate(TSymbol s1, TSymbol s2);
    [PureAttribute]
public IList`1<TSymbol> FilterArray(IList`1<TSymbol> applicable);
    public sealed virtual bool TryFilterToDestination(List`1<TSymbol> source, List`1<TSymbol> destination);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.EmbeddedInteropTypeFilter : SimpleSymbolFilter {
    [CompilerGeneratedAttribute]
private IPsiModule <module>P;
    public ResolveErrorType ErrorType { get; }
    public EmbeddedInteropTypeFilter(IPsiModule module);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.EqualsAndReferenceEqualsFilter : SimpleSymbolFilter {
    private static string EQUALS;
    private static string REFERENCE_EQUALS;
    private QualifierKind myQualifierKind;
    private ITypeElement myObject;
    private ITypeElement myQualifierTypeElement;
    public ResolveErrorType ErrorType { get; }
    public EqualsAndReferenceEqualsFilter(IAccessContext context);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.ExplicitSubstitutionProvider : object {
    [CompilerGeneratedAttribute]
private IList`1<IType> <typeArguments>P;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public ExplicitSubstitutionProvider(IList`1<IType> typeArguments);
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.ForwardedTypeCompletionFilter : object {
    [CompilerGeneratedAttribute]
private IPsiModule <sourceModule>P;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public ForwardedTypeCompletionFilter(IPsiModule sourceModule);
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.ForwardedTypeFilter : SimpleSymbolFilter {
    [CompilerGeneratedAttribute]
private IPsiModule <sourceModule>P;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public ForwardedTypeFilter(IPsiModule sourceModule);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
    public virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.ImportedElementsFilter : object {
    public static ISymbolFilter INSTANCE;
    public static ISymbolFilter INSTANCE_FOR_COMPLETION;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static ImportedElementsFilter();
    public abstract virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
    [PureAttribute]
public static int GetMaxLevel(List`1<ISymbolInfo> data, Boolean& containsLowLevelElements);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.InitializerReferenceFilter : object {
    private IAccessContext myContext;
    [NullableAttribute("2")]
private IDeclaredElement myInitializedElement;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public InitializerReferenceFilter(IAccessContext context, ITreeNode element);
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    protected virtual IDeclaredElement GetInitializerOwner(ITreeNode element);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.InlineArrayIndexerFilter : object {
    public static InlineArrayIndexerFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static InlineArrayIndexerFilter();
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    private static bool IsHiddenByInlineArrayIndexer(IDeclaredElement declaredElement);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.IsMethodFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static ISymbolFilter INSTANCE;
    public FilterRunType RunType { get; }
    public ResolveErrorType ErrorType { get; }
    private static IsMethodFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual FilterRunType get_RunType();
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.IsPublicFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static ISymbolFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    private static IsPublicFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.LocalModuleNamesFilter : object {
    [CompilerGeneratedAttribute]
private IPsiModule <module>P;
    [CompilerGeneratedAttribute]
private bool <caseSensitive>P;
    [CompilerGeneratedAttribute]
private bool <checkNameEquality>P;
    [NullableAttribute("2")]
private ISymbolScope mySymbolScope;
    private ISymbolScope SymbolScope { get; }
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public LocalModuleNamesFilter(IPsiModule module, bool caseSensitive, bool checkNameEquality);
    private ISymbolScope get_SymbolScope();
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    private bool IsLocalTypeElement(ITypeElement typeElement);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.NamedTupleComponentFilter : SimpleSymbolFilter {
    private int myIndex;
    [NotNullAttribute]
private string myName;
    [NotNullAttribute]
private StringComparer myNameComparer;
    public FilterRunType RunType { get; }
    public ResolveErrorType ErrorType { get; }
    public NamedTupleComponentFilter(int index, string name, bool caseSensitive);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual FilterRunType get_RunType();
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.NamespaceOnlyFilter : SimpleSymbolFilter {
    public static NamespaceOnlyFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static NamespaceOnlyFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
    public virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.NoEmptyNamespaceFilter : object {
    [CompilerGeneratedAttribute]
private bool <isCompletion>P;
    private IAccessContext myAccessContext;
    [NullableAttribute("2")]
private ISymbolScope mySymbolScope;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public NoEmptyNamespaceFilter(IAccessContext accessContext, bool isCompletion);
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    private bool Accepts(IDeclaredElement declaredElement);
    private bool IsLocalNamespace(INamespace ns);
    private bool HasAccessibleTypes(INamespace ns, ISymbolScope symbolScope);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.OverriddenByNameFilter : OverriddenByNameFilter`1<ISymbolInfo> {
    public static OverriddenByNameFilter INSTANCE;
    private static OverriddenByNameFilter();
    protected virtual ISymbolInfo GetSymbolInfo(ISymbolInfo symbolInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.OverriddenByNameFilter`1 : OverriddenFilterBase`1<TSymbol> {
    protected virtual bool IsShadowed(ISymbolInfo left, int leftIndex, ISymbolInfo right, int rightIndex, IList`1<TSymbol> data, Object[]& additionalData);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.OverriddenFilter : OverriddenFilter`1<ISymbolInfo> {
    public static ISymbolFilter INSTANCE;
    public static ISymbolFilter CASE_SENSITIVE_INSTANCE;
    private OverriddenFilter(bool caseSensitiveNames);
    private static OverriddenFilter();
    protected virtual ISymbolInfo GetSymbolInfo(ISymbolInfo symbolInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.OverriddenFilter`1 : OverriddenFilterBase`1<TSymbol> {
    [CompilerGeneratedAttribute]
private bool <caseSensitiveNames>P;
    protected OverriddenFilter`1(bool caseSensitiveNames);
    private static InvocableSignature GetSignature(IParametersOwner parametersOwner, ISubstitution substitution, int index, IList`1<TSymbol> data, Object[]& additionalData);
    protected virtual bool IsShadowed(ISymbolInfo left, int leftIndex, ISymbolInfo right, int rightIndex, IList`1<TSymbol> data, Object[]& additionalData);
    protected bool IsOverrides(ITypeMember left, ITypeMember right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.OverriddenFilterBase`1 : object {
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    protected abstract virtual bool IsShadowed(ISymbolInfo left, int leftIndex, ISymbolInfo right, int rightIndex, IList`1<TSymbol> data, Object[]& additionalData);
    protected abstract virtual ISymbolInfo GetSymbolInfo(TSymbol symbolInfo);
    public IList`1<TSymbol> FilterArray(IList`1<TSymbol> data);
    public sealed virtual bool TryFilterToDestination(List`1<TSymbol> source, List`1<TSymbol> destination);
    private static bool Dominates(ITypeElement typeElement1, Nullable`1<int> inheritanceLevel1, ITypeElement typeElement2, Nullable`1<int> inheritanceLevel2);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.PreImportedElementsFilter : object {
    public static PreImportedElementsFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static PreImportedElementsFilter();
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.SkipPrivateImplementationsFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static ISymbolFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    private static SkipPrivateImplementationsFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.StaticEnumMethodsFilter : object {
    private static string Format;
    private static string GetName;
    private static string GetNames;
    private static string GetUnderlyingType;
    private static string GetValues;
    private static string IsDefined;
    private static string Parse;
    private static string ToObject;
    [NullableAttribute("2")]
private IEnum myQualifierEnum;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public StaticEnumMethodsFilter(IAccessContext accessContext);
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.StaticFilter : SimpleSymbolFilter {
    [NotNullAttribute]
private IAccessContext myContext;
    public ResolveErrorType ErrorType { get; }
    public StaticFilter(IAccessContext context);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.StaticPolymorphicInterfaceMemberFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static ISymbolFilter INSTANCE;
    public FilterRunType RunType { get; }
    public ResolveErrorType ErrorType { get; }
    private static StaticPolymorphicInterfaceMemberFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual FilterRunType get_RunType();
    public virtual ResolveErrorType get_ErrorType();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.TypeOrNamespaceFilter : SimpleSymbolFilter {
    [NotNullAttribute]
public static TypeOrNamespaceFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static TypeOrNamespaceFilter();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
    public virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.TypeParameterNumberFilter : SimpleSymbolFilter {
    [CompilerGeneratedAttribute]
private int <count>P;
    public FilterRunType RunType { get; }
    public ResolveErrorType ErrorType { get; }
    public TypeParameterNumberFilter(int count);
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual FilterRunType get_RunType();
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Filters.UseLocalVariableBeforeDeclarationFilterBase : object {
    protected ITreeNode myUsage;
    private static ObjectPool`1<PooledDictionary`2<string, ISymbolInfo>> ourCaseSensitivePool;
    private static ObjectPool`1<PooledDictionary`2<string, ISymbolInfo>> ourCaseInsensitivePool;
    private static ObjectPool`1<PooledList`1<ITreeNode>> ourNodeToRootPool;
    protected bool IsCaseSensitive { get; }
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    protected UseLocalVariableBeforeDeclarationFilterBase(ITreeNode usage);
    private static UseLocalVariableBeforeDeclarationFilterBase();
    protected abstract virtual bool get_IsCaseSensitive();
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    [MustDisposeResourceAttribute]
[PureAttribute]
private static PooledList`1<ITreeNode> PathFromRoot(ITreeNode node);
    protected virtual ITreeNode GetDeclarationNode(IDeclaredElement element);
    [PureAttribute]
private static bool NodeUsedBeforeOther(List`1<ITreeNode> root1, List`1<ITreeNode> root2);
    [PureAttribute]
protected virtual bool UsedBeforeDeclaration(ITreeNode declaration, PooledList`1& usagePathToRoot, PooledList`1& declarationPathToRoot);
    public abstract virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ICachingScope {
    public Tuple`3<ISymbolTable, int, SymbolTableMode> CachedTable { get; public set; }
    public abstract virtual Tuple`3<ISymbolTable, int, SymbolTableMode> get_CachedTable();
    public abstract virtual void set_CachedTable(Tuple`3<ISymbolTable, int, SymbolTableMode> value);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ICheckedReference {
    [NotNullAttribute]
public abstract virtual ISymbolFilter[] GetSymbolFilters();
    [NotNullAttribute]
public abstract virtual ResolveResultWithInfo GetResolveResult(ISymbolTable symbolTable, string referenceName);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IConditionalScope {
    public bool IntroducesScope { get; }
    public abstract virtual bool get_IntroducesScope();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IConditionalStaticScope {
    public bool IsStatic { get; }
    public abstract virtual bool get_IsStatic();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IDocCommentReference {
    public string TagName { get; }
    public abstract virtual string get_TagName();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IExtensionMethodResolveResult {
    [CanBeNullAttribute]
public ExtensionInstance`1<IDeclaredElement> ElementExtensionInstance { get; }
    [NotNullAttribute]
public IReadOnlyList`1<ExtensionInstance`1<IDeclaredElement>> CandidateExtensionInstances { get; }
    public abstract virtual ExtensionInstance`1<IDeclaredElement> get_ElementExtensionInstance();
    public abstract virtual IReadOnlyList`1<ExtensionInstance`1<IDeclaredElement>> get_CandidateExtensionInstances();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IIncrementalScope {
    [CanBeNullAttribute]
public abstract virtual ISymbolTable AddDeclarationsBeforeElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
    [CanBeNullAttribute]
public abstract virtual ISymbolTable AddDeclarationsAfterElement(ISymbolTable parentTable, ITreeNode element, int level, SymbolTableMode mode);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ILocalScope {
    [NotNullAttribute]
public IEnumerable`1<IDeclaredElement> LocalVariables { get; }
    public abstract virtual IEnumerable`1<IDeclaredElement> get_LocalVariables();
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ImplicitBaseConstructorInvocationReference : ManagedNonQualifiableReferenceBase`1<IDeclaration> {
    private IClass myBaseClass;
    protected ImplicitBaseConstructorInvocationReference(IDeclaration ownerElement, IClass baseClass);
    public virtual bool IsValid();
    public virtual string GetName();
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    public abstract virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
    public virtual TreeTextRange GetTreeTextRange();
    public virtual IReference BindTo(IDeclaredElement element);
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IQualifiableReference {
    public bool IsQualified { get; }
    public abstract virtual bool get_IsQualified();
    public abstract virtual IQualifier GetQualifier();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IResolveInfo {
    [NotNullAttribute]
public ResolveErrorType ResolveErrorType { get; }
    public abstract virtual ResolveErrorType get_ResolveErrorType();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IResolverQualifiableReference {
    public bool ShouldResolveInGlobalTable { get; }
    [NotNullAttribute]
public abstract virtual ResolveResultWithInfo Resolve(ISymbolTable symbolTable, IAccessContext context);
    public abstract virtual bool get_ShouldResolveInGlobalTable();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IScope {
    public int LevelDelta { get; }
    [CanBeNullAttribute]
public abstract virtual ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public abstract virtual int get_LevelDelta();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ITopLevelScope {
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ITwoPhaseReferenceImpl {
    public ResolveResultWithInfo CurrentPreResolveResult { get; public set; }
    public abstract virtual ResolveResultWithInfo PreResolve(ISymbolTable symbolTable);
    public abstract virtual ResolveResultWithInfo get_CurrentPreResolveResult();
    public abstract virtual void set_CurrentPreResolveResult(ResolveResultWithInfo value);
}
[DebuggerDisplayAttribute("{Name,nq}")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.CascadingCacheKey : object {
    [NotNullAttribute]
private static object ourIndexSyncRoot;
    private static int ourNextIndex;
    public int Index;
    [UsedImplicitlyAttribute]
public string Name;
    [NotNullAttribute]
public static CascadingCacheKey TYPE_CACHE;
    [NotNullAttribute]
public static CascadingCacheKey RESOLVE_CACHE;
    [NotNullAttribute]
public static CascadingCacheKey PRERESOLVE_CACHE;
    [NotNullAttribute]
public static CascadingCacheKey CONSTANT_VALUE_CACHE;
    [NotNullAttribute]
public static CascadingCacheKey VERIFICATION_CACHE;
    [NotNullAttribute]
public static CascadingCacheKey IMPLICITLY_CONVERTED_TO_CACHE;
    public static CascadingCacheKey[] AllKeys;
    private CascadingCacheKey(string name);
    private static CascadingCacheKey();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedAccessContext {
    public abstract virtual ITypeElement GetAccessContainingTypeElement(IResolveContext resolveContext);
    public abstract virtual Staticness GetStaticness(IResolveContext resolveContext);
    public abstract virtual QualifierKind GetQualifierKind(IResolveContext resolveContext);
    public abstract virtual ITypeElement GetQualifierTypeElement(IResolveContext resolveContext);
    public abstract virtual IPsiModule GetPsiModule();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedCheckedReference {
    public abstract virtual ISymbolFilter[] GetSymbolFilters(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedConstantValueOwnerImpl {
    [CanBeNullAttribute]
public ConstantValue CachedConstantValue { get; public set; }
    [NotNullAttribute]
public abstract virtual ConstantValue GetConstantValue(IResolveContext resolveContext);
    public abstract virtual ConstantValue get_CachedConstantValue();
    public abstract virtual void set_CachedConstantValue(ConstantValue value);
    public abstract virtual IPsiModule GetPsiModule();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedConvertibleImpl {
    [NotNullAttribute]
public abstract virtual IType CalculateImplicitlyConvertedTo(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedExpressionImpl {
    [CanBeNullAttribute]
public IExpressionType CachedExpressionType { get; public set; }
    [NotNullAttribute]
public abstract virtual ConstantValue GetConstantValue(IResolveContext resolveContext, ICalculationInfo info);
    [NotNullAttribute]
public abstract virtual IExpressionType CalculateExpressionType(IResolveContext resolveContext);
    public abstract virtual IExpressionType get_CachedExpressionType();
    public abstract virtual void set_CachedExpressionType(IExpressionType value);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedNonQualifiableReferenceImpl {
    [NotNullAttribute]
public abstract virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedOnePhaseReferenceImpl {
    [NotNullAttribute]
public abstract virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext, ISymbolTable symbolTable);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedReferenceImpl {
    public abstract virtual string Dump();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedTwoPhaseReferenceImpl {
    [CanBeNullAttribute]
public ResolveResultWithInfo CurrentPreResolveResult { get; public set; }
    [NotNullAttribute]
public abstract virtual ResolveResultWithInfo PreResolve(IResolveContext resolveContext, ISymbolTable symbolTable);
    [NotNullAttribute]
public abstract virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
    public abstract virtual ResolveResultWithInfo get_CurrentPreResolveResult();
    public abstract virtual void set_CurrentPreResolveResult(ResolveResultWithInfo value);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.IManagedVariableImpl {
    [CanBeNullAttribute]
public IType CachedType { get; public set; }
    [NotNullAttribute]
public abstract virtual IType CalculateType(IResolveContext resolveContext);
    public abstract virtual IType get_CachedType();
    public abstract virtual void set_CachedType(IType value);
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.ManagedCheckedReferenceBase`1 : ManagedNonQualifiableReferenceBase`1<TOwner> {
    protected ManagedCheckedReferenceBase`1(TOwner owner);
    [NotNullAttribute]
public abstract virtual ISymbolFilter[] GetSymbolFilters(IResolveContext resolveContext);
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
}
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.ManagedCheckedReferenceUtil : object {
    public static ResolveResultWithInfo Resolve(IResolveContext resolveContext, IManagedCheckedReference reference, ISymbolTable symbolTable);
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.ManagedNonQualifiableReferenceBase`1 : ManagedReferenceBase`1<T> {
    protected ManagedNonQualifiableReferenceBase`1(T owner);
    public abstract virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.ManagedOnePhaseReferenceImplBase`1 : ManagedQualifiedReferenceBase`1<TElement> {
    protected ManagedOnePhaseReferenceImplBase`1(TElement owner);
    public abstract virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext, ISymbolTable symbolTable);
    protected virtual ResolveResultWithInfo FullResolve(IResolveContext resolveContext, ISymbolTable symbolTable);
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.ManagedQualifiableCheckedReferenceBase`1 : ManagedOnePhaseReferenceImplBase`1<TOwner> {
    protected ManagedQualifiableCheckedReferenceBase`1(TOwner owner);
    public abstract virtual ISymbolFilter[] GetSymbolFilters(IResolveContext resolveContext);
    public virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext, ISymbolTable symbolTable);
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.ManagedQualifiedReferenceBase`1 : ManagedReferenceBase`1<TTreeNode> {
    public bool IsQualified { get; }
    public bool ShouldResolveInGlobalTable { get; }
    protected ManagedQualifiedReferenceBase`1(TTreeNode owner);
    public abstract virtual bool get_IsQualified();
    public abstract virtual IQualifier GetQualifier(IResolveContext resolveContext);
    public virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    private sealed virtual override IQualifier JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IQualifiableReference.GetQualifier();
    private sealed virtual override ResolveResultWithInfo JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IResolverQualifiableReference.Resolve(ISymbolTable symbolTable, IAccessContext context);
    public sealed virtual bool get_ShouldResolveInGlobalTable();
    [NotNullAttribute]
protected abstract virtual ResolveResultWithInfo FullResolve(IResolveContext resolveContext, ISymbolTable symbolTable);
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.ManagedReferenceBase`1 : UserDataHolder {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
protected TOwnerElement myOwner;
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private CachedPsiValue`1<ResolveResultWithInfo> myResolveCache;
    public bool HasMultipleNames { get; }
    [NotNullAttribute]
[UsedImplicitlyAttribute]
private TOwnerElement Owner { get; }
    public ResolveResultWithInfo CurrentResolveResult { get; public set; }
    [CanBeNullAttribute]
[UsedImplicitlyAttribute]
private IResolveResult FakeResolveResult { get; }
    protected ManagedReferenceBase`1(TOwnerElement owner);
    public abstract virtual string GetName();
    public virtual bool get_HasMultipleNames();
    public virtual HybridCollection`1<string> GetAllNames();
    public abstract virtual TreeTextRange GetTreeTextRange();
    public abstract virtual IReference BindTo(IDeclaredElement element);
    public abstract virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    [NotNullAttribute]
public virtual string Dump();
    public abstract virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    public sealed virtual IAccessContext GetAccessContext();
    public abstract virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
    [DebuggerStepThroughAttribute]
public sealed virtual ITreeNode GetTreeNode();
    private TOwnerElement get_Owner();
    [NotNullAttribute]
public IPsiServices GetPsiServices();
    public virtual bool IsValid();
    private sealed virtual override ResolveResultWithInfo JetBrains.ReSharper.Psi.Resolve.IReference.Resolve();
    public sealed virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public sealed virtual ResolveResultWithInfo get_CurrentResolveResult();
    public sealed virtual void set_CurrentResolveResult(ResolveResultWithInfo value);
    private IResolveResult get_FakeResolveResult();
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.ManagedTwoPhaseReferenceImplBase`1 : ManagedQualifiedReferenceBase`1<TElement> {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private CachedPsiValue`1<ResolveResultWithInfo> myPreResolveCache;
    public ResolveResultWithInfo CurrentPreResolveResult { get; public set; }
    protected ManagedTwoPhaseReferenceImplBase`1(TElement owner);
    public sealed virtual ResolveResultWithInfo get_CurrentPreResolveResult();
    public sealed virtual void set_CurrentPreResolveResult(ResolveResultWithInfo value);
    public abstract virtual ResolveResultWithInfo PreResolve(IResolveContext resolveContext, ISymbolTable symbolTable);
    public sealed virtual ResolveResultWithInfo Resolve(IResolveContext resolveContext);
    protected virtual ResolveResultWithInfo FullResolve(IResolveContext resolveContext, ISymbolTable symbolTable);
    [NotNullAttribute]
protected virtual ResolveResultWithInfo RefineResolve(IResolveContext resolveContext, ResolveResultWithInfo preResolve);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.OnlyReadUniversalCalculationProcess : CalculationProcess {
    public virtual TValue Get(CascadingCacheKey cacheKey, TKey key, TParameter param, IResolveContext resolveContext, Func`4<TKey, TParameter, IResolveContext, TValue> calculator);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.OnlyReadUniversalResolveContext : ResolveContext {
    public OnlyReadUniversalResolveContext(IManagedReference managedReference);
    public OnlyReadUniversalResolveContext(ITreeNode element);
    public OnlyReadUniversalResolveContext(IPsiModule module);
    public virtual IExpressionType ExpressionType(IManagedExpression expression);
    public virtual bool HasResolveInfo(IManagedReference reference);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.ResolveContext : object {
    [NotNullAttribute]
private ICalculationProcess myCalculationProcess;
    [NotNullAttribute]
private Thread myThread;
    [CompilerGeneratedAttribute]
private IPsiModule <PsiModule>k__BackingField;
    private List`1<ForkedContexts> myForkedContexts;
    [NotNullAttribute]
private static Func`4<IManagedOnePhaseReferenceImpl, ISymbolTable, IResolveContext, ResolveResultWithInfo> ourResolveCalculator;
    [NotNullAttribute]
private static Func`4<IManagedReferenceImpl, object, IResolveContext, ResolveResultWithInfo> ourResolveWithInfoCalculator;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
private static Func`4<ValueTuple`2<ITreeNode, IVerifier>, object, IResolveContext, object> ourVerifyCalculator;
    [NotNullAttribute]
private static Func`4<IManagedVariableImpl, object, IResolveContext, IType> ourTypeOfCalculator;
    [NotNullAttribute]
private static Func`4<IManagedConvertibleImpl, object, IResolveContext, IType> ourImplicitlyConvertedToCalculator;
    [NotNullAttribute]
private static Func`4<IManagedTwoPhaseReferenceImpl, ISymbolTable, IResolveContext, ResolveResultWithInfo> ourPreResolveCalculator;
    [NotNullAttribute]
private static Func`4<IManagedConstantValueOwnerImpl, object, IResolveContext, ConstantValue> ourConstantValueCalculator;
    [NotNullAttribute]
private static Func`4<IManagedExpressionImpl, ICalculationInfo, IResolveContext, ConstantValue> ourConstantValueWithInfoCalculator;
    public IPsiModule PsiModule { get; }
    [DebuggerStepThroughAttribute]
public ResolveContext(IPsiModule module);
    [DebuggerStepThroughAttribute]
protected ResolveContext(IPsiModule module, ICalculationProcess calculationProcess);
    private static ResolveContext();
    [ConditionalAttribute("JET_MODE_ASSERT")]
internal static void AssertResultIsConsistent(IManagedReferenceImpl reference, ResolveResultWithInfo result);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertThreadAffinity();
    [ConditionalAttribute("JET_MODE_ASSERT")]
internal static void AssertModuleResolveContextIsLocal(IManagedReference reference);
    [ConditionalAttribute("JET_MODE_ASSERT")]
internal static void AssertModuleResolveContextIsLocal(IManagedExpression expression);
    [ConditionalAttribute("JET_MODE_ASSERT")]
internal static void AssertModuleResolveContextIsLocal(IManagedConstantValueOwner owner);
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_PsiModule();
    private bool TryGetForkedContext(IList`1<ValueTuple`2<IManagedVariable, IType>> assumptions, IResolveContext& result);
    public sealed virtual IResolveContext TryFork(IList`1<ValueTuple`2<IManagedVariable, IType>> assumptions);
    public sealed virtual IResolveContext TryForkOnImplicitlyConvertedTo(IList`1<ValueTuple`2<IManagedConvertible, IType>> assumptions);
    [CanBeNullAttribute]
private IResolveContext DoFork(CascadingCacheKey cacheKey, IList`1<ValueTuple`2<TKey, TValue>> assumptions);
    [NotNullAttribute]
protected virtual ResolveContext CreateForkedResolveContext(ICalculationProcess forkedCalculationProcess);
    public sealed virtual void Join(IResolveContext resolveContext);
    public virtual bool HasResolveInfo(IManagedReference reference);
    public virtual bool HasForkedImplicitlyConvertedTo(IManagedConvertible managedConvertible);
    public ResolveResultWithInfo Resolve(IManagedOnePhaseReferenceImpl managedReference, ISymbolTable symbolTable);
    [NotNullAttribute]
private static ResolveResultWithInfo ResolveCalculator(IManagedOnePhaseReferenceImpl reference, ISymbolTable symbolTable, IResolveContext resolveContext);
    public sealed virtual ResolveResultWithInfo ResolveWithInfo(IManagedReference reference);
    [NotNullAttribute]
private static ResolveResultWithInfo ResolveWithInfoCalculator(IManagedReferenceImpl reference, object state, IResolveContext resolveContext);
    public sealed virtual object Verify(ITreeNode element, IVerifier verifier);
    [CanBeNullAttribute]
private static object VerifyCalculator(ValueTuple`2<ITreeNode, IVerifier> verification, object state, IResolveContext resolveContext);
    public sealed virtual IType TypeOf(IManagedVariable managedVariable);
    [NotNullAttribute]
private static IType TypeOfCalculator(IManagedVariableImpl variable, object state, IResolveContext resolveContext);
    public virtual IExpressionType ExpressionType(IManagedExpression expression);
    public sealed virtual IType GetImplicitlyConvertedTo(IManagedConvertible convertible);
    [NotNullAttribute]
private static IType CalculateImplicitlyConvertedToCalculator(IManagedConvertibleImpl variable, object state, IResolveContext resolveContext);
    public sealed virtual ResolveResultWithInfo PreResolve(IManagedTwoPhaseReference reference, ISymbolTable table);
    [NotNullAttribute]
private static ResolveResultWithInfo PreResolveCalculator(IManagedTwoPhaseReferenceImpl reference, ISymbolTable table, IResolveContext resolveContext);
    public sealed virtual ConstantValue ConstantValue(IManagedConstantValueOwner constantValueOwner);
    [NotNullAttribute]
private static ConstantValue ConstantValueCalculator(IManagedConstantValueOwnerImpl constantValueOwner, object state, IResolveContext resolveContext);
    public sealed virtual ConstantValue ConstantValue(IManagedExpression expression, ICalculationInfo info);
    [NotNullAttribute]
private static ConstantValue ConstantValueCalculatorWithInfo(IManagedExpressionImpl managedExpression, ICalculationInfo info, IResolveContext resolveContext);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Managed.UniversalContext : ResolveContext {
    [DebuggerStepThroughAttribute]
public UniversalContext(IManagedReference managedReference);
    [DebuggerStepThroughAttribute]
public UniversalContext(ITreeNode element);
    [DebuggerStepThroughAttribute]
public UniversalContext(IPsiModule module);
    public virtual IExpressionType ExpressionType(IManagedExpression expression);
    public virtual bool HasResolveInfo(IManagedReference reference);
    public virtual bool HasForkedImplicitlyConvertedTo(IManagedConvertible managedConvertible);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.MergedSymbolTable : SymbolTableBase {
    [DebuggerBrowsableAttribute("0")]
private ISymbolTable[] myTables;
    [DebuggerBrowsableAttribute("3")]
[PublicAPIAttribute]
public IReadOnlyList`1<ISymbolTable> Constituents { get; }
    internal MergedSymbolTable(ISymbolTable table1, ISymbolTable table2);
    internal MergedSymbolTable(ICollection`1<ISymbolTable> tables);
    public IReadOnlyList`1<ISymbolTable> get_Constituents();
    private static int Count(ISymbolTable table);
    private int AddTable(ISymbolTable table, int destinationIndex);
    public virtual IList`1<ISymbolInfo> GetSymbolInfos(string name);
    public virtual void AppendSymbolInfos(string name, List`1<ISymbolInfo> consumer);
    public virtual bool ForAllSymbolInfos(TState state, Func`3<TState, ISymbolInfo, bool> processor);
    public virtual IEnumerable`1<string> Names();
    public virtual ISymbolTableDependencySet GetDependencySet();
    public sealed virtual void AddDependenciesTo(IDependencyStore store, string accessName);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.MultipleFilterNamedSymbolTable : SymbolTableBase {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbolTable <BaseTable>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbolFilter[] <Filters>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<ISymbolInfo> myFilteredSymbols;
    private IResolveInfo myResolveErrorType;
    private bool myFilteredSymbolsAreCandidates;
    private string Name { get; }
    private ISymbolTable BaseTable { get; }
    private ISymbolFilter[] Filters { get; }
    public MultipleFilterNamedSymbolTable(ISymbolTable baseTable, string name, ISymbolFilter[] filters);
    [CompilerGeneratedAttribute]
private string get_Name();
    [CompilerGeneratedAttribute]
private ISymbolTable get_BaseTable();
    [CompilerGeneratedAttribute]
private ISymbolFilter[] get_Filters();
    private void ComputeFilteredSymbols();
    public virtual IList`1<ISymbolInfo> GetSymbolInfos(string name);
    public virtual void AppendSymbolInfos(string name, List`1<ISymbolInfo> consumer);
    public virtual IList`1<ISymbolInfo> GetSymbolInfosConstitutingResolveResult(string name, IResolveInfo& resolveInfo);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.MultipleFilterNamedSymbolTable/<Names>d__17")]
public virtual IEnumerable`1<string> Names();
    public virtual bool ForAllSymbolInfos(TState state, Func`3<TState, ISymbolInfo, bool> processor);
    [NullableContextAttribute("2")]
public virtual ISymbolTableDependencySet GetDependencySet();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.MultipleFilterSymbolTable : SymbolTableBase {
    private List`1<ISymbolFilter> myFilters;
    private ISymbolTable myBaseTable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, IList`1<ISymbolInfo>> myByNameCache;
    [CompilerGeneratedAttribute]
private bool <CaseSensitive>k__BackingField;
    private static int MaxCapacityToPool;
    private static Pool<string, ISymbolInfo> ourByNamesMultiDictionaryPool;
    private static Pool<string, ISymbolInfo> ourByNamesMultiDictionaryCaseSensitivePool;
    public bool CaseSensitive { get; public set; }
    private StringComparer NameComparer { get; }
    public MultipleFilterSymbolTable(ISymbolTable baseTable, ISymbolFilter[] filters);
    internal MultipleFilterSymbolTable(ISymbolTable baseTable);
    private static MultipleFilterSymbolTable();
    internal void AppendFilter(ISymbolFilter symbolFilter);
    [CompilerGeneratedAttribute]
public bool get_CaseSensitive();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CaseSensitive(bool value);
    private StringComparer get_NameComparer();
    public virtual IList`1<ISymbolInfo> GetSymbolInfos(string name);
    public virtual void AppendSymbolInfos(string name, List`1<ISymbolInfo> consumer);
    private IList`1<ISymbolInfo> Filter(List`1<ISymbolInfo> sourceList);
    public virtual IEnumerable`1<string> Names();
    [NullableContextAttribute("2")]
public virtual ISymbolTableDependencySet GetDependencySet();
    public virtual bool ForAllSymbolInfos(TState state, Func`3<TState, ISymbolInfo, bool> processor);
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.QualifiableCheckedReferenceBase`1 : CheckedReferenceBase`1<T> {
    public bool IsQualified { get; }
    [NotNullAttribute]
protected SymbolTableMode SymbolTableMode { get; }
    public bool ShouldResolveInGlobalTable { get; }
    protected QualifiableCheckedReferenceBase`1(T owner);
    public abstract virtual bool get_IsQualified();
    public abstract virtual IQualifier GetQualifier();
    protected virtual SymbolTableMode get_SymbolTableMode();
    public virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public sealed virtual ResolveResultWithInfo ResolveWithoutCache();
    public virtual ResolveResultWithInfo Resolve(ISymbolTable symbolTable, IAccessContext context);
    public virtual bool get_ShouldResolveInGlobalTable();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ReferenceCollector`1 : object {
    private Func`2<T, bool> myPredicate;
    private bool myFirstClassOnly;
    [CompilerGeneratedAttribute]
private IList`1<T> <References>k__BackingField;
    public IList`1<T> References { get; }
    public bool ProcessingIsFinished { get; }
    public ReferenceCollector`1(Func`2<T, bool> acceptReference);
    public ReferenceCollector`1(Func`2<T, bool> acceptReference, bool firstClassOnly);
    [CompilerGeneratedAttribute]
public IList`1<T> get_References();
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ReferenceCollectorExtensions : object {
    [ExtensionAttribute]
public static ReferenceCollector`1<T> ProcessIncludingElement(ReferenceCollector`1<T> referenceCollector, ITreeNode element);
    [ExtensionAttribute]
public static ReferenceCollector`1<T> Process(ReferenceCollector`1<T> referenceCollector, ITreeNode element);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ResolveResultWithInfo : object {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
public static ResolveResultWithInfo Unresolved;
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
public static ResolveResultWithInfo Ignore;
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
public static ResolveResultWithInfo Dynamic;
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
public static ResolveResultWithInfo EmptyDynamic;
    [NotNullAttribute]
public IResolveResult Result;
    [NotNullAttribute]
public IResolveInfo Info;
    [CanBeNullAttribute]
public IDeclaredElement DeclaredElement { get; }
    [NotNullAttribute]
public ISubstitution Substitution { get; }
    [NotNullAttribute]
public ResolveErrorType ResolveErrorType { get; }
    public ResolveResultWithInfo(IResolveResult result, IResolveInfo info);
    private static ResolveResultWithInfo();
    public IDeclaredElement get_DeclaredElement();
    public ISubstitution get_Substitution();
    public ResolveErrorType get_ResolveErrorType();
    public bool IsValid();
    public void Deconstruct(IDeclaredElement& declaredElement);
    public void Deconstruct(IDeclaredElement& declaredElement, ISubstitution& substitution);
    public void Deconstruct(IDeclaredElement& declaredElement, ISubstitution& substitution, ResolveErrorType& resolveErrorType);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ResolveResultWithInfoExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IReadOnlyCollection`1<IDeclaredElement> GetDynamicDeclaredElements(ResolveResultWithInfo resultWithInfo);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IDeclaredElement GetAcceptableDeclaredElement(ResolveResultWithInfo resultWithInfo);
}
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ResolveUtil : object {
    public static Key`1<DeclaredElementInstance> InProcessKey;
    private static Key`1<IResolveResult> ourFakeResolveKey;
    [NotNullAttribute]
private static SymbolTableFactory ourSymbolTableCalculator;
    [NotNullAttribute]
private static ObjectPool`1<PooledHashSet`1<IDeclaredType>> ourVisitedPool;
    [NotNullAttribute]
private static SymbolTableFactory ourOwnMembersCalculator;
    [ThreadStaticAttribute]
private static JetHashSet`1<IReference> ourReferencesInProgress;
    private static ResolveUtil();
    [CanBeNullAttribute]
[ContractAnnotationAttribute("function: notnull => notnull")]
public static ISymbolTable CreateParametersTable(IParametersOwner function, int level);
    [NotNullAttribute]
public static ISymbolTable AddDeclarationsForProperDeclaredType(IDeclaredType type, int level, bool addObjectMembersForInterfaces, SymbolTableMode mode, IPsiModule module, HashSet`1<IDeclaredType> visited);
    [NotNullAttribute]
private static ISymbolTable AddTypeParameterInterfaceConstraintMembers(ITypeParameter typeParameter, int level, IPsiModule module, HashSet`1<IDeclaredType> visited);
    [NotNullAttribute]
public static ISymbolTable AddTypeMembers(IDeclaredType type, int level, Nullable`1<int> inheritanceLevel, SymbolTableMode mode, HashSet`1<IDeclaredType> visited);
    [NotNullAttribute]
public static ISymbolTable GetSymbolTableByTypeElement(ITypeElement typeElement, SymbolTableMode mode, IPsiModule psiModule);
    [NotNullAttribute]
public static ISymbolTable GetSymbolTableByTypeElement(ITypeElement typeElement, int level, SymbolTableMode mode, IPsiModule psiModule);
    [CanBeNullAttribute]
private static ISymbolTable SymbolTableBuilder(SymbolTableMode mode, ITypeElement element, IPsiModule psiModule);
    [NotNullAttribute]
public static ISymbolTable GetOwnMembersSymbolTable(ITypeElement typeElement, SymbolTableMode mode);
    [NotNullAttribute]
private static ISymbolTable OwnMembersSymbolTableBuilder(SymbolTableMode mode, ITypeElement element, IPsiModule psiModule);
    private static void AddAllMembersExceptConstructors(ITypeElement element, LocalList`1& members);
    private static void AddNestedTypes(ITypeElement element, LocalList`1& members);
    [NotNullAttribute]
public static ISymbolTable GetSymbolTableByNamespace(INamespace element, IPsiModule module, bool withReferences, ISymbolScope cachedSymbolScope);
    [NotNullAttribute]
[PureAttribute]
public static ISymbolTable CreateSingletonSymbolTable(string alias, IDeclaredElement element, ISubstitution substitution);
    [NotNullAttribute]
[PureAttribute]
public static ISymbolTable CreateSingletonSymbolTable(IDeclaredElement element, ISubstitution substitution);
    [NotNullAttribute]
[PureAttribute]
public static ISymbolTable CreateSymbolTable(IEnumerable`1<DeclaredElementInstance> elements);
    [NotNullAttribute]
public static ISymbolTable CreateSymbolTable(IEnumerable`1<ExtensionInstance`1<IDeclaredElement>> elements, Func`4<string, IDeclaredElement, ISubstitution, ISymbolInfo> extensionInfoCreator);
    [NotNullAttribute]
[PureAttribute]
public static ISymbolTable CreateSymbolTable(IEnumerable`1<TDeclaredElement> sourceElements, int level);
    [NotNullAttribute]
[PureAttribute]
public static ISymbolTable CreateSymbolTable(IList`1<TDeclaredElement> sourceElement, int level);
    [NotNullAttribute]
[PureAttribute]
public static ISymbolTable CreateSymbolTable(IList`1<TDeclaredElement> elements, IList`1<ISubstitution> substitutions);
    [NotNullAttribute]
[PureAttribute]
public static ISymbolTable CreateSymbolTable(IDeclaredElement element, int level);
    [CanBeNullAttribute]
public static IResolveIsolationScope GetResolveIsolationScope(ITreeNode element);
    public static void SetFakedResolveTo(IReference reference, IResolveResult result);
    public static void SetFakedResolveTo(IReference reference, IDeclaredElement element, ISubstitution substitution);
    [CanBeNullAttribute]
public static IResolveResult GetFakeResolveTo(IReference reference);
    public static void ClearFakedResolveTo(IReference reference);
    public static void ClearReferenceResolveCache(IReference reference);
    [NotNullAttribute]
public static ResolveResultWithInfo ResolveWithCache(TReference reference, Func`2<TReference, ResolveResultWithInfo> resolveWithoutCache);
    [NotNullAttribute]
public static ISymbolTable GetSymbolTableByReference(IQualifiableReference reference, SymbolTableMode mode, bool useReferenceName);
    [NotNullAttribute]
public static ISymbolTable BuildSymbolTableForReference(IReference reference, SymbolTableMode mode);
    [NotNullAttribute]
private static ISymbolTable CreateConstructorSymbolTable(ITypeElement typeElement, ISubstitution substitution);
    [NotNullAttribute]
private static ISymbolTable CreateDefaultConstructorSymbolTable(ITypeElement typeElement, ISubstitution substitution);
    [NotNullAttribute]
public static ISymbolTable CreateConstructorSymbolTable(IResolveResult resolveResult);
    [NotNullAttribute]
public static ISymbolTable CreateConstructorSymbolTable(IDeclaredType declaredType);
    [NotNullAttribute]
public static ISymbolTable CreateDefaultConstructorSymbolTable(IDeclaredType declaredType);
    [CanBeNullAttribute]
private static ITreeNode GetParent(ITreeNode node);
    [CanBeNullAttribute]
public static ITypeElement GetAccessContainingTypeElement(ITreeNode node);
    [CanBeNullAttribute]
public static ITypeMember GetAccessContainingTypeMember(ITreeNode node);
    [NotNullAttribute]
public static ResolveResultWithInfo CreateResolveResult(IList`1<T> elements);
    public static bool CheckThatAllReferencesBelongToElement(ReferenceCollection references, ITreeNode element);
    public static bool ReferenceSetsAreEqual(ReferenceCollection newReferences, ReferenceCollection oldReferences);
    [PureAttribute]
public static bool IsGoodResolveForRemovingStaticQualifier(ResolveResultWithInfo resolveResult);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ScopeExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsActiveScope(IScope scope);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static IScope GetContainingScope(ITreeNode treeNode, bool returnThis);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static TScope GetContainingScope(ITreeNode treeNode, bool returnThis);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<IScope> ContainingScopes(ITreeNode element, bool returnThis);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ScopeExtensions/<ContainingScopes>d__4`1")]
[ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<TScope> ContainingScopes(ITreeNode element, bool returnThis);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.ScopeExtensions/<ThisAndDescendantScopes>d__5`1")]
[ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<TScope> ThisAndDescendantScopes(ITreeNode element);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.SymbolInfo : object {
    [CompilerGeneratedAttribute]
private IDeclaredElement <DeclaredElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubstitution <Substitution>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <InheritanceLevel>k__BackingField;
    [NotNullAttribute]
private IDeclaredElement DeclaredElement { get; }
    [NotNullAttribute]
private ISubstitution Substitution { get; }
    public string ShortName { get; }
    public int Level { get; }
    public Nullable`1<int> InheritanceLevel { get; }
    public SymbolInfo(IDeclaredElement declaredElement);
    public SymbolInfo(IDeclaredElement declaredElement, ISubstitution substitution);
    public SymbolInfo(string aliasName, IDeclaredElement declaredElement, ISubstitution substitution);
    public SymbolInfo(string aliasName, IDeclaredElement declaredElement, ISubstitution substitution, int importLevel, Nullable`1<int> inheritanceLevel);
    [CompilerGeneratedAttribute]
private IDeclaredElement get_DeclaredElement();
    [CompilerGeneratedAttribute]
private ISubstitution get_Substitution();
    [DebuggerStepThroughAttribute]
public sealed virtual IDeclaredElement GetDeclaredElement();
    [DebuggerStepThroughAttribute]
public sealed virtual ISubstitution GetSubstitution();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ShortName();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Level();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_InheritanceLevel();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual ISymbolInfo ReplaceSubstitution(ISubstitution composedSubstitution);
    public virtual ISymbolInfo ReplaceLevel(int level);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.SymbolTable : SymbolTableBase {
    [CompilerGeneratedAttribute]
private DependencyStore <dependencyStore>P;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ISymbolTableDependencySet <dependencySet>P;
    [DebuggerBrowsableAttribute("0")]
private OneToListMap`2<string, ISymbolInfo> myDeclaredElements;
    [DebuggerBrowsableAttribute("3")]
private IList`1<ISymbolInfo> AllItems { get; }
    public SymbolTable(DependencyStore dependencyStore, ISymbolTableDependencySet dependencySet);
    public SymbolTable(IPsiServices psiServices, ISymbolTableDependencySet dependencySet);
    private IList`1<ISymbolInfo> get_AllItems();
    public ISymbolInfo AddSymbol(IDeclaredElement declaredElement);
    public ISymbolInfo AddSymbol(IDeclaredElement declaredElement, int level);
    public ISymbolInfo AddSymbol(IDeclaredElement declaredElement, ISubstitution substitution, int level);
    public ISymbolInfo AddSymbol(string alias, IDeclaredElement declaredElement);
    public ISymbolInfo AddSymbol(string alias, IDeclaredElement declaredElement, ISubstitution substitution, int level);
    private ISymbolInfo AddSymbolImpl(string name, IDeclaredElement symbol, ISubstitution substitution, int level);
    public virtual IList`1<ISymbolInfo> GetSymbolInfos(string name);
    public virtual void AppendSymbolInfos(string name, List`1<ISymbolInfo> consumer);
    public virtual IEnumerable`1<string> Names();
    [NullableContextAttribute("2")]
public virtual ISymbolTableDependencySet GetDependencySet();
    public virtual bool ForAllSymbolInfos(TState state, Func`3<TState, ISymbolInfo, bool> processor);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.SymbolTableBase : object {
    protected static StringComparer NameComparer;
    protected static StringComparison NameComparison;
    public static ObjectPool`1<PooledList`1<ISymbolInfo>> TempListPool;
    private static SymbolTableBase();
    public virtual IList`1<ISymbolInfo> GetSymbolInfosConstitutingResolveResult(string name, IResolveInfo& resolveInfo);
    public abstract virtual IList`1<ISymbolInfo> GetSymbolInfos(string name);
    public abstract virtual void AppendSymbolInfos(string name, List`1<ISymbolInfo> consumer);
    public sealed virtual void ForAllSymbolInfos(Action`1<ISymbolInfo> processor);
    public abstract virtual bool ForAllSymbolInfos(TState state, Func`3<TState, ISymbolInfo, bool> processor);
    public abstract virtual IEnumerable`1<string> Names();
    [NullableContextAttribute("2")]
public abstract virtual ISymbolTableDependencySet GetDependencySet();
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.TreeReferenceBase`1 : UserDataHolder {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
protected TOwnerElement myOwner;
    [DebuggerBrowsableAttribute("0")]
[CanBeNullAttribute]
private CachedPsiValue`1<ResolveResultWithInfo> myResolveCache;
    [NotNullAttribute]
[DebuggerBrowsableAttribute("0")]
private static Func`2<TreeReferenceBase`1<TOwnerElement>, ResolveResultWithInfo> ResolveWithoutCacheFunc;
    public ResolveResultWithInfo CurrentResolveResult { get; public set; }
    [NotNullAttribute]
[UsedImplicitlyAttribute]
private TOwnerElement Owner { get; }
    public bool HasMultipleNames { get; }
    protected TreeReferenceBase`1(TOwnerElement owner);
    private static TreeReferenceBase`1();
    public virtual bool IsValid();
    public sealed virtual ResolveResultWithInfo get_CurrentResolveResult();
    public sealed virtual void set_CurrentResolveResult(ResolveResultWithInfo value);
    [NotNullAttribute]
public abstract virtual ResolveResultWithInfo ResolveWithoutCache();
    [DebuggerStepThroughAttribute]
public sealed virtual ITreeNode GetTreeNode();
    [NotNullAttribute]
[DebuggerStepThroughAttribute]
public TOwnerElement GetElement();
    private TOwnerElement get_Owner();
    public virtual bool get_HasMultipleNames();
    public abstract virtual string GetName();
    public virtual HybridCollection`1<string> GetAllNames();
    public abstract virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    public abstract virtual IReference BindTo(IDeclaredElement element);
    public abstract virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public abstract virtual IAccessContext GetAccessContext();
    private static ResolveResultWithInfo ResolveWithoutCache(TreeReferenceBase`1<TOwnerElement> reference);
    public virtual ResolveResultWithInfo Resolve();
    public abstract virtual TreeTextRange GetTreeTextRange();
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.TwoPhaseReferenceBase`1 : TreeReferenceBase`1<TElement> {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private CachedPsiValue`1<ResolveResultWithInfo> myPreResolveCache;
    [NotNullAttribute]
private static Func`3<TwoPhaseReferenceBase`1<TElement>, ISymbolTable, ResolveResultWithInfo> ourResolveCalculator;
    public bool ShouldResolveInGlobalTable { get; }
    public bool IsQualified { get; }
    public ResolveResultWithInfo CurrentPreResolveResult { get; public set; }
    protected TwoPhaseReferenceBase`1(TElement owner);
    private static TwoPhaseReferenceBase`1();
    public abstract virtual IQualifier GetQualifier();
    public abstract virtual ResolveResultWithInfo PreResolveWithoutCache(ISymbolTable symbolTable);
    private static ResolveResultWithInfo PreResolveCalculator(TwoPhaseReferenceBase`1<TElement> reference, ISymbolTable symbolTable);
    public virtual ResolveResultWithInfo PreResolve(ISymbolTable symbolTable);
    public sealed virtual ResolveResultWithInfo Resolve(ISymbolTable symbolTable, IAccessContext context);
    protected virtual ResolveResultWithInfo RefineResolve(ResolveResultWithInfo preResolve);
    public virtual bool get_ShouldResolveInGlobalTable();
    public virtual bool get_IsQualified();
    public sealed virtual ResolveResultWithInfo get_CurrentPreResolveResult();
    public sealed virtual void set_CurrentPreResolveResult(ResolveResultWithInfo value);
}
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.TwoPhaseReferenceUtil : object {
    [ThreadStaticAttribute]
[CanBeNullAttribute]
private static JetHashSet`1<IReference> ourReferencesInProgress;
    public static ResolveResultWithInfo PreResolve(TwoPhaseReferenceBase`1<TElement> reference, ISymbolTable symbolTable, Func`3<TwoPhaseReferenceBase`1<TElement>, ISymbolTable, ResolveResultWithInfo> resolveCalculator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Verification.ExpressionVerifier : object {
    private IResolveContext myResolveContext;
    [NullableAttribute("2")]
private VerifierRegistry myVerifierRegistry;
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    public bool Success { get; private set; }
    public bool ProcessingIsFinished { get; }
    public ExpressionVerifier(IResolveContext resolveContext);
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    private IEnumerable`1<IVerifier> GetVerifiers(TreeElement treeElement);
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
private void set_Success(bool value);
    public sealed virtual bool get_ProcessingIsFinished();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Verification.IVerifier {
    [NotNullAttribute]
public IEnumerable`1<NodeType> Nodes { get; }
    public abstract virtual IEnumerable`1<NodeType> get_Nodes();
    [CanBeNullAttribute]
public abstract virtual object Verify(IResolveContext resolveContext, ITreeNode element);
}
[MeansImplicitUseAttribute]
[BaseTypeRequiredAttribute("JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Verification.IVerifier")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Verification.VerifierAttribute : PsiSharedComponentAttribute {
    public VerifierAttribute(Instantiation instantiation);
}
[DefaultMemberAttribute("Item")]
[PsiSharedComponentAttribute("18")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.Verification.VerifierRegistry : object {
    private OneToSetMap`2<NodeType, IVerifier> myNodeVerifiersCache;
    public IEnumerable`1<IVerifier> Item { get; }
    public VerifierRegistry(Lifetime lifetime, IEnumerable`1<IVerifier> verifiers);
    public IEnumerable`1<IVerifier> get_Item(NodeType nodeType);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.SecondaryDocumentGenerationResult : object {
    [CompilerGeneratedAttribute]
private ILexerFactory <LexerFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiLanguageType <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private ISecondaryRangeTranslator <SecondaryRangeTranslator>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuffer <Buffer>k__BackingField;
    public ILexerFactory LexerFactory { get; }
    public PsiLanguageType Language { get; }
    public ISecondaryRangeTranslator SecondaryRangeTranslator { get; }
    public IBuffer Buffer { get; }
    public SecondaryDocumentGenerationResult(string text, PsiLanguageType language, ISecondaryRangeTranslator secondaryRangeTranslator, ILexerFactory lexerFactory);
    [CompilerGeneratedAttribute]
public sealed virtual ILexerFactory get_LexerFactory();
    [CompilerGeneratedAttribute]
public sealed virtual PsiLanguageType get_Language();
    [CompilerGeneratedAttribute]
public sealed virtual ISecondaryRangeTranslator get_SecondaryRangeTranslator();
    [CompilerGeneratedAttribute]
public sealed virtual IBuffer get_Buffer();
    public virtual void CommitChanges();
}
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.SharedImplUtil : object {
    public static string MISSING_DECLARATION_NAME;
    [ThreadStaticAttribute]
[CanBeNullAttribute]
private static HashSet`1<IParameter> ourParametersInProgress;
    [ThreadStaticAttribute]
[CanBeNullAttribute]
[ItemNotNullAttribute]
private static HashSet`1<ITypeParameter> ourTypeParametersNullabilityComputation;
    [NotNullAttribute]
public static String[] DELEGATE_MEMBER_NAMES;
    private static SharedImplUtil();
    [PureAttribute]
public static AccessibilityDomain CalcAccessibilityDomain(ITypeMember member);
    [PureAttribute]
public static AccessibilityDomain CalcAccessibilityDomain(ITypeMember member, AccessRights accessRights);
    [CanBeNullAttribute]
private static ITypeMember GetContainerTypeMember(ITypeElement container);
    [CanBeNullAttribute]
public static IDocCommentBlock GetDocCommentBlockNode(ITreeNode node);
    [CanBeNullAttribute]
public static XmlNode GetParameterXmlDoc(IParameter parameter, bool inherit);
    [CanBeNullAttribute]
public static XmlNode GetParameterSummaryDoc(IParameter parameter, bool inherit);
    public static void SetDocCommentBlockNode(ITreeNode node, IDocCommentBlock block);
    [NotNullAttribute]
public static IList`1<IDeclaredType> GetTypeParameterSuperTypes(ITypeParameter typeParameter, bool isValueType, IEnumerable`1<IType> constraints);
    [NotNullAttribute]
[PureAttribute]
public static IList`1<IDeclaration> GetDeclarationsIn(IDeclaredElement declaredElement, IPsiSourceFile sourceFile);
    public static bool IsDefaultConstructor(IConstructor constructor);
    public static bool BindingTransaction(T& reference, Func`2<T, T> processor, Func`2<T, bool> resolveChecker);
    public static T BindingTransaction(T reference, Func`2<T, T> processor, Func`2<T, bool> resolveChecker);
    public static void SetKeywordAtFirstPlace(bool value, ITreeNode root, ITokenNode keyword, TokenNodeType keywordType);
    public static void SetKeywordAfter(bool value, ITreeNode root, ITokenNode firstKeyword, ITokenNode keyword, TokenNodeType keywordType);
    [PureAttribute]
public static TypeParameterNullability GetTypeParameterNullability(TypeParameterNullability nullabilityFromNonTypeConstraints, IList`1<IType> constraintTypes, ISubstitution substitution);
    [PureAttribute]
private static TypeParameterNullability GetTypeParameterNullabilityFromConstraintTypes(IList`1<IType> constraintTypes, ISubstitution substitution);
    [PureAttribute]
private static TypeParameterNullability GetTypeParameterNullabilityFromConstraintType(IType constraintType);
    [NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IList`1<IType> DeduplicateAndFixNullabilityOfTypeParameterSuperTypes(IEnumerable`1<IType> superTypes);
    [PureAttribute]
public static bool HasMemberWithName(String[] memberNames, string shortName, bool ignoreCase);
}
[RequiredMemberAttribute]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.SimpleInjectedContextData : object {
    public static SimpleInjectedContextData True;
    public static SimpleInjectedContextData False;
    [CompilerGeneratedAttribute]
private bool <CanInject>k__BackingField;
    [RequiredMemberAttribute]
public bool CanInject { get; public set; }
    private static SimpleInjectedContextData();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanInject();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CanInject(bool value);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.StaticCallBindException : Exception {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.AbstractNodeTypeIndexer : object {
    private Dictionary`2<int, NodeType> myNodeTypes;
    private Dictionary`2<int, TokenNodeType> myTokenTypes;
    [NullableAttribute("2")]
private NodeTypeDictionary`1<int> myFixedTokenLengthsNodeTypeDictionary;
    public void Add(NodeType nodeType, int index);
    public NodeType GetNodeType(int index);
    public Dictionary`2<int, TokenNodeType> GetIndexToTokenNodeTypeDictionary();
    public Dictionary`2<int, NodeType> GetIndexToNodeTypeDictionary();
    public NodeTypeDictionary`1<int> GetFixedTokenLengthsDictionary();
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.BoundToBufferLeafElement : LeafElementBaseWithCustomOffset {
    [CompilerGeneratedAttribute]
private IBuffer <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeType <NodeType>k__BackingField;
    public IBuffer Buffer { get; }
    public int Length { get; }
    public NodeType NodeType { get; }
    protected BoundToBufferLeafElement(NodeType nodeType, IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
    [CompilerGeneratedAttribute]
public IBuffer get_Buffer();
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public virtual NodeType get_NodeType();
    public virtual string ToString();
    public virtual int GetTextLength();
    public virtual StringBuilder GetText(StringBuilder to);
    public virtual string GetText();
    public virtual IBuffer GetTextAsBuffer();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ClosedChameleonElement : LeafElementBase {
    private int myLength;
    [CanBeNullAttribute]
private IBuffer myBuffer;
    private Nullable`1<int> myStartOffsetInBuffer;
    [CompilerGeneratedAttribute]
private NodeType <NodeType>k__BackingField;
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    private IBuffer Buffer { get; }
    public bool HasInitializedBuffer { get; }
    public ClosedChameleonElement(NodeType nodeType, int length);
    public ClosedChameleonElement(NodeType nodeType, IBuffer buffer, TreeOffset startOffset, int length);
    [CompilerGeneratedAttribute]
public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public virtual int GetTextLength();
    public virtual StringBuilder GetText(StringBuilder to);
    public virtual IBuffer GetTextAsBuffer();
    public virtual string GetText();
    private IBuffer get_Buffer();
    private void InitBuffer();
    public sealed virtual ITreeNode Parse(Func`2<IParser, ITreeNode> parseFunc);
    [CanBeNullAttribute]
private ITreeNode TryParseUsingTokenBuffer(Func`2<IParser, ITreeNode> parseFunc);
    protected internal virtual TreeElement DeepClone(TreeNodeCopyContext context);
    public bool get_HasInitializedBuffer();
    [CompilerGeneratedAttribute]
private bool <InitBuffer>g__IsValidBufferAndRange|16_0();
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElement : TreeElement {
    [DebuggerBrowsableAttribute("0")]
public TreeElement firstChild;
    [DebuggerBrowsableAttribute("0")]
public TreeElement lastChild;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myCachedTextLength;
    public ITreeNode FirstChild { get; }
    public ITreeNode LastChild { get; }
    [NotNullAttribute]
private IEnumerable`1<ITreeNode> Children { get; }
    public virtual ITreeNode get_FirstChild();
    public virtual ITreeNode get_LastChild();
    private IEnumerable`1<ITreeNode> get_Children();
    public virtual int GetTextLength();
    private void UpdateTreeTextCoords();
    private void ClearCachedLocationData();
    internal static TreeOffset GetTreeStartOffsetOfChild(TreeElement child);
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    protected virtual void PreInit();
    protected virtual void ClearCachedData();
    public virtual StringBuilder GetText(StringBuilder to);
    public virtual string GetText();
    public virtual IBuffer GetTextAsBuffer();
    protected internal virtual TreeElement DeepClone(TreeNodeCopyContext context);
    [NotNullAttribute]
private TreeElement AddChildBefore(TreeElement element, TreeElement anchor);
    [NotNullAttribute]
private TreeElement AddChildAfter(TreeElement element, TreeElement anchor);
    private TreeElement AddChildRange(TreeElement first, TreeElement last);
    private TreeElement AddChildRangeAfter(TreeElement first, TreeElement last, TreeElement leftAnchor);
    private void DeleteChildRange(TreeElement first, TreeElement last);
    public void AppendNewChild(TreeElement child);
    [NotNullAttribute]
private TreeElement AddChild(TreeElement element);
    [NotNullAttribute]
public ITreeNode AddChild(ITreeNode element);
    [NotNullAttribute]
public ITreeNode AddChildBefore(ITreeNode element, ITreeNode anchor);
    [NotNullAttribute]
public ITreeNode AddChildAfter(ITreeNode element, ITreeNode anchor);
    public ITreeNode AddChildRange(ITreeNode first, ITreeNode last);
    public ITreeNode AddChildRangeAfter(ITreeNode first, ITreeNode last, ITreeNode anchor);
    public void DeleteChildRange(ITreeNode first, ITreeNode last);
    public virtual short GetChildRole(TreeElement child);
    [PureAttribute]
public sealed virtual TreeElement FindChildByRole(short childRole);
    public TreeNodeEnumerable`1<T> AsChildrenEnumerable(short role);
    public TreeNodeCollection`1<T> FindChildrenByRole(short childRole);
    public TreeNodeCollection`1<T> FindChildrenByRole(Predicate`1<short> rolePredicate);
    public TreeNodeCollection`1<T> FindChildrenByRole(Int16[] childRoles);
    public TreeNodeCollection`1<T> FindListOfChildrenByRole(short childRole);
    public TreeNodeCollection`1<T> FindListOfChildrenByRole(short childRole, Predicate`1<T> predicate);
    [CanBeNullAttribute]
[PureAttribute]
public T FindChildByRole(short childRole, Predicate`1<T> predicate);
    [CanBeNullAttribute]
[PureAttribute]
public TreeElement GetNextFilteredChild(ITreeNode child);
    [CanBeNullAttribute]
[PureAttribute]
public TreeElement GetPreviousFilteredChild(ITreeNode child);
    public virtual ITreeNode FindNodeAt(TreeTextRange treeRange);
    public virtual void FindNodesAtInternal(TreeTextRange relativeRange, List`1<ITreeNode> result, bool includeContainingNodes);
    public virtual IChameleonNode FindChameleonWhichCoversRange(TreeTextRange textRange);
    [CanBeNullAttribute]
public TTreeElement FindDescendant(Predicate`1<TTreeElement> predicate);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeElementExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static TreeElement GetChildByRole(ICompositeElement element, short childRole);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeNodeType : CompositeNodeType`1<CompositeElement> {
    protected CompositeNodeType(string s, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.CompositeNodeType`1 : NodeType {
    protected CompositeNodeType`1(string s, int index);
    [PureAttribute]
public abstract virtual TCompositeElement Create();
    public sealed virtual NodeType ToNodeType();
    private sealed virtual override CompositeElement JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ICompositeNodeType.Create();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ErrorElement : CompositeElement {
    [CompilerGeneratedAttribute]
private string <errorDescription>P;
    public static CompositeNodeType NODE_TYPE;
    public static int NODE_TYPE_INDEX;
    public PsiLanguageType Language { get; }
    public NodeType NodeType { get; }
    public string ErrorDescription { get; public set; }
    public ErrorElement(string errorDescription);
    private static ErrorElement();
    public virtual PsiLanguageType get_Language();
    public virtual NodeType get_NodeType();
    public virtual bool IsFiltered();
    public virtual string get_ErrorDescription();
    public virtual void set_ErrorDescription(string value);
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.FileElementBase : CompositeElement {
    private bool myIsTemporaryModifiedForSecondaryPsiGeneration;
    private NodeUserDataHolder myNodeUserDataHolder;
    private TokenBuffer myTokenBuffer;
    private IBuffer myBuffer;
    private int myPsiModificationEpoch;
    private int myPsiModificationVersion;
    private Nullable`1<long> myContentHashOnCreation;
    private IPsiSourceFile mySourceFile;
    private IPsiServices myPsiServices;
    private IDocumentRangeTranslator myDocumentRangeTranslator;
    private bool myUseCacheForTokenBuffer;
    [CompilerGeneratedAttribute]
private bool <IsPrimary>k__BackingField;
    [CompilerGeneratedAttribute]
private IReferenceProvider <ReferenceProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ILexerFactory <LexerFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private ISecondaryRangeTranslator <SecondaryRangeTranslator>k__BackingField;
    public bool IsPrimary { get; public set; }
    public IReferenceProvider ReferenceProvider { get; public set; }
    public ILexerFactory LexerFactory { get; public set; }
    public ISecondaryRangeTranslator SecondaryRangeTranslator { get; public set; }
    public IDocumentRangeTranslator DocumentRangeTranslator { get; public set; }
    public IBuffer Buffer { get; }
    public TokenBuffer TokenBuffer { get; public set; }
    public CachingLexer CachingLexer { get; }
    public bool CanContainCaseInsensitiveReferences { get; }
    public bool HasSpecialCommitReparse { get; }
    private int JetBrains.ReSharper.Psi.Tree.IFile.ModificationCounter { get; }
    public int PsiModificationVersion { get; }
    public NodeUserDataHolder NodeUserDataHolder { get; }
    public bool HoldOwnUserData { get; }
    [CompilerGeneratedAttribute]
public bool get_IsPrimary();
    [CompilerGeneratedAttribute]
public void set_IsPrimary(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IReferenceProvider get_ReferenceProvider();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ReferenceProvider(IReferenceProvider value);
    [CompilerGeneratedAttribute]
public sealed virtual ILexerFactory get_LexerFactory();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LexerFactory(ILexerFactory value);
    [CompilerGeneratedAttribute]
public sealed virtual ISecondaryRangeTranslator get_SecondaryRangeTranslator();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SecondaryRangeTranslator(ISecondaryRangeTranslator value);
    public sealed virtual IDocumentRangeTranslator get_DocumentRangeTranslator();
    public sealed virtual void set_DocumentRangeTranslator(IDocumentRangeTranslator value);
    internal void InitializeWithIdenticalDocumentRangeTranslator(IDocument document);
    [NotNullAttribute]
private IDocumentRangeTranslator CreateIdenticalDocumentRangeTranslator(IDocument document);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertIsNotTemporaryModified();
    public sealed virtual IBuffer get_Buffer();
    private void InitBuffer();
    public sealed virtual TokenBuffer get_TokenBuffer();
    public sealed virtual void set_TokenBuffer(TokenBuffer value);
    public sealed virtual TokenBuffer TryGetTokenBuffer();
    public void SetUseCacheForTokenBuffer();
    public sealed virtual CachingLexer get_CachingLexer();
    protected virtual void PreInit();
    public virtual ITreeNode SemanticDeepClone(TreeNodeCopyContext context);
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    public virtual IPsiServices GetPsiServices();
    public virtual bool IsValid();
    [DebuggerStepThroughAttribute]
public sealed virtual IPsiModule GetPsiModule();
    public virtual bool get_CanContainCaseInsensitiveReferences();
    public sealed virtual bool IsInjected();
    public virtual IPsiSourceFile GetSourceFile();
    public sealed virtual void SetSourceFile(IPsiSourceFile sourceFile);
    public void SetSourceFile(IPsiSourceFile sourceFile, bool manualPsiServices);
    public void SetPsiServices(IPsiServices psiServices);
    public Nullable`1<long> GetContentHashOnCreation();
    public void SetContentHashOnCreation(Nullable`1<long> contentHashOnCreation);
    public void Invalidate();
    public virtual void CommitReparse(ITreeNode oldElement, ITreeNode newElement);
    public virtual bool get_HasSpecialCommitReparse();
    public virtual IFile ReParse(TreeTextRange modifiedRange, string text);
    public sealed virtual PsiFileModificationInfo GetReParseResult(TreeTextRange modifiedRange, string text);
    [CanBeNullAttribute]
private static PsiFileModificationInfo GetParseResultForInjectedPsi(IFile file, TreeTextRange modifiedRange, string newText);
    private sealed virtual override int JetBrains.ReSharper.Psi.Tree.IFile.get_ModificationCounter();
    public int get_PsiModificationVersion();
    public sealed virtual NodeUserDataHolder get_NodeUserDataHolder();
    public sealed virtual bool get_HoldOwnUserData();
    public int GetFileTextLengthAndLogIfGetDocumentIsRequiredToAnswer();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.IClosedChameleonBody {
    [NotNullAttribute]
public abstract virtual ITreeNode Parse(Func`2<IParser, ITreeNode> parseFunc);
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ICompositeElement {
    public abstract virtual short GetChildRole(TreeElement child);
    [CanBeNullAttribute]
public abstract virtual TreeElement FindChildByRole(short childRole);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ICompositeNodeType {
    [PureAttribute]
public abstract virtual CompositeElement Create();
    [PureAttribute]
public abstract virtual NodeType ToNodeType();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ICompositeNodeType`1 {
    [NullableContextAttribute("1")]
[PureAttribute]
public abstract virtual TCompositeElement Create();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.IFileImpl {
    [CanBeNullAttribute]
public IBuffer Buffer { get; }
    public ILexerFactory LexerFactory { get; public set; }
    [CanBeNullAttribute]
public TokenBuffer TokenBuffer { get; public set; }
    [CanBeNullAttribute]
public ISecondaryRangeTranslator SecondaryRangeTranslator { get; public set; }
    [NotNullAttribute]
public IDocumentRangeTranslator DocumentRangeTranslator { get; public set; }
    public IReferenceProvider ReferenceProvider { get; public set; }
    public bool HasSpecialCommitReparse { get; }
    public abstract virtual IBuffer get_Buffer();
    public abstract virtual ILexerFactory get_LexerFactory();
    public abstract virtual void set_LexerFactory(ILexerFactory value);
    public abstract virtual TokenBuffer get_TokenBuffer();
    public abstract virtual void set_TokenBuffer(TokenBuffer value);
    [CanBeNullAttribute]
public abstract virtual TokenBuffer TryGetTokenBuffer();
    public abstract virtual ISecondaryRangeTranslator get_SecondaryRangeTranslator();
    public abstract virtual void set_SecondaryRangeTranslator(ISecondaryRangeTranslator value);
    public abstract virtual IDocumentRangeTranslator get_DocumentRangeTranslator();
    public abstract virtual void set_DocumentRangeTranslator(IDocumentRangeTranslator value);
    public abstract virtual IReferenceProvider get_ReferenceProvider();
    public abstract virtual void set_ReferenceProvider(IReferenceProvider value);
    public abstract virtual void SetSourceFile(IPsiSourceFile sourceFile);
    public abstract virtual IChameleonNode FindChameleonWhichCoversRange(TreeTextRange range);
    public abstract virtual void CommitReparse(ITreeNode oldElement, ITreeNode newElement);
    public abstract virtual bool get_HasSpecialCommitReparse();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.IFixedTokenNodeType {
    [NotNullAttribute]
public abstract virtual LeafElementBase Create();
}
public interface JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ITreeElementWithPsiModule {
    public abstract virtual IPsiModule GetPsiModule();
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.LeafElementBase : TreeElement {
    public ITreeNode FirstChild { get; }
    public ITreeNode LastChild { get; }
    public virtual ITreeNode get_FirstChild();
    public virtual ITreeNode get_LastChild();
    public virtual ITreeNode FindNodeAt(TreeTextRange treeRange);
    public virtual void FindNodesAtInternal(TreeTextRange relativeRange, List`1<ITreeNode> result, bool includeContainingNodes);
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.LeafElementBaseWithCustomOffset : LeafElementBase {
    [CompilerGeneratedAttribute]
private TreeOffset <Offset>k__BackingField;
    public TreeOffset Offset { get; }
    protected LeafElementBaseWithCustomOffset(TreeOffset offset);
    [CompilerGeneratedAttribute]
public TreeOffset get_Offset();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.ModificationUtil : object {
    [NotNullAttribute]
private static object MODIFICATION_SERVICE_NOT_APPLICABLE;
    [ThreadStaticAttribute]
[CanBeNullAttribute]
private static Stack`1<ReferenceContextCodecFactory> ourReferenceCodecFactories;
    [ThreadStaticAttribute]
[CanBeNullAttribute]
private static List`1<IPsiModificationService> ourAdditionalModificationServices;
    [ThreadStaticAttribute]
[CanBeNullAttribute]
private static List`1<Type> ourDisabledModificationServiceTypes;
    [ThreadStaticAttribute]
private static int ourDisableCodeFormatter;
    [ThreadStaticAttribute]
private static int ourDisableExpensiveCodeFormatting;
    [ThreadStaticAttribute]
private static int ourDisableModificationServices;
    private static bool AreModificationServicesEnabled { get; }
    internal static bool IsExpensiveFormattingEnabled { get; }
    private static bool IsCodeFormatterEnabled { get; }
    private static ModificationUtil();
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
private static void AssertWriteAccessForPhysicalNode(ITreeNode node);
    [CanBeNullAttribute]
internal static ReferenceContextCodecFactory RegisterReferenceContextCodecFactory(ReferenceContextCodecFactory factory);
    internal static void UnregisterReferenceContextCodecFactory(ReferenceContextCodecFactory factory);
    [CanBeNullAttribute]
private static ReferenceContextCodecFactory TryGetCurrentCodecFactory();
    [CanBeNullAttribute]
private static IReferenceContextCodec TryCreateReferenceContextCodec(PsiLanguageType languageType);
    internal static void RegisterModificationService(IPsiModificationService service);
    internal static void UnregisterModificationService(IPsiModificationService service);
    internal static void DisableModificationService(Type serviceType);
    internal static void RestoreModificationService(Type serviceType);
    [PureAttribute]
private static bool IsModificationServiceEnabled(IPsiModificationService service);
    internal static void DisableModificationServices();
    internal static void RestoreModificationServices();
    private static bool get_AreModificationServicesEnabled();
    internal static void DisableCodeFormatter();
    internal static void RestoreCodeFormatter();
    internal static bool get_IsExpensiveFormattingEnabled();
    internal static void DisableExpensiveCodeFormatting();
    internal static void RestoreExpensiveCodeFormatting();
    private static bool get_IsCodeFormatterEnabled();
    [CanBeNullAttribute]
private static ICodeFormatter GetCodeFormatter(ITreeNode node);
    [CanBeNullAttribute]
public static ICodeFormatter GetCodeFormatter(LanguageService service);
    [MustUseReturnValueAttribute]
private static ModificationContext PrepareModificationContext(ITreeNode originalChild, ITreeNode insertedChild);
    [MustUseReturnValueAttribute]
private static ModificationContext PrepareModificationContext(ITreeNode originalChild, ITreeNode insertedChild, IReferenceContextCodec referenceContextCodec);
    [PureAttribute]
[NotNullAttribute]
private static IReadOnlyList`1<ValueTuple`2<IPsiModificationService, object>> GetContextsForServices(ITreeNode originalNode, ITreeNode insertedCopyNode, IReferenceContextCodec referenceContextCodec);
    [NotNullAttribute]
private static TTreeNode PostProcess(TTreeNode insertedNode, ModificationContext modificationContext);
    [NotNullAttribute]
public static TTreeNode AddChild(ITreeNode root, TTreeNode child);
    [NotNullAttribute]
public static TTreeNode AddChildAfter(ITreeNode anchor, TTreeNode child);
    [NotNullAttribute]
private static ITreeRange AddChildRangeImpl(LanguageService languageService, ITreeRange range, IEnumerable`1<ITreeNode> iterator, TContext& context, Func`3<ITreeNode, TContext, TContext> childAction);
    [NotNullAttribute]
private static List`1<ValueTuple`2<ITreeNode, ModificationContext>> PrepareModificationContextsForRange(ITreeRange range, IEnumerable`1<ITreeNode> iterator, TContext& context, Func`3<ITreeNode, TContext, TContext> childAction, IReferenceContextCodec codec, ITreeNode& first, ITreeNode& last);
    [NotNullAttribute]
private static ITreeRange PostProcessRange(List`1<ValueTuple`2<ITreeNode, ModificationContext>> insertedNodes, ITreeNode first, ITreeNode last);
    [NotNullAttribute]
public static ITreeRange AddChildRangeAfter(ITreeNode anchor, ITreeRange range);
    [NotNullAttribute]
public static ITreeRange AddChildRangeAfter(ITreeNode parent, ITreeNode anchor, ITreeRange range);
    [NotNullAttribute]
public static ITreeRange AddChildRangeBefore(ITreeNode anchor, ITreeRange range);
    [NotNullAttribute]
public static ITreeRange AddChildRangeBefore(ITreeNode parent, ITreeNode anchor, ITreeRange range);
    [NotNullAttribute]
public static TTreeNode AddChildBefore(ITreeNode anchor, TTreeNode child);
    [NotNullAttribute]
public static TTreeNode ReplaceChild(ITreeNode oldChild, TTreeNode newChild);
    [NotNullAttribute]
public static ITreeRange ReplaceChildRange(ITreeRange oldNodes, ITreeRange newNodes);
    private static bool IsWhitespace(ITreeNode node);
    public static void DeleteChildRange(ITreeNode first, ITreeNode last);
    public static void DeleteChildRange(ITreeRange range);
    [NotNullAttribute]
public static TTreeNode AddChildAfter(ITreeNode parent, ITreeNode anchor, TTreeNode child);
    [NotNullAttribute]
public static TTreeNode AddChildBefore(ITreeNode parent, ITreeNode anchor, TTreeNode child);
    public static void DeleteChild(ITreeNode child);
    [NotNullAttribute]
internal static ITreeNode CreateCopyWithResolve(ITreeNode node);
    [NotNullAttribute]
[PureAttribute]
public static ITreeNode CloneNode(ITreeNode node, Action`1<ITreeNode> clonedNodeAction);
    [NotNullAttribute]
[PureAttribute]
private static ITreeNode CloneNodeModifyContext(ITreeNode node, TContext& context, Func`3<ITreeNode, TContext, TContext> clonedNodeAction);
    [NotNullAttribute]
[PureAttribute]
public static ITreeNode CloneNode(ITreeNode node, TContext context, Action`2<ITreeNode, TContext> clonedNodeAction);
    [NotNullAttribute]
[PureAttribute]
public static TTreeNode CloneNode(TTreeNode node, TContext context, Action`2<ITreeNode, TContext> clonedNodeAction);
    [CompilerGeneratedAttribute]
internal static void <GetContextsForServices>g__AddContexts|33_0(IReadOnlyList`1<IPsiModificationService> services, PsiModificationServicePriority priority, <>c__DisplayClass33_0& );
    [CompilerGeneratedAttribute]
internal static TTreeNode <PostProcess>g__ApplyServices|35_0(TTreeNode node, IReadOnlyList`1<IPsiModificationService> services, PsiModificationServicePriority priority, <>c__DisplayClass35_0`1& );
    [CompilerGeneratedAttribute]
internal static void <PostProcess>g__CleanupServices|35_1(IReadOnlyList`1<IPsiModificationService> services, PsiModificationServicePriority priority, <>c__DisplayClass35_0`1& );
    [CompilerGeneratedAttribute]
internal static void <CreateCopyWithResolve>g__ProcessCopy|56_0(IReadOnlyList`1<IPsiModificationService> services, PsiModificationServicePriority priority, <>c__DisplayClass56_0& );
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.NodeType : object {
    private string myString;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public int Index { get; }
    protected NodeType(string s, int index);
    [CompilerGeneratedAttribute]
public int get_Index();
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.NodeTypeDictionary`1 : object {
    private int myMinIndex;
    private int myMaxIndex;
    [NullableAttribute("1")]
private TValue[] myValues;
    [NullableAttribute("1")]
private static EqualityComparer`1<TValue> ourEqualityComparer;
    protected TValue Item { get; }
    public TValue Item { get; }
    public NodeTypeDictionary`1(IList`1<KeyValuePair`2<NodeType, TValue>> contents);
    public NodeTypeDictionary`1(KeyValuePair`2[] contents);
    [NullableContextAttribute("1")]
public NodeTypeDictionary`1(int count, Func`2<int, NodeType> nodes, Func`2<int, TValue> values);
    [NullableContextAttribute("1")]
protected NodeTypeDictionary`1(NodeTypeDictionary`1<TValue> instance1, NodeTypeDictionary`1<TValue> instance2, Func`3<TValue, TValue, TValue> conversion);
    private static NodeTypeDictionary`1();
    protected TValue get_Item(int index);
    public TValue get_Item(NodeType type);
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.NodeTypeEqualityComparer : object {
    public static NodeTypeEqualityComparer Instance;
    private static NodeTypeEqualityComparer();
    public sealed virtual bool Equals(NodeType x, NodeType y);
    public sealed virtual int GetHashCode(NodeType obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.NodeTypeSet : NodeTypeDictionary`1<bool> {
    private NodeType[] myTypes;
    public static NodeTypeSet Empty;
    public int Count { get; }
    public NodeTypeSet(IEnumerable`1<NodeType> types);
    public NodeTypeSet(NodeType[] types);
    protected NodeTypeSet(NodeTypeSet instance1, NodeTypeSet instance2, Func`3<bool, bool, bool> conversion);
    private static NodeTypeSet();
    public sealed virtual int get_Count();
    [NullableContextAttribute("2")]
public bool Contains(NodeType nodeType);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<NodeType> GetEnumerator();
    [PureAttribute]
public NodeTypeSet Except(NodeTypeSet set);
    [PureAttribute]
public NodeTypeSet Except(NodeType[] nodeTypes);
    [PureAttribute]
public NodeTypeSet Union(NodeTypeSet set);
    [PureAttribute]
public NodeTypeSet Union(NodeType[] nodeTypes);
    [PureAttribute]
public NodeTypeSet Intersect(NodeTypeSet set);
    [PureAttribute]
public NodeTypeSet Intersect(NodeType[] nodeTypes);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.NodeUserData : ValueType {
    [NotNullAttribute]
private ITreeNode myNode;
    [NotNullAttribute]
private ConcurrentDictionary`2<ITreeNode, UserDataHolder> myTable;
    [NotNullAttribute]
private static Func`2<ITreeNode, UserDataHolder> ourInnerHolderFactory;
    internal NodeUserData(ITreeNode node, ConcurrentDictionary`2<ITreeNode, UserDataHolder> table);
    private static NodeUserData();
    public sealed virtual T GetData(Key`1<T> key);
    public sealed virtual void PutData(Key`1<T> key, T value);
    public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, Func`1<T> factory);
    public sealed virtual T GetOrCreateDataUnderLock(Key`1<T> key, TState state, Func`2<TState, T> factory);
    [MustUseReturnValueAttribute]
public T GetOrCreateDataNoLock(Key`1<T> key, Func`1<T> creator);
    [MustUseReturnValueAttribute]
public T GetOrCreateDataNoLock(Key`1<T> key, TState state, Func`2<TState, T> creator);
    [MustUseReturnValueAttribute]
public T GetOrCreateDataNoLock(Key`1<T> key, TState1 state1, TState2 state2, Func`3<TState1, TState2, T> creator);
    [MustUseReturnValueAttribute]
public T GetOrCreateDataNoLock(Key`1<T> key, TState1 state1, TState2 state2, TState3 state3, Func`4<TState1, TState2, TState3, T> creator);
    [MustUseReturnValueAttribute]
public T GetOrCreateDataNoLock(Key`1<T> key, TState1 state1, TState2 state2, TState3 state3, TState4 state4, Func`5<TState1, TState2, TState3, TState4, T> creator);
    public void PutKey(Key`1<object> key);
    [PureAttribute]
public bool HasKey(Key`1<T> key);
    public void RemoveKey(Key`1<T> key);
    public sealed virtual IEnumerable`1<KeyValuePair`2<object, object>> EnumerateData();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.NonParsableElement : CompositeElement {
    public static CompositeNodeType NODE_TYPE;
    public static int NODE_TYPE_INDEX;
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    private static NonParsableElement();
    public virtual bool IsFiltered();
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
}
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.PredefinedNodeTypeIndicies : object {
    public static int ErrorElement;
    public static int Sandbox;
    public static int InjectedNodeHolder;
    public static int PsiBuilderErrorElement;
    public static int VirtualWhitespace;
    public static int NonParsableElement;
    public static int LastPredefinedNodeTypeIndex;
    public static int CaretToken;
    public static int StringTokenBaseIndex;
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.PsiBuilderErrorElement : CompositeElement {
    [NotNullAttribute]
private string myErrorDescription;
    public static CompositeNodeWithArgumentType NODE_TYPE;
    public PsiLanguageType Language { get; }
    public NodeType NodeType { get; }
    public string ErrorDescription { get; public set; }
    public PsiBuilderErrorElement(string errorDescription);
    private static PsiBuilderErrorElement();
    public virtual PsiLanguageType get_Language();
    public virtual NodeType get_NodeType();
    public virtual bool IsFiltered();
    public virtual string get_ErrorDescription();
    public virtual void set_ErrorDescription(string value);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.SandBox : CompositeElement {
    [NotNullAttribute]
private static CompositeNodeType NODE_TYPE;
    [NotNullAttribute]
private IPsiServices myPsiServices;
    [CanBeNullAttribute]
private IPsiModule myPsiModule;
    [CanBeNullAttribute]
private PsiLanguageType myLanguage;
    private int myModificationStamp;
    [CompilerGeneratedAttribute]
private ITreeNode <ContextNode>k__BackingField;
    [CompilerGeneratedAttribute]
private SandBoxContextType <ContextType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NotifyPsiOnChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private CacheTrieNode <CacheTrieNode>k__BackingField;
    [CompilerGeneratedAttribute]
private SandBoxPartsTree <SandBoxPartsTree>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeUserDataHolder <NodeUserDataHolder>k__BackingField;
    [NotNullAttribute]
public static Key IsPhysicalSandBox;
    public ITreeNode ContextNode { get; private set; }
    public SandBoxContextType ContextType { get; private set; }
    internal bool NotifyPsiOnChanges { get; private set; }
    [CanBeNullAttribute]
internal CacheTrieNode CacheTrieNode { get; internal set; }
    [CanBeNullAttribute]
internal SandBoxPartsTree SandBoxPartsTree { get; internal set; }
    public NodeUserDataHolder NodeUserDataHolder { get; }
    public bool HoldOwnUserData { get; }
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public Nullable`1<int> ModificationStamp { get; public set; }
    protected SandBox(IPsiModule module, PsiLanguageType language);
    private static SandBox();
    [CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_ContextNode();
    [CompilerGeneratedAttribute]
private void set_ContextNode(ITreeNode value);
    [CompilerGeneratedAttribute]
public sealed virtual SandBoxContextType get_ContextType();
    [CompilerGeneratedAttribute]
private void set_ContextType(SandBoxContextType value);
    [CompilerGeneratedAttribute]
internal bool get_NotifyPsiOnChanges();
    [CompilerGeneratedAttribute]
private void set_NotifyPsiOnChanges(bool value);
    [CompilerGeneratedAttribute]
internal CacheTrieNode get_CacheTrieNode();
    [CompilerGeneratedAttribute]
internal void set_CacheTrieNode(CacheTrieNode value);
    [CompilerGeneratedAttribute]
internal SandBoxPartsTree get_SandBoxPartsTree();
    [CompilerGeneratedAttribute]
internal void set_SandBoxPartsTree(SandBoxPartsTree value);
    [CompilerGeneratedAttribute]
public sealed virtual NodeUserDataHolder get_NodeUserDataHolder();
    public sealed virtual bool get_HoldOwnUserData();
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public static void CreateSandBoxWithContextFor(ITreeNode node, IPsiModule psiModule, ITreeNode context, SandBoxContextType sandBoxContextType, PsiLanguageType sandBoxLanguage);
    public static void CreateSandBoxFor(ITreeNode node, IPsiModule psiModule, PsiLanguageType sandBoxLanguage);
    [NotNullAttribute]
public static SandBox CreateSandBoxFor_NoCache(ITreeNode node, IPsiModule psiModule, PsiLanguageType sandBoxLanguage);
    public void SetContext(ITreeNode node, SandBoxContextType type);
    public sealed virtual Nullable`1<int> get_ModificationStamp();
    public sealed virtual void set_ModificationStamp(Nullable`1<int> value);
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    public virtual IPsiServices GetPsiServices();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertNoCycleDependency();
    public virtual bool IsValid();
    public sealed virtual IPsiModule GetPsiModule();
}
public abstract class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement : object {
    [DebuggerBrowsableAttribute("0")]
public TreeElement prevSibling;
    [DebuggerBrowsableAttribute("0")]
public TreeElement nextSibling;
    [DebuggerBrowsableAttribute("0")]
public CompositeElement parent;
    public Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myCachedOffsetData;
    public ITreeNode Parent { get; }
    public ITreeNode NextSibling { get; }
    public ITreeNode PrevSibling { get; }
    public NodeType NodeType { get; }
    public ITreeNode FirstChild { get; }
    public ITreeNode LastChild { get; }
    public PsiLanguageType Language { get; }
    [NotNullAttribute]
protected PsiLanguageType LanguageFromParent { get; }
    public NodeUserData UserData { get; }
    public NodeUserData PersistentUserData { get; }
    public sealed virtual ITreeNode get_Parent();
    public sealed virtual ITreeNode get_NextSibling();
    public sealed virtual ITreeNode get_PrevSibling();
    public abstract virtual NodeType get_NodeType();
    public abstract virtual ITreeNode get_FirstChild();
    public abstract virtual ITreeNode get_LastChild();
    public abstract virtual PsiLanguageType get_Language();
    protected PsiLanguageType get_LanguageFromParent();
    protected virtual void PreInit();
    public sealed virtual TreeOffset GetTreeStartOffset();
    public abstract virtual int GetTextLength();
    public abstract virtual StringBuilder GetText(StringBuilder to);
    public abstract virtual string GetText();
    public abstract virtual IBuffer GetTextAsBuffer();
    [DebuggerStepThroughAttribute]
public virtual IPsiServices GetPsiServices();
    public virtual string ToString();
    public HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    [NotNullAttribute]
protected internal virtual TreeElement DeepClone(TreeNodeCopyContext context);
    [DebuggerStepThroughAttribute]
public virtual IPsiSourceFile GetSourceFile();
    [CanBeNullAttribute]
public virtual IChameleonNode FindChameleonWhichCoversRange(TreeTextRange textRange);
    public abstract virtual ITreeNode FindNodeAt(TreeTextRange treeRange);
    public sealed virtual IReadOnlyCollection`1<ITreeNode> FindNodesAt(TreeOffset treeOffset);
    [NotNullAttribute]
[PureAttribute]
public IReadOnlyCollection`1<ITreeNode> FindContainingNodesAt(TreeTextRange treeRange);
    public abstract virtual void FindNodesAtInternal(TreeTextRange relativeRange, List`1<ITreeNode> result, bool includeContainingNodes);
    public sealed virtual ITreeNode FindTokenAt(TreeOffset treeTextOffset);
    public virtual DocumentRange GetNavigationRange();
    [CanBeNullAttribute]
internal IReferenceProvider GetReferenceProvider();
    [DebuggerStepThroughAttribute]
public sealed virtual IPsiModule GetPsiModule();
    public sealed virtual bool Contains(ITreeNode other);
    public virtual bool IsValid();
    public virtual bool IsFiltered();
    public sealed virtual bool IsPhysical();
    public sealed virtual TTreeNode GetContainingNode(bool returnThis);
    [CanBeNullAttribute]
internal NodeUserDataHolder FindNodeUserDataHolder();
    public sealed virtual NodeUserData get_UserData();
    public sealed virtual NodeUserData get_PersistentUserData();
    [NotNullAttribute]
public virtual ITreeNode SemanticDeepClone(TreeNodeCopyContext context);
    public virtual void ProcessDescendantsForResolve(IRecursiveElementProcessor processor);
    public virtual ReferenceCollection GetFirstClassReferences();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElementFactory : object {
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static LeafElementBase CreateLeafElement(TokenNodeType tokenType);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static LeafElementBase CreateLeafElement(TokenNodeType tokenType, string text);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static TreeElement CreateTreeElement(NodeType type);
    [PureAttribute]
[NotNullAttribute]
public static CompositeElement CreateCompositeElement(ICompositeNodeType type);
    [PureAttribute]
[NotNullAttribute]
public static LeafElementBase CreateLeafElement(ILexer lexer);
    [PureAttribute]
[NotNullAttribute]
public static LeafElementBase CreateLeafElement(TokenNodeType type, IBuffer buffer, int startOffset, int endOffset);
    [PureAttribute]
[NotNullAttribute]
public static CompositeElement CreateErrorElement(string description);
    [PureAttribute]
[NotNullAttribute]
[UsedImplicitlyAttribute]
public static CompositeElement CreateErrorElementWithExpectedTokens(SyntaxError error);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.UnexpectedTokenErrorElement : ErrorElement {
    [CompilerGeneratedAttribute]
private ITokenNodeType <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<NodeType> <ExpectedTokenTypes>k__BackingField;
    public ITokenNodeType TokenType { get; }
    public IReadOnlyCollection`1<NodeType> ExpectedTokenTypes { get; }
    public UnexpectedTokenErrorElement(ITokenNodeType tokenType, IReadOnlyCollection`1<NodeType> expectedTokenTypes, string errorDescription);
    [CompilerGeneratedAttribute]
public ITokenNodeType get_TokenType();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<NodeType> get_ExpectedTokenTypes();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.ExtensionsAPI.TrivialExplicitImplementation : object {
    private OverridableMemberInstance myInstance;
    public IDeclaredType DeclaringType { get; }
    public string MemberName { get; }
    public TrivialExplicitImplementation(OverridableMemberInstance instance);
    public sealed virtual IDeclaredType get_DeclaringType();
    public sealed virtual string get_MemberName();
    public sealed virtual OverridableMemberInstance Resolve();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.FactoryArgumentsBuilder : ValueType {
    private List`1<object> myArguments;
    private StringBuilder myBuilder;
    public int Length { get; }
    [PureAttribute]
public static FactoryArgumentsBuilder Create();
    public int get_Length();
    public FactoryArgumentsBuilder Argument(object argument);
    public FactoryArgumentsBuilder Arguments(IEnumerable`1<T> arguments, string separator);
    [ObsoleteAttribute("You probably wanted to invoke .Argument instead", "True")]
public FactoryArgumentsBuilder Arguments(string argument);
    public FactoryArgumentsBuilder Append(char argument);
    public FactoryArgumentsBuilder Append(string argument);
    public FactoryArgumentsBuilder AppendFormat(FactoryArgumentsStringHandler& handler);
    [NotNullAttribute]
[PureAttribute]
public Object[] ToArguments();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Files.AllDocumentsAreCommittedReadConstraint : object {
    [CompilerGeneratedAttribute]
private IPsiFiles <psiFiles>P;
    public AllDocumentsAreCommittedReadConstraint(IPsiFiles psiFiles);
    public sealed virtual bool IsSatisfied();
    public sealed virtual Task AwaitConstraint(Lifetime lifetime);
    private void CompleteWhenAllDocumentsCommited(TaskCompletionSource`1<Unit> tcs);
}
public class JetBrains.ReSharper.Psi.Files.AllowNotCommittedPsiCookie : object {
    [CanBeNullAttribute]
[ThreadStaticAttribute]
private static AllowNotCommittedPsiCookie ourCookie;
    [NotNullAttribute]
private IPsiSourceFile mySourceFile;
    [ThreadStaticAttribute]
public static bool DisableCachesUpdateAfterTransactionCommit;
    internal static AllowNotCommittedPsiCookie Current { get; }
    internal IPsiSourceFile SourceFile { get; }
    [MustDisposeResourceAttribute]
public AllowNotCommittedPsiCookie(IPsiSourceFile sourceFile, bool disableCachesUpdateAfterTransactionCommit);
    private AllowNotCommittedPsiCookie(IPsiSourceFile sourceFile, AllowNotCommittedPsiCookie oldCookie);
    public static bool Exists();
    internal static AllowNotCommittedPsiCookie get_Current();
    internal IPsiSourceFile get_SourceFile();
    internal ReplaceCookie Replace(IPsiSourceFile sourceFile);
    [CanBeNullAttribute]
[MustDisposeResourceAttribute]
public static IDisposable CreateIfNotExists(IPsiSourceFile sourceFile, bool disableCachesUpdateAfterTransactionCommit);
    public static bool Exists(IPsiSourceFile sourceFile);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Files.CachedPsiFile : object {
    private static Key`1<CachedPsiFile> ourCachedPsiFileKey;
    private IPsiSourceFile mySourceFile;
    private LanguageService myLanguageService;
    [NullableAttribute("2")]
private IDocument myDocument;
    private ReferenceProviderFactory myReferenceProviderFactory;
    [NullableAttribute("2")]
private IFileImpl myPsiFile;
    [NullableAttribute("2")]
private IReferenceProvider myReferenceProvider;
    [NullableAttribute("2")]
private DocumentUpdatesAccumulator myUpdatesAccumulator;
    private ILexerFactory myLexerFactory;
    private IShellLocks myLocks;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PsiFilesBucket <Bucket>k__BackingField;
    [NullableAttribute("2")]
public PsiFilesBucket Bucket { get; public set; }
    public IPsiSourceFile SourceFile { get; }
    public IDocument Document { get; }
    public PsiLanguageType Language { get; }
    [NullableAttribute("2")]
public IFileImpl PsiFile { get; }
    internal CachedPsiFile(IPsiSourceFile sourceFile, PsiLanguageType languageType, ReferenceProviderFactory referenceProviderFactory, ILexerFactory lexerFactory, IShellLocks locks);
    internal CachedPsiFile(IPsiSourceFile sourceFile, PsiLanguageType languageType, IDocument document, ISecondaryRangeTranslator secondaryTranslator, ReferenceProviderFactory referenceProviderFactory, ILexerFactory lexerFactory, IShellLocks locks);
    private static CachedPsiFile();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public PsiFilesBucket get_Bucket();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Bucket(PsiFilesBucket value);
    public IPsiSourceFile get_SourceFile();
    public IDocument get_Document();
    public PsiLanguageType get_Language();
    [NullableContextAttribute("2")]
public IFileImpl get_PsiFile();
    [NullableContextAttribute("2")]
internal void AssignPsiFile(IFileImpl value);
    public void UpdateReferenceProvider();
    public void ResetDocumentUpdates();
    public void OnDocumentChanged(DocumentChange args);
    public ReparseResult WorkIncrementalParse(DocumentChange documentChange);
    private Pair`2<ITreeNode, ITreeNode> CommitIncrementalReparse(ITreeNode newElement, ITreeNode oldElement, TokenBuffer tokenBuffer, ISecondaryRangeTranslator secondaryRangeTranslator);
    private void CommitIncrementalReparse(MinimizedReparseResult minimizedReparseResult);
    private ReparseResult GetIncrementalReparseResult(TokenBuffer oldTokenBuffer, IBuffer newBuffer, ISecondaryRangeTranslator secondaryRangeTranslator, TextRange originalRange, int insertedTextLength, IDocument document);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public ReparseResult GetIncrementalReparseResult(TextRange& modifiedRange, String& newText);
    public ReparseResult GetIncrementalReparseResultForSecondaryPsi(ISecondaryDocumentGenerationResult generationResult, DocumentChange& documentChange);
}
public class JetBrains.ReSharper.Psi.Files.ChunkedCommitProcessAsync2 : object {
    private ISolution mySolution;
    private IShellLocks myShellLocks;
    private PsiFiles myPsiFiles;
    private PsiFilesCommit myPsiFilesCommit;
    private IList`1<IPsiSourceFile> mySourceFiles;
    private IList`1<IPsiSourceFileCache> myBuildMergeParticipants;
    private Action mySyncFinalAction;
    private bool mySynchronous;
    private int myBatchSize;
    private int myProcessedFilesCount;
    private CommitProcessAsync2 myCurrentBatch;
    private ILogger myLogger;
    private List`1<Action> mySuccessActions;
    private List`1<Action> myInterruptActions;
    private bool myNeedCachesUpdate;
    [CompilerGeneratedAttribute]
private bool <IsFailured>k__BackingField;
    public bool NeedCachesUpdate { get; public set; }
    public bool IsFailured { get; private set; }
    public ChunkedCommitProcessAsync2(ISolution solution, IShellLocks shellLocks, PsiFiles psiFiles, PsiFilesCommit psiFilesCommit, IList`1<IPsiSourceFile> sourceFiles, IList`1<IPsiSourceFileCache> buildMergeParticipants, Action syncFinalAction, bool synchronous, int batchSize);
    public bool get_NeedCachesUpdate();
    public void set_NeedCachesUpdate(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsFailured();
    [CompilerGeneratedAttribute]
private void set_IsFailured(bool value);
    public void Attach(Action onSuccess, Action onInterrupt);
    public Status Wait();
    public void Execute();
    private bool NeedsToStartNextBatch();
    private bool StartNextBatch();
    private void OnBatchInterrupted();
    private bool ExecuteSyncFinalAction();
    private void ExecuteInterruptActions();
    private void OnBatchSucceeded();
    private void ExecuteSuccessActions();
    private bool TryExecuteSuccessActions();
    private void OnBatchCompletedSyncAction();
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Files.ChunkedMarkAsDirty : object {
    private ISolution mySolution;
    private ChangeManager myChangeManager;
    private ILogger myLogger;
    private ICollectionEvents`1<IPsiSourceFile> myMarkAsDirtyFiles;
    private IShellLocks myLocks;
    private IPsiFiles myPsiFiles;
    private IPsiCaches myPsiCaches;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <IsEmpty>k__BackingField;
    public IProperty`1<bool> IsEmpty { get; }
    public ChunkedMarkAsDirty(Lifetime lifetime, SynchronizationPoints syncPoints, ISolution solution, ChangeManager changeManager, ISettingsStore settingsStore, ILogger logger);
    private IShellLocks GetLocks();
    private IPsiFiles GetPsiFiles();
    private IPsiCaches GetPsiCaches();
    private static Pair`2<int, TimeSpan> GetSettings(ISettingsStore settingsStore);
    private static Pair`2<int, TimeSpan> GetSettings(IContextBoundSettingsStore boundSettingsStore);
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_IsEmpty();
    private void ScheduleMarkAsDirty(Lifetime lifetime, int batchSize, TimeSpan interval);
    private void ExecuteMarkAsDirty(int chunkSize);
    public void MarkAsDirty(string requester, ICollection`1<IPsiSourceFile> sourceFiles, Action asyncAction);
    [CompilerGeneratedAttribute]
private void <MarkAsDirty>b__18_0();
}
[SettingsKeyAttribute("JetBrains.Application.Settings.WellKnownRootKeys.HousekeepingSettings", "JetBrains.ReSharper.Psi.Resources.Strings", "ChunkedMarkAsDirtySettingsKeyDescription")]
public class JetBrains.ReSharper.Psi.Files.ChunkedMarkAsDirtySettingsKey : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "ChunkSizeDescription")]
public int ChunkSize;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "ScheduleNextChunkTimeoutMs")]
public int ScheduleNextChunkTimeoutMs;
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Files.CommitAllDocumentsRequirement : object {
    [NotNullAttribute]
protected IPsiServices PsiServices;
    private Lifetime myUntilSolutionCloseLifetime;
    [CompilerGeneratedAttribute]
private ISignal`1<RequirementState> <Done>k__BackingField;
    public bool IsReady { get; }
    public ISignal`1<RequirementState> Done { get; }
    public string Description { get; }
    public CommitAllDocumentsRequirement(IPsiServices psiServices);
    [NotNullAttribute]
public static IActionRequirement TryGetInstance(IDataContext dataContext);
    [NotNullAttribute]
public static CommitAllDocumentsRequirement GetInstance(ISolution solution);
    public sealed virtual bool get_IsReady();
    public virtual void GetReady();
    [CompilerGeneratedAttribute]
public sealed virtual ISignal`1<RequirementState> get_Done();
    public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
private void <GetReady>b__7_0();
    [CompilerGeneratedAttribute]
private void <GetReady>b__7_1();
    [CompilerGeneratedAttribute]
private void <GetReady>b__7_2();
}
public class JetBrains.ReSharper.Psi.Files.CommitBuildResult : object {
    [CanBeNullAttribute]
private ReparseResult myReparseResult;
    [CanBeNullAttribute]
private CachedPsiFile myNewCachedPsiFile;
    private ITreeNode myOldElement;
    private ITreeNode myNewElement;
    private DocumentChange myPostponedDocumentChange;
    private ISecondaryDocumentGenerationResult myGenerationResult;
    [CompilerGeneratedAttribute]
private TextRange <ModifiedRange>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewText>k__BackingField;
    public TextRange ModifiedRange { get; }
    public string NewText { get; }
    public CachedPsiFile CachedPsiFile { get; }
    public IPsiSourceFile SourceFile { get; }
    public CommitBuildResult(ReparseResult reparseResult, CachedPsiFile newCachedPsiFile, DocumentChange postponedDocumentChange, ISecondaryDocumentGenerationResult generationResult, TextRange modifiedRange, string newText);
    [CompilerGeneratedAttribute]
public TextRange get_ModifiedRange();
    [CompilerGeneratedAttribute]
public string get_NewText();
    public sealed virtual CachedPsiFile get_CachedPsiFile();
    public IPsiSourceFile get_SourceFile();
    public sealed virtual void FinishCommit();
    [NotNullAttribute]
public sealed virtual PsiFileModificationInfo GetModificationInfo();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Files.CommitBuildResults : object {
    [CompilerGeneratedAttribute]
private IList`1<ICommitBuildResult> <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    public IList`1<ICommitBuildResult> Results { get; }
    public IPsiSourceFile SourceFile { get; }
    public CommitBuildResults(IPsiSourceFile sourceFile, IList`1<ICommitBuildResult> results);
    [CompilerGeneratedAttribute]
public IList`1<ICommitBuildResult> get_Results();
    [CompilerGeneratedAttribute]
public IPsiSourceFile get_SourceFile();
}
public class JetBrains.ReSharper.Psi.Files.CommitCookie : ValueType {
    private IPsiServices myPsiServices;
    private bool myReleaseReadLockRequired;
    [CompilerGeneratedAttribute]
private bool <Cancelled>k__BackingField;
    public bool Cancelled { get; private set; }
    public IPsiServices PsiServices { get; }
    public ISolution Solution { get; }
    private CommitCookie InitCommited(IPsiServices psiServices);
    private CommitCookie InitAndCommit(IPsiServices psiServices);
    [ObsoleteAttribute("Use IAsyncCommitClient pattern + AssertCommited insted. This method will call commit documents synchronously!")]
[MustDisposeResourceAttribute]
public static CommitCookie Commit(ISolution solution);
    [MustDisposeResourceAttribute]
public static CommitCookie AssertCommitted(ISolution solution);
    [MustDisposeResourceAttribute]
public static CommitCookie AssertCommitted(IDeclaredElement declaredElement);
    public CommitCookie WaitForCaches(string actionText, string cancelText);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_Cancelled();
    [CompilerGeneratedAttribute]
private void set_Cancelled(bool value);
    public IPsiServices get_PsiServices();
    public ISolution get_Solution();
    public sealed virtual void Dispose();
}
public class JetBrains.ReSharper.Psi.Files.CommitProcessAsync2 : object {
    private ILogger myLogger;
    private ISolution mySolution;
    private IShellLocks myShellLocks;
    private PsiFiles myPsiFiles;
    private PsiFilesCommit myPsiFilesCommit;
    private IList`1<IPsiSourceFile> mySourceFiles;
    private IList`1<IPsiSourceFileCache> myBuildMergeParticipants;
    private Action mySyncFinalAction;
    private bool mySynchronous;
    private IPsiFilesCache myPsiFilesCache;
    private List`1<Action> mySuccessActions;
    private List`1<Action> myInterruptActions;
    [CompilerGeneratedAttribute]
private bool <NeedCachesUpdate>k__BackingField;
    [CanBeNullAttribute]
private Task`1<IList`1<CommitBuildResults>> myBuildPsiJob;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CanBeNullAttribute]
private Task`1<IEnumerable`1<ValueTuple`2<IPsiSourceFile, IList`1<ValueTuple`2<IPsiSourceFileCache, object>>>>> myBuildParticipantsJob;
    [CanBeNullAttribute]
private LifetimeDefinition myMapReduceLifetimeDefinition;
    [CanBeNullAttribute]
private string myMapReduceName;
    private LifetimeDefinition myPsiJobLifetimeDefinition;
    private bool myPsiMerged;
    private bool myParticipantsMerged;
    [CompilerGeneratedAttribute]
private bool <IsInterrupted>k__BackingField;
    public bool NeedCachesUpdate { get; public set; }
    public bool IsFailured { get; }
    public bool IsInterrupted { get; private set; }
    public CommitProcessAsync2(ILogger logger, ISolution solution, IShellLocks shellLocks, PsiFiles psiFiles, PsiFilesCommit psiFilesCommit, IList`1<IPsiSourceFile> sourceFiles, IList`1<IPsiSourceFileCache> buildMergeParticipants, Action syncFinalAction, bool synchronous);
    [CompilerGeneratedAttribute]
public bool get_NeedCachesUpdate();
    [CompilerGeneratedAttribute]
public void set_NeedCachesUpdate(bool value);
    public void BeforeAcquiringWriteLock(object sender, BeforeAcquiringWriteLockEventArgs e);
    public void Execute();
    public void Attach(Action onSuccess, Action onInterrupt);
    public bool get_IsFailured();
    [CompilerGeneratedAttribute]
public bool get_IsInterrupted();
    [CompilerGeneratedAttribute]
private void set_IsInterrupted(bool value);
    public void Wait();
    private void OnPsiBuilt();
    private IEnumerable`1<ValueTuple`2<IPsiSourceFile, IList`1<ValueTuple`2<IPsiSourceFileCache, object>>>> BuildCacheParticipants();
    private void OnSuccess();
    private void OnInterrupt();
    private void ExecuteOnInterruptActions();
    private IList`1<CommitBuildResults> BuildPsi(IList`1<IPsiSourceFile> sourceFiles);
    private void MergePsi(IList`1<CommitBuildResults> commitBuildResults);
    private IList`1<ValueTuple`2<IPsiSourceFileCache, object>> BuildParticipant(IPsiSourceFile sourceFile);
    private IList`1<ValueTuple`2<IPsiSourceFileCache, object>> BuildParticipantImpl(IPsiSourceFile sourceFile);
    private static void MergeParticipant(IPsiSourceFile sourceFile, IList`1<ValueTuple`2<IPsiSourceFileCache, object>> buildResults);
    [CompilerGeneratedAttribute]
private void <Execute>b__25_0(Lifetime asyncLifetime);
    [CompilerGeneratedAttribute]
private void <Execute>b__25_2();
    [CompilerGeneratedAttribute]
private void <Execute>b__25_3();
    [CompilerGeneratedAttribute]
private IList`1<CommitBuildResults> <Execute>b__25_6();
    [CompilerGeneratedAttribute]
private void <Execute>b__25_7(Task`1<IList`1<CommitBuildResults>> task);
    [CompilerGeneratedAttribute]
private void <OnPsiBuilt>b__34_0(Lifetime asyncLifetime);
    [CompilerGeneratedAttribute]
private IEnumerable`1<ValueTuple`2<IPsiSourceFile, IList`1<ValueTuple`2<IPsiSourceFileCache, object>>>> <OnPsiBuilt>b__34_4();
    [CompilerGeneratedAttribute]
private void <OnPsiBuilt>b__34_5(Task`1<IEnumerable`1<ValueTuple`2<IPsiSourceFile, IList`1<ValueTuple`2<IPsiSourceFileCache, object>>>>> task);
}
public class JetBrains.ReSharper.Psi.Files.DefaultInjectCachingService : object {
    [NotNullAttribute]
private static Key`1<ConcurrentDictionary`2<Type, CachedPsiValueWithOffsets`1<InterruptibleLazy`2<IFile, IReadOnlyList`1<IFile>>>>> ourInjectedCacheKey;
    [NotNullAttribute]
public static IInjectCachingService Instance;
    private static DefaultInjectCachingService();
    public sealed virtual IEnumerable`1<IFile> GetInjectedFiles(Type injectedLanguageType, IFile dominantFile, IReadOnlyCollection`1<IInjectedPsiProvider> providersToBuild, Func`2<IFile, IReadOnlyList`1<IFile>> injectedFilesCalculator);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.KnownLanguage", "16")]
public class JetBrains.ReSharper.Psi.Files.DefaultPsiFileSizeEstimateService : object {
    public virtual int SizeOfPsiInBytes(IFile file);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.Files.DirtyFilesCollection : object {
    private object myLock;
    private HashSet`1<IPsiSourceFile> myFilesWithDirtyPsi;
    private bool myCachesAreForceDirty;
    public bool CachesAreDirty { get; public set; }
    public bool IsDirty { get; }
    public IList`1<IPsiSourceFile> DirtyPsiFiles { get; }
    public bool get_CachesAreDirty();
    public void set_CachesAreDirty(bool value);
    public void MarkAsDirty(IPsiSourceFile sourceFile);
    public bool get_IsDirty();
    public void Drop(IPsiSourceFile sourceFile);
    public void Clear(bool leaveCachesDirty);
    public IList`1<IPsiSourceFile> get_DirtyPsiFiles();
    [PureAttribute]
public bool Contains(IPsiSourceFile sourceFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Files.DummySourceFiles.DummyPsiSourceFile : UserDataHolder {
    [CompilerGeneratedAttribute]
private IPsiModule <PsiModule>k__BackingField;
    [CompilerGeneratedAttribute]
private IDocument <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectFileType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiLanguageType <PrimaryPsiLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFileProperties <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IModuleReferenceResolveContext <ResolveContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFileStorage <PsiStorage>k__BackingField;
    public IPsiModule PsiModule { get; }
    public IDocument Document { get; }
    public string Name { get; }
    public string DisplayName { get; }
    public ProjectFileType LanguageType { get; }
    public PsiLanguageType PrimaryPsiLanguage { get; }
    public IPsiSourceFileProperties Properties { get; }
    public IModuleReferenceResolveContext ResolveContext { get; }
    public IPsiSourceFileStorage PsiStorage { get; }
    public Nullable`1<ModificationStamp> InMemoryModificationStamp { get; }
    public Nullable`1<ModificationStamp> ExternalModificationStamp { get; }
    public DateTime LastWriteTimeUtc { get; }
    public DummyPsiSourceFile(ISolution solution, IDocument document, string id, ProjectFileType projectFileType, PsiLanguageType primaryPsiLanguage, IPsiModule module);
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_PsiModule();
    [CompilerGeneratedAttribute]
public sealed virtual IDocument get_Document();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual string get_DisplayName();
    public sealed virtual bool IsValid();
    [NullableContextAttribute("2")]
public sealed virtual string GetPersistentID();
    [CompilerGeneratedAttribute]
public sealed virtual ProjectFileType get_LanguageType();
    [CompilerGeneratedAttribute]
public sealed virtual PsiLanguageType get_PrimaryPsiLanguage();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiSourceFileProperties get_Properties();
    [CompilerGeneratedAttribute]
public sealed virtual IModuleReferenceResolveContext get_ResolveContext();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiSourceFileStorage get_PsiStorage();
    public sealed virtual Nullable`1<ModificationStamp> get_InMemoryModificationStamp();
    public sealed virtual Nullable`1<ModificationStamp> get_ExternalModificationStamp();
    public sealed virtual DateTime get_LastWriteTimeUtc();
}
public class JetBrains.ReSharper.Psi.Files.EmptyDocumentRangeTranslator : object {
    [NotNullAttribute]
public static EmptyDocumentRangeTranslator Instance;
    private static EmptyDocumentRangeTranslator();
    public sealed virtual DocumentRange Translate(TreeTextRange range);
    private sealed virtual override FrugalLocalList`1<DocumentRange> JetBrains.ReSharper.Psi.Files.IDocumentRangeTranslator.GetIntersectedOriginalRanges(TreeTextRange range);
    public sealed virtual TreeTextRange Translate(DocumentRange documentRange);
}
public class JetBrains.ReSharper.Psi.Files.GeneratedDocumentCommitResult : ValueType {
    public DocumentChange DocumentChange;
    public ISecondaryRangeTranslator NewRangeTranslator;
    public PsiLanguageType Language;
    public GeneratedDocumentCommitResult(ISecondaryRangeTranslator newRangeTranslator, DocumentChange documentChange, PsiLanguageType language);
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Files.GeneratedDocumentsManager : object {
    private static Key`1<PsiLanguageType> ourLanguageTypeKey;
    internal static Key`1<IPsiSourceFile> PsiSourceFileKey;
    private IInMemoryDocumentFactory myDocumentFactory;
    private LazyForkedContentModelData`1<HashSet`1<IPsiSourceFile>> myIsProcessingFromPrimaryToGenerated;
    private CachingProjectFileTypeServicesAccess`1<IGeneratedDocumentService> myCachingProjectFileTypes;
    [CompilerGeneratedAttribute]
private IDocumentTransactionManager <TransactionManager>k__BackingField;
    public IDocumentTransactionManager TransactionManager { get; public set; }
    public GeneratedDocumentsManager(Lifetime lifetime, IInMemoryDocumentFactory documentFactory, IProjectFileTypeServices projectFileTypeServices, IDocumentTransactionManager transactionManager);
    private static GeneratedDocumentsManager();
    [CompilerGeneratedAttribute]
public IDocumentTransactionManager get_TransactionManager();
    [CompilerGeneratedAttribute]
public void set_TransactionManager(IDocumentTransactionManager value);
    public sealed virtual void ApplyTransactionDocumentChange(DocumentChange documentChange, string oldText, IPsiTransactionAction transactionAction);
    public sealed virtual IEnumerable`1<PsiLanguageType> GetPossibleLanguageTypes(IProject project, ProjectFileType projectFileType);
    public sealed virtual IDocument CreateGeneratedDocument(IPsiSourceFile sourceFile, string text, PsiLanguageType language);
    public IGeneratedDocumentService GetGeneratedDocumentService(IPsiSourceFile sourceFile, PsiLanguageType generatedFileLanguage);
    public virtual void AssertGeneratedFilesValid(IPsiSourceFile psiSourceFile);
    public sealed virtual IEnumerable`1<IGeneratedDocumentService> GetServices(ProjectFileType projectFileType);
    private static void ReduceRanges(String& oldText, String& newText, TextRange& range);
    private bool TryApplyGeneratedChangeToPrimary(DocumentChange documentChange, string oldText, IPsiSourceFile sourceFile);
    private void ApplyPrimaryChangeToGenerated(DocumentChange documentChange, string oldText, IPsiTransactionAction transactionAction, IPsiSourceFile sourceFile, IFile primaryFile);
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Files.GeneratedDocumentsTracker : object {
    private Lifetime myLifetime;
    private IPsiServices myPsiServices;
    private DocumentTransactionManager myDocumentTransactionManager;
    private ChunkedMarkAsDirty myChunkedMarkAsDirty;
    private ILogger myLogger;
    public GeneratedDocumentsTracker(Lifetime lifetime, IPsiServices psiServices, DocumentTransactionManager documentTransactionManager, ChunkedMarkAsDirty chunkedMarkAsDirty, ILogger logger);
    private void OnDocumentTransactionCommit(DocumentTransactionResult documentTransactionResult);
    private void MarkFilesForRegeneration(ICollection`1<IPsiSourceFile> psiSourceFiles);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.Files.ICommitBuildResult {
    public CachedPsiFile CachedPsiFile { get; }
    public abstract virtual void FinishCommit();
    public abstract virtual CachedPsiFile get_CachedPsiFile();
    [NullableContextAttribute("2")]
public abstract virtual PsiFileModificationInfo GetModificationInfo();
}
public class JetBrains.ReSharper.Psi.Files.IdenticalDocumentRangeTranslator : object {
    [NotNullAttribute]
private IDocument myDocument;
    public IdenticalDocumentRangeTranslator(IDocument document);
    public sealed virtual DocumentRange Translate(TreeTextRange range);
    public sealed virtual FrugalLocalList`1<DocumentRange> GetIntersectedOriginalRanges(TreeTextRange range);
    public sealed virtual TreeTextRange Translate(DocumentRange documentRange);
}
internal class JetBrains.ReSharper.Psi.Files.IdenticalSourceGeneratedDocumentRangeTranslator : object {
    [NotNullAttribute]
private IFile myFile;
    [NotNullAttribute]
private IDocument myMainDocument;
    public IdenticalSourceGeneratedDocumentRangeTranslator(IFile file, IDocument mainDocument);
    public sealed virtual DocumentRange Translate(TreeTextRange range);
    public sealed virtual FrugalLocalList`1<DocumentRange> GetIntersectedOriginalRanges(TreeTextRange range);
    public sealed virtual TreeTextRange Translate(DocumentRange documentRange);
}
public interface JetBrains.ReSharper.Psi.Files.IDocumentRangeTranslator {
    public abstract virtual DocumentRange Translate(TreeTextRange range);
    [NotNullAttribute]
public abstract virtual FrugalLocalList`1<DocumentRange> GetIntersectedOriginalRanges(TreeTextRange range);
    public abstract virtual TreeTextRange Translate(DocumentRange documentRange);
}
public interface JetBrains.ReSharper.Psi.Files.IFilteringReferenceProviderFactory {
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IReferenceProvider Create(ITreeNode root);
}
public interface JetBrains.ReSharper.Psi.Files.IInjectCachingService {
    public abstract virtual IEnumerable`1<IFile> GetInjectedFiles(Type injectedLanguageType, IFile dominantFile, IReadOnlyCollection`1<IInjectedPsiProvider> providersToBuild, Func`2<IFile, IReadOnlyList`1<IFile>> injectedFilesCalculator);
}
public class JetBrains.ReSharper.Psi.Files.InjectedFileContextList : object {
    private ConcurrentDictionary`2<IInjectedPsiProvider, IInjectedFileContext> myContextMap;
    [NotNullAttribute]
internal IEnumerable`1<IInjectedFileContext> GetAllContexts();
    [CanBeNullAttribute]
public IInjectedFileContext GetInjectedFileContext(IFile originalFile, IInjectedPsiProvider provider, bool createIfNeeded);
    private static bool IsContextDataEquivalent(IInjectedContextData data1, IInjectedContextData data2);
}
[DefaultMemberAttribute("Item")]
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Files.InternalsVisibleToCache : SimpleICache`1<HashSet`1<string>> {
    [NotNullAttribute]
private PsiModules myPsiModules;
    [NotNullAttribute]
private IPsiFiles myPsiFiles;
    [NotNullAttribute]
private LanguageManager myLanguageManager;
    [NotNullAttribute]
private ReaderWriterLockSlim myLock;
    [NotNullAttribute]
private Dictionary`2<IPsiModule, HashSet`1<string>> myModuleToAssemblyNamesCache;
    [NotNullAttribute]
private OneToSetMap`2<IPsiModule, IPsiModule> myVisibleToCache;
    [NotNullAttribute]
private OneToSetMap`2<IPsiModule, IPsiModule> myNotVisibleToCache;
    public ISignal`1<EventArgs> Signal;
    public bool Item { get; }
    public InternalsVisibleToCache(Lifetime lifetime, PsiModules psiModules, IPsiFiles psiFiles, IPersistentIndexManager persistentIndexManager, LanguageManager languageManager, IShellLocks locks);
    protected void InvalidateOnPhysicalChange();
    public bool get_Item(IPsiModule module, IPsiModule dependsUpon);
    public virtual void Invalidate(ITreeNode element, PsiChangedElementType elementType);
    private bool CalcInternalsVisibleTo(IPsiModule moduleFrom, IPsiModule moduleTo);
    [CanBeNullAttribute]
private HashSet`1<string> GetInternalsVisibleToAssemblyNames(IPsiModule module);
    [CanBeNullAttribute]
private static HashSet`1<string> CalcInternalsVisibleToAssemblyNames(IPsiModule module);
    [NotNullAttribute]
public virtual object Build(IPsiSourceFile sourceFile, bool isStartup);
    public virtual void Merge(IPsiSourceFile sourceFile, object built);
    public virtual void Drop(IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.Files.InvalidateSourceFileAction : object {
    [CompilerGeneratedAttribute]
private PsiFilesBucket <bucket>P;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    [NotNullAttribute]
public IPsiSourceFile SourceFile { get; }
    public ITreeNode AffectedElement { get; }
    public PsiChangedElementType AffectedElementType { get; }
    public InvalidateSourceFileAction(IPsiSourceFile sourceFile, PsiFilesBucket bucket);
    [CompilerGeneratedAttribute]
public sealed virtual IPsiSourceFile get_SourceFile();
    public sealed virtual ITreeNode get_AffectedElement();
    public sealed virtual PsiChangedElementType get_AffectedElementType();
    public sealed virtual ICollection`1<DocumentChange> GetDocumentChanges();
    public sealed virtual void RollBack();
}
public interface JetBrains.ReSharper.Psi.Files.IPsiFiles {
    public ISolution Solution { get; }
    public IReadConstraint AllDocumentsAreCommittedConstraint { get; }
    public IProperty`1<bool> IsCommitInProgress { get; }
    public bool CommitDocumentsIsInProgress { get; }
    public bool AllDocumentsAreCommitted { get; }
    [ObsoleteAttribute("Use PsiFilesEx.StartBackgroundReadOnCommit")]
[PublicAPIAttribute]
public TaskScheduler OnCommitBackgroundReadLockScheduler { get; }
    [ObsoleteAttribute("Use PsiFilesEx.StartMainReadOnCommit")]
public TaskScheduler OnCommitMainReadLockScheduler { get; }
    [NotNullAttribute]
public IPsiFilesCache PsiFilesCache { get; }
    public int PsiTimestamp { get; }
    public int PsiCacheAnyChangesTimestamp { get; }
    public int PsiCacheTimestamp { get; }
    public abstract virtual ISolution get_Solution();
    public abstract virtual IReadConstraint get_AllDocumentsAreCommittedConstraint();
    public abstract virtual IProperty`1<bool> get_IsCommitInProgress();
    public abstract virtual void AssertAllDocumentAreCommitted(string customText);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PsiFileCreated(Action`1<IFile> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PsiFileCreated(Action`1<IFile> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BeforePsiFileCreated(Action`2<IPsiSourceFile, IReadOnlyList`1<IFile>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BeforePsiFileCreated(Action`2<IPsiSourceFile, IReadOnlyList`1<IFile>> value);
    public abstract virtual bool IsValid(IFile file);
    public abstract virtual void CommitPsiOnly();
    public abstract virtual void CommitAllDocuments();
    public abstract virtual void CommitAllDocumentsAsync(Action success, Action interrupted);
    public abstract virtual bool IsCommitted(IPsiSourceFile sourceFile);
    public abstract virtual bool get_CommitDocumentsIsInProgress();
    public abstract virtual bool get_AllDocumentsAreCommitted();
    public abstract virtual TaskScheduler get_OnCommitBackgroundReadLockScheduler();
    public abstract virtual TaskScheduler get_OnCommitMainReadLockScheduler();
    [PublicAPIAttribute]
public abstract virtual Task CommitWithRetryBackgroundRead(Lifetime lifetime, Action actionOnBackgroundUnderReadLock);
    public abstract virtual Task`1<T> CommitWithRetryBackgroundRead(Lifetime lifetime, Func`1<T> actionOnBackgroundUnderReadLock);
    public abstract virtual Task CommitWithRetryMainRead(Lifetime lifetime, Action actionOnMainUnderReadLock);
    public abstract virtual Task`1<T> CommitWithRetryMainRead(Lifetime lifetime, Func`1<T> actionOnMainUnderReadLock);
    public abstract virtual IPsiFilesCache get_PsiFilesCache();
    public abstract virtual void ObserveAfterCommit(Lifetime lifetime, Action commit);
    public abstract virtual void ObserveBeforeCommit(Lifetime lifetime, Action commit);
    [NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public abstract virtual IEnumerable`1<PsiLanguageType> GetLanguages(IPsiSourceFile sourceFile, PsiLanguageCategories categories);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IReadOnlyList`1<IFile> GetPsiFiles(IPsiSourceFile sourceFile, PsiLanguageType languageType, PsiLanguageCategories categories);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IReadOnlyList`1<IFile> GetPsiFiles(IPsiSourceFile sourceFile, PsiLanguageType languageType, DocumentRange range, PsiLanguageCategories categories);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IReadOnlyList`1<IFile> GetPsiFiles(IPsiSourceFile sourceFile, PsiLanguageCategories categories);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IReadOnlyList`1<IFile> GetPsiFiles(IPsiSourceFile sourceFile, DocumentRange range, PsiLanguageCategories categories);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IFile> GetCachedInjectedFiles(IFile originalCachedFile, PsiLanguageType injectedLanguage);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BeforePhysicalPsiChanged(Action`1<ITreeNode> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BeforePhysicalPsiChanged(Action`1<ITreeNode> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_AfterPsiChanged(Action`2<ITreeNode, PsiChangedElementType> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AfterPsiChanged(Action`2<ITreeNode, PsiChangedElementType> value);
    public abstract virtual void PsiChanged(ITreeNode treeNode, PsiChangedElementType contentsChanged);
    public abstract virtual int get_PsiTimestamp();
    public abstract virtual int get_PsiCacheAnyChangesTimestamp();
    public abstract virtual int get_PsiCacheTimestamp();
    public abstract virtual void MarkAsDirty(IPsiSourceFile psiSourceFile);
    public abstract virtual void RaiseBeforePsiChanged(ITreeNode treeNode);
    public abstract virtual void IncrementModificationTimestamp(ITreeNode treeNode);
    public abstract virtual void InvalidatePsiFilesCache(IPsiSourceFile sourceFile);
}
public interface JetBrains.ReSharper.Psi.Files.IPsiFilesCache {
    [NotNullAttribute]
public abstract virtual ICollection`1<CachedPsiFile> TryGetCachedPsiFilesOrEmpty(IPsiSourceFile sourceFile);
    [CanBeNullAttribute]
public abstract virtual CachedPsiFile TryGetCachedPsiFile(IPsiSourceFile sourceFile, PsiLanguageType language);
    [CanBeNullAttribute]
public abstract virtual CachedPsiFile GetOrCreateCachedPsiFile(IPsiSourceFile sourceFile, PsiLanguageType language);
    public abstract virtual void Drop(IPsiSourceFile sourceFile);
    [CanBeNullAttribute]
public abstract virtual IPsiTransactionAction DropWithRollback(IPsiSourceFile sourceFile);
    public abstract virtual void Merge(PsiFiles psiFiles, ICollection`1<CommitBuildResults> commitBuildResults);
    public abstract virtual void ClearHardReferences();
    public abstract virtual void UpdateReferenceProviders();
    [MustDisposeResourceAttribute]
[NotNullAttribute]
public abstract virtual IDisposable GetTransientCookie(IPsiSourceFile sourceFile);
    public abstract virtual IList`1<PsiFilesBucket> GetCachedFiles();
}
public interface JetBrains.ReSharper.Psi.Files.IPsiFileSizeEstimateService {
    public abstract virtual int SizeOfPsiInBytes(IFile file);
}
public interface JetBrains.ReSharper.Psi.Files.ISecondaryRangeTranslator {
    [NotNullAttribute]
public IFile OriginalFile { get; }
    public abstract virtual IFile get_OriginalFile();
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<TreeTextRange> GetIntersectedGeneratedRanges(TreeTextRange originalRange, bool includeHidden, bool strict);
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<TreeTextRange> GetIntersectedOriginalRanges(TreeTextRange generatedRange);
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<TreeTextRange> GetIntersectedOriginalRangesLowLevel(TreeTextRange generatedRange, bool includeHidden, bool strict);
    public abstract virtual TreeTextRange OriginalToGenerated(TreeTextRange originalRange);
    public abstract virtual TreeTextRange GeneratedToOriginal(TreeTextRange generatedRange, bool forModification);
    [CanBeNullAttribute]
public abstract virtual Tuple`2<TreeTextRange, TreeTextRange> GetCoveringRange(TreeTextRange originalRange);
    public abstract virtual string Dump(IFile generatedFile, bool dumpContext);
}
internal abstract class JetBrains.ReSharper.Psi.Files.OnCommitReadLockScheduler : TaskScheduler {
    private SyncContext mySyncContext;
    private PsiFiles myPsiFiles;
    private ILogger myLogger;
    private Lifetime myUntilSolutionCloseLifetime;
    private BlockingCollection`1<Entry> myQueue;
    private bool myHasRequests;
    private IShellLocks Locks { get; }
    protected bool OutOfOrderExecution { get; }
    private OnCommitReadLockScheduler(PsiFiles psiFiles, ILogger logger);
    private IShellLocks get_Locks();
    protected abstract virtual bool get_OutOfOrderExecution();
    protected virtual void QueueTask(Task task);
    protected abstract virtual void Dispatch(Action action);
    private bool TryExecuteInterruptable(Lifetime cancellationLifetime, Func`1<bool> action);
    private bool TryExecuteWithContext(Func`1<bool> action);
    private void ExecuteOrQueue(Action action);
    protected abstract virtual void StartRead(Lifetime cancellationLifetime, Action action);
    protected abstract virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    [CompilerGeneratedAttribute]
private void <.ctor>b__14_0();
}
public class JetBrains.ReSharper.Psi.Files.PrimaryFileModificationInfo : object {
    [NotNullAttribute]
public IPsiSourceFile SourceFile;
    [NotNullAttribute]
public IFile NewPsiFile;
    [CanBeNullAttribute]
public ITreeNode OldElement;
    [CanBeNullAttribute]
public ITreeNode NewElement;
    private Action myRestoreAction;
    public PrimaryFileModificationInfo(IPsiSourceFile sourceFile, IFile newPsiFile);
    public PrimaryFileModificationInfo(PsiFileModificationInfo info);
    public bool IsFullyReparsed();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0();
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Files.PsiFileLanguages : object {
    [NotNullAttribute]
private IGeneratedDocumentsManager myGeneratedDocumentsManager;
    [NotNullAttribute]
private IReadOnlyCollection`1<IInjectedPsiProvider> myInjectedPsiProviders;
    [NotNullAttribute]
private DataIntern`1<PsiLanguageType[]> myPsiLanguageArrayIntern;
    [NotNullAttribute]
private ConcurrentDictionary`2<IPsiSourceFile, CompactMap`2<PsiLanguageCategories, PsiLanguageType[]>> myLanguagesCache;
    [NotNullAttribute]
private ConcurrentDictionary`2<PsiLanguageType, ConcurrentDictionary`2<Type, IReadOnlyCollection`1<IInjectedPsiProvider>>> myPathsToLanguage;
    public PsiFileLanguages(IEnumerable`1<IInjectedPsiProvider> providers, IGeneratedDocumentsManager generatedDocumentsManager);
    public void DropCache(IPsiSourceFile projectFile);
    [NotNullAttribute]
public IReadOnlyCollection`1<IInjectedPsiProvider> FindPathToLanguage(PsiLanguageType primaryPsiLanguage, Type languageType);
    private static bool CollectPathsToLanguage(IReadOnlyCollection`1<IInjectedPsiProvider> injectedPsiProviders, PsiLanguageType fromLanguage, Type toLanguage, HashSet`1<Pair`2<PsiLanguageType, IInjectedPsiProvider>> visitedProviders, HashSet`1<IInjectedPsiProvider> providersToBuild);
    [NotNullAttribute]
public ICollection`1<PsiLanguageType> GetLanguages(IPsiSourceFile sourceFile, PsiLanguageCategories categories);
    [NotNullAttribute]
private PsiLanguageType[] CalculateLanguages(IPsiSourceFile sourceFile, PsiLanguageCategories categories);
    private void AppendInjectedLanguages(LocalList`1& dominantLanguages, LocalList`1& result);
    private void CollectInjectedProvidersForLanguage(PsiLanguageType languageType, HashSet`1<IInjectedPsiProvider> visitedProviders, HashSet`1<PsiLanguageType> injectedLanguages);
}
public class JetBrains.ReSharper.Psi.Files.PsiFileModificationInfo : object {
    public IPsiSourceFile SourceFile;
    [NotNullAttribute]
public IFile PsiFile;
    [CanBeNullAttribute]
public ITreeNode OldElement;
    [NotNullAttribute]
public ITreeNode NewElement;
    public PsiFileModificationInfo(IPsiSourceFile sourceFile, IFile psiFile, ITreeNode oldElement, ITreeNode newElement);
    public PrimaryFileModificationInfo TemporaryApplyPsiChange();
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Files.PsiFiles : object {
    [NotNullAttribute]
private ILanguages myLanguages;
    [NotNullAttribute]
private IShellLocks myLocks;
    [NotNullAttribute]
private IPsiModules myPsiModules;
    [NotNullAttribute]
private IPsiFilesCache myPsiFilesCache;
    [NotNullAttribute]
private IPsiTransactions myPsiTransactions;
    [NotNullAttribute]
private PsiFilesCommit myPsiFilesCommit;
    [NotNullAttribute]
private PsiFileLanguages myPsiFileLanguages;
    [NotNullAttribute]
private DocumentManager myDocumentManager;
    [NotNullAttribute]
private object myLockObject;
    [NotNullAttribute]
private LazyForkedContentModelData`1<DirtyFilesCollection> myDirtyFiles;
    [NotNullAttribute]
private List`1<ValueTuple`2<ClientId, Action>> myCommitNotifications;
    [NotNullAttribute]
private List`1<ValueTuple`2<ClientId, Action>> myBeforeCommitNotifications;
    [NotNullAttribute]
private ViewableCollection`1<IPsiSourceFileCache> myBuildMergeParticipants;
    [NotNullAttribute]
[ItemCanBeNullAttribute]
private IProperty`1<ChunkedCommitProcessAsync2> myActiveCommitProcessProperty;
    private static Key`1<InjectedFileContextList> ourInjectedFileContextsKey;
    private LazyForkedContentModelData`1<PsiTimestamps> myTimestamps;
    private List`1<Action`1<ITreeNode>> myBeforePhysicalPsiChangedEventHandlers;
    private List`1<Action`2<ITreeNode, PsiChangedElementType>> myPhysicalPsiChangedEventHandlers;
    [CompilerGeneratedAttribute]
private Action`2<IPsiSourceFile, IReadOnlyList`1<IFile>> BeforePsiFileCreated;
    [CompilerGeneratedAttribute]
private SynchronizationPoint <SyncPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadConstraint <AllDocumentsAreCommittedConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <IsCommitInProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskScheduler <OnCommitBackgroundReadLockScheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskScheduler <OnCommitMainReadLockScheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IFile> PsiFileCreated;
    public IPsiFilesCache PsiFilesCache { get; }
    public PsiFilesCommit PsiFilesCommit { get; }
    public int PsiTimestamp { get; }
    public int PsiCacheTimestamp { get; }
    public int PsiCacheAnyChangesTimestamp { get; }
    public SynchronizationPoint SyncPoint { get; }
    public bool AllDocumentsAreCommitted { get; }
    public bool CommitDocumentsIsInProgress { get; }
    [NotNullAttribute]
public ISolution Solution { get; }
    public IReadConstraint AllDocumentsAreCommittedConstraint { get; }
    public IProperty`1<bool> IsCommitInProgress { get; }
    public TaskScheduler OnCommitBackgroundReadLockScheduler { get; }
    public TaskScheduler OnCommitMainReadLockScheduler { get; }
    public PsiFiles(ISolution solution, IShellLocks locks, PsiFileLanguages psiFileLanguages, IPsiFilesCache psiFilesCache, PsiFilesCommit psiFilesCommit, IPsiTransactions psiTransactions, IPsiModules psiModules, ReferenceProviderFactory referenceProviderFactory, DocumentManager documentManager, IDocumentStorageHelpers documentStorageHelpers, ChangeManager changeManager, ProjectFilePrimaryPsiLanguageTypeCache projectFilePrimaryPsiLanguageTypeCache, ILanguages languages, SynchronizationPoints synchronizationPoints);
    private static PsiFiles();
    public void AddBuildMergeParticipant(IPsiSourceFileCache participant);
    public void RemoveBuildMergeParticipant(IPsiSourceFileCache participant);
    private void HandleTransactionAction(IPsiTransactionAction action);
    public sealed virtual object Execute(IChangeMap map);
    private void TransactionFinished(IPsiTransaction transaction);
    public sealed virtual bool IsValid(IFile file);
    private static void NotifyListeners(List`1<ValueTuple`2<ClientId, Action>> notifications);
    public sealed virtual void ObserveAfterCommit(Lifetime lifetime, Action commit);
    public sealed virtual void ObserveBeforeCommit(Lifetime lifetime, Action beforeCommit);
    public sealed virtual IEnumerable`1<PsiLanguageType> GetLanguages(IPsiSourceFile sourceFile, PsiLanguageCategories categories);
    public sealed virtual IReadOnlyList`1<IFile> GetPsiFiles(IPsiSourceFile sourceFile, PsiLanguageType languageType, DocumentRange range, PsiLanguageCategories categories);
    public sealed virtual IReadOnlyList`1<IFile> GetPsiFiles(IPsiSourceFile sourceFile, PsiLanguageType languageType, PsiLanguageCategories categories);
    public sealed virtual IReadOnlyList`1<IFile> GetPsiFiles(IPsiSourceFile sourceFile, PsiLanguageCategories categories);
    public sealed virtual IReadOnlyList`1<IFile> GetPsiFiles(IPsiSourceFile sourceFile, DocumentRange range, PsiLanguageCategories categories);
    [NotNullAttribute]
private IReadOnlyList`1<IFile> GetPsiFiles(IPsiSourceFile sourceFile, Type languageType, DocumentRange range, PsiLanguageCategories categories);
    private void AppendDominantFiles(IPsiSourceFile sourceFile, DocumentRange range, Type languageType, PsiLanguageCategories languageCategory, LocalList`1& consumer);
    private void AppendInjectFiles(IPsiSourceFile sourceFile, Type injectedLanguageType, DocumentRange range, LocalList`1& files);
    private void AppendInjectedFiles(IFile originalFile, Type toLanguage, TreeTextRange range, IReadOnlyCollection`1<IInjectedPsiProvider> providersToBuild, LocalList`1& results);
    private void AppendInjectedFiles(IFile originalFile, Type toLanguage, IReadOnlyCollection`1<IInjectedPsiProvider> providersToBuild, LocalList`1& results, bool createIfNeeded);
    public sealed virtual IPsiFilesCache get_PsiFilesCache();
    public PsiFilesCommit get_PsiFilesCommit();
    [CanBeNullAttribute]
private InjectedFileContextList GetInjectedFileContexts(IFile file, bool createIfNeeded);
    public sealed virtual IEnumerable`1<IFile> GetCachedInjectedFiles(IFile originalCachedFile, PsiLanguageType injectedLanguage);
    [CanBeNullAttribute]
internal IInjectedFileContext GetInjectedFileContext(IFile originalFile, IInjectedPsiProvider provider, bool createIfNeeded);
    private void ProcessInjectedPsiChange(ITreeNode treeNode, PsiChangedElementType elementType);
    public sealed virtual int get_PsiTimestamp();
    public sealed virtual int get_PsiCacheTimestamp();
    public sealed virtual int get_PsiCacheAnyChangesTimestamp();
    public sealed virtual void IncrementModificationTimestamp(ITreeNode treeNode);
    public sealed virtual void InvalidatePsiFilesCache(IPsiSourceFile sourceFile);
    public sealed virtual void RaiseBeforePsiChanged(ITreeNode elementContainingChanges);
    public sealed virtual void add_BeforePhysicalPsiChanged(Action`1<ITreeNode> value);
    public sealed virtual void remove_BeforePhysicalPsiChanged(Action`1<ITreeNode> value);
    public sealed virtual void add_AfterPsiChanged(Action`2<ITreeNode, PsiChangedElementType> value);
    public sealed virtual void remove_AfterPsiChanged(Action`2<ITreeNode, PsiChangedElementType> value);
    public sealed virtual void PsiChanged(ITreeNode elementContainingChanges, PsiChangedElementType elementType);
    private void NotifyPsiChange(ITreeNode elementContainingChanges, PsiChangedElementType elementType);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BeforePsiFileCreated(Action`2<IPsiSourceFile, IReadOnlyList`1<IFile>> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BeforePsiFileCreated(Action`2<IPsiSourceFile, IReadOnlyList`1<IFile>> value);
    internal void RaiseBeforePsiFileCreated(IPsiSourceFile sourceFile, IReadOnlyList`1<IFile> newFiles);
    [CompilerGeneratedAttribute]
public SynchronizationPoint get_SyncPoint();
    public sealed virtual bool get_AllDocumentsAreCommitted();
    public sealed virtual bool get_CommitDocumentsIsInProgress();
    [CompilerGeneratedAttribute]
public sealed virtual ISolution get_Solution();
    [CompilerGeneratedAttribute]
public sealed virtual IReadConstraint get_AllDocumentsAreCommittedConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<bool> get_IsCommitInProgress();
    public sealed virtual void CommitAllDocumentsAsync(Action success, Action interrupted);
    public sealed virtual void CommitPsiOnly();
    public sealed virtual void CommitAllDocuments();
    private void CommitAllDocumentsSync(bool needCachesUpdate);
    [CompilerGeneratedAttribute]
public sealed virtual TaskScheduler get_OnCommitBackgroundReadLockScheduler();
    [CompilerGeneratedAttribute]
public sealed virtual TaskScheduler get_OnCommitMainReadLockScheduler();
    private Task`1<T> CommitWithRetryImpl(Lifetime lifetime, Func`1<Task`1<T>> createFunc);
    public sealed virtual Task CommitWithRetryMainRead(Lifetime lifetime, Action actionOnMainUnderReadLock);
    public sealed virtual Task`1<T> CommitWithRetryMainRead(Lifetime lifetime, Func`1<T> actionOnMainUnderReadLock);
    public sealed virtual Task CommitWithRetryBackgroundRead(Lifetime lifetime, Action actionOnBackgroundUnderReadLock);
    public sealed virtual Task`1<T> CommitWithRetryBackgroundRead(Lifetime lifetime, Func`1<T> actionOnBackgroundUnderReadLock);
    private void ExecuteCommitDocuments(bool synchronous, Action successfulContinuation, Action interruptedContinuation, bool needCachesUpdate);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertNotDirty(IPsiSourceFile sourceFile);
    public sealed virtual void MarkAsDirty(IPsiSourceFile sourceFile);
    public sealed virtual bool IsCommitted(IPsiSourceFile sourceFile);
    public sealed virtual void AssertAllDocumentAreCommitted(string customText);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PsiFileCreated(Action`1<IFile> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PsiFileCreated(Action`1<IFile> value);
    internal void RaisePsiFileCreated(IFile psiFile);
    private void OnReferenceProviderFactoryChanged();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <.ctor>b__14_5(IPsiTransaction _);
    [CompilerGeneratedAttribute]
private void <.ctor>b__14_2(DocumentSavedEventArgs _);
}
public class JetBrains.ReSharper.Psi.Files.PsiFilesBucket : object {
    [CompilerGeneratedAttribute]
private CachedPsiFile[] <Files>k__BackingField;
    [NotNullAttribute]
public CachedPsiFile[] Files { get; }
    public PsiFilesBucket(CachedPsiFile[] files);
    [CompilerGeneratedAttribute]
public CachedPsiFile[] get_Files();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertDistinctLanguages();
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Files.PsiFilesCache2 : object {
    private Lifetime myLifetime;
    [NotNullAttribute]
private ILogger myLogger;
    [NotNullAttribute]
private IShellLocks myLocks;
    [NotNullAttribute]
private PsiModules myPsiModules;
    [NotNullAttribute]
private LanguageManager myLanguageManager;
    [NotNullAttribute]
private object myLock;
    private LazyForkedContentModelData`1<IWeakRefRetainerCache`1<PsiFilesBucket>> myPsiFilesCache;
    private bool myProjectModelLoaded;
    [NotNullAttribute]
private JetFastSemiReenterableRWLock myWriteSentry;
    [NotNullAttribute]
private static Func`2<IPsiSourceFile, PsiFilesBucket> ourProduceBucket;
    public PsiFilesCache2(Lifetime lifetime, ILogger logger, IShellLocks locks, PsiModules psiModules, ChangeManager changeManager, ISolutionLoadTasksScheduler loadTasksScheduler, LanguageManager languageManager);
    private static PsiFilesCache2();
    private IWeakRefRetainerCache`1<PsiFilesBucket> CreateCacheForPsiScope();
    private int CalculateBucketSizeInBytes(PsiFilesBucket bucket);
    public sealed virtual ICollection`1<CachedPsiFile> TryGetCachedPsiFilesOrEmpty(IPsiSourceFile sourceFile);
    public sealed virtual CachedPsiFile TryGetCachedPsiFile(IPsiSourceFile sourceFile, PsiLanguageType language);
    private static void SetTransientMode(IPsiSourceFile sourceFile, bool enabled);
    public sealed virtual CachedPsiFile GetOrCreateCachedPsiFile(IPsiSourceFile sourceFile, PsiLanguageType language);
    [NotNullAttribute]
private PsiFilesBucket GetOrCreateBucket(IPsiSourceFile sourceFile);
    [CanBeNullAttribute]
private static CachedPsiFile FindByLanguage(PsiFilesBucket bucket, PsiLanguageType language);
    public sealed virtual void Drop(IPsiSourceFile sourceFile);
    public sealed virtual IPsiTransactionAction DropWithRollback(IPsiSourceFile sourceFile);
    [NotNullAttribute]
private static string ToString(PsiFilesBucket bucket);
    public sealed virtual void Merge(PsiFiles psiFiles, ICollection`1<CommitBuildResults> commitBuildResults);
    [CanBeNullAttribute]
private PsiFilesBucket GetCachedBucket(IPsiSourceFile sourceFile);
    public sealed virtual void ClearHardReferences();
    public sealed virtual void UpdateReferenceProviders();
    public sealed virtual IDisposable GetTransientCookie(IPsiSourceFile sourceFile);
    public sealed virtual IList`1<PsiFilesBucket> GetCachedFiles();
    [NotNullAttribute]
private static PsiFilesBucket ProduceBucket(IPsiSourceFile sourceFile);
    private void LoadProjectModel();
    public sealed virtual object Execute(IChangeMap changeMap);
    private void CreateBucketOptionally(IPsiSourceFile sourceFile);
    public void TestDump(StreamWriter sw);
    private void TestDump(LRUWeakRefRetainerCache`1<PsiFilesBucket> cache, StreamWriter sw);
    [CompilerGeneratedAttribute]
private void <GetOrCreateBucket>b__16_0(PsiFilesBucket psiFilesBucket, IPsiSourceFile file);
    [CompilerGeneratedAttribute]
[NotNullAttribute]
internal static IFile[] <Merge>g__ToPsiFiles|21_0(LocalList`1<CachedPsiFile> cachedPsiFiles);
}
[PsiComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Files.PsiFilesCommit : object {
    [CompilerGeneratedAttribute]
private IShellLocks <locks>P;
    [CompilerGeneratedAttribute]
private ReferenceProviderFactory <referenceProviderFactory>P;
    [CompilerGeneratedAttribute]
private IGeneratedDocumentsManager <generatedDocumentsManager>P;
    public PsiFilesCommit(IShellLocks locks, ReferenceProviderFactory referenceProviderFactory, IGeneratedDocumentsManager generatedDocumentsManager);
    [CanBeNullAttribute]
public CommitBuildResults Build(IPsiSourceFile sourceFileToCommit, bool reparse, IPsiFilesCache psiFilesCache);
    [CanBeNullAttribute]
private CommitBuildResult BuildPrimary(PreparedSourceFile preparedSourceFile);
    [NotNullAttribute]
private CommitBuildResults BuildSecondary(CommitBuildResult primaryBuildResult, bool reparse, IPsiFilesCache psiFilesCache);
    [NotNullAttribute]
private static CommitBuildResult ReParseGeneratedPsiFile(ISecondaryDocumentGenerationResult generationResult, CachedPsiFile oldCachedPsiFile);
    [NotNullAttribute]
private CommitBuildResult BuildGeneratedPsiFile(CommitBuildResult primaryBuildResult, ISecondaryDocumentGenerationResult generationResult);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Files.PsiFilesEx : object {
    [AsyncStateMachineAttribute("JetBrains.ReSharper.Psi.Files.PsiFilesEx/<StartTaskOnAsyncCommit>d__0`1")]
[ExtensionAttribute]
public static Task`1<T> StartTaskOnAsyncCommit(IPsiFiles psiFiles, Lifetime lifetime, Func`1<Task`1<T>> createTask);
    [ExtensionAttribute]
public static Func`1<T> ExecuteIfDocumentsAreCommittedOrThrow(Func`1<T> func, IPsiFiles psiFiles);
    [ExtensionAttribute]
public static Action ExecuteIfDocumentsAreCommittedOrThrow(Action action, IPsiFiles psiFiles);
    [ExtensionAttribute]
public static Task StartBackgroundReadOnCommit(IPsiFiles psiFiles, Lifetime lifetime, Action actionOnBackgroundUnderReadLock);
    [ExtensionAttribute]
public static Task`1<T> StartBackgroundReadOnCommit(IPsiFiles psiFiles, Lifetime lifetime, Func`1<T> actionOnBackgroundUnderReadLock);
    [ExtensionAttribute]
public static Task StartMainReadOnCommit(IPsiFiles psiFiles, Lifetime lifetime, Action actionOnMainThreadWithReadLock);
    [ExtensionAttribute]
public static Task`1<T> StartMainReadOnCommit(IPsiFiles psiFiles, Lifetime lifetime, Func`1<T> actionOnMainThreadWithReadLock);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Files.PsiFilesExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IFile> GetPsiFiles(IPsiFiles psiFiles, IPsiSourceFile sourceFile, DocumentRange range);
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IFile> GetPsiFiles(IPsiFiles psiFiles, IPsiSourceFile sourceFile, DocumentOffset documentOffset);
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IFile> GetPsiFiles(IPsiServices psiServices, DocumentRange range);
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IFile> GetPsiFiles(IPsiServices psiServices, DocumentRange range);
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IFile> GetPsiFiles(IPsiServices psiServices, PsiLanguageType languageType, DocumentRange range);
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<IFile> GetPsiFiles(IPsiFiles psiFiles, IPsiSourceFile sourceFile, DocumentRange range);
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<IFile> GetPsiFiles(IPsiFiles psiFiles, IPsiSourceFile sourceFile, PsiLanguageType languageType, DocumentRange range);
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<IFile> GetPsiFiles(IPsiFiles psiFiles, IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<IFile> GetPsiFiles(IPsiFiles psiFiles, IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<IFile> GetPsiFiles(IPsiFiles psiFiles, IPsiSourceFile sourceFile, PsiLanguageType languageType);
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<IFile> GetPsiFiles(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IFile> GetPsiFiles(IPsiSourceFile sourceFile, PsiLanguageType languageType);
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IEnumerable`1<PsiLanguageType> GetDominantLanguages(IPsiSourceFile psiSourceFile);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IFile GetDominantPsiFile(IPsiFiles psiFiles, IPsiSourceFile sourceFile, DocumentRange range);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IFile GetDominantPsiFile(IPsiFiles psiFiles, IPsiSourceFile sourceFile, PsiLanguageType languageType, DocumentRange range);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IFile GetDominantPsiFile(IPsiFiles psiFiles, IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IFile GetDominantPsiFile(IPsiFiles psiFiles, IPsiSourceFile sourceFile, PsiLanguageType languageType);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IFile GetDominantPsiFile(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IFile GetPsiFile(IPsiServices psiServices, DocumentRange range);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IFile GetPsiFile(IPsiServices psiServices, DocumentOffset documentOffset);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IFile GetPsiFile(IPsiFiles psiFiles, IPsiSourceFile sourceFile, DocumentRange range);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IFile GetPsiFile(IPsiFiles psiFiles, IPsiSourceFile sourceFile, DocumentOffset documentOffset);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IFile GetPsiFile(IPsiServices psiServices, PsiLanguageType languageType, DocumentRange range);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IFile GetPsiFile(IPsiServices psiServices, PsiLanguageType languageType, DocumentOffset documentOffset);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IFile GetPsiFile(IPsiSourceFile sourceFile, PsiLanguageType language, DocumentRange range);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IFile GetPsiFile(IPsiSourceFile sourceFile, PsiLanguageType language, DocumentOffset documentOffset);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IFile GetPsiFile(IPsiSourceFile sourceFile, DocumentRange range);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IFile GetPsiFile(IPsiSourceFile sourceFile, DocumentOffset documentOffset);
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IEnumerable`1<PsiLanguageType> GetLanguages(IPsiSourceFile psiSourceFile);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IFile GetPrimaryPsiFile(IPsiFiles psiFiles, IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IFile GetPrimaryPsiFile(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
public static void DoOnCommitedPsi(IPsiFiles psiFiles, Lifetime lifetime, Action action);
    [ExtensionAttribute]
public static void ExecuteAfterCommitAllDocuments(IPsiFiles psiFiles, Action action, bool sync);
}
public class JetBrains.ReSharper.Psi.Files.PsiInjectedFiles : object {
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Files.PsiLanguageCategories : Enum {
    public int value__;
    public static PsiLanguageCategories None;
    public static PsiLanguageCategories Primary;
    public static PsiLanguageCategories Secondary;
    public static PsiLanguageCategories Injected;
    public static PsiLanguageCategories Dominant;
    public static PsiLanguageCategories All;
}
public static class JetBrains.ReSharper.Psi.Files.ReadConstrains : object {
    public static IReadConstraint AllDocumentsAreCommitted(IPsiFiles psiFiles);
}
[PsiComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Files.ReferenceProviderFactory : object {
    private List`1<IReferenceProviderFactory> myFactories;
    private Dictionary`2<IReferenceProviderFactory, HashSet`1<Type>> myFactoryToReferenceTypesMap;
    private IShellLocks myLocks;
    private IWordIndex myWordIndex;
    [CompilerGeneratedAttribute]
private ISignal`1<IReferenceProviderFactory> <Changed>k__BackingField;
    public ISignal`1<IReferenceProviderFactory> Changed { get; }
    public ReferenceProviderFactory(Lifetime lifetime, IEnumerable`1<IReferenceProviderFactory> factories, IShellLocks locks, IWordIndex wordIndex);
    [CanBeNullAttribute]
public IReferenceProvider Create(IPsiSourceFile sourceFile, IFile file);
    [NotNullAttribute]
[PureAttribute]
public IFilteringReferenceProviderFactory WithReferenceTypeFilter(TState state, Func`3<Type, TState, bool> referenceTypeFilter);
    private IReadOnlyList`1<IReferenceFactory> CreateApplicableProviders(IPsiSourceFile sourceFile, IFile file, List`1<IReferenceProviderFactory> factories);
    [CompilerGeneratedAttribute]
public ISignal`1<IReferenceProviderFactory> get_Changed();
}
public class JetBrains.ReSharper.Psi.Files.SandboxFiles.SandboxContext : object {
    [CompilerGeneratedAttribute]
private PsiLanguageType <PsiLanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectFileType <ProjectFileType>k__BackingField;
    [CompilerGeneratedAttribute]
private IModuleReferenceResolveContext <ResolveContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <OriginalPsiSourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <SandboxInfoExtraImports>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IPsiModule> <ModulesToJoin>k__BackingField;
    [CompilerGeneratedAttribute]
private IRangeMarker <RangeMarker>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNonUserFile>k__BackingField;
    [NotNullAttribute]
public PsiLanguageType PsiLanguageType { get; }
    [NotNullAttribute]
public ProjectFileType ProjectFileType { get; }
    [NotNullAttribute]
public IModuleReferenceResolveContext ResolveContext { get; }
    [CanBeNullAttribute]
public IPsiSourceFile OriginalPsiSourceFile { get; }
    [NotNullAttribute]
public IReadOnlyList`1<string> SandboxInfoExtraImports { get; }
    [NotNullAttribute]
public IEnumerable`1<IPsiModule> ModulesToJoin { get; }
    [CanBeNullAttribute]
public IRangeMarker RangeMarker { get; }
    public bool IsNonUserFile { get; }
    public SandboxContext(PsiLanguageType psiLanguageType, ProjectFileType projectFileType, IModuleReferenceResolveContext resolveContext, IPsiSourceFile originalPsiSourceFile, bool isNonUserFile, IReadOnlyList`1<string> sandboxInfoExtraImports, IEnumerable`1<IPsiModule> modulesToJoin, IRangeMarker rangeMarker);
    [CompilerGeneratedAttribute]
public PsiLanguageType get_PsiLanguageType();
    [CompilerGeneratedAttribute]
public ProjectFileType get_ProjectFileType();
    [CompilerGeneratedAttribute]
public IModuleReferenceResolveContext get_ResolveContext();
    [CompilerGeneratedAttribute]
public IPsiSourceFile get_OriginalPsiSourceFile();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_SandboxInfoExtraImports();
    [CompilerGeneratedAttribute]
public IEnumerable`1<IPsiModule> get_ModulesToJoin();
    [CompilerGeneratedAttribute]
public IRangeMarker get_RangeMarker();
    [CompilerGeneratedAttribute]
public bool get_IsNonUserFile();
    public virtual string ToString();
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Files.SandboxFiles.SandboxFilesManager : object {
    private ChangeManager myChangeManager;
    private IShellLocks myLocks;
    private ISolution mySolution;
    private PsiProjectFileTypeCoordinator myPsiProjectFileTypeCoordinator;
    private ILogger myLogger;
    private Dictionary`2<IProjectFile, IPsiSourceFile> mySandboxFiles;
    private DocumentManager myDocumentManager;
    private VirtualFileSystemPath mySandboxFolder;
    private OneToSetMap`2<string, VirtualFileSystemPath> myAvailablePaths;
    public SandboxFilesManager(ChangeManager changeManager, Lifetime lifetime, IShellLocks locks, ISolution solution, PsiProjectFileTypeCoordinator psiProjectFileTypeCoordinator, ILogger logger, DocumentManager documentManager);
    [CanBeNullAttribute]
public IPsiSourceFile GetSandboxSourceFile(IDocument document);
    [CanBeNullAttribute]
public IPsiSourceFile GetSandboxSourceFile(IProjectFile projectFile);
    [NotNullAttribute]
public SandboxPsiSourceFile CreateSandboxFile(Lifetime lifetime, IProjectFile projectFile, SandboxContext sandboxContext);
    public void RegisterSandboxFile(Lifetime lifetime, SandboxPsiModule sandboxPsiModule, SandboxPsiSourceFile psiSourceFile);
    private void RemoveModule(IPsiModule toRemove);
    public sealed virtual object Execute(IChangeMap changeMap);
    public VirtualFileSystemPath GetOrCreateNewFile(Lifetime lifetime, string extension);
    private VirtualFileSystemPath GetOrCreateNewFileInternal(string extensionWithDot);
    private void Release(VirtualFileSystemPath path);
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_0();
}
public class JetBrains.ReSharper.Psi.Files.SandboxFiles.SandboxOriginInfo : object {
    public static Key`1<SandboxOriginInfo> SandboxInfo;
    [NotNullAttribute]
private string myPurpose;
    [CanBeNullAttribute]
private string mySourceDocumentId;
    public SandboxOriginInfo(string purpose, string sourceDocumentId);
    private static SandboxOriginInfo();
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Files.SandboxFiles.SandboxPsiExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static IPsiModule UnwrapSandboxModule(IPsiModule psiModule);
    [ExtensionAttribute]
[PureAttribute]
public static IPsiSourceFile UnwrapSandboxSourceFile(IPsiSourceFile psiSourceFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Files.SandboxFiles.SandboxPsiModule : ProjectPsiModuleBase {
    private string myNameSuffix;
    private IEnumerable`1<PsiModuleReference> myModulesToReference;
    private JetHashSet`1<IPsiSourceFile> myPsiSourceFiles;
    private DocumentManager myDocumentManager;
    private IModuleReferenceResolveContext myResolveContext;
    [NullableAttribute("2")]
public IPsiModule OriginPsiModule;
    [CompilerGeneratedAttribute]
private ProjectFileType <ProjectFileType>k__BackingField;
    public ProjectFileType ProjectFileType { get; }
    public string Name { get; }
    public IModuleReferenceResolveContext GivenResolveContext { get; }
    public SandboxPsiModule(IProject project, IPsiModule originPsiModule, PsiProjectFileTypeCoordinator coordinator, IEnumerable`1<IPsiModule> modulesToReference, ProjectFileType projectFileType, string nameSuffix, DocumentManager documentManager, IModuleReferenceResolveContext resolveContext);
    protected virtual IEnumerable`1<IPsiModuleReference> GetReferencesInternal();
    [CompilerGeneratedAttribute]
public virtual ProjectFileType get_ProjectFileType();
    public SandboxPsiSourceFile CreateSandboxFile(IProjectFile projectFile, PsiLanguageType language, IPsiSourceFile originalPsiSourceFile, IReadOnlyList`1<string> extraImports, bool isNonUserFile);
    public virtual string get_Name();
    public IModuleReferenceResolveContext get_GivenResolveContext();
    protected virtual IEnumerable`1<IPsiSourceFile> GetSourceFiles();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Files.SandboxFiles.SandboxPsiSourceFile : PsiProjectFile {
    private static ILogger ourLogger;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectFileType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiLanguageType <PrimaryPsiLanguage>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IPsiSourceFile <OriginPsiSourceFile>k__BackingField;
    public string Name { get; }
    public string DisplayName { get; }
    public ProjectFileType LanguageType { get; }
    public PsiLanguageType PrimaryPsiLanguage { get; }
    [NullableAttribute("2")]
public IPsiSourceFile OriginPsiSourceFile { get; }
    public SandboxPsiSourceFile(IPsiModule psiModule, IProjectFile projectFile, ProjectFileType projectFileType, PsiLanguageType primaryPsiLanguage, IPsiSourceFile originPsiSourceFile, IReadOnlyList`1<string> extraImports, bool isNonUserFile, DocumentManager documentManager, IModuleReferenceResolveContext resolveContext);
    private static SandboxPsiSourceFile();
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    public virtual string get_DisplayName();
    [CompilerGeneratedAttribute]
public virtual ProjectFileType get_LanguageType();
    [CompilerGeneratedAttribute]
public virtual PsiLanguageType get_PrimaryPsiLanguage();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IPsiSourceFile get_OriginPsiSourceFile();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Files.SandboxFiles.SandboxSourceFileProperties : object {
    private JetHashSet`1<string> myExtraImports;
    [CompilerGeneratedAttribute]
private bool <IsNonUserFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsICacheParticipant>k__BackingField;
    public bool ShouldBuildPsi { get; }
    public bool IsGeneratedFile { get; }
    public bool ProvidesCodeModel { get; }
    public bool IsNonUserFile { get; }
    public bool IsICacheParticipant { get; }
    public SandboxSourceFileProperties(IReadOnlyList`1<string> extraImports, bool isNonUserFile, bool isICacheParticipant);
    public sealed virtual bool get_ShouldBuildPsi();
    public sealed virtual bool get_IsGeneratedFile();
    public sealed virtual bool get_ProvidesCodeModel();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsNonUserFile();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsICacheParticipant();
    public sealed virtual IEnumerable`1<string> GetPreImportedNamespaces();
    public sealed virtual string GetDefaultNamespace();
    public sealed virtual ICollection`1<PreProcessingDirective> GetDefines();
}
internal class JetBrains.ReSharper.Psi.Files.SmallCache`2 : object {
    private int myMaxDataSize;
    private Dictionary`2<TKey, Item<TKey, TValue>> myItemsInCache;
    private int myCurrentDataSize;
    private Item<TKey, TValue> myHead;
    private Item<TKey, TValue> myTail;
    public SmallCache`2(int maxDataSize);
    public bool Update(TKey key, TValue value, int valueSize);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public void Invalidate(TKey key);
    public void Clear();
    private void Add(TKey key, TValue value, int valueSize, int accessCount);
    private void Remove(Item<TKey, TValue> item);
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Files.SuppressFilesSystemTrackerCommitWhilePsiFilesCommitIsRunning : object {
    public SuppressFilesSystemTrackerCommitWhilePsiFilesCommitIsRunning(ISolution solution, IPsiFiles psiFiles, IFileSystemTracker fileSystemTracker);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.FindersExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("This method is unable to get performance profit from provided search domain. Use appropriate Finder method without searchdomain and use post filtering if necessary")]
public static void FindInheritors(IFinder finder, ITypeElement typeElement, ISearchDomain searchDomain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi);
    [ExtensionAttribute]
[ObsoleteAttribute("This method is unable to get performance profit from provided search domain. Use appropriate Finder method without searchdomain and use post filtering if necessary")]
public static void FindImmediateInheritors(IFinder finder, ITypeElement typeElement, ISearchDomain searchDomain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi);
    [ExtensionAttribute]
public static void FindImplementingMembers(IFinder finder, IOverridableMember member, ITypeElement originType, ISubstitution originSubstitution, IFindResultConsumer`1<TResult> consumer, SearchImplementorsPattern pattern, IProgressIndicator pi);
    [ExtensionAttribute]
[ObsoleteAttribute("This method is unable to get performance profit from provided search domain. Use appropriate Finder method without searchdomain and use post filtering if necessary")]
public static void FindImmediateImplementingMembers(IFinder finder, IOverridableMember member, ITypeElement originType, ISubstitution originSubstitution, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, bool searchQuasi, IProgressIndicator pi);
    public static FilteringResultConsumer`1<TResult> CreateFilteringResultConsumer(ISearchDomain searchDomain, IFindResultConsumer`1<TResult> consumer);
}
public static class JetBrains.ReSharper.Psi.Format.CasingUtil : object {
    [NotNullAttribute]
[PureAttribute]
public static string ConvertTextAccordingToCasing(string declaredText, Casing casing, string enteredText);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Format.ChangeSettings : Enum {
    public int value__;
    public static ChangeSettings None;
    public static ChangeSettings Indent;
    public static ChangeSettings Format;
    public static ChangeSettings Both;
    public static ChangeSettings DontChangeJustAdjustIndentValues;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Format.DeepCopyUtils : object {
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> DeepCopyDictionary(Dictionary`2<TKey, TValue> source, Func`2<TKey, TKey> keyCopier, Func`2<TValue, TValue> valueCopier);
    [ExtensionAttribute]
public static OneToSetMap`2<TKey, TValue> DeepCopyOneToSetMap(OneToSetMap`2<TKey, TValue> source, Func`2<TKey, TKey> keyCopier, Func`2<TValue, TValue> valueCopier);
    [ExtensionAttribute]
public static List`1<TValue> DeepCopyList(List`1<TValue> source, Func`2<TValue, TValue> valueCopier);
    [ExtensionAttribute]
public static JetHashSet`1<TValue> DeepCopyJetHashSet(JetHashSet`1<TValue> source, Func`2<TValue, TValue> valueCopier);
    private static void AddElementsToCopy(IEnumerable`1<TValue> source, Func`2<TValue, TValue> valueCopier, ICollection`1<TValue> result);
}
public enum JetBrains.ReSharper.Psi.Format.ExtraSpaces : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("Remove all extra spaces")]
public static ExtraSpaces REMOVE_ALL;
    [LocalizedDescriptionAttribute("Leave extra tabs")]
public static ExtraSpaces LEAVE_TABS;
    [LocalizedDescriptionAttribute("Leave multiple extra spaces")]
public static ExtraSpaces LEAVE_MULTIPLE;
    [LocalizedDescriptionAttribute("Leave all extra spaces and tabs")]
public static ExtraSpaces LEAVE_ALL;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Format.FileChangeAccu : object {
    [CompilerGeneratedAttribute]
private TextRangeTree`1<ChangeInfo> <ChangesByRange>k__BackingField;
    private Dictionary`2<PsiLanguageType, SingleLangChangeAccu> myLangAccus;
    [CompilerGeneratedAttribute]
private IDocument <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReferenceLinebreakStartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private Whitespace <ReferenceIndent>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private LineEnding <LineEnding>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowIndentsOnBlankLines>k__BackingField;
    [CompilerGeneratedAttribute]
private CachedSettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private IFormatterInfoProvider <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private AdditionalFormatterParameters <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TabWidth>k__BackingField;
    internal Dictionary`2<ITreeNode, ChangeInfo> NextSiblings;
    internal Dictionary`2<ITreeNode, ChangeInfo> PrevSiblings;
    internal int AlignInColumnsCounter;
    public TextRangeTree`1<ChangeInfo> ChangesByRange { get; }
    public IDocument Document { get; }
    public int ReferenceLinebreakStartOffset { get; public set; }
    public Whitespace ReferenceIndent { get; public set; }
    public IPsiSourceFile SourceFile { get; }
    public LineEnding LineEnding { get; }
    public bool AllowIndentsOnBlankLines { get; }
    public CachedSettings Settings { get; }
    public IFormatterInfoProvider Provider { get; }
    public AdditionalFormatterParameters Parameters { get; }
    public int TabWidth { get; }
    public FileChangeAccu(IDocument document, IPsiSourceFile sourceFile, LineEnding lineEnding, bool allowIndentsOnBlankLines, CachedSettings settings, IFormatterInfoProvider provider, AdditionalFormatterParameters parameters);
    [CompilerGeneratedAttribute]
public TextRangeTree`1<ChangeInfo> get_ChangesByRange();
    [CompilerGeneratedAttribute]
public IDocument get_Document();
    [CompilerGeneratedAttribute]
public int get_ReferenceLinebreakStartOffset();
    [CompilerGeneratedAttribute]
public void set_ReferenceLinebreakStartOffset(int value);
    [CompilerGeneratedAttribute]
public Whitespace get_ReferenceIndent();
    [CompilerGeneratedAttribute]
public void set_ReferenceIndent(Whitespace value);
    [CompilerGeneratedAttribute]
public IPsiSourceFile get_SourceFile();
    [CompilerGeneratedAttribute]
public LineEnding get_LineEnding();
    [CompilerGeneratedAttribute]
public bool get_AllowIndentsOnBlankLines();
    [CompilerGeneratedAttribute]
public CachedSettings get_Settings();
    [CompilerGeneratedAttribute]
public IFormatterInfoProvider get_Provider();
    [CompilerGeneratedAttribute]
public AdditionalFormatterParameters get_Parameters();
    [CompilerGeneratedAttribute]
public int get_TabWidth();
    internal SingleLangChangeAccu GetOrCreateSingleLangAccu(ICodeFormatterImpl formatter, CachedSettings cachedSettings);
    internal void RemoveChangeInfo(ChangeInfo changeInfo);
    public void CombineWith(FileChangeAccu other);
    public void ApplyChangesViaDocument();
    public string GetEditedDocumentText();
    public void CalcIndents();
    public List`1<Pair`2<IndentOperationOffset, IFormatterOperation>> GetAllFormatterOperations(bool includeWhitespaces);
    private Whitespace CalcIndentFromOffsetReplacingCharsWithWhitespaces(int offset);
    private void ProcessIndentElement(IndentRegionOperation& indentElement, Stack`1<IndentStackElement> indentStack, IndentDelta& indent, LineBreakChangeInfo lastlineBreakChangeInfo);
    internal int FindFirstLineBreakInRange(TextRange range);
    [NullableContextAttribute("0")]
internal ValueTuple`2<int, Whitespace> CountLineBreaksAndGetIndentInDocument(TextRange range);
    [NullableContextAttribute("2")]
public void ApplyChanges(CodeFormattingContext context);
    private void FullChangeWhitespacesBetweenPsiNodes(ChangeInfo changeInfo, TreeTextRange treeTextRange, IFile file, ICodeFormatterImpl formatter, string newWhitespaces, Whitespace indent, ITreeNode lastNewInsideToken);
    private ITreeNode ProcessChangeInsideToken(ITreeNode token, CodeFormattingContext context);
    private void Cleanup();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Format.FileChangeAccu/<CreatePsiWhitespaces>d__63")]
private IEnumerable`1<ITreeNode> CreatePsiWhitespaces(ChangeInfo changeInfo, ICodeFormatterImpl formatter, NodeType spaceType, NodeType lineBreakType, Whitespace existingIndent);
    internal string CreateWhitespaces(ChangeInfo changeInfo, Whitespace existingIndent);
    internal int GetLength(ChangeInfo changeInfo);
    [CompilerGeneratedAttribute]
internal static void <CalcIndents>g__FixElementOnStack|53_0(IndentDelta indentToFix, Whitespace realIndent, <>c__DisplayClass53_0& , <>c__DisplayClass53_1& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <CalcIndentFromOffsetReplacingCharsWithWhitespaces>g__Processor|55_0(ValueTuple`2& tuple, TextRange key, ChangeInfo data);
}
public class JetBrains.ReSharper.Psi.Format.FormatSettingsKeyBase : object {
    public static FormatSettingsKeyBase Default;
    public static string UseIndentFromVsName;
    public static string IndentStyleName;
    public static string IndentSizeName;
    public static string TabWidthName;
    public static string WrapLinesName;
    public static string WrapLimitName;
    public static string AlignmentTabFillStyleName;
    public static string ContinuousIndentMultiplier;
    [HideInEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "UseIndentStyleAndSizeFromVisualStudioSettingDescription")]
public bool USE_INDENT_FROM_VS;
    [EditorConfigEntryAliasAttribute("", "1")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "IndentStyleSettingDescription")]
public IndentStyle INDENT_STYLE;
    [EditorConfigEntryAliasAttribute("", "1")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "IndentSizeSettingDescription")]
public int INDENT_SIZE;
    [EditorConfigEntryAliasAttribute("", "1")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "TabWidthSettingDescription")]
public int TAB_WIDTH;
    [HideInEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "WrapLongLinesSettingDescription")]
public bool WRAP_LINES;
    [EditorConfigEntryAliasAttribute("max_line_length", "1")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "HardWrapAtSettingDescription")]
public int WRAP_LIMIT;
    [EditorConfigEntryAliasAttribute("insert_final_newline", "1")]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "LineFeedAtEndOfFileSettingDescription")]
public bool LINE_FEED_AT_FILE_END;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "RemoveSpacesOnBlankLines")]
public bool REMOVE_SPACES_ON_BLANK_LINES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "ExtraSpacesInsideSettingDescription")]
public ExtraSpaces EXTRA_SPACES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "DisableFormatterInGeneralSettingDescription")]
public bool DISABLE_FORMATTER;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "DisableIndenterSettingDescription")]
public bool DISABLE_INDENTER;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "DisableLineBreakChangesSettingDescription")]
public bool DISABLE_LINE_BREAK_CHANGES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "DisableLineBreakRemovalSettingDescription")]
public bool DISABLE_LINE_BREAK_REMOVAL;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "DisableSpaceChangesSettingDescription")]
public bool DISABLE_SPACE_CHANGES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "DisableBlankLineChangesSettingDescription")]
public bool DISABLE_BLANK_LINE_CHANGES;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "DisableAlignInColumnsSettingDescription")]
public bool DISABLE_INT_ALIGN;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "KeepUserWrappingSettingDescription")]
public bool KEEP_USER_WRAPPING;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "UsePreviousElementsIndentOnPartialFormatSettingDescription")]
public bool USE_INDENT_FROM_PREVIOUS_ELEMENT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "FixColumnAlignmentInAdjacentLinesSettingDescription")]
public bool INT_ALIGN_FIX_IN_ADJACENT;
    [HideInEditorConfigAttribute]
[SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "FormatLeadingFileSpacesViaDeclarativeFormatterSettingDescription")]
public bool FORMAT_LEADING_SPACES_DECL;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "HowToAlignWhenTabsAreUsedForIndentsSettingDescription")]
public AlignmentTabFillStyle ALIGNMENT_TAB_FILL_STYLE;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "AlignEvenIfTheResultingIndentationIsTooLargeSettingDescription")]
public bool ALLOW_FAR_ALIGNMENT;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "ContinuousLineIndentMultiplierSettingDescription")]
public int CONTINUOUS_INDENT_MULTIPLIER;
    private static FormatSettingsKeyBase();
    public int GetIndentAsInt();
    public virtual string ToString();
    public FormatSettingsKeyBase Clone();
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Format.GlobalFormatSettingsService : object {
    private PsiProjectFileTypeCoordinator myCoordinator;
    protected ILogger myLogger;
    private GlobalFormatSettings myDefaultSettings;
    public GlobalFormatSettingsService(PsiProjectFileTypeCoordinator coordinator, ILogger logger);
    public virtual GlobalFormatSettings GetDefaultSettings();
    public virtual GlobalFormatSettings GetLangSettings(PsiLanguageType languageType);
    public sealed virtual GlobalFormatSettings GetLangSettings(ProjectFileType projectFileType);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{ToString()}")]
public class JetBrains.ReSharper.Psi.Format.IndentOperationOffset : ValueType {
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private IndentOpOrientation <Orientation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OrderNum>k__BackingField;
    public int Offset { get; public set; }
    public IndentOpOrientation Orientation { get; public set; }
    public int OrderNum { get; public set; }
    public IndentOperationOffset(int Offset, IndentOpOrientation Orientation, int OrderNum);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Offset(int value);
    [CompilerGeneratedAttribute]
public IndentOpOrientation get_Orientation();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Orientation(IndentOpOrientation value);
    [CompilerGeneratedAttribute]
public int get_OrderNum();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OrderNum(int value);
    public sealed virtual int CompareTo(IndentOperationOffset other);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(IndentOperationOffset left, IndentOperationOffset right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(IndentOperationOffset left, IndentOperationOffset right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(IndentOperationOffset other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& Offset, IndentOpOrientation& Orientation, Int32& OrderNum);
}
public enum JetBrains.ReSharper.Psi.Format.IndentOpOrientation : Enum {
    public int value__;
    public static IndentOpOrientation Left;
    public static IndentOpOrientation Middle;
    public static IndentOpOrientation Right;
    public static IndentOpOrientation Indent;
    public static IndentOpOrientation Delayed;
}
public enum JetBrains.ReSharper.Psi.Format.IndentStyle : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("Tab")]
public static IndentStyle Tab;
    [LocalizedDescriptionAttribute("Spaces")]
public static IndentStyle Space;
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.Format.ISplitWhitespaceBetweenTokens {
    public abstract virtual ValueTuple`2<string, string> SplitWhitespaceBetweenTokens(TokenNodeType leftToken, TokenNodeType rightToken, string whitespace);
}
public interface JetBrains.ReSharper.Psi.Format.IVirtualCodeFormatter {
    public abstract virtual IReadOnlyList`1<VirtualIndent> RunVirtualFormatting(IFile file, bool onlyFixForInlayHints);
    public abstract virtual void FormatWithVirtualSettingsForPreview(ITreeNode node, CodeFormatProfile profile, IProgressIndicator instance, IContextBoundSettingsStore boundSettingsStore);
}
public abstract class JetBrains.ReSharper.Psi.Format.OverrideFormatterSettingsCookie : object {
    [NotNullAttribute]
[MustDisposeResourceAttribute]
public static IDisposable Create(IPsiServices psiServices, Expression`1<Func`2<TSettingsKey, TValue>> setting, TValue value);
    [NotNullAttribute]
[MustDisposeResourceAttribute]
public static IDisposable CreateBase(IPsiServices psiServices, Expression`1<Func`2<FormatSettingsKeyBase, TValue>> setting, TValue value);
    [NotNullAttribute]
[MustDisposeResourceAttribute]
public static IDisposable CreateBase(ISolution solution, Expression`1<Func`2<FormatSettingsKeyBase, TValue>> setting, TValue value);
    [NotNullAttribute]
[MustDisposeResourceAttribute]
public static IDisposable CreateBase(ITreeNode node, Expression`1<Func`2<FormatSettingsKeyBase, TValue>> setting, TValue value);
    public abstract virtual void Override(CachedSettings settings, Type settingsKeyType);
    public abstract virtual void Override(TSettingKey2 settings);
}
public class JetBrains.ReSharper.Psi.Format.OverrideFormatterSettingsCookie`1 : OverrideFormatterSettingsCookie {
    private FrugalLocalList`1<OverrideSettings<TSettingsKey>> myList;
    [NotNullAttribute]
public OverrideFormatterSettingsCookie`1<TSettingsKey> AddOverrider(Expression`1<Func`2<TSettingsKey, TValue>> setting, object value);
    [NotNullAttribute]
[MustDisposeResourceAttribute]
public IDisposable Finish(IPsiServices services);
    public virtual void Override(CachedSettings settings, Type settingsKeyType);
    public virtual void Override(TSettingKey2 settings);
}
public enum JetBrains.ReSharper.Psi.Format.QuoteStyle : Enum {
    public int value__;
    [LocalizedDescriptionAttribute("Apostrophe: '")]
[EditorConfigValueAliasAttribute("singlequoted", "True")]
public static QuoteStyle SingleQuoted;
    [LocalizedDescriptionAttribute("Quote: "")]
[EditorConfigValueAliasAttribute("doublequoted", "True")]
public static QuoteStyle DoubleQuoted;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Format.QuoteStyleEx : object {
    [ExtensionAttribute]
public static char ToPresentation(QuoteStyle qs);
}
[MigrateSettingsAttribute]
public class JetBrains.ReSharper.Psi.Format.SettingsUpgrade.AlignmentTabFillStyleMigration : object {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Format.SettingsUpgrade.AlignmentTabFillStyleMigration/<JetBrains-Application-Settings-Upgrade-IMigrateSettings-GetEntriesToMigrate>d__0")]
private sealed virtual override IEnumerable`1<SettingsEntry> JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetEntriesToMigrate(ISettingsSchema schema);
    private sealed virtual override IEnumerable`1<SettingsKey> JetBrains.Application.Settings.Upgrade.IMigrateSettings.GetKeysToMigrate(ISettingsSchema schema);
    private sealed virtual override void JetBrains.Application.Settings.Upgrade.IMigrateSettings.Migrate(IContextBoundSettingsStoreImplementation store);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Format.SingleLangChangeAccu : object {
    [CompilerGeneratedAttribute]
private FileChangeAccu <FileChangeAccu>k__BackingField;
    [CompilerGeneratedAttribute]
private AdditionalFormatterParameters <Parameters>k__BackingField;
    private int myLastLineBreak;
    private int myLastIndenting;
    private int myLastBlankLineIndentOrderNum;
    private int myFileStartPosition;
    private bool myWasIndent;
    private int myIndentCounter;
    internal List`1<IndentRegionOperation> Indents;
    [CompilerGeneratedAttribute]
private IDocument <Document>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ICodeFormatterImpl <Formatter>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IFormatterInfoProvider <Provider>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CachedSettings <Settings>k__BackingField;
    public FileChangeAccu FileChangeAccu { get; }
    public AdditionalFormatterParameters Parameters { get; }
    public IDocument Document { get; }
    [NullableAttribute("2")]
public ICodeFormatterImpl Formatter { get; }
    [NullableAttribute("2")]
public IFormatterInfoProvider Provider { get; }
    [NullableAttribute("2")]
internal CachedSettings Settings { get; internal set; }
    public SingleLangChangeAccu(IPsiSourceFile sourceFile, ICodeFormatterImpl formatter, FileChangeAccu fileChangeAccu, AdditionalFormatterParameters parameters);
    [CompilerGeneratedAttribute]
public FileChangeAccu get_FileChangeAccu();
    [CompilerGeneratedAttribute]
public AdditionalFormatterParameters get_Parameters();
    [CompilerGeneratedAttribute]
public IDocument get_Document();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ICodeFormatterImpl get_Formatter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IFormatterInfoProvider get_Provider();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal CachedSettings get_Settings();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Settings(CachedSettings value);
    public int GetNextAlignInColumnsCounter();
    [NullableContextAttribute("2")]
public void FileStart(IFile contextFile);
    public void SetReferenceLine(int referenceLinebreakStartOffset, Whitespace referenceIndent);
    public void IndentInsideToken(ITreeNode token, int position, IndentDelta delta, Nullable`1<Whitespace> approxIndent, bool closeIndent, String[] meaningfulSpaces);
    [NullableContextAttribute("2")]
public void FormatBetweenSiblings(ITreeNode lChild, ITreeNode rChild, int lineBreaks, Whitespace whitespace, int alignInColumnsId);
    private IndentOpOrientation GetMinimumOrientation(int position);
    private void FixOrientation(int position, IndentOpOrientation& orientation);
    public void OpenIndent(int position, IndentOpOrientation orientation, IndentDelta indent, bool alignment, bool continuousIndent, object additionalDebugInfo);
    public void CloseIndent(int position, IndentDelta indent, int closingPosition, IndentOpOrientation orientation, object additionalDebugInfo);
    private TextRange GetWhitespaceRange(int position);
    [NullableContextAttribute("2")]
private LineBreakChangeInfo GetOrCreateLineBreakChangeInfo(int position, ITreeNode prevSibling, ITreeNode nextSibling, ChangeSettings changeSettings, ITreeNode insideToken, String[] meaningfulSpaces);
    private void UpdateIndentRegionsOnPosition(int offset, IndentOpOrientation orientation);
    public void LineBreak(int position);
    public object SaveIndentState();
    public void RestoreIndentState(object state);
    [NullableContextAttribute("2")]
internal LineBreakChangeInfo DoIndentInternal(ITreeNode prevSibling, ITreeNode nextSibling, Nullable`1<Whitespace> approxIndent, ITreeNode insideToken, ChangeSettings changeSettings, String[] meaningfulSpaces);
    [NullableContextAttribute("2")]
public void DoIndent(ITreeNode prevSibling, ITreeNode nextSibling, Nullable`1<Whitespace> approxIndent, ITreeNode insideToken, ChangeSettings changeSettings, String[] meaningfulSpaces);
    public VirtNode GetPrevSibling(ITreeNode node);
    public VirtNode GetNextSibling(ITreeNode node);
    public bool HasLineBreaks(ITreeNode node);
    [NullableContextAttribute("0")]
public ValueTuple`3<bool, Whitespace, int> GetLastLineBreakInfo(ITreeNode node, int tabWidth, int fromPosition);
    [NullableContextAttribute("0")]
public ValueTuple`2<bool, int> GetFirstLineBreakInfo(ITreeNode node);
    public int GetLength(ITreeNode node);
    private bool ProcessMultilineNode(ITreeNode node, Func`2<string, bool> stringProcessor, Func`2<LineBreakChangeInfo, bool> lineBreakProcessor, Func`2<WhitespaceChangeInfo, bool> whitespaceProcessor, int startPosition, int endPosition);
    public Nullable`1<VirtNode> FileStartChange(IFile file);
    public int GetLineNumber(DocumentOffset docOffset);
    [CompilerGeneratedAttribute]
private void <FormatBetweenSiblings>g__ProcessWhitespace|31_0(ITreeNode node, <>c__DisplayClass31_0& );
    [CompilerGeneratedAttribute]
internal static int <GetOrCreateLineBreakChangeInfo>g__CompareRanges|37_2(ChangeInfo info1, ChangeInfo info2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Format.VirtNode : ValueType {
    private object AccuOrFormatter;
    [NullableAttribute("2")]
public ITreeNode NodeOrNull;
    [NullableAttribute("2")]
private ChangeInfo Change;
    public VirtNode Null { get; }
    public IWhitespaceChecker WhitespaceChecker { get; }
    public SingleLangChangeAccu Accu { get; }
    [NullableAttribute("2")]
private SingleLangChangeAccu AccuOrNull { get; }
    public bool IsNull { get; }
    public bool IsNotNull { get; }
    public VirtNode PrevSibling { get; }
    public VirtNode NextSibling { get; }
    public VirtNode FirstChild { get; }
    public VirtNode LastChild { get; }
    public bool IsToken { get; }
    public VirtNode Parent { get; }
    public ITreeNode Node { get; }
    public bool IsWhitespaceOrEmpty { get; }
    public bool IsWhitespace { get; }
    public bool IsPureWhitespace { get; }
    public bool IsLineBreakOrMultilineTokenWithLineBreak { get; }
    public bool IsLineBreakTokenWithEmptyIndent { get; }
    public bool IsLineBreakToken { get; }
    public int LineBreaksTokensCount { get; }
    public string NodeTypeStr { get; }
    public bool IsZeroLength { get; }
    public NodeType NodeType { get; }
    public bool IsEmpty { get; }
    public bool IsNotSynthetical { get; }
    public VirtNode(CodeFormattingContext context, ITreeNode node);
    public VirtNode(IWhitespaceChecker checker, ITreeNode node);
    public VirtNode(SingleLangChangeAccu accu, ITreeNode node);
    internal VirtNode(SingleLangChangeAccu accu, ChangeInfo changeInfo);
    private VirtNode(object accuOrFormatter, ChangeInfo changeInfo);
    private VirtNode(object accuOrFormatter, ITreeNode treeNode);
    [NullableContextAttribute("2")]
private VirtNode(object accuOrFormatter, ITreeNode node, ChangeInfo changeInfo);
    public static VirtNode FromAnotherLanguage(CodeFormattingContext context, ITreeNode node);
    public VirtNode get_Null();
    public IWhitespaceChecker get_WhitespaceChecker();
    public SingleLangChangeAccu get_Accu();
    [NullableContextAttribute("2")]
private SingleLangChangeAccu get_AccuOrNull();
    public bool get_IsNull();
    public bool get_IsNotNull();
    public VirtNode Create(ITreeNode node);
    public VirtNode get_PrevSibling();
    public VirtNode get_NextSibling();
    public VirtNode get_FirstChild();
    public VirtNode get_LastChild();
    public bool get_IsToken();
    public VirtNode get_Parent();
    public ITreeNode get_Node();
    public bool get_IsWhitespaceOrEmpty();
    public bool get_IsWhitespace();
    public bool get_IsPureWhitespace();
    [NullableContextAttribute("0")]
public ValueTuple`3<bool, Whitespace, int> GetLastLineBreakInfo(int tabWidth, int fromPosition);
    [NullableContextAttribute("0")]
public ValueTuple`2<bool, int> GetFirstLineBreakInfo();
    public bool get_IsLineBreakOrMultilineTokenWithLineBreak();
    public bool get_IsLineBreakTokenWithEmptyIndent();
    public bool get_IsLineBreakToken();
    public int get_LineBreaksTokensCount();
    public string get_NodeTypeStr();
    public bool Equals(VirtNode other);
    [NullableContextAttribute("2")]
public bool Equals(ITreeNode other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(VirtNode left, VirtNode right);
    public static bool op_Inequality(VirtNode left, VirtNode right);
    [NullableContextAttribute("2")]
public static bool op_Equality(VirtNode left, ITreeNode right);
    [NullableContextAttribute("2")]
public static bool op_Equality(ITreeNode left, VirtNode right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(VirtNode left, ITreeNode right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(ITreeNode left, VirtNode right);
    public VirtNode Coalesce(VirtNode other);
    public VirtNode Coalesce(Nullable`1<VirtNode> other);
    public string GetText();
    public TreeOffset GetTreeEndOffset();
    public TreeOffset GetTreeStartOffset();
    [NullableContextAttribute("2")]
public IFile GetContainingFile();
    public bool IsPhysical();
    public TreeTextRange GetTreeTextRange();
    public bool get_IsZeroLength();
    public NodeType get_NodeType();
    public bool get_IsEmpty();
    public bool get_IsNotSynthetical();
    public int GetOriginalTextLength();
    public int GetTextLength();
    public VirtNode GetNextToken();
    public VirtNode GetPreviousToken();
    public VirtNode FindFirstTokenIn();
    public VirtNode FindLastTokenIn();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Format.VirtNode/<PathToRoot>d__89")]
public IEnumerable`1<VirtNode> PathToRoot();
    public bool Contains(VirtNode other);
    public VirtNode FindLCA(VirtNode other);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Format.VirtNode/<PrevTokens>d__92")]
public IEnumerable`1<VirtNode> PrevTokens();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Format.VirtNode/<NextTokens>d__93")]
public IEnumerable`1<VirtNode> NextTokens();
    public bool IsIndentNode(bool includePrefixCommentInIndent);
    public Whitespace GetWhitespace(int tabWidth);
    public VirtNode FindCommonParent(VirtNode node2);
    public bool IsValid();
    public VirtNode GetSelfOrLastDescendant();
    public VirtNode GetSelfOrFirstDescendant();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Format.VirtNode/<LeftSiblings>d__100")]
public IEnumerable`1<VirtNode> LeftSiblings();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Format.VirtNode/<RightSiblings>d__101")]
public IEnumerable`1<VirtNode> RightSiblings();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Format.VirtNode/<SelfAndRightSiblings>d__102")]
public IEnumerable`1<VirtNode> SelfAndRightSiblings();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Format.VirtNode/<SelfAndPrevTokens>d__103")]
public IEnumerable`1<VirtNode> SelfAndPrevTokens();
    public VirtNode GetContainingNode(bool returnThis);
    public VirtNode GetContainingNode(Predicate`1<T> predicate, bool returnThis);
    public bool IsFiltered();
    public VirtNode GetPreviousMeaningfulSibling(Nullable`1<VirtNode> parent);
    public VirtNode GetNextMeaningfulSibling(Nullable`1<VirtNode> parent);
    public VirtNode GetPreviousMeaningfulChild(VirtNode child);
    public VirtNode GetNextMeaningfulChild(VirtNode child);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Format.VirtNode/<Children>d__111")]
public IEnumerable`1<VirtNode> Children();
    [NullableContextAttribute("2")]
public TokenNodeType GetTokenType();
    public int GetLineNumber();
    public DocumentRange GetDocumentRange();
    public DocumentOffset GetDocumentStartOffset();
    public DocumentOffset GetDocumentEndOffset();
    public VirtNode RestoreAfterChanges();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.FunctionPointerParameter : ValueType {
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterKind <Kind>k__BackingField;
    public IType Type { get; }
    public ParameterKind Kind { get; }
    public FunctionPointerParameter(IType type, ParameterKind kind);
    [CompilerGeneratedAttribute]
public IType get_Type();
    [CompilerGeneratedAttribute]
public ParameterKind get_Kind();
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.GeneralPresentationFlags : Enum {
    public int value__;
    public static GeneralPresentationFlags ShowAccessRights;
    public static GeneralPresentationFlags ShowModifiers;
    public static GeneralPresentationFlags ShowNameInQuotes;
    public static GeneralPresentationFlags ShowConstantValue;
    public static GeneralPresentationFlags ShowParameterNames;
    public static GeneralPresentationFlags ShowParameterTypes;
    public static GeneralPresentationFlags ShowParametersForDelegates;
    public static GeneralPresentationFlags ShowMemberContainerQualified;
    public static GeneralPresentationFlags ShowAccessorsInCompiledForm;
    public static GeneralPresentationFlags ShowMSDNCompatibleConstructorName;
    public static GeneralPresentationFlags ShowExplicitInterfaceQualification;
    public static GeneralPresentationFlags MakeUseOfNonBreakableSpace;
    public static GeneralPresentationFlags ShowParameterlessHint;
    public static GeneralPresentationFlags ShowContainingTypeInsteadOfConstructorName;
}
public class JetBrains.ReSharper.Psi.Generated : object {
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.GeneratedCode.DaemonExcludedFilesManager : object {
    private SettingsIndexedEntry myFilesAndFoldersToSkipEntry;
    private SettingsIndexedEntry myFileMasksToSkipEntry;
    private SettingsIndexedEntry mySourceGeneratedFilesToSkipEntry;
    private IShellLocks myLocks;
    private ISettingsStore mySettingsStore;
    private Lifetime myLifetime;
    private ProjectModelElementPointerManager myElementPointerManager;
    private object myCacheLockObject;
    private SettingsCacheManager mySettingsCacheManager;
    private ILogger myLogger;
    private SettingsKey myKeyExposed;
    private LifetimeDefinition myCacheLifetimeDefinition;
    private IFileSkipChecker myFastIsToSkipChecker;
    [CompilerGeneratedAttribute]
private ProjectModelElementPointersSet <FilesAndFoldersToSkip>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectModelElementPointersSet <FilesAndFoldersToForceEnable>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    private bool myIsInitialized;
    public ISimpleSignal Changed;
    public ProjectModelElementPointersSet FilesAndFoldersToSkip { get; }
    public ProjectModelElementPointersSet FilesAndFoldersToForceEnable { get; }
    public ISolution Solution { get; }
    private SettingsKey JetBrains.Application.Settings.Extentions.ICachedSettingsReader<JetBrains.ReSharper.Psi.GeneratedCode.ExcludedFilesInfo>.KeyExposed { get; }
    public DaemonExcludedFilesManager(IShellLocks locks, ISettingsStore settingsStore, ISolution solution, Lifetime lifetime, ProjectModelElementPointerManager elementPointerManager, SettingsCacheManager settingsCacheManager, ChangeManager changeManager, ILogger logger, ISolutionLoadTasksScheduler scheduler);
    [CompilerGeneratedAttribute]
public ProjectModelElementPointersSet get_FilesAndFoldersToSkip();
    [CompilerGeneratedAttribute]
public ProjectModelElementPointersSet get_FilesAndFoldersToForceEnable();
    [CompilerGeneratedAttribute]
public ISolution get_Solution();
    public static DaemonExcludedFilesManager GetInstance(ISolution solution);
    private void UpdateFilesAndFoldersToSkip();
    public IFileSkipChecker GetFastMassiveFileSkipChecker();
    private IFileSkipChecker CreateFastMassiveFileSkipChecker();
    [CanBeNullAttribute]
public ExcludedFilesInfo GetInfo(IProjectModelElement projectModelElement);
    public sealed virtual bool IsToSkip(IProjectFile projectFile);
    public bool IsForceEnableFast(IProjectFile projectFile);
    public sealed virtual bool IsForceEnable(IProjectFile projectFile);
    public bool IsForceEnable(IProjectFile projectFile, ExcludedFilesInfo info);
    public virtual bool IsToSkip(IProjectFile projectFile, ExcludedFilesInfo info);
    public bool IsFolderToSkip(IProjectFolder projectFolder, ExcludedFilesInfo info);
    private bool IsToSkipByMask(IProjectFile projectFile, ExcludedFilesInfo info);
    public bool IsToSkipByMask(ISourceGeneratorOutputFile sourceGeneratorOutputFile, ExcludedFilesInfo info);
    public void AddFileToSkip(IProjectFile file);
    public void AddFileToForceEnable(IProjectFile file);
    public void RemoveFileToSkip(IProjectFile file);
    public void RemoveFileToForceEnable(IProjectFile file);
    public void AddFolderToSkip(IProjectFolder folder);
    public void RemoveFolderToSkip(IProjectFolder folder);
    private bool UpdateSourceGeneratedFileExclude(IProjectFile file, Nullable`1<ExcludedFileState> state);
    [CanBeNullAttribute]
private static string GetSourceGeneratedFileProjectPath(ISourceGeneratorOutputFile sourceGeneratorOutputFile);
    public sealed virtual ExcludedFilesInfo ReadData(Lifetime lifetime, IContextBoundSettingsStore store);
    private sealed virtual override SettingsKey JetBrains.Application.Settings.Extentions.ICachedSettingsReader<JetBrains.ReSharper.Psi.GeneratedCode.ExcludedFilesInfo>.get_KeyExposed();
    [CompilerGeneratedAttribute]
private void <UpdateFilesAndFoldersToSkip>b__27_0();
}
public class JetBrains.ReSharper.Psi.GeneratedCode.ExcludedFilesInfo : object {
    [CompilerGeneratedAttribute]
private ProjectModelElementPointersSet <FilesAndFoldersToSkip>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectModelElementPointersSet <FilesAndFoldersToForceEnable>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PathWildcard> <FileMasksToSkip>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, ExcludedFileState> <SourceGeneratedFilesExclusionState>k__BackingField;
    [NotNullAttribute]
public ProjectModelElementPointersSet FilesAndFoldersToSkip { get; }
    [NotNullAttribute]
public ProjectModelElementPointersSet FilesAndFoldersToForceEnable { get; }
    [NotNullAttribute]
public IReadOnlyList`1<PathWildcard> FileMasksToSkip { get; }
    [NotNullAttribute]
public IReadOnlyDictionary`2<string, ExcludedFileState> SourceGeneratedFilesExclusionState { get; }
    public ExcludedFilesInfo(Lifetime lifetime, ISolution solution, IContextBoundSettingsStore store, ProjectModelElementPointerManager projectModelElementPointerManager, ILogger logger, string name);
    [CompilerGeneratedAttribute]
public ProjectModelElementPointersSet get_FilesAndFoldersToSkip();
    [CompilerGeneratedAttribute]
public ProjectModelElementPointersSet get_FilesAndFoldersToForceEnable();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PathWildcard> get_FileMasksToSkip();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, ExcludedFileState> get_SourceGeneratedFilesExclusionState();
    [CanBeNullAttribute]
private PathWildcard MakePathWildcard(VirtualFileSystemPath path);
}
public abstract class JetBrains.ReSharper.Psi.GeneratedCode.GeneratedCodeRegionChecker : object {
    [PureAttribute]
public bool IsInGeneratedRegion(ITreeNode element);
    [NotNullAttribute]
public abstract virtual IGeneratedCodeRegionDetector CreateDetector(IContextBoundSettingsStore settingsStore);
}
public static class JetBrains.ReSharper.Psi.GeneratedCode.GeneratedCodeSettingsAccessor : object {
    public static Expression`1<Func`2<GeneratedCodeSettingsKey, IIndexedEntry`2<string, string>>> GeneratedCodeRegions;
    public static Expression`1<Func`2<GeneratedCodeSettingsKey, IIndexedEntry`2<string, string>>> GeneratedFileMasks;
    public static Expression`1<Func`2<GeneratedCodeSettingsKey, bool>> IsGeneratedCode;
    private static GeneratedCodeSettingsAccessor();
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.GeneratedCode.GeneratedFilesCache : SimpleICache`1<CachedValue> {
    private static Key`1<CachedProjectItemAnyChange`2<IProject, int>> ourIntermediateDirectoriesTimeStampCache;
    private LanguageManager myLanguageManager;
    private GenerateUtilsCache myGenerateCache;
    private IContextBoundSettingsStoreLive myContextBoundSettingsStore;
    private JetFastSemiReenterableRWLock myLock;
    private int mySettingsTimestamp;
    public GeneratedFilesCache(Lifetime lifetime, IPersistentIndexManager persistentIndexManager, LanguageManager languageManager, ISolution solution, ISettingsStore settingsStore, GenerateUtilsCache generateCache, IConfigFileCache configFileCache);
    private static GeneratedFilesCache();
    private void ProcessSettingsChange();
    public bool IsGeneratedFile(IPsiSourceFile sourceFile);
    private bool CheckGeneratedByMaskAndPath(IPsiSourceFile file);
    private static bool CheckGeneratedByEditorConfig(IPsiSourceFile file);
    public virtual object Build(IPsiSourceFile sourceFile, bool isStartup);
    private int GetTimeStampForSourceFile(IPsiSourceFile sourceFile);
    private bool CheckGeneratedByContent(IPsiSourceFile sourceFile);
    public static GeneratedFilesCache GetInstance(ISolution solution);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <.ctor>b__6_0(Lifetime _, VirtualFileSystemPath _);
}
public class JetBrains.ReSharper.Psi.GeneratedCode.GeneratedFilesCacheAccessor : object {
    public static Expression`1<Func`2<GeneratedFilesCacheKey, int>> Timestamp;
    private static GeneratedFilesCacheAccessor();
}
[SettingsKeyAttribute("JetBrains.ProjectModel.Settings.Schema.HierarchySettings", "JetBrains.ReSharper.Psi.Resources.Strings", "GeneratedFilesCacheSettingsSettingDescription")]
public class JetBrains.ReSharper.Psi.GeneratedCode.GeneratedFilesCacheKey : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "GeneratedFilesCacheTimestampSettingDescription")]
public int Timestamp;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.GeneratedCode.GeneratedFilesExt : object {
    [ExtensionAttribute]
public static bool IsGeneratedFile(IProjectFile projectFile);
}
public class JetBrains.ReSharper.Psi.GeneratedCode.GeneratedFilesUtil : object {
    private static Dictionary`2<string, Regex> ourFetchFilePathRegexes;
    private static GeneratedFilesUtil();
    [NotNullAttribute]
public static VirtualFileSystemPath TryGetSourceFilePath(VirtualFileSystemPath generatedFilePath);
    [NotNullAttribute]
public static VirtualFileSystemPath TryGetSourceFilePath(IPsiSourceFileWithLocation sourceFile);
    [NotNullAttribute]
public static VirtualFileSystemPath TryGetSourceFilePath(INavigateablePsiSourceFile sourceFile);
    [NotNullAttribute]
public static VirtualFileSystemPath TryGetSourceFilePath(ISourceGeneratorOutputFile sourceFile);
    [NotNullAttribute]
public static VirtualFileSystemPath TryGetSourceFilePath(IPsiSourceFile sourceFile, VirtualFileSystemPath generatedFilePath);
    [NotNullAttribute]
private static VirtualFileSystemPath TryGetSourceFilePath(IPath generatedFilePath, Func`1<string> getFirstLine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.GeneratedCode.GeneratedPathRegex : object {
    private static Dictionary`2<string, Regex> ourCachedRegexes;
    private Regex myFileNameRegex;
    private Regex[] myDirectoryNamesRegexes;
    public GeneratedPathRegex(string mask);
    private static GeneratedPathRegex();
    public bool IsMatch(IProjectFile projectFile);
    public bool IsMatch(VirtualFileSystemPath location);
    [CompilerGeneratedAttribute]
internal static Regex <.ctor>g__CreateRegex|3_0(string mask);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.GeneratedCode.GeneratedUtils : object {
    [ExtensionAttribute]
public static bool IsGeneratedDeclaration(IDeclaration declaration);
    public static bool IsElementInGeneratedFileOrRegion(ITreeNode element);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
private static IGeneratedCodeRegionDetector TryGetGeneratedCodeRegionDetector(ITreeNode context, IContextBoundSettingsStore settingsStore);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IGeneratedCodeRegionDetector TryGetInitializedGeneratedCodeRegionDetector(ITreeNode root, IContextBoundSettingsStore settingsStore);
    [ExtensionAttribute]
public static void Reset(IGeneratedCodeRegionDetector generatedRegionDetector, ITreeNode node);
    [ExtensionAttribute]
public static IEnumerable`1<ITreeNode> ThisAndDescendantsWithoutGeneratedRegions(ITreeNode root);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.GeneratedCode.GeneratedUtils/<WithoutGeneratedRegionsImpl>d__6")]
private static IEnumerable`1<ITreeNode> WithoutGeneratedRegionsImpl(ITreeNode root, IGeneratedCodeRegionDetector generatedRegionDetector);
    public static Predicate`1<DocumentRange> GetGeneratedDocumentRangeChecker(ITreeNode root);
    internal static GeneratedPathRegex GetGeneratedPathRegex(string mask);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.GeneratedCode.GenerateUtilsCache : object {
    private Lifetime myLifetime;
    private ISolution mySolution;
    [NotNullAttribute]
private SettingsCacheManager mySettingsCacheManager;
    [NotNullAttribute]
private ProjectModelElementPointerManager myProjectModelElementPointerManager;
    [NotNullAttribute]
private ILogger myLogger;
    [NotNullAttribute]
private SettingsKey mySettingsKey;
    private static GeneratedPathRegex GCS;
    private static GeneratedPathRegex IGCS;
    private SettingsKey JetBrains.Application.Settings.Extentions.ICachedSettingsReader<JetBrains.ReSharper.Psi.GeneratedCode.GenerateUtilsCache.Entry>.KeyExposed { get; }
    public GenerateUtilsCache(Lifetime lifetime, ISolution solution, SettingsCacheManager settingsCacheManager, ISettingsStore settingsStore, ProjectModelElementPointerManager projectModelElementPointerManager, ILogger logger);
    private static GenerateUtilsCache();
    private sealed virtual override Entry JetBrains.Application.Settings.Extentions.ICachedSettingsReader<JetBrains.ReSharper.Psi.GeneratedCode.GenerateUtilsCache.Entry>.ReadData(Lifetime lifetime, IContextBoundSettingsStore store);
    private sealed virtual override SettingsKey JetBrains.Application.Settings.Extentions.ICachedSettingsReader<JetBrains.ReSharper.Psi.GeneratedCode.GenerateUtilsCache.Entry>.get_KeyExposed();
    public bool IsGeneratedFileByMaskAndPath(IProjectFile projectFile);
    public bool IsGeneratedFileByMask(IProjectFile projectFile);
    private bool IsGeneratedFileByMask(ISettingsCache cache, IProjectFile projectFile);
    public bool IsGeneratedFileByMask(IProject project, VirtualFileSystemPath location);
    private bool IsGeneratedFileByMask(ISettingsCache cache, T item, Func`3<GeneratedPathRegex, T, bool> isMatch);
}
public interface JetBrains.ReSharper.Psi.GeneratedCode.IFileSkipChecker {
    [PureAttribute]
public abstract virtual bool IsToSkip(IProjectFile file);
    [PureAttribute]
public abstract virtual bool IsForceEnable(IProjectFile file);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.GeneratedCode.IGeneratedCodeRegionDetector {
    public bool InGeneratedCode { get; }
    public abstract virtual bool get_InGeneratedCode();
    public abstract virtual void Process(ITreeNode node);
    public abstract virtual void Reset();
}
public interface JetBrains.ReSharper.Psi.GeneratedCode.IGeneratedFilesCacheProvider {
    public abstract virtual bool IsGeneratedFile(IPsiSourceFile sourceFile);
}
public static class JetBrains.ReSharper.Psi.GeneratedCode.Settings.ExcludedFilesSettingsAccessor : object {
    public static Expression`1<Func`2<ExcludedFilesSettingsKey, IIndexedEntry`2<string, bool>>> FileMasksToSkip;
    public static Expression`1<Func`2<ExcludedFilesSettingsKey, IIndexedEntry`2<string, string>>> GeneratedFilesAndFolders;
    public static Expression`1<Func`2<ExcludedFilesSettingsKey, bool>> SourceGeneratedFilesSweaEnabled;
    private static ExcludedFilesSettingsAccessor();
}
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeInspectionSettings", "JetBrains.ReSharper.Psi.Resources.Strings", "FilesExcludedFromCodeAnalysisSettingDescription")]
public class JetBrains.ReSharper.Psi.GeneratedCode.Settings.ExcludedFilesSettingsKey : object {
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "FilesAndFoldersToSkipSettingDescription")]
public IIndexedEntry`2<string, ExcludedFileState> FilesAndFoldersToSkip2;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "FileMasksToSkipSettingDescription")]
public IIndexedEntry`2<string, bool> FileMasksToSkip;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "SourceGeneratedFilesToSkipSettingDescription")]
public IIndexedEntry`2<string, ExcludedFileState> SourceGeneratedFilesToSkip;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "GeneratedFilesAndFoldersToSkipSettingDescription")]
public IIndexedEntry`2<string, string> GeneratedFilesAndFolders;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "ExcludedFilesSettingsKey_SourceGeneratedFilesSweaEnabled_Description")]
public bool SourceGeneratedFilesSweaEnabled;
}
[SolutionSettingsUpgraderAttribute("0")]
public class JetBrains.ReSharper.Psi.GeneratedCode.Settings.ExcludedFilesSettingsUpgrader : object {
    private ISolution mySolution;
    private ProjectModelElementPointerManager myElementPointerManager;
    private ILogger myLogger;
    public ExcludedFilesSettingsUpgrader(ISolution solution, ProjectModelElementPointerManager elementPointerManager, ILogger logger);
    public sealed virtual void Upgrade(IComponentSettingsProvider legacySettingsProvider, IContextBoundSettingsStore boundSettingsStore, Lifetime upgradeLifetime);
}
public enum JetBrains.ReSharper.Psi.GeneratedCode.Settings.ExcludedFileState : Enum {
    public int value__;
    public static ExcludedFileState ExplicitlyExcluded;
    public static ExcludedFileState ForceIncluded;
}
[ObsoleteAttribute("Obsolete GeneratedCode APIs")]
public class JetBrains.ReSharper.Psi.GeneratedCode.Settings.FilesToSkipSettingsObsolete : object {
    private Lifetime myLifetime;
    private ISolution mySolution;
    private ProjectModelElementPointerManager myPointerManager;
    private ILogger myLogger;
    [CompilerGeneratedAttribute]
private ProjectModelElementPointersSet <FilesAndFoldersToSkip>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectModelElementPointersSet <GeneratedFilesAndFolders>k__BackingField;
    internal ProjectModelElementPointersSet FilesAndFoldersToSkip { get; private set; }
    internal ProjectModelElementPointersSet GeneratedFilesAndFolders { get; private set; }
    public FilesToSkipSettingsObsolete(Lifetime lifetime, ISolution solution, IComponentSettingsProvider settingsProvider, ProjectModelElementPointerManager pointerManager, ILogger logger);
    [CompilerGeneratedAttribute]
internal ProjectModelElementPointersSet get_FilesAndFoldersToSkip();
    [CompilerGeneratedAttribute]
private void set_FilesAndFoldersToSkip(ProjectModelElementPointersSet value);
    [CompilerGeneratedAttribute]
internal ProjectModelElementPointersSet get_GeneratedFilesAndFolders();
    [CompilerGeneratedAttribute]
private void set_GeneratedFilesAndFolders(ProjectModelElementPointersSet value);
    private sealed virtual override void JetBrains.Application.Configuration.IXmlReadable.ReadFromXml(XmlElement element);
}
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeInspectionSettings", "JetBrains.ReSharper.Psi.Resources.Strings", "GeneratedCodeDetectionSettingDescription")]
public class JetBrains.ReSharper.Psi.GeneratedCode.Settings.GeneratedCodeSettingsKey : object {
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "GeneratedCodeRegionsSettingDescription")]
public IIndexedEntry`2<string, string> GeneratedCodeRegions;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "GeneratedFilesMaskSettingDescription")]
public IIndexedEntry`2<string, string> GeneratedFileMasks;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "EditorconfigGeneratedCodeSettingDescription")]
public bool IsGeneratedCode;
}
[SolutionSettingsUpgraderAttribute("0")]
[GlobalSettingsUpgraderAttribute("0")]
public class JetBrains.ReSharper.Psi.GeneratedCode.Settings.GeneratedCodeSettingsUpgrade : CodeStyleSettingsUpgrade {
    public GeneratedCodeSettingsUpgrade(ShellPartCatalogSet partsSet, ISolution solution);
    protected virtual void DoUpgrade(CodeStyleSettingsObsolete codeStyleSettings, IContextBoundSettingsStore boundSettingsStore);
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.GeneratedCode.Settings.PredefinedExcludedFilesSettings : HaveDefaultSettings`1<ExcludedFilesSettingsKey> {
    public string Name { get; }
    public PredefinedExcludedFilesSettings(ILogger logger, ISettingsSchema settingsSchema);
    public virtual void InitDefaultSettings(ISettingsStorageMountPoint mountPoint);
    public virtual string get_Name();
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.GeneratedCode.Settings.PredefinedGeneratedCodeSettings : HaveDefaultSettings`1<GeneratedCodeSettingsKey> {
    public string Name { get; }
    public PredefinedGeneratedCodeSettings(ILogger logger, ISettingsSchema settingsSchema);
    public virtual void InitDefaultSettings(ISettingsStorageMountPoint mountPoint);
    private void SetIndexedIndexValue(ISettingsStorageMountPoint mount, Expression`1<Func`2<TKeyClass, IIndexedEntry`2<TEntryIndexValue, TEntryIndexValue>>> lambdaExpression, TEntryIndexValue indexValue, IDictionary`2<SettingsKey, object> keyIndices);
    public virtual string get_Name();
}
public class JetBrains.ReSharper.Psi.GeneratedCode.Settings.ProjectModelElementPointersSet : object {
    private ISolution mySolution;
    private ProjectModelElementPointerManager myPointerManager;
    private ILogger myLogger;
    private string myName;
    private HashSet`1<IProjectModelElementPointer> myItems;
    private object myCachedLockObject;
    private List`1<IProjectModelElement> myCachedAllProjectModelElements;
    private int myCachedTimestamp;
    [CompilerGeneratedAttribute]
private Action`1<IProjectFile> FileAdded;
    [CompilerGeneratedAttribute]
private Action`1<IProjectFolder> FolderAdded;
    [CompilerGeneratedAttribute]
private Action`1<IProjectFile> FileRemoved;
    [CompilerGeneratedAttribute]
private Action`1<IProjectFolder> FolderRemoved;
    [CompilerGeneratedAttribute]
private ISimpleSignal <SomethingChanged>k__BackingField;
    public ISimpleSignal SomethingChanged { get; }
    public bool IsEmpty { get; }
    public ProjectModelElementPointersSet(Lifetime lifetime, ISolution solution, ProjectModelElementPointerManager pointerManager, ILogger logger, string name);
    [CompilerGeneratedAttribute]
public void add_FileAdded(Action`1<IProjectFile> value);
    [CompilerGeneratedAttribute]
public void remove_FileAdded(Action`1<IProjectFile> value);
    [CompilerGeneratedAttribute]
public void add_FolderAdded(Action`1<IProjectFolder> value);
    [CompilerGeneratedAttribute]
public void remove_FolderAdded(Action`1<IProjectFolder> value);
    [CompilerGeneratedAttribute]
public void add_FileRemoved(Action`1<IProjectFile> value);
    [CompilerGeneratedAttribute]
public void remove_FileRemoved(Action`1<IProjectFile> value);
    [CompilerGeneratedAttribute]
public void add_FolderRemoved(Action`1<IProjectFolder> value);
    [CompilerGeneratedAttribute]
public void remove_FolderRemoved(Action`1<IProjectFolder> value);
    [CompilerGeneratedAttribute]
public ISimpleSignal get_SomethingChanged();
    private void TraceAndFire(Func`1<object> traceFunc);
    public bool Update(ProjectModelElementPointersSet otherSet);
    public void Update(IEnumerable`1<string> fileIds);
    private void RemoveFile(IProjectModelElementPointer pointer);
    internal void AddFile(string persistentId, bool raiseEvents);
    private void AddFile(IProjectModelElementPointer pointer, bool raiseEvents);
    public bool Contains(IProjectModelElement fileOrFolder);
    public IEnumerable`1<IProjectModelElement> GetAllValidProjectItems();
    private void ClearCachedAllProjectModelElements();
    private IEnumerable`1<IProjectModelElement> EnsureAllProjectModelElements();
    public bool get_IsEmpty();
    [CompilerGeneratedAttribute]
private void <.ctor>b__23_0(IProjectFile _);
    [CompilerGeneratedAttribute]
private void <.ctor>b__23_1(IProjectFolder _);
    [CompilerGeneratedAttribute]
private void <.ctor>b__23_2(IProjectFile _);
    [CompilerGeneratedAttribute]
private void <.ctor>b__23_3(IProjectFolder _);
    [CompilerGeneratedAttribute]
private void <.ctor>b__23_4(bool b);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.GeneratedDocumentsManagerExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IGeneratedDocumentService> GetServices(IGeneratedDocumentsManager generatedDocumentsManager, IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertThatGeneratedFilesAreValid(IGeneratedDocumentsManager generatedDocumentsManager, IPsiSourceFile psiSourceFile);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertThatGeneratedFilesAreValid(IPsiSourceFile psiSourceFile);
    public static DocumentRange TryFindNavigationRangeInPrimaryDocument(ITreeNode element);
}
public enum JetBrains.ReSharper.Psi.GenerateMemberBody.AccessorImplementationKind : Enum {
    public int value__;
    public static AccessorImplementationKind Default;
    public static AccessorImplementationKind BackingField;
    public static AccessorImplementationKind AutomaticProperty;
}
public enum JetBrains.ReSharper.Psi.GenerateMemberBody.DocumentationGenerationKind : Enum {
    public int value__;
    public static DocumentationGenerationKind None;
    public static DocumentationGenerationKind Inherit;
    public static DocumentationGenerationKind Copy;
}
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeEditingSettings", "JetBrains.ReSharper.Psi.Resources.Strings", "MemberGenerationSettingsSettingDescription")]
public class JetBrains.ReSharper.Psi.GenerateMemberBody.GenerateMemberBodySettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "AccessorImplementationKindSettingDescription")]
public AccessorImplementationKind AccessorImplementationKind;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "MethodImplementationKindSettingDescription")]
public MethodImplementationKind MethodImplementationKind;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "DocumentationGenerationKindSettingDescription")]
public DocumentationGenerationKind DocumentationGenerationKind;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "WrapGeneratedMembersInRegionSettingDescription")]
public bool WrapIntoRegions;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "DebuggerStepThroughAccessorsSettingDescription")]
public bool DebuggerStepThroughAccessors;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "PlaceBackingFieldAbovePropertySettingDescription")]
public bool PlaceBackingFieldAboveProperty;
}
public static class JetBrains.ReSharper.Psi.GenerateMemberBody.GenerateMemberBodySettingsAccessor : object {
    [NotNullAttribute]
public static Expression`1<Func`2<GenerateMemberBodySettings, AccessorImplementationKind>> AccessorImplementationKind;
    [NotNullAttribute]
public static Expression`1<Func`2<GenerateMemberBodySettings, MethodImplementationKind>> MethodImplementationKind;
    [NotNullAttribute]
public static Expression`1<Func`2<GenerateMemberBodySettings, DocumentationGenerationKind>> DocumentationGenerationKind;
    [NotNullAttribute]
public static Expression`1<Func`2<GenerateMemberBodySettings, bool>> WrapIntoRegions;
    [NotNullAttribute]
public static Expression`1<Func`2<GenerateMemberBodySettings, bool>> DebuggerStepThroughAccessors;
    [NotNullAttribute]
public static Expression`1<Func`2<GenerateMemberBodySettings, bool>> PlaceBackingFieldAboveProperty;
    private static GenerateMemberBodySettingsAccessor();
}
[GlobalSettingsUpgraderAttribute("0")]
public class JetBrains.ReSharper.Psi.GenerateMemberBody.GenerateMemberBodySettingsUpgrader : CodeStyleSettingsUpgrade {
    public GenerateMemberBodySettingsUpgrader(ShellPartCatalogSet partsSet, ISolution solution);
    protected virtual void DoUpgrade(CodeStyleSettingsObsolete codeStyleSettings, IContextBoundSettingsStore contextBoundSettingsStore);
}
public enum JetBrains.ReSharper.Psi.GenerateMemberBody.MethodImplementationKind : Enum {
    public int value__;
    public static MethodImplementationKind ThrowNotImplemented;
    public static MethodImplementationKind ReturnDefaultValue;
    public static MethodImplementationKind NotCompiledCode;
}
public interface JetBrains.ReSharper.Psi.IAbstractAsyncCommitService {
    public abstract virtual void RequestCommit(IAsyncCommitClient client, Nullable`1<int> delay);
}
public interface JetBrains.ReSharper.Psi.IAccessor {
    [CanBeNullAttribute]
public IOverridableMember OwnerMember { get; }
    public AccessorKind Kind { get; }
    public bool IsAuto { get; }
    public bool IsInitOnly { get; }
    [CanBeNullAttribute]
public IParameter ValueVariable { get; }
    public abstract virtual IOverridableMember get_OwnerMember();
    public abstract virtual AccessorKind get_Kind();
    public abstract virtual bool get_IsAuto();
    public abstract virtual bool get_IsInitOnly();
    public abstract virtual IParameter get_ValueVariable();
}
public interface JetBrains.ReSharper.Psi.IAccessRightsOwner {
    [PureAttribute]
public abstract virtual AccessRights GetAccessRights();
}
public interface JetBrains.ReSharper.Psi.IAliasProvider {
    public abstract virtual IEnumerable`1<string> GetAliases(string name);
}
public interface JetBrains.ReSharper.Psi.IAlternativeNameOwner {
    [CanBeNullAttribute]
public string AlternativeName { get; }
    public abstract virtual string get_AlternativeName();
}
public interface JetBrains.ReSharper.Psi.IAnonymousDelegate {
    [PureAttribute]
public abstract virtual bool Equals(IAnonymousDelegate other, IEqualityComparer`1<IType> typeEqualityComparer);
}
public interface JetBrains.ReSharper.Psi.IAnonymousType {
    [NotNullAttribute]
public IList`1<AnonymousTypeDescriptor> TypeDescriptor { get; }
    public bool CaseSensitive { get; }
    public abstract virtual IList`1<AnonymousTypeDescriptor> get_TypeDescriptor();
    public abstract virtual bool get_CaseSensitive();
}
public interface JetBrains.ReSharper.Psi.IAnonymousTypeProperty {
    [CanBeNullAttribute]
public IAnonymousType ContainingType { get; }
    public int Index { get; }
    [NotNullAttribute]
public IList`1<AnonymousTypePropertyDescriptor> AnonymousTypePropertyDescriptor { get; }
    public abstract virtual IAnonymousType get_ContainingType();
    public abstract virtual int get_Index();
    public abstract virtual IList`1<AnonymousTypePropertyDescriptor> get_AnonymousTypePropertyDescriptor();
    [NotNullAttribute]
public abstract virtual IAnonymousTypeProperty SetName(string name);
}
public interface JetBrains.ReSharper.Psi.IArgumentInfo {
    [CanBeNullAttribute]
public DeclaredElementInstance`1<IParameter> MatchingParameter { get; }
    public bool IsExtensionInvocationQualifier { get; }
    [CanBeNullAttribute]
public IInvocationInfo Invocation { get; }
    [NotNullAttribute]
public IPsiModule PsiModule { get; }
    public abstract virtual DeclaredElementInstance`1<IParameter> get_MatchingParameter();
    public abstract virtual bool get_IsExtensionInvocationQualifier();
    public abstract virtual IInvocationInfo get_Invocation();
    [NotNullAttribute]
public abstract virtual IExpressionType GetExpressionType();
    [NotNullAttribute]
public abstract virtual IPsiServices GetPsiServices();
    public abstract virtual IPsiModule get_PsiModule();
    public abstract virtual DocumentRange GetDocumentRange();
    public abstract virtual bool IsValid();
}
public interface JetBrains.ReSharper.Psi.IArrayType {
    [NotNullAttribute]
public IType ElementType { get; }
    public int Rank { get; }
    public abstract virtual IType get_ElementType();
    public abstract virtual int get_Rank();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IArrayType WithTypeDecorations(TypeDecorationSet typeDecorations);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IArrayType WithNullableAnnotation(NullableAnnotation nullableAnnotation);
}
public interface JetBrains.ReSharper.Psi.IAsyncCommitClient {
    public abstract virtual Action BeforeCommit();
    public abstract virtual void OnInterrupt();
}
public interface JetBrains.ReSharper.Psi.IAttributeInstance {
    [CanBeNullAttribute]
public IConstructor Constructor { get; }
    public int PositionParameterCount { get; }
    public int NamedParameterCount { get; }
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IClrTypeName GetClrName();
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual string GetAttributeShortName();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IDeclaredType GetAttributeType();
    public abstract virtual IConstructor get_Constructor();
    public abstract virtual int get_PositionParameterCount();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual AttributeValue PositionParameter(int paramIndex);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IEnumerable`1<AttributeValue> PositionParameters();
    public abstract virtual int get_NamedParameterCount();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual AttributeValue NamedParameter(string name);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IEnumerable`1<Pair`2<string, AttributeValue>> NamedParameters();
}
public interface JetBrains.ReSharper.Psi.IAttributesOwner {
}
public interface JetBrains.ReSharper.Psi.IAttributesSet {
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    [PureAttribute]
public abstract virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
}
public interface JetBrains.ReSharper.Psi.ICaseInsensitiveNamespace {
    [NotNullAttribute]
public IReadOnlyCollection`1<ICaseSensitiveNamespace> Constituents { get; }
    public abstract virtual IReadOnlyCollection`1<ICaseSensitiveNamespace> get_Constituents();
}
public interface JetBrains.ReSharper.Psi.ICaseSensitiveNamespace {
    public ICaseInsensitiveNamespace CaseInsensitiveNamespace { get; }
    public abstract virtual ICaseInsensitiveNamespace get_CaseInsensitiveNamespace();
}
public interface JetBrains.ReSharper.Psi.IClass {
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IDeclaredType GetBaseClassType();
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IClass GetSuperClass();
}
public interface JetBrains.ReSharper.Psi.IClientWebLanguage {
}
public interface JetBrains.ReSharper.Psi.ICloneableTypeElement {
    [PureAttribute]
public abstract virtual int TryGetCloneableMemberCount();
    [PureAttribute]
public abstract virtual bool HasExplicitConstructorsInSuperTypes();
}
public interface JetBrains.ReSharper.Psi.IClrDeclaredElement {
    [NotNullAttribute]
public IPsiModule Module { get; }
    [NotNullAttribute]
public ISubstitution IdSubstitution { get; }
    public abstract virtual IPsiModule get_Module();
    public abstract virtual ISubstitution get_IdSubstitution();
    [CodeTemplateAttribute("$typeMember{Expression,'JetBrains.ReSharper.Psi.ITypeMember'}$.GetContainingType()")]
[CanBeNullAttribute]
[PureAttribute]
public abstract virtual ITypeElement GetContainingType();
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual ITypeMember GetContainingTypeMember();
}
[ZoneDefinitionAttribute]
public interface JetBrains.ReSharper.Psi.IClrPsiLanguageZone {
}
public interface JetBrains.ReSharper.Psi.ICompiledElement {
}
public interface JetBrains.ReSharper.Psi.IConstantValueOwner {
    public ConstantValue ConstantValue { get; }
    public abstract virtual ConstantValue get_ConstantValue();
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.IConstantValuePresenter {
    [PureAttribute]
[ObsoleteAttribute("Please, use the overload with RichText instead")]
public abstract virtual string Present(ConstantValue constantValue);
    [PureAttribute]
public abstract virtual RichText Present(PsiLanguageType language, ConstantValue constantValue, TypePresentationStyle typePresentationStyle);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.IConstantValueService {
    public IConstantValuePresenter Presenter { get; }
    public abstract virtual IConstantValuePresenter get_Presenter();
    [PureAttribute]
public abstract virtual ConstantValue GetDefaultValue(IType type);
    [PureAttribute]
public abstract virtual bool IsLegalConstantType(IType type);
}
public interface JetBrains.ReSharper.Psi.IConstructor {
    public bool IsDefault { get; }
    public bool IsParameterless { get; }
    public bool IsImplicit { get; }
    public bool IsValueTypeZeroInit { get; }
    public abstract virtual bool get_IsDefault();
    public abstract virtual bool get_IsParameterless();
    public abstract virtual bool get_IsImplicit();
    public abstract virtual bool get_IsValueTypeZeroInit();
}
public interface JetBrains.ReSharper.Psi.IConversionOperator {
    public bool IsExplicitCast { get; }
    public bool IsImplicitCast { get; }
    public abstract virtual bool get_IsExplicitCast();
    public abstract virtual bool get_IsImplicitCast();
}
public interface JetBrains.ReSharper.Psi.ICustomPsiSourceFileProperties {
}
public interface JetBrains.ReSharper.Psi.IDeclarationsRange {
    public ITreeRange TreeRange { get; }
    public IDeclaration[] Declarations { get; }
    public abstract virtual ITreeRange get_TreeRange();
    public abstract virtual IDeclaration[] get_Declarations();
}
public interface JetBrains.ReSharper.Psi.IDeclarationsRangeContainer {
    [NotNullAttribute]
public abstract virtual IDeclarationsRange GetAllDeclarationsRange();
    [NotNullAttribute]
public abstract virtual IDeclarationsRange GetDeclarationsRange(IDeclaration first, IDeclaration last);
    [CanBeNullAttribute]
public abstract virtual IDeclarationsRange GetDeclarationsRange(TreeTextRange range);
    public abstract virtual void RemoveDeclarationsRange(IDeclarationsRange range);
    [NotNullAttribute]
public abstract virtual IDeclarationsRange AddDeclarationsRangeAfter(IDeclarationsRange range, ITreeNode anchor);
    [NotNullAttribute]
public abstract virtual IDeclarationsRange AddDeclarationsRangeBefore(IDeclarationsRange range, ITreeNode anchor);
}
[CannotApplyEqualityOperatorAttribute]
public interface JetBrains.ReSharper.Psi.IDeclaredElement {
    [NotNullAttribute]
public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    [NotNullAttribute]
public PsiLanguageType PresentationLanguage { get; }
    public abstract virtual string get_ShortName();
    public abstract virtual bool get_CaseSensitiveName();
    public abstract virtual PsiLanguageType get_PresentationLanguage();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual DeclaredElementType GetElementType();
    [PureAttribute]
public abstract virtual bool IsValid();
    [PureAttribute]
public abstract virtual bool IsSynthetic();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IList`1<IDeclaration> GetDeclarations();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    [PureAttribute]
public abstract virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    [PureAttribute]
public abstract virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IPsiServices GetPsiServices();
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual XmlNode GetXMLDoc(bool inherit);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual XmlNode GetXMLDescriptionSummary(bool inherit);
}
public interface JetBrains.ReSharper.Psi.IDeclaredElementEnvoy {
    [NotNullAttribute]
public string Text { get; }
    [CanBeNullAttribute]
public abstract virtual IDeclaredElement GetValidDeclaredElement();
    [CanBeNullAttribute]
public abstract virtual DeclaredElementInstance GetValidDeclaredElementInstance();
    public abstract virtual string get_Text();
    public abstract virtual void Present(StructuredPresenter`2<TStructureElement, IPresentableItem> presenter, TStructureElement structureElement, IPresentableItem item, PresentationState state);
    public abstract virtual void ResetCache();
}
public interface JetBrains.ReSharper.Psi.IDeclaredElementEnvoyComparable {
    [NotNullAttribute]
public string PresentableText { get; }
    public abstract virtual string get_PresentableText();
}
public interface JetBrains.ReSharper.Psi.IDeclaredElementIconExtensionProvider {
    public abstract virtual PsiIconExtension GetIconExtensions(IDeclaredElement declaredElement, PsiLanguageType languageType);
}
public interface JetBrains.ReSharper.Psi.IDeclaredElementIconProvider {
    [CanBeNullAttribute]
public abstract virtual IconId GetImageId(IDeclaredElement declaredElement, PsiLanguageType languageType, Boolean& canApplyExtensions);
}
public interface JetBrains.ReSharper.Psi.IDeclaredElementPresenter {
    [CanBeNullAttribute]
public abstract virtual RichText Format(DeclaredElementPresenterStyle style, IDeclaredElement element, ISubstitution substitution, DeclaredElementPresenterMarking& marking);
    [CanBeNullAttribute]
public abstract virtual string Format(ParameterKind parameterKind);
    [CanBeNullAttribute]
public abstract virtual string Format(AccessRights accessRights);
    [NotNullAttribute]
public abstract virtual string GetEntityKind(IDeclaredElement declaredElement);
}
public interface JetBrains.ReSharper.Psi.IDeclaredElementWithHugeNumberOfSourceFiles {
}
public interface JetBrains.ReSharper.Psi.IDeclaredType {
    [CanBeNullAttribute]
public AssemblyNameInfo Assembly { get; }
    [PureAttribute]
[CanBeNullAttribute]
public abstract virtual ITypeElement GetTypeElement();
    [PureAttribute]
[NotNullAttribute]
public abstract virtual IClrTypeName GetClrName();
    [PureAttribute]
[NotNullAttribute]
public abstract virtual IResolveResult Resolve();
    [PureAttribute]
public abstract virtual bool IsSubtypeOf(IDeclaredType to, ITypeConversionRule typeConversionRule);
    public abstract virtual AssemblyNameInfo get_Assembly();
    [PureAttribute]
[NotNullAttribute]
public abstract virtual IDeclaredType Retarget(IPsiModule psiModule);
    [PureAttribute]
[NotNullAttribute]
public abstract virtual IDeclaredType WithTypeDecorations(TypeDecorationSet typeDecorations);
    [PureAttribute]
[NotNullAttribute]
public abstract virtual IDeclaredType WithNullableAnnotation(NullableAnnotation nullableAnnotation);
}
public interface JetBrains.ReSharper.Psi.IDelegate {
    [NotNullAttribute]
public IAttributesSet ReturnTypeAttributes { get; }
    [NotNullAttribute]
public IMethod InvokeMethod { get; }
    public abstract virtual IAttributesSet get_ReturnTypeAttributes();
    public abstract virtual IMethod get_InvokeMethod();
}
public interface JetBrains.ReSharper.Psi.IEnum {
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IField> EnumMembers { get; }
    public abstract virtual IEnumerable`1<IField> get_EnumMembers();
    [NotNullAttribute]
public abstract virtual IType GetUnderlyingType();
}
public interface JetBrains.ReSharper.Psi.IEvent {
    [CanBeNullAttribute]
public IAccessor Adder { get; }
    [CanBeNullAttribute]
public IAccessor Remover { get; }
    [CanBeNullAttribute]
public IAccessor Raiser { get; }
    public bool IsFieldLikeEvent { get; }
    public abstract virtual IAccessor get_Adder();
    public abstract virtual IAccessor get_Remover();
    public abstract virtual IAccessor get_Raiser();
    public abstract virtual bool get_IsFieldLikeEvent();
}
public interface JetBrains.ReSharper.Psi.IExplicitImplementation {
    [NotNullAttribute]
public IDeclaredType DeclaringType { get; }
    [NotNullAttribute]
public string MemberName { get; }
    public abstract virtual IDeclaredType get_DeclaringType();
    public abstract virtual string get_MemberName();
    [CanBeNullAttribute]
[MustUseReturnValueAttribute]
public abstract virtual OverridableMemberInstance Resolve();
}
[CannotApplyEqualityOperatorAttribute]
public interface JetBrains.ReSharper.Psi.IExpressionType {
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    [NotNullAttribute]
public IPsiModule Module { get; }
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IType ToIType();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public abstract virtual bool get_IsResolved();
    public abstract virtual bool get_IsUnknown();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IPsiServices GetPsiServices();
    [PureAttribute]
public abstract virtual bool IsValid();
    public abstract virtual IPsiModule get_Module();
}
public interface JetBrains.ReSharper.Psi.IField {
    public bool IsField { get; }
    public bool IsConstant { get; }
    public bool IsEnumMember { get; }
    public ReferenceKind ReferenceKind { get; }
    public bool IsRequired { get; }
    public Nullable`1<int> FixedBufferSize { get; }
    public abstract virtual bool get_IsField();
    public abstract virtual bool get_IsConstant();
    public abstract virtual bool get_IsEnumMember();
    public abstract virtual ReferenceKind get_ReferenceKind();
    public abstract virtual bool get_IsRequired();
    public abstract virtual Nullable`1<int> get_FixedBufferSize();
}
public interface JetBrains.ReSharper.Psi.IFunction {
    public bool IsPredefined { get; }
    public bool IsIterator { get; }
    public abstract virtual bool get_IsPredefined();
    public abstract virtual bool get_IsIterator();
}
public interface JetBrains.ReSharper.Psi.IFunctionPointerType {
    [NotNullAttribute]
public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    [NotNullAttribute]
public IReadOnlyList`1<FunctionPointerParameter> Parameters { get; }
    public CallingConvention CallingConvention { get; }
    public abstract virtual IType get_ReturnType();
    public abstract virtual ReferenceKind get_ReturnKind();
    public abstract virtual IReadOnlyList`1<FunctionPointerParameter> get_Parameters();
    public abstract virtual CallingConvention get_CallingConvention();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IFunctionPointerType WithTypeDecorations(TypeDecorationSet typeDecorations);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IFunctionPointerType WithNullableAnnotation(NullableAnnotation nullableAnnotation);
}
public interface JetBrains.ReSharper.Psi.IGeneratedDocumentsManager {
    [NotNullAttribute]
public abstract virtual IDocument CreateGeneratedDocument(IPsiSourceFile sourceFile, string text, PsiLanguageType language);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<PsiLanguageType> GetPossibleLanguageTypes(IProject project, ProjectFileType projectFileType);
    public abstract virtual void ApplyTransactionDocumentChange(DocumentChange documentChange, string oldText, IPsiTransactionAction transactionAction);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IGeneratedDocumentService> GetServices(ProjectFileType projectFileType);
    public abstract virtual void AssertGeneratedFilesValid(IPsiSourceFile psiSourceFile);
}
public interface JetBrains.ReSharper.Psi.IIgnoredInSweaPsiSourceFile {
}
public interface JetBrains.ReSharper.Psi.IImplicitTypeMember {
    public bool CanBeDefinedExplicitly { get; }
    [CanBeNullAttribute]
public IDeclaredElement ElementThatDeclaresThisMember { get; }
    public abstract virtual bool get_CanBeDefinedExplicitly();
    public abstract virtual IDeclaredElement get_ElementThatDeclaresThisMember();
}
public interface JetBrains.ReSharper.Psi.IInMemoryNavigateablePsiSourceFile {
    public abstract virtual void BindToProjectFile(IProjectFile projectFile);
    public abstract virtual void UnbindFromProjectFile(IProjectFile projectFile);
}
public interface JetBrains.ReSharper.Psi.IInterface {
}
public interface JetBrains.ReSharper.Psi.IInterLineAdornmentIndentProvider {
    public abstract virtual bool TryGetIndentWidthInCharacters(ITreeNode node, bool isAboveLine, Int32& indentWidthInCharacters);
}
public interface JetBrains.ReSharper.Psi.IInvocationInfo {
    [NotNullAttribute]
public IList`1<IArgumentInfo> Arguments { get; }
    [CanBeNullAttribute]
public IArgumentInfo ExtensionQualifier { get; }
    [CanBeNullAttribute]
public IManagedReference Reference { get; }
    [NotNullAttribute]
public IPsiModule PsiModule { get; }
    public abstract virtual IList`1<IArgumentInfo> get_Arguments();
    public abstract virtual IArgumentInfo get_ExtensionQualifier();
    public abstract virtual IManagedReference get_Reference();
    [NotNullAttribute]
public abstract virtual IPsiServices GetPsiServices();
    public abstract virtual IPsiModule get_PsiModule();
    public abstract virtual bool IsValid();
}
public interface JetBrains.ReSharper.Psi.ILabel {
}
public interface JetBrains.ReSharper.Psi.ILanguageLevelChangeHandler`1 {
    [PureAttribute]
public abstract virtual bool IsLanguageLevelBoundCrossed(Nullable`1<TLanguageLevel> before, TLanguageLevel after);
    public abstract virtual void OnLanguageLevelChanged(IPsiModule psiModule, Nullable`1<TLanguageLevel> before, TLanguageLevel after);
}
public interface JetBrains.ReSharper.Psi.ILanguageLevelOverrider`1 {
    [PureAttribute]
public abstract virtual TLanguageLevel GetDefaultLanguageLevel(IProject project, TargetFrameworkId targetFrameworkId);
    public abstract virtual void OverrideLanguageLevel(TLanguageLevel languageLevel, IProject project);
    public abstract virtual void ResetOverriddenLanguageLevel(IProject project);
}
public interface JetBrains.ReSharper.Psi.ILanguageLevelProjectProperty`2 {
    [PureAttribute]
public abstract virtual TLanguageLevel GetLanguageLevel(IProject project, TargetFrameworkId targetFrameworkId);
    [PureAttribute]
public abstract virtual TLanguageLevel GetLatestAvailableLanguageLevel(IProject project, TargetFrameworkId targetFrameworkId);
    [PublicAPIAttribute]
[PureAttribute]
public abstract virtual TLanguageLevel GetLatestAvailableLanguageLevel(VirtualFileSystemPath compilerDirectoryPath);
    [PureAttribute]
public abstract virtual bool IsAvailable(TLanguageLevel languageLevel, IProject project, TargetFrameworkId targetFrameworkId);
    [PureAttribute]
public abstract virtual TLanguageLevel ConvertToLanguageLevel(TLanguageVersion languageVersion, IProject project, TargetFrameworkId targetFrameworkId);
    [PureAttribute]
public abstract virtual TLanguageVersion ConvertToLanguageVersion(TLanguageLevel languageLevel);
}
public interface JetBrains.ReSharper.Psi.ILanguageLevelProvider`2 {
    [CanBeNullAttribute]
public ILanguageVersionModifier`1<TLanguageVersion> LanguageVersionModifier { get; }
    [CanBeNullAttribute]
public ILanguageLevelOverrider`1<TLanguageLevel> LanguageLevelOverrider { get; }
    [PureAttribute]
public abstract virtual bool IsApplicable(IPsiModule psiModule);
    [PureAttribute]
public abstract virtual TLanguageLevel GetLanguageLevel(IPsiModule psiModule);
    [PureAttribute]
public abstract virtual Nullable`1<TLanguageVersion> TryGetLanguageVersion(IPsiModule psiModule);
    [PureAttribute]
public abstract virtual bool IsAvailable(TLanguageLevel languageLevel, IPsiModule psiModule);
    [PureAttribute]
public abstract virtual bool IsAvailable(TLanguageVersion languageVersion, IPsiModule psiModule);
    [PureAttribute]
public abstract virtual TLanguageLevel ConvertToLanguageLevel(TLanguageVersion languageVersion, IPsiModule psiModule);
    [PureAttribute]
public abstract virtual TLanguageVersion ConvertToLanguageVersion(TLanguageLevel languageLevel);
    [PureAttribute]
public abstract virtual TLanguageLevel GetLatestAvailableLanguageLevel(IPsiModule psiModule);
    public abstract virtual ILanguageVersionModifier`1<TLanguageVersion> get_LanguageVersionModifier();
    public abstract virtual ILanguageLevelOverrider`1<TLanguageLevel> get_LanguageLevelOverrider();
}
[NullableContextAttribute("1")]
[DerivedComponentsInstantiationRequirementAttribute("1")]
public interface JetBrains.ReSharper.Psi.ILanguageManager {
    public ILanguages Languages { get; }
    public abstract virtual ILanguages get_Languages();
    [PureAttribute]
public abstract virtual TLanguageService GetService();
    [PureAttribute]
public abstract virtual TLanguageService TryGetService();
    [PureAttribute]
public abstract virtual TLanguageService GetService(PsiLanguageType languageType);
    [PureAttribute]
public abstract virtual TLanguageService TryGetService(PsiLanguageType languageType);
    [PureAttribute]
public abstract virtual IEnumerable`1<TLanguageService> GetServicesFromAll();
    [PureAttribute]
public abstract virtual IEnumerable`1<TLanguageService> GetMultipleServicesFromAll();
    [PureAttribute]
public abstract virtual IReadyImmutableList`1<TLanguageService> GetServices(PsiLanguageType languageType);
    [PureAttribute]
public abstract virtual bool HasService(PsiLanguageType languageType);
    [PureAttribute]
public abstract virtual TLanguageService TryGetCachedService(PsiLanguageType languageType);
    [PureAttribute]
public abstract virtual IEnumerable`1<TLanguageService> TryGetCachedServices(PsiLanguageType languageType);
}
public interface JetBrains.ReSharper.Psi.ILanguageManagerServiceProvider`2 {
}
[NullableContextAttribute("1")]
[DerivedComponentsInstantiationRequirementAttribute("1")]
public interface JetBrains.ReSharper.Psi.ILanguages {
    public IEnumerable`1<PsiLanguageType> All { get; }
    public abstract virtual IEnumerable`1<PsiLanguageType> get_All();
    [PureAttribute]
public abstract virtual PsiLanguageType GetLanguageByName(string languageName);
    [PureAttribute]
public abstract virtual PsiLanguageType GetLanguageByNameOrSynonym(string languageName);
    [NullableContextAttribute("2")]
[PureAttribute]
public abstract virtual PsiLanguageType GetLanguageByName(StringSource languageName);
    [PureAttribute]
public abstract virtual PsiLanguageType GetLanguageByType(Type type);
}
public interface JetBrains.ReSharper.Psi.ILanguageWithThirdPartyFiles {
}
public interface JetBrains.ReSharper.Psi.ILocalVariable {
    public bool IsConstant { get; }
    public bool IsWritable { get; }
    public bool IsStatic { get; }
    public ScopedKind Scope { get; }
    public ReferenceKind ReferenceKind { get; }
    public abstract virtual bool get_IsConstant();
    public abstract virtual bool get_IsWritable();
    public abstract virtual bool get_IsStatic();
    public abstract virtual ScopedKind get_Scope();
    public abstract virtual ReferenceKind get_ReferenceKind();
}
public interface JetBrains.ReSharper.Psi.IMetadataErasedElement {
}
public interface JetBrains.ReSharper.Psi.IMethod {
    public bool IsExtensionMethod { get; }
    public bool IsAsync { get; }
    public bool IsVarArg { get; }
    public abstract virtual bool get_IsExtensionMethod();
    public abstract virtual bool get_IsAsync();
    public abstract virtual bool get_IsVarArg();
}
public interface JetBrains.ReSharper.Psi.IModifiersOwner {
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsSealed();
    public abstract virtual bool get_IsVirtual();
    public abstract virtual bool get_IsOverride();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsReadonly();
    public abstract virtual bool get_IsExtern();
    public abstract virtual bool get_IsUnsafe();
    public abstract virtual bool get_IsVolatile();
}
public interface JetBrains.ReSharper.Psi.IModuleDeclaredElement {
    [NotNullAttribute]
public IModule ProjectModule { get; }
    [NotNullAttribute]
public VirtualFileSystemPath Location { get; }
    [CanBeNullAttribute]
public AssemblyNameInfo AssemblyName { get; }
    [CanBeNullAttribute]
public IPsiModule Module { get; }
    [NotNullAttribute]
public TargetFrameworkId TargetFrameworkId { get; }
    public abstract virtual IModule get_ProjectModule();
    public abstract virtual VirtualFileSystemPath get_Location();
    public abstract virtual AssemblyNameInfo get_AssemblyName();
    public abstract virtual IPsiModule get_Module();
    public abstract virtual TargetFrameworkId get_TargetFrameworkId();
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Impl.AsyncCommitServiceImpl : AsyncCommitService {
    private static TimeSpan ourDelay;
    private static TimeSpan ourDelayBadtime;
    private int myBadTimeCounter;
    private static int MAX_BAD_TIME_COUNTER;
    private object myLock;
    private Lifetime myLifetime;
    private IShellLocks myLocks;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<IAsyncCommitClient, ValueTuple`2<LifetimeDefinition, ExecutionContext>> myClients;
    private IPsiFiles myPsiFiles;
    private IPsiTransactions myPsiTransactions;
    private ILogger myLogger;
    private SynchronizationPoint mySyncPoint;
    public AsyncCommitServiceImpl(ISolution solution, IPsiFiles psiFiles, IPsiTransactions psiTransactions, SynchronizationPoints syncPoints, ILogger logger);
    private static AsyncCommitServiceImpl();
    private void DropAllRequests(string reason);
    public virtual bool HasOtherRequestsInQueue(IAsyncCommitClient client);
    public virtual void RequestCommit(IAsyncCommitClient client, Nullable`1<int> delay);
    public virtual void DropRequest(IAsyncCommitClient client);
    private void OnAlarm();
    private void RescheduleOnAlarm(string reason);
    private void Commit(Dictionary`2<IAsyncCommitClient, ExecutionContext> clientsToContexts);
    private bool BadMomentToStartAsyncCommit();
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_1(Lifetime asyncBehaviorAllowedLifetime);
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_2();
    [CompilerGeneratedAttribute]
private void <OnAlarm>b__17_0();
}
internal class JetBrains.ReSharper.Psi.Impl.CachedModuleDependencies : object {
    private IShellLocks myLocks;
    private IPsiModules myPsiModules;
    private State modreq(System.Runtime.CompilerServices.IsVolatile) myState;
    private DataIntern`1<ReferencesSet> myRefsetsIntern;
    private ConcurrentDictionary`2<Pair, ReferencesSet> myCachedModuleDependencies;
    private ConcurrentDictionary`2<Pair, ReferencesSet> myCachedReverseModuleDependencies;
    private Func`2<Pair, ReferencesSet> myCalculateReferences;
    private Func`2<Pair, ReferencesSet> myCalculateReverseReferences;
    public CachedModuleDependencies(Lifetime lifetime, IShellLocks locks, IPsiModules psiModules);
    public void ProjectModelReady();
    public void Invalidate();
    public IReadOnlyList`1<IPsiModuleReference> GetModuleReferences(IPsiModule module, IModuleReferenceResolveContext moduleReferenceResolveContext);
    public IReadOnlyList`1<IPsiModuleReference> GetReverseModuleReferences(IPsiModule module, IModuleReferenceResolveContext moduleReferenceResolveContext);
    private IReadOnlyList`1<IPsiModuleReference> UpdateModuleDependenciesCache(IPsiModule psiModule, IModuleReferenceResolveContext moduleReferenceResolveContext);
    private IReadOnlyList`1<IPsiModuleReference> UpdateReverseModuleDependenciesCache(IPsiModule psiModule, IModuleReferenceResolveContext moduleReferenceResolveContext);
    private ReferencesSet CalculateReferences(Pair pair);
    private ReferencesSet CalculateReverseReferences(Pair pair);
    [CompilerGeneratedAttribute]
private void <.ctor>b__9_0();
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Impl.Caches2.ConditionalNamesCache : SimpleICache`1<ConditionalNameUsage> {
    [NotNullAttribute]
private ISolution mySolution;
    [NotNullAttribute]
private PsiModules myPsiModules;
    [NotNullAttribute]
private OptimizedPersistentSortedMap`2<IPsiModule, JetHashSet`1<PreProcessingDirective>> myModuleDefines;
    [CanBeNullAttribute]
private JetHashSet`1<IPsiModule> myModifiedModulesBeforeLoad;
    [NotNullAttribute]
private ILogger myLogger;
    [NotNullAttribute]
private ISet`1<IPsiSourceFile> myBuiltButNotMergedSourceFiles;
    public ConditionalNamesCache(Lifetime lifetime, ISolution solution, IPersistentIndexManager persistentIndexManager, ChangeManager changeManager, PsiModules psiModules, ILogger logger);
    public virtual object Load(IProgressIndicator progress, bool enablePersistence);
    public virtual object Build(IPsiSourceFile sourceFile, bool isStartup);
    public virtual void Merge(IPsiSourceFile sourceFile, object builtPart);
    public virtual void Drop(IPsiSourceFile sourceFile);
    public virtual void MergeLoaded(object data);
    [NotNullAttribute]
private IReadOnlyList`1<IPsiSourceFile> OnModuleModified(IPsiModule psiModule);
    private bool ShouldInvalidateFileOnModulePropertiesChange(IPsiSourceFile sourceFile, List`1<PreProcessingDirective> changedDefines);
    [NotNullAttribute]
public IEnumerable`1<string> GetConditionalNamesInModule(IPsiModule psiModule);
    public sealed virtual object Execute(IChangeMap changeMap);
    [CompilerGeneratedAttribute]
private bool <Load>b__7_0();
}
public class JetBrains.ReSharper.Psi.Impl.Caches2.ConditionalNameUsage : object {
    public HashSet`1<string> UsedNamesInFile;
    [NotNullAttribute]
public static IUnsafeMarshaller`1<ConditionalNameUsage> Marshaller;
    public ConditionalNameUsage(HashSet`1<string> usedNamesInFile);
    private static ConditionalNameUsage();
    private static void Write(UnsafeWriter writer, ConditionalNameUsage usage);
    [CanBeNullAttribute]
private static ConditionalNameUsage Read(UnsafeReader reader);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.Impl.Caches2.INamedArgumentLanguageService {
    public abstract virtual String[] GetPossibleNamedArguments(IPsiSourceFile sourceFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PsiComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Impl.Caches2.NamedArgumentCache : SimpleICache`1<Int32[]> {
    [CompilerGeneratedAttribute]
private IPsiFiles <psiFiles>P;
    [CompilerGeneratedAttribute]
private LanguageManager <languageManager>P;
    public SearchFilterKind Kind { get; }
    public NamedArgumentCache(Lifetime lifetime, IShellLocks locks, IPersistentIndexManager persistentIndexManager, IPsiFiles psiFiles, LanguageManager languageManager);
    public SearchFilterKind get_Kind();
    public virtual object Build(IPsiSourceFile sourceFile, bool isStartup);
    public bool CanContainArgumentName(IPsiSourceFile sourceFile, string name);
    public IReadOnlyList`1<IPsiSourceFile> GetFilesPossiblyContainingArgumentName(string name);
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Impl.Caches2.TopLevelCodeCache : SimpleICache`1<bool> {
    [NotNullAttribute]
private IPsiFiles myPsiFiles;
    [NotNullAttribute]
private ILanguageManager myLanguageManager;
    public TopLevelCodeCache(Lifetime lifetime, IPersistentIndexManager persistentIndexManager, IPsiFiles psiFiles, ILanguageManager languageManager, IShellLocks locks);
    public virtual object Build(IPsiSourceFile sourceFile, bool isStartup);
    [PureAttribute]
[NotNullAttribute]
public IReadOnlyList`1<IPsiSourceFile> GetFilesWithTopLevelCode(IPsiModule psiModule);
    [PureAttribute]
[NotNullAttribute]
public IReadOnlyList`1<IDeclaredElement> GetTopLevelEntryPoints(IPsiModule psiModule);
}
[DeclaredElementIconExtensionProviderAttribute("0", "16")]
internal class JetBrains.ReSharper.Psi.Impl.CLRDeclaredElementIconExtensionsProvider : object {
    public sealed virtual PsiIconExtension GetIconExtensions(IDeclaredElement declaredElement, PsiLanguageType languageType);
    [PureAttribute]
private static PsiIconExtension GetExtensions(IDeclaredElement element);
    [PureAttribute]
private static PsiIconExtension GetAccessExtensions(AccessRights access);
}
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.Impl.CLRDeclaredElementPresenter : object {
    public static CLRDeclaredElementPresenter Instance { get; }
    public static CLRDeclaredElementPresenter get_Instance();
    private static void TrimString(StringBuilder str);
    public virtual RichText Format(DeclaredElementPresenterStyle style, IDeclaredElement declaredElement, ISubstitution substitution, DeclaredElementPresenterMarking& marking);
    public virtual string Format(ParameterKind parameterKind);
    public virtual string Format(AccessRights accessRights);
    private static string GetQualifiedNameStr(DeclaredElementPresenterStyle presenter, ITypeElement typeElement, ISubstitution substitution, bool appendOwnTypeParameters);
    [NotNullAttribute]
public static RichText GetNestedTypeNameRichText(DeclaredElementPresenterStyle presenter, ITypeElement typeElement, ISubstitution substitution, bool appendOwnTypeParameters);
    private static string GetTypeParametersStr(DeclaredElementPresenterStyle presenter, IList`1<ITypeParameter> typeParameters, ISubstitution substitution, int currentLength, TextRange[]& typeParameterRanges);
    private static bool CheckIsMember(IDeclaredElement declaredElement);
    private static bool CheckIsType(IDeclaredElement declaredElement);
    private static bool CheckIsNamespace(IDeclaredElement element);
    private static TextRange AppendString(StringBuilder sb, string substr);
    public virtual string GetEntityKind(IDeclaredElement declaredElement);
    private static string GetConstantValueStr(IDeclaredElement element, ISubstitution substitution);
    private static IType GetElementType(IDeclaredElement declaredElement, ISubstitution substitution);
    private static string GetParameterKindStr(IParameter parameter);
    private static string GetElementTypeStr(IDeclaredElement declaredElement, ISubstitution substitution, TextRange& scalarRange);
    private static void FormatInvocableParameter(DeclaredElementPresenterStyle presenter, IParameter param, StringBuilder str, ISubstitution substitution, Parameter& range);
    private static string GetParameterDefaultValueStr(IParameter parameter, ISubstitution substitution);
    private static string GetParametersListStr(DeclaredElementPresenterStyle presenter, IDeclaredElement element, ISubstitution substitution, Parameter[]& ranges);
    private RichText GetContainerStr(DeclaredElementPresenterStyle presenter, IDeclaredElement declaredElement, ISubstitution substitution, TextRange& containerNameRange);
    private static IList`1<ITypeParameter> GetTypeParameters(IDeclaredElement declaredElement);
    private static bool HasTypeParameters(ITypeElement element);
    public static RichText GetContainerForType(TypeContainerStyle memberContainerStyle, TextRange& textRange, RichText containerName, IDeclaredElementPresenter presenter, IDeclaredElement containerElement);
    public static RichText GetContainerForMember(MemberContainerStyle memberContainerStyle, TextRange& textRange, RichText containerName, IDeclaredElementPresenter presenter, IDeclaredElement containerElement);
    public static RichText GetContainerRichTextForNamespace(DeclaredElementPresenterStyle style, TextRange& containerNameRange, string containerName);
    public static RichText GetContainerRichTextForParameter(DeclaredElementPresenterStyle style, TextRange& containerNameRange, RichText containerName);
}
public class JetBrains.ReSharper.Psi.Impl.CLRTypePresenter : object {
    [NotNullAttribute]
public static ITypePresenter Instance;
    private static CLRTypePresenter();
    public sealed virtual RichText GetPresentableName(IType type, TypePresentationStyle typePresentationStyle);
    private static void BuildPresentableName(IType type, RichText richText, TypePresentationStyle typePresentationStyle);
    private static void BuildArrayTypeString(IArrayType arrayType, RichText builder, TypePresenter presenter);
    public sealed virtual RichText GetUnresolvedScalarTypePresentation(string name, ICollection`1<IType> typeArguments, NullableAnnotation nullableAnnotation, TypePresentationStyle typePresentationStyle);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.AliasOptimizationPolicy : ValueType {
    private bool myRemoveUnusedOnly;
    private bool myKeepNonTrivial;
    public AliasOptimizationPolicy(bool removeUnusedOnly, bool keepNonTrivial);
    public bool ShouldRemoveAliasWhen(bool isUsed, bool isTrivial);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.AlignNestedElementsRule : RuleBlankBase {
    [CompilerGeneratedAttribute]
private IBuilderAction`1[] <IgnorablePattern>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuilderAction`1<IBlankWithSinglePattern> <OperandPattern>k__BackingField;
    public INodePattern IgnorablePatternBuilt;
    public INodePattern OperandPatternBuilt;
    public INodePattern OperatorPatternBuilt;
    public INodePattern ParentPatternBuilt;
    [CompilerGeneratedAttribute]
private bool <CompareSignType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreferRightAlign>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreferLeftAlign>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutodetectOnlyFromSecondStage>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<VirtNode, CodeFormattingContext, bool> <SuitableForLeftAlign>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <AlignSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <OutdentSetting>k__BackingField;
    public IBuilderAction`1[] IgnorablePattern { get; public set; }
    public IBuilderAction`1<IBlankWithSinglePattern> OperandPattern { get; public set; }
    public bool CompareSignType { get; public set; }
    public bool PreferRightAlign { get; public set; }
    public bool PreferLeftAlign { get; public set; }
    public bool AutodetectOnlyFromSecondStage { get; public set; }
    public Func`3<VirtNode, CodeFormattingContext, bool> SuitableForLeftAlign { get; public set; }
    public int Priority { get; public set; }
    public LambdaExpression AlignSetting { get; public set; }
    public LambdaExpression OutdentSetting { get; public set; }
    [CompilerGeneratedAttribute]
public IBuilderAction`1[] get_IgnorablePattern();
    [CompilerGeneratedAttribute]
public void set_IgnorablePattern(IBuilderAction`1[] value);
    [CompilerGeneratedAttribute]
public IBuilderAction`1<IBlankWithSinglePattern> get_OperandPattern();
    [CompilerGeneratedAttribute]
public void set_OperandPattern(IBuilderAction`1<IBlankWithSinglePattern> value);
    [CompilerGeneratedAttribute]
public bool get_CompareSignType();
    [CompilerGeneratedAttribute]
public void set_CompareSignType(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreferRightAlign();
    [CompilerGeneratedAttribute]
public void set_PreferRightAlign(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreferLeftAlign();
    [CompilerGeneratedAttribute]
public void set_PreferLeftAlign(bool value);
    [CompilerGeneratedAttribute]
public bool get_AutodetectOnlyFromSecondStage();
    [CompilerGeneratedAttribute]
public void set_AutodetectOnlyFromSecondStage(bool value);
    [CompilerGeneratedAttribute]
public Func`3<VirtNode, CodeFormattingContext, bool> get_SuitableForLeftAlign();
    [CompilerGeneratedAttribute]
public void set_SuitableForLeftAlign(Func`3<VirtNode, CodeFormattingContext, bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Priority(int value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_AlignSetting();
    [CompilerGeneratedAttribute]
public void set_AlignSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_OutdentSetting();
    [CompilerGeneratedAttribute]
public void set_OutdentSetting(LambdaExpression value);
    public sealed virtual void Build(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
    private void DoBuild(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
    protected bool IsOperator(VirtNode parent, VirtNode node, CodeFormattingContext checker);
    protected bool IsLeftOperand(VirtNode parent, VirtNode node, CodeFormattingContext checker);
    protected bool IsRightOperand(VirtNode parent, VirtNode node, CodeFormattingContext checker);
    protected bool CanSkipExpression(VirtNode node, CodeFormattingContext context);
    protected VirtNode GetOperator(VirtNode node, CodeFormattingContext checker);
    protected VirtNode GetLeftOperand(VirtNode node);
    protected VirtNode GetRightOperand(VirtNode node, CodeFormattingContext checker);
    private bool IsInnermostExpression(CodeFormattingContext context, VirtNode parent, VirtNode op);
    private bool GetUpperParent(VirtNode op, CodeFormattingContext context, VirtNode& parent);
    private bool SuitableParent(VirtNode parent, CodeFormattingContext context, VirtNode& op, bool checkNested);
    private bool HasMeaningfulLeftSibOnTheSameLine(VirtNode node, CodeFormattingContext context);
    private bool HasMeaningfulRightSibOnTheSameLine(VirtNode node, CodeFormattingContext context);
    private bool IsAnyParentOnNewLine(CodeFormattingContext context, VirtNode parent, VirtNode op);
    private bool IsAnyOpOrOperandAlignable(CodeFormattingContext context, VirtNode parent, VirtNode op, bool isOperator);
    public bool AlignOperator(VirtNode node, CodeFormattingContext context);
    public bool AlignOperand(VirtNode node, CodeFormattingContext context);
    public bool AlignOperandOutdenting(VirtNode node, CodeFormattingContext context);
    public VirtNode GetCloseNodeForChild(VirtNode node, CodeFormattingContext context);
    private VirtNode GetCloseNode(CodeFormattingContext context, VirtNode parent);
    private VirtNode GetMostParent(CodeFormattingContext context, VirtNode parent, VirtNode op);
    private bool ShouldAlignChild(VirtNode node, CodeFormattingContext context, bool isOperator, Nullable`1<VirtNode> parentParam);
    private bool CheckLinebreaksForRightAlign(CodeFormattingContext context, VirtNode parent, VirtNode op, Nullable`1<bool> isOperator);
    public bool AlignParent(VirtNode parent, CodeFormattingContext context);
    public VirtNode GetCloseNodeForParent(VirtNode node, CodeFormattingContext context);
    public VirtNode GetCloseNodeForOutdent(VirtNode node, CodeFormattingContext context);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.AlignNestedElementsRuleEx : object {
    [ExtensionAttribute]
public static TEnvelope IgnorablePattern(TEnvelope builder, IBuilderAction`1[] builders);
    [ExtensionAttribute]
public static TEnvelope OperandPattern(TEnvelope builder, IBuilderAction`1<IBlankWithSinglePattern> buiders);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> AlignNestedElementsSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> OutdentSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static T CompareSignType(T builder, bool value);
    [ExtensionAttribute]
public static T PreferLeftAlign(T builder, bool value);
    [ExtensionAttribute]
public static T PreferRightAlign(T builder, bool value);
    [ExtensionAttribute]
public static T AutodetectOnlyFromSecondStage(T builder, bool value);
    [ExtensionAttribute]
public static T SuitableForLeftAlign(T builder, Func`3<VirtNode, CodeFormattingContext, bool> value);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.AndNodePattern : object {
    private INodePattern[] myChildPatterns;
    public int PerformanceRating { get; }
    private AndNodePattern(INodePattern[] childPatterns);
    public static INodePattern Create(INodePattern[] childPatterns);
    public sealed virtual IEnumerable`1<NodeType> GetNodeTypes();
    public sealed virtual bool Matches(ITreeNode node, CodeFormattingContext context);
    public sealed virtual int get_PerformanceRating();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.impl.CodeStyle.AutoDetect.AutoDetectBlankLineStage`2 : BlankLineStage`2<TContext, TSettingsKey> {
    private AutodetectSession myAutodetectSession;
    private AutoDetectSettingValueReader`1<TSettingsKey> myReader;
    public AutoDetectBlankLineStage`2(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IFormatterInfoProvider`2<TContext, TSettingsKey> provider, IProgressIndicator progress, CodeFormatProfile profile);
    public virtual void FormatRange(FormattingRangeContext formattingStageContext);
}
public class JetBrains.ReSharper.Psi.impl.CodeStyle.AutoDetect.AutoDetectFormattingStage`2 : FormattingStage`2<TContext, TSettingsKey> {
    private AutoDetectWrappingStage`2<TContext, TSettingsKey> myWrappingStage;
    private AutodetectSession myAutodetectSession;
    private AutoDetectSettingValueReader`1<TSettingsKey> myReader;
    [CompilerGeneratedAttribute]
private JetHashSet`1<VirtNode> <AlignedOneSpaceNodes>k__BackingField;
    private JetHashSet`1<VirtNode> AlignedOneSpaceNodes { get; }
    public AutoDetectFormattingStage`2(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IFormatterInfoProvider`2<TContext, TSettingsKey> provider, IProgressIndicator progress, AutoDetectWrappingStage`2<TContext, TSettingsKey> wrappingStage, JetHashSet`1<VirtNode> alignedOneSpaceNodes);
    [CompilerGeneratedAttribute]
private JetHashSet`1<VirtNode> get_AlignedOneSpaceNodes();
    public virtual void FormatRange(FormattingRangeContext formattingStageContext);
    private static void AddLineBreaks(IOptionValueQueryResult`1& optionValueQueryResults);
}
public class JetBrains.ReSharper.Psi.impl.CodeStyle.AutoDetect.AutoDetectIntAlignStage`2 : IntAlignStage`2<TContext, TSettingsKey> {
    private AutoDetectSettingValueReader`1<TSettingsKey> myReader;
    [CompilerGeneratedAttribute]
private JetHashSet`1<VirtNode> <AlignedOneSpaceNodes>k__BackingField;
    public JetHashSet`1<VirtNode> AlignedOneSpaceNodes { get; }
    public AutoDetectIntAlignStage`2(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IFormatterInfoProvider`2<TContext, TSettingsKey> provider, IProgressIndicator progress, HashSet`1<IScalarSetting`1<bool>> pureIntAlignSettings);
    [CompilerGeneratedAttribute]
public JetHashSet`1<VirtNode> get_AlignedOneSpaceNodes();
    protected virtual bool CalcIntAlignEnabled();
    protected virtual void ProcessBlockWithIntAlign(int startInclusive, int endExclusive);
    protected virtual void DoIntAlign();
    protected virtual void FindAndProcessOption(FormattingRangeContext formattingStageContext);
    public virtual void TaskFinished(VirtNode& dontReallyFinishUntilThisNode);
    public virtual void Initialize(Boolean& currentNodeInitialized);
}
public class JetBrains.ReSharper.Psi.impl.CodeStyle.AutoDetect.AutoDetectWrapLimitStage`2 : object {
    private IFormatterInfoProvider`2<TContext, TSettingsKey> myFormattingInfoProvider;
    private int myTabWidth;
    private bool myFirst;
    [CompilerGeneratedAttribute]
private TContext <Context>k__BackingField;
    public TContext Context { get; }
    public AutoDetectWrapLimitStage`2(TContext context, IFormatterInfoProvider`2<TContext, TSettingsKey> formattingInfoProvider, int tabWidth);
    [CompilerGeneratedAttribute]
public TContext get_Context();
    public sealed virtual void FormatRange(FormattingRangeContext context);
    public sealed virtual void SettingsChanged(FmtSettingsHolder`1<TSettingsKey> newSettings);
}
public class JetBrains.ReSharper.Psi.impl.CodeStyle.AutoDetect.AutoDetectWrappingStage`2 : WrappingStage`2<TContext, TSettingsKey> {
    private AutodetectSession myAutodetectSession;
    private AutoDetectSettingValueReader`1<TSettingsKey> myReader;
    private JetHashSet`1<FormatterSettingValues> myAfterMultilineKeepTogetherBlockHolder;
    private JetHashSet`1<FormatterSettingValues> myBreakLineBeforeKeepTogetherBlockHolder;
    [CompilerGeneratedAttribute]
private JetHashSet`1<FormatterSettingValues> <WasLinebreakAfterKeepTogetherBlockHolder>k__BackingField;
    public JetHashSet`1<FormatterSettingValues> WasLinebreakAfterKeepTogetherBlockHolder { get; private set; }
    public AutoDetectWrappingStage`2(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IProgressIndicator progress, IFormatterInfoProvider`2<TContext, TSettingsKey> formattingInfoProvider, SequentialNodeIterator`2<TContext, TSettingsKey> iterator);
    [CompilerGeneratedAttribute]
public JetHashSet`1<FormatterSettingValues> get_WasLinebreakAfterKeepTogetherBlockHolder();
    [CompilerGeneratedAttribute]
private void set_WasLinebreakAfterKeepTogetherBlockHolder(JetHashSet`1<FormatterSettingValues> value);
    private protected virtual void ProcessRegionClose(WrapRegionInfo regionInfo);
    public virtual void ProcessLineBreak(VirtNode& lineBreak);
    protected virtual bool TryWrap(bool allowLineThatAreTooLong);
    private protected virtual void BreakLines(PlaceToWrap ctx);
    private protected virtual PlaceToWrap GetFirstMandatoryWrap();
    private protected virtual WrapRegionInfo GetCurrentWrapRegion();
    protected virtual void FindAndProcessWrappingRegions(VirtNode node, WrapType typeMask, int position);
    private protected virtual void ProcessInterval(FormattingRangeContext ctx);
    private protected virtual void ProcessLineBreaksBeforeAndAfterRegion(WrapRegionInfo wrapRegionInfo);
    internal WrapRegionInfo GetChopWrapRegion(FormatterSettingValues valueSet);
    internal void MarkRegionsAsNotSuitableForSingleLine(FormattingRangeContext range);
    internal void AddSingleLineSettings(FormatterSettingValues[] valueSets, WrapRegionInfo[] regions);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.AutoDetectIndentingStage`2 : IndentingStage`2<TContext, TSettingsKey> {
    private Stack`1<IndentRegionsHolder<TContext, TSettingsKey>> myIndentStackHolders;
    private bool myIndentChecked;
    private bool myInitialize;
    private bool myNeedToGoToParent;
    private AutodetectSession myAutoDetectSession;
    private AutoDetectSettingValueReader`1<TSettingsKey> myReader;
    private static ValueTuple`3[] ourIndentStyles;
    public AutoDetectIndentingStage`2(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IFormatterInfoProvider`2<TContext, TSettingsKey> provider, IProgressIndicator progress, SequentialNodeIterator`2<TContext, TSettingsKey> iterator);
    private static AutoDetectIndentingStage`2();
    private void DoForRelevantStacks(Action action);
    public virtual object SaveState();
    public virtual void RestoreState(object state);
    protected virtual void StopDelayingIndents();
    public virtual void TaskFinished(VirtNode& dontReallyFinishUntilThisNode);
    private sealed virtual override void JetBrains.ReSharper.Psi.Impl.CodeStyle.ISequentialNodeProcessor<TSettingsKey>.ProcessLineBreak(VirtNode& lineBreak);
    protected virtual void PushIndent(IndentRegionInfo a);
    private void CloseIndents(Action`2<IndentRegionsHolder<TContext, TSettingsKey>, IndentRegionStackWithSettings<TContext, TSettingsKey>> action);
    protected virtual bool CloseIndents(IndentType endType);
    protected virtual void FindAndProcessIndentingRegions(IndentType startTypes);
    private void DoProcessRules(IndentType startTypes, List`1<Pair`2<IIndentingRule, VirtNode>> list);
    protected virtual void CloseExpiredIndentsAfterSkipping(VirtNode curParent);
    protected virtual void SplitInitialIndentToRegions(bool updateDelayed, bool checkAbsoluteIndent);
    protected virtual void MarkRegionAsAdjusted();
    protected virtual void BeforeDescendForInitialize();
    protected virtual void ClearIndents();
    protected virtual void MarkUsedRegions();
    protected virtual bool CalcNeedToGoToParent();
    protected virtual bool ProcessIndent(VirtNode prevNode, VirtNode current, Nullable`1<Whitespace> defaultIndent, VirtNode nodeToIndent);
    private bool CompareIndents(IndentDelta expected, IndentDelta real, Int32& indentSize, IndentStyleDetection& style);
    private void InitializeAndCreateNewHolder(bool checkAbsoluteIndent);
    private void CheckIndentAndCreateNewHolder(ITreeNode current);
    private void AddCaseWithIndents(FormatterSettingValues valueSet1, int indentSize, Nullable`1<IndentStyle> indentStyle, Nullable`1<AlignmentTabFillStyle> tabFillStyle);
    protected virtual void IndentNode(VirtNode prevNode, VirtNode current, bool reallyIndent, VirtNode nodeToIndent, bool fromFirstMacroOnLine);
    [CompilerGeneratedAttribute]
private void <StopDelayingIndents>b__12_0();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private bool <>n__0(IndentType endType);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__1(VirtNode curParent);
    [CompilerGeneratedAttribute]
private void <MarkRegionAsAdjusted>b__22_0();
    [CompilerGeneratedAttribute]
private void <MarkUsedRegions>b__25_0();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private bool <>n__2();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__3(bool updateDelayed, bool checkAbsoluteIndent);
    [CompilerGeneratedAttribute]
private void <CheckIndentAndCreateNewHolder>b__32_0();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.AutoDetectSettingValueReader`1 : object {
    private FmtSettingsHolder`1<TSettingsKey> mySettings;
    private FormatterSettingValues myDefaultFormatterSettingValues;
    [CompilerGeneratedAttribute]
private FormatterSettingValues <RelevantSettings>k__BackingField;
    public FormatterSettingValues RelevantSettings { get; public set; }
    public IReadOnlyCollection`1<IScalarSetting> PotentSettingsEntries { get; }
    public AutoDetectSettingValueReader`1(FmtSettingsHolder`1<TSettingsKey> settings);
    [CompilerGeneratedAttribute]
public FormatterSettingValues get_RelevantSettings();
    [CompilerGeneratedAttribute]
public void set_RelevantSettings(FormatterSettingValues value);
    public sealed virtual void ClearTrackedEntries();
    public sealed virtual void SettingsChanged(FmtSettingsHolder`1<TSettingsKey> settings);
    public sealed virtual object GetOptionValue(IScalarSetting setting);
    public sealed virtual T GetOrCreateCachedValue(Key`1<T> key, Func`2<ISettingValueReader, T> creator);
    public sealed virtual IReadOnlyCollection`1<IScalarSetting> get_PotentSettingsEntries();
}
public abstract class JetBrains.ReSharper.Psi.Impl.CodeStyle.BlankBase : object {
    public sealed virtual object DoDeepClone();
    protected virtual void ShallowToDeepCopy();
}
public enum JetBrains.ReSharper.Psi.Impl.CodeStyle.BlankLineLimitKind : Enum {
    public int value__;
    public static BlankLineLimitKind LimitMinimum;
    public static BlankLineLimitKind LimitMaximumMild;
    public static BlankLineLimitKind LimitMaximumStrict;
    public static BlankLineLimitKind LimitBothStrict;
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.BlankLinesAroundNodeRule : RuleBlankBase {
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IBuilder`1<NodePatternBlank>> <NodesToGroupBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IBuilder`1<NodePatternBlank>> <NodesToGroupAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IBuilder`1<NodePatternBlank>> <NodesToGroupConditionally>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuilder`1<NodePatternBlank> <AllowedNodesBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuilder`1<NodePatternBlank> <AllowedNodesAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <AllowRuleSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <MinBlankLinesBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <MinBlankLinesAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <MinBlankLines>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <MinBlankLinesForSingleLine>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<VirtNode, CodeFormattingContext, bool> <AdditionalCheckForBlankLineBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<VirtNode, CodeFormattingContext, bool> <AdditionalCheckForBlankLineAfter>k__BackingField;
    public int Priority { get; public set; }
    public List`1<IBuilder`1<NodePatternBlank>> NodesToGroupBefore { get; private set; }
    public List`1<IBuilder`1<NodePatternBlank>> NodesToGroupAfter { get; private set; }
    public List`1<IBuilder`1<NodePatternBlank>> NodesToGroupConditionally { get; private set; }
    public IBuilder`1<NodePatternBlank> AllowedNodesBefore { get; public set; }
    public IBuilder`1<NodePatternBlank> AllowedNodesAfter { get; public set; }
    public LambdaExpression AllowRuleSetting { get; public set; }
    public LambdaExpression MinBlankLinesBefore { get; public set; }
    public LambdaExpression MinBlankLinesAfter { get; public set; }
    public LambdaExpression MinBlankLines { get; public set; }
    public LambdaExpression MinBlankLinesForSingleLine { get; public set; }
    public Func`3<VirtNode, CodeFormattingContext, bool> AdditionalCheckForBlankLineBefore { get; public set; }
    public Func`3<VirtNode, CodeFormattingContext, bool> AdditionalCheckForBlankLineAfter { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Priority(int value);
    [CompilerGeneratedAttribute]
public List`1<IBuilder`1<NodePatternBlank>> get_NodesToGroupBefore();
    [CompilerGeneratedAttribute]
private void set_NodesToGroupBefore(List`1<IBuilder`1<NodePatternBlank>> value);
    [CompilerGeneratedAttribute]
public List`1<IBuilder`1<NodePatternBlank>> get_NodesToGroupAfter();
    [CompilerGeneratedAttribute]
private void set_NodesToGroupAfter(List`1<IBuilder`1<NodePatternBlank>> value);
    [CompilerGeneratedAttribute]
public List`1<IBuilder`1<NodePatternBlank>> get_NodesToGroupConditionally();
    [CompilerGeneratedAttribute]
private void set_NodesToGroupConditionally(List`1<IBuilder`1<NodePatternBlank>> value);
    [CompilerGeneratedAttribute]
public IBuilder`1<NodePatternBlank> get_AllowedNodesBefore();
    [CompilerGeneratedAttribute]
public void set_AllowedNodesBefore(IBuilder`1<NodePatternBlank> value);
    [CompilerGeneratedAttribute]
public IBuilder`1<NodePatternBlank> get_AllowedNodesAfter();
    [CompilerGeneratedAttribute]
public void set_AllowedNodesAfter(IBuilder`1<NodePatternBlank> value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_AllowRuleSetting();
    [CompilerGeneratedAttribute]
public void set_AllowRuleSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_MinBlankLinesBefore();
    [CompilerGeneratedAttribute]
public void set_MinBlankLinesBefore(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_MinBlankLinesAfter();
    [CompilerGeneratedAttribute]
public void set_MinBlankLinesAfter(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_MinBlankLines();
    [CompilerGeneratedAttribute]
public void set_MinBlankLines(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_MinBlankLinesForSingleLine();
    [CompilerGeneratedAttribute]
public void set_MinBlankLinesForSingleLine(LambdaExpression value);
    [CompilerGeneratedAttribute]
public Func`3<VirtNode, CodeFormattingContext, bool> get_AdditionalCheckForBlankLineBefore();
    [CompilerGeneratedAttribute]
public void set_AdditionalCheckForBlankLineBefore(Func`3<VirtNode, CodeFormattingContext, bool> value);
    [CompilerGeneratedAttribute]
public Func`3<VirtNode, CodeFormattingContext, bool> get_AdditionalCheckForBlankLineAfter();
    [CompilerGeneratedAttribute]
public void set_AdditionalCheckForBlankLineAfter(Func`3<VirtNode, CodeFormattingContext, bool> value);
    public virtual void Build(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
    private void DoBuild(string nameSuffix, FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider, NodePatternBlank patternBefore, NodePatternBlank patternAfter, NodePatternBlank startPattern, NodePatternBlank endPattern, MultilinePermissibility multilinePermissibility, LambdaExpression minBlankLines, LambdaExpression minBlankLinesBefore, LambdaExpression minBlankLinesAfter, LambdaExpression allowRuleSetting);
    private NodePatternBlank BuildPatternFromList(List`1<IBuilder`1<NodePatternBlank>> list, bool includeMainPattern);
    protected virtual void ShallowToDeepCopy();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.BlankLinesAroundNodeRuleEx : object {
    [ExtensionAttribute]
public static TEnvelope AddNodesToGroupBefore(TEnvelope builder, IBuilder`1<NodePatternBlank> buider);
    [ExtensionAttribute]
public static TEnvelope AddNodesToGroupAfter(TEnvelope builder, IBuilder`1<NodePatternBlank> buider);
    [ExtensionAttribute]
public static TEnvelope AddNodesToGroupConditionally(TEnvelope builder, IBuilder`1<NodePatternBlank> buider);
    [ExtensionAttribute]
public static TEnvelope AllowedNodesBefore(TEnvelope builder, IBuilder`1<NodePatternBlank> buider);
    [ExtensionAttribute]
public static TEnvelope AllowedNodesAfter(TEnvelope builder, IBuilder`1<NodePatternBlank> buider);
    [ExtensionAttribute]
public static TEnvelope AdditionalCheckForBlankLineBefore(TEnvelope builder, Func`3<VirtNode, CodeFormattingContext, bool> value);
    [ExtensionAttribute]
public static TEnvelope AdditionalCheckForBlankLineAfter(TEnvelope builder, Func`3<VirtNode, CodeFormattingContext, bool> value);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> MinBlankLines(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> MinBlankLinesAfter(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> MinBlankLinesBefore(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> AllowRuleSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> MinBlankLinesForSingleLine(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
}
public enum JetBrains.ReSharper.Psi.Impl.CodeStyle.BlankLinesMismatchType : Enum {
    public int value__;
    public static BlankLinesMismatchType MissingBlankLines;
    public static BlankLinesMismatchType RedundantBlankLines;
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.BlankLinesOptionNode : object {
    [CompilerGeneratedAttribute]
private Func`2<object, object> <KeyGetter>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting <Setting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Inherit>k__BackingField;
    [CompilerGeneratedAttribute]
private BlankLineLimitKind <LimitKind>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IOptionValue> <Values>k__BackingField;
    public Func`2<object, object> KeyGetter { get; }
    public IScalarSetting Setting { get; }
    public bool Inherit { get; }
    public BlankLineLimitKind LimitKind { get; }
    public IEnumerable`1<IOptionValue> Values { get; }
    public BlankLinesOptionNode(Func`2<object, object> keyGetter, IScalarSetting setting, bool inherit, BlankLineLimitKind limitKind);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_KeyGetter();
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting get_Setting();
    [CompilerGeneratedAttribute]
public bool get_Inherit();
    [CompilerGeneratedAttribute]
public BlankLineLimitKind get_LimitKind();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<IOptionValue> get_Values();
    public sealed virtual IOptionValue GetOptionValue(ISettingValueReader reader, object data, CodeFormattingContext context);
    private IOptionValue GetOptionValueFor(int value);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.BlankLinesOptionValue : object {
    [CompilerGeneratedAttribute]
private bool <Inherit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinBlankLines>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxBlankLinesMild>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxBlankLinesStrict>k__BackingField;
    public bool Inherit { get; }
    public int MinBlankLines { get; }
    public int MaxBlankLinesMild { get; }
    public int MaxBlankLinesStrict { get; }
    public BlankLinesOptionValue(bool inherit, int minBlankLines, int maxBlankLinesMild, int maxBlankLinesStrict);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Inherit();
    [CompilerGeneratedAttribute]
public sealed virtual int get_MinBlankLines();
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxBlankLinesMild();
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxBlankLinesStrict();
    public sealed virtual IBlankLinesOptionValue Merge(IBlankLinesOptionValue lowPriority, bool alwaysMerge, MergeKind& mergeKind);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.BlankLinesRule : FormattingRuleBase`1<IBlankLinesOptionValue> {
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.BlankLineStage`2 : FormatterStageBase`2<TContext, TSettingsKey> {
    protected IFormatterInfoProvider`2<TContext, TSettingsKey> myProvider;
    protected IProgressIndicator myProgress;
    public BlankLineStage`2(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IFormatterInfoProvider`2<TContext, TSettingsKey> provider, IProgressIndicator progress);
    public virtual void DoFormat();
    public virtual void FormatRange(FormattingRangeContext formattingStageContext);
    public static bool CheckBlankLines(IFormatterStageBase`1<TSettingsKey> formattingStage, FormattingRangeContext range, TContext context, IOptionValueQueryResult`1<IBlankLinesOptionValue> blankLinesOption, int nLineFeeds, bool returnOnViolation);
    private static void HighlightBlankLineProblem(FormattingRangeContext range, TContext context, IOptionValueQueryResult`1<IBlankLinesOptionValue> currentOption, int actualBlankLines, int expectedBlankLines, BlankLineLimitKind limitKind, int limitFromOptions);
    private static FrugalLocalList`1<RuleResultInfo`1<IBlankLinesOptionValue>> GetBlankLineRule(int value, BlankLineLimitKind limitKind, RuleResultInfo`1[] breakdown);
    public static void ChangeBlankLines(IFormatterStageBase`1<TSettingsKey> formattingStage, FormattingRangeContext range, TContext context, IFormatterInfoProvider`2<TContext, TSettingsKey> provider, IBlankLinesOptionValue blankLinesOption, IFormatOptionValue formattingOption);
    private static bool PrepareBlankLineData(FormattingRangeContext range, TContext context, IFormatterInfoProvider`2<TContext, TSettingsKey> provider, IFormatOptionValue formattingOption, Int32& nLineFeeds, Boolean& removeUserBlankLines);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.BlankWithPattern : BlankBase {
    [CompilerGeneratedAttribute]
private NodePatternBlank <GrandParentPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private NodePatternBlank <ParentPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private NodePatternBlank <Pattern>k__BackingField;
    public NodePatternBlank GrandParentPattern { get; public set; }
    public NodePatternBlank ParentPattern { get; public set; }
    public NodePatternBlank Pattern { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual NodePatternBlank get_GrandParentPattern();
    [CompilerGeneratedAttribute]
public sealed virtual void set_GrandParentPattern(NodePatternBlank value);
    [CompilerGeneratedAttribute]
public sealed virtual NodePatternBlank get_ParentPattern();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ParentPattern(NodePatternBlank value);
    [CompilerGeneratedAttribute]
public sealed virtual NodePatternBlank get_Pattern();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Pattern(NodePatternBlank value);
    public void LinkPatterns(bool onlyLinkParents);
    public INodePattern BuildPattern();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.BracesRule : ParenthesisRuleBase {
    protected static Object[] EndOfLineStyles;
    protected static Object[] NextLineStyles;
    [CompilerGeneratedAttribute]
private LambdaExpression <BraceSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <EmptyBlockSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <SpaceBeforeLBraceSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <AlignmentSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <IndentSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlignBraces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableParentAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FormatBeforeLBrace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FormatBeforeLBraceUnlessSingleLine>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreferSeparateSingleLine>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TakeParentAsWrapRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowNextLineShifted2>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustHaveIndentIfOnNewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProhibitBlankLinesNearBracesInBsdStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <MaxBlankLinesBeforeLBraceSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <RemoveBlankLinesInsideBracesSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <InsertBlankLinesInsideBracesSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <SimpleBlockSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SimpleEmbeddedStatementStyle> <SimpleBlockSettingDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <IgnoreForceSingleLineSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <SingleLineSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <SingleLineSetting2>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<VirtNode, CodeFormattingContext, bool> <SingleLineParentPredicate>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<VirtNode, CodeFormattingContext, bool> <SingleLinePredicate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcellentPlaceToWrapAroundBraces>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IBuilderAction`1[]> <ExceptionsToWrapRegion>k__BackingField;
    public LambdaExpression BraceSetting { get; public set; }
    public LambdaExpression EmptyBlockSetting { get; public set; }
    public LambdaExpression SpaceBeforeLBraceSetting { get; public set; }
    public LambdaExpression AlignmentSetting { get; public set; }
    public LambdaExpression IndentSetting { get; public set; }
    public bool AlignBraces { get; public set; }
    public bool DisableParentAlignment { get; public set; }
    public bool FormatBeforeLBrace { get; public set; }
    public bool FormatBeforeLBraceUnlessSingleLine { get; public set; }
    public bool PreferSeparateSingleLine { get; public set; }
    public bool TakeParentAsWrapRegion { get; public set; }
    public bool AllowNextLineShifted2 { get; public set; }
    public bool MustHaveIndentIfOnNewLine { get; public set; }
    public bool ProhibitBlankLinesNearBracesInBsdStyle { get; public set; }
    public LambdaExpression MaxBlankLinesBeforeLBraceSetting { get; public set; }
    public LambdaExpression RemoveBlankLinesInsideBracesSetting { get; public set; }
    public LambdaExpression InsertBlankLinesInsideBracesSetting { get; public set; }
    public LambdaExpression SimpleBlockSetting { get; public set; }
    public Nullable`1<SimpleEmbeddedStatementStyle> SimpleBlockSettingDefault { get; public set; }
    public LambdaExpression IgnoreForceSingleLineSetting { get; public set; }
    public LambdaExpression SingleLineSetting { get; public set; }
    public LambdaExpression SingleLineSetting2 { get; public set; }
    public Func`3<VirtNode, CodeFormattingContext, bool> SingleLineParentPredicate { get; public set; }
    public Func`3<VirtNode, CodeFormattingContext, bool> SingleLinePredicate { get; public set; }
    public bool ExcellentPlaceToWrapAroundBraces { get; public set; }
    public List`1<IBuilderAction`1[]> ExceptionsToWrapRegion { get; private set; }
    private static BracesRule();
    [CompilerGeneratedAttribute]
public LambdaExpression get_BraceSetting();
    [CompilerGeneratedAttribute]
public void set_BraceSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_EmptyBlockSetting();
    [CompilerGeneratedAttribute]
public void set_EmptyBlockSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_SpaceBeforeLBraceSetting();
    [CompilerGeneratedAttribute]
public void set_SpaceBeforeLBraceSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_AlignmentSetting();
    [CompilerGeneratedAttribute]
public void set_AlignmentSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_IndentSetting();
    [CompilerGeneratedAttribute]
public void set_IndentSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public bool get_AlignBraces();
    [CompilerGeneratedAttribute]
public void set_AlignBraces(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableParentAlignment();
    [CompilerGeneratedAttribute]
public void set_DisableParentAlignment(bool value);
    [CompilerGeneratedAttribute]
public bool get_FormatBeforeLBrace();
    [CompilerGeneratedAttribute]
public void set_FormatBeforeLBrace(bool value);
    [CompilerGeneratedAttribute]
public bool get_FormatBeforeLBraceUnlessSingleLine();
    [CompilerGeneratedAttribute]
public void set_FormatBeforeLBraceUnlessSingleLine(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreferSeparateSingleLine();
    [CompilerGeneratedAttribute]
public void set_PreferSeparateSingleLine(bool value);
    [CompilerGeneratedAttribute]
public bool get_TakeParentAsWrapRegion();
    [CompilerGeneratedAttribute]
public void set_TakeParentAsWrapRegion(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowNextLineShifted2();
    [CompilerGeneratedAttribute]
public void set_AllowNextLineShifted2(bool value);
    [CompilerGeneratedAttribute]
public bool get_MustHaveIndentIfOnNewLine();
    [CompilerGeneratedAttribute]
public void set_MustHaveIndentIfOnNewLine(bool value);
    [CompilerGeneratedAttribute]
public bool get_ProhibitBlankLinesNearBracesInBsdStyle();
    [CompilerGeneratedAttribute]
public void set_ProhibitBlankLinesNearBracesInBsdStyle(bool value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_MaxBlankLinesBeforeLBraceSetting();
    [CompilerGeneratedAttribute]
public void set_MaxBlankLinesBeforeLBraceSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_RemoveBlankLinesInsideBracesSetting();
    [CompilerGeneratedAttribute]
public void set_RemoveBlankLinesInsideBracesSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_InsertBlankLinesInsideBracesSetting();
    [CompilerGeneratedAttribute]
public void set_InsertBlankLinesInsideBracesSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_SimpleBlockSetting();
    [CompilerGeneratedAttribute]
public void set_SimpleBlockSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public Nullable`1<SimpleEmbeddedStatementStyle> get_SimpleBlockSettingDefault();
    [CompilerGeneratedAttribute]
public void set_SimpleBlockSettingDefault(Nullable`1<SimpleEmbeddedStatementStyle> value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_IgnoreForceSingleLineSetting();
    [CompilerGeneratedAttribute]
public void set_IgnoreForceSingleLineSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_SingleLineSetting();
    [CompilerGeneratedAttribute]
public void set_SingleLineSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_SingleLineSetting2();
    [CompilerGeneratedAttribute]
public void set_SingleLineSetting2(LambdaExpression value);
    [CompilerGeneratedAttribute]
public Func`3<VirtNode, CodeFormattingContext, bool> get_SingleLineParentPredicate();
    [CompilerGeneratedAttribute]
public void set_SingleLineParentPredicate(Func`3<VirtNode, CodeFormattingContext, bool> value);
    [CompilerGeneratedAttribute]
public Func`3<VirtNode, CodeFormattingContext, bool> get_SingleLinePredicate();
    [CompilerGeneratedAttribute]
public void set_SingleLinePredicate(Func`3<VirtNode, CodeFormattingContext, bool> value);
    [CompilerGeneratedAttribute]
public bool get_ExcellentPlaceToWrapAroundBraces();
    [CompilerGeneratedAttribute]
public void set_ExcellentPlaceToWrapAroundBraces(bool value);
    [CompilerGeneratedAttribute]
public List`1<IBuilderAction`1[]> get_ExceptionsToWrapRegion();
    [CompilerGeneratedAttribute]
private void set_ExceptionsToWrapRegion(List`1<IBuilderAction`1[]> value);
    protected virtual void ShallowToDeepCopy();
    public virtual void Build(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
    private void BeforeLBrace(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider, IBuilderWithProvider`3[] lBraceFormatOptions, int basePriority, IBuilderWithProvider`3[] spacesBeforeLBrace);
    protected WrapType GetWrapRegionType(bool keepExisting);
    protected void WrapAroundBraces(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
    internal IBuilderWithProvider`3<TContext, TSettingsKey, TRule> AddWrapRegionSettings(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider, IBuilderWithProvider`3<TContext, TSettingsKey, TRule> builder);
    internal virtual IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> AddWrapOption(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider, IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, bool forElementsAndComma);
    [CompilerGeneratedAttribute]
private bool <Build>b__108_3(VirtNode node, CodeFormattingContext context);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.BracesRuleEx : object {
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> BraceSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> EmptyBlockSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> SpaceBeforeLBraceSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> AlignmentSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static T AlignBraces(T builder, bool value);
    [ExtensionAttribute]
public static T DisableParentAlignment(T builder, bool value);
    [ExtensionAttribute]
public static T FormatBeforeLBrace(T builder, bool value, bool formatBeforeLBraceUnlessSingleLine, bool preferSeparateSingleLine);
    [ExtensionAttribute]
public static T TakeParentAsWrapRegion(T builder, bool value);
    [ExtensionAttribute]
public static T AllowNextLineShifted2(T builder, bool value);
    [ExtensionAttribute]
public static T MustHaveIndentIfOnNewLine(T builder, bool value);
    [ExtensionAttribute]
public static T ProhibitBlankLinesNearBracesInBsdStyle(T builder, bool value);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, BracesRule> MaxBlankLinesBeforeLBraceSetting(IBuilderWithProvider`3<TContext, TSettingsKey, BracesRule> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, BracesRule> RemoveBlankLinesInsideBracesSetting(IBuilderWithProvider`3<TContext, TSettingsKey, BracesRule> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, BracesRule> InsertBlankLinesInsideBracesSetting(IBuilderWithProvider`3<TContext, TSettingsKey, BracesRule> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, BracesRule> SimpleBlockSetting(IBuilderWithProvider`3<TContext, TSettingsKey, BracesRule> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, BracesRule> IndentSetting(IBuilderWithProvider`3<TContext, TSettingsKey, BracesRule> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, BracesRule> SingleLineSetting(IBuilderWithProvider`3<TContext, TSettingsKey, BracesRule> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, BracesRule> IgnoreForceSingleLineSetting(IBuilderWithProvider`3<TContext, TSettingsKey, BracesRule> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, BracesRule> SingleLineSetting2(IBuilderWithProvider`3<TContext, TSettingsKey, BracesRule> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static T SingleLineParentPredicate(T builder, Func`3<VirtNode, CodeFormattingContext, bool> value);
    [ExtensionAttribute]
public static T SingleLinePredicate(T builder, Func`3<VirtNode, CodeFormattingContext, bool> value);
    [ExtensionAttribute]
public static T ExcellentPlaceToWrapAroundBraces(T builder, bool value);
    [ExtensionAttribute]
public static T SimpleBlockSettingDefault(T builder, Nullable`1<SimpleEmbeddedStatementStyle> value);
    [ExtensionAttribute]
public static TEnvelope AddExceptionToWrapRegion(TEnvelope builder, IBuilderAction`1[] buiders);
}
internal class JetBrains.ReSharper.Psi.Impl.CodeStyle.BuilderAction`1 : object {
    private Action`1<T> myAction;
    public BuilderAction`1(Action`1<T> action);
    public sealed virtual void Run(T obj);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.BuilderWithProvider`3 : SimpleBuilderWithProvider`3<TContext, TSettingsKey, TStorage> {
    public BuilderWithProvider`3(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
    public virtual IBuilder`1<TStorage> DoClone();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.BuilderWithProviderAndExternalKey`4 : SimpleBuilderWithProvider`3<TContext, TSettingsKey, TStorage> {
    public BuilderWithProviderAndExternalKey`4(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
    public virtual IBuilder`1<TStorage> DoClone();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.ChildBuilder`2 : SimpleBuilder`1<TChild> {
    private Action`2<TParent, TChild> myProcessor;
    public ChildBuilder`2(Action`2<TParent, TChild> processor);
    public sealed virtual void Run(TParent parent);
    public virtual IBuilder`1<TChild> DoClone();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.ChildRoleNodePattern : object {
    private short myChildRole;
    public int PerformanceRating { get; }
    public ChildRoleNodePattern(short childRole);
    public sealed virtual IEnumerable`1<NodeType> GetNodeTypes();
    public sealed virtual bool Matches(ITreeNode treeNode, CodeFormattingContext context);
    public sealed virtual int get_PerformanceRating();
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.Impl.CodeStyle.ChopElements : Enum {
    public int value__;
    public static ChopElements ChopAlways;
    public static ChopElements NeverChop;
    public static ChopElements UseOptionForPars;
}
public abstract class JetBrains.ReSharper.Psi.Impl.CodeStyle.CodeFormatterBase`1 : FormatSettingsService`1<TSettingsKey> {
    private Lazy`1<Dictionary`2<CodeFormatProfile, ConditionalSettingsChange[]>> mySettingsToChange;
    public bool SupportsSettingsTracking { get; }
    public bool SupportsAdditionalProfiles { get; }
    public bool SupportsWrapping { get; }
    public bool SupportsReindenting { get; }
    public bool PotentiallySupportsFormatterDaemon { get; }
    public bool SupportsAutoDetect { get; }
    public bool SupportsFormattingWithAccu { get; }
    public string OverridenSettingPrefix { get; }
    public string OverridenSettingSuffix { get; }
    protected CodeFormatterBase`1(PsiLanguageType languageType, CodeFormatterRequirements requirements);
    protected abstract virtual CodeFormattingContext CreateFormatterContext(AdditionalFormatterParameters parameters, ICustomFormatterInfoProvider provider, int tabWidth, SingleLangChangeAccu changeAccu, FormatTask[] formatTasks);
    public virtual bool get_SupportsSettingsTracking();
    public virtual bool get_SupportsAdditionalProfiles();
    public virtual bool get_SupportsWrapping();
    public virtual bool get_SupportsReindenting();
    public virtual bool get_PotentiallySupportsFormatterDaemon();
    public virtual bool SupportsFormatterDaemon(IFile fileNode, IContextBoundSettingsStore overrideSettingsStore);
    public virtual bool CanBeMultilineToken(ITreeNode node);
    public virtual bool IsWhitespaceToken(ITokenNode token);
    protected internal virtual bool IsWhitespaceTokenForFindFormattingRange(ITokenNode token);
    protected internal virtual bool IsFormatNextSpaces(CodeFormatProfile profile);
    public virtual bool get_SupportsAutoDetect();
    public virtual ITreeNode NextFormattableSibling(ITreeNode node);
    public virtual ITreeNode PrevFormattableSibling(ITreeNode node);
    public sealed virtual bool IsWhitespaceToken(ITreeNode node);
    public virtual bool IsNewLine(ITreeNode ws);
    public sealed virtual bool IsPureSpace(ITreeNode ws);
    public abstract virtual ITreeNode CreateSpace(string indent, NodeType replacedOrLeftSiblingType);
    public virtual ITreeNode CreateSpace();
    public abstract virtual ITreeNode CreateNewLine(LineEnding lineEnding, NodeType lineBreakType);
    public virtual bool CanModifyInsideNodeRange(ITreeNode leftElement, ITreeNode rightElement, CodeFormattingContext context);
    public virtual bool CanModifyNode(ITreeNode element, CodeFormattingContext context);
    public virtual IFormatterInfoProvider GetFormatterInfoProvider(IPsiSourceFile sourceFile, AdditionalFormatterParameters parameters);
    public virtual void FormatFile(IFile fileNode, CodeFormatProfile profile, AdditionalFormatterParameters parameters);
    protected virtual void RemoveLeadingAndTrailingSpacesInFile(IFile fileNode, IContextBoundSettingsStore overrideSettingsStore);
    public void RemoveTrailingSpaces(IFile fileNode);
    public virtual void InsertLineFeedAtFileEndIfNeeded(IFile fileNode, IContextBoundSettingsStore overrideSettingsStore);
    public void RemoveLeadingSpacesInFile(IFile fileNode);
    public virtual void Format(ITreeNode root, CodeFormatProfile profile, AdditionalFormatterParameters parameters);
    public virtual void Format(FormatTask[] formatTasks, AdditionalFormatterParameters parameters);
    public sealed virtual void AdjustFormatTasks(FormatTask[] formatTasks);
    public virtual bool HasSignificantWhitespaces(ITreeNode node);
    protected static void RestoreFormatTasks(FormatTask[]& formatTasks);
    protected static void SaveFormatTasks(FormatTask[] formatTasks, bool always);
    protected static void FreeRangeMarkers(FormatTask[] formatTasks);
    public abstract virtual ITreeRange Format(ITreeNode firstElement, ITreeNode lastElement, CodeFormatProfile profile, AdditionalFormatterParameters parameters);
    [CanBeNullAttribute]
private IReadOnlyList`1<ConditionalSettingsChange<TSettingsKey>> GetSettingsToChangeForProfile(CodeFormatProfile profile);
    protected virtual Dictionary`2<CodeFormatProfile, ConditionalSettingsChange[]> GetSettingsToChangeForProfileImpl();
    public virtual void ChangeSettingsForProfiles(CodeFormatProfile profile, FmtSettingsHolder`1<TSettingsKey> formatterSettings);
    public virtual bool UseChangeAccu(CachedSettings fmtSettings, IPsiSourceFile sourceFile);
    [ObsoleteAttribute("Use overload without doAdditionalFormat, instead overrider NeedsAdditionalFormatStage in FormatterInfoProviderBase to provide the value if you need")]
protected void DoDeclarativeFormat(FmtSettingsHolder`1<TSettingsKey> settings, FormatterInfoProviderBase`2<TContext, TSettingsKey> provider, ICustomFormatterInfoProvider customProvider, FormatTask[] formatTasks, AdditionalFormatterParameters parameters, Action`4<FormatTask, FmtSettingsHolder`1<TSettingsKey>, TContext, IProgressIndicator> beforeFormat, Action`4<FormatTask, FmtSettingsHolder`1<TSettingsKey>, TContext, IProgressIndicator> afterFormat, bool doAdditionalFormat);
    protected void DoDeclarativeFormat(FmtSettingsHolder`1<TSettingsKey> settings, FormatterInfoProviderBase`2<TContext, TSettingsKey> provider, ICustomFormatterInfoProvider customProvider, FormatTask[] formatTasks, AdditionalFormatterParameters parameters, Action`4<FormatTask, FmtSettingsHolder`1<TSettingsKey>, TContext, IProgressIndicator> beforeFormat, Action`4<FormatTask, FmtSettingsHolder`1<TSettingsKey>, TContext, IProgressIndicator> afterFormat);
    public void DoFormatMyLanguageInMultiLanguageFileWithAccu(FormatTask[] formatTasks, FileChangeAccu accu, AdditionalFormatterParameters parameters, IContextBoundSettingsStore settingsStore, IPsiSourceFile sourceFile, LineEnding lineEnding, ICustomFormatterInfoProvider customFormattingInfoProvider);
    public virtual void FormatMyLanguageInMultiLanguageFileWithAccu(FormatTask[] formatTasks, FileChangeAccu accu, AdditionalFormatterParameters parameters, IContextBoundSettingsStore settingsStore, IPsiSourceFile sourceFile, LineEnding lineEnding);
    public virtual bool get_SupportsFormattingWithAccu();
    protected virtual bool NeedMultilanguageFormattingWithAccu(IPsiSourceFile sourceFile, CachedSettings settings);
    protected void FormatMultiLanguageFileWithAccu(DocumentRangeFormatTask[] formatTasks, IPsiSourceFile sourceFile, AdditionalFormatterParameters parameters);
    public sealed virtual FileChangeAccu CalculateFormattingChanges(DocumentRangeFormatTask[] formatTasks, IPsiSourceFile sourceFile, AdditionalFormatterParameters parameters);
    private static FileChangeAccu CalculateFormattingChanges(DocumentRangeFormatTask[] formatTasks, IPsiSourceFile sourceFile, IFile& primaryPsiFile, FormatTask[]& mainTasks, AdditionalFormatterParameters parameters, CodeFormatterRequirements requirements);
    private DocumentRangeFormatTask[] Translate(FormatTask[] formatTasks);
    private static void ConcatenateRangeTasks(DocumentRangeFormatTask[]& formatTasks, IDocument document);
    private static void AdjustRangeTasks(DocumentRangeFormatTask[]& formatTasks, IDocument document);
    private void DoDeclarativeFormatChangesWithAccu(FormatterInfoProviderBase`2<TContext, TSettingsKey> provider, FormatTask[] formatTasks, AdditionalFormatterParameters parameters, Action`4<FormatTask, FmtSettingsHolder`1<TSettingsKey>, TContext, IProgressIndicator> beforeFormat, Action`4<FormatTask, FmtSettingsHolder`1<TSettingsKey>, TContext, IProgressIndicator> afterFormat, FmtSettingsHolder`1<TSettingsKey> settings, int tabWidth, ICustomFormatterInfoProvider customProvider);
    protected void DoDeclarativeFormatChanges(FormatterInfoProviderBase`2<TContext, TSettingsKey> provider, FormatTask[] formatTasks, AdditionalFormatterParameters parameters, Action`4<FormatTask, FmtSettingsHolder`1<TSettingsKey>, TContext, IProgressIndicator> beforeFormat, Action`4<FormatTask, FmtSettingsHolder`1<TSettingsKey>, TContext, IProgressIndicator> afterFormat, FmtSettingsHolder`1<TSettingsKey> settings, TContext context);
    private static void DoFormattingInspection(FormatterInfoProviderBase`2<TContext, TSettingsKey> provider, AdditionalFormatterParameters parameters, TContext context, FmtSettingsHolder`1<TSettingsKey> settings);
    protected virtual FmtSettingsHolder`1<TSettingsKey> OverrideSettingsIfNeeded(FmtSettingsHolder`1<TSettingsKey> settings, FormatTask[] formatTasks, ICustomFormatterInfoProvider customFormatterInfoProvider);
    protected void DoAutoDetectFormat(ITreeNode firstElement, ITreeNode lastElement, CodeFormatProfile profile, FormatterInfoProviderBase`2<TContext, TSettingsKey> provider, AdditionalFormatterParameters parameters);
    public virtual string get_OverridenSettingPrefix();
    public virtual string get_OverridenSettingSuffix();
    public FormatterTagsProcessor`1<TSettingsKey> CreateTagProcessor(CachedSettings settings);
    public sealed virtual Pair`2<string, string> GenerateOverrideComments(Pair`2[] settings, string lineEnding);
    protected IEnumerable`1<IScalarSetting> GetSettingsByAlias(string name);
    protected void SetSettingsByAlias(string name, CachedSettings`1<TSettingsKey> settings, object value);
    public abstract virtual void FormatInsertedNodes(ITreeNode nodeFirst, ITreeNode nodeLast, bool formatSurround, bool indentSurround);
    public abstract virtual ITreeRange FormatInsertedRange(ITreeNode nodeFirst, ITreeNode nodeLast, ITreeRange origin);
    public abstract virtual void FormatReplacedNode(ITreeNode oldNode, ITreeNode newNode);
    public abstract virtual void FormatReplacedRange(ITreeNode first, ITreeNode last, ITreeRange oldNodes);
    public abstract virtual void FormatDeletedNodes(ITreeNode parent, ITreeNode prevNode, ITreeNode nextNode);
    public virtual ITokenNode GetMinimalSeparator(ITokenNode leftToken, ITokenNode rightToken);
    public abstract virtual MinimalSeparatorType GetMinimalSeparatorByNodeTypes(TokenNodeType leftToken, TokenNodeType rightToken);
    public sealed virtual Pair`2<string, FormatterDirectiveType> GetFormatterRegionTypeFromComment(IComment comment);
    protected virtual void SetKeepArrangementsSettings(FmtSettingsHolder`1<TSettingsKey> formatterSettings, bool value);
    public virtual Nullable`1<bool> ParseCustomEnableDisableTag(IBuffer buffer, int start, int end);
    [CompilerGeneratedAttribute]
private bool <GetSettingsByAlias>b__73_0(SettingIndex it);
    [CompilerGeneratedAttribute]
private IScalarSetting <GetSettingsByAlias>b__73_1(SettingIndex it);
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.CodeFormatterRequirements : object {
    [CompilerGeneratedAttribute]
private IFormatterDebugInfoLoggersProvider <FormatterLoggerProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettingsOptimization <SettingsOptimization>k__BackingField;
    [CompilerGeneratedAttribute]
private IEditorConfigSchema <EditorConfigSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettingsStore <SettingsStore>k__BackingField;
    [CompilerGeneratedAttribute]
private ICalculatedSettingsSchema <CalculatedSettingsSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettingsSchema <Schema>k__BackingField;
    public IFormatterDebugInfoLoggersProvider FormatterLoggerProvider { get; }
    public ISettingsOptimization SettingsOptimization { get; }
    public IEditorConfigSchema EditorConfigSchema { get; }
    public ISettingsStore SettingsStore { get; }
    public ICalculatedSettingsSchema CalculatedSettingsSchema { get; }
    public ISettingsSchema Schema { get; }
    public CodeFormatterRequirements(IFormatterDebugInfoLoggersProvider formatterLoggerProvider, ISettingsOptimization settingsOptimization, IEditorConfigSchema editorConfigSchema, ISettingsStore settingsStore, ICalculatedSettingsSchema calculatedSettingsSchema, ISettingsSchema schema);
    [CompilerGeneratedAttribute]
public IFormatterDebugInfoLoggersProvider get_FormatterLoggerProvider();
    [CompilerGeneratedAttribute]
public ISettingsOptimization get_SettingsOptimization();
    [CompilerGeneratedAttribute]
public IEditorConfigSchema get_EditorConfigSchema();
    [CompilerGeneratedAttribute]
public ISettingsStore get_SettingsStore();
    [CompilerGeneratedAttribute]
public ICalculatedSettingsSchema get_CalculatedSettingsSchema();
    [CompilerGeneratedAttribute]
public ISettingsSchema get_Schema();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.CodeFormattingContext : object {
    private ICodeFormatterImpl myCodeFormatter;
    private JetHashSet`1<VirtNode> mySticklessNodes;
    private Dictionary`2<ITreeNode, bool> myIsNodeInOurDocument;
    protected IFile myFile;
    protected IFile myParentFile;
    private FormattingRangeContext myTempContext;
    [CompilerGeneratedAttribute]
private FormatTask[] <FormatTasks>k__BackingField;
    private DisableLineBreakChangesInCodeFormatterCookie myCookie;
    private bool myValidDocRangeForWholeFile;
    [CompilerGeneratedAttribute]
private FormattingStageId <StageId>k__BackingField;
    [CompilerGeneratedAttribute]
private IFormatterDebugInfoLogger <DebugInfoLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableIndentingInsideComments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableFormatterDisabling>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TreatTextAfterLastNodeAsIncorrect>k__BackingField;
    [CompilerGeneratedAttribute]
private IFormatterDaemon <Daemon>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPhysical>k__BackingField;
    [CompilerGeneratedAttribute]
private IPotentSettingsTracker <PotentSettingsTracker>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<VirtNode, VirtNode> <RemovedLineBreaks>k__BackingField;
    [CompilerGeneratedAttribute]
private ILanguageInjectorProviderInLiterals <Injector>k__BackingField;
    [CompilerGeneratedAttribute]
private AutodetectSession <AutodetectSession>k__BackingField;
    [CompilerGeneratedAttribute]
private AdditionalFormatterParameters <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TabWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private SingleLangChangeAccu <ChangeAccu>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SolutionWideOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtNode <NullNode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AppliedAlignmentThatMayAffectIntAlign>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AppliedIntAlign>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NeedSecondPass>k__BackingField;
    public FormatTask[] FormatTasks { get; }
    public FormattingStageId StageId { get; public set; }
    public IFormatterDebugInfoLogger DebugInfoLogger { get; }
    public bool DisableIndentingInsideComments { get; }
    public bool DisableFormatterDisabling { get; }
    public bool TreatTextAfterLastNodeAsIncorrect { get; }
    public IFormatterDaemon Daemon { get; public set; }
    public bool IsPhysical { get; }
    [CanBeNullAttribute]
public IPotentSettingsTracker PotentSettingsTracker { get; }
    public Dictionary`2<VirtNode, VirtNode> RemovedLineBreaks { get; }
    public ILanguageInjectorProviderInLiterals Injector { get; }
    public AutodetectSession AutodetectSession { get; public set; }
    public AdditionalFormatterParameters Parameters { get; }
    public int TabWidth { get; }
    [CanBeNullAttribute]
public SingleLangChangeAccu ChangeAccu { get; }
    public bool SolutionWideOperation { get; }
    public VirtNode NullNode { get; }
    [CanBeNullAttribute]
public IFile File { get; }
    [CanBeNullAttribute]
public IFile ParentFile { get; }
    public ICodeFormatterImpl CodeFormatter { get; }
    public bool IsEmbedded { get; }
    public VirtNode FirstNodeOfFirstTask { get; }
    public VirtNode LastNodeOfLastTask { get; }
    [ObsoleteAttribute]
public VirtNode FirstNode { get; }
    [ObsoleteAttribute]
public VirtNode LastNode { get; }
    public bool AppliedAlignmentThatMayAffectIntAlign { get; public set; }
    public bool AppliedIntAlign { get; public set; }
    public bool NeedSecondPass { get; public set; }
    public FormattingRangeContext TempContext { get; }
    public bool IsEmpty { get; }
    protected bool ForceCheckModifiableRange { get; }
    public CodeFormattingContext(ICodeFormatterImpl codeFormatter, IFormatterDebugInfoLogger debugInfoLogger, AdditionalFormatterParameters parameters, int tabWidth, SingleLangChangeAccu changeAccu, FormatTask[] formatTasks);
    [CompilerGeneratedAttribute]
public FormatTask[] get_FormatTasks();
    [CompilerGeneratedAttribute]
public FormattingStageId get_StageId();
    [CompilerGeneratedAttribute]
public void set_StageId(FormattingStageId value);
    [CompilerGeneratedAttribute]
public IFormatterDebugInfoLogger get_DebugInfoLogger();
    [CompilerGeneratedAttribute]
public bool get_DisableIndentingInsideComments();
    [CompilerGeneratedAttribute]
public bool get_DisableFormatterDisabling();
    [CompilerGeneratedAttribute]
public bool get_TreatTextAfterLastNodeAsIncorrect();
    [CompilerGeneratedAttribute]
public IFormatterDaemon get_Daemon();
    [CompilerGeneratedAttribute]
public void set_Daemon(IFormatterDaemon value);
    [CompilerGeneratedAttribute]
public bool get_IsPhysical();
    [CompilerGeneratedAttribute]
public IPotentSettingsTracker get_PotentSettingsTracker();
    [CompilerGeneratedAttribute]
public Dictionary`2<VirtNode, VirtNode> get_RemovedLineBreaks();
    [CompilerGeneratedAttribute]
public ILanguageInjectorProviderInLiterals get_Injector();
    [CompilerGeneratedAttribute]
public AutodetectSession get_AutodetectSession();
    [CompilerGeneratedAttribute]
public void set_AutodetectSession(AutodetectSession value);
    [CompilerGeneratedAttribute]
public AdditionalFormatterParameters get_Parameters();
    [CompilerGeneratedAttribute]
public int get_TabWidth();
    [CompilerGeneratedAttribute]
public SingleLangChangeAccu get_ChangeAccu();
    [CompilerGeneratedAttribute]
public bool get_SolutionWideOperation();
    [CompilerGeneratedAttribute]
public VirtNode get_NullNode();
    public IFile get_File();
    public IFile get_ParentFile();
    public ICodeFormatterImpl get_CodeFormatter();
    public bool get_IsEmbedded();
    public VirtNode get_FirstNodeOfFirstTask();
    public VirtNode get_LastNodeOfLastTask();
    public VirtNode get_FirstNode();
    public VirtNode get_LastNode();
    [CompilerGeneratedAttribute]
public bool get_AppliedAlignmentThatMayAffectIntAlign();
    [CompilerGeneratedAttribute]
public void set_AppliedAlignmentThatMayAffectIntAlign(bool value);
    [CompilerGeneratedAttribute]
public bool get_AppliedIntAlign();
    [CompilerGeneratedAttribute]
public void set_AppliedIntAlign(bool value);
    [CompilerGeneratedAttribute]
public bool get_NeedSecondPass();
    [CompilerGeneratedAttribute]
public void set_NeedSecondPass(bool value);
    public FormattingRangeContext get_TempContext();
    public TreeTextRange GetTotalRangeForAllTasks();
    public virtual void ClearCache();
    public bool get_IsEmpty();
    public virtual bool ImagineLineBreakBefore(ITreeNode node);
    public bool ImagineLineBreakBefore(VirtNode node);
    protected virtual bool get_ForceCheckModifiableRange();
    public VirtNode GetFirstElementFromTask(int taskNum);
    public VirtNode GetLastElementFromTask(int taskNum);
    public VirtNode GetFirstElementFromTask(FormatTask formatTask);
    public VirtNode GetLastElementFromTask(FormatTask formatTask);
    public bool IsStickless(ITreeNode node);
    public bool IsStickless(VirtNode node);
    public void MarkAsStickless(VirtNode node);
    public void MarkAsStickless(ITreeNode node);
    public bool AllowLineBreaks(VirtNode leftNode, VirtNode rightNode);
    public virtual bool AllowLineBreaks(ITreeNode leftNode, ITreeNode rightNode);
    public bool AllowLineBreakChanges(VirtNode leftNode, VirtNode rightNode);
    public bool AllowLineBreakChanges(ITreeNode leftNode, ITreeNode rightNode);
    public bool CanModifyInsideNodeRange(ITreeNode leftElement, ITreeNode rightElement);
    public bool CanModifyNode(ITreeNode element);
    public bool IsNodeInOurDocument(ITreeNode element);
    public bool HasLineBreaks();
    public bool HasLineBreaks(FormatTask task);
    public void HandleNodeReplace(ITreeNode oldNode, ITreeNode newNode);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.ComplexFormatProcessor`2 : object {
    private TContext myContext;
    private ISequentialNodeProcessor`1<TSettingsKey> myFirstProcessor;
    private ISequentialNodeProcessor`1<TSettingsKey> mySecondProcessor;
    private ISequentialNodeProcessor`1<TSettingsKey> myThirdProcessor;
    private ISequentialNodeProcessor`1<TSettingsKey> myFourthProcessor;
    [CompilerGeneratedAttribute]
private SequentialNodeIterator`2<TContext, TSettingsKey> <Iterator>k__BackingField;
    public SequentialNodeIterator`2<TContext, TSettingsKey> Iterator { get; }
    public ComplexFormatProcessor`2(TContext context, FmtSettingsHolder`1<TSettingsKey> settings);
    [CompilerGeneratedAttribute]
public SequentialNodeIterator`2<TContext, TSettingsKey> get_Iterator();
    public void RunProcessors(IProgressIndicator progressIndicator, string taskName, ISequentialNodeProcessor`1<TSettingsKey> firstProcessor, ISequentialNodeProcessor`1<TSettingsKey> secondProcessor, ISequentialNodeProcessor`1<TSettingsKey> thirdProcessor, ISequentialNodeProcessor`1<TSettingsKey> fourthProcessor);
    public sealed virtual void TaskStarted();
    public sealed virtual void FileStart();
    public sealed virtual void ProcessNodeEnd();
    public sealed virtual void ProcessLineBreak(VirtNode& lineBreak);
    public sealed virtual void ProcessDescendIntoNode();
    public sealed virtual void TaskFinished(VirtNode& dontReallyFinishUntilThisNode);
    public sealed virtual VirtNode FixLastNodeWhenEmptyInterval(VirtNode lastNode);
    public sealed virtual void ProcessNextSolidNode(FormattingRangeContext context);
    public sealed virtual VirtNode GetNextSibling(VirtNode node);
    public sealed virtual ITreeNode GetFirstChild(ITreeNode node);
    public sealed virtual void SettingsChanged(FmtSettingsHolder`1<TSettingsKey> newSettings);
    public sealed virtual void AllTaskFinished();
    public sealed virtual void Initialize(Boolean& currentNodeInitialized);
    public sealed virtual void PreProcessNextSolidNode(FormattingRangeContext context);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.ConstantOptionNode : object {
    [CompilerGeneratedAttribute]
private IOptionValue <Value>k__BackingField;
    public IOptionValue Value { get; }
    public IEnumerable`1<IOptionValue> Values { get; }
    public ConstantOptionNode(IOptionValue value);
    [CompilerGeneratedAttribute]
public IOptionValue get_Value();
    public sealed virtual IOptionValue GetOptionValue(ISettingValueReader reader, object data, CodeFormattingContext context);
    public sealed virtual IEnumerable`1<IOptionValue> get_Values();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.ContinuousIndentRule : RuleBlankBase {
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IBuilderAction`1[]> <Exceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <MultiplierSetting>k__BackingField;
    public int Priority { get; public set; }
    public List`1<IBuilderAction`1[]> Exceptions { get; private set; }
    public LambdaExpression MultiplierSetting { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Priority(int value);
    [CompilerGeneratedAttribute]
public List`1<IBuilderAction`1[]> get_Exceptions();
    [CompilerGeneratedAttribute]
private void set_Exceptions(List`1<IBuilderAction`1[]> value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_MultiplierSetting();
    [CompilerGeneratedAttribute]
public void set_MultiplierSetting(LambdaExpression value);
    protected virtual void ShallowToDeepCopy();
    public sealed virtual void Build(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
    public static IBuildableBuilder`1[] ContinuousIndentOptions(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider, IndentType indentType);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.ContinuousIndentRuleEx : object {
    [ExtensionAttribute]
public static TEnvelope AddException(TEnvelope builder, IBuilderAction`1[] buiders);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> MultiplierSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.DelayedIndentingRule : IndentingRule {
    [CompilerGeneratedAttribute]
private BlankWithPattern <PatternToStartCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<VirtNode, CodeFormattingContext, VirtNode> <CheckUntilNodeGetter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckUntilNodeRightSide>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveAfterApplying>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckOnNodeRightSide>k__BackingField;
    public BlankWithPattern PatternToStartCheck { get; }
    public Func`3<VirtNode, CodeFormattingContext, VirtNode> CheckUntilNodeGetter { get; public set; }
    public bool CheckUntilNodeRightSide { get; public set; }
    public bool RemoveAfterApplying { get; public set; }
    public bool CheckOnNodeRightSide { get; public set; }
    [CompilerGeneratedAttribute]
public BlankWithPattern get_PatternToStartCheck();
    [CompilerGeneratedAttribute]
public Func`3<VirtNode, CodeFormattingContext, VirtNode> get_CheckUntilNodeGetter();
    [CompilerGeneratedAttribute]
public void set_CheckUntilNodeGetter(Func`3<VirtNode, CodeFormattingContext, VirtNode> value);
    [CompilerGeneratedAttribute]
public bool get_CheckUntilNodeRightSide();
    [CompilerGeneratedAttribute]
public void set_CheckUntilNodeRightSide(bool value);
    [CompilerGeneratedAttribute]
public bool get_RemoveAfterApplying();
    [CompilerGeneratedAttribute]
public void set_RemoveAfterApplying(bool value);
    [CompilerGeneratedAttribute]
public bool get_CheckOnNodeRightSide();
    [CompilerGeneratedAttribute]
public void set_CheckOnNodeRightSide(bool value);
    public virtual void Build(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.DelayedIndentingRuleEx : object {
    [ExtensionAttribute]
public static TEnvelope WhereToStartCheck(TEnvelope builder, IBuilderAction`1[] builders);
    [ExtensionAttribute]
public static T CheckUntilNodeGetter(T builder, Func`3<VirtNode, CodeFormattingContext, VirtNode> checkUntilNodeGetter);
    [ExtensionAttribute]
public static T CheckUntilNodeRightSide(T builder, bool value);
    [ExtensionAttribute]
public static T RemoveAfterApplying(T builder, bool value);
    [ExtensionAttribute]
public static T CheckOnNodeRightSide(T builder, bool value);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.DelayedSingleIndentingRule`1 : SingleIndentingRule`1<TSettingsKey> {
    private Func`3<VirtNode, CodeFormattingContext, VirtNode> myCheckUntilNodeGetter;
    private TemporaryIndentingRule<TSettingsKey> myTemporaryIndentingRule;
    [CompilerGeneratedAttribute]
private bool <CheckUntilNodeRightSide>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveAfterApplying>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckOnNodeRightSide>k__BackingField;
    public bool CheckUntilNodeRightSide { get; public set; }
    public bool RemoveAfterApplying { get; public set; }
    public bool CheckOnNodeRightSide { get; public set; }
    public DelayedSingleIndentingRule`1(string name, INodePattern whereToStartCheckPattern, Func`3<VirtNode, CodeFormattingContext, VirtNode> checkUntilNodeGetter, INodePattern openNodePattern, Func`3<VirtNode, CodeFormattingContext, VirtNode> closeNodeGetter, IOptionNode optionTree);
    [CompilerGeneratedAttribute]
public bool get_CheckUntilNodeRightSide();
    [CompilerGeneratedAttribute]
public void set_CheckUntilNodeRightSide(bool value);
    [CompilerGeneratedAttribute]
public bool get_RemoveAfterApplying();
    [CompilerGeneratedAttribute]
public void set_RemoveAfterApplying(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CheckOnNodeRightSide();
    [CompilerGeneratedAttribute]
public void set_CheckOnNodeRightSide(bool value);
    public sealed virtual ValueTuple`2<VirtNode, ITemporaryIndentingRule> GetTemporaryRule(VirtNode current, CodeFormattingContext context);
    public virtual VirtNode GetClosingNode(VirtNode node, CodeFormattingContext context);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.DelayedWrapGroupRule`1 : WrapGroupRule`1<TSettingsKey> {
    private Func`3<VirtNode, CodeFormattingContext, VirtNode> myCheckUntilNodeGetter;
    private TemporaryWrapGroupRule<TSettingsKey> myTemporaryWrapGroupRule;
    [CompilerGeneratedAttribute]
private bool <CheckUntilNodeRightSide>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveAfterApplying>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckOnNodeRightSide>k__BackingField;
    public bool CheckUntilNodeRightSide { get; public set; }
    public bool RemoveAfterApplying { get; public set; }
    public bool CheckOnNodeRightSide { get; public set; }
    public DelayedWrapGroupRule`1(string name, INodePattern whereToStartCheckPattern, Func`3<VirtNode, CodeFormattingContext, VirtNode> checkUntilNodeGetter, INodePattern openNodePattern, Func`3<VirtNode, CodeFormattingContext, VirtNode> closeNodeGetter, IOptionNode optionTree);
    [CompilerGeneratedAttribute]
public bool get_CheckUntilNodeRightSide();
    [CompilerGeneratedAttribute]
public void set_CheckUntilNodeRightSide(bool value);
    [CompilerGeneratedAttribute]
public bool get_RemoveAfterApplying();
    [CompilerGeneratedAttribute]
public void set_RemoveAfterApplying(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CheckOnNodeRightSide();
    [CompilerGeneratedAttribute]
public void set_CheckOnNodeRightSide(bool value);
    public sealed virtual ValueTuple`2<VirtNode, ITemporaryWrapGroupRule> GetTemporaryRule(VirtNode current, CodeFormattingContext context);
    public virtual VirtNode GetClosingNode(VirtNode node, CodeFormattingContext context);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.DelayedWrapRule : WrapRule {
    [CompilerGeneratedAttribute]
private BlankWithPattern <PatternToStartCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<VirtNode, CodeFormattingContext, VirtNode> <CheckUntilNodeGetter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckUntilNodeRightSide>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveAfterApplying>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckOnNodeRightSide>k__BackingField;
    public BlankWithPattern PatternToStartCheck { get; }
    public Func`3<VirtNode, CodeFormattingContext, VirtNode> CheckUntilNodeGetter { get; public set; }
    public bool CheckUntilNodeRightSide { get; public set; }
    public bool RemoveAfterApplying { get; public set; }
    public bool CheckOnNodeRightSide { get; public set; }
    [CompilerGeneratedAttribute]
public BlankWithPattern get_PatternToStartCheck();
    [CompilerGeneratedAttribute]
public Func`3<VirtNode, CodeFormattingContext, VirtNode> get_CheckUntilNodeGetter();
    [CompilerGeneratedAttribute]
public void set_CheckUntilNodeGetter(Func`3<VirtNode, CodeFormattingContext, VirtNode> value);
    [CompilerGeneratedAttribute]
public bool get_CheckUntilNodeRightSide();
    [CompilerGeneratedAttribute]
public void set_CheckUntilNodeRightSide(bool value);
    [CompilerGeneratedAttribute]
public bool get_RemoveAfterApplying();
    [CompilerGeneratedAttribute]
public void set_RemoveAfterApplying(bool value);
    [CompilerGeneratedAttribute]
public bool get_CheckOnNodeRightSide();
    [CompilerGeneratedAttribute]
public void set_CheckOnNodeRightSide(bool value);
    public virtual void Build(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.DelayedWrapRuleEx : object {
    [ExtensionAttribute]
public static TEnvelope WhereToStartCheck(TEnvelope builder, IBuilderAction`1[] builders);
    [ExtensionAttribute]
public static T CheckUntilNodeGetter(T builder, Func`3<VirtNode, CodeFormattingContext, VirtNode> checkUntilNodeGetter);
    [ExtensionAttribute]
public static T CheckUntilNodeRightSide(T builder, bool value);
    [ExtensionAttribute]
public static T RemoveAfterApplying(T builder, bool value);
    [ExtensionAttribute]
public static T CheckOnNodeRightSide(T builder, bool value);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.ElementListRule : ElementListRuleBase {
    [CompilerGeneratedAttribute]
private bool <ShrinkRegionToElements>k__BackingField;
    public bool ShrinkRegionToElements { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ShrinkRegionToElements();
    [CompilerGeneratedAttribute]
public void set_ShrinkRegionToElements(bool value);
    public virtual void Build(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
}
public abstract class JetBrains.ReSharper.Psi.Impl.CodeStyle.ElementListRuleBase : RuleBlankBase {
    protected ElementData CurrentElementData;
    [CompilerGeneratedAttribute]
private TokenNodeType <Comma>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeType <CommaAndElementParent>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeTypeSet <Comments>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuilder`1<NodePatternBlank> <Elements>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <MaxBlankLinesInsideSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <WrapBeforeCommaSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <WrapSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <MaxElementsOnLine>k__BackingField;
    [CompilerGeneratedAttribute]
private ChopElements <ChopElements>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <KeepExistingArrangementSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DontForce>k__BackingField;
    [CompilerGeneratedAttribute]
private KeepTogetherPolicy <KeepTogetherPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LineBreakBeforeElementIfMultiline>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LineBreakAfterElementIfMultiline>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ListLineBreaksHighlighting>k__BackingField;
    public TokenNodeType Comma { get; public set; }
    public NodeType CommaAndElementParent { get; public set; }
    public NodeTypeSet Comments { get; public set; }
    public IBuilder`1<NodePatternBlank> Elements { get; public set; }
    public int Priority { get; public set; }
    public LambdaExpression MaxBlankLinesInsideSetting { get; public set; }
    public LambdaExpression WrapBeforeCommaSetting { get; public set; }
    public LambdaExpression WrapSetting { get; public set; }
    public LambdaExpression MaxElementsOnLine { get; public set; }
    public ChopElements ChopElements { get; public set; }
    public LambdaExpression KeepExistingArrangementSetting { get; public set; }
    public bool DontForce { get; public set; }
    public KeepTogetherPolicy KeepTogetherPolicy { get; public set; }
    public bool LineBreakBeforeElementIfMultiline { get; public set; }
    public bool LineBreakAfterElementIfMultiline { get; public set; }
    public string ListLineBreaksHighlighting { get; public set; }
    [CompilerGeneratedAttribute]
public TokenNodeType get_Comma();
    [CompilerGeneratedAttribute]
public void set_Comma(TokenNodeType value);
    [CompilerGeneratedAttribute]
public NodeType get_CommaAndElementParent();
    [CompilerGeneratedAttribute]
public void set_CommaAndElementParent(NodeType value);
    [CompilerGeneratedAttribute]
public NodeTypeSet get_Comments();
    [CompilerGeneratedAttribute]
public void set_Comments(NodeTypeSet value);
    [CompilerGeneratedAttribute]
public IBuilder`1<NodePatternBlank> get_Elements();
    [CompilerGeneratedAttribute]
public void set_Elements(IBuilder`1<NodePatternBlank> value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Priority(int value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_MaxBlankLinesInsideSetting();
    [CompilerGeneratedAttribute]
public void set_MaxBlankLinesInsideSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_WrapBeforeCommaSetting();
    [CompilerGeneratedAttribute]
public void set_WrapBeforeCommaSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_WrapSetting();
    [CompilerGeneratedAttribute]
public void set_WrapSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_MaxElementsOnLine();
    [CompilerGeneratedAttribute]
public void set_MaxElementsOnLine(LambdaExpression value);
    [CompilerGeneratedAttribute]
public ChopElements get_ChopElements();
    [CompilerGeneratedAttribute]
public void set_ChopElements(ChopElements value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_KeepExistingArrangementSetting();
    [CompilerGeneratedAttribute]
public void set_KeepExistingArrangementSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public bool get_DontForce();
    [CompilerGeneratedAttribute]
public void set_DontForce(bool value);
    [CompilerGeneratedAttribute]
public KeepTogetherPolicy get_KeepTogetherPolicy();
    [CompilerGeneratedAttribute]
public void set_KeepTogetherPolicy(KeepTogetherPolicy value);
    [CompilerGeneratedAttribute]
public bool get_LineBreakBeforeElementIfMultiline();
    [CompilerGeneratedAttribute]
public void set_LineBreakBeforeElementIfMultiline(bool value);
    [CompilerGeneratedAttribute]
public bool get_LineBreakAfterElementIfMultiline();
    [CompilerGeneratedAttribute]
public void set_LineBreakAfterElementIfMultiline(bool value);
    [CompilerGeneratedAttribute]
public string get_ListLineBreaksHighlighting();
    [CompilerGeneratedAttribute]
public void set_ListLineBreaksHighlighting(string value);
    public virtual void Build(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
    private void CreateKeepTogetherRegion(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider, ChildBuilder`2<IBlankWithSinglePattern, NodePatternBlank> condition, Nullable`1<bool> beforeComma, Func`3<VirtNode, CodeFormattingContext, VirtNode> closeNodeGetter);
    private ChildBuilder`2<IBlankWithSinglePattern, NodePatternBlank> GetElementCondition(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider, ElementData data, bool checkExceptFirstElement, bool checkExceptOnlyElement, bool checkExceptFirstLine);
    private void AddRulesForElements(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider, int basePriority);
    private void AddWrapRulesForComma(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider, int basePriority);
    private void AddRulesForComma(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider, string name, int priority, long group, IBuildableBuilder`1[] options);
    private void AddRulesForCommaForMaxElements(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider, ElementData data, int basePriority);
    internal virtual IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> AddWrapOption(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider, IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, bool forElementsAndComma);
    internal virtual IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> AddNoWrapOption(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider, IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, bool forElementsAndComma);
    protected void CreateWrapRegionFromWrapSetting(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider, bool shrinkRegionToElements);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.ElementListRuleBaseEx : object {
    [ExtensionAttribute]
internal static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> Wrap(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, ElementListRuleBase rule, FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider, bool forElementsAndComma);
    [ExtensionAttribute]
internal static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> NoWrap(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, ElementListRuleBase rule, FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider, bool forElementsAndComma);
    [ExtensionAttribute]
internal static T InsideElementParent(T builder, ElementListRuleBase rule, FormatterInfoProviderBase provider);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> MaxBlankLinesInsideSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> WrapBeforeCommaSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static T Comma(T builder, TokenNodeType comma);
    [ExtensionAttribute]
public static T CommaAndElementParent(T builder, NodeType commaParent);
    [ExtensionAttribute]
public static T ChopElements(T builder, ChopElements value);
    [ExtensionAttribute]
public static T ListLineBreaksHighlighting(T builder, string value);
    [ExtensionAttribute]
public static T Comments(T builder, NodeTypeSet comments);
    [ExtensionAttribute]
public static T Elements(T builder, NodeTypeSet elements);
    [ExtensionAttribute]
public static T Elements(T builder, IBuilder`1<NodePatternBlank> elements);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> WrapSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> MaxElementsOnLine(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static T KeepTogetherPolicy(T builder, KeepTogetherPolicy value);
    [ExtensionAttribute]
public static T LineBreakAfterElementIfMultiline(T builder, bool value);
    [ExtensionAttribute]
public static T LineBreakBeforeElementIfMultiline(T builder, bool value);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> KeepExistingArrangementSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static T DontForce(T builder, bool value);
    [ExtensionAttribute]
public static T ShrinkRegionToElements(T builder, bool value);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.EmptyNodePattern : object {
    public static EmptyNodePattern Instance;
    public int PerformanceRating { get; }
    private static EmptyNodePattern();
    public sealed virtual IEnumerable`1<NodeType> GetNodeTypes();
    public sealed virtual bool Matches(ITreeNode node, CodeFormattingContext context);
    public virtual string ToString();
    public sealed virtual int get_PerformanceRating();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.FmtCachedSettings`1 : CachedSettings`1<TKeyClass> {
    [CompilerGeneratedAttribute]
private IFormatterInfoProvider <Provider>k__BackingField;
    public IFormatterInfoProvider Provider { get; }
    public FmtCachedSettings`1(IContextBoundSettingsStore settingsStore, ICalculatedSettingsSchema schema, IFormatterInfoProvider provider);
    [CompilerGeneratedAttribute]
public IFormatterInfoProvider get_Provider();
    public virtual FmtCachedSettings`1<TKeyClass> Clone();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.FmtCachedSettingsOverriden`2 : FmtCachedSettings`1<TSettingsClassBase> {
    private string myBaseKeyName;
    private string myDerivedKeyName;
    public FmtCachedSettingsOverriden`2(IContextBoundSettingsStore settingsStore, ICalculatedSettingsSchema schema, IFormatterInfoProvider provider);
    private string FixName(string sKeyLocalName);
    public virtual TEntryValue GetValue(IScalarSetting`1<TEntryValue> setting);
    public virtual object GetValueUntyped(IScalarSetting setting);
    private TSetting ConvertSetting(TSetting setting);
    protected virtual void SetValue(TKey key, TValue value);
    public virtual FmtCachedSettings`1<TSettingsClassBase> Clone();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.FmtSettingsClassic`1 : object {
    [CompilerGeneratedAttribute]
private TSettingsKey <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private TSettingsKey <InitialSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private IContextBoundSettingsStore <Store>k__BackingField;
    [CompilerGeneratedAttribute]
private CommonFormatterSettingsKey <CommonSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private LineEnding <LineEnding>k__BackingField;
    public TSettingsKey Settings { get; }
    public TSettingsKey InitialSettings { get; }
    public IContextBoundSettingsStore Store { get; }
    public CommonFormatterSettingsKey CommonSettings { get; }
    public LineEnding LineEnding { get; }
    public FmtSettingsClassic`1(TSettingsKey settings, CommonFormatterSettingsKey commonSettings, IContextBoundSettingsStore store, LineEnding lineEnding, TSettingsKey initialSettings);
    [CompilerGeneratedAttribute]
public TSettingsKey get_Settings();
    [CompilerGeneratedAttribute]
public TSettingsKey get_InitialSettings();
    [CompilerGeneratedAttribute]
public IContextBoundSettingsStore get_Store();
    [CompilerGeneratedAttribute]
public CommonFormatterSettingsKey get_CommonSettings();
    [CompilerGeneratedAttribute]
public LineEnding get_LineEnding();
    public FmtSettingsClassic`1<TSettingsKey> ChangeMainSettings(TSettingsKey key, bool updateInitial);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.FmtSettingsHolder`1 : object {
    [CompilerGeneratedAttribute]
private FmtCachedSettings`1<TSettingsKey> <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private FmtCachedSettings`1<TSettingsKey> <SettingsWithModificationsFromComments>k__BackingField;
    [CompilerGeneratedAttribute]
private FmtCachedSettings`1<TSettingsKey> <InitialSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private IContextBoundSettingsStore <Store>k__BackingField;
    [CompilerGeneratedAttribute]
private CachedSettings`1<CommonFormatterSettingsKey> <CommonSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private LineEnding <LineEnding>k__BackingField;
    public FmtCachedSettings`1<TSettingsKey> Settings { get; }
    public FmtCachedSettings`1<TSettingsKey> SettingsWithModificationsFromComments { get; }
    public FmtCachedSettings`1<TSettingsKey> InitialSettings { get; }
    public IContextBoundSettingsStore Store { get; }
    public CachedSettings`1<CommonFormatterSettingsKey> CommonSettings { get; }
    public LineEnding LineEnding { get; }
    public FmtSettingsHolder`1(FmtCachedSettings`1<TSettingsKey> settings, CachedSettings`1<CommonFormatterSettingsKey> commonSettings, IContextBoundSettingsStore store, LineEnding lineEnding, FmtCachedSettings`1<TSettingsKey> initialSettings, FmtCachedSettings`1<TSettingsKey> settingsWithModificationsFromComments);
    [CompilerGeneratedAttribute]
public FmtCachedSettings`1<TSettingsKey> get_Settings();
    [CompilerGeneratedAttribute]
public FmtCachedSettings`1<TSettingsKey> get_SettingsWithModificationsFromComments();
    [CompilerGeneratedAttribute]
public FmtCachedSettings`1<TSettingsKey> get_InitialSettings();
    [CompilerGeneratedAttribute]
public IContextBoundSettingsStore get_Store();
    [CompilerGeneratedAttribute]
public CachedSettings`1<CommonFormatterSettingsKey> get_CommonSettings();
    [CompilerGeneratedAttribute]
public LineEnding get_LineEnding();
    public FmtSettingsHolder`1<TSettingsKey> ChangeMainSettings(FmtCachedSettings`1<TSettingsKey> settings, FmtCachedSettings`1<TSettingsKey> settingsWithModificationsFromComments);
}
public enum JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatMismatchType : Enum {
    public int value__;
    public static FormatMismatchType MissingLinebreak;
    public static FormatMismatchType MissingSpace;
    public static FormatMismatchType RedundantLinebreak;
    public static FormatMismatchType RedundantSpace;
    public static FormatMismatchType MultipleSpacesOrTabs;
    public static FormatMismatchType None;
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatOptionValue : object {
    [CompilerGeneratedAttribute]
private IntervalFormatType <SpaceType>k__BackingField;
    public IntervalFormatType SpaceType { get; }
    public FormatOptionValue(IntervalFormatType spaceType);
    [CompilerGeneratedAttribute]
public sealed virtual IntervalFormatType get_SpaceType();
    public sealed virtual IFormatOptionValue Merge(IFormatOptionValue lowPriority, bool alwaysMerge, MergeKind& mergeKind);
    private bool AllowInherit(IFormatOptionValue lowPriority);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatResult`1 : object {
    private FormattingRange myRange;
    private T myResult;
    public FormattingRange Range { get; }
    public T ResultValue { get; }
    public FormatResult`1(FormattingRange range, T result);
    public FormattingRange get_Range();
    public T get_ResultValue();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatSettingsService`1 : object {
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private IFormatterDebugInfoLoggersProvider <FormatterLoggerProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettingsOptimization <SettingsOptimization>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeFormatterRequirements <Requirements>k__BackingField;
    [CompilerGeneratedAttribute]
private SettingsKey <SettingsKey>k__BackingField;
    public PsiLanguageType LanguageType { get; }
    protected IFormatterDebugInfoLoggersProvider FormatterLoggerProvider { get; }
    protected ISettingsOptimization SettingsOptimization { get; }
    protected internal CodeFormatterRequirements Requirements { get; }
    protected internal SettingsKey SettingsKey { get; }
    public FormatSettingsService`1(PsiLanguageType languageType, CodeFormatterRequirements requirements);
    [CompilerGeneratedAttribute]
public sealed virtual PsiLanguageType get_LanguageType();
    [CompilerGeneratedAttribute]
protected IFormatterDebugInfoLoggersProvider get_FormatterLoggerProvider();
    [CompilerGeneratedAttribute]
protected ISettingsOptimization get_SettingsOptimization();
    [CompilerGeneratedAttribute]
protected internal CodeFormatterRequirements get_Requirements();
    [CompilerGeneratedAttribute]
protected internal SettingsKey get_SettingsKey();
    protected static IContextBoundSettingsStore GetProperContextBoundSettingsStore(IContextBoundSettingsStore overrideSettingsStore, ITreeNode firstNode);
    protected static IContextBoundSettingsStore GetProperContextBoundSettingsStoreNoEc(IContextBoundSettingsStore overrideSettingsStore, ITreeNode firstNode);
    private void UseIndentsFromVS(ISolution solution, IPsiSourceFile sourceFile, IContextBoundSettingsStore settingsStore, FormatSettingsKeyBase settingsToUpdate);
    public virtual Type GetSettingsKeyType();
    [NotNullAttribute]
protected TSettingsKey GetFormatterTypedSettings(ISolution solution, IPsiSourceFile sourceFile, IContextBoundSettingsStore settingsStore, bool autodetectIndentSettings);
    [NotNullAttribute]
protected FmtCachedSettings`1<TSettingsKey> GetFormatterCachedSettings(ISolution solution, IPsiSourceFile sourceFile, IContextBoundSettingsStore settingsStore, bool autodetectIndentSettings, IFormatterInfoProvider provider);
    [NotNullAttribute]
protected FmtCachedSettings`1<TSettingsKey> GetFormatterCachedSettingsForVirtualFormatting(ISolution solution, IPsiSourceFile sourceFile, IContextBoundSettingsStore settingsStore, bool autodetectIndentSettings, IFormatterInfoProvider provider);
    protected void UpdateFmtSettingsFromVsAndMainFile(ISolution solution, IPsiSourceFile sourceFile, IContextBoundSettingsStore settingsStore, bool autodetectIndentSettings, IFormatterInfoProvider provider, FmtCachedSettings`1<TSettingsKey> result);
    private void UpdateFormatterSettings(ISolution solution, IPsiSourceFile sourceFile, IContextBoundSettingsStore settingsStore, bool autodetectIndentSettings, FormatSettingsKeyBase settingsToUpdate);
    protected internal virtual void AdjustExternalSettings(FormatSettingsKeyBase result);
    public sealed virtual FormatSettingsKeyBase GetFormatterSettings(ISolution solution, IPsiSourceFile sourceFile, IContextBoundSettingsStore settingsStore, bool autodetectIndentSettings);
    private T UpdateSettingsWithCookie(T obj, IPsiServices services);
    private void UpdateCachedSettingsWithCookie(CachedSettings`1<T> obj, IPsiServices services);
    public FmtSettingsHolder`1<TSettingsKey> GetFormattingSettings(ITreeNode node, AdditionalFormatterParameters parameters, IFormatterInfoProvider provider);
    protected FmtSettingsHolder`1<TSettingsKey> GetFormattingSettings(ITreeNode node, AdditionalFormatterParameters parameters, IPsiSourceFile sourceFile, IContextBoundSettingsStore settingsStore, LineEnding lineEnding, IFormatterInfoProvider provider);
    protected FmtSettingsHolder`1<TSettingsKey> GetFormattingSettingsForVirtualFormatting(ITreeNode node, AdditionalFormatterParameters parameters, IPsiSourceFile sourceFile, IContextBoundSettingsStore settingsStore, LineEnding lineEnding, IFormatterInfoProvider provider);
    public FmtSettingsClassic`1<TSettingsKey> GetFormattingSettingsClassic(ITreeNode node, AdditionalFormatterParameters parameters);
    protected FmtSettingsClassic`1<TSettingsKey> GetFormattingSettingsClassic(ITreeNode node, AdditionalFormatterParameters parameters, IPsiSourceFile sourceFile, IContextBoundSettingsStore settingsStore, LineEnding lineEnding);
    protected static ValueTuple`3<IContextBoundSettingsStore, IPsiSourceFile, LineEnding> PrepareSettingsData(ITreeNode node, AdditionalFormatterParameters parameters);
    protected static ValueTuple`3<IContextBoundSettingsStore, IPsiSourceFile, LineEnding> PrepareSettingsDataForVirtualFormatting(ITreeNode node, AdditionalFormatterParameters parameters, bool useContextDependantConfig);
    public sealed virtual IScalarSetting`1<TValue> GetEntry(Expression`1<Func`2<FormatSettingsKeyBase, TValue>> expression);
    public sealed virtual IProperty`1<FormatSettingsKeyBase> GetFormatterSettingsLive(Lifetime lifetime, ISolution solution, IPsiSourceFile sourceFile);
}
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterDebugInfoLoggersProvider : object {
    [CompilerGeneratedAttribute]
private IFormatterDebugInfoLogger <FormatterLogger>k__BackingField;
    public IFormatterDebugInfoLogger FormatterLogger { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IFormatterDebugInfoLogger get_FormatterLogger();
    [CompilerGeneratedAttribute]
public void set_FormatterLogger(IFormatterDebugInfoLogger value);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper : object {
    public static ILogger ourLogger;
    public static String[] NoSpace;
    public static String[] SingleSpace;
    public static String[] NewLine;
    public static Func`2<ITreeNode, bool> ourLengthGreaterThanZero;
    public static string ProhibitHighlighting;
    private static ElementsCache`2<string, StringBuffer> ourWhitespacesPool;
    public static StringBuffer SpaceBuffer;
    private static FormatterImplHelper();
    public static void AddSpaceBetween(ITokenNode token1, ITokenNode token2, ITokenNode separator);
    [ExtensionAttribute]
public static ParentWithDirections GetCommonParentWithDirections(ITreeNode node1, ITreeNode node2);
    private static StringBuilder GetRangeText(FormattingRange range);
    public static void ReplaceSpaces(ITreeNode leftNode, ITreeNode rightNode, IEnumerable`1<string> wsTexts, CodeFormattingContext context, FmtSettingsClassic`1<TKey> settings, bool processMinimalSeparator, bool processLineBreaksDisable);
    public static void CheckForMinimumSeparator(ICodeFormatterImpl codeFormatter, ITreeNode first, ITreeNode last);
    public static void CheckForMinimumSeparator(ICodeFormatterImpl codeFormatter, ITreeNode newNode);
    public static void ReplaceSpaces(ITreeNode leftNode, ITreeNode rightNode, ITreeNode[] wsNodes, bool allowLineBreakChanges, bool adjustLeadingSpace, bool allowLineBreakRemoval, bool compareTexts);
    [ExtensionAttribute]
private static int CountLineBreaks(StringBuilder sb);
    [ExtensionAttribute]
private static StringBuilder GetTextFromNodes(ITreeNode[] wsNodes);
    [ExtensionAttribute]
public static void AddSpacesInPlaceOfNode(StringBuilder sb, ITreeNode node, bool prepend);
    [ExtensionAttribute]
public static void TrimRight(ITreeNode node, IWhitespaceChecker checker, Func`2<ITokenNode, bool> setChecker);
    [ExtensionAttribute]
public static void TrimLeft(ITreeNode node, IWhitespaceChecker checker, Func`2<ITokenNode, bool> setChecker);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper/<LeftFormattableSiblings>d__19")]
[ExtensionAttribute]
private static IEnumerable`1<ITreeNode> LeftFormattableSiblings(ITreeNode startNode, Func`2<ITreeNode, ITreeNode> getPrevSibling);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper/<RightFormattableSiblings>d__20")]
[ExtensionAttribute]
private static IEnumerable`1<ITreeNode> RightFormattableSiblings(ITreeNode startNode, Func`2<ITreeNode, ITreeNode> getNextSibling);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper/<SelfAndLeftFormattableSiblings>d__21")]
[ExtensionAttribute]
private static IEnumerable`1<ITreeNode> SelfAndLeftFormattableSiblings(ITreeNode startNode, Func`2<ITreeNode, ITreeNode> getPrevSibling);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper/<SelfAndRightFormattableSiblings>d__22")]
[ExtensionAttribute]
private static IEnumerable`1<ITreeNode> SelfAndRightFormattableSiblings(ITreeNode startNode, Func`2<ITreeNode, ITreeNode> getNextSibling);
    [ExtensionAttribute]
public static ITreeNode GetSelfOrFirstDescendant(ITreeNode node);
    [ExtensionAttribute]
public static ITreeNode GetSelfOrLastDescendant(ITreeNode node);
    private static bool IsWhitespace(ITreeNode node, Func`2<ITokenNode, bool> customChecker);
    [ExtensionAttribute]
public static Func`2<ITokenNode, bool> GetNodeTypeSetChecker(NodeTypeSet nodeTypeSet);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITreeNode FindFormattingRangeToLeft(ITreeNode node, IWhitespaceChecker checker);
    [ExtensionAttribute]
public static VirtNode FindFormattingRangeToLeft(VirtNode node);
    [ExtensionAttribute]
public static VirtNode FindFormattingRangeToRight(VirtNode node);
    [ExtensionAttribute]
[NotNullAttribute]
public static ITreeNode FindFormattingRangeToLeftNotNull(ITreeNode node, IWhitespaceChecker checker);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITreeNode FindFormattingRangeToLeft(ITreeNode node, Func`2<ITokenNode, bool> customChecker, Func`2<ITreeNode, ITreeNode> getPrevSibling);
    [ExtensionAttribute]
[NotNullAttribute]
public static ITreeNode FindFormattingRangeToLeftNotNull(ITreeNode node, Func`2<ITokenNode, bool> customChecker, Func`2<ITreeNode, ITreeNode> getPrevSibling);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITreeNode FindFormattingRangeToRight(ITreeNode node, IWhitespaceChecker checker);
    [ExtensionAttribute]
[NotNullAttribute]
public static ITreeNode FindFormattingRangeToRightNotNull(ITreeNode node, IWhitespaceChecker checker);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITreeNode FindFormattingRangeToRight(ITreeNode node, Func`2<ITokenNode, bool> customChecker, Func`2<ITreeNode, ITreeNode> getNextSibling);
    public static ITreeRange FindSolidInnerRange(ITreeNode nodeFirst, ITreeNode nodeLast, IWhitespaceChecker checker);
    [ExtensionAttribute]
public static FormattingRange FindFormattingRange(ITreeNode node, bool formatPrevSpaces, bool formatNextSpaces, Func`2<ITokenNode, bool> customChecker, Func`2<ITreeNode, ITreeNode> getPrevSibling, Func`2<ITreeNode, ITreeNode> getNextSibling);
    [NotNullAttribute]
public static StringBuffer GetPooledWhitespace(string wsText);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITreeNode GetNextChildlessNode(ITreeNode treeNode, IWhitespaceChecker whitespaceChecker);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITreeNode GetPreviousChildlessNode(ITreeNode treeNode, IWhitespaceChecker checker);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITokenNode SkipLeftWhitespaces(ITokenNode token);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITokenNode SkipLeftWhitespacesUntilFileFirstChild(ITokenNode token);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITreeNode SkipLeftWhitespacesAndZeroLength(ITreeNode node, IWhitespaceChecker checker);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITreeNode SkipLeftWhitespaces(ITreeNode node, IWhitespaceChecker checker);
    [ExtensionAttribute]
public static VirtNode SkipLeftWhitespaces(VirtNode node);
    [ExtensionAttribute]
public static VirtNode SkipRightWhitespaces(VirtNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITreeNode SkipLeftWhitespaces(ITreeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITokenNode SkipRightWhitespaces(ITokenNode token);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITreeNode SkipRightWhitespaces(ITreeNode node);
    [ExtensionAttribute]
[ContractAnnotationAttribute("node:null=>false")]
public static bool IsWhitespaceTokenOrZeroLength(IWhitespaceChecker checker, ITreeNode node);
    [ExtensionAttribute]
public static bool IsWhitespaceTokenOrZeroLength(VirtNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITreeNode SkipRightWhitespacesAndZeroLength(ITreeNode node, IWhitespaceChecker checker);
    [ExtensionAttribute]
public static IEnumerable`1<ITreeNode> LeftWhitespaces(ITreeNode node, Func`2<ITokenNode, bool> customChecker, Func`2<ITreeNode, ITreeNode> getPrevSibling);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper/<SelfAndLeftWhitespaces>d__56")]
[ExtensionAttribute]
public static IEnumerable`1<ITreeNode> SelfAndLeftWhitespaces(ITreeNode node, Func`2<ITokenNode, bool> customChecker, Func`2<ITreeNode, ITreeNode> getPrevSibling);
    [ExtensionAttribute]
public static IEnumerable`1<ITreeNode> RightWhitespaces(ITreeNode node, Func`2<ITokenNode, bool> customChecker, Func`2<ITreeNode, ITreeNode> getNextSibling);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper/<SelfAndRightWhitespaces>d__58")]
[ExtensionAttribute]
public static IEnumerable`1<ITreeNode> SelfAndRightWhitespaces(ITreeNode node, Func`2<ITokenNode, bool> customChecker, Func`2<ITreeNode, ITreeNode> getNextSibling);
    [ExtensionAttribute]
public static FrugalLocalList`1<ITreeNode> GetPureWhitespacesTo(ITreeNode fromNode, ITreeNode toNode, IWhitespaceChecker checker);
    [ExtensionAttribute]
public static FrugalLocalList`1<ITreeNode> GetWhitespacesTo(ITreeNode fromNode, ITreeNode toNode, IWhitespaceChecker checker);
    [ExtensionAttribute]
public static FrugalLocalList`1<VirtNode> GetWhitespacesTo(VirtNode fromNode, VirtNode toNode);
    [ExtensionAttribute]
public static FrugalLocalList`1<ITreeNode> GetLineFeedsTo(ITreeNode fromNode, ITreeNode toNode, IWhitespaceChecker checker);
    [ExtensionAttribute]
public static bool HasLineFeedsTo(ITreeNode fromNode, ITreeNode toNode, IWhitespaceChecker checker);
    [ExtensionAttribute]
public static int GetLineFeedsCountTo(ITreeNode fromNode, ITreeNode toNode, IWhitespaceChecker checker);
    [ExtensionAttribute]
public static int GetLineFeedsCount(FormattingStageContext context, IWhitespaceChecker checker);
    [ExtensionAttribute]
public static bool HasLineFeeds(FormattingStageContext context, IWhitespaceChecker checker);
    [ExtensionAttribute]
public static ITreeNode FindNodeToInsertIndentBefore(ITreeNode node, IWhitespaceChecker checker);
    [ExtensionAttribute]
public static VirtNode FindNodeToInsertIndentBefore(VirtNode node);
    [ExtensionAttribute]
public static bool IsFirstOnLine(ITreeNode node, IWhitespaceChecker checker);
    [ExtensionAttribute]
public static bool IsFirstOnLine(VirtNode node);
    [ExtensionAttribute]
public static bool HasNewLineBefore(VirtNode node, bool returnTrueForFile, bool skipZeroLengthNodes);
    [ExtensionAttribute]
public static VirtNode FindNewLineBefore(VirtNode node, bool returnTrueForFile, bool skipZeroLengthNodes);
    [ExtensionAttribute]
public static bool HasNewLineAfter(VirtNode node, bool skipZeroLengthNodes);
    [ExtensionAttribute]
public static bool HasNewLineBefore(ITreeNode node, IWhitespaceChecker checker, bool returnTrueForFile, bool skipZeroLengthNodes);
    [ExtensionAttribute]
public static bool HasWhitespaceBefore(ITreeNode node, IWhitespaceChecker checker);
    [ExtensionAttribute]
public static bool HasNewLineAfter(ITreeNode node, IWhitespaceChecker checker, bool skipZeroLengthNodes);
    [ExtensionAttribute]
public static int CountNewLinesBefore(ITreeNode node, IWhitespaceChecker checker, bool skipZeroLengthNodes);
    [ExtensionAttribute]
public static int CountNewLinesAfter(ITreeNode node, IWhitespaceChecker checker, bool skipZeroLengthNodes);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string GetLineIndent(ITreeNode node, IIndentCache indentCache);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string GetNodeIndent(ITreeNode node, IIndentCache indentCache);
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetIndent(ITreeNode node, IIndentCache indentCache, bool align);
    [ExtensionAttribute]
[ContractAnnotationAttribute("node:null=>false")]
public static bool IsIndentNode(ITreeNode node, IWhitespaceChecker checker, bool includePrefixCommentInIndent);
    [ExtensionAttribute]
public static void MakeIndent(ITreeNode indentNode, Whitespace indent, int tabWidth, ICodeFormatterImpl codeFormatter, LineEnding lineEnding, bool includePrefixCommentInIndent, CodeFormattingContext context);
    private static string CalcOrInsertIndent(Whitespace indent, int tabWidth, ICodeFormatterImpl codeFormatter, ITreeNode firstSpace, ITreeNode lastSpace, bool allWhitespaces);
    [ExtensionAttribute]
public static void MakeIndent(ITreeNode indentNode, string indent, ICodeFormatterImpl codeFormatter);
    [ExtensionAttribute]
public static bool IsIndentComment(ITreeNode node, IWhitespaceChecker codeFormatter);
    private static string GetWhitespacesAtIndex(IBuffer buffer, int index, Int32& charsAfterWhitespaces);
    public static Whitespace GetWhitespacesAtIndex(string s, int index, Int32& charsAfterWhitespaces, int tabWidth, int length);
    [ExtensionAttribute]
public static Whitespace CalcLineIndent(VirtNode node, int tabWidth, bool includePrefixCommentInIndent, bool ofNodeStart);
    [ExtensionAttribute]
public static string CalcLineIndent(ITreeNode node, IWhitespaceChecker codeFormatter, bool includePrefixCommentInIndent, bool ofNodeStart);
    [ExtensionAttribute]
public static string CalcLineIndent(ITreeNode node, IWhitespaceChecker codeFormatter, ITokenNode& firstTokenOnLine, bool includePrefixCommentInIndent, bool ofNodeStart);
    [ExtensionAttribute]
public static string CalcNodeIndent(ITreeNode node, IWhitespaceChecker codeFormatter, bool includeNode);
    [ExtensionAttribute]
public static string CalcNodeIndent(ITreeNode node, IWhitespaceChecker codeFormatter, ITokenNode& firstToken, Int32& lengthAfterIndent, bool includeNode);
    public static ValueTuple`3<bool, Whitespace, int> GetLastLineBreakInfo(string s, int tabWidth, int fromPosition);
    public static ValueTuple`2<bool, int> GetFirstLineBreakInfo(string s);
    [ExtensionAttribute]
public static Whitespace CalcNodeIndent(VirtNode node, int tabWidth, bool includeNode);
    [ExtensionAttribute]
public static Whitespace CalcNodeOrLineIndent(VirtNode node, int tabWidth, VirtNode& firstSolidToken, Int32& lengthAfterIndent, VirtNode& lineBreakNode, bool includeNode, bool lineIndent, bool includePrefixInComments, int fromPosition);
    public static string AddIndent(string sourceIndent, string addedIndent);
    public static string AddIndent(string sourceIndent, string addedIndent, string addedIndent1);
    [ExtensionAttribute]
public static int CountTabs(string s);
    [ExtensionAttribute]
public static Whitespace FixTabSpaceStyle(Whitespace alignment, CachedSettings settings, IFormatterInfoProvider provider);
    [ExtensionAttribute]
public static IndentDelta FixTabSpaceStyle(IndentDelta alignment, FmtCachedSettings`1<TKey> settings);
    public static string ConvertAlignmentFromSpacesToTabsIfNeeded(string alignment, FormatSettingsKeyBase settings);
    public static int RoundClosestOrLowDivide(int a, int divisor);
    public static void DecoratingIterateNodes(CodeFormattingContext context, IDecoratingStage formattingStage, VirtNode firstNode, VirtNode lastNode);
    private static void DecorateRange(CodeFormattingContext context, IDecoratingStage formattingStage, VirtNode node, VirtNode lastNode);
    private static bool DecorateSubTree(CodeFormattingContext context, VirtNode node, VirtNode lastNode, IDecoratingStage formattingStage);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper/<HierarchicalEnumNodes>d__108")]
public static IEnumerable`1<FormattingRange> HierarchicalEnumNodes(ITreeNode firstNode, ITreeNode lastNode, Func`2<ITokenNode, bool> customChecker, Func`2<ITreeNode, ITreeNode> getNextSibling);
    [ExtensionAttribute]
public static IEnumerable`1<FormattingRange> HierarchicalEnumNodes(CodeFormattingContext context);
    [ExtensionAttribute]
public static IEnumerable`1<FormattingRange> HierarchicalEnumNodes(FormattingRange range, Func`2<ITokenNode, bool> customChecker, Func`2<ITreeNode, ITreeNode> getNextSibling);
    public static void HierarchicalIterateNodes(ITreeNode firstNode, ITreeNode lastNode, IFormattingStage formattingStage, Func`2<ITokenNode, bool> customChecker, Func`2<ITreeNode, ITreeNode> getNextSibling);
    public static bool EnumNodesBetween(VirtNode firstNode, VirtNode lastNode, Func`2<VirtNode, bool> processor, bool goInsideFirstNode);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper/<SequentialEnumNodes>d__113")]
public static IEnumerable`1<FormattingRange> SequentialEnumNodes(ITreeNode firstNode, ITreeNode lastNode, Func`2<ITokenNode, bool> customChecker, Func`2<ITreeNode, ITreeNode> getNextSibling);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper/<SequentialEnumNodes>d__114")]
public static IEnumerable`1<ValueTuple`2<VirtNode, VirtNode>> SequentialEnumNodes(VirtNode firstNode, VirtNode lastNode);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterImplHelper/<SequentialEnumNodesBackwards>d__115")]
public static IEnumerable`1<ValueTuple`2<VirtNode, VirtNode>> SequentialEnumNodesBackwards(VirtNode firstNode, VirtNode lastNode);
    [ExtensionAttribute]
public static IEnumerable`1<FormattingRange> SequentialEnumNodes(CodeFormattingContext context);
    [ExtensionAttribute]
public static IEnumerable`1<FormattingRange> SequentialEnumNodes(FormattingRange range);
    public static void SequentialIterateNodes(ITreeNode firstNode, ITreeNode lastNode, IFormattingStage formattingStage, Func`2<ITreeNode, ITreeNode> getNextSibling);
    public static bool GetFormattingRangeForTextRange(ITreeNode file, TreeTextRange range, OuterSpaceFormatType formatSpacesBefore, OuterSpaceFormatType formatSpacesAfter, ITokenNode& tokenFirst, ITokenNode& tokenLast, bool allowSingleTokenTasks);
    public static void Format(IFile file, TreeTextRange range, CodeFormatProfile profile, OuterSpaceFormatType formatSpacesBefore, OuterSpaceFormatType formatSpacesAfter, AdditionalFormatterParameters parameters);
    [ExtensionAttribute]
public static int ComputeEndColumnOfNode(ITreeNode node, Func`2<ITokenNode, bool> hasLineBreak, Func`3<ITokenNode, bool, int> getTokenLength);
    [ExtensionAttribute]
public static int ComputeEndColumnOfNode(ITreeNode node, IWhitespaceChecker checker);
    [ExtensionAttribute]
public static Whitespace ComputeEndColumnOfNode(VirtNode node, int tabWidth);
    [ExtensionAttribute]
public static Whitespace ComputeEndColumnOfLine(VirtNode node, int tabWidth);
    [ExtensionAttribute]
public static int ComputeEndColumnOfLine(ITreeNode node, IWhitespaceChecker checker);
    [ExtensionAttribute]
public static int ComputeNodePosition(ITreeNode node, IWhitespaceChecker checker, ITokenNode token);
    [ExtensionAttribute]
public static int ComputeNodePosition(ITreeNode node, Func`2<ITokenNode, bool> hasLineBreak, Func`3<ITokenNode, bool, int> getTokenLength, ITokenNode token);
    [ExtensionAttribute]
public static int ComputeNodeLengthBeforeLineBreak(ITreeNode node, IWhitespaceChecker checker, ITokenNode token, Boolean& lineBreakEncountered);
    [ExtensionAttribute]
public static int ComputeNodeLengthBeforeLineBreak(ITreeNode node, Func`2<ITokenNode, bool> hasLineBreak, Func`3<ITokenNode, bool, int> getTokenLength, ITokenNode token, Boolean& lineBreakEncountered);
    [ExtensionAttribute]
public static int ComputeEndColumnOfNode(ITreeNode node, NodeTypeSet lineBreaks);
    [ExtensionAttribute]
public static bool ContainsLineBreak(ITreeNode node, IWhitespaceChecker checker);
    public static bool ContainsLineBreak(ITreeNode first, ITreeNode last, IWhitespaceChecker checker);
    [ExtensionAttribute]
public static int CountLineBreaks(VirtNode node);
    [ExtensionAttribute]
public static int CountLineBreakTokensBetween(VirtNode first, VirtNode last);
    [ExtensionAttribute]
public static int CountLineBreaks(ITreeNode node, IWhitespaceChecker checker);
    public static int CountLineBreaks(ITreeNode first, ITreeNode last, IWhitespaceChecker checker);
    [ExtensionAttribute]
public static bool HasLineBreakInside(ITreeNode node, IWhitespaceChecker checker);
    [ExtensionAttribute]
public static bool HasLineBreakInside(VirtNode node);
    public static bool ContainsLineBreak(VirtNode node1, VirtNode node2);
    [ExtensionAttribute]
public static bool ContainsLineBreak(VirtNode node);
    public static bool HasLineBreaksBetween(VirtNode node1, VirtNode node2);
    public static int HasLineBreaksBetween(VirtNode node1, VirtNode endNode1, VirtNode endNode2);
    public static bool HasLineBreaksBetween(ITreeNode node1, ITreeNode node2, IWhitespaceChecker checker);
    public static int HasLineBreaksBetween(ITreeNode startNode, ITreeNode endNode1, ITreeNode endNode2, IWhitespaceChecker checker);
    private static int SearchNewLineInSubTree(ITreeNode node, ITreeNode lastNode1, ITreeNode lastNode2, IWhitespaceChecker checker);
    public static bool HasTokenBetween(ITreeNode node1, ITreeNode node2, NodeTypeSet tokens, Func`2<ITreeNode, ITreeNode> getNextSibling);
    private static bool SearchTokenInSubTree(ITreeNode node, ITreeNode lastNode, NodeTypeSet tokens, Func`2<ITreeNode, ITreeNode> getNextSibling, Boolean& tokenFound);
    public static void MakeRangeConsistent(ITreeNode left, ITreeNode right);
    public static void ForeachResult(IEnumerable`1<FormatResult`1<T>> items, IProgressIndicator progress, Action`1<FormatResult`1<T>> action);
    [ExtensionAttribute]
public static FormatTask CreateFormatTask(IWhitespaceChecker checker, ITreeNode node, CodeFormatProfile profile);
    public static ITreeNode AdjustFirstNode(ICodeFormatterImpl codeFormatter, ITreeNode firstNode, ITreeNode lastNode);
    [ExtensionAttribute]
public static ITreeNode GetFirstNodeInTree(ITreeNode node);
    [ExtensionAttribute]
public static VirtNode GetFirstNodeInTree(VirtNode node);
    public static void RemoveExtraLines(ICodeFormatterImpl codeFormatter, ITreeNode parent, ITreeNode prevNode, ITreeNode nextNode);
    public static void FormatDeletedNodesHelper(ICodeFormatterImpl codeFormatter, ITreeNode parent, ITreeNode prevNode, ITreeNode nextNode, bool checkForNulls);
    public static void RestoreEolsForInsertedNodeRange(ICodeFormatterImpl codeFormatter, ITreeNode nodeFirst, ITreeNode nodeLast, ITreeRange origin);
    public static ITreeRange FormatInsertedRangeHelper(ICodeFormatterImpl formatter, ITreeNode nodeFirst, ITreeNode nodeLast, ITreeRange origin, bool restoreEols);
    public static void FormatInsertedNodesHelper(ICodeFormatterImpl codeFormatter, ITreeNode nodeFirst, ITreeNode nodeLast, bool formatSurround, bool indentSurround, Action`2<ITreeNode, ITreeNode> customFormatLeftOuterSpace, Action`2<ITreeNode, ITreeNode> customFormatRightOuterSpace);
    public static void FormatInsertedNodesHelperViaTasks(ICodeFormatterImpl codeFormatter, ITreeNode nodeFirst, ITreeNode nodeLast, bool formatSurround, bool indentSurround, Action`2<ITreeNode, ITreeNode> customFormatLeftOuterSpace, Action`3<ITreeNode, ITreeNode, ITreeNode> customFormatRightOuterSpace);
    [ExtensionAttribute]
public static string GetIndentViaDocument(ITreeNode originalNode);
    [ExtensionAttribute]
public static Whitespace GetIndentViaDocument(VirtNode originalNode);
    public static string TurnToWhitespace(string s);
    [ExtensionAttribute]
public static string GetIndentFromDocumentRange(DocumentRange documentRange);
    [ExtensionAttribute]
public static Whitespace GetWhitespaceIndentFromDocumentRange(DocumentRange documentRange);
    [ExtensionAttribute]
public static string GetLineIndentFromOriginalNode(ITreeNode originalNode, Func`2<ITreeNode, bool> isOurCodeToken, TreeOffset position);
    [ExtensionAttribute]
public static ProjectFileType GetProjectFileType(ITreeNode node);
    [ExtensionAttribute]
[NotNullAttribute]
public static ITreeNode[] CreateWhitespaces(CodeFormattingContext context, IEnumerable`1<string> wsTexts, LineEnding lineEnding, NodeType contextNodeType);
    public static bool AreBracesEmpty(TokenNodeType lBrace, TokenNodeType rBrace, VirtNode lBraceOrItsParent, CodeFormattingContext checker);
    public static ITreeNode GetLBrace(TokenNodeType lBrace, ITreeNode node);
    public static bool CheckSingleSignificantChildBetweenBracesSingleLine(ITreeNode openingBrace, IWhitespaceChecker checker, TokenNodeType rBrace, NodeTypeSet nodesThatNeedEol);
    public static bool CheckSingleSignificantChildBetweenBraces(ITreeNode openingBrace, IWhitespaceChecker checker, TokenNodeType rBrace);
    [ExtensionAttribute]
public static bool AreBracesEmpty(VirtNode openingBrace, CodeFormattingContext checker, TokenNodeType closingBraceType);
    [ExtensionAttribute]
public static bool AreBracesEmptyReverse(VirtNode closingBrace, CodeFormattingContext checker, TokenNodeType openingBraceType);
    [ExtensionAttribute]
public static bool AreBracesOnOneLine(VirtNode openingBrace, CodeFormattingContext context, TokenNodeType closingBraceType);
    [ExtensionAttribute]
public static bool AreBracesOnOneLineReverse(VirtNode closingBrace, CodeFormattingContext context, TokenNodeType openingBraceType);
    public static void RunFormatterForGeneratedLanguages(IFile originalFile, ITreeNode firstNode, ITreeNode lastNode, CodeFormatProfile profile, Predicate`1<PsiLanguageType> filter, PsiLanguageCategories categories, AdditionalFormatterParameters parameters);
    private static void RunFormatterForGeneratedLanguage(IPsiSourceFile sourceFile, PsiLanguageType language, DocumentRange range, CodeFormatProfile profile, PsiLanguageCategories categories, AdditionalFormatterParameters parameters);
    public static ITreeRangePointer CreateRangePointer(ITreeNode firstElement, ITreeNode lastElement);
    public static TreeRange PointerToRange(ITreeRangePointer pointer, ITreeNode firstElement, ITreeNode lastElement);
    [ExtensionAttribute]
public static FrugalLocalList`1<string> GetExistingLineBreaksAndIndentTo(ITreeNode lChild, ITreeNode rChild, IWhitespaceChecker checker);
    [ExtensionAttribute]
public static IntervalFormatType GetSpaceType(IFormatOptionValue a);
    [ExtensionAttribute]
public static bool Has(IntervalFormatType a, IntervalFormatType b);
    [ExtensionAttribute]
public static bool Has(WrapType a, WrapType b);
    [ExtensionAttribute]
public static bool Has(IndentType a, IndentType b);
    [ExtensionAttribute]
public static bool GetAllSettingsAndValues(IOptionNode optionTree, OneToSetMap`2<IScalarSetting, object> result, AutodetectSession session, object data, CodeFormattingContext context);
    [ExtensionAttribute]
public static Whitespace ToWhitespace(string str, int tabWidth);
    [ExtensionAttribute]
public static int ComparePositionTo(VirtNode node1, VirtNode node2, bool compareNodeEndPos);
    [ExtensionAttribute]
public static int ComparePositionToEx(VirtNode node1, VirtNode node2, bool useNode1End, bool useNode2End);
    public static int CompareSiblingNodesPosition(VirtNode node1, VirtNode node2);
    [ExtensionAttribute]
public static List`1<ValueTuple`2<IScalarSetting, object>> AddWithValue(List`1<ValueTuple`2<IScalarSetting, object>> list, IEnumerable`1<IScalarSetting> settings, object value);
    [ExtensionAttribute]
public static List`1<ValueTuple`2<IScalarSetting, object>> AddWithValue(List`1<ValueTuple`2<IScalarSetting, object>> list, FormatSettingsService`1<TSettingsKey> service, Expression`1<Func`2<TSettingsKey, TValue>> lambda, TValue value);
    public static FormatTask[] Translate(DocumentRangeFormatTask[] formatTasks, PsiLanguageType language, IPsiSourceFile sourceFile);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterInfoProviderBase : object {
    public static int WrapRuleGroup;
    public static int SpaceRuleGroup;
    public static int LineBreaksRuleGroup;
    public static int UserLineBreaksRuleGroup;
    public static int LineBreaksDependingOnLengthRuleGroup;
    public static int StandardRuleGroup;
    public static int ExtendedLineBreakGroup;
    public static int AllRuleGroup;
    public static int StageNumberMask;
    public static int MinLineBreaks;
    public static int MaxLineBreaks;
    public static int ParsAndBracesIndentGroup;
    public static int StatementIndentGroup;
    public static int ExpressionIndentGroup;
    public static int ParsAndBracesIndentGroup2;
    public static int NoMildLimitOnMaxBlankLines;
    public static int NoStrictLimitOnMaxBlankLines;
    public ChildBuilder`2<IBlankWithParentPattern, NodePatternBlank> GrandParent();
    public ChildBuilder`2<IBlankWithParentPattern, NodePatternBlank> Parent();
    public ChildBuilder`2<IBlankWithSinglePattern, NodePatternBlank> Node();
    public ChildBuilder`2<IBlankWithTwoPatterns, NodePatternBlank> Left();
    public ChildBuilder`2<IBlankWithTwoPatterns, NodePatternBlank> Right();
    public IBuilderAction`1<IBlankWithPredicate> If(Func`3<FormattingRangeContext, CodeFormattingContext, bool> predicate);
}
public abstract class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterInfoProviderBase`2 : FormatterInfoProviderBase {
    [CompilerGeneratedAttribute]
private bool <Finished>k__BackingField;
    protected TaskWithWorkStealing myTaskWithWorkStealing;
    private List`1<IFormattingRule`2<TSettingsKey, IFormatOptionValue>> myFormattingRules;
    private List`1<IFormattingRule`2<TSettingsKey, IBlankLinesOptionValue>> myBlankLinesRules;
    private List`1<IFormattingRule`2<TSettingsKey, IIntAlignOptionValue>> myIntAlignRules;
    private List`1<IWrapGroupRule> myWrappingRules;
    private List`1<IIndentingRule> myIndentingRules;
    private HashSet`1<IIndentingRule> myDelayedRules;
    private HashSet`1<IIndentingRule> myAlignmentRules;
    private RulesByTwoNodeTypesList`3<TSettingsKey, IFormatOptionValue, TContext> myFormattingRulesByNodeType;
    private RulesByNodeTypeList`1<IFormattingRule`2<TSettingsKey, IBlankLinesOptionValue>> myBlankLinesRulesByNodeType;
    private RulesByNodeTypeList`1<IWrapGroupRule> myWrappingRulesByNodeType;
    private RulesByNodeTypeList`1<IIndentingRule> myIndentingRulesByNodeTypeInternal;
    private RulesByNodeTypeList`1<IIndentingRule> myIndentingRulesByNodeTypeExternal;
    private Comparison`1<Pair`2<IIndentingRule, VirtNode>> myCachedComparer;
    [CompilerGeneratedAttribute]
private ISettingsSchema <SettingsSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private ICalculatedSettingsSchema <CalculatedSettingsSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private SettingsKey <SchemaKey>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<ExtraSpaces> <ExtraSpacesSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <WrapLinesSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <KeepUserWrappingSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<int> <WrapLimitSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<IndentStyle> <IndentStyleSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<int> <IndentSizeSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <AllowFarAlignmentSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<AlignmentTabFillStyle> <AlignmentTabFillStyleSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <UseIndentFromVsSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<int> <TabWidthSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <RemoveSpacesOnBlankLines>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <DisableLineBreakRemovalSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <DisableBlankLineChangesSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <DisableLineBreakChangesSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <DisableFormatterSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <DisableIndenterSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <DisableSpaceChangesSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <DisableIntAlignSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <IntAlignFixInAdjacent>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <FormatLeadingSpacesDeclSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting`1<bool> <UseIndentFromPreviousElementSetting>k__BackingField;
    protected bool Finished { get; protected set; }
    protected ISettingsSchema SettingsSchema { get; }
    protected ICalculatedSettingsSchema CalculatedSettingsSchema { get; }
    public SettingsKey SchemaKey { get; }
    public IScalarSetting`1<ExtraSpaces> ExtraSpacesSetting { get; private set; }
    public IScalarSetting`1<bool> WrapLinesSetting { get; private set; }
    public IScalarSetting`1<bool> KeepUserWrappingSetting { get; private set; }
    public IScalarSetting`1<int> WrapLimitSetting { get; private set; }
    public IScalarSetting`1<IndentStyle> IndentStyleSetting { get; private set; }
    public IScalarSetting`1<int> IndentSizeSetting { get; private set; }
    public IScalarSetting`1<bool> AllowFarAlignmentSetting { get; private set; }
    public IScalarSetting`1<AlignmentTabFillStyle> AlignmentTabFillStyleSetting { get; private set; }
    public IScalarSetting`1<bool> UseIndentFromVsSetting { get; private set; }
    public IScalarSetting`1<int> TabWidthSetting { get; private set; }
    public IScalarSetting`1<bool> RemoveSpacesOnBlankLines { get; private set; }
    public IScalarSetting`1<bool> DisableLineBreakRemovalSetting { get; private set; }
    public IScalarSetting`1<bool> DisableBlankLineChangesSetting { get; private set; }
    public IScalarSetting`1<bool> DisableLineBreakChangesSetting { get; private set; }
    public IScalarSetting`1<bool> DisableFormatterSetting { get; private set; }
    public IScalarSetting`1<bool> DisableIndenterSetting { get; private set; }
    public IScalarSetting`1<bool> DisableSpaceChangesSetting { get; private set; }
    public IScalarSetting`1<bool> DisableIntAlignSetting { get; private set; }
    public IScalarSetting`1<bool> IntAlignFixInAdjacent { get; private set; }
    public IScalarSetting`1<bool> FormatLeadingSpacesDeclSetting { get; private set; }
    public IScalarSetting`1<bool> UseIndentFromPreviousElementSetting { get; private set; }
    public ProjectFileType MainProjectFileType { get; }
    public bool UsesInheritedIntervalFormatType { get; }
    public bool NeedsAdditionalFormatStage { get; }
    protected bool RunInitializeTaskInBaseConstructor { get; }
    public bool ShouldCorrectCalculatedIndentsWithActual { get; }
    public bool ShouldFixAlignmentBeyondGivenRange { get; }
    public bool HasIntAlignRules { get; }
    protected FormatterInfoProviderBase`2(ISettingsSchema settingsSchema, ICalculatedSettingsSchema calculatedSettingsSchema, IThreading threading, Lifetime lifetime);
    [CompilerGeneratedAttribute]
protected bool get_Finished();
    [CompilerGeneratedAttribute]
protected void set_Finished(bool value);
    public object SettingKeyGetterInstance(object settings);
    [CompilerGeneratedAttribute]
protected ISettingsSchema get_SettingsSchema();
    [CompilerGeneratedAttribute]
protected ICalculatedSettingsSchema get_CalculatedSettingsSchema();
    [CompilerGeneratedAttribute]
public SettingsKey get_SchemaKey();
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<ExtraSpaces> get_ExtraSpacesSetting();
    [CompilerGeneratedAttribute]
private void set_ExtraSpacesSetting(IScalarSetting`1<ExtraSpaces> value);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<bool> get_WrapLinesSetting();
    [CompilerGeneratedAttribute]
private void set_WrapLinesSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<bool> get_KeepUserWrappingSetting();
    [CompilerGeneratedAttribute]
private void set_KeepUserWrappingSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<int> get_WrapLimitSetting();
    [CompilerGeneratedAttribute]
private void set_WrapLimitSetting(IScalarSetting`1<int> value);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<IndentStyle> get_IndentStyleSetting();
    [CompilerGeneratedAttribute]
private void set_IndentStyleSetting(IScalarSetting`1<IndentStyle> value);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<int> get_IndentSizeSetting();
    [CompilerGeneratedAttribute]
private void set_IndentSizeSetting(IScalarSetting`1<int> value);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<bool> get_AllowFarAlignmentSetting();
    [CompilerGeneratedAttribute]
private void set_AllowFarAlignmentSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<AlignmentTabFillStyle> get_AlignmentTabFillStyleSetting();
    [CompilerGeneratedAttribute]
private void set_AlignmentTabFillStyleSetting(IScalarSetting`1<AlignmentTabFillStyle> value);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<bool> get_UseIndentFromVsSetting();
    [CompilerGeneratedAttribute]
private void set_UseIndentFromVsSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<int> get_TabWidthSetting();
    [CompilerGeneratedAttribute]
private void set_TabWidthSetting(IScalarSetting`1<int> value);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<bool> get_RemoveSpacesOnBlankLines();
    [CompilerGeneratedAttribute]
private void set_RemoveSpacesOnBlankLines(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<bool> get_DisableLineBreakRemovalSetting();
    [CompilerGeneratedAttribute]
private void set_DisableLineBreakRemovalSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<bool> get_DisableBlankLineChangesSetting();
    [CompilerGeneratedAttribute]
private void set_DisableBlankLineChangesSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<bool> get_DisableLineBreakChangesSetting();
    [CompilerGeneratedAttribute]
private void set_DisableLineBreakChangesSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<bool> get_DisableFormatterSetting();
    [CompilerGeneratedAttribute]
private void set_DisableFormatterSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<bool> get_DisableIndenterSetting();
    [CompilerGeneratedAttribute]
private void set_DisableIndenterSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<bool> get_DisableSpaceChangesSetting();
    [CompilerGeneratedAttribute]
private void set_DisableSpaceChangesSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<bool> get_DisableIntAlignSetting();
    [CompilerGeneratedAttribute]
private void set_DisableIntAlignSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<bool> get_IntAlignFixInAdjacent();
    [CompilerGeneratedAttribute]
private void set_IntAlignFixInAdjacent(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<bool> get_FormatLeadingSpacesDeclSetting();
    [CompilerGeneratedAttribute]
private void set_FormatLeadingSpacesDeclSetting(IScalarSetting`1<bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting`1<bool> get_UseIndentFromPreviousElementSetting();
    [CompilerGeneratedAttribute]
private void set_UseIndentFromPreviousElementSetting(IScalarSetting`1<bool> value);
    public abstract virtual ProjectFileType get_MainProjectFileType();
    public virtual bool get_UsesInheritedIntervalFormatType();
    public virtual bool get_NeedsAdditionalFormatStage();
    protected static Expression`1<Func`2<TSettingsKey, object>> Setting(string setting);
    protected void RunInitializationTask();
    protected virtual bool get_RunInitializeTaskInBaseConstructor();
    protected virtual void Initialize();
    public IScalarSetting`1<TValue> ToSettingTyped(Expression`1<Func`2<TSettingsKey, TValue>> lambda);
    public IScalarSetting ToSetting(Expression`1<Func`2<TSettingsKey, TValue>> lambda);
    public IScalarSetting ToSetting(LambdaExpression lambda);
    public void RegisterFormattingRules(long group, IFormattingRule`2[] formattingRules);
    public void RegisterFormattingRule(IFormattingRule`2<TSettingsKey, IFormatOptionValue> formattingRule);
    public void RegisterBlankLinesRules(IFormattingRule`2[] formattingRules);
    public void RegisterIntAlignRules(IFormattingRule`2[] formattingRules);
    public void RegisterWrappingRules(IWrapGroupRule[] wrappingRules);
    public void RegisterIndentingRules(IIndentingRule[] indentingRules);
    public void RegisterIndentingRuleGroup(long group, IIndentingRule[] indentingRules);
    public virtual void FinishAddingRules();
    public sealed virtual void EnsureInitialization();
    public sealed virtual List`1<Pair`2<IWrapGroupRule, VirtNode>> FindWrappingRules(VirtNode node, WrapType typeMask, TContext context, TemporaryRules`1& temporaryRules);
    public sealed virtual void FindAndProcessWrappingRegions(VirtNode node, WrapType typeMask, IWrappingStage`1<TSettingsKey> callback, TContext context, int position, TemporaryRules`1& temporaryRules);
    public virtual FormattingStage`2<TContext, TSettingsKey> CreateStageForFirstPass(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IProgressIndicator progress, WrappingStage`2<TContext, TSettingsKey> wrappingStage);
    public virtual BlankLineStage`2<TContext, TSettingsKey> CreateBlankLineStage(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IProgressIndicator progress);
    public virtual IntAlignStage`2<TContext, TSettingsKey> CreateStageForIntAlign(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IProgressIndicator progress, HashSet`1<IScalarSetting`1<bool>> pureIntAlignSettings);
    public virtual VirtualIntAlignStage`2<TContext, TSettingsKey> CreateStageForVirtualIntAlign(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IProgressIndicator progress, HashSet`1<IScalarSetting`1<bool>> pureIntAlignSettings, IndentMap indentMap);
    public virtual WrappingStage`2<TContext, TSettingsKey> CreateStageForSecondPass(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IProgressIndicator progress, SequentialNodeIterator`2<TContext, TSettingsKey> iterator, IndentingStage`2<TContext, TSettingsKey> indentingStage);
    public sealed virtual IOptionValueQueryResult`1<IFormatOptionValue> FindFormattingOptionInternal(FormattingRangeContext interval, IFormatterStageBase`1<TSettingsKey> stage, TContext context, bool breakdownByRule);
    public sealed virtual List`1<IFormattingRule`2<TSettingsKey, IFormatOptionValue>> FindFormattingRules(FormattingRangeContext interval, TContext context);
    public sealed virtual List`1<IFormattingRule`2<TSettingsKey, IBlankLinesOptionValue>> FindBlankLinesRules(FormattingRangeContext interval, TContext context);
    public sealed virtual IBlankLinesOptionValue FindBlankLinesOption(FormattingRangeContext interval, IFormatterStageBase`1<TSettingsKey> stage, TContext context);
    public sealed virtual IOptionValueQueryResult`1<IBlankLinesOptionValue> FindBlankLinesOptionWithBreakdownByRule(FormattingRangeContext interval, IFormatterStageBase`1<TSettingsKey> stage, TContext context);
    public sealed virtual List`1<IFormattingRule`2<TSettingsKey, IIntAlignOptionValue>> FindIntAlignRules(FormattingRangeContext interval, TContext context);
    public sealed virtual IIntAlignOptionValue FindIntAlignOption(FormattingRangeContext interval, IFormatterStageBase`1<TSettingsKey> stage, TContext context);
    private sealed virtual override void JetBrains.ReSharper.Psi.Impl.CodeStyle.IFormatterInfoProvider<TContext,TSettingsKey>.FindAndProcessIndentingRegions(VirtNode node, IndentType typeMask, IIndentingStage`1<TSettingsKey> stage, TContext context, List`1<Pair`2<IIndentingRule, VirtNode>> sortedRules, TemporaryRules`1& temporaryRules);
    private void FilterAndSortRules(VirtNode node, TContext context, List`1<Pair`2<IIndentingRule, VirtNode>> result, TemporaryRules`1& temporaryRules, IFormatterDebugInfoLogger logger, IndentType typeMask, bool checkForLineBreaks);
    protected virtual bool Matches(IIndentingRule rule, VirtNode node, TContext context, VirtNode& closingNode);
    private static int CompareIndentingRules(Pair`2<IIndentingRule, VirtNode> x, Pair`2<IIndentingRule, VirtNode> y);
    public sealed virtual bool IsRuleDelayed(IIndentingRule rule);
    public sealed virtual bool IsRuleForAlignment(IIndentingRule rule);
    public sealed virtual List`1<Pair`2<IIndentingRule, VirtNode>> FindIndentingRules(VirtNode node, IndentType typeMask, TContext context, TemporaryRules`1& temporaryRules);
    private bool ProcessTempIndentingRuleProvider(VirtNode node, TContext context, TemporaryRules`1& temporaryRules, IIndentingRule rule, bool leftSide, IFormatterDebugInfoLogger debugInfoLogger);
    private bool ProcessTempWrapGroupRuleProvider(VirtNode node, TContext context, TemporaryRules`1& temporaryRules, IWrapGroupRule rule, Nullable`1<bool> leftSide, IFormatterDebugInfoLogger debugInfoLogger);
    private bool DoesRuleContainsLineBreak(VirtNode node, bool leftSide, TContext context, VirtNode closingNode);
    public sealed virtual bool ProcessQueryResultForIndent(VirtNode node, IndentType typeMask, IIndentingStage`1<TSettingsKey> callback, TContext context, IOptionValueQueryResult`1<IIndentOptionValue> queryResult, IIndentingRule rule, VirtNode closingNode);
    public virtual ITreeNode ThisOrPrecedingMacro(ITreeNode node, IWhitespaceChecker checker);
    public virtual VirtNode GetNextSiblingForIndenting(VirtNode node);
    public virtual bool NodeFromFirstMacroOnLine(ITreeNode node, IWhitespaceChecker checker, TContext context, ITreeNode& prototypeMacro);
    public virtual bool ReallyNeedIndent(ITreeNode node, IndentRegionInfo info, TContext context);
    public virtual bool IsNonEmptyMacroCall(ITreeNode node, TContext context);
    [CanBeNullAttribute]
public virtual ITreeNode GetContainingMacro(ITreeNode node);
    public virtual bool IncludePrefixCommentInIndent(IFormatterStageBase`1<TSettingsKey> stage);
    public virtual bool CustomReindentInsideMultilineNode(VirtNode node, IndentingStage`2<TContext, TSettingsKey> indentingStage);
    public virtual void AfterNodeEnd(ITreeNode node, TContext context);
    public virtual void BeforeDescendIntoNode(ITreeNode node, TContext context);
    public virtual void CustomTaskFinished(VirtNode& dontReallyFinishUntilThisNode, TContext context, VirtNode current);
    public virtual FormattingRangeContext AdjustFormattingRangeContext(FormattingRangeContext formattingRangeContext, TContext context);
    public virtual VirtNode ThisOrMacroForIndent(VirtNode node, int indent, Func`2<VirtNode, int> calcNodeIndent, TContext context, Boolean& disableIndent);
    public sealed virtual void MatchNode(VirtNode node, IndentType typeMask, IIndentingStage`1<TSettingsKey> callback, TContext context, IOptionValueQueryResult`1& queryResult, VirtNode& closingNode, IIndentingRule& rule1, List`1<Pair`2<IIndentingRule, VirtNode>> sortedRules, TemporaryRules`1& temporaryRules);
    public virtual ITreeNode GetPossibleIndentLeftBoundInsideNode(ITreeNode parent);
    public virtual ITreeNode GetPossibleIndentRightBoundInsideNode(ITreeNode parent);
    public virtual string GetOldIndent(ITreeNode node);
    public virtual bool ShouldReindentInsideNode(ITreeNode node);
    public virtual bool get_ShouldCorrectCalculatedIndentsWithActual();
    public virtual bool get_ShouldFixAlignmentBeyondGivenRange();
    public virtual void ModifyIndent(ITreeNode nodeToIndent, Nullable`1& indent, TContext context, IIndentingStage`1<TSettingsKey> callback, IndentType indentType);
    public virtual IndentingStage`2<TContext, TSettingsKey> CreateIndentingStage(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IProgressIndicator progress, SequentialNodeIterator`2<TContext, TSettingsKey> iterator);
    public virtual VirtualIndentingStage`2<TContext, TSettingsKey> CreateVirtualIndentingStage(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IProgressIndicator progress, bool onlyFixForInlayHints);
    public virtual AutoDetectIndentingStage`2<TContext, TSettingsKey> CreateAutoDetectIndentingStage(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IProgressIndicator progress, SequentialNodeIterator`2<TContext, TSettingsKey> iterator);
    public sealed virtual void RegisterUsedSetting(TContext context, IScalarSetting setting);
    public virtual bool CanCollapseUnusedRegions();
    public virtual bool RemoveUserBlankLinesInStrictMode();
    public virtual bool ShouldRemoveExtraBlankLines(IFormatterStageBase`1<TSettingsKey> stage, TContext context);
    public virtual ExtraSpaces GetExtraSpacesStyle(IFormatterStageBase`1<TSettingsKey> stage, TContext context);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterInfoProviderBase`2/<SettingsToIgnoreInAutodetect>d__192")]
public virtual IEnumerable`1<IScalarSetting> SettingsToIgnoreInAutodetect();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterInfoProviderBase`2/<SettingsNotToCalculateInAutodetect>d__193")]
public virtual IEnumerable`1<IScalarSetting> SettingsNotToCalculateInAutodetect();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterInfoProviderBase`2/<KeepExistingSettings>d__194")]
public virtual IEnumerable`1<IScalarSetting> KeepExistingSettings();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterInfoProviderBase`2/<PureIntAlignSettings>d__195")]
public virtual IEnumerable`1<IScalarSetting`1<bool>> PureIntAlignSettings();
    public sealed virtual bool get_HasIntAlignRules();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterInfoProviderBase`2/<SettingsForStrictAutodetectMode>d__198")]
public virtual IEnumerable`1<Pair`2<IScalarSetting, object>> SettingsForStrictAutodetectMode();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterInfoProviderBase`2/<AdditionalSettingValuesForAutodetect>d__199")]
public virtual IEnumerable`1<Pair`2<IScalarSetting, object>> AdditionalSettingValuesForAutodetect();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterInfoProviderBase`2/<GetSettingPreferences>d__200")]
public virtual IEnumerable`1<ValueTuple`3<object, int, IScalarSetting[]>> GetSettingPreferences();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterInfoProviderBase`2/<GetSettingPreferencesForNewLines>d__201")]
public virtual IEnumerable`1<ValueTuple`3<object, int, IScalarSetting[]>> GetSettingPreferencesForNewLines();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterInfoProviderBase`2/<GetSettingPriority>d__202")]
public virtual IEnumerable`1<ValueTuple`2<IScalarSetting, int>> GetSettingPriority();
    [CompilerGeneratedAttribute]
private void <.ctor>b__119_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__119_1();
    [CompilerGeneratedAttribute]
internal static void <FindAndProcessWrappingRegions>g__ProcessMatch|137_0(IWrapGroupRule rule, <>c__DisplayClass137_0& );
    [CompilerGeneratedAttribute]
internal static bool <MatchNode>g__ProcessMatch|174_0(IIndentingRule rule, VirtNode ruleClosingNode, IOptionValueQueryResult`1& queryresult, VirtNode& closingnode, IIndentingRule& rule1, <>c__DisplayClass174_0& );
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterInfoProviderEx : object {
    [ExtensionAttribute]
public static VirtNode ThisOrPrecedingMacro(IFormatterInfoProvider`2<TContext, TSettingsKey> provider, VirtNode node, TContext context);
}
public abstract class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterInfoProviderWithFluentApi`2 : FormatterInfoProviderWithMethodApi`2<TContext, TSettingsKey> {
    [CompilerGeneratedAttribute]
private IBuildableBuilder`1[] <SpaceOptionsBuilders>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuildableBuilder`1[] <OnlySpaceOptionsBuilders>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuildableBuilder`1[] <WrapOptionsBuilders>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuildableBuilder`1[] <WrapOptionsBuildersWithBonus>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuildableBuilder`1[] <NoWrapOptionsBuilders>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuildableBuilder`1[] <NoWrapStrictOptionsBuilders>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuildableBuilder`1[] <SimpleEmbeddedOptionsBuilders>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuildableBuilder`1[] <SimpleEmbeddedOptionsBuildersWithBonus>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuildableBuilder`1[] <AlignThroughOptionsBuilders>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuildableBuilder`1[] <AlignTillOptionsBuilders>k__BackingField;
    public IBuildableBuilder`1[] SpaceOptionsBuilders { get; private set; }
    public IBuildableBuilder`1[] OnlySpaceOptionsBuilders { get; private set; }
    public IBuildableBuilder`1[] WrapOptionsBuilders { get; private set; }
    public IBuildableBuilder`1[] WrapOptionsBuildersWithBonus { get; private set; }
    public IBuildableBuilder`1[] NoWrapOptionsBuilders { get; private set; }
    public IBuildableBuilder`1[] NoWrapStrictOptionsBuilders { get; private set; }
    public IBuildableBuilder`1[] SimpleEmbeddedOptionsBuilders { get; private set; }
    public IBuildableBuilder`1[] SimpleEmbeddedOptionsBuildersWithBonus { get; private set; }
    public IBuildableBuilder`1[] AlignThroughOptionsBuilders { get; private set; }
    public IBuildableBuilder`1[] AlignTillOptionsBuilders { get; private set; }
    protected FormatterInfoProviderWithFluentApi`2(ISettingsSchema settingsSchema, ICalculatedSettingsSchema calculatedSettingsSchema, IThreading threading, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public IBuildableBuilder`1[] get_SpaceOptionsBuilders();
    [CompilerGeneratedAttribute]
private void set_SpaceOptionsBuilders(IBuildableBuilder`1[] value);
    [CompilerGeneratedAttribute]
public IBuildableBuilder`1[] get_OnlySpaceOptionsBuilders();
    [CompilerGeneratedAttribute]
private void set_OnlySpaceOptionsBuilders(IBuildableBuilder`1[] value);
    [CompilerGeneratedAttribute]
public IBuildableBuilder`1[] get_WrapOptionsBuilders();
    [CompilerGeneratedAttribute]
private void set_WrapOptionsBuilders(IBuildableBuilder`1[] value);
    [CompilerGeneratedAttribute]
public IBuildableBuilder`1[] get_WrapOptionsBuildersWithBonus();
    [CompilerGeneratedAttribute]
private void set_WrapOptionsBuildersWithBonus(IBuildableBuilder`1[] value);
    [CompilerGeneratedAttribute]
public IBuildableBuilder`1[] get_NoWrapOptionsBuilders();
    [CompilerGeneratedAttribute]
private void set_NoWrapOptionsBuilders(IBuildableBuilder`1[] value);
    [CompilerGeneratedAttribute]
public IBuildableBuilder`1[] get_NoWrapStrictOptionsBuilders();
    [CompilerGeneratedAttribute]
private void set_NoWrapStrictOptionsBuilders(IBuildableBuilder`1[] value);
    [CompilerGeneratedAttribute]
public IBuildableBuilder`1[] get_SimpleEmbeddedOptionsBuilders();
    [CompilerGeneratedAttribute]
private void set_SimpleEmbeddedOptionsBuilders(IBuildableBuilder`1[] value);
    [CompilerGeneratedAttribute]
public IBuildableBuilder`1[] get_SimpleEmbeddedOptionsBuildersWithBonus();
    [CompilerGeneratedAttribute]
private void set_SimpleEmbeddedOptionsBuildersWithBonus(IBuildableBuilder`1[] value);
    [CompilerGeneratedAttribute]
public IBuildableBuilder`1[] get_AlignThroughOptionsBuilders();
    [CompilerGeneratedAttribute]
private void set_AlignThroughOptionsBuilders(IBuildableBuilder`1[] value);
    [CompilerGeneratedAttribute]
public IBuildableBuilder`1[] get_AlignTillOptionsBuilders();
    [CompilerGeneratedAttribute]
private void set_AlignTillOptionsBuilders(IBuildableBuilder`1[] value);
    protected virtual void Initialize();
    public virtual IBuilderWithProvider`3<TContext, TSettingsKey, T> Describe();
    public virtual IBuilderWithProviderAndExternalKey`4<TContext, TSettingsKey, TExternalSettingsKey, T> DescribeWithExternalKey();
    public IBuilderWithProvider`3<TContext, TSettingsKey, OptionTreeBlank> When(T[] values);
    public IBuilderWithProviderAndExternalKey`4<TContext, TSettingsKey, TExternalSettingsKey, OptionTreeBlank> When(T[] values);
    private static object GetWhenCase(T[] values);
    public IBuilderWithProvider`3<TContext, TSettingsKey, OptionTreeBlank> WhenMixed(Object[] values);
    public IBuilderWithProviderAndExternalKey`4<TContext, TSettingsKey, TExternalSettingsKey, OptionTreeBlank> WhenMixed(Object[] values);
    public static Func`3<VirtNode, CodeFormattingContext, bool> IsFirstNodeOfTypeSet(NodeTypeSet nodeTypeSet, bool mustBeManySuchNodes);
    public static bool IsFirstNodeOfItsTypeFromMany(VirtNode node, CodeFormattingContext wc);
    public static bool IsFirstNodeOfItsType(VirtNode node, CodeFormattingContext wc);
    public static bool IsLastNodeOfItsType(VirtNode node, CodeFormattingContext wc);
    public static VirtNode GetLastNodeWithSameType(VirtNode node);
    public static VirtNode GetLastNodeWithSameType(VirtNode node, CodeFormattingContext wc);
}
public abstract class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterInfoProviderWithFluentApiAndParts`2 : FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> {
    [CompilerGeneratedAttribute]
private IEnumerable`1<FormatterInfoProviderWithFluentApiPart`2<TContext, TSettingsKey>> <Parts>k__BackingField;
    [NotNullAttribute]
protected IEnumerable`1<FormatterInfoProviderWithFluentApiPart`2<TContext, TSettingsKey>> Parts { get; }
    protected bool RunInitializeTaskInBaseConstructor { get; }
    protected FormatterInfoProviderWithFluentApiAndParts`2(ISettingsSchema settingsSchema, ICalculatedSettingsSchema calculatedSettingsSchema, IThreading threading, Lifetime lifetime, IEnumerable`1<FormatterInfoProviderWithFluentApiPart`2<TContext, TSettingsKey>> formatterParts);
    [CompilerGeneratedAttribute]
protected IEnumerable`1<FormatterInfoProviderWithFluentApiPart`2<TContext, TSettingsKey>> get_Parts();
    protected virtual bool get_RunInitializeTaskInBaseConstructor();
    protected virtual void Initialize();
}
public abstract class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterInfoProviderWithFluentApiPart`2 : FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> {
    [CompilerGeneratedAttribute]
private FormatterInfoProviderWithFluentApiAndParts`2<TContext, TSettingsKey> <Host>k__BackingField;
    protected bool RunInitializeTaskInBaseConstructor { get; }
    private FormatterInfoProviderWithFluentApiAndParts`2<TContext, TSettingsKey> Host { get; private set; }
    protected FormatterInfoProviderWithFluentApiPart`2(ISettingsSchema settingsSchema, ICalculatedSettingsSchema calculatedSettingsSchema, IThreading threading, Lifetime lifetime);
    public sealed virtual IBuilderWithProvider`3<TContext, TSettingsKey, T> Describe();
    public sealed virtual IBuilderWithProviderAndExternalKey`4<TContext, TSettingsKey, TExternalSettingsKey, T> DescribeWithExternalKey();
    protected virtual bool get_RunInitializeTaskInBaseConstructor();
    [CompilerGeneratedAttribute]
private FormatterInfoProviderWithFluentApiAndParts`2<TContext, TSettingsKey> get_Host();
    [CompilerGeneratedAttribute]
private void set_Host(FormatterInfoProviderWithFluentApiAndParts`2<TContext, TSettingsKey> value);
    internal void SetHostAndInitialize(FormatterInfoProviderWithFluentApiAndParts`2<TContext, TSettingsKey> host);
}
public abstract class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterInfoProviderWithMethodApi`2 : FormatterInfoProviderBase`2<TContext, TSettingsKey> {
    public Pair`2[] SpaceOptions;
    public Pair`2[] OnlySpaceOptions;
    public Pair`2[] LineBreakOptions;
    protected FormatterInfoProviderWithMethodApi`2(ISettingsSchema settingsSchema, ICalculatedSettingsSchema calculatedSettingsSchema, IThreading threading, Lifetime lifetime);
    public INodePattern Node(INodePattern parentPattern);
    public INodePattern NodeOfType();
    public INodePattern NodeOfType(INodePattern parentPattern);
    public INodePattern Node(short childRole);
    public INodePattern Node(short childRole);
    public INodePattern Node(short childRole, Func`3<VirtNode, CodeFormattingContext, bool> predicate);
    public INodePattern Node(short childRole, INodePattern parentPattern);
    public INodePattern Node(NodeTypeSet nodeTypeSet);
    public INodePattern Node(NodeTypeSet nodeTypeSet, Func`3<VirtNode, CodeFormattingContext, bool> predicate);
    public INodePattern Node(NodeTypeSet nodeTypeSet, INodePattern parentPattern);
    public INodePattern Node(NodeTypeSet nodeTypeSet, INodePattern parentPattern, Func`3<VirtNode, CodeFormattingContext, bool> predicate);
    public INodePattern Node(NodeType nodeType, INodePattern parentPattern);
    public INodePattern Node(NodeType nodeType);
    public INodePattern Node(NodeType nodeType, Func`3<VirtNode, CodeFormattingContext, bool> predicate);
    public INodePattern Node(NodeType nodeType, INodePattern parentPattern, Func`3<VirtNode, CodeFormattingContext, bool> predicate);
    public INodePattern Node(NodeType nodeType);
    public static Pair`2<object, IOptionValue> OptionPair(object value, IOptionValue optionValue);
    public Pair`2<object, IOptionValue> Option(object value, IntervalFormatType spaceType);
    public Pair`2<object, IOptionValue> Option(object value, bool inherit, int minBlankLines, int maxBlankLinesMild, int maxBlankLinesStrict);
    public Pair`2<object, IOptionValue> Option(object value, Expression`1<Func`2<TSettingsKey, object>> setting, Pair`2[] extraOptions);
    public Pair`2<object, IOptionValue> Option(object value, Expression`1<Func`2<TSettingsKey, object>> setting, object defaultValue, Pair`2[] extraOptions);
    public IOptionNode Switch(Expression`1<Func`2<TSettingsKey, object>> setting, Pair`2[] settingValues);
    public IOptionNode SwitchBlankLines(Expression`1<Func`2<TSettingsKey, object>> setting, Pair`2[] settingValues);
    public IOptionNode MinMaxBlankLines(Expression`1<Func`2<TSettingsKey, object>> setting, bool inherit, BlankLineLimitKind limitKind);
    public IOptionNode Always(int minBlankLines, int maxBlankLinesMild, int maxBlankLinesStrict, bool inherit);
    public IOptionNode Always(IntervalFormatType spaceType);
    public Pair`2<object, IOptionValue> Option(object value, WrapType wrapType);
    protected static SingleIndentingRule`1<TSettingsKey> Indent(string name, INodePattern openNodePattern, INodePattern closeNodePattern, IndentType indentType);
    protected static SingleIndentingRule`1<TSettingsKey> Indent(string name, INodePattern openNodePattern, INodePattern closeNodePattern, IndentType indentType, int indent);
    protected static Pair`2<object, IOptionValue> Option(object value, IndentType indentType, int indent);
    protected static Pair`2<object, IOptionValue> Option(object value, IndentType indentType);
    protected static Pair`2<object, IOptionValue> Align(object value, IndentType indentType);
    public SingleIndentingRule`1<TSettingsKey> Indent(string name, INodePattern openNodePattern, INodePattern closeNodePattern, Expression`1<Func`2<TSettingsKey, object>> setting, Pair`2[] settingValueToRegion);
    public SingleIndentingRule`1<TSettingsKey> Indent(string name, INodePattern openNodePattern, INodePattern closeNodePattern, string setting, Pair`2[] settingValueToRegion);
    public SingleIndentingRule`1<TSettingsKey> Indent(string name, INodePattern openNodePattern, Func`3<VirtNode, CodeFormattingContext, VirtNode> closeNodeGetter, string setting, Pair`2[] settingValueToRegion);
    public IFormattingRule`2<TSettingsKey, IBlankLinesOptionValue> FormatBlankLines(string name, INodePattern parentPattern, INodePattern leftPattern, INodePattern rightPattern, Func`3<FormattingRangeContext, CodeFormattingContext, bool> predicate, IOptionNode optionTree, int priority);
    public void FormatAround(long group, string name, INodePattern parentPattern, INodePattern nodePattern, Func`3<FormattingRangeContext, CodeFormattingContext, bool> predicate, IOptionNode optionTreeLeft, IOptionNode optionTreeRight, int priority);
    public void FormatBetween(long group, string name, INodePattern parentPattern, INodePattern leftPattern, INodePattern rightPattern, Func`3<FormattingRangeContext, CodeFormattingContext, bool> predicate, IOptionNode optionTree, int priority);
    public IFormattingRule`2<TSettingsKey, IFormatOptionValue> FormatBetweenChildren(string name, INodePattern parentPattern, INodePattern leftPattern, INodePattern rightPattern, Func`3<FormattingRangeContext, CodeFormattingContext, bool> predicate, IOptionNode optionTree, int priority);
    public void FormatBeforeOrAfter(long group, string name, INodePattern parentPattern, INodePattern childPattern, Func`3<FormattingRangeContext, CodeFormattingContext, bool> predicate, Expression`1<Func`2<TSettingsKey, object>> selectorForBeforeOrAfter, bool valueForBefore, IOptionValue optionValueIfOptionHasCorrectValue, IOptionValue optionValueOtherwise, int priority);
    public IFormattingRule`2<TSettingsKey, IFormatOptionValue> FormatBetweenChildren(string name, INodePattern parentPattern, INodePattern leftPattern, INodePattern rightPattern, Func`3<FormattingRangeContext, CodeFormattingContext, bool> predicate, IOptionNode optionTree);
}
public abstract class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterStageBase`2 : object {
    [CompilerGeneratedAttribute]
private FmtSettingsHolder`1<TSettingsKey> <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private TContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettingValueReader`1<TSettingsKey> <Reader>k__BackingField;
    public FmtSettingsHolder`1<TSettingsKey> Settings { get; protected set; }
    public TContext Context { get; }
    public IFormatterDebugInfoLogger DebugInfoLogger { get; }
    public ISettingValueReader`1<TSettingsKey> Reader { get; protected set; }
    private ISettingValueReader JetBrains.ReSharper.Psi.Impl.CodeStyle.IFormatterStageBase.Reader { get; }
    protected FormatterStageBase`2(TContext context, FmtSettingsHolder`1<TSettingsKey> settings);
    [CompilerGeneratedAttribute]
public sealed virtual FmtSettingsHolder`1<TSettingsKey> get_Settings();
    [CompilerGeneratedAttribute]
protected void set_Settings(FmtSettingsHolder`1<TSettingsKey> value);
    [CompilerGeneratedAttribute]
public TContext get_Context();
    public sealed virtual IFormatterDebugInfoLogger get_DebugInfoLogger();
    [CompilerGeneratedAttribute]
public ISettingValueReader`1<TSettingsKey> get_Reader();
    [CompilerGeneratedAttribute]
protected void set_Reader(ISettingValueReader`1<TSettingsKey> value);
    private sealed virtual override ISettingValueReader JetBrains.ReSharper.Psi.Impl.CodeStyle.IFormatterStageBase.get_Reader();
    protected int CalcMargin(IFormatterInfoProvider`2<TContext, TSettingsKey> provider);
    public virtual void SettingsChanged(FmtSettingsHolder`1<TSettingsKey> newSettings);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormatterTagsProcessor`1 : object {
    private CodeFormatterBase`1<TSettingsKey> myFormatter;
    private string myOverridenSettingPrefix;
    private bool mySupportTags;
    private string myOnTag;
    private string myOffTag;
    private bool mySupportRegexp;
    private Regex myOnRegex;
    private Regex myOffRegex;
    public FormatterTagsProcessor`1(CodeFormatterBase`1<TSettingsKey> formatter, CachedSettings settings);
    public void SearchOverridenSettings(IFile file, DocumentOffset start, DocumentOffset end, CachedSettings`1<TSettingsKey> settings, CachedSettings`1<TSettingsKey> initialSettings);
    public void SearchOverridenSettings(CachedSettings`1<TSettingsKey> settings, string text, CachedSettings`1<TSettingsKey> initialSettings, CachedSettings`1<TSettingsKey> settings2);
    public bool FastCheckOverridenSettings(string text);
    private void ProcessFormatterEnableDisableTag(CachedSettings`1<TSettingsKey> settings, IBuffer buffer, int start, int end, CachedSettings`1<TSettingsKey> initialSettings);
    private void ParseFormatterEnableDisableTag(IBuffer buffer, int start, int end, Nullable`1& value);
    private void ParseFormatterEnableDisableTagImpl(IBuffer buffer, int start, int end, Nullable`1& value);
    internal void ParseOverridenSetting(IBuffer buffer, int index, String& name, String& value);
    private void ChangeSetting(CachedSettings`1<TSettingsKey> settings, CachedSettings`1<TSettingsKey> initialSettings, string name, string value, CachedSettings`1<TSettingsKey> settings2);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormattingBuilderEx : object {
    [ExtensionAttribute]
public static T DeepClone(T obj);
    [ExtensionAttribute]
public static TBuilder Is(TBuilder builder, TObj obj);
    [ExtensionAttribute]
public static T Name(T builder, string name);
    [ExtensionAttribute]
public static T Group(T builder, long group);
    [ExtensionAttribute]
public static T Priority(T builder, int priority);
    [ExtensionAttribute]
public static T Or(T builder, object obj);
    [ExtensionAttribute]
public static TEnvelope Where(TEnvelope builder, IBuilderAction`1[] builders);
    [ExtensionAttribute]
public static T Clone(T builder);
    [ExtensionAttribute]
public static T Build(T builder);
    [ExtensionAttribute]
public static T BuildNoRestore(T builder);
    [ExtensionAttribute]
public static T StartAlternating(T builder);
    [ExtensionAttribute]
public static T StopAlternating(T builder);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> Switch(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting, IBuildableBuilder`1[] settingValues);
    [ExtensionAttribute]
public static IBuilderWithProviderAndExternalKey`4<TContext, TSettingsKey, TExternalSettingsKey, TStorage> SwitchOnExternalKey(IBuilderWithProviderAndExternalKey`4<TContext, TSettingsKey, TExternalSettingsKey, TStorage> builder, Expression`1<Func`2<TExternalSettingsKey, object>> setting, IBuildableBuilder`1[] settingValues);
    [ExtensionAttribute]
public static T IfSettingIsNullThenChooseValueFor(T builder, object defaultValue);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> Switch(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, LambdaExpression setting, IBuildableBuilder`1[] settingValues);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> Calculate(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Func`3<object, CodeFormattingContext, IOptionValue> calc);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> IfIncludedInStringList(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Func`3<object, CodeFormattingContext, string> getValue, Expression`1<Func`2<TSettingsKey, object>> setting, StringComparison comparison, IBuildableBuilder`1[] settingValues);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> IfAnyIncludedInStringList(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Func`3<object, CodeFormattingContext, IEnumerable`1<string>> getValue, Expression`1<Func`2<TSettingsKey, object>> setting, StringComparison comparison, IBuildableBuilder`1[] settingValues);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> CompareToThresholdInSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Func`3<object, CodeFormattingContext, int> getValue, Expression`1<Func`2<TSettingsKey, object>> setting, IBuildableBuilder`1[] settingValues);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> CompareToThresholdInSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Func`3<object, CodeFormattingContext, int> getValue, LambdaExpression setting, IBuildableBuilder`1[] settingValues);
    private static OptionTreeBlank[] BuildCasesForSwitch(IBuildableBuilder`1[] settingValues);
    [ExtensionAttribute]
public static T AndViceVersa(T builder);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormattingRange : ValueType {
    public ITreeNode First;
    public ITreeNode Last;
    public FormattingRange(ITreeNode first, ITreeNode last);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormattingRangeContext : object {
    private IOptionValueQueryResult`1<IFormatOptionValue> myFormattingOption;
    private Nullable`1<int> myLinebreaksNumber;
    [CompilerGeneratedAttribute]
private VirtNode <LeftChild>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtNode <RightChild>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtNode <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowModifications>k__BackingField;
    public VirtNode LeftChild { get; private set; }
    public VirtNode RightChild { get; private set; }
    public VirtNode Parent { get; private set; }
    public bool AllowModifications { get; private set; }
    public FormattingRangeContext(VirtNode first, VirtNode last, CodeFormattingContext context);
    public void Reuse(VirtNode first, VirtNode last, CodeFormattingContext context);
    public IOptionValueQueryResult`1<IFormatOptionValue> FindExtendedFormattingOption(IFormatterInfoProvider`2<TContext, TSettingsKey> provider, IFormatterStageBase`1<TSettingsKey> stage, TContext context);
    public IFormatOptionValue FindFormattingOption(IFormatterInfoProvider`2<TContext, TSettingsKey> provider, IFormatterStageBase`1<TSettingsKey> stage, TContext context);
    public string FindFormattingRuleName(IFormatterInfoProvider`2<TContext, TSettingsKey> provider, IFormatterStageBase`1<TSettingsKey> stage, TContext context, IntervalFormatType ift);
    public int GetLinebreaksNumber();
    [CompilerGeneratedAttribute]
public VirtNode get_LeftChild();
    [CompilerGeneratedAttribute]
private void set_LeftChild(VirtNode value);
    [CompilerGeneratedAttribute]
public VirtNode get_RightChild();
    [CompilerGeneratedAttribute]
private void set_RightChild(VirtNode value);
    [CompilerGeneratedAttribute]
public VirtNode get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(VirtNode value);
    [CompilerGeneratedAttribute]
public bool get_AllowModifications();
    [CompilerGeneratedAttribute]
private void set_AllowModifications(bool value);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormattingRule : FormattingRuleBase`1<IFormatOptionValue> {
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormattingRuleBase`1 : RuleWithTwoPatterns {
    [CompilerGeneratedAttribute]
private Func`3<FormattingRangeContext, CodeFormattingContext, bool> <Predicate>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<FormattingStageAcceptanceType> <StageIdPredicate>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private OptionTreeBlank <OptionTree>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HighlightingForMissing>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HighlightingForRedundant>k__BackingField;
    public Func`3<FormattingRangeContext, CodeFormattingContext, bool> Predicate { get; public set; }
    public Nullable`1<FormattingStageAcceptanceType> StageIdPredicate { get; public set; }
    public int Priority { get; public set; }
    public OptionTreeBlank OptionTree { get; public set; }
    public string HighlightingForMissing { get; public set; }
    public string HighlightingForRedundant { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual Func`3<FormattingRangeContext, CodeFormattingContext, bool> get_Predicate();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Predicate(Func`3<FormattingRangeContext, CodeFormattingContext, bool> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<FormattingStageAcceptanceType> get_StageIdPredicate();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StageIdPredicate(Nullable`1<FormattingStageAcceptanceType> value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Priority(int value);
    [CompilerGeneratedAttribute]
public OptionTreeBlank get_OptionTree();
    [CompilerGeneratedAttribute]
public void set_OptionTree(OptionTreeBlank value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_HighlightingForMissing();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HighlightingForMissing(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_HighlightingForRedundant();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HighlightingForRedundant(string value);
    public sealed virtual void Build(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
    public sealed virtual void RunWithOptionTree(Action`1<OptionTreeBlank> action);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormattingRuleBuilderEx : object {
    [ExtensionAttribute]
public static T StageIdPredicate(T builder, Nullable`1<FormattingStageAcceptanceType> value);
    [ExtensionAttribute]
public static T HighlightingForMissing(T builder, string value);
    [ExtensionAttribute]
public static T HighlightingForRedundant(T builder, string value);
    [ExtensionAttribute]
public static T FormatHighlighting(T builder, string value);
    [ExtensionAttribute]
public static T Return(T builder, IntervalFormatType intervalFormatType);
    [ExtensionAttribute]
public static T ReturnIntAlign(T builder, string name, int priority);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> SwitchBlankLines(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting, bool inherit, BlankLineLimitKind limitKind);
    [ExtensionAttribute]
public static IBuilderWithProviderAndExternalKey`4<TContext, TSettingsKey, TExternalKey, TStorage> SwitchBlankLinesOnExternalKey(IBuilderWithProviderAndExternalKey`4<TContext, TSettingsKey, TExternalKey, TStorage> builder, Expression`1<Func`2<TExternalKey, object>> setting, bool inherit, BlankLineLimitKind limitKind);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> SwitchBlankLines(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, LambdaExpression setting, bool inherit, BlankLineLimitKind limitKind);
    [ExtensionAttribute]
public static IBuilderWithProviderAndExternalKey`4<TContext, TSettingsKey, TExternalKey, TStorage> SwitchBlankLinesOnExternalKey(IBuilderWithProviderAndExternalKey`4<TContext, TSettingsKey, TExternalKey, TStorage> builder, LambdaExpression setting, bool inherit, BlankLineLimitKind limitKind);
    [ExtensionAttribute]
public static T Return(T builder, int minBlankLines, int maxBlankLinesMild, int maxBlankLinesStrict, bool inherit);
    private static void ReverseOptions(OptionTreeBlank optionTree);
    [ExtensionAttribute]
public static T ReverseOptions(T builder);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormattingStage`2 : FormatterStageBase`2<TContext, TSettingsKey> {
    protected IFormatterInfoProvider`2<TContext, TSettingsKey> myProvider;
    protected IProgressIndicator myProgress;
    private WrappingStage`2<TContext, TSettingsKey> myWrappingStage;
    private VirtNode myLastLineBreakLeft;
    private IncompleteRangeDataHolder<TContext, TSettingsKey> myIncompleteRangeDataHolder;
    public FormattingStage`2(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IFormatterInfoProvider`2<TContext, TSettingsKey> provider, IProgressIndicator progress, WrappingStage`2<TContext, TSettingsKey> wrappingStage);
    public virtual void DoFormat();
    public virtual void FormatRange(FormattingRangeContext range);
    private FrugalLocalList`1<RuleResultInfo`1<IFormatOptionValue>> GetFormatterRule(IntervalFormatType ift, RuleResultInfo`1[] breakdown);
    protected bool CheckSpacesForAutodetect(int nLineFeeds, int nSpaces, int nTabs, FormattingRangeContext o, Func`2<FormattingRangeContext, bool> hasIntAlign, bool newLine, Whitespace space);
    protected ValueTuple`2<Nullable`1<IntervalFormatType>, FormatMismatchType> CheckSpaces(bool allowLineBreaks, IntervalFormatType formatType, int nLineFeeds, int nSpaces, int nTabs, object o, Func`2<object, bool> hasIntAlign, bool newLine, Whitespace space);
    protected bool FullCalcSpaceOrNewLine(FormattingRangeContext range, Nullable`1<IntervalFormatType> spaceType, int nLineFeeds, int nSpaces, int nTabs, Whitespace& space, Boolean& newLine, ValueTuple`2& minSeparator);
    private void CalcAndCheckSpaces(IFormatterStageBase`1<TSettingsKey> formattingStage, FormattingRangeContext range, TContext context, IFormatterInfoProvider`2<TContext, TSettingsKey> provider, IOptionValueQueryResult`1<IFormatOptionValue> currentOption);
    private bool ModifyOptionWithWrappingRules(IOptionValueQueryResult`1& currentOption);
    private void HighlightFormattingProblem(FormattingRangeContext range, RuleResultInfo`1[] breakdownByRule, IntervalFormatType intervalFormatType, FormatMismatchType formatMismatchType, ValueTuple`2<bool, bool> minSeparator, bool logErrors);
    public static void ChangeSpaces(IFormatterStageBase`1<TSettingsKey> formattingStage, FormattingRangeContext range, TContext context, IFormatterInfoProvider`2<TContext, TSettingsKey> provider, IFormatOptionValue currentOption);
    protected static Nullable`1<ValueTuple`4<int, int, int, string>> CalcSpaces(FormattingRangeContext range, IFormatterInfoProvider`2<TContext, TSettingsKey> formattingInfoProvider, TContext context, IFormatterStageBase`1<TSettingsKey> stage, IFormatOptionValue currentOption);
    private static bool NotEnoughSpaces(int nTabs, int nSpaces, Whitespace space, ExtraSpaces extraSpacesStyle);
    private static bool ShouldRemoveExtraSpaces(ExtraSpaces extraSpacesStyle, int nTabs, int nSpaces);
    private static ExtraSpaces GetExtraSpacesStyle(IFormatterInfoProvider`2<TContext, TSettingsKey> formattingInfoProvider, TContext context, IFormatterStageBase`1<TSettingsKey> formattingStage, int nLineFeeds, int nTabs, int nSpaces, Whitespace space);
    private static bool HasExtraSpaces(int nTabs, int nSpaces, Whitespace space);
    private static ValueTuple`2<bool, bool> ModifySpacesWithMinSeparator(FormattingRangeContext range, TContext context, Boolean& newLine, Whitespace& space);
    private static bool CalcSpaceOrNewLine(FormattingRangeContext range, TContext context, IFormatterStageBase`1<TSettingsKey> formattingStage, Nullable`1<IntervalFormatType> currentOption, int nLineFeeds, int nSpaces, int nTabs, bool allowLineBreakChanges, Whitespace& space, Boolean& newLine, IFormatterInfoProvider provider);
    private static bool AllowLineBreakChanges(FormattingRangeContext range, TContext context, IFormatterStageBase`1<TSettingsKey> formattingStage, IFormatterInfoProvider provider);
    private static bool KeepUserNewLines(IntervalFormatType ruleSpace);
    protected static FrugalLocalList`1<VirtNode> CalcExistingSpaces(FormattingRangeContext range, TContext context, Int32& lastLineBreak, Int32& nLineFeeds, Int32& nSpaces, Int32& nTabs, Boolean& blankLineSpaces);
    public static ITokenNode CalcMinSeparator(FormattingRangeContext range, TContext context);
    [CompilerGeneratedAttribute]
internal static string <HighlightFormattingProblem>g__DumpTokenInfo|15_0(VirtNode node);
}
public enum JetBrains.ReSharper.Psi.Impl.CodeStyle.FormattingStageAcceptanceType : Enum {
    public int value__;
    public static FormattingStageAcceptanceType MainStages;
    public static FormattingStageAcceptanceType AdditionalFormatStage;
    public static FormattingStageAcceptanceType AllStages;
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormattingStageContext : object {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private ITreeNode myLeftChild;
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private ITreeNode myRightChild;
    [DebuggerBrowsableAttribute("0")]
private CompositeElement myParent;
    [DebuggerBrowsableAttribute("0")]
private short myLeftRole;
    [DebuggerBrowsableAttribute("0")]
private short myRightRole;
    [NotNullAttribute]
public ITreeNode LeftChild { get; }
    [NotNullAttribute]
public ITreeNode RightChild { get; }
    public CompositeElement Parent { get; }
    public short LeftRole { get; }
    public short RightRole { get; }
    public FormattingStageContext(FormattingRange range);
    public ITreeNode get_LeftChild();
    public ITreeNode get_RightChild();
    public CompositeElement get_Parent();
    public short get_LeftRole();
    public short get_RightRole();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormattingStageContextExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TokenNodeType GetLeftTokenType(FormattingStageContext context);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TokenNodeType GetRightTokenType(FormattingStageContext context);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.FormattingStageId : ValueType {
    [CompilerGeneratedAttribute]
private FormattingStageType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Pass>k__BackingField;
    public FormattingStageType Type { get; }
    public int Pass { get; }
    public FormattingStageId(FormattingStageType type, int pass);
    [CompilerGeneratedAttribute]
public FormattingStageType get_Type();
    [CompilerGeneratedAttribute]
public int get_Pass();
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.Impl.CodeStyle.FormattingStageType : Enum {
    public int value__;
    public static FormattingStageType Unspecified;
    public static FormattingStageType Format;
    public static FormattingStageType AdditionalFormat;
    public static FormattingStageType IndentAndWrap;
    public static FormattingStageType BlankLines;
    public static FormattingStageType IndentOnly;
    public static FormattingStageType IntAlign;
    public static FormattingStageType Daemon;
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IBlankLinesOptionValue {
    public int MinBlankLines { get; }
    public int MaxBlankLinesMild { get; }
    public int MaxBlankLinesStrict { get; }
    public bool Inherit { get; }
    public abstract virtual int get_MinBlankLines();
    public abstract virtual int get_MaxBlankLinesMild();
    public abstract virtual int get_MaxBlankLinesStrict();
    public abstract virtual bool get_Inherit();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IBlankThatBuilds {
    public abstract virtual void Build(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IBlankWithOptionTree {
    public abstract virtual void RunWithOptionTree(Action`1<OptionTreeBlank> action);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IBlankWithParentPattern {
    public NodePatternBlank GrandParentPattern { get; public set; }
    public NodePatternBlank ParentPattern { get; public set; }
    public abstract virtual NodePatternBlank get_GrandParentPattern();
    public abstract virtual void set_GrandParentPattern(NodePatternBlank value);
    public abstract virtual NodePatternBlank get_ParentPattern();
    public abstract virtual void set_ParentPattern(NodePatternBlank value);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IBlankWithPredicate {
    public Func`3<FormattingRangeContext, CodeFormattingContext, bool> Predicate { get; public set; }
    public abstract virtual Func`3<FormattingRangeContext, CodeFormattingContext, bool> get_Predicate();
    public abstract virtual void set_Predicate(Func`3<FormattingRangeContext, CodeFormattingContext, bool> value);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IBlankWithPriority {
    public int Priority { get; public set; }
    public abstract virtual int get_Priority();
    public abstract virtual void set_Priority(int value);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IBlankWithSinglePattern {
    public NodePatternBlank Pattern { get; public set; }
    public abstract virtual NodePatternBlank get_Pattern();
    public abstract virtual void set_Pattern(NodePatternBlank value);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IBlankWithTwoPatterns {
    public NodePatternBlank SecondPattern { get; public set; }
    public abstract virtual NodePatternBlank get_SecondPattern();
    public abstract virtual void set_SecondPattern(NodePatternBlank value);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IBlankWithTwoPatternsAndOptionTree {
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IBuildable {
    public abstract virtual void DoBuild();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IBuildableBuilder`1 {
    public T SavedState { get; }
    public abstract virtual T get_SavedState();
    public abstract virtual void SaveState();
    public abstract virtual void RestoreState();
    public abstract virtual void CleanState();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IBuilder`1 {
    public T Obj { get; }
    public abstract virtual T get_Obj();
    public abstract virtual IBuilder`1<T> DoClone();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IBuilderAction`1 {
    public abstract virtual void Run(T obj);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IBuilderEx`1 {
    public abstract virtual void SetObj(T obj);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IBuilderWithProvider`3 {
    public FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> Provider { get; }
    public abstract virtual FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> get_Provider();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IBuilderWithProviderAndExternalKey`4 {
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IClosableIndentingHighlighting {
    public abstract virtual void SetClosingNode(ITreeNode node);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.ICodeFormatterImpl {
    [CanBeNullAttribute]
public abstract virtual ITokenNode GetMinimalSeparator(ITokenNode leftToken, ITokenNode rightToken);
    public abstract virtual MinimalSeparatorType GetMinimalSeparatorByNodeTypes(TokenNodeType leftToken, TokenNodeType rightToken);
    public abstract virtual ITreeNode CreateSpace(string indent, NodeType replacedOrLeftSiblingType);
    public abstract virtual ITreeNode CreateSpace();
    public abstract virtual ITreeNode CreateNewLine(LineEnding lineEnding, NodeType lineBreakType);
    public abstract virtual bool CanModifyInsideNodeRange(ITreeNode leftElement, ITreeNode rightElement, CodeFormattingContext context);
    public abstract virtual bool CanModifyNode(ITreeNode element, CodeFormattingContext context);
    public abstract virtual IScalarSetting`1<TValue> GetEntry(Expression`1<Func`2<FormatSettingsKeyBase, TValue>> expression);
    [CanBeNullAttribute]
public abstract virtual IFormatterInfoProvider GetFormatterInfoProvider(IPsiSourceFile sourceFile, AdditionalFormatterParameters parameters);
    public abstract virtual void FormatMyLanguageInMultiLanguageFileWithAccu(FormatTask[] formatTasks, FileChangeAccu accu, AdditionalFormatterParameters parameters, IContextBoundSettingsStore settingsStore, IPsiSourceFile sourceFile, LineEnding lineEnding);
    public abstract virtual bool UseChangeAccu(CachedSettings fmtSettings, IPsiSourceFile sourceFile);
    public abstract virtual void AdjustFormatTasks(FormatTask[] formatTasks);
    public abstract virtual bool HasSignificantWhitespaces(ITreeNode node);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.ICustomFormatterInfoProvider {
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IDecoratingStage {
    public abstract virtual void Decorate(ITreeNode node);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IFormatOptionValue {
    public IntervalFormatType SpaceType { get; }
    public abstract virtual IntervalFormatType get_SpaceType();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IFormatterDaemon {
    public bool HighlightIndents { get; }
    public bool HighlightLineBreaks { get; }
    public bool HighlightSpaces { get; }
    public bool HighlightBlankLines { get; }
    public abstract virtual IClosableIndentingHighlighting MissingIndent(ITreeNode node, ITreeNode closingNode, IndentMismatchType mismatchType, String[] highlightingId, Whitespace expectedDifference);
    public abstract virtual IClosableIndentingHighlighting TabAndSpacesMismatch(ITreeNode node, ITreeNode closingNode, int tabsExpected, int spacesExpected, int tabsEncountered, int spacesEncountered);
    public abstract virtual IClosableIndentingHighlighting UnknownIndent(ITreeNode node, ITreeNode closingNode, String[] highlightingId);
    public abstract virtual IClosableIndentingHighlighting TabsMustGoFirst(ITreeNode node, ITreeNode closingNode);
    public abstract virtual void IncorrectFormat(FormatMismatchType mismatchType, RuleResultInfo`1[] rules, FormattingRangeContext range);
    public abstract virtual void MultipleSpacesOrTabs(FormattingRangeContext range, int nSpaces, int nTabs);
    public abstract virtual void IncorrectBlankLines(BlankLinesMismatchType mismatchType, RuleResultInfo`1[] rules, FormattingRangeContext range, int expected, int actual);
    public abstract virtual bool get_HighlightIndents();
    public abstract virtual bool get_HighlightLineBreaks();
    public abstract virtual bool get_HighlightSpaces();
    public abstract virtual bool get_HighlightBlankLines();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IFormatterDebugInfoLogger {
    public string LeftNodeToLog { get; }
    public string RightNodeToLog { get; }
    public int LineNumberToLogWrapping { get; }
    public abstract virtual void OpenIndentingRegion(string regionName, VirtNode node, int indentLength, IndentType indentType);
    public abstract virtual void CloseIndentingRegion(string regionName, VirtNode node, IndentType indentType);
    public abstract virtual void OpenWrappingRegion(string regionName, VirtNode node, string additionalInfo);
    public abstract virtual void CloseWrappingRegion(string regionName, VirtNode node);
    public abstract virtual void BeforeNode(VirtNode node);
    public abstract virtual void AfterNode(VirtNode node);
    public abstract virtual void Started(int task);
    public abstract virtual void Ended(int task);
    public abstract virtual void Log(string message);
    public abstract virtual string get_LeftNodeToLog();
    public abstract virtual string get_RightNodeToLog();
    public abstract virtual int get_LineNumberToLogWrapping();
}
[DerivedComponentsInstantiationRequirementAttribute("1")]
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IFormatterDebugInfoLoggersProvider {
    public IFormatterDebugInfoLogger FormatterLogger { get; }
    public abstract virtual IFormatterDebugInfoLogger get_FormatterLogger();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IFormatterInfoProvider {
    public IScalarSetting`1<ExtraSpaces> ExtraSpacesSetting { get; }
    public IScalarSetting`1<bool> WrapLinesSetting { get; }
    public IScalarSetting`1<bool> KeepUserWrappingSetting { get; }
    public IScalarSetting`1<int> WrapLimitSetting { get; }
    public IScalarSetting`1<IndentStyle> IndentStyleSetting { get; }
    public IScalarSetting`1<int> IndentSizeSetting { get; }
    public IScalarSetting`1<bool> AllowFarAlignmentSetting { get; }
    public IScalarSetting`1<AlignmentTabFillStyle> AlignmentTabFillStyleSetting { get; }
    public IScalarSetting`1<bool> UseIndentFromVsSetting { get; }
    public IScalarSetting`1<int> TabWidthSetting { get; }
    public IScalarSetting`1<bool> RemoveSpacesOnBlankLines { get; }
    public IScalarSetting`1<bool> DisableLineBreakRemovalSetting { get; }
    public IScalarSetting`1<bool> DisableBlankLineChangesSetting { get; }
    public IScalarSetting`1<bool> DisableLineBreakChangesSetting { get; }
    public IScalarSetting`1<bool> DisableFormatterSetting { get; }
    public IScalarSetting`1<bool> DisableIndenterSetting { get; }
    public IScalarSetting`1<bool> DisableSpaceChangesSetting { get; }
    public IScalarSetting`1<bool> DisableIntAlignSetting { get; }
    public IScalarSetting`1<bool> IntAlignFixInAdjacent { get; }
    public IScalarSetting`1<bool> FormatLeadingSpacesDeclSetting { get; }
    public IScalarSetting`1<bool> UseIndentFromPreviousElementSetting { get; }
    public ProjectFileType MainProjectFileType { get; }
    public bool UsesInheritedIntervalFormatType { get; }
    public bool HasIntAlignRules { get; }
    public bool ShouldCorrectCalculatedIndentsWithActual { get; }
    public abstract virtual IScalarSetting`1<ExtraSpaces> get_ExtraSpacesSetting();
    public abstract virtual IScalarSetting`1<bool> get_WrapLinesSetting();
    public abstract virtual IScalarSetting`1<bool> get_KeepUserWrappingSetting();
    public abstract virtual IScalarSetting`1<int> get_WrapLimitSetting();
    public abstract virtual IScalarSetting`1<IndentStyle> get_IndentStyleSetting();
    public abstract virtual IScalarSetting`1<int> get_IndentSizeSetting();
    public abstract virtual IScalarSetting`1<bool> get_AllowFarAlignmentSetting();
    public abstract virtual IScalarSetting`1<AlignmentTabFillStyle> get_AlignmentTabFillStyleSetting();
    public abstract virtual IScalarSetting`1<bool> get_UseIndentFromVsSetting();
    public abstract virtual IScalarSetting`1<int> get_TabWidthSetting();
    public abstract virtual IScalarSetting`1<bool> get_RemoveSpacesOnBlankLines();
    public abstract virtual IScalarSetting`1<bool> get_DisableLineBreakRemovalSetting();
    public abstract virtual IScalarSetting`1<bool> get_DisableBlankLineChangesSetting();
    public abstract virtual IScalarSetting`1<bool> get_DisableLineBreakChangesSetting();
    public abstract virtual IScalarSetting`1<bool> get_DisableFormatterSetting();
    public abstract virtual IScalarSetting`1<bool> get_DisableIndenterSetting();
    public abstract virtual IScalarSetting`1<bool> get_DisableSpaceChangesSetting();
    public abstract virtual IScalarSetting`1<bool> get_DisableIntAlignSetting();
    public abstract virtual IScalarSetting`1<bool> get_IntAlignFixInAdjacent();
    public abstract virtual IScalarSetting`1<bool> get_FormatLeadingSpacesDeclSetting();
    public abstract virtual IScalarSetting`1<bool> get_UseIndentFromPreviousElementSetting();
    public abstract virtual ProjectFileType get_MainProjectFileType();
    public abstract virtual bool get_UsesInheritedIntervalFormatType();
    public abstract virtual bool get_HasIntAlignRules();
    public abstract virtual bool get_ShouldCorrectCalculatedIndentsWithActual();
    public abstract virtual IEnumerable`1<IScalarSetting> SettingsToIgnoreInAutodetect();
    public abstract virtual IEnumerable`1<IScalarSetting> SettingsNotToCalculateInAutodetect();
    public abstract virtual IEnumerable`1<IScalarSetting> KeepExistingSettings();
    public abstract virtual IEnumerable`1<IScalarSetting`1<bool>> PureIntAlignSettings();
    public abstract virtual IEnumerable`1<Pair`2<IScalarSetting, object>> SettingsForStrictAutodetectMode();
    public abstract virtual IEnumerable`1<Pair`2<IScalarSetting, object>> AdditionalSettingValuesForAutodetect();
    public abstract virtual IEnumerable`1<ValueTuple`3<object, int, IScalarSetting[]>> GetSettingPreferences();
    public abstract virtual IEnumerable`1<ValueTuple`3<object, int, IScalarSetting[]>> GetSettingPreferencesForNewLines();
    public abstract virtual IEnumerable`1<ValueTuple`2<IScalarSetting, int>> GetSettingPriority();
    public abstract virtual void EnsureInitialization();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IFormatterInfoProvider`2 {
    public bool ShouldFixAlignmentBeyondGivenRange { get; }
    public abstract virtual IOptionValueQueryResult`1<IFormatOptionValue> FindFormattingOptionInternal(FormattingRangeContext interval, IFormatterStageBase`1<TSettingsKey> stage, TContext context, bool breakdownByRule);
    public abstract virtual IBlankLinesOptionValue FindBlankLinesOption(FormattingRangeContext interval, IFormatterStageBase`1<TSettingsKey> callback, TContext context);
    public abstract virtual IOptionValueQueryResult`1<IBlankLinesOptionValue> FindBlankLinesOptionWithBreakdownByRule(FormattingRangeContext interval, IFormatterStageBase`1<TSettingsKey> stage, TContext context);
    public abstract virtual IIntAlignOptionValue FindIntAlignOption(FormattingRangeContext interval, IFormatterStageBase`1<TSettingsKey> callback, TContext context);
    public abstract virtual List`1<IFormattingRule`2<TSettingsKey, IFormatOptionValue>> FindFormattingRules(FormattingRangeContext interval, TContext context);
    public abstract virtual List`1<IFormattingRule`2<TSettingsKey, IBlankLinesOptionValue>> FindBlankLinesRules(FormattingRangeContext interval, TContext context);
    public abstract virtual List`1<IFormattingRule`2<TSettingsKey, IIntAlignOptionValue>> FindIntAlignRules(FormattingRangeContext interval, TContext context);
    public abstract virtual List`1<Pair`2<IIndentingRule, VirtNode>> FindIndentingRules(VirtNode node, IndentType typeMask, TContext context, TemporaryRules`1& temporaryRules);
    public abstract virtual List`1<Pair`2<IWrapGroupRule, VirtNode>> FindWrappingRules(VirtNode node, WrapType typeMask, TContext context, TemporaryRules`1& temporaryRules);
    public abstract virtual bool IsRuleDelayed(IIndentingRule rule);
    public abstract virtual bool IsRuleForAlignment(IIndentingRule rule);
    public abstract virtual void FindAndProcessWrappingRegions(VirtNode node, WrapType typeMask, IWrappingStage`1<TSettingsKey> callback, TContext context, int position, TemporaryRules`1& temporaryRules);
    public abstract virtual void FindAndProcessIndentingRegions(VirtNode node, IndentType typeMask, IIndentingStage`1<TSettingsKey> callback, TContext context, List`1<Pair`2<IIndentingRule, VirtNode>> sortedRules, TemporaryRules`1& temporaryRules);
    public abstract virtual void ModifyIndent(ITreeNode nodeToIndent, Nullable`1& indent, TContext context, IIndentingStage`1<TSettingsKey> callback, IndentType indentType);
    public abstract virtual void MatchNode(VirtNode node, IndentType typeMask, IIndentingStage`1<TSettingsKey> callback, TContext context, IOptionValueQueryResult`1& queryResult, VirtNode& closingNode, IIndentingRule& rule, List`1<Pair`2<IIndentingRule, VirtNode>> sortedRules, TemporaryRules`1& temporaryRules);
    public abstract virtual ITreeNode GetPossibleIndentLeftBoundInsideNode(ITreeNode parent);
    public abstract virtual ITreeNode GetPossibleIndentRightBoundInsideNode(ITreeNode parent);
    public abstract virtual string GetOldIndent(ITreeNode node);
    public abstract virtual bool ShouldReindentInsideNode(ITreeNode node);
    public abstract virtual bool get_ShouldFixAlignmentBeyondGivenRange();
    public abstract virtual IndentingStage`2<TContext, TSettingsKey> CreateIndentingStage(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IProgressIndicator progress, SequentialNodeIterator`2<TContext, TSettingsKey> iterator);
    public abstract virtual void RegisterUsedSetting(TContext context, IScalarSetting setting);
    public abstract virtual bool CanCollapseUnusedRegions();
    public abstract virtual bool RemoveUserBlankLinesInStrictMode();
    public abstract virtual bool ShouldRemoveExtraBlankLines(IFormatterStageBase`1<TSettingsKey> stage, TContext context);
    public abstract virtual ExtraSpaces GetExtraSpacesStyle(IFormatterStageBase`1<TSettingsKey> stage, TContext context);
    public abstract virtual bool ProcessQueryResultForIndent(VirtNode node, IndentType typeMask, IIndentingStage`1<TSettingsKey> callback, TContext context, IOptionValueQueryResult`1<IIndentOptionValue> queryResult, IIndentingRule rule, VirtNode closingNode);
    public abstract virtual ITreeNode ThisOrPrecedingMacro(ITreeNode node, IWhitespaceChecker checker);
    public abstract virtual VirtNode GetNextSiblingForIndenting(VirtNode node);
    public abstract virtual bool NodeFromFirstMacroOnLine(ITreeNode node, IWhitespaceChecker checker, TContext context, ITreeNode& prototypeMacro);
    public abstract virtual bool ReallyNeedIndent(ITreeNode node, IndentRegionInfo info, TContext context);
    public abstract virtual bool IsNonEmptyMacroCall(ITreeNode node, TContext context);
    public abstract virtual VirtNode ThisOrMacroForIndent(VirtNode node, int indent, Func`2<VirtNode, int> calcNodeIndent, TContext context, Boolean& disableIndent);
    [CanBeNullAttribute]
public abstract virtual ITreeNode GetContainingMacro(ITreeNode node);
    public abstract virtual bool IncludePrefixCommentInIndent(IFormatterStageBase`1<TSettingsKey> stage);
    public abstract virtual bool CustomReindentInsideMultilineNode(VirtNode node, IndentingStage`2<TContext, TSettingsKey> indentingStage);
    public abstract virtual void AfterNodeEnd(ITreeNode node, TContext context);
    public abstract virtual void BeforeDescendIntoNode(ITreeNode node, TContext context);
    public abstract virtual void CustomTaskFinished(VirtNode& dontReallyFinishUntilThisNode, TContext context, VirtNode current);
    public abstract virtual FormattingRangeContext AdjustFormattingRangeContext(FormattingRangeContext formattingRangeContext, TContext context);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IFormatterRule {
    public string Name { get; }
    public int Priority { get; }
    public abstract virtual string get_Name();
    public abstract virtual int get_Priority();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IFormatterStageBase {
    public IFormatterDebugInfoLogger DebugInfoLogger { get; }
    public ISettingValueReader Reader { get; }
    public abstract virtual IFormatterDebugInfoLogger get_DebugInfoLogger();
    public abstract virtual ISettingValueReader get_Reader();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IFormatterStageBase`1 {
    public FmtSettingsHolder`1<TSettingsKey> Settings { get; }
    public abstract virtual FmtSettingsHolder`1<TSettingsKey> get_Settings();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IFormattingRule`2 {
    public INodePattern LeftNode { get; }
    public INodePattern RightNode { get; }
    public INodePattern ParentNode { get; }
    public FormattingStageAcceptanceType StageIdPredicate { get; }
    public long Group { get; public set; }
    public abstract virtual INodePattern get_LeftNode();
    public abstract virtual INodePattern get_RightNode();
    public abstract virtual INodePattern get_ParentNode();
    public abstract virtual FormattingStageAcceptanceType get_StageIdPredicate();
    public abstract virtual long get_Group();
    public abstract virtual void set_Group(long value);
    public abstract virtual bool MatchesPatterns(FormattingRangeContext interval, CodeFormattingContext context);
    public abstract virtual IOptionNode GetOptionTree(FormattingRangeContext interval);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IFormattingRuleBlank {
    public Nullable`1<FormattingStageAcceptanceType> StageIdPredicate { get; public set; }
    public string HighlightingForMissing { get; public set; }
    public string HighlightingForRedundant { get; public set; }
    public abstract virtual Nullable`1<FormattingStageAcceptanceType> get_StageIdPredicate();
    public abstract virtual void set_StageIdPredicate(Nullable`1<FormattingStageAcceptanceType> value);
    public abstract virtual string get_HighlightingForMissing();
    public abstract virtual void set_HighlightingForMissing(string value);
    public abstract virtual string get_HighlightingForRedundant();
    public abstract virtual void set_HighlightingForRedundant(string value);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IFormattingStage {
    public abstract virtual void Format(ITreeNode leftChild, ITreeNode rightChild);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IGeneralRuleBlank {
    public string Name { get; public set; }
    public long Group { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual long get_Group();
    public abstract virtual void set_Group(long value);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IHighlightableFormatterRule {
    public string HighlightingForMissing { get; }
    public string HighlightingForRedundant { get; }
    public abstract virtual string get_HighlightingForMissing();
    public abstract virtual string get_HighlightingForRedundant();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IIndentCache {
    [NotNullAttribute]
public abstract virtual string GetLineIndent(ITreeNode node);
    [NotNullAttribute]
public abstract virtual string GetNodeIndent(ITreeNode node);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IIndentingRule {
    public string OpeningHighlightingId { get; }
    public string ClosingHighlightingId { get; }
    public bool IgnoreRegionIfClosingNodeIsNull { get; }
    public abstract virtual string get_OpeningHighlightingId();
    public abstract virtual string get_ClosingHighlightingId();
    public abstract virtual bool get_IgnoreRegionIfClosingNodeIsNull();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IIndentingStage`1 {
    public abstract virtual bool ProcessIndentingRegion(IIndentingRule rule, VirtNode current, VirtNode closingNode, IndentType typeMask, IIndentOptionValue indentOptionValue, IReadOnlyCollection`1<IScalarSetting> observedSettings);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IIndentOptionValue {
    public IndentType IndentType { get; }
    public int StandardIndentMultiplier { get; }
    public Whitespace AdditionalIndent { get; }
    public abstract virtual IndentType get_IndentType();
    public abstract virtual int get_StandardIndentMultiplier();
    public abstract virtual Whitespace get_AdditionalIndent();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IIntAlignOptionValue {
    public object ID { get; }
    public int Priority { get; }
    public abstract virtual object get_ID();
    public abstract virtual int get_Priority();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IMergeable`1 {
    public abstract virtual T Merge(T lowPriority, bool alwaysMerge, MergeKind& mergeKind);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IMergeableBlank {
    public abstract virtual object DoDeepClone();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IMergeableOptionValue`1 {
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.IndentCache`1 : object {
    private ICodeFormatterImpl myCodeFormatter;
    private Func`3<ITreeNode, CustomIndentType, string> myCustomLineIndenter;
    private FormatSettingsKeyBase myFormatSettings;
    private ElementsCache`2<ITreeNode, string> myLineIndents;
    private ElementsCache`2<ITreeNode, string> myNodeIndents;
    public ICodeFormatterImpl CodeFormatter { get; }
    public IndentCache`1(ICodeFormatterImpl codeFormatter, Func`3<ITreeNode, CustomIndentType, string> customLineIndenter, FormatSettingsKeyBase formatSettings);
    public ICodeFormatterImpl get_CodeFormatter();
    [NotNullAttribute]
public sealed virtual string GetLineIndent(ITreeNode node);
    [NotNullAttribute]
public sealed virtual string GetNodeIndent(ITreeNode node);
    public string GetCustomIndent(ITreeNode node, CustomIndentType customIndentType);
    protected string CalcNodeIndent(ITreeNode node);
    protected string CalcLineIndent(ITreeNode node);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.IndentDelta : ValueType {
    public IndentDeltaType IndentType;
    public int StandardIndentsDelta;
    public Whitespace AdditionalDelta;
    public bool IsZero { get; }
    public bool IsRelative { get; }
    public bool IsDefault { get; }
    public IndentDelta(IndentDeltaType indentType, int standardIndentsDelta, Whitespace additionalDelta);
    public IndentDelta(Whitespace absoluteIndent);
    public bool get_IsZero();
    public bool get_IsRelative();
    public bool get_IsDefault();
    public IndentDelta FixIndentSize(Whitespace standardIndent);
    public Nullable`1<Whitespace> AddToIndent(Nullable`1<Whitespace> indent, Whitespace standardIndent);
    public Nullable`1<Whitespace> TakeFromIndent(Nullable`1<Whitespace> indent, Whitespace standardIndent);
    public Nullable`1<Whitespace> FixAndConvertToWhitespace(CachedSettings settings, IFormatterInfoProvider provider);
    public Nullable`1<Whitespace> ConvertToWhitespace(Whitespace standardIndent);
    public int GetLength(int tabWidth, Whitespace standardIndent);
    public static IndentDelta op_Implicit(Whitespace whitespace);
    public static IndentDelta op_Implicit(Nullable`1<Whitespace> whitespace);
    public static IndentDelta op_Addition(IndentDelta a, IndentDelta b);
    public static IndentDelta op_Subtraction(IndentDelta a, IndentDelta b);
    public static IndentDelta op_UnaryNegation(IndentDelta a);
    public sealed virtual bool Equals(IndentDelta other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(IndentDelta left, IndentDelta right);
    public static bool op_Inequality(IndentDelta left, IndentDelta right);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum JetBrains.ReSharper.Psi.Impl.CodeStyle.IndentDeltaType : Enum {
    public int value__;
    public static IndentDeltaType Relative;
    public static IndentDeltaType Absolute;
    public static IndentDeltaType LeaveAsIs;
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.IndentingRule : RegionRuleBlankBase {
    [CompilerGeneratedAttribute]
private string <OpeningHighlighting>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClosingHighlighting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreRegionIfClosingNodeIsNull>k__BackingField;
    public string OpeningHighlighting { get; public set; }
    public string ClosingHighlighting { get; public set; }
    public bool IgnoreRegionIfClosingNodeIsNull { get; public set; }
    [CompilerGeneratedAttribute]
public string get_OpeningHighlighting();
    [CompilerGeneratedAttribute]
public void set_OpeningHighlighting(string value);
    [CompilerGeneratedAttribute]
public string get_ClosingHighlighting();
    [CompilerGeneratedAttribute]
public void set_ClosingHighlighting(string value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreRegionIfClosingNodeIsNull();
    [CompilerGeneratedAttribute]
public void set_IgnoreRegionIfClosingNodeIsNull(bool value);
    public virtual void Build(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.IndentingRuleBuilderEx : object {
    [ExtensionAttribute]
public static T OpeningHighlighting(T builder, string value);
    [ExtensionAttribute]
public static T ClosingHighlighting(T builder, string value);
    [ExtensionAttribute]
public static T IndentHighlighting(T builder, string value);
    [ExtensionAttribute]
public static T IgnoreRegionIfClosingNodeIsNull(T builder, bool value);
    [ExtensionAttribute]
public static T Return(T builder, IndentType indentType, int indent, Whitespace additionalIndent);
    [ExtensionAttribute]
public static T Align(T builder, IndentType indentType);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.IndentingStage`2 : FormatterStageBase`2<TContext, TSettingsKey> {
    protected IFormatterInfoProvider`2<TContext, TSettingsKey> myProvider;
    protected IProgressIndicator myProgress;
    protected IIndentRegionInfoStack<TContext, TSettingsKey> myIndents;
    protected List`1<IndentRegionInfo> myOpenedIndents;
    protected List`1<Pair`2<Nullable`1<Whitespace>, IndentRegionInfo>> myClosedIndents;
    protected Whitespace myIndentStr;
    [CompilerGeneratedAttribute]
private int <TabWidth>k__BackingField;
    protected Whitespace myPrevIndent;
    [CompilerGeneratedAttribute]
private bool <InsertIndent>k__BackingField;
    protected bool myIndentChecked;
    private IReadOnlyCollection`1<IScalarSetting> myIndentEntries;
    protected VirtNode myOnlyChange;
    protected bool myAllowChange;
    protected long myMargin;
    protected bool myAllowFarAlignment;
    protected bool myInsideTask;
    protected bool myAfterInitialization;
    protected SequentialNodeIterator`2<TContext, TSettingsKey> myIterator;
    protected List`1<Pair`2<IIndentingRule, VirtNode>> mySortedRules;
    internal Action OnIndentChange;
    protected TemporaryRules`1<ITemporaryIndentingRule> myTemporaryRules;
    public int TabWidth { get; public set; }
    protected bool InsertIndent { get; protected set; }
    public SequentialNodeIterator`2<TContext, TSettingsKey> Iterator { get; }
    protected VirtNode Current { get; }
    protected long FarAlignmentMargin { get; }
    public IndentingStage`2(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IFormatterInfoProvider`2<TContext, TSettingsKey> provider, IProgressIndicator progress, SequentialNodeIterator`2<TContext, TSettingsKey> iterator);
    [CompilerGeneratedAttribute]
public int get_TabWidth();
    [CompilerGeneratedAttribute]
public void set_TabWidth(int value);
    [CompilerGeneratedAttribute]
protected bool get_InsertIndent();
    [CompilerGeneratedAttribute]
protected void set_InsertIndent(bool value);
    public SequentialNodeIterator`2<TContext, TSettingsKey> get_Iterator();
    private void CalcIndent();
    protected bool AllowChange();
    public virtual object SaveState();
    public virtual void RestoreState(object state);
    protected VirtNode get_Current();
    public sealed virtual VirtNode GetNextSibling(VirtNode node);
    public sealed virtual ITreeNode GetFirstChild(ITreeNode node);
    public virtual void SettingsChanged(FmtSettingsHolder`1<TSettingsKey> newSettings);
    public sealed virtual void AllTaskFinished();
    private sealed virtual override void JetBrains.ReSharper.Psi.Impl.CodeStyle.ISequentialNodeProcessor<TSettingsKey>.Initialize(Boolean& currentNodeInitialized);
    protected void SetInsertIndent(bool value);
    public Nullable`1<Whitespace> GetIndent(ITreeNode node, Position position);
    public void DoIndent(bool allowNoLinebreaks);
    protected virtual void StopDelayingIndents();
    private ValueTuple`2<VirtNode, bool> FixNodeToDescend(VirtNode nodeToDescend);
    public void DoIndent(VirtNode onlyChange, IProgressIndicator progressIndicator, string taskName);
    public virtual void ProcessNextSolidNode(FormattingRangeContext context);
    protected void DoProcessNextSolidNode(FormattingRangeContext context, bool fromFirstMacroOnLine, ITreeNode macro);
    [PureAttribute]
public VirtNode GetNextToken(VirtNode treeNode);
    public virtual void TaskFinished(VirtNode& dontReallyFinishUntilThisNode);
    private VirtNode FindLastSolidTokenOnLineAfterThis(VirtNode currentNode);
    public sealed virtual VirtNode FixLastNodeWhenEmptyInterval(VirtNode lastNode);
    private VirtNode FindLastDescendant(VirtNode treeNode);
    private sealed virtual override void JetBrains.ReSharper.Psi.Impl.CodeStyle.ISequentialNodeProcessor<TSettingsKey>.PreProcessNextSolidNode(FormattingRangeContext context);
    public virtual void ProcessLineBreak(VirtNode& lineBreak);
    protected void ProcessIndentsOnLineBreak();
    private void RemoveBlankLineIndent(ITreeNode lineBreak);
    protected bool RegionsOverlap(VirtNode oldRegionClosingNode, VirtNode newRegionClosingNode);
    protected virtual void PushIndent(IndentRegionInfo a);
    protected void BeforePushIndent(IndentRegionInfo a, IIndentRegionInfoStack<TContext, TSettingsKey> indents);
    private bool ShouldRemoveOverlappedRegion(IndentType indentType, IndentRegionInfo info, VirtNode openingNode, VirtNode closingNode);
    protected void FixIndent(VirtNode current, IndentRegionInfo info);
    private IndentRegionInfo PeekIndent();
    protected IndentRegionInfo PeekIndent(IIndentRegionInfoStack<TContext, TSettingsKey> indents);
    private void PopIndent();
    protected void PopIndent(IIndentRegionInfoStack<TContext, TSettingsKey> indents);
    private void RegisterIndentCloseInAccu(DocumentOffset docOffset, IndentRegionInfo a, TreeOffset treeOffset, IndentOpOrientation orientation);
    private ValueTuple`3<DocumentOffset, TreeOffset, IndentOpOrientation> GetCurrentOffset(bool delayed, bool crossLanguage);
    private ValueTuple`3<DocumentOffset, TreeOffset, IndentOpOrientation> GetCurrentOffsetForNode(bool delayed, bool crossLanguage, bool isEndOfNode, VirtNode node);
    protected virtual void IndentNode(VirtNode prevNode, VirtNode originalCurrent, bool reallyIndent, VirtNode nodeToIndent, bool fromFirstMacroOnLine);
    [ContractAnnotationAttribute("tokenNode: null => false")]
private bool ShouldReindentInsideTokenNode(ITokenNode tokenNode);
    protected Nullable`1<Whitespace> ModifyIndent(VirtNode current, IndentRegionInfo indentInfo, Nullable`1<Whitespace> indent);
    private void CheckIndentForDaemon(VirtNode current, IndentRegionInfo indentInfo);
    private IClosableIndentingHighlighting CreateAndProcessHighlighting(IndentRegionInfo indentInfo, Nullable`1<Whitespace> expectedIndent, ITreeNode nodeWithIndent, Whitespace realIndent, string realIndentStr, string expectedIndentStr);
    private bool SearchInIndentHistory(VirtNode current, IndentRegionInfo indentInfo, Whitespace realIndent);
    private IClosableIndentingHighlighting CheckForTabsAndSpacesMismatch(ITreeNode node, string realIndent, string expectedIndent, ITreeNode closingNode);
    protected IndentRegionInfo GetIndentRegionInfo(bool reallyIndent, bool markUsed);
    private void ProcessMultiLineTokenWithAccu(VirtNode tokenNode);
    private ITreeNode ProcessMultiLineComment(ITokenNode tokenNode, Whitespace newIndent);
    protected string CalcNodeIndent(ITreeNode node);
    protected Whitespace CalcNodeIndent(VirtNode node);
    private void TryCollapsePrevRegion(IndentRegionInfo& prevIndentInfo, VirtNode current, VirtNode closingNode, IndentType& indentType, bool delayed, string regionName, IReadOnlyCollection`1& observedSettings);
    private bool ShouldCollapsePrevRegion(IndentRegionInfo prevIndentInfo, VirtNode current, VirtNode closingNode, IndentType& indentType, bool delayed, string regionName);
    private bool CanCollapsePrevRegion(bool parentDelayed, VirtNode current, IndentType indentType, bool delayed, VirtNode closingNode, bool lineBreakBefore);
    private ObstacleType<TContext, TSettingsKey> IsPrevRegionCovered(VirtNode curRegionClosingNode, IndentType indentType, string regionName, IndentRegionInfo prevIndentInfo, bool canCollapseUnusedRegion);
    protected virtual IndentRegionInfo GetRegionByNode(VirtNode node, IndentType typeMask, TemporaryRules`1& temporaryRules);
    private IndentRegionInfo FindRegionAhead(VirtNode firstNode, VirtNode lastNode, bool isFirst, bool descentIntoFirst, bool descentIntoLast, bool noIndentAtLastRegion, bool canCollapseUnusedRegion, ObstacleType& obstacle, TemporaryRules`1& temporaryRules);
    private IndentType ModifyIndentTypeWithTypeMask(IndentType typeMask, IndentType indentType);
    private void ProcessNodeSide(IndentType endType, IndentType startTypes);
    protected virtual bool CloseIndents(IndentType endType);
    protected virtual void FindAndProcessIndentingRegions(IndentType startTypes);
    private sealed virtual override void JetBrains.ReSharper.Psi.Impl.CodeStyle.ISequentialNodeProcessor<TSettingsKey>.ProcessDescendIntoNode();
    public VirtNode GetNearestAlignmentNode();
    private sealed virtual override void JetBrains.ReSharper.Psi.Impl.CodeStyle.ISequentialNodeProcessor<TSettingsKey>.TaskStarted();
    private sealed virtual override void JetBrains.ReSharper.Psi.Impl.CodeStyle.ISequentialNodeProcessor<TSettingsKey>.FileStart();
    public sealed virtual void ProcessNodeEnd();
    public void Initialize();
    private void RegisterIndentDuringInitialization();
    protected virtual void MarkRegionAsAdjusted();
    private bool FindPrevSiblingOnNewLine(VirtNode& skipTo, VirtNode until, VirtNode& lineBreak);
    protected virtual void SplitInitialIndentToRegionsAfterSkipping();
    protected virtual void BeforeDescendForInitialize();
    protected virtual void ClearIndents();
    protected virtual void MarkUsedRegions();
    protected virtual void CloseExpiredIndentsAfterSkipping(VirtNode curParent);
    protected virtual void SplitInitialIndentToRegions(bool updateDelayed, bool checkAbsoluteIndent);
    protected virtual bool CalcNeedToGoToParent();
    protected bool CalcNeedToGoToParent(IIndentRegionInfoStack<TContext, TSettingsKey> indents);
    private void GoToStartNodeParent();
    private Whitespace GetIndentFromFile();
    private bool SetCurrentToCommonParent();
    private sealed virtual override bool JetBrains.ReSharper.Psi.Impl.CodeStyle.IIndentingStage<TSettingsKey>.ProcessIndentingRegion(IIndentingRule rule, VirtNode current, VirtNode closingNode, IndentType typeMask, IIndentOptionValue indentOptionValue, IReadOnlyCollection`1<IScalarSetting> observedSettings);
    protected IndentRegionInfo CalculateIndentInfo(IIndentingRule rule, VirtNode current, VirtNode closingNode, IndentType typeMask, IIndentOptionValue option, IReadOnlyCollection`1<IScalarSetting> observedSettings, bool forLookAhead);
    protected long get_FarAlignmentMargin();
    private void FixClosingNode(VirtNode current, IndentRegionInfo oldIndentInfo, VirtNode& closingNode, IndentType& indentType);
    protected bool IsFirstOnLine(VirtNode current);
    protected virtual bool ProcessIndent(VirtNode prevNode, VirtNode originalCurrent, Nullable`1<Whitespace> indent, VirtNode nodeToIndent);
    private ValueTuple`2<VirtNode, bool> FindNodeToInsertIndentBefore(VirtNode originalCurrent, Nullable`1<Whitespace> indent, VirtNode nodeToIndent);
    private static ValueTuple`2<ITreeNode, bool> FindPrevSiblingAndLineBreak(VirtNode nodeToInsertIndentBefore);
    public void IndentInsideToken(ITreeNode token, int position, IndentDelta delta, Nullable`1<Whitespace> approxIndent, bool closeIndent, String[] meaningfulSpaces);
    private VirtNode ThisOrPrecedingMacro(VirtNode node);
    [CompilerGeneratedAttribute]
private int <CheckIndentForDaemon>b__76_0(VirtNode x);
    [CompilerGeneratedAttribute]
private int <FindNodeToInsertIndentBefore>b__125_0(VirtNode x);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.IndentMap : Dictionary`2<ITokenNode, int> {
    public void SaveIndent(ITreeNode node, int indent);
    public int GetNodeIndent(ITreeNode node, IWhitespaceChecker codeFormatter, int tabWidth, Int32& unadjusted, bool includeNode);
}
public enum JetBrains.ReSharper.Psi.Impl.CodeStyle.IndentMismatchType : Enum {
    public int value__;
    public static IndentMismatchType NoRequiredIndent;
    public static IndentMismatchType IndentIsTooBig;
    public static IndentMismatchType IndentIsTooSmall;
    public static IndentMismatchType IndentIsOffPrevLevel;
    public static IndentMismatchType NoRequiredOutdent;
    public static IndentMismatchType OutdentIsTooBig;
    public static IndentMismatchType OutdentIsTooSmall;
    public static IndentMismatchType WrongIndentSizeOnComplexIndents;
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.IndentOptionValue : object {
    [CompilerGeneratedAttribute]
private IndentType <IndentType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StandardIndentMultiplier>k__BackingField;
    [CompilerGeneratedAttribute]
private Whitespace <AdditionalIndent>k__BackingField;
    public IndentType IndentType { get; }
    public int StandardIndentMultiplier { get; }
    public Whitespace AdditionalIndent { get; }
    public IndentOptionValue(IndentType indentType, int standardIndentMultiplier, Whitespace additionalIndent);
    [CompilerGeneratedAttribute]
public sealed virtual IndentType get_IndentType();
    [CompilerGeneratedAttribute]
public sealed virtual int get_StandardIndentMultiplier();
    [CompilerGeneratedAttribute]
public sealed virtual Whitespace get_AdditionalIndent();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.IndentRegionInfo : object {
    [CompilerGeneratedAttribute]
private IIndentingRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private IndentType <IndentType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OpenPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private TreeOffset <OpenTreePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtNode <OpeningNode>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtNode <ClosingNode>k__BackingField;
    [CompilerGeneratedAttribute]
private IndentDelta <IndentDelta>k__BackingField;
    [CompilerGeneratedAttribute]
private IndentDelta <IndentDeltaForAccu>k__BackingField;
    [CompilerGeneratedAttribute]
private IndentDelta <Indent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Adjusted>k__BackingField;
    [CompilerGeneratedAttribute]
private Whitespace[] <IndentHistory>k__BackingField;
    [CompilerGeneratedAttribute]
private IClosableIndentingHighlighting[] <HighlightingHistory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LineBreakAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LineBreakBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Used>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Delayed>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IScalarSetting> <ObservedSettings>k__BackingField;
    public IIndentingRule Rule { get; }
    public string Name { get; }
    public IndentType IndentType { get; }
    public int OpenPosition { get; public set; }
    public TreeOffset OpenTreePosition { get; public set; }
    public VirtNode OpeningNode { get; private set; }
    public VirtNode ClosingNode { get; private set; }
    public IndentDelta IndentDelta { get; public set; }
    public IndentDelta IndentDeltaForAccu { get; public set; }
    public IndentDelta Indent { get; public set; }
    public bool Adjusted { get; public set; }
    public Whitespace[] IndentHistory { get; public set; }
    public IClosableIndentingHighlighting[] HighlightingHistory { get; public set; }
    public bool LineBreakAfter { get; public set; }
    public bool LineBreakBefore { get; public set; }
    public bool Used { get; public set; }
    public bool Delayed { get; public set; }
    [NotNullAttribute]
public IReadOnlyCollection`1<IScalarSetting> ObservedSettings { get; public set; }
    public IndentRegionInfo(IIndentingRule rule, IndentType indentType, VirtNode openingNode, VirtNode closingNode, IndentDelta indent, IndentDelta indentDelta, bool delayed, IReadOnlyCollection`1<IScalarSetting> settings);
    public IndentRegionInfo(Whitespace indent, CodeFormattingContext context);
    [CompilerGeneratedAttribute]
public IIndentingRule get_Rule();
    public string get_Name();
    [CompilerGeneratedAttribute]
public IndentType get_IndentType();
    [CompilerGeneratedAttribute]
public int get_OpenPosition();
    [CompilerGeneratedAttribute]
public void set_OpenPosition(int value);
    [CompilerGeneratedAttribute]
public TreeOffset get_OpenTreePosition();
    [CompilerGeneratedAttribute]
public void set_OpenTreePosition(TreeOffset value);
    [CompilerGeneratedAttribute]
public VirtNode get_OpeningNode();
    [CompilerGeneratedAttribute]
private void set_OpeningNode(VirtNode value);
    [CompilerGeneratedAttribute]
public VirtNode get_ClosingNode();
    [CompilerGeneratedAttribute]
private void set_ClosingNode(VirtNode value);
    [CompilerGeneratedAttribute]
public IndentDelta get_IndentDelta();
    [CompilerGeneratedAttribute]
public void set_IndentDelta(IndentDelta value);
    [CompilerGeneratedAttribute]
public IndentDelta get_IndentDeltaForAccu();
    [CompilerGeneratedAttribute]
public void set_IndentDeltaForAccu(IndentDelta value);
    [CompilerGeneratedAttribute]
public IndentDelta get_Indent();
    [CompilerGeneratedAttribute]
public void set_Indent(IndentDelta value);
    [CompilerGeneratedAttribute]
public bool get_Adjusted();
    [CompilerGeneratedAttribute]
public void set_Adjusted(bool value);
    [CompilerGeneratedAttribute]
public Whitespace[] get_IndentHistory();
    [CompilerGeneratedAttribute]
public void set_IndentHistory(Whitespace[] value);
    [CompilerGeneratedAttribute]
public IClosableIndentingHighlighting[] get_HighlightingHistory();
    [CompilerGeneratedAttribute]
public void set_HighlightingHistory(IClosableIndentingHighlighting[] value);
    [CompilerGeneratedAttribute]
public bool get_LineBreakAfter();
    [CompilerGeneratedAttribute]
public void set_LineBreakAfter(bool value);
    [CompilerGeneratedAttribute]
public bool get_LineBreakBefore();
    [CompilerGeneratedAttribute]
public void set_LineBreakBefore(bool value);
    [CompilerGeneratedAttribute]
public bool get_Used();
    [CompilerGeneratedAttribute]
public void set_Used(bool value);
    [CompilerGeneratedAttribute]
public bool get_Delayed();
    [CompilerGeneratedAttribute]
public void set_Delayed(bool value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<IScalarSetting> get_ObservedSettings();
    [CompilerGeneratedAttribute]
public void set_ObservedSettings(IReadOnlyCollection`1<IScalarSetting> value);
    public IndentRegionInfo Copy();
    internal void SetIndent(Whitespace standardIndent, Whitespace indent, IClosableIndentingHighlighting highlighting, ITreeNode closingNode);
    public virtual string ToString();
    public void HandleNodeReplace(ITreeNode oldNode, VirtNode newNode);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Impl.CodeStyle.IndentType : Enum {
    public int value__;
    public static IndentType StartAtInternal;
    public static IndentType StartAtExternal;
    public static IndentType EndAtInternal;
    public static IndentType EndAtExternal;
    public static IndentType Alignment;
    public static IndentType NoIndentAtExternal;
    public static IndentType StartAfterFirstToken;
    public static IndentType NonSticky;
    public static IndentType IgnoreOverlappingRegions;
    public static IndentType AbsoluteIndent;
    public static IndentType LeaveAsIs;
    public static IndentType Transparent;
    public static IndentType OverrideAlignment;
    public static IndentType NoOverrideByIndentlessRegions;
    public static IndentType Outdent;
    public static IndentType NonAdjustable;
    public static IndentType CancelledAlignment;
    public static IndentType AllowOverrideByOneLinedRegions;
    public static IndentType MayBeAffectedByIntAlign;
    public static IndentType CrossLanguage;
    public static IndentType ContinuousIndent;
    public static IndentType PossibleExternalIndentTypes;
    public static IndentType PossibleInternalIndentTypes;
    public static IndentType AllStartIndentTypes;
    public static IndentType BothAtEnd;
    public static IndentType Internal;
    public static IndentType ExternalNoIndent;
    public static IndentType InternalCollapsible;
    public static IndentType External;
    public static IndentType InternalAndExternal;
    public static IndentType AlignTill;
    public static IndentType AlignThrough;
    public static IndentType AlignAndIndentFromInternalThrough;
    public static IndentType AlignAtExternalAndIndentAtInternal;
    public static IndentType AfterFirstToken;
    public static IndentType None;
}
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.InjectedInLiteralsCodeFormatterUtil : object {
    public static bool CanModify(ITreeNode element, CodeFormattingContext context);
    public static bool CanModifyInsideNodeRange(ITreeNode leftElement, ITreeNode rightElement, CodeFormattingContext context);
    public static bool IsWhitespaceToken(ITokenNode token);
    public static void RemoveLeadingAndTrailingSpacesInFile(IFile fileNode, IContextBoundSettingsStore overrideSettingsStore);
    public static void InsertLineFeedAtFileEndIfNeeded(IFile fileNode, IContextBoundSettingsStore overrideSettingsStore);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.INodePattern {
    public int PerformanceRating { get; }
    public abstract virtual IEnumerable`1<NodeType> GetNodeTypes();
    public abstract virtual bool Matches(ITreeNode node, CodeFormattingContext context);
    public abstract virtual int get_PerformanceRating();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.IntAlignOptionValue : object {
    [CompilerGeneratedAttribute]
private object <ID>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    public object ID { get; }
    public int Priority { get; }
    public IntAlignOptionValue(object id, int priority);
    public sealed virtual IIntAlignOptionValue Merge(IIntAlignOptionValue lowPriority, bool alwaysMerge, MergeKind& mergeKind);
    [CompilerGeneratedAttribute]
public sealed virtual object get_ID();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.IntAlignRule : FormattingRuleBase`1<IIntAlignOptionValue> {
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.IntAlignStage`2 : FormatterStageBase`2<TContext, TSettingsKey> {
    protected IFormatterInfoProvider`2<TContext, TSettingsKey> myProvider;
    protected IProgressIndicator myProgress;
    protected List`1<IntAlignLine<TContext, TSettingsKey>> myLines;
    protected List`1<IntAlignColumn<TContext, TSettingsKey>> myColumns;
    protected HashSet`1<IScalarSetting`1<bool>> myPureIntAlignSettings;
    protected bool myIntAlignEnabled;
    protected int myMargin;
    [CompilerGeneratedAttribute]
private SequentialNodeIterator`2<TContext, TSettingsKey> <Iterator>k__BackingField;
    public SequentialNodeIterator`2<TContext, TSettingsKey> Iterator { get; }
    public IntAlignStage`2(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IFormatterInfoProvider`2<TContext, TSettingsKey> provider, IProgressIndicator progress, HashSet`1<IScalarSetting`1<bool>> pureIntAlignSettings);
    [CompilerGeneratedAttribute]
public SequentialNodeIterator`2<TContext, TSettingsKey> get_Iterator();
    protected virtual bool CalcIntAlignEnabled();
    private void CalcMargin();
    public virtual void DoFormat();
    protected virtual void ProcessBlockWithIntAlign(int startInclusive, int endExclusive);
    protected void DoProcessBlockWithIntAlign(int startInclusive, int endExclusive, Func`2<IntAlignInterval<TContext, TSettingsKey>, bool> intervalFilter);
    protected void ProcessLines();
    protected virtual void DoIntAlign();
    public void FormatRange(FormattingRangeContext formattingStageContext);
    protected virtual void FindAndProcessOption(FormattingRangeContext formattingStageContext);
    protected IntAlignInterval<TContext, TSettingsKey> ProcessOption(FormattingRangeContext formattingStageContext, IIntAlignOptionValue currentOption);
    public virtual void SettingsChanged(FmtSettingsHolder`1<TSettingsKey> newSettings);
    public sealed virtual void AllTaskFinished();
    public sealed virtual void TaskStarted();
    public sealed virtual void FileStart();
    public sealed virtual void ProcessNodeEnd();
    public sealed virtual void ProcessLineBreak(VirtNode& lineBreak);
    public sealed virtual void ProcessDescendIntoNode();
    public virtual void TaskFinished(VirtNode& dontReallyFinishUntilThisNode);
    public sealed virtual VirtNode FixLastNodeWhenEmptyInterval(VirtNode lastNode);
    public sealed virtual void ProcessNextSolidNode(FormattingRangeContext context);
    public sealed virtual VirtNode GetNextSibling(VirtNode node);
    public sealed virtual ITreeNode GetFirstChild(ITreeNode node);
    public virtual void Initialize(Boolean& currentNodeInitialized);
    private void ProcessRangeForLookAhead(FormattingRangeContext ctx, ValueTuple`2& range, LocalHashSet`1& ids);
    public sealed virtual void PreProcessNextSolidNode(FormattingRangeContext context);
    [CompilerGeneratedAttribute]
private bool <CalcIntAlignEnabled>b__14_0(IScalarSetting`1<bool> setting);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Impl.CodeStyle.IntervalFormatType : Enum {
    public int value__;
    public static IntervalFormatType None;
    public static IntervalFormatType RemoveSpace;
    public static IntervalFormatType InsertSpace;
    public static IntervalFormatType InsertTab;
    public static IntervalFormatType RemoveUserNewLines;
    public static IntervalFormatType InsertNewLine;
    public static IntervalFormatType Inherited;
    public static IntervalFormatType ReallyDoNotChangeAnything;
    public static IntervalFormatType ProhibitNewLines;
    public static IntervalFormatType InsertNewLineConditionally;
    public static IntervalFormatType DoNotRemoveUserNewLines;
    public static IntervalFormatType LateInsertNewLine;
    public static IntervalFormatType PlaceToWrap;
    public static IntervalFormatType GoodPlaceToWrap;
    public static IntervalFormatType ExcellentPlaceToWrap;
    public static IntervalFormatType NoWrap;
    public static IntervalFormatType GeneratorMode;
    public static IntervalFormatType Empty;
    public static IntervalFormatType OnlyEmpty;
    public static IntervalFormatType Space;
    public static IntervalFormatType OnlySpace;
    public static IntervalFormatType NoLineBreaks;
    public static IntervalFormatType NewLine;
    public static IntervalFormatType SpaceOptions;
    public static IntervalFormatType LineBreakOptions;
    public static IntervalFormatType DoNotChange;
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IOptionNode {
    public abstract virtual IOptionValue GetOptionValue(ISettingValueReader reader, object data, CodeFormattingContext context);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IOptionNodeWithChildValues {
    public IEnumerable`1<IOptionValue> Values { get; }
    public abstract virtual IEnumerable`1<IOptionValue> get_Values();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IOptionValue {
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IOptionValueQueryResult`1 {
    public TOptionValue Value { get; }
    [NotNullAttribute]
public IReadOnlyCollection`1<IScalarSetting> ObservedSettings { get; }
    public RuleResultInfo`1[] BreakdownByRule { get; }
    public abstract virtual TOptionValue get_Value();
    public abstract virtual IReadOnlyCollection`1<IScalarSetting> get_ObservedSettings();
    public abstract virtual RuleResultInfo`1[] get_BreakdownByRule();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IRegionRule {
    public long Group { get; public set; }
    public int Priority { get; public set; }
    public abstract virtual long get_Group();
    public abstract virtual void set_Group(long value);
    public abstract virtual IEnumerable`1<NodeType> GetNodeTypes();
    public abstract virtual int get_Priority();
    public abstract virtual void set_Priority(int value);
    public abstract virtual bool MatchesPatterns(VirtNode node, CodeFormattingContext context);
    public abstract virtual VirtNode GetClosingNode(VirtNode node, CodeFormattingContext context);
    public abstract virtual IOptionNode GetOptionTree(VirtNode node, CodeFormattingContext context);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.ISelectorOptionNode {
    public IScalarSetting Setting { get; }
    public abstract virtual IScalarSetting get_Setting();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.ISequentialNodeProcessor`1 {
    public abstract virtual void Initialize(Boolean& currentNodeInitialized);
    public abstract virtual VirtNode FixLastNodeWhenEmptyInterval(VirtNode lastNode);
    public abstract virtual void FileStart();
    public abstract virtual void TaskStarted();
    public abstract virtual void TaskFinished(VirtNode& dontReallyFinishUntilThisNode);
    public abstract virtual void ProcessNodeEnd();
    public abstract virtual void ProcessLineBreak(VirtNode& lineBreak);
    public abstract virtual void ProcessDescendIntoNode();
    public abstract virtual void PreProcessNextSolidNode(FormattingRangeContext context);
    public abstract virtual void ProcessNextSolidNode(FormattingRangeContext context);
    public abstract virtual VirtNode GetNextSibling(VirtNode node);
    public abstract virtual ITreeNode GetFirstChild(ITreeNode node);
    public abstract virtual void SettingsChanged(FmtSettingsHolder`1<TSettingsKey> newSettings);
    public abstract virtual void AllTaskFinished();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.ISettingValueReader {
    [NotNullAttribute]
public IReadOnlyCollection`1<IScalarSetting> PotentSettingsEntries { get; }
    public abstract virtual void ClearTrackedEntries();
    public abstract virtual object GetOptionValue(IScalarSetting setting);
    public abstract virtual T GetOrCreateCachedValue(Key`1<T> key, Func`2<ISettingValueReader, T> creator);
    public abstract virtual IReadOnlyCollection`1<IScalarSetting> get_PotentSettingsEntries();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.ISettingValueReader`1 {
    public abstract virtual void SettingsChanged(FmtSettingsHolder`1<TSettingsKey> settings);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.ISimpleSequentialNodeProcessor`1 {
    public abstract virtual void FormatRange(FormattingRangeContext context);
    public abstract virtual void SettingsChanged(FmtSettingsHolder`1<TSettingsKey> newSettings);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.ITemporaryIndentingRule {
    public bool CouldBeDelayed { get; }
    public abstract virtual bool get_CouldBeDelayed();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.ITemporaryRule {
    public bool CheckUntilNodeRightSide { get; }
    public bool RemoveAfterApplying { get; }
    public abstract virtual bool get_CheckUntilNodeRightSide();
    public abstract virtual bool get_RemoveAfterApplying();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.ITemporaryRuleProvider`1 {
    public bool CheckOnNodeRightSide { get; }
    public abstract virtual ValueTuple`2<VirtNode, TRule> GetTemporaryRule(VirtNode current, CodeFormattingContext context);
    public abstract virtual bool get_CheckOnNodeRightSide();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.ITemporaryWrapGroupRule {
}
public enum JetBrains.ReSharper.Psi.Impl.CodeStyle.IteratorState : Enum {
    public int value__;
    public static IteratorState FileStart;
    public static IteratorState BeforeDescend;
    public static IteratorState Descend;
    public static IteratorState AfterDescend;
    public static IteratorState Ascend;
    public static IteratorState EndOfNode;
    public static IteratorState SkipWhitespaces;
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IWhitespaceChecker {
    [ContractAnnotationAttribute("token:null=>false")]
public abstract virtual bool IsWhitespaceToken(ITokenNode token);
    [ContractAnnotationAttribute("node:null=>false")]
public abstract virtual bool IsWhitespaceToken(ITreeNode node);
    [ContractAnnotationAttribute("null => false")]
public abstract virtual bool IsNewLine(ITreeNode ws);
    [ContractAnnotationAttribute("null => false")]
public abstract virtual bool IsPureSpace(ITreeNode ws);
    [ContractAnnotationAttribute("null => false")]
public abstract virtual bool CanBeMultilineToken(ITreeNode node);
    [CanBeNullAttribute]
public abstract virtual ITreeNode NextFormattableSibling(ITreeNode node);
    [CanBeNullAttribute]
public abstract virtual ITreeNode PrevFormattableSibling(ITreeNode node);
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IWrapGroupOptionValue {
    public WrapType WrapType { get; }
    public abstract virtual WrapType get_WrapType();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IWrapGroupRule {
    public string LineBreaksAroundHighlighting { get; }
    public abstract virtual string get_LineBreaksAroundHighlighting();
}
public interface JetBrains.ReSharper.Psi.Impl.CodeStyle.IWrappingStage`1 {
    public abstract virtual void ProcessRegion(IWrapGroupRule rule, VirtNode current, VirtNode closingNode, WrapType wrapType, IEnumerable`1<IScalarSetting> observedSettings, int position);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.JustDocumentMappedFormattingCookie : object {
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.JustPsiFormattingCookie : object {
}
public enum JetBrains.ReSharper.Psi.Impl.CodeStyle.KeepTogetherPolicy : Enum {
    public int value__;
    public static KeepTogetherPolicy Always;
    public static KeepTogetherPolicy ExceptTheOnlyElement;
    public static KeepTogetherPolicy ExceptFirstElement;
    public static KeepTogetherPolicy ExceptFirstLineElement;
    public static KeepTogetherPolicy Never;
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.LambdaOptionNode : object {
    private Func`3<object, CodeFormattingContext, IOptionValue> myLambda;
    public LambdaOptionNode(Func`3<object, CodeFormattingContext, IOptionValue> lambda);
    public sealed virtual IOptionValue GetOptionValue(ISettingValueReader reader, object data, CodeFormattingContext context);
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Impl.CodeStyle.MergeableOptionValueExtensions : object {
    [ExtensionAttribute]
internal static IOptionValueQueryResult`1<TOptionValue> QueryOptionValueOnInterval(IList`1<IFormattingRule`2<TSettingsKey, TOptionValue>> rules, FormattingRangeContext interval, IFormatterStageBase`1<TSettingsKey> stage, TContext context, bool log, bool breakdownByRule);
    [ExtensionAttribute]
public static IOptionValueQueryResult`1<TOptionValue> Merge(IOptionValueQueryResult`1<TOptionValue> highPriority, IOptionValueQueryResult`1<TOptionValue> lowPriority, bool alwaysMerge);
    [NotNullAttribute]
public static IReadOnlyCollection`1<IScalarSetting> Union(IReadOnlyCollection`1<IScalarSetting> left, IReadOnlyCollection`1<IScalarSetting> right);
    [ExtensionAttribute]
[NotNullAttribute]
internal static IOptionValueQueryResult`1<TOptionValue> QueryOptionValue(IOptionNode node, IFormatterStageBase context, CodeFormattingContext context1, IFormatterRule rule, object data, bool breakDownByRule);
    [ExtensionAttribute]
public static IndentType GetAllIndentingTypes(IOptionValue value);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Impl.CodeStyle.MergeKind : Enum {
    public int value__;
    public static MergeKind None;
    public static MergeKind LowPriority;
    public static MergeKind HighPriority;
    public static MergeKind Both;
}
public enum JetBrains.ReSharper.Psi.Impl.CodeStyle.MinimalSeparatorType : Enum {
    public int value__;
    public static MinimalSeparatorType NotRequired;
    public static MinimalSeparatorType Space;
    public static MinimalSeparatorType NewLine;
}
public enum JetBrains.ReSharper.Psi.Impl.CodeStyle.MultilinePermissibility : Enum {
    public int value__;
    public static MultilinePermissibility SingleAndMulti;
    public static MultilinePermissibility OnlyMultiline;
    public static MultilinePermissibility OnlySingleline;
}
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.NodePattern : object {
    public static INodePattern Create(short childRole, NodeTypeSet nodeTypeSet, NodeType nodeType, Type type, Func`3<VirtNode, CodeFormattingContext, bool> predicate, INodePattern parentPattern, Func`3[] predicate2, Func`3[] predicate3);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.NodePatternBlank : BlankBase {
    internal short ChildRole;
    internal NodeTypeSet NodeTypeSet;
    internal NodeType NodeType;
    internal Type Type;
    internal Func`3<VirtNode, CodeFormattingContext, bool> Predicate;
    internal Func`3[] Predicate2;
    internal Func`3[] Predicate3;
    internal List`1<NodePatternBlank> OrList;
    internal List`1<NodePatternBlank> AndList;
    internal bool Not;
    [CompilerGeneratedAttribute]
private NodePatternBlank <Parent>k__BackingField;
    internal NodePatternBlank Parent { get; private set; }
    [CompilerGeneratedAttribute]
internal NodePatternBlank get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(NodePatternBlank value);
    public void SetParent(NodePatternBlank pattern);
    public void AddPredicate(Func`3<VirtNode, CodeFormattingContext, bool> predicate);
    public void AddContextPredicate(Func`3<VirtNode, CodeFormattingContext, bool> predicate);
    protected virtual void ShallowToDeepCopy();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.NodePatternBuilderEx : object {
    [ExtensionAttribute]
public static INodePattern BuildPattern(NodePatternBlank storage);
    private static INodePattern BuildOrPatternIfNeeded(List`1<NodePatternBlank> orList, INodePattern pattern);
    private static INodePattern BuildAndPatternIfNeeded(List`1<NodePatternBlank> andList, INodePattern pattern);
    [ExtensionAttribute]
public static TBuilder Is(TBuilder builder, NodePatternBlank obj);
    [ExtensionAttribute]
public static T Or(T builder);
    [ExtensionAttribute]
public static T And(T builder);
    [ExtensionAttribute]
public static T OptionallyPreceededBy(T builder, NodeTypeSet set);
    [ExtensionAttribute]
public static T Not(T builder);
    [ExtensionAttribute]
public static T HasRole(T builder, short childRole);
    [ExtensionAttribute]
public static T In(T builder, NodeTypeSet nodeTypeSet);
    [ExtensionAttribute]
public static T In(T builder, NodeType[] nodeTypes);
    [ExtensionAttribute]
public static T Or(T builder, NodeTypeSet nodeTypeSet);
    [ExtensionAttribute]
public static T Or(T builder, NodeType[] nodeTypes);
    [ExtensionAttribute]
public static T Except(T builder, NodeTypeSet nodeTypeSet);
    [ExtensionAttribute]
public static T Except(T builder, NodeType[] nodeTypes);
    [ExtensionAttribute]
public static T HasType(T builder, NodeType nodeType);
    [ExtensionAttribute]
public static T HasType(T builder, Type type);
    [ExtensionAttribute]
public static T Satisfies(T builder, Func`3<VirtNode, CodeFormattingContext, bool> predicate);
    [ExtensionAttribute]
public static T Satisfies2(T builder, Func`3<VirtNode, CodeFormattingContext, bool> predicate);
    [ExtensionAttribute]
public static T SatisfiesEx(T builder, Func`3<VirtNode, CodeFormattingContext, bool> predicate);
    [ExtensionAttribute]
public static INodePattern Build(IBuilderAction`1<IBlankWithSinglePattern> patternBuilder);
    [ExtensionAttribute]
public static NodePatternBlank BuildBlank(IBuilderAction`1<IBlankWithSinglePattern> patternBuilder);
    [ExtensionAttribute]
public static INodePattern Build(IBuilderAction`1[] patternBuilders);
    [ExtensionAttribute]
public static NodePatternBlank BuildBlank(IBuilderAction`1[] patternBuilders);
    [ExtensionAttribute]
public static Pair`2<NodePatternBlank, NodePatternBlank> BuildBlankWithTwoPatterns(IBuilderAction`1[] patternBuilders, bool linkSecondPatternToParent);
    [ExtensionAttribute]
public static T Parent(T builder, IBuilderAction`1<IBlankWithSinglePattern> pattern);
    [ExtensionAttribute]
public static T Parent(T builder, NodePatternBlank pattern);
    [ExtensionAttribute]
public static T After(T builder, IBuilderAction`1[] patternBuilders);
    [ExtensionAttribute]
public static T After(T builder, INodePattern pattern);
    [ExtensionAttribute]
public static T Before(T builder, IBuilderAction`1[] patternBuilders);
    [ExtensionAttribute]
public static T Before(T builder, INodePattern pattern);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.NodePatternEx : object {
    [ExtensionAttribute]
public static bool Matches(INodePattern pattern, VirtNode node, CodeFormattingContext context);
}
internal class JetBrains.ReSharper.Psi.Impl.CodeStyle.NodePatternExceptionList : List`1<Pair`2<INodePattern, INodePattern>> {
    public bool FirstOrAfterExceptions(VirtNode node, CodeFormattingContext checker);
    public bool NotException(VirtNode node, CodeFormattingContext checker);
    public VirtNode GetCloseNode(VirtNode node, CodeFormattingContext checker);
    internal static ValueTuple`2<NodePatternExceptionList, ChildBuilder`2<IBlankWithSinglePattern, NodePatternBlank>> CreateNodePatternExceptionList(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider, List`1<IBuilderAction`1[]> exceptions);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.NodeTypePattern : object {
    private NodeType myNodeType;
    public int PerformanceRating { get; }
    public NodeTypePattern(NodeType nodeType);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.CodeStyle.NodeTypePattern/<GetNodeTypes>d__2")]
public sealed virtual IEnumerable`1<NodeType> GetNodeTypes();
    public sealed virtual bool Matches(ITreeNode node, CodeFormattingContext context);
    public virtual string ToString();
    public sealed virtual int get_PerformanceRating();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.NodeTypeSetPattern : object {
    private NodeTypeSet myNodeTypeSet;
    public int PerformanceRating { get; }
    public NodeTypeSetPattern(NodeTypeSet nodeTypeSet);
    public sealed virtual IEnumerable`1<NodeType> GetNodeTypes();
    public sealed virtual bool Matches(ITreeNode node, CodeFormattingContext context);
    public virtual string ToString();
    public sealed virtual int get_PerformanceRating();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.NotNodePattern : object {
    private INodePattern myPattern;
    public int PerformanceRating { get; }
    public NotNodePattern(INodePattern pattern);
    public sealed virtual IEnumerable`1<NodeType> GetNodeTypes();
    public sealed virtual bool Matches(ITreeNode node, CodeFormattingContext context);
    public virtual string ToString();
    public sealed virtual int get_PerformanceRating();
}
[ObsoleteAttribute("Deprecated CodeStyle APIs")]
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.Obsolete.CodeStyleSettingsManager : object {
    private JetHashSet`1<SettingsClassInfo> myCodeStyleTypes;
    internal IEnumerable`1<SettingsClassInfo> CodeStyleTypes { get; }
    public CodeStyleSettingsManager(Lifetime lifetime, IPartCatalogSet catalog);
    internal IEnumerable`1<SettingsClassInfo> get_CodeStyleTypes();
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0(Lifetime typeLifetime, Type type);
}
[ObsoleteAttribute("Deprecated CodeStyle APIs")]
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.Obsolete.CodeStyleSettingsShellStore : object {
    private static string ConfigName;
    private static XmlExternalizationScope ConfigScope;
    private XmlElement myConfiguration;
    private Tuple`2<XmlElement, Version> myOldConfiguration;
    private CodeStyleSettingsObsolete myCodeStyleSettings;
    private CodeStyleSettingsManager myCodeStyleSettingsManager;
    [CompilerGeneratedAttribute]
private Action CodeStyleSettingsChanged;
    public CodeStyleSettingsManager CodeStyleSettingsManager { get; }
    public CodeStyleSettingsObsolete CodeStyleSettings { get; public set; }
    public IEnumerable`1<string> LegacyTagNames { get; }
    public CodeStyleSettingsShellStore(IComponentSettingsProvider settings, CodeStyleSettingsManager codeStyleSettingsManager);
    public virtual CodeStyleSettingsManager get_CodeStyleSettingsManager();
    [CompilerGeneratedAttribute]
public void add_CodeStyleSettingsChanged(Action value);
    [CompilerGeneratedAttribute]
public void remove_CodeStyleSettingsChanged(Action value);
    public CodeStyleSettingsObsolete get_CodeStyleSettings();
    public void set_CodeStyleSettings(CodeStyleSettingsObsolete value);
    private sealed virtual override void JetBrains.Application.Configuration.IXmlReadable.ReadFromXml(XmlElement element);
    public sealed virtual IEnumerable`1<string> get_LegacyTagNames();
    public sealed virtual bool UpgradeFromXml(XmlElement element, Version version);
}
[ObsoleteAttribute("Deprecated CodeStyle APIs")]
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.Obsolete.CodeStyleSettingsSolutionStore : object {
    private CodeStyleSettingsShellStore myCodeStyleSettingsStore;
    private ISolution mySolution;
    private CodeStyleSettingsObsolete myCodeStyleSettings;
    private IProperty`1<CodeStyleSettingsSharing> mySharing;
    private IProperty`1<string> myExternalPath;
    [CompilerGeneratedAttribute]
private CodeStyleSettingsManager <CodeStyleSettingsManager>k__BackingField;
    public CodeStyleSettingsManager CodeStyleSettingsManager { get; }
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public IProperty`1<CodeStyleSettingsSharing> Sharing { get; }
    [XmlExternalizableAttribute("Mono.Cecil.CustomAttributeArgument")]
public IProperty`1<string> ExternalPath { get; }
    public CodeStyleSettingsObsolete CodeStyleSettings { get; }
    private XmlExternalizationScope Scope { get; }
    private string TagName { get; }
    public CodeStyleSettingsSolutionStore(Lifetime lifetime, IComponentSettingsProvider solutionSettingsComponent, CodeStyleSettingsShellStore codeStyleSettingsStore, CodeStyleSettingsManager codeStyleSettingsManager, ISolution solution);
    [CompilerGeneratedAttribute]
public CodeStyleSettingsManager get_CodeStyleSettingsManager();
    public virtual IProperty`1<CodeStyleSettingsSharing> get_Sharing();
    public virtual IProperty`1<string> get_ExternalPath();
    public virtual CodeStyleSettingsObsolete get_CodeStyleSettings();
    private XmlExternalizationScope get_Scope();
    private string get_TagName();
    private sealed virtual override void JetBrains.Application.Configuration.IXmlReadable.ReadFromXml(XmlElement element);
}
internal class JetBrains.ReSharper.Psi.Impl.CodeStyle.Obsolete.SettingsClassInfo : object {
    public Type Type;
    public string TagName { get; }
    public SettingsClassInfo(Type type);
    public string get_TagName();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public abstract class JetBrains.ReSharper.Psi.Impl.CodeStyle.OptimizeImportsAndReferencesEngine : object {
    [CompilerGeneratedAttribute]
private IFile <File>k__BackingField;
    [CompilerGeneratedAttribute]
private IRangeMarker <RangeMarker>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferenceContextCodec <ReferenceContextCodec>k__BackingField;
    [CompilerGeneratedAttribute]
private IDocument <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private IRegionsInfo <RegionsInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IContextBoundSettingsStore <SettingsStore>k__BackingField;
    [NotNullAttribute]
public IFile File { get; }
    [CanBeNullAttribute]
public IRangeMarker RangeMarker { get; }
    [NotNullAttribute]
protected ReferenceContextCodec ReferenceContextCodec { get; }
    [NotNullAttribute]
protected IDocument Document { get; }
    [CanBeNullAttribute]
protected IRegionsInfo RegionsInfo { get; }
    [NotNullAttribute]
protected IContextBoundSettingsStore SettingsStore { get; }
    protected OptimizeImportsAndReferencesEngine(IFile file, IRangeMarker rangeMarker);
    [CompilerGeneratedAttribute]
public IFile get_File();
    [CompilerGeneratedAttribute]
public IRangeMarker get_RangeMarker();
    [CompilerGeneratedAttribute]
protected ReferenceContextCodec get_ReferenceContextCodec();
    [CompilerGeneratedAttribute]
protected IDocument get_Document();
    [CompilerGeneratedAttribute]
protected IRegionsInfo get_RegionsInfo();
    [CompilerGeneratedAttribute]
protected IContextBoundSettingsStore get_SettingsStore();
    [NotNullAttribute]
protected abstract virtual IGeneratedCodeRegionDetector CreateGeneratedCodeRegionDetector();
    protected abstract virtual HashSet`1<ITreeNode> GetUsedImports();
    protected abstract virtual void RemoveImportsAndAddMandatory(HashSet`1<ITreeNode> usedImports);
    protected abstract virtual void ReindentImports();
    [CanBeNullAttribute]
protected abstract virtual IQualifiableReference ShortenReferenceCore(IQualifiableReference reference, DeclaredElementInstance instance);
    protected abstract virtual ReferenceOptimizationKind GetReferenceKind(IReference reference, IDeclaredElement target);
    protected abstract virtual void ShortenStaticMemberReferences(Dictionary`2<IReference, IResolveResult> referenceResolveMap);
    [PureAttribute]
protected abstract virtual bool CanRequireImport(IReference reference);
    protected abstract virtual void AddImportForExtensionMethodIfRequired(IReference reference, IMethod extensionMethod);
    public void Run(bool optimizeUsings, bool shortenReferences, IProgressIndicator progressIndicator);
    private void UpdateCachesAndResolveReferences();
    [NotNullAttribute]
private Dictionary`2<IReference, IResolveResult> ReBindReferences(OptimizeReferenceCollector collector, bool shortenReferences, IProgressIndicator progressIndicator);
    [NotNullAttribute]
private List`1<KeyValuePair`2<IReference, IResolveResult>> ShortenNamespaceOrTypeReferences(List`1<KeyValuePair`2<IReference, IResolveResult>> list, OptimizeReferenceCollector collector, bool shortenReferences);
    [CanBeNullAttribute]
private IQualifiableReference ShortenReference(IQualifiableReference reference, DeclaredElementInstance target);
    [CanBeNullAttribute]
private IQualifiableReference TryShortenNamespaceOrTypeReference(IQualifiableReference reference, OptimizeReferenceCollector collector, bool shortenReferences);
    private IReference ReBindReference(IReference reference, IResolveResult resolveResult);
    private void SetFakeResolve(IReference reference, IResolveResult resolveResult);
    private void ClearFakeResolve(IReference reference);
    private static IResolveResult GetFakeResolve(IReference reference);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.OptionNode : object {
    private IEnumerable`1<IOptionValue> myValues;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <KeyGetter>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting <Setting>k__BackingField;
    [CompilerGeneratedAttribute]
private Pair`2[] <Values>k__BackingField;
    public Func`2<object, object> KeyGetter { get; }
    public IScalarSetting Setting { get; }
    public Pair`2[] Values { get; }
    private IEnumerable`1<IOptionValue> JetBrains.ReSharper.Psi.Impl.CodeStyle.IOptionNodeWithChildValues.Values { get; }
    public OptionNode(Func`2<object, object> keyGetter, IScalarSetting setting, Pair`2[] values);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_KeyGetter();
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting get_Setting();
    [CompilerGeneratedAttribute]
public Pair`2[] get_Values();
    public sealed virtual IOptionValue GetOptionValue(ISettingValueReader reader, object data, CodeFormattingContext context);
    private sealed virtual override IEnumerable`1<IOptionValue> JetBrains.ReSharper.Psi.Impl.CodeStyle.IOptionNodeWithChildValues.get_Values();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.OptionTreeBlank : BlankBase {
    internal object Case;
    internal object TheOnlyValue;
    internal IScalarSetting Setting;
    internal OptionTreeBlank[] Values;
    public static Pair`2[] CreatePairs(Func`2<object, object> settingKeyGetter, OptionTreeBlank[] values);
    public Pair`2<object, IOptionValue> CreatePair(Func`2<object, object> settingKeyGetter);
    public IOptionValue CreateOptionValue(Func`2<object, object> settingKeyGetter);
    public IOptionNode CreateOptionNode(Func`2<object, object> settingKeyGetter);
    public sealed virtual void RunWithOptionTree(Action`1<OptionTreeBlank> action);
    public sealed virtual void Build(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
}
internal class JetBrains.ReSharper.Psi.Impl.CodeStyle.OptionValueQueryResult`1 : object {
    public static IOptionValueQueryResult`1<TOptionValue> Empty;
    [CompilerGeneratedAttribute]
private TOptionValue <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IScalarSetting> <ObservedSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private RuleResultInfo`1[] <BreakdownByRule>k__BackingField;
    public TOptionValue Value { get; }
    public IReadOnlyCollection`1<IScalarSetting> ObservedSettings { get; }
    public RuleResultInfo`1[] BreakdownByRule { get; }
    public OptionValueQueryResult`1(TOptionValue value, IReadOnlyCollection`1<IScalarSetting> settings, RuleResultInfo`1[] breakdownByRule);
    private static OptionValueQueryResult`1();
    [CompilerGeneratedAttribute]
public sealed virtual TOptionValue get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyCollection`1<IScalarSetting> get_ObservedSettings();
    [CompilerGeneratedAttribute]
public sealed virtual RuleResultInfo`1[] get_BreakdownByRule();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.OrNodePattern : object {
    private INodePattern[] myChildPatterns;
    public int PerformanceRating { get; }
    public OrNodePattern(INodePattern[] childPatterns);
    public sealed virtual IEnumerable`1<NodeType> GetNodeTypes();
    public sealed virtual bool Matches(ITreeNode node, CodeFormattingContext context);
    public virtual string ToString();
    public sealed virtual int get_PerformanceRating();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.ParenthesisRule : ParenthesisRuleBase {
    [CompilerGeneratedAttribute]
private LambdaExpression <SpacesBeforeLParSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <SpacesBeforeEmptyParsSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <IndentParsSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <AlignSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <NoOverrideByIndentlessRegionsSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoWrapBeforeRPar>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentByOneChar>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OutsideIndentIfLParIsFirstChild>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CollapsibleIndentOnlyIfLineBreaksNearParens>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoOverrideByIndentlessRegions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoAlignIfLBraceAtTheEndOfLine>k__BackingField;
    public LambdaExpression SpacesBeforeLParSetting { get; public set; }
    public LambdaExpression SpacesBeforeEmptyParsSetting { get; public set; }
    public LambdaExpression IndentParsSetting { get; public set; }
    public LambdaExpression AlignSetting { get; public set; }
    public LambdaExpression NoOverrideByIndentlessRegionsSetting { get; public set; }
    public bool NoWrapBeforeRPar { get; public set; }
    public bool IndentByOneChar { get; public set; }
    public bool OutsideIndentIfLParIsFirstChild { get; public set; }
    public bool CollapsibleIndentOnlyIfLineBreaksNearParens { get; public set; }
    public bool NoOverrideByIndentlessRegions { get; public set; }
    public bool NoAlignIfLBraceAtTheEndOfLine { get; public set; }
    [CompilerGeneratedAttribute]
public LambdaExpression get_SpacesBeforeLParSetting();
    [CompilerGeneratedAttribute]
public void set_SpacesBeforeLParSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_SpacesBeforeEmptyParsSetting();
    [CompilerGeneratedAttribute]
public void set_SpacesBeforeEmptyParsSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_IndentParsSetting();
    [CompilerGeneratedAttribute]
public void set_IndentParsSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_AlignSetting();
    [CompilerGeneratedAttribute]
public void set_AlignSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_NoOverrideByIndentlessRegionsSetting();
    [CompilerGeneratedAttribute]
public void set_NoOverrideByIndentlessRegionsSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public bool get_NoWrapBeforeRPar();
    [CompilerGeneratedAttribute]
public void set_NoWrapBeforeRPar(bool value);
    [CompilerGeneratedAttribute]
public bool get_IndentByOneChar();
    [CompilerGeneratedAttribute]
public void set_IndentByOneChar(bool value);
    [CompilerGeneratedAttribute]
public bool get_OutsideIndentIfLParIsFirstChild();
    [CompilerGeneratedAttribute]
public void set_OutsideIndentIfLParIsFirstChild(bool value);
    [CompilerGeneratedAttribute]
public bool get_CollapsibleIndentOnlyIfLineBreaksNearParens();
    [CompilerGeneratedAttribute]
public void set_CollapsibleIndentOnlyIfLineBreaksNearParens(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoOverrideByIndentlessRegions();
    [CompilerGeneratedAttribute]
public void set_NoOverrideByIndentlessRegions(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoAlignIfLBraceAtTheEndOfLine();
    [CompilerGeneratedAttribute]
public void set_NoAlignIfLBraceAtTheEndOfLine(bool value);
    public virtual void Build(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
}
public abstract class JetBrains.ReSharper.Psi.Impl.CodeStyle.ParenthesisRuleBase : ElementListRuleBase {
    [CompilerGeneratedAttribute]
private TokenNodeType <LPar>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeTypeSet <GroupEmptyToLPar>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenNodeType <RPar>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <SpacesInsideParsSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <SpacesInsideEmptyParsSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FormatBeforeParent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OnlyLParAsFirstChild>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <ContIndentMultiplierSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <UseContIndentSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndentHighlighting>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LineBreaksHighlighting>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LineBreaksForEmptyParsHighlighting>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SingleLineHighlighting>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BlankLinesHighlighting>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SpacesBeforeParsHighlighting>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SpacesHighlighting>k__BackingField;
    public TokenNodeType LPar { get; public set; }
    public NodeTypeSet GroupEmptyToLPar { get; public set; }
    public TokenNodeType RPar { get; public set; }
    public LambdaExpression SpacesInsideParsSetting { get; public set; }
    public LambdaExpression SpacesInsideEmptyParsSetting { get; public set; }
    public bool FormatBeforeParent { get; public set; }
    public bool OnlyLParAsFirstChild { get; public set; }
    public LambdaExpression ContIndentMultiplierSetting { get; public set; }
    public LambdaExpression UseContIndentSetting { get; public set; }
    public string IndentHighlighting { get; public set; }
    public string LineBreaksHighlighting { get; public set; }
    public string LineBreaksForEmptyParsHighlighting { get; public set; }
    public string SingleLineHighlighting { get; public set; }
    public string BlankLinesHighlighting { get; public set; }
    public string SpacesBeforeParsHighlighting { get; public set; }
    public string SpacesHighlighting { get; public set; }
    [CompilerGeneratedAttribute]
public TokenNodeType get_LPar();
    [CompilerGeneratedAttribute]
public void set_LPar(TokenNodeType value);
    [CompilerGeneratedAttribute]
public NodeTypeSet get_GroupEmptyToLPar();
    [CompilerGeneratedAttribute]
public void set_GroupEmptyToLPar(NodeTypeSet value);
    [CompilerGeneratedAttribute]
public TokenNodeType get_RPar();
    [CompilerGeneratedAttribute]
public void set_RPar(TokenNodeType value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_SpacesInsideParsSetting();
    [CompilerGeneratedAttribute]
public void set_SpacesInsideParsSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_SpacesInsideEmptyParsSetting();
    [CompilerGeneratedAttribute]
public void set_SpacesInsideEmptyParsSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public bool get_FormatBeforeParent();
    [CompilerGeneratedAttribute]
public void set_FormatBeforeParent(bool value);
    [CompilerGeneratedAttribute]
public bool get_OnlyLParAsFirstChild();
    [CompilerGeneratedAttribute]
public void set_OnlyLParAsFirstChild(bool value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_ContIndentMultiplierSetting();
    [CompilerGeneratedAttribute]
public void set_ContIndentMultiplierSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_UseContIndentSetting();
    [CompilerGeneratedAttribute]
public void set_UseContIndentSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public string get_IndentHighlighting();
    [CompilerGeneratedAttribute]
public void set_IndentHighlighting(string value);
    [CompilerGeneratedAttribute]
public string get_LineBreaksHighlighting();
    [CompilerGeneratedAttribute]
public void set_LineBreaksHighlighting(string value);
    [CompilerGeneratedAttribute]
public string get_LineBreaksForEmptyParsHighlighting();
    [CompilerGeneratedAttribute]
public void set_LineBreaksForEmptyParsHighlighting(string value);
    [CompilerGeneratedAttribute]
public string get_SingleLineHighlighting();
    [CompilerGeneratedAttribute]
public void set_SingleLineHighlighting(string value);
    [CompilerGeneratedAttribute]
public string get_BlankLinesHighlighting();
    [CompilerGeneratedAttribute]
public void set_BlankLinesHighlighting(string value);
    [CompilerGeneratedAttribute]
public string get_SpacesBeforeParsHighlighting();
    [CompilerGeneratedAttribute]
public void set_SpacesBeforeParsHighlighting(string value);
    [CompilerGeneratedAttribute]
public string get_SpacesHighlighting();
    [CompilerGeneratedAttribute]
public void set_SpacesHighlighting(string value);
    public virtual void Build(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.ParenthesisRuleBaseEx : object {
    [ExtensionAttribute]
public static T LPar(T builder, TokenNodeType lPar);
    [ExtensionAttribute]
public static T GroupEmptyToLPar(T builder, NodeTypeSet value);
    [ExtensionAttribute]
public static T RPar(T builder, TokenNodeType rPar);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> SpacesInsideParsSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> SpacesInsideEmptyParsSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
internal static T BeforeLPar(T builder, ParenthesisRuleBase rule, FormatterInfoProviderBase provider);
    [ExtensionAttribute]
internal static T ParsRegion(T buider, ParenthesisRuleBase rule, FormatterInfoProviderBase provider, bool empty, bool nonEmpty);
    [ExtensionAttribute]
internal static T BeforeEmptyLPar(T buider, ParenthesisRuleBase rule, FormatterInfoProviderBase provider);
    [ExtensionAttribute]
internal static T InsidePars(T buider, ParenthesisRuleBase rule, FormatterInfoProviderBase provider);
    [ExtensionAttribute]
internal static T AfterLPar(T buider, ParenthesisRuleBase rule, FormatterInfoProviderBase provider, Func`3<VirtNode, CodeFormattingContext, bool> condition);
    [ExtensionAttribute]
internal static T AfterLParOrGroupedEmpty(T buider, ParenthesisRuleBase rule, FormatterInfoProviderBase provider);
    [ExtensionAttribute]
internal static T BeforeRPar(T buider, ParenthesisRuleBase rule, FormatterInfoProviderBase provider);
    [ExtensionAttribute]
internal static T AfterEmptyLPar(T buider, ParenthesisRuleBase rule, FormatterInfoProviderBase provider);
    [ExtensionAttribute]
internal static T BeforeEmptyRPar(T buider, ParenthesisRuleBase rule, FormatterInfoProviderBase provider);
    [ExtensionAttribute]
internal static IBuilderWithProvider`3<TContext, TSettingsKey, OptionTreeBlank> ContIndent(IBuilderWithProvider`3<TContext, TSettingsKey, OptionTreeBlank> builder, IndentType indentType, ParenthesisRuleBase rule, FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
    [ExtensionAttribute]
public static T FormatBeforeParent(T builder, bool value);
    [ExtensionAttribute]
public static T OnlyLParAsFirstChild(T builder, bool value);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> ContIndentMultiplierSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> UseContIndentSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static T ParsIndentingHighlighting(T builder, string value);
    [ExtensionAttribute]
public static T ParsLineBreaksHighlighting(T builder, string value);
    [ExtensionAttribute]
public static T LineBreaksForEmptyParsHighlighting(T builder, string value);
    [ExtensionAttribute]
public static T ParsSingleLineHighlighting(T builder, string value);
    [ExtensionAttribute]
public static T ParsBlankLinesHighlighting(T builder, string value);
    [ExtensionAttribute]
public static T ParsSpacesHighlighting(T builder, string value);
    [ExtensionAttribute]
public static T SpacesBeforeParsHighlighting(T builder, string value);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.ParenthesisRuleEx : object {
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> SpacesBeforeLParSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> SpacesBeforeEmptyParsSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> IndentParsSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> AlignSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> NoOverrideByIndentlessRegionsSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static T IndentByOneChar(T builder, bool value);
    [ExtensionAttribute]
public static T NoWrapBeforeRPar(T builder, bool value);
    [ExtensionAttribute]
public static T OutsideIndentIfLParIsFirstChild(T builder, bool value);
    [ExtensionAttribute]
public static T CollapsibleIndentOnlyIfLineBreaksNearParens(T builder, bool value);
    [ExtensionAttribute]
public static T NoOverrideByIndentlessRegions(T builder, bool value);
    [ExtensionAttribute]
public static T NoAlignIfLBraceAtTheEndOfLine(T builder, bool value);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.ParenthesisRuleWithWrapping : ParenthesisRule {
    [CompilerGeneratedAttribute]
private LambdaExpression <WrapSettingForBraces>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <WrapBeforeLParSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <WrapAfterLParSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <WrapBeforeRParSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private LambdaExpression <KeepExistingArrangementOfParsSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ITreeNode, bool> <DontChopIf>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WrapBeforeRParByDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WrapAfterLParByDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ChopAroundPars>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcellentPlaceToWrapAroundPars>k__BackingField;
    public LambdaExpression WrapSettingForBraces { get; public set; }
    public LambdaExpression WrapBeforeLParSetting { get; public set; }
    public LambdaExpression WrapAfterLParSetting { get; public set; }
    public LambdaExpression WrapBeforeRParSetting { get; public set; }
    public LambdaExpression KeepExistingArrangementOfParsSetting { get; public set; }
    public Func`2<ITreeNode, bool> DontChopIf { get; public set; }
    public bool WrapBeforeRParByDefault { get; public set; }
    public bool WrapAfterLParByDefault { get; public set; }
    public bool ChopAroundPars { get; public set; }
    public bool ExcellentPlaceToWrapAroundPars { get; public set; }
    [CompilerGeneratedAttribute]
public LambdaExpression get_WrapSettingForBraces();
    [CompilerGeneratedAttribute]
public void set_WrapSettingForBraces(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_WrapBeforeLParSetting();
    [CompilerGeneratedAttribute]
public void set_WrapBeforeLParSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_WrapAfterLParSetting();
    [CompilerGeneratedAttribute]
public void set_WrapAfterLParSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_WrapBeforeRParSetting();
    [CompilerGeneratedAttribute]
public void set_WrapBeforeRParSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public LambdaExpression get_KeepExistingArrangementOfParsSetting();
    [CompilerGeneratedAttribute]
public void set_KeepExistingArrangementOfParsSetting(LambdaExpression value);
    [CompilerGeneratedAttribute]
public Func`2<ITreeNode, bool> get_DontChopIf();
    [CompilerGeneratedAttribute]
public void set_DontChopIf(Func`2<ITreeNode, bool> value);
    [CompilerGeneratedAttribute]
public bool get_WrapBeforeRParByDefault();
    [CompilerGeneratedAttribute]
public void set_WrapBeforeRParByDefault(bool value);
    [CompilerGeneratedAttribute]
public bool get_WrapAfterLParByDefault();
    [CompilerGeneratedAttribute]
public void set_WrapAfterLParByDefault(bool value);
    [CompilerGeneratedAttribute]
public bool get_ChopAroundPars();
    [CompilerGeneratedAttribute]
public void set_ChopAroundPars(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExcellentPlaceToWrapAroundPars();
    [CompilerGeneratedAttribute]
public void set_ExcellentPlaceToWrapAroundPars(bool value);
    private IntervalFormatType ExcellentPlaceBonus();
    public virtual void Build(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
    internal virtual IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> AddWrapOption(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider, IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, bool forElementsAndComma);
    internal virtual IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> AddNoWrapOption(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider, IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, bool forElementsAndComma);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.ParenthesisRuleWithWrappingEx : object {
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> WrapSettingForBraces(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> WrapBeforeLParSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> WrapAfterLParSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> WrapBeforeRParSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> KeepExistingArrangementOfParsSetting(IBuilderWithProvider`3<TContext, TSettingsKey, TStorage> builder, Expression`1<Func`2<TSettingsKey, object>> setting);
    [ExtensionAttribute]
public static T DontChopIf(T builder, Func`2<ITreeNode, bool> dontChopIf);
    [ExtensionAttribute]
public static T WrapBeforeRParByDefault(T builder, bool value);
    [ExtensionAttribute]
public static T WrapAfterLParByDefault(T builder, bool value);
    [ExtensionAttribute]
public static T ChopAroundPars(T builder, bool value);
    [ExtensionAttribute]
public static T ExcellentPlaceToWrapAroundPars(T builder, bool value);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.ParentNodePattern : object {
    private INodePattern myPattern;
    public int PerformanceRating { get; }
    public ParentNodePattern(INodePattern pattern);
    public sealed virtual IEnumerable`1<NodeType> GetNodeTypes();
    public sealed virtual bool Matches(ITreeNode node, CodeFormattingContext context);
    public virtual string ToString();
    public sealed virtual int get_PerformanceRating();
}
internal class JetBrains.ReSharper.Psi.Impl.CodeStyle.PlaceToWrap : object {
    [CompilerGeneratedAttribute]
private VirtNode <LeftChild>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LeftChildEndPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtNode <RightChild>k__BackingField;
    [CompilerGeneratedAttribute]
private WrapDesirability <Desirability>k__BackingField;
    [CompilerGeneratedAttribute]
private WrapRegionInfo <Region>k__BackingField;
    public VirtNode LeftChild { get; }
    public int LeftChildEndPosition { get; }
    public VirtNode RightChild { get; }
    public WrapDesirability Desirability { get; }
    public WrapRegionInfo Region { get; }
    public PlaceToWrap(VirtNode leftNode, VirtNode rightNode, WrapDesirability desirability, WrapRegionInfo region, int leftChildEndPosition);
    [CompilerGeneratedAttribute]
public VirtNode get_LeftChild();
    [CompilerGeneratedAttribute]
public int get_LeftChildEndPosition();
    [CompilerGeneratedAttribute]
public VirtNode get_RightChild();
    [CompilerGeneratedAttribute]
public WrapDesirability get_Desirability();
    [CompilerGeneratedAttribute]
public WrapRegionInfo get_Region();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.PossiblyEmbeddedCodeFormatterContext : CodeFormattingContext {
    private Nullable`1<bool> myAreLineBreaksAllowedAlongWholeRange;
    private IFileWithEmbeds ParentFileWithEmbeds { get; }
    public bool AllowWrapLimit { get; }
    public PossiblyEmbeddedCodeFormatterContext(ICodeFormatterImpl codeFormatter, IFormatterDebugInfoLogger debugInfoLogger, AdditionalFormatterParameters parameters, int tabWidth, SingleLangChangeAccu changeAccu, FormatTask[] formatTasks);
    private IFileWithEmbeds get_ParentFileWithEmbeds();
    public bool get_AllowWrapLimit();
    public virtual bool AllowLineBreaks(ITreeNode leftNode, ITreeNode rightNode);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.PredicateNodePattern : object {
    private Func`3<VirtNode, CodeFormattingContext, bool> myPredicate;
    public int PerformanceRating { get; }
    public PredicateNodePattern(Func`3<VirtNode, CodeFormattingContext, bool> predicate);
    public sealed virtual IEnumerable`1<NodeType> GetNodeTypes();
    public sealed virtual bool Matches(ITreeNode node, CodeFormattingContext context);
    public virtual string ToString();
    public sealed virtual int get_PerformanceRating();
}
public abstract class JetBrains.ReSharper.Psi.Impl.CodeStyle.RegionRuleBase : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private IOptionNode <OptionTree>k__BackingField;
    [CompilerGeneratedAttribute]
private INodePattern <OpenNodePattern>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<VirtNode, CodeFormattingContext, VirtNode> <CloseNodeGetter>k__BackingField;
    public static Func`3<VirtNode, CodeFormattingContext, VirtNode> GetLastSibling;
    public string Name { get; }
    public long Group { get; public set; }
    public int Priority { get; public set; }
    public IOptionNode OptionTree { get; }
    public INodePattern OpenNodePattern { get; }
    public Func`3<VirtNode, CodeFormattingContext, VirtNode> CloseNodeGetter { get; }
    protected RegionRuleBase(string name, INodePattern openNodePattern, Func`3<VirtNode, CodeFormattingContext, VirtNode> closeNodeGetter, IOptionNode optionTree);
    private static RegionRuleBase();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual long get_Group();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Group(long value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Priority(int value);
    [CompilerGeneratedAttribute]
public IOptionNode get_OptionTree();
    [CompilerGeneratedAttribute]
public INodePattern get_OpenNodePattern();
    [CompilerGeneratedAttribute]
public Func`3<VirtNode, CodeFormattingContext, VirtNode> get_CloseNodeGetter();
    public sealed virtual IEnumerable`1<NodeType> GetNodeTypes();
    public static VirtNode DoGetLastSiblingOrError(VirtNode node, CodeFormattingContext context, bool stopBeforeError);
    public static Func`3<VirtNode, CodeFormattingContext, VirtNode> GetCloseNodeGetterByPattern(INodePattern pattern);
    public static Func`3<VirtNode, CodeFormattingContext, VirtNode> GetCloseNodeGetterThatCountsParens(NodeType openPar, NodeType closePar);
    public sealed virtual bool MatchesPatterns(VirtNode node, CodeFormattingContext context);
    public virtual VirtNode GetClosingNode(VirtNode node, CodeFormattingContext context);
    public virtual IOptionNode GetOptionTree(VirtNode node, CodeFormattingContext context);
    public virtual string ToString();
}
public abstract class JetBrains.ReSharper.Psi.Impl.CodeStyle.RegionRuleBlankBase : RuleWithTwoPatterns {
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private OptionTreeBlank <OptionTree>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<VirtNode, CodeFormattingContext, VirtNode> <CloseNodeGetter>k__BackingField;
    public int Priority { get; public set; }
    public OptionTreeBlank OptionTree { get; public set; }
    public Func`3<VirtNode, CodeFormattingContext, VirtNode> CloseNodeGetter { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Priority(int value);
    [CompilerGeneratedAttribute]
public OptionTreeBlank get_OptionTree();
    [CompilerGeneratedAttribute]
public void set_OptionTree(OptionTreeBlank value);
    [CompilerGeneratedAttribute]
public Func`3<VirtNode, CodeFormattingContext, VirtNode> get_CloseNodeGetter();
    [CompilerGeneratedAttribute]
public void set_CloseNodeGetter(Func`3<VirtNode, CodeFormattingContext, VirtNode> value);
    public abstract virtual void Build(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
    public sealed virtual void RunWithOptionTree(Action`1<OptionTreeBlank> action);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.RegionRuleBlankEx : object {
    [ExtensionAttribute]
public static T CloseNodeGetter(T builder, Func`3<VirtNode, CodeFormattingContext, VirtNode> closeNodeGetter);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.RuleBlankBase : BlankWithPattern {
    [CompilerGeneratedAttribute]
private long <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public long Group { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual long get_Group();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Group(long value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.RuleResultInfo`1 : ValueType {
    [CompilerGeneratedAttribute]
private IFormatterRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private TOptionValue <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IScalarSetting> <ObservedSettings>k__BackingField;
    public IFormatterRule Rule { get; }
    public TOptionValue Value { get; }
    public IEnumerable`1<IScalarSetting> ObservedSettings { get; }
    public RuleResultInfo`1(IFormatterRule rule, TOptionValue value, IEnumerable`1<IScalarSetting> observedSettings);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IFormatterRule get_Rule();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TOptionValue get_Value();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IEnumerable`1<IScalarSetting> get_ObservedSettings();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.RulesByNodeTypeList`1 : object {
    private NodeTypeDictionary`1<List`1<TRule>> myDictionary;
    private List`1<TRule> myListWithoutNodeType;
    public void Fill(Func`2<TRule, IEnumerable`1<NodeType>> nodeTypeGetter, ICollection`1<TRule> ruleList);
    public IList`1<TRule> GetRulesFor(VirtNode node);
    public IList`1<TRule> GetRulesWithoutNodeType();
    public string GetLogInfo(VirtNode node, IList`1<TRule> rules);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.RulesByTwoNodeTypesList`3 : object {
    private NodeTypeDictionary`1<FormattingRuleList<TSettingsKey, TOptionValue, TContext>> myDictionary1;
    private NodeTypeDictionary`1<FormattingRuleList<TSettingsKey, TOptionValue, TContext>> myDictionary2;
    private FormattingRuleList<TSettingsKey, TOptionValue, TContext> myListWithoutNodeType;
    public void Fill(ICollection`1<IFormattingRule`2<TSettingsKey, TOptionValue>> ruleList);
    public List`1<IFormattingRule`2<TSettingsKey, TOptionValue>> GetRulesFor(FormattingRangeContext interval, TContext context);
    internal IOptionValueQueryResult`1<TOptionValue> QueryOptionValueOnInterval(FormattingRangeContext interval, IFormatterStageBase`1<TSettingsKey> stage, TContext context, bool log, bool breakdownByRule);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.RuleWithTwoPatterns : RuleBlankBase {
    [CompilerGeneratedAttribute]
private NodePatternBlank <SecondPattern>k__BackingField;
    public NodePatternBlank SecondPattern { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual NodePatternBlank get_SecondPattern();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SecondPattern(NodePatternBlank value);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.SequentialNodeIterator`2 : object {
    private IFormatterDebugInfoLogger myDebugInfoLogger;
    private ISequentialNodeProcessor`1<TSettingsKey> myProcessor;
    private TContext myContext;
    private FormattingRangeContext myRangeContext;
    private IProgressIndicator myProgress;
    private VirtNode myPrevNode;
    private bool mySettingsOverriden;
    private TreeOffset myStartOffset;
    private TreeOffset myEndOffset;
    private TreeOffset myCurrentOffset;
    private FormatterTagsProcessor`1<TSettingsKey> myTagsProcessor;
    private bool myOldStarted;
    [CompilerGeneratedAttribute]
private FmtSettingsHolder`1<TSettingsKey> <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TaskStarted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TaskEnded>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtNode <NodeBeforeDescend>k__BackingField;
    [CompilerGeneratedAttribute]
private IteratorState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtNode <Current>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtNode <LastNode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentFormatTask>k__BackingField;
    public FmtSettingsHolder`1<TSettingsKey> Settings { get; private set; }
    public CodeFormatProfile Profile { get; }
    public VirtNode TaskFirstNode { get; }
    public VirtNode TaskLastNode { get; }
    public bool TaskStarted { get; private set; }
    public bool TaskEnded { get; private set; }
    public VirtNode NodeBeforeDescend { get; private set; }
    public IteratorState State { get; public set; }
    public VirtNode Current { get; public set; }
    public VirtNode LastNode { get; public set; }
    public int CurrentFormatTask { get; private set; }
    public SequentialNodeIterator`2(TContext context, ISequentialNodeProcessor`1<TSettingsKey> processor, FmtSettingsHolder`1<TSettingsKey> settings);
    [CompilerGeneratedAttribute]
public FmtSettingsHolder`1<TSettingsKey> get_Settings();
    [CompilerGeneratedAttribute]
private void set_Settings(FmtSettingsHolder`1<TSettingsKey> value);
    public CodeFormatProfile get_Profile();
    public VirtNode get_TaskFirstNode();
    public VirtNode get_TaskLastNode();
    [CompilerGeneratedAttribute]
public bool get_TaskStarted();
    [CompilerGeneratedAttribute]
private void set_TaskStarted(bool value);
    [CompilerGeneratedAttribute]
public bool get_TaskEnded();
    [CompilerGeneratedAttribute]
private void set_TaskEnded(bool value);
    [CompilerGeneratedAttribute]
public VirtNode get_NodeBeforeDescend();
    [CompilerGeneratedAttribute]
private void set_NodeBeforeDescend(VirtNode value);
    [CompilerGeneratedAttribute]
public IteratorState get_State();
    [CompilerGeneratedAttribute]
public void set_State(IteratorState value);
    [CompilerGeneratedAttribute]
public VirtNode get_Current();
    [CompilerGeneratedAttribute]
public void set_Current(VirtNode value);
    [CompilerGeneratedAttribute]
public VirtNode get_LastNode();
    [CompilerGeneratedAttribute]
public void set_LastNode(VirtNode value);
    [CompilerGeneratedAttribute]
public int get_CurrentFormatTask();
    [CompilerGeneratedAttribute]
private void set_CurrentFormatTask(int value);
    public object SaveState();
    public void RestoreState(object state);
    private void ChangeCurrent(VirtNode value, bool ascending, bool descending);
    private bool NextFormatTask();
    public void InitializeCurrent(VirtNode current);
    public void CheckForFileStart();
    public void DescendIntoNode();
    public bool ParseOverridenSetting(ITreeNode node);
    private void DoProcessDescendIntoNode();
    public bool IterateOnce(VirtNode untilNode, IteratorState untilState);
    private bool ProcessTaskEnded();
    public void ProcessLineBreak(VirtNode node);
    public void IterateWithProgress(VirtNode untilNode, IteratorState untilState, string name, IProgressIndicator progress);
    public void Iterate(VirtNode untilNode, IteratorState untilState, bool shouldRunFinalizer);
    public bool AdjustTaskLastNode();
    public void HandleNodeReplace(ITreeNode oldNode, ITreeNode newNode);
    [CompilerGeneratedAttribute]
private bool <ChangeCurrent>g__CheckNextFormatTask|54_0(<>c__DisplayClass54_0& );
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.SimpleBuilder`1 : object {
    [CompilerGeneratedAttribute]
private T <Obj>k__BackingField;
    public T Obj { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual T get_Obj();
    [CompilerGeneratedAttribute]
public void set_Obj(T value);
    public virtual IBuilder`1<T> DoClone();
    public sealed virtual void SetObj(T obj);
}
public abstract class JetBrains.ReSharper.Psi.Impl.CodeStyle.SimpleBuilderWithProvider`3 : SimpleBuilderWithSavedState`1<TStorage> {
    [CompilerGeneratedAttribute]
private FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> <Provider>k__BackingField;
    public FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> Provider { get; }
    public SimpleBuilderWithProvider`3(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
    [CompilerGeneratedAttribute]
public sealed virtual FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> get_Provider();
    public sealed virtual void DoBuild();
}
public abstract class JetBrains.ReSharper.Psi.Impl.CodeStyle.SimpleBuilderWithSavedState`1 : SimpleBuilder`1<TStorage> {
    [CompilerGeneratedAttribute]
private TStorage <SavedState>k__BackingField;
    public TStorage SavedState { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual TStorage get_SavedState();
    [CompilerGeneratedAttribute]
public void set_SavedState(TStorage value);
    public sealed virtual void SaveState();
    public sealed virtual void RestoreState();
    public sealed virtual void CleanState();
}
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.SimpleFormatProcessor : object {
    [CanBeNullAttribute]
public static SimpleFormatProcessor`2<TContext, TSettingsKey> Create(TContext context, ISimpleSequentialNodeProcessor`1<TSettingsKey> simpleProcessor, SequentialNodeIterator`2<TContext, TSettingsKey> iterator);
    public static void Process(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, ISimpleSequentialNodeProcessor`1<TSettingsKey> simpleProcessor, IProgressIndicator progressIndicator, string taskName);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.SimpleFormatProcessor`2 : object {
    private TContext myContext;
    private ISimpleSequentialNodeProcessor`1<TSettingsKey> mySimpleProcessor;
    private bool myInsideTask;
    [CompilerGeneratedAttribute]
private SequentialNodeIterator`2<TContext, TSettingsKey> <Iterator>k__BackingField;
    public SequentialNodeIterator`2<TContext, TSettingsKey> Iterator { get; }
    public SimpleFormatProcessor`2(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, ISimpleSequentialNodeProcessor`1<TSettingsKey> simpleProcessor);
    public SimpleFormatProcessor`2(TContext context, ISimpleSequentialNodeProcessor`1<TSettingsKey> simpleProcessor, SequentialNodeIterator`2<TContext, TSettingsKey> iterator);
    [CompilerGeneratedAttribute]
public SequentialNodeIterator`2<TContext, TSettingsKey> get_Iterator();
    public sealed virtual void TaskStarted();
    public sealed virtual void FileStart();
    public sealed virtual void ProcessNodeEnd();
    public sealed virtual void ProcessLineBreak(VirtNode& lineBreak);
    public sealed virtual void ProcessDescendIntoNode();
    public sealed virtual void TaskFinished(VirtNode& dontReallyFinishUntilThisNode);
    public sealed virtual VirtNode FixLastNodeWhenEmptyInterval(VirtNode lastNode);
    public sealed virtual void ProcessNextSolidNode(FormattingRangeContext context);
    public sealed virtual VirtNode GetNextSibling(VirtNode node);
    public sealed virtual ITreeNode GetFirstChild(ITreeNode node);
    public sealed virtual void SettingsChanged(FmtSettingsHolder`1<TSettingsKey> newSettings);
    public sealed virtual void AllTaskFinished();
    public sealed virtual void Initialize(Boolean& currentNodeInitialized);
    public sealed virtual void PreProcessNextSolidNode(FormattingRangeContext context);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.SimpleSettingValueReader`1 : object {
    private FmtSettingsHolder`1<TSettingsKey> mySettings;
    private Dictionary`2<object, object> myCache;
    public IReadOnlyCollection`1<IScalarSetting> PotentSettingsEntries { get; }
    public SimpleSettingValueReader`1(FmtSettingsHolder`1<TSettingsKey> settings);
    public sealed virtual void ClearTrackedEntries();
    public sealed virtual void SettingsChanged(FmtSettingsHolder`1<TSettingsKey> settings);
    public sealed virtual object GetOptionValue(IScalarSetting setting);
    public sealed virtual T GetOrCreateCachedValue(Key`1<T> key, Func`2<ISettingValueReader, T> creator);
    public sealed virtual IReadOnlyCollection`1<IScalarSetting> get_PotentSettingsEntries();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.SingleFormattingRule`2 : object {
    private Func`3<FormattingRangeContext, CodeFormattingContext, bool> myPredicate;
    private int myPriority;
    [CompilerGeneratedAttribute]
private IOptionNode <OptionTree>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HighlightingForMissing>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HighlightingForRedundant>k__BackingField;
    [CompilerGeneratedAttribute]
private INodePattern <ParentNode>k__BackingField;
    [CompilerGeneratedAttribute]
private INodePattern <LeftNode>k__BackingField;
    [CompilerGeneratedAttribute]
private INodePattern <RightNode>k__BackingField;
    [CompilerGeneratedAttribute]
private FormattingStageAcceptanceType <StageIdPredicate>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Group>k__BackingField;
    protected IOptionNode OptionTree { get; }
    public string Name { get; }
    public string HighlightingForMissing { get; }
    public string HighlightingForRedundant { get; }
    public INodePattern ParentNode { get; }
    public INodePattern LeftNode { get; }
    public INodePattern RightNode { get; }
    public FormattingStageAcceptanceType StageIdPredicate { get; }
    public int Priority { get; }
    public long Group { get; public set; }
    public SingleFormattingRule`2(string name, INodePattern parentNode, INodePattern leftNode, INodePattern rightNode, Func`3<FormattingRangeContext, CodeFormattingContext, bool> predicate, IOptionNode optionTree, int priority, Nullable`1<FormattingStageAcceptanceType> stageIdPredicate, string highlightingForMissing, string highlightingForRedundant);
    [CompilerGeneratedAttribute]
protected IOptionNode get_OptionTree();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_HighlightingForMissing();
    [CompilerGeneratedAttribute]
public sealed virtual string get_HighlightingForRedundant();
    [CompilerGeneratedAttribute]
public sealed virtual INodePattern get_ParentNode();
    [CompilerGeneratedAttribute]
public sealed virtual INodePattern get_LeftNode();
    [CompilerGeneratedAttribute]
public sealed virtual INodePattern get_RightNode();
    [CompilerGeneratedAttribute]
public sealed virtual FormattingStageAcceptanceType get_StageIdPredicate();
    public sealed virtual bool MatchesPatterns(FormattingRangeContext interval, CodeFormattingContext context);
    public sealed virtual IOptionNode GetOptionTree(FormattingRangeContext interval);
    public sealed virtual int get_Priority();
    [CompilerGeneratedAttribute]
public sealed virtual long get_Group();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Group(long value);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool <MatchesPatterns>g__DoMatch|27_0(<>c__DisplayClass27_0& );
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.SingleIndentingRule`1 : RegionRuleBase {
    [CompilerGeneratedAttribute]
private string <OpeningHighlightingId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClosingHighlightingId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreRegionIfClosingNodeIsNull>k__BackingField;
    public string OpeningHighlightingId { get; public set; }
    public string ClosingHighlightingId { get; public set; }
    public bool IgnoreRegionIfClosingNodeIsNull { get; public set; }
    public SingleIndentingRule`1(string name, INodePattern openNodePattern, Func`3<VirtNode, CodeFormattingContext, VirtNode> closeNodeGetter, IOptionNode optionTree);
    [CompilerGeneratedAttribute]
public sealed virtual string get_OpeningHighlightingId();
    [CompilerGeneratedAttribute]
public void set_OpeningHighlightingId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ClosingHighlightingId();
    [CompilerGeneratedAttribute]
public void set_ClosingHighlightingId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IgnoreRegionIfClosingNodeIsNull();
    [CompilerGeneratedAttribute]
public void set_IgnoreRegionIfClosingNodeIsNull(bool value);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.StringListMultipleValuesOptionNode : object {
    private Key`1<HashSet`1<string>> myCacheKey;
    [CompilerGeneratedAttribute]
private Func`3<object, CodeFormattingContext, IEnumerable`1<string>> <GetValueToCompare>k__BackingField;
    [CompilerGeneratedAttribute]
private StringComparison <Comparison>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <KeyGetter>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting <Setting>k__BackingField;
    [CompilerGeneratedAttribute]
private IOptionValue <ValueIfFound>k__BackingField;
    [CompilerGeneratedAttribute]
private IOptionValue <ValueIfNotFound>k__BackingField;
    public Func`3<object, CodeFormattingContext, IEnumerable`1<string>> GetValueToCompare { get; public set; }
    public StringComparison Comparison { get; }
    public Func`2<object, object> KeyGetter { get; }
    public IScalarSetting Setting { get; }
    public IOptionValue ValueIfFound { get; }
    public IOptionValue ValueIfNotFound { get; }
    public IEnumerable`1<IOptionValue> Values { get; }
    public StringListMultipleValuesOptionNode(Func`3<object, CodeFormattingContext, IEnumerable`1<string>> getValueToCompare, StringComparison comparison, Func`2<object, object> keyGetter, IScalarSetting setting, IOptionValue valueIfFound, IOptionValue valueIfNotFound);
    [CompilerGeneratedAttribute]
public Func`3<object, CodeFormattingContext, IEnumerable`1<string>> get_GetValueToCompare();
    [CompilerGeneratedAttribute]
public void set_GetValueToCompare(Func`3<object, CodeFormattingContext, IEnumerable`1<string>> value);
    [CompilerGeneratedAttribute]
public StringComparison get_Comparison();
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_KeyGetter();
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting get_Setting();
    [CompilerGeneratedAttribute]
public IOptionValue get_ValueIfFound();
    [CompilerGeneratedAttribute]
public IOptionValue get_ValueIfNotFound();
    public sealed virtual IEnumerable`1<IOptionValue> get_Values();
    public sealed virtual IOptionValue GetOptionValue(ISettingValueReader reader, object data, CodeFormattingContext context);
    [CompilerGeneratedAttribute]
private HashSet`1<string> <GetOptionValue>b__23_0(ISettingValueReader reader1);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.StringListOptionNode : object {
    [CompilerGeneratedAttribute]
private Func`3<object, CodeFormattingContext, string> <GetValueToCompare>k__BackingField;
    [CompilerGeneratedAttribute]
private StringComparison <Comparison>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <KeyGetter>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting <Setting>k__BackingField;
    [CompilerGeneratedAttribute]
private IOptionValue <ValueIfFound>k__BackingField;
    [CompilerGeneratedAttribute]
private IOptionValue <ValueIfNotFound>k__BackingField;
    public Func`3<object, CodeFormattingContext, string> GetValueToCompare { get; public set; }
    public StringComparison Comparison { get; }
    public Func`2<object, object> KeyGetter { get; }
    public IScalarSetting Setting { get; }
    public IOptionValue ValueIfFound { get; }
    public IOptionValue ValueIfNotFound { get; }
    public IEnumerable`1<IOptionValue> Values { get; }
    public StringListOptionNode(Func`3<object, CodeFormattingContext, string> getValueToCompare, StringComparison comparison, Func`2<object, object> keyGetter, IScalarSetting setting, IOptionValue valueIfFound, IOptionValue valueIfNotFound);
    [CompilerGeneratedAttribute]
public Func`3<object, CodeFormattingContext, string> get_GetValueToCompare();
    [CompilerGeneratedAttribute]
public void set_GetValueToCompare(Func`3<object, CodeFormattingContext, string> value);
    [CompilerGeneratedAttribute]
public StringComparison get_Comparison();
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_KeyGetter();
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting get_Setting();
    [CompilerGeneratedAttribute]
public IOptionValue get_ValueIfFound();
    [CompilerGeneratedAttribute]
public IOptionValue get_ValueIfNotFound();
    public sealed virtual IEnumerable`1<IOptionValue> get_Values();
    public sealed virtual IOptionValue GetOptionValue(ISettingValueReader reader, object data, CodeFormattingContext context);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.TemporaryRules`1 : ValueType {
    private FrugalLocalList`1<ValueTuple`2<VirtNode, TRule>> myRules;
    public TemporaryRules`1<TRule> Clone();
    public void Add(VirtNode checkUntilThisNode, TRule rule, IFormatterDebugInfoLogger logger);
    public void RemoveTempRules(VirtNode node, bool rightSide, IFormatterDebugInfoLogger formatterDebugInfoLogger);
    public FrugalLocalListEnumerator`1<ValueTuple`2<VirtNode, TRule>> GetEnumerator();
    public void RemoveTempRules(FrugalLocalList`1<TRule> toRemove);
    public void Clear();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.ThresholdOptionNode : object {
    [CompilerGeneratedAttribute]
private Func`3<object, CodeFormattingContext, int> <GetValueToCompare>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <KeyGetter>k__BackingField;
    [CompilerGeneratedAttribute]
private IScalarSetting <Setting>k__BackingField;
    [CompilerGeneratedAttribute]
private IOptionValue <ValueIfGtSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IOptionValue <ValueIfLtSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private IOptionValue <ValueIfEqSetting>k__BackingField;
    public Func`3<object, CodeFormattingContext, int> GetValueToCompare { get; public set; }
    public Func`2<object, object> KeyGetter { get; }
    public IScalarSetting Setting { get; }
    public IOptionValue ValueIfGtSetting { get; }
    public IOptionValue ValueIfLtSetting { get; }
    public IOptionValue ValueIfEqSetting { get; }
    public IEnumerable`1<IOptionValue> Values { get; }
    public ThresholdOptionNode(Func`3<object, CodeFormattingContext, int> getValueToCompare, Func`2<object, object> keyGetter, IScalarSetting setting, IOptionValue valueIfGtSetting, IOptionValue valueIfLtSetting, IOptionValue valueIfEqSetting);
    [CompilerGeneratedAttribute]
public Func`3<object, CodeFormattingContext, int> get_GetValueToCompare();
    [CompilerGeneratedAttribute]
public void set_GetValueToCompare(Func`3<object, CodeFormattingContext, int> value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_KeyGetter();
    [CompilerGeneratedAttribute]
public sealed virtual IScalarSetting get_Setting();
    [CompilerGeneratedAttribute]
public IOptionValue get_ValueIfGtSetting();
    [CompilerGeneratedAttribute]
public IOptionValue get_ValueIfLtSetting();
    [CompilerGeneratedAttribute]
public IOptionValue get_ValueIfEqSetting();
    public sealed virtual IEnumerable`1<IOptionValue> get_Values();
    public sealed virtual IOptionValue GetOptionValue(ISettingValueReader reader, object data, CodeFormattingContext context);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.TrackedSettingValueReader`1 : HashSet`1<IScalarSetting> {
    private FmtSettingsHolder`1<TSettingsKey> mySettings;
    public IReadOnlyCollection`1<IScalarSetting> PotentSettingsEntries { get; }
    public TrackedSettingValueReader`1(FmtSettingsHolder`1<TSettingsKey> settings);
    public sealed virtual void ClearTrackedEntries();
    public sealed virtual void SettingsChanged(FmtSettingsHolder`1<TSettingsKey> settings);
    public sealed virtual object GetOptionValue(IScalarSetting setting);
    public sealed virtual T GetOrCreateCachedValue(Key`1<T> key, Func`2<ISettingValueReader, T> creator);
    public sealed virtual IReadOnlyCollection`1<IScalarSetting> get_PotentSettingsEntries();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.TupleEx : object {
    [ExtensionAttribute]
public static ValueTuple`2<int, int> Plus(ValueTuple`2& a, ValueTuple`2& b);
    [ExtensionAttribute]
public static ValueTuple`3<int, int, int> Plus(ValueTuple`3& a, ValueTuple`3& b);
    [ExtensionAttribute]
public static ValueTuple`2<int, int> Minus(ValueTuple`2& a, ValueTuple`2& b);
    [ExtensionAttribute]
public static ValueTuple`3<int, int, int> Minus(ValueTuple`3& a, ValueTuple`3& b);
    [ExtensionAttribute]
public static ValueTuple`2<bool, bool> Or(ValueTuple`2& a, ValueTuple`2& b);
    [ExtensionAttribute]
public static ValueTuple`3<bool, bool, bool> Or(ValueTuple`3& a, ValueTuple`3& b);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.TypeNodePattern : object {
    private Type myType;
    public int PerformanceRating { get; }
    public TypeNodePattern(Type type);
    public sealed virtual IEnumerable`1<NodeType> GetNodeTypes();
    public sealed virtual bool Matches(ITreeNode node, CodeFormattingContext context);
    public virtual string ToString();
    public sealed virtual int get_PerformanceRating();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.VirtualIndent : object {
    [CompilerGeneratedAttribute]
private ITreeNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RelativeIndent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AbsoluteIndent>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <Parent>k__BackingField;
    public ITreeNode Node { get; }
    public int RelativeIndent { get; }
    public int AbsoluteIndent { get; }
    public ITreeNode Parent { get; }
    public VirtualIndent(ITreeNode node, int relativeIndent, ITreeNode parentNode, int absoluteIndent);
    [CompilerGeneratedAttribute]
public ITreeNode get_Node();
    [CompilerGeneratedAttribute]
public int get_RelativeIndent();
    [CompilerGeneratedAttribute]
public int get_AbsoluteIndent();
    [CompilerGeneratedAttribute]
public ITreeNode get_Parent();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.VirtualIndentingStage`2 : IndentingStage`2<TContext, TSettingsKey> {
    private bool myOnlyFixForInlayHints;
    private List`1<VirtualIndent> myNodes;
    [CompilerGeneratedAttribute]
private IndentMap <IndentMap>k__BackingField;
    public IndentMap IndentMap { get; }
    public VirtualIndentingStage`2(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IFormatterInfoProvider`2<TContext, TSettingsKey> provider, IProgressIndicator progress, SequentialNodeIterator`2<TContext, TSettingsKey> iterator, bool onlyFixForInlayHints);
    [CompilerGeneratedAttribute]
public IndentMap get_IndentMap();
    public virtual void ProcessLineBreak(VirtNode& lineBreak);
    protected ValueTuple`2<IndentRegionInfo, IndentRegionInfo> GetIndentRegionInfoWithAlignmentNode(bool reallyIndent, bool markUsed);
    public List`1<VirtualIndent> GetNodes();
    protected virtual void IndentNode(VirtNode prevNode, VirtNode originalCurrent, bool reallyIndent, VirtNode nodeToIndent, bool fromFirstMacroOnLine);
    private void ProcessVirtualIndent(ITreeNode originalCurrent);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.VirtualIntAlignStage`2 : IntAlignStage`2<TContext, TSettingsKey> {
    private IndentMap myIndentMap;
    private List`1<VirtualIndent> myNodes;
    public VirtualIntAlignStage`2(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IFormatterInfoProvider`2<TContext, TSettingsKey> provider, IProgressIndicator progress, HashSet`1<IScalarSetting`1<bool>> pureIntAlignSettings, IndentMap indentMap);
    protected virtual void DoIntAlign();
    public List`1<VirtualIndent> GetNodes();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.Whitespace : ValueType {
    public static Whitespace Empty;
    public static Whitespace Space;
    public static Whitespace Tab;
    public int Tabs;
    public int Spaces;
    public bool IsPositiveOrZero { get; }
    public bool IsZero { get; }
    public bool IsPositive { get; }
    public int CharsNum { get; }
    public Whitespace(StringSlice str, int tabWidth);
    public Whitespace(int tabs, int spaces);
    private static Whitespace();
    public bool get_IsPositiveOrZero();
    public bool get_IsZero();
    public bool get_IsPositive();
    public int get_CharsNum();
    public static void ParseString(StringSlice str, int tabWidth, Boolean& fullConversion, Whitespace& whitespace);
    [PureAttribute]
public int GetLength(int tabWidth);
    [PureAttribute]
public int GetLengthPositive(int tabWidth);
    [PureAttribute]
public Whitespace ConvertTabsToSpaces(int tabWidth);
    [PureAttribute]
public Whitespace ToPositive(int tabWidth, bool makeZeroIfImpossible);
    [PureAttribute]
[NotNullAttribute]
public string ConvertToString(int tabWidth);
    public static Whitespace op_Addition(Whitespace a, Whitespace b);
    public static Whitespace op_Subtraction(Whitespace a, Whitespace b);
    public static Whitespace op_Multiply(Whitespace a, int multiplier);
    public static bool op_Equality(Whitespace left, Whitespace right);
    public static bool op_Inequality(Whitespace left, Whitespace right);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Whitespace other);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Impl.CodeStyle.WrapDesirability : ValueType {
    public static WrapDesirability Default;
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; public set; }
    public WrapDesirability(int value);
    private static WrapDesirability();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(int value);
    public WrapDesirability Add(int value);
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.WrapGroupOptionValue : object {
    [CompilerGeneratedAttribute]
private WrapType <WrapType>k__BackingField;
    public WrapType WrapType { get; }
    public WrapGroupOptionValue(WrapType wrapType);
    [CompilerGeneratedAttribute]
public sealed virtual WrapType get_WrapType();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.WrapGroupRule`1 : RegionRuleBase {
    [CompilerGeneratedAttribute]
private string <LineBreaksAroundHighlighting>k__BackingField;
    public string LineBreaksAroundHighlighting { get; public set; }
    public string HighlightingForMissing { get; }
    public string HighlightingForRedundant { get; }
    public WrapGroupRule`1(string name, INodePattern openNodePattern, Func`3<VirtNode, CodeFormattingContext, VirtNode> closeNodeGetter, IOptionNode optionTree);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LineBreaksAroundHighlighting();
    [CompilerGeneratedAttribute]
public void set_LineBreaksAroundHighlighting(string value);
    public sealed virtual string get_HighlightingForMissing();
    public sealed virtual string get_HighlightingForRedundant();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.WrappingStage`2 : FormatterStageBase`2<TContext, TSettingsKey> {
    [CanBeNullAttribute]
private IndentingStage`2<TContext, TSettingsKey> myIndentingStage;
    protected IFormatterInfoProvider`2<TContext, TSettingsKey> myFormattingInfoProvider;
    protected int myMargin;
    private bool myKeepUserWrapping;
    private protected SequentialNodeIterator`2<TContext, TSettingsKey> myIterator;
    private protected List`1<WrapRegionInfo> myRegions;
    private protected List`1<WrapRegionInfo> myPostponedRegions;
    private int myLinePositionBeforeWhitespaces;
    private int myLinePositionAfterWhitespaces;
    private VirtNode myLastProcessedNode;
    private VirtNode myLastLineBreakLeft;
    private object myStateAtLineStart;
    private List`1<PlaceToWrap> myPlacesToWrap;
    private int myIndexOfRemovedUserLinebreak;
    private bool myAfterWrap;
    protected bool myLineDataCalculated;
    protected bool myNeedRecalculateAfterSolidNode;
    protected int myIndent;
    protected int myLineLength;
    protected int myPrevLineLengthPure;
    protected int myTabAdjustment;
    protected bool myInsideTask;
    private bool myLogWrapScores;
    private bool myAfterMultilineKeepTogetherBlock;
    private bool myBreakLineBeforeKeepTogetherBlock;
    [CompilerGeneratedAttribute]
private bool <WasLinebreakAfterKeepTogetherBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private IFormatterRule <HighlightingForLinebreakAfterKeepTogetherBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WasConditionalLinebreak>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WasLateLinebreak>k__BackingField;
    protected TemporaryRules`1<ITemporaryWrapGroupRule> myTemporaryRules;
    private static int ShortRegionLengthCoef;
    private static int LongRegionLengthCoef;
    private static int SuperLongRegionLengthCoef;
    private static int WrapMarginPercentForShort;
    private static int WrapMarginPercentForSuperLong;
    private static int EncourgeLateRegionStartCoef;
    private static int EarlyRegionStartCoef;
    private static int LateRegionStartCoef;
    private static int WrapMarginPercentForEarlyRegionStart;
    private static int ShortAlignmentCoef10;
    private static int LongAlignmentCoef;
    private static int WrapMarginPercentForShortAlignment;
    private static int WrapMarginPercentForEarlyRegionBreak;
    private static int EarlyRegionBreakCoef;
    private static int LateRegionBreakCoef;
    private static int WrapMarginPercentForBreakNearAlignment;
    private static int PenaltyForBreakNearAlignment;
    private static int BonusForUserLinebreak;
    private static int BonusForExcellentPlace;
    private static int BonusForGoodPlace;
    private static int BonusForDesignatedPlace;
    private static int PenaltyForUndesignatedPlace;
    private static int PenaltyForWrapInClosedRegion;
    public bool WasLinebreakAfterKeepTogetherBlock { get; private set; }
    public IFormatterRule HighlightingForLinebreakAfterKeepTogetherBlock { get; private set; }
    public bool WasConditionalLinebreak { get; private set; }
    public bool WasLateLinebreak { get; private set; }
    public WrappingStage`2(TContext context, FmtSettingsHolder`1<TSettingsKey> settings, IProgressIndicator progress, IFormatterInfoProvider`2<TContext, TSettingsKey> formattingInfoProvider, SequentialNodeIterator`2<TContext, TSettingsKey> iterator, IndentingStage`2<TContext, TSettingsKey> indentingStage);
    [CompilerGeneratedAttribute]
public bool get_WasLinebreakAfterKeepTogetherBlock();
    [CompilerGeneratedAttribute]
private void set_WasLinebreakAfterKeepTogetherBlock(bool value);
    [CompilerGeneratedAttribute]
public IFormatterRule get_HighlightingForLinebreakAfterKeepTogetherBlock();
    [CompilerGeneratedAttribute]
private void set_HighlightingForLinebreakAfterKeepTogetherBlock(IFormatterRule value);
    [CompilerGeneratedAttribute]
public bool get_WasConditionalLinebreak();
    [CompilerGeneratedAttribute]
private void set_WasConditionalLinebreak(bool value);
    [CompilerGeneratedAttribute]
public bool get_WasLateLinebreak();
    [CompilerGeneratedAttribute]
private void set_WasLateLinebreak(bool value);
    private void CalcMargin();
    public object SaveState();
    public void RestoreState(object state);
    public sealed virtual void TaskStarted();
    public sealed virtual void FileStart();
    public sealed virtual void ProcessNodeEnd();
    protected virtual void CloseRegions(bool endAtInternal, VirtNode closingNode);
    private protected virtual void ProcessRegionClose(WrapRegionInfo regionInfo);
    public virtual void ProcessLineBreak(VirtNode& lineBreak);
    private void LineStart(VirtNode node, bool fromInitialize);
    private sealed virtual override void JetBrains.ReSharper.Psi.Impl.CodeStyle.ISequentialNodeProcessor<TSettingsKey>.ProcessDescendIntoNode();
    public sealed virtual void TaskFinished(VirtNode& dontReallyFinishUntilThisNode);
    public sealed virtual VirtNode FixLastNodeWhenEmptyInterval(VirtNode lastNode);
    protected virtual bool TryWrap(bool allowLineThatAreTooLong);
    private bool UnderMargin(bool allowLineThatAreTooLong, int position);
    private void HandleIndentChange();
    private sealed virtual override void JetBrains.ReSharper.Psi.Impl.CodeStyle.ISequentialNodeProcessor<TSettingsKey>.ProcessNextSolidNode(FormattingRangeContext context);
    private sealed virtual override VirtNode JetBrains.ReSharper.Psi.Impl.CodeStyle.ISequentialNodeProcessor<TSettingsKey>.GetNextSibling(VirtNode node);
    private sealed virtual override ITreeNode JetBrains.ReSharper.Psi.Impl.CodeStyle.ISequentialNodeProcessor<TSettingsKey>.GetFirstChild(ITreeNode node);
    private protected virtual void BreakLines(PlaceToWrap ctx);
    private protected virtual PlaceToWrap GetFirstMandatoryWrap();
    private protected void CalculateLineData(VirtNode node);
    private int GetWrapDesirabilityValue(PlaceToWrap placeToWrap);
    private WrapDesirability CalcWrapDesirabilityOutsideRegion(FormattingRangeContext ctx, IntervalFormatType ift);
    private WrapDesirability CalcWrapDesirabilityInsideRegion(WrapRegionInfo region, FormattingRangeContext ctx, IntervalFormatType ift);
    private WrapDesirability CalcWrapDesirability(int positionInsideRegion, int regionStart, int regionLength, int keepTogether, IntervalFormatType ift, string regionName, WrapType wrapType);
    private sealed virtual override void JetBrains.ReSharper.Psi.Impl.CodeStyle.ISequentialNodeProcessor<TSettingsKey>.PreProcessNextSolidNode(FormattingRangeContext context);
    protected virtual void FindAndProcessWrappingRegions(VirtNode node, WrapType wrapType, int position);
    private void AddPostponedRegions(VirtNode iteratorCurrent, int priority);
    private protected virtual void ProcessInterval(FormattingRangeContext ctx);
    private void AddPlaceToWrap(PlaceToWrap placeToWrap);
    private static bool AllowWrap(IFormatOptionValue setting);
    private void BreakLineConditionally(IFormatOptionValue setting, FormattingRangeContext ctx);
    private protected virtual WrapRegionInfo GetCurrentWrapRegion();
    public sealed virtual void ProcessRegion(IWrapGroupRule rule, VirtNode current, VirtNode closingNode, WrapType wrapType, IEnumerable`1<IScalarSetting> observedSettings, int position);
    private protected WrapRegionInfo CreateRegion(IWrapGroupRule rule, VirtNode current, VirtNode closingNode, WrapType wrapType, int position, IEnumerable`1<IScalarSetting> observedSettings, FormatterSettingValues valueSet);
    private protected virtual void ProcessLineBreaksBeforeAndAfterRegion(WrapRegionInfo wrapRegionInfo);
    public virtual void SettingsChanged(FmtSettingsHolder`1<TSettingsKey> newSettings);
    public sealed virtual void AllTaskFinished();
    private sealed virtual override void JetBrains.ReSharper.Psi.Impl.CodeStyle.ISequentialNodeProcessor<TSettingsKey>.Initialize(Boolean& currentNodeInitialized);
    private void Initialize();
    private void SetLinePosition(int linePositionAfterWhitespace, VirtNode lastProcessed);
    private void UpdatePosition(VirtNode node, bool including);
}
internal class JetBrains.ReSharper.Psi.Impl.CodeStyle.WrapRegionInfo : object {
    [CompilerGeneratedAttribute]
private IWrapGroupRule <Rule>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtNode <OpeningNode>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtNode <ClosingNode>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IScalarSetting> <ObservedSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private PlaceToWrap <FirstNodeWithMandatoryWrap>k__BackingField;
    [CompilerGeneratedAttribute]
private PlaceToWrap <LastNodeWithWrap>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasLineBreaks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Closed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StartAtExternal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StartBeforeExternal>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeepTogetherCount>k__BackingField;
    [CompilerGeneratedAttribute]
private WrapType <WrapType>k__BackingField;
    [CompilerGeneratedAttribute]
private FormatterSettingValues <ValueSet>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PotentiallySingleLine>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SingleLineValuesAdded>k__BackingField;
    [CompilerGeneratedAttribute]
private FormatterSettingValues <SingleLineValueSet>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PotentiallySingleLineCounter>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RegionLength>k__BackingField;
    public IWrapGroupRule Rule { get; }
    public VirtNode OpeningNode { get; }
    public VirtNode ClosingNode { get; }
    [CanBeNullAttribute]
public IEnumerable`1<IScalarSetting> ObservedSettings { get; public set; }
    public PlaceToWrap FirstNodeWithMandatoryWrap { get; public set; }
    public PlaceToWrap LastNodeWithWrap { get; public set; }
    public bool HasLineBreaks { get; private set; }
    public bool Closed { get; public set; }
    public bool StartAtExternal { get; }
    public bool StartBeforeExternal { get; }
    public int Position { get; public set; }
    public int KeepTogetherCount { get; public set; }
    public WrapType WrapType { get; private set; }
    public FormatterSettingValues ValueSet { get; public set; }
    public bool PotentiallySingleLine { get; public set; }
    public bool SingleLineValuesAdded { get; public set; }
    public FormatterSettingValues SingleLineValueSet { get; public set; }
    public int PotentiallySingleLineCounter { get; public set; }
    public int RegionLength { get; public set; }
    public string Name { get; }
    public bool Chop { get; }
    public bool PseudoStartBeforeExternal { get; }
    public bool PreferWrapBefore { get; }
    public bool LineBreakBeforeIfMultiline { get; }
    public bool LineBreakAfterIfMultiline { get; }
    public WrapRegionInfo(IWrapGroupRule rule, VirtNode openingNode, VirtNode closingNode, WrapType wrapType, IEnumerable`1<IScalarSetting> observedSettings, bool startAtExternal, bool startBeforeExternal, int position);
    [CompilerGeneratedAttribute]
public IWrapGroupRule get_Rule();
    [CompilerGeneratedAttribute]
public VirtNode get_OpeningNode();
    [CompilerGeneratedAttribute]
public VirtNode get_ClosingNode();
    [CompilerGeneratedAttribute]
public IEnumerable`1<IScalarSetting> get_ObservedSettings();
    [CompilerGeneratedAttribute]
public void set_ObservedSettings(IEnumerable`1<IScalarSetting> value);
    [CompilerGeneratedAttribute]
public PlaceToWrap get_FirstNodeWithMandatoryWrap();
    [CompilerGeneratedAttribute]
public void set_FirstNodeWithMandatoryWrap(PlaceToWrap value);
    [CompilerGeneratedAttribute]
public PlaceToWrap get_LastNodeWithWrap();
    [CompilerGeneratedAttribute]
public void set_LastNodeWithWrap(PlaceToWrap value);
    [CompilerGeneratedAttribute]
public bool get_HasLineBreaks();
    [CompilerGeneratedAttribute]
private void set_HasLineBreaks(bool value);
    [CompilerGeneratedAttribute]
public bool get_Closed();
    [CompilerGeneratedAttribute]
public void set_Closed(bool value);
    [CompilerGeneratedAttribute]
public bool get_StartAtExternal();
    [CompilerGeneratedAttribute]
public bool get_StartBeforeExternal();
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(int value);
    [CompilerGeneratedAttribute]
public int get_KeepTogetherCount();
    [CompilerGeneratedAttribute]
public void set_KeepTogetherCount(int value);
    [CompilerGeneratedAttribute]
public WrapType get_WrapType();
    [CompilerGeneratedAttribute]
private Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_WrapType(WrapType value);
    [CompilerGeneratedAttribute]
public FormatterSettingValues get_ValueSet();
    [CompilerGeneratedAttribute]
public void set_ValueSet(FormatterSettingValues value);
    [CompilerGeneratedAttribute]
public bool get_PotentiallySingleLine();
    [CompilerGeneratedAttribute]
public void set_PotentiallySingleLine(bool value);
    [CompilerGeneratedAttribute]
public bool get_SingleLineValuesAdded();
    [CompilerGeneratedAttribute]
public void set_SingleLineValuesAdded(bool value);
    [CompilerGeneratedAttribute]
public FormatterSettingValues get_SingleLineValueSet();
    [CompilerGeneratedAttribute]
public void set_SingleLineValueSet(FormatterSettingValues value);
    [CompilerGeneratedAttribute]
public int get_PotentiallySingleLineCounter();
    [CompilerGeneratedAttribute]
public void set_PotentiallySingleLineCounter(int value);
    [CompilerGeneratedAttribute]
public int get_RegionLength();
    [CompilerGeneratedAttribute]
public void set_RegionLength(int value);
    public string get_Name();
    public bool get_Chop();
    public bool get_PseudoStartBeforeExternal();
    public bool get_PreferWrapBefore();
    public bool get_LineBreakBeforeIfMultiline();
    public bool get_LineBreakAfterIfMultiline();
    public void CalculateLineBreaks(CodeFormattingContext context);
    public WrapRegionInfo Copy();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Impl.CodeStyle.WrapRule : RegionRuleBlankBase {
    [CompilerGeneratedAttribute]
private string <LineBreaksAroundHighlighting>k__BackingField;
    public string LineBreaksAroundHighlighting { get; public set; }
    [CompilerGeneratedAttribute]
public string get_LineBreaksAroundHighlighting();
    [CompilerGeneratedAttribute]
public void set_LineBreaksAroundHighlighting(string value);
    public virtual void Build(FormatterInfoProviderWithFluentApi`2<TContext, TSettingsKey> provider);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.CodeStyle.WrapRuleEx : object {
    [ExtensionAttribute]
public static T Return(T builder, WrapType wrapType);
    [ExtensionAttribute]
public static T LineBreaksAroundHighlighting(T builder, string value);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Impl.CodeStyle.WrapType : Enum {
    public int value__;
    public static WrapType None;
    public static WrapType Chop;
    public static WrapType StartAtExternal;
    public static WrapType StartAtInternal;
    public static WrapType StartBeforeExternal;
    public static WrapType PseudoStartBeforeExternal;
    public static WrapType EndAtInternal;
    public static WrapType PreferWrapBefore;
    public static WrapType LineBreakBeforeIfMultiline;
    public static WrapType LineBreakAfterIfMultiline;
    public static WrapType BrokenRegion;
    public static WrapType AllowEarlyBreak;
    public static WrapType EncourageLateRegionStart;
    public static WrapType KeepTogether;
}
public interface JetBrains.ReSharper.Psi.Impl.ControlFlow.ISharedControlFlowAnalysisResult {
    [NotNullAttribute]
public ICollection`1<IDeclaredElement> UsedFieldsWithTrackedAccessState { get; }
    [NotNullAttribute]
public ICollection`1<IDeclaredElement> ReadWithoutWriteExternalVariables { get; }
    public bool HasTooManyVariables { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<ICollection`1<ITypeMember>, ICollection`1<ITypeMember>> InitializedTypeMembers { get; }
    [CanBeNullAttribute]
public ClassInitializationInfo InitializationInfo { get; }
    public abstract virtual ICollection`1<IDeclaredElement> get_UsedFieldsWithTrackedAccessState();
    public abstract virtual ICollection`1<IDeclaredElement> get_ReadWithoutWriteExternalVariables();
    public abstract virtual bool get_HasTooManyVariables();
    public abstract virtual ValueTuple`2<ICollection`1<ITypeMember>, ICollection`1<ITypeMember>> get_InitializedTypeMembers();
    public abstract virtual ClassInitializationInfo get_InitializationInfo();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Impl.ControlFlow.Util.OneToCompactListMap`2 : object {
    private static int DEFAULT_LIST_CAPACITY;
    [NotNullAttribute]
private CompactMap`2<TKey, List`1<TValue>> myMap;
    private int myValueCount;
    public int ValueCount { get; }
    [NotNullAttribute]
public ICollection`1<TKey> Keys { get; }
    [CanBeNullAttribute]
public List`1<TValue> Item { get; }
    public int get_ValueCount();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool Remove(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public List`1<TValue> get_Item(TKey key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, List`1<TValue>>> GetEnumerator();
    [CanBeNullAttribute]
public sealed virtual List`1<TValue> GetValuesSafe(TKey key);
}
[SolutionComponentAttribute("16")]
[DerivedComponentsInstantiationRequirementAttribute("0")]
public class JetBrains.ReSharper.Psi.Impl.DebuggerAssembliesRedirector : object {
    [CanBeNullAttribute]
public virtual VirtualFileSystemPath TryGetRuntimeAssembly(AssemblyNameInfo assemblyName);
}
public class JetBrains.ReSharper.Psi.Impl.DeclaredElementEqualityComparer : object {
    [NotNullAttribute]
public static IEqualityComparer`1<ITypeElement> TypeElementComparer;
    [NotNullAttribute]
public static IEqualityComparer`1<ITypeMember> MemberComparer;
    [NotNullAttribute]
public static IEqualityComparer`1<IDeclaredElement> ElementComparer;
    private static DeclaredElementEqualityComparer();
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<JetBrains.ReSharper.Psi.ITypeElement>.GetHashCode(ITypeElement obj);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<JetBrains.ReSharper.Psi.ITypeElement>.Equals(ITypeElement x, ITypeElement y);
    private static bool CompareClrNames(ITypeElement x, ITypeElement y);
    private static bool CompareAssemblyNames(ITypeElement x, ITypeElement y);
    private static bool IsEqualEmbeddedComInteropTypes(ITypeElement x, ITypeElement y);
    private static bool IsComTypeEligibleForTypeEquivalence(ITypeElement typeElement);
    private static bool IsTypeForwardedTo(ITypeElement typeElement, IPsiAssembly toAssembly);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<JetBrains.ReSharper.Psi.ITypeMember>.Equals(ITypeMember x, ITypeMember y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<JetBrains.ReSharper.Psi.ITypeMember>.GetHashCode(ITypeMember member);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<JetBrains.ReSharper.Psi.IDeclaredElement>.Equals(IDeclaredElement x, IDeclaredElement y);
    public static bool CompareDescriptors(IList`1<AnonymousTypeDescriptor> d1, IList`1<AnonymousTypeDescriptor> d2, bool caseSensitive);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<JetBrains.ReSharper.Psi.IDeclaredElement>.GetHashCode(IDeclaredElement obj);
}
public abstract class JetBrains.ReSharper.Psi.Impl.DefaultPropertiesForFileInProject : object {
    [CompilerGeneratedAttribute]
private IProject <Project>k__BackingField;
    [NotNullAttribute]
protected IPsiModule Module { get; }
    [CanBeNullAttribute]
protected IProject Project { get; }
    public bool ShouldBuildPsi { get; }
    public bool IsGeneratedFile { get; }
    public bool IsICacheParticipant { get; }
    public bool ProvidesCodeModel { get; }
    public bool IsNonUserFile { get; }
    protected DefaultPropertiesForFileInProject(IProject project);
    protected abstract virtual IPsiModule get_Module();
    [CompilerGeneratedAttribute]
protected IProject get_Project();
    public virtual ICollection`1<PreProcessingDirective> GetDefines();
    public virtual IEnumerable`1<string> GetPreImportedNamespaces();
    public virtual string GetDefaultNamespace();
    public abstract virtual bool get_ShouldBuildPsi();
    public abstract virtual bool get_IsGeneratedFile();
    public abstract virtual bool get_IsICacheParticipant();
    public abstract virtual bool get_ProvidesCodeModel();
    public abstract virtual bool get_IsNonUserFile();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Impl.DefaultPsiProjectFileProperties : DefaultPropertiesForFileInProject {
    [CompilerGeneratedAttribute]
private IProjectFile <ProjectFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    [NotNullAttribute]
protected IProjectFile ProjectFile { get; }
    [NotNullAttribute]
protected IPsiSourceFile SourceFile { get; }
    protected IPsiModule Module { get; }
    public bool ShouldBuildPsi { get; }
    public bool IsNonUserFile { get; }
    public bool IsGeneratedFile { get; }
    public bool ProvidesCodeModel { get; }
    public bool IsICacheParticipant { get; }
    public DefaultPsiProjectFileProperties(IProjectFile projectFile, IPsiSourceFile sourceFile);
    [CompilerGeneratedAttribute]
protected IProjectFile get_ProjectFile();
    [CompilerGeneratedAttribute]
protected IPsiSourceFile get_SourceFile();
    protected virtual IPsiModule get_Module();
    public virtual bool get_ShouldBuildPsi();
    public virtual bool get_IsNonUserFile();
    public virtual bool get_IsGeneratedFile();
    public virtual bool get_ProvidesCodeModel();
    public virtual bool get_IsICacheParticipant();
}
public class JetBrains.ReSharper.Psi.Impl.DefaultTypePresenter : object {
    public static DefaultTypePresenter Instance;
    private static DefaultTypePresenter();
    private static ITypePresenter GetTypePresenter();
    public sealed virtual RichText GetPresentableName(IType type, TypePresentationStyle typePresentationStyle);
    public sealed virtual RichText GetUnresolvedScalarTypePresentation(string name, ICollection`1<IType> typeArguments, NullableAnnotation nullableAnnotation, TypePresentationStyle typePresentationStyle);
}
public class JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigCollectionInfoResults : object {
    [CompilerGeneratedAttribute]
private IList`1<ISettingsStorageMountPoint> <MountPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfigFileType <FileType>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigFileService <ConfigFileService>k__BackingField;
    public IList`1<ISettingsStorageMountPoint> MountPoints { get; public set; }
    public IConfigFileType FileType { get; public set; }
    public ConfigFileService ConfigFileService { get; public set; }
    public ICollection`1<SettingIndex> Entries { get; }
    private IEnumerable`1<ISettingsStorageMountPoint> JetBrains.ReSharper.Psi.EditorConfig.IConfigFileInfo.MountPoints { get; }
    [CompilerGeneratedAttribute]
public IList`1<ISettingsStorageMountPoint> get_MountPoints();
    [CompilerGeneratedAttribute]
public void set_MountPoints(IList`1<ISettingsStorageMountPoint> value);
    [CompilerGeneratedAttribute]
public sealed virtual IConfigFileType get_FileType();
    [CompilerGeneratedAttribute]
public void set_FileType(IConfigFileType value);
    [CompilerGeneratedAttribute]
public ConfigFileService get_ConfigFileService();
    [CompilerGeneratedAttribute]
public void set_ConfigFileService(ConfigFileService value);
    public sealed virtual ICollection`1<SettingIndex> get_Entries();
    public sealed virtual bool HasNonEmptyConfig();
    private sealed virtual override IEnumerable`1<ISettingsStorageMountPoint> JetBrains.ReSharper.Psi.EditorConfig.IConfigFileInfo.get_MountPoints();
    private void AddAllFromSection(ISettingsStorageMountPoint mountPoint, HashSet`1<SettingIndex> settings);
    private static void ProcessKeys(IList`1<SettingsKeyInstance> rootKeys, HashSet`1<SettingIndex> settings);
}
public class JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigDataForFile : object {
    public VirtualFileSystemPath Location;
    public Pair`2[] Files;
    public bool LastFileWithRootProperty;
    [CompilerGeneratedAttribute]
private SettingsStorageMountPoint <MountPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<SettingIndex> <Entries>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfigFileType <FileType>k__BackingField;
    public SettingsStorageMountPoint MountPoint { get; public set; }
    public ICollection`1<SettingIndex> Entries { get; public set; }
    public IConfigFileType FileType { get; public set; }
    public IEnumerable`1<ISettingsStorageMountPoint> MountPoints { get; }
    [CompilerGeneratedAttribute]
public SettingsStorageMountPoint get_MountPoint();
    [CompilerGeneratedAttribute]
public void set_MountPoint(SettingsStorageMountPoint value);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<SettingIndex> get_Entries();
    [CompilerGeneratedAttribute]
public void set_Entries(ICollection`1<SettingIndex> value);
    [CompilerGeneratedAttribute]
public sealed virtual IConfigFileType get_FileType();
    [CompilerGeneratedAttribute]
public void set_FileType(IConfigFileType value);
    public sealed virtual bool HasNonEmptyConfig();
    public sealed virtual IEnumerable`1<ISettingsStorageMountPoint> get_MountPoints();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PsiComponentAttribute("10")]
internal class JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigFileCache : SimpleICache`1<ConfigFileCacheData> {
    private Lifetime myLifetime;
    private ConfigFileService myConfigFileService;
    private ConfigFileProcessor myConfigFileProcessor;
    private ILogger myLogger;
    [CompilerGeneratedAttribute]
private ICollectionEvents`1<ISettingsStorageMountPoint> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollectionEvents`1<VirtualFileSystemPath> <ConfigFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    private IFileSystemTracker myFileSystemTracker;
    private ChangeManager myChangeManager;
    private ISettingsStore mySettingsStore;
    public ICollectionEvents`1<ISettingsStorageMountPoint> Items { get; public set; }
    public ICollectionEvents`1<VirtualFileSystemPath> ConfigFiles { get; }
    public ISolution Solution { get; }
    public string Version { get; }
    public ConfigFileCache(Lifetime lifetime, PersistentIndexManager persistentIndexManager, ConfigFileService configFileService, ConfigFileCacheDataMarshaller marshaller, ConfigFileProcessor configFileProcessor, IShellLocks locks, ISolution solution, IFileSystemTracker fileWithLocationTracker, ChangeManager changeManager, ISettingsStore settingsStore);
    [CompilerGeneratedAttribute]
public ICollectionEvents`1<ISettingsStorageMountPoint> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(ICollectionEvents`1<ISettingsStorageMountPoint> value);
    [CompilerGeneratedAttribute]
public sealed virtual ICollectionEvents`1<VirtualFileSystemPath> get_ConfigFiles();
    [CompilerGeneratedAttribute]
public ISolution get_Solution();
    private void SwitchMountPoints(IConfigFileType fileType, PropertyChangedEventArgs`1<bool> args);
    public virtual string get_Version();
    protected virtual bool IsApplicable(IPsiSourceFile sourceFile);
    public virtual void MergeLoaded(object data);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigFileCache/<GetAffectedProjectFiles>d__23")]
public sealed virtual IEnumerable`1<IProjectFile> GetAffectedProjectFiles(VirtualFileSystemPath configFilePath, Predicate`1<IProjectFile> predicate);
    public sealed virtual void Invalidate();
    private List`1<ISettingsStorageMountPoint> SelectItems(IConfigFileType fileType);
    private void AddItems(List`1<ISettingsStorageMountPoint> list, string message, bool sync);
    public virtual void Merge(IPsiSourceFile sourceFile, object builtPart);
    private void RemoveItems(ConfigFileCacheData fileData, string message, bool sync);
    private void RemoveItems(List`1<ISettingsStorageMountPoint> list, string message, ConfigFileCacheData fileData, bool sync);
    private void RemoveRangeSync(List`1<ISettingsStorageMountPoint> list, string message);
    public virtual void Drop(IPsiSourceFile sourceFile);
    public virtual object Build(IPsiSourceFile sourceFile, bool isStartup);
    public virtual bool UpToDate(IPsiSourceFile sourceFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiredMemberAttribute]
internal class JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigFileCacheData : object {
    [CompilerGeneratedAttribute]
private List`1<ConfigSectionCacheData> <Sections>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfigFileType <FileType>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <FileSystemPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <PsiSourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastModifiedUtc>k__BackingField;
    [RequiredMemberAttribute]
public List`1<ConfigSectionCacheData> Sections { get; public set; }
    [RequiredMemberAttribute]
public IConfigFileType FileType { get; public set; }
    [RequiredMemberAttribute]
public VirtualFileSystemPath FileSystemPath { get; public set; }
    [RequiredMemberAttribute]
public IPsiSourceFile PsiSourceFile { get; public set; }
    public DateTime LastModifiedUtc { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<ConfigSectionCacheData> get_Sections();
    [CompilerGeneratedAttribute]
public void set_Sections(List`1<ConfigSectionCacheData> value);
    [CompilerGeneratedAttribute]
public IConfigFileType get_FileType();
    [CompilerGeneratedAttribute]
public void set_FileType(IConfigFileType value);
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_FileSystemPath();
    [CompilerGeneratedAttribute]
public void set_FileSystemPath(VirtualFileSystemPath value);
    [CompilerGeneratedAttribute]
public IPsiSourceFile get_PsiSourceFile();
    [CompilerGeneratedAttribute]
public void set_PsiSourceFile(IPsiSourceFile value);
    [CompilerGeneratedAttribute]
public DateTime get_LastModifiedUtc();
    [CompilerGeneratedAttribute]
public void set_LastModifiedUtc(DateTime value);
}
[PsiComponentAttribute("10")]
internal class JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigFileCacheDataMarshaller : object {
    private ConfigFileService myConfigFileService;
    private IPersistentIndexManager myPersistentIndexManager;
    private ILogger myLogger;
    private static byte TupleType;
    private static byte NullType;
    public ConfigFileCacheDataMarshaller(ConfigFileService configFileService, IPersistentIndexManager persistentIndexManager);
    public sealed virtual void Marshal(UnsafeWriter writer, ConfigFileCacheData value);
    private void WriteSection(UnsafeWriter writer, ConfigSectionCacheData value, IConfigFileType fileType);
    private void WriteObject(UnsafeWriter writer2, object o);
    public sealed virtual ConfigFileCacheData Unmarshal(UnsafeReader reader);
    private ConfigSectionCacheData ReadSection(UnsafeReader reader, ValueTuple`4<IConfigFileType, VirtualFileSystemPath, IRawStringIntern, IPsiSourceFile> context);
    private object ReadObject(UnsafeReader reader2, IRawStringIntern intern);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigFileGroupAvailability : object {
    private ConfigFileService myConfigFileService;
    private IShellLocks myLocks;
    private Lifetime myLifetime;
    private HashSet`1<object> myItems;
    private List`1<IConfigFileMountCollection> myMountCollections;
    private List`1<IConfigFileTypeWithDefaulters> myDefaultTypes;
    private SpinWaitLock myLock;
    private IConfigFileCustomOverride myOverride;
    private ILogger myLogger;
    private IProperty`1<bool> myIsStyleCopReadingEnabledProperty;
    private LoggingLevel myReadLockNotAcquiredLogLevel;
    private IEnumerable`1<object> Items { get; }
    private bool JetBrains.Application.Settings.IIsAvailableOptimizedGroup.IsEmpty { get; }
    public ConfigFileGroupAvailability(Lifetime lifetime, ILogger logger, ISettingsStore settingsStore, IShellLocks locks, ISettingsSchema schema, IConfigFileCustomOverride override, ConfigFileService configFileService, ISolutionLoadTasksScheduler solutionLoadTasksScheduler);
    private IEnumerable`1<object> get_Items();
    private sealed virtual override bool JetBrains.Application.Settings.IIsAvailableOptimizedGroup.get_IsEmpty();
    [NullableContextAttribute("0")]
private sealed virtual override void JetBrains.Application.Settings.IIsAvailableOptimizedGroup.EvaluateItems(FrugalLocalList`1& modreq(System.Runtime.InteropServices.InAttribute) queries);
    [NullableContextAttribute("0")]
private bool TryEvaluateItems(FrugalLocalList`1& queries, Lifetime lifetime, int timeout);
    internal SourceFileDataForConfig GetSourceFileInfo(IPsiSourceFile psiSourceFile);
    private ValueTuple`2<SourceFileDataForConfig, bool> GetDataFromDataContextInternal(Lifetime lifeLimit, DataContextDelegate context);
    private Result`1<TResult> ExecuteUnderReadLockSmart(TParam param, Func`2<TParam, TResult> action, int timeout);
    [NullableContextAttribute("0")]
private static bool IsAllDataContextsEmpty(FrugalLocalList`1& queries);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigFileGroupAvailability/<JetBrains-Application-Settings-IIsAvailableOptimizedGroup-EvaluateItemsAsync>d__24")]
private sealed virtual override Task JetBrains.Application.Settings.IIsAvailableOptimizedGroup.EvaluateItemsAsync(Lifetime lifetime, FrugalLocalList`1<AvailabilityGroupQuery> queries);
    private sealed virtual override bool JetBrains.Application.Settings.IIsAvailableOptimizedGroup.TryAddItem(Lifetime lifetime, ISettingsStorageMountPoint item, IIsAvailable availability);
    private sealed virtual override IEnumerable`1<ISettingsStorageMountPoint> JetBrains.Application.Settings.IIsAvailableOptimizedGroup.GetItems();
    private bool TryAddItem(Lifetime lifetime, object item, IIsAvailable availability);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertValid();
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_1();
}
public class JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigFileMountPointAvailability : object {
    [CompilerGeneratedAttribute]
private IConfigFileType <ConfigFileType>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <DirectoryPathOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <FullPathName>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfigFileMask <Mask>k__BackingField;
    [CompilerGeneratedAttribute]
private IConfigFileService <ConfigFileService>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <PsiSourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OrderNum>k__BackingField;
    [CompilerGeneratedAttribute]
private object <AdditionalData>k__BackingField;
    public IConfigFileType ConfigFileType { get; }
    public VirtualFileSystemPath DirectoryPathOnly { get; }
    public VirtualFileSystemPath FullPathName { get; }
    [CanBeNullAttribute]
public IConfigFileMask Mask { get; }
    public IConfigFileService ConfigFileService { get; }
    public bool IsRoot { get; }
    public IPsiSourceFile PsiSourceFile { get; }
    public int OrderNum { get; }
    public object AdditionalData { get; }
    public ConfigFileMountPointAvailability(IConfigFileType configFileType, VirtualFileSystemPath path, IConfigFileMask mask, IConfigFileService configFileService, bool isRoot, IPsiSourceFile psiSourceFile, int orderNum, object additionalData);
    [CompilerGeneratedAttribute]
public IConfigFileType get_ConfigFileType();
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_DirectoryPathOnly();
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_FullPathName();
    [CompilerGeneratedAttribute]
public IConfigFileMask get_Mask();
    [CompilerGeneratedAttribute]
public IConfigFileService get_ConfigFileService();
    [CompilerGeneratedAttribute]
public bool get_IsRoot();
    [CompilerGeneratedAttribute]
public IPsiSourceFile get_PsiSourceFile();
    [CompilerGeneratedAttribute]
public int get_OrderNum();
    [CompilerGeneratedAttribute]
public object get_AdditionalData();
    public sealed virtual bool IsAvailable(IDataContext context);
    public virtual IIsAvailableOptimizedGroup CreateEmptyGroup();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigFileMountProjectCollection : object {
    private ReaderWriterLockSlim myLockData;
    private OneToListMap`2<IProject, ISettingsStorageMountPoint> myMapProjectToConfigs;
    private IConfigFileType myConfigFileType;
    private ConfigFileService myConfigFileService;
    private IShellLocks myLocks;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ConfigFileGroupAvailability <JetBrains.ReSharper.Psi.impl.EditorConfig.IConfigFileMountCollection.ConfigFileGroupAvailability>k__BackingField;
    protected GroupingEvent myGroupingConfigFilesChanged;
    [NullableAttribute("2")]
private ConfigFileGroupAvailability JetBrains.ReSharper.Psi.impl.EditorConfig.IConfigFileMountCollection.ConfigFileGroupAvailability { get; private set; }
    [NullableAttribute("2")]
public ConfigFileGroupAvailability ConfigFileGroupAvailability { get; }
    protected Comparison`1<ISettingsStorageMountPoint> PrioritySortComparison { get; }
    public IConfigFileType ConfigFileType { get; }
    protected ConfigFileMountProjectCollection(Lifetime lifetime, IConfigFileType configFileType, ConfigFileService configFileService);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private sealed virtual override ConfigFileGroupAvailability JetBrains.ReSharper.Psi.impl.EditorConfig.IConfigFileMountCollection.get_ConfigFileGroupAvailability();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private sealed virtual override void JetBrains.ReSharper.Psi.impl.EditorConfig.IConfigFileMountCollection.set_ConfigFileGroupAvailability(ConfigFileGroupAvailability value);
    [NullableContextAttribute("2")]
public ConfigFileGroupAvailability get_ConfigFileGroupAvailability();
    protected virtual bool IsExplicitlyIncluded(IPsiSourceFile sourceFile);
    protected virtual Comparison`1<ISettingsStorageMountPoint> get_PrioritySortComparison();
    public sealed virtual IConfigFileType get_ConfigFileType();
    protected abstract virtual bool ShouldYieldMounts(SourceFileDataForConfig sourceFileData);
    public sealed virtual VirtualFileSystemPath[] GetApplicableConfigFiles(IPsiSourceFile psiSourceFile);
    public sealed virtual void CollectMountPointsForSourceFile(IList`1<ISettingsStorageMountPoint> list, SourceFileDataForConfig sourceFileData);
    public sealed virtual void AddMountPoint(ISettingsStorageMountPoint mountPoint, ConfigFileMountPointAvailability availMy);
    public void RemoveMountPointsOnMatchingPath(ConfigFileMountPointAvailability availability);
    public sealed virtual void RemoveMountPoint(ISettingsStorageMountPoint mountPoint, ConfigFileMountPointAvailability availMy);
    public sealed virtual IEnumerable`1<ISettingsStorageMountPoint> GetAllMountPoints();
    public sealed virtual IProperty`1<IConfigFileInfo> GetConfigFileInfo(Lifetime lifetime, IPsiSourceFile psiSourceFile);
    public sealed virtual IConfigFileInfo GetConfigFileInfo(IPsiSourceFile psiSourceFile);
    protected virtual List`1<IProject> GetProjectsForSourceFile(IPsiSourceFile sourceFile);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigFileProcessor : AdditionalFilesModuleFactoryBase {
    [NotNullAttribute]
private ConfigFileService myConfigFileService;
    [NotNullAttribute]
private FreeThreadedGroupingEvent myGroupingProjectModelChanges;
    [NotNullAttribute]
private FreeThreadedGroupingEvent myGroupingRemoveNonActualConfigFiles;
    [NotNullAttribute]
private object myLockQueue;
    [NotNullAttribute]
private JetHashSet`1<VirtualFileSystemPath> myFileSet;
    [NotNullAttribute]
private IPsiSourceFileProperties myFileProperties;
    [NotNullAttribute]
private String[] myConfigFileNames;
    [NotNullAttribute]
private string myFileSystemChangeDescription;
    [NotNullAttribute]
private string myProjectModelChangeDescription;
    [NotNullAttribute]
private string myInitialLoadChangeDescription;
    private FrugalLocalHashSet`1<VirtualFileSystemPath> myAddedFoldersToProcess;
    private FrugalLocalHashSet`1<VirtualFileSystemPath> myRemovedFoldersToProcess;
    private FrugalLocalHashSet`1<VirtualFileSystemPath> myAddedConfigFilesToProcess;
    private FrugalLocalHashSet`1<VirtualFileSystemPath> myRemovedConfigFilesToProcess;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myLoadStarted;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myReadConfigAboveSolution;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <Ready>k__BackingField;
    [NotNullAttribute]
public IProperty`1<bool> Ready { get; }
    public ConfigFileProcessor(Lifetime lifetime, ISolution solution, ConfigFileService configFileService, ISolutionLoadTasksScheduler scheduler, IFileSystemTracker fileSystemTracker, ChangeManager changeManager, ISettingsStore settingsStore, SolutionFileLocationLive solutionFileLocationLive, ConfigFilesModuleFactory moduleFactory, PsiProjectFileTypeCoordinator coordinator, IProjectFileExtensions extensions);
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_Ready();
    public void Invalidate();
    private void QueueProcessSolution();
    private void ProcessProjectModelChanges();
    private void FileSystemChanged(FileSystemChange change);
    private void ProcessFileSystemDelta(FileSystemChangeDelta delta, FrugalLocalList`1& added, FrugalLocalList`1& removed);
    private void ProcessFilePaths(FrugalLocalHashSet`1& added, bool remove, object changeDescription, FrugalLocalHashSet`1& addedToSolutionConfigs, FrugalLocalHashSet`1& removedFromSolutionConfigs, bool onlyRemove);
    protected virtual void OnChangesPropagated(object changeDescription);
    private HashSet`1<VirtualFileSystemPath> AddConfigFileNames(HashSet`1<VirtualFileSystemPath> setWithParents, Func`2<VirtualFileSystemPath, bool> checker);
    private HashSet`1<VirtualFileSystemPath> GetAllParents(FrugalLocalHashSet`1& set);
    private String[] GetConfigFileNames();
    private void ProcessSolution(bool onlyRemove);
    private void QueueProjectModelProcessing(ConfigFileProjectModelChangeVisitor visitor);
    protected virtual bool MustAlwaysHaveAdditionalFile(VirtualFileSystemPath oldLocation);
    public virtual object Execute(IChangeMap changeMap);
    protected virtual bool ShouldAcceptMiscProjectFile(IProjectFile projectFile);
    protected virtual IPsiSourceFileProperties CreateProperties();
    [CompilerGeneratedAttribute]
private void <QueueProcessSolution>b__21_0();
    [CompilerGeneratedAttribute]
private void <QueueProcessSolution>b__21_1();
    [CompilerGeneratedAttribute]
private bool <ProcessFilePaths>b__25_2(VirtualFileSystemPath path);
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigFileService : object {
    private ConfigFileTypeData[] myTypes;
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    [CompilerGeneratedAttribute]
private InternKeyPathComponent <Interned>k__BackingField;
    [CompilerGeneratedAttribute]
private IShellLocks <ShellLocks>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettingsStore <SettingsStore>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigFilesMountPointsProvider <MountPointsProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<VirtualFileSystemPath, string> <DebugDescriptionForKey>k__BackingField;
    [CompilerGeneratedAttribute]
private IContextBoundSettingsStoreLive <LiveSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private CollectionEvents`1<NonDefaultFileTypeEntry> <NonDefaultFileTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <FileNamesForPathBasedDetection>k__BackingField;
    public Lifetime Lifetime { get; }
    [NotNullAttribute]
public ISolution Solution { get; internal set; }
    [NotNullAttribute]
public InternKeyPathComponent Interned { get; }
    [NotNullAttribute]
internal IShellLocks ShellLocks { get; }
    [NotNullAttribute]
internal ISettingsStore SettingsStore { get; }
    [NotNullAttribute]
public ILogger Logger { get; }
    [NotNullAttribute]
internal ConfigFilesMountPointsProvider MountPointsProvider { get; }
    [NotNullAttribute]
internal Func`2<VirtualFileSystemPath, string> DebugDescriptionForKey { get; }
    public IContextBoundSettingsStoreLive LiveSettings { get; }
    public CollectionEvents`1<NonDefaultFileTypeEntry> NonDefaultFileTypes { get; }
    public String[] FileNamesForPathBasedDetection { get; }
    public ConfigFileGroupAvailability GroupAvailability { get; }
    public ConfigFileService(IEnumerable`1<IConfigFileType> types, ISolution solution, Lifetime lifetime, IShellLocks shellLocks, ISettingsStore settingsStore, ILogger logger, ConfigFilesMountPointsProvider mountPointsProvider, InternKeyPathComponent interned, IApplicationWideContextBoundSettingStore liveSettingsContainer);
    [CompilerGeneratedAttribute]
public sealed virtual Lifetime get_Lifetime();
    [CompilerGeneratedAttribute]
public ISolution get_Solution();
    [CompilerGeneratedAttribute]
internal void set_Solution(ISolution value);
    [CompilerGeneratedAttribute]
public InternKeyPathComponent get_Interned();
    [CompilerGeneratedAttribute]
internal IShellLocks get_ShellLocks();
    [CompilerGeneratedAttribute]
internal ISettingsStore get_SettingsStore();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
internal ConfigFilesMountPointsProvider get_MountPointsProvider();
    [CompilerGeneratedAttribute]
internal Func`2<VirtualFileSystemPath, string> get_DebugDescriptionForKey();
    [CompilerGeneratedAttribute]
public IContextBoundSettingsStoreLive get_LiveSettings();
    [CompilerGeneratedAttribute]
public CollectionEvents`1<NonDefaultFileTypeEntry> get_NonDefaultFileTypes();
    private static ConfigFileTypeData MakeConfigFileTypeData(ConfigFileService service, IConfigFileType type);
    public sealed virtual IConfigFileMountCollection GetMountTree(IConfigFileType configFileType);
    [CanBeNullAttribute]
public sealed virtual IConfigFileMountCollection TryGetMountDefault(IConfigFileType configFileType, IConfigDefaulter defaulter);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_FileNamesForPathBasedDetection();
    public sealed virtual ConfigFileGroupAvailability get_GroupAvailability();
    public virtual string GetFilePathDescriptionForLogs(VirtualFileSystemPath path);
    private static void AssureItemAt(ListEvents`1<T> listEvents, T mountPoint, int i);
    public sealed virtual OneToListMultimap`2<SettingIndex, SettingSourceInfo> GetEntriesWithDetails(IContextBoundSettingsStore context, IPsiSourceFile psiSourceFile);
    public sealed virtual IListEvents`1<IConfigFileInfo> GetConfigInfoLive(Lifetime lifetime, IPsiSourceFile psiSourceFile);
    public sealed virtual IEnumerable`1<IConfigFileType> GetTypes();
    public sealed virtual IReadOnlyList`1<IConfigFile> GetInvolvedFilesAndProperties(IConfigFileType fileType, IPsiSourceFile psiSourceFile);
    private bool PruneEmpty(IModifiableConfigContainer configContainer, VirtualFileSystemPath path, bool pruneComments);
    public sealed virtual IProperty`1<IConfigFileInfo> GetConfigFileInfo(IConfigFileType fileType, Lifetime lifetime, IPsiSourceFile psiSourceFile);
    private ConfigFileTypeData GetConfigFileTypeData(IConfigFileType fileType);
    public IProperty`1<bool> IsEnabled(IConfigFileType fileType);
    [CompilerGeneratedAttribute]
private ConfigFileTypeData <.ctor>b__33_1(IConfigFileType it);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigFileServiceUtils : object {
    [ExtensionAttribute]
public static double GetMountPointPriority(IConfigFileType fileType);
    [ExtensionAttribute]
public static double GetMountPointPriority(IConfigDefaulter defaulter);
    public static string GetConfigFileSection(IConfigFileType fileType, VirtualFileSystemPath configFilePath, VirtualFileSystemPath sourceFilePath);
    public static List`1<IConfigFile> ParseConfigFilesTillRoot(IConfigFileType fileType, VirtualFileSystemPath[] fileNames, ILogger logger, bool details);
    public static Object[] FilterConfigsByFileName(VirtualFileSystemPath location, List`1<IConfigFile> list);
    public static bool CompareListsOfUsedFiles(VirtualFileSystemPath[] newList, Pair`2[] oldList, bool configLastFileWithRootProperty);
    public static Pair`2[] GetListOfUsedFilesAndTheirTimestamps(List`1<IConfigFile> editorConfigFiles);
    public static SettingsStorageMountPoint CreateStorage(Lifetime lifetime, string name, ILogger logger, InternKeyPathComponent interned, IConfigFileType configFileType);
    public static SettingsStorageMountPoint ConvertSettingsToMountPoint(string name, ConfigFileService configFileService, ConvertedSettings converter, IConfigFileType configFileType);
    public static Result`1<TResult> ExecuteUnderReadLockSmart(IShellLocks shellLocks, TParam param, Func`2<TParam, TResult> action, int timeout);
    public static bool IsAllDataContextsEmpty(FrugalLocalList`1& queries);
}
[PsiModuleFactoryAttribute("16")]
public class JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigFilesModuleFactory : object {
    private static string PersistentId;
    [CompilerGeneratedAttribute]
private PsiModuleOnFileSystemPaths <PsiModule>k__BackingField;
    [CompilerGeneratedAttribute]
private HybridCollection`1<IPsiModule> <Modules>k__BackingField;
    public PsiModuleOnFileSystemPaths PsiModule { get; }
    public HybridCollection`1<IPsiModule> Modules { get; }
    public ConfigFilesModuleFactory(ISolution solution, IFileSystemTracker fileSystemTracker, PsiSourceFileWithLocationTracker psiSourceFileWithLocationTracker, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public PsiModuleOnFileSystemPaths get_PsiModule();
    [CompilerGeneratedAttribute]
public sealed virtual HybridCollection`1<IPsiModule> get_Modules();
    public static bool IsPersistantIdAuthor(IPsiModule module);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigFilesMountPointsProvider : object {
    [CompilerGeneratedAttribute]
private ICollectionEvents`1<ISettingsStorageMountPoint> <Items>k__BackingField;
    public ICollectionEvents`1<ISettingsStorageMountPoint> Items { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ICollectionEvents`1<ISettingsStorageMountPoint> get_Items();
}
public class JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigFileTriePathCollection : ConfigFileTriePathCollectionBase {
    [NullableContextAttribute("1")]
public ConfigFileTriePathCollection(Lifetime lifetime, IConfigFileType configFileType, ConfigFileService configFileService);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigFileTriePathCollectionBase : object {
    protected IConfigFileType myConfigFileType;
    protected ConfigFileService myConfigFileService;
    protected IShellLocks myLocks;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected FileSystemPathTrie`1<List`1<Pair`2<ConfigFileMountPointAvailability, ISettingsStorageMountPoint>>> myTrie;
    protected SpinWaitLock myLock;
    protected GroupingEvent myGroupingConfigFilesChanged;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ConfigFileGroupAvailability <JetBrains.ReSharper.Psi.impl.EditorConfig.IConfigFileMountCollection.ConfigFileGroupAvailability>k__BackingField;
    public IConfigFileType ConfigFileType { get; }
    [NullableAttribute("2")]
private ConfigFileGroupAvailability JetBrains.ReSharper.Psi.impl.EditorConfig.IConfigFileMountCollection.ConfigFileGroupAvailability { get; private set; }
    [NullableAttribute("2")]
public ConfigFileGroupAvailability ConfigFileGroupAvailability { get; }
    protected ConfigFileTriePathCollectionBase(Lifetime lifetime, IConfigFileType configFileType, ConfigFileService configFileService);
    public sealed virtual IConfigFileType get_ConfigFileType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private sealed virtual override ConfigFileGroupAvailability JetBrains.ReSharper.Psi.impl.EditorConfig.IConfigFileMountCollection.get_ConfigFileGroupAvailability();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private sealed virtual override void JetBrains.ReSharper.Psi.impl.EditorConfig.IConfigFileMountCollection.set_ConfigFileGroupAvailability(ConfigFileGroupAvailability value);
    [NullableContextAttribute("2")]
public ConfigFileGroupAvailability get_ConfigFileGroupAvailability();
    public virtual void AddMountPoint(ISettingsStorageMountPoint mountPoint, ConfigFileMountPointAvailability availMy);
    public virtual void RemoveMountPoint(ISettingsStorageMountPoint mountPoint, ConfigFileMountPointAvailability availMy);
    [ConditionalAttribute("JET_MODE_ASSERT")]
protected void AssertValid();
    public virtual IEnumerable`1<ISettingsStorageMountPoint> GetAllMountPoints();
    public void CollectMountPoints(IList`1<ISettingsStorageMountPoint> items, VirtualFileSystemPath location, HashSet`1<Pair`2<VirtualFileSystemPath, int>> hashSet);
    public void CollectMountPointsIgnoringMasks(IList`1<ISettingsStorageMountPoint> items, VirtualFileSystemPath location, HashSet`1<Pair`2<VirtualFileSystemPath, int>> hashSet);
    public sealed virtual IProperty`1<IConfigFileInfo> GetConfigFileInfo(Lifetime lifetime, IPsiSourceFile psiSourceFile);
    public sealed virtual IConfigFileInfo GetConfigFileInfo(IPsiSourceFile psiSourceFile);
    public sealed virtual VirtualFileSystemPath[] GetApplicableConfigFiles(IPsiSourceFile psiSourceFile);
    public ISettingsStorageMountPoint[] GetApplicableMountPointsIgnoringMasks(VirtualFileSystemPath psiSourceFilePath);
    public virtual void CollectMountPointsForSourceFile(IList`1<ISettingsStorageMountPoint> items, SourceFileDataForConfig sourceFileData);
}
public abstract class JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigFileTypeBase : object {
    public SettingsScalarEntry EnabledSetting { get; }
    public virtual IConfigFile GetDefaultFileForDetails(IEnumerable`1<IConfigFile> parsedFiles);
    public virtual ConvertedSettings ConvertSettings(Object[] firstPassParseResults, VirtualFileSystemPath path);
    public virtual IUnsafeMarshaller`1<IConfigFileMask> GetFileMaskMarshaller();
    public virtual IConfigFileMountCollection CreateConfigMountTree(Lifetime lifetime, ConfigFileService configFileService);
    public virtual bool Accepts(IPsiSourceFile sourceFile);
    public virtual object GetAdditionalDataToSave(IConfigElement element, IConfigFile configFile);
    public abstract virtual String[] GetFileNamesForPathBasedDetection();
    public abstract virtual SettingsScalarEntry get_EnabledSetting();
    public virtual bool IsEnabled(IContextBoundSettingsStore context);
    public virtual IProperty`1<bool> IsEnabled(Lifetime lifetime, IContextBoundSettingsStoreLive context, IThreading threading);
    public virtual ConfigProjectAvailability GetProjectFileAvailability(IPsiSourceFile psiSourceFile);
    public virtual IProperty`1<ConfigProjectAvailability> GetProjectFileAvailabilityLive(IProperty`1<IPsiSourceFile> psiSourceFileProperty, Lifetime flowLifetime);
    public virtual ConfigProjectAvailability GetProjectAvailability(IProject project);
    public virtual bool ShouldDisplayProjectAvailability();
    public virtual IConfigFileInfo GetConfigFileInfo(ISolution solution, IPsiSourceFile psiSourceFile);
}
internal class JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigFileTypeData : object {
    [CompilerGeneratedAttribute]
private IConfigFileType <ConfigFileType>k__BackingField;
    [NotNullAttribute]
private ConfigFileService myConfigFileService;
    [CompilerGeneratedAttribute]
private IConfigFileMountCollection <MountTree>k__BackingField;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <IsEnabled>k__BackingField;
    public IConfigFileType ConfigFileType { get; }
    public IConfigFileMountCollection MountTree { get; }
    public IProperty`1<bool> IsEnabled { get; }
    public ConfigFileTypeData(ConfigFileService configFileService, IConfigFileType configFileType);
    [CompilerGeneratedAttribute]
public IConfigFileType get_ConfigFileType();
    [CompilerGeneratedAttribute]
public IConfigFileMountCollection get_MountTree();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_IsEnabled();
    public IConfigFileInfo GetConfigFileInfo(IPsiSourceFile psiSourceFile);
    public IProperty`1<IConfigFileInfo> GetConfigFileInfo(Lifetime lifetime, IPsiSourceFile psiSourceFile);
}
internal class JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigFileTypeDataWithDefaults : ConfigFileTypeData {
    private Dictionary`2<IConfigDefaulter, IConfigFileMountCollection> myMountTreeDefaults;
    public ConfigFileTypeDataWithDefaults(ConfigFileService configFileService, IConfigFileTypeWithDefaulters configFileType);
    [CanBeNullAttribute]
public IConfigFileMountCollection GetMountForDefaulter(IConfigDefaulter defaulter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiredMemberAttribute]
internal class JetBrains.ReSharper.Psi.impl.EditorConfig.ConfigSectionCacheData : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IConfigFileMask <FileMask>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private SettingsStorageMountPoint <MountPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OrderNum>k__BackingField;
    [CompilerGeneratedAttribute]
private object <AdditionalData>k__BackingField;
    [NullableAttribute("2")]
[RequiredMemberAttribute]
public IConfigFileMask FileMask { get; public set; }
    [RequiredMemberAttribute]
public string Name { get; public set; }
    [RequiredMemberAttribute]
public SettingsStorageMountPoint MountPoint { get; public set; }
    [RequiredMemberAttribute]
public bool IsRoot { get; public set; }
    [RequiredMemberAttribute]
public int OrderNum { get; public set; }
    [RequiredMemberAttribute]
public object AdditionalData { get; public set; }
    public ISettingsStorageSerializable Storage { get; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IConfigFileMask get_FileMask();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FileMask(IConfigFileMask value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public SettingsStorageMountPoint get_MountPoint();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MountPoint(SettingsStorageMountPoint value);
    [CompilerGeneratedAttribute]
public bool get_IsRoot();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsRoot(bool value);
    [CompilerGeneratedAttribute]
public int get_OrderNum();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OrderNum(int value);
    [CompilerGeneratedAttribute]
public object get_AdditionalData();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AdditionalData(object value);
    public ISettingsStorageSerializable get_Storage();
    public static SettingsStorageMountPoint CreateStorage(string name, ConfigFileService configFileService, IConfigFileType fileType, VirtualFileSystemPath fileSystemPath, IConfigFileMask mask, ConvertedSettings converter, bool isRoot, IPsiSourceFile psiSourceFile, int orderNum, object additionalDataToSave, string sectionName);
}
public class JetBrains.ReSharper.Psi.impl.EditorConfig.ConvertedSettings : object {
    public static ConvertedSettings EmptyInstance;
    private Dictionary`2<SettingIndex, Pair`2<object, int>> myStorage;
    public bool IsEmpty { get; }
    private static ConvertedSettings();
    public bool get_IsEmpty();
    public void AddSettingsWithPriority(SettingsEntry entry, object index, int priority, string convertedValue);
    private void AddSettingsWithPriorityObj(SettingIndex key, int priority, object convertedValue);
    public void SetValue(SettingIndex key, object convertedValue, int priority);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.impl.EditorConfig.ConvertedSettings/<GetAllValues>d__8")]
public IEnumerable`1<KeyValuePair`2<SettingIndex, object>> GetAllValues();
    public void SaveConvertedSettingsToStorage(IContextBoundSettingsStore store);
    public void SaveConvertedSettingsToMount(ISettingsStorageMountPoint mountPoint, ILogger logger);
    public void ResetSettings(ICollection`1<SettingIndex> entries, IContextBoundSettingsStore storageContext);
    public ICollection`1<SettingIndex> GetEntries();
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.impl.EditorConfig.EditorConfigCrossLanguageDescriptionProvider : object {
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.impl.EditorConfig.EditorConfigCrossLanguageDescriptionProvider/<GetDescriptions>d__0")]
public sealed virtual IEnumerable`1<Tuple`2<string, string>> GetDescriptions();
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.impl.EditorConfig.EditorConfigParser : object {
    public static string IndentStylePropName;
    public static string IndentSizePropName;
    public static string TabWidthPropName;
    public static string EndOfLinePropName;
    public static string CharsetPropName;
    public static string TrimTrailingWhitespacePropName;
    public static string InsertFinalNewlinePropName;
    public static string MaxLineLengthPropName;
    public static string RootPropName;
    public static string IsGlobalPropName;
    public static string GlobalLevelPropName;
    public static string TrueValueName;
    public static string TabValueName;
    public static string SpaceValueName;
    public static string OffValueName;
    public static string UnsetName;
    public String[] KnownProperties;
    public static string VersionString;
    public static Version Version;
    public GlobMatcherOptions myGlobOptions;
    [CompilerGeneratedAttribute]
private string <ConfigFileName>k__BackingField;
    public string ConfigFileName { get; }
    private static EditorConfigParser();
    [CompilerGeneratedAttribute]
public string get_ConfigFileName();
}
internal class JetBrains.ReSharper.Psi.Impl.EditorConfig.EditorConfigPropertyInfo : object {
    [CompilerGeneratedAttribute]
private IEditorConfigValueTypeInfo <ValueTypeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private IEditorConfigPropertyInfo <Grandparent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HideThisProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SettingIndex> <Entries>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStandard>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLanguageStandard>k__BackingField;
    public IEditorConfigValueTypeInfo ValueTypeInfo { get; }
    public string Alias { get; }
    public int Priority { get; public set; }
    public string Description { get; public set; }
    public IEditorConfigPropertyInfo Grandparent { get; public set; }
    public bool HideThisProperty { get; public set; }
    public List`1<SettingIndex> Entries { get; }
    public bool IsStandard { get; }
    public bool IsLanguageStandard { get; }
    private IEnumerable`1<SettingIndex> JetBrains.ReSharper.Psi.EditorConfig.IEditorConfigPropertyInfo.Entries { get; }
    public bool HasResharperPrefix { get; }
    public bool IsGeneralized { get; }
    public bool IsLanguageSpecific { get; }
    public EditorConfigPropertyInfo(string alias, IEditorConfigValueTypeInfo valueTypeInfo, string description, bool isStandard, bool isLanguageStandard);
    [CompilerGeneratedAttribute]
public sealed virtual IEditorConfigValueTypeInfo get_ValueTypeInfo();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Alias();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IEditorConfigPropertyInfo get_Grandparent();
    [CompilerGeneratedAttribute]
public void set_Grandparent(IEditorConfigPropertyInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HideThisProperty();
    [CompilerGeneratedAttribute]
public void set_HideThisProperty(bool value);
    [CompilerGeneratedAttribute]
public List`1<SettingIndex> get_Entries();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsStandard();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsLanguageStandard();
    private sealed virtual override IEnumerable`1<SettingIndex> JetBrains.ReSharper.Psi.EditorConfig.IEditorConfigPropertyInfo.get_Entries();
    public sealed virtual bool get_HasResharperPrefix();
    public sealed virtual bool get_IsGeneralized();
    public sealed virtual bool get_IsLanguageSpecific();
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.impl.EditorConfig.EditorConfigSchema : object {
    private Lifetime myLifetime;
    [NotNullAttribute]
private SettingsSchemaCollector mySettingsSchemaCollector;
    [NotNullAttribute]
private IEnumerable`1<IEditorConfigDescriptionProvider> myDescriptionProviders;
    private IExceptionThrowingLogger myLogger;
    private LockObject myLockEditorConfigKeysList;
    private TimeSpan myOptionLockTimeout;
    private List`1<PartCatalogType> myEditorConfigKeysList;
    [CanBeNullAttribute]
private Cache modreq(System.Runtime.CompilerServices.IsVolatile) mySchemaCache;
    private Lazy`1<IReadOnlyList`1<ReadConverter>> myReadConverters;
    private ConcurrentArray`1<WriteConverter> myWriteConverters;
    private static string ourEntryAliasName;
    private static string ourEntryAliasTypeName;
    private static string ourValueAliasName;
    private static string ourValueUseOriginalNameName;
    private static string ourKeyAliasName;
    public static string ReSharperPrefix;
    public EditorConfigSchema(Lifetime lifetime, IComponentContainer container, ShellPartCatalogSet catalogset, ISettingsLogger settingsLogger, SettingsSchemaCollector settingsSchemaCollector, IEnumerable`1<IEditorConfigDescriptionProvider> descriptionProviders);
    private static EditorConfigSchema();
    public void Dump(StringBuilder sb);
    public sealed virtual IEnumerable`1<IEditorConfigPropertyInfo> GetPropertiesForSettingsEntry(SettingsScalarEntry entry);
    public sealed virtual IEnumerable`1<IEditorConfigPropertyInfo> GetPropertiesForSettingsEntry(SettingIndex index);
    public sealed virtual IEditorConfigPropertyInfo GetSpecificPropertyForSettingsEntry(SettingsScalarEntry entry);
    public sealed virtual string GetPropertyNameForHighlightingId(string id);
    public sealed virtual IEnumerable`1<IEditorConfigPropertyInfo> GetPropertiesForSettingsEntry(Expression`1<Func`2<TKey, TValue>> entry);
    public sealed virtual IEditorConfigPropertyInfo GetSettingsForAlias(string name);
    public sealed virtual IEditorConfigValueTypeInfo GetValueTypeInfo(PartCatalogType partCatalogType);
    private IEditorConfigValueTypeInfo GetOrCreateValueTypeInfo(Cache cache, PartCatalogType valueType, SettingsStoreSerializerType serializerType);
    public static IEditorConfigValueTypeInfo CreateEditorConfigValueTypeInfo(PartCatalogType valueType, SettingsStoreSerializerType serializerType);
    [NotNullAttribute]
public ConvertedSettings Convert(IJetSortedStringDictionary`1<string> editorConfigData, EditorConfigConverterCollection converterCollection, VirtualFileSystemPath ecPath);
    public Dictionary`2<IEditorConfigPropertyInfo, string> ReverseConvertAliases(IContextBoundSettingsStore store, ISettingsExportParameters parameters, IJetSortedStringDictionary`1<string> existingProperties, SettingsExportStatus settingsStatus, IContextBoundSettingsStore defaultContextBoundSettings, ICalculatedSettingsSchema schema);
    [NotNullAttribute]
private Cache EnsureValidCache();
    public sealed virtual Dictionary`2<SettingsKey, string> GetSettingsKeyToEditorConfigAlias();
    [NotNullAttribute]
private Cache BuildSchema();
    private void CreateMappingsForIndexedEntry(Cache schema, SettingsIndexedEntry indexedEntry, bool hideThisProperty, string keyAlias);
    private void CreateMappingsForScalarEntry(Cache schema, SettingsScalarEntry scalarEntry, bool hideThisProperty, string keyAlias);
    private EditorConfigPropertyInfo CreateOrUpdateProperty(Cache cache, string alias, SettingsScalarEntry entry, int priority, bool hideThisProperty, EditorConfigPropertyInfo& grandParent, bool isStandard, bool isLanguageStandard);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.impl.EditorConfig.EditorConfigSchema/<ExpandReadConverterAliases>d__35")]
public sealed virtual IEnumerable`1<ReadConverter> ExpandReadConverterAliases(IEnumerable`1<ReadConverter> converters);
    public sealed virtual HashSet`1<string> GetAllAliases(string propertyName);
    public bool IsSupported(string propertyName, EditorConfigConverterCollection converterCollection);
    public sealed virtual IEnumerable`1<IEditorConfigPropertyInfo> GetAllProperties();
    public void AddWriteConverter(Lifetime lifetime, string propertyName, bool addAllAliases, WriteConverterDelegate convert);
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.impl.EditorConfig.EditorConfigService : ConfigFileTypeBase {
    public static int EditorConfigPriority;
    private String[] myFileNames;
    [NotNullAttribute]
private ILogger myLogger;
    [NotNullAttribute]
private EditorConfigParser myParser;
    [NotNullAttribute]
private EditorConfigSchema mySchema;
    [NotNullAttribute]
private EditorConfigConverterCollection myConverterCollection;
    [CompilerGeneratedAttribute]
private SettingsScalarEntry <EnabledSetting>k__BackingField;
    internal static Regex SectionRegex;
    internal static Regex CommentRegex;
    internal static Regex PropertyRegex;
    [CompilerGeneratedAttribute]
private IConfigDefaulter[] <ConfigDefaulters>k__BackingField;
    public SettingsScalarEntry EnabledSetting { get; }
    public string Name { get; }
    public string DisplayName { get; }
    public HelpId HelpTopicId { get; }
    public int Priority { get; }
    public bool InheritFromParentFile { get; }
    public IConfigDefaulter[] ConfigDefaulters { get; }
    public EditorConfigService(ILogger logger, EditorConfigParser parser, EditorConfigSchema schema, ISettingsSchema settingsSchema, EditorConfigConverterCollection converterCollection, IEnumerable`1<IConfigDefaultersFactory`1<EditorConfigService>> defaultersFactories);
    private static EditorConfigService();
    [CompilerGeneratedAttribute]
public virtual SettingsScalarEntry get_EnabledSetting();
    public sealed virtual string get_Name();
    public sealed virtual string get_DisplayName();
    public sealed virtual HelpId get_HelpTopicId();
    public sealed virtual int get_Priority();
    public sealed virtual bool get_InheritFromParentFile();
    public virtual String[] GetFileNamesForPathBasedDetection();
    public sealed virtual IConfigFile ParseFile(VirtualFileSystemPath path, TextReader reader, bool details);
    private void UpdateSectionData(EditorConfigFileSection activeSection, IJetSortedStringDictionary`1<string> activeSectionProps, ConfigFile file);
    [NotNullAttribute]
public virtual ConvertedSettings ConvertSettings(Object[] firstPassParseResults, VirtualFileSystemPath path);
    public virtual IUnsafeMarshaller`1<IConfigFileMask> GetFileMaskMarshaller();
    public virtual bool Accepts(IPsiSourceFile sourceFile);
    [CompilerGeneratedAttribute]
public sealed virtual IConfigDefaulter[] get_ConfigDefaulters();
    [CompilerGeneratedAttribute]
private IConfigFileMask <GetFileMaskMarshaller>b__28_0(UnsafeReader reader);
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.impl.EditorConfig.EditorConfigStandardPropertiesConverter : object {
    private sealed virtual override IEnumerable`1<ReadConverter> JetBrains.ReSharper.Psi.impl.EditorConfig.IEditorConfigSchemaReadConvertersProvider.ProvideReadConverters(IEditorConfigSchemaCollector manager);
    public static string GetPrefix(string propertyName, string mainPart);
    private void ConvertIndentStyleOnRead(string propertyName, string value, IDictionary`2<string, string> properties, ConvertedSettings convertedSettings);
    private void ConvertIndentSizeOnRead(string propertyName, string value, IDictionary`2<string, string> properties, ConvertedSettings convertedSettings);
    private void ConvertMaxLineLengthOnRead(string propertyName, string value, IDictionary`2<string, string> properties, ConvertedSettings convertedSettings);
    private void ConvertEndOfLineOnRead(string propertyname, string value, IDictionary`2<string, string> properties, ConvertedSettings convertedSettings);
}
internal class JetBrains.ReSharper.Psi.Impl.EditorConfig.EditorConfigValueInfo : object {
    private InterruptibleLazy`1<string> myDescription;
    private InterruptibleLazy`1<object> myValueEnum;
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Alias { get; }
    public string Value { get; }
    public object ValueObj { get; }
    public long ValueInt { get; }
    public string Description { get; }
    public EditorConfigValueInfo(string alias, string value, InterruptibleLazy`1<string> description, InterruptibleLazy`1<object> valueEnum);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Alias();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Value();
    public sealed virtual object get_ValueObj();
    public long get_ValueInt();
    public sealed virtual string get_Description();
}
internal class JetBrains.ReSharper.Psi.Impl.EditorConfig.EditorConfigValueTypeInfo : object {
    private Type myBindedType;
    private InterruptibleLazy`1<bool> myIsFlags;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<IEditorConfigValueInfo> <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private PartCatalogType <ValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private SettingsStoreSerializerType <SerializerType>k__BackingField;
    [CompilerGeneratedAttribute]
private IEditorConfigCustomSerializer <CustomSerializer>k__BackingField;
    public IReadOnlyCollection`1<IEditorConfigValueInfo> Values { get; }
    public PartCatalogType ValueType { get; }
    public SettingsStoreSerializerType SerializerType { get; }
    public bool IsFlags { get; }
    public bool IsEnum { get; }
    public IEditorConfigCustomSerializer CustomSerializer { get; }
    public EditorConfigValueTypeInfo(PartCatalogType valueType, SettingsStoreSerializerType serializerType, IReadOnlyCollection`1<IEditorConfigValueInfo> values, IEditorConfigCustomSerializer customSerializer);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyCollection`1<IEditorConfigValueInfo> get_Values();
    [CompilerGeneratedAttribute]
public sealed virtual PartCatalogType get_ValueType();
    [CompilerGeneratedAttribute]
public sealed virtual SettingsStoreSerializerType get_SerializerType();
    public sealed virtual bool get_IsFlags();
    public sealed virtual bool get_IsEnum();
    [CompilerGeneratedAttribute]
public sealed virtual IEditorConfigCustomSerializer get_CustomSerializer();
    public Type GetBindedType();
    [CanBeNullAttribute]
private string ConvertSingleValue(string value);
    private string ConvertSingleValueToString(object value);
    private EditorConfigValueInfo GetValueInfoForEnum(object value);
    private string ConvertFlagsValueToString(object value);
    public sealed virtual string ConvertAndCheck(string value, Object& result, Boolean& isValueAcceptable);
    public sealed virtual string ConvertToString(object value);
    public sealed virtual string GetDescriptionForValue(object value);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__18_0();
}
public class JetBrains.ReSharper.Psi.impl.EditorConfig.ExpiringCache`2 : object {
    private IThreading myThreading;
    private ILogger myLogger;
    private string myName;
    private ConcurrentDictionary`2<TKey, CachedEntry<TKey, TValue>> myDict;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myResetCounter;
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExpirationTimeSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<TKey, TValue, TValue> <GetOrUpdate>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`3<TKey, TValue, Lifetime> <AssignLiveLifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<TKey, string> <GetDebugDescriptionForKey>k__BackingField;
    private Lifetime Lifetime { get; }
    private int ExpirationTimeSpan { get; }
    private Func`3<TKey, TValue, TValue> GetOrUpdate { get; }
    private Action`3<TKey, TValue, Lifetime> AssignLiveLifetime { get; }
    private Func`2<TKey, string> GetDebugDescriptionForKey { get; }
    public ExpiringCache`2(Lifetime lifetime, IThreading threading, ILogger logger, int expirationTimeSpan, string name, Func`3<TKey, TValue, TValue> getOrUpdate, Action`3<TKey, TValue, Lifetime> assignLiveLifetime, Func`2<TKey, string> getDebugDescriptionForKey);
    [CompilerGeneratedAttribute]
private Lifetime get_Lifetime();
    [CompilerGeneratedAttribute]
private int get_ExpirationTimeSpan();
    [CompilerGeneratedAttribute]
private Func`3<TKey, TValue, TValue> get_GetOrUpdate();
    [CompilerGeneratedAttribute]
private Action`3<TKey, TValue, Lifetime> get_AssignLiveLifetime();
    [CompilerGeneratedAttribute]
private Func`2<TKey, string> get_GetDebugDescriptionForKey();
    private bool Has(ExpiringCacheUpdateMode mode, ExpiringCacheUpdateMode flag);
    public void PurgeAndUpdate(ExpiringCacheUpdateMode mode);
    public Property`1<TValue> GetOrCalculate(Lifetime lifetimeToPin, TKey key);
    public TValue GetOrCalculate(TKey key);
    private void DoPurgeAndUpdate(ExpiringCacheUpdateMode mode);
    private void RemoveEntry(TKey key, CachedEntry<TKey, TValue> entry);
    private void ReleasePinned(TKey key);
    private CachedEntry<TKey, TValue> AddEntry(TKey key);
    private bool GetValue(TKey key, CachedEntry<TKey, TValue> entry, bool pinned, bool forceUpdate, Property`1& valueProperty, TValue& value);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.impl.EditorConfig.ExpiringCacheUpdateMode : Enum {
    public int value__;
    public static ExpiringCacheUpdateMode PurgeExpiredOnly;
    public static ExpiringCacheUpdateMode ForceExpire;
    public static ExpiringCacheUpdateMode UpdateLive;
    public static ExpiringCacheUpdateMode RestartUpdateIfAlreadyRunning;
}
public class JetBrains.ReSharper.Psi.impl.EditorConfig.FakeAutodetectConfigFileType : ConfigFileTypeBase {
    public string Name { get; }
    public string DisplayName { get; }
    public int Priority { get; }
    public bool InheritFromParentFile { get; }
    public SettingsScalarEntry EnabledSetting { get; }
    public HelpId HelpTopicId { get; }
    public sealed virtual string get_Name();
    public sealed virtual string get_DisplayName();
    public sealed virtual int get_Priority();
    public sealed virtual bool get_InheritFromParentFile();
    public virtual SettingsScalarEntry get_EnabledSetting();
    public sealed virtual HelpId get_HelpTopicId();
    public virtual String[] GetFileNamesForPathBasedDetection();
    public sealed virtual IConfigFile ParseFile(VirtualFileSystemPath path, TextReader stream, bool details);
}
public abstract class JetBrains.ReSharper.Psi.impl.EditorConfig.GlobalAnalyzerConfigServiceBase : ConfigFileTypeBase {
    [NotNullAttribute]
private EditorConfigParser myParser;
    [NotNullAttribute]
private EditorConfigSchema mySchema;
    [NotNullAttribute]
private EditorConfigConverterCollection myConverterCollection;
    [CompilerGeneratedAttribute]
private EditorConfigService <EditorConfigService>k__BackingField;
    public static int GlobalAnalyzerConfigPriority;
    [CompilerGeneratedAttribute]
private SettingsScalarEntry <EnabledSetting>k__BackingField;
    private String[] myFileNames;
    [CompilerGeneratedAttribute]
private IConfigDefaulter[] <ConfigDefaulters>k__BackingField;
    public EditorConfigService EditorConfigService { get; }
    public string Name { get; }
    public string DisplayName { get; }
    public int Priority { get; }
    public bool InheritFromParentFile { get; }
    public SettingsScalarEntry EnabledSetting { get; }
    public HelpId HelpTopicId { get; }
    public IConfigDefaulter[] ConfigDefaulters { get; }
    protected GlobalAnalyzerConfigServiceBase(ILogger logger, EditorConfigService editorConfigService, EditorConfigParser parser, EditorConfigSchema schema, EditorConfigConverterCollection converterCollection, IEnumerable`1<IConfigDefaultersFactory`1<GlobalAnalyzerConfigServiceBase>> defaultersFactories);
    [CompilerGeneratedAttribute]
public EditorConfigService get_EditorConfigService();
    public sealed virtual string get_Name();
    public sealed virtual string get_DisplayName();
    public sealed virtual int get_Priority();
    public sealed virtual bool get_InheritFromParentFile();
    [CompilerGeneratedAttribute]
public virtual SettingsScalarEntry get_EnabledSetting();
    public sealed virtual HelpId get_HelpTopicId();
    public virtual String[] GetFileNamesForPathBasedDetection();
    public sealed virtual IConfigFile ParseFile(VirtualFileSystemPath path, TextReader reader, bool details);
    public virtual object GetAdditionalDataToSave(IConfigElement element, IConfigFile configFile);
    public virtual ConvertedSettings ConvertSettings(Object[] firstPassParseResults, VirtualFileSystemPath path);
    [CompilerGeneratedAttribute]
public sealed virtual IConfigDefaulter[] get_ConfigDefaulters();
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.impl.EditorConfig.GlobalAnalyzerFilePathConfigService : GlobalAnalyzerConfigServiceBase {
    public GlobalAnalyzerFilePathConfigService(ILogger logger, EditorConfigService editorConfigService, EditorConfigParser parser, EditorConfigSchema schema, EditorConfigConverterCollection converterCollection, IEnumerable`1<IConfigDefaultersFactory`1<GlobalAnalyzerConfigServiceBase>> defaultersFactories);
    public virtual IConfigFileMountCollection CreateConfigMountTree(Lifetime lifetime, ConfigFileService configFileService);
    public virtual bool Accepts(IPsiSourceFile sourceFile);
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.impl.EditorConfig.GlobalAnalyzerProjectConfigService : GlobalAnalyzerConfigServiceBase {
    public GlobalAnalyzerProjectConfigService(ILogger logger, EditorConfigService editorConfigService, EditorConfigParser parser, EditorConfigSchema schema, EditorConfigConverterCollection converterCollection, IEnumerable`1<IConfigDefaultersFactory`1<GlobalAnalyzerConfigServiceBase>> defaultersFactories);
    public virtual IConfigFileMountCollection CreateConfigMountTree(Lifetime lifetime, ConfigFileService configFileService);
    public static bool IsExplicitlyIncludedConfigFile(IPsiSourceFile sourceFile);
    public virtual bool Accepts(IPsiSourceFile sourceFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.impl.EditorConfig.GlobalAnalyzerProjectMountCollection : ConfigFileMountProjectCollection {
    protected Comparison`1<ISettingsStorageMountPoint> PrioritySortComparison { get; }
    public GlobalAnalyzerProjectMountCollection(Lifetime lifetime, IConfigFileType configFileType, ConfigFileService configFileService);
    protected virtual bool IsExplicitlyIncluded(IPsiSourceFile sourceFile);
    protected virtual Comparison`1<ISettingsStorageMountPoint> get_PrioritySortComparison();
    protected virtual bool ShouldYieldMounts(SourceFileDataForConfig sourceFileData);
}
public class JetBrains.ReSharper.Psi.impl.EditorConfig.GlobMatcher : object {
    private GlobMatcherOptions myOptions;
    private List`1<PatternCase> mySet;
    private bool myNegate;
    private bool myComment;
    private bool myEmpty;
    private static Char[] ourUnixPathSeparators;
    private static Char[] ourWinPathSeparators;
    private static Regex ourHasBraces;
    private static Regex ourNumericSet;
    private GlobMatcher(GlobMatcherOptions options, List`1<PatternCase> parsedPatternSet, bool negate, bool comment, bool empty);
    private static GlobMatcher();
    public bool IsMatch(string input);
    private static bool IsPathSeparator(GlobMatcherOptions options, char c);
    public static GlobMatcher Create(string pattern, GlobMatcherOptions options);
    private static bool ParseNegate(GlobMatcherOptions options, String& pattern);
    private static IList`1<string> BraceExpand(string pattern, GlobMatcherOptions options);
    private static PatternCase Parse(GlobMatcherOptions options, string pattern);
    [CompilerGeneratedAttribute]
internal static void <Parse>g__FinishLiteral|24_0(<>c__DisplayClass24_0& );
    [CompilerGeneratedAttribute]
internal static void <Parse>g__AppendChar|24_1(char c1, <>c__DisplayClass24_0& );
    [CompilerGeneratedAttribute]
internal static void <Parse>g__HandleOpenClass|24_2(<>c__DisplayClass24_0& , <>c__DisplayClass24_1& );
}
public class JetBrains.ReSharper.Psi.impl.EditorConfig.GlobMatcherOptions : object {
    [CompilerGeneratedAttribute]
private bool <NoComment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoNegate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoBrace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoGlobStar>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Dot>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoNull>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FlipNegate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MatchBase>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowWindowsPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowWindowsPathsInPatterns>k__BackingField;
    public bool NoComment { get; public set; }
    public bool NoNegate { get; public set; }
    public bool NoBrace { get; public set; }
    public bool NoGlobStar { get; public set; }
    public bool IgnoreCase { get; public set; }
    public bool Dot { get; public set; }
    public bool NoNull { get; public set; }
    public bool FlipNegate { get; public set; }
    public bool MatchBase { get; public set; }
    public bool AllowWindowsPaths { get; public set; }
    public bool AllowWindowsPathsInPatterns { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_NoComment();
    [CompilerGeneratedAttribute]
public void set_NoComment(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoNegate();
    [CompilerGeneratedAttribute]
public void set_NoNegate(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoBrace();
    [CompilerGeneratedAttribute]
public void set_NoBrace(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoGlobStar();
    [CompilerGeneratedAttribute]
public void set_NoGlobStar(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public void set_IgnoreCase(bool value);
    [CompilerGeneratedAttribute]
public bool get_Dot();
    [CompilerGeneratedAttribute]
public void set_Dot(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoNull();
    [CompilerGeneratedAttribute]
public void set_NoNull(bool value);
    [CompilerGeneratedAttribute]
public bool get_FlipNegate();
    [CompilerGeneratedAttribute]
public void set_FlipNegate(bool value);
    [CompilerGeneratedAttribute]
public bool get_MatchBase();
    [CompilerGeneratedAttribute]
public void set_MatchBase(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowWindowsPaths();
    [CompilerGeneratedAttribute]
public void set_AllowWindowsPaths(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowWindowsPathsInPatterns();
    [CompilerGeneratedAttribute]
public void set_AllowWindowsPathsInPatterns(bool value);
}
public interface JetBrains.ReSharper.Psi.impl.EditorConfig.IConfigDefaultersFactory`1 {
    public abstract virtual IConfigDefaulter[] ProvideProjectDefaulters(ILogger logger, T fileType);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.impl.EditorConfig.IConfigFileCache {
    public ICollectionEvents`1<VirtualFileSystemPath> ConfigFiles { get; }
    public abstract virtual ICollectionEvents`1<VirtualFileSystemPath> get_ConfigFiles();
    public abstract virtual IEnumerable`1<IProjectFile> GetAffectedProjectFiles(VirtualFileSystemPath configFilePath, Predicate`1<IProjectFile> predicate);
    public abstract virtual void Invalidate();
}
public interface JetBrains.ReSharper.Psi.impl.EditorConfig.IConfigFileCustomOverride {
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual ISettingsStorageMountPoint ProvideOverride(IReadOnlyList`1<ISettingsStorageMountPoint> mounts, IReadOnlyList`1<IConfigFileTypeWithDefaulters> configFileTypeWithDefaults, SourceFileDataForConfig sourceFileDataForConfig);
}
public interface JetBrains.ReSharper.Psi.impl.EditorConfig.IConfigFileMountCollection {
    public IConfigFileType ConfigFileType { get; }
    public ConfigFileGroupAvailability ConfigFileGroupAvailability { get; internal set; }
    public abstract virtual void AddMountPoint(ISettingsStorageMountPoint mountPoint, ConfigFileMountPointAvailability availMy);
    public abstract virtual void RemoveMountPoint(ISettingsStorageMountPoint mountPoint, ConfigFileMountPointAvailability availMy);
    public abstract virtual IEnumerable`1<ISettingsStorageMountPoint> GetAllMountPoints();
    public abstract virtual IProperty`1<IConfigFileInfo> GetConfigFileInfo(Lifetime lifetime, IPsiSourceFile psiSourceFile);
    public abstract virtual IConfigFileInfo GetConfigFileInfo(IPsiSourceFile psiSourceFile);
    public abstract virtual VirtualFileSystemPath[] GetApplicableConfigFiles(IPsiSourceFile psiSourceFile);
    public abstract virtual void CollectMountPointsForSourceFile(IList`1<ISettingsStorageMountPoint> items, SourceFileDataForConfig sourceFileData);
    public abstract virtual IConfigFileType get_ConfigFileType();
    public abstract virtual ConfigFileGroupAvailability get_ConfigFileGroupAvailability();
    internal abstract virtual void set_ConfigFileGroupAvailability(ConfigFileGroupAvailability value);
}
public interface JetBrains.ReSharper.Psi.impl.EditorConfig.IConfigFileMountGroup {
    public abstract virtual void AddMountPoint(ISettingsStorageMountPoint mountPoint, ConfigFileMountPointAvailability availMy);
    public abstract virtual void RemoveMountPoint(ISettingsStorageMountPoint mountPoint, ConfigFileMountPointAvailability availMy);
    public abstract virtual IEnumerable`1<ISettingsStorageMountPoint> GetAllMountPoints();
    public abstract virtual IProperty`1<IConfigFileInfo> GetConfigFileInfo(Lifetime lifetime, IPsiSourceFile psiSourceFile);
    public abstract virtual IConfigFileInfo GetConfigFileInfo(IPsiSourceFile psiSourceFile);
    public abstract virtual VirtualFileSystemPath[] GetApplicableConfigFiles(IPsiSourceFile psiSourceFile);
}
[DerivedComponentsInstantiationRequirementAttribute("1")]
public interface JetBrains.ReSharper.Psi.impl.EditorConfig.IEditorConfigDescriptionProvider {
    public abstract virtual IEnumerable`1<Tuple`2<string, string>> GetDescriptions();
}
public interface JetBrains.ReSharper.Psi.impl.EditorConfig.IEditorConfigSchemaCollector {
    public abstract virtual IEnumerable`1<ReadConverter> ExpandReadConverterAliases(IEnumerable`1<ReadConverter> converters);
}
[DerivedComponentsInstantiationRequirementAttribute("1")]
public interface JetBrains.ReSharper.Psi.impl.EditorConfig.IEditorConfigSchemaReadConvertersProvider {
    public abstract virtual IEnumerable`1<ReadConverter> ProvideReadConverters(IEditorConfigSchemaCollector manager);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.impl.EditorConfig.IndentAutodetectService : object {
    private Key`1<PopularIndentInfo> myKey;
    private Lifetime myLifetime;
    [NotNullAttribute]
private IShellLocks myThreading;
    [NotNullAttribute]
private WeakHashSet`1<IDocument> myChangedDocuments;
    [NotNullAttribute]
private ConcurrentDictionary`2<LivePropertyInfo, LivePropertyInfo> myLiveProperties;
    private bool myUpdateScheduled;
    private ILogger myLogger;
    private IProperty`1<bool> myEnabled;
    public IndentAutodetectService(Lifetime lifetime, ILogger logger, ISettingsStore settingsStore, IShellLocks threading, ISolution solution, IPsiFiles psiFiles, DocumentManager documentManager);
    internal void CacheAutoIndentInfo(IDocument document);
    [MustUseReturnValueAttribute]
protected PopularIndentInfo GetPopularIndentInfo(IDocument document, bool ignoreDisable);
    private void ScheduleUpdate(IDocument document);
    private void UpdateSavedIndents();
    public sealed virtual int GetAutodetectedIndent(IDocument document, int indentFromSettings, bool ignoreDisable);
    public sealed virtual IProperty`1<int> GetAutodetectedIndentLive(Lifetime lifetime, IDocument document, IProperty`1<int> baseIndent, bool ignoreDisable);
    [CompilerGeneratedAttribute]
private void <ScheduleUpdate>b__11_0(Lifetime asyncLifetime);
}
internal class JetBrains.ReSharper.Psi.impl.EditorConfig.IndexedWithEnumEntryDescriptor : object {
    private IEditorConfigValueTypeInfo myTypeInfo;
    public IndexedWithEnumEntryDescriptor(IEditorConfigValueTypeInfo typeInfo);
    public sealed virtual IEnumerable`1<object> EnumerateAllPossibleIndexValues();
    public sealed virtual object GetDefaultValueForKey(object keyValue);
}
public class JetBrains.ReSharper.Psi.impl.EditorConfig.NonDefaultFileTypeEntry : object {
    [CompilerGeneratedAttribute]
private IConfigFileType <FileType>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <PsiFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SectionName>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IConfigFileType FileType { get; public set; }
    public IPsiSourceFile PsiFile { get; public set; }
    public string SectionName { get; public set; }
    public NonDefaultFileTypeEntry(IConfigFileType FileType, IPsiSourceFile PsiFile, string SectionName);
    [CompilerGeneratedAttribute]
protected NonDefaultFileTypeEntry(NonDefaultFileTypeEntry original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IConfigFileType get_FileType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FileType(IConfigFileType value);
    [CompilerGeneratedAttribute]
public IPsiSourceFile get_PsiFile();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PsiFile(IPsiSourceFile value);
    [CompilerGeneratedAttribute]
public string get_SectionName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SectionName(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(NonDefaultFileTypeEntry left, NonDefaultFileTypeEntry right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(NonDefaultFileTypeEntry left, NonDefaultFileTypeEntry right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(NonDefaultFileTypeEntry other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual NonDefaultFileTypeEntry <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(IConfigFileType& FileType, IPsiSourceFile& PsiFile, String& SectionName);
}
public class JetBrains.ReSharper.Psi.impl.EditorConfig.ReadConverter : object {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadConverterDelegate <Handler>k__BackingField;
    public string PropertyName { get; public set; }
    public ReadConverterDelegate Handler { get; public set; }
    public ReadConverter(string propertyName, ReadConverterDelegate handler);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public ReadConverterDelegate get_Handler();
    [CompilerGeneratedAttribute]
public void set_Handler(ReadConverterDelegate value);
}
public class JetBrains.ReSharper.Psi.impl.EditorConfig.ReadConverterDelegate : MulticastDelegate {
    public ReadConverterDelegate(object object, IntPtr method);
    public virtual void Invoke(string propertyName, string value, IDictionary`2<string, string> properties, ConvertedSettings convertedSettings);
    public virtual IAsyncResult BeginInvoke(string propertyName, string value, IDictionary`2<string, string> properties, ConvertedSettings convertedSettings, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.impl.EditorConfig.SourceFileDataForConfig : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IPsiSourceFile <PsiSourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LocationSuccess>k__BackingField;
    [CompilerGeneratedAttribute]
private IProject <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <ProjectFileLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProjectFileLocationSuccess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasStyleCopAnalyzersReference>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStyleCopSupportEnabledForFile>k__BackingField;
    [CompilerGeneratedAttribute]
private UserDataHolder <UserData>k__BackingField;
    [NullableAttribute("1")]
public IPsiSourceFile PsiSourceFile { get; public set; }
    public VirtualFileSystemPath Location { get; public set; }
    public bool LocationSuccess { get; public set; }
    public IProject Project { get; public set; }
    public VirtualFileSystemPath ProjectFileLocation { get; public set; }
    public bool ProjectFileLocationSuccess { get; public set; }
    public bool HasStyleCopAnalyzersReference { get; public set; }
    public bool IsStyleCopSupportEnabledForFile { get; public set; }
    public UserDataHolder UserData { get; public set; }
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IPsiSourceFile get_PsiSourceFile();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_PsiSourceFile(IPsiSourceFile value);
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(VirtualFileSystemPath value);
    [CompilerGeneratedAttribute]
public bool get_LocationSuccess();
    [CompilerGeneratedAttribute]
public void set_LocationSuccess(bool value);
    [CompilerGeneratedAttribute]
public IProject get_Project();
    [CompilerGeneratedAttribute]
public void set_Project(IProject value);
    [CompilerGeneratedAttribute]
public VirtualFileSystemPath get_ProjectFileLocation();
    [CompilerGeneratedAttribute]
public void set_ProjectFileLocation(VirtualFileSystemPath value);
    [CompilerGeneratedAttribute]
public bool get_ProjectFileLocationSuccess();
    [CompilerGeneratedAttribute]
public void set_ProjectFileLocationSuccess(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasStyleCopAnalyzersReference();
    [CompilerGeneratedAttribute]
public void set_HasStyleCopAnalyzersReference(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsStyleCopSupportEnabledForFile();
    [CompilerGeneratedAttribute]
public void set_IsStyleCopSupportEnabledForFile(bool value);
    [CompilerGeneratedAttribute]
public UserDataHolder get_UserData();
    [CompilerGeneratedAttribute]
public void set_UserData(UserDataHolder value);
}
public class JetBrains.ReSharper.Psi.impl.EditorConfig.WriteConverterDelegate : MulticastDelegate {
    public WriteConverterDelegate(object object, IntPtr method);
    public virtual void Invoke(string propertyName, string value, IContextBoundSettingsStore store, IDictionary`2<string, string> properties);
    public virtual IAsyncResult BeginInvoke(string propertyName, string value, IContextBoundSettingsStore store, IDictionary`2<string, string> properties, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class JetBrains.ReSharper.Psi.Impl.EnumPredefinedOperator : PredefinedOperator {
    [CompilerGeneratedAttribute]
private IEnum <Enum>k__BackingField;
    [NotNullAttribute]
public IEnum Enum { get; }
    public EnumPredefinedOperator(PsiLanguageType language, IEnum enum, string name, IType returnType, IType[] parameterTypes);
    public EnumPredefinedOperator(PsiLanguageType language, IEnum enum, string name, IType type, int parameterNumber);
    [CompilerGeneratedAttribute]
public IEnum get_Enum();
}
public class JetBrains.ReSharper.Psi.Impl.FileAssemblyPsiModule : UserDataHolder {
    private ISolution mySolution;
    private FileAssembly myAssembly;
    private IPsiServices myPsiServices;
    public string Name { get; }
    public string DisplayName { get; }
    public TargetFrameworkId TargetFrameworkId { get; }
    public PsiLanguageType PsiLanguage { get; }
    public ProjectFileType ProjectFileType { get; }
    public IModule ContainingProjectModule { get; }
    public IEnumerable`1<IPsiSourceFile> SourceFiles { get; }
    public IPsiAssembly Assembly { get; }
    protected FileAssemblyPsiModule(ISolution solution, VirtualFileSystemPath location, TargetFrameworkId targetFrameworkId);
    public virtual string get_Name();
    public virtual string get_DisplayName();
    public sealed virtual TargetFrameworkId get_TargetFrameworkId();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual ISolution GetSolution();
    public sealed virtual PsiLanguageType get_PsiLanguage();
    public sealed virtual ProjectFileType get_ProjectFileType();
    public virtual IEnumerable`1<IPsiModuleReference> GetReferences(IModuleReferenceResolveContext moduleReferenceResolveContext);
    public sealed virtual IModule get_ContainingProjectModule();
    public sealed virtual IEnumerable`1<IPsiSourceFile> get_SourceFiles();
    public sealed virtual ICollection`1<PreProcessingDirective> GetAllDefines();
    public sealed virtual bool IsValid();
    public sealed virtual string GetPersistentID();
    public sealed virtual IPsiAssembly get_Assembly();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Impl.FormatterTestLogger : object {
    public static string MakeLog;
    public static string DumpRulesForInterval;
    public static string LineNumberToLogWrappingStr;
    private TextWriter myStreamWriter;
    [CompilerGeneratedAttribute]
private string <LeftNodeToLog>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RightNodeToLog>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumberToLogWrapping>k__BackingField;
    public string LeftNodeToLog { get; public set; }
    public string RightNodeToLog { get; public set; }
    public int LineNumberToLogWrapping { get; public set; }
    public FormatterTestLogger(FileSystemPath logFile);
    public sealed virtual void OpenIndentingRegion(string regionName, VirtNode node, int indentLength, IndentType indentType);
    public sealed virtual void CloseIndentingRegion(string regionName, VirtNode node, IndentType indentType);
    public sealed virtual void OpenWrappingRegion(string regionName, VirtNode node, string additionalInfo);
    public sealed virtual void CloseWrappingRegion(string regionName, VirtNode node);
    public sealed virtual void BeforeNode(VirtNode node);
    public sealed virtual void AfterNode(VirtNode node);
    public sealed virtual void Started(int task);
    public sealed virtual void Ended(int task);
    public sealed virtual void Log(string message);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LeftNodeToLog();
    [CompilerGeneratedAttribute]
public void set_LeftNodeToLog(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RightNodeToLog();
    [CompilerGeneratedAttribute]
public void set_RightNodeToLog(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_LineNumberToLogWrapping();
    [CompilerGeneratedAttribute]
public void set_LineNumberToLogWrapping(int value);
    public sealed virtual void Dispose();
}
public static class JetBrains.ReSharper.Psi.Impl.HiddenMemberImpl : object {
    [NotNullAttribute]
public static IList`1<TypeMemberInstance> GetHiddenMembers(ITypeMember typeMember);
    [NotNullAttribute]
public static IList`1<TypeMemberInstance> GetHiddenMembers(TypeMemberInstance memberInstance);
}
public interface JetBrains.ReSharper.Psi.Impl.INodeUserDataHolderOwner {
    [NotNullAttribute]
public NodeUserDataHolder NodeUserDataHolder { get; }
    public bool HoldOwnUserData { get; }
    public abstract virtual NodeUserDataHolder get_NodeUserDataHolder();
    public abstract virtual bool get_HoldOwnUserData();
}
public interface JetBrains.ReSharper.Psi.Impl.IResolveIsolationScope {
    public Nullable`1<int> ModificationStamp { get; public set; }
    public abstract virtual Nullable`1<int> get_ModificationStamp();
    public abstract virtual void set_ModificationStamp(Nullable`1<int> value);
}
public interface JetBrains.ReSharper.Psi.Impl.ITypeElementWithSpeculativeFields {
    [PureAttribute]
public abstract virtual IEnumerable`1<ITypeOwner> GetOrComputeSpeculativeInstanceFields();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class JetBrains.ReSharper.Psi.Impl.Multitype : object {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private IPsiModule myModule;
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private HashSet`1<IType> myTypes;
    public IEnumerable`1<IType> Constituents { get; }
    public TypeClassification Classify { get; }
    public bool IsOpenType { get; }
    public IPsiModule Module { get; }
    public TypeDecorationSet TypeDecorations { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public bool IsUnknown { get; }
    public bool IsResolved { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public Multitype(IPsiModule module, IEnumerable`1<IType> types);
    public sealed virtual IEnumerable`1<IType> get_Constituents();
    public sealed virtual bool IsWellFormed(ITypeConstraintsVerifier typeConstraintsVerifier);
    public sealed virtual ITypePointer CreatePointer();
    public sealed virtual bool Equals(IType type, IEqualityComparer`1<IType> childrenComparer);
    public sealed virtual TypeClassification get_Classify();
    public sealed virtual bool get_IsOpenType();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual TypeDecorationSet get_TypeDecorations();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    public sealed virtual IType WithNullableAnnotation(NullableAnnotation annotation);
    public sealed virtual IType WithTypeDecorations(TypeDecorationSet typeDecorations);
    public sealed virtual IType MergeNullability(IType otherType, TypeParameterVariance variance);
    public sealed virtual bool IsValid();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual bool get_IsResolved();
    public sealed virtual IDeclaredType GetScalarType();
    [NotNullAttribute]
[DebuggerStepThroughAttribute]
public sealed virtual IType ToIType();
    public virtual string ToString();
    private string get_DebuggerDisplay();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual void Accept(TypeVisitor typeVisitor);
    public sealed virtual TResult Accept(TypeVisitor`2<TContext, TResult> typeVisitor, TContext context);
    public sealed virtual ISymbolTable GetSymbolTable(IPsiModule module);
    public sealed virtual bool IsImplicitlyConvertibleTo(IType type, ITypeConversionRule conversionRule);
    public sealed virtual bool IsExplicitlyConvertibleTo(IType type, ITypeConversionRule conversionRule);
}
public class JetBrains.ReSharper.Psi.Impl.NamedTupleComponent : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private DecoratedType`1<TupleTypeDecoration> <ContainingType>k__BackingField;
    [CompilerGeneratedAttribute]
private IField <UnderlyingField>k__BackingField;
    public int Index { get; }
    public DecoratedType`1<TupleTypeDecoration> ContainingType { get; }
    public IField UnderlyingField { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IType Type { get; }
    private IType JetBrains.ReSharper.Psi.ITypeOwner.Type { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public string XMLDocId { get; }
    private ITypeElement JetBrains.ReSharper.Psi.ITypeMember.ContainingType { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public MemberHidePolicy HidePolicy { get; }
    public ConstantValue ConstantValue { get; }
    public bool IsField { get; }
    public bool IsConstant { get; }
    public bool IsEnumMember { get; }
    public bool IsRequired { get; }
    public ReferenceKind ReferenceKind { get; }
    public Nullable`1<int> FixedBufferSize { get; }
    public NamedTupleComponent(DecoratedType`1<TupleTypeDecoration> containingType, int index, IField underlyingField);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Index();
    [CompilerGeneratedAttribute]
public sealed virtual DecoratedType`1<TupleTypeDecoration> get_ContainingType();
    [CompilerGeneratedAttribute]
public sealed virtual IField get_UnderlyingField();
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual IType get_Type();
    private sealed virtual override IType JetBrains.ReSharper.Psi.ITypeOwner.get_Type();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual string get_XMLDocId();
    private sealed virtual override ITypeElement JetBrains.ReSharper.Psi.ITypeMember.get_ContainingType();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual Nullable`1<Hash> CalcHash();
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual bool get_IsField();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsEnumMember();
    public sealed virtual bool get_IsRequired();
    public sealed virtual ReferenceKind get_ReferenceKind();
    public sealed virtual Nullable`1<int> get_FixedBufferSize();
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    private bool Equals(NamedTupleComponent other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual AccessRights GetAccessRights();
    public virtual string ToString();
    public sealed virtual IDeclaredElementPointer`1<INamedTupleComponent> CreateElementPointer();
}
public class JetBrains.ReSharper.Psi.Impl.NodeUserDataHolder : object {
    [CanBeNullAttribute]
private ConcurrentDictionary`2<ITreeNode, UserDataHolder> myNodeData;
    [CanBeNullAttribute]
private ConcurrentDictionary`2<ITreeNode, UserDataHolder> myPersistentData;
    [NotNullAttribute]
protected ConcurrentDictionary`2<ITreeNode, UserDataHolder> NodeData { get; }
    [NotNullAttribute]
protected ConcurrentDictionary`2<ITreeNode, UserDataHolder> PersistentData { get; }
    public bool ContainsPersistentData { get; }
    protected ConcurrentDictionary`2<ITreeNode, UserDataHolder> get_NodeData();
    protected ConcurrentDictionary`2<ITreeNode, UserDataHolder> get_PersistentData();
    [PureAttribute]
public NodeUserData GetNodeUserData(ITreeNode node);
    [PureAttribute]
public NodeUserData GetNodePersistentUserData(ITreeNode node);
    public bool get_ContainsPersistentData();
    [CanBeNullAttribute]
[PureAttribute]
public UserDataHolder CopyPersistentData(ITreeNode node);
    public void ApplyPersistentDataCopy(Dictionary`2<ITreeNode, UserDataHolder> data);
}
public abstract class JetBrains.ReSharper.Psi.Impl.OverridableLanguageLevelProjectProperty`2 : object {
    [NotNullAttribute]
private ProjectSettingsStorageComponent myProjectSettings;
    [NotNullAttribute]
private ConcurrentDictionary`2<IProject, LanguageLevelsPerTargetFramework<TLanguageLevel, TLanguageVersion>> myProjectToLanguageLevel;
    private int myLanguageLevelOverridesCount;
    private int myLatestSupportedLevelOverridesCount;
    private TLanguageLevel myOverriddenLanguageLevel;
    private TLanguageLevel myOverridenLatestSupportedLanguageLevel;
    private static TLanguageLevel ourLanguageLevelMaxValue;
    private AsyncItemsProcessor`1<ValueTuple`2<Nullable`1<TLanguageLevel>, SettingsPerProject>> mySetLanguageLevelItemsProcessor;
    [NotNullAttribute]
public IComparer`1<TLanguageLevel> LanguageLevelComparer { get; }
    public string LanguageName { get; }
    protected OverridableLanguageLevelProjectProperty`2(Lifetime lifetime, IShellLocks locks, ProjectPropertiesListener projectPropertiesListener, ProjectSettingsStorageComponent projectSettings, PersistentProjectItemProperties persistentProjectItemProperties, SettingsEntry languageLevelSettingsEntry);
    private static OverridableLanguageLevelProjectProperty`2();
    private void ScheduleSetLanguageLevel(Nullable`1<TLanguageLevel> languageLevel, SettingsPerProject settings);
    public sealed virtual TLanguageLevel GetLanguageLevel(IProject project, TargetFrameworkId targetFrameworkId);
    [NotNullAttribute]
[PureAttribute]
private LanguageLevelsPerTargetFramework<TLanguageLevel, TLanguageVersion> GetDefaultLanguageLevelsPerTargetFramework(IProject project);
    private void SetLanguageLevelImpl(Nullable`1<TLanguageLevel> languageLevel, SettingsPerProject settings);
    protected virtual void HandleLanguageLevelChange(IProject project, LanguageLevelsPerTargetFramework<TLanguageLevel, TLanguageVersion> oldValues, LanguageLevelsPerTargetFramework<TLanguageLevel, TLanguageVersion> newValues);
    public abstract virtual TLanguageLevel GetDefaultLanguageLevel(IProject project, TargetFrameworkId targetFrameworkId);
    public abstract virtual TLanguageVersion GetLanguageVersion(IProject project, TargetFrameworkId targetFrameworkId);
    public abstract virtual IComparer`1<TLanguageLevel> get_LanguageLevelComparer();
    public abstract virtual bool IsAvailable(TLanguageLevel languageLevel, IProject project, TargetFrameworkId targetFrameworkId);
    public abstract virtual bool IsAvailable(TLanguageVersion languageVersion, IProject project, TargetFrameworkId targetFrameworkId);
    public virtual TLanguageLevel GetLatestAvailableLanguageLevel(IProject project, TargetFrameworkId targetFrameworkId);
    protected abstract virtual TLanguageLevel GetLatestAvailableLanguageLevelImpl(IProject project, TargetFrameworkId targetFrameworkId);
    public abstract virtual TLanguageLevel GetLatestAvailableLanguageLevel(VirtualFileSystemPath compilerDirectoryPath);
    public abstract virtual TLanguageLevel ConvertToLanguageLevel(TLanguageVersion languageVersion, IProject project, TargetFrameworkId targetFrameworkId);
    public abstract virtual TLanguageVersion ConvertToLanguageVersion(TLanguageLevel languageLevel);
    public abstract virtual Nullable`1<TLanguageVersion> TryParseCompilationOption(string languageVersion);
    public abstract virtual string ConvertToCompilationOption(TLanguageVersion languageVersion);
    public virtual void OverrideLanguageLevel(TLanguageLevel languageLevel, IProject project);
    public sealed virtual void ResetOverriddenLanguageLevel(IProject project);
    [MustUseReturnValueAttribute]
protected abstract virtual Nullable`1<TLanguageLevel> GetOverriddenLanguageLevelFromSettings(IContextBoundSettingsStore settingsStore);
    protected abstract virtual void SetOverridenLanguageLevelInSettings(IContextBoundSettingsStore settingsStore, Nullable`1<TLanguageLevel> languageLevel);
    [PureAttribute]
protected abstract virtual bool IsApplicableToProject(IProject project);
    public void OverrideLanguageLevel(Lifetime lifetime, TLanguageLevel languageLevel, IProject project);
    public void OverrideLatestSupportedLanguageLevel(Lifetime lifetime, TLanguageLevel languageLevel, IProject project);
    public abstract virtual string get_LanguageName();
    public abstract virtual string GetPresentation(TLanguageVersion languageVersion, LanguageVersionPresentationOptions options, IProject project, TargetFrameworkId targetFrameworkId);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_0(ValueTuple`2<Nullable`1<TLanguageLevel>, SettingsPerProject> pair);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_1(IProject project);
    [CompilerGeneratedAttribute]
private void <.ctor>g__OnProjectSettingsChanged|8_2(SettingsPerProject settings);
    [CompilerGeneratedAttribute]
private void <ResetOverriddenLanguageLevel>b__28_0(SettingsPerProject settings);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.OverridableMemberImpl : object {
    public static bool CompareNames(IDeclaredElement element1, IDeclaredElement element2);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.OverridableMemberImpl/<FindOverridableInTypeByExample>d__2")]
[NotNullAttribute]
public static IEnumerable`1<OverridableMemberInstance> FindOverridableInTypeByExample(ITypeElement typeElement, ISubstitution typeSubstitution, OverridableMemberInstance origin, bool checkReturnType);
    public static bool CanImplement(OverridableMemberInstance derived, OverridableMemberInstance super);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanOverrideReturnType(IType derivedType, IType baseType, IPsiModule psiModule);
    [NotNullAttribute]
private static ISubstitution ApplyOriginMemberSubstitution(OverridableMemberInstance origin, IOverridableMember overridableMember, ISubstitution overridableSubstitution);
    [NotNullAttribute]
private static IEnumerable`1<OverridableMemberInstance> FindMembersInSuperInterfaces(OverridableMemberInstance member, IDeclaredType type, HashSet`1<IDeclaredType> visited, HashSet`1<IDeclaredType> ignored);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.OverridableMemberImpl/<FindMembersInSuperInterfaces>d__7")]
[NotNullAttribute]
private static IEnumerable`1<OverridableMemberInstance> FindMembersInSuperInterfaces(JetHashSet`1<IDeclaredType> superInterfaces, OverridableMemberInstance member, HashSet`1<IDeclaredType> ignored);
    public static bool IsAppropriateInstance(OverridableMemberInstance inheritor, OverridableMemberInstance super);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.OverridableMemberImpl/<FindQuasiSupers>d__9")]
[NotNullAttribute]
public static IEnumerable`1<OverridableMemberInstance> FindQuasiSupers(OverridableMemberInstance member, ITypeElement typeElement, HashSet`1<IDeclaredType> visited, IProgressIndicator progressIndicator);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.OverridableMemberImpl/<FindOverriddenInSuperClasses>d__10")]
[NotNullAttribute]
private static IEnumerable`1<OverridableMemberInstance> FindOverriddenInSuperClasses(OverridableMemberInstance member, IDeclaredType type, HashSet`1<IDeclaredType> visitedDeclaredTypes, HashSet`1<ITypeElement> visitedTypeElements);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.OverridableMemberImpl/<GetImmediateSuperMembers>d__11")]
[NotNullAttribute]
public static IEnumerable`1<OverridableMemberInstance> GetImmediateSuperMembers(OverridableMemberInstance member, bool searchQuasi, IProgressIndicator progressIndicator);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.OverridableMemberImpl/<GetImmediateImplement>d__12")]
[NotNullAttribute]
public static IEnumerable`1<OverridableMemberInstance> GetImmediateImplement(OverridableMemberInstance member, bool searchQuasi, ITypeElement containingTypeForImplicitImplementationsSearch, IProgressIndicator progressIndicator);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.OverridableMemberImpl/<FindExplicitImplementationsInSuperInterfaces>d__13")]
private static IEnumerable`1<OverridableMemberInstance> FindExplicitImplementationsInSuperInterfaces(OverridableMemberInstance origin, IDeclaredType declaredType, FrugalLocalHashSet`1<OverridableMemberInstance> topMembers);
    [NotNullAttribute]
public static IList`1<OverridableMemberInstance> GetRootSuperMembers(IOverridableMember member, bool searchQuasi, IProgressIndicator progressIndicator);
    [NotNullAttribute]
public static IList`1<OverridableMemberInstance> GetAllSuperMembers(IOverridableMember member, bool searchQuasi, IProgressIndicator progressIndicator);
    [NotNullAttribute]
public static IList`1<OverridableMemberInstance> GetRootSuperMembers(OverridableMemberInstance member, bool searchQuasi, IProgressIndicator progressIndicator);
    [NotNullAttribute]
public static IList`1<OverridableMemberInstance> GetAllSuperMembers(OverridableMemberInstance member, bool searchQuasi, IProgressIndicator progressIndicator);
    [NotNullAttribute]
private static IList`1<OverridableMemberInstance> GetSuperMembers(OverridableMemberInstance member, bool searchQuasi, IProgressIndicator progressIndicator, bool consumeRootOnly);
    [NotNullAttribute]
public static IEnumerable`1<OverridableMemberInstance> GetImmediateOverride(OverridableMemberInstance member);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.OverridableMemberImpl/<GetImmediateOverride>d__20")]
private static IEnumerable`1<OverridableMemberInstance> GetImmediateOverride(OverridableMemberInstance member, ITypeElement typeElement);
    [NotNullAttribute]
public static ICollection`1<OverridableMemberInstance> GetRootOverride(OverridableMemberInstance derived);
    public static bool OverridesOrImplements(OverridableMemberInstance derived, OverridableMemberInstance super);
    public static bool OverridesOrImplements(IOverridableMember derived, IOverridableMember super);
}
public class JetBrains.ReSharper.Psi.Impl.PathDeclaredElement : object {
    public static string ROOT_NAME;
    public static string LEVEL_UP_NAME;
    public static string CURRENT_DIR_NAME;
    [NotNullAttribute]
public static VirtualFileSystemPath WebRootPath;
    [CanBeNullAttribute]
private string myShortName;
    [NotNullAttribute]
private IPsiServices myPsiServices;
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <PhysicalPath>k__BackingField;
    [NotNullAttribute]
public VirtualFileSystemPath Path { get; }
    [NotNullAttribute]
public VirtualFileSystemPath PhysicalPath { get; }
    public bool IsDirectory { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public PathDeclaredElement(IPsiServices psiServices, IPsiSourceFileWithLocation sourceFile);
    public PathDeclaredElement(IPsiServices psiServices, IProjectItem projectItem);
    public PathDeclaredElement(IPsiServices psiServices, VirtualFileSystemPath path);
    public PathDeclaredElement(string shortName, IPsiServices psiServices, VirtualFileSystemPath path);
    public PathDeclaredElement(string shortName, IPsiServices psiServices, VirtualFileSystemPath logicalPath, VirtualFileSystemPath physicalPath);
    private static PathDeclaredElement();
    [CompilerGeneratedAttribute]
public sealed virtual VirtualFileSystemPath get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual VirtualFileSystemPath get_PhysicalPath();
    public virtual IProjectItem GetProjectItem();
    public virtual HybridCollection`1<IProjectItem> GetProjectItems();
    public virtual bool get_IsDirectory();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public virtual DeclaredElementType GetElementType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public virtual PsiLanguageType get_PresentationLanguage();
    public virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual bool Equals(PathDeclaredElement other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DeclaredElementIconProviderAttribute("0", "16")]
internal class JetBrains.ReSharper.Psi.Impl.PathDeclaredElementImageProvider : object {
    [NotNullAttribute]
private ProjectModelElementPresentationService myService;
    [NotNullAttribute]
private ProjectModelIcons myIcons;
    private PsiProjectFileTypeCoordinator myTypeCoordinator;
    private IProjectFileExtensions myMapping;
    public PathDeclaredElementImageProvider(ProjectModelElementPresentationService service, ProjectModelIcons icons, PsiProjectFileTypeCoordinator typeCoordinator, IProjectFileExtensions projectFileExtensions);
    public sealed virtual IconId GetImageId(IDeclaredElement declaredElement, PsiLanguageType languageType, Boolean& canApplyExtensions);
}
public class JetBrains.ReSharper.Psi.Impl.PathDeclaredElementPresenter : object {
    [NotNullAttribute]
public static IDeclaredElementPresenter Instance;
    private static PathDeclaredElementPresenter();
    public virtual RichText Format(DeclaredElementPresenterStyle style, IDeclaredElement element, ISubstitution substitution, DeclaredElementPresenterMarking& marking);
    protected virtual void FormatEntityKind(IDeclaredElement declaredElement, DeclaredElementPresenterStyle style, DeclaredElementPresenterMarking marking, StringBuilder builder);
    protected static TextRange AppendString(StringBuilder builder, string text);
    public virtual string Format(ParameterKind parameterKind);
    public virtual string Format(AccessRights accessRights);
    public virtual string GetEntityKind(IDeclaredElement declaredElement);
}
public class JetBrains.ReSharper.Psi.Impl.PathDeclaredElementType : DeclaredElementType {
    public static DeclaredElementType Instance;
    public string PresentableName { get; }
    protected internal IDeclaredElementPresenter DefaultPresenter { get; }
    private static PathDeclaredElementType();
    public virtual string get_PresentableName();
    public virtual IconId GetImage();
    protected internal virtual IDeclaredElementPresenter get_DefaultPresenter();
    public virtual bool IsPresentable(PsiLanguageType language);
}
public class JetBrains.ReSharper.Psi.Impl.Paths.ModuleDeclaredElement : object {
    [NotNullAttribute]
private IModule myModule;
    [NotNullAttribute]
private string myName;
    [CompilerGeneratedAttribute]
private TargetFrameworkId <TargetFrameworkId>k__BackingField;
    [NotNullAttribute]
public TargetFrameworkId TargetFrameworkId { get; }
    public IModule ProjectModule { get; }
    public IPsiModule Module { get; }
    public VirtualFileSystemPath Location { get; }
    public AssemblyNameInfo AssemblyName { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public ModuleDeclaredElement(IModule module, TargetFrameworkId targetFrameworkId);
    public ModuleDeclaredElement(IModule module, string name, TargetFrameworkId targetFrameworkId);
    [CompilerGeneratedAttribute]
public sealed virtual TargetFrameworkId get_TargetFrameworkId();
    public sealed virtual IModule get_ProjectModule();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual VirtualFileSystemPath get_Location();
    public sealed virtual AssemblyNameInfo get_AssemblyName();
    public IProjectItem GetProjectItem();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Impl.Paths.PathMappingManagerImpl : PathMappingManager {
    private ISolution mySolution;
    private Lifetime myLifetime;
    private ISettingsStore mySettingsStore;
    private Dictionary`2<IProject, ProjectPathMapping> myPathMappings;
    public PathMappingManagerImpl(Lifetime lifetime, ISolution solution, ISettingsStore settingsStore, IViewableProjectsCollection projects);
    private void RemoveProject(IProject project);
    private void Clear();
    protected virtual void RunPathMappingEditorImpl(IProject project, VirtualFileSystemPath preselectedPath);
    protected virtual IProjectPathMapping GetPathMappingImpl(IProject project);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(Lifetime projectLifetime, IProject project);
}
internal class JetBrains.ReSharper.Psi.Impl.Paths.ProjectPathMapping : object {
    private IProject myProject;
    private IContextBoundSettingsStore myContextBoundSettingsStore;
    public LifetimeDefinition Definition;
    public IProject Project { get; }
    public ProjectPathMapping(Lifetime lifetime, IProject project, ISettingsStore settingsStore);
    private VirtualFileSystemPath ToKeyPath(VirtualFileSystemPath realPath);
    private VirtualFileSystemPath ToRealPath(VirtualFileSystemPath keyPath);
    [NotNullAttribute]
private VirtualFileSystemPath ToAbsolutePath(VirtualFileSystemPath path);
    [NotNullAttribute]
private VirtualFileSystemPath ToRelativePath(VirtualFileSystemPath path);
    public sealed virtual IProject get_Project();
    public virtual PathState GetPathState(VirtualFileSystemPath webPath);
    public virtual IList`1<VirtualFileSystemPath> GetRealPaths(VirtualFileSystemPath webPath);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.Paths.ProjectPathMapping/<GetRelativeIgnoredPaths>d__12")]
private IEnumerable`1<VirtualFileSystemPath> GetRelativeIgnoredPaths();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.Paths.ProjectPathMapping/<GetRelativeMappedPaths>d__13")]
private IEnumerable`1<VirtualFileSystemPath> GetRelativeMappedPaths();
    public sealed virtual IList`1<VirtualFileSystemPath> GetAllRelativePaths();
    public sealed virtual IList`1<VirtualFileSystemPath> GetAllPathPartsIn(VirtualFileSystemPath parentPath);
    public sealed virtual void RemoveAllPaths();
    public sealed virtual void IgnorePath(VirtualFileSystemPath path);
    public sealed virtual void SetPathMapping(VirtualFileSystemPath webPath, VirtualFileSystemPath realPath);
    private sealed virtual override void System.IDisposable.Dispose();
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Impl.Paths.VirtualPathsServiceImpl : object {
    private Lifetime myLifetime;
    private JetHashSet`1<IVirtualFilesProvider> myFileProviders;
    private JetHashSet`1<IVirtualFoldersProvider> myFolderProviders;
    public VirtualPathsServiceImpl(Lifetime lifetime);
    public sealed virtual void RegisterFilesProvider(Lifetime lifetime, IVirtualFilesProvider filesProvider);
    public sealed virtual void RegisterFoldersProvider(Lifetime lifetime, IVirtualFoldersProvider foldersProvider);
    public sealed virtual IEnumerable`1<VirtualFileSystemPath> GetAbsolutePathsToVirtualFolders(IProject project);
    public sealed virtual IProjectFolder GetProjectFolderByVirtualPath(IProject project, VirtualFileSystemPath virtualPath);
    public sealed virtual IEnumerable`1<VirtualFileSystemPath> GetAbsolutePathsToVirtualFiles(IProject project);
    public sealed virtual IProjectFile GetProjectFileByVirtualPath(IProject project, VirtualFileSystemPath virtualPath);
    public sealed virtual IPsiSourceFile GetPsiSourceFileByVirtualPath(IProject project, VirtualFileSystemPath virtualPath);
    public sealed virtual IEnumerable`1<VirtualFileSystemPath> GetPathPartsIn(IProject project, VirtualFileSystemPath virtualPrefixPath);
    private IEnumerable`1<VirtualFileSystemPath> GetAllPaths(IProject project);
    private static VirtualFileSystemPath GetFirstPathPartAfterPrefix(VirtualFileSystemPath path, VirtualFileSystemPath prefixPath);
    public sealed virtual bool IsVirtualPathOrPrefix(IProject project, VirtualFileSystemPath virtualPath);
}
public class JetBrains.ReSharper.Psi.Impl.PredefinedOperator : object {
    private PsiLanguageType myLanguage;
    private string myName;
    private IType myReturnType;
    private IParameter[] myParameters;
    private int myHashCode;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PriorityIfLifted>k__BackingField;
    public int Priority { get; public set; }
    public int PriorityIfLifted { get; public set; }
    public ISubstitution IdSubstitution { get; }
    public ITypeElement ContainingType { get; }
    public MemberHidePolicy HidePolicy { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public string XMLDocId { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public bool IsPredefined { get; }
    public bool IsIterator { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public bool IsExplicitImplementation { get; }
    public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    public bool CanBeImplicitImplementation { get; }
    public bool IsChecked { get; }
    public PredefinedOperator(PsiLanguageType language, string name, IType returnType, IType[] parameterTypes);
    public PredefinedOperator(PsiLanguageType language, string name, IType type, int parameterNumber);
    [CompilerGeneratedAttribute]
public int get_Priority();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Priority(int value);
    [CompilerGeneratedAttribute]
public int get_PriorityIfLifted();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PriorityIfLifted(int value);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual ITypeElement get_ContainingType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual Nullable`1<Hash> CalcHash();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual string get_XMLDocId();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual bool get_IsPredefined();
    public sealed virtual bool get_IsIterator();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public virtual string ToString();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool get_IsExplicitImplementation();
    public sealed virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    public sealed virtual bool get_CanBeImplicitImplementation();
    public sealed virtual bool get_IsChecked();
    public virtual bool Equals(object obj);
    private int CalculateHashCode();
    public virtual int GetHashCode();
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Impl.ProjectFilePrimaryPsiLanguageTypeCache : object {
    private PsiProjectFileTypeCoordinator myProjectFileTypeCoordinator;
    private IPsiModules myPsiModules;
    private ILogger myLogger;
    private ConcurrentDictionary`2<IPsiSourceFile, PsiLanguageType> myPrimaryLanguageTypeCache;
    public ProjectFilePrimaryPsiLanguageTypeCache(Lifetime lifetime, ISolution solution, PsiProjectFileTypeCoordinator projectFileTypeCoordinator, ChangeManager changeManager, IPsiModules psiModules, ILogger logger);
    public PsiLanguageType GetPrimaryLanguage(IPsiSourceFile sourceFile);
    public sealed virtual object Execute(IChangeMap changeMap);
}
public class JetBrains.ReSharper.Psi.Impl.PsiBuilderLexer : FilteringLexerBase {
    private Queue`1<Entry> mySkippedTokensQueue;
    private Predicate`1<TokenNodeType> mySkipFilter;
    public int SkippedTokenCount { get; }
    public bool HasSkippedTokens { get; }
    public PsiBuilderLexer(ILexer lexer, Predicate`1<TokenNodeType> skip);
    public int get_SkippedTokenCount();
    public bool get_HasSkippedTokens();
    protected virtual bool Skip(TokenNodeType tokenType);
    protected virtual void SkipFilteredTokens();
    protected virtual LeafElementBase CreateSkippedElement(TokenNodeType tokenType);
    public void DropSkippedTokens(TokenNodeType tokenType);
    private void AppendSkippedTokensInternal(CompositeElement parent, TokenNodeType expectedTokenType);
    public void AppendSkippedTokens(CompositeElement parent);
    public void AppendNewChild(CompositeElement parent, TreeElement child);
    public void AppendChildren(CompositeElement parent, CompositeElement oldParent);
    private TreeElement MoveSkippedChildrenUp(CompositeElement parent, CompositeElement oldParent);
    [CanBeNullAttribute]
private static CompositeElement FindCompositeElementToAppend(CompositeElement parent, TreeElement& before);
    private static void AppendSkippedChild(CompositeElement parent, TreeElement element);
    private static void AppendSkippedChildren(CompositeElement parent, ICollection`1<LeafElementBase> skipped);
}
[SolutionInstanceComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Impl.PsiConfigurationImpl : object {
    [CompilerGeneratedAttribute]
private DocumentLineEndingsDetector <LineEndingsDetector>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    [CompilerGeneratedAttribute]
private ShellCaches <ShellCaches>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolutionCaches <SolutionCaches>k__BackingField;
    public bool EagerMetadataLoad { get; }
    public bool FullMetadataLoad { get; }
    public bool CacheJobServiceSynchronous { get; }
    public DocumentLineEndingsDetector LineEndingsDetector { get; }
    public ISolution Solution { get; }
    public ShellCaches ShellCaches { get; }
    public ISolutionCaches SolutionCaches { get; }
    public bool PersistCaches { get; }
    public PsiConfigurationImpl(ISolution solution, ISolutionCaches solutionCaches, ShellCaches shellCaches, DocumentLineEndingsDetector documentLineEndingsDetector);
    public virtual bool get_EagerMetadataLoad();
    public virtual bool get_FullMetadataLoad();
    public virtual bool get_CacheJobServiceSynchronous();
    [CompilerGeneratedAttribute]
public sealed virtual DocumentLineEndingsDetector get_LineEndingsDetector();
    [CompilerGeneratedAttribute]
public sealed virtual ISolution get_Solution();
    [CompilerGeneratedAttribute]
public sealed virtual ShellCaches get_ShellCaches();
    [CompilerGeneratedAttribute]
public sealed virtual ISolutionCaches get_SolutionCaches();
    public virtual bool get_PersistCaches();
}
[PsiSharedComponentAttribute("16")]
internal class JetBrains.ReSharper.Psi.Impl.PsiIconManagerImpl : PsiIconManager {
    private static IconId myPublicNodeImage;
    private static IconId myPrivateNodeImage;
    private static IconId myProtectedNodeImage;
    private static IconId myProtectedInternalNodeImage;
    private static IconId myInternalNodeImage;
    private static IconId myStaticNodeImage;
    private static IconId myAbstractNodeImage;
    private static IconId myVirtualNodeImage;
    private static IconId myReadAccessNodeImage;
    private static IconId myWriteAccessNodeImage;
    private static IconId myReadWriteAccessNodeImage;
    [NotNullAttribute]
private IShellLocks myLocks;
    [NotNullAttribute]
private Lazy`1<ICollection`1<IDeclaredElementIconProvider>> myLazyIconProviders;
    [NotNullAttribute]
private ICollection`1<IDeclaredElementIconExtensionProvider> myIconExtensionProviders;
    [NotNullAttribute]
private Dictionary`2<Pair`2<object, PsiIconExtension>, IconId> myCache;
    [NotNullAttribute]
private Dictionary`2<IconId, IconId> myExtendToTypicalSizeCache;
    private static IconId myDummyImage;
    public IconId TransparentIconOfTypicalPsiIconSize { get; }
    public IconId KeywordIcon { get; }
    public PsiIconManagerImpl(Lifetime lifetime, IEnumerable`1<IDeclaredElementIconExtensionProvider> extensionsExtensions, IShellLocks locks, ISettingsStore settingsStore);
    private static PsiIconManagerImpl();
    private static int Compare(T x, T y);
    private void LazyExtensionsInit(Lifetime lifetime);
    public virtual IconId get_TransparentIconOfTypicalPsiIconSize();
    public virtual IconId GetDummyImage();
    public virtual IconId GetImage(IDeclaredElement element, PsiLanguageType languageType, bool drawExtensions);
    public virtual IconId GetImage(DeclaredElementType elementType);
    public virtual IconId GetImage(DeclaredElementType elementType, PsiIconExtension psiIconExtension);
    public virtual IconId ExtendToTypicalSize(IconId image);
    [NotNullAttribute]
internal static IconId ExtendToTypicalSizeCore(IconId image);
    public virtual IconId AttachExtensions(IconId image, PsiIconExtension extension);
    [NotNullAttribute]
private static IconId Combine(IconId lower, IconId upper);
    public sealed virtual void AddExtension(Lifetime lifetime, IDeclaredElementIconProvider extension);
    public sealed virtual void AddExtension(Lifetime lifetime, IDeclaredElementIconExtensionProvider extension);
    public virtual IconId get_KeywordIcon();
    [CompilerGeneratedAttribute]
private PsiIconExtension <GetImage>g__GetExtensions|23_0(<>c__DisplayClass23_0& );
}
[DebuggerDisplayAttribute("{DisplayName}")]
public class JetBrains.ReSharper.Psi.Impl.PsiProjectFile : UserDataHolder {
    [NotNullAttribute]
private IPsiModule myPsiModule;
    [NotNullAttribute]
private IProjectFile myProjectFile;
    private Func`3<IProjectFile, IPsiSourceFile, IPsiSourceFileProperties> myPropertiesProvider;
    private Func`3<IProjectFile, IPsiSourceFile, bool> myValidityChecks;
    [NotNullAttribute]
private ProjectFilePrimaryPsiLanguageTypeCache myPrimaryPsiLanguageTypeCache;
    [NotNullAttribute]
private DocumentManager myDocumentManager;
    private PsiSourceFileStorage myPsiSourceFileStorage;
    [CompilerGeneratedAttribute]
private IModuleReferenceResolveContext <ResolveContext>k__BackingField;
    public IPsiSourceFileStorage PsiStorage { get; }
    public IPsiModule PsiModule { get; }
    public string Name { get; }
    public string DisplayName { get; }
    public IDocument Document { get; }
    public VirtualFileSystemPath Location { get; }
    public IProjectFile ProjectFile { get; }
    public IPsiSourceFileProperties Properties { get; }
    public PsiLanguageType PrimaryPsiLanguage { get; }
    public ProjectFileType LanguageType { get; }
    public Nullable`1<ModificationStamp> InMemoryModificationStamp { get; }
    public Nullable`1<ModificationStamp> ExternalModificationStamp { get; }
    public DateTime LastWriteTimeUtc { get; }
    public IModuleReferenceResolveContext ResolveContext { get; }
    public PsiProjectFile(IPsiModule psiModule, IProjectFile projectFile, Func`3<IProjectFile, IPsiSourceFile, IPsiSourceFileProperties> propertiesProvider, Func`3<IProjectFile, IPsiSourceFile, bool> validityChecks, DocumentManager documentManager, IModuleReferenceResolveContext resolveContext);
    public sealed virtual IPsiSourceFileStorage get_PsiStorage();
    public sealed virtual IPsiModule get_PsiModule();
    public virtual string get_Name();
    public virtual string get_DisplayName();
    public sealed virtual IDocument get_Document();
    public sealed virtual string GetPersistentID();
    public sealed virtual bool IsValid();
    public sealed virtual VirtualFileSystemPath get_Location();
    public sealed virtual IProjectFile get_ProjectFile();
    public sealed virtual IPsiSourceFileProperties get_Properties();
    public virtual PsiLanguageType get_PrimaryPsiLanguage();
    public virtual ProjectFileType get_LanguageType();
    public sealed virtual Nullable`1<ModificationStamp> get_InMemoryModificationStamp();
    public sealed virtual Nullable`1<ModificationStamp> get_ExternalModificationStamp();
    public sealed virtual DateTime get_LastWriteTimeUtc();
    [CompilerGeneratedAttribute]
public virtual IModuleReferenceResolveContext get_ResolveContext();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PsiComponentAttribute("66")]
public class JetBrains.ReSharper.Psi.Impl.PsiServicesImpl : object {
    private IComponentContainer myContainer;
    [CompilerGeneratedAttribute]
private IPsiConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiPointers <Pointers>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettingsStore <SettingsStore>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    [CompilerGeneratedAttribute]
private IShellLocks <Locks>k__BackingField;
    [CompilerGeneratedAttribute]
private ILanguageManager <LanguageManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiTransactions <Transactions>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiFiles <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiCaches <Caches>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiCachesState <CachesState>k__BackingField;
    [CompilerGeneratedAttribute]
private IPersistentIndexManager <PersistentIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModules <Modules>k__BackingField;
    [CompilerGeneratedAttribute]
private DependencyStore <DependencyStore>k__BackingField;
    [CompilerGeneratedAttribute]
private SearchDomainFactory <SearchDomainFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IFinder <Finder>k__BackingField;
    [CompilerGeneratedAttribute]
private IFinder <ParallelFinder>k__BackingField;
    [CompilerGeneratedAttribute]
private IGeneratedDocumentsManager <GeneratedDocumentsManager>k__BackingField;
    [CompilerGeneratedAttribute]
private NamingManager <Naming>k__BackingField;
    [CompilerGeneratedAttribute]
private IWordIndex <WordIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbolCache <Symbols>k__BackingField;
    [CompilerGeneratedAttribute]
private StubTreeNodeCache <StubTreeNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeElementInheritanceCache <TypeElementInheritanceCache>k__BackingField;
    [CompilerGeneratedAttribute]
private AnnotatedEntitiesCache <AnnotatedMembersCache>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyAnnotatedEntitiesCache <AssemblyAnnotatedMembersCache>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeAnnotationsConfiguration <CodeAnnotationsConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectFileTypeServices <ProjectFileTypeServices>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiModuleResolveContextManager <PsiModuleResolveContextManager>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiCachesRepairService <PsiCachesRepairService>k__BackingField;
    [CompilerGeneratedAttribute]
private InternalsVisibleToCache <InternalsVisibleToCache>k__BackingField;
    [CompilerGeneratedAttribute]
private GeneratedFilesCache <GeneratedFilesCache>k__BackingField;
    [CompilerGeneratedAttribute]
private IAttributesCache <AttributesCache>k__BackingField;
    public IPsiConfiguration Configuration { get; }
    public IPsiPointers Pointers { get; }
    public ISettingsStore SettingsStore { get; }
    public ISolution Solution { get; }
    public IShellLocks Locks { get; }
    public ILanguageManager LanguageManager { get; }
    public IPsiTransactions Transactions { get; }
    public IPsiFiles Files { get; }
    public IPsiCaches Caches { get; }
    public IPsiCachesState CachesState { get; }
    public IPersistentIndexManager PersistentIndex { get; }
    public IPsiModules Modules { get; }
    public DependencyStore DependencyStore { get; }
    public SearchDomainFactory SearchDomainFactory { get; }
    public IFinder Finder { get; }
    public IFinder ParallelFinder { get; }
    public IFinder AsyncFinder { get; }
    public IGeneratedDocumentsManager GeneratedDocumentsManager { get; }
    public NamingManager Naming { get; }
    public IWordIndex WordIndex { get; }
    public ISymbolCache Symbols { get; }
    public StubTreeNodeCache StubTreeNodes { get; }
    public TypeElementInheritanceCache TypeElementInheritanceCache { get; }
    public AnnotatedEntitiesCache AnnotatedMembersCache { get; }
    public AssemblyAnnotatedEntitiesCache AssemblyAnnotatedMembersCache { get; }
    public CodeAnnotationsConfiguration CodeAnnotationsConfiguration { get; }
    public IProjectFileTypeServices ProjectFileTypeServices { get; }
    public PsiModuleResolveContextManager PsiModuleResolveContextManager { get; }
    public PsiCachesRepairService PsiCachesRepairService { get; }
    public InternalsVisibleToCache InternalsVisibleToCache { get; }
    public GeneratedFilesCache GeneratedFilesCache { get; }
    public IAttributesCache AttributesCache { get; }
    public PsiServicesImpl(IShellLocks locks, ILanguageManager languageManager, SearchDomainFactory searchDomainFactory, ISolution solution, ISettingsStore settingsStorage, IGeneratedDocumentsManager generatedDocumentsManager, IPsiCaches caches, IPsiCachesState cachesState, DependencyStore dependencyStore, IPsiModules modules, NamingManager namingManager, IPsiConfiguration psiConfiguration, IPsiTransactions transactions, IPsiFiles psiFiles, ISymbolCache symbols, IWordIndex wordIndex, IPsiPointers pointers, IPersistentIndexManager persistentIndex, StubTreeNodeCache stubTreeNodeCache, IProjectFileTypeServices projectFileTypeServices, TypeElementInheritanceCache typeElementInheritanceCache, AnnotatedEntitiesCache annotatedMembersCache, AssemblyAnnotatedEntitiesCache assemblyAnnotatedMembersCache, CodeAnnotationsConfiguration codeAnnotationsConfiguration, PsiModuleResolveContextManager psiModuleResolveContextManager, PsiCachesRepairService psiCachesRepairService, InternalsVisibleToCache internalsVisibleToCache, GeneratedFilesCache generatedFilesCache, IAttributesCache attributesCache, IImmutableList`1<ISearchFilter> searchFilters, IImmutableList`1<IDomainSpecificSearcherFactory> domainSpecificSearcherFactories, FinderOperationManager finderOperationManager);
    public sealed virtual TComponent GetComponent();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiPointers get_Pointers();
    [CompilerGeneratedAttribute]
public sealed virtual ISettingsStore get_SettingsStore();
    [CompilerGeneratedAttribute]
public sealed virtual ISolution get_Solution();
    [CompilerGeneratedAttribute]
public sealed virtual IShellLocks get_Locks();
    [CompilerGeneratedAttribute]
public sealed virtual ILanguageManager get_LanguageManager();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiTransactions get_Transactions();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiFiles get_Files();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiCaches get_Caches();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiCachesState get_CachesState();
    [CompilerGeneratedAttribute]
public sealed virtual IPersistentIndexManager get_PersistentIndex();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModules get_Modules();
    [CompilerGeneratedAttribute]
public sealed virtual DependencyStore get_DependencyStore();
    [CompilerGeneratedAttribute]
public sealed virtual SearchDomainFactory get_SearchDomainFactory();
    [CompilerGeneratedAttribute]
public sealed virtual IFinder get_Finder();
    [CompilerGeneratedAttribute]
public sealed virtual IFinder get_ParallelFinder();
    public sealed virtual IFinder get_AsyncFinder();
    [CompilerGeneratedAttribute]
public sealed virtual IGeneratedDocumentsManager get_GeneratedDocumentsManager();
    [CompilerGeneratedAttribute]
public sealed virtual NamingManager get_Naming();
    [CompilerGeneratedAttribute]
public sealed virtual IWordIndex get_WordIndex();
    [CompilerGeneratedAttribute]
public sealed virtual ISymbolCache get_Symbols();
    [CompilerGeneratedAttribute]
public sealed virtual StubTreeNodeCache get_StubTreeNodes();
    [CompilerGeneratedAttribute]
public sealed virtual TypeElementInheritanceCache get_TypeElementInheritanceCache();
    [CompilerGeneratedAttribute]
public sealed virtual AnnotatedEntitiesCache get_AnnotatedMembersCache();
    [CompilerGeneratedAttribute]
public sealed virtual AssemblyAnnotatedEntitiesCache get_AssemblyAnnotatedMembersCache();
    [CompilerGeneratedAttribute]
public sealed virtual CodeAnnotationsConfiguration get_CodeAnnotationsConfiguration();
    [CompilerGeneratedAttribute]
public sealed virtual IProjectFileTypeServices get_ProjectFileTypeServices();
    [CompilerGeneratedAttribute]
public sealed virtual PsiModuleResolveContextManager get_PsiModuleResolveContextManager();
    [CompilerGeneratedAttribute]
public PsiCachesRepairService get_PsiCachesRepairService();
    [CompilerGeneratedAttribute]
public InternalsVisibleToCache get_InternalsVisibleToCache();
    [CompilerGeneratedAttribute]
public GeneratedFilesCache get_GeneratedFilesCache();
    [CompilerGeneratedAttribute]
public IAttributesCache get_AttributesCache();
}
public class JetBrains.ReSharper.Psi.Impl.ReferencesSet : object {
    public static ReferencesSet Empty;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IPsiModuleReference> <SortedReferences>k__BackingField;
    public IReadOnlyList`1<IPsiModuleReference> SortedReferences { get; }
    public ReferencesSet(IReadOnlyList`1<IPsiModuleReference> references);
    private static ReferencesSet();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IPsiModuleReference> get_SortedReferences();
    public sealed virtual bool Equals(ReferencesSet other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Impl.Reflection2.AssemblyAttributes : object {
    private AssemblyPsiFile myAssemblyPsiFile;
    public AssemblyAttributes(AssemblyPsiFile assemblyPsiFile);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
}
internal class JetBrains.ReSharper.Psi.Impl.Reflection2.AssemblyDataCacheIntern : object {
    [NotNullAttribute]
private ClrNameInternTrie myInternTrie;
    [NotNullAttribute]
private DataIntern`1<string> myStrings;
    [NotNullAttribute]
private DataIntern`1<ReflectionType> myReflectionTypes;
    [CanBeNullAttribute]
private DataIntern`1<string> myMemberNames;
    [CanBeNullAttribute]
private DataIntern`1<Int32[]> myAttributeHash;
    public sealed virtual ReflectionType AddType(ReflectionType repr);
    public sealed virtual AssemblyNameInfo AddAssemblyName(AssemblyNameInfo name);
    public sealed virtual string AddString(string str);
    public sealed virtual INode AddNamespaceName(string namespaceName);
    public sealed virtual INode AddTypeName(string namespaceName, string typeName, IList`1<int> typeParameterNumberFromReflection, IMetadataTypeInfo typeHint);
    public sealed virtual string AddMemberName(string str);
    public sealed virtual Int32[] AddAttributeHash(Int32[] hash);
    public sealed virtual void OnAssemblyLoadingFinished();
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Impl.reflection2.AssemblyFileLoaderZoned.AssemblyFileFactory : object {
    public int Priority { get; }
    public sealed virtual int get_Priority();
    public sealed virtual bool IsApplicable(IPsiAssembly assembly, IMetadataAssembly metadataAssembly);
    public sealed virtual AssemblyPsiFile CreateFile(Func`3<IAssemblyLocation, IPsiModule, MetadataLoader> metadataLoaderFactory, IPsiConfiguration psiConfiguration, IExternalProviderCache`2<ICompiledEntity, IType> decodedTypeCache, IWeakRefRetainerCache`1<object> compiledMembersBucketCache);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.Impl.reflection2.AssemblyFileLoaderZoned.IPsiAssemblyFileFactory {
    public int Priority { get; }
    public abstract virtual int get_Priority();
    public abstract virtual bool IsApplicable(IPsiAssembly assembly, IMetadataAssembly metadataAssembly);
    public abstract virtual AssemblyPsiFile CreateFile(Func`3<IAssemblyLocation, IPsiModule, MetadataLoader> metadataLoaderFactory, IPsiConfiguration psiConfiguration, IExternalProviderCache`2<ICompiledEntity, IType> decodedTypeCache, IWeakRefRetainerCache`1<object> compiledMembersBucketCache);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Impl.reflection2.AssemblyFileLoaderZoned.PsiAssemblyFileLoader : PsiAssemblyFileLoaderDoNotLoadUnlessRequired {
    private AssemblyToAssemblyReferencesResolveManager myResolveManager;
    private IPsiConfiguration myPsiConfiguration;
    private IPlatformManager myPlatformManager;
    private ISolution mySolution;
    private Lifetime myLifetime;
    private IPsiModules myPsiModules;
    private AssemblyExistsService myAssemblyExistsService;
    private IShellLocks myLocks;
    private XmlIndexThread myXmlIndexThread;
    private AnnotationsIndex myIndex;
    private AssembliesDiagnostics myAssembliesDiagnostics;
    private ExternalAnnotationsManager myExternalAnnotationsManager;
    private List`1<IPsiAssemblyFileFactory> myAssemblyFileProviders;
    private ConcurrentDictionary`2<IPsiAssembly, IPsiAssemblyFile> myCompiledPsi;
    [CompilerGeneratedAttribute]
private IExternalProviderCache`2<ICompiledEntity, IType> <DecodedTypeCache>k__BackingField;
    protected LRUWeakRefRetainerCache`1<object> CompiledBucketCache;
    public IExternalProviderCache`2<ICompiledEntity, IType> DecodedTypeCache { get; protected set; }
    public PsiAssemblyFileLoader(Lifetime lifetime, AssemblyToAssemblyReferencesResolveManager resolveManager, IPsiConfiguration psiConfiguration, IPlatformManager platformManager, ISolution solution, IPsiModules psiModules, ChangeManager changeManager, AssemblyExistsService assemblyExistsService, IShellLocks locks, XmlIndexThread xmlIndexThread, AssembliesDiagnostics assembliesDiagnostics, AnnotationsIndex index, ExternalAnnotationsManager externalAnnotationsManager, IEnumerable`1<IPsiAssemblyFileFactory> assemblyFileFactories);
    [CompilerGeneratedAttribute]
public IExternalProviderCache`2<ICompiledEntity, IType> get_DecodedTypeCache();
    [CompilerGeneratedAttribute]
protected void set_DecodedTypeCache(IExternalProviderCache`2<ICompiledEntity, IType> value);
    [MemberNotNullAttribute("DecodedTypeCache")]
[MemberNotNullAttribute("CompiledBucketCache")]
protected virtual void InitCaches(Lifetime lifetime);
    public virtual IPsiAssemblyFile GetOrLoadAssembly(IPsiAssembly psiAssembly, bool shouldLoad, Action`3<IPsiAssembly, IPsiAssemblyFile, IMetadataAssembly> processor);
    protected virtual IPsiAssemblyFile LoadAssembly(IPsiAssembly psiAssembly, Action`3<IPsiAssembly, IPsiAssemblyFile, IMetadataAssembly> processor);
    public virtual IPsiAssemblyFile UnloadAssembly(IPsiAssembly assembly);
    private MetadataLoader MetadataLoaderFactory(IAssemblyLocation assemblyLocation);
    private IMetadataAssembly GetMetadataAssembly(MetadataLoader loader, IPsiAssembly psiAssembly);
    protected AssemblyPsiFile CreateFile(IPsiAssembly psiAssembly, IMetadataAssembly metadataAssembly);
    protected virtual IPsiAssemblyFile GetPsiAssemblyFile(IPsiAssembly assembly, IMetadataAssembly metadataAssembly);
    protected IPsiAssemblyFile InvokeProcessorAndReturn(IPsiAssemblyFile assemblyFile, IPsiAssembly psiAssembly, Action`3<IPsiAssembly, IPsiAssemblyFile, IMetadataAssembly> processor);
    protected IPsiAssemblyFile ProcessMetadataAssembly(IPsiAssembly psiAssembly, Func`3<IPsiAssembly, IMetadataAssembly, IPsiAssemblyFile> preProcessor, Action`3<IPsiAssembly, IPsiAssemblyFile, IMetadataAssembly> processor);
    public sealed virtual object Execute(IChangeMap changeMap);
    [CompilerGeneratedAttribute]
private MetadataLoader <CreateFile>b__26_0(IAssemblyLocation location, IPsiModule _);
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Impl.reflection2.AssemblyFileLoaderZoned.WinMDPsiAssemblyFileFactory : object {
    public int Priority { get; }
    public sealed virtual int get_Priority();
    public sealed virtual bool IsApplicable(IPsiAssembly assembly, IMetadataAssembly metadataAssembly);
    public sealed virtual AssemblyPsiFile CreateFile(Func`3<IAssemblyLocation, IPsiModule, MetadataLoader> metadataLoaderFactory, IPsiConfiguration psiConfiguration, IExternalProviderCache`2<ICompiledEntity, IType> decodedTypeCache, IWeakRefRetainerCache`1<object> compiledMembersBucketCache);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Psi.Impl.reflection2.AssemblyFileLoaderZoned.ZoneMarker : object {
}
public class JetBrains.ReSharper.Psi.Impl.Reflection2.AssemblyPsiFile : object {
    [NotNullAttribute]
private Func`3<IAssemblyLocation, IPsiModule, MetadataLoader> myMetadataLoaderFactory;
    [NotNullAttribute]
private IExternalProviderCache`2<ICompiledEntity, IType> myDecodedTypeCache;
    [NotNullAttribute]
private IWeakRefRetainerCache`1<object> myCompiledMembersBucketCache;
    private bool myFullMetadataLoad;
    private bool myEagerMetadataLoad;
    private IPsiServices myPsiServices;
    private IAssemblyPsiModule myModule;
    private AssemblyNameInfo myAssemblyName;
    private CompiledTypeElement[] myInternalTypesElement;
    private IAssemblyDataCache myAssemblyDataCache;
    private JetHashSet`1<Namespace> myNamespaces;
    private ForwardedTypeInfo[] myForwardedFromTypesTable;
    private ForwardedTypeInfo[] myForwardedToTypesTable;
    private Dictionary`2<UInt32, Tuple`2<IAssemblyLocation, AssemblyId>> myModules;
    private IAssemblyLocation myLocation;
    private AssemblyNameInfo[] myReferencedAssembliesNames;
    private DateTime myTimestamp;
    private IList`1 modreq(System.Runtime.CompilerServices.IsVolatile) myAttributeInstances;
    private IList`1 modreq(System.Runtime.CompilerServices.IsVolatile) myModuleAttributeInstances;
    private IReadOnlySet`1<int> myAttributeInstancesTypeNameHash;
    private bool myLoadedAllMembers;
    [CompilerGeneratedAttribute]
private AssemblyId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDocIndex <XmlDocIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyExternalAnnotations <ExternalAnnotations>k__BackingField;
    public Func`3<IAssemblyLocation, IPsiModule, MetadataLoader> MetadataLoaderFactory { get; }
    public DateTime Timestamp { get; }
    public AssemblyId Id { get; private set; }
    internal IExternalProviderCache`2<ICompiledEntity, IType> DecodedTypeCache { get; }
    internal IWeakRefRetainerCache`1<object> CompiledMemberBucketCache { get; }
    public AssemblyNameInfo AssemblyName { get; }
    public XmlDocIndex XmlDocIndex { get; internal set; }
    public AssemblyExternalAnnotations ExternalAnnotations { get; internal set; }
    [NotNullAttribute]
[ItemNotNullAttribute]
internal IEnumerable`1<CompiledTypeElement> InternalTypesElement { get; }
    internal IEnumerable`1<ForwardedTypeInfo> ForwardedFromTypes { get; }
    internal IEnumerable`1<ForwardedTypeInfo> ForwardedToTypes { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
internal IEnumerable`1<Namespace> Namespaces { get; }
    public AssemblyNameInfo[] ReferencedAssembliesNames { get; }
    public IEnumerable`1<CompiledTypeElement> Types { get; }
    public ILibraryMemberNamesAccess MemberNamesAccess { get; }
    public IPsiModule Module { get; }
    private ICompiledEntity JetBrains.ReSharper.Psi.Impl.Reflection2.ICompiledEntity.Parent { get; }
    public AssemblyPsiFile(Func`3<IAssemblyLocation, IPsiModule, MetadataLoader> metadataLoaderFactory, IPsiConfiguration psiConfiguration, IExternalProviderCache`2<ICompiledEntity, IType> decodedTypeCache, IWeakRefRetainerCache`1<object> compiledMembersBucketCache);
    public virtual void LoadAssembly(IMetadataAssembly assembly, IAssemblyPsiModule containingModule);
    [NotNullAttribute]
protected virtual ReflectionTypeBuilder CreateReflectionTypeBuilder(IAssemblyDataCache cache, IMetadataAssembly assembly);
    [NotNullAttribute]
protected virtual ReflectionElementAccessibility CreateReflectionElementAccessibility(bool fullMetadataLoad);
    [NotNullAttribute]
protected virtual ReflectionElementPropertiesProvider CreateReflectionElementPropertiesProvider();
    public Func`3<IAssemblyLocation, IPsiModule, MetadataLoader> get_MetadataLoaderFactory();
    public sealed virtual DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public AssemblyId get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(AssemblyId value);
    private void LoadTypes(IMetadataAssembly metadataAssembly, IEnumerable`1<IMetadataTypeInfo> typeInfos, List`1<CompiledTypeElement> loadedTypes, List`1<ForwardedTypeInfo> forwardedFromInfo);
    internal void UnloadCachedCompiledMembers();
    [NotNullAttribute]
internal IReflectionBuilder GetReflectionBuilder(IMetadataAssembly assembly);
    internal IExternalProviderCache`2<ICompiledEntity, IType> get_DecodedTypeCache();
    internal IWeakRefRetainerCache`1<object> get_CompiledMemberBucketCache();
    public AssemblyNameInfo get_AssemblyName();
    public IPsiServices GetPsiServices();
    [CanBeNullAttribute]
internal Tuple`2<IAssemblyLocation, AssemblyId> GetTypeElementModule(CompiledTypeElement typeElement);
    public sealed virtual VirtualFileSystemPath GetXmlDocPath();
    [CompilerGeneratedAttribute]
public sealed virtual XmlDocIndex get_XmlDocIndex();
    [CompilerGeneratedAttribute]
internal void set_XmlDocIndex(XmlDocIndex value);
    [CompilerGeneratedAttribute]
public sealed virtual AssemblyExternalAnnotations get_ExternalAnnotations();
    [CompilerGeneratedAttribute]
internal void set_ExternalAnnotations(AssemblyExternalAnnotations value);
    public sealed virtual IAttributesSet CreateAssemblyAttributes();
    internal IEnumerable`1<CompiledTypeElement> get_InternalTypesElement();
    internal IEnumerable`1<ForwardedTypeInfo> get_ForwardedFromTypes();
    internal IEnumerable`1<ForwardedTypeInfo> get_ForwardedToTypes();
    internal IEnumerable`1<Namespace> get_Namespaces();
    public virtual AssemblyNameInfo[] get_ReferencedAssembliesNames();
    [NotNullAttribute]
public IList`1<IAttributeInstance> GetAttributeInstances();
    public IList`1<IAttributeInstance> GetModuleAttributeInstances();
    private ValueTuple`2<IList`1<IAttributeInstance>, IList`1<IAttributeInstance>> LoadAttributes();
    [NotNullAttribute]
public IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName);
    public bool HasAttributeInstance(IClrTypeName clrName);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.Reflection2.AssemblyPsiFile/<get_Types>d__71")]
public sealed virtual IEnumerable`1<CompiledTypeElement> get_Types();
    public sealed virtual ILibraryMemberNamesAccess get_MemberNamesAccess();
    public sealed virtual void LoadAllTypeMembers();
    public sealed virtual IPsiModule get_Module();
    public void BindToModule(IAssemblyPsiModule module, AnnotationsIndex annotationsIndex, ExternalAnnotationsManager externalAnnotationsManager);
    public void UnbindFromModule();
    public void Dump(TextWriter writer, string indent);
    public virtual string ToString();
    private sealed virtual override ICompiledEntity JetBrains.ReSharper.Psi.Impl.Reflection2.ICompiledEntity.get_Parent();
    [PureAttribute]
public sealed virtual bool IsValid();
    internal void AddNamespace(Namespace ns);
    internal void InvalidateCaches();
    [CompilerGeneratedAttribute]
private void <GetReflectionBuilder>b__36_0();
}
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ClrNameInternTrie : object {
    private static EmptyNode Empty;
    private NodeChildren myChildren;
    private static ClrNameInternTrie();
    public INode Add(string namespaceName, string typeName, IList`1<int> typeParameterNumberFromReflection, IMetadataTypeInfo typeHint);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertNode(string typeName, string namespaceName, INode node);
}
public abstract class JetBrains.ReSharper.Psi.Impl.Reflection2.CompiledElementBase : object {
    [NotNullAttribute]
protected ICompiledEntity myParent;
    [CanBeNullAttribute]
protected IList`1<IAttributeInstance> myAttributeInstances;
    [CompilerGeneratedAttribute]
private UInt32 <Token>k__BackingField;
    public IPsiModule Module { get; }
    [NotNullAttribute]
private ICompiledEntity JetBrains.ReSharper.Psi.Impl.Reflection2.ICompiledEntity.Parent { get; }
    [NotNullAttribute]
public string XMLDocId { get; }
    [CanBeNullAttribute]
public ITypeElement ContainingType { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiAssemblyFile PsiAssemblyFile { get; }
    public UInt32 Token { get; }
    public UInt32 ModuleToken { get; }
    protected CompiledElementBase(ICompiledEntity parent, IReflectionBuilder builder, IMetadataEntity entity, bool loadAttributes);
    public virtual string ToString();
    public sealed virtual IPsiModule get_Module();
    private sealed virtual override ICompiledEntity JetBrains.ReSharper.Psi.Impl.Reflection2.ICompiledEntity.get_Parent();
    public sealed virtual IPsiServices GetPsiServices();
    public virtual string get_XMLDocId();
    [CanBeNullAttribute]
public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual VirtualFileSystemPath GetXmlDocPath();
    [CanBeNullAttribute]
public VirtualFileSystemPath GetXmlDocPath(XmlDocIndex index);
    public virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    [NotNullAttribute]
internal AssemblyPsiFile GetContainingFile();
    public virtual void Dump(TextWriter writer, string indent);
    [NotNullAttribute]
[PureAttribute]
internal IType DecodeType(ReflectionType type, bool decodeDynamic, IList`1<IAttributeInstance> ownTypeAttributes);
    [NotNullAttribute]
[PureAttribute]
internal IType DecodeType(ReflectionType type, Nullable`1<int> dynamicDecoderOffset, IList`1<IAttributeInstance> ownTypeAttributes);
    [PureAttribute]
private TypeAnnotationsEnumerator`1<bool> GetAnnotationsEnumerator(IClrTypeName annotationTypeName, IList`1<IAttributeInstance> ownTypeAttributes, Nullable`1<int> decoderOffset);
    [PureAttribute]
private TypeAnnotationsEnumerator`1<NullableAnnotation> GetNullableAnnotationsEnumerator(IList`1<IAttributeInstance> ownTypeAttributes);
    [PureAttribute]
private TypeAnnotationsEnumerator`1<string> GetTupleComponentNamesEnumerator(IList`1<IAttributeInstance> ownTypeAttributes);
    public sealed virtual ITypeElement get_ContainingType();
    [CanBeNullAttribute]
public sealed virtual ITypeElement GetContainingType();
    [CanBeNullAttribute]
public sealed virtual ITypeMember GetContainingTypeMember();
    public virtual bool IsValid();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    protected virtual bool HasAttributeInstance(IClrTypeName qualifiedTypeName);
    [NotNullAttribute]
protected virtual IEnumerable`1<IAttributeInstance> BuildAttributeInstances();
    [NotNullAttribute]
protected virtual IList`1<IAttributeInstance> GetMetadataAttributeInstances();
    public virtual bool HasMetadataAttributeInstances(IClrTypeName qualifiedTypeName);
    [PureAttribute]
protected ReferenceKind GetReferenceKind(bool isByRefType);
    protected virtual Nullable`1<NullableAnnotation> TryGetNullableContextValue();
    public sealed virtual IPsiAssemblyFile get_PsiAssemblyFile();
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_Token();
    public virtual UInt32 get_ModuleToken();
}
internal class JetBrains.ReSharper.Psi.Impl.Reflection2.CompiledMembersBucket : object {
    public static CompiledMembersBucket Empty;
    private MembersMask myMask;
    private Constant[] myConstants;
    private Constructor[] myConstructors;
    private Event[] myEvents;
    private Field[] myFields;
    private Method[] myMethods;
    private Operator[] myOperators;
    private Property[] myProperties;
    public bool IsPreloaded { get; }
    public bool HasExtensionMethods { get; }
    public Constant[] Constants { get; }
    public Constructor[] Constructors { get; }
    public Event[] Events { get; }
    public Field[] Fields { get; }
    public Method[] Methods { get; }
    public Operator[] Operators { get; }
    public Property[] Properties { get; }
    public IEnumerable`1<ITypeMember> AllMembers { get; }
    public CompiledMembersBucket(CompiledTypeElement owner, IMetadataTypeInfo info, IReflectionBuilder builder, bool hasExtensionMethods, bool preloaded);
    private static CompiledMembersBucket();
    private static CompiledTypeElementFactory GetContainerFactory(CompiledTypeElement owner, IReflectionBuilder builder);
    [CanBeNullAttribute]
private static Dictionary`2<string, int> FindIteratorNestedTypes(IMetadataTypeInfo info);
    public void Dump(TextWriter writer, string indent);
    public bool get_IsPreloaded();
    public bool get_HasExtensionMethods();
    public Constant[] get_Constants();
    public Constructor[] get_Constructors();
    public Event[] get_Events();
    public Field[] get_Fields();
    public Method[] get_Methods();
    public Operator[] get_Operators();
    public Property[] get_Properties();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.Reflection2.CompiledMembersBucket/<get_AllMembers>d__34")]
public IEnumerable`1<ITypeMember> get_AllMembers();
}
public abstract class JetBrains.ReSharper.Psi.Impl.Reflection2.CompiledTypeElement : CompiledElementBase {
    private TypeElementFlags myFlags;
    [NotNullAttribute]
[ItemCanBeNullAttribute]
private IList`1<ReflectionType> myBaseTypes;
    [NotNullAttribute]
[ItemNotNullAttribute]
private IList`1[] myInterfaceImplementationAttributes;
    [NotNullAttribute]
[ItemNotNullAttribute]
private IList`1<ITypeParameter> myTypeParameters;
    [NotNullAttribute]
private IReadOnlySet`1<int> myAttributeInstancesTypeNameHash;
    [NotNullAttribute]
private INode myNamespaceName;
    [CompilerGeneratedAttribute]
private UInt32 <ModuleToken>k__BackingField;
    private static HashSet`1<string> ourObjectName;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private CacheTrieNode <TrieNode>k__BackingField;
    protected ReflectionTypeFlags TypeFlags { get; protected set; }
    protected bool HasBaseClass { get; }
    public ISubstitution IdSubstitution { get; }
    public UInt32 ModuleToken { get; }
    public ISet`1<string> ExtendsListNames { get; }
    public string ShortName { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public IList`1<ITypeElement> NestedTypes { get; }
    public IEnumerable`1<IField> Constants { get; }
    public IEnumerable`1<IField> Fields { get; }
    public IEnumerable`1<IConstructor> Constructors { get; }
    public IEnumerable`1<IOperator> Operators { get; }
    public IEnumerable`1<IMethod> Methods { get; }
    public IEnumerable`1<IProperty> Properties { get; }
    public IEnumerable`1<IEvent> Events { get; }
    [NotNullAttribute]
public ICollection`1<ICompiledExtensionMemberProxy> ExtensionMembers { get; }
    public IEnumerable`1<string> MemberNames { get; }
    internal CacheTrieNode TrieNode { get; internal set; }
    private CacheTrieNode JetBrains.ReSharper.Psi.Caches.SymbolCache.ICacheTrieNodeOwner.TrieNode { get; private set; }
    public MemberHidePolicy HidePolicy { get; }
    public string XMLDocId { get; }
    protected CompiledTypeElement(ICompiledEntity parent, IReflectionBuilder builder, CompiledTypeElementFactory factory, IMetadataTypeInfo info);
    private static CompiledTypeElement();
    protected ReflectionTypeFlags get_TypeFlags();
    protected void set_TypeFlags(ReflectionTypeFlags value);
    internal virtual void LoadFromAssembly(IMetadataAssembly assembly);
    private string StripTypeParametersCount(string shortName, int expectedTypeParametersCount);
    public static string StripTypeParametersCount(string shortName, int expectedTypeParametersCount, ReflectionTypeFlags& typeFlags);
    [CanBeNullAttribute]
private static string TryToStripTypeParameters(string name, char symbol, string expectedTypeParametersCountStr);
    internal TRes ExecuteWithMetadataAssembly(Func`3<TParam, IMetadataAssembly, TRes> action, TParam param);
    private void LoadCustomAttributes();
    protected virtual IList`1<IAttributeInstance> GetMetadataAttributeInstances();
    public virtual bool HasMetadataAttributeInstances(IClrTypeName qualifiedTypeName);
    protected bool get_HasBaseClass();
    public sealed virtual ISubstitution get_IdSubstitution();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public virtual UInt32 get_ModuleToken();
    public sealed virtual IClrTypeName GetClrName();
    [NotNullAttribute]
[ItemNotNullAttribute]
public sealed virtual IEnumerable`1<string> GetNamespaceNames();
    public sealed virtual ISet`1<string> get_ExtendsListNames();
    private static string ExtractShortName(ReflectionType type);
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ShortName();
    public abstract virtual DeclaredElementType GetElementType();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    [NotNullAttribute]
public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public abstract virtual IList`1<ITypeElement> get_NestedTypes();
    public abstract virtual IEnumerable`1<IField> get_Constants();
    public abstract virtual IEnumerable`1<IField> get_Fields();
    public abstract virtual IEnumerable`1<IConstructor> get_Constructors();
    public abstract virtual IEnumerable`1<IOperator> get_Operators();
    public abstract virtual IEnumerable`1<IMethod> get_Methods();
    public abstract virtual IEnumerable`1<IProperty> get_Properties();
    public abstract virtual IEnumerable`1<IEvent> get_Events();
    public abstract virtual IEnumerable`1<ITypeMember> GetMembers();
    public virtual ICollection`1<ICompiledExtensionMemberProxy> get_ExtensionMembers();
    public sealed virtual IDeclaredType GetBaseClassType();
    public virtual IList`1<IDeclaredType> GetSuperTypes();
    public virtual IList`1<ITypeElement> GetSuperTypeElements();
    public abstract virtual MemberPresenceFlag GetMemberPresenceFlag();
    public sealed virtual INamespace GetContainingNamespace();
    public virtual bool IsValid();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    protected virtual bool HasAttributeInstance(IClrTypeName qualifiedTypeName);
    public abstract virtual bool HasMemberWithName(string shortName, bool ignoreCase);
    public abstract virtual IEnumerable`1<string> get_MemberNames();
    public sealed virtual IPsiSourceFile GetSingleOrDefaultSourceFile();
    [CompilerGeneratedAttribute]
internal CacheTrieNode get_TrieNode();
    [CompilerGeneratedAttribute]
internal void set_TrieNode(CacheTrieNode value);
    private sealed virtual override CacheTrieNode JetBrains.ReSharper.Psi.Caches.SymbolCache.ICacheTrieNodeOwner.get_TrieNode();
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.SymbolCache.ICacheTrieNodeOwner.set_TrieNode(CacheTrieNode value);
    public virtual void Dump(TextWriter writer, string indent);
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual string get_XMLDocId();
    protected virtual Hash CalculateHashInternal();
    public sealed virtual Nullable`1<Hash> CalcHash();
    public sealed virtual bool IsSynthetic();
    public void Unbind();
    protected virtual IEnumerable`1<IAttributeInstance> BuildAttributeInstances();
    protected virtual Nullable`1<NullableAnnotation> TryGetNullableContextValue();
}
public abstract class JetBrains.ReSharper.Psi.Impl.Reflection2.CompiledTypeElementFactory : object {
    [NotNullAttribute]
public abstract virtual CompiledTypeElement Create(ICompiledEntity parent, IReflectionBuilder builder, IMetadataTypeInfo info);
    public virtual MemberDecoration GetDecoration(IMetadataTypeInfo info);
    public virtual KeyValuePair`2<string, string> GetName(IMetadataTypeInfo info);
    public virtual bool IsImplementsInterface(IMetadataTypeInfo typeInfo, IMetadataClassType implementedInterface);
    private static void ResplitTypeName(IMetadataTypeInfo info, String& shortName, String& namespaceName);
}
internal class JetBrains.ReSharper.Psi.Impl.Reflection2.ConstantSpecification : ValueType {
    private object myValue;
    public object Value { get; }
    public ConstantSpecification(IReflectionBuilder builder, object value);
    public object get_Value();
    [PureAttribute]
public Hash AddToHash(Hash hash);
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Impl.Reflection2.DeclaredTypeFromReflectionClassType : DeclaredTypeBase {
    [NotNullAttribute]
private IClrTypeName myClrTypeName;
    [NotNullAttribute]
private IType[] myTypeArguments;
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyNameInfo <Assembly>k__BackingField;
    public TypeDecorationSet TypeDecorations { get; }
    [DebuggerBrowsableAttribute("0")]
public IPsiModule Module { get; }
    public AssemblyNameInfo Assembly { get; }
    private DeclaredTypeFromReflectionClassType(IPsiModule module, IClrTypeName clrTypeName, AssemblyNameInfo assemblyName, IType[] typeArguments);
    [NotNullAttribute]
[PureAttribute]
public static IDeclaredType Create(IPsiModule module, ITypeMember context, IClrTypeName clrTypeName, AssemblyNameInfo assemblyName, TypeModifier[] typeModifiers, ReflectionType[] typeArguments, Nullable`1<bool> isValueType, TypeAnnotationsEnumerator`1& dynamicAnnotationsEnumerator, TypeAnnotationsEnumerator`1& tupleComponentNamesEnumerator, TypeAnnotationsEnumerator`1& nullableAnnotationsEnumerator, TypeAnnotationsEnumerator`1& nativeIntegerAnnotationsEnumerator);
    public virtual bool IsValid();
    public virtual TypeDecorationSet get_TypeDecorations();
    [CompilerGeneratedAttribute]
public virtual IPsiModule get_Module();
    public virtual IPsiServices GetPsiServices();
    protected virtual RichText GetUnresolvedPresentation(NullableAnnotation nullableAnnotation, ITypePresenter presenter, TypePresentationStyle typePresentationStyle);
    public virtual IClrTypeName GetClrName();
    [CompilerGeneratedAttribute]
public virtual AssemblyNameInfo get_Assembly();
    public virtual IDeclaredType Retarget(IPsiModule psiModule);
    protected virtual ITypeElement GetTypeElement(IModuleReferenceResolveContext resolveContext);
    protected virtual ITypeElement GetTypeElementNoRetargeting();
    protected virtual IResolveResult Resolve(IModuleReferenceResolveContext resolveContext);
    protected virtual IResolveResult ResolveNoRetargeting();
    public virtual bool Equals(object obj);
    [NotNullAttribute]
private sealed virtual override string JetBrains.ReSharper.Psi.Impl.Types.ISimplifiedIdTypeInfo.GetShortName();
    [NotNullAttribute]
private sealed virtual override IType[] JetBrains.ReSharper.Psi.Impl.Types.ISimplifiedIdTypeInfo.GetTypeArguments();
}
internal class JetBrains.ReSharper.Psi.Impl.Reflection2.DeclaredTypeFromReflectionTypeParameter : DeclaredTypeBase {
    private ReflectionTypeParameterType myTypeParameterType;
    private ITypeMember myContext;
    [DebuggerBrowsableAttribute("0")]
private IPsiModule myModule;
    private ITypeParameter myTypeParameter;
    [DebuggerBrowsableAttribute("0")]
public IPsiModule Module { get; }
    public TypeDecorationSet TypeDecorations { get; }
    public DeclaredTypeFromReflectionTypeParameter(ReflectionTypeParameterType typeParameterType, ITypeMember context, IPsiModule module);
    private DeclaredTypeFromReflectionTypeParameter(ReflectionTypeParameterType typeParameterType, ITypeMember context, IPsiModule module, ITypeParameter typeParameter);
    public virtual IDeclaredType Retarget(IPsiModule psiModule);
    public virtual bool IsValid();
    public virtual IPsiModule get_Module();
    public virtual TypeDecorationSet get_TypeDecorations();
    public virtual IPsiServices GetPsiServices();
    protected virtual ITypeElement GetTypeElement(IModuleReferenceResolveContext resolveContext);
    protected virtual ITypeElement GetTypeElementNoRetargeting();
    private ITypeParameter GetTypeElementInternal(ReflectionTypeParameterType typeParameterType);
    protected virtual IResolveResult Resolve(IModuleReferenceResolveContext resolveContext);
    protected virtual IResolveResult ResolveNoRetargeting();
}
[DefaultMemberAttribute("Item")]
internal class JetBrains.ReSharper.Psi.Impl.Reflection2.DecodedTypeCacheDictionary`2 : object {
    private int myMaxCapacity;
    private Dictionary`2<TKey, TValue> myStorageInUse;
    private Dictionary`2<TKey, TValue> myStorageBacklog;
    unknown TValue Item {public set; }
    public DecodedTypeCacheDictionary`2(int maxCapacity);
    public void Clear();
    public bool TryGetValue(TKey element, TValue& result);
    private void SwapIfNeeded();
    public void set_Item(TKey element, TValue value);
}
internal static class JetBrains.ReSharper.Psi.Impl.Reflection2.ElementBuilderUtil : object {
    [CanBeNullAttribute]
public static CompiledTypeElement CreateType(ICompiledEntity parent, IReflectionBuilder builder, IMetadataTypeInfo typeInfo);
    public static void ReadAttributes(IMetadataMethod method, MemberDecoration& decoration, bool isConstructor);
    [NotNullAttribute]
public static string ExtractMethodName(IMetadataMethod method);
    [CanBeNullAttribute]
public static string ExtractMemberName(MemberInfo memberInfo);
    [ContractAnnotationAttribute("null => null; => notnull")]
public static string ExtractMemberName(string name);
    [CanBeNullAttribute]
public static string TryLoadForwardedFromAttribute(IMetadataTypeInfo info);
    [NotNullAttribute]
[PureAttribute]
public static IList`1<IAttributeInstance> GetMetadataAttributeInstances(ICompiledEntity psiOwner, IMetadataEntity metadataOwner, IReflectionBuilder builder);
    [NotNullAttribute]
[PureAttribute]
public static IList`1<IAttributeInstance> GetModuleAttributeInstances(ICompiledEntity assembly, IMetadataAssembly metadataAssembly, IReflectionBuilder builder);
    [NotNullAttribute]
[PureAttribute]
public static IReadOnlySet`1<int> GetMetadataAttributeInstancesTypeNameHash(IMetadataEntity metadataOwner, IReflectionBuilder builder);
}
internal class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.Accessor : MethodBase {
    private AccessorFlags myFlags;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    public string ShortName { get; }
    public bool IsExtensionMethod { get; }
    public bool IsAsync { get; }
    public bool IsVarArg { get; }
    public bool IsIterator { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public bool IsExplicitImplementation { get; }
    public bool IsExplicitImplementationByName { get; }
    public bool CanBeImplicitImplementation { get; }
    [NotNullAttribute]
public IOverridableMember OwnerMember { get; }
    public AccessorKind Kind { get; }
    public bool IsAuto { get; }
    public bool IsInitOnly { get; }
    public IParameter ValueVariable { get; }
    public bool IsStatic { get; }
    public bool IsUnsafe { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsReadonly { get; }
    public Accessor(Member element, IReflectionBuilder builder, IMetadataMethod method, AccessorKind kind, bool canBeIterator, CompiledTypeElementFactory ownerFactory);
    [CompilerGeneratedAttribute]
public virtual string get_ShortName();
    public sealed virtual bool get_IsExtensionMethod();
    public sealed virtual bool get_IsAsync();
    public sealed virtual bool get_IsVarArg();
    public virtual bool get_IsIterator();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public sealed virtual bool get_IsExplicitImplementation();
    public sealed virtual bool get_IsExplicitImplementationByName();
    public sealed virtual bool get_CanBeImplicitImplementation();
    public sealed virtual IOverridableMember get_OwnerMember();
    public sealed virtual AccessorKind get_Kind();
    public sealed virtual bool get_IsAuto();
    public sealed virtual bool get_IsInitOnly();
    public virtual DeclaredElementType GetElementType();
    public sealed virtual IParameter get_ValueVariable();
    public virtual bool get_IsStatic();
    public virtual bool get_IsUnsafe();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsReadonly();
    public virtual void Dump(TextWriter writer, string indent);
}
internal class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.AccessorPropertiesProvider : MethodBasePropertiesProvider {
    [NotNullAttribute]
public static AccessorPropertiesProvider Instance;
    private static AccessorPropertiesProvider();
    [NotNullAttribute]
[PureAttribute]
public string GetCommonPrefix(AccessorKind kind);
    [CanBeNullAttribute]
[PureAttribute]
public string GetName(IMetadataMethod entity, AccessorKind kind, Member owner);
    [PureAttribute]
public MemberDecoration GetMemberDecoration(IMetadataMethod entity);
}
public class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.Class : MemberOwner {
    private MemberPresenceFlag myMemberPresenceFlags;
    public Class(ICompiledEntity parent, IReflectionBuilder builder, IMetadataTypeInfo info);
    public virtual DeclaredElementType GetElementType();
    public virtual IClass GetSuperClass();
    public virtual MemberPresenceFlag GetMemberPresenceFlag();
    public virtual void Dump(TextWriter writer, string indent);
}
public class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.ClassFactory : CompiledTypeElementFactory {
    public static ClassFactory Instance;
    private static ClassFactory();
    public virtual CompiledTypeElement Create(ICompiledEntity parent, IReflectionBuilder builder, IMetadataTypeInfo info);
    public virtual MemberDecoration GetDecoration(IMetadataTypeInfo info);
}
internal class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.Constant : FieldBase {
    private ConstantSpecification myValue;
    public bool IsStatic { get; }
    public ConstantValue ConstantValue { get; }
    public bool IsField { get; }
    public bool IsConstant { get; }
    public Constant(ICompiledEntity element, IReflectionBuilder builder, IMetadataField field);
    public virtual bool get_IsStatic();
    public virtual DeclaredElementType GetElementType();
    public virtual ConstantValue get_ConstantValue();
    public virtual bool get_IsField();
    public virtual bool get_IsConstant();
    public virtual void Dump(TextWriter writer, string indent);
    protected virtual Hash CalculateHashInternal();
}
internal class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.ConstantPropertiesProvider : FieldBasePropertiesProvider {
    [NotNullAttribute]
public static ConstantPropertiesProvider Instance;
    private static ConstantPropertiesProvider();
}
internal class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.Constructor : MethodBase {
    public bool IsDefault { get; }
    public bool IsParameterless { get; }
    public bool IsImplicit { get; }
    public bool IsValueTypeZeroInit { get; }
    public bool IsIterator { get; }
    public string ShortName { get; }
    public Constructor(ICompiledEntity element, IReflectionBuilder builder, IMetadataMethod method, CompiledTypeElementFactory ownerFactory);
    public sealed virtual bool get_IsDefault();
    public sealed virtual bool get_IsParameterless();
    public sealed virtual bool get_IsImplicit();
    public sealed virtual bool get_IsValueTypeZeroInit();
    public virtual DeclaredElementType GetElementType();
    public virtual bool get_IsIterator();
    public virtual string get_ShortName();
    public virtual void Dump(TextWriter writer, string indent);
}
internal class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.ConstructorPropertiesProvider : MethodBasePropertiesProvider {
    [NotNullAttribute]
public static ConstructorPropertiesProvider Instance;
    private static ConstructorPropertiesProvider();
    public MemberDecoration GetMemberDecoration(IMetadataMethod entity);
}
internal class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.ConversionOperator : Operator {
    private bool myIsImplicit;
    [CompilerGeneratedAttribute]
private bool <IsChecked>k__BackingField;
    public string ShortName { get; }
    public bool IsChecked { get; }
    public bool IsExplicitCast { get; }
    public bool IsImplicitCast { get; }
    public bool IsIterator { get; }
    public ConversionOperator(ICompiledEntity element, IReflectionBuilder builder, IMetadataMethod method, bool isImplicit, CompiledTypeElementFactory ownerFactory, bool isChecked);
    public virtual string get_ShortName();
    [CompilerGeneratedAttribute]
public virtual bool get_IsChecked();
    public virtual DeclaredElementType GetElementType();
    public sealed virtual bool get_IsExplicitCast();
    public sealed virtual bool get_IsImplicitCast();
    public virtual bool get_IsIterator();
    public virtual void Dump(TextWriter writer, string indent);
    protected virtual Hash CalculateHashInternal();
}
public class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.Delegate : MemberOwner {
    [CanBeNullAttribute]
private IMethod modreq(System.Runtime.CompilerServices.IsVolatile) myInvokeMethod;
    public IMethod InvokeMethod { get; }
    [NotNullAttribute]
public IList`1<IParameter> Parameters { get; }
    [NotNullAttribute]
public IType ReturnType { get; }
    public IEnumerable`1<IConstructor> Constructors { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public Delegate(ICompiledEntity parent, IReflectionBuilder builder, IMetadataTypeInfo info);
    public virtual MemberPresenceFlag GetMemberPresenceFlag();
    public sealed virtual IMethod get_InvokeMethod();
    public IList`1<IParameter> get_Parameters();
    public IType get_ReturnType();
    [NotNullAttribute]
public InvocableSignature GetSignature(IParametersOwner parametersOwner, ISubstitution substitution);
    public virtual DeclaredElementType GetElementType();
    public virtual IEnumerable`1<IConstructor> get_Constructors();
    public virtual string ToString();
    public virtual void Dump(TextWriter writer, string indent);
    protected virtual Hash CalculateHashInternal();
    public virtual bool HasMemberWithName(string shortName, bool ignoreCase);
    public virtual IEnumerable`1<string> get_MemberNames();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    [CompilerGeneratedAttribute]
private IType <get_InvokeMethod>b__4_2(DelegateInvokeMethod _);
}
public class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.DelegateFactory : CompiledTypeElementFactory {
    [NotNullAttribute]
public static DelegateFactory Instance;
    private static DelegateFactory();
    public virtual CompiledTypeElement Create(ICompiledEntity parent, IReflectionBuilder builder, IMetadataTypeInfo info);
}
public class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.Enum : CompiledTypeElement {
    private IParametrizedCachedValue`2<EnumInfo, KeyValuePair`2<Enum, IMetadataAssembly>> myInfo;
    public IEnumerable`1<IField> EnumMembers { get; }
    public IEnumerable`1<IField> Constants { get; }
    public IEnumerable`1<IField> Fields { get; }
    public IEnumerable`1<IConstructor> Constructors { get; }
    public IEnumerable`1<IProperty> Properties { get; }
    public IEnumerable`1<IEvent> Events { get; }
    public IEnumerable`1<IMethod> Methods { get; }
    public IEnumerable`1<IOperator> Operators { get; }
    public IList`1<ITypeElement> NestedTypes { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public Enum(ICompiledEntity parent, IReflectionBuilder builder, IMetadataTypeInfo info);
    private static EnumInfo ProduceBucket(KeyValuePair`2<Enum, IMetadataAssembly> pair);
    [NotNullAttribute]
private static EnumInfo ProduceBucketInternal(Enum owner, IMetadataAssembly assembly);
    internal virtual void LoadFromAssembly(IMetadataAssembly metadataAssembly);
    [CanBeNullAttribute]
private EnumInfo LoadInfoOnDemand();
    public sealed virtual IType GetUnderlyingType();
    public sealed virtual IEnumerable`1<IField> get_EnumMembers();
    public virtual IEnumerable`1<ITypeMember> GetMembers();
    public virtual IEnumerable`1<IField> get_Constants();
    public virtual IEnumerable`1<IField> get_Fields();
    public virtual IEnumerable`1<IConstructor> get_Constructors();
    public virtual IEnumerable`1<IProperty> get_Properties();
    public virtual IEnumerable`1<IEvent> get_Events();
    public virtual IEnumerable`1<IMethod> get_Methods();
    public virtual IEnumerable`1<IOperator> get_Operators();
    public virtual IList`1<ITypeElement> get_NestedTypes();
    public virtual IList`1<IDeclaredType> GetSuperTypes();
    public virtual MemberPresenceFlag GetMemberPresenceFlag();
    public virtual DeclaredElementType GetElementType();
    public virtual bool HasMemberWithName(string shortName, bool ignoreCase);
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual void Dump(TextWriter writer, string indent);
}
internal class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.EnumMember : Member {
    private ConstantSpecification myValue;
    public IType Type { get; }
    public ConstantValue ConstantValue { get; }
    public bool IsRequired { get; }
    public Nullable`1<int> FixedBufferSize { get; }
    public bool IsField { get; }
    public bool IsConstant { get; }
    public bool IsEnumMember { get; }
    public ReferenceKind ReferenceKind { get; }
    public bool IsReadonly { get; }
    public EnumMember(ICompiledEntity element, IReflectionBuilder builder, IMetadataField entity);
    public sealed virtual IType get_Type();
    public sealed virtual ConstantValue get_ConstantValue();
    public sealed virtual bool get_IsRequired();
    public sealed virtual Nullable`1<int> get_FixedBufferSize();
    public virtual DeclaredElementType GetElementType();
    public sealed virtual bool get_IsField();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsEnumMember();
    public sealed virtual ReferenceKind get_ReferenceKind();
    public virtual bool get_IsReadonly();
    public virtual void Dump(TextWriter writer, string indent);
    protected virtual Hash CalculateHashInternal();
}
internal class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.EnumMemberPropertiesProvider : object {
    public static EnumMemberPropertiesProvider Instance;
    private static EnumMemberPropertiesProvider();
    [NotNullAttribute]
public string GetMemberName(IMetadataField entity);
    public MemberDecoration GetMemberDecoration(IMetadataField entity);
}
internal class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.Event : Member {
    [CanBeNullAttribute]
private ReflectionType myDelegateName;
    [CanBeNullAttribute]
private ReflectionType myInterfaceQualification;
    [CanBeNullAttribute]
private Accessor myAdder;
    [CanBeNullAttribute]
private Accessor myRemover;
    [CanBeNullAttribute]
private Accessor myRaiser;
    [CanBeNullAttribute]
private Field myBackingField;
    public bool IsExplicitImplementation { get; }
    public bool IsExplicitImplementationByName { get; }
    public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    public IType Type { get; }
    public IAccessor Adder { get; }
    public IAccessor Remover { get; }
    public IAccessor Raiser { get; }
    public bool IsFieldLikeEvent { get; }
    public IField BackingField { get; }
    public bool CanBeImplicitImplementation { get; }
    public bool IsReadonly { get; }
    public Event(CompiledTypeElement element, IReflectionBuilder builder, IMetadataEvent event, CompiledTypeElementFactory ownerFactory, Field backingField);
    public sealed virtual bool get_IsExplicitImplementation();
    public sealed virtual bool get_IsExplicitImplementationByName();
    public sealed virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    private void CollectExplicitImplementation(IExplicitImplementation implementation, string prefix, JetHashSet`1<IExplicitImplementation> result);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual IType get_Type();
    public sealed virtual IAccessor get_Adder();
    public sealed virtual IAccessor get_Remover();
    public sealed virtual IAccessor get_Raiser();
    public sealed virtual bool get_IsFieldLikeEvent();
    public sealed virtual IField get_BackingField();
    public sealed virtual bool get_CanBeImplicitImplementation();
    public virtual bool get_IsReadonly();
    public virtual void Dump(TextWriter writer, string indent);
    protected virtual Hash CalculateHashInternal();
}
internal class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.EventPropertiesProvider : object {
    [NotNullAttribute]
public static EventPropertiesProvider Instance;
    private static EventPropertiesProvider();
    [NotNullAttribute]
public string GetMemberName(IMetadataEvent entity);
    public MemberDecoration GetMemberDecoration(IMetadataEvent entity);
}
internal class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.Field : FieldBase {
    private static IClrTypeName ourFixedSizeBufferCLRName;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    public bool IsField { get; }
    public bool IsConstant { get; }
    public bool IsRequired { get; }
    public ConstantValue ConstantValue { get; }
    public IType Type { get; }
    public Nullable`1<int> FixedBufferSize { get; }
    public Field(ICompiledEntity element, IReflectionBuilder builder, IMetadataField field);
    private static Field();
    public virtual DeclaredElementType GetElementType();
    public virtual bool get_IsField();
    public virtual bool get_IsConstant();
    [CompilerGeneratedAttribute]
public virtual bool get_IsRequired();
    public virtual ConstantValue get_ConstantValue();
    public virtual IType get_Type();
    public virtual Nullable`1<int> get_FixedBufferSize();
    [PureAttribute]
private bool GetFixedSizeBufferParameters(IType& type, Int32& size);
    public virtual void Dump(TextWriter writer, string indent);
}
internal class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.FieldPropertiesProvider : FieldBasePropertiesProvider {
    [NotNullAttribute]
public static FieldPropertiesProvider Instance;
    private static FieldPropertiesProvider();
    public virtual MemberDecoration GetMemberDecoration(IMetadataField entity);
}
public interface JetBrains.ReSharper.Psi.impl.reflection2.elements.Compiled.ICompiledOverridableMember {
    public bool IsExplicitImplementationByName { get; }
    public abstract virtual bool get_IsExplicitImplementationByName();
}
public class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.Interface : MemberOwner {
    private MemberPresenceFlag myMemberPresenceFlags;
    public IEnumerable`1<IConstructor> Constructors { get; }
    public Interface(ICompiledEntity parent, IReflectionBuilder builder, IMetadataTypeInfo info);
    public virtual IList`1<IDeclaredType> GetSuperTypes();
    public virtual MemberPresenceFlag GetMemberPresenceFlag();
    public virtual DeclaredElementType GetElementType();
    public virtual IEnumerable`1<IConstructor> get_Constructors();
    public virtual void Dump(TextWriter writer, string indent);
}
public class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.InterfaceFactory : CompiledTypeElementFactory {
    [NotNullAttribute]
public static InterfaceFactory Instance;
    private static InterfaceFactory();
    public virtual CompiledTypeElement Create(ICompiledEntity parent, IReflectionBuilder builder, IMetadataTypeInfo info);
}
public class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.Method : MethodBase {
    private TypeParameter[] myTypeParameters;
    private MethodFlags myMethodFlags;
    public ISubstitution IdSubstitution { get; }
    public IList`1<IParameter> Parameters { get; }
    public bool IsExplicitImplementation { get; }
    public bool IsExplicitImplementationByName { get; }
    public bool CanBeImplicitImplementation { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public bool IsAsync { get; }
    public bool IsVarArg { get; }
    public bool IsIterator { get; }
    public bool IsExtensionMethod { get; }
    public bool IsReadonly { get; }
    public ExtensionMemberKind Kind { get; }
    private IPsiModule JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.IExtensionMemberProxy.PsiModule { get; }
    public Method(CompiledTypeElement element, IReflectionBuilder builder, IMetadataMethod method, bool canBeIterator, CompiledTypeElementFactory ownerFactory);
    public virtual ISubstitution get_IdSubstitution();
    public virtual IList`1<IParameter> get_Parameters();
    public sealed virtual bool get_IsExplicitImplementation();
    public sealed virtual bool get_IsExplicitImplementationByName();
    public sealed virtual bool GetExtendedTypePattern(CompiledCandidateType& candidateType);
    public virtual DeclaredElementType GetElementType();
    public sealed virtual bool get_CanBeImplicitImplementation();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public sealed virtual bool get_IsAsync();
    public sealed virtual bool get_IsVarArg();
    public virtual bool get_IsIterator();
    public sealed virtual bool get_IsExtensionMethod();
    public virtual bool get_IsReadonly();
    [CanBeNullAttribute]
public static string IsIteratorNestedTypeName(IMetadataTypeInfo nestedType);
    public virtual void Dump(TextWriter writer, string indent);
    protected virtual Hash CalculateHashInternal();
    private sealed virtual override HybridCollection`1<ITypeMember> JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.IExtensionMemberProxy.FindExtensionMember();
    public sealed virtual ExtensionMemberKind get_Kind();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.IExtensionMemberProxy.get_PsiModule();
    private sealed virtual override IPsiSourceFile JetBrains.ReSharper.Psi.ExtensionsAPI.Caches2.ExtensionMethods.IExtensionMemberProxy.TryGetSourceFile();
}
internal class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.MethodPropertiesProvider : MethodBasePropertiesProvider {
    [NotNullAttribute]
public static MethodPropertiesProvider Instance;
    private static MethodPropertiesProvider();
    public MemberDecoration GetMemberDecoration(IMetadataMethod entity);
}
internal abstract class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.Operator : MethodBase {
    [CompilerGeneratedAttribute]
private bool <IsExplicitImplementation>k__BackingField;
    public bool IsStatic { get; }
    public bool IsChecked { get; }
    public bool IsExplicitImplementation { get; }
    public bool CanBeImplicitImplementation { get; }
    protected Operator(ICompiledEntity element, IReflectionBuilder builder, IMetadataMethod method, CompiledTypeElementFactory ownerFactory);
    public virtual string ToString();
    public virtual bool get_IsStatic();
    public abstract virtual bool get_IsChecked();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsExplicitImplementation();
    public sealed virtual bool get_CanBeImplicitImplementation();
    public virtual void Dump(TextWriter writer, string indent);
    protected virtual Hash CalculateHashInternal();
}
internal class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.OperatorPropertiesProvider : MethodBasePropertiesProvider {
    [NotNullAttribute]
public static OperatorPropertiesProvider Instance;
    private static OperatorPropertiesProvider();
    public MemberDecoration GetMemberDecoration(IMetadataEntity entity);
}
public class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.Parameter : CompiledElementBase {
    private string myName;
    private ParameterFlags myFlags;
    [CanBeNullAttribute]
private ReflectionType myType;
    private ConstantSpecification myDefaultValue;
    private Nullable`1<ScopedKind> myScope;
    [CanBeNullAttribute]
internal ReflectionType ReflectionType { get; }
    public string ShortName { get; }
    public ISubstitution IdSubstitution { get; }
    public IType Type { get; }
    public ParameterKind Kind { get; }
    public bool IsParams { get; }
    public bool IsParameterArray { get; }
    public bool IsParameterCollection { get; }
    public bool IsOptional { get; }
    public bool IsVarArg { get; }
    public ScopedKind Scope { get; }
    [NotNullAttribute]
public IParametersOwner ContainingParametersOwner { get; }
    public bool IsValueVariable { get; }
    private int Index { get; }
    public bool HasExplicitDefaultValue { get; }
    public Parameter(ICompiledEntity parent, IReflectionBuilder builder, IMetadataParameter parameter);
    internal ReflectionType get_ReflectionType();
    public sealed virtual string get_ShortName();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual DeclaredElementType GetElementType();
    public virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual IType get_Type();
    public sealed virtual ParameterKind get_Kind();
    public sealed virtual bool get_IsParams();
    public sealed virtual bool get_IsParameterArray();
    public sealed virtual bool get_IsParameterCollection();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual ScopedKind get_Scope();
    public sealed virtual DefaultValue GetDefaultValue();
    public sealed virtual IParametersOwner get_ContainingParametersOwner();
    public sealed virtual bool get_IsValueVariable();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual string ToString();
    public virtual void Dump(TextWriter writer, string indent);
    public sealed virtual bool IsSynthetic();
    public Hash AddToHash(Hash hash);
    protected virtual IEnumerable`1<IAttributeInstance> BuildAttributeInstances();
    protected virtual bool HasAttributeInstance(IClrTypeName qualifiedTypeName);
    private int get_Index();
    public bool get_HasExplicitDefaultValue();
    public sealed virtual bool Equals(Parameter other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.Property : Member {
    [CanBeNullAttribute]
private ReflectionType myTypeName;
    [CanBeNullAttribute]
private ReflectionType myInterfaceQualification;
    [CanBeNullAttribute]
private Accessor myGetter;
    [CanBeNullAttribute]
private Accessor mySetter;
    [CanBeNullAttribute]
private Field myBackingField;
    private ReferenceKind myReturnKind;
    private Nullable`1<bool> myIsDefault;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    public bool IsExplicitImplementation { get; }
    public bool IsExplicitImplementationByName { get; }
    public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    public bool IsAuto { get; }
    public IField BackingField { get; }
    public bool IsDefault { get; }
    public bool IsRequired { get; }
    public MemberHidePolicy HidePolicy { get; }
    public IList`1<IParameter> Parameters { get; }
    public IAccessor Getter { get; }
    public IAccessor Setter { get; }
    public bool IsWritable { get; }
    public bool IsReadable { get; }
    public bool CanBeImplicitImplementation { get; }
    public IType Type { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public bool IsReadonly { get; }
    public Property(CompiledTypeElement parent, IReflectionBuilder builder, IMetadataProperty property, CompiledTypeElementFactory ownerFactory, Field backingField, bool canBeIterator);
    public sealed virtual bool get_IsExplicitImplementation();
    public sealed virtual bool get_IsExplicitImplementationByName();
    public sealed virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    private void CollectExplicitImplementation(IExplicitImplementation implementation, string prefix, JetHashSet`1<IExplicitImplementation> result);
    public sealed virtual bool get_IsAuto();
    public sealed virtual IField get_BackingField();
    public sealed virtual bool get_IsDefault();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRequired();
    public sealed virtual string GetDefaultPropertyMetadataName();
    private bool CalcIsDefault();
    public virtual MemberHidePolicy get_HidePolicy();
    public virtual DeclaredElementType GetElementType();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual IAccessor get_Getter();
    public sealed virtual IAccessor get_Setter();
    public sealed virtual bool get_IsWritable();
    public sealed virtual bool get_IsReadable();
    public sealed virtual bool get_CanBeImplicitImplementation();
    public sealed virtual IType get_Type();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public virtual bool get_IsReadonly();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public virtual string ToString();
    public virtual void Dump(TextWriter writer, string indent);
    protected virtual Hash CalculateHashInternal();
}
internal class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.PropertyPropertiesProvider : object {
    [NotNullAttribute]
public static PropertyPropertiesProvider Instance;
    private static PropertyPropertiesProvider();
    public string GetMemberName(IMetadataProperty entity);
    public MemberDecoration GetMemberDecoration(IMetadataProperty property);
}
internal class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.ReturnValue : CompiledElementBase {
    [CanBeNullAttribute]
private ReflectionType myReturnType;
    private ReferenceKind myReturnKind;
    private MethodBase myOwner;
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public ReturnValue(MethodBase owner, IReflectionBuilder builder, IMetadataReturnValue value);
    public IType get_ReturnType();
    public ReferenceKind get_ReturnKind();
    private static IAttributesSet GetReturnTypeAttributes(IOverridableMember member);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    protected virtual IEnumerable`1<IAttributeInstance> BuildAttributeInstances();
    public virtual void Dump(TextWriter writer, string indent);
    public Hash AddToHash(Hash hash);
    public sealed virtual bool Equals(ReturnValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.SignOperator : Operator {
    private string mySign;
    public string ShortName { get; }
    public bool IsChecked { get; }
    public bool IsIterator { get; }
    public SignOperator(ICompiledEntity element, IReflectionBuilder builder, IMetadataMethod method, string sign, CompiledTypeElementFactory ownerFactory);
    public virtual string get_ShortName();
    public virtual bool get_IsChecked();
    public virtual DeclaredElementType GetElementType();
    public virtual bool get_IsIterator();
    public virtual void Dump(TextWriter writer, string indent);
    protected virtual Hash CalculateHashInternal();
    public static bool IsCheckedOperatorName(string name);
}
public class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.Struct : MemberOwner {
    private MemberPresenceFlag myMemberPresenceFlags;
    public IEnumerable`1<IConstructor> Constructors { get; }
    public bool HasHiddenInstanceFields { get; }
    public bool HasCustomParameterlessConstructor { get; }
    public bool IsReadonly { get; }
    public bool IsByRefLike { get; }
    public Struct(ICompiledEntity parent, IReflectionBuilder builder, IMetadataTypeInfo info);
    public virtual IEnumerable`1<IConstructor> get_Constructors();
    public virtual MemberPresenceFlag GetMemberPresenceFlag();
    public sealed virtual bool get_HasHiddenInstanceFields();
    public sealed virtual bool get_HasCustomParameterlessConstructor();
    public virtual bool get_IsReadonly();
    public sealed virtual bool get_IsByRefLike();
    public virtual DeclaredElementType GetElementType();
    public virtual void Dump(TextWriter writer, string indent);
}
public class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.StructFactory : CompiledTypeElementFactory {
    public static StructFactory Instance;
    private static StructFactory();
    public virtual CompiledTypeElement Create(ICompiledEntity parent, IReflectionBuilder builder, IMetadataTypeInfo info);
    public virtual MemberDecoration GetDecoration(IMetadataTypeInfo info);
}
internal class JetBrains.ReSharper.Psi.Impl.reflection2.elements.Compiled.TypeParameter : CompiledElementBase {
    [NotNullAttribute]
private string myName;
    [NotNullAttribute]
private ReflectionType[] myTypeConstraints;
    [NotNullAttribute]
[ItemCanBeNullAttribute]
private IList`1[] myTypeConstraintAttributes;
    private TypeParameterFlags myTypeParameterFlags;
    public ISubstitution IdSubstitution { get; }
    public int Index { get; }
    public TypeParameterVariance Variance { get; }
    private TypeParameterConstraintFlags ConstraintFlags { get; }
    public bool IsValueType { get; }
    public bool IsReferenceType { get; }
    public bool IsUnmanagedType { get; }
    public bool HasDefaultConstructor { get; }
    public bool IsNotNullableValueOrReferenceType { get; }
    public bool AllowsByRefLikeType { get; }
    public TypeParameterNullability Nullability { get; }
    public bool HasTypeConstraints { get; }
    public IList`1<IType> TypeConstraints { get; }
    public TypeParameterConstraintFlags Constraints { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public IList`1<ITypeElement> NestedTypes { get; }
    public IEnumerable`1<IField> Constants { get; }
    public IEnumerable`1<IField> Fields { get; }
    public IEnumerable`1<IConstructor> Constructors { get; }
    public IEnumerable`1<IOperator> Operators { get; }
    public IEnumerable`1<IMethod> Methods { get; }
    public IEnumerable`1<IProperty> Properties { get; }
    public IEnumerable`1<IEvent> Events { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public string ShortName { get; }
    public ITypeElement OwnerType { get; }
    public IParametersOwner OwnerFunction { get; }
    public IMethod OwnerMethod { get; }
    [NotNullAttribute]
public ITypeParametersOwner Owner { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public TypeParameter(ICompiledEntity element, IReflectionBuilder builder, IMetadataTypeParameter typeParameter, int localIndex);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual int get_Index();
    public sealed virtual IClrTypeName GetClrName();
    public sealed virtual TypeParameterVariance get_Variance();
    private TypeParameterConstraintFlags get_ConstraintFlags();
    private void ComputeConstraintFlags();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsUnmanagedType();
    public sealed virtual bool get_HasDefaultConstructor();
    public sealed virtual bool get_IsNotNullableValueOrReferenceType();
    public sealed virtual bool get_AllowsByRefLikeType();
    public sealed virtual TypeParameterNullability get_Nullability();
    public sealed virtual TypeParameterNullability GetNullability(ISubstitution explicitInheritorSubstitution);
    public sealed virtual bool get_HasTypeConstraints();
    public sealed virtual IList`1<IType> get_TypeConstraints();
    [NotNullAttribute]
[MustUseReturnValueAttribute]
private IList`1<IType> ComputeTypeConstraints();
    public sealed virtual TypeParameterConstraintFlags get_Constraints();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    public sealed virtual IList`1<IDeclaredType> GetSuperTypes();
    public sealed virtual IList`1<ITypeElement> GetSuperTypeElements();
    public sealed virtual IEnumerable`1<ITypeMember> GetMembers();
    public sealed virtual IList`1<ITypeElement> get_NestedTypes();
    public sealed virtual IEnumerable`1<IField> get_Constants();
    public sealed virtual IEnumerable`1<IField> get_Fields();
    public sealed virtual IEnumerable`1<IConstructor> get_Constructors();
    public sealed virtual IEnumerable`1<IOperator> get_Operators();
    public sealed virtual IEnumerable`1<IMethod> get_Methods();
    public sealed virtual IEnumerable`1<IProperty> get_Properties();
    public sealed virtual IEnumerable`1<IEvent> get_Events();
    public sealed virtual MemberPresenceFlag GetMemberPresenceFlag();
    public sealed virtual INamespace GetContainingNamespace();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual string get_ShortName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual ITypeElement get_OwnerType();
    public sealed virtual IParametersOwner get_OwnerFunction();
    public sealed virtual IMethod get_OwnerMethod();
    public sealed virtual ITypeParametersOwner get_Owner();
    public sealed virtual bool HasMemberWithName(string shortName, bool ignoreCase);
    public sealed virtual IEnumerable`1<string> get_MemberNames();
    public virtual void Dump(TextWriter writer, string indent);
    public sealed virtual bool IsSynthetic();
    public Hash AddToHash(Hash hash);
    protected virtual IEnumerable`1<IAttributeInstance> BuildAttributeInstances();
    protected virtual bool HasAttributeInstance(IClrTypeName qualifiedTypeName);
    public sealed virtual IPsiSourceFile GetSingleOrDefaultSourceFile();
    public sealed virtual bool Equals(TypeParameter other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class JetBrains.ReSharper.Psi.impl.reflection2.elements.EmptyAttributesArray : object {
    [NotNullAttribute]
private static IList`1[] ourArray00;
    [NotNullAttribute]
private static IList`1[] ourArray01;
    [NotNullAttribute]
private static IList`1[] ourArray02;
    [NotNullAttribute]
private static IList`1[] ourArray03;
    [NotNullAttribute]
private static IList`1[] ourArray04;
    [NotNullAttribute]
private static IList`1[] ourArray05;
    [NotNullAttribute]
private static IList`1[] ourArray06;
    [NotNullAttribute]
private static IList`1[] ourArray07;
    [NotNullAttribute]
private static IList`1[] ourArray08;
    [NotNullAttribute]
private static IList`1[] ourArray09;
    [NotNullAttribute]
private static IList`1[] ourArray10;
    [NotNullAttribute]
private static IList`1[] ourArray11;
    [NotNullAttribute]
private static IList`1[] ourArray12;
    [NotNullAttribute]
private static IList`1[] ourArray13;
    [NotNullAttribute]
private static IList`1[] ourArray14;
    [NotNullAttribute]
private static IList`1[] ourArray15;
    [NotNullAttribute]
private static IList`1[] ourArray16;
    private static EmptyAttributesArray();
    [PureAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public static IList`1[] Get(int length);
    [CompilerGeneratedAttribute]
internal static IList`1[] <Get>g__Init|0_0(IList`1[] array);
}
public class JetBrains.ReSharper.Psi.Impl.Reflection2.EnumFactory : CompiledTypeElementFactory {
    public static EnumFactory Instance;
    private static EnumFactory();
    public virtual CompiledTypeElement Create(ICompiledEntity parent, IReflectionBuilder builder, IMetadataTypeInfo info);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.AnnotationCollection`1 : ValueType {
    private static List`1<T> ourOneItemList;
    private T myItem;
    private IList`1<T> myItems;
    public int Count { get; }
    public T Item { get; }
    private AnnotationCollection`1(T item);
    public AnnotationCollection`1(int capacity);
    private AnnotationCollection`1(IList`1<T> items);
    private static AnnotationCollection`1();
    public int get_Count();
    public T get_Item(int index);
    [PureAttribute]
public AnnotationCollection`1<T> AddInplace(T item);
    public void CopyTo(LocalList`1& localList);
    [NullableContextAttribute("0")]
[PureAttribute]
public Enumerator<T> GetEnumerator();
    [PureAttribute]
public static IUnsafeMarshaller`1<AnnotationCollection`1<T>> GetMarshaller(IUnsafeMarshaller`1<T> itemMarshaller);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.AnnotationCollectionEx : object {
    [ExtensionAttribute]
public static AnnotationCollection`1<T> ReadCollection(UnsafeReader reader, ReadDelegate`1<T> readDelegate);
    [ExtensionAttribute]
public static void WriteCollection(UnsafeWriter writer, WriteDelegate`1<T> writeDelegate, AnnotationCollection`1<T> value);
}
[SolutionComponentAttribute("4")]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.AnnotationsIndex : object {
    private long myCurrentIndex;
    [NotNullAttribute]
private LexerTokenIntern myIntern;
    [NotNullAttribute]
private OptimizedPersistentSortedMap`2<VirtualFileSystemPath, AnnotationFileInfo> myFileInfoCache;
    [NotNullAttribute]
private OptimizedPersistentSortedMap`2<int, long> myFileIndexMap;
    [NotNullAttribute]
private OptimizedPersistentSortedMap`2<AnnotationMemberKey, AnnotationCollection`1<MemberAnnotation>> myMemberAnnotation;
    [NotNullAttribute]
private OptimizedPersistentSortedMap`2<AnnotationMemberKey, AnnotationCollection`1<ReturnValueAnnotation>> myReturnValueAnnotation;
    [NotNullAttribute]
private OptimizedPersistentSortedMap`2<AnnotationMemberKey, AnnotationCollection`1<AssemblyAnnotation>> myAssemblyAnnotations;
    [NotNullAttribute]
private OptimizedPersistentSortedMap`2<AnnotationMemberKey, AnnotationCollection`1<ParameterAnnotation>> myParameterAnnotations;
    [NotNullAttribute]
private OptimizedPersistentSortedMap`2<AnnotationMemberKey, AnnotationCollection`1<TypeParameterAnnotation>> myTypeParameterAnnotations;
    [NotNullAttribute]
private OptimizedPersistentSortedMap`2<long, PersistentAnnotationsEssentials> myFileToPersistentAnnotationsEssentials;
    [NotNullAttribute]
private ExternalAnnotationsAttributesToWatchers myWatchers;
    [NotNullAttribute]
private ILogger myLogger;
    [NotNullAttribute]
private ConcurrentDictionary`2<VirtualFileSystemPath, object> myBuildingItemsMonitors;
    public AnnotationsIndex(ShellCaches shellCaches, ExternalAnnotationsAttributesToWatchers watchers, ILogger logger, Lifetime lifetime);
    private void RunInitTimestamps();
    private PersistentAnnotationsEssentials GetEssentials(VirtualFileSystemPath path, Func`2<string, bool> check);
    private AnnotationFileInfo NextFileInfo(VirtualFileSystemPath path);
    public JetHashSet`1<string> AllAttributeNames(List`1<VirtualFileSystemPath> paths, Func`2<string, bool> check);
    public void ConsumeAttributes(List`1<VirtualFileSystemPath> paths, AnnotatedEntitiesSet annotatedEntitiesSet, Func`2<string, bool> check);
    private long FileTimestamp(VirtualFileSystemPath file);
    public AnnotationFileInfo EnsureFileUpdated(VirtualFileSystemPath path, Func`2<string, bool> assemblyNameCheck);
    private AnnotationFileInfo SyncBuildIndex(VirtualFileSystemPath path, Func`2<string, bool> assemblyNameCheck, object monitor);
    private void UpdateCaches(AnnotationFileInfo info, PersistentAnnotations persistentAnnotations);
    public IList`1<AssemblyAnnotation> GetAttributesForAssembly(List`1<VirtualFileSystemPath> paths, Func`2<string, bool> assemblyNameCheck);
    public IList`1<MemberAnnotation> GetAttributesForMember(string xmlDocId, List`1<VirtualFileSystemPath> paths, Func`2<string, bool> assemblyNameCheck);
    public IList`1<ReturnValueAnnotation> GetAttributesForMemberReturnValue(string xmlDocId, List`1<VirtualFileSystemPath> paths, Func`2<string, bool> assemblyNameCheck);
    public IList`1<ParameterAnnotation> GetAttributesForParameter(string xmlDocId, List`1<VirtualFileSystemPath> paths, Func`2<string, bool> assemblyNameCheck);
    public IList`1<TypeParameterAnnotation> GetAttributesForTypeParameter(string xmlDocId, List`1<VirtualFileSystemPath> paths, Func`2<string, bool> assemblyNameCheck);
    private IList`1<TAnnotation> GetAttributes(string xmlDocId, List`1<VirtualFileSystemPath> paths, IDictionary`2<AnnotationMemberKey, AnnotationCollection`1<TAnnotation>> map, Func`2<string, bool> assemblyNameCheck);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.AnnotationsIndexBuilder : object {
    private LexerTokenIntern myAttributeXmlDotIdIntern;
    private Func`2<string, bool> myAssemblyNameCheck;
    [CompilerGeneratedAttribute]
private PersistentAnnotations <PersistentAnnotations>k__BackingField;
    public PersistentAnnotations PersistentAnnotations { get; }
    public AnnotationsIndexBuilder(LexerTokenIntern attributeXmlDotIdIntern, Func`2<string, bool> assemblyNameCheck);
    [CompilerGeneratedAttribute]
public PersistentAnnotations get_PersistentAnnotations();
    public bool BuildIndexForFile(VirtualFileSystemPath filePath);
    private bool BuildIndexForFile(XmlReader lexer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.AssemblyAnnotation : ValueType {
    public AttributeInstance AttributeInstance;
    public static IUnsafeMarshaller`1<AssemblyAnnotation> Marshaller;
    public AssemblyAnnotation(AttributeInstance attributeInstance);
    private static AssemblyAnnotation();
}
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.AssemblyExternalAnnotations : object {
    private AssemblyNameInfo myAssemblyName;
    private AnnotationsIndex myIndex;
    private List`1<VirtualFileSystemPath> myPaths;
    private Lazy`1<JetHashSet`1<string>> myAllAttributeNames;
    private Func`2<string, bool> myAssemblyNameCheck;
    [CompilerGeneratedAttribute]
private IPsiModule <HostModule>k__BackingField;
    private IList`1<AssemblyAnnotation> myAssemblyAttributes;
    private ConcurrentDictionary`2<string, IList`1<MemberAnnotation>> myAttributesForMembers;
    private ConcurrentDictionary`2<string, IList`1<ReturnValueAnnotation>> myReturnValueAnnotations;
    private ConcurrentDictionary`2<string, IList`1<ParameterAnnotation>> myParameterAnnotations;
    private ConcurrentDictionary`2<string, IList`1<TypeParameterAnnotation>> myTypeParameterAnnotations;
    public IPsiModule HostModule { get; }
    public long Timestamp { get; }
    public bool IsEmpty { get; }
    public AssemblyExternalAnnotations(AssemblyNameInfo assemblyName, VirtualFileSystemPath assemblyLocation, IPsiModule module, AnnotationsIndex annotationsIndex, ExternalAnnotationsManager externalAnnotationsManager);
    [CompilerGeneratedAttribute]
public IPsiModule get_HostModule();
    public void ContributeToAnnotatedEntitiesSet(AnnotatedEntitiesSet annotatedEntitiesSet);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.AssemblyExternalAnnotations/<EnsureUpdated>d__15")]
private IEnumerable`1<AnnotationFileInfo> EnsureUpdated();
    public long get_Timestamp();
    public bool ContainsAnnotation(string clrTypeName);
    public bool ContainsAnyAnnotation(IEnumerable`1<string> clrTypeNames);
    private bool AssemblyNameCheckPredicate(string assemblyName, AssemblyNameInfo expectedAssemblyName);
    public bool get_IsEmpty();
    public IList`1<IAttributeInstance> GetAttributesForAssembly();
    public IList`1<IAttributeInstance> GetAttributesForMember(string xmlDocId);
    public IList`1<IAttributeInstance> GetAttributesForReturnValue(string xmlDocId);
    public IList`1<IAttributeInstance> GetAttributesForParameter(string xmlDocId, string paramName);
    public IList`1<IAttributeInstance> GetAttributesForTypeParameter(string xmlDocId, string paramName);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__13_0(string info);
    [CompilerGeneratedAttribute]
private JetHashSet`1<string> <.ctor>b__13_1();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__13_2(string info);
    [CompilerGeneratedAttribute]
private bool <ContributeToAnnotatedEntitiesSet>b__14_0(string info);
    [CompilerGeneratedAttribute]
private bool <EnsureUpdated>b__15_0(string assemblyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.AttributeInstance : object {
    protected static byte UniqueAttributeMarker;
    protected static IUnsafeMarshaller`1<IList`1<AttributeInstancePositionalArgument>> PositionalArgumentsMarshaller;
    protected static IUnsafeMarshaller`1<IList`1<AttributeInstancePropertyArgument>> PropertyArgumentsMarshaller;
    [CompilerGeneratedAttribute]
private string <CtorXmlDocId>k__BackingField;
    public static IUnsafeMarshaller`1<AttributeInstance> Marshaller;
    public string CtorXmlDocId { get; }
    protected AttributeInstance(string ctorXmlDocId);
    private static AttributeInstance();
    [CompilerGeneratedAttribute]
public string get_CtorXmlDocId();
    protected abstract virtual void Serialize(UnsafeWriter writer);
    public abstract virtual IList`1<ArgumentValue> GetPositionalArguments(AssemblyExternalAnnotations assembly);
    public abstract virtual IList`1<KeyValuePair`2<string, ArgumentValue>> GetPropertyArguments(AssemblyExternalAnnotations assembly);
    public static AttributeInstance Create(string ctorXmlDocId, IList`1<AttributeInstancePositionalArgument> positionalArguments, IList`1<AttributeInstancePropertyArgument> propertyArguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.AttributeInstancePositionalArgument : ValueType {
    public static IUnsafeMarshaller`1<AttributeInstancePositionalArgument> Marshaller;
    public object Value;
    private static DataIntern`1<string> ourValueIntern;
    public AttributeInstancePositionalArgument(object value);
    private static AttributeInstancePositionalArgument();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.AttributeInstancePropertyArgument : ValueType {
    public static IUnsafeMarshaller`1<AttributeInstancePropertyArgument> Marshaller;
    public string Name;
    public object Value;
    public AttributeInstancePropertyArgument(string name, object value);
    private static AttributeInstancePropertyArgument();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.CommonAttributeInstance : AttributeInstance {
    private static string NotNullDocId;
    private static string CanBeNullDocId;
    private static string PureDocId;
    private static string LocalizationRequiredDocId;
    private static CommonAttributeInstance ourNotNull;
    private static CommonAttributeInstance ourCanBeNull;
    private static CommonAttributeInstance ourPure;
    private static ParametrizedCommonAttributeInstance ourLocalizationRequiredFalse;
    private static ParametrizedCommonAttributeInstance ourLocalizationRequiredTrue;
    private AttributeKind myKind;
    protected CommonAttributeInstance(AttributeKind kind);
    private static CommonAttributeInstance();
    public static CommonAttributeInstance Get(byte kind);
    private static CommonAttributeInstance Get(AttributeKind kind);
    [NullableContextAttribute("2")]
public static CommonAttributeInstance TryGet(string ctorXmlDocId, IList`1<AttributeInstancePositionalArgument> positionalArguments);
    private static Nullable`1<AttributeKind> TryGetKind(string ctorXmlDocId, IList`1<AttributeInstancePositionalArgument> positionalArguments);
    private static string GetXmlDocId(AttributeKind kind);
    protected virtual void Serialize(UnsafeWriter writer);
    public virtual IList`1<ArgumentValue> GetPositionalArguments(AssemblyExternalAnnotations assembly);
    public virtual IList`1<KeyValuePair`2<string, ArgumentValue>> GetPropertyArguments(AssemblyExternalAnnotations assembly);
    [CompilerGeneratedAttribute]
internal static Nullable`1<AttributeKind> <TryGetKind>g__GetLocalizationRequired|15_0(<>c__DisplayClass15_0& );
}
[ShellComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.EmbeddedExternalAnnotationsFileProvider : object {
    private SequentialLifetimes mySequentialLifetimes;
    private ExternalAnnotationsFileProvider myExternalAnnotationsFileProvider;
    public EmbeddedExternalAnnotationsFileProvider(Lifetime lifetime, ProductSettingsLocation productSettingsLocation, ExternalAnnotationsFileProvider externalAnnotationsFileProvider);
    protected void Init(VirtualFileSystemPath fileSystemPath);
}
[ShellComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.ExtensionsExternalAnnotationsFileProvider : object {
    private static string AnnotationsFolderName;
    private OneToSetMap`2<string, VirtualFileSystemPath> myAnnotations;
    public ExtensionsExternalAnnotationsFileProvider(ApplicationPackagesFiles applicationPackagesFiles);
    public sealed virtual IEnumerable`1<VirtualFileSystemPath> GetAnnotationsFiles(AssemblyNameInfo assemblyName, VirtualFileSystemPath assemblyLocation);
}
[LocalizationRequiredAttribute("False")]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.ExternalAnnotationAttributeInstance : object {
    [NotNullAttribute]
private AssemblyExternalAnnotations myAssembly;
    [NotNullAttribute]
private string myConstructorXmlId;
    [NotNullAttribute]
private IList`1<ArgumentValue> myPositionalArguments;
    [NotNullAttribute]
private IList`1<KeyValuePair`2<string, ArgumentValue>> myNamedArguments;
    [NotNullAttribute]
private IPsiModule Module { get; }
    public IConstructor Constructor { get; }
    public int PositionParameterCount { get; }
    public int NamedParameterCount { get; }
    public ExternalAnnotationAttributeInstance(AssemblyExternalAnnotations assembly, AttributeInstance assemblyAnnotation);
    private IPsiModule get_Module();
    [NotNullAttribute]
private IPsiServices GetPsiServices();
    public sealed virtual IClrTypeName GetClrName();
    public sealed virtual string GetAttributeShortName();
    private int FindFqnEndPosition(int start);
    public sealed virtual IDeclaredType GetAttributeType();
    public sealed virtual IConstructor get_Constructor();
    public sealed virtual int get_PositionParameterCount();
    public sealed virtual AttributeValue PositionParameter(int paramIndex);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.ExternalAnnotationAttributeInstance/<PositionParameters>d__17")]
public sealed virtual IEnumerable`1<AttributeValue> PositionParameters();
    public sealed virtual int get_NamedParameterCount();
    public sealed virtual AttributeValue NamedParameter(string name);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.ExternalAnnotationAttributeInstance/<NamedParameters>d__21")]
public sealed virtual IEnumerable`1<Pair`2<string, AttributeValue>> NamedParameters();
    [NotNullAttribute]
private AttributeValue GetAttributeValue(ArgumentValue value, IType type);
    [NotNullAttribute]
private AttributeValue ParseSimpleAttributeValue(string value, IType type);
    [CanBeNullAttribute]
private ConstantValue ParseEnumValue(IDeclaredType type, string value);
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.ExternalAnnotationsAttributesToWatchers : object {
    [CompilerGeneratedAttribute]
private long <ProvidersHash>k__BackingField;
    [CompilerGeneratedAttribute]
private JetHashSet`1<string> <AttributesFullNameToWatch>k__BackingField;
    [CompilerGeneratedAttribute]
private JetHashSet`1<IClrTypeName> <AttributesToWatch>k__BackingField;
    public long ProvidersHash { get; }
    public JetHashSet`1<string> AttributesFullNameToWatch { get; }
    public JetHashSet`1<IClrTypeName> AttributesToWatch { get; }
    public ExternalAnnotationsAttributesToWatchers(IEnumerable`1<IExternalAnnotationsAttributeWatcher> watchers);
    [CompilerGeneratedAttribute]
public long get_ProvidersHash();
    [CompilerGeneratedAttribute]
public JetHashSet`1<string> get_AttributesFullNameToWatch();
    [CompilerGeneratedAttribute]
public JetHashSet`1<IClrTypeName> get_AttributesToWatch();
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.ExternalAnnotationsFileProvider : object {
    public static RelativePath ExternalAnnotationsLocation;
    private ConcurrentDictionary`2<VirtualFileSystemPath, HybridCollection`1<Lazy`1<OneToSetMap`2<string, VirtualFileSystemPath>>>> myAnnotations;
    private static ExternalAnnotationsFileProvider();
    [CanBeNullAttribute]
public Lazy`1<OneToSetMap`2<string, VirtualFileSystemPath>> InitAnnotationsLazy(Lifetime lifetime, VirtualFileSystemPath location);
    private static OneToSetMap`2<string, VirtualFileSystemPath> InitAnnotations(VirtualFileSystemPath location);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.ExternalAnnotationsFileProvider/<JetBrains-ReSharper-Psi-ExtensionsAPI-ExternalAnnotations-IExternalAnnotationsFileProvider-GetAnnotationsFiles>d__4")]
private sealed virtual override IEnumerable`1<VirtualFileSystemPath> JetBrains.ReSharper.Psi.ExtensionsAPI.ExternalAnnotations.IExternalAnnotationsFileProvider.GetAnnotationsFiles(AssemblyNameInfo assemblyName, VirtualFileSystemPath assemblyLocation);
}
[ShellComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.ExternalAnnotationsManager : object {
    private IEnumerable`1<IExternalAnnotationsFileProvider> myExternalAnnotationsFileProviders;
    private AssemblyExistsService myAssemblyExistsService;
    public ExternalAnnotationsManager(AssemblyExistsService assemblyExistsService, IEnumerable`1<IExternalAnnotationsFileProvider> externalAnnotationsFileProviders);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.ExternalAnnotationsManager/<EnumerateExternalAnnotationsFiles>d__3")]
internal IEnumerable`1<VirtualFileSystemPath> EnumerateExternalAnnotationsFiles(AssemblyNameInfo assemblyName, VirtualFileSystemPath assemblyLocation);
}
[PsiModuleFactoryAttribute("10")]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.ExternalAnnotationsModuleFactory : object {
    private ISolution mySolution;
    private ILogger myLogger;
    private IReadOnlyDictionary`2<TargetFrameworkId, VirtualFileSystemPath> myAnnotationFiles;
    private ConcurrentDictionary`2<TargetFrameworkId, IAssemblyPsiModule> myModules;
    [CompilerGeneratedAttribute]
private HybridCollection`1<IPsiModule> <Modules>k__BackingField;
    public HybridCollection`1<IPsiModule> Modules { get; private set; }
    public ExternalAnnotationsModuleFactory(Lifetime lifetime, ISolution solution, ApplicationPackagesFiles applicationPackagesFiles, ChangeManager changeManager, ILogger logger);
    [CompilerGeneratedAttribute]
public sealed virtual HybridCollection`1<IPsiModule> get_Modules();
    [CompilerGeneratedAttribute]
private void set_Modules(HybridCollection`1<IPsiModule> value);
    public void InvalidateCaches();
    private sealed virtual override object JetBrains.Application.changes.IChangeProvider.Execute(IChangeMap changeMap);
    private IAssemblyPsiModule AddModule(TargetFrameworkId targetFrameworkId);
    [CanBeNullAttribute]
public IPsiModule GetPsiModule(TargetFrameworkId targetFrameworkId);
    [CompilerGeneratedAttribute]
private IAssemblyPsiModule <GetPsiModule>b__12_0(TargetFrameworkId id);
}
public interface JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.IExternalAnnotationPsiModule {
}
public interface JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.IExternalAnnotationsAttributeWatcher {
    public IEnumerable`1<IClrTypeName> AttributeClrNamesToWatch { get; }
    public abstract virtual IEnumerable`1<IClrTypeName> get_AttributeClrNamesToWatch();
}
public interface JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.ITagScanner {
    public Func`2<string, bool> Value { get; public set; }
    public Func`1<bool> Enter { get; public set; }
    public Func`1<bool> Exit { get; public set; }
    public Func`1<bool> AttributesDone { get; public set; }
    public abstract virtual Func`2<string, bool> get_Value();
    public abstract virtual void set_Value(Func`2<string, bool> value);
    public abstract virtual Func`1<bool> get_Enter();
    public abstract virtual void set_Enter(Func`1<bool> value);
    public abstract virtual Func`1<bool> get_Exit();
    public abstract virtual void set_Exit(Func`1<bool> value);
    public abstract virtual Func`1<bool> get_AttributesDone();
    public abstract virtual void set_AttributesDone(Func`1<bool> value);
    public abstract virtual void ScanAttribute(string name, LexerTokenIntern intern, Func`2<string, bool> onAttributeValue);
    public abstract virtual void ScanTag(string tagName, Action`1<ITagScanner> tagScanner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.MemberAnnotation : ValueType {
    public string MemberDocId;
    public AttributeInstance AttributeInstance;
    public static IUnsafeMarshaller`1<MemberAnnotation> Marshaller;
    public MemberAnnotation(string memberDocId, AttributeInstance attributeInstance);
    private static MemberAnnotation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.ParameterAnnotation : ValueType {
    public string ParameterName;
    public AttributeInstance AttributeInstance;
    public static IUnsafeMarshaller`1<ParameterAnnotation> Marshaller;
    public ParameterAnnotation(string parameterName, AttributeInstance attributeInstance);
    private static ParameterAnnotation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.PersistentAnnotations : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, AnnotationCollection`1<MemberAnnotation>> <MemberAnnotations>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, AnnotationCollection`1<ReturnValueAnnotation>> <ReturnValueAnnotations>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, AnnotationCollection`1<ParameterAnnotation>> <ParameterAnnotations>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, AnnotationCollection`1<TypeParameterAnnotation>> <TypeParameterAnnotations>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private AnnotationCollection`1<AssemblyAnnotation> <AssemblyAnnotations>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    public static PersistentAnnotations Empty;
    private static Char[] ourXmlDocSuffixes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, AnnotationCollection`1<MemberAnnotation>> MemberAnnotations { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, AnnotationCollection`1<ReturnValueAnnotation>> ReturnValueAnnotations { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, AnnotationCollection`1<ParameterAnnotation>> ParameterAnnotations { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, AnnotationCollection`1<TypeParameterAnnotation>> TypeParameterAnnotations { get; }
    [NullableAttribute("0")]
public AnnotationCollection`1<AssemblyAnnotation> AssemblyAnnotations { get; public set; }
    public string AssemblyName { get; public set; }
    public bool IsEmpty { get; }
    private static PersistentAnnotations();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, AnnotationCollection`1<MemberAnnotation>> get_MemberAnnotations();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, AnnotationCollection`1<ReturnValueAnnotation>> get_ReturnValueAnnotations();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, AnnotationCollection`1<ParameterAnnotation>> get_ParameterAnnotations();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, AnnotationCollection`1<TypeParameterAnnotation>> get_TypeParameterAnnotations();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public AnnotationCollection`1<AssemblyAnnotation> get_AssemblyAnnotations();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public void set_AssemblyAnnotations(AnnotationCollection`1<AssemblyAnnotation> value);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    public bool get_IsEmpty();
    public PersistentAnnotationsEssentials GetPersistentAnnotationsEssentials(ExternalAnnotationsAttributesToWatchers watchers);
    private static string ExtractTypeNameFromId(string docId);
    private static string GetShortNameFromXmlDocId(string xmlDocId);
    private bool TryGetTypeFQNFromXmlDocId(string xmlDocId, String& result);
}
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.PersistentAnnotationsEssentials : object {
    [CompilerGeneratedAttribute]
private List`1<Pair`2<string, string>> <AttributeToMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Pair`2<string, string>> <AttributeToTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Pair`2<string, FullTypeMemberName>> <AttributeToFullTypeMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private JetHashSet`1<string> <UsedAttributeNames>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    public static PersistentAnnotationsEssentials Empty;
    public static IUnsafeMarshaller`1<PersistentAnnotationsEssentials> Marshaller;
    public List`1<Pair`2<string, string>> AttributeToMembers { get; }
    public List`1<Pair`2<string, string>> AttributeToTypes { get; }
    public List`1<Pair`2<string, FullTypeMemberName>> AttributeToFullTypeMembers { get; }
    public JetHashSet`1<string> UsedAttributeNames { get; }
    public string AssemblyName { get; }
    public PersistentAnnotationsEssentials(string assemblyName, List`1<Pair`2<string, string>> attributeToMembers, List`1<Pair`2<string, string>> attributeToTypes, List`1<Pair`2<string, FullTypeMemberName>> attributeToFullTypeMembers, JetHashSet`1<string> usedAttributeNames);
    private static PersistentAnnotationsEssentials();
    [CompilerGeneratedAttribute]
public List`1<Pair`2<string, string>> get_AttributeToMembers();
    [CompilerGeneratedAttribute]
public List`1<Pair`2<string, string>> get_AttributeToTypes();
    [CompilerGeneratedAttribute]
public List`1<Pair`2<string, FullTypeMemberName>> get_AttributeToFullTypeMembers();
    [CompilerGeneratedAttribute]
public JetHashSet`1<string> get_UsedAttributeNames();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.ReturnValueAnnotation : ValueType {
    public AttributeInstance AttributeInstance;
    public static IUnsafeMarshaller`1<ReturnValueAnnotation> Marshaller;
    public ReturnValueAnnotation(AttributeInstance attributeInstances);
    private static ReturnValueAnnotation();
}
[SolutionInstanceComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.SolutionAndProjectsExternalAnnotationsFileProvider : object {
    public SolutionAndProjectsExternalAnnotationsFileProvider(Lifetime lifetime, SolutionFileLocationLive solutionFileLocationLive, IViewableProjectsCollection projectsCollection, ExternalAnnotationsFileProvider externalAnnotationsFileProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.TypeParameterAnnotation : ValueType {
    public string ParameterName;
    public AttributeInstance AttributeInstance;
    public static IUnsafeMarshaller`1<TypeParameterAnnotation> Marshaller;
    public TypeParameterAnnotation(string parameterName, AttributeInstance attributeInstance);
    private static TypeParameterAnnotation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.UniqueAttributeInstance : AttributeInstance {
    private static DataIntern`1<string> ourNameIntern;
    private IList`1<AttributeInstancePositionalArgument> myPositionalArguments;
    private IList`1<AttributeInstancePropertyArgument> myPropertyArguments;
    public UniqueAttributeInstance(string ctorXmlDocId, IList`1<AttributeInstancePositionalArgument> positionalArguments, IList`1<AttributeInstancePropertyArgument> propertyArguments);
    private static UniqueAttributeInstance();
    public virtual IList`1<ArgumentValue> GetPositionalArguments(AssemblyExternalAnnotations assembly);
    public virtual IList`1<KeyValuePair`2<string, ArgumentValue>> GetPropertyArguments(AssemblyExternalAnnotations assembly);
    protected virtual void Serialize(UnsafeWriter writer);
    internal static UniqueAttributeInstance Deserialize(UnsafeReader reader);
}
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ExternalAnnotations.XmlPsiScanner : object {
    private TagScanner myRootScanner;
    public XmlPsiScanner ScanTag(string name, Action`1<ITagScanner> tagScanner);
    public void Process(XmlIndexingLexer lexer);
    public void Process(XmlReader reader);
}
internal abstract class JetBrains.ReSharper.Psi.Impl.Reflection2.FieldBase : Member {
    [CanBeNullAttribute]
private ReflectionType myType;
    [CompilerGeneratedAttribute]
private ReferenceKind <ReferenceKind>k__BackingField;
    public IType Type { get; }
    public bool IsRequired { get; }
    public Nullable`1<int> FixedBufferSize { get; }
    public bool IsField { get; }
    public bool IsConstant { get; }
    public bool IsEnumMember { get; }
    public ReferenceKind ReferenceKind { get; }
    public ConstantValue ConstantValue { get; }
    protected FieldBase(ICompiledEntity element, IReflectionBuilder builder, IMetadataField field, string shortName, MemberDecoration decoration);
    public virtual IType get_Type();
    public virtual bool get_IsRequired();
    public virtual Nullable`1<int> get_FixedBufferSize();
    public abstract virtual bool get_IsField();
    public abstract virtual bool get_IsConstant();
    public sealed virtual bool get_IsEnumMember();
    [CompilerGeneratedAttribute]
public sealed virtual ReferenceKind get_ReferenceKind();
    public abstract virtual ConstantValue get_ConstantValue();
    public virtual void Dump(TextWriter writer, string indent);
    protected virtual Hash CalculateHashInternal();
}
internal class JetBrains.ReSharper.Psi.Impl.Reflection2.FieldBasePropertiesProvider : object {
    [NotNullAttribute]
public virtual string GetMemberName(IMetadataField entity);
    public virtual MemberDecoration GetMemberDecoration(IMetadataField field);
}
internal class JetBrains.ReSharper.Psi.Impl.Reflection2.ForwardedTypeInfo : ValueType {
    public string FullyQualifiedName;
    public string DeclaringAssemblyName;
    public ForwardedTypeInfo(string fullyQualifiedName, string declaringAssemblyName);
}
public interface JetBrains.ReSharper.Psi.Impl.Reflection2.IAssemblyDataCache {
    [CanBeNullAttribute]
public abstract virtual ReflectionType AddType(ReflectionType repr);
    public abstract virtual AssemblyNameInfo AddAssemblyName(AssemblyNameInfo name);
    public abstract virtual string AddString(string str);
    public abstract virtual string AddMemberName(string str);
    public abstract virtual INode AddNamespaceName(string namespaceName);
    public abstract virtual INode AddTypeName(string namespaceName, string typeName, IList`1<int> typeParameterNumberFromReflection, IMetadataTypeInfo typeHint);
    public abstract virtual Int32[] AddAttributeHash(Int32[] hash);
    public abstract virtual void OnAssemblyLoadingFinished();
}
public interface JetBrains.ReSharper.Psi.Impl.Reflection2.ICompiledEntity {
    public ICompiledEntity Parent { get; }
    [NotNullAttribute]
public IPsiModule Module { get; }
    public abstract virtual ICompiledEntity get_Parent();
    public abstract virtual IPsiModule get_Module();
    public abstract virtual bool IsValid();
    [CanBeNullAttribute]
public abstract virtual VirtualFileSystemPath GetXmlDocPath();
}
public interface JetBrains.ReSharper.Psi.Impl.Reflection2.ICompiledEvent {
    [CanBeNullAttribute]
public IField BackingField { get; }
    public abstract virtual IField get_BackingField();
}
public interface JetBrains.ReSharper.Psi.Impl.Reflection2.ICompiledProperty {
    [CanBeNullAttribute]
public IField BackingField { get; }
    public abstract virtual IField get_BackingField();
}
public interface JetBrains.ReSharper.Psi.Impl.Reflection2.ICompiledTypeElement {
    public ICollection`1<ICompiledExtensionMemberProxy> ExtensionMembers { get; }
    public ISet`1<string> ExtendsListNames { get; }
    public abstract virtual IEnumerable`1<string> GetNamespaceNames();
    public abstract virtual ICollection`1<ICompiledExtensionMemberProxy> get_ExtensionMembers();
    public abstract virtual ISet`1<string> get_ExtendsListNames();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ImplementsMethodSpecification : ValueType {
    [CompilerGeneratedAttribute]
private ReflectionType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IAttributeInstance> <AttributeInstances>k__BackingField;
    [CanBeNullAttribute]
public ReflectionType Type { get; }
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public IList`1<IAttributeInstance> AttributeInstances { get; }
    public ImplementsMethodSpecification(ReflectionType type, string name, IList`1<IAttributeInstance> attributeInstances);
    [CompilerGeneratedAttribute]
public ReflectionType get_Type();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IList`1<IAttributeInstance> get_AttributeInstances();
    public void Dump(TextWriter sb, string indent);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.Impl.Reflection2.IPsiAssemblyFileLoader {
    public abstract virtual IPsiAssemblyFile GetOrLoadAssembly(IPsiAssembly assembly, bool shouldLoad, Action`3<IPsiAssembly, IPsiAssemblyFile, IMetadataAssembly> processor);
    public abstract virtual IPsiAssemblyFile UnloadAssembly(IPsiAssembly assembly);
}
[ZoneDefinitionAttribute]
public interface JetBrains.ReSharper.Psi.Impl.Reflection2.IPsiAssemblyFileLoaderImplZone {
}
public interface JetBrains.ReSharper.Psi.Impl.Reflection2.IReflectionBuilder {
    [NotNullAttribute]
public IAssemblyDataCache AssemblyDataCache { get; }
    [NotNullAttribute]
public ReflectionTypeBuilder ReflectionTypeBuilder { get; }
    [NotNullAttribute]
public ReflectionElementAccessibility Accessibility { get; }
    [NotNullAttribute]
public ReflectionElementPropertiesProvider ElementFactory { get; }
    public bool EagerMetadataLoad { get; }
    public abstract virtual IAssemblyDataCache get_AssemblyDataCache();
    public abstract virtual ReflectionTypeBuilder get_ReflectionTypeBuilder();
    public abstract virtual ReflectionElementAccessibility get_Accessibility();
    public abstract virtual ReflectionElementPropertiesProvider get_ElementFactory();
    public abstract virtual bool get_EagerMetadataLoad();
}
internal class JetBrains.ReSharper.Psi.Impl.Reflection2.LibraryMemberNamesAccess : object {
    private AssemblyPsiFile myFile;
    private CompactMap`2<string, int> myNames;
    private ChunkList`1<Entry> myTokens;
    public LibraryMemberNamesAccess(AssemblyPsiFile file, IAssemblyLocation assemblyLocation);
    private void LoadNames(IMetadataTypeInfo typeInfo);
    public sealed virtual IEnumerable`1<string> GetAllMemberNames();
    public sealed virtual int GetMembersCount();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.Reflection2.LibraryMemberNamesAccess/<GetTypesWithMember>d__8")]
public sealed virtual IEnumerable`1<ITypeElement> GetTypesWithMember(string name);
}
public abstract class JetBrains.ReSharper.Psi.Impl.Reflection2.Member : CompiledElementBase {
    private string myShortName;
    private MemberFlags myFlags;
    public ISubstitution IdSubstitution { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public string ShortName { get; }
    public MemberHidePolicy HidePolicy { get; }
    public string XMLDocId { get; }
    protected Member(ICompiledEntity parent, IReflectionBuilder builder, IMetadataEntity entity, string shortName, MemberDecoration decoration);
    public virtual ISubstitution get_IdSubstitution();
    public virtual string ToString();
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public virtual bool get_IsAbstract();
    public virtual bool get_IsSealed();
    public virtual bool get_IsVirtual();
    public virtual bool get_IsOverride();
    public virtual bool get_IsStatic();
    public virtual bool get_IsReadonly();
    public virtual bool get_IsExtern();
    public virtual bool get_IsUnsafe();
    public virtual bool get_IsVolatile();
    public virtual AccessRights GetAccessRights();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public virtual string get_ShortName();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public abstract virtual DeclaredElementType GetElementType();
    public virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    protected virtual bool HasAttributeInstance(IClrTypeName qualifiedTypeName);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    protected virtual Nullable`1<NullableAnnotation> TryGetNullableContextValue();
    public virtual void Dump(TextWriter writer, string indent);
    public sealed virtual string get_XMLDocId();
    public sealed virtual bool IsSynthetic();
    protected virtual Hash CalculateHashInternal();
    public sealed virtual Nullable`1<Hash> CalcHash();
    protected virtual IEnumerable`1<IAttributeInstance> BuildAttributeInstances();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(Member other);
    public virtual bool Equals(object obj);
}
public abstract class JetBrains.ReSharper.Psi.Impl.Reflection2.MemberOwner : CompiledTypeElement {
    [NotNullAttribute]
private IList`1<ITypeElement> myNestedTypeElements;
    [NotNullAttribute]
private IParametrizedCachedValue`2<CompiledMembersBucket, KeyValuePair`2<MemberOwner, IMetadataAssembly>> myMembers;
    public ICollection`1<ICompiledExtensionMemberProxy> ExtensionMembers { get; }
    public IEnumerable`1<IField> Constants { get; }
    public IEnumerable`1<IField> Fields { get; }
    public IEnumerable`1<IMethod> Methods { get; }
    public IEnumerable`1<IProperty> Properties { get; }
    public IEnumerable`1<IEvent> Events { get; }
    public IList`1<ITypeElement> NestedTypes { get; }
    public IEnumerable`1<IOperator> Operators { get; }
    public IEnumerable`1<IConstructor> Constructors { get; }
    public IEnumerable`1<string> MemberNames { get; }
    protected MemberOwner(ICompiledEntity parent, IReflectionBuilder builder, CompiledTypeElementFactory factory, IMetadataTypeInfo info);
    internal virtual void LoadFromAssembly(IMetadataAssembly assembly);
    internal void UnloadCachedBucket();
    private static CompiledMembersBucket ProduceBucket(KeyValuePair`2<MemberOwner, IMetadataAssembly> pair);
    private static CompiledMembersBucket ProduceBucketInternal(MemberOwner owner, IMetadataAssembly assembly);
    [NotNullAttribute]
private CompiledMembersBucket LoadMembersOnDemand();
    public virtual ICollection`1<ICompiledExtensionMemberProxy> get_ExtensionMembers();
    public virtual IEnumerable`1<IField> get_Constants();
    public virtual IEnumerable`1<IField> get_Fields();
    public virtual IEnumerable`1<IMethod> get_Methods();
    public virtual IEnumerable`1<IProperty> get_Properties();
    public virtual IEnumerable`1<IEvent> get_Events();
    public virtual IList`1<ITypeElement> get_NestedTypes();
    public virtual IEnumerable`1<IOperator> get_Operators();
    public virtual IEnumerable`1<IConstructor> get_Constructors();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.Reflection2.MemberOwner/<GetMembers>d__26")]
public virtual IEnumerable`1<ITypeMember> GetMembers();
    public virtual bool HasMemberWithName(string shortName, bool ignoreCase);
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual void Dump(TextWriter writer, string indent);
}
public class JetBrains.ReSharper.Psi.Impl.Reflection2.MetadataAccessFileWithDependencies : object {
    private List`1<TokenRef> myExportedTypes;
    private MetadataAccessHasher myMainModuleHasher;
    private IMetadataAccess myMainModule;
    private VirtualFileSystemPath myMainModuleLocation;
    private IDictionary`2<MetadataToken, MetadataAccessHasher> myReferencedFiles;
    public IEnumerable`1<ModuleProperty> ModulePropertyDependencies { get; }
    public MetadataAccessFileWithDependencies(VirtualFileSystemPath location);
    public sealed virtual IEnumerable`1<Pair`2<object, IUsingsInfo>> GetTopLevelHashableEntities();
    public sealed virtual ICollection`1<string> GetEmptyNamespaceDeclarations();
    public sealed virtual IEnumerable`1<ModuleProperty> get_ModulePropertyDependencies();
    public sealed virtual IHashableEntityInfo[] CalcAllEntityHashes(object hashableEntity, string parentQualifiedName, String& qualifiedName);
    public sealed virtual IEnumerable EntityChildren(object hashableEntity);
    public sealed virtual bool IsEntityInternal(object hashableEntity);
    public sealed virtual void Dispose();
    private void LoadExportedTypes();
    private void LoadReferencedFiles();
}
public class JetBrains.ReSharper.Psi.Impl.Reflection2.MetadataAccessHasher : object {
    private IMetadataAccess myMetadata;
    private IDictionary`2<UInt32, TypeDefProperties> myTypeProperties;
    private HashingSignatureBuilder mySignatureHasher;
    public IMetadataAccess Metadata { get; }
    public MetadataAccessHasher(IMetadataAccess metadata);
    public IMetadataAccess get_Metadata();
    private TypeDefProperties GetTypeDefProperties(MetadataToken type);
    public IHashableEntityInfo[] GetEntityHashes(MetadataToken token, string parentQualifiedName, String& qualifiedName);
    public IList`1<MetadataToken> GetEntityChildren(MetadataToken entityToken);
    public bool IsEntityInternal(MetadataToken entityToken);
    private static void AddBlobToHash(IBlob blob, Hash& hash);
    private Hash TypeTokenPresenter(MetadataToken typeToken);
    private void AddTypeToHash(MetadataToken typeToken, Hash& hash);
    private void AddMethodDefOrRefToHash(MetadataToken methodToken, Hash& hash);
    private void AddMethodSignatureToHash(IBlob signature, Hash& hash);
    private void AddFieldSignatureToHash(IBlob signature, Hash& hash);
    private void AddMemberRefSignatureToHash(IBlob signature, Hash& hash);
    private void AddCustomAttributesToHash(MetadataToken owner, Hash& hash);
    private StringDotConcat GetBaseTypeFqn(MetadataToken type);
    private bool IsDelegate(MetadataToken typeDefToken);
    private bool IsValueType(MetadataToken typeDefToken);
    private bool IsExtensionMethod(MetadataToken methodToken);
    private string GetTypeDefaultMemberName(MetadataToken typeToken);
    private bool IsAbstract(MetadataToken method);
    private void AddGenericParamToHash(MetadataToken owner, Hash& hash);
}
public class JetBrains.ReSharper.Psi.Impl.Reflection2.MetadataAttributeInstance : object {
    [NotNullAttribute]
private ICompiledEntity myParent;
    [CanBeNullAttribute]
private ReflectionClassType myAttributeType;
    [NotNullAttribute]
private Pair`2[] myPositionalArguments;
    [NotNullAttribute]
private Pair`2[] myNamedArguments;
    public int NamedParameterCount { get; }
    public int PositionParameterCount { get; }
    public IConstructor Constructor { get; }
    internal MetadataAttributeInstance(ICompiledEntity parent, ReflectionClassType attributeType, Pair`2[] positionalArguments, Pair`2[] namedArguments);
    public sealed virtual int get_NamedParameterCount();
    [CanBeNullAttribute]
[PureAttribute]
public static MetadataAttributeInstance FromCompilerSpecificAttribute(ICompiledEntity psiOwner, IReflectionBuilder builder, ICompilerSpecificAttribute compilerSpecificAttribute, IMetadataAssembly declaringAssembly);
    [NotNullAttribute]
[PureAttribute]
public static MetadataAttributeInstance FromMetadataCustomAttribute(ICompiledEntity parent, IReflectionBuilder builder, IMetadataCustomAttribute customAttribute);
    [NotNullAttribute]
public static MetadataAttributeInstance FromMetadataSecurityAttribute(ICompiledEntity parent, IReflectionBuilder builder, IMetadataSecurityAttribute securityAttribute, IMetadataAssembly declaringAssembly, SecurityAction securityAction);
    [NotNullAttribute]
[PureAttribute]
private static Pair`2[] MakeNamedArguments(IReflectionBuilder builder, IMetadataAttributeNamedArgument[] attributeNamedArguments);
    private static ReflectionAttributeValue ToReflectionAttributeValue(IReflectionBuilder builder, MetadataAttributeValue metadataValue);
    [NotNullAttribute]
[PureAttribute]
private AttributeValue ToAttributeValue(ReflectionAttributeValue rvalue);
    public sealed virtual int get_PositionParameterCount();
    private IType ToType(ReflectionType type);
    [NotNullAttribute]
public sealed virtual string GetAttributeShortName();
    public sealed virtual IDeclaredType GetAttributeType();
    public sealed virtual IConstructor get_Constructor();
    private bool IsApplicableConstructor(IConstructor constructor, ISubstitution substitution);
    public sealed virtual AttributeValue PositionParameter(int paramIndex);
    [PureAttribute]
internal Nullable`1<ReflectionAttributeValue> PositionalParameterNoResolve(int paramIndex);
    public sealed virtual IEnumerable`1<AttributeValue> PositionParameters();
    public sealed virtual AttributeValue NamedParameter(string name);
    public sealed virtual IEnumerable`1<Pair`2<string, AttributeValue>> NamedParameters();
    public sealed virtual IClrTypeName GetClrName();
    public void Dump(TextWriter writer, string indent);
    public Hash AddToHash(Hash hash);
    [CompilerGeneratedAttribute]
private AttributeValue <PositionParameters>b__23_0(Pair`2<ReflectionType, ReflectionAttributeValue> positionalArgument);
    [CompilerGeneratedAttribute]
private Pair`2<string, AttributeValue> <NamedParameters>b__25_0(Pair`2<string, ReflectionAttributeValue> namedArgument);
}
public abstract class JetBrains.ReSharper.Psi.Impl.Reflection2.MethodBase : Member {
    [NotNullAttribute]
protected IList`1<IParameter> myParameters;
    [NotNullAttribute]
private ReturnValue myReturnValue;
    private ImplementsMethodSpecification[] myMethodSpecifications;
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public bool IsPredefined { get; }
    public bool IsIterator { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    protected ImplementsMethodSpecification[] MethodSpecifications { get; }
    [NotNullAttribute]
public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    protected MethodBase(ICompiledEntity parent, IReflectionBuilder builder, IMetadataMethod method, string shortName, MemberDecoration decoration, CompiledTypeElementFactory ownerFactory);
    public virtual IList`1<IParameter> get_Parameters();
    [PureAttribute]
internal int ParameterIndex(Parameter parameter);
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual bool get_IsPredefined();
    public abstract virtual bool get_IsIterator();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    protected ImplementsMethodSpecification[] get_MethodSpecifications();
    public sealed virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    public virtual string ToString();
    public virtual void Dump(TextWriter writer, string indent);
    protected virtual Hash CalculateHashInternal();
    protected bool CalculateIsIterator();
}
internal abstract class JetBrains.ReSharper.Psi.Impl.Reflection2.MethodBasePropertiesProvider : object {
    [NotNullAttribute]
public string GetMemberName(IMetadataMethod entity);
}
internal static class JetBrains.ReSharper.Psi.Impl.Reflection2.NullableContextMetadataUtil : object {
    [CanBeNullAttribute]
[PureAttribute]
public static IAttributeInstance FindNullableAttributeInstance(IList`1<IAttributeInstance> attributeInstances);
    public static bool TryGetNullableAttributeValue(IList`1<IAttributeInstance> attributeInstances, NullableAnnotation& annotation, NullableAnnotation[]& annotations);
    private static bool TryGetNullableAttributeValueSlow(NullableAnnotation& annotation, NullableAnnotation[]& annotations, IAttributeInstance nullableAttributeInstance);
    [PureAttribute]
public static Nullable`1<NullableAnnotation> TryGetNullableContextAttributeValue(IList`1<IAttributeInstance> attributeInstances);
}
[ShellComponentAttribute("16")]
[DerivedComponentsInstantiationRequirementAttribute("0")]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.PsiAssemblyFileLoaderDoNotLoadUnlessRequired : object {
    [NullableContextAttribute("1")]
public virtual IPsiAssemblyFile GetOrLoadAssembly(IPsiAssembly assembly, bool shouldLoad, Action`3<IPsiAssembly, IPsiAssemblyFile, IMetadataAssembly> processor);
    [NullableContextAttribute("1")]
public virtual IPsiAssemblyFile UnloadAssembly(IPsiAssembly assembly);
}
internal class JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionArrayType : ReflectionType {
    [CompilerGeneratedAttribute]
private int <Rank>k__BackingField;
    [CompilerGeneratedAttribute]
private ReflectionType <ElementType>k__BackingField;
    public int Rank { get; }
    public ReflectionType ElementType { get; }
    public ReflectionArrayType(int rank, ReflectionType elementType, Pair`2[] typeModifiers);
    [CompilerGeneratedAttribute]
public int get_Rank();
    [CompilerGeneratedAttribute]
public ReflectionType get_ElementType();
    public virtual IType DecodeType(IPsiServices psiServices, ITypeMember context, IPsiModule module, TypeAnnotationsEnumerator`1& dynamicAnnotationsEnumerator, TypeAnnotationsEnumerator`1& tupleComponentNamesEnumerator, TypeAnnotationsEnumerator`1& nullableAnnotationsEnumerator, TypeAnnotationsEnumerator`1& nativeIntegerAnnotationsEnumerator);
    protected internal virtual int CalculateExpectedNumberOfTupleElementNames();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual Hash AddToHash(Hash hash);
}
internal class JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionAttributeValue : ValueType {
    public static ReflectionAttributeValue BadValue;
    [CompilerGeneratedAttribute]
private ReflectionType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private ReflectionAttributeValue[] <ValuesArray>k__BackingField;
    public ReflectionType Type { get; }
    public object Value { get; }
    public ReflectionAttributeValue[] ValuesArray { get; }
    private ReflectionAttributeValue(ReflectionType type, object value, ReflectionAttributeValue[] valuesArray);
    private static ReflectionAttributeValue();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReflectionType get_Type();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public object get_Value();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReflectionAttributeValue[] get_ValuesArray();
    public static ReflectionAttributeValue MakeArray(ReflectionArrayType arrayType, ReflectionAttributeValue[] valuesArray);
    public static ReflectionAttributeValue MakeScalar(ReflectionType type, object value);
    public Hash AddToHash(Hash hash);
    public bool IsBadValue();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionBuilder : object {
    private Action myOnDispose;
    [CompilerGeneratedAttribute]
private IAssemblyDataCache <AssemblyDataCache>k__BackingField;
    [CompilerGeneratedAttribute]
private ReflectionTypeBuilder <ReflectionTypeBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private ReflectionElementAccessibility <Accessibility>k__BackingField;
    [CompilerGeneratedAttribute]
private ReflectionElementPropertiesProvider <ElementFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EagerMetadataLoad>k__BackingField;
    public IAssemblyDataCache AssemblyDataCache { get; }
    public ReflectionTypeBuilder ReflectionTypeBuilder { get; }
    public ReflectionElementAccessibility Accessibility { get; }
    public ReflectionElementPropertiesProvider ElementFactory { get; }
    public bool EagerMetadataLoad { get; }
    public ReflectionBuilder(IAssemblyDataCache assemblyDataCache, ReflectionTypeBuilder reflectionTypeBuilder, ReflectionElementAccessibility accessibility, ReflectionElementPropertiesProvider elementFactory, bool eagerMetadataLoad, Action onDispose);
    [CompilerGeneratedAttribute]
public sealed virtual IAssemblyDataCache get_AssemblyDataCache();
    [CompilerGeneratedAttribute]
public sealed virtual ReflectionTypeBuilder get_ReflectionTypeBuilder();
    [CompilerGeneratedAttribute]
public sealed virtual ReflectionElementAccessibility get_Accessibility();
    [CompilerGeneratedAttribute]
public sealed virtual ReflectionElementPropertiesProvider get_ElementFactory();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EagerMetadataLoad();
    public sealed virtual void Dispose();
}
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionClassType : ReflectionClassTypeBase {
    [NotNullAttribute]
private INode myName;
    public IClrTypeName ClrName { get; }
    public ReflectionClassType(INode name, AssemblyNameInfo assemblyName, ReflectionType[] typeArguments, Nullable`1<bool> isValueType, Pair`2[] typeModifiers);
    public virtual IClrTypeName get_ClrName();
    protected virtual bool CompareClrName(ReflectionClassTypeBase otherType);
    protected virtual int GetClrNameHash();
}
public abstract class JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionClassTypeBase : ReflectionType {
    [CanBeNullAttribute]
private AssemblyNameInfo myAssemblyName;
    [NotNullAttribute]
private ReflectionType[] myTypeArguments;
    private Nullable`1<bool> myIsValueType;
    public IClrTypeName ClrName { get; }
    public AssemblyNameInfo AssemblyName { get; }
    public ReflectionType[] TypeArguments { get; }
    protected ReflectionClassTypeBase(AssemblyNameInfo assemblyName, ReflectionType[] typeArguments, Nullable`1<bool> isValueType, Pair`2[] typeModifiers);
    public abstract virtual IClrTypeName get_ClrName();
    public AssemblyNameInfo get_AssemblyName();
    public ReflectionType[] get_TypeArguments();
    public sealed virtual IType DecodeType(IPsiServices psiServices, ITypeMember context, IPsiModule module, TypeAnnotationsEnumerator`1& dynamicAnnotationsEnumerator, TypeAnnotationsEnumerator`1& tupleComponentNamesEnumerator, TypeAnnotationsEnumerator`1& nullableAnnotationsEnumerator, TypeAnnotationsEnumerator`1& nativeIntegerAnnotationsEnumerator);
    protected internal virtual int CalculateExpectedNumberOfTupleElementNames();
    private IType DecodeValueTupleType(IPsiServices psiServices, ITypeMember context, IPsiModule module, TypeAnnotationsEnumerator`1& dynamicAnnotationsEnumerator, TypeAnnotationsEnumerator`1& tupleComponentNamesEnumerator, TypeAnnotationsEnumerator`1& nullableAnnotationsEnumerator, TypeAnnotationsEnumerator`1& nativeIntegerAnnotationsEnumerator);
    private int CalculateTupleCardinality();
    [PureAttribute]
private bool IsValueTupleType();
    protected virtual bool CompareClrName(ReflectionClassTypeBase otherType);
    public virtual bool Equals(object obj);
    protected virtual int GetClrNameHash();
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual Hash AddToHash(Hash hash);
}
internal class JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionClassTypeFromClrName : ReflectionClassTypeBase {
    [CompilerGeneratedAttribute]
private IClrTypeName <ClrName>k__BackingField;
    public IClrTypeName ClrName { get; }
    public ReflectionClassTypeFromClrName(IClrTypeName name, AssemblyNameInfo assemblyName, ReflectionType[] typeArguments, Pair`2[] typeModifiers);
    [CompilerGeneratedAttribute]
public virtual IClrTypeName get_ClrName();
}
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionElementAccessibility : object {
    private bool myFullMetadataLoad;
    public ReflectionElementAccessibility(bool fullMetadataLoad);
    internal virtual bool IsMethodAccessible(IMetadataMethod method);
    public virtual bool IsFieldAccessible(IMetadataField field);
    public virtual bool IsTypeAccessible(IMetadataTypeInfo typeInfo);
}
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionElementPropertiesProvider : object {
    public CompiledTypeElementFactory ClassProperties { get; }
    public CompiledTypeElementFactory StructProperties { get; }
    public CompiledTypeElementFactory InterfaceProperties { get; }
    public CompiledTypeElementFactory EnumProperties { get; }
    public CompiledTypeElementFactory DelegateProperties { get; }
    public virtual CompiledTypeElementFactory get_ClassProperties();
    public virtual CompiledTypeElementFactory get_StructProperties();
    public virtual CompiledTypeElementFactory get_InterfaceProperties();
    public virtual CompiledTypeElementFactory get_EnumProperties();
    public virtual CompiledTypeElementFactory get_DelegateProperties();
}
internal class JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionFunctionPointerType : ReflectionType {
    [CompilerGeneratedAttribute]
private ReflectionType <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferenceKind <ReturnKind>k__BackingField;
    [CompilerGeneratedAttribute]
private Parameter[] <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUnmanaged>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <UnmanagedCallingConventions>k__BackingField;
    [NotNullAttribute]
public ReflectionType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    [NotNullAttribute]
public Parameter[] Parameters { get; }
    public bool IsUnmanaged { get; }
    [NotNullAttribute]
public String[] UnmanagedCallingConventions { get; }
    public ReflectionFunctionPointerType(ReflectionType returnType, ReferenceKind returnKind, Parameter[] parameters, bool isUnmanaged, String[] unmanagedCallingConventions, Pair`2[] typeModifiers);
    [CompilerGeneratedAttribute]
public ReflectionType get_ReturnType();
    [CompilerGeneratedAttribute]
public ReferenceKind get_ReturnKind();
    [CompilerGeneratedAttribute]
public Parameter[] get_Parameters();
    [CompilerGeneratedAttribute]
public bool get_IsUnmanaged();
    [CompilerGeneratedAttribute]
public String[] get_UnmanagedCallingConventions();
    public virtual IType DecodeType(IPsiServices psiServices, ITypeMember context, IPsiModule module, TypeAnnotationsEnumerator`1& dynamicAnnotationsEnumerator, TypeAnnotationsEnumerator`1& tupleComponentNamesEnumerator, TypeAnnotationsEnumerator`1& nullableAnnotationsEnumerator, TypeAnnotationsEnumerator`1& nativeIntegerAnnotationsEnumerator);
    protected internal virtual int CalculateExpectedNumberOfTupleElementNames();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual Hash AddToHash(Hash hash);
}
internal class JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionPointerType : ReflectionType {
    [CompilerGeneratedAttribute]
private ReflectionType <ElementType>k__BackingField;
    public ReflectionType ElementType { get; }
    public ReflectionPointerType(ReflectionType elementType, Pair`2[] typeModifiers);
    [CompilerGeneratedAttribute]
public ReflectionType get_ElementType();
    public virtual IType DecodeType(IPsiServices psiServices, ITypeMember context, IPsiModule module, TypeAnnotationsEnumerator`1& dynamicAnnotationsEnumerator, TypeAnnotationsEnumerator`1& tupleComponentNamesEnumerator, TypeAnnotationsEnumerator`1& nullableAnnotationsEnumerator, TypeAnnotationsEnumerator`1& nativeIntegerAnnotationsEnumerator);
    protected internal virtual int CalculateExpectedNumberOfTupleElementNames();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual Hash AddToHash(Hash hash);
}
internal class JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionSpecificTypeParser : AbstractTypeNameParser`1<ReflectionType> {
    public ReflectionSpecificTypeParser(string typeName);
    protected virtual ReflectionType CreateUnresolvedType(string typeName, TextRange typeNameRange);
    protected virtual ReflectionType CreateTypeByNameAndAssembly(string typeName, TextRange typeNameRange, string assemblyName, TextRange assemblyNameRange, TextRange assemblyFullNameRange, ReflectionType[] genericArguments);
    protected virtual ReflectionType CreatePointerType(ReflectionType elementType);
    protected virtual ReflectionType CreateArrayType(ReflectionType elementType, UInt32 rank, UInt32[] sizes, Int32[] lBounds);
    protected virtual ReflectionType CreateArrayType(ReflectionType elementType);
    protected virtual ReflectionType CreateReferenceType(ReflectionType elementType);
}
public abstract class JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionType : object {
    [NotNullAttribute]
private Pair`2[] myTypeModifiers;
    protected ReflectionType(Pair`2[] typeModifiers);
    protected TypeModifier[] DecodeTypeModifiers(IPsiServices psiServices, ITypeMember context, IPsiModule module);
    protected bool TypeModifierEquals(ReflectionType type);
    protected int TypeModifiersHashCode();
    [NotNullAttribute]
public abstract virtual IType DecodeType(IPsiServices psiServices, ITypeMember context, IPsiModule module, TypeAnnotationsEnumerator`1& dynamicAnnotationsEnumerator, TypeAnnotationsEnumerator`1& tupleComponentNamesEnumerator, TypeAnnotationsEnumerator`1& nullableAnnotationsEnumerator, TypeAnnotationsEnumerator`1& nativeIntegerAnnotationsEnumerator);
    protected internal abstract virtual int CalculateExpectedNumberOfTupleElementNames();
    public abstract virtual Hash AddToHash(Hash hash);
    public abstract virtual string ToString();
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionTypeBuilder : object {
    [NotNullAttribute]
private IAssemblyDataCache myCache;
    [NotNullAttribute]
private static Func`3<CompiledElementBase, ReflectionType, IType> ByValTypeDecoder;
    [NotNullAttribute]
private static Func`3<CompiledElementBase, ReflectionType, IType> ByRefTypeDecoder;
    public ReflectionTypeBuilder(IAssemblyDataCache cache);
    private static ReflectionTypeBuilder();
    [CanBeNullAttribute]
public ReflectionClassType Create(IMetadataTypeInfo info);
    [CanBeNullAttribute]
public ReflectionClassType Create(AssemblyNameInfo declaringAssemblyName, string fqn);
    [CanBeNullAttribute]
public ReflectionClassType Create(AssemblyNameInfo declaringAssemblyName, string namespaceName, string typeName, IList`1<int> typeParameterNumberFromReflection, IMetadataTypeInfo typeHint);
    [NotNullAttribute]
[PureAttribute]
public static Func`3<CompiledElementBase, ReflectionType, IType> GetTypeDecoder(bool isByRefType);
    [CanBeNullAttribute]
[PureAttribute]
public ReflectionType UnwrapFromReferenceTypeAndCreate(IMetadataType type, Boolean& isByRef);
    [CanBeNullAttribute]
[PureAttribute]
public ReflectionType Create(IMetadataType type);
    [CanBeNullAttribute]
private ReflectionType CreateClassType(IMetadataClassType classType);
    [CanBeNullAttribute]
private ReflectionType CreateTypeParameterType(IMetadataTypeParameterReferenceType typeParameterReferenceType);
    [CanBeNullAttribute]
private ReflectionType CreateArrayType(IMetadataArrayType arrayType);
    [CanBeNullAttribute]
private ReflectionType CreatePointerType(IMetadataPointerType pointerType);
    [CanBeNullAttribute]
private ReflectionType CreateFunctionPointerType(IMetadataFunctionPointerType functionPointerType);
    [NotNullAttribute]
private static String[] DecodeCallingConvention(MethodSignature methodSignature, Boolean& isUnmanaged);
    public virtual MetadataTypeReference ProjectTypeReference(MetadataTypeReference reference);
    [NotNullAttribute]
internal virtual MetadataAttributeInstance CreateMetadataAttributeInstance(ICompiledEntity parent, IMetadataCustomAttribute customAttribute, ReflectionClassType attributeType, Pair`2[] positionalArguments, Pair`2[] namedArguments);
    [NotNullAttribute]
private Pair`2[] BuildTypeModifiers(IMetadataType type);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionTypeFlags : Enum {
    public byte value__;
    public static ReflectionTypeFlags HasBaseClass;
    public static ReflectionTypeFlags HasHiddenInstanceFields;
    public static ReflectionTypeFlags StrippedTypeParametersFromName;
    public static ReflectionTypeFlags InvalidTypeParametersCount;
    public static ReflectionTypeFlags OldTypeParametersSymbol;
}
public class JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionTypeNameCache : object {
    private DataIntern`1<string> myStringIntern;
    private Dictionary`2<string, String[]> myParsedNamespaceIntern;
    private Func`2<string, string> myInternFunc;
    public IClrTypeName GetClrName(IMetadataTypeInfo typeInfo);
    [CompilerGeneratedAttribute]
private string <.ctor>b__3_0(string str);
}
internal class JetBrains.ReSharper.Psi.Impl.Reflection2.ReflectionTypeParameterType : ReflectionType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private ReflectionClassType <Owner>k__BackingField;
    public string Name { get; }
    public int Index { get; }
    public ReflectionClassType Owner { get; }
    public ReflectionTypeParameterType(string name, int index, ReflectionClassType owner, Pair`2[] typeModifiers);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public ReflectionClassType get_Owner();
    public virtual IType DecodeType(IPsiServices psiServices, ITypeMember context, IPsiModule module, TypeAnnotationsEnumerator`1& dynamicAnnotationsEnumerator, TypeAnnotationsEnumerator`1& tupleComponentNamesEnumerator, TypeAnnotationsEnumerator`1& nullableAnnotationsEnumerator, TypeAnnotationsEnumerator`1& nativeIntegerAnnotationsEnumerator);
    protected internal virtual int CalculateExpectedNumberOfTupleElementNames();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual Hash AddToHash(Hash hash);
}
public interface JetBrains.ReSharper.Psi.Impl.Reflection2.WinMD.IWinMDClass {
    public abstract virtual IEnumerable`1<IDeclaredType> GetProjectedSuperInterfaces();
}
public interface JetBrains.ReSharper.Psi.Impl.Reflection2.WinMD.IWinMDTypeProjectionModuleCache {
    [CanBeNullAttribute]
public ITypeElement IVector { get; }
    [CanBeNullAttribute]
public ITypeElement IVectorView { get; }
    [CanBeNullAttribute]
public abstract virtual ITypeElement GetTypeProjectionFromWinMDToClr(ITypeElement typeElement);
    [CanBeNullAttribute]
public abstract virtual ITypeElement GetTypeProjectionFromClrToWinMD(ITypeElement typeElement);
    [CanBeNullAttribute]
public abstract virtual ITypeElement GetTypeProjectionFromClrToWinMD(IDeclaredType type);
    [CanBeNullAttribute]
public abstract virtual ITypeElement GetTypeProjection(ITypeElement typeElement);
    public abstract virtual Pair`2<ITypeElement, bool> GetTypeProjectionAndDirection(ITypeElement typeElement);
    public abstract virtual ITypeElement get_IVector();
    public abstract virtual ITypeElement get_IVectorView();
}
public static class JetBrains.ReSharper.Psi.Impl.Reflection2.WinMD.WinMDProjectedTypes : object {
    private static string WindowsFoundation;
    private static string WindowsUI;
    private static string WindowsUIXaml;
    private static string WindowsUIXamlInput;
    private static string WindowsUIXamlInterop;
    private static string WindowsUIXamlData;
    private static string WindowsUIXamlControlsPrimitives;
    private static string WindowsUIXamlMedia;
    private static string WindowsUIXamlMediaAnimation;
    private static string WindowsUIXamlMediaMedia3D;
    private static string Mscorlib;
    private static string System;
    private static string SystemRuntimeWindowsRuntime;
    private static string SystemRuntimeWindowsRuntimeUIXaml;
    private static string SystemNumerics;
    public static Dictionary`2<Pair`2<string, string>, Pair`2<string, string>> WinMDToClr;
    private static WinMDProjectedTypes();
}
public class JetBrains.ReSharper.Psi.Impl.Reflection2.WinMD.WinMDPsiFile : AssemblyPsiFile {
    private static string ClrPrefix;
    private static string PlatformAttributeFqn;
    private static ClrTypeName ExclusiveToAttributeName;
    private static Dictionary`2<string, MetadataTypeReference> ProjectionTable;
    private static Dictionary`2<IClrTypeName, IClrTypeName> RevertProjectionTable;
    private static OneToListMap`2<AssemblyNameInfo, AssemblyNameInfo> AssemblyReferenceSubstitutionMap;
    private HashSet`1<string> myLocalClrTypes;
    private HashSet`1<Pair`2<string, string>> myLocalWinMDCounterpartsOfClrType;
    private HashSet`1<string> myLocalProjectionInterfaces;
    private Platform myWinMdPlatform;
    private static WinMDPsiFile();
    public WinMDPsiFile(Func`3<IAssemblyLocation, IPsiModule, MetadataLoader> metadataLoaderFactory, IPsiConfiguration psiConfiguration, IExternalProviderCache`2<ICompiledEntity, IType> decodedTypeCache, IWeakRefRetainerCache`1<object> compiledMembersBucketCache);
    public virtual void LoadAssembly(IMetadataAssembly assembly, IAssemblyPsiModule containingModule);
    private static Platform CalculateWinMdPlatform(IMetadataAssembly assembly);
    [NotNullAttribute]
private static string RemoveClrPrefix(IMetadataTypeInfo typeInfo);
    [NotNullAttribute]
private static string AppendRemovePrefix(IMetadataTypeInfo typeInfo);
    protected virtual ReflectionTypeBuilder CreateReflectionTypeBuilder(IAssemblyDataCache cache, IMetadataAssembly assembly);
    protected virtual ReflectionElementAccessibility CreateReflectionElementAccessibility(bool fullMetadataLoad);
    protected virtual ReflectionElementPropertiesProvider CreateReflectionElementPropertiesProvider();
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Impl.Reflection2.WinMD.WinMDTypeProjectionCache : object {
    [NotNullAttribute]
private Dictionary`2<IPsiModule, IWinMDTypeProjectionModuleCache> myPsiModuleCaches;
    [NotNullAttribute]
private IPsiModules myPsiModules;
    public WinMDTypeProjectionCache(Lifetime lifetime, ChangeManager changeManager, IPsiModules psiModules);
    [NotNullAttribute]
private static IWinMDTypeProjectionModuleCache CreateCache(IPsiModule module);
    [NotNullAttribute]
public IWinMDTypeProjectionModuleCache GetModuleCache(IPsiModule module);
    [PureAttribute]
public static IWinMDTypeProjectionModuleCache GetCache(IPsiModule module);
    [PureAttribute]
public static IWinMDTypeProjectionModuleCache GetCache(ITreeNode element);
    private void OnChangeManagerChanged(ChangeEventArgs changeEventArgs);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Psi.Impl.Resolve.DeclaredElementInstancesSymbolTable : DeclaredElementsSymbolTableBase`1<DeclaredElementInstance> {
    public DeclaredElementInstancesSymbolTable(IPsiServices psiServices, IList`1<DeclaredElementInstance> sourceItems, int level, Nullable`1<int> inheritanceLevel);
    protected virtual string GetItemName(DeclaredElementInstance element);
    protected virtual IDeclaredElement GetDeclaredElement(DeclaredElementInstance element);
    protected virtual ISymbolInfo CreateSymbolInfo(string name, DeclaredElementInstance element);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Psi.Impl.Resolve.DeclaredElementsSymbolTable`1 : DeclaredElementsSymbolTableBase`1<TDeclaredElement> {
    public DeclaredElementsSymbolTable`1(IPsiServices psiServices, IList`1<TDeclaredElement> sourceItems, int level, Nullable`1<int> inheritanceLevel);
    protected virtual string GetItemName(TDeclaredElement element);
    protected virtual IDeclaredElement GetDeclaredElement(TDeclaredElement element);
    protected ISubstitution ElementSubstitution(IDeclaredElement declaredElement);
    protected virtual ISymbolInfo CreateSymbolInfo(string name, TDeclaredElement declaredElement);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.Impl.Resolve.DeclaredElementsSymbolTableBase`1 : SymbolTableBase {
    [DebuggerBrowsableAttribute("0")]
private IList`1<TItem> mySourceItems;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerBrowsableAttribute("0")]
private CompactOneToListMap`2<string, TItem> myItemsByName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerBrowsableAttribute("0")]
private List`1<TItem> myDefaultProperties;
    [DebuggerBrowsableAttribute("0")]
private DependencyStore myDependencyStore;
    private static List`1<TItem> ourEmptyItemsMarker;
    private static CompactOneToListMap`2<string, TItem> ourTooSmallForMapMarker;
    [CompilerGeneratedAttribute]
private int <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <InheritanceLevel>k__BackingField;
    private static int SmallTableThreshold;
    protected int Level { get; }
    protected Nullable`1<int> InheritanceLevel { get; }
    [DebuggerBrowsableAttribute("3")]
protected IList`1<TItem> AllItems { get; }
    protected DeclaredElementsSymbolTableBase`1(IPsiServices psiServices, IList`1<TItem> sourceItems, int level, Nullable`1<int> inheritanceLevel);
    private static DeclaredElementsSymbolTableBase`1();
    [CompilerGeneratedAttribute]
protected int get_Level();
    [CompilerGeneratedAttribute]
protected Nullable`1<int> get_InheritanceLevel();
    [MustUseReturnValueAttribute]
private CompactOneToListMap`2<string, TItem> GetOrCreateByNameMap();
    [MustUseReturnValueAttribute]
private List`1<TItem> GetOrInitDefaultProperties();
    protected IList`1<TItem> get_AllItems();
    public virtual IList`1<ISymbolInfo> GetSymbolInfos(string name);
    public virtual void AppendSymbolInfos(string name, List`1<ISymbolInfo> consumer);
    public virtual bool ForAllSymbolInfos(TState state, Func`3<TState, ISymbolInfo, bool> processor);
    public virtual IEnumerable`1<string> Names();
    [NullableContextAttribute("2")]
public virtual ISymbolTableDependencySet GetDependencySet();
    [PureAttribute]
protected bool IsDefaultProperty(TItem element);
    [PureAttribute]
protected abstract virtual ISymbolInfo CreateSymbolInfo(string name, TItem element);
    [PureAttribute]
protected abstract virtual string GetItemName(TItem element);
    [PureAttribute]
protected abstract virtual IDeclaredElement GetDeclaredElement(TItem element);
}
public class JetBrains.ReSharper.Psi.Impl.Resolve.ExtensionMethodResolveResult : ResolveResultWithSubstitution {
    public ExtensionInstance`1<IDeclaredElement> ElementExtensionInstance { get; }
    public IReadOnlyList`1<ExtensionInstance`1<IDeclaredElement>> CandidateExtensionInstances { get; }
    public ExtensionMethodResolveResult(IDeclaredElement declaredElement, ISubstitution substitution);
    public ExtensionMethodResolveResult(IResolveResult resolveResult);
    public virtual IResolveResult ReplaceDeclaredElement(IDeclaredElement element);
    public virtual IResolveResult ReplaceSubstitution(ISubstitution candidateSubstitution);
    public sealed virtual ExtensionInstance`1<IDeclaredElement> get_ElementExtensionInstance();
    public sealed virtual IReadOnlyList`1<ExtensionInstance`1<IDeclaredElement>> get_CandidateExtensionInstances();
}
public interface JetBrains.ReSharper.Psi.Impl.resolve.IReferenceImpl {
    [CanBeNullAttribute]
public ResolveResultWithInfo CurrentResolveResult { get; public set; }
    public abstract virtual ResolveResultWithInfo get_CurrentResolveResult();
    public abstract virtual void set_CurrentResolveResult(ResolveResultWithInfo value);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Impl.Resolve.Managed.Calculation : ValueType {
    [CompilerGeneratedAttribute]
private CascadingCacheKey <Cache>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Key>k__BackingField;
    public CascadingCacheKey Cache { get; }
    public object Key { get; }
    [DebuggerStepThroughAttribute]
public Calculation(CascadingCacheKey cache, object key);
    [CompilerGeneratedAttribute]
public CascadingCacheKey get_Cache();
    [CompilerGeneratedAttribute]
public object get_Key();
    public sealed virtual bool Equals(Calculation calculation);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Calculation left, Calculation right);
    public static bool op_Inequality(Calculation left, Calculation right);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Impl.Resolve.Managed.CalculationProcess : object {
    [CanBeNullAttribute]
private ICalculationProcess myParentProcess;
    [CanBeNullAttribute]
private CalculationStack myCalculations;
    private ICascadingCache[] myCaches;
    public ICalculationProcess ParentProcess { get; }
    public IEnumerable`1<ICascadingCache> Caches { get; }
    private CalculationProcess(CalculationProcess parentProcess);
    protected CalculationProcess(CalculationProcess parentProcess, LocalList`1& forkings);
    protected CalculationProcess(CalculationProcess parentProcess, Forking forking);
    public sealed virtual ICalculationProcess get_ParentProcess();
    [NotNullAttribute]
[MustUseReturnValueAttribute]
private ICascadingCache GetCache(CascadingCacheKey key);
    public sealed virtual IEnumerable`1<ICascadingCache> get_Caches();
    public sealed virtual ICalculationProcess TryFork(Forking forking);
    protected virtual ICalculationProcess CreateFork(CalculationProcess parentProcess, Forking forking);
    public sealed virtual ICalculationProcess TryFork(Forking[] forkings);
    protected virtual ICalculationProcess CreateFork(CalculationProcess parentProcess, LocalList`1& forkings);
    public sealed virtual void OnAccessingForkedValueFrom(ICalculationProcess recalledFrom);
    public sealed virtual void Join(ICalculationProcess process);
    public sealed virtual bool HasValue(CascadingCacheKey cacheKey, TKey key);
    public virtual TValue Get(CascadingCacheKey cacheKey, TKey key, TParameter param, IResolveContext resolveContext, Func`4<TKey, TParameter, IResolveContext, TValue> calculator);
    private object GetRecalledValue(Calculation calculation, ICalculationProcess& recalledFrom);
    public virtual void AssignResult(Calculation calculation, object result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.Impl.Resolve.Managed.CalculationStack : object {
    private ICalculationProcess myOwner;
    private ICalculationProcess myDefaultAssignmentTarget;
    [NullableAttribute("0")]
private FrugalLocalHashSet`1<Calculation> myCalculations;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Stack`1<ValueTuple`2<Calculation, ICalculationProcess>> myCalculationStack;
    [NullableAttribute("2")]
private ICalculationProcess myCurrentAssignmentTarget;
    private Nullable`1<Calculation> myCurrentCalculation;
    public CalculationStack(ICalculationProcess process);
    public void Join();
    public void Enter(Calculation calculation);
    public void OnAccessingForkedValueFrom(ICalculationProcess process);
    [NullableContextAttribute("2")]
private static ICalculationProcess DeeperOf(ICalculationProcess process, ICalculationProcess target);
    [NullableContextAttribute("2")]
public ICalculationProcess Leave(Calculation calculation);
}
public class JetBrains.ReSharper.Psi.Impl.Resolve.Managed.CascadingCache : object {
    [NotNullAttribute]
public static object FORGET;
    [NotNullAttribute]
private Dictionary`2<object, object> myData;
    [NotNullAttribute]
private ICalculationProcess myCalculationProcess;
    [CompilerGeneratedAttribute]
private CascadingCacheKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private ICascadingCache <ParentCache>k__BackingField;
    public CascadingCacheKey Key { get; }
    public ICascadingCache ParentCache { get; }
    public CascadingCache(CascadingCacheKey key, ICalculationProcess calculationProcess);
    public CascadingCache(ICascadingCache parentCache, ICalculationProcess calculationProcess);
    private static CascadingCache();
    [CompilerGeneratedAttribute]
public sealed virtual CascadingCacheKey get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual ICascadingCache get_ParentCache();
    public sealed virtual void Assign(object key, object result);
    public sealed virtual bool HasValue(object key);
    public sealed virtual object Recall(object key, ICalculationProcess& recalledFrom);
    public sealed virtual void Join(ICascadingCache cache);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Impl.Resolve.Managed.CircularCalculationException : Exception {
    private string myDump;
    public string Message { get; }
    public string Dump { get; public set; }
    public virtual string get_Message();
    public string get_Dump();
    public void set_Dump(string value);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Impl.Resolve.Managed.Forking : ValueType {
    [NotNullAttribute]
public CascadingCacheKey Cache;
    [NotNullAttribute]
public object Key;
    public object Value;
    [DebuggerStepThroughAttribute]
public Forking(CascadingCacheKey cache, object key, object value);
}
public interface JetBrains.ReSharper.Psi.Impl.Resolve.Managed.ICalculationProcess {
    public ICalculationProcess ParentProcess { get; }
    public IEnumerable`1<ICascadingCache> Caches { get; }
    public abstract virtual ICalculationProcess get_ParentProcess();
    public abstract virtual IEnumerable`1<ICascadingCache> get_Caches();
    [CanBeNullAttribute]
public abstract virtual ICalculationProcess TryFork(Forking forkings);
    [CanBeNullAttribute]
public abstract virtual ICalculationProcess TryFork(Forking[] forkings);
    public abstract virtual void Join(ICalculationProcess process);
    public abstract virtual TValue Get(CascadingCacheKey cacheKey, TKey key, TParameter param, IResolveContext resolveContext, Func`4<TKey, TParameter, IResolveContext, TValue> calculator);
    public abstract virtual bool HasValue(CascadingCacheKey cacheKey, TKey key);
    public abstract virtual void AssignResult(Calculation calculation, object result);
    public abstract virtual void OnAccessingForkedValueFrom(ICalculationProcess recalledFrom);
}
public interface JetBrains.ReSharper.Psi.Impl.Resolve.Managed.ICascadingCache {
    [NotNullAttribute]
public CascadingCacheKey Key { get; }
    [CanBeNullAttribute]
public ICascadingCache ParentCache { get; }
    public abstract virtual CascadingCacheKey get_Key();
    public abstract virtual ICascadingCache get_ParentCache();
    public abstract virtual object Recall(object key, ICalculationProcess& recalledFrom);
    public abstract virtual void Join(ICascadingCache cache);
    public abstract virtual void Assign(object key, object result);
    public abstract virtual bool HasValue(object key);
}
public static class JetBrains.ReSharper.Psi.Impl.Resolve.Managed.PrecalculatedData : object {
    [CanBeNullAttribute]
public static object Get(CascadingCacheKey cacheKey, object key);
    public static void Set(CascadingCacheKey cache, object key, object result);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private static void CheckDataConsistency(CascadingCacheKey cache, object key, object result);
}
public class JetBrains.ReSharper.Psi.Impl.Resolve.Managed.UniversalCalculationProcess : CalculationProcess {
    public virtual TValue Get(CascadingCacheKey cacheKey, TKey key, TParameter param, IResolveContext resolveContext, Func`4<TKey, TParameter, IResolveContext, TValue> calculator);
    public virtual void AssignResult(Calculation calculation, object result);
}
public class JetBrains.ReSharper.Psi.Impl.Resolve.MixedResolveResult : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ExtensionInstance`1<IDeclaredElement>> <CandidateExtensionInstances>k__BackingField;
    public ExtensionInstance`1<IDeclaredElement> ElementExtensionInstance { get; }
    public IReadOnlyList`1<ExtensionInstance`1<IDeclaredElement>> CandidateExtensionInstances { get; }
    public IDeclaredElement DeclaredElement { get; }
    public ISubstitution Substitution { get; }
    public IList`1<IDeclaredElement> Candidates { get; }
    public IList`1<ISubstitution> CandidateSubstitutions { get; }
    public bool IsEmpty { get; }
    public MixedResolveResult(IReadOnlyList`1<ExtensionInstance`1<IDeclaredElement>> candidates);
    public sealed virtual ExtensionInstance`1<IDeclaredElement> get_ElementExtensionInstance();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<ExtensionInstance`1<IDeclaredElement>> get_CandidateExtensionInstances();
    public sealed virtual IDeclaredElement get_DeclaredElement();
    public sealed virtual ISubstitution get_Substitution();
    public sealed virtual IList`1<IDeclaredElement> get_Candidates();
    public sealed virtual IList`1<ISubstitution> get_CandidateSubstitutions();
    public sealed virtual IResolveResult ReplaceDeclaredElement(IDeclaredElement element);
    public sealed virtual IResolveResult ReplaceSubstitution(ISubstitution candidateSubstitution);
    public sealed virtual bool get_IsEmpty();
    public sealed virtual bool IsValid();
    public sealed virtual string Dump();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Impl.Resolve.NamespaceSymbolTable : SymbolTableBase {
    [DebuggerBrowsableAttribute("0")]
private DependencyStore myDependencyStore;
    [NullableAttribute("2")]
[DebuggerBrowsableAttribute("0")]
private string myNamespaceQualifiedName;
    [CompilerGeneratedAttribute]
private INamespace <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbolScope <SymbolScope>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModule <SourceModule>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Level>k__BackingField;
    protected INamespace Namespace { get; }
    protected ISymbolScope SymbolScope { get; }
    protected IPsiModule SourceModule { get; }
    protected int Level { get; }
    [DebuggerBrowsableAttribute("3")]
[PublicAPIAttribute]
private IReadOnlyList`1<ISymbolInfo> NestedElements { get; }
    public NamespaceSymbolTable(INamespace namespace, IPsiModule psiModule, bool withReferences, int level, ISymbolScope cachedSymbolScope);
    [CompilerGeneratedAttribute]
protected INamespace get_Namespace();
    [CompilerGeneratedAttribute]
protected ISymbolScope get_SymbolScope();
    [CompilerGeneratedAttribute]
protected IPsiModule get_SourceModule();
    [CompilerGeneratedAttribute]
protected int get_Level();
    protected virtual ISymbolInfo CreateSymbolInfo(IClrDeclaredElement declaredElement);
    public virtual IList`1<ISymbolInfo> GetSymbolInfos(string name);
    public virtual void AppendSymbolInfos(string name, List`1<ISymbolInfo> consumer);
    public virtual IEnumerable`1<string> Names();
    public virtual bool ForAllSymbolInfos(TState state, Func`3<TState, ISymbolInfo, bool> processor);
    public virtual ISymbolTableDependencySet GetDependencySet();
    public sealed virtual void AddDependenciesTo(IDependencyStore store, string accessName);
    private IReadOnlyList`1<ISymbolInfo> get_NestedElements();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Impl.Resolve.SubstitutedSymbolTable : object {
    [CompilerGeneratedAttribute]
private ISymbolTable <originalTable>P;
    [CompilerGeneratedAttribute]
private ISubstitution <substitution>P;
    public SubstitutedSymbolTable(ISymbolTable originalTable, ISubstitution substitution);
    public sealed virtual IEnumerable`1<string> Names();
    public sealed virtual IList`1<ISymbolInfo> GetSymbolInfos(string name);
    public sealed virtual void AppendSymbolInfos(string name, List`1<ISymbolInfo> consumer);
    public sealed virtual IList`1<ISymbolInfo> GetSymbolInfosConstitutingResolveResult(string name, IResolveInfo& resolveInfo);
    public sealed virtual ISymbolTableDependencySet GetDependencySet();
    public sealed virtual void ForAllSymbolInfos(Action`1<ISymbolInfo> processor);
    public sealed virtual bool ForAllSymbolInfos(TState state, Func`3<TState, ISymbolInfo, bool> processor);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebugView,nq}")]
internal class JetBrains.ReSharper.Psi.Impl.Resolve.SubstitutionImpl : object {
    [DebuggerBrowsableAttribute("3")]
[NotNullAttribute]
private Entry[] myTable;
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private string DebugView { get; }
    [DebuggerBrowsableAttribute("0")]
public IList`1<ITypeParameter> Domain { get; }
    public IType Item { get; }
    public IType Item { get; }
    private int System.Collections.Generic.ICollection<JetBrains.ReSharper.Psi.ITypeParameter>.Count { get; }
    private bool System.Collections.Generic.ICollection<JetBrains.ReSharper.Psi.ITypeParameter>.IsReadOnly { get; }
    private ITypeParameter System.Collections.Generic.IList<JetBrains.ReSharper.Psi.ITypeParameter>.Item { get; private set; }
    private SubstitutionImpl(Entry[] table);
    internal SubstitutionImpl(ICollection`1<KeyValuePair`2<ITypeParameter, IType>> map);
    [ObsoleteAttribute("Do not use it directly, expand EmptySubstitution")]
public SubstitutionImpl(IList`1<ITypeParameter> typeParameters, IList`1<IType> typeArguments);
    [ObsoleteAttribute("Do not use it directly, expand EmptySubstitution")]
internal SubstitutionImpl(ITypeParameter typeParameter, IType value);
    private string get_DebugView();
    public sealed virtual IList`1<ITypeParameter> get_Domain();
    public sealed virtual bool HasInDomain(ITypeParameter typeParameter);
    public sealed virtual bool IsIdempotent(ITypeParameter typeParameter);
    public sealed virtual IType get_Item(ITypeParameter tp);
    public sealed virtual IType get_Item(IType t);
    public sealed virtual IType Apply(ITypeParameter typeParameter);
    public sealed virtual IType Apply(IType type);
    [NotNullAttribute]
private IType ApplyToDeclaredType(IDeclaredType declaredType);
    public sealed virtual ISubstitution Apply(ISubstitution substitution);
    public sealed virtual ISubstitution Extend(ITypeParameter typeParameter, IType value);
    public sealed virtual ISubstitution Extend(IList`1<ITypeParameter> typeParameters, IList`1<IType> values);
    public sealed virtual ISubstitution Extend(IDictionary`2<ITypeParameter, IType> map);
    [PureAttribute]
private static int FindTypeParameterIndex(List`1<Entry> table, ITypeParameter typeParameter);
    public sealed virtual bool IsEmpty();
    public sealed virtual bool IsValid();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual ISubstitution TryTranslateToCurrentFork(IContentModelForkTranslator translator);
    public virtual string ToString();
    [PureAttribute]
private static bool TypeParameterEquals(ITypeElement x, ITypeElement y);
    [PureAttribute]
private static bool IsIdempotent(ITypeParameter typeParameter, IType typeArgument);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<ITypeParameter> System.Collections.Generic.IEnumerable<JetBrains.ReSharper.Psi.ITypeParameter>.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<JetBrains.ReSharper.Psi.ITypeParameter>.Add(ITypeParameter item);
    private sealed virtual override void System.Collections.Generic.ICollection<JetBrains.ReSharper.Psi.ITypeParameter>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<JetBrains.ReSharper.Psi.ITypeParameter>.Contains(ITypeParameter item);
    private sealed virtual override void System.Collections.Generic.ICollection<JetBrains.ReSharper.Psi.ITypeParameter>.CopyTo(ITypeParameter[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<JetBrains.ReSharper.Psi.ITypeParameter>.Remove(ITypeParameter item);
    private sealed virtual override int System.Collections.Generic.ICollection<JetBrains.ReSharper.Psi.ITypeParameter>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<JetBrains.ReSharper.Psi.ITypeParameter>.get_IsReadOnly();
    private sealed virtual override int System.Collections.Generic.IList<JetBrains.ReSharper.Psi.ITypeParameter>.IndexOf(ITypeParameter item);
    private sealed virtual override void System.Collections.Generic.IList<JetBrains.ReSharper.Psi.ITypeParameter>.Insert(int index, ITypeParameter item);
    private sealed virtual override void System.Collections.Generic.IList<JetBrains.ReSharper.Psi.ITypeParameter>.RemoveAt(int index);
    private sealed virtual override ITypeParameter System.Collections.Generic.IList<JetBrains.ReSharper.Psi.ITypeParameter>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<JetBrains.ReSharper.Psi.ITypeParameter>.set_Item(int index, ITypeParameter value);
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Impl.Resolve.SymbolTableCache : InvalidatingPsiCache {
    [NotNullAttribute]
private IPsiModules myPsiModules;
    [NotNullAttribute]
private LazyForkedContentModelData`1<PerContentModelForkStorage> myStorage;
    public SymbolTableCache(Lifetime lifetime, ChangeManager changeManager, IPsiModules psiModules);
    [PureAttribute]
public ISymbolTable GetOrCreate(ITypeElement typeElement, SymbolTableMode mode, IPsiModule requestFromModule, SymbolTableFactory factory);
    [PureAttribute]
public ISymbolTable GetOrCreateOwnTable(ITypeElement element, SymbolTableMode mode, SymbolTableFactory factory);
    [PublicAPIAttribute]
[CanBeNullAttribute]
public ISymbolTable TryGetCachedSymbolTable(ITypeElement element, SymbolTableMode mode);
    protected virtual void InvalidateOnPhysicalChange(PsiChangedElementType elementType);
    private void Invalidate();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <.ctor>b__4_0(ChangeEventArgs args);
}
public class JetBrains.ReSharper.Psi.Impl.RetargetedPsiModuleEqualityComparer : object {
    public static RetargetedPsiModuleEqualityComparer Comparer;
    public static RetargetedPsiModuleEqualityComparer OutputAssemblyComparer;
    private ComparerMode myMode;
    private RetargetedPsiModuleEqualityComparer(ComparerMode mode);
    private static RetargetedPsiModuleEqualityComparer();
    public sealed virtual bool Equals(IPsiModule module1, IPsiModule module2);
    public sealed virtual int GetHashCode(IPsiModule module);
}
public abstract class JetBrains.ReSharper.Psi.Impl.RoslynBasedLanguageLevelHelper`1 : object {
    [NotNullAttribute]
private ConcurrentDictionary`2<VirtualFileSystemPath, VersionMapping<TLanguageLevel>> myCompilerDirectoryToLanguageLevels;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolutionToolset <SolutionToolset>k__BackingField;
    [NotNullAttribute]
public ILogger Logger { get; }
    [NotNullAttribute]
protected ISolutionToolset SolutionToolset { get; }
    [CanBeNullAttribute]
public Version2 ToolsetVersion { get; }
    public string LanguageName { get; }
    protected RoslynBasedLanguageLevelHelper`1(ILogger logger, ISolutionToolset solutionToolset);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
protected ISolutionToolset get_SolutionToolset();
    public Version2 get_ToolsetVersion();
    [PureAttribute]
public abstract virtual TLanguageLevel GetLanguageLevelByToolsetVersion(Version2 toolsetVersion);
    [PureAttribute]
public abstract virtual Nullable`1<VersionMapping<TLanguageLevel>> GetLanguageLevelByCompilerVersion(Version2 roslynVersion);
    [MustUseReturnValueAttribute]
public VersionMapping<TLanguageLevel> GetLanguageLevelByCompiler(VirtualFileSystemPath roslynDirectoryPath);
    public abstract virtual string get_LanguageName();
    [NotNullAttribute]
[PureAttribute]
protected string PresentSpecialLanguageVersion(string specialVersion, string description, LanguageVersionPresentationOptions options);
    [NotNullAttribute]
[PureAttribute]
protected string PresentLanguageVersion(int major, int minor, LanguageVersionPresentationOptions options);
    [CompilerGeneratedAttribute]
private VersionMapping<TLanguageLevel> <GetLanguageLevelByCompiler>g__GetLanguageLevelByToolset|13_0();
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.impl.RuleSet.MsBuildPropertiesFileProcessor : AdditionalFilesModuleFactoryBase {
    [NotNullAttribute]
private GroupingEvent myGroupingProjectModelChanges;
    [CompilerGeneratedAttribute]
private Property`1<bool> <Ready>k__BackingField;
    [CompilerGeneratedAttribute]
private Property`1<bool> <HasStyleCopAnalyzersReference>k__BackingField;
    [NotNullAttribute]
private string myProjectModelChangeDescription;
    [NotNullAttribute]
private string myInitialLoadChangeDescription;
    [NotNullAttribute]
private MsBuildPropertiesFileProperties myFileProperties;
    [NotNullAttribute]
private IFileSystemTracker myFileSystemTracker;
    private JetHashSet`1<ValueTuple`2<string, VirtualFileSystemPath>> myCurrentlyActiveMsBuildPropertiesFiles;
    private FrugalLocalHashSet`1<ValueTuple`2<string, VirtualFileSystemPath>> myDetectedActiveRuleSetsToProcess;
    private FrugalLocalHashSet`1<ValueTuple`2<string, VirtualFileSystemPath>> myDetectedActiveRulesetFilesToRemove;
    private bool myIsRuleSetDropped;
    private bool myLoadStarted;
    [NotNullAttribute]
private object myLockQueue;
    [NotNullAttribute]
public Property`1<bool> Ready { get; public set; }
    [NotNullAttribute]
public Property`1<bool> HasStyleCopAnalyzersReference { get; public set; }
    public MsBuildPropertiesFileProcessor(ISolution solution, ChangeManager changeManager, PsiProjectFileTypeCoordinator coordinator, IProjectFileExtensions extensions, ISolutionLoadTasksScheduler scheduler, Lifetime lifetime, MsBuildPropertiesFilesModuleFactory moduleFactory, ISettingsStore settingsStore, ISettingsSchema settingsSchema, ILogger logger, IFileSystemTracker fileSystemTracker);
    [CompilerGeneratedAttribute]
public Property`1<bool> get_Ready();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Ready(Property`1<bool> value);
    [CompilerGeneratedAttribute]
public Property`1<bool> get_HasStyleCopAnalyzersReference();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HasStyleCopAnalyzersReference(Property`1<bool> value);
    public string LookupProjectPersistentId(VirtualFileSystemPath path);
    protected virtual void OnChangesPropagated(object changeDescription);
    private void ProcessProjectModelChanges();
    private void QueueProjectModelProcessing(MsBuildPropertiesProjectModelChangeVisitor visitor);
    public virtual object Execute(IChangeMap changeMap);
    private void QueueProcessSolution();
    private void ProcessSolution();
    internal void LookForRuleSet(IProject project, FrugalLocalHashSet`1& firstPassSet);
    private void ProcessFilePaths(FrugalLocalHashSet`1& detectedActive, object changeDescription, FrugalLocalHashSet`1& removed);
    protected virtual bool MustAlwaysHaveAdditionalFile(VirtualFileSystemPath oldLocation);
    protected virtual bool ShouldAcceptMiscProjectFile(IProjectFile projectFile);
    protected virtual IPsiSourceFileProperties CreateProperties();
    [CompilerGeneratedAttribute]
private void <QueueProcessSolution>b__25_0();
}
public class JetBrains.ReSharper.Psi.impl.RuleSet.MsBuildPropertiesFileProperties : object {
    public bool ShouldBuildPsi { get; }
    public bool IsGeneratedFile { get; }
    public bool IsICacheParticipant { get; }
    public bool ProvidesCodeModel { get; }
    public bool IsNonUserFile { get; }
    public sealed virtual bool get_ShouldBuildPsi();
    public sealed virtual bool get_IsGeneratedFile();
    public sealed virtual bool get_IsICacheParticipant();
    public sealed virtual bool get_ProvidesCodeModel();
    public sealed virtual bool get_IsNonUserFile();
    public sealed virtual IEnumerable`1<string> GetPreImportedNamespaces();
    public sealed virtual string GetDefaultNamespace();
    public sealed virtual ICollection`1<PreProcessingDirective> GetDefines();
}
[PsiModuleFactoryAttribute("16")]
public class JetBrains.ReSharper.Psi.impl.RuleSet.MsBuildPropertiesFilesModuleFactory : object {
    private static string PersistentId;
    [CompilerGeneratedAttribute]
private PsiModuleOnFileSystemPaths <PsiModule>k__BackingField;
    [CompilerGeneratedAttribute]
private HybridCollection`1<IPsiModule> <Modules>k__BackingField;
    public PsiModuleOnFileSystemPaths PsiModule { get; }
    public HybridCollection`1<IPsiModule> Modules { get; }
    public MsBuildPropertiesFilesModuleFactory(ISolution solution, IFileSystemTracker fileSystemTracker, PsiSourceFileWithLocationTracker psiSourceFileWithLocationTracker, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public PsiModuleOnFileSystemPaths get_PsiModule();
    [CompilerGeneratedAttribute]
public sealed virtual HybridCollection`1<IPsiModule> get_Modules();
    public static bool IsPersistantIdAuthor(IPsiModule module);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.impl.RuleSet.StyleCopAnalyzersProjectEx : object {
    public static string ScAnalyzersName;
    [ExtensionAttribute]
public static bool HasStyleCopAnalyzersReference(IProject project);
    [ExtensionAttribute]
public static bool IsRulesetProjectFile(IProjectFile pf);
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Impl.RuntimeAssembliesManager : object {
    private IPlatformManager myPlatformManager;
    private DebuggerAssembliesRedirector myDebuggerAssembliesRedirector;
    public RuntimeAssembliesManager(IPlatformManager platformManager, DebuggerAssembliesRedirector debuggerAssembliesRedirector);
    public IAssemblyLocation GetRuntimeAssemblyLocation(IAssemblyPsiModule assemblyPsiModule, FrameworkLocationService frameworkLocationService, IModuleReferenceResolveContext resolveContext);
    [CanBeNullAttribute]
private VirtualFileSystemPath FindRuntimeInNuget(IPsiAssembly psiAssembly);
    private static bool IsRuntimeAssemblyByAttribute(IPsiAssembly psiAssembly, TargetFrameworkId targetFrameworkId);
}
internal class JetBrains.ReSharper.Psi.Impl.Search.AnonymousTypeSearchProcessor : SearchProcessorBase {
    public AnonymousTypeSearchProcessor(IFinder finder, IList`1<AnonymousTypeDescriptor> typeDescription, bool caseSensitive);
    public virtual bool ProcessLibraryFile(IPsiAssemblyFile libraryFile, IFindResultConsumer`1<TResult> consumer);
}
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.Impl.Search.CLRDeclaredElementSearcherFactory : DomainSpecificSearcherFactoryBase {
    private SearchDomainFactory mySearchDomainFactory;
    public CLRDeclaredElementSearcherFactory(SearchDomainFactory searchDomainFactory);
    public virtual IEnumerable`1<string> GetAllPossibleWordsInFile(IDeclaredElement element);
    public virtual bool IsSpecialName(string name);
    public virtual bool IsCompatibleWithLanguage(PsiLanguageType languageType);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.Search.CLRDeclaredElementSearcherFactory/<GetRelatedDeclaredElements>d__5")]
public virtual IEnumerable`1<RelatedDeclaredElement> GetRelatedDeclaredElements(IDeclaredElement element);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.Search.CLRDeclaredElementSearcherFactory/<RetargetElement>d__6")]
private static IEnumerable`1<IDeclaredElement> RetargetElement(IDeclaredElement element);
    [NotNullAttribute]
private static IEnumerable`1<ITypeElement> RetargetTypeElement(ITypeElement typeElement);
    public virtual NavigateTargets GetNavigateToTargets(IDeclaredElement element);
    private ISearchDomain GetTypeMemberOwnSearchDomain(ITypeMember typeMember);
    [NotNullAttribute]
private ISearchDomain GetFileLocalTypeSearchDomain(ITypeElement typeElement);
    private ISearchDomain GetNonSharedTypeMemberOwnSearchDomain(IPsiModule psiModule, AccessibilityDomain accessibilityDomain);
    private ISearchDomain GetTypeMemberSearchDomain(ITypeMember member);
    public virtual ISearchDomain GetDeclaredElementSearchDomain(IDeclaredElement declaredElement);
}
internal class JetBrains.ReSharper.Psi.Impl.Search.ConstantExpressionSearchProcessor : SearchProcessorBase {
    public ConstantExpressionSearchProcessor(IFinder finder, ConstantValue constantValue, bool onlyLiteralExpression);
    public virtual bool ProcessLibraryFile(IPsiAssemblyFile libraryFile, IFindResultConsumer`1<TResult> consumer);
}
internal class JetBrains.ReSharper.Psi.Impl.Search.ConstructorSpecialReferenceSearchProcessor : SearchProcessorBase {
    public ConstructorSpecialReferenceSearchProcessor(IFinder finder, ICollection`1<IConstructor> constructors);
    public virtual bool ProcessLibraryFile(IPsiAssemblyFile libraryFile, IFindResultConsumer`1<TResult> consumer);
}
internal class JetBrains.ReSharper.Psi.Impl.Search.Finder : object {
    private IJetReadonlyList`1<IDomainSpecificSearcherFactory> myDomainSpecificSearcherFactories;
    private FinderOperationManager myFinderOperationManager;
    [CompilerGeneratedAttribute]
private IPsiFiles <PsiFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IWordIndex <WordIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    [CompilerGeneratedAttribute]
private IShellLocks <Locks>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ISearchFilter> <SearchFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private SearchDomainFactory <SearchDomainFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParallel>k__BackingField;
    public IPsiFiles PsiFiles { get; }
    public IWordIndex WordIndex { get; }
    public ISolution Solution { get; }
    public IShellLocks Locks { get; }
    public IReadOnlyList`1<ISearchFilter> SearchFilters { get; }
    public SearchDomainFactory SearchDomainFactory { get; }
    public bool IsParallel { get; }
    public IReadOnlyList`1<IDomainSpecificSearcherFactory> DomainSpecificSearcherFactories { get; }
    public Finder(IShellLocks locks, SearchDomainFactory searchDomainFactory, ISolution solution, IPsiFiles psiFiles, IWordIndex wordIndex, IImmutableList`1<ISearchFilter> searchFilters, IImmutableList`1<IDomainSpecificSearcherFactory> domainSpecificSearcherFactories, FinderOperationManager finderOperationManager, bool isParallel);
    [CompilerGeneratedAttribute]
public IPsiFiles get_PsiFiles();
    [CompilerGeneratedAttribute]
public sealed virtual IWordIndex get_WordIndex();
    [CompilerGeneratedAttribute]
public sealed virtual ISolution get_Solution();
    [CompilerGeneratedAttribute]
public IShellLocks get_Locks();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<ISearchFilter> get_SearchFilters();
    [CompilerGeneratedAttribute]
public sealed virtual SearchDomainFactory get_SearchDomainFactory();
    [CompilerGeneratedAttribute]
public bool get_IsParallel();
    public sealed virtual IReadOnlyList`1<IDomainSpecificSearcherFactory> get_DomainSpecificSearcherFactories();
    public sealed virtual void FindImplementingMembers(IOverridableMember member, ITypeElement originType, ISubstitution originSubstitution, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, SearchImplementorsPattern pattern, IProgressIndicator pi);
    public sealed virtual void FindMethodsReferencedByDelegate(IDelegate delegate, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi);
    public sealed virtual void FindTextOccurrences(string subject, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi);
    public sealed virtual void Find(ICollection`1<IDeclaredElement> elements, ISearchDomain searchDomain, IFindResultConsumer`1<TResult> consumer, SearchPattern pattern, IProgressIndicator pi, IFinderSearchRoot root);
    public sealed virtual void FindAsync(ICollection`1<IDeclaredElement> elements, ISearchDomain searchDomain, IFindResultConsumer`1<TResult> consumer, SearchPattern pattern, IProgressIndicator pi, IFinderSearchRoot root, IFinderAsyncCallback callback);
    public sealed virtual void FindReferences(IDeclaredElement element, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi, bool includeDynamic);
    public sealed virtual void FindReferences(IDeclaredElement element, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi, bool includeDynamic, bool onlyExplicitlyTyped);
    public sealed virtual void FindReferencesAsync(IDeclaredElement element, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi, bool includeDynamic, IFinderAsyncCallback callback);
    public sealed virtual void FindReferences(ICollection`1<TElement> elements, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi, bool includeDynamic);
    public sealed virtual void FindReferencesAsync(ICollection`1<TElement> elements, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi, bool includeDynamic, IFinderAsyncCallback callback);
    private FindReferencesOperation`1<TResult> FindReferences(ICollection`1<IDeclaredElement> elements, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, SearchPattern pattern, IProgressIndicator pi);
    public sealed virtual IDeclaredElement[] FindImmediateBaseElements(IDeclaredElement declaredElement, IProgressIndicator pi, bool searchQuasi);
    public sealed virtual void FindImmediateInheritors(ITypeElement typeElement, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi);
    public sealed virtual void FindInheritors(ITypeElement typeElement, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi);
    public sealed virtual void FindInheritors(ITypeElement typeElement, ISymbolScope scope, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi);
    public sealed virtual void FindAnonymousTypes(IList`1<AnonymousTypeDescriptor> signature, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, bool caseSensitive, IProgressIndicator pi);
    public sealed virtual void FindConstantExpressions(ConstantValue constantValue, bool onlyLiteral, ISearchDomain searchDomain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi);
    public sealed virtual IOccurrencesComparer GetOccurrencesComparer(ITreeNode element);
    public sealed virtual IList`1<TElement> FindExpressionOccurrences(TElement element, ITreeNode scope);
    public sealed virtual ICollection`1<RelatedDeclaredElement> GetRelatedElements(IDeclaredElement element);
    public sealed virtual void FindDeclarations(IDeclaredElement declaredElement, IProgressIndicator progressIndicator, IFindResultConsumer`1<TResult> consumer);
}
public class JetBrains.ReSharper.Psi.Impl.search.FinderModuleReferenceResolveContextProvider : object {
    [ThreadStaticAttribute]
private static FinderModuleReferenceResolveContextProvider ourCollector;
    [NotNullAttribute]
private Dictionary`2<IDeclaredElement, IModuleReferenceResolveContext> myInstances;
    public static FinderModuleReferenceResolveContextProvider Create();
    public static FinderModuleReferenceResolveContextProvider Set(FinderModuleReferenceResolveContextProvider provider);
    public sealed virtual void Dispose();
    public static void Register(IDeclaredElement element, IModuleReferenceResolveContext resolveContext);
    public static void Execute(ICollection`1<IDeclaredElement> elements, Action action);
    [CanBeNullAttribute]
private IModuleReferenceResolveContext GetPredefinedContextInternal(ICollection`1<IDeclaredElement> elements);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Impl.Search.FinderUtil : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static String[] GetAllPossibleWordsInFile(IFinder finder, IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasSinglePossibleName(IFinder finder, IDeclaredElement declaredElement);
    [ExtensionAttribute]
public static ISearchDomain NarrowSearchDomain(IFinder finder, ISearchDomain searchDomain, ICollection`1<IDeclaredElement> elements, SearchPattern searchPattern);
    private static ISearchDomain NarrowSearchDomainCore(IFinder finder, ISearchDomain searchDomain, List`1<KeyValuePair`2<IDeclaredElement, ISearchDomain>> elementDomains, HashSet`1<string> searchWords, SearchPattern searchPattern);
    private static ISearchDomain ApplySearchFilters(IEnumerable`1<ISearchFilter> searchFilters, SearchPattern searchPattern, IDeclaredElement element, ISearchDomain domain, SearchDomainFactory factory);
    [ExtensionAttribute]
public static IEnumerable`1<IPsiSourceFile> EnumerateFiles(ISearchDomain elementDomain);
    [ExtensionAttribute]
public static IEnumerable`1<IPsiAssembly> EnumerateAssemblies(ISearchDomain elementDomain);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, sourceFile:notnull; => false, sourceFile:null")]
public static bool IsSingleFileSearchDomain(ISearchDomain searchDomain, IPsiSourceFile& sourceFile);
    public static ValueTuple`2<HashSet`1<string>, int> GetInheritorsClosure(ITypeElement typeElement);
    public static ValueTuple`2<HashSet`1<string>, int> GetInheritorsClosure(IPsiServices psiServices, IClrTypeName clrName);
}
public interface JetBrains.ReSharper.Psi.Impl.Search.ISearchProcessor {
    public abstract virtual bool ProcessProjectItem(IPsiSourceFile sourceFile, IFindResultConsumer`1<TResult> consumer, Func`1<bool> checkForInterrupt);
    public abstract virtual bool ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
    public abstract virtual bool ProcessLibraryFile(IPsiAssemblyFile libraryFile, IFindResultConsumer`1<TResult> consumer);
}
internal class JetBrains.ReSharper.Psi.Impl.Search.LateBoundReferenceSearchProcessor : ReferenceSearchProcessorBase {
    public LateBoundReferenceSearchProcessor(IFinder finder, IDeclaredElementsSet elements, ReferenceSearcherParameters parameters);
    public virtual bool ProcessLibraryFile(IPsiAssemblyFile libraryFile, IFindResultConsumer`1<TResult> consumer);
}
internal class JetBrains.ReSharper.Psi.Impl.Search.LibraryUsageSearchHelper`1 : object {
    private IDeclaredElementsSet myElements;
    private List`1<IClrTypeName> myAttributes;
    private IPsiAssemblyFile myLibraryFile;
    private IFindResultConsumer`1<TResult> myConsumer;
    public LibraryUsageSearchHelper`1(IDeclaredElementsSet elements, IPsiAssemblyFile libraryFile, IFindResultConsumer`1<TResult> consumer);
    public bool Run();
    private void ProcessLibrary();
    private void ProcessAssemblyAttributes();
    private static CustomAttributeTargetPosition CreateAttributeForAssemblyTargetPosition(IDeclaredElement target, IAttributeInstance attributeInstance, IDictionary`2<Pair`2<IConstructor, IDeclaredElement>, int> indices);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.Search.LibraryUsageSearchHelper`1/<FilterRetargetedElements>d__9")]
private IEnumerable`1<IDeclaredElement> FilterRetargetedElements(IEnumerable`1<IDeclaredElement> elements);
    private void ProcessAttributeValueForTypeEquality(IAttributeInstance attributeInstance, AttributeValue attributeValue, IDeclaredElement target, IDictionary`2<Pair`2<IConstructor, IDeclaredElement>, int> indices);
    private static bool CheckForEnumValue(AttributeValue positionParameter, IDeclaredElement target);
    [CanBeNullAttribute]
private IType TryGetIType(IDeclaredElement target);
    private void ProcessDeclaredElement(IDeclaredElement element);
    private void ProcessType(IDeclaredElement owner, IType type, SearchTargetRole role);
    private static IList`1<IDeclaredElement> ResolveReferences(IType aType);
}
public class JetBrains.ReSharper.Psi.Impl.Search.MethodBodiesSearchHelper : object {
    public static IEnumerable`1<MethodUsageInfo> ResolveMethods(IAssemblyPsiModule assemblyPsiModule, IEnumerable`1<MethodUsageCount> mmethods, IMethodBodyUsagesFinder finder, IDeclaredElement searchTarget);
    private static ValueTuple`2<ITypeElement, MetadataToken> ResolveType(IAssemblyPsiModule assemblyPsiModule, IMetadataTypeInfo typeInfo);
    protected static IEnumerable`1<MethodUsageInfo> SearchForMethodUsage(IFunction searchFor, IMethodBodyUsagesFinder finder, IAssemblyPsiModule searchIn, IMetadataAssembly searchForMetadata);
    [CanBeNullAttribute]
protected static IMetadataTypeInfo GetMetadataTypeInfo(IMetadataAssembly asm, ITypeElement typeElement);
    private static CompiledElementBase GetOwner(IClrDeclaredElement declaredElement);
    [CanBeNullAttribute]
protected static IMetadataField GetMetadataField(IMetadataAssembly asm, IField field);
    private static IMetadataMethod GetMetadataMethod(IMetadataAssembly asm, IFunction method);
    private static bool IsCompilerGenerated(IMetadataMethod method);
    private static bool IsCompilerGenerated(IMetadataTypeInfo typeInfo);
    private static bool IsPrivateOrInternalCompilerGenerated(IMetadataMethod method);
    private static bool IsPrivateCompilerGenerated(IMetadataTypeInfo typeInfo);
    private static ITypeMember GetMethod(IAssemblyPsiModule assemblyPsiModule, IMetadataMethod mmethod);
    private static ITypeElement GetType(IAssemblyPsiModule assemblyPsiModule, IMetadataTypeInfo mtype);
    [CompilerGeneratedAttribute]
internal static void <ResolveMethods>g__AddToResult|1_0(IDeclaredElement containingElement, MetadataToken key, int index, <>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static void <ResolveMethods>g__Enqueue|1_1(MethodUsageCount usage, UsageTreeNode parent, <>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static bool <ResolveMethods>g__PathToRootContains|1_2(UsageTreeNode node, MetadataToken token);
    [CompilerGeneratedAttribute]
internal static int <ResolveMethods>g__Compare|1_3(MethodUsageInfo x, MethodUsageInfo y);
}
internal class JetBrains.ReSharper.Psi.Impl.Search.MethodBodiesSearchHelper`1 : MethodBodiesSearchHelper {
    private IFindResultConsumer`1<TResult> myConsumer;
    private OneToListMap`2<IAssemblyPsiModule, IDeclaredElement> myElements;
    private IPsiAssemblyFile myLibraryFile;
    private MetadataLoader myLoader;
    public MethodBodiesSearchHelper`1(IEnumerable`1<IDeclaredElement> elements, IPsiAssemblyFile libraryFile, IFindResultConsumer`1<TResult> consumer);
    public static OneToListMap`2<IAssemblyPsiModule, IDeclaredElement> SelectAndPartitionElements(IEnumerable`1<IDeclaredElement> elements, IPsiAssemblyFile psiAssemblyFile);
    private IMetadataAssembly LoadAssemblyMetadata(IAssemblyLocation assemblyLocation);
    private void Process();
    public bool Run();
    [CompilerGeneratedAttribute]
private void <Process>b__7_0(IEnumerable`1<MethodUsageInfo> methodUsageInfos);
}
internal class JetBrains.ReSharper.Psi.Impl.Search.MethodsReferencedByDelegateSearchProcessor : SearchProcessorBase {
    public MethodsReferencedByDelegateSearchProcessor(IFinder finder, IDelegate delegate);
    public virtual bool ProcessLibraryFile(IPsiAssemblyFile libraryFile, IFindResultConsumer`1<TResult> consumer);
}
public class JetBrains.ReSharper.Psi.Impl.Search.MethodUsageInfo : object {
    [CompilerGeneratedAttribute]
private IDeclaredElement <SearchTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeclaredElement <ContainingElement>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public static int UnknownIndex;
    [CanBeNullAttribute]
public IDeclaredElement SearchTarget { get; }
    [NotNullAttribute]
public IDeclaredElement ContainingElement { get; }
    public int Index { get; }
    public MethodUsageInfo(IDeclaredElement searchTarget, IDeclaredElement containingElement, int index);
    [CompilerGeneratedAttribute]
public IDeclaredElement get_SearchTarget();
    [CompilerGeneratedAttribute]
public IDeclaredElement get_ContainingElement();
    [CompilerGeneratedAttribute]
public int get_Index();
}
public class JetBrains.ReSharper.Psi.Impl.Search.Occurrences.ElementsIndex : object {
    private IOccurrencesFinderImpl myLanguageSpecific;
    private int myIndex;
    private Dictionary`2<IDeclaredElement, int> myMap;
    public Dictionary`2<IDeclaredElement, int> Map { get; }
    public ElementsIndex(IOccurrencesFinderImpl languageSpecific);
    public int GetNewIndex();
    public Dictionary`2<IDeclaredElement, int> get_Map();
    public void ProcessElementForReferences(ITreeNode element);
    private void ProcessReference(IReference reference);
    public void ProcessDelcaration(IDeclaration declaration);
}
public interface JetBrains.ReSharper.Psi.Impl.Search.Occurrences.IOccurrencesFinderImpl {
    public abstract virtual IDeclaredElement GetOriginalElement(IDeclaredElement element);
    public abstract virtual bool CompareLeafNodex(ITreeNode node1, ITreeNode node2);
}
public class JetBrains.ReSharper.Psi.Impl.Search.Occurrences.OccurrencesComparer`1 : object {
    private TElement myExpression;
    private IOccurrencesFinderImpl myLanguageSpecific;
    private ElementsIndex myElementsIndex;
    public OccurrencesComparer`1(TElement expression);
    [NotNullAttribute]
private static IOccurrencesFinderImpl GetLanguageSpecific(PsiLanguageType languageType);
    private ElementsIndex CreateIndex(ITreeNode expression);
    public virtual bool CompareWith(ITreeNode element);
    public IList`1<TElement> Find(ITreeNode scope);
    protected virtual bool AreNodesEquivalent(ITreeNode node1, ITreeNode node2);
    protected virtual bool AreNodesEquivalent(ITreeNode node1, ITreeNode node2, ElementsIndex newIndex);
    private bool CompareElements(IDeclaredElement element1, IDeclaredElement element2, ElementsIndex index);
}
public class JetBrains.ReSharper.Psi.Impl.Search.Occurrences.OccurrencesFinderImplBase : object {
    public virtual IDeclaredElement GetOriginalElement(IDeclaredElement element);
    public virtual bool CompareLeafNodex(ITreeNode node1, ITreeNode node2);
}
public class JetBrains.ReSharper.Psi.Impl.Search.Operations.FinalState : object {
    public static IState Instance;
    private static FinalState();
    public sealed virtual IState Run();
}
public class JetBrains.ReSharper.Psi.Impl.Search.Operations.FinderAsyncCallback : object {
    private Action myComplete;
    private Action`1<string> myError;
    public FinderAsyncCallback(Action complete, Action`1<string> error);
    public sealed virtual void Complete();
    public sealed virtual void Error(string message);
}
public abstract class JetBrains.ReSharper.Psi.Impl.Search.Operations.FinderOperation`1 : FinderOperationBase {
    [NotNullAttribute]
private ISearchDomain mySearchDomain;
    [NotNullAttribute]
private SynchronizedConsumer`1<TResult> myConsumer;
    [NotNullAttribute]
private List`1<IEnumerable> myValidationList;
    private int myPsiTimestamp;
    private static ILogger ourLog;
    [NotNullAttribute]
protected IFindResultConsumer`1<TResult> Consumer { get; }
    [NotNullAttribute]
protected ISearchDomain SearchDomain { get; }
    protected FinderOperation`1(IFinder finder, ICollection`1<IDeclaredElement> elements, ISearchDomain searchDomain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator progressIndicator);
    private static FinderOperation`1();
    protected IFindResultConsumer`1<TResult> get_Consumer();
    protected ISearchDomain get_SearchDomain();
    protected void RegisterCollectionAsOperationState(IEnumerable`1<T> elementCollection);
    protected virtual void CheckValid();
    protected virtual void DoFinish();
}
public abstract class JetBrains.ReSharper.Psi.Impl.Search.Operations.FinderOperationBase : object {
    private static ILogger ourLog;
    [NotNullAttribute]
private Finder myFinder;
    [NotNullAttribute]
private IProgressIndicator myProgressIndicator;
    [NotNullAttribute]
private ICollection`1<IDeclaredElement> myElements;
    [CanBeNullAttribute]
private ICollection`1<IDeclaredElementPointer`1<IDeclaredElement>> myElementPointers;
    private bool myFinished;
    private bool myProcessing;
    [CanBeNullAttribute]
private IState myState;
    public bool IsCanceled { get; }
    public bool IsFinished { get; }
    public bool IsProcessing { get; }
    public ICollection`1<IDeclaredElement> Elements { get; }
    [NotNullAttribute]
private protected Finder Finder { get; }
    [NotNullAttribute]
public IProgressIndicator ProgressIndicator { get; }
    [NotNullAttribute]
protected IState State { get; }
    protected FinderOperationBase(IFinder finder, ICollection`1<IDeclaredElement> elements, IProgressIndicator progressIndicator);
    private static FinderOperationBase();
    public sealed virtual bool get_IsCanceled();
    public sealed virtual bool get_IsFinished();
    public sealed virtual bool get_IsProcessing();
    public sealed virtual ICollection`1<IDeclaredElement> get_Elements();
    private protected Finder get_Finder();
    public sealed virtual IProgressIndicator get_ProgressIndicator();
    protected abstract virtual IState CreateStartState();
    protected IState get_State();
    public sealed virtual void Start();
    [PureAttribute]
protected abstract virtual int CalculateProgressIndicatorWorkUnits();
    protected abstract virtual void CheckValid();
    public virtual void PrepareForReuse();
    protected virtual void DoWork();
    protected virtual void DoFinish();
    protected virtual void RestoreTargets();
}
internal class JetBrains.ReSharper.Psi.Impl.Search.Operations.FinderOperationCollection`2 : object {
    private ICollection`1<TElement> myElements;
    private Func`2<TElement, FinderOperation`1<TResult>> myOperationFactory;
    private JetHashSet`1<TElement> myVisitedElements;
    private FinderOperation`1<TResult> myOperation;
    public FinderOperationCollection`2(ICollection`1<TElement> elements, Func`2<TElement, FinderOperation`1<TResult>> operationFactory);
    public void Start();
}
public class JetBrains.ReSharper.Psi.Impl.Search.Operations.FinderOperationException : Exception {
    public FinderOperationException(string message);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Impl.Search.Operations.FinderOperationManager : object {
    [NotNullAttribute]
private Lifetime myLifetime;
    [NotNullAttribute]
private IShellLocks myShellLocks;
    [NotNullAttribute]
private IPsiFiles myPsiFiles;
    [NotNullAttribute]
private ILogger myLogger;
    [NotNullAttribute]
private ILogger myPerfLogger;
    [NotNullAttribute]
private Stack`1<FinderOperationRequest> myRequests;
    [CanBeNullAttribute]
private InterruptableReadActivityThe myCurrentActivity;
    [NotNullAttribute]
private SequentialLifetimes myCurrentLifetime;
    public FinderOperationManager(Lifetime lifetime, IPsiFiles psiFiles, IShellLocks shellLocks, ILogger logger);
    private void AfterAllDocumentsAreCommited();
    private void AfterCommitInterrupted();
    private void QueueRestart(bool wait);
    private void ActivityCompletedOrCancelled(FinderOperationRequest request, bool completed);
    private void ActivityCancelled(FinderOperationRequest request);
    private void ActivityCompleted(FinderOperationRequest request);
    private void ActivityRun(FinderOperationRequest request);
    public sealed virtual void Run(ICollection`1<IDeclaredElement> declaredElements, Func`2<ICollection`1<IDeclaredElement>, IFinderOperation> factory, IFinderAsyncCallback callback);
    public sealed virtual void RunSync(IFinderOperation operation);
    [CompilerGeneratedAttribute]
private void <QueueRestart>g__CommitAllAsync|11_0();
}
internal class JetBrains.ReSharper.Psi.Impl.Search.Operations.FinderSearchDomainVisitor`1 : SearchDomainVisitor {
    private IShellLocks myShellLocks;
    private ISearchDomain myDomain;
    private ICollection`1<ISearchProcessor> mySearcher;
    private IFindResultConsumer`1<TResult> myConsumer;
    private IProgressIndicator myProgressIndicator;
    private IFinderSearchRoot mySearchRoot;
    private bool myIsParallel;
    private object myProgressIndicatorLocker;
    private HashSet`1<IPsiAssembly> myVisitedAssemblies;
    private HashSet`1<IPsiSourceFile> myVisitedSourceFiles;
    private HashSet`1<ITreeNode> myVisitedElements;
    private static ILogger ourLog;
    private bool myProcessingIsStarted;
    private IProperty`1<bool> myProcessingFinished;
    private ITaskBarrier myTaskBarrier;
    private bool myCurrentTargetFrameworkFinished;
    [CompilerGeneratedAttribute]
private IComparer`1<IPsiModule> <PsiModulesComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private IComparer`1<IPsiSourceFile> <PsiSourceFileComparer>k__BackingField;
    public IComparer`1<IPsiModule> PsiModulesComparer { get; }
    public IComparer`1<IPsiSourceFile> PsiSourceFileComparer { get; }
    public bool ProcessingIsFinished { get; }
    public FinderSearchDomainVisitor`1(IShellLocks shellLocks, ISearchDomain searchDomain, ICollection`1<ISearchProcessor> searchers, IFindResultConsumer`1<TResult> consumer, IProgressIndicator progressIndicator, IFinderSearchRoot root, bool isParallel);
    private static FinderSearchDomainVisitor`1();
    public sealed virtual FinderSearchDomainVisitResult Run();
    [CompilerGeneratedAttribute]
public virtual IComparer`1<IPsiModule> get_PsiModulesComparer();
    [CompilerGeneratedAttribute]
public virtual IComparer`1<IPsiSourceFile> get_PsiSourceFileComparer();
    public virtual void VisitPsiSourceFile(IPsiSourceFile sourceFile);
    public virtual void VisitAssembly(IPsiAssembly assembly);
    protected virtual void BeforePsiModuleVisit(IPsiModule module);
    public virtual void VisitPsiModule(IPsiModule module);
    public virtual void VisitPsiModuleSearchDomainNode(PsiModuleSearchDomainNode psiModuleNode);
    public virtual void VisitElement(ITreeNode element);
    public virtual bool get_ProcessingIsFinished();
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Impl.Search.Operations.FinderSearchDomainVisitorFactory : object {
    private IShellLocks myShellLocks;
    public FinderSearchDomainVisitorFactory(IShellLocks shellLocks);
    public virtual IFinderSearchDomainVisitor Create(ISearchDomain searchDomain, ICollection`1<ISearchProcessor> searchers, IFindResultConsumer`1<TResult> consumer, IProgressIndicator progressIndicator, IFinderSearchRoot root, bool isParallel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[RequiredMemberAttribute]
public class JetBrains.ReSharper.Psi.Impl.Search.Operations.FinderSearchDomainVisitResult : ValueType {
    [CompilerGeneratedAttribute]
private HashSet`1<IPsiAssembly> <VisitedAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<IPsiSourceFile> <VisitedSourceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<ITreeNode> <VisitedNodes>k__BackingField;
    [RequiredMemberAttribute]
public HashSet`1<IPsiAssembly> VisitedAssemblies { get; public set; }
    [RequiredMemberAttribute]
public HashSet`1<IPsiSourceFile> VisitedSourceFiles { get; public set; }
    [RequiredMemberAttribute]
public HashSet`1<ITreeNode> VisitedNodes { get; public set; }
    [CompilerGeneratedAttribute]
public HashSet`1<IPsiAssembly> get_VisitedAssemblies();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_VisitedAssemblies(HashSet`1<IPsiAssembly> value);
    [CompilerGeneratedAttribute]
public HashSet`1<IPsiSourceFile> get_VisitedSourceFiles();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_VisitedSourceFiles(HashSet`1<IPsiSourceFile> value);
    [CompilerGeneratedAttribute]
public HashSet`1<ITreeNode> get_VisitedNodes();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_VisitedNodes(HashSet`1<ITreeNode> value);
}
public class JetBrains.ReSharper.Psi.Impl.Search.Operations.FinderSearchRoot : object {
    public static IFinderSearchRoot Empty;
    [CompilerGeneratedAttribute]
private ICollection`1<IPsiSourceFile> <SourceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<DeclaredElementEnvoy`1<IDeclaredElement>> <OriginalElements>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetFrameworkId <TargetFrameworkId>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectWithTestsDetector <ProjectWithTestDetector>k__BackingField;
    public ICollection`1<IPsiSourceFile> SourceFiles { get; }
    [CanBeNullAttribute]
public ICollection`1<DeclaredElementEnvoy`1<IDeclaredElement>> OriginalElements { get; }
    public TargetFrameworkId TargetFrameworkId { get; }
    public IProjectWithTestsDetector ProjectWithTestDetector { get; }
    public FinderSearchRoot(ICollection`1<IPsiSourceFile> sourceFiles, List`1<DeclaredElementEnvoy`1<IDeclaredElement>> originalElements, TargetFrameworkId targetFrameworkId, IProjectWithTestsDetector projectWithTestDetector);
    private static FinderSearchRoot();
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<IPsiSourceFile> get_SourceFiles();
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<DeclaredElementEnvoy`1<IDeclaredElement>> get_OriginalElements();
    [CompilerGeneratedAttribute]
public sealed virtual TargetFrameworkId get_TargetFrameworkId();
    [CompilerGeneratedAttribute]
public sealed virtual IProjectWithTestsDetector get_ProjectWithTestDetector();
}
public interface JetBrains.ReSharper.Psi.Impl.Search.Operations.IFinderAsyncCallback {
    public abstract virtual void Complete();
    public abstract virtual void Error(string message);
}
public interface JetBrains.ReSharper.Psi.Impl.Search.Operations.IFinderOperation {
    public bool IsCanceled { get; }
    public bool IsFinished { get; }
    public bool IsProcessing { get; }
    public IProgressIndicator ProgressIndicator { get; }
    [NotNullAttribute]
public ICollection`1<IDeclaredElement> Elements { get; }
    public abstract virtual bool get_IsCanceled();
    public abstract virtual bool get_IsFinished();
    public abstract virtual bool get_IsProcessing();
    public abstract virtual IProgressIndicator get_ProgressIndicator();
    public abstract virtual void PrepareForReuse();
    public abstract virtual ICollection`1<IDeclaredElement> get_Elements();
    public abstract virtual void Start();
}
public interface JetBrains.ReSharper.Psi.Impl.Search.Operations.IFinderOperationManager {
    public abstract virtual void Run(ICollection`1<IDeclaredElement> declaredElements, Func`2<ICollection`1<IDeclaredElement>, IFinderOperation> factory, IFinderAsyncCallback callback);
    public abstract virtual void RunSync(IFinderOperation operation);
}
public interface JetBrains.ReSharper.Psi.Impl.Search.Operations.IFinderSearchDomainVisitor {
    public abstract virtual FinderSearchDomainVisitResult Run();
}
public interface JetBrains.ReSharper.Psi.Impl.Search.Operations.IFinderSearchRoot {
    [NotNullAttribute]
public ICollection`1<IPsiSourceFile> SourceFiles { get; }
    [CanBeNullAttribute]
public ICollection`1<DeclaredElementEnvoy`1<IDeclaredElement>> OriginalElements { get; }
    [CanBeNullAttribute]
public TargetFrameworkId TargetFrameworkId { get; }
    [CanBeNullAttribute]
public IProjectWithTestsDetector ProjectWithTestDetector { get; }
    public abstract virtual ICollection`1<IPsiSourceFile> get_SourceFiles();
    public abstract virtual ICollection`1<DeclaredElementEnvoy`1<IDeclaredElement>> get_OriginalElements();
    public abstract virtual TargetFrameworkId get_TargetFrameworkId();
    public abstract virtual IProjectWithTestsDetector get_ProjectWithTestDetector();
}
internal class JetBrains.ReSharper.Psi.Impl.Search.Operations.Impl.FilteringInheritorsConsumer`1 : object {
    private Predicate`1<ITypeElement> myFilter;
    private IFindResultConsumer`1<TResult> myConsumer;
    public FilteringInheritorsConsumer`1(SearchPattern pattern, IFindResultConsumer`1<TResult> consumer);
    public sealed virtual TResult Build(FindResult result);
    public sealed virtual FindExecution Merge(TResult data);
}
internal class JetBrains.ReSharper.Psi.Impl.Search.Operations.Impl.FindAnonymousTypesOperation`1 : SimpleFinderOperation`1<TResult> {
    private ICollection`1<ISearchProcessor> mySearchProcessors;
    protected ICollection`1<ISearchProcessor> SearchProcessors { get; }
    public FindAnonymousTypesOperation`1(Finder finder, IList`1<AnonymousTypeDescriptor> signature, ISearchDomain searchDomain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator progressIndicator, bool caseSensitive);
    private static ISearchDomain NarrowSearchDomainByAllWords(Finder finder, ISearchDomain searchDomain, IEnumerable`1<AnonymousTypeDescriptor> signature);
    public static ISearchDomain NarrowSearchDomainByAllWords(ISolution solution, ISearchDomain searchDomain, String[] words);
    protected virtual ICollection`1<ISearchProcessor> get_SearchProcessors();
}
internal class JetBrains.ReSharper.Psi.Impl.Search.Operations.Impl.FindConstantExpressionsOperation`1 : SimpleFinderOperation`1<TResult> {
    private ICollection`1<ISearchProcessor> mySearchProcessors;
    protected ICollection`1<ISearchProcessor> SearchProcessors { get; }
    public FindConstantExpressionsOperation`1(Finder finder, ConstantValue constantValue, bool onlyLiteral, ISearchDomain searchDomain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator progressIndicator);
    protected virtual ICollection`1<ISearchProcessor> get_SearchProcessors();
}
public class JetBrains.ReSharper.Psi.Impl.Search.Operations.Impl.FindImplementingMembersOperation`1 : FinderOperation`1<TResult> {
    private Dictionary`2<OverridableMemberInstance, Pair`2<InheritanceKind, ITypeElement>> myResults;
    private HashSet`1<OverridableMemberInstance> mySearchForRegularRoots;
    private JetHashSet`1<ITypeElement> myVisitedInterfaces;
    private JetHashSet`1<ITypeElement> myVisited;
    private IOverridableMember myOverridableMember;
    private ITypeElement myOriginType;
    private ISubstitution myOriginSubstitution;
    private bool mySearchQuasi;
    private bool mySearchOnlyImmediate;
    private bool myFindHiddenMembers;
    [CanBeNullAttribute]
private ISearchDomain myDomain;
    private JetHashSet`1<IClass> mySearchForQuasiRoots;
    private Queue`1<IInterface> myExtendingInterfaces;
    private JetHashSet`1<ITypeElement> myImplementations;
    private ITaskBarrier myTaskBarrier;
    private ISymbolScope mySymbolScope;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) myShouldStop;
    public FindImplementingMembersOperation`1(IFinder finder, IOverridableMember overridableMember, ITypeElement originType, ISubstitution originSubstitution, bool searchQuasi, bool onlyImmediate, bool findHiddenMembers, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator progressIndicator);
    private static ICollection`1<IDeclaredElement> DeclaredElements(IOverridableMember overridableMember, ITypeElement originType);
    private IState Init();
    protected virtual IState CreateStartState();
    protected virtual int CalculateProgressIndicatorWorkUnits();
    private IState FindInterface();
    private void EnqueueFindImplementingMembers(ITypeElement implementation, bool onlyExplicit, bool shouldCheckQuasi);
    private bool FindImplementingMembers(ITypeElement implementation, bool onlyExplicit);
    private bool FindImplementingMembersOfInterface(ITypeElement type, ISubstitution ancestorSubstitution, bool onlyExplicit);
    private IState FindImplementingMembersInSubclassesForInterface();
    private IState FindQuasiImplementations();
    private IState FindImplementation();
    private void FindImplementingMembersInSubclasses(ITypeElement type, OverridableMemberInstance superMember, InheritanceKind foundMemberKind);
    private void FindImplementingMembersInClass(ITypeElement type, OverridableMemberInstance superMember, InheritanceKind foundMemberKind);
    private void SearchForQuasiImplementations(IClass root);
    private void AddResult(IOverridableMember overridableMember, ISubstitution substitutionOfSuper, ITypeElement quasiBasis, InheritanceKind kind);
}
internal class JetBrains.ReSharper.Psi.Impl.Search.Operations.Impl.FindInheritorsOperation`1 : FinderOperation`1<TResult> {
    private static ILogger ourLog;
    private static IEqualityComparer`1<ITypeElement> ourComparer;
    private static IEqualityComparer`1<ITypeElement> ourCacheComparer;
    private ITypeElement myTypeElement;
    private bool myFindOnlyImmediateInheritors;
    private ISymbolScope myCache;
    private HashSet`1<ITypeElement> myFoundElements;
    private HashSet`1<ITypeElement> myConsumedElements;
    private object myCacheLock;
    private OneToSetMap`2<ITypeElement, ITypeElement> mySuperTypesCache;
    private ConcurrentDictionary`2<ITypeElement, ITypeElement> mySuperClassCache;
    private bool myShouldStop;
    public FindInheritorsOperation`1(Finder finder, ITypeElement typeElement, bool onlyImmediateInheritors, IFindResultConsumer`1<TResult> consumer, IProgressIndicator progressIndicator);
    public FindInheritorsOperation`1(Finder finder, ITypeElement typeElement, ISymbolScope symbolScope, bool onlyImmediateInheritors, IFindResultConsumer`1<TResult> consumer, IProgressIndicator progressIndicator);
    private static FindInheritorsOperation`1();
    [NotNullAttribute]
public static ISymbolScope GetSymbolScope(ITypeElement typeElement);
    private IState Find();
    private void TraceResults();
    private void FindInheritors(ITypeElement baseType, ITaskBarrier taskBarrier);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.Search.Operations.Impl.FindInheritorsOperation`1/<AllClasses>d__18`1")]
private IEnumerable`1<ITypeElement> AllClasses();
    private bool IsImmediateSuperType(ITypeElement derived, ITypeElement parent);
    private void FoundInheritor(ITypeElement subTypeElement);
    protected virtual IState CreateStartState();
    protected virtual int CalculateProgressIndicatorWorkUnits();
}
internal class JetBrains.ReSharper.Psi.Impl.Search.Operations.Impl.FindMethodsReferencedByDelegateOperation`1 : SimpleFinderOperation`1<TResult> {
    private ICollection`1<ISearchProcessor> mySearchProcessors;
    protected ICollection`1<ISearchProcessor> SearchProcessors { get; }
    public FindMethodsReferencedByDelegateOperation`1(Finder finder, ICollection`1<IDelegate> delegates, ISearchDomain searchDomain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator progressIndicator);
    public FindMethodsReferencedByDelegateOperation`1(Finder finder, IDelegate delegate, ISearchDomain searchDomain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator progressIndicator);
    protected virtual ICollection`1<ISearchProcessor> get_SearchProcessors();
    [CompilerGeneratedAttribute]
private MethodsReferencedByDelegateSearchProcessor <.ctor>b__1_0(IDelegate delegate);
}
internal class JetBrains.ReSharper.Psi.Impl.Search.Operations.Impl.FindOperation`1 : FinderOperation`1<TResult> {
    private static SearchPattern UsagesMask;
    private IFinderSearchRoot mySearchRoot;
    private FilteringInheritorsConsumer`1<TResult> myFilteringInheritorsConsumer;
    private List`1<ITypeElement> myTypeElements;
    private List`1<IOverridableMember> myOverridableMembers;
    private SearchPattern myPattern;
    private int myProgressParts;
    [CanBeNullAttribute]
private FindReferencesOperation`1<TResult> myFindReferencesOperation;
    [CanBeNullAttribute]
private FindMethodsReferencedByDelegateOperation`1<TResult> myFindMethodsReferencedByDelegateOperation;
    private FinderOperationCollection`2<ITypeElement, TResult> mySearchDerivedTypesOperationCollection;
    private FinderOperationCollection`2<IOverridableMember, TResult> mySearchImplementingMembersOperationCollection;
    private bool myReuse;
    public FindOperation`1(Finder finder, ICollection`1<IDeclaredElement> elements, ISearchDomain searchDomain, IFindResultConsumer`1<TResult> consumer, SearchPattern pattern, IProgressIndicator progressIndicator, IFinderSearchRoot root);
    private IState Analyze();
    private IState SearchReferences();
    private IState SearchMethodsReferencedByDelegate();
    private IState SearchImplementingMembers();
    private FinderOperation`1<TResult> SearchImplementingMembersOperationFactory(IOverridableMember overridableMember);
    private IState SearchDerivedTypes();
    private FinderOperation`1<TResult> SearchDerivedTypesOperationFactory(ITypeElement typeElement);
    private IState ValidatePattern();
    protected virtual IState CreateStartState();
    protected virtual int CalculateProgressIndicatorWorkUnits();
    public virtual void PrepareForReuse();
}
public class JetBrains.ReSharper.Psi.Impl.Search.Operations.Impl.FindReferencesOperation`1 : FinderOperation`1<TResult> {
    private static ILogger ourLog;
    private SearchPattern myPattern;
    private IFinderSearchRoot mySearchRoot;
    private List`1<ISearchProcessor> mySearchers;
    private JetHashSet`1<IDeclaredElement> myFindUsagesAllElements;
    private JetHashSet`1<IDeclaredElement> myFindUsagesImplementors;
    private JetHashSet`1<ITypeElement> myFindUsagesImplementatorContainerTypes;
    private JetHashSet`1<IOverridableMember> myOverridableMembers;
    private OneToListMap`2<IDeclaredElement, Predicate`1<IFindResultReference>> myDerivedFindElements;
    private Dictionary`2<IDeclaredElement, FindResult> myDerivedToOriginalMap;
    private IFindResultConsumer`1<TResult> myResultConsumer;
    private ISearchDomain myNarrowedSearchDomain;
    private IProgressIndicator myFindImplementingMemberProgress;
    [CanBeNullAttribute]
private IFinderSearchDomainVisitor myVisitor;
    [CanBeNullAttribute]
private IFinderSearchDomainVisitor myCtorSearchDomainVisitor;
    [CanBeNullAttribute]
private FindReferencesOperation`1<TResult> myDerivedFindReferencesOperation;
    private FinderOperationCollection`2<IOverridableMember, IDeclaredElement> myFindImplementingMembersOperationCollection;
    private FinderSearchDomainVisitorFactory myFinderSearchDomainVisitorFactory;
    private bool myReuse;
    private static double TotalProgressFraction;
    private static double ConstructorsProgressFraction;
    private static double ImplicitUsagesProgressFraction;
    public FindReferencesOperation`1(IFinder finder, ICollection`1<IDeclaredElement> elements, ISearchDomain searchDomain, IFindResultConsumer`1<TResult> consumer, SearchPattern pattern, IProgressIndicator progressIndicator, IFinderSearchRoot root);
    private static FindReferencesOperation`1();
    private IState Init();
    private IState ProcessConstructors();
    private IState ProcessFindImplementatorsUsages();
    private IState ProcessRelatedElements();
    private IState ConsumeRelatedFindResult();
    private IState ConstructReferenceSearchProcessor();
    private IState ProcessOther();
    private IState Find();
    private void FindAdditionalImplicitUsages(TwoPhaseImplicitUsagesSearchProcessor implicitUsagesSearchProcessor, HashSet`1<IPsiSourceFile> processedFilesFromNamedSearch);
    private IState FindDerived();
    protected virtual IState CreateStartState();
    protected virtual int CalculateProgressIndicatorWorkUnits();
    public virtual void PrepareForReuse();
    [CompilerGeneratedAttribute]
private FinderOperation`1<IDeclaredElement> <ProcessFindImplementatorsUsages>b__25_0(IOverridableMember member);
    [CompilerGeneratedAttribute]
private FindResult <ProcessFindImplementatorsUsages>b__25_1(FindResult result);
    [CompilerGeneratedAttribute]
private FindResult <ProcessRelatedElements>b__26_1(FindResult result);
    [CompilerGeneratedAttribute]
private FindResult <FindDerived>b__32_0(FindResult result);
}
internal class JetBrains.ReSharper.Psi.Impl.Search.Operations.Impl.FindTextOccurrencesOperation`1 : SimpleFinderOperation`1<TResult> {
    private ICollection`1<ISearchProcessor> mySearchProcessors;
    protected ICollection`1<ISearchProcessor> SearchProcessors { get; }
    public FindTextOccurrencesOperation`1(Finder finder, string subject, ISearchDomain searchDomain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator progressIndicator);
    protected virtual ICollection`1<ISearchProcessor> get_SearchProcessors();
}
public interface JetBrains.ReSharper.Psi.Impl.Search.Operations.IProjectWithTestsDetector {
    public abstract virtual bool HasTests(IProject project);
}
public interface JetBrains.ReSharper.Psi.Impl.Search.Operations.IState {
    public abstract virtual IState Run();
}
internal class JetBrains.ReSharper.Psi.Impl.Search.Operations.PsiModuleComparer : object {
    [CanBeNullAttribute]
private TargetFrameworkId myTargetFramework;
    private JetHashSet`1<IPsiModule> myModules;
    private JetHashSet`1<TargetFrameworkId> myPlatformIds;
    private IFinderSearchRoot mySearchRoot;
    public PsiModuleComparer(IFinderSearchRoot searchRoot);
    public sealed virtual int Compare(IPsiModule x, IPsiModule y);
    public bool IsRootModule(IPsiModule x);
}
public class JetBrains.ReSharper.Psi.Impl.Search.Operations.PsiSourceFileComparer : object {
    private PsiModuleComparer myModuleComparer;
    private JetHashSet`1<IProjectFile> myProjectFile;
    private JetHashSet`1<IProjectFolder> myProjectFolder;
    public PsiSourceFileComparer(IFinderSearchRoot searchRoot);
    public sealed virtual int Compare(IPsiSourceFile x, IPsiSourceFile y);
    private int CompareByNearby(IPsiSourceFile x, IPsiSourceFile y);
    public int CompareByPath(IPsiSourceFile x, IPsiSourceFile y);
}
internal abstract class JetBrains.ReSharper.Psi.Impl.Search.Operations.SimpleFinderOperation`1 : FinderOperation`1<TResult> {
    private FinderSearchDomainVisitorFactory myFinderSearchDomainVisitorFactory;
    private IFinderSearchDomainVisitor myVisitor;
    protected ICollection`1<ISearchProcessor> SearchProcessors { get; }
    protected SimpleFinderOperation`1(Finder finder, ICollection`1<IDeclaredElement> elements, ISearchDomain searchDomain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator progressIndicator);
    protected abstract virtual ICollection`1<ISearchProcessor> get_SearchProcessors();
    protected virtual IState CreateStartState();
    protected virtual int CalculateProgressIndicatorWorkUnits();
    private IState Find();
}
public class JetBrains.ReSharper.Psi.Impl.Search.Operations.State : object {
    private Func`1<IState> myAction;
    public State(Func`1<IState> action);
    public sealed virtual IState Run();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Impl.Search.ReferenceSearchProcessor : ReferenceSearchProcessorBase {
    public ReferenceSearchProcessor(IFinder finder, IDeclaredElementsSet elements, ReferenceSearcherParameters parameters);
    public virtual bool ProcessLibraryFile(IPsiAssemblyFile libraryFile, IFindResultConsumer`1<TResult> consumer);
}
internal abstract class JetBrains.ReSharper.Psi.Impl.Search.ReferenceSearchProcessorBase : SearchProcessorBase {
    private IDeclaredElementsSet myElements;
    private Dictionary`2<Type, ICollection`1<string>> myWordsCache;
    protected IDeclaredElementsSet Elements { get; }
    protected ReferenceSearchProcessorBase(IFinder finder, IDeclaredElementsSet elements, Func`2<IDomainSpecificSearcherFactory, IDomainSpecificSearcher> createSearcher);
    protected IDeclaredElementsSet get_Elements();
    protected virtual bool FilterByWordIndex(IDomainSpecificSearcherFactory factory, IPsiSourceFile sourceFile);
}
public static class JetBrains.ReSharper.Psi.Impl.Search.SearchDomain.DomainMeasuringHelper : object {
    public static int Measure(ISearchDomain searchDomain);
    public static int MeasureWithoutElements(ISearchDomain searchDomain);
}
public class JetBrains.ReSharper.Psi.Impl.Search.SearchDomain.DomainMeasuringVisitor : SearchDomainVisitor {
    [CompilerGeneratedAttribute]
private int <FileCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ElementCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AssemblyCount>k__BackingField;
    public int FileCount { get; private set; }
    public int ElementCount { get; private set; }
    public int AssemblyCount { get; private set; }
    public bool ProcessingIsFinished { get; }
    [CompilerGeneratedAttribute]
public int get_FileCount();
    [CompilerGeneratedAttribute]
private void set_FileCount(int value);
    [CompilerGeneratedAttribute]
public int get_ElementCount();
    [CompilerGeneratedAttribute]
private void set_ElementCount(int value);
    [CompilerGeneratedAttribute]
public int get_AssemblyCount();
    [CompilerGeneratedAttribute]
private void set_AssemblyCount(int value);
    public virtual void VisitElement(ITreeNode element);
    public virtual void VisitPsiSourceFile(IPsiSourceFile sourceFile);
    public virtual void VisitAssembly(IPsiAssembly assembly);
    public virtual bool get_ProcessingIsFinished();
}
public static class JetBrains.ReSharper.Psi.Impl.Search.SearchDomain.EmptySearchDomain : object {
    public static ISearchDomain Instance;
    private static EmptySearchDomain();
}
[DebuggerTypeProxyAttribute("JetBrains.ReSharper.Psi.Impl.Search.SearchDomain.PsiSearchDomainDebugView")]
internal class JetBrains.ReSharper.Psi.Impl.Search.SearchDomain.PsiSearchDomain : object {
    private RootSearchDomainNode myRoot;
    [NotNullAttribute]
public static PsiSearchDomain Empty;
    public bool IsEmpty { get; }
    [NotNullAttribute]
internal string PresentableDescription { get; }
    public bool HasPhysicalPart { get; }
    private PsiSearchDomain(RootSearchDomainNode root);
    private static PsiSearchDomain();
    private void AddPhysicalElement(IPsiSourceFile sourceFile, ITreeNode element);
    private void AddSandBoxElement(ITreeNode element);
    private void AddSourceFile(IPsiSourceFile sourceFile);
    private void AddPsiModule(IPsiModule psiModule);
    [NotNullAttribute]
internal static ISearchDomain FromSolution(ISolution solution, bool includeLibraries);
    [NotNullAttribute]
internal static ISearchDomain FromLibraries(ISolution solution);
    [NotNullAttribute]
internal static ISearchDomain FromPsiModules(IEnumerable`1<IPsiModule> psiModules);
    [NotNullAttribute]
internal static ISearchDomain FromProjectFiles(IEnumerable`1<IPsiSourceFile> psiSourceFiles);
    [NotNullAttribute]
internal static ISearchDomain FromProjectFiles(HybridCollection`1<IPsiSourceFile> psiSourceFiles);
    [NotNullAttribute]
internal static ISearchDomain FromElements(IEnumerable`1<ITreeNode> elements);
    public sealed virtual bool get_IsEmpty();
    internal string get_PresentableDescription();
    public sealed virtual ISearchDomain Intersect(ISearchDomain otherDomain);
    public sealed virtual ISearchDomain Union(ISearchDomain otherDomain);
    public sealed virtual bool HasIntersectionWith(IDeclaredElement declaredElement);
    public sealed virtual void Accept(SearchDomainVisitor visitor);
    public sealed virtual void Dump(TextWriter to);
    public sealed virtual bool Contains(ISearchDomain otherDomain);
    public sealed virtual bool get_HasPhysicalPart();
    public sealed virtual ISearchDomain ExtractNonPhysicalDomain();
    public sealed virtual ISearchDomain ExtractLibraryDomain();
    public sealed virtual bool Equals(ISearchDomain other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public sealed virtual bool IsValid();
}
internal class JetBrains.ReSharper.Psi.Impl.Search.SearchDomain.PsiSearchDomainDebugView : object {
    private PsiSearchDomain mySearchDomain;
    [UsedImplicitlyAttribute]
public string AsText { get; }
    public PsiSearchDomainDebugView(PsiSearchDomain searchDomain);
    public string get_AsText();
}
[PsiSharedComponentAttribute]
internal class JetBrains.ReSharper.Psi.Impl.Search.SearchDomain.SearchDomainFactoryImpl : SearchDomainFactory {
    public virtual ISearchDomain CreateSearchDomain(IPsiSourceFile sourceFile);
    public virtual ISearchDomain CreateSearchDomain(IEnumerable`1<IPsiSourceFile> psiSourceFiles);
    public virtual ISearchDomain CreateSearchDomain(HybridCollection`1<IPsiSourceFile> psiSourceFiles);
    public virtual ISearchDomain CreateLibrariesDomain(ISolution solution);
    public virtual ISearchDomain CreateSearchDomain(ISolution solution, bool includeLibraries);
    public virtual ISearchDomain CreateSearchDomain(ITreeNode sourceElement);
    public virtual ISearchDomain CreateSearchDomain(IEnumerable`1<ITreeNode> sourceElements);
    public virtual ISearchDomain CreatePublicAccessibilityDomain(IPsiModule module);
    public virtual ISearchDomain CreatePublicAccessibilityDomain(IEnumerable`1<IPsiModule> modules);
    public virtual ISearchDomain CreateInternalAccessibilityDomain(IPsiModule module);
    public virtual ISearchDomain CreateSearchDomain(IPsiModule module);
    public virtual ISearchDomain CreateSearchDomain(IEnumerable`1<IPsiModule> modules);
    public virtual ISearchDomain CreateSearchDomain(IProjectModelElement item);
}
public abstract class JetBrains.ReSharper.Psi.Impl.Search.SearchProcessorBase : object {
    private static int LOGGER_THRESHOLD;
    [NotNullAttribute]
private ILogger myLogger;
    private Dictionary`2<IDomainSpecificSearcherFactory, IDomainSpecificSearcher> mySearchers;
    protected SearchProcessorBase(IFinder finder, Func`2<IDomainSpecificSearcherFactory, IDomainSpecificSearcher> createSearcher);
    public sealed virtual bool ProcessProjectItem(IPsiSourceFile sourceFile, IFindResultConsumer`1<TResult> consumer, Func`1<bool> checkForInterrupt);
    public sealed virtual bool ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
    public abstract virtual bool ProcessLibraryFile(IPsiAssemblyFile libraryFile, IFindResultConsumer`1<TResult> consumer);
    protected virtual bool FilterByWordIndex(IDomainSpecificSearcherFactory factory, IPsiSourceFile sourceFile);
}
internal class JetBrains.ReSharper.Psi.Impl.Search.TextOccurrenceSearchProcessor : SearchProcessorBase {
    internal TextOccurrenceSearchProcessor(IFinder finder, IDeclaredElementsSet elements);
    public virtual bool ProcessLibraryFile(IPsiAssemblyFile libraryFile, IFindResultConsumer`1<TResult> consumer);
}
public class JetBrains.ReSharper.Psi.Impl.Search.TextOccurrenceStringSearchProcessor : SearchProcessorBase {
    internal TextOccurrenceStringSearchProcessor(IFinder finder, string subject);
    public virtual bool ProcessLibraryFile(IPsiAssemblyFile libraryFile, IFindResultConsumer`1<TResult> consumer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.Impl.Search.TwoPhaseImplicitUsagesSearchProcessor : object {
    private IReadOnlyList`1<ITwoPhaseDomainSpecificSearcher> mySearchers;
    private TwoPhaseImplicitUsagesSearchProcessor(IReadOnlyList`1<ITwoPhaseDomainSpecificSearcher> searchers);
    public static TwoPhaseImplicitUsagesSearchProcessor TryCreate(IFinder finder, SearchPattern searchPattern, ICollection`1<IDeclaredElement> declaredElements);
    public IReadOnlyList`1<ValueTuple`2<ISearchProcessor, ISearchDomain>> CreateSecondPhaseSearchProcessors(SearchDomainFactory searchDomainFactory, ISearchDomain originalSearchDomain, HashSet`1<IPsiSourceFile> processedFiles);
    public sealed virtual bool ProcessProjectItem(IPsiSourceFile sourceFile, IFindResultConsumer`1<TResult> consumer, Func`1<bool> checkForInterrupt);
    public sealed virtual bool ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
    public sealed virtual bool ProcessLibraryFile(IPsiAssemblyFile libraryFile, IFindResultConsumer`1<TResult> consumer);
}
public static class JetBrains.ReSharper.Psi.Impl.Search.WordIndexExtensions : object {
}
public class JetBrains.ReSharper.Psi.Impl.Shared.AllowCustomPropagation : object {
}
public static class JetBrains.ReSharper.Psi.Impl.Shared.CustomGeneratedChangePromotionCookie : object {
    [NotNullAttribute]
public static IDisposable Create(ITreeNode node);
    [NotNullAttribute]
public static IDisposable Create(IPsiTransactions psiTransactions, PsiLanguageType language, ITreeNode node);
    public static bool IsSet(ITreeNode node);
}
public class JetBrains.ReSharper.Psi.Impl.Shared.DisableChecks : object {
}
public class JetBrains.ReSharper.Psi.Impl.Shared.DisablePromotionOfChangesAndRangesFromGeneratedToPrimaryCookie : object {
}
public class JetBrains.ReSharper.Psi.Impl.Shared.DisablePromotionOfChangesFromGeneratedToPrimaryCookie : object {
    private PsiLanguageType myLanguage;
    [CanBeNullAttribute]
private IPsiSourceFile myPsiSourceFile;
    [CompilerGeneratedAttribute]
private ITreeNode <FirstGeneratedOuterBound>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <LastGeneratedOuterBound>k__BackingField;
    public ITreeNode FirstGeneratedOuterBound { get; public set; }
    public ITreeNode LastGeneratedOuterBound { get; public set; }
    public DisablePromotionOfChangesFromGeneratedToPrimaryCookie(PsiLanguageType language, IPsiSourceFile psiSourceFile);
    [CompilerGeneratedAttribute]
public ITreeNode get_FirstGeneratedOuterBound();
    [CompilerGeneratedAttribute]
public void set_FirstGeneratedOuterBound(ITreeNode value);
    [CompilerGeneratedAttribute]
public ITreeNode get_LastGeneratedOuterBound();
    [CompilerGeneratedAttribute]
public void set_LastGeneratedOuterBound(ITreeNode value);
    [NotNullAttribute]
[MustDisposeResourceAttribute]
public static IDisposable Create(ITreeNode node);
    public static bool IsSet(ITreeNode node);
    [CanBeNullAttribute]
public static DisablePromotionOfChangesFromGeneratedToPrimaryCookie GetCookie(ITreeNode node);
}
public class JetBrains.ReSharper.Psi.Impl.Shared.DisablePromotionOfChangesFromPrimaryToGeneratedCookie : object {
}
public class JetBrains.ReSharper.Psi.Impl.Shared.ElementRange`1 : object {
    [CanBeNullAttribute]
public T Token;
    public TreeTextRange RangeWithin;
    private string myCachedText;
    public static ElementRange`1<T> InvalidRange;
    public bool IsValid { get; }
    public ElementRange`1(T token);
    public ElementRange`1(T token, TreeTextRange rangeWithin);
    private static ElementRange`1();
    public bool get_IsValid();
    public string GetText();
    public TreeTextRange GetTreeTextRange();
    [NotNullAttribute]
protected virtual string GetElementText();
    public bool Equals(ElementRange`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class JetBrains.ReSharper.Psi.Impl.Shared.GeneratedRangeMapFactory : object {
    public static IGeneratedRangeMap CreateGeneratedRangeMap(IFile originalFile);
}
public class JetBrains.ReSharper.Psi.Impl.Shared.GeneratedRangeMapTree : object {
    private TreeTextRangeTree`2<Original, RangesPair> myOriginalTree;
    private TreeTextRangeTree`2<Generated, RangesPair> myGeneratedTree;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    private static Key`1<Tuple`3<IGeneratedRangeMap, TreeTextRange, RangesPair>> ourTranslatorKey;
    private PsiLanguageType myLanguage;
    public IFile OriginalFile { get; }
    public IPsiSourceFile SourceFile { get; }
    public bool IsEmpty { get; }
    public GeneratedRangeMapTree(IFile originalFile);
    private static GeneratedRangeMapTree();
    public sealed virtual IFile get_OriginalFile();
    [CompilerGeneratedAttribute]
public IPsiSourceFile get_SourceFile();
    internal IEnumerable`1<RangesPair> GetAllPairs();
    internal void Reset(IEnumerable`1<RangesPair> list);
    private void AddRangesRollbackAction();
    internal void AddPair(RangesPair pair);
    private void RemovePair(RangesPair pair);
    private void UpdatePair(RangesPair oldPair, RangesPair newPair);
    public sealed virtual void Add(TreeTextRange`1<Generated> generatedRange, TreeTextRange`1<Original> originalRange);
    public sealed virtual void Add(TreeTextRange`1<Generated> generatedRange, TreeTextRange`1<Original> originalRange, MappedRangeType rangeType, bool greedyOnLeft, bool greedyOnRight);
    public sealed virtual void CloseAddedRange(TreeTextRange`1<Original> originalRange, MappedRangeType rangeType);
    public sealed virtual void AddOrMerge(TreeTextRange`1<Generated> generatedRange, TreeTextRange`1<Original> originalRange, MappedRangeType rangeType, bool greedyOnLeft, bool greedyOnRight, bool mapIsOrdered);
    public sealed virtual void AppendWithShiftToGenerated(IGeneratedRangeMap anotherMap1, int offset, bool mapIsOrdered);
    public sealed virtual void AppendWithShiftToOriginal(IGeneratedRangeMap anotherMap1, TreeOffset offset);
    public sealed virtual FrugalLocalList`1<RangesPair> GetIntersectingRanges(TreeTextRange`1<Generated> generatedRange, bool strict);
    public sealed virtual FrugalLocalList`1<RangesPair> GetIntersectingRanges(TreeTextRange`1<Original> originalRange, bool strict);
    public sealed virtual TreeTextRange`1<Original> Translate(TreeTextRange`1<Generated> generatedRange, Predicate`1<IUserDataHolder> filter);
    public sealed virtual TreeTextRange`1<Generated> Translate(TreeTextRange`1<Original> originalRange, Predicate`1<IUserDataHolder> filter);
    public sealed virtual FrugalLocalList`1<TreeTextRange`1<Original>> GetIntersectedOriginalRanges(TreeTextRange`1<Original> originalRange, bool strict);
    public sealed virtual FrugalLocalList`1<TreeTextRange`1<Generated>> GetIntersectedGeneratedRanges(TreeTextRange`1<Generated> generatedRange, bool strict);
    public sealed virtual FrugalLocalList`1<RangesPair> GetIntersectedPairs(TreeTextRange`1<Generated> generatedRange, Predicate`1<IUserDataHolder> filter, bool strict);
    public sealed virtual FrugalLocalList`1<RangesPair> GetIntersectedPairs(TreeTextRange`1<Original> originalRange, Predicate`1<IUserDataHolder> filter, bool strict);
    public sealed virtual FrugalLocalList`1<TreeTextRange`1<Original>> GetIntersectedOriginalRanges(TreeTextRange`1<Generated> generatedRange, Predicate`1<IUserDataHolder> filter, bool strict);
    public sealed virtual FrugalLocalList`1<TreeTextRange`1<Generated>> GetIntersectedGeneratedRanges(TreeTextRange`1<Original> originalRange, Predicate`1<IUserDataHolder> filter, bool strict);
    public sealed virtual RangesPair GetCoveringRange(TreeTextRange`1<Original> originalRange);
    public sealed virtual RangesPair GetCoveringRangeExceptZeroLengthAtBounds(TreeTextRange`1<Original> originalRange);
    private RangesPair GetCoveringRange(TreeTextRange`1<Generated> modifiedGeneratedRange);
    public sealed virtual FrugalLocalList`1<RangesPair> GetCoveredRanges(TreeTextRange`1<Generated> coveringRange);
    public sealed virtual FrugalLocalList`1<RangesPair> GetCoveredRanges(TreeTextRange`1<Original> coveringRange);
    private static bool CompareOriginalAndGeneratedTexts(string original, string generated);
    public sealed virtual string Dump(IFile generatedFile, bool dumpContext);
    public sealed virtual void CheckValidity(IFile generatedFile, StringBuilder text, bool checkTranslation, bool dumpContext);
    public sealed virtual bool OnSharedRangeModified(TreeTextRange`1<Original> modifiedOriginalRange, TreeTextRange`1<Generated> modifiedGeneratedRange, int newTextLength, bool addTransactionAction);
    public sealed virtual void OnOriginalRangeModified(TreeTextRange`1<Original> modifiedOriginalRange, int newLength, bool addTransactionAction);
    internal void OnOriginalRangeModified(TreeTextRange`1<Original> modifiedOriginalRange, int newLength, bool addTransactionAction, bool removeOnZero, UpdateCoveringRange updateCoveringRange);
    public sealed virtual void OnGeneratedRangeModified(TreeTextRange`1<Generated> modifiedGeneratedRange, int newTextLength, bool alwaysNotGreedy);
    internal void OnGeneratedRangeModified(TreeTextRange`1<Generated> modifiedGeneratedRange, int newTextLength, bool alwaysNotGreedy, bool addTransactionAction, UpdateCoveringRange updateCoveringRange);
    public sealed virtual void AddProjectionItem(TreeTextRange`1<Generated> generatedRange, TreeTextRange`1<Original> originalRange);
    public sealed virtual void AddProjectionItem(TreeTextRange`1<Generated> generatedRange, TreeTextRange`1<Original> originalRange, MappedRangeType rangeType, bool greedyOnLeft, bool greedyOnRight);
    public sealed virtual bool get_IsEmpty();
    public sealed virtual IDisposable MoveToPointers();
    private void DoRemoveCoveredProjectionItems(TreeTextRange`1<Original> originalRange, bool addTransactionAction);
    public sealed virtual void RemoveCoveredProjectionItems(TreeTextRange`1<Original> originalRange);
    public sealed virtual void RemoveOrCutIntersectingRanges(TreeTextRange`1<Original> originalRange);
    public sealed virtual void RemoveOrCutIntersectingRanges(TreeTextRange`1<Generated> generatedRange);
    public sealed virtual TreeTextRange`1<Original> FindNearestRangeOriginal(TreeTextRange`1<Generated> generatedRange, bool before);
    public sealed virtual void ReplaceWith(IGeneratedRangeMap rangeMap);
    public sealed virtual TreeTextRange`1<Original> TranslateForModification(TreeTextRange`1<Generated> generatedRange);
    public sealed virtual FrugalLocalList`1<TreeTextRange`1<Generated>> GetIntersectedGeneratedRangesForModification(TreeTextRange`1<Generated> generatedRange);
    [CompilerGeneratedAttribute]
private void <MoveToPointers>b__51_0();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Impl.Shared.GreedType : ValueType {
    [CompilerGeneratedAttribute]
private bool <GreedyOnLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GreedyOnRight>k__BackingField;
    public static GreedType GREEDY;
    public static GreedType NOT_GREEDY;
    public bool GreedyOnLeft { get; }
    public bool GreedyOnRight { get; }
    private GreedType(bool greedyOnLeft, bool greedyOnRight);
    private static GreedType();
    [CompilerGeneratedAttribute]
public bool get_GreedyOnLeft();
    [CompilerGeneratedAttribute]
public bool get_GreedyOnRight();
}
public interface JetBrains.ReSharper.Psi.Impl.Shared.IGeneratedRangeMap {
    public IFile OriginalFile { get; }
    public bool IsEmpty { get; }
    public abstract virtual IFile get_OriginalFile();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual void Add(TreeTextRange`1<Generated> generatedRange, TreeTextRange`1<Original> originalRange);
    public abstract virtual void Add(TreeTextRange`1<Generated> generatedRange, TreeTextRange`1<Original> originalRange, MappedRangeType rangeType, bool greedyOnLeft, bool greedyOnRight);
    public abstract virtual void AddOrMerge(TreeTextRange`1<Generated> generatedRange, TreeTextRange`1<Original> originalRange, MappedRangeType rangeType, bool greedyOnLeft, bool greedyOnRight, bool mapIsOrdered);
    public abstract virtual void AppendWithShiftToGenerated(IGeneratedRangeMap anotherMap, int offset, bool mapIsOrdered);
    public abstract virtual void AppendWithShiftToOriginal(IGeneratedRangeMap anotherMap, TreeOffset offset);
    public abstract virtual FrugalLocalList`1<RangesPair> GetIntersectingRanges(TreeTextRange`1<Generated> generatedRange, bool strict);
    public abstract virtual FrugalLocalList`1<RangesPair> GetIntersectingRanges(TreeTextRange`1<Original> originalRange, bool strict);
    public abstract virtual TreeTextRange`1<Original> Translate(TreeTextRange`1<Generated> generatedRange, Predicate`1<IUserDataHolder> filter);
    public abstract virtual TreeTextRange`1<Generated> Translate(TreeTextRange`1<Original> originalRange, Predicate`1<IUserDataHolder> filter);
    public abstract virtual FrugalLocalList`1<TreeTextRange`1<Original>> GetIntersectedOriginalRanges(TreeTextRange`1<Original> originalRange, bool strict);
    public abstract virtual FrugalLocalList`1<TreeTextRange`1<Generated>> GetIntersectedGeneratedRanges(TreeTextRange`1<Generated> generatedRange, bool strict);
    public abstract virtual FrugalLocalList`1<RangesPair> GetIntersectedPairs(TreeTextRange`1<Generated> generatedRange, Predicate`1<IUserDataHolder> filter, bool strict);
    public abstract virtual FrugalLocalList`1<RangesPair> GetIntersectedPairs(TreeTextRange`1<Original> originalRange, Predicate`1<IUserDataHolder> filter, bool strict);
    public abstract virtual FrugalLocalList`1<TreeTextRange`1<Original>> GetIntersectedOriginalRanges(TreeTextRange`1<Generated> generatedRange, Predicate`1<IUserDataHolder> filter, bool strict);
    public abstract virtual FrugalLocalList`1<TreeTextRange`1<Generated>> GetIntersectedGeneratedRanges(TreeTextRange`1<Original> originalRange, Predicate`1<IUserDataHolder> filter, bool strict);
    public abstract virtual RangesPair GetCoveringRange(TreeTextRange`1<Original> originalRange);
    public abstract virtual RangesPair GetCoveringRangeExceptZeroLengthAtBounds(TreeTextRange`1<Original> originalRange);
    public abstract virtual FrugalLocalList`1<RangesPair> GetCoveredRanges(TreeTextRange`1<Generated> coveringRange);
    public abstract virtual FrugalLocalList`1<RangesPair> GetCoveredRanges(TreeTextRange`1<Original> coveringRange);
    public abstract virtual string Dump(IFile generatedFile, bool dumpContext);
    public abstract virtual void CheckValidity(IFile generatedFile, StringBuilder text, bool checkTranslation, bool dumpContext);
    public abstract virtual bool OnSharedRangeModified(TreeTextRange`1<Original> modifiedOriginalRange, TreeTextRange`1<Generated> modifiedGeneratedRange, int newTextLength, bool addTransactionAction);
    public abstract virtual void OnOriginalRangeModified(TreeTextRange`1<Original> modifiedOriginalRange, int newLength, bool addTransactionAction);
    public abstract virtual void OnGeneratedRangeModified(TreeTextRange`1<Generated> modifiedGeneratedRange, int newTextLength, bool alwaysNotGreedy);
    public abstract virtual void AddProjectionItem(TreeTextRange`1<Generated> generatedRange, TreeTextRange`1<Original> originalRange);
    public abstract virtual void AddProjectionItem(TreeTextRange`1<Generated> generatedRange, TreeTextRange`1<Original> originalRange, MappedRangeType rangeType, bool greedyOnLeft, bool greedyOnRight);
    [MustDisposeResourceAttribute]
public abstract virtual IDisposable MoveToPointers();
    public abstract virtual void RemoveCoveredProjectionItems(TreeTextRange`1<Original> originalRange);
    public abstract virtual void RemoveOrCutIntersectingRanges(TreeTextRange`1<Original> originalRange);
    public abstract virtual void RemoveOrCutIntersectingRanges(TreeTextRange`1<Generated> generatedRange);
    public abstract virtual TreeTextRange`1<Original> FindNearestRangeOriginal(TreeTextRange`1<Generated> generatedRange, bool before);
    public abstract virtual void ReplaceWith(IGeneratedRangeMap rangeMap);
    public abstract virtual TreeTextRange`1<Original> TranslateForModification(TreeTextRange`1<Generated> generatedRange);
    public abstract virtual FrugalLocalList`1<TreeTextRange`1<Generated>> GetIntersectedGeneratedRangesForModification(TreeTextRange`1<Generated> generatedRange);
    public abstract virtual void CloseAddedRange(TreeTextRange`1<Original> originalRange, MappedRangeType rangeType);
}
public abstract class JetBrains.ReSharper.Psi.impl.Shared.InjectedPsi.AnnotatedInjectionByAttributeNodeProvider : object {
    private string myAttributeShortNameTrimmed;
    private String[] myAttributes;
    public PsiLanguageType SupportedOriginalLanguage { get; }
    public string Summary { get; }
    public string Description { get; }
    public String[] Words { get; }
    public String[] Attributes { get; }
    protected string AttributeShortName { get; }
    private string AttributeShortNameTrimmed { get; }
    public string ProvidedLanguageID { get; }
    public string Guid { get; }
    public abstract virtual PsiLanguageType get_SupportedOriginalLanguage();
    public sealed virtual string get_Summary();
    public sealed virtual string get_Description();
    public sealed virtual String[] get_Words();
    public sealed virtual String[] get_Attributes();
    protected abstract virtual string get_AttributeShortName();
    private string get_AttributeShortNameTrimmed();
    public abstract virtual bool Check(ITreeNode node, ILiteralsInjectionDataProvider injectedContext, Object& data);
    public abstract virtual string GetPrefix(ITreeNode node, object data);
    public abstract virtual string GetSuffix(ITreeNode node, object data);
    public abstract virtual string get_ProvidedLanguageID();
    public abstract virtual string get_Guid();
}
public interface JetBrains.ReSharper.Psi.impl.Shared.InjectedPsi.IGroupedInjectorProviderInLiterals {
    public string GroupName { get; }
    public abstract virtual string get_GroupName();
}
public interface JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.IInjectedRangeTranslator {
}
public interface JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.IInjectionAwareLanguage {
}
public interface JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.IInjectionNodeProvider {
    public PsiLanguageType SupportedOriginalLanguage { get; }
    public string ProvidedLanguageID { get; }
    public string Summary { get; }
    public string Description { get; }
    public string Guid { get; }
    [CanBeNullAttribute]
public String[] Words { get; }
    public String[] Attributes { get; }
    public abstract virtual bool Check(ITreeNode node, ILiteralsInjectionDataProvider injectedContext, Object& data);
    [CanBeNullAttribute]
public abstract virtual string GetPrefix(ITreeNode node, object data);
    [CanBeNullAttribute]
public abstract virtual string GetSuffix(ITreeNode node, object data);
    public abstract virtual PsiLanguageType get_SupportedOriginalLanguage();
    public abstract virtual string get_ProvidedLanguageID();
    public abstract virtual string get_Summary();
    public abstract virtual string get_Description();
    public abstract virtual string get_Guid();
    public abstract virtual String[] get_Words();
    public abstract virtual String[] get_Attributes();
}
public interface JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.IInjectionTargetLanguage {
    [NotNullAttribute]
public PsiLanguageType Language { get; }
    public bool SupportsRegeneration { get; }
    [NotNullAttribute]
public Char[] LiteralBorderCharacters { get; }
    public abstract virtual PsiLanguageType get_Language();
    public abstract virtual bool get_SupportsRegeneration();
    [PureAttribute]
public abstract virtual ILexerFactory CreateLexerFactory(LanguageService languageService);
    [PureAttribute]
public abstract virtual IBuffer CreateBuffer(ITreeNode originalNode, string text, object options);
    public abstract virtual bool ShouldInjectByAnnotation(ITreeNode originalNode, String& prefix, String& suffix);
    [PureAttribute]
public abstract virtual int GetStartOffsetForString(ITreeNode originalNode);
    [PureAttribute]
public abstract virtual int GetEndOffsetForString(ITreeNode originalNode);
    [CanBeNullAttribute]
public abstract virtual ITreeNode UpdateNode(IFile generatedFile, ITreeNode generatedNode, ITreeNode originalNode, Int32& length, string prefix, string suffix, int startOffset, int endOffset);
    [PureAttribute]
public abstract virtual TreeTextRange FixValueRangeForLiteral(ITreeNode element);
    [PureAttribute]
public abstract virtual bool IsPrimaryLanguageApplicable(IPsiSourceFile sourceFile);
    [PureAttribute]
public abstract virtual InjectableLiteralsPresence ContainsInjectableLiterals(ITreeNode element);
    [PureAttribute]
public abstract virtual bool IsInjectionAllowed(ITreeNode literalNode);
    [PureAttribute]
public abstract virtual bool IsInjectionAllowed(TokenNodeType tokenType);
    public abstract virtual Char[] get_LiteralBorderCharacters();
    [PureAttribute]
public abstract virtual bool AllowsLineBreaks(ITreeNode originalNode);
    [PureAttribute]
public abstract virtual bool IsWhitespaceToken(ITokenNode token);
    [PureAttribute]
public abstract virtual string GetCorrespondingCommentTextForLiteral(ITreeNode originalNode);
}
public interface JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.IInjectorProviderInLiterals {
    public string ProvidedInjectionID { get; }
    public string InjectDescription { get; }
    public int Priority { get; }
    public InjectionNodeProvidersViewer InjectionNodeProvidersViewer { get; }
    [CanBeNullAttribute]
public IconId Icon { get; }
    public String[] CommentInjectionIDs { get; }
    public Char[] LiteralBorderCharacters { get; }
    public bool SupportsInjectionIntention { get; }
    public bool SupportsInjectionComment { get; }
    public bool CanRegenerate { get; }
    public PsiLanguageType SupportedOriginalLanguage { get; }
    public IInjectionTargetLanguage Target { get; }
    public String[] LanguageEqualsCommentTexts { get; }
    public string ReSharperInjectCommentText { get; }
    public string InjectionKindId { get; }
    public abstract virtual string get_ProvidedInjectionID();
    public abstract virtual string get_InjectDescription();
    public abstract virtual int get_Priority();
    public abstract virtual int GetStartOffset(ITreeNode originalNode);
    public abstract virtual int GetEndOffset(ITreeNode originalNode);
    public abstract virtual InjectionNodeProvidersViewer get_InjectionNodeProvidersViewer();
    public abstract virtual IconId get_Icon();
    public abstract virtual String[] get_CommentInjectionIDs();
    public abstract virtual InjectableLiteralsPresence ContainsInjectableLiterals(ITreeNode element);
    public abstract virtual bool IsSupportedLiteralForInjection(ITreeNode originalNode);
    public abstract virtual bool IsSupportedLiteralForInjection(TokenNodeType tokenType);
    public abstract virtual Char[] get_LiteralBorderCharacters();
    [CanBeNullAttribute]
public abstract virtual string GetCorrespondingCommentText(ITreeNode originalNode);
    public abstract virtual bool get_SupportsInjectionIntention();
    public abstract virtual bool get_SupportsInjectionComment();
    public abstract virtual bool HasRangeMarks(IPsiSourceFile sourceFile);
    public abstract virtual bool HasRangeMarkInsideNodeRange(IPsiSourceFile sourceFile, ITreeNode node);
    public abstract virtual bool ShouldInjectByRangeMarker(IPsiSourceFile sourceFile, ITreeNode originalNode);
    public abstract virtual IEnumerable`1<ITreeNode> GetMarkedNodes(IPsiSourceFile psf);
    public abstract virtual void InjectIntoNodeRange(ITreeNode node, ITreeNodePointer`1<ITreeNode> pointer);
    public abstract virtual void RemoveInjectFromNodeRange(ITreeNode node);
    public abstract virtual bool get_CanRegenerate();
    public abstract virtual IBuffer CreateBuffer(ITreeNode originalNode, string text, object options);
    public abstract virtual PsiLanguageType get_SupportedOriginalLanguage();
    [CanBeNullAttribute]
public abstract virtual ITreeNode LocateInjectNodeByTreeOffset(IFile file, IDocument document, int offset);
    public abstract virtual IInjectionTargetLanguage get_Target();
    public abstract virtual String[] get_LanguageEqualsCommentTexts();
    public abstract virtual string get_ReSharperInjectCommentText();
    public abstract virtual string get_InjectionKindId();
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.impl.Shared.InjectedPsi.ILanguageInjectionTargetConsumer {
    public abstract virtual void Consume(ITreeNode languageInjectionTarget, string injectedLanguage, string prefix, string suffix);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.impl.Shared.InjectedPsi.ILanguageInjectionTargetsFinder {
    public abstract virtual void Find(ITreeNode searchRoot, ILanguageInjectionTargetConsumer consumer);
}
[NullableContextAttribute("2")]
public interface JetBrains.ReSharper.Psi.impl.Shared.InjectedPsi.ILanguageInjectionTargetsFinderFactory {
    public abstract virtual ILanguageInjectionTargetsFinder CreateAnnotationTargetsFinder();
}
public interface JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.ILanguageInjectorProviderInLiterals {
    public PsiLanguageType ProvidedLanguage { get; }
    public abstract virtual bool IsGeneratedFile(IFile file);
    public abstract virtual ITreeNode UpdateNode(IFile generatedFile, ITreeNode generatedNode, ITreeNode originalNode, Int32& length, string prefix, string suffix);
    public abstract virtual PsiLanguageType get_ProvidedLanguage();
    public abstract virtual ILexerFactory CreateLexerFactory(LanguageService languageService);
    public abstract virtual bool OwnsNode(ITreeNode node);
    public abstract virtual bool AllowsLineBreaks(ITreeNode contextNode);
    public abstract virtual bool IsWhitespaceToken(ITokenNode token);
    public abstract virtual TreeTextRange FixValueRangeForLiteral(ITreeNode element);
}
public interface JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.ILiteralsInjectionDataProvider {
    public IInjectionNodeProvider[] Providers { get; }
    public HashSet`1<string> Words { get; }
    public abstract virtual IInjectionNodeProvider[] get_Providers();
    public abstract virtual HashSet`1<string> get_Words();
}
public class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.IndependentInjectedFileContext : object {
    [CompilerGeneratedAttribute]
private IInjectedContextData <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private IFile <OriginalFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IIndependentInjectedPsiProvider <Provider>k__BackingField;
    [NotNullAttribute]
private object myLockObject;
    [NotNullAttribute]
private ConcurrentDictionary`2<ITreeNode, IInjectedNodeContext> myInjectedContexts;
    [CanBeNullAttribute]
private CollectedData modreq(System.Runtime.CompilerServices.IsVolatile) myCollectedData;
    public int PromoteToPrimaryInProgress;
    public int PromoteToGeneratedInProgress;
    [NotNullAttribute]
public IInjectedContextData Data { get; }
    [NotNullAttribute]
public IFile OriginalFile { get; }
    [NotNullAttribute]
public IIndependentInjectedPsiProvider Provider { get; }
    [NotNullAttribute]
private IInjectedPsiProvider JetBrains.ReSharper.Psi.ExtensionsAPI.IInjectedFileContext.Provider { get; }
    public IndependentInjectedFileContext(IIndependentInjectedPsiProvider provider, IFile originalFile, IInjectedContextData data);
    [CompilerGeneratedAttribute]
public sealed virtual IInjectedContextData get_Data();
    [CompilerGeneratedAttribute]
public sealed virtual IFile get_OriginalFile();
    [CompilerGeneratedAttribute]
public IIndependentInjectedPsiProvider get_Provider();
    public sealed virtual bool IsValid();
    private sealed virtual override IInjectedPsiProvider JetBrains.ReSharper.Psi.ExtensionsAPI.IInjectedFileContext.get_Provider();
    [NotNullAttribute]
protected virtual IRecursiveElementProcessor`1<CollectedData> CreateInjectedNodeCollector();
    public sealed virtual bool HasInjectedNodes();
    public virtual ICollection`1<IInjectedNodeContext> GetAllInjects();
    public sealed virtual IInjectedNodeContext GetInjectForNode(ITreeNode originalNode);
    public IInjectedNodeContext TryGetCachedInjectedForNode(ITreeNode originalNode);
    public void UpdateInjectionPointListOnFileChange(ITreeNode originalParent, IEnumerable`1<ITreeNode> deletedNodes, IEnumerable`1<ITreeNode> addedNodes, PsiChangedElementType elementType);
    public void ResetInjectionPointList();
    [NotNullAttribute]
private CollectedData CollectInjectedNodes();
    public IInjectedNodeContext CreateNodeContext(ITreeNode originalNode, IFile generatedFile, InjectedRangeTranslator rangeTranslator);
    public void InvalidateNodeContext(ITreeNode node);
    [CanBeNullAttribute]
public IInjectedFileContext TryTranslateToCurrentFork(IContentModelForkTranslator translator);
    [CompilerGeneratedAttribute]
private bool <TryGetCachedInjectedForNode>b__24_0(ITreeNode node);
}
public class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.IndependentInjectedNodeContext : object {
    [CompilerGeneratedAttribute]
private IInjectedFileContext <FileContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <OriginalContextNode>k__BackingField;
    [CompilerGeneratedAttribute]
private IFile <GeneratedFile>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <GeneratedNode>k__BackingField;
    [CompilerGeneratedAttribute]
private InjectedRangeTranslator <RangeTranslator>k__BackingField;
    [CompilerGeneratedAttribute]
private InjectedHolderNode <NodeHolder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NeedsRegeneration>k__BackingField;
    public IInjectedFileContext FileContext { get; }
    public ITreeNode OriginalContextNode { get; public set; }
    public IFile GeneratedFile { get; }
    public ITreeNode GeneratedNode { get; }
    public InjectedRangeTranslator RangeTranslator { get; public set; }
    private ISecondaryRangeTranslator JetBrains.ReSharper.Psi.ExtensionsAPI.IInjectedNodeContext.RangeTranslator { get; }
    public InjectedHolderNode NodeHolder { get; }
    public bool NeedsRegeneration { get; public set; }
    public IndependentInjectedNodeContext(IInjectedFileContext fileContext, ITreeNode originalContextNode, IFile generatedFile, ITreeNode generatedNode, InjectedRangeTranslator rangeTranslator);
    [CompilerGeneratedAttribute]
public sealed virtual IInjectedFileContext get_FileContext();
    [CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_OriginalContextNode();
    [CompilerGeneratedAttribute]
public void set_OriginalContextNode(ITreeNode value);
    [CompilerGeneratedAttribute]
public sealed virtual IFile get_GeneratedFile();
    [CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_GeneratedNode();
    [CompilerGeneratedAttribute]
public InjectedRangeTranslator get_RangeTranslator();
    [CompilerGeneratedAttribute]
public void set_RangeTranslator(InjectedRangeTranslator value);
    private sealed virtual override ISecondaryRangeTranslator JetBrains.ReSharper.Psi.ExtensionsAPI.IInjectedNodeContext.get_RangeTranslator();
    [CompilerGeneratedAttribute]
public InjectedHolderNode get_NodeHolder();
    [CompilerGeneratedAttribute]
public bool get_NeedsRegeneration();
    [CompilerGeneratedAttribute]
public void set_NeedsRegeneration(bool value);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public void IsValid();
}
public abstract class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.IndependentInjectedPsiProvider : object {
    public bool ProvidedLanguageCanHaveNestedInjects { get; }
    public PsiLanguageType GeneratedLanguage { get; }
    public virtual IInjectedContextData ComputeDataForFileContext(IFile originalFile);
    public virtual IInjectedFileContext CreateInjectedFileContext(IFile originalFile, IInjectedContextData contextData);
    public sealed virtual void OriginalFileChanged(IInjectedFileContext fileContext, ITreeNode originalParent, IEnumerable`1<ITreeNode> deletedNodes, IEnumerable`1<ITreeNode> addedNodes, bool processImmediately, PsiChangedElementType elementType);
    public sealed virtual void GeneratedFileChanged(IInjectedFileContext fileContext, ITreeNode generatedParent, IEnumerable`1<ITreeNode> deletedNodes, IEnumerable`1<ITreeNode> addedNodes, bool processImmediately);
    public void ReentrancySafeRegenerate(IndependentInjectedNodeContext injectedNodeContext);
    public virtual void CleanupNodeContextOnDelete(IInjectedNodeContext nodeContext);
    public abstract virtual bool get_ProvidedLanguageCanHaveNestedInjects();
    public abstract virtual bool IsApplicable(PsiLanguageType originalLanguage);
    public abstract virtual bool IsApplicableToNode(ITreeNode node, IInjectedFileContext context);
    public virtual bool CouldBeApplicableToDescendants(ITreeNode node);
    public abstract virtual PsiLanguageType get_GeneratedLanguage();
    public abstract virtual IInjectedNodeContext CreateInjectedNodeContext(IInjectedFileContext fileContext, ITreeNode originalNode);
    [NotNullAttribute]
public abstract virtual IInjectedNodeContext Regenerate(IndependentInjectedNodeContext nodeContext);
    protected abstract virtual bool CanBeGeneratedNode(ITreeNode node);
    protected abstract virtual bool CanBeOriginalNode(ITreeNode node);
    [NotNullAttribute]
protected IInjectedNodeContext UpdateInjectedFileAndContext(IndependentInjectedNodeContext nodeContext, ITreeNode originalNode, int originalStartOffset, int originalEndOffset, int generatedStartOffset, int generatedEndOffset);
    protected IInjectedNodeContext CreateInjectedFileAndContext(IInjectedFileContext fileContext, ITreeNode originalNode, IBuffer buffer, LanguageService languageService, int originalStartOffset, int originalEndOffset, int generatedStartOffset, int generatedEndOffset);
    protected IInjectedNodeContext CreateInjectedFileAndContext(IInjectedFileContext fileContext, ITreeNode originalNode, int originalStartOffset, int originalEndOffset, int generatedStartOffset, int generatedEndOffset, IParser parser, ILazyCachingLexer lexer, IPsiSourceFile psiSourceFile, ILexerFactory lexerFactory);
    [NotNullAttribute]
protected virtual ILexerFactory CreateLexerFactory(LanguageService languageService);
}
public enum JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.InjectableLiteralsPresence : Enum {
    public int value__;
    public static InjectableLiteralsPresence Yes;
    public static InjectableLiteralsPresence No;
    public static InjectableLiteralsPresence Maybe;
}
public class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.InjectedHolderNode : CompositeElement {
    private static CompositeNodeType NODE_TYPE;
    private IPsiServices myPsiServices;
    [CompilerGeneratedAttribute]
private NodeUserDataHolder <NodeUserDataHolder>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ModificationStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <OriginalNode>k__BackingField;
    [CompilerGeneratedAttribute]
private IInjectedFileContext <FileContext>k__BackingField;
    public NodeUserDataHolder NodeUserDataHolder { get; }
    public bool HoldOwnUserData { get; }
    public NodeType NodeType { get; }
    public PsiLanguageType Language { get; }
    public int LevelDelta { get; }
    public ITreeNode ContextNode { get; }
    public SandBoxContextType ContextType { get; }
    public Nullable`1<int> ModificationStamp { get; public set; }
    public IFile GeneratedFile { get; }
    public ITreeNode OriginalNode { get; }
    public IInjectedFileContext FileContext { get; }
    public InjectedHolderNode(IPsiServices psiServices, IInjectedFileContext context, ITreeNode originalNode);
    private static InjectedHolderNode();
    [CompilerGeneratedAttribute]
public sealed virtual NodeUserDataHolder get_NodeUserDataHolder();
    public sealed virtual bool get_HoldOwnUserData();
    public virtual void SubTreeChanged(ITreeNode elementContainingChanges, PsiChangedElementType changeType);
    public virtual IPsiServices GetPsiServices();
    public sealed virtual IPsiModule GetPsiModule();
    public virtual bool IsValid();
    public virtual NodeType get_NodeType();
    public virtual PsiLanguageType get_Language();
    public ISymbolTable AddGlobalDeclarations(ISymbolTable parentTable, int level, SymbolTableMode mode);
    public int get_LevelDelta();
    public sealed virtual ITreeNode get_ContextNode();
    public sealed virtual SandBoxContextType get_ContextType();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_ModificationStamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ModificationStamp(Nullable`1<int> value);
    public sealed virtual IFile get_GeneratedFile();
    [CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_OriginalNode();
    [CompilerGeneratedAttribute]
public sealed virtual IInjectedFileContext get_FileContext();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.InjectedLanguageBufferWrapper : object {
    private IBuffer myOriginalBuffer;
    public int Length { get; }
    public char Item { get; }
    public InjectedLanguageBufferWrapper(IBuffer originalBuffer);
    public sealed virtual int get_Length();
    public sealed virtual string GetText();
    public sealed virtual string GetText(TextRange range);
    public sealed virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public sealed virtual char get_Item(int index);
    public sealed virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
}
public static class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.InjectedLanguageIDs : object {
    public static int SqlLanguagesPriority;
    public static string CssLanguage;
    public static string HtmlLanguage;
    public static string AngularHtmlLanguage;
    public static string JsonLanguage;
    public static string XmlLanguage;
    public static string JsRegExpLanguage;
    public static string ClrRegExpLanguage;
    public static string JavaScriptLanguage;
    public static string Angular2ExpressionsLanguage;
    public static string Angular2StatementsLanguage;
    public static string Angular2NgForLanguage;
    public static string Angular2NgIfLanguage;
    public static string PathReference;
    private static string Angular2InternalId;
    public static string RouteTemplateLanguage;
    public static int GetPriority(string id);
    public static string GetPresentableName(string id);
    public static string MergeIdForGrouping(string id);
}
public abstract class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.InjectedLanguageLexerWithTranslationBase : object {
    private Lazy`1<ILexer> myLexerImplementation;
    private ILexer LexerImplementation { get; }
    private object JetBrains.ReSharper.Psi.Parsing.ILexer.CurrentPosition { get; private set; }
    private TokenNodeType JetBrains.ReSharper.Psi.Parsing.ILexer.TokenType { get; }
    private int JetBrains.ReSharper.Psi.Parsing.ILexer.TokenStart { get; }
    private int JetBrains.ReSharper.Psi.Parsing.ILexer.TokenEnd { get; }
    private IBuffer JetBrains.ReSharper.Psi.Parsing.ILexer.Buffer { get; }
    protected InjectedLanguageLexerWithTranslationBase(IBuffer originalBuffer);
    private ILexer get_LexerImplementation();
    protected abstract virtual ILexer CreateRawLexer(IBuffer originalBuffer, RangeTranslator& rangeTranslator);
    private sealed virtual override void JetBrains.ReSharper.Psi.Parsing.ILexer.Start();
    private sealed virtual override void JetBrains.ReSharper.Psi.Parsing.ILexer.Advance();
    private sealed virtual override object JetBrains.ReSharper.Psi.Parsing.ILexer.get_CurrentPosition();
    private sealed virtual override void JetBrains.ReSharper.Psi.Parsing.ILexer.set_CurrentPosition(object value);
    private sealed virtual override TokenNodeType JetBrains.ReSharper.Psi.Parsing.ILexer.get_TokenType();
    private sealed virtual override int JetBrains.ReSharper.Psi.Parsing.ILexer.get_TokenStart();
    private sealed virtual override int JetBrains.ReSharper.Psi.Parsing.ILexer.get_TokenEnd();
    private sealed virtual override IBuffer JetBrains.ReSharper.Psi.Parsing.ILexer.get_Buffer();
}
public class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.InjectedRangeTranslator : object {
    [NotNullAttribute]
private Predicate`1<ITreeNode> myGeneratedParentPredicate;
    [NotNullAttribute]
private Predicate`1<ITreeNode> myOriginalParentPredicate;
    [NotNullAttribute]
private Dictionary`2<ITreeNode, Section> myOriginalToSectionMap;
    [NotNullAttribute]
private Dictionary`2<ITreeNode, Section> myGeneratedToSectionMap;
    [CompilerGeneratedAttribute]
private IFile <OriginalFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IFile <GeneratedFile>k__BackingField;
    public IFile OriginalFile { get; }
    public IFile GeneratedFile { get; }
    public InjectedRangeTranslator(IFile originalFile, IFile generatedFile, Predicate`1<ITreeNode> originalParentPredicate, Predicate`1<ITreeNode> generatedParentPredicate);
    [CompilerGeneratedAttribute]
public sealed virtual IFile get_OriginalFile();
    [CompilerGeneratedAttribute]
public IFile get_GeneratedFile();
    public sealed virtual IReadOnlyList`1<TreeTextRange> GetIntersectedGeneratedRanges(TreeTextRange originalRange, bool includeHidden, bool strict);
    public sealed virtual IReadOnlyList`1<TreeTextRange> GetIntersectedOriginalRanges(TreeTextRange generatedRange);
    public sealed virtual IReadOnlyList`1<TreeTextRange> GetIntersectedOriginalRangesLowLevel(TreeTextRange generatedRange, bool includeHidden, bool strict);
    public sealed virtual TreeTextRange OriginalToGenerated(TreeTextRange originalRange);
    public sealed virtual TreeTextRange GeneratedToOriginal(TreeTextRange generatedRange, bool forModification);
    public sealed virtual Tuple`2<TreeTextRange, TreeTextRange> GetCoveringRange(TreeTextRange originalRange);
    [NotNullAttribute]
public sealed virtual string Dump(IFile generatedFile, bool dumpContext);
    [NotNullAttribute]
private string Substring(string originalText, TreeTextRange treeTextRange);
    public void AddOrReplaceSection(ITreeNode original, ITreeNode generated, RangesPair[] pairs);
    public void RemoveSectionByOriginal(ITreeNode original);
    public void RemoveSectionByGenerated(ITreeNode generated);
}
public abstract class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.InjectingPsiRangeManagerBase`1 : object {
    private ReaderWriterLockSlim myLocker;
    private OneToListMap`2 modreq(System.Runtime.CompilerServices.IsVolatile) myPointers;
    private IOptimizedPersistentSortedMap`2<IPsiSourceFile, TextRange[]> myPersistedMap;
    private ISolution mySolution;
    [ObsoleteAttribute("Do not use in production code to avoid perf penalty")]
public ILookup`2<IPsiSourceFile, ITreeNodePointer`1<T>> Pointers { get; }
    protected InjectingPsiRangeManagerBase`1(Lifetime lifetime, ISolution solution, IPersistentIndexManager persistentIndexManager, string customId);
    public bool HasPointersInFile(IPsiSourceFile file);
    public IEnumerable`1<ITreeNodePointer`1<T>> GetPointersInFile(IPsiSourceFile file);
    public ILookup`2<IPsiSourceFile, ITreeNodePointer`1<T>> get_Pointers();
    public void Clear();
    public TextRange[] GetRanges(IPsiSourceFile file);
    private void InitPointers();
    private void RangeMarkerOnChanged(object sender, RangeMarkerChangedEventArgs args);
    public void Bind(T node, ITreeNodePointer`1<T> pointer);
    public void UnBind(T node);
    public bool Check(IPsiSourceFile sourceFile, T node);
}
public class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.InjectionInfo : object {
    public string Guid;
    public bool IsEnabled;
    public InjectionInfo(string guid, bool enabled);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.InjectionNodeProvidersViewer : object {
    private List`1<InjectionInfo> myCatalogs;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IInjectionNodeProvider> <AllProviders>k__BackingField;
    public IEnumerable`1<IInjectionNodeProvider> AllProviders { get; }
    public InjectionNodeProvidersViewer(IEnumerable`1<IInjectionNodeProvider> providers, Lifetime lifetime, ISettingsStore settingsStore, ISolution solution, ISettingsOptimization settingsOptimization);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IInjectionNodeProvider> get_AllProviders();
    private bool IsEnabled(IInjectionNodeProvider p);
    public IEnumerable`1<IInjectionNodeProvider> GetProvidersForInjector(IInjectorProviderInLiterals injector);
}
public abstract class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.InjectorProviderInLiteralsWithRangeMarkersBase`2 : object {
    private TInjectionTargetLanguage myInjectionTargetLanguage;
    private SimpleInjectingPsiRangeManager myRangeManager;
    private String[] myCommentInjectionIDs;
    [CompilerGeneratedAttribute]
private InjectionNodeProvidersViewer <InjectionNodeProvidersViewer>k__BackingField;
    private String[] myLanguageEqualsCommentTexts;
    private string myCachedCommentText;
    public string ProvidedInjectionID { get; }
    public PsiLanguageType SupportedOriginalLanguage { get; }
    public string InjectionKindId { get; }
    public IconId Icon { get; }
    public bool SupportsInjectionIntention { get; }
    public bool SupportsInjectionComment { get; }
    public string InjectDescription { get; }
    public int Priority { get; }
    public String[] CommentInjectionIDs { get; }
    public IInjectionTargetLanguage Target { get; }
    public InjectionNodeProvidersViewer InjectionNodeProvidersViewer { get; }
    public String[] LanguageEqualsCommentTexts { get; }
    public string ReSharperInjectCommentText { get; }
    [ObsoleteAttribute("Do not use in production code to avoid perf penalty")]
public ILookup`2<IPsiSourceFile, ITreeNodePointer`1<ITreeNode>> RangeManagerPointers { get; }
    public Char[] LiteralBorderCharacters { get; }
    public bool CanRegenerate { get; }
    protected InjectorProviderInLiteralsWithRangeMarkersBase`2(Lifetime lifetime, ISolution solution, IPersistentIndexManager persistentIndexManager, InjectionNodeProvidersViewer providersViewer, TInjectionTargetLanguage injectionTargetLanguage);
    public abstract virtual string get_ProvidedInjectionID();
    public abstract virtual PsiLanguageType get_SupportedOriginalLanguage();
    public abstract virtual string get_InjectionKindId();
    public abstract virtual IconId get_Icon();
    public abstract virtual ITreeNode LocateInjectNodeByTreeOffset(IFile file, IDocument document, int offset);
    public virtual bool get_SupportsInjectionIntention();
    public virtual bool get_SupportsInjectionComment();
    public virtual string get_InjectDescription();
    public virtual int get_Priority();
    public sealed virtual String[] get_CommentInjectionIDs();
    protected virtual String[] GetCommentInjectionIDs();
    public virtual int GetStartOffset(ITreeNode originalNode);
    public virtual int GetEndOffset(ITreeNode originalNode);
    public sealed virtual IInjectionTargetLanguage get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual InjectionNodeProvidersViewer get_InjectionNodeProvidersViewer();
    public sealed virtual String[] get_LanguageEqualsCommentTexts();
    public sealed virtual string get_ReSharperInjectCommentText();
    public ILookup`2<IPsiSourceFile, ITreeNodePointer`1<ITreeNode>> get_RangeManagerPointers();
    public sealed virtual bool HasRangeMarks(IPsiSourceFile sourceFile);
    public sealed virtual bool HasRangeMarkInsideNodeRange(IPsiSourceFile sourceFile, ITreeNode node);
    public sealed virtual IEnumerable`1<ITreeNode> GetMarkedNodes(IPsiSourceFile psf);
    public void ClearRanges();
    public sealed virtual void InjectIntoNodeRange(ITreeNode node, ITreeNodePointer`1<ITreeNode> pointer);
    public sealed virtual void RemoveInjectFromNodeRange(ITreeNode node);
    public sealed virtual InjectableLiteralsPresence ContainsInjectableLiterals(ITreeNode element);
    public virtual bool IsSupportedLiteralForInjection(ITreeNode originalNode);
    public sealed virtual bool IsSupportedLiteralForInjection(TokenNodeType tokenType);
    public sealed virtual Char[] get_LiteralBorderCharacters();
    public sealed virtual string GetCorrespondingCommentText(ITreeNode originalNode);
    public sealed virtual bool ShouldInjectByRangeMarker(IPsiSourceFile sourceFile, ITreeNode originalNode);
    public virtual IBuffer CreateBuffer(ITreeNode originalNode, string text, object options);
    public virtual bool get_CanRegenerate();
}
public interface JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.IReferenceInjectorProviderInLiterals {
}
[SettingsIndexedKeyAttribute("System.Reflection.Missing", "JetBrains.ReSharper.Psi.Resources.Strings", "LanguageInjectionsSettingDescription", "System.Int32")]
public class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.LanguageInjectionsSettingsKey : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "GuidSettingDescription")]
public string Guid;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "EnabledSettingDescription")]
public bool Enabled;
}
public abstract class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.LanguageInjectorProviderInLiteralsWithRangeMarkersBase`3 : InjectorProviderInLiteralsWithRangeMarkersBase`2<TOriginalNode, TInjectionTargetLanguage> {
    private static string LanguageInjectionKindId;
    private TInjectionTargetLanguage myInjectionTargetLanguage;
    public string InjectionKindId { get; }
    public PsiLanguageType ProvidedLanguage { get; }
    public IconId Icon { get; }
    protected LanguageInjectorProviderInLiteralsWithRangeMarkersBase`3(Lifetime lifetime, ISolution solution, IPersistentIndexManager persistentIndexManager, InjectionNodeProvidersViewer providersViewer, TInjectionTargetLanguage injectionTargetLanguage);
    public virtual string get_InjectionKindId();
    public virtual ITreeNode LocateInjectNodeByTreeOffset(IFile file, IDocument document, int offset);
    public sealed virtual bool IsGeneratedFile(IFile file);
    public virtual ITreeNode UpdateNode(IFile generatedFile, ITreeNode generatedNode, ITreeNode originalNode, Int32& length, string prefix, string suffix);
    public abstract virtual PsiLanguageType get_ProvidedLanguage();
    public virtual IconId get_Icon();
    public sealed virtual ILexerFactory CreateLexerFactory(LanguageService languageService);
    public sealed virtual bool OwnsNode(ITreeNode node);
    public sealed virtual bool AllowsLineBreaks(ITreeNode contextNode);
    public sealed virtual bool IsWhitespaceToken(ITokenNode token);
    public sealed virtual TreeTextRange FixValueRangeForLiteral(ITreeNode element);
}
public class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.LiteralInjectionContextData : object {
    [CompilerGeneratedAttribute]
private bool <CanInject>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanHaveInjectionComment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanHaveInjectionByRangeMarker>k__BackingField;
    [CompilerGeneratedAttribute]
private IInjectionNodeProvider[] <NodeProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AllWords>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Timestamp>k__BackingField;
    public bool CanInject { get; public set; }
    public bool CanHaveInjectionComment { get; public set; }
    public bool CanHaveInjectionByRangeMarker { get; public set; }
    public IInjectionNodeProvider[] NodeProviders { get; public set; }
    public IPsiSourceFile SourceFile { get; public set; }
    public String[] AllWords { get; public set; }
    public long Timestamp { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanInject();
    [CompilerGeneratedAttribute]
public void set_CanInject(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanHaveInjectionComment();
    [CompilerGeneratedAttribute]
public void set_CanHaveInjectionComment(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanHaveInjectionByRangeMarker();
    [CompilerGeneratedAttribute]
public void set_CanHaveInjectionByRangeMarker(bool value);
    [CompilerGeneratedAttribute]
public IInjectionNodeProvider[] get_NodeProviders();
    [CompilerGeneratedAttribute]
public void set_NodeProviders(IInjectionNodeProvider[] value);
    [CompilerGeneratedAttribute]
public IPsiSourceFile get_SourceFile();
    [CompilerGeneratedAttribute]
public void set_SourceFile(IPsiSourceFile value);
    [CompilerGeneratedAttribute]
public String[] get_AllWords();
    [CompilerGeneratedAttribute]
public void set_AllWords(String[] value);
    [CompilerGeneratedAttribute]
public long get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(long value);
}
public static class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.LiteralInjectorProviderUtil : object {
    private static Regex ourPatternEqualsLanguage;
    private static Regex ourPatternReSharperLanguage;
    private static Regex ourPatternEqualsReference;
    private static Regex ourPatternReSharperReference;
    private static String[] ourSuffixPrefixes;
    private static string PrefixPrefix;
    private static LiteralInjectorProviderUtil();
    public static TreeTextRange GetOwnerInnerTextRange(ITreeNode injectedNode, IFile& ownerOuterFile);
    public static ITreeNode LocateInjectNodeByTreeOffset(IFile file, IDocument document, int offset, PsiLanguageType providedLanguage);
    public static string ToOriginalText(string text, string prefix, string suffix, int startOffset, int endOffset, bool refixWhitespace);
    private static string TrimSuffix(string text, string suffix);
    private static string TrimPrefix(string text, string prefix);
    private static bool HasNewLineBeforeOrAtFileStart(ITreeNode token);
    private static bool IsNewLine(ITreeNode token);
    public static ITreeNode GetNearestCommentNode(ITreeNode originalNode, bool treatNewlines);
    public static bool CanApplyFormatter(ITreeNode element);
    public static bool CanApplyFormatter(ITreeNode element, IInjectorProviderInLiterals injector);
    private static bool CanApplyFormatter(IInjectedFileHolder injectedHolder, ITreeNode originalNode, IInjectorProviderInLiterals injector);
    public static LiteralInjectionContextData ComputeInjectionContextData(IPsiSourceFile sourceFile, IFile originalFile, IInjectorProviderInLiterals injector);
    public static bool ShouldAlwaysInject(IInjectedScopeData fileContext, ITreeNode originalNode, IInjectorProviderInLiterals provider);
    public static bool ShouldAlwaysInject(IInjectedScopeData fileContext, ITreeNode originalNode, IInjectorProviderInLiterals provider, String& prefix, String& suffix, Object& options);
    private static bool ShouldInjectByComment(ITreeNode originalNode, IInjectorProviderInLiterals provider, String& prefix, String& suffix);
    public static TreeTextRange GetValueTextRange(ITreeNode element);
}
public class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.LiteralsInjectedFileContext : IndependentInjectedFileContext {
    [NotNullAttribute]
private IPsiSourceFile mySourceFile;
    [CanBeNullAttribute]
private List`1<StringSearcher> mySearchers;
    [CanBeNullAttribute]
private HashSet`1<ITreeNode> myMarkedNodes;
    private int myMarkedNodesCounter;
    [CompilerGeneratedAttribute]
private IInjectionNodeProvider[] <Providers>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Words>k__BackingField;
    [CompilerGeneratedAttribute]
private ILanguageInjectorProviderInLiterals <InjectorProvider>k__BackingField;
    [CanBeNullAttribute]
public IInjectionNodeProvider[] Providers { get; }
    [CanBeNullAttribute]
public HashSet`1<string> Words { get; }
    public ILanguageInjectorProviderInLiterals InjectorProvider { get; }
    public LiteralsInjectedFileContext(IIndependentInjectedPsiProvider provider, ILanguageInjectorProviderInLiterals injectorProvider, IFile originalFile, LiteralInjectionContextData data);
    [CompilerGeneratedAttribute]
public sealed virtual IInjectionNodeProvider[] get_Providers();
    [CompilerGeneratedAttribute]
public sealed virtual HashSet`1<string> get_Words();
    [CompilerGeneratedAttribute]
public ILanguageInjectorProviderInLiterals get_InjectorProvider();
    protected virtual IRecursiveElementProcessor`1<CollectedData> CreateInjectedNodeCollector();
    public virtual ICollection`1<IInjectedNodeContext> GetAllInjects();
    public Nullable`1<bool> IsNodeMarked(ITreeNode node);
    [CanBeNullAttribute]
private List`1<StringSearcher> GetWordSearchers();
}
public abstract class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.LiteralsInjectionPsiProvider`2 : IndependentInjectedPsiProvider {
    [CompilerGeneratedAttribute]
private ILanguageInjectorProviderInLiterals <injectorProvider>P;
    [CompilerGeneratedAttribute]
private TTargetLanguage <targetLanguage>P;
    public PsiLanguageType GeneratedLanguage { get; }
    protected LiteralsInjectionPsiProvider`2(ILanguageInjectorProviderInLiterals injectorProvider, TTargetLanguage targetLanguage);
    public virtual bool IsApplicable(PsiLanguageType originalLanguage);
    public virtual bool IsApplicableToNode(ITreeNode node, IInjectedFileContext context);
    public virtual PsiLanguageType get_GeneratedLanguage();
    public virtual IInjectedContextData ComputeDataForFileContext(IFile originalFile);
    public virtual IInjectedFileContext CreateInjectedFileContext(IFile originalFile, IInjectedContextData data);
    public virtual IInjectedNodeContext CreateInjectedNodeContext(IInjectedFileContext fileContext, ITreeNode originalNode);
    private bool CanCreateInject(IInjectedFileContext fileContext, ITreeNode originalNode, Object& options, String& prefix, String& suffix);
    protected virtual bool CanBeGeneratedNode(ITreeNode node);
    protected virtual bool CanBeOriginalNode(ITreeNode node);
    public virtual IInjectedNodeContext Regenerate(IndependentInjectedNodeContext nodeContext);
    protected virtual ILexerFactory CreateLexerFactory(LanguageService languageService);
}
internal class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.Marshaller : object {
    public static Marshaller Instance;
    private static Marshaller();
    public sealed virtual void Marshal(UnsafeWriter s, TextRange[] arg);
    public sealed virtual TextRange[] Unmarshal(UnsafeReader s);
}
public class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.SimpleInjectingPsiRangeManager : InjectingPsiRangeManagerBase`1<ITreeNode> {
    public SimpleInjectingPsiRangeManager(Lifetime lifetime, ISolution solution, IPersistentIndexManager persistentIndexManager, string id);
}
public class JetBrains.ReSharper.Psi.Impl.Shared.InjectedPsi.SuspendInjectRegenerationCookie : object {
    [ThreadStaticAttribute]
private static int ourSuspendCounter;
    [ThreadStaticAttribute]
private static HashSet`1<IndependentInjectedNodeContext> ourContextForRegenerations;
    public static bool IsActive { get; }
    public static bool get_IsActive();
    public sealed virtual void Dispose();
    public static void RegisterForRegenerate(IndependentInjectedNodeContext contextToRegenerate);
}
public class JetBrains.ReSharper.Psi.Impl.Shared.MappedRangeType : object {
    public static string DefaultRangeType;
    public static MappedRangeType DEFAULT;
    public static Key FORBID_TRANSLATE;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private GreedType <GeneratedGreedType>k__BackingField;
    [CompilerGeneratedAttribute]
private IUserDataHolder <RangeProperties>k__BackingField;
    public string Name { get; }
    public string Type { get; }
    public GreedType GeneratedGreedType { get; }
    public IUserDataHolder RangeProperties { get; }
    public MappedRangeType(string name, string type, GreedType generatedGreedType);
    private static MappedRangeType();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public GreedType get_GeneratedGreedType();
    [CompilerGeneratedAttribute]
public IUserDataHolder get_RangeProperties();
    public sealed virtual IEnumerator GetEnumerator();
    public void Add(Key key);
    public void Add(Key`1<T> key, T value);
    public bool Equals(MappedRangeType other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.Impl.Shared.ModifyGeneratedRangeTransactionAction : object {
    private GeneratedRangeMapTree myMap;
    private TreeOffset myGeneratedOffset;
    private int myNewTextLength;
    private int myOldTextLength;
    private UpdateCoveringRange myUpdateCoveringRange;
    public ITreeNode AffectedElement { get; }
    public PsiChangedElementType AffectedElementType { get; }
    public IPsiSourceFile SourceFile { get; }
    public ModifyGeneratedRangeTransactionAction(GeneratedRangeMapTree map, TreeOffset generatedOffset, int newTextLength, int oldTextLength, UpdateCoveringRange updateCoveringRange);
    public sealed virtual ITreeNode get_AffectedElement();
    public sealed virtual PsiChangedElementType get_AffectedElementType();
    public sealed virtual IPsiSourceFile get_SourceFile();
    public sealed virtual ICollection`1<DocumentChange> GetDocumentChanges();
    public sealed virtual void RollBack();
}
internal class JetBrains.ReSharper.Psi.Impl.Shared.ModifyOriginalRangeTransactionAction : object {
    private GeneratedRangeMapTree myMap;
    private TreeOffset myOriginalOffset;
    private int myNewTextLength;
    private int myOldTextLength;
    private UpdateCoveringRange myUpdateCoveringRange;
    public ITreeNode AffectedElement { get; }
    public PsiChangedElementType AffectedElementType { get; }
    public IPsiSourceFile SourceFile { get; }
    public ModifyOriginalRangeTransactionAction(GeneratedRangeMapTree map, TreeOffset originalOffset, int newTextLength, int oldTextLength, UpdateCoveringRange updateCoveringRange);
    public sealed virtual ITreeNode get_AffectedElement();
    public sealed virtual PsiChangedElementType get_AffectedElementType();
    public sealed virtual IPsiSourceFile get_SourceFile();
    public sealed virtual ICollection`1<DocumentChange> GetDocumentChanges();
    public sealed virtual void RollBack();
}
internal class JetBrains.ReSharper.Psi.Impl.Shared.ModifySharedRangeTransactionAction : object {
    private GeneratedRangeMapTree myMap;
    private TreeOffset myOriginalOffset;
    private TreeOffset myGeneratedOffset;
    private int myNewTextLength;
    private int myOldTextLength;
    public ITreeNode AffectedElement { get; }
    public PsiChangedElementType AffectedElementType { get; }
    public IPsiSourceFile SourceFile { get; }
    public ModifySharedRangeTransactionAction(GeneratedRangeMapTree map, TreeOffset originalOffset, TreeOffset generatedOffset, int newTextLength, int oldTextLength);
    public sealed virtual ITreeNode get_AffectedElement();
    public sealed virtual PsiChangedElementType get_AffectedElementType();
    public sealed virtual IPsiSourceFile get_SourceFile();
    public sealed virtual ICollection`1<DocumentChange> GetDocumentChanges();
    public sealed virtual void RollBack();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Impl.Shared.RangesPair : ValueType {
    private TreeTextRange`1<Generated> myGeneratedRange;
    private TreeTextRange`1<Original> myOriginalRange;
    private MappedRangeType myRangeType;
    public static RangesPair InvalidPair;
    [CompilerGeneratedAttribute]
private bool <GreedyOnLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GreedyOnRight>k__BackingField;
    public TreeTextRange`1<Original> OriginalRange { get; }
    public TreeTextRange`1<Generated> GeneratedRange { get; }
    public MappedRangeType RangeType { get; }
    public bool GreedyOnLeft { get; }
    public bool GreedyOnRight { get; }
    public bool IsValid { get; }
    public RangesPair(TreeTextRange`1<Original> originalRange, TreeTextRange`1<Generated> generatedRange, MappedRangeType rangeType, bool greedyOnLeft, bool greedyOnRight);
    private static RangesPair();
    public TreeTextRange`1<Original> get_OriginalRange();
    public TreeTextRange`1<Generated> get_GeneratedRange();
    public MappedRangeType get_RangeType();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public bool get_GreedyOnLeft();
    [CompilerGeneratedAttribute]
public bool get_GreedyOnRight();
    public bool get_IsValid();
    [PureAttribute]
public TreeTextRange`1<Generated> Translate(TreeTextRange`1<Original> originalRange);
    [PureAttribute]
public TreeTextRange`1<Original> Translate(TreeTextRange`1<Generated> generatedRange);
    public bool Equals(RangesPair other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(RangesPair left, RangesPair right);
    public static bool op_Inequality(RangesPair left, RangesPair right);
}
public class JetBrains.ReSharper.Psi.Impl.Shared.RangesPairComparerByGenerated : object {
    [NotNullAttribute]
public static RangesPairComparerByGenerated Default;
    private static RangesPairComparerByGenerated();
    public sealed virtual int Compare(RangesPair x, RangesPair y);
}
public class JetBrains.ReSharper.Psi.Impl.Shared.RangesPairComparerByOriginal : object {
    [NotNullAttribute]
public static RangesPairComparerByOriginal Default;
    private static RangesPairComparerByOriginal();
    public sealed virtual int Compare(RangesPair x, RangesPair y);
}
public class JetBrains.ReSharper.Psi.Impl.Shared.RangeTranslatorWithGeneratedRangeMap : object {
    private object myLockObject;
    private IGeneratedRangeMap myRangeMap;
    public IFile OriginalFile { get; }
    public RangeTranslatorWithGeneratedRangeMap(IGeneratedRangeMap generatedRangeMap);
    public sealed virtual IFile get_OriginalFile();
    public sealed virtual IReadOnlyList`1<TreeTextRange> GetIntersectedOriginalRanges(TreeTextRange generatedRange);
    public sealed virtual IReadOnlyList`1<TreeTextRange> GetIntersectedOriginalRangesLowLevel(TreeTextRange generatedRange, bool includeHidden, bool strict);
    public static bool ExplicitTranslationFilter(IUserDataHolder userDataHolder);
    [NotNullAttribute]
public IReadOnlyList`1<TreeTextRange> GetIntersectedOriginalRanges(TreeTextRange generatedRange, Predicate`1<IUserDataHolder> filter, bool strict);
    public sealed virtual IReadOnlyList`1<TreeTextRange> GetIntersectedGeneratedRanges(TreeTextRange originalRange, bool includeHidden, bool strict);
    public IReadOnlyList`1<TreeTextRange> GetIntersectedGeneratedRangesLowLevel(TreeTextRange generatedRange);
    public IReadOnlyList`1<TreeTextRange> GetIntersectedGeneratedRangesForModification(TreeTextRange generatedRange);
    public IReadOnlyList`1<TreeTextRange`1<Original>> GetIntersectedOriginalRangesLowLevel(TreeTextRange`1<Original> originalTreeRange);
    public IReadOnlyList`1<TreeTextRange`1<Original>> GetIntersectedOriginalRangesLowLevel(TreeTextRange`1<Generated> generatedTreeRange);
    public IReadOnlyList`1<TreeTextRange`1<Generated>> GetIntersectedGeneratedRangesLowLevel(TreeTextRange`1<Generated> generatedTreeRange);
    public IReadOnlyList`1<TreeTextRange`1<Generated>> GetIntersectedGeneratedRanges(TreeTextRange`1<Original> originalTreeRange);
    public IReadOnlyList`1<TreeTextRange`1<Generated>> GetIntersectedGeneratedRanges(TreeTextRange`1<Original> originalTreeRange, Predicate`1<IUserDataHolder> filter);
    public IReadOnlyList`1<TreeTextRange`1<Generated>> GetIntersectedGeneratedRangesLowLevel(TreeTextRange`1<Original> originalTreeRange);
    public sealed virtual TreeTextRange OriginalToGenerated(TreeTextRange originalTreeRange);
    public TreeTextRange OriginalToGenerated(TreeTextRange originalTreeRange, Predicate`1<IUserDataHolder> filter);
    public sealed virtual TreeTextRange GeneratedToOriginal(TreeTextRange generatedRange, bool forModification);
    public sealed virtual Tuple`2<TreeTextRange, TreeTextRange> GetCoveringRange(TreeTextRange originalRange);
    public TreeTextRange GeneratedToOriginal(TreeTextRange generatedRange, Predicate`1<IUserDataHolder> filter);
    public TreeTextRange GeneratedToOriginalForModification(TreeTextRange generatedRange);
    public bool OnSharedRangeModified(TreeTextRange`1<Original> modifiedOriginalRange, TreeTextRange`1<Generated> modifiedGeneratedRange, int newText, bool addTransactionAction);
    public void OnOriginalRangeModified(TreeTextRange modifiedOriginalRange, int newLength, bool addTransactionAction);
    public void OnGeneratedRangeModified(TreeTextRange modifiedGeneratedRange, int newText, bool alwaysNotGreedy);
    public IReadOnlyList`1<RangesPair> GetIntersectedPairs(TreeTextRange`1<Original> range, Predicate`1<IUserDataHolder> filter, bool strict);
    public IReadOnlyList`1<RangesPair> GetIntersectedPairs(TreeTextRange`1<Generated> range, Predicate`1<IUserDataHolder> filter, bool strict);
    public IReadOnlyList`1<RangesPair> GetIntersectedPairs(TreeTextRange`1<Original> range, bool strict);
    public IReadOnlyList`1<RangesPair> GetIntersectedPairs(TreeTextRange`1<Generated> range, bool strict);
    public IReadOnlyList`1<RangesPair> GetIntersectedPairsLowLevel(TreeTextRange`1<Original> range, bool strict);
    public IReadOnlyList`1<RangesPair> GetIntersectedPairsLowLevel(TreeTextRange`1<Generated> range, bool strict);
    public IReadOnlyList`1<RangesPair> GetIntersectingPairs(TreeTextRange`1<Original> range, bool strict);
    public IReadOnlyList`1<RangesPair> GetIntersectingPairs(TreeTextRange`1<Generated> range, bool strict);
    public FrugalLocalList`1<RangesPair> GetCoveredRanges(TreeTextRange`1<Generated> coveringRange);
    public FrugalLocalList`1<RangesPair> GetCoveredRanges(TreeTextRange`1<Original> coveringRange);
    public sealed virtual string Dump(IFile generatedFile, bool dumpContext);
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertValid(IFile generatedFile);
    public void AddProjectionItem(TreeTextRange`1<Generated> generatedRange, TreeTextRange`1<Original> originalRange);
    public void AddProjectionItem(TreeTextRange`1<Generated> generatedRange, TreeTextRange`1<Original> originalRange, MappedRangeType rangeType);
    public void AddProjectionItem(TreeTextRange`1<Generated> generatedRange, TreeTextRange`1<Original> originalRange, MappedRangeType rangeType, bool greedyOnLeft, bool greedyOnRight);
    public void AppendWithShiftToOriginal(IGeneratedRangeMap anotherMap, TreeOffset offset);
    public IDisposable MoveToPointers();
    public void RemoveCoveredProjectionItems(TreeTextRange`1<Original> originalRange);
    public void RemoveOrCutIntersectingRanges(TreeTextRange`1<Original> originalRange);
    public void RemoveOrCutIntersectingRanges(TreeTextRange`1<Generated> generatedRange);
    public TreeTextRange`1<Original> FindRangeOriginal(TreeTextRange`1<Generated> generatedRange, bool before);
    public void ReplaceWith(RangeTranslatorWithGeneratedRangeMap newTranslator);
    public RangesPair GetCoveringRange(TreeTextRange`1<Original> originalRange);
    public RangesPair GetCoveringRangeExceptZeroLengthAtBounds(TreeTextRange`1<Original> originalRange);
}
public abstract class JetBrains.ReSharper.Psi.impl.Shared.References.InjectedReferenceProviderFactory : object {
    private IInjectorProviderInLiterals myProvider;
    [CompilerGeneratedAttribute]
private ISignal`1<IReferenceProviderFactory> <Changed>k__BackingField;
    [CompilerGeneratedAttribute]
private Action OnChanged;
    public ISignal`1<IReferenceProviderFactory> Changed { get; }
    protected InjectedReferenceProviderFactory(IInjectorProviderInLiterals provider, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public sealed virtual ISignal`1<IReferenceProviderFactory> get_Changed();
    [CompilerGeneratedAttribute]
public void add_OnChanged(Action value);
    [CompilerGeneratedAttribute]
public void remove_OnChanged(Action value);
    public sealed virtual IReferenceFactory CreateFactory(IPsiSourceFile sourceFile, IFile file, IWordIndex wordIndexForChecks);
    protected ReferenceCollection GetReferences(ITreeNode element, ReferenceCollection oldReferences, ILiteralsInjectionDataProvider data, IPsiSourceFile sourceFile);
    protected abstract virtual ReferenceCollection CreateReferences(ITreeNode element, IInjectorProviderInLiterals provider, ILiteralsInjectionDataProvider data, IPsiSourceFile sourceFile, string prefix, string suffix, object options);
    protected bool HasReference(ITreeNode element, IReferenceNameContainer names, ILiteralsInjectionDataProvider data, IPsiSourceFile sourceFile);
    protected abstract virtual bool HasName(ITreeNode element, IReferenceNameContainer names);
}
public interface JetBrains.ReSharper.Psi.Impl.Shared.References.IReferenceWithinElement {
    public ITreeNode Token { get; }
    public TreeTextRange RangeWithin { get; }
    public abstract virtual ITreeNode get_Token();
    public abstract virtual TreeTextRange get_RangeWithin();
}
public interface JetBrains.ReSharper.Psi.Impl.Shared.References.IReferenceWithinElement`1 {
    public ElementRange`1<T> ElementRange { get; public set; }
    public abstract virtual ElementRange`1<T> get_ElementRange();
    public abstract virtual void set_ElementRange(ElementRange`1<T> value);
}
public abstract class JetBrains.ReSharper.Psi.Impl.Shared.References.QualifiableReferenceImpl`1 : QualifiableCheckedReferenceBase`1<TOwnerElement> {
    protected IQualifier myQualifier;
    protected bool AllowedNotResolved { get; }
    public bool IsQualified { get; }
    protected QualifiableReferenceImpl`1(TOwnerElement owner, IQualifier qualifier);
    protected virtual bool get_AllowedNotResolved();
    public void SetQualifier(IQualifier qualifier);
    public virtual bool IsValid();
    public virtual bool get_IsQualified();
    public virtual IQualifier GetQualifier();
    public virtual ResolveResultWithInfo Resolve(ISymbolTable symbolTable, IAccessContext context);
}
public abstract class JetBrains.ReSharper.Psi.Impl.Shared.References.QualifiableReferenceWithinElement`2 : QualifiableReferenceImpl`1<TOwner> {
    private ElementRange`1<TToken> myElementRange;
    [CanBeNullAttribute]
public TToken Token { get; }
    private ITreeNode JetBrains.ReSharper.Psi.Impl.Shared.References.IReferenceWithinElement.Token { get; }
    public TreeTextRange RangeWithin { get; }
    public ElementRange`1<TToken> ElementRange { get; public set; }
    public bool CaseSensitive { get; }
    protected QualifiableReferenceWithinElement`2(TOwner owner, IQualifier qualifier, TToken token);
    protected QualifiableReferenceWithinElement`2(TOwner owner, IQualifier qualifier, TToken token, TreeTextRange rangeWithin);
    public TToken get_Token();
    private sealed virtual override ITreeNode JetBrains.ReSharper.Psi.Impl.Shared.References.IReferenceWithinElement.get_Token();
    public sealed virtual TreeTextRange get_RangeWithin();
    public virtual ElementRange`1<TToken> get_ElementRange();
    public virtual void set_ElementRange(ElementRange`1<TToken> value);
    public virtual string GetName();
    public virtual bool IsValid();
    public virtual TreeTextRange GetTreeTextRange();
    public virtual IAccessContext GetAccessContext();
    public abstract virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    public sealed virtual IPsiModule GetPsiModule();
    public sealed virtual IPsiSourceFile GetSourceFile();
    public virtual ITypeElement GetAccessContainingTypeElement();
    public abstract virtual ITypeElement GetQualifierTypeElement();
    public virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public sealed virtual IReference BindTo(IDeclaredElement element);
    [NotNullAttribute]
protected abstract virtual IReference BindToInternal(IDeclaredElement declaredElement, ISubstitution substitution);
    [NotNullAttribute]
public virtual ISymbolTable GetCompletionSymbolTable();
    [NotNullAttribute]
public virtual ISymbolTable GetSmartCompletionSymbolTable();
    [NotNullAttribute]
protected virtual ISymbolFilter[] GetCompletionFilters();
    [NotNullAttribute]
protected virtual ISymbolFilter[] GetSmartSymbolFilters();
    public virtual ISymbolFilter[] GetSymbolFilters();
    public virtual bool get_CaseSensitive();
}
public class JetBrains.ReSharper.Psi.impl.Shared.References.ReferenceInjectionData : object {
    [CompilerGeneratedAttribute]
private IInjectionNodeProvider[] <Providers>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Words>k__BackingField;
    public IInjectionNodeProvider[] Providers { get; }
    public HashSet`1<string> Words { get; }
    public ReferenceInjectionData(IInjectionNodeProvider[] providers, HashSet`1<string> words);
    [CompilerGeneratedAttribute]
public sealed virtual IInjectionNodeProvider[] get_Providers();
    [CompilerGeneratedAttribute]
public sealed virtual HashSet`1<string> get_Words();
}
public abstract class JetBrains.ReSharper.Psi.impl.Shared.References.ReferenceInjectorProviderInLiteralsWithRangeMarkersBase`2 : InjectorProviderInLiteralsWithRangeMarkersBase`2<TOriginalNode, TInjectionTargetLanguage> {
    private static string ReferenceInjectionKindId;
    public string InjectionKindId { get; }
    protected ReferenceInjectorProviderInLiteralsWithRangeMarkersBase`2(Lifetime lifetime, ISolution solution, IPersistentIndexManager persistentIndexManager, InjectionNodeProvidersViewer providersViewer, TInjectionTargetLanguage injectionTargetLanguage);
    public virtual ITreeNode LocateInjectNodeByTreeOffset(IFile file, IDocument document, int offset);
    public virtual string get_InjectionKindId();
}
public abstract class JetBrains.ReSharper.Psi.Impl.Shared.References.ReferenceWithinElementBase`2 : CheckedReferenceBase`1<TOwner> {
    private ElementRange`1<TToken> myElementRange;
    protected bool AllowedNotResolved;
    public TToken Token { get; }
    private ITreeNode JetBrains.ReSharper.Psi.Impl.Shared.References.IReferenceWithinElement.Token { get; }
    public TreeTextRange RangeWithin { get; }
    public ElementRange`1<TToken> ElementRange { get; public set; }
    public bool CaseSensitive { get; }
    protected ReferenceWithinElementBase`2(TOwner owner, TToken token, TreeTextRange rangeWithin);
    public TToken get_Token();
    private sealed virtual override ITreeNode JetBrains.ReSharper.Psi.Impl.Shared.References.IReferenceWithinElement.get_Token();
    public sealed virtual TreeTextRange get_RangeWithin();
    public virtual ElementRange`1<TToken> get_ElementRange();
    public virtual void set_ElementRange(ElementRange`1<TToken> value);
    public virtual bool IsValid();
    public virtual ResolveResultWithInfo Resolve(ISymbolTable symbolTable, IAccessContext context);
    public virtual ResolveResultWithInfo ResolveWithoutCache();
    public virtual string GetName();
    public sealed virtual IReference BindTo(IDeclaredElement element);
    protected abstract virtual IReference BindToInternal(IDeclaredElement element, ISubstitution substitution);
    public sealed virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    public virtual TreeTextRange GetTreeTextRange();
    public virtual IAccessContext GetAccessContext();
    public virtual ITypeElement GetAccessContainingTypeElement();
    public virtual Staticness GetStaticness();
    public virtual QualifierKind GetQualifierKind();
    public virtual ITypeElement GetQualifierTypeElement();
    public sealed virtual IPsiModule GetPsiModule();
    public sealed virtual IPsiSourceFile GetSourceFile();
    [NotNullAttribute]
public virtual ISymbolTable GetCompletionSymbolTable();
    protected virtual ISymbolFilter[] GetCompletionFilters();
    public virtual ISymbolFilter[] GetSymbolFilters();
    public virtual bool get_CaseSensitive();
    protected virtual ISymbolFilter[] GetSmartSymbolFilters(Boolean& applyAllFilters);
    public virtual ISymbolTable GetSmartCompletionSymbolTable();
}
public interface JetBrains.ReSharper.Psi.Impl.Shared.References.Universal.IUniversalPathReferenceProvider {
    public abstract virtual IEnumerable`1<Tuple`2<TreeTextRange, string>> GetPathReferenceInfos(ITreeNode node);
    public abstract virtual IReference BindReference(UniversalPathReference universalPathReference, IDeclaredElement declaredElement);
}
public class JetBrains.ReSharper.Psi.Impl.Shared.References.Universal.UniversalPathReference : QualifiableReferenceWithinElement`2<ITreeNode, ITreeNode> {
    private string myName;
    private String[] myPrev;
    private IUniversalPathReferenceProvider myProvider;
    public UniversalPathReference(ITreeNode owner, TreeTextRange rangeWithin, string name, String[] prev, IUniversalPathReferenceProvider provider);
    public virtual Staticness GetStaticness();
    public virtual string GetName();
    public virtual ITypeElement GetQualifierTypeElement();
    protected virtual IReference BindToInternal(IDeclaredElement declaredElement, ISubstitution substitution);
    public sealed virtual VirtualFileSystemPath GetBasePath();
    public sealed virtual ISymbolFilter[] GetPathFilters();
    public virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
}
public static class JetBrains.ReSharper.Psi.Impl.Shared.References.Universal.UniversalPathReferenceUtil : object {
    private static Char[] ourSeparators;
    private static UniversalPathReferenceUtil();
    public static ReferenceCollection CreatePathReferences(IUniversalPathReferenceProvider provider, ITreeNode element);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.Shared.References.Universal.UniversalPathReferenceUtil/<GetPathReferenceInfos>d__2")]
public static IEnumerable`1<Tuple`2<TreeTextRange, string>> GetPathReferenceInfos(ITreeNode element, int startOffset, int endOffset, Func`2<string, Tuple`2<string, RangeTranslator>> parseLiteral);
}
internal class JetBrains.ReSharper.Psi.Impl.Shared.RemoveRangesTransactionAction : object {
    private GeneratedRangeMapTree myMap;
    private IEnumerable`1<RangesPair> myListToRemove;
    public ITreeNode AffectedElement { get; }
    public PsiChangedElementType AffectedElementType { get; }
    public IPsiSourceFile SourceFile { get; }
    public RemoveRangesTransactionAction(GeneratedRangeMapTree map, IEnumerable`1<RangesPair> listToRemove);
    public sealed virtual ITreeNode get_AffectedElement();
    public sealed virtual PsiChangedElementType get_AffectedElementType();
    public sealed virtual IPsiSourceFile get_SourceFile();
    public sealed virtual ICollection`1<DocumentChange> GetDocumentChanges();
    public sealed virtual void RollBack();
}
internal class JetBrains.ReSharper.Psi.Impl.Shared.ResetRangesTransactionAction : object {
    private GeneratedRangeMapTree myMap;
    private List`1<RangesPair> myPairList;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    public ITreeNode AffectedElement { get; }
    public PsiChangedElementType AffectedElementType { get; }
    public IPsiSourceFile SourceFile { get; }
    public ResetRangesTransactionAction(GeneratedRangeMapTree map);
    public sealed virtual ITreeNode get_AffectedElement();
    public sealed virtual PsiChangedElementType get_AffectedElementType();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiSourceFile get_SourceFile();
    public sealed virtual ICollection`1<DocumentChange> GetDocumentChanges();
    public sealed virtual void RollBack();
}
public abstract class JetBrains.ReSharper.Psi.Impl.Shared.Tree.CompositeElementWithReferences : CompositeElement {
    private object myReferencesLockObject;
    private Nullable`1<ReferenceCollection> myFirstClassReferences;
    protected virtual void PreInit();
    public sealed virtual ReferenceCollection GetFirstClassReferences();
    public virtual ReferenceCollection CreateCustomReferences();
    protected virtual ReferenceCollection CreateFirstClassReferences();
    protected void ResetReferencesIfGoneOff();
    public void ResetReferences();
    public virtual IChameleonNode FindChameleonWhichCoversRange(TreeTextRange textRange);
}
public static class JetBrains.ReSharper.Psi.Impl.Shared.Util.ReferenceWithinElementUtil`1 : object {
    public static bool CheckElementValidity(ElementRange`1<TTreeNode> elementRange, ITreeNode expectedOwner);
    public static void AddRestoreTransactionAction(IPsiServices psiServices, IReferenceWithinElement`1<TTreeNode> referenceWithToken, ElementRange`1<TTreeNode> oldRange);
    private static TTreeNode PrepareNewToken(TTreeNode token, TreeTextRange oldRange, string newText, Func`3<TTreeNode, IBuffer, TTreeNode> tokenFactory);
    public static TTreeNode SetText(TTreeNode token, TreeTextRange oldRange, string newText, Func`3<TTreeNode, IBuffer, TTreeNode> tokenFactory, ITreeNode[] elementsToRemoveReferences);
    private static void ReplaceToken(TTreeNode oldToken, TTreeNode newToken);
    private static IReferenceWithinElement`1<TTreeNode> AssertReferenceIsValid(IReferenceWithinElement`1<TTreeNode> reference);
    public static IReferenceWithinElement`1<TTreeNode> SetText(IReferenceWithinElement`1<TTreeNode> reference, string newText, Func`3<TTreeNode, IBuffer, TTreeNode> tokenFactory, ITreeNode[] fixReferencesElements);
}
public class JetBrains.ReSharper.Psi.Impl.Special.DefaultConstructor : object {
    [NotNullAttribute]
private ITypeElement myTypeElement;
    public ISubstitution IdSubstitution { get; }
    public bool IsDefault { get; }
    public bool IsParameterless { get; }
    public bool IsImplicit { get; }
    public bool IsValueTypeZeroInit { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    [NotNullAttribute]
public ITypeElement ContainingType { get; }
    public IPsiModule Module { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public bool CanBeDefinedExplicitly { get; }
    public IDeclaredElement ElementThatDeclaresThisMember { get; }
    public string XMLDocId { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public bool IsPredefined { get; }
    public bool IsIterator { get; }
    public MemberHidePolicy HidePolicy { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public DefaultConstructor(ITypeElement typeElement);
    public virtual string ToString();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual bool get_IsDefault();
    public sealed virtual bool get_IsParameterless();
    public sealed virtual bool get_IsImplicit();
    public sealed virtual bool get_IsValueTypeZeroInit();
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual ITypeElement get_ContainingType();
    [NotNullAttribute]
public sealed virtual ITypeElement GetContainingType();
    [NotNullAttribute]
public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual bool get_CanBeDefinedExplicitly();
    public sealed virtual IDeclaredElement get_ElementThatDeclaresThisMember();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual string get_XMLDocId();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual bool get_IsPredefined();
    public sealed virtual bool get_IsIterator();
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual Nullable`1<Hash> CalcHash();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Impl.Special.DelegateBeginInvokeMethod : DelegateMethod {
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public string ShortName { get; }
    public DelegateBeginInvokeMethod(IDelegate holder);
    public virtual IList`1<IParameter> get_Parameters();
    public virtual IType get_ReturnType();
    public virtual string get_ShortName();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Impl.Special.DelegateConstructor : object {
    [NotNullAttribute]
private IDelegate myDelegateType;
    [CanBeNullAttribute]
private IParameter[] modreq(System.Runtime.CompilerServices.IsVolatile) myParameters;
    public bool IsPredefined { get; }
    public bool IsIterator { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    [NotNullAttribute]
public ITypeElement ContainingType { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public string XMLDocId { get; }
    public ISubstitution IdSubstitution { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public bool IsDefault { get; }
    public bool IsParameterless { get; }
    public bool IsImplicit { get; }
    public bool IsValueTypeZeroInit { get; }
    public MemberHidePolicy HidePolicy { get; }
    public DelegateConstructor(IDelegate delegateType);
    public sealed virtual bool get_IsPredefined();
    public sealed virtual bool get_IsIterator();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual ITypeElement get_ContainingType();
    [NotNullAttribute]
public sealed virtual ITypeElement GetContainingType();
    [NotNullAttribute]
public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual string get_XMLDocId();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual bool get_IsDefault();
    public sealed virtual bool get_IsParameterless();
    public sealed virtual bool get_IsImplicit();
    public sealed virtual bool get_IsValueTypeZeroInit();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual Nullable`1<Hash> CalcHash();
    public virtual string ToString();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Impl.Special.DelegateEndInvokeMethod : DelegateMethod {
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public string ShortName { get; }
    public DelegateEndInvokeMethod(IDelegate holder);
    public virtual IList`1<IParameter> get_Parameters();
    public virtual IType get_ReturnType();
    public virtual ReferenceKind get_ReturnKind();
    public virtual string get_ShortName();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Impl.Special.DelegateInvokeMethod : DelegateMethod {
    [NotNullAttribute]
private Func`2<DelegateInvokeMethod, IList`1<IParameter>> myParametersGetter;
    [NotNullAttribute]
private Func`2<DelegateInvokeMethod, IType> myReturnTypeGetter;
    [NotNullAttribute]
private Func`2<DelegateInvokeMethod, ReferenceKind> myReturnKindGetter;
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public string ShortName { get; }
    public DelegateInvokeMethod(IDelegate holder, Func`2<DelegateInvokeMethod, IList`1<IParameter>> parametersGetter, Func`2<DelegateInvokeMethod, IType> returnTypeGetter, Func`2<DelegateInvokeMethod, ReferenceKind> returnKindGetter);
    public virtual IList`1<IParameter> get_Parameters();
    public virtual IType get_ReturnType();
    public virtual ReferenceKind get_ReturnKind();
    public virtual string get_ShortName();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class JetBrains.ReSharper.Psi.Impl.Special.DelegateMethod : object {
    protected IDelegate myDelegate;
    public IDelegate Owner { get; }
    public bool IsPredefined { get; }
    public bool IsIterator { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public string ShortName { get; }
    public bool IsVarArg { get; }
    public bool CaseSensitiveName { get; }
    public ITypeElement ContainingType { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public string XMLDocId { get; }
    public ISubstitution IdSubstitution { get; }
    public bool IsExplicitImplementation { get; }
    public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    public bool CanBeImplicitImplementation { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public bool IsExtensionMethod { get; }
    public bool IsAsync { get; }
    public MemberHidePolicy HidePolicy { get; }
    protected DelegateMethod(IDelegate holder);
    public IDelegate get_Owner();
    public sealed virtual bool get_IsPredefined();
    public sealed virtual bool get_IsIterator();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public abstract virtual IList`1<IParameter> get_Parameters();
    public abstract virtual IType get_ReturnType();
    public virtual ReferenceKind get_ReturnKind();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public abstract virtual string get_ShortName();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual ITypeElement get_ContainingType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual string get_XMLDocId();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual bool get_IsExplicitImplementation();
    public sealed virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    public sealed virtual bool get_CanBeImplicitImplementation();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public sealed virtual bool get_IsExtensionMethod();
    public sealed virtual bool get_IsAsync();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual Nullable`1<Hash> CalcHash();
    protected static bool EqualDelegates(IDelegate delegate1, IDelegate delegate2);
}
public class JetBrains.ReSharper.Psi.Impl.Special.ImplicitAccessor : SimpleAccessorBase {
    public bool CanBeDefinedExplicitly { get; }
    public IDeclaredElement ElementThatDeclaresThisMember { get; }
    public ImplicitAccessor(IOverridableMember owner, AccessorKind kind);
    public sealed virtual bool get_CanBeDefinedExplicitly();
    public sealed virtual IDeclaredElement get_ElementThatDeclaresThisMember();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Impl.Special.Parameter : object {
    private int myParameterIndex;
    private ScopedKind myScope;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private IParametersOwner <ContainingParametersOwner>k__BackingField;
    public string ShortName { get; }
    public ParameterKind Kind { get; }
    public IType Type { get; }
    [NotNullAttribute]
public IParametersOwner ContainingParametersOwner { get; }
    public ISubstitution IdSubstitution { get; }
    public bool IsOptional { get; }
    public bool IsVarArg { get; }
    public bool IsParams { get; }
    public bool IsParameterArray { get; }
    public bool IsParameterCollection { get; }
    public bool IsValueVariable { get; }
    public ScopedKind Scope { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public Parameter(IParametersOwner declaringParametersOwner, int parameterIndex, ParameterKind kind, ScopedKind parameterScope, IType type, string name);
    public Parameter(IParametersOwner declaringParametersOwner, int parameterIndex, ParameterKind kind, IType type, string name);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ShortName();
    [CompilerGeneratedAttribute]
public sealed virtual ParameterKind get_Kind();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual IParametersOwner get_ContainingParametersOwner();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual bool get_IsParams();
    public sealed virtual bool get_IsParameterArray();
    public sealed virtual bool get_IsParameterCollection();
    public sealed virtual bool get_IsValueVariable();
    public sealed virtual ScopedKind get_Scope();
    public sealed virtual DefaultValue GetDefaultValue();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class JetBrains.ReSharper.Psi.Impl.Special.SimpleAccessorBase : object {
    [CompilerGeneratedAttribute]
private IOverridableMember <OwnerMember>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessorKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private IParameter <ValueVariable>k__BackingField;
    [NotNullAttribute]
public IOverridableMember OwnerMember { get; }
    public AccessorKind Kind { get; }
    public bool IsAuto { get; }
    public bool IsInitOnly { get; }
    public bool IsVarArg { get; }
    public IParameter ValueVariable { get; }
    public bool IsPredefined { get; }
    public bool IsIterator { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public bool IsExtensionMethod { get; }
    public bool IsAsync { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public ITypeElement ContainingType { get; }
    public string XMLDocId { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public MemberHidePolicy HidePolicy { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public bool IsExplicitImplementation { get; }
    public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    public bool CanBeImplicitImplementation { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    protected SimpleAccessorBase(IOverridableMember owner, AccessorKind kind);
    [CompilerGeneratedAttribute]
public sealed virtual IOverridableMember get_OwnerMember();
    [CompilerGeneratedAttribute]
public sealed virtual AccessorKind get_Kind();
    public sealed virtual bool get_IsAuto();
    public virtual bool get_IsInitOnly();
    public sealed virtual bool get_IsVarArg();
    [CompilerGeneratedAttribute]
public sealed virtual IParameter get_ValueVariable();
    public sealed virtual bool get_IsPredefined();
    public sealed virtual bool get_IsIterator();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public sealed virtual bool get_IsExtensionMethod();
    public sealed virtual bool get_IsAsync();
    public virtual IList`1<IParameter> get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    private string CalculateShortName(string ownerShortName);
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual ITypeElement get_ContainingType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual string get_XMLDocId();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual Nullable`1<Hash> CalcHash();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public virtual AccessRights GetAccessRights();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual bool get_IsExplicitImplementation();
    public sealed virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    public sealed virtual bool get_CanBeImplicitImplementation();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
}
public class JetBrains.ReSharper.Psi.Impl.Special.SpecialAttributeInstance : object {
    private IClrTypeName myClrTypeName;
    private IPsiModule myModule;
    private Func`1<AttributeValue[]> myCtorArguments;
    private Func`1<IEnumerable`1<Pair`2<string, AttributeValue>>> myNamedArguments;
    public IConstructor Constructor { get; }
    public int PositionParameterCount { get; }
    public int NamedParameterCount { get; }
    public SpecialAttributeInstance(IClrTypeName clrTypeName, IPsiModule module);
    public SpecialAttributeInstance(IClrTypeName clrTypeName, IPsiModule module, Func`1<AttributeValue[]> ctorArguments);
    public SpecialAttributeInstance(IClrTypeName clrTypeName, IPsiModule module, Func`1<AttributeValue[]> ctorArguments, Func`1<IEnumerable`1<Pair`2<string, AttributeValue>>> namedArguments);
    public sealed virtual IClrTypeName GetClrName();
    public sealed virtual string GetAttributeShortName();
    public sealed virtual IDeclaredType GetAttributeType();
    public sealed virtual IConstructor get_Constructor();
    public sealed virtual int get_PositionParameterCount();
    public sealed virtual AttributeValue PositionParameter(int paramIndex);
    public sealed virtual IEnumerable`1<AttributeValue> PositionParameters();
    public sealed virtual int get_NamedParameterCount();
    public sealed virtual AttributeValue NamedParameter(string name);
    public sealed virtual IEnumerable`1<Pair`2<string, AttributeValue>> NamedParameters();
    public void Dump(TextWriter writer, string indent);
}
public class JetBrains.ReSharper.Psi.Impl.Special.ValueVariable : object {
    private IAccessor myAccessor;
    private string myName;
    [CanBeNullAttribute]
public IOverridableMember AccessorOwner { get; }
    public IType Type { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public ParameterKind Kind { get; }
    public bool IsParams { get; }
    public bool IsParameterArray { get; }
    public bool IsParameterCollection { get; }
    public bool IsOptional { get; }
    public bool IsVarArg { get; }
    public ScopedKind Scope { get; }
    public IParametersOwner ContainingParametersOwner { get; }
    public bool IsValueVariable { get; }
    public ValueVariable(IAccessor accessor, string name);
    public IOverridableMember get_AccessorOwner();
    public sealed virtual IType get_Type();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual ParameterKind get_Kind();
    public sealed virtual bool get_IsParams();
    public sealed virtual bool get_IsParameterArray();
    public sealed virtual bool get_IsParameterCollection();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual ScopedKind get_Scope();
    public sealed virtual DefaultValue GetDefaultValue();
    public sealed virtual IParametersOwner get_ContainingParametersOwner();
    public sealed virtual bool get_IsValueVariable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Impl.TreeNodeCopyContext : object {
    [CanBeNullAttribute]
private NodeUserDataHolder myUserDataHolder;
    [NotNullAttribute]
private Dictionary`2<ITreeNode, ITreeNode> myNodeMap;
    [NotNullAttribute]
private Dictionary`2<ITreeNode, UserDataHolder> myUserDataCopy;
    public ITreeNode Item { get; }
    private TreeNodeCopyContext(NodeUserDataHolder userDataHolder);
    [NotNullAttribute]
[PureAttribute]
public static TreeNodeCopyContext CreateFrom(ITreeNode node);
    public void OnNodeCopied(ITreeNode original, ITreeNode clone);
    public ITreeNode get_Item(ITreeNode original);
    public void ApplyPersistentData(ITreeNode copiedElement);
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Impl.TypeElementInheritanceCache : InvalidatingPsiCache {
    [NotNullAttribute]
private LazyForkedContentModelData`1<PerContentModelForkStorage> myStorage;
    [NotNullAttribute]
private static HashSet`1<ITypeElement> EMPTY;
    [ThreadStaticAttribute]
private static HashSet`1<ITypeElement> ourPerThreadImmediateSuperTypesCalcInProgress;
    [NotNullAttribute]
private static ObjectPool`1<PooledHashSet`1<ITypeElement>> ourVisitedSetPool;
    private static TypeElementInheritanceCache();
    [NotNullAttribute]
[PureAttribute]
public static TypeElementInheritanceCache GetInstance(IPsiServices psiServices);
    protected virtual void InvalidateOnPhysicalChange(PsiChangedElementType elementType);
    public bool IsDescendantOf(ITypeElement subType, ITypeElement superType);
    public bool IsImmediateDescendantOf(ITypeElement subType, ITypeElement superType);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public IList`1<IDeclaredType> GetOrCalculateImmediateSuperTypes(TTypeElement typeElement, Func`2<TTypeElement, IList`1<IDeclaredType>> calculator);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public IDeclaredType GetOrCalculateBaseClass(TClass derived, Func`2<TClass, IDeclaredType> calculator);
    [MustUseReturnValueAttribute]
public HybridCollection`1<ISubstitution> GetAncestorSubstitution(ITypeElement subtype, ITypeElement type);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
private HashSet`1<ITypeElement> GetSuperTypes(ITypeElement typeElement);
    [MustUseReturnValueAttribute]
public bool HasInheritors(ITypeElement typeElement);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class JetBrains.ReSharper.Psi.Impl.Types.ArrayType : object {
    [CompilerGeneratedAttribute]
private IType <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Rank>k__BackingField;
    public IType ElementType { get; }
    public int Rank { get; }
    public TypeDecorationSet TypeDecorations { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public IPsiModule Module { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public bool IsOpenType { get; }
    public TypeClassification Classify { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public ArrayType(IType elementType, int rank);
    public sealed virtual IPsiServices GetPsiServices();
    [CompilerGeneratedAttribute]
public sealed virtual IType get_ElementType();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Rank();
    public sealed virtual TypeDecorationSet get_TypeDecorations();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual bool get_IsOpenType();
    public sealed virtual TypeClassification get_Classify();
    public sealed virtual IDeclaredType GetScalarType();
    [DebuggerStepThroughAttribute]
[NotNullAttribute]
public sealed virtual IType ToIType();
    public sealed virtual ISymbolTable GetSymbolTable(IPsiModule module);
    public sealed virtual bool IsWellFormed(ITypeConstraintsVerifier typeConstraintsVerifier);
    public sealed virtual ITypePointer CreatePointer();
    public sealed virtual bool IsValid();
    public sealed virtual IArrayType WithTypeDecorations(TypeDecorationSet typeDecorations);
    private sealed virtual override IType JetBrains.ReSharper.Psi.IType.WithTypeDecorations(TypeDecorationSet typeDecorations);
    public sealed virtual IArrayType WithNullableAnnotation(NullableAnnotation nullableAnnotation);
    private sealed virtual override IType JetBrains.ReSharper.Psi.IType.WithNullableAnnotation(NullableAnnotation nullableAnnotation);
    public sealed virtual bool IsExplicitlyConvertibleTo(IType anotherType, ITypeConversionRule conversionRule);
    public sealed virtual bool IsImplicitlyConvertibleTo(IType anotherType, ITypeConversionRule conversionRule);
    public sealed virtual void Accept(TypeVisitor typeVisitor);
    public sealed virtual TResult Accept(TypeVisitor`2<TContext, TResult> typeVisitor, TContext context);
    private static void AcceptInternal(IArrayType arrayType, TypeVisitor typeVisitor);
    public sealed virtual IType MergeNullability(IType otherType, TypeParameterVariance variance);
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public virtual string ToString();
    private string get_DebuggerDisplay();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IType type, IEqualityComparer`1<IType> childrenComparer);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ThreadSafeAttribute]
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Impl.Types.CaseSensitiveSymbolScopeRequestCache : InvalidatingPsiCache {
    private SourceTypeNamesCatalog mySourceTypeNamesCatalog;
    private DirectMappedCache`2<Input, ITypeElement[]> mySourceOrCompiledTypeElementCaches;
    private DirectMappedCache`2<Input, ITypeElement[]> myCompiledTypeElementCaches;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private DirectMappedCache`2<Pair`2<IPsiModule, IClrTypeName>, ITypeElement[]> myUniversalContextTypeElementCaches;
    public CaseSensitiveSymbolScopeRequestCache(Lifetime lifetime, ChangeManager changeManager, IPsiModules psiModules, SourceTypeNamesCatalog sourceTypeNamesCatalog, InternalsVisibleToCache internalsVisibleToCache);
    public ITypeElement[] GetOrCreateWithContext(IModuleReferenceResolveContext context, IPsiModule psiModule, IClrTypeName clrTypeName);
    private static ITypeElement[] CreateTypeElements(Input input);
    private static ITypeElement[] CreateTypeElements(Pair`2<IPsiModule, IClrTypeName> pair);
    public virtual void Invalidate(ITreeNode element, PsiChangedElementType elementType);
    public sealed virtual object Execute(IChangeMap changeMap);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__4_0(EventArgs _);
}
[DebuggerDisplayAttribute("{DebugString,nq}")]
public abstract class JetBrains.ReSharper.Psi.Impl.Types.DeclaredTypeBase : object {
    [ThreadStaticAttribute]
private static HashSet`1<Pair`2<IDeclaredType, IDeclaredType>> ourSubtypeOfInProgress;
    [ThreadStaticAttribute]
private static HashSet`1<ITypeParameter> ourTypeParameterClassificationInProgress;
    public IPsiModule Module { get; }
    public TypeDecorationSet TypeDecorations { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public AssemblyNameInfo Assembly { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public bool IsOpenType { get; }
    public TypeClassification Classify { get; }
    [NotNullAttribute]
[DebuggerBrowsableAttribute("0")]
private string DebugString { get; }
    public abstract virtual IPsiModule get_Module();
    public abstract virtual TypeDecorationSet get_TypeDecorations();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    public virtual AssemblyNameInfo get_Assembly();
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual bool get_IsOpenType();
    public virtual TypeClassification get_Classify();
    private string get_DebugString();
    public abstract virtual IPsiServices GetPsiServices();
    [CanBeNullAttribute]
protected abstract virtual ITypeElement GetTypeElement(IModuleReferenceResolveContext projectResolveContext);
    [CanBeNullAttribute]
protected abstract virtual ITypeElement GetTypeElementNoRetargeting();
    [NotNullAttribute]
protected abstract virtual IResolveResult Resolve(IModuleReferenceResolveContext projectResolveContext);
    [NotNullAttribute]
protected abstract virtual IResolveResult ResolveNoRetargeting();
    [NotNullAttribute]
[DebuggerStepThroughAttribute]
public sealed virtual IType ToIType();
    [NotNullAttribute]
public sealed virtual IDeclaredType GetScalarType();
    public virtual IDeclaredType WithTypeDecorations(TypeDecorationSet typeDecorations);
    private sealed virtual override IType JetBrains.ReSharper.Psi.IType.WithTypeDecorations(TypeDecorationSet typeDecorations);
    public sealed virtual IDeclaredType WithNullableAnnotation(NullableAnnotation nullableAnnotation);
    private sealed virtual override IType JetBrains.ReSharper.Psi.IType.WithNullableAnnotation(NullableAnnotation nullableAnnotation);
    public virtual bool IsValid();
    public virtual IClrTypeName GetClrName();
    public sealed virtual ITypeElement GetTypeElement();
    private static bool SkipRetarget(IModuleReferenceResolveContext projectResolveContext);
    public virtual bool IsExplicitlyConvertibleTo(IType anotherType, ITypeConversionRule conversionRule);
    public virtual bool IsImplicitlyConvertibleTo(IType anotherType, ITypeConversionRule conversionRule);
    protected static TypeClassification ClassifyTypeParameter(ITypeParameter typeParameter, ISubstitution substitution);
    public sealed virtual bool IsWellFormed(ITypeConstraintsVerifier typeConstraintsVerifier);
    public virtual ITypePointer CreatePointer();
    public virtual void Accept(TypeVisitor typeVisitor);
    public virtual TResult Accept(TypeVisitor`2<TContext, TResult> typeVisitor, TContext context);
    private static void AcceptInternal(IDeclaredType declaredType, TypeVisitor typeVisitor);
    public virtual IDeclaredType Retarget(IPsiModule psiModule);
    [NotNullAttribute]
private static ISubstitution RetargetSubstitution(ITypeElement typeElement, ITypeElement retargetedTypeElement, ISubstitution substitution);
    public sealed virtual ISymbolTable GetSymbolTable(IPsiModule module);
    public sealed virtual bool IsSubtypeOf(IDeclaredType to, ITypeConversionRule typeConversionRule);
    public sealed virtual IType MergeNullability(IType otherType, TypeParameterVariance variance);
    private static IType MergeNullability(IDeclaredType self, IType otherType, TypeParameterVariance variance);
    private static TypeParameterVariance GetTypeArgumentVariance(TypeParameterVariance typeVariance, TypeParameterVariance typeParameterVariance);
    public sealed virtual IResolveResult Resolve();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IType type, IEqualityComparer`1<IType> childrenComparer);
    public sealed virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    protected virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle, NullableAnnotation annotation);
    [NotNullAttribute]
protected virtual RichText GetUnresolvedPresentation(NullableAnnotation nullableAnnotation, ITypePresenter presenter, TypePresentationStyle typePresentationStyle);
    [CompilerGeneratedAttribute]
internal static bool <get_Classify>g__IsFromSystemNamespace|17_0(ITypeElement typeElement);
    [CompilerGeneratedAttribute]
internal static TypeClassification <ClassifyTypeParameter>g__ClassifyByBaseTypes|37_0(ITypeParameter typeParameter, ISubstitution substitution, HashSet`1<ITypeParameter> inProgress);
}
public class JetBrains.ReSharper.Psi.Impl.Types.DeclaredTypeFromCLRName : DeclaredTypeBase {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private IPsiModule myModule;
    [NotNullAttribute]
private IClrTypeName myCLRName;
    private static Key`1<Tuple`2<int, ISymbolScope>> ourCachedSymbolScopeNoRetargeting;
    [DebuggerBrowsableAttribute("0")]
public IPsiModule Module { get; }
    public TypeDecorationSet TypeDecorations { get; }
    public TypeClassification Classify { get; }
    protected internal DeclaredTypeFromCLRName(IClrTypeName clrName, IPsiModule module);
    private static DeclaredTypeFromCLRName();
    public virtual IPsiModule get_Module();
    public virtual TypeDecorationSet get_TypeDecorations();
    public virtual IPsiServices GetPsiServices();
    public virtual IClrTypeName GetClrName();
    protected virtual ITypeElement GetTypeElement(IModuleReferenceResolveContext resolveContext);
    protected virtual ISymbolScope GetSymbolScope(IModuleReferenceResolveContext resolveContext);
    public virtual TypeClassification get_Classify();
    protected virtual ITypeElement GetTypeElementNoRetargeting();
    protected virtual IResolveResult Resolve(IModuleReferenceResolveContext resolveContext);
    protected virtual IResolveResult ResolveNoRetargeting();
    protected virtual ITypeElement ChooseBestCandidate(ICollection`1<ITypeElement> candidates);
    protected virtual RichText GetUnresolvedPresentation(NullableAnnotation nullableAnnotation, ITypePresenter presenter, TypePresentationStyle typePresentationStyle);
    public virtual bool Equals(object obj);
}
internal class JetBrains.ReSharper.Psi.Impl.Types.DeclaredTypeFromCLRNameWithModuleContext : DeclaredTypeFromCLRName {
    protected internal DeclaredTypeFromCLRNameWithModuleContext(IClrTypeName clrName, IPsiModule module);
    protected virtual ISymbolScope GetSymbolScope(IModuleReferenceResolveContext resolveContext);
}
public class JetBrains.ReSharper.Psi.Impl.Types.DeclaredTypeFromTypeElement : DeclaredTypeBase {
    [CompilerGeneratedAttribute]
private ITypeElement <TypeElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubstitution <Substitution>k__BackingField;
    [NotNullAttribute]
public ITypeElement TypeElement { get; }
    [NotNullAttribute]
public ISubstitution Substitution { get; }
    [DebuggerBrowsableAttribute("0")]
public IPsiModule Module { get; }
    public TypeDecorationSet TypeDecorations { get; }
    public DeclaredTypeFromTypeElement(ITypeElement typeElement, ISubstitution substitution);
    [CompilerGeneratedAttribute]
public ITypeElement get_TypeElement();
    [CompilerGeneratedAttribute]
public ISubstitution get_Substitution();
    public virtual IPsiModule get_Module();
    public virtual TypeDecorationSet get_TypeDecorations();
    public virtual IPsiServices GetPsiServices();
    protected virtual IResolveResult Resolve(IModuleReferenceResolveContext resolveContext);
    protected virtual IResolveResult ResolveNoRetargeting();
    protected virtual ITypeElement GetTypeElement(IModuleReferenceResolveContext resolveContext);
    protected virtual ITypeElement GetTypeElementNoRetargeting();
    public virtual bool IsValid();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private static void AssertValidSubstitution(ITypeElement typeElement, ISubstitution substitution);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class JetBrains.ReSharper.Psi.Impl.Types.FunctionPointerType : object {
    [CompilerGeneratedAttribute]
private IType <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferenceKind <ReturnKind>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<FunctionPointerParameter> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private CallingConvention <CallingConvention>k__BackingField;
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public IReadOnlyList`1<FunctionPointerParameter> Parameters { get; }
    public CallingConvention CallingConvention { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public bool IsOpenType { get; }
    public TypeClassification Classify { get; }
    public IPsiModule Module { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public TypeDecorationSet TypeDecorations { get; }
    internal FunctionPointerType(IType returnType, ReferenceKind returnKind, IReadOnlyList`1<FunctionPointerParameter> parameters, CallingConvention callingConvention);
    [CompilerGeneratedAttribute]
public sealed virtual IType get_ReturnType();
    [CompilerGeneratedAttribute]
public sealed virtual ReferenceKind get_ReturnKind();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<FunctionPointerParameter> get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsWellFormed(ITypeConstraintsVerifier typeConstraintsVerifier);
    public sealed virtual ITypePointer CreatePointer();
    [DebuggerStepThroughAttribute]
public sealed virtual IType ToIType();
    public sealed virtual bool IsImplicitlyConvertibleTo(IType anotherType, ITypeConversionRule conversionRule);
    public sealed virtual bool IsExplicitlyConvertibleTo(IType anotherType, ITypeConversionRule conversionRule);
    public sealed virtual void Accept(TypeVisitor typeVisitor);
    public sealed virtual TResult Accept(TypeVisitor`2<TContext, TResult> typeVisitor, TContext context);
    private static void AcceptInternal(IFunctionPointerType functionPointerType, TypeVisitor typeVisitor);
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual IDeclaredType GetScalarType();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IType type, IEqualityComparer`1<IType> childrenComparer);
    public virtual int GetHashCode();
    public sealed virtual ISymbolTable GetSymbolTable(IPsiModule module);
    [PureAttribute]
private bool ForAllTypes(Func`2<IType, bool> predicate);
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual bool IsValid();
    public virtual string ToString();
    private string get_DebuggerDisplay();
    public sealed virtual bool get_IsOpenType();
    public sealed virtual TypeClassification get_Classify();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    public sealed virtual TypeDecorationSet get_TypeDecorations();
    public sealed virtual IFunctionPointerType WithTypeDecorations(TypeDecorationSet typeDecorations);
    private sealed virtual override IType JetBrains.ReSharper.Psi.IType.WithTypeDecorations(TypeDecorationSet typeDecorations);
    public sealed virtual IFunctionPointerType WithNullableAnnotation(NullableAnnotation nullableAnnotation);
    private sealed virtual override IType JetBrains.ReSharper.Psi.IType.WithNullableAnnotation(NullableAnnotation nullableAnnotation);
    public sealed virtual IType MergeNullability(IType otherType, TypeParameterVariance variance);
    [CompilerGeneratedAttribute]
internal static IType <MergeNullability>g__Merge|51_0(IType type, IType other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.Impl.Types.Input : ValueType {
    public IModuleReferenceResolveContext ReferenceResolveContext;
    public IClrTypeName ClrTypeName;
    public IPsiModule PsiModule;
    private int myHashCode;
    public Input(IModuleReferenceResolveContext referenceResolveContext, IPsiModule psiModule, IClrTypeName clrTypeName);
    public sealed virtual bool Equals(Input other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface JetBrains.ReSharper.Psi.Impl.Types.ISimplifiedIdTypeInfo {
    [CanBeNullAttribute]
public abstract virtual string GetShortName();
    [CanBeNullAttribute]
public abstract virtual IType[] GetTypeArguments();
}
internal class JetBrains.ReSharper.Psi.Impl.Types.MembersBucket : object {
    [CompilerGeneratedAttribute]
private IList`1<IMethod> <Methods>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IProperty> <Properties>k__BackingField;
    public IList`1<IMethod> Methods { get; }
    public IList`1<IProperty> Properties { get; }
    public MembersBucket(IList`1<IMethod> methods, IList`1<IProperty> properties);
    [CompilerGeneratedAttribute]
public IList`1<IMethod> get_Methods();
    [CompilerGeneratedAttribute]
public IList`1<IProperty> get_Properties();
}
internal class JetBrains.ReSharper.Psi.Impl.Types.NativeNumericTypeElement : object {
    [NotNullAttribute]
private IStruct myUnderlyingTypeElement;
    [NotNullAttribute]
private PredefinedType myPredefinedType;
    [NotNullAttribute]
private IParametrizedCachedValue`2<MembersBucket, NativeNumericTypeElement> myMembersBucket;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [NotNullAttribute]
private static String[] ourMemberNames;
    public IDeclaredElement UnderlyingDeclaredElement { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public ITypeElement ContainingType { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public IList`1<ITypeElement> NestedTypes { get; }
    public IEnumerable`1<IConstructor> Constructors { get; }
    public IEnumerable`1<IOperator> Operators { get; }
    public IEnumerable`1<IMethod> Methods { get; }
    public IEnumerable`1<IProperty> Properties { get; }
    public IEnumerable`1<IEvent> Events { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public string XMLDocId { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public MemberHidePolicy HidePolicy { get; }
    public IEnumerable`1<IField> Constants { get; }
    public IEnumerable`1<IField> Fields { get; }
    public bool HasHiddenInstanceFields { get; }
    public bool HasCustomParameterlessConstructor { get; }
    public bool IsByRefLike { get; }
    internal NativeNumericTypeElement(string shortName, IStruct underlyingTypeElement);
    private static NativeNumericTypeElement();
    private static MembersBucket LoadMembers(NativeNumericTypeElement nativeNumericTypeElement);
    public sealed virtual IDeclaredElement get_UnderlyingDeclaredElement();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IPsiModule get_Module();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual ITypeElement get_ContainingType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual IClrTypeName GetClrName();
    public sealed virtual IList`1<IDeclaredType> GetSuperTypes();
    public sealed virtual IList`1<ITypeElement> GetSuperTypeElements();
    public sealed virtual IList`1<ITypeElement> get_NestedTypes();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.Types.NativeNumericTypeElement/<GetMembers>d__44")]
public sealed virtual IEnumerable`1<ITypeMember> GetMembers();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.Types.NativeNumericTypeElement/<get_Constructors>d__46")]
public sealed virtual IEnumerable`1<IConstructor> get_Constructors();
    public sealed virtual IEnumerable`1<IOperator> get_Operators();
    public sealed virtual IEnumerable`1<IMethod> get_Methods();
    public sealed virtual IEnumerable`1<IProperty> get_Properties();
    public sealed virtual IEnumerable`1<IEvent> get_Events();
    public sealed virtual MemberPresenceFlag GetMemberPresenceFlag();
    public sealed virtual INamespace GetContainingNamespace();
    public sealed virtual bool HasMemberWithName(string shortName, bool ignoreCase);
    public sealed virtual IEnumerable`1<string> get_MemberNames();
    public sealed virtual IPsiSourceFile GetSingleOrDefaultSourceFile();
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual string get_XMLDocId();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual Nullable`1<Hash> CalcHash();
    public sealed virtual IEnumerable`1<IField> get_Constants();
    public sealed virtual IEnumerable`1<IField> get_Fields();
    public sealed virtual bool get_HasHiddenInstanceFields();
    public sealed virtual bool get_HasCustomParameterlessConstructor();
    public sealed virtual bool get_IsByRefLike();
    internal IType SubstituteNativeIntegers(IType type);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class JetBrains.ReSharper.Psi.Impl.Types.PointerType : object {
    [CompilerGeneratedAttribute]
private IType <ElementType>k__BackingField;
    public IType ElementType { get; }
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    public bool IsOpenType { get; }
    public TypeClassification Classify { get; }
    public IPsiModule Module { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public TypeDecorationSet TypeDecorations { get; }
    internal PointerType(IType type);
    [CompilerGeneratedAttribute]
public sealed virtual IType get_ElementType();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsWellFormed(ITypeConstraintsVerifier typeConstraintsVerifier);
    public sealed virtual ITypePointer CreatePointer();
    public sealed virtual bool IsExplicitlyConvertibleTo(IType anotherType, ITypeConversionRule conversionRule);
    [DebuggerStepThroughAttribute]
public sealed virtual IType ToIType();
    public sealed virtual bool IsImplicitlyConvertibleTo(IType anotherType, ITypeConversionRule conversionRule);
    public sealed virtual void Accept(TypeVisitor typeVisitor);
    public sealed virtual TResult Accept(TypeVisitor`2<TContext, TResult> typeVisitor, TContext context);
    private static void AcceptInternal(IPointerType pointerType, TypeVisitor typeVisitor);
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual IDeclaredType GetScalarType();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(IType type, IEqualityComparer`1<IType> childrenComparer);
    public virtual int GetHashCode();
    public sealed virtual ISymbolTable GetSymbolTable(IPsiModule module);
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual bool IsValid();
    public virtual string ToString();
    private string get_DebuggerDisplay();
    public sealed virtual bool get_IsOpenType();
    public sealed virtual TypeClassification get_Classify();
    public sealed virtual IPsiModule get_Module();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    public sealed virtual TypeDecorationSet get_TypeDecorations();
    public sealed virtual IPointerType WithNullableAnnotation(NullableAnnotation nullableAnnotation);
    private sealed virtual override IType JetBrains.ReSharper.Psi.IType.WithNullableAnnotation(NullableAnnotation nullableAnnotation);
    public sealed virtual IPointerType WithTypeDecorations(TypeDecorationSet typeDecorations);
    private sealed virtual override IType JetBrains.ReSharper.Psi.IType.WithTypeDecorations(TypeDecorationSet typeDecorations);
    public sealed virtual IType MergeNullability(IType otherType, TypeParameterVariance variance);
}
public abstract class JetBrains.ReSharper.Psi.Impl.Types.TupleExpressionTypeBase : object {
    [NotNullAttribute]
private TupleExpressionTypeComponent[] myComponent;
    private bool myNoIType;
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public IPsiModule Module { get; }
    public IReadOnlyList`1<TupleExpressionTypeComponent> Components { get; }
    private IEnumerable`1<IExpressionType> JetBrains.ReSharper.Psi.ITargetTypedExpressionType.NestedTypes { get; }
    public bool IsNonCacheable { get; }
    protected TupleExpressionTypeBase(IPsiModule module, TupleExpressionTypeComponent[] component);
    [CanBeNullAttribute]
protected virtual IType GetIType(IExpressionType type);
    public sealed virtual IType ToIType();
    public sealed virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsValid();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_Module();
    public sealed virtual IReadOnlyList`1<TupleExpressionTypeComponent> get_Components();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Impl.Types.TupleExpressionTypeBase/<JetBrains-ReSharper-Psi-ITargetTypedExpressionType-get_NestedTypes>d__18")]
private sealed virtual override IEnumerable`1<IExpressionType> JetBrains.ReSharper.Psi.ITargetTypedExpressionType.get_NestedTypes();
    public sealed virtual bool get_IsNonCacheable();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Impl.Types.TupleExpressionTypeComponent : ValueType {
    [CompilerGeneratedAttribute]
private IExpressionType <ExpressionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExplicitName>k__BackingField;
    [NotNullAttribute]
public IExpressionType ExpressionType { get; }
    [CanBeNullAttribute]
public string ExplicitName { get; }
    public TupleExpressionTypeComponent(IExpressionType expressionType, string explicitName);
    [CompilerGeneratedAttribute]
public IExpressionType get_ExpressionType();
    [CompilerGeneratedAttribute]
public string get_ExplicitName();
}
internal class JetBrains.ReSharper.Psi.Impl.Types.UninferredType : UnknownTypeBase {
    [NotNullAttribute]
private ITypeParameter myTypeParameter;
    internal UninferredType(ITypeParameter typeParameter);
    public virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public virtual ITypePointer CreatePointer();
    public virtual bool IsValid();
    public virtual ITypeElement GetTypeElement();
    public virtual IResolveResult Resolve();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual bool Equals(IType type, IEqualityComparer`1<IType> childrenComparer);
    public virtual int GetHashCode();
}
internal class JetBrains.ReSharper.Psi.Impl.Types.UnknownType : UnknownTypeBase {
    internal UnknownType(IPsiModule module);
    public virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public virtual ITypePointer CreatePointer();
    public virtual bool IsValid();
    public virtual bool Equals(object obj);
    public virtual bool Equals(IType type, IEqualityComparer`1<IType> childrenComparer);
    public virtual int GetHashCode();
}
internal abstract class JetBrains.ReSharper.Psi.Impl.Types.UnknownTypeBase : object {
    [NotNullAttribute]
private IPsiModule myModule;
    public bool IsResolved { get; }
    public bool IsUnknown { get; }
    public bool IsOpenType { get; }
    public TypeClassification Classify { get; }
    public IPsiModule Module { get; }
    public TypeDecorationSet TypeDecorations { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public AssemblyNameInfo Assembly { get; }
    private IPsiModule JetBrains.ReSharper.Psi.ITypePointer.PsiModule { get; }
    internal UnknownTypeBase(IPsiModule module);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual bool IsExplicitlyConvertibleTo(IType type, ITypeConversionRule conversionRule);
    [DebuggerStepThroughAttribute]
[NotNullAttribute]
public sealed virtual IType ToIType();
    public abstract virtual bool IsValid();
    public abstract virtual RichText GetPresentableName(PsiLanguageType languageType, TypePresentationStyle typePresentationStyle);
    public abstract virtual ITypePointer CreatePointer();
    public abstract virtual bool Equals(IType type, IEqualityComparer`1<IType> childrenComparer);
    public sealed virtual bool IsImplicitlyConvertibleTo(IType type, ITypeConversionRule conversionRule);
    public sealed virtual void Accept(TypeVisitor typeVisitor);
    public sealed virtual TResult Accept(TypeVisitor`2<TContext, TResult> typeVisitor, TContext context);
    [NotNullAttribute]
public sealed virtual IDeclaredType GetScalarType();
    public sealed virtual ISymbolTable GetSymbolTable(IPsiModule module);
    public sealed virtual bool get_IsResolved();
    public sealed virtual bool get_IsUnknown();
    public sealed virtual bool get_IsOpenType();
    public sealed virtual TypeClassification get_Classify();
    public sealed virtual bool IsWellFormed(ITypeConstraintsVerifier typeConstraintsVerifier);
    public sealed virtual IPsiModule get_Module();
    public sealed virtual TypeDecorationSet get_TypeDecorations();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    public sealed virtual IDeclaredType WithTypeDecorations(TypeDecorationSet typeDecorations);
    private sealed virtual override IType JetBrains.ReSharper.Psi.IType.WithTypeDecorations(TypeDecorationSet typeDecorationSet);
    public sealed virtual IDeclaredType WithNullableAnnotation(NullableAnnotation nullableAnnotation);
    private sealed virtual override IType JetBrains.ReSharper.Psi.IType.WithNullableAnnotation(NullableAnnotation annotation);
    public sealed virtual IType MergeNullability(IType otherType, TypeParameterVariance variance);
    public virtual ITypeElement GetTypeElement();
    public virtual IResolveResult Resolve();
    public sealed virtual IClrTypeName GetClrName();
    public sealed virtual bool IsSubtypeOf(IDeclaredType to, ITypeConversionRule typeConversionRule);
    public sealed virtual AssemblyNameInfo get_Assembly();
    public sealed virtual IDeclaredType Retarget(IPsiModule psiModule);
    private sealed virtual override IType JetBrains.ReSharper.Psi.ITypePointer.FindType();
    private sealed virtual override IPsiModule JetBrains.ReSharper.Psi.ITypePointer.get_PsiModule();
}
internal class JetBrains.ReSharper.Psi.Impl.Types.WrappedAccessor : WrappedMethod {
    [NotNullAttribute]
private IAccessor myUnderlyingAccessor;
    [NotNullAttribute]
private NativeNumericTypeElement myContainingTypeElement;
    [CompilerGeneratedAttribute]
private IOverridableMember <OwnerMember>k__BackingField;
    public IOverridableMember OwnerMember { get; }
    public AccessorKind Kind { get; }
    public bool IsAuto { get; }
    public bool IsInitOnly { get; }
    public IParameter ValueVariable { get; }
    public WrappedAccessor(IAccessor underlyingAccessor, IOverridableMember ownerProperty, NativeNumericTypeElement containingTypeElement);
    [CompilerGeneratedAttribute]
public sealed virtual IOverridableMember get_OwnerMember();
    public sealed virtual AccessorKind get_Kind();
    public sealed virtual bool get_IsAuto();
    public sealed virtual bool get_IsInitOnly();
    public sealed virtual IParameter get_ValueVariable();
}
internal class JetBrains.ReSharper.Psi.Impl.Types.WrappedMethod : WrappedOverridableMember {
    [NotNullAttribute]
private IMethod myUnderlyingMethod;
    [NotNullAttribute]
private NativeNumericTypeElement myContainingTypeElement;
    [CompilerGeneratedAttribute]
private IList`1<IParameter> <Parameters>k__BackingField;
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public IAttributesSet ReturnTypeAttributes { get; }
    public bool IsPredefined { get; }
    public bool IsIterator { get; }
    public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public bool IsExtensionMethod { get; }
    public bool IsAsync { get; }
    public bool IsVarArg { get; }
    public ISubstitution IdSubstitution { get; }
    public WrappedMethod(IMethod underlyingMethod, NativeNumericTypeElement containingTypeElement);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual IAttributesSet get_ReturnTypeAttributes();
    public sealed virtual bool get_IsPredefined();
    public sealed virtual bool get_IsIterator();
    public sealed virtual IList`1<ITypeParameter> get_TypeParameters();
    public sealed virtual int get_TypeParametersCount();
    public sealed virtual bool get_IsExtensionMethod();
    public sealed virtual bool get_IsAsync();
    public sealed virtual bool get_IsVarArg();
    public virtual ISubstitution get_IdSubstitution();
}
internal abstract class JetBrains.ReSharper.Psi.Impl.Types.WrappedOverridableMember : object {
    [NotNullAttribute]
private IOverridableMember myUnderlyingOverridableMember;
    [NotNullAttribute]
private ITypeElement myContainingTypeElement;
    public ITypeElement ContainingType { get; }
    public IDeclaredElement UnderlyingDeclaredElement { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsStatic { get; }
    public bool IsReadonly { get; }
    public bool IsExtern { get; }
    public bool IsUnsafe { get; }
    public bool IsVolatile { get; }
    public string XMLDocId { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public MemberHidePolicy HidePolicy { get; }
    public bool IsExplicitImplementation { get; }
    public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    public bool CanBeImplicitImplementation { get; }
    protected WrappedOverridableMember(IOverridableMember underlyingOverridableMember, ITypeElement containingTypeElement);
    public sealed virtual ITypeElement get_ContainingType();
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual IDeclaredElement get_UnderlyingDeclaredElement();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual IPsiModule get_Module();
    public abstract virtual ISubstitution get_IdSubstitution();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual AccessRights GetAccessRights();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsReadonly();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsUnsafe();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual string get_XMLDocId();
    public sealed virtual AccessibilityDomain get_AccessibilityDomain();
    public sealed virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public sealed virtual MemberHidePolicy get_HidePolicy();
    public sealed virtual Nullable`1<Hash> CalcHash();
    public sealed virtual bool get_IsExplicitImplementation();
    public sealed virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    public sealed virtual bool get_CanBeImplicitImplementation();
}
internal class JetBrains.ReSharper.Psi.Impl.Types.WrappedParameter : object {
    [NotNullAttribute]
private IParameter myUnderlyingParameter;
    [NotNullAttribute]
private NativeNumericTypeElement myContainingTypeElement;
    [CompilerGeneratedAttribute]
private IParametersOwner <ContainingParametersOwner>k__BackingField;
    public IType Type { get; }
    public IParametersOwner ContainingParametersOwner { get; }
    public IDeclaredElement UnderlyingDeclaredElement { get; }
    public string ShortName { get; }
    public bool CaseSensitiveName { get; }
    public PsiLanguageType PresentationLanguage { get; }
    public IPsiModule Module { get; }
    public ISubstitution IdSubstitution { get; }
    public ParameterKind Kind { get; }
    public bool IsParams { get; }
    public bool IsParameterArray { get; }
    public bool IsParameterCollection { get; }
    public bool IsValueVariable { get; }
    public bool IsOptional { get; }
    public bool IsVarArg { get; }
    public ScopedKind Scope { get; }
    public WrappedParameter(IParameter underlyingParameter, IParametersOwner parametersOwner, NativeNumericTypeElement containingTypeElement);
    public sealed virtual ITypeElement GetContainingType();
    public sealed virtual ITypeMember GetContainingTypeMember();
    public sealed virtual IType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual IParametersOwner get_ContainingParametersOwner();
    public sealed virtual IDeclaredElement get_UnderlyingDeclaredElement();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual string get_ShortName();
    public sealed virtual bool get_CaseSensitiveName();
    public sealed virtual PsiLanguageType get_PresentationLanguage();
    public sealed virtual DeclaredElementType GetElementType();
    public sealed virtual bool IsValid();
    public sealed virtual bool IsSynthetic();
    public sealed virtual IList`1<IDeclaration> GetDeclarations();
    public sealed virtual IList`1<IDeclaration> GetDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual HybridCollection`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual bool HasDeclarationsIn(IPsiSourceFile sourceFile);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual XmlNode GetXMLDoc(bool inherit);
    public sealed virtual XmlNode GetXMLDescriptionSummary(bool inherit);
    public sealed virtual IPsiModule get_Module();
    public sealed virtual ISubstitution get_IdSubstitution();
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(AttributesSource attributesSource);
    public sealed virtual IList`1<IAttributeInstance> GetAttributeInstances(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual bool HasAttributeInstance(IClrTypeName clrName, AttributesSource attributesSource);
    public sealed virtual ParameterKind get_Kind();
    public sealed virtual bool get_IsParams();
    public sealed virtual bool get_IsParameterArray();
    public sealed virtual bool get_IsParameterCollection();
    public sealed virtual bool get_IsValueVariable();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_IsVarArg();
    public sealed virtual ScopedKind get_Scope();
    public sealed virtual DefaultValue GetDefaultValue();
}
internal class JetBrains.ReSharper.Psi.Impl.Types.WrappedProperty : WrappedOverridableMember {
    [NotNullAttribute]
private IProperty myUnderlyingProperty;
    [NotNullAttribute]
private NativeNumericTypeElement myContainingTypeElement;
    [CompilerGeneratedAttribute]
private IAccessor <Getter>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccessor <Setter>k__BackingField;
    public IType Type { get; }
    public IAccessor Getter { get; }
    public IAccessor Setter { get; }
    public ISubstitution IdSubstitution { get; }
    public IList`1<IParameter> Parameters { get; }
    public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public bool IsReadable { get; }
    public bool IsWritable { get; }
    public bool IsAuto { get; }
    public bool IsDefault { get; }
    public bool IsRequired { get; }
    public WrappedProperty(IProperty underlyingProperty, NativeNumericTypeElement containingTypeElement);
    public sealed virtual IType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual IAccessor get_Getter();
    [CompilerGeneratedAttribute]
public sealed virtual IAccessor get_Setter();
    public virtual ISubstitution get_IdSubstitution();
    public sealed virtual IList`1<IParameter> get_Parameters();
    public sealed virtual IType get_ReturnType();
    public sealed virtual ReferenceKind get_ReturnKind();
    public sealed virtual InvocableSignature GetSignature(ISubstitution substitution);
    public sealed virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
    public sealed virtual bool get_IsReadable();
    public sealed virtual bool get_IsWritable();
    public sealed virtual bool get_IsAuto();
    public sealed virtual bool get_IsDefault();
    public sealed virtual bool get_IsRequired();
    public sealed virtual string GetDefaultPropertyMetadataName();
}
[SettingsIndexedKeyAttribute("JetBrains.Application.Settings.WellKnownRootKeys.EnvironmentSettings", "JetBrains.ReSharper.Psi.Resources.Strings", "AutoImportSettingsSettingDescription", "System.String")]
public class JetBrains.ReSharper.Psi.ImportType.AutoImport2Settings : object {
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "BlockListMaskSettingDescription")]
public IIndexedEntry`2<string, bool> BlackLists;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "FullyQualifiedImportsSettingDescription")]
public IIndexedEntry`2<string, bool> FullyQualifiedImports;
}
public class JetBrains.ReSharper.Psi.ImportType.ClrImportTypeFilter : object {
    [NotNullAttribute]
private List`1<Predicate`1<string>> myMasks;
    public static Regex Pattern;
    public ClrImportTypeFilter(IEnumerable`1<string> patterns);
    private static ClrImportTypeFilter();
    public sealed virtual bool Contains(IDeclaredElement element);
    private bool DoMatch(string qualifiedName);
    private static string GetQualifiedName(ITypeMember typeElement);
    private static Predicate`1<string> CreatePredicate(string value);
}
public interface JetBrains.ReSharper.Psi.ImportType.IImportTypeFilter {
    [PureAttribute]
public abstract virtual bool Contains(IDeclaredElement element);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.ImportType.IImportTypeFilteringCachedSettings {
    public abstract virtual ImportTypeFiltering TryGetImportFiltering(PsiLanguageType languageType, ISolution solution);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.ImportType.ImportFilteringUtil : object {
    private static Key`1<IImportTypeFilteringCachedSettings> ourImportFilteringKey;
    private static ImportFilteringUtil();
    [PureAttribute]
public static Func`2<IDeclaredElement, bool> GetImportFilteringPredicate(ITreeNode context);
    public static bool ShouldPreferFullQualification(IDeclaredElement declaredElement, ITreeNode context);
    private static IImportTypeFilteringCachedSettings GetImportFilteringSettings(ITreeNode context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ImportType.ImportTypeFiltering : object {
    [CompilerGeneratedAttribute]
private IImportTypeFilter <ExcludedFromImport>k__BackingField;
    [CompilerGeneratedAttribute]
private IImportTypeFilter <FullyQualifiedImports>k__BackingField;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public IImportTypeFilter ExcludedFromImport { get; public set; }
    public IImportTypeFilter FullyQualifiedImports { get; public set; }
    public ImportTypeFiltering(IImportTypeFilter ExcludedFromImport, IImportTypeFilter FullyQualifiedImports);
    [CompilerGeneratedAttribute]
private ImportTypeFiltering(ImportTypeFiltering original);
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IImportTypeFilter get_ExcludedFromImport();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExcludedFromImport(IImportTypeFilter value);
    [CompilerGeneratedAttribute]
public IImportTypeFilter get_FullyQualifiedImports();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FullyQualifiedImports(IImportTypeFilter value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ImportTypeFiltering left, ImportTypeFiltering right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ImportTypeFiltering left, ImportTypeFiltering right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ImportTypeFiltering other);
    [CompilerGeneratedAttribute]
public ImportTypeFiltering <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(IImportTypeFilter& ExcludedFromImport, IImportTypeFilter& FullyQualifiedImports);
}
public interface JetBrains.ReSharper.Psi.IMultitype {
    [NotNullAttribute]
public IEnumerable`1<IType> Constituents { get; }
    public abstract virtual IEnumerable`1<IType> get_Constituents();
}
public interface JetBrains.ReSharper.Psi.INamedTupleComponent {
    public int Index { get; }
    [NotNullAttribute]
public IType Type { get; }
    public DecoratedType`1<TupleTypeDecoration> ContainingType { get; }
    [NotNullAttribute]
public IField UnderlyingField { get; }
    public abstract virtual int get_Index();
    public abstract virtual IType get_Type();
    public abstract virtual DecoratedType`1<TupleTypeDecoration> get_ContainingType();
    public abstract virtual IField get_UnderlyingField();
    [NotNullAttribute]
public abstract virtual IDeclaredElementPointer`1<INamedTupleComponent> CreateElementPointer();
}
public interface JetBrains.ReSharper.Psi.INamespace {
    public string QualifiedName { get; }
    public bool IsRootNamespace { get; }
    public bool HasNonSourceMembers { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IPsiModule> Modules { get; }
    public abstract virtual string get_QualifiedName();
    public abstract virtual bool get_IsRootNamespace();
    public abstract virtual bool get_HasNonSourceMembers();
    [NotNullAttribute]
public abstract virtual ICollection`1<INamespace> GetNestedNamespaces(ISymbolScope cache);
    [CanBeNullAttribute]
public abstract virtual INamespace GetNestedNamespace(ISymbolScope cache, string name);
    [NotNullAttribute]
public abstract virtual ICollection`1<ITypeElement> GetNestedTypeElements(ISymbolScope cache);
    [NotNullAttribute]
public abstract virtual ICollection`1<ITypeElement> GetNestedTypeElements(ISymbolScope cache, string name, bool caseSensitive);
    [NotNullAttribute]
public abstract virtual ICollection`1<IClrDeclaredElement> GetNestedElements(ISymbolScope cache);
    [NotNullAttribute]
public abstract virtual ICollection`1<IClrDeclaredElement> GetNestedElements(ISymbolScope cache, string name, bool caseSensitive);
    public abstract virtual bool ForAllNestedElements(ISymbolScope symbolScope, TState state, Func`3<TState, IClrDeclaredElement, bool> processor);
    public abstract virtual bool ForAllNestedElements(ISymbolScope symbolScope, string shortName, bool caseSensitive, TState state, Func`3<TState, IClrDeclaredElement, bool> processor);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual INamespace GetContainingNamespace();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ICaseInsensitiveNamespace GetCaseInsensitiveNamespace();
    public abstract virtual bool IsEmptyNamespace(ISymbolScope cache);
    public abstract virtual IEnumerable`1<IPsiModule> get_Modules();
}
public interface JetBrains.ReSharper.Psi.INativeNumericTypeElement {
}
[ZoneDefinitionAttribute]
public interface JetBrains.ReSharper.Psi.INativePsiLanguageZone {
}
public interface JetBrains.ReSharper.Psi.INavigatableDeclaredElement {
    public abstract virtual Pair`2<VirtualFileSystemPath, TextRange> GetNavigationLocation();
}
public interface JetBrains.ReSharper.Psi.INavigateablePsiSourceFile {
    [NotNullAttribute]
public VirtualFileSystemPath NavigationPath { get; }
    public abstract virtual VirtualFileSystemPath get_NavigationPath();
}
public interface JetBrains.ReSharper.Psi.INonCacheableExpressionType {
    public bool IsNonCacheable { get; }
    public abstract virtual bool get_IsNonCacheable();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.InterfaceEx : object {
    [ExtensionAttribute]
public static bool CanBeInstantiated(IInterface interface);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.Internal.IPsiDiagnosticInfoProvider {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual IEnumerable`1<ValueTuple`2<string, object>> GetDiagnosticInfo(IFile file);
}
public class JetBrains.ReSharper.Psi.InvocableSignature : object {
    [NotNullAttribute]
private IList`1<IParameter> myParameters;
    [NotNullAttribute]
private ISignatureComparer mySignatureComparer;
    [NotNullAttribute]
[ItemCanBeNullAttribute]
private IType[] myComputedCachedParameterTypes;
    [NotNullAttribute]
[ItemCanBeNullAttribute]
private IType[] myComputedEqualityParameterTypes;
    [NotNullAttribute]
public static InvocableSignature Null;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubstitution <Substitution>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubstitution <EqualitySubstitution>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <ConversionOperatorReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ITypeParameter> <TypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStaticConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefaultProperty>k__BackingField;
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public ISubstitution Substitution { get; }
    public int ParametersCount { get; }
    [NotNullAttribute]
public ISubstitution EqualitySubstitution { get; }
    [CanBeNullAttribute]
public IType ConversionOperatorReturnType { get; }
    [NotNullAttribute]
public IList`1<ITypeParameter> TypeParameters { get; }
    public bool IsStaticConstructor { get; }
    public bool IsDefaultProperty { get; }
    public bool IsResolved { get; }
    public InvocableSignature(IParametersOwner parametersOwner, ISubstitution substitution, ISignatureComparer signatureComparer);
    public InvocableSignature(IParametersOwner parametersOwner, ISubstitution substitution, IList`1<IParameter> parameters, ISignatureComparer signatureComparer);
    private static InvocableSignature();
    [CanBeNullAttribute]
[PureAttribute]
public static InvocableSignature FromExtensionMethodReducedForm(IMethod extensionMethod, ISubstitution substitution, ISignatureComparer signatureComparer);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ISubstitution get_Substitution();
    public int get_ParametersCount();
    [CompilerGeneratedAttribute]
public ISubstitution get_EqualitySubstitution();
    [CompilerGeneratedAttribute]
public IType get_ConversionOperatorReturnType();
    [CompilerGeneratedAttribute]
public IList`1<ITypeParameter> get_TypeParameters();
    [CompilerGeneratedAttribute]
public bool get_IsStaticConstructor();
    [CompilerGeneratedAttribute]
public bool get_IsDefaultProperty();
    [NotNullAttribute]
[PureAttribute]
public IType GetParameterType(int index);
    [NotNullAttribute]
[PureAttribute]
public IType GetEqualityParameterType(int index);
    public void ReplaceParameterType(int index, IType type);
    public bool get_IsResolved();
    [NotNullAttribute]
[PureAttribute]
private IParameter GetParameter(int index);
    [PureAttribute]
public ParameterKind GetParameterKind(int index);
    [PureAttribute]
public bool IsOptional(int index);
    [PureAttribute]
public bool IsParams(int index);
    [PureAttribute]
public bool IsVarArg(int index);
    [PureAttribute]
public ScopedKind GetParameterScope(int index);
    [PureAttribute]
public bool GetParameterHasUnscopedRefAttribute(int index, UnscopedRefAnnotationProvider annotationProvider);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool CompareWithoutName(InvocableSignature s1, InvocableSignature s2);
    [PureAttribute]
[NotNullAttribute]
private static ISubstitution BuildEqualitySubstitution(ITypeParametersOwner typeParametersOwner, ISubstitution substitution);
}
public interface JetBrains.ReSharper.Psi.IOperator {
    public bool IsChecked { get; }
    public abstract virtual bool get_IsChecked();
}
public interface JetBrains.ReSharper.Psi.IOverridableMember {
    public bool IsExplicitImplementation { get; }
    [NotNullAttribute]
public IList`1<IExplicitImplementation> ExplicitImplementations { get; }
    public bool CanBeImplicitImplementation { get; }
    public abstract virtual bool get_IsExplicitImplementation();
    public abstract virtual IList`1<IExplicitImplementation> get_ExplicitImplementations();
    public abstract virtual bool get_CanBeImplicitImplementation();
}
public interface JetBrains.ReSharper.Psi.IParameter {
    public ParameterKind Kind { get; }
    public bool IsParams { get; }
    public bool IsParameterArray { get; }
    public bool IsParameterCollection { get; }
    public bool IsValueVariable { get; }
    public bool IsOptional { get; }
    public bool IsVarArg { get; }
    public ScopedKind Scope { get; }
    [CanBeNullAttribute]
public IParametersOwner ContainingParametersOwner { get; }
    public abstract virtual ParameterKind get_Kind();
    public abstract virtual bool get_IsParams();
    public abstract virtual bool get_IsParameterArray();
    public abstract virtual bool get_IsParameterCollection();
    public abstract virtual bool get_IsValueVariable();
    public abstract virtual bool get_IsOptional();
    public abstract virtual bool get_IsVarArg();
    public abstract virtual ScopedKind get_Scope();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual DefaultValue GetDefaultValue();
    public abstract virtual IParametersOwner get_ContainingParametersOwner();
}
public interface JetBrains.ReSharper.Psi.IParametersOwner {
    [NotNullAttribute]
public IList`1<IParameter> Parameters { get; }
    [NotNullAttribute]
public IType ReturnType { get; }
    public ReferenceKind ReturnKind { get; }
    public abstract virtual IList`1<IParameter> get_Parameters();
    public abstract virtual IType get_ReturnType();
    public abstract virtual ReferenceKind get_ReturnKind();
    [NotNullAttribute]
public abstract virtual InvocableSignature GetSignature(ISubstitution substitution);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IParametersOwnerDeclaration> GetParametersOwnerDeclarations();
}
public interface JetBrains.ReSharper.Psi.IParametersOwnerWithAttributes {
    [NotNullAttribute]
public IAttributesSet ReturnTypeAttributes { get; }
    public abstract virtual IAttributesSet get_ReturnTypeAttributes();
}
public interface JetBrains.ReSharper.Psi.IPathDeclaredElement {
    [NotNullAttribute]
public VirtualFileSystemPath Path { get; }
    [NotNullAttribute]
public VirtualFileSystemPath PhysicalPath { get; }
    public bool IsDirectory { get; }
    public abstract virtual VirtualFileSystemPath get_Path();
    public abstract virtual VirtualFileSystemPath get_PhysicalPath();
    [ObsoleteAttribute("Use IPathDeclaredElement.GetProjectItems instead.")]
[CanBeNullAttribute]
public abstract virtual IProjectItem GetProjectItem();
    public abstract virtual HybridCollection`1<IProjectItem> GetProjectItems();
    public abstract virtual bool get_IsDirectory();
}
public interface JetBrains.ReSharper.Psi.IPointerType {
    [NotNullAttribute]
public IType ElementType { get; }
    public abstract virtual IType get_ElementType();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IPointerType WithTypeDecorations(TypeDecorationSet typeDecorations);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IPointerType WithNullableAnnotation(NullableAnnotation nullableAnnotation);
}
public interface JetBrains.ReSharper.Psi.IPredefinedTypeCache {
    [NotNullAttribute]
public abstract virtual PredefinedType GetOrCreatePredefinedType(IPsiModule module);
}
public interface JetBrains.ReSharper.Psi.IProjectFileCustomPsiPropertiesProvider {
    [CanBeNullAttribute]
public abstract virtual T GetCustomProperties(IPsiSourceFile sourceFile);
}
public interface JetBrains.ReSharper.Psi.IProjectFileLanguageService {
    [NotNullAttribute]
public ProjectFileType LanguageType { get; }
    [CanBeNullAttribute]
public IconId Icon { get; }
    public abstract virtual ProjectFileType get_LanguageType();
    public abstract virtual IconId get_Icon();
    [NotNullAttribute]
public abstract virtual PsiLanguageType GetPsiLanguageType(IProjectFile projectFile);
    [NotNullAttribute]
public abstract virtual PsiLanguageType GetPsiLanguageType(IPsiSourceFile sourceFile);
    [CanBeNullAttribute]
public abstract virtual IPsiSourceFileProperties GetPsiProperties(IProjectFile projectFile, IPsiSourceFile sourceFile, IsCompileService isCompileService);
    [ObsoleteAttribute("Use overload that takes source file")]
[NotNullAttribute]
public abstract virtual PsiLanguageType GetPsiLanguageType(ProjectFileType languageType);
    [CanBeNullAttribute]
public abstract virtual ILexerFactory GetMixedLexerFactory(ISolution solution, IBuffer buffer, IPsiSourceFile sourceFile);
    [NotNullAttribute]
public abstract virtual PreProcessingDirective[] GetPreprocessorDefines(IProject project, TargetFrameworkId targetFrameworkId);
}
public interface JetBrains.ReSharper.Psi.IProperty {
    [CanBeNullAttribute]
public IAccessor Getter { get; }
    [CanBeNullAttribute]
public IAccessor Setter { get; }
    public bool IsReadable { get; }
    public bool IsWritable { get; }
    public bool IsAuto { get; }
    public bool IsDefault { get; }
    public bool IsRequired { get; }
    public abstract virtual IAccessor get_Getter();
    public abstract virtual IAccessor get_Setter();
    public abstract virtual bool get_IsReadable();
    public abstract virtual bool get_IsWritable();
    public abstract virtual bool get_IsAuto();
    public abstract virtual bool get_IsDefault();
    public abstract virtual bool get_IsRequired();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual string GetDefaultPropertyMetadataName();
}
public interface JetBrains.ReSharper.Psi.IPsiAssembly {
    [NotNullAttribute]
public IAssemblyPsiModule PsiModule { get; }
    [NotNullAttribute]
public AssemblyNameInfo AssemblyName { get; }
    public AssemblyId Id { get; }
    public bool IsFrameworkAssembly { get; }
    public bool IsRetargetable { get; }
    [CanBeNullAttribute]
public IAssemblyLocation Location { get; }
    public TargetFrameworkId TargetFrameworkId { get; }
    public abstract virtual IAssemblyPsiModule get_PsiModule();
    public abstract virtual AssemblyNameInfo get_AssemblyName();
    public abstract virtual AssemblyId get_Id();
    public abstract virtual bool get_IsFrameworkAssembly();
    public abstract virtual bool get_IsRetargetable();
    public abstract virtual IAssemblyLocation get_Location();
    public abstract virtual bool IsValid();
    public abstract virtual TargetFrameworkId get_TargetFrameworkId();
}
public interface JetBrains.ReSharper.Psi.IPsiCleanupProvider {
    public abstract virtual void Run();
}
public interface JetBrains.ReSharper.Psi.IPsiConfiguration {
    public bool EagerMetadataLoad { get; }
    public bool FullMetadataLoad { get; }
    public bool PersistCaches { get; }
    public bool CacheJobServiceSynchronous { get; }
    [NotNullAttribute]
public ISolutionCaches SolutionCaches { get; }
    [NotNullAttribute]
public ShellCaches ShellCaches { get; }
    [NotNullAttribute]
public ISolution Solution { get; }
    [NotNullAttribute]
public DocumentLineEndingsDetector LineEndingsDetector { get; }
    public abstract virtual bool get_EagerMetadataLoad();
    public abstract virtual bool get_FullMetadataLoad();
    public abstract virtual bool get_PersistCaches();
    public abstract virtual bool get_CacheJobServiceSynchronous();
    public abstract virtual ISolutionCaches get_SolutionCaches();
    public abstract virtual ShellCaches get_ShellCaches();
    public abstract virtual ISolution get_Solution();
    public abstract virtual DocumentLineEndingsDetector get_LineEndingsDetector();
}
[ZoneDefinitionAttribute]
public interface JetBrains.ReSharper.Psi.IPsiLanguageZone {
}
public interface JetBrains.ReSharper.Psi.IPsiProjectFile {
    [NotNullAttribute]
public IProjectFile ProjectFile { get; }
    public abstract virtual IProjectFile get_ProjectFile();
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.IPsiServices {
    public ISolution Solution { get; }
    public IShellLocks Locks { get; }
    public ILanguageManager LanguageManager { get; }
    public DependencyStore DependencyStore { get; }
    public IGeneratedDocumentsManager GeneratedDocumentsManager { get; }
    public SearchDomainFactory SearchDomainFactory { get; }
    public IFinder Finder { get; }
    public IFinder ParallelFinder { get; }
    [CodeTemplateAttribute("$expr{Expression,'JetBrains.ReSharper.Psi.IPsiServices'}$.AsyncFinder")]
public IFinder AsyncFinder { get; }
    public NamingManager Naming { get; }
    public ISettingsStore SettingsStore { get; }
    public ISymbolCache Symbols { get; }
    public IWordIndex WordIndex { get; }
    public StubTreeNodeCache StubTreeNodes { get; }
    public IPsiConfiguration Configuration { get; }
    public IPsiFiles Files { get; }
    public IPsiPointers Pointers { get; }
    public IPsiCaches Caches { get; }
    public IPsiCachesState CachesState { get; }
    public IPersistentIndexManager PersistentIndex { get; }
    public IPsiTransactions Transactions { get; }
    public IPsiModules Modules { get; }
    public IProjectFileTypeServices ProjectFileTypeServices { get; }
    public PsiModuleResolveContextManager PsiModuleResolveContextManager { get; }
    public TypeElementInheritanceCache TypeElementInheritanceCache { get; }
    public AnnotatedEntitiesCache AnnotatedMembersCache { get; }
    public AssemblyAnnotatedEntitiesCache AssemblyAnnotatedMembersCache { get; }
    public CodeAnnotationsConfiguration CodeAnnotationsConfiguration { get; }
    [MustUseReturnValueAttribute]
public abstract virtual TComponent GetComponent();
    public abstract virtual ISolution get_Solution();
    public abstract virtual IShellLocks get_Locks();
    public abstract virtual ILanguageManager get_LanguageManager();
    public abstract virtual DependencyStore get_DependencyStore();
    public abstract virtual IGeneratedDocumentsManager get_GeneratedDocumentsManager();
    public abstract virtual SearchDomainFactory get_SearchDomainFactory();
    public abstract virtual IFinder get_Finder();
    public abstract virtual IFinder get_ParallelFinder();
    public abstract virtual IFinder get_AsyncFinder();
    public abstract virtual NamingManager get_Naming();
    public abstract virtual ISettingsStore get_SettingsStore();
    public abstract virtual ISymbolCache get_Symbols();
    public abstract virtual IWordIndex get_WordIndex();
    public abstract virtual StubTreeNodeCache get_StubTreeNodes();
    public abstract virtual IPsiConfiguration get_Configuration();
    public abstract virtual IPsiFiles get_Files();
    public abstract virtual IPsiPointers get_Pointers();
    public abstract virtual IPsiCaches get_Caches();
    public abstract virtual IPsiCachesState get_CachesState();
    public abstract virtual IPersistentIndexManager get_PersistentIndex();
    public abstract virtual IPsiTransactions get_Transactions();
    public abstract virtual IPsiModules get_Modules();
    public abstract virtual IProjectFileTypeServices get_ProjectFileTypeServices();
    public abstract virtual PsiModuleResolveContextManager get_PsiModuleResolveContextManager();
    public abstract virtual TypeElementInheritanceCache get_TypeElementInheritanceCache();
    public abstract virtual AnnotatedEntitiesCache get_AnnotatedMembersCache();
    public abstract virtual AssemblyAnnotatedEntitiesCache get_AssemblyAnnotatedMembersCache();
    public abstract virtual CodeAnnotationsConfiguration get_CodeAnnotationsConfiguration();
}
public interface JetBrains.ReSharper.Psi.IPsiSourceFile {
    [NotNullAttribute]
public IPsiModule PsiModule { get; }
    [NotNullAttribute]
public IDocument Document { get; }
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public string DisplayName { get; }
    [NotNullAttribute]
public ProjectFileType LanguageType { get; }
    [NotNullAttribute]
public PsiLanguageType PrimaryPsiLanguage { get; }
    [NotNullAttribute]
public IPsiSourceFileProperties Properties { get; }
    [NotNullAttribute]
public IModuleReferenceResolveContext ResolveContext { get; }
    [NotNullAttribute]
public IPsiSourceFileStorage PsiStorage { get; }
    public Nullable`1<ModificationStamp> InMemoryModificationStamp { get; }
    public Nullable`1<ModificationStamp> ExternalModificationStamp { get; }
    public DateTime LastWriteTimeUtc { get; }
    public abstract virtual IPsiModule get_PsiModule();
    public abstract virtual IDocument get_Document();
    public abstract virtual string get_Name();
    public abstract virtual string get_DisplayName();
    public abstract virtual bool IsValid();
    [CanBeNullAttribute]
public abstract virtual string GetPersistentID();
    public abstract virtual ProjectFileType get_LanguageType();
    public abstract virtual PsiLanguageType get_PrimaryPsiLanguage();
    public abstract virtual IPsiSourceFileProperties get_Properties();
    public abstract virtual IModuleReferenceResolveContext get_ResolveContext();
    public abstract virtual IPsiSourceFileStorage get_PsiStorage();
    public abstract virtual Nullable`1<ModificationStamp> get_InMemoryModificationStamp();
    public abstract virtual Nullable`1<ModificationStamp> get_ExternalModificationStamp();
    public abstract virtual DateTime get_LastWriteTimeUtc();
}
public interface JetBrains.ReSharper.Psi.IPsiSourceFileProperties {
    public bool ShouldBuildPsi { get; }
    public bool IsGeneratedFile { get; }
    public bool IsICacheParticipant { get; }
    public bool ProvidesCodeModel { get; }
    public bool IsNonUserFile { get; }
    public abstract virtual bool get_ShouldBuildPsi();
    public abstract virtual bool get_IsGeneratedFile();
    public abstract virtual bool get_IsICacheParticipant();
    public abstract virtual bool get_ProvidesCodeModel();
    public abstract virtual bool get_IsNonUserFile();
    [NotNullAttribute]
public abstract virtual IEnumerable`1<string> GetPreImportedNamespaces();
    [NotNullAttribute]
public abstract virtual string GetDefaultNamespace();
    [NotNullAttribute]
public abstract virtual ICollection`1<PreProcessingDirective> GetDefines();
}
public interface JetBrains.ReSharper.Psi.IPsiSourceFilePropertiesExplanation {
    [CanBeNullAttribute]
public abstract virtual string GetExplanation();
}
public interface JetBrains.ReSharper.Psi.IPsiSourceFilePropertiesProvider {
    public double Order { get; }
    public abstract virtual double get_Order();
    [CanBeNullAttribute]
public abstract virtual IPsiSourceFileProperties GetPsiProperties(IPsiSourceFileProperties prevProperties, IProject project, IProjectFile projectFile, IPsiSourceFile sourceFile);
}
public interface JetBrains.ReSharper.Psi.IPsiSourceFileStorage {
    [NotNullAttribute]
public object TypeMemberBucketLock { get; }
    [NotNullAttribute]
public object StubTreeNodesCacheLock { get; }
    public Nullable`1<OWORD> PersistentIndex { get; public set; }
    public Nullable`1<long> ContentHash { get; }
    [CanBeNullAttribute]
public TypeMembersBucket TypeMemberBucket { get; }
    [CanBeNullAttribute]
public IParametrizedCachedValue`2<PsiFilesBucket, IPsiSourceFile> PsiFilesBucket { get; }
    public abstract virtual object get_TypeMemberBucketLock();
    public abstract virtual object get_StubTreeNodesCacheLock();
    public abstract virtual Nullable`1<OWORD> get_PersistentIndex();
    public abstract virtual void set_PersistentIndex(Nullable`1<OWORD> value);
    public abstract virtual Nullable`1<long> get_ContentHash();
    public abstract virtual void ResetContentHash();
    public abstract virtual TypeMembersBucket get_TypeMemberBucket();
    public abstract virtual IParametrizedCachedValue`2<PsiFilesBucket, IPsiSourceFile> get_PsiFilesBucket();
}
public interface JetBrains.ReSharper.Psi.IPsiSourceFileWithLocation {
    [NotNullAttribute]
public VirtualFileSystemPath Location { get; }
    public abstract virtual VirtualFileSystemPath get_Location();
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.IRecursiveElementModifier`1 {
    public abstract virtual bool IsModificationFinished(TContext context);
    [PureAttribute]
public abstract virtual bool InteriorShouldBeModified(ITreeNode element, TContext context);
    public abstract virtual ITreeNode ModifyBeforeInterior(ITreeNode element, TContext context);
    public abstract virtual ITreeNode ModifyAfterInterior(ITreeNode element, TContext context);
}
public interface JetBrains.ReSharper.Psi.IRecursiveElementProcessor {
    public bool ProcessingIsFinished { get; }
    public abstract virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public abstract virtual bool get_ProcessingIsFinished();
    public abstract virtual void ProcessBeforeInterior(ITreeNode element);
    public abstract virtual void ProcessAfterInterior(ITreeNode element);
}
public interface JetBrains.ReSharper.Psi.IRecursiveElementProcessor`1 {
    public abstract virtual bool InteriorShouldBeProcessed(ITreeNode element, TContext context);
    public abstract virtual bool IsProcessingFinished(TContext context);
    public abstract virtual void ProcessBeforeInterior(ITreeNode element, TContext context);
    public abstract virtual void ProcessAfterInterior(ITreeNode element, TContext context);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.IReferencePointer {
    public IPsiSourceFile SourceFile { get; }
    [NullableContextAttribute("2")]
[MustUseReturnValueAttribute]
public abstract virtual IReference GetReference();
    public abstract virtual IPsiSourceFile get_SourceFile();
}
public interface JetBrains.ReSharper.Psi.IRefSafetyRulesVersionModuleProvider {
    public abstract virtual Nullable`1<RefSafetyRulesVersion> GetRefSafetyRulesVersionFromModule(IPsiModule module);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.IRegionsInfo {
    public bool IsEmpty { get; }
    public abstract virtual bool get_IsEmpty();
    [PureAttribute]
public abstract virtual bool ContainedInIgnoreRangeForWarning(string severityId, DocumentRange documentRange);
    [PureAttribute]
public abstract virtual bool ContainedInGeneratedRange(DocumentRange documentRange);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.IRegionsInfoProvider {
    public abstract virtual IRegionsInfo GetCachedInfoForDocument(IDocument document);
    public abstract virtual IRegionsInfo CreateInfoForDocument(IDocument document);
    public abstract virtual IRegionsInfo GetOrCreateInfoForDocument(IDocument document);
}
public interface JetBrains.ReSharper.Psi.IResourceItemDeclaredElement {
    [NotNullAttribute]
public IPsiModule Module { get; }
    public abstract virtual IPsiModule get_Module();
}
public interface JetBrains.ReSharper.Psi.ISandBox {
    [CanBeNullAttribute]
public ITreeNode ContextNode { get; }
    public SandBoxContextType ContextType { get; }
    public abstract virtual ITreeNode get_ContextNode();
    public abstract virtual SandBoxContextType get_ContextType();
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.IsCompileChangedTracker : object {
    private IsCompileService myIsCompileService;
    private IDictionary`2<VirtualFileSystemPath, IMsBuildFilesData> myFilesData;
    private SynchronizationPoint mySyncPoint;
    public IsCompileChangedTracker(Lifetime lifetime, ISolution solution, IShellLocks locks, IMsBuildDataStorage storage, IPsiModules psiModules, ChangeManager changeManager, IsCompileService isCompileService, ILogger logger, PsiProjectFileTypeCoordinator psiProjectFileTypeCoordinator, SynchronizationPoints synchronizationPoints, IEnumerable`1<IsCompileChangedTrackerPathsCollector> pathsCollectors);
    private void OnFilesChanged(Lifetime lifetime, ICollection`1<VirtualFileSystemPath> changedProjectFiles, ISolution solution, IMsBuildDataStorage storage, IShellLocks locks, ChangeManager changeManager, IPsiModules psiModules, ILogger logger, PsiProjectFileTypeCoordinator psiProjectFileTypeCoordinator, IList`1<IsCompileChangedTrackerPathsCollector> pathsCollectors);
    private static void GetAllPaths(JetHashSet`1<VirtualFileSystemPath> result, IMsBuildFilesDataForTargetFrameworkId data);
    private static void GetAllPaths(JetHashSet`1<VirtualFileSystemPath> result, IMsBuildFilesData data, IEnumerable`1<IsCompileChangedTrackerPathsCollector> pathsCollectors, IProject project);
}
public interface JetBrains.ReSharper.Psi.IsCompileChangedTrackerPathsCollector {
    public abstract virtual IEnumerable`1<VirtualFileSystemPath> GetPaths(IProject project, IMsBuildFilesData filesData);
}
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.IsCompileService : object {
    private Lifetime myLifetime;
    private IMsBuildDataStorage myStorage;
    private ILogger myLogger;
    private IShellLocks myLocks;
    private ChangeManager myChangeManager;
    private Key`1<CachedValue> ourKey;
    [CompilerGeneratedAttribute]
private ProjectSyncSettingsComponent <SyncSettingsComponent>k__BackingField;
    [CanBeNullAttribute]
internal ProjectSyncSettingsComponent SyncSettingsComponent { get; internal set; }
    public IsCompileService(Lifetime lifetime, IMsBuildDataStorage storage, ILogger logger, IShellLocks locks, ChangeManager changeManager);
    [CompilerGeneratedAttribute]
internal ProjectSyncSettingsComponent get_SyncSettingsComponent();
    [CompilerGeneratedAttribute]
internal void set_SyncSettingsComponent(ProjectSyncSettingsComponent value);
    public bool IsCompile(IProjectFile projectFile, IPsiSourceFile sourceFile);
    public static bool CalculateIsCompile(IProjectFile projectFile, IPsiSourceFile psiSourceFile, TState state, Func`2<TState, IMsBuildFilesData> getMsbuildFilesData);
}
[SolutionInstanceComponentAttribute("10")]
internal class JetBrains.ReSharper.Psi.IsCompileServiceHelper : object {
    public IsCompileServiceHelper(Lifetime lifetime, ISolution solution, IsCompileService isCompileService, ProjectSyncSettingsComponent settingsComponent);
}
public interface JetBrains.ReSharper.Psi.ISignatureComparer {
    [PureAttribute]
public abstract virtual bool Compare(InvocableSignature signature1, InvocableSignature signature2);
    [PureAttribute]
public abstract virtual bool CompareWithoutName(InvocableSignature signature1, InvocableSignature signature2);
    [PureAttribute]
public abstract virtual bool CompareWithoutNameAndWithoutTypeParameters(InvocableSignature signature1, InvocableSignature signature2);
    [PureAttribute]
public abstract virtual bool CompareParameters(InvocableSignature signature1, InvocableSignature signature2);
}
public interface JetBrains.ReSharper.Psi.ISignOperator {
}
public interface JetBrains.ReSharper.Psi.IStruct {
    public bool HasHiddenInstanceFields { get; }
    public bool HasCustomParameterlessConstructor { get; }
    public bool IsByRefLike { get; }
    public abstract virtual bool get_HasHiddenInstanceFields();
    public abstract virtual bool get_HasCustomParameterlessConstructor();
    public abstract virtual bool get_IsByRefLike();
}
public interface JetBrains.ReSharper.Psi.ITargetTypedExpressionType {
    public IEnumerable`1<IExpressionType> NestedTypes { get; }
    public abstract virtual IEnumerable`1<IExpressionType> get_NestedTypes();
}
[NullableContextAttribute("2")]
public interface JetBrains.ReSharper.Psi.ITreeNodePointer`1 {
    public IPsiSourceFile SourceFile { get; }
    [MustUseReturnValueAttribute]
public abstract virtual TTreeNode GetTreeNode();
    public abstract virtual IPsiSourceFile get_SourceFile();
}
public interface JetBrains.ReSharper.Psi.ITreeRange {
    public bool IsEmpty { get; }
    public ITreeNode First { get; }
    public ITreeNode Last { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual ITreeNode get_First();
    public abstract virtual ITreeNode get_Last();
}
public interface JetBrains.ReSharper.Psi.ITreeRangePointer {
    [CanBeNullAttribute]
public abstract virtual ITreeRange GetTreeRange();
}
public interface JetBrains.ReSharper.Psi.ITreeTextRangeKind {
}
public interface JetBrains.ReSharper.Psi.ITupleExpressionType {
    [NotNullAttribute]
public IReadOnlyList`1<TupleExpressionTypeComponent> Components { get; }
    public abstract virtual IReadOnlyList`1<TupleExpressionTypeComponent> get_Components();
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.IType {
    public bool IsOpenType { get; }
    public TypeClassification Classify { get; }
    public TypeDecorationSet TypeDecorations { get; }
    public NullableAnnotation NullableAnnotation { get; }
    [PureAttribute]
public abstract virtual bool IsImplicitlyConvertibleTo(IType type, ITypeConversionRule conversionRule);
    [PureAttribute]
public abstract virtual bool IsExplicitlyConvertibleTo(IType type, ITypeConversionRule conversionRule);
    public abstract virtual void Accept(TypeVisitor typeVisitor);
    public abstract virtual TResult Accept(TypeVisitor`2<TContext, TResult> typeVisitor, TContext context);
    [NullableContextAttribute("2")]
[PureAttribute]
public abstract virtual IDeclaredType GetScalarType();
    [MustUseReturnValueAttribute]
public abstract virtual ISymbolTable GetSymbolTable(IPsiModule module);
    public abstract virtual bool get_IsOpenType();
    public abstract virtual TypeClassification get_Classify();
    [PureAttribute]
public abstract virtual bool IsWellFormed(ITypeConstraintsVerifier typeConstraintsVerifier);
    [PureAttribute]
public abstract virtual ITypePointer CreatePointer();
    public abstract virtual bool Equals(IType type, IEqualityComparer`1<IType> childrenComparer);
    public abstract virtual TypeDecorationSet get_TypeDecorations();
    [PureAttribute]
public abstract virtual IType WithTypeDecorations(TypeDecorationSet typeDecorations);
    public abstract virtual NullableAnnotation get_NullableAnnotation();
    [PureAttribute]
public abstract virtual IType WithNullableAnnotation(NullableAnnotation nullableAnnotation);
    [PureAttribute]
public abstract virtual IType MergeNullability(IType otherType, TypeParameterVariance variance);
}
[NullableContextAttribute("2")]
public interface JetBrains.ReSharper.Psi.ITypeConstraintsVerifier {
    [NullableContextAttribute("1")]
public abstract virtual TypeArgumentValidationResult ValidateTypeArgument(ITypeParameter typeParameter, ISubstitution constraintsSubstitution, IType typeArgument, bool isExplicitTypeArgument);
    [NullableContextAttribute("1")]
public abstract virtual TypeArgumentValidationResult ValidateTypeCanBeUsedAsTypeArgument(IType typeArgument, bool allowByRefLikeType);
    public abstract virtual bool SatisfiesReferenceTypeConstraint(IType typeArgument);
    public abstract virtual bool SatisfiesValueTypeConstraint(IDeclaredType typeArgument);
    public abstract virtual bool SatisfiesUnmanagedTypeConstraint(IDeclaredType typeArgument);
    public abstract virtual bool SatisfiesDefaultConstructorConstraint(IDeclaredType typeArgument);
    public abstract virtual bool SatisfiesSuperTypeConstraint(IType typeArgument, IType superType);
}
public interface JetBrains.ReSharper.Psi.ITypeConversionRule {
    [NotNullAttribute]
public IEqualityComparer`1<IType> EqualityComparer { get; }
    public abstract virtual IEqualityComparer`1<IType> get_EqualityComparer();
    [PureAttribute]
[ContractAnnotationAttribute("from: null => false; to: null => false")]
public abstract virtual bool IsImplicitlyConvertibleTo(IType from, IType to);
    [PureAttribute]
[ContractAnnotationAttribute("from: null => false; to: null => false")]
public abstract virtual bool IsExplicitlyConvertibleTo(IType from, IType to);
    [PureAttribute]
[ContractAnnotationAttribute("from: null => false; to: null => false")]
public abstract virtual bool IsImplicitlyConvertibleTo(IExpressionType from, IType to);
    [PureAttribute]
[ContractAnnotationAttribute("from: null => false; to: null => false")]
public abstract virtual bool IsExplicitlyConvertibleTo(IExpressionType from, IType to);
    [PureAttribute]
[ContractAnnotationAttribute("from: null => false; to: null => false")]
public abstract virtual bool IsImplicitlyConvertiblePredefined(IType from, IType to);
    [PureAttribute]
[ContractAnnotationAttribute("from: null => false; to: null => false")]
public abstract virtual bool IsExplicitlyConvertiblePredefined(IType from, IType to);
    [PureAttribute]
[ContractAnnotationAttribute("from: null => false; to: null => false")]
public abstract virtual bool HasStandardImplicitConversion(IType from, IType to);
    [PureAttribute]
[ContractAnnotationAttribute("from: null => false; to: null => false")]
public abstract virtual bool HasExtensionMethodThisArgumentConversion(IType from, IType to, ParameterKind thisParameterKind);
    [PureAttribute]
[ContractAnnotationAttribute("from: null => false; to: null => false")]
public abstract virtual bool HasIdentityConversion(IType from, IType to);
}
[NullableContextAttribute("2")]
public interface JetBrains.ReSharper.Psi.ITypeDecorationPointer {
    public abstract virtual TypeDecoration Find();
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.ITypeDecorationSetPointer {
    public abstract virtual TypeDecorationSet Find();
}
public interface JetBrains.ReSharper.Psi.ITypeElement {
    [NotNullAttribute]
[ItemNotNullAttribute]
public IList`1<ITypeElement> NestedTypes { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IField> Constants { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IField> Fields { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IConstructor> Constructors { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IOperator> Operators { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IMethod> Methods { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IProperty> Properties { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IEvent> Events { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<string> MemberNames { get; }
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IClrTypeName GetClrName();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IList`1<IDeclaredType> GetSuperTypes();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IList`1<ITypeElement> GetSuperTypeElements();
    public abstract virtual IList`1<ITypeElement> get_NestedTypes();
    [NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public abstract virtual IEnumerable`1<ITypeMember> GetMembers();
    public abstract virtual IEnumerable`1<IField> get_Constants();
    public abstract virtual IEnumerable`1<IField> get_Fields();
    public abstract virtual IEnumerable`1<IConstructor> get_Constructors();
    public abstract virtual IEnumerable`1<IOperator> get_Operators();
    public abstract virtual IEnumerable`1<IMethod> get_Methods();
    public abstract virtual IEnumerable`1<IProperty> get_Properties();
    public abstract virtual IEnumerable`1<IEvent> get_Events();
    [PureAttribute]
public abstract virtual MemberPresenceFlag GetMemberPresenceFlag();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual INamespace GetContainingNamespace();
    public abstract virtual IEnumerable`1<string> get_MemberNames();
    [PureAttribute]
public abstract virtual bool HasMemberWithName(string shortName, bool ignoreCase);
    [CanBeNullAttribute]
public abstract virtual IPsiSourceFile GetSingleOrDefaultSourceFile();
}
public interface JetBrains.ReSharper.Psi.ITypeKeywordsService {
    [NotNullAttribute]
public abstract virtual IEnumerable`1<string> GetTypeKeywords(IPsiModule psiModule);
    [CanBeNullAttribute]
public abstract virtual string GetFullQualifiedTypeName(string keyword, IPsiModule psiModule);
    [CanBeNullAttribute]
public abstract virtual string GetTypeKeyword(ITypeElement typeElement);
    public abstract virtual bool IsTypeKeywordReference(IReference reference);
    public abstract virtual bool IsDynamicKeyword(string keyword);
}
public interface JetBrains.ReSharper.Psi.ITypeMember {
    [CanBeNullAttribute]
public ITypeElement ContainingType { get; }
    public AccessibilityDomain AccessibilityDomain { get; }
    public MemberHidePolicy HidePolicy { get; }
    public abstract virtual ITypeElement get_ContainingType();
    public abstract virtual AccessibilityDomain get_AccessibilityDomain();
    [NotNullAttribute]
public abstract virtual IList`1<TypeMemberInstance> GetHiddenMembers();
    public abstract virtual MemberHidePolicy get_HidePolicy();
    [PureAttribute]
public abstract virtual Nullable`1<Hash> CalcHash();
}
public interface JetBrains.ReSharper.Psi.ITypeOwner {
    [NotNullAttribute]
public IType Type { get; }
    public abstract virtual IType get_Type();
}
public interface JetBrains.ReSharper.Psi.ITypeParameter {
    public int Index { get; }
    public TypeParameterVariance Variance { get; }
    public bool IsValueType { get; }
    public bool IsReferenceType { get; }
    public bool IsUnmanagedType { get; }
    public bool HasDefaultConstructor { get; }
    public bool IsNotNullableValueOrReferenceType { get; }
    public bool AllowsByRefLikeType { get; }
    public TypeParameterNullability Nullability { get; }
    public bool HasTypeConstraints { get; }
    [NotNullAttribute]
public IList`1<IType> TypeConstraints { get; }
    public TypeParameterConstraintFlags Constraints { get; }
    public NullableAnnotation NullableAnnotation { get; }
    [CanBeNullAttribute]
public ITypeParametersOwner Owner { get; }
    [CanBeNullAttribute]
public ITypeElement OwnerType { get; }
    [CanBeNullAttribute]
public IParametersOwner OwnerFunction { get; }
    [ObsoleteAttribute("Use 'OwnerFunction' instead")]
[CanBeNullAttribute]
public IMethod OwnerMethod { get; }
    public abstract virtual int get_Index();
    public abstract virtual TypeParameterVariance get_Variance();
    public abstract virtual bool get_IsValueType();
    public abstract virtual bool get_IsReferenceType();
    public abstract virtual bool get_IsUnmanagedType();
    public abstract virtual bool get_HasDefaultConstructor();
    public abstract virtual bool get_IsNotNullableValueOrReferenceType();
    public abstract virtual bool get_AllowsByRefLikeType();
    public abstract virtual TypeParameterNullability get_Nullability();
    [PureAttribute]
public abstract virtual TypeParameterNullability GetNullability(ISubstitution explicitInheritorSubstitution);
    public abstract virtual bool get_HasTypeConstraints();
    public abstract virtual IList`1<IType> get_TypeConstraints();
    public abstract virtual TypeParameterConstraintFlags get_Constraints();
    public abstract virtual NullableAnnotation get_NullableAnnotation();
    public abstract virtual ITypeParametersOwner get_Owner();
    public abstract virtual ITypeElement get_OwnerType();
    public abstract virtual IParametersOwner get_OwnerFunction();
    public abstract virtual IMethod get_OwnerMethod();
}
public interface JetBrains.ReSharper.Psi.ITypeParametersOwner {
    [CodeTemplateAttribute("$typeMember{Expression,'JetBrains.ReSharper.Psi.ITypeParametersOwner'}$.TypeParameters.Count")]
[NotNullAttribute]
public IList`1<ITypeParameter> TypeParameters { get; }
    public int TypeParametersCount { get; }
    public abstract virtual IList`1<ITypeParameter> get_TypeParameters();
    public abstract virtual int get_TypeParametersCount();
}
public interface JetBrains.ReSharper.Psi.ITypePointer {
    public IPsiModule PsiModule { get; }
    [NotNullAttribute]
public abstract virtual IType FindType();
    public abstract virtual IPsiModule get_PsiModule();
}
public interface JetBrains.ReSharper.Psi.ITypePointerDecorator {
    public ITypePointer UnderlyingTypePointer { get; public set; }
    public abstract virtual ITypePointer get_UnderlyingTypePointer();
    public abstract virtual void set_UnderlyingTypePointer(ITypePointer value);
}
public interface JetBrains.ReSharper.Psi.ITypePresenter {
    [NotNullAttribute]
[PureAttribute]
public abstract virtual RichText GetPresentableName(IType type, TypePresentationStyle typePresentationStyle);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual RichText GetUnresolvedScalarTypePresentation(string name, ICollection`1<IType> typeArguments, NullableAnnotation nullableAnnotation, TypePresentationStyle typePresentationStyle);
}
public interface JetBrains.ReSharper.Psi.IUnmanagedCppDeclaredElement {
}
public interface JetBrains.ReSharper.Psi.IUnresolvedDeclaredElement {
    public bool IsDynamic { get; }
    public abstract virtual bool get_IsDynamic();
}
public interface JetBrains.ReSharper.Psi.IWebDeclaredElement {
}
[ZoneDefinitionAttribute]
[ZoneDefinitionConfigurableFeatureAttribute("Web Languages", "Support for Html, ASP.NET, ASP.NET MVC, Razor, Blazor", "False")]
public interface JetBrains.ReSharper.Psi.IWebPsiLanguageZone {
}
public interface JetBrains.ReSharper.Psi.IWrappedDeclaredElement {
    public IDeclaredElement UnderlyingDeclaredElement { get; }
    public abstract virtual IDeclaredElement get_UnderlyingDeclaredElement();
}
public interface JetBrains.ReSharper.Psi.IXmlDocIdOwner {
    [NotNullAttribute]
public string XMLDocId { get; }
    public abstract virtual string get_XMLDocId();
}
[LanguageDefinitionAttribute("ANY")]
public class JetBrains.ReSharper.Psi.KnownLanguage : PsiLanguageType {
    public static string ANY_LANGUAGEID;
    [CompilerGeneratedAttribute]
private static KnownLanguage <ANY>k__BackingField;
    [CanBeNullAttribute]
[UsedImplicitlyAttribute]
public static KnownLanguage ANY { get; private set; }
    protected KnownLanguage(string name);
    protected KnownLanguage(string name, string presentableName);
    [CompilerGeneratedAttribute]
public static KnownLanguage get_ANY();
    [CompilerGeneratedAttribute]
private static void set_ANY(KnownLanguage value);
}
[AttributeUsageAttribute("4")]
[MeansImplicitUseAttribute]
public class JetBrains.ReSharper.Psi.LanguageAttribute : ComponentAttribute {
    protected static Instantiation LanguageDefaultInstantiation;
    [CompilerGeneratedAttribute]
private Type <Language>k__BackingField;
    public Type Language { get; }
    public LanguageAttribute(Type Language, Instantiation instantiation);
    [CompilerGeneratedAttribute]
public Type get_Language();
}
[AttributeUsageAttribute("4")]
[MeansImplicitUseAttribute]
public class JetBrains.ReSharper.Psi.LanguageDefinitionAttribute : PartAttribute {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Language { get; }
    public LanguageDefinitionAttribute(string Language);
    [CompilerGeneratedAttribute]
public string get_Language();
}
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.LanguageManager : SplittedComponentContainer`2<PsiLanguageType, LanguageAttribute> {
    [NotNullAttribute]
private ConcurrentDictionary`2<Pair`2<PsiLanguageType, Type>, object> myCachedService;
    [NotNullAttribute]
private ConcurrentDictionary`2<Pair`2<PsiLanguageType, Type>, object> myCachedServices;
    [CompilerGeneratedAttribute]
private ILanguages <Languages>k__BackingField;
    [NotNullAttribute]
public static ILanguageManager Instance { get; }
    public ILanguages Languages { get; }
    public LanguageManager(IShellLocks locks, Lifetime lifetime, ShellPartCatalogSet catalogueSet, IComponentContainer parentContainer, ILanguages languages);
    public static ILanguageManager get_Instance();
    [CompilerGeneratedAttribute]
public sealed virtual ILanguages get_Languages();
    public sealed virtual TLanguageService TryGetCachedService(PsiLanguageType languageType);
    public sealed virtual IEnumerable`1<TLanguageService> TryGetCachedServices(PsiLanguageType languageType);
    private sealed virtual override TLanguageService JetBrains.ReSharper.Psi.ILanguageManager.GetService();
    private sealed virtual override TLanguageService JetBrains.ReSharper.Psi.ILanguageManager.GetService(PsiLanguageType languageType);
    private sealed virtual override TLanguageService JetBrains.ReSharper.Psi.ILanguageManager.TryGetService();
    private sealed virtual override TLanguageService JetBrains.ReSharper.Psi.ILanguageManager.TryGetService(PsiLanguageType languageType);
    private sealed virtual override IEnumerable`1<TLanguageService> JetBrains.ReSharper.Psi.ILanguageManager.GetServicesFromAll();
    private sealed virtual override IEnumerable`1<TLanguageService> JetBrains.ReSharper.Psi.ILanguageManager.GetMultipleServicesFromAll();
    private sealed virtual override IReadyImmutableList`1<TLanguageService> JetBrains.ReSharper.Psi.ILanguageManager.GetServices(PsiLanguageType languageType);
    private sealed virtual override bool JetBrains.ReSharper.Psi.ILanguageManager.HasService(PsiLanguageType languageType);
}
public class JetBrains.ReSharper.Psi.LanguageManagerServiceProvider`2 : object {
    [CompilerGeneratedAttribute]
private TService <Service>k__BackingField;
    public TService Service { get; }
    public LanguageManagerServiceProvider`2(TService service);
    [CompilerGeneratedAttribute]
public sealed virtual TService get_Service();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.Languages : object {
    private ViewableCollection`1<PsiLanguageType> myLanguages;
    private Dictionary`2<string, PsiLanguageType> myNameToLanguage;
    private Dictionary`2<string, PsiLanguageType> mySynonymToLanguage;
    private Dictionary`2<Type, PsiLanguageType> myTypeToLanguage;
    private Dictionary`2<StringSource, PsiLanguageType> myNameSourceToLanguage;
    public IEnumerable`1<PsiLanguageType> All { get; }
    public static ILanguages Instance { get; }
    public Languages(Lifetime lifetime, ShellPartCatalogSet catalogueSet, ProductConfigurations productConfigurations);
    public static T SetStaticInstanceProperty(Lifetime lifetime, Type type);
    [NullableContextAttribute("0")]
private void AddLanguages(Lifetime lifetime, CollectionSource`1<PartCatalogType> parts);
    public sealed virtual void View(Lifetime lifetime, Action`2<Lifetime, PsiLanguageType> viewer);
    public sealed virtual IEnumerable`1<PsiLanguageType> get_All();
    public sealed virtual PsiLanguageType GetLanguageByName(string languageName);
    public sealed virtual PsiLanguageType GetLanguageByNameOrSynonym(string languageName);
    [NullableContextAttribute("2")]
public sealed virtual PsiLanguageType GetLanguageByName(StringSource languageName);
    public sealed virtual PsiLanguageType GetLanguageByType(Type type);
    public static ILanguages get_Instance();
}
public class JetBrains.ReSharper.Psi.LanguagesChanged : object {
    private IEnumerable`1<PsiLanguageType> myAddedLanguages;
    private IEnumerable`1<PsiLanguageType> myRemovingLanguages;
    public IEnumerable`1<PsiLanguageType> AddedLanguages { get; }
    public IEnumerable`1<PsiLanguageType> RemovingLanguages { get; }
    public LanguagesChanged(IEnumerable`1<PsiLanguageType> addedLanguages, IEnumerable`1<PsiLanguageType> removingLanguages);
    public IEnumerable`1<PsiLanguageType> get_AddedLanguages();
    public IEnumerable`1<PsiLanguageType> get_RemovingLanguages();
}
public abstract class JetBrains.ReSharper.Psi.LanguageService : object {
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private IConstantValueService <ConstantValueService>k__BackingField;
    [NotNullAttribute]
public PsiLanguageType LanguageType { get; }
    [NotNullAttribute]
public IConstantValueService ConstantValueService { get; }
    [CanBeNullAttribute]
public ILanguageCacheProvider CacheProvider { get; }
    public bool IsCaseSensitive { get; }
    public bool SupportTypeMemberCache { get; }
    [CanBeNullAttribute]
public ICodeFormatter CodeFormatter { get; }
    [NotNullAttribute]
public ITypePresenter TypePresenter { get; }
    [CanBeNullAttribute]
public IDeclaredElementPresenter DeclaredElementPresenter { get; }
    public bool ParticipatesInClrCaches { get; }
    public bool SandboxFilesParticipateInICache { get; }
    public bool AnalyzePossibleInfiniteInheritance { get; }
    public bool AnalyzeFormatStrings { get; }
    public IReadOnlyList`1<IPsiModificationService> ModificationServices { get; }
    protected LanguageService(PsiLanguageType psiLanguageType, IConstantValueService constantValueService);
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    [CompilerGeneratedAttribute]
public IConstantValueService get_ConstantValueService();
    public abstract virtual ILanguageCacheProvider get_CacheProvider();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ILexerFactory GetPrimaryLexerFactory();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ILexer CreateFilteringLexer(ILexer lexer);
    public virtual bool IsValidName(DeclaredElementType elementType, string name);
    public ILazyCachingLexer CreateCachingLexer(IBuffer buffer);
    [NotNullAttribute]
public virtual IEnumerable`1<string> EnumerateParserCapabilities();
    public abstract virtual IParser CreateParser(ILexer lexer, IPsiModule module, IPsiSourceFile sourceFile);
    [CanBeNullAttribute]
public IFile ParseFile(ILexer lexer, IPsiSourceFile sourceFile);
    public abstract virtual bool get_IsCaseSensitive();
    public abstract virtual bool get_SupportTypeMemberCache();
    [CanBeNullAttribute]
[PublicAPIAttribute]
public virtual ITreeNode ParseUsingCapability(string text, string capability, IPsiModule psiModule);
    [CanBeNullAttribute]
public virtual PreProcessingDirectivesInFile GetUsedConditionalSymbols(IPsiSourceFile sourceFile);
    public virtual ICodeFormatter get_CodeFormatter();
    public virtual void OptimizeImportsAndRefs(IFile file, IRangeMarker rangeMarker, bool optimizeUsings, bool shortenReferences, IProgressIndicator progressIndicator);
    [CanBeNullAttribute]
[PureAttribute]
public virtual IReferenceContextCodec CreateReferenceContextCodec();
    [CanBeNullAttribute]
[PureAttribute]
public virtual ITypeConversionRule GetTypeConversionRule(ITreeNode context, bool useStrict);
    public abstract virtual ITypePresenter get_TypePresenter();
    public virtual IDeclaredElementPresenter get_DeclaredElementPresenter();
    [PureAttribute]
public virtual bool IsTypeMemberVisible(ITypeMember member);
    [PureAttribute]
public virtual ReferenceAccessType GetReferenceAccessType(IReference reference);
    [PureAttribute]
public virtual ReferenceAccessType GetReferenceAccessType(IDeclaredElement target, IReference reference);
    [PureAttribute]
public virtual IDeclaredElementPointer`1<TDeclaredElement> CreateElementPointer(TDeclaredElement declaredElement);
    [CanBeNullAttribute]
[PureAttribute]
public virtual ITreeNodePointer`1<TTreeNode> CreateTreeElementPointer(TTreeNode node);
    [CanBeNullAttribute]
[PureAttribute]
public virtual IReferencePointer CreateReferencePointer(IReference reference);
    public virtual bool CanContainCachableDeclarations(ITreeNode node);
    public virtual IEnumerable`1<ITreeNode> GetAdditionalCachableDeclarations(IFile file);
    public virtual TreeOffset CalcOffset(IDeclaration declaration);
    public virtual bool get_ParticipatesInClrCaches();
    public virtual bool get_SandboxFilesParticipateInICache();
    public abstract virtual IEnumerable`1<ITypeDeclaration> FindTypeDeclarations(IFile file);
    public virtual bool get_AnalyzePossibleInfiniteInheritance();
    public virtual bool get_AnalyzeFormatStrings();
    public virtual bool SupportsNativeNumericTypes(IProjectPsiModule projectPsiModule);
    public virtual SourceExtensionMembersIndex CreateSourceExtensionMethodsIndex();
    public virtual IReadOnlyList`1<IPsiModificationService> get_ModificationServices();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.LanguagesEx : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static PsiLanguageType LanguageOrUnknown(ILanguages languages, string languageName);
}
[ProjectModelElementPresenterAttribute("10", "16")]
public class JetBrains.ReSharper.Psi.LanguageSpecificProjectElementPresenter : object {
    public sealed virtual IconId GetIcon(IProjectModelElement element);
    public sealed virtual string GetPresentableLocation(IProjectModelElement projectModelElement);
    private static IconId GetIconForProjectFileType(ProjectFileType type);
}
public class JetBrains.ReSharper.Psi.ManuallyRemappedTreeNodePointer : object {
    private TreeNodeMarker myMarker;
    private ITreeNode myTree;
    public ICollection`1<ITreeNode> Nodes { get; }
    public ManuallyRemappedTreeNodePointer(string keyName);
    public ICollection`1<ITreeNode> get_Nodes();
    public void Add(ITreeNode node);
    public void Remap(ITreeNode tree);
}
public enum JetBrains.ReSharper.Psi.MemberContainerStyle : Enum {
    public int value__;
    public static MemberContainerStyle NONE;
    public static MemberContainerStyle AFTER;
    public static MemberContainerStyle AFTER_WITH_KIND;
    public static MemberContainerStyle AFTER_IN_PARENTHESIS;
    public static MemberContainerStyle AFTER_IN_PARENTHESIS_WITH_KIND;
    public static MemberContainerStyle BEFORE_WITH_DOT;
}
public class JetBrains.ReSharper.Psi.MemberDecoration : ValueType {
    public Modifiers Modifiers;
    public static MemberDecoration DefaultValue;
    public bool IsAbstract { get; public set; }
    public bool IsSealed { get; public set; }
    public bool IsVirtual { get; public set; }
    public bool IsOverride { get; public set; }
    public bool IsStatic { get; public set; }
    public bool IsReadonly { get; public set; }
    public bool IsExtern { get; public set; }
    public bool IsVolatile { get; public set; }
    public bool IsUnsafe { get; public set; }
    public bool IsHideBySig { get; public set; }
    public AccessRights AccessRights { get; public set; }
    private MemberDecoration(Modifiers modifiers);
    private static MemberDecoration();
    [PureAttribute]
public ushort ToRawValue();
    [PureAttribute]
public static MemberDecoration FromRawValue(ushort modifiers);
    [PureAttribute]
public static MemberDecoration FromModifiers(Modifiers modifiers);
    private void SetModifier(Modifiers modifier, bool value);
    [PureAttribute]
private bool GetModifier(Modifiers modifier);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public bool get_IsSealed();
    public void set_IsSealed(bool value);
    public bool get_IsVirtual();
    public void set_IsVirtual(bool value);
    public bool get_IsOverride();
    public void set_IsOverride(bool value);
    public bool get_IsStatic();
    public void set_IsStatic(bool value);
    public bool get_IsReadonly();
    public void set_IsReadonly(bool value);
    public bool get_IsExtern();
    public void set_IsExtern(bool value);
    public bool get_IsVolatile();
    public void set_IsVolatile(bool value);
    public bool get_IsUnsafe();
    public void set_IsUnsafe(bool value);
    public bool get_IsHideBySig();
    public void set_IsHideBySig(bool value);
    public AccessRights get_AccessRights();
    public void set_AccessRights(AccessRights value);
}
public enum JetBrains.ReSharper.Psi.MemberHidePolicy : Enum {
    public byte value__;
    public static MemberHidePolicy HIDE_BY_SIGNATURE;
    public static MemberHidePolicy HIDE_BY_NAME;
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.MemberPresenceFlag : Enum {
    public ushort value__;
    public static MemberPresenceFlag NONE;
    public static MemberPresenceFlag IMPLICIT_OP;
    public static MemberPresenceFlag EXPLICIT_OP;
    public static MemberPresenceFlag SIGN_OR_EQUALITY_OP;
    public static MemberPresenceFlag MAY_EQUALS_OVERRIDE;
    public static MemberPresenceFlag REQUIRED_MEMBERS;
    public static MemberPresenceFlag PUBLIC_DEFAULT_CTOR;
    public static MemberPresenceFlag ACCESSIBLE_INSTANCE_CTOR;
    public static MemberPresenceFlag ACCESSIBLE_INSTANCE_CTOR_WITH_PARAMETERS;
    public static MemberPresenceFlag HAS_POSSIBLE_SYNTHETIC;
    public static MemberPresenceFlag ACCESSIBLE_NESTED_TYPES;
    public static MemberPresenceFlag ACCESSIBLE_CONSTANTS;
    public static MemberPresenceFlag HAS_RECORD_CLONE_METHOD;
    public static MemberPresenceFlag HAS_STATIC_ABSTRACT_MEMBERS;
    public static MemberPresenceFlag HAS_STATIC_ABSTRACT_MEMBERS_IMPLEMENTATATIONS;
    public static MemberPresenceFlag INTERFACE_WITH_ONLY_STATIC_OVERRIDEABLE_MEMBERS;
    public static MemberPresenceFlag INTERFACE_WITHOUT_OVERRIDEABLE_MEMBERS;
    public static MemberPresenceFlag INSTANCE_CTOR;
    public static MemberPresenceFlag HAS_STRUCT_INSTANCE_INITIALIZERS;
    public static MemberPresenceFlag RECORD_HAS_COPY_CONSTRUCTOR_LIKE_INSTANCE_CTOR;
    public static MemberPresenceFlag PUBLIC_DEFAULT_INSTANCE_CTOR_ALL_FLAGS;
}
public abstract class JetBrains.ReSharper.Psi.MixedProjectFileLanguageService : ProjectFileLanguageService {
    protected MixedProjectFileLanguageService(ProjectFileType projectFileType);
    public virtual ILexerFactory GetMixedLexerFactory(ISolution solution, IBuffer buffer, IPsiSourceFile sourceFile);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Modifiers : Enum {
    public ushort value__;
    public static Modifiers INITIAL;
    public static Modifiers ABSTRACT;
    public static Modifiers SEALED;
    public static Modifiers VIRTUAL;
    public static Modifiers OVERRIDE;
    public static Modifiers STATIC;
    public static Modifiers READONLY;
    public static Modifiers EXTERN;
    public static Modifiers UNSAFE;
    public static Modifiers VOLATILE;
    public static Modifiers SPECIAL_NAME;
    public static Modifiers PUBLIC;
    public static Modifiers PROTECTED;
    public static Modifiers INTERNAL;
    public static Modifiers PRIVATE;
    public static Modifiers HIDE_BY_SIG;
    public static Modifiers FILE_LOCAL_TYPE;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ModifiersOwnerExtension : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool CanBeOverridden(IModifiersOwner modifiersOwner);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsAbstractOrVirtual(ITypeMember typeMember);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Modules.AssemblyPsiModuleFactory : object {
    private static ILogger ourLogger;
    private ISolution mySolution;
    private IModuleReferencesResolveStore myModuleReferencesResolveStore;
    private Dictionary`2<IAssembly, IAssemblyPsiModule> myAssemblyModules;
    private CompactOneToListMap`2<AssemblyNameInfo, IAssemblyPsiModule> myAssemblyModulesByName;
    private OutputAssemblies myOutputAssemblies;
    private AssemblyInfoDatabase myAssemblyInfoDatabase;
    private ResolveContextManager myResolveContextManager;
    public Dictionary`2<IAssembly, IAssemblyPsiModule> AssemblyModules { get; }
    public AssemblyPsiModuleFactory(Lifetime lifetime, ChangeManager changeManager, ISolution solution, ModuleReferenceResolveSync moduleReferenceResolve, IModuleReferencesResolveStore moduleReferencesResolveStore, OutputAssemblies outputAssemblies, IModuleReferenceResolveManager moduleReferenceManager, IAssemblyCollection assemblyCollection, AssemblyInfoDatabase assemblyInfoDatabase, ResolveContextManager resolveContextManager);
    private static AssemblyPsiModuleFactory();
    public Dictionary`2<IAssembly, IAssemblyPsiModule> get_AssemblyModules();
    [NotNullAttribute]
public IEnumerable`1<IAssemblyPsiModule> GetAssemblyPsiModuleByName(AssemblyNameInfo name);
    public sealed virtual object Execute(IChangeMap changeMap);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertAllAssembliesAreAlive();
    [CanBeNullAttribute]
private IProject FindProjectByAssembly(IAssembly assembly);
    public IPsiModule TryGetModule(IAssembly assembly);
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Modules.BinaryOutputProjectPsiModuleProviderFilter : object {
    private IAssemblyFactory myAssemblyFactory;
    private ChangeManager myChangeManager;
    private IShellLocks myShellLocks;
    private ILogger myLogger;
    private BinaryOutputInProjectJson myBinaryOutputInProjectJson;
    public BinaryOutputProjectPsiModuleProviderFilter(IAssemblyFactory assemblyFactory, ChangeManager changeManager, IShellLocks shellLocks, ILogger logger, BinaryOutputInProjectJson binaryOutputInProjectJson);
    public sealed virtual Tuple`2<IProjectPsiModuleHandler, IPsiModuleDecorator> OverrideHandler(Lifetime lifetime, IProject project, IProjectPsiModuleHandler handler);
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Modules.DefaultPsiModuleProvider : object {
    private IModuleReferencesResolveStore myModuleReferencesResolveStore;
    private PsiSourceFilePropertiesManager myPsiSourceFilePropertiesManager;
    private DocumentManager myDocumentManager;
    private PsiProjectFileTypeCoordinator myPsiProjectFileTypeCoordinator;
    private IDiagnosticCollector myDiagnosticCollector;
    [CompilerGeneratedAttribute]
private bool <WebAppProviderExists>k__BackingField;
    private bool WebAppProviderExists { get; public set; }
    public DefaultPsiModuleProvider(IModuleReferencesResolveStore moduleReferencesResolveStore, PsiSourceFilePropertiesManager psiSourceFilePropertiesManager, DocumentManager documentManager, PsiProjectFileTypeCoordinator psiProjectFileTypeCoordinator, IDiagnosticCollector diagnosticCollector);
    [CompilerGeneratedAttribute]
private bool get_WebAppProviderExists();
    [CompilerGeneratedAttribute]
public void set_WebAppProviderExists(bool value);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Modules.DefaultPsiModuleProvider/<TryCreate>d__10")]
public sealed virtual IEnumerable`1<IProjectPsiModuleHandler> TryCreate(Lifetime projectLifetime, IProject project);
    public IProjectPsiModuleHandler CreateProjectPsiModuleHandler(Lifetime projectLifetime, IProject project, TargetFrameworkId targetFrameworkId);
}
public abstract class JetBrains.ReSharper.Psi.Modules.DelegatingProjectPsiModuleHandler : object {
    [CompilerGeneratedAttribute]
private IProjectPsiModuleHandler <BaseHandler>k__BackingField;
    public IProjectPsiModuleHandler BaseHandler { get; }
    public IChangeProvider ChangeProvider { get; }
    public IProjectPsiModule PrimaryModule { get; }
    protected DelegatingProjectPsiModuleHandler(IProjectPsiModuleHandler handler);
    [CompilerGeneratedAttribute]
public IProjectPsiModuleHandler get_BaseHandler();
    public virtual IChangeProvider get_ChangeProvider();
    public virtual IProjectPsiModule get_PrimaryModule();
    public virtual IList`1<IPsiModule> GetAllModules();
    public virtual IEnumerable`1<IPsiModule> GetPsiModulesToReference(TargetFrameworkId targetFrameworkId);
    public virtual IEnumerable`1<IPsiSourceFile> GetPsiSourceFilesFor(IProjectFile projectFile);
    public virtual void OnProjectPropertiesChanged(PsiModuleChangeBuilder changeBuilder);
    public virtual void OnProjectFileChanged(IProjectFile projectFile, VirtualFileSystemPath oldLocation, ChangeType changeType, PsiModuleChangeBuilder changeBuilder);
    public virtual void OnExternalModuleSetChanged(PsiModuleChangeBuilder changeBuilder, PsiModuleChange result);
    public virtual bool InternalsVisibleTo(IPsiModule moduleTo, IPsiModule moduleFrom);
}
public abstract class JetBrains.ReSharper.Psi.Modules.ExternalFileModules.AdditionalFilesModuleFactoryBase : object {
    protected ISolution Solution;
    protected ChangeManager myChangeManager;
    protected PsiProjectFileTypeCoordinator myCoordinator;
    protected IProjectFileExtensions myExtensions;
    protected Lifetime myLifetime;
    protected IShellLocks myLocks;
    protected GroupingEvent myGroupingFileChange;
    private Dictionary`2<VirtualFileSystemPath, ChangeType> myFileChanges;
    protected string FileChangeDescription;
    private DocumentManager myDocumentManager;
    [CompilerGeneratedAttribute]
private IPsiModuleOnFileSystemPaths <PsiModule>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    public IPsiModuleOnFileSystemPaths PsiModule { get; }
    public ILogger Logger { get; }
    protected DocumentManager DocumentManager { get; }
    protected AdditionalFilesModuleFactoryBase(ISolution solution, ChangeManager changeManager, PsiProjectFileTypeCoordinator coordinator, IProjectFileExtensions extensions, Lifetime lifetime, IShellLocks locks, IPsiModuleOnFileSystemPaths psiModule, ILogger logger);
    [CompilerGeneratedAttribute]
public IPsiModuleOnFileSystemPaths get_PsiModule();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    public static bool IsFileFromSolution(ISolution solution, VirtualFileSystemPath externalFile);
    public static bool IsFromSolution(ISolution solution, VirtualFileSystemPath externalFile, bool onlyFiles);
    protected DocumentManager get_DocumentManager();
    private void HandleFileChange();
    public sealed virtual IEnumerable`1<IPsiSourceFile> GetPsiSourceFilesFor(IProjectFile projectFile);
    public sealed virtual IEnumerable`1<IPsiModule> GetModules();
    public sealed virtual void Dispose();
    public sealed virtual void OnProjectFileChanged(IProjectFile projectFile, ChangeType changeType, PsiModuleChangeBuilder builder, VirtualFileSystemPath oldLocation);
    protected abstract virtual bool MustAlwaysHaveAdditionalFile(VirtualFileSystemPath oldLocation);
    protected IPsiSourceFile AddFileFromPath(VirtualFileSystemPath path, PsiModuleChangeBuilder builder);
    protected void RemoveFileFromPath(VirtualFileSystemPath path, PsiModuleChangeBuilder builder);
    public virtual object Execute(IChangeMap changeMap);
    protected abstract virtual bool ShouldAcceptMiscProjectFile(IProjectFile projectFile);
    protected abstract virtual IPsiSourceFileProperties CreateProperties();
    protected virtual void HandleRemoveLastReference(VirtualFileSystemPath path, PsiModuleChangeBuilder builder);
    protected void HandleAddFirstReference(VirtualFileSystemPath path, PsiModuleChangeBuilder builder);
    protected void PropagateChanges(PsiModuleChangeBuilder builder, bool fireChange, object changeDescription);
    protected virtual void InvalidateState();
    protected virtual void OnChangesPropagated(object changeDescription);
    protected PsiModuleChangeBuilder FlushChanges(ICollection`1<VirtualFileSystemPath> addedFiles, ICollection`1<VirtualFileSystemPath> removedFiles, bool fireChange, object changeDescription);
    private static Nullable`1<ChangeType> FileChangeToModuleChange(FileSystemChangeType changeType);
    protected void OnFileChange(FileSystemChangeDelta delta);
}
[SolutionInstanceComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Modules.ExternalFileModules.ContentFilesModuleFactory : object {
    [CompilerGeneratedAttribute]
private PsiModuleOnFileSystemPaths <PsiModule>k__BackingField;
    [CompilerGeneratedAttribute]
private HybridCollection`1<IPsiModule> <Modules>k__BackingField;
    public PsiModuleOnFileSystemPaths PsiModule { get; }
    public HybridCollection`1<IPsiModule> Modules { get; }
    public ContentFilesModuleFactory(ISolution solution, IFileSystemTracker fileSystemTracker, PsiSourceFileWithLocationTracker psiSourceFileWithLocationTracker, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public PsiModuleOnFileSystemPaths get_PsiModule();
    [CompilerGeneratedAttribute]
public sealed virtual HybridCollection`1<IPsiModule> get_Modules();
}
[SolutionInstanceComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Modules.ExternalFileModules.DefaultFileDependencyCandidatesTracker : object {
    private static int DEPENDENCIES_THRESHOLD;
    private Lifetime myLifetime;
    private ISolution mySolution;
    private ILogger myLogger;
    private IFileSystemTracker myFileSystemTracker;
    private FileExistenceCacheManager myFileExistenceCacheManager;
    private IGroupingEvent mySubtreeChangeGroupingEvent;
    private IGroupingEvent myTerminationGroupingEvent;
    private ConcurrentQueue`1<DependencyDescription> myTerminationQueue;
    private ReaderWriterLockSlim myDependenciesLock;
    private IDictionary`2<IFileDependency, DependencyDescription> myDependencies;
    private FileDependencyFileSystemPathTrie myPath2DependencyTrie;
    private TwoLevelInternCache myInternCache;
    private DependentFilesModuleFactory myDependentFilesModuleFactory;
    private ExternalFilesSet myFilesSet;
    private SequentialLifetimes myProcessAllOnSubtreeChangedSequentialLifetimes;
    private JetHashSet`1<VirtualFileSystemPath> mySubtreeChangedRoots;
    private LifetimeDefinition myBeforeSolutionDirectoryAdviseLifetime;
    private AsyncItemsProcessor`1<Action> myAsyncProcessor;
    public DefaultFileDependencyCandidatesTracker(Lifetime lifetime, ISolution solution, IShellLocks locks, ILogger logger, IGroupingEventFactory groupingEventFactory, IFileSystemTracker fileSystemTracker, FileExistenceCacheManager fileExistenceCacheManager);
    private void TerminateAsync();
    internal void LinkToDependentFilesModuleFactory(DependentFilesModuleFactory factory);
    public sealed virtual void Register(IFileDependency dependency);
    public sealed virtual void Unregister(IFileDependency dependency);
    public sealed virtual void AddDependencyCandidate(IFileDependency dependency, VirtualFileSystemPath candidatePath);
    public sealed virtual void ClearDependencyCaches(IFileDependency dependency);
    public sealed virtual void ClearDependencyCandidates(IFileDependency dependency);
    private void ClearDependencyCandidates(IFileDependency dependency, bool remove);
    private void OnFileChangeAction(FileSystemChangeDelta fileSystemChangeDelta);
    private void ProcessChanges(FileSystemChangeDelta fileSystemChangeDelta);
    private void ProcessSubtreeChanges();
    internal void HandleFileChange(VirtualFileSystemPath path);
    private void HandleFileChange(IEnumerable`1<IFileDependency> dependencies);
    [CompilerGeneratedAttribute]
private void <Register>b__22_0();
}
public class JetBrains.ReSharper.Psi.Modules.ExternalFileModules.DependencyUpdateCanceledException : OperationCanceledException {
    [CompilerGeneratedAttribute]
private IEnumerable`1<IFileDependency> <Processed>k__BackingField;
    public IEnumerable`1<IFileDependency> Processed { get; }
    public DependencyUpdateCanceledException(IEnumerable`1<IFileDependency> processed);
    public DependencyUpdateCanceledException(IEnumerable`1<IFileDependency> processed, OperationCanceledException inner);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IFileDependency> get_Processed();
}
public abstract class JetBrains.ReSharper.Psi.Modules.ExternalFileModules.DependentFilesCacheBase : object {
    private static int Version;
    private SimplePersistentCache`1<FileDependenciesPerFile> myPersistentCache;
    protected Lifetime myLifetime;
    private ILogger myLogger;
    protected DependentFilesModuleFactory myDependentFilesModuleFactory;
    private IEnumerable`1<IDependentFilesBuilder> myBuilders;
    private IShellLocks myLocks;
    private HashSet`1<IFileDependency> myPreliminaryDependencies;
    private JetHashSet`1<IPsiSourceFile> myDirtyFiles;
    private IPersistentIndexManager myPersistentIndexManager;
    protected IFileDependencyFactory DependencyFactory;
    [CompilerGeneratedAttribute]
private ViewableCollection`1<IFileDependency> <HighPriorityDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private PreliminaryDependenciesChangedEventHandler PreliminaryDependenciesChanged;
    [CompilerGeneratedAttribute]
private CompactMap`2<IPsiSourceFile, FileDependenciesPerFile> <FileDependencies>k__BackingField;
    public Signal`1<IFileDependency> Added;
    public Signal`1<IFileDependency> Removed;
    public IProperty`1<bool> BatchInProgress;
    public ViewableCollection`1<IFileDependency> HighPriorityDependencies { get; }
    public CompactMap`2<IPsiSourceFile, FileDependenciesPerFile> FileDependencies { get; }
    public bool HasDirtyFiles { get; }
    protected DependentFilesCacheBase(Lifetime lifetime, ILogger logger, DependentFilesModuleFactory dependentFilesModuleFactory, IEnumerable`1<IDependentFilesBuilder> builders, IShellLocks locks, IPsiConfiguration configuration, IPersistentIndexManager persistentIndexManager, IFileDependencyFactory dependencyFactory);
    [CompilerGeneratedAttribute]
public ViewableCollection`1<IFileDependency> get_HighPriorityDependencies();
    [CompilerGeneratedAttribute]
public void add_PreliminaryDependenciesChanged(PreliminaryDependenciesChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PreliminaryDependenciesChanged(PreliminaryDependenciesChangedEventHandler value);
    [CompilerGeneratedAttribute]
public CompactMap`2<IPsiSourceFile, FileDependenciesPerFile> get_FileDependencies();
    public sealed virtual object Load(IProgressIndicator progress, bool enablePersistence);
    public sealed virtual void MergeLoaded(object data);
    protected virtual void BeforeAttach();
    public sealed virtual void Save(IProgressIndicator progress, bool enablePersistence);
    public sealed virtual void MarkAsDirty(IPsiSourceFile sourceFile);
    public sealed virtual bool get_HasDirtyFiles();
    protected virtual bool DoNotRecomputeFile(IPsiSourceFile sourceFile);
    public sealed virtual bool UpToDate(IPsiSourceFile sourceFile);
    public sealed virtual object Build(IPsiSourceFile sourceFile, bool isStartup);
    private static Diff ComputeDiff(FileDependenciesPerFile deps1, FileDependenciesPerFile deps2);
    public sealed virtual void Merge(IPsiSourceFile sourceFile, object builtPart);
    public sealed virtual void Drop(IPsiSourceFile sourceFile);
    public sealed virtual void OnPsiChange(ITreeNode elementContainingChanges, PsiChangedElementType type);
    public sealed virtual void OnDocumentChange(IPsiSourceFile sourceFile, ProjectFileDocumentCopyChange args);
    public sealed virtual void SyncUpdate(bool underTransaction);
    public sealed virtual void Dump(TextWriter writer, IPsiSourceFile sourceFile);
    protected virtual bool Accepts(IPsiSourceFile sourceFile);
    private void DropFile(IPsiSourceFile sourceFile);
    protected virtual void FileAdded(IPsiSourceFile sourceFile);
    protected virtual void FileRemoved(IPsiSourceFile sourceFile);
    private void HandleRemove(IFileDependency oldPath);
    private void HandleAdd(IFileDependency path);
    protected IDisposable UsingBatch();
    public IEnumerable`1<IFileDependency> FlushPreliminaryDependencies();
    [CompilerGeneratedAttribute]
private bool <Load>b__21_0();
    [CompilerGeneratedAttribute]
private FileDependenciesPerFile <Load>b__21_1(IPsiSourceFile file, BinaryReader reader);
}
public abstract class JetBrains.ReSharper.Psi.Modules.ExternalFileModules.DependentFilesModuleFactory : AdditionalFilesModuleFactoryBase {
    private static string CacheFolderName;
    private Task`1<ExternalFilesSetData> myLoadTask;
    private ISolutionLoadTasksScheduler myScheduler;
    private IGroupingEventFactory myGroupingEventFactory;
    private FileExistenceCacheManager myFileExistenceCacheManager;
    private IPsiConfiguration myConfiguration;
    private IFileDependencyFactory myFileDependencyFactory;
    private DefaultFileDependencyCandidatesTracker myDefaultFileDependencyCandidatesTracker;
    private bool myStateSaved;
    private SafeFileThrowAwayAccess myFileAccess;
    private bool myLoaded;
    private ISimpleSignal myCacheLoadedSignal;
    private long myLastCheckSolutionFileChangesRequest;
    private bool myCheckSourceFilesRequested;
    private IGroupingEvent myChangesGroupingEvent;
    private int mySuspendedFlushChangesDeep;
    private bool myIsCheckAccessibilityScheduled;
    private IProperty`1<bool> myIsGoodTimeToResolve;
    private IProperty`1<bool> myInitialized;
    private ConcurrentQueue`1<Action> myOnChangesPropagatedHandlers;
    private SynchronizationPoint mySyncPoint;
    private Lazy`1<ExternalFilesSet> myFilesSet;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <IsDirty>k__BackingField;
    private static int ourCounter;
    public ExternalFilesSet FilesSet { get; }
    public IProperty`1<bool> IsDirty { get; }
    protected bool EnableFlushMinorChanges { get; }
    protected string FileName { get; }
    private IProperty`1<bool> JetBrains.ReSharper.Psi.Modules.ExternalFileModules.IFileDependenciesSet.IsGoodTimeToResolve { get; }
    protected DependentFilesModuleFactory(Lifetime lifetime, ILogger logger, ISolutionLoadTasksScheduler scheduler, IShellLocks locks, IGroupingEventFactory groupingEventFactory, ChangeManager changeManager, IProjectFileExtensions extensions, PsiProjectFileTypeCoordinator coordinator, ISolution solution, IPsiConfiguration configuration, IPsiModuleOnFileSystemPaths module, SynchronizationPoints synchronizationPoints, IFileDependencyFactory fileDependencyFactory, IEnumerable`1<IFileDependencyCandidatesTracker> candidatesTrackers, DefaultFileDependencyCandidatesTracker defaultFileDependencyCandidatesTracker, FileExistenceCacheManager fileExistenceCacheManager);
    public ExternalFilesSet get_FilesSet();
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_IsDirty();
    protected virtual bool get_EnableFlushMinorChanges();
    private sealed virtual override void JetBrains.Application.Extensibility.IComponentWithAdditionalInitOnAnyThread.InitOnAnyThread();
    private void OnChanges();
    protected void FireChangesEvent(string source);
    public IExternalPsiSourceFileFactory CreateExternalPsiSourceFileFactory();
    public Task`1<bool> CheckSolutionFileChanges(bool checkSourceFiles, bool allowAsync);
    protected abstract virtual string get_FileName();
    public virtual object Execute(IChangeMap changeMap);
    private Task`1<bool> FlushChanges();
    private PsiModuleChangeBuilder FlushChanges(bool fireChange, object changeDescription);
    private ExternalFilesSetData WaitForLoad();
    protected virtual void InvalidateState();
    protected virtual void OnChangesPropagated(object n);
    public void AttachActivePaths(DependentFilesCacheBase cache, Lifetime lifetime);
    private void OnActivePathAdded(IFileDependency added);
    private void OnActivePathRemoved(Lifetime lifetime, IFileDependency removed, IProperty`1<bool> batch);
    public void AdviseCacheLoaded(Lifetime lifetime, Action action);
    public sealed virtual VirtualFileSystemPath Resolve(IFileDependency dependency, IFileDependenciesResolveSession resolveSession);
    public sealed virtual VirtualFileSystemPath Resolve(IPsiSourceFile sourceFile, string dependencyValue, IFileDependenciesResolveSession resolveSession);
    public sealed virtual VirtualFileSystemPath GetCachedResolveResult(IPsiSourceFile sourceFile, string dependencyValue);
    public sealed virtual IFileDependency Create(IPsiSourceFile sourceFile, string dependencyValue);
    public sealed virtual IFileDependency Create(IPsiSourceFile sourceFile, VirtualFileSystemPath fixedPath);
    private sealed virtual override IFileDependenciesResolveSession JetBrains.ReSharper.Psi.Modules.ExternalFileModules.IFileDependenciesSet.CreateResolveSession();
    private sealed virtual override IProperty`1<bool> JetBrains.ReSharper.Psi.Modules.ExternalFileModules.IFileDependenciesSet.get_IsGoodTimeToResolve();
    protected virtual bool MustAlwaysHaveAdditionalFile(VirtualFileSystemPath oldLocation);
    private IDisposable SuspendedFlushChanges(bool checkOnDispose);
    [CompilerGeneratedAttribute]
private void <OnChanges>b__31_0();
    [CompilerGeneratedAttribute]
private void <FireChangesEvent>b__32_0(Lifetime _);
    [CompilerGeneratedAttribute]
private IPsiSourceFileProperties <CreateExternalPsiSourceFileFactory>b__33_0(PsiSourceFileFromPath _);
}
public class JetBrains.ReSharper.Psi.Modules.ExternalFileModules.ExternalFileDependencyProperties : object {
    public bool ShouldBuildPsi { get; }
    public bool IsGeneratedFile { get; }
    public bool IsICacheParticipant { get; }
    public bool ProvidesCodeModel { get; }
    public bool IsNonUserFile { get; }
    public sealed virtual bool get_ShouldBuildPsi();
    public sealed virtual bool get_IsGeneratedFile();
    public sealed virtual bool get_IsICacheParticipant();
    public sealed virtual bool get_ProvidesCodeModel();
    public sealed virtual bool get_IsNonUserFile();
    public sealed virtual IEnumerable`1<string> GetPreImportedNamespaces();
    public sealed virtual string GetDefaultNamespace();
    public sealed virtual ICollection`1<PreProcessingDirective> GetDefines();
    public sealed virtual string GetExplanation();
}
public class JetBrains.ReSharper.Psi.Modules.ExternalFileModules.ExternalFilesSet : object {
    private static int Version;
    private TimeSpan myLockTimeout;
    private ReaderWriterLockSlim myLock;
    private Lifetime myLifetime;
    private ILogger myLogger;
    private ISolution mySolution;
    private FileExistenceCacheManager myFileExistenceCacheManager;
    private IEnumerable`1<IFileDependencyCandidatesTracker> myCandidatesTrackers;
    private DefaultFileDependencyCandidatesTracker myDefaultFileDependencyCandidatesTracker;
    private HistorySet`1<VirtualFileSystemPath> myExternalFiles;
    private HashMap`2<IFileDependency, VirtualFileSystemPath> myFileDependencies;
    private OneToSetMap`2<VirtualFileSystemPath, IFileDependency> myFileBackRefs;
    private long myLastCheckFilesAccessibilityRequest;
    private IGroupingEvent myCheckAccessibilityGroupingEvent;
    private IGroupingEvent myNewUnprocessedItemGroupingEvent;
    private CollectionEvents`1<IFileDependency> myUnprocessedItems;
    private AsyncItemsProcessor`1<Action`1<FileExistenceCache>> myUpdateActionsProcessor;
    private IProperty`1<bool> myAsyncAllowed;
    public IProperty`1<bool> HasChanges;
    public IProperty`1<bool> HasMinorChanges;
    public IProperty`1<bool> IsUnprocessedItemsEmpty;
    public IReadonlyCollectionEvents`1<IFileDependency> UnprocessedItems { get; }
    public bool IsLoaded { get; }
    internal ExternalFilesSet(Lifetime lifetime, ILogger logger, ISolution solution, IGroupingEventFactory groupingEventFactory, IEnumerable`1<IFileDependencyCandidatesTracker> candidatesTrackers, DefaultFileDependencyCandidatesTracker defaultFileDependencyCandidatesTracker, FileExistenceCacheManager fileExistenceCacheManager);
    public IReadonlyCollectionEvents`1<IFileDependency> get_UnprocessedItems();
    private void ProcessAsyncUpdateAction(Action`1<FileExistenceCache> action);
    private void ProcessAsyncItems();
    public void QueueUpdateAction(Action`1<FileExistenceCache> action);
    public ISet`1<IFileDependency> GetUnprocessedItemsSnapshot();
    public ISet`1<IFileDependency> GetItemsSnapshot();
    public bool get_IsLoaded();
    public void InitEmpty();
    public Pair`2<ICollection`1<VirtualFileSystemPath>, ICollection`1<VirtualFileSystemPath>> CommitDiff();
    public static ExternalFilesSetData Load(SafeFileThrowAwayAccess fileAccess, IFileDependencyFactory fileDependencyFactory);
    public void Load(ExternalFilesSetData data, IExternalPsiSourceFileFactory sourceFileFactory);
    public void Save(SafeFileThrowAwayAccess filesAccess, bool dry);
    public void Clear();
    public bool Contains(VirtualFileSystemPath file);
    internal IFileDependency TryGet(IFileDependency dependency);
    private bool AsyncAllowed(IFileDependency fileDependency);
    public void Add(IFileDependency fileDependency, bool sync);
    private bool AddAsync(IFileDependency fileDependency);
    private void AddSync(IFileDependency fileDependency, FileExistenceCache fileExistenceCache);
    public void Replace(IEnumerable`1<IFileDependency> fileDependencies, Func`2<IFileDependency, bool> allowAsync);
    public void Remove(IFileDependency fileDependency);
    public void RemoveInternal(IFileDependency fileDependency);
    public void Update(IFileDependency fileDependency, bool sync, bool invalidate, FileExistenceCache fileExistenceCache);
    public void Update(VirtualFileSystemPath file, bool sync, FileExistenceCache fileExistenceCache);
    public void UpdateInterruptable(bool checkSourceFiles, ISet`1<IFileDependency> items, FileExistenceCache fileExistenceCache, bool checkUnprocessedItems);
    internal void ScheduleCheckFilesAccessibility();
    private void CheckFilesAccessibility();
    private IDisposable GetInterruptableActivityCookie(bool checkUnprocessedItems);
    private void UpdateSync(IFileDependency fileDependency, VirtualFileSystemPath oldRef, Predicate`1<VirtualFileSystemPath> isFileExists, bool force);
    private void UpdateInternal(IFileDependency fileDependency, VirtualFileSystemPath oldRef, Predicate`1<VirtualFileSystemPath> isFileExists, bool force);
    private VirtualFileSystemPath ProcessFileDependency(IFileDependency fileDependency, VirtualFileSystemPath exclude, Predicate`1<VirtualFileSystemPath> isFileExists, bool add);
    [CompilerGeneratedAttribute]
private bool <ProcessAsyncItems>b__25_0();
    [CompilerGeneratedAttribute]
private void <Save>b__35_0(BinaryWriter writer);
    [CompilerGeneratedAttribute]
private bool <GetInterruptableActivityCookie>b__51_0();
    [CompilerGeneratedAttribute]
private bool <GetInterruptableActivityCookie>b__51_1();
}
public class JetBrains.ReSharper.Psi.Modules.ExternalFileModules.ExternalFilesSetData : object {
    public HistorySet`1<VirtualFileSystemPath> ExternalFiles;
    private List`1<ExternalFilesSetDataItem> myItems;
    internal ExternalFilesSetData(HistorySet`1<VirtualFileSystemPath> externalFiles, List`1<ExternalFilesSetDataItem> items);
    public HashMap`2<IFileDependency, VirtualFileSystemPath> LoadFileDependencies(IExternalPsiSourceFileFactory sourceFileFactory);
}
[DebuggerDisplayAttribute("{FileDependencyDescription} ({FileRef})")]
internal class JetBrains.ReSharper.Psi.Modules.ExternalFileModules.ExternalFilesSetDataItem : object {
    public IFileDependencyDescription FileDependencyDescription;
    public VirtualFileSystemPath FileRef;
    public ExternalFilesSetDataItem(IFileDependencyDescription fileDependencyDescription, VirtualFileSystemPath fileRef);
}
internal class JetBrains.ReSharper.Psi.Modules.ExternalFileModules.ExternalPsiSourceFileFactoryCookie : object {
    [ThreadStaticAttribute]
private static Stack`1<IDictionary`2<VirtualFileSystemPath, IPsiSourceFile>> ourSourceFiles;
    public static IPsiSourceFile CreateExternalPsiSourceFile(VirtualFileSystemPath path, Func`1<IPsiSourceFile> f);
    public sealed virtual void Dispose();
}
internal class JetBrains.ReSharper.Psi.Modules.ExternalFileModules.ExternalPsiSourceFileFromPath : PsiSourceFileFromPath {
    public ExternalPsiSourceFileFromPath(IProjectFileExtensions projectFileExtensions, PsiProjectFileTypeCoordinator projectFileTypeCoordinator, IPsiModule module, VirtualFileSystemPath path, Func`2<PsiSourceFileFromPath, bool> validityCheck, Func`2<PsiSourceFileFromPath, IPsiSourceFileProperties> propertiesFactory, DocumentManager documentManager, IModuleReferenceResolveContext resolveContext);
}
public class JetBrains.ReSharper.Psi.Modules.ExternalFileModules.FileDependenciesPerFile : object {
    [CompilerGeneratedAttribute]
private IList`1<IFileDependency> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasDependencies>k__BackingField;
    public IList`1<IFileDependency> Files { get; }
    public bool HasDependencies { get; private set; }
    public FileDependenciesPerFile(IList`1<IFileDependency> files, bool hasDependencies);
    [CompilerGeneratedAttribute]
public IList`1<IFileDependency> get_Files();
    [CompilerGeneratedAttribute]
public bool get_HasDependencies();
    [CompilerGeneratedAttribute]
private void set_HasDependencies(bool value);
    public FileDependenciesPerFile Combine(FileDependenciesPerFile with);
    public void Read(BinaryReader reader, IFileDependencyFactory dependencyFactory, IPsiSourceFile sourceFile);
    public void Write(BinaryWriter writer);
}
public class JetBrains.ReSharper.Psi.Modules.ExternalFileModules.FileExistenceCache : object {
    private Dictionary`2<VirtualFileSystemPath, bool> myFiles;
    private Dictionary`2<VirtualFileSystemPath, bool> myDirectories;
    public FileExistenceCache(ISolution solution);
    public bool IsFileExists(VirtualFileSystemPath path);
    private bool IsDirectoryExists(VirtualFileSystemPath path);
    private bool IsExistsInternal(VirtualFileSystemPath path, bool dir);
}
[SolutionInstanceComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Modules.ExternalFileModules.FileExistenceCacheManager : object {
    protected ISolution Solution;
    public FileExistenceCacheManager(ISolution solution);
    public virtual FileExistenceCache GetFileExistenceCache();
}
public class JetBrains.ReSharper.Psi.Modules.ExternalFileModules.HistorySet`1 : object {
    private HashSet`1<T> myAddedElements;
    private HashSet`1<T> myRemovedElements;
    private HashSet`1<T> myPreviousRevision;
    private ReaderWriterLockSlim myLock;
    public int Count { get; }
    public bool HasChanges { get; }
    public int get_Count();
    public bool get_HasChanges();
    public Pair`2<ICollection`1<T>, ICollection`1<T>> CommitDiff();
    public void Add(T element);
    public void Remove(T element);
    public IReadOnlyList`1<T> GetSnapshot();
    public bool Contains(T item);
    public void Clear();
}
public interface JetBrains.ReSharper.Psi.Modules.ExternalFileModules.IDependentFilesBuilder {
    public int Priority { get; }
    public abstract virtual FileDependenciesPerFile Build(IPsiSourceFile sourceFile);
    public abstract virtual int get_Priority();
}
public interface JetBrains.ReSharper.Psi.Modules.ExternalFileModules.IExternalPsiSourceFile {
}
public interface JetBrains.ReSharper.Psi.Modules.ExternalFileModules.IExternalPsiSourceFileFactory {
    public abstract virtual IEnumerable`1<IPsiSourceFile> GetPsiSourceFiles(VirtualFileSystemPath path, string projectFilePersistentId, string psiFilePersistentId);
}
public interface JetBrains.ReSharper.Psi.Modules.ExternalFileModules.IFileDependenciesResolveSession {
}
public interface JetBrains.ReSharper.Psi.Modules.ExternalFileModules.IFileDependenciesSet {
    public IProperty`1<bool> IsGoodTimeToResolve { get; }
    public abstract virtual VirtualFileSystemPath Resolve(IFileDependency dependency, IFileDependenciesResolveSession resolveSession);
    public abstract virtual VirtualFileSystemPath Resolve(IPsiSourceFile sourceFile, string dependencyValue, IFileDependenciesResolveSession resolveSession);
    [CanBeNullAttribute]
public abstract virtual VirtualFileSystemPath GetCachedResolveResult(IPsiSourceFile sourceFile, string dependencyValue);
    public abstract virtual IFileDependency Create(IPsiSourceFile sourceFile, string dependencyValue);
    public abstract virtual IFileDependency Create(IPsiSourceFile sourceFile, VirtualFileSystemPath fixedPath);
    public abstract virtual IFileDependenciesResolveSession CreateResolveSession();
    public abstract virtual IProperty`1<bool> get_IsGoodTimeToResolve();
}
public interface JetBrains.ReSharper.Psi.Modules.ExternalFileModules.IFileDependency {
    [CanBeNullAttribute]
public IPsiSourceFile SourceFile { get; }
    public abstract virtual IPsiSourceFile get_SourceFile();
    [NotNullAttribute]
public abstract virtual VirtualFileSystemPath GetPath(bool useCache, Predicate`1<VirtualFileSystemPath> existenceCheck);
    public abstract virtual bool IsPossibleCandidate(VirtualFileSystemPath path, Predicate`1<VirtualFileSystemPath> isFileExists);
    public abstract virtual void Invalidate();
    public abstract virtual bool IsValidCachedPath(VirtualFileSystemPath path, bool fileExists);
    public abstract virtual void Write(BinaryWriter writer);
}
public interface JetBrains.ReSharper.Psi.Modules.ExternalFileModules.IFileDependencyCandidatesTracker {
    public abstract virtual void Register(IFileDependency fileDependency);
    public abstract virtual void Unregister(IFileDependency fileDependency);
    public abstract virtual void AddDependencyCandidate(IFileDependency fileDependency, VirtualFileSystemPath candidatePath);
    public abstract virtual void ClearDependencyCandidates(IFileDependency fileDependency);
    public abstract virtual void ClearDependencyCaches(IFileDependency fileDependency);
}
public interface JetBrains.ReSharper.Psi.Modules.ExternalFileModules.IFileDependencyDescription {
    public abstract virtual IEnumerable`1<IFileDependency> GetFileDependencies(IExternalPsiSourceFileFactory sourceFileFactory, VirtualFileSystemPath initial);
}
public interface JetBrains.ReSharper.Psi.Modules.ExternalFileModules.IFileDependencyFactory {
    [NotNullAttribute]
public abstract virtual IFileDependency CreateFileDependency(IPsiSourceFile sourceFile, string dependencyPath);
    [NotNullAttribute]
public abstract virtual IFileDependency CreateFileDependency(IPsiSourceFile sourceFile, VirtualFileSystemPath fixedPath);
    public abstract virtual ISourceFileDescription CreateSourceFileDescription(VirtualFileSystemPath sourceFileLocation, string sourceProjectFilePersistentId, string psiSourceFilePersistentId);
    public abstract virtual IFileDependency Read(BinaryReader reader, IPsiSourceFile sourceFile);
    public abstract virtual IFileDependencyDescription Read(BinaryReader reader, ISourceFileDescription sourceFileDescription);
}
public interface JetBrains.ReSharper.Psi.Modules.ExternalFileModules.IFileDependencyWithNodeJsCandidates {
    [NotNullAttribute]
public IPsiSourceFile SourceFile { get; }
    public abstract virtual IPsiSourceFile get_SourceFile();
}
public interface JetBrains.ReSharper.Psi.Modules.ExternalFileModules.IFixedFileDependency {
    public abstract virtual IEnumerable`1<VirtualFileSystemPath> GetCandidatePaths();
}
public interface JetBrains.ReSharper.Psi.Modules.ExternalFileModules.IPsiModuleOnFileSystemPaths {
    public abstract virtual bool ContainsPath(VirtualFileSystemPath path);
    public abstract virtual bool TryGetFileByPath(VirtualFileSystemPath path, IPsiSourceFile& file);
    public abstract virtual void Add(VirtualFileSystemPath path, IPsiSourceFile file, Action`1<FileSystemChangeDelta> processFileChange);
    public abstract virtual void Remove(VirtualFileSystemPath path);
}
public interface JetBrains.ReSharper.Psi.Modules.ExternalFileModules.IResourceModule {
}
public interface JetBrains.ReSharper.Psi.Modules.ExternalFileModules.ISourceFileDescription {
    public abstract virtual IEnumerable`1<IPsiSourceFile> GetPsiSourceFiles(IExternalPsiSourceFileFactory sourceFileFactory);
}
public interface JetBrains.ReSharper.Psi.Modules.ExternalFileModules.ISourceFileWithoutDependencies {
}
public class JetBrains.ReSharper.Psi.Modules.ExternalFileModules.PsiModuleOnFileSystemPaths : UserDataHolder {
    private ISolution mySolution;
    private string myPersistentId;
    private IFileSystemTracker myFileSystemTracker;
    private Lifetime myLifetime;
    private PsiSourceFileWithLocationTracker myPsiSourceFileWithLocationTracker;
    private bool myWatchOutsideSolution;
    private CompactMap`2<VirtualFileSystemPath, Pair`2<IPsiSourceFile, LifetimeDefinition>> mySourceFiles;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetFrameworkId <TargetFrameworkId>k__BackingField;
    private static List`1<string> ourItemsToSkip;
    public string Name { get; }
    public string DisplayName { get; }
    public TargetFrameworkId TargetFrameworkId { get; }
    public PsiLanguageType PsiLanguage { get; }
    public ProjectFileType ProjectFileType { get; }
    public IModule ContainingProjectModule { get; }
    public IEnumerable`1<IPsiSourceFile> SourceFiles { get; }
    public PsiModuleOnFileSystemPaths(ISolution solution, string moduleName, string persistentId, TargetFrameworkId targetFrameworkId, IFileSystemTracker fileSystemTracker, Lifetime lifetime, PsiSourceFileWithLocationTracker psiSourceFileWithLocationTracker, bool watchOutsideSolution);
    private static PsiModuleOnFileSystemPaths();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual string get_DisplayName();
    [CompilerGeneratedAttribute]
public sealed virtual TargetFrameworkId get_TargetFrameworkId();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual ISolution GetSolution();
    public sealed virtual PsiLanguageType get_PsiLanguage();
    public sealed virtual ProjectFileType get_ProjectFileType();
    public sealed virtual IEnumerable`1<IPsiModuleReference> GetReferences(IModuleReferenceResolveContext moduleReferenceResolveContext);
    public sealed virtual IModule get_ContainingProjectModule();
    public sealed virtual IEnumerable`1<IPsiSourceFile> get_SourceFiles();
    public sealed virtual bool ContainsPath(VirtualFileSystemPath path);
    public sealed virtual bool TryGetFileByPath(VirtualFileSystemPath path, IPsiSourceFile& file);
    public sealed virtual void Add(VirtualFileSystemPath path, IPsiSourceFile file, Action`1<FileSystemChangeDelta> processFileChange);
    public sealed virtual void Remove(VirtualFileSystemPath path);
    private bool ShouldWatchFileChanges(VirtualFileSystemPath path);
    public sealed virtual ICollection`1<PreProcessingDirective> GetAllDefines();
    public sealed virtual bool IsValid();
    public sealed virtual string GetPersistentID();
}
[ModuleReferencerAttribute("16")]
public class JetBrains.ReSharper.Psi.Modules.GenericModuleReferencer : object {
    public virtual bool ReferenceModule(IPsiModule module, IPsiModule moduleToReference);
    public virtual bool ReferenceModuleWithType(IPsiModule module, ITypeElement typeToReference);
    public virtual bool CanReferenceModule(IPsiModule module, IPsiModule moduleToReference, UserDataHolder context);
    private static Nullable`1<bool> TryIsPlatformsCompatible(IPsiModule module, IPsiModule moduleToReference);
    private static bool CanModuleBeReferenced(IPsiModule psiModule);
    [NotNullAttribute]
private static JetHashSet`1<IPsiModule> CollectReferencesDeep(IPsiModule module);
    [NotNullAttribute]
private static IList`1<IAssemblyPsiModule> GetCorLibReferences(IEnumerable`1<IPsiModule> projectReferences);
}
public interface JetBrains.ReSharper.Psi.Modules.IAssemblyPsiModule {
    [NotNullAttribute]
public IPsiAssembly Assembly { get; }
    public abstract virtual IPsiAssembly get_Assembly();
}
public interface JetBrains.ReSharper.Psi.Modules.IDecorableProjectPsiModule {
    public IList`1<IPsiModuleDecorator> Decorators { get; public set; }
    public abstract virtual IList`1<IPsiModuleDecorator> get_Decorators();
    public abstract virtual void set_Decorators(IList`1<IPsiModuleDecorator> value);
}
public interface JetBrains.ReSharper.Psi.Modules.IMiscFilesProjectPsiModuleProvider {
    public abstract virtual IEnumerable`1<IPsiModule> GetModules();
    public abstract virtual IEnumerable`1<IPsiSourceFile> GetPsiSourceFilesFor(IProjectFile projectFile);
    public abstract virtual void OnProjectFileChanged(IProjectFile projectFile, ChangeType changeType, PsiModuleChangeBuilder changeBuilder, VirtualFileSystemPath oldLocation);
}
[DerivedComponentsInstantiationRequirementAttribute("1")]
public interface JetBrains.ReSharper.Psi.Modules.IModuleReferencer {
    public abstract virtual bool CanReferenceModule(IPsiModule module, IPsiModule moduleToReference, UserDataHolder context);
    public abstract virtual bool ReferenceModule(IPsiModule module, IPsiModule moduleToReference);
    public abstract virtual bool ReferenceModuleWithType(IPsiModule module, ITypeElement typeToReference);
}
public interface JetBrains.ReSharper.Psi.Modules.IProjectPsiModule {
    [NotNullAttribute]
public IProject Project { get; }
    public abstract virtual IProject get_Project();
}
public interface JetBrains.ReSharper.Psi.Modules.IProjectPsiModuleHandler {
    [CanBeNullAttribute]
public IChangeProvider ChangeProvider { get; }
    [CanBeNullAttribute]
public IProjectPsiModule PrimaryModule { get; }
    public abstract virtual IChangeProvider get_ChangeProvider();
    public abstract virtual IProjectPsiModule get_PrimaryModule();
    [NotNullAttribute]
public abstract virtual IList`1<IPsiModule> GetAllModules();
    public abstract virtual IEnumerable`1<IPsiModule> GetPsiModulesToReference(TargetFrameworkId targetFrameworkId);
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IEnumerable`1<IPsiSourceFile> GetPsiSourceFilesFor(IProjectFile projectFile);
    public abstract virtual void OnProjectPropertiesChanged(PsiModuleChangeBuilder changeBuilder);
    public abstract virtual void OnExternalModuleSetChanged(PsiModuleChangeBuilder changeBuilder, PsiModuleChange result);
    public abstract virtual void OnProjectFileChanged(IProjectFile projectFile, VirtualFileSystemPath oldLocation, ChangeType changeType, PsiModuleChangeBuilder changeBuilder);
    public abstract virtual bool InternalsVisibleTo(IPsiModule moduleTo, IPsiModule moduleFrom);
}
public interface JetBrains.ReSharper.Psi.Modules.IProjectPsiModuleProvider {
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IProjectPsiModuleHandler> TryCreate(Lifetime projectLifetime, IProject project);
}
public interface JetBrains.ReSharper.Psi.Modules.IProjectPsiModuleProviderFilter {
    [CanBeNullAttribute]
public abstract virtual Tuple`2<IProjectPsiModuleHandler, IPsiModuleDecorator> OverrideHandler(Lifetime lifetime, IProject project, IProjectPsiModuleHandler handler);
}
public interface JetBrains.ReSharper.Psi.Modules.IPsiModule {
    public string Name { get; }
    public string DisplayName { get; }
    [NotNullAttribute]
public TargetFrameworkId TargetFrameworkId { get; }
    [ObsoleteAttribute("Use with care. Semantics is a bit unclear for non-project modules")]
public PsiLanguageType PsiLanguage { get; }
    [ObsoleteAttribute("Use with care. Semantics is a bit unclear for non-project modules")]
public ProjectFileType ProjectFileType { get; }
    [CanBeNullAttribute]
public IModule ContainingProjectModule { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IPsiSourceFile> SourceFiles { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_DisplayName();
    public abstract virtual TargetFrameworkId get_TargetFrameworkId();
    [NotNullAttribute]
public abstract virtual IPsiServices GetPsiServices();
    [NotNullAttribute]
public abstract virtual ISolution GetSolution();
    public abstract virtual PsiLanguageType get_PsiLanguage();
    public abstract virtual ProjectFileType get_ProjectFileType();
    [ObsoleteAttribute("Do not call the method to obtain references. Use IPsiModules.GetModuleReferences")]
[NotNullAttribute]
public abstract virtual IEnumerable`1<IPsiModuleReference> GetReferences(IModuleReferenceResolveContext moduleReferenceResolveContext);
    public abstract virtual IModule get_ContainingProjectModule();
    public abstract virtual IEnumerable`1<IPsiSourceFile> get_SourceFiles();
    [NotNullAttribute]
public abstract virtual ICollection`1<PreProcessingDirective> GetAllDefines();
    public abstract virtual bool IsValid();
    [NotNullAttribute]
public abstract virtual string GetPersistentID();
}
public interface JetBrains.ReSharper.Psi.Modules.IPsiModuleDecorator {
    public abstract virtual IEnumerable`1<IPsiModuleReference> OverrideModuleReferences(IEnumerable`1<IPsiModuleReference> references);
    public abstract virtual IEnumerable`1<IPsiSourceFile> OverrideSourceFiles(IEnumerable`1<IPsiSourceFile> files);
}
public interface JetBrains.ReSharper.Psi.Modules.IPsiModuleFactory {
    public HybridCollection`1<IPsiModule> Modules { get; }
    public abstract virtual HybridCollection`1<IPsiModule> get_Modules();
}
public interface JetBrains.ReSharper.Psi.Modules.IPsiModuleReference {
    [NotNullAttribute]
public IPsiModule Module { get; }
    [NotNullAttribute]
public String[] ExternAliases { get; }
    public bool EmbedInteropTypes { get; }
    public abstract virtual IPsiModule get_Module();
    public abstract virtual String[] get_ExternAliases();
    public abstract virtual bool get_EmbedInteropTypes();
}
public interface JetBrains.ReSharper.Psi.Modules.IPsiModules {
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IPsiModule GetPrimaryPsiModule(IModule module, TargetFrameworkId targetFrameworkId);
    [PureAttribute]
public abstract virtual FrugalLocalList`1<IPsiSourceFile> GetPsiSourceFilesFor(IProjectFile projectFile);
    [PureAttribute]
public abstract virtual FrugalLocalList`1<IPsiSourceFile> GetUnsortedPsiSourceFilesFor(IProjectFile projectFile);
    [PureAttribute]
public abstract virtual FrugalLocalList`1<IPsiModule> GetPsiModulesToReference(IModule module, TargetFrameworkId targetFrameworkId);
    [CanBeNullAttribute]
public abstract virtual IPsiModuleReference GetModuleReference(IPsiModule fromModule, IPsiModule toModule, IModuleReferenceResolveContext context);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IPsiModuleReference> GetModuleReferences(IPsiModule fromModule, IEnumerable`1<IPsiModule> toAnyModule, IModuleReferenceResolveContext context);
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<IPsiModuleReference> GetModuleReferences(IPsiModule fromModule, IModuleReferenceResolveContext context);
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<IPsiModuleReference> GetReverseModuleReferences(IPsiModule toModule, IModuleReferenceResolveContext context);
    [NotNullAttribute]
public abstract virtual IList`1<IPsiModule> GetPsiModules(IProject project);
    public abstract virtual bool HasModule(IPsiModule module);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IPsiModule> GetModules();
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IPsiModule> GetSourceModules();
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IEnumerable`1<IAssemblyPsiModule> GetAssemblyModules();
    [CanBeNullAttribute]
public abstract virtual IProject TryGetProjectByOutputAssembly(IAssembly assembly);
    [CanBeNullAttribute]
public abstract virtual IProject TryGetProjectByReferenceAssembly(IAssembly assembly);
    [CanBeNullAttribute]
public abstract virtual IProject TryGetProjectByOutputOrReferenceAssembly(IAssembly assembly);
    [CanBeNullAttribute]
public abstract virtual IProject TryGetProjectByOutputAssembly(VirtualFileSystemPath assemblyPath);
    [CanBeNullAttribute]
public abstract virtual IProject TryGetProjectByReferenceAssembly(VirtualFileSystemPath assemblyPath);
    [CanBeNullAttribute]
public abstract virtual IProject TryGetProjectByOutputOrReferenceAssembly(VirtualFileSystemPath assemblyPath);
    [CanBeNullAttribute]
public abstract virtual IAssembly GetOutputAssemblyByProject(IProject project, TargetFrameworkId targetFrameworkId);
    [CanBeNullAttribute]
public abstract virtual Tuple`2<IProject, TargetFrameworkId> TryGetProjectAndTargetFrameworkIdByOutputAssembly(VirtualFileSystemPath assemblyPath);
    [CanBeNullAttribute]
public abstract virtual Tuple`2<IProject, TargetFrameworkId> TryGetProjectAndTargetFrameworkIdByReferenceAssembly(VirtualFileSystemPath assemblyPath);
    [CanBeNullAttribute]
public abstract virtual Tuple`2<IProject, TargetFrameworkId> TryGetProjectAndTargetFrameworkIdByOutputOrReferenceAssembly(VirtualFileSystemPath assemblyPath);
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IEnumerable`1<IAssemblyPsiModule> GetAssemblyPsiModuleByName(AssemblyNameInfo name);
    public abstract virtual bool IsSourceProject(IProject project);
    public abstract virtual void Dump(TextWriter to, Action`3<IPsiSourceFile, TextWriter, int> dumpFiles, Func`2<IPsiSourceFile, string> fileSortString, bool dumpPlatformId, Predicate`1<IPsiModule> dumpNonProject);
    public abstract virtual void DumpProject(TextWriter to, IProject project, Func`2<IPsiModule, string> moduleNameDumper, Action`3<IPsiSourceFile, TextWriter, int> dumpFiles, Func`2<IPsiSourceFile, string> fileSortString, bool dumpPlatformId);
    public abstract virtual bool CanBeVisibleToSolution(IClrDeclaredElement element);
    [CanBeNullAttribute]
public abstract virtual IPsiModule GetById(string persistentId);
    public abstract virtual string DeduplicatePersistentId(string persistentId);
}
public interface JetBrains.ReSharper.Psi.Modules.IPsiSourceFileSorter {
    public abstract virtual FrugalLocalList`1<IPsiSourceFile> SortFilesByContext(IProjectFile projectFile, FrugalLocalList`1<IPsiSourceFile> sourceFiles);
    public abstract virtual void AddContextChecker(Lifetime lifetime, Func`3<IProjectFile, IPsiSourceFile, bool> checker);
}
[BaseTypeRequiredAttribute("JetBrains.ReSharper.Psi.Modules.IMiscFilesProjectPsiModuleProvider")]
[AttributeUsageAttribute("4")]
[MeansImplicitUseAttribute]
[ComponentInstantiationAttribute("-32758")]
public class JetBrains.ReSharper.Psi.Modules.MiscFilesProjectPsiModuleProviderAttribute : SolutionComponentAttribute {
    public MiscFilesProjectPsiModuleProviderAttribute(Instantiation instantiation);
}
[SolutionComponentAttribute("10")]
internal class JetBrains.ReSharper.Psi.Modules.MiscFilesProjectPsiModuleProviderFactory : object {
    private MiscFilesProjectProjectPsiModuleHandler myMiscFilesProjectProjectPsiModuleHandler;
    public MiscFilesProjectPsiModuleProviderFactory(Lifetime lifetime, ISolution solution, IEnumerable`1<IMiscFilesProjectPsiModuleProvider> providers, PsiProjectFileTypeCoordinator psiProjectFileTypeCoordinator, PsiSourceFilePropertiesManager psiSourceFilePropertiesManager, DocumentManager documentManger, ChangeManager changeManager, SandboxFilesManager sandboxFilesManager);
    public sealed virtual IEnumerable`1<IProjectPsiModuleHandler> TryCreate(Lifetime projectLifetime, IProject project);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Modules.ModuleExtensions : object {
    [ExtensionAttribute]
public static VirtualFileSystemPath GetLocation(IModule module);
}
[MeansImplicitUseAttribute]
[AttributeUsageAttribute("4")]
[BaseTypeRequiredAttribute("JetBrains.ReSharper.Psi.Modules.IModuleReferencer")]
public class JetBrains.ReSharper.Psi.Modules.ModuleReferencerAttribute : PsiSharedComponentAttribute {
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    public int Priority { get; public set; }
    public ModuleReferencerAttribute(Instantiation instantiation);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Priority();
    [CompilerGeneratedAttribute]
public void set_Priority(int value);
}
[PsiSharedComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Modules.ModuleReferencerService : object {
    [NotNullAttribute]
private IOrderedImmutableList`1<IModuleReferencer> myModuleReferencers;
    public ModuleReferencerService(Lifetime lifetime, IOrderedImmutableList`2<IModuleReferencer, ModuleReferencerAttribute> referencers);
    public bool CanReferenceModule(IPsiModule module, IPsiModule moduleToReference, UserDataHolder context);
    public bool ReferenceModule(IPsiModule module, IPsiModule moduleToReference);
    public bool ReferenceModuleWithType(IPsiModule module, ITypeElement typeToReference);
}
public interface JetBrains.ReSharper.Psi.Modules.MsBuild.IMsbuildGeneratedFilePropertiesProvider {
    public double Order { get; }
    public abstract virtual double get_Order();
    [NotNullAttribute]
public abstract virtual IPsiSourceFileProperties GetPsiProperties(IPsiSourceFileProperties prevProperties, IProject project, IPsiSourceFileWithLocation sourceFile);
}
public class JetBrains.ReSharper.Psi.Modules.MsBuild.MsbuildGeneratedFilesProjectHandler : DelegatingProjectPsiModuleHandler {
    private IShellLocks myLocks;
    private IMsBuildDataStorage myDataStorage;
    private ILogger myLogger;
    private Lifetime myLifetime;
    private IProject myProject;
    private ChangeManager myChangeManager;
    private Dictionary`2<VirtualFileSystemPath, Pair`2<IPsiSourceFileWithLocation, LifetimeDefinition>> myGeneratedFiles;
    private IProjectFileExtensions myProjectFileExtensions;
    private PsiProjectFileTypeCoordinator myProjectFileTypeCoordinator;
    private Func`2<PsiSourceFileFromPath, IPsiSourceFileProperties> myPropertiesFactory;
    private PsiSourceFileWithLocationTracker myPsiSourceFileWithLocationTracker;
    private DocumentManager myDocumentManager;
    private IModuleReferenceResolveContext myResolveContext;
    private VirtualFileSystemPath myProjectFileLocation;
    public IEnumerable`1<IPsiSourceFile> GeneratedFiles { get; }
    public MsbuildGeneratedFilesProjectHandler(Lifetime lifetime, IProject project, IProjectPsiModuleHandler handler, ChangeManager changeManager, IShellLocks locks, IMsBuildDataStorage dataStorage, ILogger logger, IProjectFileExtensions projectFileExtensions, PsiProjectFileTypeCoordinator projectFileTypeCoordinator, DocumentManager documentManager, MsbuildGeneratedFilesProviderChangeListener changeListener, PsiSourceFileWithLocationTracker psiSourceFileWithLocationTracker, Func`2<PsiSourceFileFromPath, IPsiSourceFileProperties> propertiesFactory);
    public IEnumerable`1<IPsiSourceFile> get_GeneratedFiles();
    private void RebuildItems();
    private void CreateFileIfNecessary(VirtualFileSystemPath compileItemPath, PsiModuleChangeBuilder changeBuilder);
    private void OnFileSystemChange(FileSystemChangeDelta fileSystemChangeDelta, ExternalChangeType externalChangeType);
    private void RemoveFile(VirtualFileSystemPath filePath, PsiModuleChangeBuilder changeBuilder);
    private PsiSourceFileFromPath CreateGeneratedFile(IProjectPsiModuleHandler handler, VirtualFileSystemPath file);
    [CompilerGeneratedAttribute]
private bool <CreateGeneratedFile>b__21_0(PsiSourceFileFromPath f);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Modules.MsBuild.MsbuildGeneratedFilesProvider : object {
    private ChangeManager myChangeManager;
    private IShellLocks myLocks;
    private IMsBuildDataStorage myDataStorage;
    private ILogger myLogger;
    private DocumentManager myDocumentManager;
    private PsiProjectFileTypeCoordinator myProjectFileTypeCoordinator;
    private IProjectFileExtensions myProjectFileExtensions;
    private PsiSourceFileWithLocationTracker myPsiSourceFileWithLocationTracker;
    private MsbuildGeneratedFilesProviderChangeListener myChangeListener;
    private IList`1<IMsbuildGeneratedFilePropertiesProvider> myPropertiesProviders;
    public MsbuildGeneratedFilesProvider(ChangeManager changeManager, IShellLocks locks, IMsBuildDataStorage dataStorage, ILogger logger, DocumentManager documentManager, PsiProjectFileTypeCoordinator projectFileTypeCoordinator, IProjectFileExtensions projectFileExtensions, IFileSystemTracker fileSystemTracker, MsbuildGeneratedFilesProviderChangeListener changeListener, IEnumerable`1<IMsbuildGeneratedFilePropertiesProvider> propertiesProviders, PsiSourceFileWithLocationTracker psiSourceFileWithLocationTracker);
    public sealed virtual Tuple`2<IProjectPsiModuleHandler, IPsiModuleDecorator> OverrideHandler(Lifetime lifetime, IProject project, IProjectPsiModuleHandler handler);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Modules.MsBuild.MsbuildGeneratedFilesProviderChangeListener : object {
    private static TimeSpan UPDATE_INTERVAL;
    private int myChangeRequests;
    private JetHashSet`1<IProject> myChangedProjects;
    [CompilerGeneratedAttribute]
private ISignal`1<ICollection`1<IProject>> <ProjectsChanges>k__BackingField;
    public ISignal`1<ICollection`1<IProject>> ProjectsChanges { get; }
    public MsbuildGeneratedFilesProviderChangeListener(Lifetime lifetime, ChangeManager changeManager, ISolution solution, IShellLocks locks);
    private static MsbuildGeneratedFilesProviderChangeListener();
    [CompilerGeneratedAttribute]
public ISignal`1<ICollection`1<IProject>> get_ProjectsChanges();
    public void RequestChanges(Lifetime lifetime);
    [CompilerGeneratedAttribute]
private void <RequestChanges>b__7_0();
    [CompilerGeneratedAttribute]
private void <RequestChanges>b__7_1();
}
public class JetBrains.ReSharper.Psi.Modules.NoRetargetableComparer : object {
    public static IEqualityComparer`1<AssemblyNameInfo> Instance;
    private static NoRetargetableComparer();
    public sealed virtual bool Equals(AssemblyNameInfo x, AssemblyNameInfo y);
    public sealed virtual int GetHashCode(AssemblyNameInfo nameInfo);
}
internal class JetBrains.ReSharper.Psi.Modules.ProjectAssemblyPsiModule : UserDataHolder {
    [NotNullAttribute]
private IPsiServices myPsiServices;
    [NotNullAttribute]
private IPlatformManager myPlatformManager;
    [NotNullAttribute]
private PsiAssembly myAssembly;
    [NotNullAttribute]
private CachedProjectItemAnyChange`2<IProject, string> myPersistentID;
    private IModuleReferencesResolveStore myReferencesResolveStore;
    private AssemblyInfoDatabase myAssemblyInfoDatabase;
    private ResolveContextManager myResolveContextManager;
    private OutputAssemblies myOutputAssemblies;
    public string Name { get; }
    public string DisplayName { get; }
    public TargetFrameworkId TargetFrameworkId { get; }
    public PsiLanguageType PsiLanguage { get; }
    public ProjectFileType ProjectFileType { get; }
    public IModule ContainingProjectModule { get; }
    public IEnumerable`1<IPsiSourceFile> SourceFiles { get; }
    public IPsiAssembly Assembly { get; }
    public ProjectAssemblyPsiModule(IPsiServices psiServices, IPlatformManager platformManager, IModuleReferencesResolveStore referencesResolveStore, IAssembly assembly, AssemblyInfoDatabase assemblyInfoDatabase, ResolveContextManager resolveContextManager, OutputAssemblies outputAssemblies);
    public sealed virtual bool IsValid();
    public sealed virtual string GetPersistentID();
    public sealed virtual string get_Name();
    public sealed virtual string get_DisplayName();
    public sealed virtual TargetFrameworkId get_TargetFrameworkId();
    public sealed virtual ISolution GetSolution();
    public sealed virtual PsiLanguageType get_PsiLanguage();
    public sealed virtual ProjectFileType get_ProjectFileType();
    public sealed virtual IModule get_ContainingProjectModule();
    public sealed virtual IEnumerable`1<IPsiSourceFile> get_SourceFiles();
    [CanBeNullAttribute]
public IProject TryGetProject();
    public virtual IEnumerable`1<IPsiModuleReference> GetReferences(IModuleReferenceResolveContext resolveContext);
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual IPsiAssembly get_Assembly();
    public sealed virtual ICollection`1<PreProcessingDirective> GetAllDefines();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private string <.ctor>b__8_0(IProject _);
}
public abstract class JetBrains.ReSharper.Psi.Modules.ProjectPsiModuleBase : ConcurrentUserDataHolder {
    [NotNullAttribute]
private string myNameSuffix;
    [NotNullAttribute]
private IProject myProject;
    [NotNullAttribute]
private IPsiServices myPsiServices;
    [NotNullAttribute]
private PsiProjectFileTypeCoordinator myCoordinator;
    [CanBeNullAttribute]
private IProjectFileLanguageService myProjectFileService;
    private string myPersistentID;
    private Func`3<IProjectFile, IPsiSourceFile, bool> myCheckIsValidFunc;
    [CompilerGeneratedAttribute]
private Dictionary`2<IProjectFile, IPsiProjectFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetFrameworkId <TargetFrameworkId>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IPsiModuleDecorator> <Decorators>k__BackingField;
    [NotNullAttribute]
public Dictionary`2<IProjectFile, IPsiProjectFile> Files { get; }
    public string Name { get; }
    public string DisplayName { get; }
    public TargetFrameworkId TargetFrameworkId { get; }
    public PsiLanguageType PsiLanguage { get; }
    public ProjectFileType ProjectFileType { get; }
    public IModule ContainingProjectModule { get; }
    public IProject Project { get; }
    protected PsiProjectFileTypeCoordinator PsiProjectFileTypeCoordinator { get; }
    public IList`1<IPsiModuleDecorator> Decorators { get; public set; }
    public IEnumerable`1<IPsiSourceFile> SourceFiles { get; }
    protected ProjectPsiModuleBase(IProject project, string nameSuffix, PsiProjectFileTypeCoordinator coordinator, TargetFrameworkId targetFrameworkId);
    [CompilerGeneratedAttribute]
public Dictionary`2<IProjectFile, IPsiProjectFile> get_Files();
    public virtual string get_Name();
    private bool IsSingleTargetFrameworkId();
    public virtual string get_DisplayName();
    [CompilerGeneratedAttribute]
public sealed virtual TargetFrameworkId get_TargetFrameworkId();
    public sealed virtual string GetPersistentID();
    private string BuildPersistentID();
    public virtual PsiLanguageType get_PsiLanguage();
    public virtual ProjectFileType get_ProjectFileType();
    public sealed virtual IModule get_ContainingProjectModule();
    public sealed virtual bool IsValid();
    public sealed virtual IPsiServices GetPsiServices();
    public sealed virtual ISolution GetSolution();
    public sealed virtual IProject get_Project();
    protected PsiProjectFileTypeCoordinator get_PsiProjectFileTypeCoordinator();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IPsiModuleDecorator> get_Decorators();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Decorators(IList`1<IPsiModuleDecorator> value);
    protected virtual IEnumerable`1<IPsiSourceFile> GetSourceFiles();
    public sealed virtual IEnumerable`1<IPsiSourceFile> get_SourceFiles();
    protected abstract virtual IEnumerable`1<IPsiModuleReference> GetReferencesInternal();
    public sealed virtual IEnumerable`1<IPsiModuleReference> GetReferences(IModuleReferenceResolveContext moduleReferenceResolveContext);
    public virtual ICollection`1<PreProcessingDirective> GetAllDefines();
    public bool CheckIsValid(IProjectFile projectFile, IPsiSourceFile sourceFile);
    public Func`3<IProjectFile, IPsiSourceFile, bool> GetCheckIsValidFunc();
    public virtual string ToString();
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Modules.ProjectPsiModuleFactory : object {
    private Lifetime myLifetime;
    private ISolution mySolution;
    private ChangeManager myChangeManager;
    private ILogger myLogger;
    private IEnumerable`1<IProjectPsiModuleProvider> myProjectPsiModuleProviders;
    private IEnumerable`1<IProjectPsiModuleProviderFilter> myFilters;
    private Dictionary`2<IProject, Tuple`2<IList`1<IProjectPsiModuleHandler>, LifetimeDefinition>> myProjects;
    public ProjectPsiModuleFactory(Lifetime lifetime, ISolution solution, ChangeManager changeManager, ILogger logger, IEnumerable`1<IProjectPsiModuleProvider> psiModuleProviders, IEnumerable`1<IProjectPsiModuleProviderFilter> filters, ModuleReferenceResolveSync moduleReferenceResolve);
    public FrugalLocalList`1<IProjectPsiModuleHandler> TryGetHandlers(IProject project);
    [CanBeNullAttribute]
public IPsiModule TryGetModule(IProject project, TargetFrameworkId targetFrameworkId);
    public IEnumerable`1<KeyValuePair`2<IProject, IProjectPsiModuleHandler>> GetAllHandlers();
    private static ChangeType GetChangeType(ProjectModelChange change);
    private static Nullable`1<Pair`2<ChangeType, VirtualFileSystemPath>> MergeProjectFileChanges(IProjectFile projectFile, IList`1<ProjectItemChange> changes);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Modules.ProjectPsiModuleFactory/<GetAllChildren>d__15")]
private IEnumerable`1<ProjectModelChange> GetAllChildren(ProjectModelChange change);
    public sealed virtual object Execute(IChangeMap changeMap);
    private void HandleProjectModified(IProject project, PsiModuleChangeBuilder changeBuilder, IList`1<ProjectItemChange> projectChanges);
    private void HandleProjectRemoved(IProject project, PsiModuleChangeBuilder changeBuilder);
    private void HandleProjectAdded(IProject project, PsiModuleChangeBuilder changeBuilder, ProjectItemChange projectChange);
    [CanBeNullAttribute]
private Tuple`2<IList`1<IProjectPsiModuleHandler>, LifetimeDefinition> TryCreateProviders(IProject project);
}
public abstract class JetBrains.ReSharper.Psi.Modules.ProjectPsiModuleHandlerWithNoDuplicateFilesBase : object {
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private IProject <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetFrameworkId <TargetFrameworkId>k__BackingField;
    private IDiagnosticCollector myDiagnosticCollector;
    private object myLockObject;
    private IDictionary`2<IProjectFile, Key> myProjectFileKeys;
    private IDictionary`2<Key, IProjectFile> myPrimaryProjectFiles;
    private IDictionary`2<Key, LifetimeDefinition> myDiagnosticLifetimeDefinitions;
    public Lifetime Lifetime { get; }
    public IProject Project { get; }
    public TargetFrameworkId TargetFrameworkId { get; }
    protected ProjectPsiModuleHandlerWithNoDuplicateFilesBase(Lifetime lifetime, IProject project, TargetFrameworkId targetFramework, IDiagnosticCollector diagnosticCollector);
    [CompilerGeneratedAttribute]
public Lifetime get_Lifetime();
    [CompilerGeneratedAttribute]
public IProject get_Project();
    [CompilerGeneratedAttribute]
public TargetFrameworkId get_TargetFrameworkId();
    protected virtual Key GetOrCreateKey(IProjectFile projectFile);
    protected virtual Key CreateKey(IProjectFile projectFile);
    protected virtual IList`1<IProjectFile> GetProjectFilesByKey(Key key);
    [CanBeNullAttribute]
protected IProjectFile TryGetPrimaryProjectFile(Key key);
    public sealed virtual IEnumerable`1<IPsiSourceFile> GetPsiSourceFilesFor(IProjectFile projectFile);
    public sealed virtual void OnProjectFileChanged(IProjectFile projectFile, VirtualFileSystemPath oldLocation, ChangeType changeType, PsiModuleChangeBuilder changeBuilder);
    protected abstract virtual void OnProjectFileAddedImpl(IProjectFile projectFile, VirtualFileSystemPath oldLocation, PsiModuleChangeBuilder changeBuilder);
    protected abstract virtual void OnProjectFileRemovedImpl(IProjectFile projectFile, VirtualFileSystemPath oldLocation, PsiModuleChangeBuilder changeBuilder);
    protected abstract virtual void OnProjectFileModifiedImpl(IProjectFile projectFile, VirtualFileSystemPath oldLocation, PsiModuleChangeBuilder changeBuilder);
    private void ReportDuplicatedFileByKeyIfNecessary(Key key, IProjectFile duplicateProjectFile);
    protected virtual bool ShouldReportDuplicatedFile(IProjectFile primaryProjectFile, IProjectFile duplicatedProjectFile);
    private void StopReportingDuplicatedFile(Key key);
    protected abstract virtual IEnumerable`1<IPsiSourceFile> GetPsiSourceFilesImpl(IProjectFile projectFile);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Modules.ProjectPsiModuleInvalidator : object {
    private ResolveContextManager myResolveContextManager;
    public ProjectPsiModuleInvalidator(Lifetime lifetime, ChangeManager changeManager, ResolveContextManager resolveContextManager);
    private void InvalidateModules(IEnumerable`1<PsiModuleChange> psiModuleChanges);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <.ctor>b__1_0(ChangeEventArgs args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PsiComponentAttribute("10")]
internal class JetBrains.ReSharper.Psi.Modules.PsiModuleCachingInvalidator : InvalidatingPsiCache {
    private IPsiModules myPsiModules;
    public PsiModuleCachingInvalidator(Lifetime lifetime, ChangeManager changeManager, IPsiModules psiModules);
    private void ChangeHandler(ChangeEventArgs args);
    [NullableContextAttribute("2")]
public virtual void Invalidate(ITreeNode element, PsiChangedElementType elementType);
    private static void ResetCachedData(IPsiModule psiModule);
}
public class JetBrains.ReSharper.Psi.Modules.PsiModuleChange : object {
    public static ChangeEqualityComparer`1<IAssemblyPsiModule> AssemblyChangeComparer;
    public static ChangeEqualityComparer`1<IPsiModule> ModuleChangeComparer;
    public static ChangeEqualityComparer`1<IPsiSourceFile> FileChangeComparer;
    [NotNullAttribute]
public ICollection`1<Change`1<IAssemblyPsiModule>> AssemblyChanges;
    [NotNullAttribute]
public ICollection`1<Change`1<IPsiModule>> ModuleChanges;
    [NotNullAttribute]
public ICollection`1<Change`1<IPsiSourceFile>> FileChanges;
    public PsiModuleChange(ICollection`1<Change`1<IAssemblyPsiModule>> assemblyChanges, ICollection`1<Change`1<IPsiModule>> moduleChanges, ICollection`1<Change`1<IPsiSourceFile>> fileChanges);
    private static PsiModuleChange();
    public bool IsEmpty();
}
public class JetBrains.ReSharper.Psi.Modules.PsiModuleChangeBuilder : object {
    private Dictionary`2<IAssemblyPsiModule, ChangeType> myAssemblyChanges;
    private Dictionary`2<IPsiModule, ChangeType> myModuleChanges;
    private Dictionary`2<IPsiSourceFile, ChangeType> myFileChanges;
    public bool IsEmpty { get; }
    public PsiModuleChange Result { get; }
    private static Nullable`1<ChangeType> AppendChangeType(ChangeType old, ChangeType new, T item);
    private static Nullable`1<ChangeType> AddChange(Dictionary`2<T, ChangeType> changeMap, T item, ChangeType changeType);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private static void AssertIsValid(T item);
    private static void AddChanges(Dictionary`2<T, ChangeType> changeMap, Dictionary`2<T, ChangeType> otherChanges);
    private static void AddChanges(Dictionary`2<T, ChangeType> changeMap, ICollection`1<Change`1<T>> otherChanges);
    private static ICollection`1<Change`1<T>> ToCollection(Dictionary`2<T, ChangeType> changeMap);
    public void AddAssemblyChange(IAssemblyPsiModule module, ChangeType change);
    public void AddModuleChange(IPsiModule module, ChangeType change);
    public void AddFileChange(IPsiSourceFile file, ChangeType change);
    public void JoinWith(PsiModuleChange moduleChange);
    public void JoinWith(PsiModuleChangeBuilder changeBuilder);
    public bool get_IsEmpty();
    public bool ContainsAssemblyChange();
    public bool ContainsModuleChange();
    public bool ContainsFileChange();
    public PsiModuleChange get_Result();
    public void Clear();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Modules.PsiModuleExtensions : object {
    private static Key`1<Optional`1<IPsiModule>> ourPsiModuleKey;
    private static Key`1<ISymbolScope> ourCaseSensitiveSymbolScopeKey;
    [NotNullAttribute]
internal static Key`1<IReadOnlyCollection`1<string>> RUNTIME_FEATURES;
    [NotNullAttribute]
internal static Key`1<ISymbolScope> CACHED_CASE_SENSITIVE_SYMBOL_SCOPE;
    [NotNullAttribute]
internal static Key`1<ISymbolScope> CACHED_CASE_INSENSITIVE_SYMBOL_SCOPE;
    [NotNullAttribute]
internal static Key`1<Boxed`1<ValueTuple`2<bool, ObsoleteAnnotationInfo>>> MODULE_EXPERIMENTAL_ANNOTATION;
    [NotNullAttribute]
private static Boxed`1<ValueTuple`2<bool, ObsoleteAnnotationInfo>> NOT_EXPERIMENTAL_RESULT_BOXED;
    private static PsiModuleExtensions();
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IPsiModuleReference GetModuleReference(IPsiModule fromModule, IPsiModule toModule, IModuleReferenceResolveContext context);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IModuleReferenceResolveContext GetResolveContextEx(IPsiModule thisModule, IProjectFile projectFile);
    [ExtensionAttribute]
[NotNullAttribute]
public static IModuleReferenceResolveContext GetResolveContextEx(IPsiModule thisModule, IProject project);
    [ExtensionAttribute]
public static bool References(IPsiModule module, IPsiModule dependsUpon, IModuleReferenceResolveContext context);
    [ExtensionAttribute]
public static bool References(IPsiModule module, IEnumerable`1<IPsiModule> dependsUponAny, IModuleReferenceResolveContext context);
    [ExtensionAttribute]
public static void ResetPsiModule(IModuleReferenceResolveContext context);
    [CanBeNullAttribute]
private static IPsiModule CalculatePsiModule(IModuleReferenceResolveContext resolveContext);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IPsiModule GetPsiModule(IModuleReferenceResolveContext context);
    [ExtensionAttribute]
[NotNullAttribute]
public static ISymbolScope GetCaseSensitiveSymbolScopeWithReferences(IModuleReferenceResolveContext context);
    [ExtensionAttribute]
public static bool IsMiscFilesProjectModule(IPsiModule module);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<IPsiModule> WhereInternalsVisibleTo(IPsiModule from, IEnumerable`1<IPsiModule> toCandidates);
    [ExtensionAttribute]
[PureAttribute]
public static bool AreInternalsVisibleTo(IPsiModule from, IPsiModule to);
    [ExtensionAttribute]
[NotNullAttribute]
public static IPsiModule GetPsiModule(IProjectFile projectFile);
    [ExtensionAttribute]
[NotNullAttribute]
public static IPsiModule GetPsiModule(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
public static PsiModulePtr Ptr(IPsiModule module);
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<IPsiModule> GetPsiModules(IProject project);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<IPsiModule> GetPsiModules(IModule module);
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ContractAnnotationAttribute("module: null=>halt")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertIsValid(IPsiModule module, string messageText);
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ContractAnnotationAttribute("module: null=>halt")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertIsValid(IPsiModule module, string messageText, Pair`2<string, object> additionalData);
    [ExtensionAttribute]
[AssertionMethodAttribute]
[ContractAnnotationAttribute("module: null=>halt")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertIsNotNullAndValid(IPsiModule module, string messageText);
    [ExtensionAttribute]
[PureAttribute]
public static bool RuntimeSupportsDefaultInterfaceImplementation(IPsiModule module);
    [ExtensionAttribute]
[PureAttribute]
public static bool RuntimeSupportsCovariantReturnsOfClasses(IPsiModule module);
    [ExtensionAttribute]
[PureAttribute]
public static bool RuntimeSupportsUnmanagedSignatureCallingConvention(IPsiModule module);
    [ExtensionAttribute]
[PureAttribute]
public static bool RuntimeSupportsStaticAbstractMembersInInterfaces(IPsiModule module);
    [ExtensionAttribute]
[PureAttribute]
public static bool RuntimeSupportsNumericIntPtr(IPsiModule module);
    [ExtensionAttribute]
[PureAttribute]
public static bool RuntimeSupportsInlineArrayTypes(IPsiModule module);
    [ExtensionAttribute]
[PureAttribute]
public static bool RuntimeSupportsByRefFields(IPsiModule module);
    [ExtensionAttribute]
[PureAttribute]
public static bool RuntimeSupportsByRefLikeGenerics(IPsiModule module);
    [ExtensionAttribute]
[ItemNotNullAttribute]
[PureAttribute]
[NotNullAttribute]
public static IReadOnlyCollection`1<string> GetRuntimeFeatures(IPsiModule psiModule);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static ISymbolScope GetCachedCaseSensitiveSymbolScopeWithReferences(IPsiModule psiModule);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static ISymbolScope GetCachedCaseInsensitiveSymbolScopeWithReferences(IPsiModule psiModule);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsModuleExperimental(IPsiModule psiModule, ObsoleteAnnotationInfo& annotationInfo);
    [CompilerGeneratedAttribute]
[CanBeNullAttribute]
internal static IPsiModule <GetRuntimeFeatures>g__GetCoreLib|31_1(IPsiModule module);
}
[BaseTypeRequiredAttribute("JetBrains.ReSharper.Psi.Modules.IPsiModuleFactory")]
[AttributeUsageAttribute("4")]
[MeansImplicitUseAttribute]
[ComponentInstantiationAttribute("-32758")]
public class JetBrains.ReSharper.Psi.Modules.PsiModuleFactoryAttribute : SolutionComponentAttribute {
    public PsiModuleFactoryAttribute(Instantiation instantiation);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Modules.PsiModuleHealthDiagnostics : object {
    private static Key`1<IList`1<string>> ourModuleEventsKey;
    private static PsiModuleHealthDiagnostics();
    [ExtensionAttribute]
[NotNullAttribute]
public static IReadOnlyList`1<string> GetModuleHistory(IPsiModule psiModule);
    [ExtensionAttribute]
public static void ReportPsiModuleChange(PsiModuleChange psiModuleChange);
    [ExtensionAttribute]
public static void ReportModuleAddedToPsiModules(IPsiModule psiModule);
    [ExtensionAttribute]
public static void ReportModuleRemovedFromPsiModules(IPsiModule psiModule);
}
public class JetBrains.ReSharper.Psi.Modules.PsiModuleReference : object {
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ExternAliases>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmbedInteropTypes>k__BackingField;
    public IPsiModule Module { get; }
    public String[] ExternAliases { get; }
    public bool EmbedInteropTypes { get; }
    public PsiModuleReference(IPsiModule module, String[] aliases, bool embedInteropTypes);
    public PsiModuleReference(IPsiModule module);
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_Module();
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_ExternAliases();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EmbedInteropTypes();
    public virtual string ToString();
    protected bool Equals(PsiModuleReference other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Modules.PsiModuleReferenceExtensions : object {
    [ExtensionAttribute]
public static bool HasGlobalExternAlias(IPsiModuleReference result);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => true")]
public static bool IsGlobalAlias(string alias);
}
public class JetBrains.ReSharper.Psi.Modules.PsiModuleResolveContext : ConcurrentUserDataHolder {
    [CompilerGeneratedAttribute]
private IPsiModule <PsiModule>k__BackingField;
    [CompilerGeneratedAttribute]
private IModule <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetFrameworkId <TargetFramework>k__BackingField;
    public IPsiModule PsiModule { get; }
    public IModule Module { get; }
    public TargetFrameworkId TargetFramework { get; public set; }
    public string UniqueName { get; }
    public AssemblyNameAndLocation Originator { get; }
    public PsiModuleResolveContext(IPsiModule psiModule, TargetFrameworkId targetFramework, IProject project);
    [CompilerGeneratedAttribute]
public IPsiModule get_PsiModule();
    [CompilerGeneratedAttribute]
public sealed virtual IModule get_Module();
    [CompilerGeneratedAttribute]
public sealed virtual TargetFrameworkId get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(TargetFrameworkId value);
    public sealed virtual void Write(BinaryWriter writer);
    public sealed virtual string get_UniqueName();
    public sealed virtual bool IsValid();
    public sealed virtual AssemblyNameAndLocation get_Originator();
    public sealed virtual void Dump(TextWriter writer);
}
[SolutionInstanceComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Modules.PsiModuleResolveContextManager : object {
    [NotNullAttribute]
private ResolveContextManager myResolveContextManager;
    [NotNullAttribute]
private static Key`1<IModuleReferenceResolveContext> ourCachedPsiModuleResolveContext;
    public PsiModuleResolveContextManager(ResolveContextManager resolveContextManager);
    private static PsiModuleResolveContextManager();
    [NotNullAttribute]
public IModuleReferenceResolveContext GetOrCreateModuleResolveContext(IProject project, IPsiModule psiModule, TargetFrameworkId targetFramework);
    [CanBeNullAttribute]
private IModuleReferenceResolveContext TryGetProjectResolveContext(IProject project, IPsiModule psiModule, TargetFrameworkId& targetFramework);
    [NotNullAttribute]
protected virtual IModuleReferenceResolveContext CreateResolveContext(IPsiModule psiModule, TargetFrameworkId targetFramework, IProject project);
}
[SolutionInstanceComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Modules.PsiModuleResolveContextReader : object {
    private ISolution mySolution;
    private PsiModuleResolveContextManager myResolveContextManager;
    public string ContextId { get; }
    public PsiModuleResolveContextReader(ISolution solution, PsiModuleResolveContextManager resolveContextManager);
    public sealed virtual IModuleReferenceResolveContext Read(BinaryReader reader);
    public sealed virtual string get_ContextId();
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Modules.PsiModules : object {
    private ILogger myLogger;
    private IShellLocks myLocks;
    private ISolution mySolution;
    private PsiProjectFileTypeCoordinator myPsiProjectFileTypeCoordinator;
    private ProjectPsiModuleFactory myProjectModuleFactory;
    private AssemblyPsiModuleFactory myAssemblyModuleFactory;
    private List`1<IPsiModuleFactory> myFactories;
    private CachedModuleDependencies myCachedModuleDependencies;
    private List`1<IPsiModule> myNonProjectModules;
    private HashSet`1<IPsiModule> myAllModules;
    private Dictionary`2<string, IPsiModule> myModulesById;
    private WeakToStrongDictionary`2<IPsiModule, bool> myAssembliesVisibleToSolution;
    private OutputAssemblies myOutputAssemblies;
    private IPsiSourceFileSorter mySourceFileSorter;
    private IProjectHasPsiService myProjectHasPsiService;
    private ConcurrentDictionary`2<IProject, IList`1<IPsiModule>> myCachedProjectPsiModules;
    private int myDeduplicationCounter;
    private OneToSetMap`2<string, string> myPersistentIds;
    public PsiModules(Lifetime lifetime, ILogger logger, IShellLocks locks, ISolution solution, ChangeManager changeManager, PsiProjectFileTypeCoordinator psiProjectFileTypeCoordinator, ProjectPsiModuleFactory projectModuleFactory, AssemblyPsiModuleFactory assemblyModuleFactory, OutputAssemblies outputAssembliesCache, IEnumerable`1<IPsiModuleFactory> factories, ISolutionLoadTasksScheduler loadTasksScheduler, IPsiSourceFileSorter sourceFileSorter, IProjectHasPsiService projectHasPsiService);
    public sealed virtual IPsiModule GetPrimaryPsiModule(IModule module, TargetFrameworkId targetFrameworkId);
    [CanBeNullAttribute]
private IPsiModule TryGetPrimaryPsiModule(IAssembly assembly, TargetFrameworkId targetFrameworkId);
    [CanBeNullAttribute]
private IPsiModule TryGetPrimaryPsiModule(IProject project, TargetFrameworkId targetFrameworkId);
    public sealed virtual FrugalLocalList`1<IPsiModule> GetPsiModulesToReference(IModule module, TargetFrameworkId targetFrameworkId);
    public sealed virtual IList`1<IPsiModule> GetPsiModules(IProject project);
    [NotNullAttribute]
private IList`1<IPsiModule> CalculateProjectPsiModules(IProject project);
    public sealed virtual FrugalLocalList`1<IPsiSourceFile> GetPsiSourceFilesFor(IProjectFile projectFile);
    public sealed virtual FrugalLocalList`1<IPsiSourceFile> GetUnsortedPsiSourceFilesFor(IProjectFile projectFile);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertIsValid(IPsiSourceFile sourceFile, IProjectPsiModuleHandler handler);
    public sealed virtual IPsiModuleReference GetModuleReference(IPsiModule fromModule, IPsiModule toModule, IModuleReferenceResolveContext context);
    public sealed virtual IEnumerable`1<IPsiModuleReference> GetModuleReferences(IPsiModule fromModule, IEnumerable`1<IPsiModule> toAnyModule, IModuleReferenceResolveContext context);
    internal static bool ReferencedModuleMatchesDefined(IPsiModuleReference definitionReference, IPsiModule reference, IModuleReferenceResolveContext resolveContext);
    [NotNullAttribute]
public IEnumerable`1<IPsiModuleReference> GetModuleReferences(IPsiModule module);
    public sealed virtual IReadOnlyList`1<IPsiModuleReference> GetModuleReferences(IPsiModule module, IModuleReferenceResolveContext context);
    public sealed virtual IReadOnlyList`1<IPsiModuleReference> GetReverseModuleReferences(IPsiModule module, IModuleReferenceResolveContext context);
    public sealed virtual IEnumerable`1<IAssemblyPsiModule> GetAssemblyPsiModuleByName(AssemblyNameInfo name);
    public sealed virtual IProject TryGetProjectByOutputAssembly(IAssembly outputAssembly);
    public sealed virtual IProject TryGetProjectByReferenceAssembly(IAssembly referenceAssembly);
    public sealed virtual IProject TryGetProjectByOutputOrReferenceAssembly(IAssembly assembly);
    public sealed virtual IProject TryGetProjectByOutputAssembly(VirtualFileSystemPath assemblyPath);
    public sealed virtual IProject TryGetProjectByReferenceAssembly(VirtualFileSystemPath assemblyPath);
    public sealed virtual IProject TryGetProjectByOutputOrReferenceAssembly(VirtualFileSystemPath assemblyPath);
    public sealed virtual Tuple`2<IProject, TargetFrameworkId> TryGetProjectAndTargetFrameworkIdByOutputAssembly(VirtualFileSystemPath assemblyPath);
    public sealed virtual Tuple`2<IProject, TargetFrameworkId> TryGetProjectAndTargetFrameworkIdByReferenceAssembly(VirtualFileSystemPath assemblyPath);
    public sealed virtual Tuple`2<IProject, TargetFrameworkId> TryGetProjectAndTargetFrameworkIdByOutputOrReferenceAssembly(VirtualFileSystemPath assemblyPath);
    public sealed virtual IAssembly GetOutputAssemblyByProject(IProject project, TargetFrameworkId targetFrameworkId);
    public sealed virtual bool HasModule(IPsiModule module);
    public sealed virtual IEnumerable`1<IPsiModule> GetModules();
    public sealed virtual IEnumerable`1<IPsiModule> GetSourceModules();
    public sealed virtual IEnumerable`1<IAssemblyPsiModule> GetAssemblyModules();
    public sealed virtual IPsiModule GetById(string persistentId);
    private static string TryNormalizePersistentId(string persistentId);
    public sealed virtual string DeduplicatePersistentId(string persistentId);
    private void RemovePersistentId(string persistentId);
    public sealed virtual object Execute(IChangeMap changeMap);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertModulesAreValid(IEnumerable`1<IPsiModule> modules);
    public sealed virtual void Dump(TextWriter to, Action`3<IPsiSourceFile, TextWriter, int> dumpFile, Func`2<IPsiSourceFile, string> fileSortString, bool dumpPlatformId, Predicate`1<IPsiModule> dumpNonProject);
    public sealed virtual void DumpProject(TextWriter to, IProject project, Func`2<IPsiModule, string> moduleNameDumper, Action`3<IPsiSourceFile, TextWriter, int> dumpFiles, Func`2<IPsiSourceFile, string> fileSortString, bool dumpPlatformId);
    public static string DumpPsiModule(IPsiModule psiModule);
    public static void DumpPsiModule(TextWriter to, IPsiModule module, Func`2<IPsiModule, string> moduleNameDumper, Action`3<IPsiSourceFile, TextWriter, int> dumpFiles, Func`2<IPsiSourceFile, string> fileSortString, int offset);
    public sealed virtual bool IsSourceProject(IProject project);
    public static bool IsUnsupportedWebSourceProject(IProject project, PsiProjectFileTypeCoordinator projectFileTypeCoordinator);
    internal bool CalculateProvidedInternalsVisibleTo(IPsiModule moduleFrom, IPsiModule moduleTo);
    public virtual bool CanBeVisibleToSolution(IClrDeclaredElement element);
    [CompilerGeneratedAttribute]
private void <.ctor>b__18_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__18_1();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Modules.PsiModulesExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IPsiModules PsiModules(ISolution solution);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasSourceProject(IPsiModules psiModules, IAssembly assembly);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasSourceProject(IPsiModules psiModules, IPsiAssembly assembly);
    [ExtensionAttribute]
[PureAttribute]
public static JetHashSet`1<IPsiModule> GetPsiModuleAndThoseThatReferenceItTransitively(IPsiModules psiModules, IPsiModule psiModule);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Modules.PsiModulesUtil : object {
    public static void DumpPsiSourceFile(IPsiSourceFile sourceFile, TextWriter to, int offset);
    [ExtensionAttribute]
public static string GetPsiSourceFileDumpName(IPsiSourceFile sourceFile);
    public static string DumpPsiSourceFileProperties(IPsiSourceFile sourceFile);
    public static bool CanBeVisibleToSolution(IClrDeclaredElement element);
}
public static class JetBrains.ReSharper.Psi.Modules.PsiModuleUtil : object {
    private static string Global;
    private static String[] ourGlobalAlias;
    private static Char[] ourSeparator;
    private static PsiModuleUtil();
    public static FrugalLocalList`1<IPsiModuleReference> TryGetPsiModuleReferences(IProjectToModuleReference reference, IPsiModules psiModules, IModuleReferencesResolveStore moduleReferencesResolveStore, Predicate`1<IModule> acceptModule);
    [NotNullAttribute]
public static IEnumerable`1<IPsiModuleReference> GetProjectReferences(IProject project, IPsiModules psiModules, IModuleReferencesResolveStore moduleReferencesResolveStore, TargetFrameworkId targetFrameworkId, Predicate`1<IModule> acceptModule);
    [PureAttribute]
[NotNullAttribute]
private static String[] GetAliases(string aliasList);
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Modules.PsiSourceFileSorter : object {
    [NotNullAttribute]
private List`1<Func`3<IProjectFile, IPsiSourceFile, bool>> myContextCheckers;
    public PsiSourceFileSorter(Lifetime lifetime);
    public sealed virtual void AddContextChecker(Lifetime lifetime, Func`3<IProjectFile, IPsiSourceFile, bool> checker);
    public sealed virtual FrugalLocalList`1<IPsiSourceFile> SortFilesByContext(IProjectFile projectFile, FrugalLocalList`1<IPsiSourceFile> sourceFiles);
    [PureAttribute]
public int GetFileWeight(IPsiSourceFile sourceFile, IProjectFile projectFile);
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0();
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Modules.PsiSourceFileSortRules : object {
    [NotNullAttribute]
private IPsiModules myPsiModules;
    [NotNullAttribute]
private ProjectContext myProjectContext;
    public PsiSourceFileSortRules(Lifetime lifetime, IPsiModules psiModules, IPsiSourceFileSorter sorter, ProjectContext projectContext);
    private bool TargetContextPreference(IProjectFile projectFile, IPsiSourceFile sourceFile);
    private bool PrimaryPsiModulePreference(IProjectFile projectFile, IPsiSourceFile sourceFile);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Modules.ReferencesResolveContextUtil : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IModuleReferenceResolveContext GetContextFromModule(IPsiModule module);
}
[ModuleReferencerAttribute("16")]
public class JetBrains.ReSharper.Psi.Modules.RetargetProjectModuleReferencer : object {
    private static int BeforeDefaultButAfterNugetReferencerPriority;
    private GenericModuleReferencer myGenericModuleReferencer;
    public RetargetProjectModuleReferencer(GenericModuleReferencer genericModuleReferencer);
    public virtual bool ReferenceModule(IPsiModule module, IPsiModule moduleToReference);
    public virtual bool ReferenceModuleWithType(IPsiModule module, ITypeElement typeToReference);
    public virtual bool CanReferenceModule(IPsiModule module, IPsiModule moduleToReference, UserDataHolder context);
    [CanBeNullAttribute]
private static IPsiModule GetRetargetedPsiModule(IPsiModule module, IPsiModule moduleToReference);
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Modules.SolutionFolderPsiModuleProviderFactory : object {
    private PsiSourceFilePropertiesManager myPsiSourceFilePropertiesManager;
    private DocumentManager myDocumentManager;
    private PsiProjectFileTypeCoordinator myPsiProjectFileTypeCoordinator;
    public SolutionFolderPsiModuleProviderFactory(PsiSourceFilePropertiesManager psiSourceFilePropertiesManager, DocumentManager documentManager, PsiProjectFileTypeCoordinator psiProjectFileTypeCoordinator);
    public sealed virtual IEnumerable`1<IProjectPsiModuleHandler> TryCreate(Lifetime projectLifetime, IProject project);
}
[SolutionComponentAttribute("10")]
internal class JetBrains.ReSharper.Psi.Modules.SolutionProjectPsiModuleProviderFactory : object {
    private IEnumerable`1<IProjectPsiModuleHandler> mySolutionProjectProjectPsiModuleHandlers;
    public SolutionProjectPsiModuleProviderFactory(IEnumerable`1<IMiscFilesProjectPsiModuleProvider> providers);
    public sealed virtual IEnumerable`1<IProjectPsiModuleHandler> TryCreate(Lifetime projectLifetime, IProject project);
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Modules.WinRtBroker.AppContainerProjectPsiModuleProviderFilter : object {
    private BrokeredWinrtSupport myService;
    public AppContainerProjectPsiModuleProviderFilter(Lifetime lifetime, BrokeredWinrtSupport service);
    public sealed virtual Tuple`2<IProjectPsiModuleHandler, IPsiModuleDecorator> OverrideHandler(Lifetime lifetime, IProject project, IProjectPsiModuleHandler handler);
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Modules.WinRtBroker.BrokeredWinrtSupport : object {
    private ISolution mySolution;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <IsAllowed>k__BackingField;
    private ICollectionEvents`1<IProject> myAppContainerProjects;
    private ICollectionEvents`1<IProject> myProxyProjects;
    private OneToSetMap`2<IProject, IProject> myAppContainerToProxyReferences;
    private OneToSetMap`2<IProject, IProject> myProxyToWinMdProjectReferences;
    private IPsiModules myPsiModules;
    public IProperty`1<bool> IsAllowed { get; }
    private IPsiModules PsiModules { get; }
    public BrokeredWinrtSupport(Lifetime lifetime, ISolution solution, IViewableProjectsCollection projects, ChangeManager changeManager);
    [CompilerGeneratedAttribute]
public IProperty`1<bool> get_IsAllowed();
    private IPsiModules get_PsiModules();
    private void DropProxy(IProject broker);
    private void DropBrokerReferences(IProject broker);
    private void DropAppContainerReferences(IProject appContainer);
    private void ReadAppContainerReferences(IProject appContainer);
    private void ReadProxyReferences(IProject proxy);
    public bool IsWinMdProject(IProject project);
    public virtual bool IsAppContainerProject(IProject project);
    public virtual bool IsProxyStubProject(IProject project);
    public ICollection`1<IProject> GetReferencedWinMdProjects(IProject project);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.MultitypeExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IType> Constituents(IType type);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IType TransformMultitype(IType type, Func`2<IType, IType> transformer, IPsiModule module);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IType TransformMultitype(IType type, TState state, Func`3<IType, TState, IType> transformer, IPsiModule module);
}
public enum JetBrains.ReSharper.Psi.NamespaceContainerStyle : Enum {
    public int value__;
    public static NamespaceContainerStyle NONE;
    public static NamespaceContainerStyle AFTER;
    public static NamespaceContainerStyle AFTER_IN_PARENTHESIS;
}
public enum JetBrains.ReSharper.Psi.NameStyle : Enum {
    public int value__;
    public static NameStyle NONE;
    public static NameStyle SHORT;
    public static NameStyle SHORT_RAW;
    public static NameStyle QUALIFIED;
    public static NameStyle QUALIFIED_EXCEPT_MEMBERS;
    public static NameStyle QUALIFIED_FULL_NESTED_TYPE_FOR_MEMBERS;
    public static NameStyle FULL_NESTED_TYPE;
    public static NameStyle FULL_NESTED_TYPE_EXCEPT_MEMBERS;
}
public abstract class JetBrains.ReSharper.Psi.Naming.Elements.ElementKindBase : EnumPattern {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private RoslynNamingSymbolModifier <Modifier>k__BackingField;
    private string myPresentableName;
    private Type myResourceType;
    private string myResourceName;
    public PsiLanguageType Language { get; }
    public string PresentableName { get; }
    public string Name { get; }
    public IElementKind Parent { get; }
    public RoslynNamingSymbolModifier Modifier { get; }
    [ObsoleteAttribute("Consider to use overload with resourceType and resourceName instead of presentableName.")]
protected ElementKindBase(string name, string presentableName, RoslynNamingSymbolModifier modifier);
    protected ElementKindBase(string name, Type resourceType, string resourceName, RoslynNamingSymbolModifier modifier);
    public abstract virtual PsiLanguageType get_Language();
    public sealed virtual string get_PresentableName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public virtual IElementKind get_Parent();
    [CompilerGeneratedAttribute]
public sealed virtual RoslynNamingSymbolModifier get_Modifier();
    public abstract virtual bool IsApplicable(IDeclaredElement element);
    public virtual NamingRule GetDefaultRule();
    public sealed virtual Hash AddToHash(Hash hash);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[NamedElementsBagAttribute("")]
public class JetBrains.ReSharper.Psi.Naming.Elements.ElementKindOfElementType : ElementKindBase {
    private Func`2<IDeclaredElement, bool> myIsApplicable;
    [CompilerGeneratedAttribute]
private IElementKind <Parent>k__BackingField;
    public static IElementKind NAMESPACE;
    public static IElementKind TYPE;
    public static IElementKind CLASS;
    public static IElementKind STRUCT;
    public static IElementKind INTERFACE;
    public static IElementKind DELEGATE;
    public static IElementKind ENUM;
    public static IElementKind TYPE_MEMBER;
    public static IElementKind METHOD;
    public static IElementKind EXTENSION_METHOD;
    public static IElementKind PROPERTY;
    public static IElementKind EVENT;
    public static IElementKind ANY_FIELD;
    public static IElementKind FIELD;
    public static IElementKind READONLY_FIELD;
    public static IElementKind CONSTANT_FIELD;
    public static IElementKind ENUM_MEMBER;
    public static IElementKind LOCAL;
    public static IElementKind LOCAL_VARIABLE;
    public static IElementKind LOCAL_CONSTANT;
    public static IElementKind PARAMETER;
    public static IElementKind LABEL;
    public static IElementKind TYPE_PARAMETER;
    public IElementKind Parent { get; }
    [NullableAttribute("2")]
public PsiLanguageType Language { get; }
    [ObsoleteAttribute("Consider to use overload with resourceType and resourceName instead of presentableName.")]
protected ElementKindOfElementType(string name, string presentableName, Func`2<IDeclaredElement, bool> isApplicable, IElementKind parent, RoslynNamingSymbolModifier modifier);
    protected ElementKindOfElementType(string name, Type resourceType, string resourceName, Func`2<IDeclaredElement, bool> isApplicable, IElementKind parent, RoslynNamingSymbolModifier modifier);
    private static ElementKindOfElementType();
    [CompilerGeneratedAttribute]
public virtual IElementKind get_Parent();
    [NullableContextAttribute("2")]
public virtual PsiLanguageType get_Language();
    public virtual bool IsApplicable(IDeclaredElement element);
}
public class JetBrains.ReSharper.Psi.Naming.Elements.ElementKindSet : object {
    [CompilerGeneratedAttribute]
private HashSet`1<IElementKind> <Elements>k__BackingField;
    public HashSet`1<IElementKind> Elements { get; }
    public ElementKindSet(IElementKind element);
    public ElementKindSet(IElementKind[] elements);
    public ElementKindSet(IEnumerable`1<IElementKind> elements);
    [CompilerGeneratedAttribute]
public sealed virtual HashSet`1<IElementKind> get_Elements();
    public sealed virtual void Add(IElementKind kind);
    public sealed virtual Hash AddToHash(Hash hash);
    public sealed virtual bool Contains(IElementKindSet elementKindSet);
    public sealed virtual bool Contains(IElementKind kind);
    public sealed virtual bool ContainsElementOrParent(IElementKind kind);
    public sealed virtual bool IsSubsetOf(IElementKindSet other);
    public sealed virtual bool Intersects(IElementKindSet other);
    public sealed virtual IElementKindSet IntersectWith(IElementKindSet other);
    public sealed virtual void ReadFromXml(XmlElement element);
    public sealed virtual void WriteToXml(XmlElement element);
    public bool Equals(ElementKindSet other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface JetBrains.ReSharper.Psi.Naming.Elements.IElementKind {
    public PsiLanguageType Language { get; }
    public string PresentableName { get; }
    public string Name { get; }
    public IElementKind Parent { get; }
    public RoslynNamingSymbolModifier Modifier { get; }
    public abstract virtual PsiLanguageType get_Language();
    public abstract virtual string get_PresentableName();
    public abstract virtual string get_Name();
    public abstract virtual IElementKind get_Parent();
    public abstract virtual RoslynNamingSymbolModifier get_Modifier();
    public abstract virtual bool IsApplicable(IDeclaredElement element);
    public abstract virtual NamingRule GetDefaultRule();
    public abstract virtual Hash AddToHash(Hash hash);
}
public interface JetBrains.ReSharper.Psi.Naming.Elements.IElementKindSet {
    public HashSet`1<IElementKind> Elements { get; }
    public abstract virtual bool Contains(IElementKindSet kinds);
    public abstract virtual bool Contains(IElementKind kind);
    public abstract virtual bool ContainsElementOrParent(IElementKind kind);
    public abstract virtual bool IsSubsetOf(IElementKindSet other);
    public abstract virtual bool Intersects(IElementKindSet other);
    public abstract virtual IElementKindSet IntersectWith(IElementKindSet other);
    public abstract virtual HashSet`1<IElementKind> get_Elements();
    public abstract virtual void Add(IElementKind kind);
    public abstract virtual Hash AddToHash(Hash hash);
}
public interface JetBrains.ReSharper.Psi.Naming.Elements.INamedElementsManager {
    [NotNullAttribute]
public abstract virtual IEnumerable`1<IElementKind> GetAllElementKinds(PsiLanguageType language);
    [CanBeNullAttribute]
public abstract virtual IElementKind GetElementKindByName(string id);
}
[AttributeUsageAttribute("4")]
[BaseTypeRequiredAttribute("JetBrains.ReSharper.Psi.Naming.Elements.IElementKind")]
[MeansImplicitUseAttribute("3")]
public class JetBrains.ReSharper.Psi.Naming.Elements.NamedElementsBagAttribute : PartAttribute {
    [CompilerGeneratedAttribute]
private Type <LanguageType>k__BackingField;
    public Type LanguageType { get; }
    public NamedElementsBagAttribute(Type languageType);
    [CompilerGeneratedAttribute]
public Type get_LanguageType();
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Naming.Elements.NamedElementsManager : object {
    private OneToListMap`2<Type, IElementKind> myNamedElements;
    public NamedElementsManager(Lifetime lifetime, ShellPartCatalogSet catalog, ILogger logger);
    public sealed virtual IEnumerable`1<IElementKind> GetAllElementKinds(PsiLanguageType language);
    public sealed virtual IElementKind GetElementKindByName(string name);
    [NotNullAttribute]
public static INamedElementsManager GetInstance();
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Naming.Elements.RoslynNamingSymbolModifier : Enum {
    public int value__;
    public static RoslynNamingSymbolModifier None;
    public static RoslynNamingSymbolModifier Readonly;
    public static RoslynNamingSymbolModifier Async;
    public static RoslynNamingSymbolModifier Const;
    public static RoslynNamingSymbolModifier Abstract;
    public static RoslynNamingSymbolModifier Static;
    public static RoslynNamingSymbolModifier UntranslatableToRoslyn;
    public static RoslynNamingSymbolModifier Negate;
}
public class JetBrains.ReSharper.Psi.Naming.Elements.UnknownElementKind : ElementKindBase {
    public static IElementKind INSTANCE;
    public PsiLanguageType Language { get; }
    private UnknownElementKind(string name, Type resourceType, string resourceName);
    private static UnknownElementKind();
    public virtual PsiLanguageType get_Language();
    public virtual bool IsApplicable(IDeclaredElement element);
}
public class JetBrains.ReSharper.Psi.Naming.Extentions.EntryOptions : object {
    [CompilerGeneratedAttribute]
private PluralityKinds <PluralityKind>k__BackingField;
    [CompilerGeneratedAttribute]
private SubrootPolicy <SubrootPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private PredefinedPrefixPolicy <PredefinedPrefixPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Emphasis <Emphasis>k__BackingField;
    public PluralityKinds PluralityKind { get; public set; }
    public SubrootPolicy SubrootPolicy { get; public set; }
    public PredefinedPrefixPolicy PredefinedPrefixPolicy { get; public set; }
    public Emphasis Emphasis { get; public set; }
    public EntryOptions(PluralityKinds pluralityKind, SubrootPolicy subrootPolicy, PredefinedPrefixPolicy prefixPolicy, Emphasis emphasis);
    [CompilerGeneratedAttribute]
public PluralityKinds get_PluralityKind();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PluralityKind(PluralityKinds value);
    [CompilerGeneratedAttribute]
public SubrootPolicy get_SubrootPolicy();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SubrootPolicy(SubrootPolicy value);
    [CompilerGeneratedAttribute]
public PredefinedPrefixPolicy get_PredefinedPrefixPolicy();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PredefinedPrefixPolicy(PredefinedPrefixPolicy value);
    [CompilerGeneratedAttribute]
public Emphasis get_Emphasis();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Emphasis(Emphasis value);
}
public interface JetBrains.ReSharper.Psi.Naming.Extentions.INamesCollection {
    [NotNullAttribute]
public ISolution Solution { get; }
    [NotNullAttribute]
public INamingPolicyProvider PolicyProvider { get; }
    public abstract virtual ISolution get_Solution();
    public abstract virtual INamingPolicyProvider get_PolicyProvider();
    public abstract virtual void Add(IType type, EntryOptions entryOptions);
    public abstract virtual void Add(ITreeNode element, EntryOptions entryOptions);
    public abstract virtual void Add(ITreeNode element, EntryOptions entryOptions, bool useExpectedTypes);
    public abstract virtual void Add(IDeclaredElement declaredElement, EntryOptions entryOptions);
    public abstract virtual void Add(NameRoot root, EntryOptions entryOptions);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual INamesSuggestion Prepare(NamedElementKinds elementKind, ScopeKind scopeKind, SuggestionOptions suggestionOptions);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual INamesSuggestion Prepare(IElementKind elementKind, ScopeKind scopeKind, SuggestionOptions suggestionOptions);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual INamesSuggestion Prepare(IDeclaredElement targetElement, SuggestionOptions suggestionOptions);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual INamesSuggestion Prepare(NamingRule namingRule, ScopeKind scopeKind, SuggestionOptions suggestionOptions);
    [NotNullAttribute]
public abstract virtual INamesCollection Clone();
    [NotNullAttribute]
public abstract virtual IList`1<NameRoot> GetRoots();
}
public interface JetBrains.ReSharper.Psi.Naming.Extentions.INamesSuggestion {
    [NotNullAttribute]
[PureAttribute]
public abstract virtual string FirstName();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IReadOnlyList`1<string> AllNames();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IReadOnlyCollection`1<NameRoot> GetRoots();
}
public static class JetBrains.ReSharper.Psi.Naming.Extentions.NameChangeUtil : object {
    [NullableContextAttribute("1")]
public static NameRoot GetSuggestedName(NameRoot rootToChange, NameRoot rootFrom, NameRoot rootTo);
    [NullableContextAttribute("1")]
private static CompareResults CompareWithPlurality(string textFrom, string textTo);
    [NullableContextAttribute("1")]
private static List`1<NameChange> GetNameChanges(NameRoot rootFrom, NameRoot to);
}
public class JetBrains.ReSharper.Psi.Naming.Extentions.NameCompletionUtil : object {
    public static IEnumerable`1<string> SuggestNames(IEnumerable`1<NameRoot> roots, string prefix, NamingPolicy policy, PsiLanguageType language, ISolution solution, INamingPolicyProvider policyProvider);
    public static ICollection`1<NameRoot> PrepareNameRootsForSuggestion(IEnumerable`1<NameRoot> nameRoots, PsiLanguageType languageType);
    public static ICollection`1<NameRoot> PrepareNameRootsForSuggestionAndFilterInnane(IEnumerable`1<NameRoot> nameRoots, PsiLanguageType languageType, NamingManager manager);
}
internal class JetBrains.ReSharper.Psi.Naming.Extentions.NamesCollection : object {
    [NotNullAttribute]
private PsiLanguageType myLanguage;
    private PluralityKinds myPluralityKind;
    private bool myLongerNamesFirst;
    [NotNullAttribute]
private List`1<NameRoot> myRoots;
    [CompilerGeneratedAttribute]
private INamingPolicyProvider <PolicyProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    public INamingPolicyProvider PolicyProvider { get; }
    public ISolution Solution { get; }
    [NotNullAttribute]
private NamingManager Naming { get; }
    public NamesCollection(ISolution solution, PluralityKinds pluralityKinds, PsiLanguageType language, bool longerNamesFirst, INamingPolicyProvider policyProvider);
    [CompilerGeneratedAttribute]
public sealed virtual INamingPolicyProvider get_PolicyProvider();
    [CompilerGeneratedAttribute]
public sealed virtual ISolution get_Solution();
    private NamingManager get_Naming();
    public sealed virtual INamesSuggestion Prepare(NamedElementKinds elementKind, ScopeKind scopeKind, SuggestionOptions suggestionOptions);
    public sealed virtual INamesSuggestion Prepare(IElementKind elementKind, ScopeKind scopeKind, SuggestionOptions suggestionOptions);
    public sealed virtual INamesSuggestion Prepare(IDeclaredElement targetElement, SuggestionOptions suggestionOptions);
    public sealed virtual INamesSuggestion Prepare(NamingRule namingRule, ScopeKind scopeKind, SuggestionOptions suggestionOptions);
    public sealed virtual INamesCollection Clone();
    public sealed virtual IList`1<NameRoot> GetRoots();
    public sealed virtual void Add(IType type, EntryOptions entryOptions);
    public sealed virtual void Add(ITreeNode element, EntryOptions entryOptions);
    public sealed virtual void Add(ITreeNode element, EntryOptions entryOptions, bool useExpectedTypes);
    public sealed virtual void Add(IDeclaredElement declaredElement, EntryOptions entryOptions);
    public sealed virtual void Add(NameRoot root, EntryOptions entryOptions);
    private void AddRoot(NameRoot root, EntryOptions entryOptions);
}
public enum JetBrains.ReSharper.Psi.Naming.Extentions.SubrootPolicy : Enum {
    public int value__;
    public static SubrootPolicy Decompose;
    public static SubrootPolicy DecomposeToBad;
    public static SubrootPolicy DoNotDecompose;
}
public class JetBrains.ReSharper.Psi.Naming.Extentions.SuggestionOptions : object {
    [CompilerGeneratedAttribute]
private ITreeNode <UniqueNameContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <UsageContext>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, bool> <UsedNamesFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IDeclaredElement, bool> <IsConflictingElement>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DoNotUseNumericSuffixes>k__BackingField;
    [CanBeNullAttribute]
public ITreeNode UniqueNameContext { get; public set; }
    [CanBeNullAttribute]
public ITreeNode UsageContext { get; }
    [NotNullAttribute]
public Func`2<string, bool> UsedNamesFilter { get; public set; }
    [NotNullAttribute]
public Func`2<IDeclaredElement, bool> IsConflictingElement { get; public set; }
    [NotNullAttribute]
public string DefaultName { get; public set; }
    public bool DoNotUseNumericSuffixes { get; public set; }
    public SuggestionOptions(ITreeNode uniqueNameContext, string defaultName, ITreeNode usageContext);
    [CompilerGeneratedAttribute]
public ITreeNode get_UniqueNameContext();
    [CompilerGeneratedAttribute]
public void set_UniqueNameContext(ITreeNode value);
    [CompilerGeneratedAttribute]
public ITreeNode get_UsageContext();
    [CompilerGeneratedAttribute]
public Func`2<string, bool> get_UsedNamesFilter();
    [CompilerGeneratedAttribute]
public void set_UsedNamesFilter(Func`2<string, bool> value);
    [CompilerGeneratedAttribute]
public Func`2<IDeclaredElement, bool> get_IsConflictingElement();
    [CompilerGeneratedAttribute]
public void set_IsConflictingElement(Func`2<IDeclaredElement, bool> value);
    [CompilerGeneratedAttribute]
public string get_DefaultName();
    [CompilerGeneratedAttribute]
public void set_DefaultName(string value);
    [CompilerGeneratedAttribute]
public bool get_DoNotUseNumericSuffixes();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DoNotUseNumericSuffixes(bool value);
}
public abstract class JetBrains.ReSharper.Psi.Naming.Impl.ClrNamingConsistencyCheckerBase : object {
    public virtual bool IsApplicable(IPsiSourceFile sourceFile);
    [PureAttribute]
[CanBeNullAttribute]
protected virtual IDeclaredElement GetDeclaredElementToCheck(IDeclaration declaration);
    public sealed virtual void Check(IDeclaration declaration, INamingPolicyProvider namingPolicyProvider, Boolean& isFinalResult, NamingConsistencyCheckResult& result);
    protected bool ShouldCheckNaming(IDeclaration declaration);
    protected bool ShouldCheckNaming(IDeclaredElement declaredElement, string shortName);
    protected bool DoesCorrespondWithPolicy(IDeclaration declaration, INamingPolicyProvider namingPolicyProvider, NamingPolicy policy, String& canonicalName);
    protected bool DoesCorrespondWithPolicy(IDeclaredElement declaredElement, string shortName, INamingPolicyProvider namingPolicyProvider, NamingPolicy policy, String& canonicalName);
    protected virtual bool IsException(string canonicalName);
    private bool CheckEventHandlerMethod(string name, IMethod member, INamingPolicyProvider namingPolicyProvider);
    private static bool CheckEventHandlerMethod(string name, string pattern);
    protected abstract virtual bool IsUnnamedElement(IDeclaration declaration);
}
public class JetBrains.ReSharper.Psi.Naming.Impl.ClrNamingLanguageServiceBase : NamingLanguageServiceBase {
    private IEnumerable`1<IClrNamingSuggestionAdviser> myNamingSuggestionAdvisers;
    private static ObjectPool`1<PooledHashSet`1<IType>> ourPool;
    public bool IsSameNestedNameAllowedForMembers { get; }
    public ClrNamingLanguageServiceBase(PsiLanguageType language, IEnumerable`1<IClrNamingSuggestionAdviser> namingSuggestionAdvisers);
    private static ClrNamingLanguageServiceBase();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Naming.Impl.ClrNamingLanguageServiceBase/<SuggestRoots>d__3")]
public virtual IEnumerable`1<NameRoot> SuggestRoots(IType type, INamingPolicyProvider policyProvider);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Naming.Impl.ClrNamingLanguageServiceBase/<SuggestRootsNoCycles>d__4")]
protected virtual IEnumerable`1<NameRoot> SuggestRootsNoCycles(IType type, INamingPolicyProvider policyProvider, HashSet`1<IType> visited);
    public virtual bool get_IsSameNestedNameAllowedForMembers();
    private static Pair`2<IEnumerable`1<IType>, string> GetElementTypes(IDeclaredType declaredType);
    public virtual ScopeKind GetScopeKind(IDeclaredElement element);
    protected virtual IEnumerable`1<NameRoot> SuggestRoots(IReference reference, IReference qualifierReference, INamingPolicyProvider policyProvider);
    private IEnumerable`1<NameRoot> SuggestClrNameRoots(IReference reference, IReference qualifierReference, INamingPolicyProvider policyProvider, bool allowQualifierSuggestion);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Naming.Impl.ClrNamingLanguageServiceBase/<SuggestRootsWithQualifier>d__11")]
private IEnumerable`1<NameRoot> SuggestRootsWithQualifier(IReference reference, IReference qualifierReference, INamingPolicyProvider policyProvider);
    private static bool CanUseQualifierToClarifyName(IReference qualifierReference);
    [NotNullAttribute]
private NameRoot[] SuggestEventHandlerRoot(IEvent event, IReference qualifierReference, INamingPolicyProvider policyProvider, NameRoot root, NamingManager namingManager);
    private static NameRoot GetEventHandlerName(INamingPolicyProvider policyProvider, NamingManager namingManager, string patternNew);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Naming.Impl.ClrNamingLanguageServiceBase/<SuggestRoots>d__15")]
public virtual IEnumerable`1<NameRoot> SuggestRoots(IDeclaredElement declaredElement, INamingPolicyProvider policyProvider);
}
public abstract class JetBrains.ReSharper.Psi.Naming.Impl.CustomRulesBasedPolicyProvider`1 : object {
    private List`1<IElementKind> myElementKinds;
    private PsiLanguageType myLanguage;
    private IContextBoundSettingsStore myContextBoundSettingsStore;
    private TKey myKey;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    protected NamingPolicy UndefinedPolicy { get; }
    public IPsiSourceFile SourceFile { get; }
    protected CustomRulesBasedPolicyProvider`1(PsiLanguageType language, IPsiSourceFile sourceFile, IContextBoundSettingsStore settingsStore);
    protected abstract virtual NamingPolicy get_UndefinedPolicy();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiSourceFile get_SourceFile();
    private static IDataContext CreateContext(DataContexts contexts, Lifetime lifetime, ISolution solution, IPsiSourceFile sourceFile);
    public sealed virtual string GetRuleName(IDeclaredElement declaredElement);
    public sealed virtual NamingPolicy GetPolicy(NamedElementKinds namedElementKind, IElementKind namedElementDescriptor, AccessRightKinds accessRightKinds, StaticnessKinds staticnessKinds);
    public virtual NamingPolicy GetPolicy(IElementKind elementKind);
    public virtual NamingPolicy GetPolicy(IDeclaredElement declaredElement);
    public sealed virtual void SetPolicy(IDeclaredElement declaredElement, NamingPolicy policy, IContextBoundSettingsStore settingsStore);
    public sealed virtual bool IsAbbreviation(string text, ISolution solution);
    public sealed virtual void AddAbbreviation(string text, ISolution solution);
    public sealed virtual void RemoveAbbreviation(string text, ISolution solution);
    public virtual IReadOnlyList`1<string> GetAllPrefixes();
    public virtual IReadOnlyList`1<string> GetAllSuffixes();
    public sealed virtual IReadOnlyList`1<string> GetAllPrefixesToWarn();
    public sealed virtual IReadOnlyList`1<string> GetAllSuffixesToWarn();
    public sealed virtual string GetExceptionName();
    public sealed virtual string PresentWithLongPattern(string objNew, string eventNew);
    public sealed virtual string PresentWithShortPattern(string eventNew);
    public sealed virtual Hash AddSettingsToHash(Hash hash);
    public sealed virtual string GetEventHandlerPatternLong();
    public sealed virtual string GetEventHandlerPatternShort();
    public sealed virtual bool SupportVSEventNamingPattern();
    private IList`1<IElementKind> GetRelatedElementKinds();
    private NamingPolicy GetPolicyForKind(IElementKind elementKind);
}
public class JetBrains.ReSharper.Psi.Naming.Impl.DummyPolicyProvider : object {
    public static INamingPolicyProvider Null;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    public IPsiSourceFile SourceFile { get; }
    public DummyPolicyProvider(IPsiSourceFile sourceFile);
    private static DummyPolicyProvider();
    public sealed virtual string GetRuleName(IDeclaredElement declaredElement);
    public sealed virtual NamingPolicy GetPolicy(IDeclaredElement declaredElement);
    public sealed virtual void SetPolicy(IDeclaredElement declaredElement, NamingPolicy policy, IContextBoundSettingsStore settingsStore);
    public sealed virtual NamingPolicy GetPolicy(NamedElementKinds namedElementKind, IElementKind namedElementDescriptor, AccessRightKinds accessRightKinds, StaticnessKinds staticnessKinds);
    public sealed virtual NamingPolicy GetPolicy(IElementKind elementKind);
    public sealed virtual bool IsAbbreviation(string text, ISolution solution);
    public sealed virtual void AddAbbreviation(string text, ISolution solution);
    public sealed virtual void RemoveAbbreviation(string text, ISolution solution);
    public sealed virtual IReadOnlyList`1<string> GetAllPrefixes();
    public sealed virtual IReadOnlyList`1<string> GetAllSuffixes();
    public sealed virtual IReadOnlyList`1<string> GetAllPrefixesToWarn();
    public sealed virtual IReadOnlyList`1<string> GetAllSuffixesToWarn();
    public sealed virtual Hash AddSettingsToHash(Hash hash);
    [CompilerGeneratedAttribute]
public sealed virtual IPsiSourceFile get_SourceFile();
    public sealed virtual string GetExceptionName();
    public sealed virtual string GetEventHandlerPatternLong();
    public sealed virtual string GetEventHandlerPatternShort();
    public sealed virtual bool SupportVSEventNamingPattern();
    public sealed virtual string PresentWithLongPattern(string objNew, string eventNew);
    public sealed virtual string PresentWithShortPattern(string eventNew);
}
public enum JetBrains.ReSharper.Psi.Naming.Impl.Emphasis : Enum {
    public int value__;
    public static Emphasis Good;
    public static Emphasis Unknown;
    public static Emphasis Bad;
}
public interface JetBrains.ReSharper.Psi.Naming.Impl.IClrNamingSuggestionAdviser {
    public abstract virtual IReadOnlyList`1<NameRoot> SuggestRoots(IType type, Func`2<IType, IEnumerable`1<NameRoot>> nameProvider);
}
public class JetBrains.ReSharper.Psi.Naming.Impl.Name : object {
    [CompilerGeneratedAttribute]
private NameSuffix <NameSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private NamePrefix <NamePrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<NameInnerElement> <InnerElements>k__BackingField;
    public NameSuffix NameSuffix { get; }
    public NamePrefix NamePrefix { get; }
    public List`1<NameInnerElement> InnerElements { get; }
    public bool HasErrors { get; }
    public Name(NameSuffix nameSuffix, NamePrefix namePrefix, List`1<NameInnerElement> innerElements);
    [CompilerGeneratedAttribute]
public NameSuffix get_NameSuffix();
    [CompilerGeneratedAttribute]
public NamePrefix get_NamePrefix();
    [CompilerGeneratedAttribute]
public List`1<NameInnerElement> get_InnerElements();
    public string GetShortName();
    public string GetCanonicalName();
    [CanBeNullAttribute]
[PureAttribute]
public NameRoot GetRoot();
    [NotNullAttribute]
[PureAttribute]
public NameRoot GetRootOrDefault(string root);
    public virtual string ToString();
    public bool get_HasErrors();
}
public static class JetBrains.ReSharper.Psi.Naming.Impl.NameCanoniser : object {
    public static string GetCanonicalShortName(string name, PsiLanguageType languageType);
    public static string GetCanonicalQualifiedName(string name, PsiLanguageType languageType);
}
public class JetBrains.ReSharper.Psi.Naming.Impl.NameElement : object {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CanonicalText>k__BackingField;
    [NotNullAttribute]
public string Text { get; }
    [NotNullAttribute]
public string CanonicalText { get; }
    public bool HasErrors { get; }
    public NameElement(string text, string canonicalText);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public string get_CanonicalText();
    public bool get_HasErrors();
    public bool Equals(NameElement obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class JetBrains.ReSharper.Psi.Naming.Impl.NameInnerElement : NameElement {
    public bool IsSeparator { get; }
    protected NameInnerElement(string text, string canonicalText);
    public abstract virtual bool get_IsSeparator();
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Naming.Impl.NameParser : object {
    [NotNullAttribute]
public static Char[] DIGITS;
    [NotNullAttribute]
private ISolution mySolution;
    [NotNullAttribute]
private NamingPolicyManager mySettingsManager;
    [NotNullAttribute]
private CultureInfo myHostCulture;
    public NameParser(ISolution solution, NamingPolicyManager settingsManager, HostCulture hostCulture);
    private static NameParser();
    [NotNullAttribute]
public Name GetName(IDeclaredElement element, string defaultRoot, PsiLanguageType language, IPsiSourceFile sourceFile);
    [NotNullAttribute]
public Name GetName(IDeclaredElement element, string defaultRoot, INamingPolicyProvider policyProvider);
    [NotNullAttribute]
public string RenderNameSafe(NameRoot nameRoot, NamingRule namingRule, PsiLanguageType language, IPsiSourceFile sourceFile, ITreeNode usageContext);
    [NotNullAttribute]
[PureAttribute]
public string RenderNameSafe(NameRoot nameRoot, NamingRule namingRule, PsiLanguageType language, INamingPolicyProvider policyProvider, ITreeNode usageContext);
    [NotNullAttribute]
[PureAttribute]
public string Render(NameRoot nameRoot, NamingRule rule, INamingPolicyProvider namingPolicyProvider);
    [NotNullAttribute]
[PureAttribute]
public Name Parse(string name, NamingRule namingRule, PsiLanguageType language, IPsiSourceFile sourceFile);
    [NotNullAttribute]
[PureAttribute]
public Name Parse(string name, NamingRule namingRule, INamingPolicyProvider policyProvider);
    [NotNullAttribute]
private string GetCanonicalWord(string word, NamingStyleKinds kind, bool isFirstInName, bool isFirstInNamePart, INamingPolicyProvider policyProvider, bool forceAbbreviationsUpper);
    private bool CanBeAbbreviation(string word);
    [NotNullAttribute]
private string GetUpperWord(string word, bool isAbbreviation, bool forceAbbreviationsUpper);
    [PureAttribute]
private static bool MustHaveUnderscore(NamingRule rule);
    private static bool CanHaveUnderscore(NamingRule rule);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Naming.Impl.NameParser/<SplitTextByWords>d__19")]
private static IEnumerable`1<string> SplitTextByWords(string name);
    [PureAttribute]
private static SymbolKinds GetSymbolKinds(char c);
    [NotNullAttribute]
[PureAttribute]
public string ToUpper(string s);
    [NotNullAttribute]
[PureAttribute]
public string ToLower(string s);
    [NotNullAttribute]
[PureAttribute]
public string ToCamel(string s);
}
public class JetBrains.ReSharper.Psi.Naming.Impl.NamePrefix : NameElement {
    public NamePrefix(string text, string canonicalText);
}
public class JetBrains.ReSharper.Psi.Naming.Impl.NameRoot : object {
    private static JetHashSet`1<string> ourStupidNames;
    [CompilerGeneratedAttribute]
private IList`1<NameInnerElement> <Words>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFinalPresentation>k__BackingField;
    [CompilerGeneratedAttribute]
private Emphasis <Emphasis>k__BackingField;
    [CompilerGeneratedAttribute]
private PluralityKinds <PluralityKind>k__BackingField;
    [NotNullAttribute]
public IList`1<NameInnerElement> Words { get; }
    public bool IsFinalPresentation { get; }
    public Emphasis Emphasis { get; public set; }
    public PluralityKinds PluralityKind { get; }
    [CanBeNullAttribute]
public NameWord FirstWord { get; }
    public NameRoot(IList`1<NameInnerElement> rootWords, PluralityKinds pluralityKind, bool isFinalName);
    private static NameRoot();
    [CompilerGeneratedAttribute]
public IList`1<NameInnerElement> get_Words();
    [CompilerGeneratedAttribute]
public bool get_IsFinalPresentation();
    [CompilerGeneratedAttribute]
public Emphasis get_Emphasis();
    [CompilerGeneratedAttribute]
public void set_Emphasis(Emphasis value);
    [CompilerGeneratedAttribute]
public PluralityKinds get_PluralityKind();
    public NameWord get_FirstWord();
    public sealed virtual object Clone();
    [NotNullAttribute]
[PureAttribute]
public static NameRoot FromWords(Emphasis emphasis, bool isFinalName, String[] words);
    [NotNullAttribute]
[PureAttribute]
public NameRoot WithNewEmphasis(Emphasis emphasis);
    [NotNullAttribute]
[PureAttribute]
public NameRoot AppendString(string identSuffix);
    [NotNullAttribute]
[PureAttribute]
public NameRoot PrependString(string identSuffix);
    [NotNullAttribute]
[PureAttribute]
public NameRoot AppendRoot(NameRoot root);
    [NotNullAttribute]
[PureAttribute]
public NameRoot Subroot(int start, int length);
    [NotNullAttribute]
[PureAttribute]
public NameRoot AppendStringToLastWord(string identSuffix);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Naming.Impl.NameRoot/<GetSubroots>d__25")]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public IEnumerable`1<NameRoot> GetSubroots(PredefinedPrefixPolicy predefinedPrefixPolicy, SubrootPolicy subrootPolicy);
    public bool Equals(NameRoot other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private static Emphasis GetEmphasis(string text);
    [NotNullAttribute]
public string GetFinalPresentation();
}
public class JetBrains.ReSharper.Psi.Naming.Impl.NameSeparator : NameInnerElement {
    public bool IsSeparator { get; }
    public NameSeparator(string text, string canonicalText);
    public virtual bool get_IsSeparator();
}
public class JetBrains.ReSharper.Psi.Naming.Impl.NameSuffix : NameElement {
    public NameSuffix(string text, string canonicalText);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Naming.Impl.NameSuggestionManager : object {
    [CompilerGeneratedAttribute]
private ISolution <solution>P;
    [CompilerGeneratedAttribute]
private NameParser <nameParser>P;
    [CompilerGeneratedAttribute]
private NamingPolicyManager <namingPolicyManager>P;
    public NameSuggestionManager(ISolution solution, NameParser nameParser, NamingPolicyManager namingPolicyManager);
    [PureAttribute]
public INamesCollection CreateEmptyCollection(PluralityKinds pluralityKind, PsiLanguageType language, bool longerNamesFirst, INamingPolicyProvider namingPolicyProvider);
    [PureAttribute]
public INamesCollection CreateEmptyCollection(PluralityKinds pluralityKind, PsiLanguageType language, INamingPolicyProvider namingPolicyProvider);
    [PureAttribute]
public INamesCollection CreateEmptyCollection(PluralityKinds pluralityKind, PsiLanguageType language, bool longerNamesFirst, IPsiSourceFile psiSourceFile);
    [PureAttribute]
public INamesCollection CreateEmptyCollection(PluralityKinds pluralityKind, PsiLanguageType language, bool longerNamesFirst, ITreeNode node);
    [PureAttribute]
public string GetDerivedName(IDeclaredElement sampleElement, IDeclaredElement targetElement, SuggestionOptions options, IPsiSourceFile sourceFileForNaming);
    [PureAttribute]
public string GetDerivedName(IDeclaredElement sampleElement, NamedElementKinds elementKind, ScopeKind scopeKind, PsiLanguageType language, SuggestionOptions options, IPsiSourceFile psiSourceFile);
    [PureAttribute]
public string GetDerivedName(string shortSimpleName, NamedElementKinds elementKind, ScopeKind scopeKind, PsiLanguageType language, SuggestionOptions options, IPsiSourceFile psiSourceFile);
    [PureAttribute]
public string GetDerivedName(string shortSimpleName, IElementKind elementKind, ScopeKind scopeKind, PsiLanguageType language, SuggestionOptions options, IPsiSourceFile psiSourceFile);
    public INamesSuggestion SuggestName(IExpression expression, IDeclaredElement declaredElement, string defaultName);
}
[LocalizableAttribute("False")]
public class JetBrains.ReSharper.Psi.Naming.Impl.NameWord : NameInnerElement {
    private static JetHashSet`1<string> ourSkipTailInfix;
    private static JetHashSet`1<string> ourPredefinedPrefixes;
    private static JetHashSet`1<string> ourCollectionSuffixes;
    [CompilerGeneratedAttribute]
private bool <IsAbbreviation>k__BackingField;
    public bool IsAbbreviation { get; }
    public bool IsSeparator { get; }
    public bool IsVerbPrefix { get; }
    public bool IsCollectionSuffix { get; }
    public bool IsSkipTailInfix { get; }
    public NameWord(string text, string canonicalText);
    public NameWord(string text, string canonicalText, bool isAbbreviation);
    private static NameWord();
    [CompilerGeneratedAttribute]
public bool get_IsAbbreviation();
    public virtual bool get_IsSeparator();
    public bool CanBeIdentifier();
    public bool get_IsVerbPrefix();
    public bool get_IsCollectionSuffix();
    public bool get_IsSkipTailInfix();
}
public class JetBrains.ReSharper.Psi.Naming.Impl.NamingConsistencyCheckResult : object {
    public bool HasErrors;
    public string ShortName;
    public string CanonicalName;
    public string RuleName;
    public static NamingConsistencyCheckResult OK { get; }
    public static NamingConsistencyCheckResult get_OK();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[LanguageAttribute("JetBrains.ReSharper.Psi.PsiLanguageType", "16")]
public class JetBrains.ReSharper.Psi.Naming.Impl.NamingLanguageServiceBase : object {
    [CompilerGeneratedAttribute]
private PsiLanguageType <Language>k__BackingField;
    protected PsiLanguageType Language { get; }
    public NamingLanguageServiceBase(PsiLanguageType language);
    [CompilerGeneratedAttribute]
protected PsiLanguageType get_Language();
    public virtual NamedElementKinds GetNamedElementKind(IDeclaredElement element);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Naming.Impl.NamingLanguageServiceBase/<ExpandAndShortenKeywords>d__5")]
public sealed virtual IEnumerable`1<NameRoot> ExpandAndShortenKeywords(IEnumerable`1<NameRoot> roots);
    public sealed virtual string ConvertNameToUnmangledSafe(string name);
    public virtual string MangleNameIfNecessary(string name, ITreeNode usageContext);
    private static string MakeUnmangledNameSafe(string name);
    protected virtual string Unmangle(string name);
    public virtual IEnumerable`1<NameRoot> SuggestRoots(ITreeNode element, bool useExpectedTypes, INamingPolicyProvider policyProvider);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Naming.Impl.NamingLanguageServiceBase/<SuggestRoots>d__11")]
protected virtual IEnumerable`1<NameRoot> SuggestRoots(IReference reference, IReference qualifierReference, INamingPolicyProvider policyProvider);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Naming.Impl.NamingLanguageServiceBase/<PluralToSingle>d__12")]
protected static IEnumerable`1<NameRoot> PluralToSingle(IEnumerable`1<NameRoot> operandRoots);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Naming.Impl.NamingLanguageServiceBase/<SuggestRoots>d__13")]
public virtual IEnumerable`1<NameRoot> SuggestRoots(IDeclaredElement declaredElement, INamingPolicyProvider policyProvider);
    public sealed virtual bool IsUnique(string shortName, ITreeNode context, ScopeKind elementKind);
    [PureAttribute]
protected virtual bool IsLocalDeclaration(IDeclaration declaration);
    [PureAttribute]
protected virtual bool IsStaticScope(ILocalScope localScope);
    public virtual ScopeKind GetScopeKind(IDeclaredElement element);
    protected virtual void AddConflictingFromSymbolTable(string name, ITreeNode context, ScopeKind kind, ISymbolTable table, HashSet`1<IDeclaredElement> conflicted);
    protected virtual ISymbolTable FilterConflictingElementsSymbolTable(ISymbolTable table, ITreeNode context);
    public virtual IList`1<IDeclaredElement> GetConflictedElements(string name, ITreeNode context, ScopeKind kind);
    protected virtual void AddSymbolsFromNestedScope(ITreeNode context, HashSet`1<IDeclaredElement> conflicted, ITreeNode scope, string shortName);
    protected virtual NameRoot GetAbbreviation(NameRoot root);
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Naming.Impl.NamingPolicyManager : object {
    private ILanguageManager myLanguageManager;
    private ISolution mySolution;
    public NamingPolicyManager(ILanguageManager languageManager, ISolution solution);
    [NotNullAttribute]
[PureAttribute]
public INamingPolicyProvider GetPolicyProvider(PsiLanguageType language, IPsiSourceFile sourceFile, IContextBoundSettingsStore settingsStore);
    [NotNullAttribute]
[PureAttribute]
public INamingPolicyProvider GetPolicyProvider(PsiLanguageType language, IPsiSourceFile sourceFile);
    [NotNullAttribute]
[PureAttribute]
public INamingPolicyProvider GetPolicyProvider(ITreeNode context);
    [NotNullAttribute]
[PureAttribute]
public NamingRule GetDefaultRule(NamedElementKinds namedElementKind, PsiLanguageType language, IPsiSourceFile sourceFile);
    [NotNullAttribute]
[PureAttribute]
public NamingRule GetDefaultRule(NamedElementKinds namedElementKind, ITreeNode context);
    [NotNullAttribute]
[PureAttribute]
public NamingPolicy GetPolicy(NamedElementKinds namedElementKind, PsiLanguageType language, IPsiSourceFile sourceFile);
    [NotNullAttribute]
[PureAttribute]
public NamingRule GetDefaultRule(IPsiSourceFile sourceFile, PsiLanguageType language, IContextBoundSettingsStore settingsStore, NamedElementKinds namedElementKind, IElementKind namedElementDescriptor);
    [NotNullAttribute]
[PureAttribute]
public NamingRule GetDefaultRule(IElementKind elementKind, IPsiSourceFile sourceFile);
    [NotNullAttribute]
public NamingRule GetDefaultRule(IDeclaredElement declaredElement, PsiLanguageType language, IPsiSourceFile sourceFile);
    [NotNullAttribute]
public NamingPolicy GetPolicy(IDeclaredElement declaredElement, PsiLanguageType language, IPsiSourceFile sourceFile);
    public void SetPolicy(IDeclaredElement declaredElement, PsiLanguageType language, IPsiSourceFile sourceFile, NamingPolicy policy, IContextBoundSettingsStore contextBoundSettingsStore);
    [NotNullAttribute]
public NamingPolicy GetPolicy(IPsiSourceFile sourceFile, PsiLanguageType language, NamedElementKinds namedElementKind, IElementKind namedElementDescriptor, AccessRightKinds accessRightKinds, StaticnessKinds staticnessKinds);
    [NotNullAttribute]
public string GetRuleName(IDeclaredElement element, PsiLanguageType language, IPsiSourceFile sourceFile);
    [NotNullAttribute]
public string GetRuleName(IDeclaredElement element, PsiLanguageType language, INamingPolicyProvider policyProvider);
}
public static class JetBrains.ReSharper.Psi.Naming.Impl.NamingUtil : object {
    public static IEnumerable`1<string> SortShortNames(IEnumerable`1<string> roots, bool longNameFirst);
    [ObsoleteAttribute("Use NamingManager.IsIdentifier")]
public static bool IsIdentifier(string name);
    [NotNullAttribute]
public static IEnumerable`1<NameRoot> DecomposeRoot(NameRoot nameRoot, PredefinedPrefixPolicy predefinedPrefixPolicy, SubrootPolicy subrootPolicy);
    [NotNullAttribute]
public static ICollection`1<NameRoot> MergeIdenticalNameRoots(IEnumerable`1<NameRoot> roots);
    [CanBeNullAttribute]
public static NameRoot GetRootOfLiteralValue(string value);
    [NotNullAttribute]
[PureAttribute]
public static NameRoot NextRoot(NameRoot root, int index);
    [NotNullAttribute]
[PureAttribute]
private static string NextWord(string text, int index);
    public static string PresentNamedElementKind(NamedElementKinds namedElementKinds);
    [NotNullAttribute]
public static NameRoot PluralToSingle(NameRoot nameRoot);
    [CanBeNullAttribute]
public static NameRoot TryPluralToSingle(NameRoot nameRoot);
    [NotNullAttribute]
public static NameRoot SingleToPlural(NameRoot nameRoot, string suffixToUseIfAlreadyPlural);
    public static bool IsValidQualifiedName(string text, PsiLanguageType language);
    public static bool IsValidQualifiedName(string text, PsiLanguageType language, DeclaredElementType declaredElementType);
    [ObsoleteAttribute("Split and use NamingManager.IsIdentifier")]
public static bool IsValidQualifiedName(string text);
    [CanBeNullAttribute]
public static string TryGetIdent(string s);
    public static RichText GetRulePresentation(NamingPolicy namingPolicy);
    public static string GetShortRulePresentation(NamingPolicy namingPolicy);
    public static string GetExtendedRulePresentation(NamingPolicy namingPolicy);
    [NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<NameRoot> SortNameRoots(IEnumerable`1<NameRoot> roots, bool longerNamesFirst);
    [PureAttribute]
private static int CompareRoots(NameRoot root1, NameRoot root2, bool longNameFirst);
    private static int CompareShortNames(string name1, string name2, bool longNameFirst);
}
public enum JetBrains.ReSharper.Psi.Naming.Impl.PluralityKinds : Enum {
    public int value__;
    public static PluralityKinds Plural;
    public static PluralityKinds Single;
    public static PluralityKinds Unknown;
}
public enum JetBrains.ReSharper.Psi.Naming.Impl.PredefinedPrefixPolicy : Enum {
    public int value__;
    public static PredefinedPrefixPolicy Ignore;
    public static PredefinedPrefixPolicy Remove;
    public static PredefinedPrefixPolicy Preserve;
}
public enum JetBrains.ReSharper.Psi.Naming.Impl.ScopeKind : Enum {
    public int value__;
    public static ScopeKind TypeAndNamespace;
    public static ScopeKind LocalSelfScoped;
    public static ScopeKind Common;
}
[SolutionComponentAttribute("16")]
internal class JetBrains.ReSharper.Psi.Naming.Impl.UniqueNamesService : object {
    public sealed virtual bool IsUnique(string name, ITreeNode context, ScopeKind kind);
    public sealed virtual IList`1<IDeclaredElement> GetConflictedElements(string name, ITreeNode context, ScopeKind kind);
}
public interface JetBrains.ReSharper.Psi.Naming.INameCanoniser {
    public abstract virtual string GetCanonicalShortName(string name);
    public abstract virtual string GetCanonicalQualifiedName(string name);
}
public interface JetBrains.ReSharper.Psi.Naming.Interfaces.IClrNamingLanguageService {
    public bool IsSameNestedNameAllowedForMembers { get; }
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IEnumerable`1<NameRoot> SuggestRoots(IType type, INamingPolicyProvider policyProvider);
    public abstract virtual bool get_IsSameNestedNameAllowedForMembers();
}
public interface JetBrains.ReSharper.Psi.Naming.Interfaces.INamingCheckException {
    public abstract virtual bool ShouldBeExcepted(IDeclaredElement declaredElement);
    public abstract virtual bool IsApplicable(IPsiSourceFile sourceFile);
}
public interface JetBrains.ReSharper.Psi.Naming.Interfaces.INamingConsistencyChecker {
    public abstract virtual bool IsApplicable(IPsiSourceFile sourceFile);
    public abstract virtual void Check(IDeclaration declaration, INamingPolicyProvider namingPolicyProvider, Boolean& isFinalResult, NamingConsistencyCheckResult& result);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.Naming.Interfaces.INamingLanguageService {
    [PureAttribute]
public abstract virtual IEnumerable`1<NameRoot> SuggestRoots(ITreeNode element, bool useExpectedTypes, INamingPolicyProvider policyProvider);
    [PureAttribute]
public abstract virtual IEnumerable`1<NameRoot> SuggestRoots(IDeclaredElement declaredElement, INamingPolicyProvider policyProvider);
    [PureAttribute]
public abstract virtual bool IsUnique(string shortName, ITreeNode context, ScopeKind elementKind);
    [PureAttribute]
public abstract virtual NamedElementKinds GetNamedElementKind(IDeclaredElement element);
    public abstract virtual IEnumerable`1<NameRoot> ExpandAndShortenKeywords(IEnumerable`1<NameRoot> roots);
    public abstract virtual string MangleNameIfNecessary(string name, ITreeNode usageContext);
    public abstract virtual string ConvertNameToUnmangledSafe(string name);
    [PureAttribute]
public abstract virtual ScopeKind GetScopeKind(IDeclaredElement element);
    [PureAttribute]
public abstract virtual IList`1<IDeclaredElement> GetConflictedElements(string name, ITreeNode context, ScopeKind kind);
}
public interface JetBrains.ReSharper.Psi.Naming.Interfaces.INamingPolicyProvider {
    [CanBeNullAttribute]
public IPsiSourceFile SourceFile { get; }
    [NotNullAttribute]
public abstract virtual string GetRuleName(IDeclaredElement declaredElement);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual NamingPolicy GetPolicy(IDeclaredElement declaredElement);
    public abstract virtual void SetPolicy(IDeclaredElement declaredElement, NamingPolicy policy, IContextBoundSettingsStore settingsStore);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual NamingPolicy GetPolicy(NamedElementKinds namedElementKind, IElementKind namedElementDescriptor, AccessRightKinds accessRightKinds, StaticnessKinds staticnessKinds);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual NamingPolicy GetPolicy(IElementKind elementKind);
    public abstract virtual bool IsAbbreviation(string text, ISolution solution);
    public abstract virtual void AddAbbreviation(string text, ISolution solution);
    public abstract virtual void RemoveAbbreviation(string text, ISolution solution);
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<string> GetAllPrefixes();
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<string> GetAllSuffixes();
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<string> GetAllPrefixesToWarn();
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<string> GetAllSuffixesToWarn();
    public abstract virtual Hash AddSettingsToHash(Hash hash);
    public abstract virtual IPsiSourceFile get_SourceFile();
    [NotNullAttribute]
public abstract virtual string GetExceptionName();
    public abstract virtual string GetEventHandlerPatternLong();
    public abstract virtual string GetEventHandlerPatternShort();
    public abstract virtual bool SupportVSEventNamingPattern();
    public abstract virtual string PresentWithLongPattern(string objNew, string eventNew);
    public abstract virtual string PresentWithShortPattern(string eventNew);
}
public interface JetBrains.ReSharper.Psi.Naming.Interfaces.INamingPolicyProviderFactory {
    [NotNullAttribute]
[PureAttribute]
public abstract virtual INamingPolicyProvider CreatePolicyProvider(ISolution solution, IPsiSourceFile sourceFile, IContextBoundSettingsStore settingsStore);
}
public interface JetBrains.ReSharper.Psi.Naming.Interfaces.IUniqueNamesService {
    [PureAttribute]
public abstract virtual bool IsUnique(string name, ITreeNode context, ScopeKind kind);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IList`1<IDeclaredElement> GetConflictedElements(string name, ITreeNode context, ScopeKind kind);
}
[MeansImplicitUseAttribute]
[AttributeUsageAttribute("4")]
[BaseTypeRequiredAttribute("JetBrains.ReSharper.Psi.Naming.Interfaces.INamingCheckException")]
public class JetBrains.ReSharper.Psi.Naming.Interfaces.NamingCheckExceptionAttribute : LanguageAttribute {
    public NamingCheckExceptionAttribute(Type Language, Instantiation instantiation);
}
[MeansImplicitUseAttribute]
[AttributeUsageAttribute("4")]
[BaseTypeRequiredAttribute("JetBrains.ReSharper.Psi.Naming.Interfaces.INamingConsistencyChecker")]
public class JetBrains.ReSharper.Psi.Naming.Interfaces.NamingConsistencyCheckerAttribute : LanguageAttribute {
    public NamingConsistencyCheckerAttribute(Type Language, Instantiation instantiation);
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Naming.NamingManager : object {
    [CompilerGeneratedAttribute]
private NameParser <Parsing>k__BackingField;
    [CompilerGeneratedAttribute]
private NameSuggestionManager <Suggestion>k__BackingField;
    [CompilerGeneratedAttribute]
private NamingPolicyManager <Policy>k__BackingField;
    [CompilerGeneratedAttribute]
private IUniqueNamesService <UniqueNamesService>k__BackingField;
    [NotNullAttribute]
public NameParser Parsing { get; }
    [NotNullAttribute]
public NameSuggestionManager Suggestion { get; }
    [NotNullAttribute]
public NamingPolicyManager Policy { get; }
    [NotNullAttribute]
public IUniqueNamesService UniqueNamesService { get; }
    public NamingManager(NameParser parser, NameSuggestionManager nameSuggestionManager, NamingPolicyManager namingSettingsManager, IUniqueNamesService uniqueNamesService);
    [CompilerGeneratedAttribute]
public NameParser get_Parsing();
    [CompilerGeneratedAttribute]
public NameSuggestionManager get_Suggestion();
    [CompilerGeneratedAttribute]
public NamingPolicyManager get_Policy();
    [CompilerGeneratedAttribute]
public IUniqueNamesService get_UniqueNamesService();
    [NotNullAttribute]
public static INamingLanguageService GetNamingLanguageService(PsiLanguageType language);
    public static ScopeKind GetScopeKind(IDeclaredElement element);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Naming.Settings.AccessRightKinds : Enum {
    public int value__;
    public static AccessRightKinds No;
    public static AccessRightKinds Private;
    public static AccessRightKinds Protected;
    public static AccessRightKinds ProtectedInternal;
    public static AccessRightKinds Internal;
    public static AccessRightKinds Public;
    public static AccessRightKinds PrivateProtected;
    public static AccessRightKinds FileLocal;
    public static AccessRightKinds Any;
}
public class JetBrains.ReSharper.Psi.Naming.Settings.ClrLanguageNamingSettingsKeyBase : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "DefaultNameForExceptionVariableSettingDescription")]
[EditorConfigEntryAliasAttribute("default_exception_variable_name", "0")]
public string ExceptionName;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "EventHandlerNamePatternLongVersionWithObjectNameSettingDescription")]
public string EventHandlerPatternLong;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "EventHandlerNamePatternSettingDescription")]
public string EventHandlerPatternShort;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "SupportVisualStudioEventNamingPatternSettingDescription")]
public bool SupportVSEventNamingPattern;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "ListOfAbbreviationsSettingDescription")]
public IIndexedEntry`2<string, string> Abbreviations;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "ListOfNamingRulesSettingDescription")]
public IIndexedEntry`2<NamedElementKinds, NamingPolicy> PredefinedNamingRules;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "ListOfNamingRulesSettingDescription")]
public IIndexedEntry`2<Guid, ClrUserDefinedNamingRule> UserRules;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "ShouldAutoDetectedRulesBeAppliedSettingDescription")]
[HideInEditorConfigAttribute]
public bool ApplyAutoDetectedRules;
}
public class JetBrains.ReSharper.Psi.Naming.Settings.ClrNamedElementDescriptor : object {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private StaticnessKinds <Staticness>k__BackingField;
    [CompilerGeneratedAttribute]
private AccessRightKinds <AccessRightKinds>k__BackingField;
    [CompilerGeneratedAttribute]
private IElementKindSet <ElementKinds>k__BackingField;
    public string Description { get; public set; }
    public StaticnessKinds Staticness { get; public set; }
    public StaticnessKinds StaticnessForComparison { get; }
    public AccessRightKinds AccessRightKinds { get; public set; }
    public IElementKindSet ElementKinds { get; public set; }
    public ClrNamedElementDescriptor(AccessRightKinds accessRightKinds, StaticnessKinds staticness, IElementKindSet elementKind, string description);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public StaticnessKinds get_Staticness();
    [CompilerGeneratedAttribute]
public void set_Staticness(StaticnessKinds value);
    public StaticnessKinds get_StaticnessForComparison();
    [CompilerGeneratedAttribute]
public AccessRightKinds get_AccessRightKinds();
    [CompilerGeneratedAttribute]
public void set_AccessRightKinds(AccessRightKinds value);
    [CompilerGeneratedAttribute]
public IElementKindSet get_ElementKinds();
    [CompilerGeneratedAttribute]
public void set_ElementKinds(IElementKindSet value);
    public Hash AddToHash(Hash hash);
    public sealed virtual void ReadFromXml(XmlElement element);
    public sealed virtual void WriteToXml(XmlElement element);
    public bool Equals(ClrNamedElementDescriptor other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string DescribeFully();
    public bool Intersects(ClrNamedElementDescriptor other);
    public ClrNamedElementDescriptor IntersectWith(ClrNamedElementDescriptor other);
    public bool IsSubsetOf(ClrNamedElementDescriptor other);
    public bool AllConsts();
    public RoslynNamingSymbolModifier GetModifiers();
    public sealed virtual int CompareTo(ClrNamedElementDescriptor other);
}
public class JetBrains.ReSharper.Psi.Naming.Settings.ClrNamedElementDescriptorConverter : TypeConverterBase`1<ClrUserDefinedNamingRule> {
    private static int CacheCapacity;
    private static LimitedDictionary`2<string, XmlDocument> ourItemsCache;
    private static Func`2<string, XmlDocument> ourStringToPolicy;
    private static ClrNamedElementDescriptorConverter();
    private static ClrUserDefinedNamingRule StringToElementDescriptor(ITypeDescriptorContext context, CultureInfo cultureInfo, string value);
    private static string ElementDescriptorToString(ITypeDescriptorContext context, CultureInfo cultureInfo, ClrUserDefinedNamingRule descriptor);
    private static XmlDocument StringToDocument(string value);
}
public class JetBrains.ReSharper.Psi.Naming.Settings.ClrNamedElementDescriptorNoDescriptionComparer : object {
    public sealed virtual bool Equals(ClrNamedElementDescriptor x, ClrNamedElementDescriptor y);
    public sealed virtual int GetHashCode(ClrNamedElementDescriptor obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.Naming.Settings.ClrPolicyProviderBase : object {
    [PureAttribute]
public static NamingPolicy GetDefaultPolicy(NamedElementKinds elementKinds, bool enableInspections);
    [PureAttribute]
[PublicAPIAttribute]
public static NamingPolicy GetDefaultPolicy(NamedElementKinds elementKinds);
    [PureAttribute]
private static NamingRule GetDefaultRule(NamedElementKinds elementKinds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.Naming.Settings.ClrPolicyProviderBase`1 : object {
    private PsiLanguageType myLanguage;
    private IContextBoundSettingsStore myContextBoundSettingsStore;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected IReadOnlyList`1<ValueTuple`2<Guid, ClrUserDefinedNamingRule>> myUserRules;
    protected TKey myKey;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyList`1<string> myAllPrefixes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyList`1<string> myAllSuffixes;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    [NullableAttribute("2")]
public IPsiSourceFile SourceFile { get; }
    protected bool UsePredefinedNamingSettings { get; }
    protected ClrPolicyProviderBase`1(PsiLanguageType language, IPsiSourceFile psiSourceFile, IContextBoundSettingsStore settings, IEnumerable`1<Guid> defaultGuids);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual IPsiSourceFile get_SourceFile();
    protected abstract virtual bool get_UsePredefinedNamingSettings();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Naming.Settings.ClrPolicyProviderBase`1/<GetApplicableUserRules>d__12")]
private IEnumerable`1<ValueTuple`2<Guid, ClrUserDefinedNamingRule>> GetApplicableUserRules(IDeclaredElement declaredElement);
    public sealed virtual string GetRuleName(IDeclaredElement declaredElement);
    public virtual NamingPolicy GetPolicy(IDeclaredElement declaredElement);
    public sealed virtual void SetPolicy(IDeclaredElement declaredElement, NamingPolicy policy, IContextBoundSettingsStore settingsStore);
    [NullableContextAttribute("0")]
[PureAttribute]
private static ValueTuple`2<StaticnessKinds, AccessRightKinds> GetMetrics(IDeclaredElement declaredElement);
    private NamingPolicy GetRuleOfElementKind(NamedElementKinds kind, IElementKind namedElementDescriptor, AccessRightKinds accessRightKinds, StaticnessKinds staticnessKinds);
    private static AccessRightKinds GetAccessRights(AccessRights rights);
    public sealed virtual string GetExceptionName();
    public sealed virtual string GetEventHandlerPatternLong();
    public sealed virtual string GetEventHandlerPatternShort();
    public sealed virtual bool SupportVSEventNamingPattern();
    public sealed virtual string PresentWithLongPattern(string objNew, string eventNew);
    public sealed virtual string PresentWithShortPattern(string eventNew);
    public sealed virtual Hash AddSettingsToHash(Hash hash);
    private string DoWithTemplate(string pattern, string objNew, string eventNew);
    public virtual NamingPolicy GetPolicy(NamedElementKinds namedElementKind, IElementKind namedElementDescriptor, AccessRightKinds accessRightKinds, StaticnessKinds staticnessKinds);
    public sealed virtual NamingPolicy GetPolicy(IElementKind elementKind);
    public sealed virtual bool IsAbbreviation(string text, ISolution solution);
    public sealed virtual void AddAbbreviation(string text, ISolution solution);
    public sealed virtual void RemoveAbbreviation(string text, ISolution solution);
    public sealed virtual IReadOnlyList`1<string> GetAllPrefixes();
    public sealed virtual IReadOnlyList`1<string> GetAllPrefixesToWarn();
    protected virtual IReadOnlyList`1<string> GetAllPrefixes(bool toWarn);
    public sealed virtual IReadOnlyList`1<string> GetAllSuffixes();
    public sealed virtual IReadOnlyList`1<string> GetAllSuffixesToWarn();
    public virtual IReadOnlyList`1<string> GetAllSuffixes(bool toWarn);
    protected NamingPolicy GetRuleOfElementKind(NamedElementKinds kind);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Naming.Settings.ClrPolicyProviderBase`1/<GetAllPredefinedRules>d__39")]
private IEnumerable`1<Pair`2<NamedElementKinds, NamingPolicy>> GetAllPredefinedRules();
}
[TypeConverterAttribute("JetBrains.ReSharper.Psi.Naming.Settings.ClrNamedElementDescriptorConverter")]
public class JetBrains.ReSharper.Psi.Naming.Settings.ClrUserDefinedNamingRule : object {
    [CompilerGeneratedAttribute]
private ClrNamedElementDescriptor <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private NamingPolicy <Policy>k__BackingField;
    public ClrNamedElementDescriptor Descriptor { get; }
    public NamingPolicy Policy { get; private set; }
    public ClrUserDefinedNamingRule(ClrNamedElementDescriptor descriptor, NamingPolicy policy);
    [CompilerGeneratedAttribute]
public ClrNamedElementDescriptor get_Descriptor();
    [CompilerGeneratedAttribute]
public NamingPolicy get_Policy();
    [CompilerGeneratedAttribute]
private void set_Policy(NamingPolicy value);
    public sealed virtual void ReadFromXml(XmlElement element);
    public sealed virtual void WriteToXml(XmlElement element);
    public bool Equals(ClrUserDefinedNamingRule other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string DescribeFully();
}
public class JetBrains.ReSharper.Psi.Naming.Settings.CustomRulesNamingSettingsKeyBase : object {
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "ListOfAbbreviationsSettingDescription")]
public IIndexedEntry`2<string, string> Abbreviations;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "ListOfNamingRulesSettingDescription")]
public IIndexedEntry`2<string, NamingPolicy> UserRules;
}
public class JetBrains.ReSharper.Psi.Naming.Settings.EditorConfigNamingPolicySerializer : object {
    private static string DoNotCheck;
    private static string ExclusivePrefixesSuffixes;
    public sealed virtual ValueTuple`2<object, string> ConvertFromString(string str);
    public sealed virtual string ConvertToString(object value);
    [CompilerGeneratedAttribute]
internal static Nullable`1<NamingStyleKinds> <ConvertFromString>g__ParseNamingStyle|2_0(string s);
    [CompilerGeneratedAttribute]
internal static void <ConvertToString>g__AddRule|3_0(NamingRule rule, <>c__DisplayClass3_0& );
}
public enum JetBrains.ReSharper.Psi.Naming.Settings.NamedElementKinds : Enum {
    public int value__;
    public static NamedElementKinds TypesAndNamespaces;
    public static NamedElementKinds Interfaces;
    public static NamedElementKinds TypeParameters;
    [ObsoleteAttribute]
public static NamedElementKinds MethodPropertyEvent;
    public static NamedElementKinds Method;
    public static NamedElementKinds Property;
    public static NamedElementKinds Event;
    public static NamedElementKinds Locals;
    public static NamedElementKinds LocalConstants;
    public static NamedElementKinds Parameters;
    public static NamedElementKinds PublicFields;
    public static NamedElementKinds PrivateInstanceFields;
    public static NamedElementKinds PrivateStaticFields;
    public static NamedElementKinds Constants;
    public static NamedElementKinds PrivateConstants;
    public static NamedElementKinds StaticReadonly;
    public static NamedElementKinds PrivateStaticReadonly;
    public static NamedElementKinds EnumMember;
    public static NamedElementKinds LocalFunctions;
    public static NamedElementKinds Other;
}
public static class JetBrains.ReSharper.Psi.Naming.Settings.NamedElementKindsEx : object {
    private static NamedElementKinds[] ourValues;
    private static NamedElementKindsEx();
    public static NamedElementKinds[] GetValues();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeConverterAttribute("JetBrains.ReSharper.Psi.Naming.Settings.NamingPolicyConverter")]
[EditorConfigCustomValueSerializerAttribute("JetBrains.ReSharper.Psi.Naming.Settings.EditorConfigNamingPolicySerializer")]
public class JetBrains.ReSharper.Psi.Naming.Settings.NamingPolicy : object {
    public static NamingPolicy Default;
    [CompilerGeneratedAttribute]
private NamingRule <NamingRule>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<NamingRule> <ExtraRules>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableInspection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WarnAboutUsingPrefixesAndSuffixesFromThisRule>k__BackingField;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public NamingRule NamingRule { get; public set; }
    public IReadOnlyList`1<NamingRule> ExtraRules { get; public set; }
    public bool EnableInspection { get; public set; }
    public bool WarnAboutUsingPrefixesAndSuffixesFromThisRule { get; public set; }
    public NamingPolicy(NamingRule namingRule);
    public NamingPolicy(IReadOnlyList`1<NamingRule> extraRules, NamingRule namingRule, bool enableInspection, bool warnAboutUsingPrefixesAndSuffixesFromThisRule);
    [CompilerGeneratedAttribute]
private NamingPolicy(NamingPolicy original);
    private static NamingPolicy();
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public NamingRule get_NamingRule();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NamingRule(NamingRule value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<NamingRule> get_ExtraRules();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExtraRules(IReadOnlyList`1<NamingRule> value);
    [CompilerGeneratedAttribute]
public bool get_EnableInspection();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EnableInspection(bool value);
    [CompilerGeneratedAttribute]
public bool get_WarnAboutUsingPrefixesAndSuffixesFromThisRule();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_WarnAboutUsingPrefixesAndSuffixesFromThisRule(bool value);
    public Hash AddToHash(Hash hash);
    public virtual string ToString();
    public string DescribeFully(bool withInspection);
    [PureAttribute]
public static NamingPolicy CreateFromXml(XmlElement element);
    public sealed virtual void WriteToXml(XmlElement element);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(NamingPolicy other);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(NamingPolicy left, NamingPolicy right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(NamingPolicy left, NamingPolicy right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public NamingPolicy <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[UsedImplicitlyAttribute]
public class JetBrains.ReSharper.Psi.Naming.Settings.NamingPolicyConverter : TypeConverterBase`1<NamingPolicy> {
    private static int CacheCapacity;
    private static LimitedDictionary`2<string, XmlDocument> ourItemsCache;
    private static Func`2<string, XmlDocument> ourStringToPolicy;
    private static NamingPolicyConverter();
    private static NamingPolicy StringToPolicy(ITypeDescriptorContext context, CultureInfo cultureInfo, string value);
    private static string PolicyToString(ITypeDescriptorContext context, CultureInfo cultureInfo, NamingPolicy policy);
    private static XmlDocument StringToPolicy(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Naming.Settings.NamingRule : object {
    public static NamingRule Default;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Suffix>k__BackingField;
    [CompilerGeneratedAttribute]
private NamingStyleKinds <NamingStyleKind>k__BackingField;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public string Prefix { get; public set; }
    public string Suffix { get; public set; }
    public NamingStyleKinds NamingStyleKind { get; public set; }
    [CompilerGeneratedAttribute]
private NamingRule(NamingRule original);
    private static NamingRule();
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Prefix(string value);
    [CompilerGeneratedAttribute]
public string get_Suffix();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Suffix(string value);
    [CompilerGeneratedAttribute]
public NamingStyleKinds get_NamingStyleKind();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NamingStyleKind(NamingStyleKinds value);
    public Hash AddToHash(Hash hash);
    public virtual string ToString();
    public string PresentNamingRule();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(NamingRule left, NamingRule right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(NamingRule left, NamingRule right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(NamingRule other);
    [CompilerGeneratedAttribute]
public NamingRule <Clone>$();
}
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeStyleSettings", "JetBrains.ReSharper.Psi.Resources.Strings", "NamingSettingsSettingDescription")]
public class JetBrains.ReSharper.Psi.Naming.Settings.NamingSettings : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Naming.Settings.NamingSettingsUtil : object {
    public static string InconsistentNamingHighlightingID;
    private static Dictionary`2<string, string> ourEnumRenamesTable;
    private static NamingSettingsUtil();
    [NullableContextAttribute("0")]
public static Nullable`1<TEnum> GetEnumValueSafeWithUpgrade(string stringValue);
    [PureAttribute]
public static IReadOnlyList`1<NamingRule> ReadExtraRules(XmlElement xmlElement);
    public static void WriteExtraRules(XmlNode parentElement, NamingPolicy policy);
}
public enum JetBrains.ReSharper.Psi.Naming.Settings.NamingStyleKinds : Enum {
    public int value__;
    public static NamingStyleKinds AaBb;
    public static NamingStyleKinds AaBb_AaBb;
    public static NamingStyleKinds AaBb_aaBb;
    public static NamingStyleKinds aaBb;
    public static NamingStyleKinds aaBb_AaBb;
    public static NamingStyleKinds aaBb_aaBb;
    public static NamingStyleKinds AA_BB;
    public static NamingStyleKinds aa_bb;
    public static NamingStyleKinds Aa_bb;
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Naming.Settings.StaticnessKinds : Enum {
    public int value__;
    public static StaticnessKinds No;
    public static StaticnessKinds Static;
    public static StaticnessKinds Instance;
    public static StaticnessKinds Any;
}
public abstract class JetBrains.ReSharper.Psi.Naming.Settings.Upgrade.CodeStyleSettingsUpgrade : object {
    private ISolution mySolution;
    private IPartCatalogSet myPartsSet;
    protected CodeStyleSettingsUpgrade(ShellPartCatalogSet partsSet, ISolution solution);
    private sealed virtual override void JetBrains.ProjectModel.Settings.Upgrade.ISolutionSettingsUpgrader.Upgrade(IComponentSettingsProvider legacySettingsProvider, IContextBoundSettingsStore boundSettingsStore, Lifetime upgradeLifetime);
    private sealed virtual override void JetBrains.Application.Configuration.Upgrade.IGlobalSettingsUpgrader.Upgrade(IComponentSettingsProvider legacySettingsProvider, IContextBoundSettingsStore boundSettingsStore, Lifetime upgradeLifetime);
    protected abstract virtual void DoUpgrade(CodeStyleSettingsObsolete codeStyleSettings, IContextBoundSettingsStore contextBoundSettingsStore);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.NativeNumericTypeDecoration : TypeDecoration {
    public static NativeNumericTypeDecoration Instance;
    private static NativeNumericTypeDecoration();
    public virtual ITypeDecorationPointer CreatePointer();
    private sealed virtual override TypeDecoration JetBrains.ReSharper.Psi.ITypeDecorationPointer.Find();
    public virtual TUnderlyingType GetUnderlyingTypeProxy(TUnderlyingType underlyingType);
    [NullableContextAttribute("2")]
public virtual bool Equals(TypeDecoration other);
    public virtual int GetHashCode();
    private static bool GetSign(IDeclaredType declaredType);
    public virtual RichText PresentType(IType decoratedType, PsiLanguageType language, TypePresentationStyle style);
    public virtual string PresentType(IType decoratedType);
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.NativeNumericTypeExtensions : object {
    [NullableAttribute("1")]
private static Key`1<CachedProjectItemValue`2<IProject, bool>> ourNativeIntegerFeatureKey;
    private static NativeNumericTypeExtensions();
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNativeNumericWithoutRuntimeSupport(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNativeNumeric(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNativeInteger(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNativeUnsignedInteger(IType type);
    [ExtensionAttribute]
[PureAttribute]
public static bool LanguageSupportsNativeNumericTypes(IPsiModule psiModule);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static CachedProjectItemValue`2<IProject, bool> <LanguageSupportsNativeNumericTypes>g__CalculateNativeIntegerSupported|5_1(IProjectPsiModule psiModule);
}
public class JetBrains.ReSharper.Psi.NavigateablePsiSourceFileWithLocation : PsiSourceFileFromPath {
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <NavigationPath>k__BackingField;
    public VirtualFileSystemPath NavigationPath { get; }
    public NavigateablePsiSourceFileWithLocation(IProjectFileExtensions projectFileExtensions, PsiProjectFileTypeCoordinator projectFileTypeCoordinator, IPsiModule module, VirtualFileSystemPath path, Func`2<PsiSourceFileFromPath, bool> validityCheck, Func`2<PsiSourceFileFromPath, IPsiSourceFileProperties> propertiesFactory, DocumentManager documentManager, IModuleReferenceResolveContext resolveContext);
    public NavigateablePsiSourceFileWithLocation(IProjectFileExtensions projectFileExtensions, PsiProjectFileTypeCoordinator projectFileTypeCoordinator, IPsiModule module, VirtualFileSystemPath path, Func`2<PsiSourceFileFromPath, bool> validityCheck, Func`2<PsiSourceFileFromPath, IPsiSourceFileProperties> propertiesFactory, DocumentManager documentManager, IModuleReferenceResolveContext resolveContext, VirtualFileSystemPath navigationPath);
    [CompilerGeneratedAttribute]
public sealed virtual VirtualFileSystemPath get_NavigationPath();
}
[PsiSharedComponentAttribute("18")]
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Psi.NuGet.NuGetExternalAnnotationsFileProvider : EmbeddedExternalAnnotationsFileProvider {
    public static string PackageId;
    private bool myAllowPrerelease;
    private bool myAllowUnlisted;
    public NuGetExternalAnnotationsFileProvider(Lifetime lifetime, ProductSettingsLocation productSettingsLocation, ExternalAnnotationsFileProvider externalAnnotationsFileProvider, IPackageRepositoryFactory packageRepositoryFactory, IApplicationHost applicationHost, IThreading taskHost, ApplicationPackagesLocallyInstalled applicationPackagesLocallyInstalled, ILogger logger);
    private static NuGetExternalAnnotationsFileProvider();
    [CanBeNullAttribute]
private IPackage InitAnnotations(ILogger logger, LocalPackageRepository localRepository, IVersionSpec versionRestriction);
}
[ModuleReferencerAttribute("16")]
public class JetBrains.ReSharper.Psi.NuGet.NuGetModuleReferencer : object {
    public static Key`1<Optional`1<NuGetNupkg>> NupkgKey;
    private static int NuGetModuleReferencerPriority;
    private Lifetime myLifetime;
    private ITextControlManager myTextControlManager;
    private IShellLocks myShellLocks;
    private ITooltipManager myTooltipManager;
    public NuGetModuleReferencer(Lifetime lifetime, ITextControlManager textControlManager, IShellLocks shellLocks, ITooltipManager tooltipManager);
    private static NuGetModuleReferencer();
    public sealed virtual bool CanReferenceModule(IPsiModule module, IPsiModule moduleToReference, UserDataHolder context);
    [CanBeNullAttribute]
public static NuGetNupkg GetContainingNuGet(IPsiModule module);
    private static Optional`1<NuGetNupkg> GetContainingNuGet(IPsiModule module, NuGetAssemblyManager moduleHelper, IList`1<VirtualFileSystemPath> assemblyLocations);
    public sealed virtual bool ReferenceModule(IPsiModule module, IPsiModule moduleToReference);
    public sealed virtual bool ReferenceModuleWithType(IPsiModule module, ITypeElement typeToReference);
    private static bool IsProjectModule(IPsiModule module);
    private static bool IsAssemblyModule(IPsiModule module);
    private static IList`1<VirtualFileSystemPath> GetAllAssemblyLocations(IPsiModule psiModule);
    public static void PokeReSharpersAssemblyReferences(IShellLocks shellLocks, IPsiModule module, IEnumerable`1<VirtualFileSystemPath> assemblyLocations, VirtualFileSystemPath packageLocation, IProjectPsiModule projectModule);
    public static void HandleFailureToReference(VirtualFileSystemPath packageLocation, Lifetime lifetime, ITextControlManager textControlManager, IShellLocks shellLocks, ITooltipManager tooltipManager);
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.NuGet.NuGetPsiSourceFilePropertiesProvider : object {
    private ILogger myLogger;
    private ILazy`1<NuGetContentFileStorage> myLazyNuGetContentFileTracker;
    private NuGetContentFileStorage ContentFileStorage { get; }
    public double Order { get; }
    public NuGetPsiSourceFilePropertiesProvider(ILogger logger, ILazy`1<NuGetContentFileStorage> lazyNuGetContentFileTracker);
    private NuGetContentFileStorage get_ContentFileStorage();
    public sealed virtual double get_Order();
    public virtual IPsiSourceFileProperties GetPsiProperties(IPsiSourceFileProperties prevProperties, IProject project, IProjectFile projectFile, IPsiSourceFile sourceFile);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Psi.NuGet.ZoneMarker : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.NullabilityDecoration : TypeDecoration {
    private static NullabilityDecoration[] ourDecorations;
    [CompilerGeneratedAttribute]
private NullableAnnotation <NullableAnnotation>k__BackingField;
    public NullableAnnotation NullableAnnotation { get; }
    private NullabilityDecoration(NullableAnnotation nullableAnnotation);
    private static NullabilityDecoration();
    public static NullabilityDecoration GetInstanceForNotUnknown(NullableAnnotation nullableAnnotation);
    [CompilerGeneratedAttribute]
public NullableAnnotation get_NullableAnnotation();
    public virtual ITypeDecorationPointer CreatePointer();
    private sealed virtual override TypeDecoration JetBrains.ReSharper.Psi.ITypeDecorationPointer.Find();
    [NullableContextAttribute("2")]
public virtual bool Equals(TypeDecoration other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.NullableAnnotationExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsAnyNullableCompiler(NullableAnnotation annotation);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsAnyNotNullableCompiler(NullableAnnotation annotation);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsAnyNotNullable(NullableAnnotation annotation);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsAnyNullable(NullableAnnotation annotation);
    [ExtensionAttribute]
public static bool IsAnyNotNullableHeuristically(NullableAnnotation annotation);
    [ExtensionAttribute]
public static bool IsAnyNullableHeuristically(NullableAnnotation annotation);
    [ExtensionAttribute]
[PureAttribute]
private static bool IsAnyUnknown(NullableAnnotation annotation);
    [ExtensionAttribute]
[PureAttribute]
public static NullableAnnotation Join(NullableAnnotation a, NullableAnnotation b);
    [PureAttribute]
private static NullableAnnotation JoinWithUnknownAnnotation(NullableAnnotation a, NullableAnnotation b);
    [ExtensionAttribute]
[PureAttribute]
public static NullableAnnotation Meet(NullableAnnotation a, NullableAnnotation b);
    [ExtensionAttribute]
[PureAttribute]
public static NullableAnnotation EnsureCompatible(NullableAnnotation a, NullableAnnotation b);
    [ExtensionAttribute]
[PureAttribute]
public static NullableAnnotation MergeNullableAnnotation(NullableAnnotation a, NullableAnnotation b, TypeParameterVariance variance);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static Nullable`1<NullableAnnotation> WithUnknownSubstate(Nullable`1<NullableAnnotation> annotation);
    [ExtensionAttribute]
[PureAttribute]
public static NullableAnnotation WithUnknownSubstate(NullableAnnotation annotation);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("annotation: null => null; annotation: notnull => notnull")]
public static Nullable`1<NullableAnnotation> WithUnknownSubstate(Nullable`1<NullableAnnotation> annotation, bool setUnknownSubstate);
    [ExtensionAttribute]
[PureAttribute]
public static NullableAnnotation WithUnknownSubstate(NullableAnnotation annotation, bool setUnknownSubstate);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("targetType:null => null; targetType:notnull => notnull")]
public static IType Apply(Nullable`1<NullableAnnotation> annotation, IType targetType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.NullableReferenceTypeExtensions : object {
    [ExtensionAttribute]
public static NullableAnnotation GetValueNullableAnnotation(IType type);
    [ExtensionAttribute]
public static bool IsPossiblyNullableReferenceTypeTypeParameter(IType type);
    [ExtensionAttribute]
public static bool IsTypeParameterDisallowingAnnotationInCSharp8(IType type);
    [ExtensionAttribute]
public static IType EraseNullableAnnotations(IType type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.ObsoleteAnnotationInfo : object {
    public static ObsoleteAnnotationInfo NotObsolete;
    public static ObsoleteAnnotationInfo WindowsExperimental;
    public ObsoleteAttributeKind Kind;
    public bool IsError;
    [NullableAttribute("2")]
public string Message;
    [NullableAttribute("2")]
public string DiagnosticId;
    [NullableAttribute("2")]
public string UrlFormat;
    private static string ByRefLikeMarker;
    private static string RequiredMembersMarker;
    public bool IsAnyObsoleteLike { get; }
    [NullableContextAttribute("2")]
private ObsoleteAnnotationInfo(ObsoleteAttributeKind kind, bool isError, string message, string diagnosticId, string urlFormat);
    private static ObsoleteAnnotationInfo();
    public bool get_IsAnyObsoleteLike();
    [PureAttribute]
public static ObsoleteAnnotationInfo CreateFromDeprecatedAttribute(IAttributeInstance attributeInstance);
    [PureAttribute]
public static ObsoleteAnnotationInfo CreateFromExperimentalAttribute(IAttributeInstance attributeInstance);
    [PureAttribute]
public static ObsoleteAnnotationInfo CreateFromObsoleteAttribute(IAttributeInstance attributeInstance, IAttributesOwner attributeOwner);
    [PureAttribute]
private static bool IsSpecialCompilerEmittedByRefLikeMarkerObsoleteAttribute(string obsoleteMessage, IDeclaredElement declaredElement);
    [PureAttribute]
private static bool IsSpecialCompilerEmittedRequiredMembersMarkerObsoleteAttribute(string obsoleteMessage, IDeclaredElement declaredElement);
    [CompilerGeneratedAttribute]
internal static ObsoleteAttributeKind <CreateFromObsoleteAttribute>g__CalculateKind|12_0(<>c__DisplayClass12_0& );
}
public enum JetBrains.ReSharper.Psi.ObsoleteAttributeKind : Enum {
    public int value__;
    public static ObsoleteAttributeKind None;
    public static ObsoleteAttributeKind Obsolete;
    public static ObsoleteAttributeKind WindowsExperimental;
    public static ObsoleteAttributeKind Experimental;
    public static ObsoleteAttributeKind SpecialObsoleteForByRefLike;
    public static ObsoleteAttributeKind SpecialObsoleteForRequiredMembers;
}
[ObsoleteAttribute("Use .ThisAndDescendants()")]
public class JetBrains.ReSharper.Psi.OneActionProcessor : object {
    protected Action`1<ITreeNode> myAction;
    protected Predicate`1<ITreeNode> myPredicate;
    public bool ProcessingIsFinished { get; }
    public OneActionProcessor(Action`1<ITreeNode> action, Predicate`1<ITreeNode> predicate);
    public virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
}
public static class JetBrains.ReSharper.Psi.OperatorName : object {
    public static string IMPLICIT_CONVERSION;
    public static string EXPLICIT_CONVERSION;
    public static string CHECKED_EXPLICIT_CONVERSION;
    public static string UNARY_PLUS;
    public static string UNARY_MINUS;
    public static string CHECKED_UNARY_MINUS;
    public static string UNARY_LOGNOT;
    public static string UNARY_COMPLEMENT;
    public static string UNARY_INCREMENT;
    public static string CHECKED_UNARY_INCREMENT;
    public static string UNARY_DECREMENT;
    public static string CHECKED_UNARY_DECREMENT;
    public static string UNARY_TRUE;
    public static string UNARY_FALSE;
    public static string BINARY_PLUS;
    public static string CHECKED_BINARY_PLUS;
    public static string BINARY_MINUS;
    public static string CHECKED_BINARY_MINUS;
    public static string BINARY_MULTIPLY;
    public static string CHECKED_BINARY_MULTIPLY;
    public static string BINARY_DIVIDE;
    public static string CHECKED_BINARY_DIVIDE;
    public static string BINARY_MODULUS;
    public static string BINARY_BITWISE_AND;
    public static string BINARY_BITWISE_OR;
    public static string BINARY_EXCLUSIVE_OR;
    public static string BINARY_LEFTSHIFT;
    public static string BINARY_RIGHTSHIFT;
    public static string BINARY_UNSIGNEDRIGHTSHIFT;
    public static string BINARY_EQUALITY;
    public static string BINARY_INEQUALITY;
    public static string BINARY_LT;
    public static string BINARY_LE;
    public static string BINARY_GT;
    public static string BINARY_GE;
}
public class JetBrains.ReSharper.Psi.Original : object {
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.OverridableMemberExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<OverridableMemberInstance> GetImmediateSuperMembers(IOverridableMember overridableMember, bool searchQuasi, IProgressIndicator progressIndicator);
    [ExtensionAttribute]
public static bool HasImmediateSuperMembers(IOverridableMember overridableMember, bool searchQuasi);
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<OverridableMemberInstance> GetRootSuperMembers(IOverridableMember overridableMember, bool searchQuasi);
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<OverridableMemberInstance> GetAllSuperMembers(IOverridableMember overridableMember, bool searchQuasi);
    [ExtensionAttribute]
public static bool OverridesOrImplements(IOverridableMember derivedMember, IOverridableMember superMember);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ISubstitution GetAncestorSubstitution(IOverridableMember derivedMember, IOverridableMember superMember);
    [NotNullAttribute]
private static ISubstitution GetAncestorSubstitution(ITypeParametersOwner superTypeParametersOwner, ITypeParametersOwner derivedTypeParametersOwner, ISubstitution baseSubstitution);
}
public class JetBrains.ReSharper.Psi.OverridableMemberInstance : DeclaredElementInstance`1<IOverridableMember> {
    private bool mySignatureCalculated;
    [CanBeNullAttribute]
private InvocableSignature myInvocableSignature;
    [NotNullAttribute]
public IOverridableMember Member { get; }
    [NotNullAttribute]
public IDeclaredType DeclaringType { get; }
    [CanBeNullAttribute]
public InvocableSignature Signature { get; }
    public OverridableMemberInstance(IOverridableMember member, ISubstitution substitution);
    public OverridableMemberInstance(IOverridableMember member);
    public IOverridableMember get_Member();
    public bool OverridesOrImplements(OverridableMemberInstance superMember);
    [NotNullAttribute]
public IList`1<OverridableMemberInstance> GetImmediateSuperMembers(bool searchQuasi, IProgressIndicator progressIndicator);
    [NotNullAttribute]
public IList`1<OverridableMemberInstance> GetRootSuperMembers(bool searchQuasi, IProgressIndicator progressIndicator);
    [NotNullAttribute]
public IList`1<OverridableMemberInstance> GetImmediateOverride();
    [NotNullAttribute]
public IList`1<OverridableMemberInstance> GetImmediateImplement(bool searchQuasi, ITypeElement containingTypeForImplicitImplementationsSearch, IProgressIndicator progressIndicator);
    [NotNullAttribute]
public ICollection`1<OverridableMemberInstance> GetRootOverride();
    public IDeclaredType get_DeclaringType();
    [CanBeNullAttribute]
public IType Type();
    public InvocableSignature get_Signature();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.OverridableMemberInstanceExtension : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static OverridableMemberInstance ToOverridableMemberInstance(DeclaredElementInstance instance);
}
public enum JetBrains.ReSharper.Psi.ParameterContainerStyle : Enum {
    public int value__;
    public static ParameterContainerStyle NONE;
    public static ParameterContainerStyle AFTER;
    public static ParameterContainerStyle AFTER_IN_PARENTHESIS;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ParameterExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsExtensionFirstParameter(IParameter parameter);
    [ExtensionAttribute]
[PureAttribute]
public static int IndexOf(IParameter parameter);
    [ExtensionAttribute]
public static bool IsImplicitlyScoped(FunctionPointerParameter parameter, Nullable`1<RefSafetyRulesVersion> refSafetyRulesVersion);
    [ExtensionAttribute]
public static bool IsImplicitlyScoped(IParameter parameter);
    [ExtensionAttribute]
public static bool IsImplicitlyScoped(IParameter parameter, RefSafetyRulesVersion refSafetyRulesVersion);
    private static bool IsImplicitlyScoped(ParameterKind kind);
}
public enum JetBrains.ReSharper.Psi.ParameterKind : Enum {
    public byte value__;
    public static ParameterKind UNKNOWN;
    public static ParameterKind VALUE;
    public static ParameterKind INPUT;
    public static ParameterKind REFERENCE;
    public static ParameterKind OUTPUT;
    public static ParameterKind READONLY_REFERENCE;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ParameterKindExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsByReference(ParameterKind parameterKind);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsValueOrInOrRefReadonly(ParameterKind parameterKind);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsReadableInsideDeclaration(ParameterKind parameterKind);
    [ExtensionAttribute]
[PureAttribute]
public static ReferenceKind ToReferenceKind(ParameterKind parameterKind);
    [ExtensionAttribute]
[PureAttribute]
public static ParameterKind CoalesceReadonlyRefToInput(ParameterKind parameterKind);
}
internal class JetBrains.ReSharper.Psi.Parsing.ArrayOfTokensView : object {
    private IArrayOfTokens myArrayOfTokens;
    private int myStart;
    private int myEnd;
    public ArrayOfTokensView(IArrayOfTokens arrayOfTokens, int start, int end);
    public sealed virtual IEnumerator`1<Token> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class JetBrains.ReSharper.Psi.Parsing.CachingLexer : object {
    [DebuggerBrowsableAttribute("0")]
private int myCurrentCachedToken;
    [DebuggerBrowsableAttribute("0")]
private TokenBuffer myTokenBuffer;
    private IArrayOfTokens myTokens;
    [DebuggerBrowsableAttribute("0")]
private TokenNodeType myCachedTokenType;
    [DebuggerBrowsableAttribute("0")]
private int myCachedTokenStart;
    [DebuggerBrowsableAttribute("0")]
private int myCachedTokenEnd;
    [DebuggerBrowsableAttribute("0")]
private UInt32 myCachedLexerState;
    public TextRange LastResyncAffectedRange { get; }
    public TokenNodeType TokenType { get; }
    public UInt32 LexerStateEx { get; }
    public int TokenStart { get; }
    public int TokenEnd { get; }
    [DebuggerBrowsableAttribute("0")]
private object JetBrains.ReSharper.Psi.Parsing.ILexer.CurrentPosition { get; private set; }
    public IBuffer Buffer { get; }
    public int CurrentPosition { get; public set; }
    public TokenBuffer TokenBuffer { get; }
    protected internal CachingLexer(TokenBuffer buffer);
    public void SetCurrentToken(int tokenNum);
    public TextRange get_LastResyncAffectedRange();
    public sealed virtual TokenNodeType get_TokenType();
    public sealed virtual UInt32 get_LexerStateEx();
    public sealed virtual int get_TokenStart();
    public sealed virtual int get_TokenEnd();
    public sealed virtual void Advance();
    public sealed virtual void Start();
    private sealed virtual override object JetBrains.ReSharper.Psi.Parsing.ILexer.get_CurrentPosition();
    private sealed virtual override void JetBrains.ReSharper.Psi.Parsing.ILexer.set_CurrentPosition(object value);
    public sealed virtual IBuffer get_Buffer();
    public sealed virtual void SetPositionAndAdvance(int tokenNum);
    public sealed virtual int get_CurrentPosition();
    public sealed virtual void set_CurrentPosition(int value);
    public bool FindTokenAt(int pos);
    public void Advance(int delta);
    public sealed virtual TokenBuffer get_TokenBuffer();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Parsing.DelegatingLexer : object {
    [NotNullAttribute]
private ILexer myOriginalLexer;
    [NotNullAttribute]
protected ILexer OriginalLexer { get; }
    public object CurrentPosition { get; public set; }
    public TokenNodeType TokenType { get; }
    public int TokenStart { get; }
    public int TokenEnd { get; }
    public IBuffer Buffer { get; }
    protected DelegatingLexer(ILexer originalLexer);
    protected ILexer get_OriginalLexer();
    public virtual void Start();
    public virtual void Advance();
    public virtual object get_CurrentPosition();
    public virtual void set_CurrentPosition(object value);
    public virtual TokenNodeType get_TokenType();
    public virtual int get_TokenStart();
    public virtual int get_TokenEnd();
    public virtual IBuffer get_Buffer();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Parsing.DocumentUpdatesAccumulator : object {
    private IDocument myDocument;
    private int myModifiedRangeStart;
    private int myModifiedRangeEnd;
    private int myOriginalDocumentLength;
    private int myCurrentDocumentLength;
    public TextRange ModifiedRange { get; }
    public bool IsDirty { get; }
    public int InsertedTextLength { get; }
    public IDocument Document { get; }
    public DocumentUpdatesAccumulator(IDocument document);
    public DocumentUpdatesAccumulator(DocumentChange change);
    public TextRange get_ModifiedRange();
    public bool get_IsDirty();
    public int get_InsertedTextLength();
    public IDocument get_Document();
    public void DocumentChanged(DocumentChange args);
    private void DocumentChanged(int start, int end, int currentDocumentLength);
    private void AssertState();
    public void Reset();
    public void AssertClean();
}
public abstract class JetBrains.ReSharper.Psi.Parsing.FilteringLexer : FilteringLexerBase {
    protected FilteringLexer(ILexer lexer);
    protected virtual void SkipFilteredTokens();
}
public abstract class JetBrains.ReSharper.Psi.Parsing.FilteringLexerBase : object {
    [NotNullAttribute]
protected ILexer myLexer;
    public IBuffer Buffer { get; }
    public object CurrentPosition { get; public set; }
    public int TokenEnd { get; }
    public int TokenStart { get; }
    public TokenNodeType TokenType { get; }
    protected FilteringLexerBase(ILexer lexer);
    public virtual void Advance();
    public sealed virtual IBuffer get_Buffer();
    public virtual object get_CurrentPosition();
    public virtual void set_CurrentPosition(object value);
    public virtual void Start();
    public sealed virtual int get_TokenEnd();
    public sealed virtual int get_TokenStart();
    public sealed virtual TokenNodeType get_TokenType();
    protected abstract virtual void SkipFilteredTokens();
    protected abstract virtual bool Skip(TokenNodeType tokenType);
    public virtual string ToString();
}
public class JetBrains.ReSharper.Psi.Parsing.FollowsFailure : SyntaxError {
    [CompilerGeneratedAttribute]
private TokenNodeType <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<NodeType> <ExpectedTokenTypes>k__BackingField;
    public TokenNodeType TokenType { get; }
    public IReadOnlyCollection`1<NodeType> ExpectedTokenTypes { get; }
    public FollowsFailure(string details);
    public FollowsFailure(TokenNodeType tokenType, IReadOnlyCollection`1<NodeType> expectedTokenTypes, string details);
    [CompilerGeneratedAttribute]
public sealed virtual TokenNodeType get_TokenType();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyCollection`1<NodeType> get_ExpectedTokenTypes();
}
public abstract class JetBrains.ReSharper.Psi.Parsing.GeneratedParserBase`1 : object {
    [NotNullAttribute]
protected TLexer myLexer;
    protected void SetLexer(TLexer lexer);
    [NotNullAttribute]
protected virtual TreeElement CreateToken();
    protected void Skip(CompositeElement parent);
    protected int GetOffset(LeafElementBase element);
    protected void SetOffset(LeafElementBase element, int offset);
    private sealed virtual override int JetBrains.ReSharper.Psi.Parsing.ITokenOffsetProvider.GetOffset(LeafElementBase element);
    private sealed virtual override void JetBrains.ReSharper.Psi.Parsing.ITokenOffsetProvider.SetOffset(LeafElementBase element, int offset);
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.ReSharper.Psi.Parsing.IArrayOfTokens {
    public int Count { get; }
    public Token Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual void GetTokenProperties(int index, Int32& start, Int32& end, TokenNodeType& type, UInt32& lexerState);
    public abstract virtual Token get_Item(int index);
    public abstract virtual int GetTokenStart(int index);
    public abstract virtual int GetTokenEnd(int index);
    [CanBeNullAttribute]
public abstract virtual TokenNodeType GetTokenType(int index);
    public abstract virtual UInt32 GetTokenState(int index);
    public abstract virtual int Add(Token item);
    public abstract virtual int Add(TokenNodeType tokenType, int start, int end, UInt32 lexerState);
    public abstract virtual void Clear();
    public abstract virtual void RemoveRange(int start);
    public abstract virtual void Purge();
    public abstract virtual void AddRange(IArrayOfTokens array, int start, int length, int delta);
    public abstract virtual int FindTokenAt(int offset);
    public abstract virtual Token Last();
    public abstract virtual IEnumerable`1<Token> View(int start, int end);
}
public interface JetBrains.ReSharper.Psi.Parsing.IIncrementalLexer {
    public int EOFPos { get; }
    public int LexemIndent { get; }
    public abstract virtual void Start(int startOffset, int endOffset, UInt32 state);
    public abstract virtual int get_EOFPos();
    public abstract virtual int get_LexemIndent();
}
public interface JetBrains.ReSharper.Psi.Parsing.IIncrementalLexerFactory {
    [NotNullAttribute]
public abstract virtual IIncrementalLexer CreateLexer(IBuffer buffer);
}
public interface JetBrains.ReSharper.Psi.Parsing.ILexer {
    public object CurrentPosition { get; public set; }
    [CanBeNullAttribute]
public TokenNodeType TokenType { get; }
    public int TokenStart { get; }
    public int TokenEnd { get; }
    public IBuffer Buffer { get; }
    public abstract virtual void Start();
    public abstract virtual void Advance();
    public abstract virtual object get_CurrentPosition();
    public abstract virtual void set_CurrentPosition(object value);
    public abstract virtual TokenNodeType get_TokenType();
    public abstract virtual int get_TokenStart();
    public abstract virtual int get_TokenEnd();
    public abstract virtual IBuffer get_Buffer();
}
public interface JetBrains.ReSharper.Psi.Parsing.ILexer`1 {
    public TState CurrentPosition { get; public set; }
    public abstract virtual TState get_CurrentPosition();
    public abstract virtual void set_CurrentPosition(TState value);
}
public interface JetBrains.ReSharper.Psi.Parsing.ILexerEx {
    public UInt32 LexerStateEx { get; }
    public abstract virtual UInt32 get_LexerStateEx();
}
public interface JetBrains.ReSharper.Psi.Parsing.ILexerFactory {
    [NotNullAttribute]
public abstract virtual ILexer CreateLexer(IBuffer buffer);
}
public interface JetBrains.ReSharper.Psi.Parsing.IParser {
    [CanBeNullAttribute]
public abstract virtual IFile ParseFile();
}
public interface JetBrains.ReSharper.Psi.Parsing.ISecondaryLexer {
    public bool IsActual { get; }
    public int BufferStartOffset { get; }
    public abstract virtual bool get_IsActual();
    public abstract virtual int get_BufferStartOffset();
}
public interface JetBrains.ReSharper.Psi.Parsing.IStringLexer {
    [NotNullAttribute]
public string CompiledChars { get; }
    public bool CanAdvance { get; }
    public abstract virtual string get_CompiledChars();
    public abstract virtual bool get_CanAdvance();
}
public interface JetBrains.ReSharper.Psi.Parsing.ITokenNodeType {
    public bool IsWhitespace { get; }
    public bool IsComment { get; }
    public bool IsStringLiteral { get; }
    public bool IsConstantLiteral { get; }
    public bool IsIdentifier { get; }
    public bool IsKeyword { get; }
    [NotNullAttribute]
public string TokenRepresentation { get; }
    public abstract virtual bool get_IsWhitespace();
    public abstract virtual bool get_IsComment();
    public abstract virtual bool get_IsStringLiteral();
    public abstract virtual bool get_IsConstantLiteral();
    public abstract virtual bool get_IsIdentifier();
    public abstract virtual bool get_IsKeyword();
    public abstract virtual string get_TokenRepresentation();
}
public interface JetBrains.ReSharper.Psi.Parsing.ITokenOffsetProvider {
    [PureAttribute]
public abstract virtual int GetOffset(LeafElementBase element);
    public abstract virtual void SetOffset(LeafElementBase element, int offset);
}
public interface JetBrains.ReSharper.Psi.Parsing.IUnexpectedTokenError {
    [NotNullAttribute]
public string Message { get; }
    [CanBeNullAttribute]
public TokenNodeType TokenType { get; }
    [CanBeNullAttribute]
public IReadOnlyCollection`1<NodeType> ExpectedTokenTypes { get; }
    public abstract virtual string get_Message();
    public abstract virtual TokenNodeType get_TokenType();
    public abstract virtual IReadOnlyCollection`1<NodeType> get_ExpectedTokenTypes();
}
public interface JetBrains.ReSharper.Psi.Parsing.IXmlTokenBuilder {
    public abstract virtual LeafElementBase CreateToken(XmlTokenNodeType tokenType, IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
}
public class JetBrains.ReSharper.Psi.Parsing.LexerDictionary`1 : Dictionary`2<object, TValue> {
    [NotNullAttribute]
private static TokenTextEqualityComparer ourComparer;
    [NotNullAttribute]
private static TokenTextEqualityComparer ourCaseInsensitiveComparer;
    public LexerDictionary`1(bool caseSensitive);
    private static LexerDictionary`1();
    public TValue GetValueSafe(ReusableBufferRange reusableBuffer, IBuffer buffer, int start, int end);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Parsing.LexerExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static ILazyCachingLexer ToCachingLexer(ILexer lexer);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Parsing.LexerFactoryEx : object {
    [ExtensionAttribute]
public static ILazyCachingLexer CreateCachingLexer(ILexerFactory factory, IBuffer buffer);
}
public static class JetBrains.ReSharper.Psi.Parsing.LexerStateConstants : object {
    public static UInt32 InvalidState;
}
public static class JetBrains.ReSharper.Psi.Parsing.LexerStateCookie : object {
    [PureAttribute]
public static Common Create(ILexer lexer);
    [PureAttribute]
public static TypeSafe`1<T> Create(ILexer`1<T> lexer);
}
public class JetBrains.ReSharper.Psi.Parsing.LexerTokenIntern : object {
    [NotNullAttribute]
private ChunkHashSetConversionIntern`2<object, string> myIntern;
    [NotNullAttribute]
private ReusableBufferRange myBufferRange;
    private int INTERNING_THRESHOLD;
    private static Func`2<object, string> DataConverter;
    public int Count { get; }
    public LexerTokenIntern(int count);
    private static LexerTokenIntern();
    public void Clear();
    public void OnPoolFree();
    public int get_Count();
    [NotNullAttribute]
public IBuffer Intern(IBuffer buffer);
    public sealed virtual string Intern(ILexer lexer);
    public sealed virtual string Intern(IBuffer buffer, int start, int end);
    public sealed virtual string InternWithoutThreshold(IBuffer buffer, int start, int end);
    private string Intern(ReusableBufferRange bufferRange);
    private string InternWithoutThreshold(ReusableBufferRange bufferRange);
    public sealed virtual string Intern(string text);
    public sealed virtual string InternWithoutThreshold(string text);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Parsing.LexerUtil : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TokenNodeType LookaheadToken(ILexer lexer, int k);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TokenNodeType LookaheadTokenSkipping(ILexer lexer, int k, TokenNodeType nodeTypeToSkip);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TokenNodeType LookaheadToken(ILexer`1<T> lexer, int k);
    [ExtensionAttribute]
[PureAttribute]
public static int GetTokenLength(ILexer lexer);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
[ObsoleteAttribute("Use 'GetTokenText' instead")]
public static string GetCurrTokenText(ILexer lexer);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static string GetTokenText(ILexer lexer);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static string GetQuotedTokenText(ILexer lexer, char quote);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static string GetQuotedTokenText(ILexer lexer, char openQuote, char closeQuote);
    [ExtensionAttribute]
[PureAttribute]
public static bool CompareTokenText(ILexer lexer, string str, bool caseSensitive);
    [ExtensionAttribute]
[PureAttribute]
public static bool CompareBufferText(ILexer lexer, string str, bool caseSensitive);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Parsing.LexerUtil/<Tokens>d__10")]
[ExtensionAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<TokenNodeType> Tokens(ILexer lexer);
    [ExtensionAttribute]
public static int AdvanceWhile(TLexer lexer, TokenNodeType skipToken);
    [ExtensionAttribute]
public static int AdvanceWhile(TLexer lexer, NodeTypeSet skipTokens);
}
public class JetBrains.ReSharper.Psi.Parsing.LexerWithRangeTranslation : object {
    private ILexer myLexer;
    private IBuffer myBuffer;
    private RangeTranslator myTranslator;
    private int myTokenIndex;
    private IArrayOfTokens myArrayOfTokens;
    public IBuffer Buffer { get; }
    public int TokenStart { get; }
    public int TokenEnd { get; }
    public TokenNodeType TokenType { get; }
    public object CurrentPosition { get; public set; }
    public LexerWithRangeTranslation(IBuffer buffer, ILexer lexer, RangeTranslator translator);
    public sealed virtual IBuffer get_Buffer();
    public sealed virtual int get_TokenStart();
    public sealed virtual int get_TokenEnd();
    public sealed virtual TokenNodeType get_TokenType();
    public sealed virtual void Start();
    public sealed virtual void Advance();
    public sealed virtual object get_CurrentPosition();
    public sealed virtual void set_CurrentPosition(object value);
    private static IArrayOfTokens FixRanges(ILexer lexer, RangeTranslator translator);
}
public abstract class JetBrains.ReSharper.Psi.Parsing.MissingTokenInserterBase : object {
    [NotNullAttribute]
private ITokenOffsetProvider myOffsetProvider;
    [NotNullAttribute]
protected ITokenIntern WhitespaceIntern;
    protected MissingTokenInserterBase(ITokenOffsetProvider offsetProvider, ITokenIntern intern);
    protected TreeOffset GetLeafOffset(TreeElement element);
    protected void Run(TreeElement root);
    protected abstract virtual void ProcessLeafElement(TreeElement leafElement);
}
public class JetBrains.ReSharper.Psi.Parsing.MixedLexer : object {
    private IBuffer myBuffer;
    private ILexerFactory myLexerFactory;
    [CanBeNullAttribute]
private ILexer myCodeLexer;
    private List`1<ISecondaryLexer> mySleepingLexers;
    private ProjectFileType myProjectFileType;
    private ISecondaryLexingProcess mySecondaryLexerProcess;
    [CompilerGeneratedAttribute]
private ILexer <PrimaryLexer>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenBuffer <PrimaryTokenBuffer>k__BackingField;
    private TokenNodeType myCurrentTokenType;
    private int myPrimaryTokenStart;
    [CompilerGeneratedAttribute]
private UInt32 <LexerStateEx>k__BackingField;
    public ILexer PrimaryLexer { get; private set; }
    private TokenBuffer PrimaryTokenBuffer { get; private set; }
    public int TokenStart { get; }
    public object CurrentPosition { get; public set; }
    public TokenNodeType TokenType { get; }
    public int TokenEnd { get; }
    public IBuffer Buffer { get; }
    public UInt32 LexerStateEx { get; private set; }
    private int JetBrains.ReSharper.Psi.Parsing.IIncrementalLexer.EOFPos { get; }
    private int JetBrains.ReSharper.Psi.Parsing.IIncrementalLexer.LexemIndent { get; }
    public MixedLexer(ISolution solution, IBuffer buffer, ILexerFactory lexerFactory, ProjectFileType projectFileType, IPsiSourceFile sourceFile);
    [CompilerGeneratedAttribute]
public ILexer get_PrimaryLexer();
    [CompilerGeneratedAttribute]
private void set_PrimaryLexer(ILexer value);
    [CompilerGeneratedAttribute]
private TokenBuffer get_PrimaryTokenBuffer();
    [CompilerGeneratedAttribute]
private void set_PrimaryTokenBuffer(TokenBuffer value);
    private ISecondaryLexingProcess CreateCompoundSecondaryLexerProcess(ISolution solution, ProjectFileType projectFileType, MixedLexer mixedLexer, IPsiSourceFile sourceFile);
    private void LocateToken(bool recursive);
    public sealed virtual void Start();
    public sealed virtual void Advance();
    public sealed virtual int get_TokenStart();
    public sealed virtual object get_CurrentPosition();
    public sealed virtual void set_CurrentPosition(object value);
    public sealed virtual TokenNodeType get_TokenType();
    public sealed virtual int get_TokenEnd();
    public sealed virtual IBuffer get_Buffer();
    public CachingLexer GetParentCachingLexer();
    public TokenBuffer ReSync(DocumentUpdatesAccumulator accumulator, TokenBuffer cachedTokenBuffer, IBuffer buffer);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_LexerStateEx();
    [CompilerGeneratedAttribute]
private void set_LexerStateEx(UInt32 value);
    private sealed virtual override void JetBrains.ReSharper.Psi.Parsing.IIncrementalLexer.Start(int startOffset, int endOffset, UInt32 state);
    private sealed virtual override int JetBrains.ReSharper.Psi.Parsing.IIncrementalLexer.get_EOFPos();
    private sealed virtual override int JetBrains.ReSharper.Psi.Parsing.IIncrementalLexer.get_LexemIndent();
}
public class JetBrains.ReSharper.Psi.Parsing.MixedLexerFactory : object {
    private ISolution mySolution;
    private ILexerFactory myLexerFactory;
    private ProjectFileType myProjectFileType;
    [CanBeNullAttribute]
private IPsiSourceFile mySourceFile;
    public MixedLexerFactory(ISolution solution, ILexerFactory lexerFactory, ProjectFileType projectFileType, IPsiSourceFile sourceFile);
    public sealed virtual ILexer CreateLexer(IBuffer buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Parsing.PackedArrayOfTokens : PackedArrayOfTokensBase {
    private static ObjectPool`1<PooledDictionary`2<long, byte>> ourSmallTokensMapPool;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ObjectPool`1<TokenNodeType[]> ourDecodeMapPool;
    private static ObjectPool`1<Int32[]> ourDecodeLengthsPool;
    public PackedArrayOfTokens(int capacity);
    private PackedArrayOfTokens(int count, List`1<PackedToken[]> pages);
    private static PackedArrayOfTokens();
    protected virtual void ProvideSpaceFor(int nItems);
    public virtual void Clear();
    [PublicAPIAttribute]
public static void Serialize(PackedArrayOfTokens arrayOfTokens, UnsafeWriter writer, NodeTypeDictionary`1<int> tokensLengthMap);
    [PublicAPIAttribute]
public static PackedArrayOfTokens Deserialize(UnsafeReader reader, Dictionary`2<int, TokenNodeType> indexToTokenType, NodeTypeDictionary`1<int> tokensLengthMap);
    [PublicAPIAttribute]
public bool Equals(PackedArrayOfTokens other);
}
[DefaultMemberAttribute("Item")]
public abstract class JetBrains.ReSharper.Psi.Parsing.PackedArrayOfTokensBase : object {
    protected static int PageSize;
    protected List`1<PackedToken[]> myPages;
    protected int myCount;
    public int Count { get; }
    public Token Item { get; }
    protected PackedArrayOfTokensBase(int capacity);
    protected PackedArrayOfTokensBase(int count, List`1<PackedToken[]> pages);
    public sealed virtual int get_Count();
    public sealed virtual void GetTokenProperties(int index, Int32& start, Int32& end, TokenNodeType& type, UInt32& lexerState);
    public sealed virtual Token get_Item(int index);
    public sealed virtual int GetTokenStart(int index);
    public sealed virtual int GetTokenEnd(int index);
    public sealed virtual TokenNodeType GetTokenType(int index);
    public sealed virtual UInt32 GetTokenState(int index);
    public sealed virtual int Add(Token item);
    public sealed virtual int Add(TokenNodeType tokenType, int start, int end, UInt32 lexerState);
    public sealed virtual void RemoveRange(int start);
    public sealed virtual void Purge();
    public sealed virtual void AddRange(IArrayOfTokens array, int start, int length, int delta);
    public void AddRange(PackedArrayOfTokensBase array, int start, int length, int delta);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void ValidateIndex(int index);
    protected abstract virtual void ProvideSpaceFor(int nItems);
    public abstract virtual void Clear();
    public sealed virtual int FindTokenAt(int offset);
    public sealed virtual Token Last();
    public IEnumerable`1<Token> View();
    public sealed virtual IEnumerable`1<Token> View(int start, int end);
}
public static class JetBrains.ReSharper.Psi.Parsing.ParserService : object {
    private static IParser CreateParser(ILexer lexer, PsiLanguageType type, ISolution solution, IPsiModule project);
    internal static IFile ParseFile(IBuffer buffer, PsiLanguageType type, ISolution solution, IPsiModule project);
    [ObsoleteAttribute("Use language service instead")]
public static IFile ParseFileDebug(IBuffer buffer, PsiLanguageType type, ISolution solution, IPsiModule project);
    [ObsoleteAttribute("Use language service instead")]
public static IFile ParseFileDebug(VirtualFileSystemPath fileName, PsiLanguageType languageType, IPsiModule project);
}
public class JetBrains.ReSharper.Psi.Parsing.ProjectedLexer : object {
    private CachingLexer myLexer;
    private TextRange myRange;
    private IBuffer myBuffer;
    private int myStartPosition;
    private TokenNodeType myTokenType;
    private int myTokenStart;
    private int myTokenEnd;
    private object JetBrains.ReSharper.Psi.Parsing.ILexer.CurrentPosition { get; private set; }
    public int CurrentPosition { get; public set; }
    public TokenNodeType TokenType { get; }
    public int TokenStart { get; }
    public int TokenEnd { get; }
    public IBuffer Buffer { get; }
    public ProjectedLexer(CachingLexer lexer, TextRange range);
    private void Cache();
    public sealed virtual void Start();
    public sealed virtual void Advance();
    private sealed virtual override object JetBrains.ReSharper.Psi.Parsing.ILexer.get_CurrentPosition();
    private sealed virtual override void JetBrains.ReSharper.Psi.Parsing.ILexer.set_CurrentPosition(object value);
    public sealed virtual int get_CurrentPosition();
    public sealed virtual void set_CurrentPosition(int value);
    public sealed virtual TokenNodeType get_TokenType();
    public sealed virtual int get_TokenStart();
    public sealed virtual int get_TokenEnd();
    public sealed virtual IBuffer get_Buffer();
}
public class JetBrains.ReSharper.Psi.Parsing.PsiGetterTestUtil : object {
    protected static TextWriter writer;
    protected static JetHashSet`1<ITreeNode> visitedElements;
    unknown static TextWriter Writer {public set; }
    private static PsiGetterTestUtil();
    public static void set_Writer(TextWriter value);
    public static void Clear();
    protected static bool CanVisitFurther(ITreeNode param);
    protected static void VisitElement(int level, ITreeNode sourceElement, string caller);
    public static void TestTokenNode(int level, ITokenNode param, string caller);
    public static void TestTreeNode(int level, ITreeNode param, string caller);
}
public class JetBrains.ReSharper.Psi.Parsing.ReusableBufferRange : object {
    private BufferRange myBufferRange;
    public BufferRange BufferRange { get; }
    public void Reuse(IBuffer buffer, TextRange range);
    public void ClearLastBuffer();
    public BufferRange get_BufferRange();
}
public class JetBrains.ReSharper.Psi.Parsing.SimpleFilteringLexer : FilteringLexer {
    [CanBeNullAttribute]
private Predicate`1<TokenNodeType> mySkipTokenPredicate;
    [NotNullAttribute]
public static Predicate`1<TokenNodeType> IS_WHITESPACE;
    [NotNullAttribute]
public static Predicate`1<TokenNodeType> IS_WHITESPACE_OR_COMMENT;
    public SimpleFilteringLexer(ILexer lexer, Predicate`1<TokenNodeType> skipTokenPredicate);
    private static SimpleFilteringLexer();
    protected virtual bool Skip(TokenNodeType tokenType);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Parsing.SparseArrayOfTokens : object {
    private static int PageSize;
    private List`1<StoredToken[]> myPages;
    private int myCount;
    public int Count { get; }
    public Token Item { get; }
    public SparseArrayOfTokens(int capacity);
    public sealed virtual int get_Count();
    public sealed virtual void GetTokenProperties(int index, Int32& start, Int32& end, TokenNodeType& type, UInt32& lexerState);
    public sealed virtual Token get_Item(int index);
    public sealed virtual int GetTokenStart(int index);
    public sealed virtual int GetTokenEnd(int index);
    public sealed virtual TokenNodeType GetTokenType(int index);
    public sealed virtual UInt32 GetTokenState(int index);
    public sealed virtual int Add(Token item);
    public sealed virtual int Add(TokenNodeType tokenType, int start, int end, UInt32 lexerState);
    public sealed virtual void Clear();
    public sealed virtual void RemoveRange(int start);
    public sealed virtual void Purge();
    public sealed virtual void AddRange(IArrayOfTokens array, int start, int length, int delta);
    public void AddRange(SparseArrayOfTokens array, int start, int length, int delta);
    private void ProvideSpaceFor(int nItems);
    public sealed virtual int FindTokenAt(int offset);
    public sealed virtual Token Last();
    public IEnumerable`1<Token> View();
    public sealed virtual IEnumerable`1<Token> View(int start, int end);
}
public abstract class JetBrains.ReSharper.Psi.Parsing.StringLexerBase : object {
    private IBuffer myBuffer;
    private TokenNodeType myTokenType;
    private int myTokenStart;
    private int myTokenEnd;
    private int myTokenCount;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    protected int StartOffset { get; }
    protected int EndOffset { get; }
    public bool CanAdvance { get; }
    protected int Position { get; protected set; }
    public string CompiledChars { get; }
    public TokenNodeType TokenType { get; }
    public int TokenStart { get; }
    public int TokenEnd { get; }
    public IBuffer Buffer { get; }
    public int TokenCount { get; }
    private object JetBrains.ReSharper.Psi.Parsing.ILexer.CurrentPosition { get; private set; }
    protected StringLexerBase(IBuffer buffer);
    protected abstract virtual int get_StartOffset();
    protected abstract virtual int get_EndOffset();
    public sealed virtual bool get_CanAdvance();
    public sealed virtual void Start();
    protected virtual TokenNodeType StartInternal();
    public sealed virtual void Advance();
    private void FixTokenBorders();
    protected abstract virtual TokenNodeType AdvanceInternal();
    private TokenNodeType AdvanceToEnd();
    [PureAttribute]
protected bool CheckPosition(int position);
    [CompilerGeneratedAttribute]
protected int get_Position();
    [CompilerGeneratedAttribute]
protected void set_Position(int value);
    public virtual string get_CompiledChars();
    [NotNullAttribute]
protected abstract virtual string ParseEscapeCharacter(string value);
    protected TokenNodeType ProcessHexEscapeSequence(int min, int max);
    [NotNullAttribute]
protected string ProcessEscapeSequence(int min, int max, int shift, Func`2<char, bool> matcher);
    protected static string ParseHexEscapeSequence(string value, int min, int max);
    protected static string ParseEscapeSequence(string value, int min, int max, int shift, Func`2<string, string> factory);
    public sealed virtual TokenNodeType get_TokenType();
    public sealed virtual int get_TokenStart();
    public sealed virtual int get_TokenEnd();
    public sealed virtual IBuffer get_Buffer();
    public int get_TokenCount();
    private sealed virtual override object JetBrains.ReSharper.Psi.Parsing.ILexer.get_CurrentPosition();
    private sealed virtual override void JetBrains.ReSharper.Psi.Parsing.ILexer.set_CurrentPosition(object value);
}
public static class JetBrains.ReSharper.Psi.Parsing.StringTokenTypes : object {
    public static TokenNodeType CHARACTER;
    public static TokenNodeType ESCAPE_CHARACTER;
    public static TokenNodeType REDUNDANT_SLASH_ESCAPE_CHARACTER;
    public static TokenNodeType FORMAT_CHARACTER;
    public static TokenNodeType INVALID_CHARACTER;
    public static TokenNodeType START_BORDER_CHARACTER;
    public static TokenNodeType END_BORDER_CHARACTER;
    public static int BASE_INDEX;
    public static int CHARACTER_INDEX;
    public static int ESCAPE_INDEX;
    public static int INVALID_INDEX;
    public static int START_BORDER_INDEX;
    public static int END_BORDER_INDEX;
    public static int REDUNDANT_SLASH_ESCAPE_CHARACTER_INDEX;
    public static int FORMAT_INDEX;
    private static StringTokenTypes();
}
public class JetBrains.ReSharper.Psi.Parsing.SyntaxError : Exception {
    [CompilerGeneratedAttribute]
private TreeElement <ParsingResult>k__BackingField;
    [CompilerGeneratedAttribute]
private CompositeElement <ErrorElement>k__BackingField;
    [CanBeNullAttribute]
public TreeElement ParsingResult { get; public set; }
    [CanBeNullAttribute]
public CompositeElement ErrorElement { get; }
    public SyntaxError(TreeElement result);
    public SyntaxError(string details);
    [CompilerGeneratedAttribute]
public TreeElement get_ParsingResult();
    [CompilerGeneratedAttribute]
public void set_ParsingResult(TreeElement value);
    [CompilerGeneratedAttribute]
public CompositeElement get_ErrorElement();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Parsing.Token : ValueType {
    public int Start;
    public int End;
    public UInt32 LexerState;
    [CanBeNullAttribute]
public TokenNodeType Type;
    public Token(TokenNodeType type, int start, int end, UInt32 state);
    public virtual string ToString();
    [PureAttribute]
public Token Shift(int delta);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Parsing.TokenBuffer : object {
    [CompilerGeneratedAttribute]
private TextRange <LastResyncAffectedRange>k__BackingField;
    private IBuffer myBuffer;
    private IArrayOfTokens myCachedTokens;
    [CompilerGeneratedAttribute]
private bool <AllowReparseOnDocumentChange>k__BackingField;
    public TextRange LastResyncAffectedRange { get; private set; }
    public Token Item { get; }
    public IBuffer Buffer { get; }
    public IArrayOfTokens CachedTokens { get; }
    public bool AllowReparseOnDocumentChange { get; public set; }
    public TokenBuffer(ILexer lexer);
    public TokenBuffer(IArrayOfTokens cachedTokens, IBuffer buffer);
    [CompilerGeneratedAttribute]
public TextRange get_LastResyncAffectedRange();
    [CompilerGeneratedAttribute]
private Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LastResyncAffectedRange(TextRange value);
    public Token get_Item(int index);
    private void ReScanUpToEnd(ILexer lexer);
    public TokenBuffer ReScan(TextRange oldRange, ILexerFactory lexerFactory, BufferRange newBufferRange);
    private TokenBuffer ReScanInternalIncremental(TextRange changedRange, IIncrementalLexer lexer);
    public TokenBuffer ScanModifiedRangeAndTryMerge(ILexer newLexer, IArrayOfTokens newArrayOfTokens, int affectedRangeStart, int modifiedRangeEnd, int syncLexerPosition);
    private TokenBuffer ReScanInternalFull(TextRange changedRange, ILexer lexer);
    public IBuffer get_Buffer();
    public IArrayOfTokens get_CachedTokens();
    [CompilerGeneratedAttribute]
public bool get_AllowReparseOnDocumentChange();
    [CompilerGeneratedAttribute]
public void set_AllowReparseOnDocumentChange(bool value);
    public CachingLexer CreateLexer();
    public CachingLexer CreateLexer(ITokenIntern intern);
    public int FindTokenAt(int offset);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Parsing.TokenBufferExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static TokenBuffer ReSync(TokenBuffer tokenBuffer, TextRange modifiedRange, int insertedTextLength, ILexerFactory lexerFactory, IBuffer newDocumentBuffer);
}
public abstract class JetBrains.ReSharper.Psi.Parsing.TokenNodeType : NodeType {
    public bool IsWhitespace { get; }
    public bool IsComment { get; }
    public bool IsStringLiteral { get; }
    public bool IsConstantLiteral { get; }
    public bool IsIdentifier { get; }
    public bool IsKeyword { get; }
    public bool IsFiltered { get; }
    public string TokenRepresentation { get; }
    protected TokenNodeType(string s, int index);
    [NotNullAttribute]
public virtual LeafElementBase Create(string token);
    [NotNullAttribute]
public abstract virtual LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
    public abstract virtual bool get_IsWhitespace();
    public abstract virtual bool get_IsComment();
    public abstract virtual bool get_IsStringLiteral();
    public abstract virtual bool get_IsConstantLiteral();
    public abstract virtual bool get_IsIdentifier();
    public abstract virtual bool get_IsKeyword();
    public virtual bool get_IsFiltered();
    public abstract virtual string get_TokenRepresentation();
    public virtual string GetSampleText();
    public virtual string GetDescription();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Parsing.TokenNodeTypeEx : object {
    [ExtensionAttribute]
public static LeafElementBase Create(TokenNodeType nodeType, IBuffer buffer);
    [ExtensionAttribute]
public static LeafElementBase Create(TokenNodeType nodeType, IBuffer buffer, TreeTextRange range);
}
internal class JetBrains.ReSharper.Psi.Parsing.TokenTextEqualityComparer : object {
    private bool myCaseSensitive;
    public TokenTextEqualityComparer(bool caseSensitive);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Object>.Equals(object x, object y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Object>.GetHashCode(object obj);
}
public class JetBrains.ReSharper.Psi.Parsing.UnexpectedToken : SyntaxError {
    [CompilerGeneratedAttribute]
private TokenNodeType <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<NodeType> <ExpectedTokenTypes>k__BackingField;
    public TokenNodeType TokenType { get; }
    public IReadOnlyCollection`1<NodeType> ExpectedTokenTypes { get; }
    public UnexpectedToken(string details);
    public UnexpectedToken(TokenNodeType tokenType, IReadOnlyCollection`1<NodeType> expectedTokenTypes, string details);
    [CompilerGeneratedAttribute]
public sealed virtual TokenNodeType get_TokenType();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyCollection`1<NodeType> get_ExpectedTokenTypes();
}
public class JetBrains.ReSharper.Psi.Parsing.XmlLexerFactory : object {
    private XmlTokenTypes myXmlTokenTypes;
    public XmlLexerFactory(XmlTokenTypes xmlTokenTypes);
    private sealed virtual override ILexer JetBrains.ReSharper.Psi.Parsing.ILexerFactory.CreateLexer(IBuffer buffer);
    protected virtual XmlLexerGenerated CreateLexer(IBuffer buffer);
    public static XmlLexerGenerated CreateXmlLexer(IBuffer buffer, XmlTokenTypes xmlTokenTypes);
}
public class JetBrains.ReSharper.Psi.Parsing.XmlLexerGenerated : object {
    protected bool myIsDTDLexer;
    protected TokenNodeType currTokenType;
    private XmlTokenTypes myXmlTokenTypes;
    private int myPrevState;
    private static int YY_F;
    private static int YY_NO_STATE;
    private static int YY_NOT_ACCEPT;
    private static int YY_START;
    private static int YY_END;
    private static int YY_NO_ANCHOR;
    private static int YY_BOL;
    private static int YY_EOF;
    private int yy_buffer_index;
    private int yy_buffer_start;
    private int yy_buffer_end;
    private IBuffer yy_buffer;
    private int yy_eof_pos;
    private bool yy_at_bol;
    private int yy_lexical_state;
    protected static int YY_IN_CDATA;
    protected static int YY_IN_TAG;
    protected static int YY_IN_PI_BODY;
    protected static int YY_IN_DTD_BODY;
    protected static int YY_IN_DTD;
    protected static int YYINITIAL;
    protected static int YY_IN_COMMENT;
    protected static int YY_IN_PI;
    private static Int32[] yy_state_dtrans;
    private static int YY_E_INTERNAL;
    private static int YY_E_MATCH;
    private static String[] yy_error_string;
    private static Int32[] yy_acpt;
    private static Int32[] yy_cmap;
    private static Int32[] yy_rmap;
    private static Int32[0...,0...] yy_nxt;
    public bool IsDTDLexer { get; public set; }
    public XmlTokenTypes XmlTokenType { get; }
    public UInt32 LexerStateEx { get; }
    public XmlLexerState CurrentPosition { get; public set; }
    private object JetBrains.ReSharper.Psi.Parsing.ILexer.CurrentPosition { get; private set; }
    public TokenNodeType TokenType { get; }
    public int TokenStart { get; }
    public int TokenEnd { get; }
    public int LexemIndent { get; }
    public IBuffer Buffer { get; }
    protected int BufferIndex { get; protected set; }
    protected int BufferStart { get; protected set; }
    protected int BufferEnd { get; protected set; }
    public int EOFPos { get; }
    protected int LexicalState { get; protected set; }
    public XmlLexerGenerated(IBuffer buffer, XmlTokenTypes xmlTokenTypes);
    private XmlLexerGenerated(IBuffer buffer);
    private XmlLexerGenerated(IBuffer buffer, int startOffset, int endOffset);
    private static XmlLexerGenerated();
    public bool get_IsDTDLexer();
    public void set_IsDTDLexer(bool value);
    public XmlTokenTypes get_XmlTokenType();
    protected TokenNodeType makeToken(TokenNodeType type);
    public sealed virtual void Start();
    public sealed virtual void Start(int startOffset, int endOffset, UInt32 state);
    public sealed virtual void Advance();
    private void PushState();
    private int PopState();
    public sealed virtual UInt32 get_LexerStateEx();
    public sealed virtual XmlLexerState get_CurrentPosition();
    public sealed virtual void set_CurrentPosition(XmlLexerState value);
    private sealed virtual override object JetBrains.ReSharper.Psi.Parsing.ILexer.get_CurrentPosition();
    private sealed virtual override void JetBrains.ReSharper.Psi.Parsing.ILexer.set_CurrentPosition(object value);
    public sealed virtual TokenNodeType get_TokenType();
    public sealed virtual int get_TokenStart();
    public sealed virtual int get_TokenEnd();
    public sealed virtual int get_LexemIndent();
    public sealed virtual IBuffer get_Buffer();
    protected int get_BufferIndex();
    protected void set_BufferIndex(int value);
    protected int get_BufferStart();
    protected void set_BufferStart(int value);
    protected int get_BufferEnd();
    protected void set_BufferEnd(int value);
    public sealed virtual int get_EOFPos();
    protected int get_LexicalState();
    protected void set_LexicalState(int value);
    protected virtual void locateToken();
    private void yybegin(int state);
    private void yy_move_end();
    private static bool yy_isnewline(char c);
    internal string yytext();
    private int yylength();
    private void yy_error(int code, bool fatal);
    public TokenNodeType _locateToken();
}
public class JetBrains.ReSharper.Psi.Parsing.XmlLexerState : ValueType {
    public TokenNodeType currTokenType;
    public int yy_buffer_index;
    public int yy_buffer_start;
    public int yy_buffer_end;
    public int yy_lexical_state;
    public int myPrevState;
}
public class JetBrains.ReSharper.Psi.Parsing.XmlTokenNodeType : TokenNodeType {
    [NotNullAttribute]
private XmlTokenTypes myTypes;
    private IXmlTokenBuilder myXmlTokenBuilder;
    [CompilerGeneratedAttribute]
private bool <IsFiltered>k__BackingField;
    [NotNullAttribute]
public XmlTokenTypes XmlTokenTypes { get; }
    public bool IsFiltered { get; }
    public bool IsWhitespace { get; }
    public bool IsComment { get; }
    public bool IsStringLiteral { get; }
    public bool IsIdentifier { get; }
    public bool IsKeyword { get; }
    public string TokenRepresentation { get; }
    public bool IsConstantLiteral { get; }
    protected XmlTokenNodeType(string s, XmlTokenTypes types, int index, bool isFilteredNode);
    public XmlTokenNodeType(string s, XmlTokenTypes types, IXmlTokenBuilder xmlTokenBuilder, int index, bool isFilteredNode);
    public virtual LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset);
    public XmlTokenTypes get_XmlTokenTypes();
    [CompilerGeneratedAttribute]
public virtual bool get_IsFiltered();
    public virtual bool get_IsWhitespace();
    public virtual bool get_IsComment();
    public virtual bool get_IsStringLiteral();
    public virtual bool get_IsIdentifier();
    public virtual bool get_IsKeyword();
    public virtual string get_TokenRepresentation();
    public virtual bool get_IsConstantLiteral();
}
public class JetBrains.ReSharper.Psi.Parsing.XmlTokenTypes : object {
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <COMMENT_START>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <COMMENT_BODY>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <COMMENT_END>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <SPACE>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <NEW_LINE>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <TAG_START>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <TAG_START1>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <TEXT>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <TAG_END>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <TAG_END1>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <PISTART>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <PI_BODY>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <PIEND>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <STRING>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <UNFINISHED_STRING>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <EQ>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <IDENTIFIER>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <CDATA_START>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <CDATA_BODY>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <CDATA_END>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <ERROR>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <DTD_START>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <LBRACKET>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <RBRACKET>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <ELEMENT_START>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <ATTLIST_START>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <ENTITY_START>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <NOTATION_START>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <LPARENTH>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <RPARENTH>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <OR>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <ASTERISK>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <QUESTION>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <PLUS>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <COMMA>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <PERCENT>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <PE_REF>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <ENTITY_REF>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <CHAR_REF>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <PCDATA>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <REQUIRED>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <IMPLIED>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlTokenNodeType <FIXED>k__BackingField;
    public NodeTypeSet TEXT_NODES;
    [NotNullAttribute]
public PsiLanguageType LanguageType { get; }
    public XmlTokenNodeType COMMENT_START { get; protected set; }
    public XmlTokenNodeType COMMENT_BODY { get; protected set; }
    public XmlTokenNodeType COMMENT_END { get; protected set; }
    public XmlTokenNodeType SPACE { get; protected set; }
    public XmlTokenNodeType NEW_LINE { get; protected set; }
    public XmlTokenNodeType TAG_START { get; protected set; }
    public XmlTokenNodeType TAG_START1 { get; protected set; }
    public XmlTokenNodeType TEXT { get; protected set; }
    public XmlTokenNodeType TAG_END { get; protected set; }
    public XmlTokenNodeType TAG_END1 { get; protected set; }
    public XmlTokenNodeType PISTART { get; protected set; }
    public XmlTokenNodeType PI_BODY { get; protected set; }
    public XmlTokenNodeType PIEND { get; protected set; }
    public XmlTokenNodeType STRING { get; protected set; }
    public XmlTokenNodeType UNFINISHED_STRING { get; protected set; }
    public XmlTokenNodeType EQ { get; protected set; }
    public XmlTokenNodeType IDENTIFIER { get; protected set; }
    public XmlTokenNodeType CDATA_START { get; protected set; }
    public XmlTokenNodeType CDATA_BODY { get; protected set; }
    public XmlTokenNodeType CDATA_END { get; protected set; }
    public XmlTokenNodeType ERROR { get; protected set; }
    public XmlTokenNodeType DTD_START { get; protected set; }
    public XmlTokenNodeType LBRACKET { get; protected set; }
    public XmlTokenNodeType RBRACKET { get; protected set; }
    public XmlTokenNodeType ELEMENT_START { get; protected set; }
    public XmlTokenNodeType ATTLIST_START { get; protected set; }
    public XmlTokenNodeType ENTITY_START { get; protected set; }
    public XmlTokenNodeType NOTATION_START { get; protected set; }
    public XmlTokenNodeType LPARENTH { get; protected set; }
    public XmlTokenNodeType RPARENTH { get; protected set; }
    public XmlTokenNodeType OR { get; protected set; }
    public XmlTokenNodeType ASTERISK { get; protected set; }
    public XmlTokenNodeType QUESTION { get; protected set; }
    public XmlTokenNodeType PLUS { get; protected set; }
    public XmlTokenNodeType COMMA { get; protected set; }
    public XmlTokenNodeType PERCENT { get; protected set; }
    public XmlTokenNodeType PE_REF { get; protected set; }
    public XmlTokenNodeType ENTITY_REF { get; protected set; }
    public XmlTokenNodeType CHAR_REF { get; protected set; }
    public XmlTokenNodeType PCDATA { get; protected set; }
    public XmlTokenNodeType REQUIRED { get; protected set; }
    public XmlTokenNodeType IMPLIED { get; protected set; }
    public XmlTokenNodeType FIXED { get; protected set; }
    protected XmlTokenTypes(PsiLanguageType languageType);
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    public static XmlTokenTypes GetInstance(PsiLanguageType languageType);
    public static XmlTokenTypes GetInstance();
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_COMMENT_START();
    [CompilerGeneratedAttribute]
protected void set_COMMENT_START(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_COMMENT_BODY();
    [CompilerGeneratedAttribute]
protected void set_COMMENT_BODY(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_COMMENT_END();
    [CompilerGeneratedAttribute]
protected void set_COMMENT_END(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_SPACE();
    [CompilerGeneratedAttribute]
protected void set_SPACE(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_NEW_LINE();
    [CompilerGeneratedAttribute]
protected void set_NEW_LINE(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_TAG_START();
    [CompilerGeneratedAttribute]
protected void set_TAG_START(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_TAG_START1();
    [CompilerGeneratedAttribute]
protected void set_TAG_START1(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_TEXT();
    [CompilerGeneratedAttribute]
protected void set_TEXT(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_TAG_END();
    [CompilerGeneratedAttribute]
protected void set_TAG_END(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_TAG_END1();
    [CompilerGeneratedAttribute]
protected void set_TAG_END1(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_PISTART();
    [CompilerGeneratedAttribute]
protected void set_PISTART(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_PI_BODY();
    [CompilerGeneratedAttribute]
protected void set_PI_BODY(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_PIEND();
    [CompilerGeneratedAttribute]
protected void set_PIEND(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_STRING();
    [CompilerGeneratedAttribute]
protected void set_STRING(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_UNFINISHED_STRING();
    [CompilerGeneratedAttribute]
protected void set_UNFINISHED_STRING(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_EQ();
    [CompilerGeneratedAttribute]
protected void set_EQ(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_IDENTIFIER();
    [CompilerGeneratedAttribute]
protected void set_IDENTIFIER(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_CDATA_START();
    [CompilerGeneratedAttribute]
protected void set_CDATA_START(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_CDATA_BODY();
    [CompilerGeneratedAttribute]
protected void set_CDATA_BODY(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_CDATA_END();
    [CompilerGeneratedAttribute]
protected void set_CDATA_END(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_ERROR();
    [CompilerGeneratedAttribute]
protected void set_ERROR(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_DTD_START();
    [CompilerGeneratedAttribute]
protected void set_DTD_START(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_LBRACKET();
    [CompilerGeneratedAttribute]
protected void set_LBRACKET(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_RBRACKET();
    [CompilerGeneratedAttribute]
protected void set_RBRACKET(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_ELEMENT_START();
    [CompilerGeneratedAttribute]
protected void set_ELEMENT_START(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_ATTLIST_START();
    [CompilerGeneratedAttribute]
protected void set_ATTLIST_START(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_ENTITY_START();
    [CompilerGeneratedAttribute]
protected void set_ENTITY_START(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_NOTATION_START();
    [CompilerGeneratedAttribute]
protected void set_NOTATION_START(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_LPARENTH();
    [CompilerGeneratedAttribute]
protected void set_LPARENTH(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_RPARENTH();
    [CompilerGeneratedAttribute]
protected void set_RPARENTH(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_OR();
    [CompilerGeneratedAttribute]
protected void set_OR(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_ASTERISK();
    [CompilerGeneratedAttribute]
protected void set_ASTERISK(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_QUESTION();
    [CompilerGeneratedAttribute]
protected void set_QUESTION(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_PLUS();
    [CompilerGeneratedAttribute]
protected void set_PLUS(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_COMMA();
    [CompilerGeneratedAttribute]
protected void set_COMMA(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_PERCENT();
    [CompilerGeneratedAttribute]
protected void set_PERCENT(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_PE_REF();
    [CompilerGeneratedAttribute]
protected void set_PE_REF(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_ENTITY_REF();
    [CompilerGeneratedAttribute]
protected void set_ENTITY_REF(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_CHAR_REF();
    [CompilerGeneratedAttribute]
protected void set_CHAR_REF(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_PCDATA();
    [CompilerGeneratedAttribute]
protected void set_PCDATA(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_REQUIRED();
    [CompilerGeneratedAttribute]
protected void set_REQUIRED(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_IMPLIED();
    [CompilerGeneratedAttribute]
protected void set_IMPLIED(XmlTokenNodeType value);
    [CompilerGeneratedAttribute]
public XmlTokenNodeType get_FIXED();
    [CompilerGeneratedAttribute]
protected void set_FIXED(XmlTokenNodeType value);
}
public interface JetBrains.ReSharper.Psi.Paths.IProjectPathMapping {
    [CanBeNullAttribute]
public IProject Project { get; }
    public abstract virtual IProject get_Project();
    public abstract virtual PathState GetPathState(VirtualFileSystemPath webPath);
    public abstract virtual IList`1<VirtualFileSystemPath> GetRealPaths(VirtualFileSystemPath webPath);
    public abstract virtual IList`1<VirtualFileSystemPath> GetAllRelativePaths();
    public abstract virtual IList`1<VirtualFileSystemPath> GetAllPathPartsIn(VirtualFileSystemPath parentPath);
    public abstract virtual void RemoveAllPaths();
    public abstract virtual void IgnorePath(VirtualFileSystemPath path);
    public abstract virtual void SetPathMapping(VirtualFileSystemPath webPath, VirtualFileSystemPath realPath);
}
public interface JetBrains.ReSharper.Psi.Paths.IVirtualFilesProvider {
    [NotNullAttribute]
public abstract virtual IEnumerable`1<VirtualFileSystemPath> GetAbsolutePathsToVirtualFiles(IProject project);
    [CanBeNullAttribute]
public abstract virtual IProjectFile GetProjectFileByVirtualPath(IProject project, VirtualFileSystemPath virtualPath);
    [CanBeNullAttribute]
public abstract virtual IPsiSourceFile GetPsiSourceFileByVirtualPath(IProject project, VirtualFileSystemPath virtualPath);
}
public interface JetBrains.ReSharper.Psi.Paths.IVirtualFoldersProvider {
    [NotNullAttribute]
public abstract virtual IEnumerable`1<VirtualFileSystemPath> GetAbsolutePathsToVirtualFolders(IProject project);
    [CanBeNullAttribute]
public abstract virtual IProjectFolder GetProjectFolderByVirtualPath(IProject project, VirtualFileSystemPath virtualPath);
}
public interface JetBrains.ReSharper.Psi.Paths.IVirtualPathsService {
    [NotNullAttribute]
public abstract virtual IEnumerable`1<VirtualFileSystemPath> GetPathPartsIn(IProject project, VirtualFileSystemPath virtualPrefixPath);
    public abstract virtual bool IsVirtualPathOrPrefix(IProject project, VirtualFileSystemPath virtualPath);
    public abstract virtual void RegisterFilesProvider(Lifetime lifetime, IVirtualFilesProvider filesProvider);
    public abstract virtual void RegisterFoldersProvider(Lifetime lifetime, IVirtualFoldersProvider foldersProvider);
}
public abstract class JetBrains.ReSharper.Psi.Paths.PathMappingManager : object {
    [NotNullAttribute]
public static IProjectPathMapping GetPathMapping(IPathReference pathReference);
    [NotNullAttribute]
public static IProjectPathMapping GetPathMapping(IProject project);
    public static void RunPathMappingEditor(IPathReference pathReference, VirtualFileSystemPath preselectedPath);
    public static void RunPathMappingEditor(IProject project, VirtualFileSystemPath preselectedPath);
    protected abstract virtual void RunPathMappingEditorImpl(IProject project, VirtualFileSystemPath preselectedPath);
    [NotNullAttribute]
protected abstract virtual IProjectPathMapping GetPathMappingImpl(IProject project);
}
internal static class JetBrains.ReSharper.Psi.Paths.PathMappingSettingsAccessor : object {
    public static Expression`1<Func`2<WebPathMappingSettings, IIndexedEntry`2<VirtualFileSystemPath, VirtualFileSystemPath>>> MappedPathsExpression;
    public static Expression`1<Func`2<WebPathMappingSettings, IIndexedEntry`2<VirtualFileSystemPath, VirtualFileSystemPath>>> IgnoredPathsExpression;
    public static Expression`1<Func`2<WebPathMappingSettings, IIndexedEntry`2<VirtualFileSystemPath, VirtualFileSystemPath>>> PathsInCorrectCasingExpression;
    private static PathMappingSettingsAccessor();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Paths.PathReferenceEx : object {
    [ExtensionAttribute]
public static IPsiSourceFile GetPsiSourceFileInProject(IProject project, VirtualFileSystemPath resourceFilePath);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IPsiSourceFile ResolvePsiSourceFileInOwnProject(IPathReference pathReference);
    [CanBeNullAttribute]
private static IProject GetOwnProject(IPathReference pathReference);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Paths.PathState : Enum {
    public int value__;
    public static PathState NONE;
    public static PathState IGNORED_OR_PART_OF;
    public static PathState MAPPED;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Paths.ProjectPathMappingExtensions : object {
    public static IProjectPathMapping EmptyMapping;
    private static ProjectPathMappingExtensions();
    [ExtensionAttribute]
public static bool IsEmpty(IProjectPathMapping mapping);
    [ExtensionAttribute]
public static void Dump(IProjectPathMapping mapping, TextWriter w, Func`2<VirtualFileSystemPath, VirtualFileSystemPath> pathPresenter);
    [ExtensionAttribute]
public static IDictionary`2<VirtualFileSystemPath, VirtualFileSystemPath> GetRealToWebPathMapping(IProjectPathMapping mapping);
}
public class JetBrains.ReSharper.Psi.PerformanceThreshold.BinaryFileDetector : object {
    private static Int32[][] ourKnownBinaryMasks;
    private static int MAX_MASK_LENGTH;
    private static String[] ourQuickCheckNonTextExtension;
    private static BinaryFileDetector();
    public static bool IsBinary(VirtualFileSystemPath location);
    public static bool IsLikelyBinary(VirtualFileSystemPath path);
    private static bool IsLikelyBinaryExtension(VirtualFileSystemPath path);
    public static bool IsLikelyBinaryContent(VirtualFileSystemPath path);
}
[PsiSharedComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.PerformanceThreshold.DoNotBuildPsiForCompressedFiles : object {
    private PerformanceThresholds myThresholds;
    public double Order { get; }
    public DoNotBuildPsiForCompressedFiles(PerformanceThresholds thresholds);
    public sealed virtual double get_Order();
    public sealed virtual IPsiSourceFileProperties GetPsiProperties(IPsiSourceFileProperties prevProperties, IProject project, IProjectFile projectFile, IPsiSourceFile sourceFile);
}
[PsiSharedComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.PerformanceThreshold.DoNotBuildPsiForHugeFiles : object {
    private PerformanceThresholds myThresholds;
    public double Order { get; }
    public DoNotBuildPsiForHugeFiles(PerformanceThresholds thresholds);
    public sealed virtual double get_Order();
    public sealed virtual IPsiSourceFileProperties GetPsiProperties(IPsiSourceFileProperties prevProperties, IProject project, IProjectFile projectFile, IPsiSourceFile sourceFile);
}
[PsiSharedComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.PerformanceThreshold.ExcludedProjectPsiSourceFilePropertiesProvider : object {
    private ExcludedProjects myExcludedProjects;
    public double Order { get; }
    public ExcludedProjectPsiSourceFilePropertiesProvider(ExcludedProjects excludedProjects);
    public sealed virtual double get_Order();
    public sealed virtual IPsiSourceFileProperties GetPsiProperties(IPsiSourceFileProperties prevProperties, IProject project, IProjectFile projectFile, IPsiSourceFile sourceFile);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.PerformanceThreshold.PerformanceThresholdExtensions : object {
    [ExtensionAttribute]
public static bool IsAnalysisFileSizeThresholdExceeded(PerformanceThresholds self, IPsiSourceFile file);
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.PerformanceThreshold.PerformanceThresholds : object {
    private Dictionary`2<PsiLanguageType, int> myBuildPsiFileSizeThreshold;
    private Dictionary`2<PsiLanguageType, int> myAnalysisFileSizeThreshold;
    private Dictionary`2<PsiLanguageType, int> myAnalysisAverageLineLengthThreshold;
    private Dictionary`2<PsiLanguageType, int> myPsiDepthThreshold;
    private Dictionary`2<PsiLanguageType, int> myBuildPsiCompressedThreshold;
    [CompilerGeneratedAttribute]
private int <ContentFileThreshold>k__BackingField;
    public int ContentFileThreshold { get; private set; }
    public PerformanceThresholds(SynchronizedLifetime lifetime, ISettingsStore settingsStore, ProjectFileTypes projectFileTypes, ILanguages psiLanguages);
    private static void LoadDictionary(IContextBoundSettingsStoreLive settingsStoreLive, ProjectFileTypes projectFileTypes, ILanguages psiLanguages, Expression`1<Func`2<PerformanceThresholdSettings, IIndexedEntry`2<string, int>>> expr, Dictionary`2<PsiLanguageType, int> dictionary);
    private void Load(IContextBoundSettingsStoreLive settingsStoreLive, ProjectFileTypes projectFileTypes, ILanguages psiLanguages);
    private void Clear();
    private static int GetValueFromDictionary(PsiLanguageType language, Dictionary`2<PsiLanguageType, int> dictionary);
    public int GetBuildPsiFileSizeThreshold(PsiLanguageType language);
    public int GetAnalysisAverageLineLengthThreshold(PsiLanguageType language);
    public int GetAnalysisFileSizeThreshold(PsiLanguageType language);
    public int GetPsiDepthThreshold(PsiLanguageType language);
    public bool ShouldCheckForCompressedFile(PsiLanguageType language);
    [CompilerGeneratedAttribute]
public int get_ContentFileThreshold();
    [CompilerGeneratedAttribute]
private void set_ContentFileThreshold(int value);
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.PerformanceThreshold.Settings.DefaultPerformanceThresholdSettingsProvider : HaveDefaultSettings`1<PerformanceThresholdSettings> {
    private static string JavaScript;
    private static string TypeScript;
    private static string JSON;
    private static string CSS;
    private static string HTML;
    private static string XML;
    private static string ASPX;
    private static string Razor;
    private static string CSharp;
    private static string RazorCSharp;
    private static string Cpp;
    private static string CppDoxygen;
    private static string SQL;
    public string Name { get; }
    public DefaultPerformanceThresholdSettingsProvider(ILogger logger, ISettingsSchema settingsSchema);
    public virtual void InitDefaultSettings(ISettingsStorageMountPoint mountPoint);
    public virtual string get_Name();
}
[SettingsKeyAttribute("System.Reflection.Missing", "JetBrains.ReSharper.Psi.Resources.Strings", "ThresholdsToDisablePSIOrAnalysisInTheSakeOfPerformanceReasonsSettingDescription")]
public class JetBrains.ReSharper.Psi.PerformanceThreshold.Settings.PerformanceThresholdSettings : object {
    private static int _100MB;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "FilesSizeThresholdAfterWhichPSIIsNotBuiltKeyIsLanguageValueIsFileSizeInCharactersSettingDescription")]
public IIndexedEntry`2<string, int> BuildPsiFileSizeThreshold;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "FilesSizeThresholdAfterWhichAnalysisIsNotRunUnlessExplicitlySpecifiedByUserKeyIsLanguageValueIsFileSizeInCharactersSettingDescription")]
public IIndexedEntry`2<string, int> AnalysisFileSizeThreshold;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "AverageLineLengthThresholdAfterWhichAnalysisIsNotRunUnlessExplicitlySpecifiedByUserIEMinimizedJavascriptsKeyIsLanguageValueIsFileSizeInCharactersSettingDescription")]
public IIndexedEntry`2<string, int> AnalysisAverageLineLengthThreshold;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "MaximumPSITreeDepthUsedToPreventStackOverflowExceptionSettingDescription")]
public IIndexedEntry`2<string, int> PsiDepthThreshold;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "SpecifiesWhetherFilesShouldBeCheckedForBeingCompressedKeyIsLanguageIfValueItIstrueSettingDescription")]
public IIndexedEntry`2<string, int> CompressedFileThreshold;
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Psi.Resources.Strings", "SpecifiesWhetherFilesShouldIndexedForTextSearchDescription")]
public int ContentFileThreshold;
}
public static class JetBrains.ReSharper.Psi.PerformanceThreshold.Settings.PerformanceThresholdSettingsAccessor : object {
    public static Expression`1<Func`2<PerformanceThresholdSettings, IIndexedEntry`2<string, int>>> BuildPsiFileSizeThreshold;
    public static Expression`1<Func`2<PerformanceThresholdSettings, IIndexedEntry`2<string, int>>> AnalysisAverageLineLengthThreshold;
    public static Expression`1<Func`2<PerformanceThresholdSettings, IIndexedEntry`2<string, int>>> AnalysisFileSizeThreshold;
    public static Expression`1<Func`2<PerformanceThresholdSettings, IIndexedEntry`2<string, int>>> PsiDepthThreshold;
    public static Expression`1<Func`2<PerformanceThresholdSettings, IIndexedEntry`2<string, int>>> CompressedFileThreshold;
    public static Expression`1<Func`2<PerformanceThresholdSettings, int>> ContentFileThreshold;
    private static PerformanceThresholdSettingsAccessor();
}
internal class JetBrains.ReSharper.Psi.Pointers.DeclaredElementInstancePointer`1 : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CanBeNullAttribute]
private IReadOnlyList`1<ValueTuple`2<IDeclaredElementPointer`1<ITypeParameter>, ITypePointer>> mySubstitution;
    [CompilerGeneratedAttribute]
private IDeclaredElementPointer`1<TDeclaredElement> <ElementPointer>k__BackingField;
    public IDeclaredElementPointer`1<TDeclaredElement> ElementPointer { get; }
    public DeclaredElementInstancePointer`1(TDeclaredElement element, ISubstitution substitution);
    public DeclaredElementInstancePointer`1(DeclaredElementInstance`1<TDeclaredElement> instance);
    [CompilerGeneratedAttribute]
public sealed virtual IDeclaredElementPointer`1<TDeclaredElement> get_ElementPointer();
    public sealed virtual DeclaredElementInstance`1<TDeclaredElement> Resolve();
}
public abstract class JetBrains.ReSharper.Psi.Pointers.DeclaredElementPointer : object {
    [NotNullAttribute]
private IDeclaredElement myStoredDeclaredElement;
    [NotNullAttribute]
private IPsiServices myPsiServices;
    [NotNullAttribute]
private DeclaredElementType myElementType;
    [NotNullAttribute]
private CompactOneToListMap`2<IPsiSourceFile, Binding> myBindings;
    internal IDeclaredElement StoredDeclaredElement { get; }
    protected DeclaredElementPointer(IDeclaredElement declaredElement);
    internal IDeclaredElement get_StoredDeclaredElement();
    [NotNullAttribute]
protected virtual Binding CreateBinding(IPsiSourceFile sourceFile, IDeclaration declaration);
    internal void FastenBelts(IPsiPointers pointers, IPsiSourceFile sourceFile);
    protected IDeclaredElement FindDeclaredElement();
    public virtual string ToString();
}
public interface JetBrains.ReSharper.Psi.Pointers.IDeclaredElementPointer`1 {
    [CanBeNullAttribute]
[MustUseReturnValueAttribute]
public abstract virtual TDeclaredElement FindDeclaredElement();
}
public interface JetBrains.ReSharper.Psi.Pointers.IElementInstancePointer`1 {
    [NotNullAttribute]
public IDeclaredElementPointer`1<TDeclaredElement> ElementPointer { get; }
    public abstract virtual IDeclaredElementPointer`1<TDeclaredElement> get_ElementPointer();
    [CanBeNullAttribute]
public abstract virtual DeclaredElementInstance`1<TDeclaredElement> Resolve();
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.Pointers.IPsiPointers {
    public abstract virtual IDeclaredElementPointer`1<TDeclaredElement> CreateDeclaredElementPointer(TDeclaredElement element);
    public abstract virtual IReferencePointer CreateReferencePointer(IReference reference);
    public abstract virtual ITreeNodePointer`1<TTreeNode> CreateTreeElementPointer(TTreeNode element, TreeNodePointerConfiguration configuration);
    public abstract virtual TSmartPointer RegisterSmartPointer(TSmartPointer binding);
}
public interface JetBrains.ReSharper.Psi.Pointers.ISmartPointer {
    public IPsiSourceFile SourceFile { get; }
    public abstract virtual IPsiSourceFile get_SourceFile();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changed(EventHandler`1<RangeMarkerChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changed(EventHandler`1<RangeMarkerChangedEventArgs> value);
}
public interface JetBrains.ReSharper.Psi.Pointers.ISpecificPsiPointers {
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IDeclaredElementPointer`1<TDeclaredElement> CreateElementPointer(TDeclaredElement declaredElement);
}
public class JetBrains.ReSharper.Psi.Pointers.NonPhysicalElementPointer`1 : object {
    [NotNullAttribute]
private ITreeNode myNode;
    public NonPhysicalElementPointer`1(TDeclaredElement element);
    public sealed virtual TDeclaredElement FindDeclaredElement();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Pointers.PsiModulePtr : ValueType {
    public static PsiModulePtr Invalid;
    private string myId;
    private int myHash;
    private IPsiModules myModules;
    public string Id { get; }
    [CanBeNullAttribute]
public IPsiModule Module { get; }
    public PsiModulePtr(string id, IPsiModules modules);
    private static PsiModulePtr();
    public string get_Id();
    public IPsiModule get_Module();
    public sealed virtual bool Equals(PsiModulePtr other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [PureAttribute]
public bool IsValid();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Pointers.PsiPointersExtensions : object {
    [ExtensionAttribute]
public static IDeclaredElementPointer`1<TDeclaredElement> CreateElementPointer(TDeclaredElement element);
    [ExtensionAttribute]
public static IElementInstancePointer`1<TDeclaredElement> CreateElementInstancePointer(DeclaredElementInstance`1<TDeclaredElement> instance);
    [ExtensionAttribute]
public static IElementInstancePointer`1<TDeclaredElement> CreateElementInstancePointer(TDeclaredElement element, ISubstitution substitution);
    [ExtensionAttribute]
public static ITreeNodePointer`1<TTreeNode> CreateTreeElementPointer(TTreeNode element, TreeNodePointerConfiguration configuration);
    [ExtensionAttribute]
public static IReferencePointer CreateReferencePointer(TReference reference);
}
internal class JetBrains.ReSharper.Psi.Pointers.ReferencePointer : SmartPointerBase`1<IReference> {
    private Type myReferenceType;
    public ReferencePointer(IReference reference);
    public sealed virtual IReference GetReference();
    protected virtual DocumentRange GetDocumentRange(IReference reference);
    protected virtual TreeTextRange GetTreeTextRange(IReference reference);
    protected virtual bool IsValid(IReference reference);
    protected virtual IReference FindByRange(IFile file, TreeTextRange range);
}
public abstract class JetBrains.ReSharper.Psi.Pointers.SmartPointerBase`1 : object {
    [NotNullAttribute]
private WeakReference`1<TElement> myElement;
    [CanBeNullAttribute]
private IRangeMarker myRangeMarker;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiLanguageType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiLanguageCategories <LanguageCategories>k__BackingField;
    private EventHandler`1<RangeMarkerChangedEventArgs> myChanged;
    [NotNullAttribute]
public IPsiSourceFile SourceFile { get; }
    [NotNullAttribute]
public PsiLanguageType LanguageType { get; }
    public PsiLanguageCategories LanguageCategories { get; }
    [CanBeNullAttribute]
public IRangeMarker RangeMarker { get; }
    protected SmartPointerBase`1(IPsiSourceFile sourceFile, PsiLanguageType language, PsiLanguageCategories languageCategories, TElement element);
    [CompilerGeneratedAttribute]
public sealed virtual IPsiSourceFile get_SourceFile();
    [CompilerGeneratedAttribute]
public PsiLanguageType get_LanguageType();
    [CompilerGeneratedAttribute]
public PsiLanguageCategories get_LanguageCategories();
    [CanBeNullAttribute]
public TElement Find();
    protected abstract virtual bool IsValid(TElement element);
    protected abstract virtual DocumentRange GetDocumentRange(TElement element);
    protected abstract virtual TreeTextRange GetTreeTextRange(TElement element);
    protected abstract virtual TElement FindByRange(IFile file, TreeTextRange range);
    [CanBeNullAttribute]
protected virtual TElement FindByCustomRules();
    protected virtual void OnElementUpdated(TElement element);
    private void RegisterRangeMarker(TElement element);
    private void UnregisterRangeMarker(IRangeMarker rangeMarker);
    private void OnChanged(object sender, RangeMarkerChangedEventArgs args);
    public sealed virtual void add_Changed(EventHandler`1<RangeMarkerChangedEventArgs> value);
    public sealed virtual void remove_Changed(EventHandler`1<RangeMarkerChangedEventArgs> value);
    public virtual IRangeMarker get_RangeMarker();
}
internal static class JetBrains.ReSharper.Psi.Pointers.SmartPointerKeyStorage : object {
    public static Key Key;
    private static SmartPointerKeyStorage();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PsiComponentAttribute("10")]
internal class JetBrains.ReSharper.Psi.Pointers.SmartPointerManager : object {
    private static Key`1<WeakCollection`1<DeclaredElementPointer>> ELEMENT_POINTERS_LIST_KEY;
    private static Key`1<WeakCollection`1<ISmartPointer>> SMART_POINTERS_LIST_KEY;
    private IShellLocks myLocks;
    private IPsiFiles myPsiFiles;
    private PsiProjectFileTypeCoordinator myProjectFileTypeCoordinator;
    private object myLock;
    private HashSet`1<IPsiSourceFile> myPsiSourceFilesOfCreatedIFiles;
    public SmartPointerManager(Lifetime lifetime, IShellLocks locks, IPsiFiles psiFiles, PsiProjectFileTypeCoordinator projectFileTypeCoordinator);
    private static SmartPointerManager();
    private void OnPsiFileCreatedEvent(IFile file);
    public sealed virtual IDeclaredElementPointer`1<TDeclaredElement> CreateDeclaredElementPointer(TDeclaredElement element);
    private void FastenBelts(SourceElementPointer`1<TDeclaredElement> sourceElementPointer, HybridCollection`1<IPsiSourceFile> sourceFiles);
    public sealed virtual IReferencePointer CreateReferencePointer(IReference reference);
    public sealed virtual TSmartPointer RegisterSmartPointer(TSmartPointer smartPointer);
    private void ProcessPsiSourceFiles();
    private void OnPsiFileCreated(IPsiSourceFile sourceFile);
    public sealed virtual ITreeNodePointer`1<TTreeNode> CreateTreeElementPointer(TTreeNode element, TreeNodePointerConfiguration configuration);
}
public class JetBrains.ReSharper.Psi.Pointers.SourceElementPointer`1 : DeclaredElementPointer {
    public SourceElementPointer`1(TDeclaredElement element);
    private sealed virtual override TDeclaredElement JetBrains.ReSharper.Psi.Pointers.IDeclaredElementPointer<TDeclaredElement>.FindDeclaredElement();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Pointers.SourceFilePtr : ValueType {
    public static SourceFilePtr Fake;
    [CanBeNullAttribute]
private IPersistentIndexManager myPersistentIndexManager;
    [CompilerGeneratedAttribute]
private OWORD <Id>k__BackingField;
    public OWORD Id { get; }
    public IPsiSourceFile File { get; }
    public SourceFilePtr(OWORD id, IPersistentIndexManager indexManager);
    private static SourceFilePtr();
    [CompilerGeneratedAttribute]
public OWORD get_Id();
    public IPsiSourceFile get_File();
    public sealed virtual bool Equals(SourceFilePtr other);
    public virtual bool Equals(object obj);
    [PureAttribute]
public bool IsFake();
    public virtual int GetHashCode();
    [PureAttribute]
public bool IsValid();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Psi.Pointers.TreeNodePointer`1 : SmartPointerBase`1<TTreeNode> {
    private TreeNodePointerConfiguration myConfiguration;
    private object myPersistentValue;
    private NodeType myType;
    private TreeTextRange myTreeTextRange;
    public TreeNodePointer`1(IPsiSourceFile sourceFile, TTreeNode element, TreeNodePointerConfiguration configuration);
    protected virtual bool IsValid(TTreeNode element);
    protected virtual DocumentRange GetDocumentRange(TTreeNode element);
    protected virtual TreeTextRange GetTreeTextRange(TTreeNode element);
    protected virtual TTreeNode FindByRange(IFile file, TreeTextRange range);
    protected virtual TTreeNode FindByCustomRules();
    protected virtual void OnElementUpdated(TTreeNode element);
    private bool PointerKeyChecker(ITreeNode treeNode);
    public sealed virtual TTreeNode GetTreeNode();
}
public class JetBrains.ReSharper.Psi.Pointers.TreeNodePointerConfiguration : object {
    public static TreeNodePointerConfiguration Default;
    public static TreeNodePointerConfiguration SkipRangeChecking;
    private IFindByRangeStrategy myFindByRangeStrategy;
    private TreeNodePointerConfiguration(IFindByRangeStrategy findByRangeStrategy);
    private static TreeNodePointerConfiguration();
    [PureAttribute]
public TTreeNode FindByRange(IFile file, TreeTextRange range, NodeType nodeType);
}
public class JetBrains.ReSharper.Psi.Pointers.TrivialElementInstancePointer`1 : object {
    [NotNullAttribute]
private DeclaredElementInstance`1<TDeclaredElement> myElementInstance;
    public IDeclaredElementPointer`1<TDeclaredElement> ElementPointer { get; }
    public TrivialElementInstancePointer`1(DeclaredElementInstance`1<TDeclaredElement> element);
    public sealed virtual IDeclaredElementPointer`1<TDeclaredElement> get_ElementPointer();
    public sealed virtual DeclaredElementInstance`1<TDeclaredElement> Resolve();
}
public class JetBrains.ReSharper.Psi.Pointers.TrivialElementPointer`1 : object {
    [NotNullAttribute]
private TDeclaredElement myElement;
    public TrivialElementPointer`1(TDeclaredElement element);
    [NotNullAttribute]
public sealed virtual TDeclaredElement FindDeclaredElement();
}
internal class JetBrains.ReSharper.Psi.Pointers.TrivialReferencePointer : object {
    private IReference myReference;
    public IPsiSourceFile SourceFile { get; }
    public TrivialReferencePointer(IReference reference);
    public sealed virtual IReference GetReference();
    public sealed virtual IPsiSourceFile get_SourceFile();
}
internal class JetBrains.ReSharper.Psi.Pointers.TrivialTreeNodePointer`1 : object {
    private T myElement;
    public IPsiSourceFile SourceFile { get; }
    public TrivialTreeNodePointer`1(T element);
    public sealed virtual T GetTreeNode();
    public sealed virtual IPsiSourceFile get_SourceFile();
}
public class JetBrains.ReSharper.Psi.PredefinedType : object {
    [NotNullAttribute]
private static HashSet`1<IClrTypeName> PredefinedNumericTypes;
    [NotNullAttribute]
private static HashSet`1<IClrTypeName> PredefinedNumericTypesWithoutNumericIntPtr;
    [NotNullAttribute]
private static HashSet`1<IClrTypeName> PredefinedIntegralTypes;
    [NotNullAttribute]
private static HashSet`1<IClrTypeName> PredefinedIntegralTypesWithoutNumericIntPtr;
    [NotNullAttribute]
private static HashSet`1<IClrTypeName> PredefinedIntegralNumericTypes;
    [NotNullAttribute]
private static HashSet`1<IClrTypeName> PredefinedIntegralNumericTypesWithoutNumericIntPtr;
    [NotNullAttribute]
private static HashSet`1<IClrTypeName> SimplePredefinedTypes;
    [NotNullAttribute]
private static HashSet`1<IClrTypeName> SimplePredefinedTypesWithoutNumericIntPtr;
    [NotNullAttribute]
private static HashSet`1<IClrTypeName> PredefinedTypesWithoutOperators_BeforeNet7;
    [NotNullAttribute]
private static HashSet`1<IClrTypeName> PredefinedTypesWithoutOperators;
    [NotNullAttribute]
private static Dictionary`2<IClrTypeName, TypeClassification> PredefinedTypesClassification;
    [NotNullAttribute]
private static Dictionary`2<IClrTypeName, int> PredefinedTypeNamesIndex;
    [NotNullAttribute]
private IPsiModule myModule;
    [NotNullAttribute]
private IDeclaredType[] myTypes;
    [CanBeNullAttribute]
private PredefinedColorTypes modreq(System.Runtime.CompilerServices.IsVolatile) myColorTypes;
    [CanBeNullAttribute]
private IDeclaredType myDynamicType;
    [CanBeNullAttribute]
private IDeclaredType myNativeInteger;
    [CanBeNullAttribute]
private IDeclaredType myNativeUnsignedInteger;
    [CanBeNullAttribute]
private IDeclaredType myReadOnlySpanOfByte;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
private ConcurrentDictionary`2<ValueTuple`2<IClrTypeName, NullableAnnotation>, IDeclaredType> myAnnotatedPredefinedType;
    [NotNullAttribute]
private ConcurrentDictionary`2<NullableAnnotation, IDeclaredType> myAnnotatedDynamicType;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<ValueTuple`2<int, bool>, ITypeElement> myStandardDelegateTypes;
    private Nullable`1<bool> myRuntimeSupportsNumericIntPtr;
    [NotNullAttribute]
public static IClrTypeName DATA_MEMBER_ATTRIBUTE;
    [NotNullAttribute]
public static IClrTypeName ENUM_MEMBER_ATTRIBUTE;
    [NotNullAttribute]
public static IClrTypeName DATA_CONTRACT_ATTRIBUTE;
    [NotNullAttribute]
public static IClrTypeName SERVICE_CONTRACT_ATTRIBUTE;
    [NotNullAttribute]
public static IClrTypeName OPERATION_CONTRACT_ATTRIBUTE;
    [NotNullAttribute]
public static IClrTypeName EDITOR_BROWSABLE_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName ATTRIBUTE_USAGE_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName ATTRIBUTE_TARGETS_ENUM;
    [NotNullAttribute]
public static IClrTypeName TYPE_DESCRIPTION_PROVIDER_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName INTERNALS_VISIBLE_TO_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName FLAGS_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName STRUCT_LAYOUT_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName LAYOUT_KIND_ENUM;
    [NotNullAttribute]
public static IClrTypeName EXTENSION_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName IS_VOLATILE_CLASS;
    [NotNullAttribute]
public static IClrTypeName PARAM_ARRAY_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName FIELD_OFFSET_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName ASSEMBLY_COMPANY_ATTRIBUTE;
    [NotNullAttribute]
public static IClrTypeName DEFAULT_MEMBER_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName COCLASS_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName GUID_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName TYPEIDENTIFIER_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName IMPORTEDFROMTYPELIB_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName COMIMPORT_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName OBSOLETE_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName OVERLOAD_RESOLUTION_PRIORITY_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName EXPERIMENTAL_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName DEPRECATED_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName WINDOWS_EXPERIMENTAL_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName INDEXER_NAME_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName SPECIAL_NAME_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName SERIALIZABLE_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName NONSERIALIZED_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName COMPILER_GENERATED_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName ASYNC_STATE_MACHINE_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName ASYNC_ITERATOR_STATE_MACHINE_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName ITERATOR_STATE_MACHINE_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName DYNAMIC_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName NATIVE_INTEGER_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName DLLIMPORT_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName METHODIMPL_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName MARSHALAS_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName IN_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName OUT_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName OPTIONAL_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName DEFAULTPARAMETERVALUE_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName DEBUGGER_STEP_THROUGH_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName DEBUGGER_DISPLAY_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName DEBUGGER_BROWSABLE_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName CONDITIONAL_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName TYPE_FORWARDED_FROM_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName DECIMAL_CONSTANT_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName DATETIME_CONSTANT_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName FIXED_BUFFER_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName THREAD_STATIC_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName DESCRIPTION_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName DESIGNER_SERIALIZATION_VISIBILITY_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName BROWSABLE_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName ACCESSEDTHROUGHPROPERTY_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName CODEDOM_GENERATED_CODE_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName DEFAULTVALUE_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName RUNTIMEARGUMENTHANDLE_FQN;
    [NotNullAttribute]
public static IClrTypeName RUNTIMEFIELDHANDLE_FQN;
    [NotNullAttribute]
public static IClrTypeName RUNTIMEMETHODHANDLE_FQN;
    [NotNullAttribute]
public static IClrTypeName RUNTIMETYPEHANDLE_FQN;
    [NotNullAttribute]
public static IClrTypeName ENUMERABLE_CLASS;
    [NotNullAttribute]
public static IClrTypeName ASYNC_ENUMERABLE_CLASS;
    [NotNullAttribute]
public static IClrTypeName STREAM_FQN;
    [NotNullAttribute]
public static IClrTypeName RUNTIME_COMPATIBILITY_ATTRIBUTE;
    [NotNullAttribute]
public static IClrTypeName RUNTIME_HELPERS_FQN;
    [NotNullAttribute]
public static IClrTypeName RUNTIME_FEATURE_FQN;
    [NotNullAttribute]
public static IClrTypeName PRESERVE_BASE_OVERRIDES_ATTRIBTUE_FQN;
    [NotNullAttribute]
public static IClrTypeName INTERPOLATED_STRING_HANDLER_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName COLLECTION_BUILDER_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName INTERPOLATED_STRING_HANDLER_ARGUMENT_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName DEFAULT_INTERPOLATED_STRING_HANDLER_FQN;
    [NotNullAttribute]
public static IClrTypeName REQUIRES_PREVIEW_FEATURES_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName MEMORY_EXTENSIONS_FQN;
    [NotNullAttribute]
public static IClrTypeName TASK_ASYNC_ENUMERABLE_EXTENSIONS_FQN;
    [NotNullAttribute]
public static IClrTypeName COLLECTION_EXTENSIONS_FQN;
    [NotNullAttribute]
public static IClrTypeName STRING_COMPARISON_CLASS;
    [NotNullAttribute]
public static IClrTypeName EVENT_REGISTRATION_TOKEN;
    [NotNullAttribute]
public static IClrTypeName WINRT_ATTRIBUTE_USAGE_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName WINRT_ALLOW_MULTIPLE_ATTRIBUTE_CLASS;
    [NotNullAttribute]
public static IClrTypeName CHAR_FQN;
    [NotNullAttribute]
public static IClrTypeName BOOLEAN_FQN;
    [NotNullAttribute]
public static IClrTypeName DECIMAL_FQN;
    [NotNullAttribute]
public static IClrTypeName FLOAT_FQN;
    [NotNullAttribute]
public static IClrTypeName DOUBLE_FQN;
    [NotNullAttribute]
public static IClrTypeName BYTE_FQN;
    [NotNullAttribute]
public static IClrTypeName SBYTE_FQN;
    [NotNullAttribute]
public static IClrTypeName SHORT_FQN;
    [NotNullAttribute]
public static IClrTypeName USHORT_FQN;
    [NotNullAttribute]
public static IClrTypeName INT_FQN;
    [NotNullAttribute]
public static IClrTypeName UINT_FQN;
    [NotNullAttribute]
public static IClrTypeName LONG_FQN;
    [NotNullAttribute]
public static IClrTypeName ULONG_FQN;
    [NotNullAttribute]
public static IClrTypeName OBJECT_FQN;
    [NotNullAttribute]
public static IClrTypeName STRING_FQN;
    [NotNullAttribute]
public static IClrTypeName DATETIME_FQN;
    [NotNullAttribute]
public static IClrTypeName DATETIMEOFFSET_FQN;
    [NotNullAttribute]
public static IClrTypeName DATE_ONLY_FQN;
    [NotNullAttribute]
public static IClrTypeName TIME_ONLY_FQN;
    [NotNullAttribute]
public static IClrTypeName TIMESPAN_FQN;
    [NotNullAttribute]
public static IClrTypeName CONVERT_FQN;
    [NotNullAttribute]
public static IClrTypeName ICONVERTIBLE_FQN;
    [NotNullAttribute]
public static IClrTypeName IFORMATPROVIDER_FQN;
    [NotNullAttribute]
public static IClrTypeName IFORMATTABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName ISPANFORMATTABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName IUTF8SPANFORMATTABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName UTF8_FQN;
    [NotNullAttribute]
public static IClrTypeName INUMBERBASE_FQN;
    [NotNullAttribute]
public static IClrTypeName GUID_FQN;
    [NotNullAttribute]
public static IClrTypeName TYPE_FQN;
    [NotNullAttribute]
public static IClrTypeName EXCEPTION_FQN;
    [NotNullAttribute]
public static IClrTypeName NOTIMPLEMENTEDEXCEPTION_FQN;
    [NotNullAttribute]
public static IClrTypeName ARGUMENTEXCEPTION_FQN;
    [NotNullAttribute]
public static IClrTypeName ARGUMENTNULLEXCEPTION_FQN;
    [NotNullAttribute]
public static IClrTypeName ARGUMENTOUTOFRANGEEXCEPTION_FQN;
    [NotNullAttribute]
public static IClrTypeName INVALIDOPERATIONEXCEPTION_FQN;
    [NotNullAttribute]
public static IClrTypeName INVALIDENUMARGUMENTEXCEPTION_FQN;
    [NotNullAttribute]
public static IClrTypeName ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName VALUETYPE_FQN;
    [NotNullAttribute]
public static IClrTypeName ENUM_FQN;
    [NotNullAttribute]
public static IClrTypeName DELEGATE_FQN;
    [NotNullAttribute]
public static IClrTypeName ARRAY_FQN;
    [NotNullAttribute]
public static IClrTypeName ICLONEABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName ICOLLECTION_FQN;
    [NotNullAttribute]
public static IClrTypeName ISERIALIZABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName SERIALIZATION_INFO_FQN;
    [NotNullAttribute]
public static IClrTypeName STREAMING_CONTEXT_FQN;
    [NotNullAttribute]
public static IClrTypeName ILIST_FQN;
    [NotNullAttribute]
public static IClrTypeName MULTICAST_DELEGATE_FQN;
    [NotNullAttribute]
public static IClrTypeName IDICTIONARY_FQN;
    [NotNullAttribute]
public static IClrTypeName IDICTIONARY_ENUMERATOR_FQN;
    [NotNullAttribute]
public static IClrTypeName IENUMERABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName IENUMERATOR_FQN;
    [NotNullAttribute]
public static IClrTypeName IORDEREDENUMERABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName PARALLELQUERY_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_PARALLELQUERY_FQN;
    [NotNullAttribute]
public static IClrTypeName ORDEREDPARALLELQUERY_FQN;
    [NotNullAttribute]
public static IClrTypeName IDISPOSABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName INOTIFYPROPERTYCHANGED_FQN;
    [NotNullAttribute]
public static IClrTypeName IQUERYABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName IASYNCRESULT_FQN;
    [NotNullAttribute]
public static IClrTypeName ASYNCCALLBACK;
    [NotNullAttribute]
public static IClrTypeName ACTION_FQN;
    [NotNullAttribute]
public static IClrTypeName INTPTR_FQN;
    [NotNullAttribute]
public static IClrTypeName UINTPTR_FQN;
    [NotNullAttribute]
public static IClrTypeName MARSHAL_BY_REF_OBJECT_FQN;
    [NotNullAttribute]
public static IClrTypeName TASK_FQN;
    [NotNullAttribute]
public static IClrTypeName IASYNCACTION_FQN;
    [NotNullAttribute]
public static IClrTypeName EVENTARGS_FQN;
    [NotNullAttribute]
public static IClrTypeName TUPLE_FQN;
    [NotNullAttribute]
public static IClrTypeName KEY_VALUE_PAIR_FQN;
    [NotNullAttribute]
public static IClrTypeName FUNC_FQN;
    [NotNullAttribute]
public static IClrTypeName FUNC1_FQN;
    [NotNullAttribute]
public static IClrTypeName FUNC2_FQN;
    [NotNullAttribute]
public static IClrTypeName FUNC3_FQN;
    [NotNullAttribute]
public static IClrTypeName NULLABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName ICOMPARABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_NULLABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_ICOLLECTION_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_ILIST_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_QUEUE_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_STACK_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_IREADONLYLIST_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_IREADONLYCOLLECTION_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_IREADONLYDICTIONARY_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_IREADONLYSET_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_LIST_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_DICTIONARY_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_IDICTIONARY_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_IENUMERATOR_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_IENUMERABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_IQUERYABLE_FQN2;
    [NotNullAttribute]
public static IClrTypeName GENERIC_IQUERYABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_IOBSERVABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_IMMUTABLE_ARRAY_FQN;
    [NotNullAttribute]
public static IClrTypeName IMMUTABLE_ARRAY_FQN;
    [NotNullAttribute]
public static IClrTypeName IMMUTABLE_COLLECTIONS_MARSHAL_FQN;
    [NotNullAttribute]
public static IClrTypeName IASYNCDISPOSABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName IASYNCENUMERATOR_FQN;
    [NotNullAttribute]
public static IClrTypeName IASYNCENUMERABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName CONFIGURED_CANCELABLE_ASYNC_ENUMERABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName CONFIGURE_AWAIT_OPTIONS_FQN;
    [NotNullAttribute]
public static IClrTypeName ISET_FQN;
    [NotNullAttribute]
public static IClrTypeName HASHSET_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_TASK_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_VALUE_TASK_FQN;
    [NotNullAttribute]
public static IClrTypeName VALUE_TASK_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_TASK_AWAITER_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_VALUE_TASK_AWAITER_FQN;
    [NotNullAttribute]
public static IClrTypeName YIELD_AWAITABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName CANCELLATION_TOKEN_FQN;
    [NotNullAttribute]
public static IClrTypeName CANCELLATION_TOKEN_SOURCE_FQN;
    [NotNullAttribute]
public static IClrTypeName INTERLOCKED_FQN;
    [NotNullAttribute]
public static IClrTypeName THREAD_FQN;
    [NotNullAttribute]
public static IClrTypeName MONITOR_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_IASYNCOPERATION_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_IEQUATABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName LAZY_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_ICOMPARABLE_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_ICOMPARER_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_EQUALITY_COMPARER_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_IEQUALITY_COMPARER_FQN;
    [NotNullAttribute]
public static IClrTypeName LINQ_EXPRESSION_FQN;
    [NotNullAttribute]
public static IClrTypeName LINQ_GENERIC_EXPRESSION_FQN;
    [NotNullAttribute]
public static IClrTypeName LINQ_LAMBDA_EXPRESSION_FQN;
    [NotNullAttribute]
public static IClrTypeName VOID_FQN;
    [NotNullAttribute]
public static IClrTypeName STRING_BUILDER_FQN;
    [NotNullAttribute]
public static IClrTypeName FORMATTABLE_STRING_FQN;
    [NotNullAttribute]
public static IClrTypeName FORMATTABLE_STRING_FACTORY_FQN;
    [NotNullAttribute]
public static IClrTypeName CALLER_MEMBER_NAME_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName CALLER_FILE_PATH_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName CALLER_LINE_NUMBER_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName CALLER_ARGUMENT_EXPRESSION_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName APIINFORMATION_FQN;
    [NotNullAttribute]
public static IClrTypeName TYPED_REFERENCE_FQN;
    [NotNullAttribute]
public static IClrTypeName ARG_ITERATOR_FQN;
    [NotNullAttribute]
public static IClrTypeName GENERIC_COMPARER_FQN;
    [NotNullAttribute]
public static IClrTypeName ASYNC_METHOD_BUILDER_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName ASYNC_ITERATOR_METHOD_BUILDER_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName CONSOLE_FQN;
    [NotNullAttribute]
public static IClrTypeName ENVIRONMENT_FQN;
    [NotNullAttribute]
public static IClrTypeName ITESTOUTPUTHELPER_FQN;
    [NotNullAttribute]
public static IClrTypeName DEBUG_FQN;
    [NotNullAttribute]
public static IClrTypeName TRACE_FQN;
    [NotNullAttribute]
public static IClrTypeName CONTRACT_FQN;
    [NotNullAttribute]
public static IClrTypeName INOTIFY_COMPLETION_FQN;
    [NotNullAttribute]
public static IClrTypeName IS_READ_ONLY_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName SCOPED_REF_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName UNSCOPED_REF_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName REF_SAFETY_RULES_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName IS_BY_REF_LIKE_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName IS_UNMANAGED_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName NULLABLE_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName NULLABLE_CONTEXT_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName SYSTEM_SPAN_FQN;
    [NotNullAttribute]
public static IClrTypeName SYSTEM_READ_ONLY_SPAN_FQN;
    [NotNullAttribute]
public static IClrTypeName DEPENDENCY_OBJECT_FQN;
    [NotNullAttribute]
public static IClrTypeName AVALONIA_OBJECT_FQN;
    [NotNullAttribute]
public static IClrTypeName SYSTEM_HASH_CODE_FQN;
    [NotNullAttribute]
public static IClrTypeName IS_EXTERNAL_INIT_FQN;
    [NotNullAttribute]
public static IClrTypeName MODULE_INITIALIZER_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName SYSTEM_THREADING_SPINLOCK_FQN;
    [NotNullAttribute]
public static IClrTypeName SYSTEM_THREADING_LOCK_FQN;
    [NotNullAttribute]
public static IClrTypeName SYSTEM_THREADING_LOCK_SCOPE_FQN;
    [NotNullAttribute]
public static IClrTypeName INDEX_FQN;
    [NotNullAttribute]
public static IClrTypeName RANGE_FQN;
    [NotNullAttribute]
public static IClrTypeName NOT_NULL_IF_NOT_NULL_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName DOES_NOT_RETURN_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName DOES_NOT_RETURN_IF_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName NOT_NULL_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName NOT_NULL_WHEN_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName MAYBE_NULL_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName MAYBE_NULL_WHEN_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName DISALLOW_NULL_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName ALLOW_NULL_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName MEMBER_NOT_NULL_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName MEMBER_NOT_NULL_WHEN_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName DYNAMICALLY_ACCESSED_MEMBERS_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName SKIP_LOCALS_INIT_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName TUPLE_ELEMENT_NAMES_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static string VALUETUPLE_FQN_STRING_PREFIX;
    [NotNullAttribute]
public static IClrTypeName VALUE_TUPLE_1_FQN;
    [NotNullAttribute]
public static IClrTypeName VALUE_TUPLE_2_FQN;
    [NotNullAttribute]
public static IClrTypeName VALUE_TUPLE_3_FQN;
    [NotNullAttribute]
public static IClrTypeName VALUE_TUPLE_4_FQN;
    [NotNullAttribute]
public static IClrTypeName VALUE_TUPLE_5_FQN;
    [NotNullAttribute]
public static IClrTypeName VALUE_TUPLE_6_FQN;
    [NotNullAttribute]
public static IClrTypeName VALUE_TUPLE_7_FQN;
    [NotNullAttribute]
public static IClrTypeName VALUE_TUPLE_8_FQN;
    [NotNullAttribute]
public static IClrTypeName ITUPLE_FQN;
    [NotNullAttribute]
public static IClrTypeName REQUIRED_MEMBER_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName SETS_REQUIRED_MEMBERS_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName COMPILER_FEATURE_REQUIRED_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName INLINE_ARRAY_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName INTERCEPTS_LOCATION_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName UNMANAGED_CALLERS_ONLY_ATTRIBUTE_FQN;
    [NotNullAttribute]
public static IClrTypeName ENTITY_FRAMEWORK_CORE_DB_CONTEXT_FQN;
    [NotNullAttribute]
public static IClrTypeName ENTITY_FRAMEWORK_CORE_DB_SET_FQN;
    public static int VALUE_TUPLE_MAX_TYPE_PARAMETERS_COUNT;
    [NotNullAttribute]
public IPsiModule Module { get; }
    private bool RuntimeSupportsNumericIntPtr { get; }
    [NotNullAttribute]
public IDeclaredType String { get; }
    [NotNullAttribute]
public IDeclaredType Object { get; }
    [NotNullAttribute]
public IDeclaredType Bool { get; }
    [NotNullAttribute]
public IDeclaredType Decimal { get; }
    [NotNullAttribute]
public IDeclaredType Sbyte { get; }
    [NotNullAttribute]
public IDeclaredType Byte { get; }
    [NotNullAttribute]
public IDeclaredType Short { get; }
    [NotNullAttribute]
public IDeclaredType Ushort { get; }
    [NotNullAttribute]
public IDeclaredType Int { get; }
    [NotNullAttribute]
public IDeclaredType Uint { get; }
    [NotNullAttribute]
public IDeclaredType Long { get; }
    [NotNullAttribute]
public IDeclaredType Ulong { get; }
    [NotNullAttribute]
public IDeclaredType Char { get; }
    [NotNullAttribute]
public IDeclaredType Float { get; }
    [NotNullAttribute]
public IDeclaredType Double { get; }
    [NotNullAttribute]
public IDeclaredType Guid { get; }
    [NotNullAttribute]
public IDeclaredType Attribute { get; }
    [NotNullAttribute]
public IDeclaredType Delegate { get; }
    [NotNullAttribute]
public IDeclaredType MulticastDelegate { get; }
    [NotNullAttribute]
public IDeclaredType IDictionary { get; }
    [NotNullAttribute]
public IDeclaredType IDictionaryEnumerator { get; }
    [NotNullAttribute]
public IDeclaredType IEnumerable { get; }
    [NotNullAttribute]
public IDeclaredType IEnumerator { get; }
    [NotNullAttribute]
public IDeclaredType Array { get; }
    [NotNullAttribute]
public IDeclaredType ICloneable { get; }
    [NotNullAttribute]
public IDeclaredType ICollection { get; }
    [NotNullAttribute]
public IDeclaredType ISerializable { get; }
    [NotNullAttribute]
public IDeclaredType SerializationInfo { get; }
    [NotNullAttribute]
public IDeclaredType StreamingContext { get; }
    [NotNullAttribute]
public IDeclaredType StringBuilder { get; }
    [NotNullAttribute]
public IDeclaredType IList { get; }
    [NotNullAttribute]
public IDeclaredType IDisposable { get; }
    [NotNullAttribute]
public IDeclaredType INotifyPropertyChanged { get; }
    [NotNullAttribute]
public IDeclaredType IQueryable { get; }
    [NotNullAttribute]
public IDeclaredType IAsyncResult { get; }
    [NotNullAttribute]
public IDeclaredType AsyncCallback { get; }
    [NotNullAttribute]
public IDeclaredType Action { get; }
    [NotNullAttribute]
public IDeclaredType Func1 { get; }
    [NotNullAttribute]
public IDeclaredType Func2 { get; }
    [NotNullAttribute]
public IDeclaredType Func3 { get; }
    [NotNullAttribute]
public IDeclaredType Tuple { get; }
    [NotNullAttribute]
public IDeclaredType KeyValuePair { get; }
    [NotNullAttribute]
public IDeclaredType IAsyncAction { get; }
    [NotNullAttribute]
public IDeclaredType EventArgs { get; }
    [NotNullAttribute]
public IDeclaredType IComparable { get; }
    [NotNullAttribute]
public IDeclaredType ParallelQuery { get; }
    [NotNullAttribute]
public IDeclaredType IOrderedEnumerable { get; }
    [NotNullAttribute]
public IDeclaredType GenericParallelQuery { get; }
    [NotNullAttribute]
public IDeclaredType OrderedParallelQuery { get; }
    [NotNullAttribute]
public IDeclaredType IAsyncDisposable { get; }
    [NotNullAttribute]
public IDeclaredType IAsyncEnumerator { get; }
    [NotNullAttribute]
public IDeclaredType IAsyncEnumerable { get; }
    [NotNullAttribute]
public IDeclaredType ConfiguredCancelableAsyncEnumerable { get; }
    [NotNullAttribute]
public IDeclaredType ConfigureAwaitOptions { get; }
    [NotNullAttribute]
public IDeclaredType IntPtr { get; }
    [NotNullAttribute]
public IDeclaredType UIntPtr { get; }
    [NotNullAttribute]
public IDeclaredType DateTime { get; }
    [NotNullAttribute]
public IDeclaredType DateTimeOffset { get; }
    [NotNullAttribute]
public IDeclaredType TimeSpan { get; }
    [NotNullAttribute]
public IDeclaredType Enum { get; }
    [NotNullAttribute]
public IDeclaredType ValueType { get; }
    [NotNullAttribute]
public IDeclaredType Type { get; }
    [NotNullAttribute]
public IDeclaredType Convert { get; }
    [NotNullAttribute]
public IDeclaredType IConvertible { get; }
    [NotNullAttribute]
public IDeclaredType IFormatProvider { get; }
    [NotNullAttribute]
public IDeclaredType IFormattable { get; }
    [NotNullAttribute]
public IDeclaredType ISpanFormattable { get; }
    [NotNullAttribute]
public IDeclaredType IUtf8SpanFormattable { get; }
    [NotNullAttribute]
public IDeclaredType Utf8 { get; }
    [NotNullAttribute]
public IDeclaredType INumberBase { get; }
    [NotNullAttribute]
public IDeclaredType Exception { get; }
    [NotNullAttribute]
public IDeclaredType MarshalByRefObject { get; }
    [NotNullAttribute]
public IDeclaredType NotImplementedException { get; }
    [NotNullAttribute]
public IDeclaredType ArgumentException { get; }
    [NotNullAttribute]
public IDeclaredType ArgumentNullException { get; }
    [NotNullAttribute]
public IDeclaredType ArgumentOutOfRangeException { get; }
    [NotNullAttribute]
public IDeclaredType InvalidOperationException { get; }
    [NotNullAttribute]
public IDeclaredType InvalidEnumArgumentException { get; }
    [NotNullAttribute]
public IDeclaredType Void { get; }
    [NotNullAttribute]
public IPointerType VoidPointer { get; }
    [NotNullAttribute]
public IDeclaredType GenericIDictionary { get; }
    [NotNullAttribute]
public IDeclaredType GenericIEnumerable { get; }
    [NotNullAttribute]
public IDeclaredType GenericISet { get; }
    [NotNullAttribute]
public IDeclaredType GenericHashSet { get; }
    [NotNullAttribute]
public IDeclaredType GenericIQueryable { get; }
    [NotNullAttribute]
public IDeclaredType GenericIQueryable2 { get; }
    [NotNullAttribute]
public IDeclaredType GenericIEnumerator { get; }
    [NotNullAttribute]
public IDeclaredType GenericICollection { get; }
    [NotNullAttribute]
public IDeclaredType GenericIList { get; }
    [NotNullAttribute]
public IDeclaredType GenericIReadOnlyList { get; }
    [NotNullAttribute]
public IDeclaredType GenericIReadOnlyCollection { get; }
    [NotNullAttribute]
public IDeclaredType GenericIReadOnlyDictionary { get; }
    [NotNullAttribute]
public IDeclaredType GenericIReadOnlySet { get; }
    [NotNullAttribute]
public IDeclaredType GenericList { get; }
    [NotNullAttribute]
public IDeclaredType GenericDictionary { get; }
    [NotNullAttribute]
public IDeclaredType GenericIAsyncOperation { get; }
    [NotNullAttribute]
public IDeclaredType GenericIEquatable { get; }
    [NotNullAttribute]
public IDeclaredType GenericIComparable { get; }
    [NotNullAttribute]
public IDeclaredType GenericIComparer { get; }
    [NotNullAttribute]
public IDeclaredType GenericEqualityComparer { get; }
    [NotNullAttribute]
public IDeclaredType GenericIEqualityComparer { get; }
    [NotNullAttribute]
public IDeclaredType GenericIObservable { get; }
    [NotNullAttribute]
public IDeclaredType GenericImmutableArray { get; }
    [NotNullAttribute]
public IDeclaredType ImmutableArray { get; }
    [NotNullAttribute]
public IDeclaredType ImmutableCollectionsMarshal { get; }
    [NotNullAttribute]
public IDeclaredType GenericStack { get; }
    [NotNullAttribute]
public IDeclaredType GenericQueue { get; }
    [NotNullAttribute]
public IDeclaredType Task { get; }
    [NotNullAttribute]
public IDeclaredType GenericTask { get; }
    [NotNullAttribute]
public IDeclaredType ValueTask { get; }
    [NotNullAttribute]
public IDeclaredType GenericValueTask { get; }
    [NotNullAttribute]
public IDeclaredType YieldAwaitable { get; }
    [NotNullAttribute]
public IDeclaredType Lazy { get; }
    [NotNullAttribute]
public IDeclaredType CancellationToken { get; }
    [NotNullAttribute]
public IDeclaredType CancellationTokenSource { get; }
    [NotNullAttribute]
public IDeclaredType Interlocked { get; }
    [NotNullAttribute]
public IDeclaredType LinqNonGenericExpression { get; }
    [NotNullAttribute]
public IDeclaredType LinqGenericExpression { get; }
    [NotNullAttribute]
public IDeclaredType GenericNullable { get; }
    [NotNullAttribute]
public IDeclaredType ExtensionAttribute { get; }
    [NotNullAttribute]
public IDeclaredType DefaultMemberAttribute { get; }
    [NotNullAttribute]
public IDeclaredType IndexerNameAttribute { get; }
    [NotNullAttribute]
public IDeclaredType DebuggerStepThroughAttribute { get; }
    [NotNullAttribute]
public IDeclaredType OutAttribute { get; }
    [NotNullAttribute]
public IDeclaredType OptionalAttribute { get; }
    [NotNullAttribute]
public IDeclaredType RuntimeArgumentHandle { get; }
    [NotNullAttribute]
public IDeclaredType TypedReference { get; }
    [NotNullAttribute]
public IDeclaredType FixedBufferAttribute { get; }
    [NotNullAttribute]
public IDeclaredType ThreadStaticAttribute { get; }
    [NotNullAttribute]
public IDeclaredType Enumerable { get; }
    [NotNullAttribute]
public IDeclaredType AsyncEnumerable { get; }
    [NotNullAttribute]
public IDeclaredType ISet { get; }
    [NotNullAttribute]
public IDeclaredType Stream { get; }
    [NotNullAttribute]
public IDeclaredType RuntimeHelpers { get; }
    [NotNullAttribute]
public IDeclaredType IsExternalInit { get; }
    [NotNullAttribute]
public IDeclaredType StringComparison { get; }
    [NotNullAttribute]
public IDeclaredType FormattableString { get; }
    [NotNullAttribute]
public IDeclaredType FormattableStringFactory { get; }
    [NotNullAttribute]
public IDeclaredType DynamicObject { get; }
    [NotNullAttribute]
public IDeclaredType ApiInformation { get; }
    [NotNullAttribute]
public IDeclaredType Debug { get; }
    [NotNullAttribute]
public IDeclaredType Console { get; }
    [NotNullAttribute]
public IDeclaredType Environment { get; }
    [NotNullAttribute]
public IDeclaredType ITestOutputHelper { get; }
    [NotNullAttribute]
public IDeclaredType Trace { get; }
    [NotNullAttribute]
public IDeclaredType Contract { get; }
    [NotNullAttribute]
public IDeclaredType INotifyCompletion { get; }
    [NotNullAttribute]
public IDeclaredType Span { get; }
    [NotNullAttribute]
public IDeclaredType ReadOnlySpan { get; }
    [NotNullAttribute]
public IDeclaredType ReadOnlySpanOfByte { get; }
    [NotNullAttribute]
public IDeclaredType DependencyObject { get; }
    [NotNullAttribute]
public IDeclaredType AvaloniaObject { get; }
    [NotNullAttribute]
public IDeclaredType SpinLock { get; }
    [NotNullAttribute]
public IDeclaredType ValueTuple1 { get; }
    [NotNullAttribute]
public IDeclaredType ValueTuple2 { get; }
    [NotNullAttribute]
public IDeclaredType ValueTuple3 { get; }
    [NotNullAttribute]
public IDeclaredType ValueTuple4 { get; }
    [NotNullAttribute]
public IDeclaredType ValueTuple5 { get; }
    [NotNullAttribute]
public IDeclaredType ValueTuple6 { get; }
    [NotNullAttribute]
public IDeclaredType ValueTuple7 { get; }
    [NotNullAttribute]
public IDeclaredType ValueTuple8 { get; }
    [NotNullAttribute]
public IDeclaredType Index { get; }
    [NotNullAttribute]
public IDeclaredType Range { get; }
    [NotNullAttribute]
public IDeclaredType NotNullIfNotNullAttribute { get; }
    [NotNullAttribute]
public IDeclaredType DoesNotReturnAttribute { get; }
    [NotNullAttribute]
public IDeclaredType DoesNotReturnIfAttribute { get; }
    [NotNullAttribute]
public IDeclaredType NotNullAttribute { get; }
    [NotNullAttribute]
public IDeclaredType NotNullWhenAttribute { get; }
    [NotNullAttribute]
public IDeclaredType MaybeNullAttribute { get; }
    [NotNullAttribute]
public IDeclaredType MaybeNullWhenAttribute { get; }
    [NotNullAttribute]
public IDeclaredType DisallowNullAttribute { get; }
    [NotNullAttribute]
public IDeclaredType AllowNullAttribute { get; }
    [NotNullAttribute]
public IDeclaredType MemberNotNullAttribute { get; }
    [NotNullAttribute]
public IDeclaredType MemberNotNullWhenAttribute { get; }
    [NotNullAttribute]
public IDeclaredType NativeInteger { get; }
    [NotNullAttribute]
public IDeclaredType NativeUnsignedInteger { get; }
    [NotNullAttribute]
public IDeclaredType RuntimeFeature { get; }
    [NotNullAttribute]
public IDeclaredType PreserveBaseOverridesAttribute { get; }
    [NotNullAttribute]
public IDeclaredType InterpolatedStringHandlerAttribute { get; }
    [NotNullAttribute]
public IDeclaredType DefaultInterpolatedStringHandler { get; }
    [NotNullAttribute]
public IDeclaredType MemoryExtensions { get; }
    [NotNullAttribute]
public IDeclaredType TaskAsyncEnumerableExtensions { get; }
    [NotNullAttribute]
public IDeclaredType CollectionExtensions { get; }
    [NotNullAttribute]
public IDeclaredType UnscopedRefAttribute { get; }
    [NotNullAttribute]
public IDeclaredType ScopedRefAttribute { get; }
    [NotNullAttribute]
public IDeclaredType RequiredMemberAttribute { get; }
    [NotNullAttribute]
public IDeclaredType SetsRequiredMembersAttribute { get; }
    [NotNullAttribute]
public IDeclaredType CompilerFeatureRequiredAttribute { get; }
    [NotNullAttribute]
public IDeclaredType InlineArrayAttribute { get; }
    [NotNullAttribute]
public IDeclaredType InterceptsLocationAttribute { get; }
    [NotNullAttribute]
public IDeclaredType ExperimentalAttribute { get; }
    [NotNullAttribute]
public IDeclaredType EntityFrameworkCoreDbContext { get; }
    [NotNullAttribute]
public IDeclaredType EntityFrameworkCoreDbSet { get; }
    [NotNullAttribute]
public IDeclaredType Lock { get; }
    [NotNullAttribute]
public IDeclaredType ITuple { get; }
    private static PredefinedType();
    internal PredefinedType(IPsiModule module);
    public IPsiModule get_Module();
    private bool get_RuntimeSupportsNumericIntPtr();
    public IDeclaredType get_String();
    public IDeclaredType get_Object();
    public IDeclaredType get_Bool();
    public IDeclaredType get_Decimal();
    public IDeclaredType get_Sbyte();
    public IDeclaredType get_Byte();
    public IDeclaredType get_Short();
    public IDeclaredType get_Ushort();
    public IDeclaredType get_Int();
    public IDeclaredType get_Uint();
    public IDeclaredType get_Long();
    public IDeclaredType get_Ulong();
    public IDeclaredType get_Char();
    public IDeclaredType get_Float();
    public IDeclaredType get_Double();
    public IDeclaredType get_Guid();
    public IDeclaredType get_Attribute();
    public IDeclaredType get_Delegate();
    public IDeclaredType get_MulticastDelegate();
    public IDeclaredType get_IDictionary();
    public IDeclaredType get_IDictionaryEnumerator();
    public IDeclaredType get_IEnumerable();
    public IDeclaredType get_IEnumerator();
    public IDeclaredType get_Array();
    public IDeclaredType get_ICloneable();
    public IDeclaredType get_ICollection();
    public IDeclaredType get_ISerializable();
    public IDeclaredType get_SerializationInfo();
    public IDeclaredType get_StreamingContext();
    public IDeclaredType get_StringBuilder();
    public IDeclaredType get_IList();
    public IDeclaredType get_IDisposable();
    public IDeclaredType get_INotifyPropertyChanged();
    public IDeclaredType get_IQueryable();
    public IDeclaredType get_IAsyncResult();
    public IDeclaredType get_AsyncCallback();
    public IDeclaredType get_Action();
    public IDeclaredType get_Func1();
    public IDeclaredType get_Func2();
    public IDeclaredType get_Func3();
    public IDeclaredType get_Tuple();
    public IDeclaredType get_KeyValuePair();
    public IDeclaredType get_IAsyncAction();
    public IDeclaredType get_EventArgs();
    public IDeclaredType get_IComparable();
    public IDeclaredType get_ParallelQuery();
    public IDeclaredType get_IOrderedEnumerable();
    public IDeclaredType get_GenericParallelQuery();
    public IDeclaredType get_OrderedParallelQuery();
    public IDeclaredType get_IAsyncDisposable();
    public IDeclaredType get_IAsyncEnumerator();
    public IDeclaredType get_IAsyncEnumerable();
    public IDeclaredType get_ConfiguredCancelableAsyncEnumerable();
    public IDeclaredType get_ConfigureAwaitOptions();
    public IDeclaredType get_IntPtr();
    public IDeclaredType get_UIntPtr();
    public IDeclaredType get_DateTime();
    public IDeclaredType get_DateTimeOffset();
    public IDeclaredType get_TimeSpan();
    public IDeclaredType get_Enum();
    public IDeclaredType get_ValueType();
    public IDeclaredType get_Type();
    public IDeclaredType get_Convert();
    public IDeclaredType get_IConvertible();
    public IDeclaredType get_IFormatProvider();
    public IDeclaredType get_IFormattable();
    public IDeclaredType get_ISpanFormattable();
    public IDeclaredType get_IUtf8SpanFormattable();
    public IDeclaredType get_Utf8();
    public IDeclaredType get_INumberBase();
    public IDeclaredType get_Exception();
    public IDeclaredType get_MarshalByRefObject();
    public IDeclaredType get_NotImplementedException();
    public IDeclaredType get_ArgumentException();
    public IDeclaredType get_ArgumentNullException();
    public IDeclaredType get_ArgumentOutOfRangeException();
    public IDeclaredType get_InvalidOperationException();
    public IDeclaredType get_InvalidEnumArgumentException();
    public IDeclaredType get_Void();
    public IPointerType get_VoidPointer();
    public IDeclaredType get_GenericIDictionary();
    public IDeclaredType get_GenericIEnumerable();
    public IDeclaredType get_GenericISet();
    public IDeclaredType get_GenericHashSet();
    public IDeclaredType get_GenericIQueryable();
    public IDeclaredType get_GenericIQueryable2();
    public IDeclaredType get_GenericIEnumerator();
    public IDeclaredType get_GenericICollection();
    public IDeclaredType get_GenericIList();
    public IDeclaredType get_GenericIReadOnlyList();
    public IDeclaredType get_GenericIReadOnlyCollection();
    public IDeclaredType get_GenericIReadOnlyDictionary();
    public IDeclaredType get_GenericIReadOnlySet();
    public IDeclaredType get_GenericList();
    public IDeclaredType get_GenericDictionary();
    public IDeclaredType get_GenericIAsyncOperation();
    public IDeclaredType get_GenericIEquatable();
    public IDeclaredType get_GenericIComparable();
    public IDeclaredType get_GenericIComparer();
    public IDeclaredType get_GenericEqualityComparer();
    public IDeclaredType get_GenericIEqualityComparer();
    public IDeclaredType get_GenericIObservable();
    public IDeclaredType get_GenericImmutableArray();
    public IDeclaredType get_ImmutableArray();
    public IDeclaredType get_ImmutableCollectionsMarshal();
    public IDeclaredType get_GenericStack();
    public IDeclaredType get_GenericQueue();
    public IDeclaredType get_Task();
    public IDeclaredType get_GenericTask();
    public IDeclaredType get_ValueTask();
    public IDeclaredType get_GenericValueTask();
    public IDeclaredType get_YieldAwaitable();
    public IDeclaredType get_Lazy();
    public IDeclaredType get_CancellationToken();
    public IDeclaredType get_CancellationTokenSource();
    public IDeclaredType get_Interlocked();
    public IDeclaredType get_LinqNonGenericExpression();
    public IDeclaredType get_LinqGenericExpression();
    public IDeclaredType get_GenericNullable();
    public IDeclaredType get_ExtensionAttribute();
    public IDeclaredType get_DefaultMemberAttribute();
    public IDeclaredType get_IndexerNameAttribute();
    public IDeclaredType get_DebuggerStepThroughAttribute();
    public IDeclaredType get_OutAttribute();
    public IDeclaredType get_OptionalAttribute();
    public IDeclaredType get_RuntimeArgumentHandle();
    public IDeclaredType get_TypedReference();
    public IDeclaredType get_FixedBufferAttribute();
    public IDeclaredType get_ThreadStaticAttribute();
    public IDeclaredType get_Enumerable();
    public IDeclaredType get_AsyncEnumerable();
    public IDeclaredType get_ISet();
    public IDeclaredType get_Stream();
    public IDeclaredType get_RuntimeHelpers();
    public IDeclaredType get_IsExternalInit();
    public IDeclaredType get_StringComparison();
    public IDeclaredType get_FormattableString();
    public IDeclaredType get_FormattableStringFactory();
    public IDeclaredType get_DynamicObject();
    public IDeclaredType get_ApiInformation();
    public IDeclaredType get_Debug();
    public IDeclaredType get_Console();
    public IDeclaredType get_Environment();
    public IDeclaredType get_ITestOutputHelper();
    public IDeclaredType get_Trace();
    public IDeclaredType get_Contract();
    public IDeclaredType get_INotifyCompletion();
    public IDeclaredType get_Span();
    public IDeclaredType get_ReadOnlySpan();
    public IDeclaredType get_ReadOnlySpanOfByte();
    public IDeclaredType get_DependencyObject();
    public IDeclaredType get_AvaloniaObject();
    public IDeclaredType get_SpinLock();
    public IDeclaredType get_ValueTuple1();
    public IDeclaredType get_ValueTuple2();
    public IDeclaredType get_ValueTuple3();
    public IDeclaredType get_ValueTuple4();
    public IDeclaredType get_ValueTuple5();
    public IDeclaredType get_ValueTuple6();
    public IDeclaredType get_ValueTuple7();
    public IDeclaredType get_ValueTuple8();
    public IDeclaredType get_Index();
    public IDeclaredType get_Range();
    public IDeclaredType get_NotNullIfNotNullAttribute();
    public IDeclaredType get_DoesNotReturnAttribute();
    public IDeclaredType get_DoesNotReturnIfAttribute();
    public IDeclaredType get_NotNullAttribute();
    public IDeclaredType get_NotNullWhenAttribute();
    public IDeclaredType get_MaybeNullAttribute();
    public IDeclaredType get_MaybeNullWhenAttribute();
    public IDeclaredType get_DisallowNullAttribute();
    public IDeclaredType get_AllowNullAttribute();
    public IDeclaredType get_MemberNotNullAttribute();
    public IDeclaredType get_MemberNotNullWhenAttribute();
    public IDeclaredType get_NativeInteger();
    public IDeclaredType get_NativeUnsignedInteger();
    public IDeclaredType get_RuntimeFeature();
    public IDeclaredType get_PreserveBaseOverridesAttribute();
    public IDeclaredType get_InterpolatedStringHandlerAttribute();
    public IDeclaredType get_DefaultInterpolatedStringHandler();
    public IDeclaredType get_MemoryExtensions();
    public IDeclaredType get_TaskAsyncEnumerableExtensions();
    public IDeclaredType get_CollectionExtensions();
    public IDeclaredType get_UnscopedRefAttribute();
    public IDeclaredType get_ScopedRefAttribute();
    public IDeclaredType get_RequiredMemberAttribute();
    public IDeclaredType get_SetsRequiredMembersAttribute();
    public IDeclaredType get_CompilerFeatureRequiredAttribute();
    public IDeclaredType get_InlineArrayAttribute();
    public IDeclaredType get_InterceptsLocationAttribute();
    public IDeclaredType get_ExperimentalAttribute();
    public IDeclaredType get_EntityFrameworkCoreDbContext();
    public IDeclaredType get_EntityFrameworkCoreDbSet();
    public IDeclaredType get_Lock();
    public IDeclaredType get_ITuple();
    [NotNullAttribute]
[PureAttribute]
public IDeclaredType GetValueTupleType(int numberOfTypeParameters);
    [PureAttribute]
public static bool CanHasUserDefinedOperators(IType type);
    [PureAttribute]
public static bool IsPredefinedType(IClrTypeName clrName);
    [PureAttribute]
public bool IsPredefinedNumeric(IClrTypeName clrName);
    [PureAttribute]
public bool IsPredefinedIntegral(IClrTypeName clrName);
    [PureAttribute]
public bool IsPredefinedIntegralNumeric(IClrTypeName clrName);
    [PureAttribute]
public bool IsSimplePredefined(IClrTypeName clrName);
    [PureAttribute]
public static bool IsPredefinedTuple(IClrTypeName clrName);
    public static bool TryGetPredefinedTypeClassification(IClrTypeName clrName, TypeClassification& typeClassification);
    [PureAttribute]
[NotNullAttribute]
public IEnumerable`1<IDeclaredType> GetSimplePredefinedTypes();
    [CanBeNullAttribute]
public IDeclaredType TryGetType(IClrTypeName clrTypeName, NullableAnnotation annotation);
    [NotNullAttribute]
private IDeclaredType CreateType(int index, IClrTypeName clrName, NullableAnnotation annotation);
    [NotNullAttribute]
private IDeclaredType GetOrCreateDynamicType();
    [NotNullAttribute]
private IDeclaredType GetOrCreateNativeIntegerType();
    [NotNullAttribute]
private IDeclaredType GetOrCreateNativeUnsignedIntegerType();
    [NotNullAttribute]
private IDeclaredType CreateReadOnlySpanOfByteType();
    [NotNullAttribute]
[PureAttribute]
public PredefinedColorTypes GetColorTypes();
    [NotNullAttribute]
[PureAttribute]
private IDeclaredType CreateType(IClrTypeName clrName);
    [CanBeNullAttribute]
[PureAttribute]
public ITypeElement TryFindStandardDelegateType(int parametersCount, bool hasReturnValue);
    [CanBeNullAttribute]
[PureAttribute]
public static ITypeElement TryCalculateStandardDelegateType(IPsiModule psiModule, int parametersCount, bool hasReturnValue);
    [CompilerGeneratedAttribute]
private IDeclaredType <GetSimplePredefinedTypes>b__711_0(IClrTypeName clrTypeName);
    [CompilerGeneratedAttribute]
private IDeclaredType <GetSimplePredefinedTypes>b__711_1(IClrTypeName clrTypeName);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.PredefinedTypeExtensions : object {
    [NotNullAttribute]
private static Key`1<PredefinedTypeCache> PredefinedTypeCacheKey;
    private static PredefinedTypeExtensions();
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsVoid(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsObject(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSystemValueType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSystemEnum(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsString(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsBool(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsDecimal(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSbyte(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsByte(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsShort(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsUshort(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsInt(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsUint(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsLong(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsUlong(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsChar(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsFloat(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsDouble(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsFloatOrDouble(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsDateTime(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsDateTimeOffset(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsTimeSpan(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsGuid(IType type);
    [ExtensionAttribute]
[ObsoleteAttribute("Use .IsSystemType() instead for clarity")]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSystemType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSystemDelegate(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSystemMulticastDelegate(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullable(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsArray(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsGenericList(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsIList(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsGenericIList(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsGenericIReadOnlyList(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsGenericIReadOnlyCollection(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsIEnumerable(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsIEnumerator(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsICollection(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsGenericICollection(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsIEquatable(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableBool(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableDecimal(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableSbyte(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableByte(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableShort(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableInt(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableUint(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableLong(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableUlong(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableChar(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableFloat(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableDouble(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableDateTime(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableTimeSpan(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsGenericIEnumerable(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsGenericIEnumerator(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsIAsyncEnumerable(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsIAsyncEnumerator(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsAction(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsTask(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsGenericTask(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsValueTask(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsYieldAwaitable(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsGenericValueTask(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsGenericTaskAwaiter(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsGenericValueTaskAwaiter(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsConfigureAwaitOptions(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsLinqGenericExpression(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsLinqNonGenericExpression(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsLinqLambdaExpression(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsGenericOrNonGenericLinqExpression(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsGenericOrNonGenericLinqExpressionOrLambdaExpression(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsIFormatProvider(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsInterlocked(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsThread(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsLazy(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSpan(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsReadOnlySpan(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsRuntimeArgumentHandle(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsRuntimeFieldHandle(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsRuntimeMethodHandle(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsRuntimeTypeHandle(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsArgIterator(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsTypedReference(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsUIntPtr(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsIntPtr(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSpinLock(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsICloneable(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsISerializable(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsThread(ITypeElement typeElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsGenericIOrderedEnumerable(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSystemIndex(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSystemRange(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsIReadOnlyDictionary(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsIDictionary(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsPredefinedNumeric(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsPredefinedNumericOrNativeNumeric(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsPredefinedIntegral(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsPredefinedIntegralNumeric(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSimplePredefined(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSystemTuple(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSystemThreadingLock(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSpanOrReadOnlySpan(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("=> false, spanTypeArgument: null; => true, spanTypeArgument: notnull")]
public static bool IsSpanOrReadOnlySpan(IType type, IType& spanTypeArgument);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("=> false, spanTypeArgument: null; => true, spanTypeArgument: notnull")]
public static bool IsSpan(IType type, IType& spanTypeArgument);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("=> false, spanTypeArgument: null; => true, spanTypeArgument: notnull")]
public static bool IsReadOnlySpan(IType type, IType& spanTypeArgument);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("=> false, taskTypeArgument: null; => true, taskTypeArgument: notnull")]
public static bool IsGenericTask(IType type, IType& taskTypeArgument);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("=> false, arrayTypeArgument: null; => true, arrayTypeArgument: notnull")]
public static bool IsGenericImmutableArray(IType type, IType& arrayTypeArgument);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("=> false, listTypeArgument: null; => true, listTypeArgument: notnull")]
public static bool IsGenericList(IType type, IType& listTypeArgument);
    [ExtensionAttribute]
public static bool IsArrayInterface(IType targetType, IType& elementType);
    [PureAttribute]
[ContractAnnotationAttribute("type:null => false")]
private static bool IsPredefinedType(IType type, IClrTypeName clrName);
    [PureAttribute]
[ContractAnnotationAttribute("typeElement:null => false")]
private static bool IsPredefinedTypeElement(ITypeElement typeElement, IClrTypeName clrName);
    [ExtensionAttribute]
[CodeTemplateAttribute("$expr{Expression,'JetBrains.ReSharper.Psi.Tree.ITreeNode'}$.GetPsiModule().GetPredefinedType()")]
[PureAttribute]
[NotNullAttribute]
public static PredefinedType GetPredefinedType(IPsiModule module);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static PredefinedType GetPredefinedType(ITreeNode context);
    [ExtensionAttribute]
[NotNullAttribute]
public static TTypeMember GetPredefinedMember(ITreeNode context, Func`2<PredefinedType, IDeclaredType> getDeclaredType, string name);
    [ExtensionAttribute]
public static bool IsCompilerSpecialType(IType type);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.PreProcessingDirective : ValueType {
    private int myHashCode;
    public static string Defined;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [NotNullAttribute]
public static WriteDelegate`1<PreProcessingDirective> WriteDelegate;
    [NotNullAttribute]
public string Name { get; }
    [NotNullAttribute]
public string Value { get; }
    public PreProcessingDirective(string name, string value);
    private static PreProcessingDirective();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Value();
    public static PreProcessingDirective Read(UnsafeReader reader);
    public static void Write(UnsafeWriter writer, PreProcessingDirective value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(PreProcessingDirective d1, PreProcessingDirective d2);
    public static bool op_Inequality(PreProcessingDirective d1, PreProcessingDirective d2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.PreProcessingDirectivesInFile : object {
    public String[] UsedNames;
    public String[] PossibleDefinedNames;
    public PreProcessingDirectivesInFile(String[] usedNames, String[] localDefinedNames);
}
public abstract class JetBrains.ReSharper.Psi.ProjectFileLanguageService : object {
    [CompilerGeneratedAttribute]
private ProjectFileType <LanguageType>k__BackingField;
    [NotNullAttribute]
protected PsiLanguageType PsiLanguageType { get; }
    public IconId Icon { get; }
    public ProjectFileType LanguageType { get; }
    protected ProjectFileLanguageService(ProjectFileType projectFileType);
    protected abstract virtual PsiLanguageType get_PsiLanguageType();
    public abstract virtual IconId get_Icon();
    [CompilerGeneratedAttribute]
public sealed virtual ProjectFileType get_LanguageType();
    public virtual PsiLanguageType GetPsiLanguageType(IProjectFile projectFile);
    public virtual PsiLanguageType GetPsiLanguageType(IPsiSourceFile sourceFile);
    public virtual IPsiSourceFileProperties GetPsiProperties(IProjectFile projectFile, IPsiSourceFile sourceFile, IsCompileService isCompileService);
    public virtual PsiLanguageType GetPsiLanguageType(ProjectFileType languageType);
    public abstract virtual ILexerFactory GetMixedLexerFactory(ISolution solution, IBuffer buffer, IPsiSourceFile sourceFile);
    public virtual PreProcessingDirective[] GetPreprocessorDefines(IProject project, TargetFrameworkId targetFrameworkId);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ProjectFileLanguageServiceExtensions : object {
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertProjectFileType(IProjectFileLanguageService projectFileLanguageService, ProjectFileType projectFileType);
    [ExtensionAttribute]
[NotNullAttribute]
public static PsiLanguageType GetPsiLanguageType(IProjectFileLanguageService projectFileLanguageService);
}
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.ProjectFileLanguageServiceFilter : object {
    private IProjectFileTypeServices myServices;
    public ProjectFileLanguageServiceFilter(IProjectFileTypeServices services);
    public sealed virtual bool Supports(ProjectFileType fileType);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.PropertyExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsReadable(IProperty property, IAccessContext accessContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsWritable(IProperty property, IAccessContext accessContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsWritableOrCanBeInitialized(IProperty property, IAccessContext accessContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsWritableOrReturnsWriteableRef(IProperty property);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsWritableOrReturnsWriteableRef(IProperty property, IAccessContext accessContext, bool allowInitOnly);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IAccessor GetPolymorphicGetter(IProperty property);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IAccessor GetPolymorphicSetter(IProperty property);
    [CanBeNullAttribute]
[PureAttribute]
private static IAccessor FindAccessorInSuperMembers(IProperty property, AccessorKind kind);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.PsiAssemblyExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IAssembly ToAssembly(IPsiAssembly assembly);
    [ExtensionAttribute]
public static bool PossiblyContainsPredefinedTypes(IPsiAssembly assembly);
}
public enum JetBrains.ReSharper.Psi.PsiChangedElementType : Enum {
    public int value__;
    public static PsiChangedElementType CompiledContentsChanged;
    public static PsiChangedElementType SourceContentsChanged;
    public static PsiChangedElementType Whitespaces;
    public static PsiChangedElementType InvalidateCached;
    public static PsiChangedElementType TemporaryChangedBeforeSecondaryPsiGeneration;
    public static PsiChangedElementType RestoredAfterSecondaryPsiGeneration;
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.PsiCleanupManager : object {
    [NotNullAttribute]
private IEnumerable`1<IPsiCleanupProvider> myProviders;
    public PsiCleanupManager(IEnumerable`1<IPsiCleanupProvider> providers);
    [NotNullAttribute]
public static PsiCleanupManager GetInstance(ISolution solution);
    public void Run();
}
[BaseTypeRequiredAttribute("JetBrains.ReSharper.Psi.IPsiCleanupProvider")]
[MeansImplicitUseAttribute]
[ComponentInstantiationAttribute("-32758")]
public class JetBrains.ReSharper.Psi.PsiCleanupProviderAttribute : SolutionComponentAttribute {
    public PsiCleanupProviderAttribute(Instantiation instantiation);
}
[AttributeUsageAttribute("4")]
[MeansImplicitUseAttribute("8")]
[ComponentInstantiationAttribute("-32758")]
public class JetBrains.ReSharper.Psi.PsiComponentAttribute : SolutionComponentAttribute {
    public PsiComponentAttribute(Instantiation instantiation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.PsiExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static IPsiServices GetPsiServices(ISolution solution);
    [ExtensionAttribute]
[PureAttribute]
public static IPsiServices GetPsiServices(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
public static void MarkAsDirty(IPsiServices psiServices, IProjectFile projectFile);
}
[ShellComponentAttribute("16")]
internal class JetBrains.ReSharper.Psi.PsiFakeSolutionZoneProvider : object {
    public IEnumerable`1<FakeSolutionZoneFilter> Zones { get; }
    public sealed virtual IEnumerable`1<FakeSolutionZoneFilter> get_Zones();
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.PsiIconExtension : Enum {
    public int value__;
    public static PsiIconExtension None;
    public static PsiIconExtension ReadAccess;
    public static PsiIconExtension WriteAccess;
    public static PsiIconExtension ReadWriteAccess;
    public static PsiIconExtension Static;
    public static PsiIconExtension Private;
    public static PsiIconExtension FileLocal;
    public static PsiIconExtension Protected;
    public static PsiIconExtension Internal;
    public static PsiIconExtension ProtectedInternal;
    public static PsiIconExtension Abstract;
    public static PsiIconExtension Virtual;
    public static PsiIconExtension Public;
    public static PsiIconExtension Sealed;
}
public abstract class JetBrains.ReSharper.Psi.PsiIconManager : object {
    public IconId TransparentIconOfTypicalPsiIconSize { get; }
    public IconId KeywordIcon { get; }
    [NotNullAttribute]
public abstract virtual IconId GetDummyImage();
    [CanBeNullAttribute]
public abstract virtual IconId GetImage(IDeclaredElement element, PsiLanguageType languageType, bool drawExtensions);
    [CanBeNullAttribute]
public abstract virtual IconId GetImage(DeclaredElementType elementType);
    [CanBeNullAttribute]
public abstract virtual IconId GetImage(DeclaredElementType elementType, PsiIconExtension extensions);
    public abstract virtual IconId get_TransparentIconOfTypicalPsiIconSize();
    [NotNullAttribute]
public abstract virtual IconId ExtendToTypicalSize(IconId image);
    public abstract virtual IconId AttachExtensions(IconId image, PsiIconExtension extension);
    public abstract virtual void AddExtension(Lifetime lifetime, IDeclaredElementIconProvider extension);
    public abstract virtual void AddExtension(Lifetime lifetime, IDeclaredElementIconExtensionProvider extension);
    public abstract virtual IconId get_KeywordIcon();
    [PureAttribute]
public IconId GetImage(AccessRights accessRights);
}
[CannotApplyEqualityOperatorAttribute]
public class JetBrains.ReSharper.Psi.PsiLanguageType : object {
    [NotNullAttribute]
public string Name;
    [NotNullAttribute]
public string PresentableName;
    private LanguageService myService;
    private bool myServiceAsked;
    [NotNullAttribute]
public static IComparer`1<PsiLanguageType> ByNameComparer;
    public PsiLanguageCategories SupportedCategories { get; }
    public String[] Synonyms { get; }
    protected PsiLanguageType(string name);
    protected PsiLanguageType(string name, string presentableName);
    private static PsiLanguageType();
    internal void CleanLanguageService(IShellLocks locks);
    [CanBeNullAttribute]
internal LanguageService GetLanguageService();
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual PsiLanguageCategories get_SupportedCategories();
    public virtual String[] get_Synonyms();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.PsiLanguageTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsLanguage(PsiLanguageType languageType, PsiLanguageType baseLanguage);
    [ExtensionAttribute]
public static bool IsLanguage(PsiLanguageType languageType, Type baseLanguage);
    [ExtensionAttribute]
public static bool Is(PsiLanguageType languageType);
    [ExtensionAttribute]
public static bool IsExactly(PsiLanguageType languageType);
    [ExtensionAttribute]
public static bool IsExactly(PsiLanguageType languageType, PsiLanguageType language);
    [ExtensionAttribute]
public static bool IsExactly(PsiLanguageType languageType, Type language);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null=>true")]
public static bool IsNullOrUnknown(PsiLanguageType psiLanguageType);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static ITypeConversionRule TypeConversionRule(PsiLanguageType language, ITreeNode context, bool useStrict);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static LanguageService LanguageService(PsiLanguageType language);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static LanguageService LanguageServiceNotNull(PsiLanguageType language);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IDeclaredElementPresenter DeclaredElementPresenter(PsiLanguageType language);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IConstantValueService ConstantValueService(PsiLanguageType language);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITypePresenter TypePresenter(PsiLanguageType language);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ILanguageCacheProvider CacheProvider(PsiLanguageType language);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ICodeFormatter Formatter(PsiLanguageType language);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static T Formatter(PsiLanguageType language);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("language: null => null")]
private static T Get(PsiLanguageType language, Func`2<LanguageService, T> getter);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.PsiManagerExtensions : object {
    [ExtensionAttribute]
public static bool IsLanguageSupported(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
public static IEnumerable`1<IFile> EnumerateDominantPsiFiles(IPsiSourceFile psiSourceFile);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.PsiManagerExtensions/<EnumerateGeneratedPsiFiles>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<Pair`2<IFile, ISecondaryRangeTranslator>> EnumerateGeneratedPsiFiles(IPsiSourceFile sourceFile);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.PsiManagerExtensions/<EnumerateIntersectingPsiFiles>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<Pair`2<IFile, TreeTextRange>> EnumerateIntersectingPsiFiles(IPsiSourceFile psiSourceFile, DocumentRange range, PsiLanguageType language, PsiLanguageCategories psiLanguageCategories, bool includeEmpty);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IFile GetTheOnlyPsiFile(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IFile GetTheOnlyPsiFile(IPsiSourceFile sourceFile, PsiLanguageType language);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IFile GetPrimaryPsiFile(IProjectFile projectFile, Func`2<IPsiSourceFile, bool> psiSourceFileFilter);
    [ExtensionAttribute]
[NotNullAttribute]
[MustDisposeResourceAttribute]
public static IDisposable CreateCustomCookie(IPsiTransactions psiFiles);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private static void LogIfDebugMode(string message);
}
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.PsiProjectFileTypeCoordinator : object {
    private IProjectFileTypeServices myFileTypeServices;
    private CachedProjectFileLanguageService myLanguageServices;
    [ObsoleteAttribute("Inject me!")]
public static PsiProjectFileTypeCoordinator Instance { get; }
    public PsiProjectFileTypeCoordinator(IProjectFileTypeServices fileTypeServices, CachedProjectFileLanguageService languageServices);
    public static PsiProjectFileTypeCoordinator get_Instance();
    [CanBeNullAttribute]
public IconId GetIconByPsiLanguage(PsiLanguageType language);
    [NotNullAttribute]
public PsiLanguageType GetPrimaryPsiLanguageType(IProject project);
    [NotNullAttribute]
public PsiLanguageType GetPrimaryPsiLanguageType(IProjectFile projectFile);
    [NotNullAttribute]
public PsiLanguageType GetPrimaryPsiLanguageType(IPsiSourceFile sourceFile);
    [NotNullAttribute]
public PsiLanguageType GetPrimaryPsiLanguageType(ProjectFileType projectFileType);
    public IEnumerable`1<ProjectFileType> GetByPrimaryPsiLanguageType(PsiLanguageType psiLanguageType);
    [CanBeNullAttribute]
public ILexerFactory CreateLexerFactory(ISolution solution, IPsiSourceFile sourceFile, IBuffer buffer);
    [CanBeNullAttribute]
public ILexerFactory CreateLexerFactory(ISolution solution, ProjectFileType projectFileType, IBuffer buffer, IPsiSourceFile sourceFile);
    [CanBeNullAttribute]
public IProjectFileLanguageService TryGetService(ProjectFileType projectFileType);
    [CanBeNullAttribute]
public T TryGetService(ProjectFileType projectFileType);
}
public static class JetBrains.ReSharper.Psi.PsiShared : object {
    [NotNullAttribute]
public static T GetComponent();
    [CanBeNullAttribute]
public static T TryGetComponent();
    public static bool HasComponent();
}
[AttributeUsageAttribute("4")]
[MeansImplicitUseAttribute]
[ComponentInstantiationAttribute("16")]
public class JetBrains.ReSharper.Psi.PsiSharedComponentAttribute : ShellComponentAttribute {
    protected static Instantiation PsiSharedComponentDefaultInstantiation;
    public PsiSharedComponentAttribute(Instantiation instantiation);
}
public class JetBrains.ReSharper.Psi.PsiSharedComponentWithPriorityAttribute : PsiSharedComponentAttribute {
    [CompilerGeneratedAttribute]
private double <Priority>k__BackingField;
    public double Priority { get; }
    public PsiSharedComponentWithPriorityAttribute(double priority, Instantiation instantiation);
    [CompilerGeneratedAttribute]
public double get_Priority();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.PsiSourceFileEx : object {
    [ExtensionAttribute]
[PureAttribute]
public static PersistentIdForLogging GetPersistentIdForLogging(IPsiSourceFile psiSourceFile);
    [ExtensionAttribute]
public static void AssertIsNotBinary(IPsiSourceFile file);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.PsiSourceFileExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static TCustomPsiSourceFileProperties GetCustomProperties(IPsiSourceFile psiSource);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IPsiSourceFile ToValidSourceFile(ProjectModelElementEnvoy envoy);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IPsiSourceFile> TryGetSourceFiles(ITextControl textControl, ISolution solution);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ISolution GetSolution(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IModuleReferenceResolveContext GetResolveContext(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IContextBoundSettingsStore GetSettingsStore(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IContextBoundSettingsStore GetSettingsStoreWithEditorConfig(IPsiSourceFile sourceFile, ISolution solution);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IContextBoundSettingsStore GetLazySettingsStoreWithEditorConfig(IPsiSourceFile sourceFile, ISolution solution);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IContextBoundSettingsStore GetSettingsStoreWithEditorConfig(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
public static ContextRange GetContextRange(IPsiSourceFile sourceFile, ISolution solution);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IContextBoundSettingsStore GetSettingsStore(IPsiSourceFile sourceFile, ISolution solution);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IPsiSourceFile GetPsiSourceFile(IDocument document, ISolution solution);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IPsiSourceFile> GetPsiSourceFiles(IDocument document, ISolution solution);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IList`1<IPsiSourceFile> GetPsiSourceFilesIncludingShared(IDocument document, ISolution solution);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IPsiSourceFile> GetPsiSourceFilesInCurrentContext(IDocument document, ISolution solution);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null <= null")]
[PureAttribute]
public static IProjectFile ToProjectFile(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static VirtualFileSystemPath GetLocation(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[PureAttribute]
public static FrugalLocalList`1<IPsiSourceFile> ToSourceFiles(IProjectFile projectFile);
    [ExtensionAttribute]
[PureAttribute]
public static FrugalLocalList`1<IPsiSourceFile> ToSourceFilesInCurrentContext(IProjectFile projectFile);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IPsiSourceFile ToSourceFile(IProjectFile projectFile, TargetFrameworkId targetFrameworkId);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IPsiSourceFile ToSourceFile(IProjectFile projectFile);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDocument GetDocumentPreferSourceGeneratedDocument(IProjectFile projectFile);
    [ExtensionAttribute]
[PureAttribute]
public static long GetAggregatedTimestamp(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
public static Nullable`1<long> CalculateHash(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IProject GetProject(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[PureAttribute]
public static SourceFilePtr Ptr(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsProjFile(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertIsValid(IPsiSourceFile sourceFile, string messageText);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IDocument TryGetAssociatedEditorDocumentForSourceGeneratedFile(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDocument GetDocumentForHighlighters(IPsiSourceFile sourceFile);
}
public class JetBrains.ReSharper.Psi.PsiSourceFileFromPath : UserDataHolder {
    public static string ModuleIdPrefix;
    private IProjectFileExtensions myProjectFileExtensions;
    private PsiProjectFileTypeCoordinator myProjectFileTypeCoordinator;
    private IPsiModule myModule;
    private VirtualFileSystemPath myPath;
    private Func`2<PsiSourceFileFromPath, bool> myValidityCheck;
    private Func`2<PsiSourceFileFromPath, IPsiSourceFileProperties> myPropertiesFactory;
    private DocumentManager myDocumentManager;
    private PsiSourceFileStorage myPsiSourceFileStorage;
    private VirtualFileSystemPath myLastSeenBasePath;
    private string myDisplayName;
    private ModificationStamp myModificationCount;
    [CompilerGeneratedAttribute]
private IModuleReferenceResolveContext <ResolveContext>k__BackingField;
    public VirtualFileSystemPath Location { get; }
    public IPsiModule PsiModule { get; }
    public IDocument Document { get; }
    public string Name { get; }
    public string DisplayName { get; }
    public ProjectFileType LanguageType { get; }
    public PsiLanguageType PrimaryPsiLanguage { get; }
    public IPsiSourceFileProperties Properties { get; }
    public IPsiSourceFileStorage PsiStorage { get; }
    public Nullable`1<ModificationStamp> InMemoryModificationStamp { get; }
    public Nullable`1<ModificationStamp> ExternalModificationStamp { get; }
    public DateTime LastWriteTimeUtc { get; }
    public IModuleReferenceResolveContext ResolveContext { get; }
    public VirtualFileSystemPath NavigationPath { get; }
    public PsiSourceFileFromPath(IProjectFileExtensions projectFileExtensions, PsiProjectFileTypeCoordinator projectFileTypeCoordinator, IPsiModule module, VirtualFileSystemPath path, Func`2<PsiSourceFileFromPath, bool> validityCheck, Func`2<PsiSourceFileFromPath, IPsiSourceFileProperties> propertiesFactory, DocumentManager documentManager, IModuleReferenceResolveContext resolveContext, CachedFileSystemData cachedFileSystemData);
    public sealed virtual VirtualFileSystemPath get_Location();
    public sealed virtual bool IsValid();
    public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual IDocument get_Document();
    public void MarkDocumentModified();
    public sealed virtual string get_Name();
    public sealed virtual string get_DisplayName();
    [CanBeNullAttribute]
private VirtualFileSystemPath GetBasePath();
    public sealed virtual string GetPersistentID();
    public static string GetPersistentIDForPathAndModule(VirtualFileSystemPath path, IPsiModule module);
    public virtual string ToString();
    public virtual ProjectFileType get_LanguageType();
    public sealed virtual PsiLanguageType get_PrimaryPsiLanguage();
    public sealed virtual IPsiSourceFileProperties get_Properties();
    public sealed virtual IPsiSourceFileStorage get_PsiStorage();
    public sealed virtual Nullable`1<ModificationStamp> get_InMemoryModificationStamp();
    public sealed virtual Nullable`1<ModificationStamp> get_ExternalModificationStamp();
    public sealed virtual DateTime get_LastWriteTimeUtc();
    [CompilerGeneratedAttribute]
public sealed virtual IModuleReferenceResolveContext get_ResolveContext();
    public sealed virtual VirtualFileSystemPath get_NavigationPath();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.PsiSourceFilePropertiesEx : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string TryGetExplanation(IPsiSourceFileProperties properties);
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.PsiSourceFilePropertiesManager : object {
    [NotNullAttribute]
private IPsiTransactions myPsiTransactions;
    [NotNullAttribute]
private IShellLocks myLocks;
    [NotNullAttribute]
private object myLock;
    [NotNullAttribute]
private List`1 modreq(System.Runtime.CompilerServices.IsVolatile) myPsiSourceFilePropertiesProviders;
    [NotNullAttribute]
private ConcurrentDictionary`2<IPsiSourceFile, IPsiSourceFileProperties> myCachedProperties;
    public PsiSourceFilePropertiesManager(Lifetime lifetime, IEnumerable`1<IPsiSourceFilePropertiesProvider> filePropertiesProviders, IPsiTransactions psiTransactions, IShellLocks locks);
    private void ClearCachedProperties();
    [CanBeNullAttribute]
public IPsiSourceFileProperties GetPsiProperties(IProject project, IProjectFile projectFile, IPsiSourceFile sourceFile);
    private bool DoCacheProperties();
    [CanBeNullAttribute]
private IPsiSourceFileProperties CalculatePsiSourceFileProperties(IProject project, IProjectFile projectFile, IPsiSourceFile sourceFile);
}
public class JetBrains.ReSharper.Psi.PsiSourceFileStorage : object {
    [CanBeNullAttribute]
private IPsiSourceFile myPsiSourceFile;
    [CanBeNullAttribute]
private WeakReference`1<TypeMembersBucket> myTypeMembersBucketReference;
    private long myLastTimeStamp;
    private Nullable`1<long> myContentHash;
    [CompilerGeneratedAttribute]
private Nullable`1<OWORD> <PersistentIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private object <TypeMemberBucketLock>k__BackingField;
    [CompilerGeneratedAttribute]
private object <StubTreeNodesCacheLock>k__BackingField;
    private IParametrizedCachedValue`2<PsiFilesBucket, IPsiSourceFile> myPsiFilesBucket;
    private static ForkAttachedDataDescriptor ourPsiFilesBucketFieldDescriptor;
    public Nullable`1<OWORD> PersistentIndex { get; public set; }
    public Nullable`1<long> ContentHash { get; }
    public object TypeMemberBucketLock { get; }
    public object StubTreeNodesCacheLock { get; }
    public TypeMembersBucket TypeMemberBucket { get; internal set; }
    public IParametrizedCachedValue`2<PsiFilesBucket, IPsiSourceFile> PsiFilesBucket { get; internal set; }
    public PsiSourceFileStorage(IPsiSourceFile psiSourceFile);
    private static PsiSourceFileStorage();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<OWORD> get_PersistentIndex();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PersistentIndex(Nullable`1<OWORD> value);
    public sealed virtual Nullable`1<long> get_ContentHash();
    public sealed virtual void ResetContentHash();
    [CompilerGeneratedAttribute]
public sealed virtual object get_TypeMemberBucketLock();
    [CompilerGeneratedAttribute]
public sealed virtual object get_StubTreeNodesCacheLock();
    public sealed virtual TypeMembersBucket get_TypeMemberBucket();
    internal void set_TypeMemberBucket(TypeMembersBucket value);
    public sealed virtual IParametrizedCachedValue`2<PsiFilesBucket, IPsiSourceFile> get_PsiFilesBucket();
    internal void set_PsiFilesBucket(IParametrizedCachedValue`2<PsiFilesBucket, IPsiSourceFile> value);
    [CanBeNullAttribute]
public WeakReference`1<TypeMembersBucket> GetBucketWeakReference();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.PsiSourceFileWithLocationEx : object {
    private static Key`1<CachedFileSystemData> ourCachedFileSystemDataKey;
    private static PsiSourceFileWithLocationEx();
    [ExtensionAttribute]
public static void SetCachedFileSystemData(IPsiSourceFileWithLocation sourceFile, CachedFileSystemData data);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static CachedFileSystemData GetCachedFileSystemData(IPsiSourceFileWithLocation sourceFile);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
internal static CachedFileSystemData TryGetCachedFileSystemData(IPsiSourceFileWithLocation sourceFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SolutionInstanceComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.PsiSourceFileWithLocationTracker : object {
    private IShellLocks myShellLocks;
    private IFileSystemTracker myFileSystemTracker;
    private AsyncItemsProcessor`1<TrackChangesRequest> myItemsProcessor;
    public PsiSourceFileWithLocationTracker(Lifetime lifetime, ILogger logger, IShellLocks shellLocks, IFileSystemTracker fileSystemTracker);
    public void TrackChanges(Lifetime lifetime, IPsiSourceFileWithLocation sourceFile, Action`2<FileSystemChangeDelta, ExternalChangeType> onExternalChange);
    private static CachedFileSystemData TrackChangesSync(Lifetime lifetime, IPsiSourceFileWithLocation sourceFile, IFileSystemTracker fileSystemTracker, Action`2<FileSystemChangeDelta, ExternalChangeType> onExternalChange);
    protected void Pause(Lifetime lifetime, string reason);
}
public class JetBrains.ReSharper.Psi.RecursiveElementCollector`1 : object {
    [NotNullAttribute]
private Func`2<T, bool> myPredicate;
    [NotNullAttribute]
private List`1<T> myList;
    public bool ProcessingIsFinished { get; }
    public RecursiveElementCollector`1(Func`2<T, bool> predicate);
    [NotNullAttribute]
public virtual RecursiveElementCollector`1<T> ProcessElement(ITreeNode element);
    public virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    public sealed virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
    [NotNullAttribute]
public IList`1<T> GetResults();
    [NotNullAttribute]
public RecursiveElementCollector`1<T> ClearResults();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.RecursiveElementModifier`1 : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IGeneratedCodeRegionDetector <generatedRegionDetector>P;
    private int myVersion;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<ITreeNode, int>> myModificationStack;
    [NullableAttribute("0")]
protected ModificationMode<TContext> Mode { get; }
    [NullableContextAttribute("2")]
protected RecursiveElementModifier`1(IGeneratedCodeRegionDetector generatedRegionDetector);
    [NullableContextAttribute("0")]
protected abstract virtual ModificationMode<TContext> get_Mode();
    protected abstract virtual bool Modify(ITreeNode element, TContext context);
    public virtual bool IsModificationFinished(TContext context);
    public virtual bool InteriorShouldBeModified(ITreeNode element, TContext context);
    public sealed virtual ITreeNode ModifyBeforeInterior(ITreeNode element, TContext context);
    public sealed virtual ITreeNode ModifyAfterInterior(ITreeNode element, TContext context);
    [NullableContextAttribute("2")]
private ITreeNode CalculateNextNodeAfterModification(bool isAfterInterior);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.RecursiveElementModifierExtensions : object {
    [ExtensionAttribute]
public static ITreeNode ModifyThisAndDescendants(ITreeNode root, IRecursiveElementModifier`1<TContext> modifier, TContext context);
    [ExtensionAttribute]
public static bool ModifyDescendants(ITreeNode root, IRecursiveElementModifier`1<TContext> modifier, TContext context);
}
public class JetBrains.ReSharper.Psi.RecursiveElementProcessor : RecursiveElementProcessor`1<ITreeNode> {
    public RecursiveElementProcessor(Action`1<ITreeNode> action);
    public virtual void ProcessBeforeInterior(ITreeNode element);
}
public class JetBrains.ReSharper.Psi.RecursiveElementProcessor`1 : object {
    [NotNullAttribute]
protected Action`1<T> Action;
    [NotNullAttribute]
private Predicate`1<ITreeNode> myInteriorShouldBeProcessedHandler;
    [NotNullAttribute]
private Func`1<bool> myProcessingIsFinishedHandler;
    [NotNullAttribute]
public Predicate`1<ITreeNode> InteriorShouldBeProcessedHandler { get; public set; }
    [NotNullAttribute]
public Func`1<bool> ProcessingIsFinishedHandler { get; public set; }
    public bool ProcessingIsFinished { get; }
    public RecursiveElementProcessor`1(Action`1<T> action);
    public void Process(ITreeNode element);
    public void Process(IEnumerable`1<ITreeNode> range);
    public Predicate`1<ITreeNode> get_InteriorShouldBeProcessedHandler();
    public void set_InteriorShouldBeProcessedHandler(Predicate`1<ITreeNode> value);
    public Func`1<bool> get_ProcessingIsFinishedHandler();
    public void set_ProcessingIsFinishedHandler(Func`1<bool> value);
    public void ProcessForResolve(ITreeNode element);
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
    public sealed virtual bool get_ProcessingIsFinished();
    public virtual void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual void ProcessAfterInterior(ITreeNode element);
}
public class JetBrains.ReSharper.Psi.RecursiveElementProcessor`2 : object {
    [CompilerGeneratedAttribute]
private Action`2<T, TContext> <action>P;
    [NotNullAttribute]
private Predicate`1<ITreeNode> myInteriorShouldBeProcessedHandler;
    [NotNullAttribute]
private Func`2<TContext, bool> myProcessingIsFinishedHandler;
    [NotNullAttribute]
public Predicate`1<ITreeNode> InteriorShouldBeProcessedHandler { get; public set; }
    [NotNullAttribute]
public Func`2<TContext, bool> ProcessingIsFinishedHandler { get; public set; }
    public RecursiveElementProcessor`2(Action`2<T, TContext> action);
    public TContext Process(ITreeNode element, TContext context);
    public TContext Process(IEnumerable`1<ITreeNode> range, TContext context);
    public Predicate`1<ITreeNode> get_InteriorShouldBeProcessedHandler();
    public void set_InteriorShouldBeProcessedHandler(Predicate`1<ITreeNode> value);
    public Func`2<TContext, bool> get_ProcessingIsFinishedHandler();
    public void set_ProcessingIsFinishedHandler(Func`2<TContext, bool> value);
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element, TContext context);
    public sealed virtual bool IsProcessingFinished(TContext context);
    public virtual void ProcessBeforeInterior(ITreeNode element, TContext context);
    public sealed virtual void ProcessAfterInterior(ITreeNode element, TContext context);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.RecursiveElementProcessorExtensions : object {
    [ExtensionAttribute]
public static void ProcessThisAndDescendants(ITreeNode root, IRecursiveElementProcessor processor);
    [ExtensionAttribute]
public static void ProcessThisAndDescendants(ITreeNode root, IRecursiveElementProcessor`1<TContext> processor, TContext context);
    [ExtensionAttribute]
public static void ProcessDescendants(ITreeNode root, IRecursiveElementProcessor processor);
    [ExtensionAttribute]
public static void ProcessDescendants(ITreeNode root, IRecursiveElementProcessor`1<TContext> processor, TContext context);
    public static bool ProcessDescendantForResolve(IRecursiveElementProcessor processor, ITreeNode descendant);
    public static void ProcessOtherElementsForResolve(TreeElement element, IRecursiveElementProcessor processor, Func`2<ITreeNode, bool> predicate);
}
public class JetBrains.ReSharper.Psi.RecursiveReferenceProcessor : RecursiveElementProcessor`1<IReference> {
    public RecursiveReferenceProcessor(Action`1<IReference> action);
    public virtual void ProcessBeforeInterior(ITreeNode element);
}
public class JetBrains.ReSharper.Psi.RecursiveReferenceProcessor`1 : RecursiveElementProcessor`1<TReference> {
    public RecursiveReferenceProcessor`1(Action`1<TReference> action);
    public virtual void ProcessBeforeInterior(ITreeNode element);
}
public enum JetBrains.ReSharper.Psi.ReferenceAccessType : Enum {
    public int value__;
    public static ReferenceAccessType READ;
    public static ReferenceAccessType WRITE;
    public static ReferenceAccessType READ_WRITE;
    public static ReferenceAccessType INVOCATION;
    public static ReferenceAccessType NAME_CAPTURE;
    public static ReferenceAccessType DOCUMENTATION_REFERENCE;
    public static ReferenceAccessType ATTRIBUTE;
    public static ReferenceAccessType OTHER;
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.ReferencedProjectsService : object {
    private static object ourReferencedAssembliesHashLock;
    private static Key`1<Dictionary`2<TargetFrameworkId, JetHashSet`1<IProject>>> ourReferencedProjectsHashKey;
    private static IEqualityComparer`1<AssemblyNameInfo> ourAssemblyNameComparer;
    private static ClrTypeName ourAssemblyVersionAttribute;
    private ISolution mySolution;
    public ReferencedProjectsService(Lifetime lifetime, ChangeManager changeManager, ISolution solution);
    private static ReferencedProjectsService();
    private void Handler(ChangeEventArgs e);
    private static Dictionary`2<TargetFrameworkId, JetHashSet`1<IProject>> GetReferencedProjects(IProject project);
    public static bool IsProjectReferencingAssemblyByName(IProject project, TargetFrameworkId targetFrameworkId, AssemblyNameInfo targetAssembly, AssemblyNameInfo& referencedAssembly);
    private static Version GetFromPsi(IPsiModule psiModule, IProject project, TargetFrameworkId targetFrameworkId, IPsiServices psiServices);
    [NotNullAttribute]
public static string GetModuleName(IPsiModule psiModule);
}
public enum JetBrains.ReSharper.Psi.ReferenceKind : Enum {
    public byte value__;
    public static ReferenceKind VALUE;
    public static ReferenceKind MUTABLE_REFERENCE;
    public static ReferenceKind READONLY_REFERENCE;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.ReferenceKindExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsByReference(ReferenceKind referenceKind);
    [ExtensionAttribute]
[PureAttribute]
public static ParameterKind ToParameterKind(ReferenceKind referenceKind);
}
public enum JetBrains.ReSharper.Psi.RefSafetyRulesVersion : Enum {
    public byte value__;
    public static RefSafetyRulesVersion CSharp72;
    public static RefSafetyRulesVersion CSharp110;
}
[LanguageAttribute("JetBrains.ReSharper.Psi.KnownLanguage", "16")]
public class JetBrains.ReSharper.Psi.RefSafetyRulesVersionLanguageProvider : object {
    public virtual RefSafetyRulesVersion GetRefSafetyRulesVersion(ITreeNode context);
}
public static class JetBrains.ReSharper.Psi.RefSafetyRulesVersionProvider : object {
    public static Key`1<BoxedRefSafetyRulesVersion> Key;
    private static BoxedRefSafetyRulesVersion CSharp72;
    private static BoxedRefSafetyRulesVersion CSharp110;
    private static RefSafetyRulesVersionProvider();
    [CanBeNullAttribute]
public static Nullable`1<RefSafetyRulesVersion> GetRefSafetyRulesVersion(IDeclaredElement declaredElement);
    [CanBeNullAttribute]
public static Nullable`1<RefSafetyRulesVersion> GetRefSafetyRulesVersion(IPsiModule module);
}
public static class JetBrains.ReSharper.Psi.ReSharperControlConstruct : object {
    private static string CommonPrefix;
    private static string Disable;
    private static string Restore;
    private static string Once;
    public static string DisablePrefix;
    public static string RestorePrefix;
    public static string DisableOncePrefix;
    public static string DisableAllReSharperWarningsID;
    public static string DisableAllReSharperErrorsID;
    public static string DisableAllCompilerWarningsID;
    private static StringComparison ControlKeywordComparison;
    [PureAttribute]
public static ControlConstructInfo ParseCommentText(string commentText);
    private static bool SkipWhitespace(string text, Int32& index);
}
public class JetBrains.ReSharper.Psi.Resolve.AllNonQualifiedSignatureReferencesResolver : CachingNonQualifiedReferencesResolver {
    protected virtual bool ScopeShouldBeVisited(IScope scope);
    protected virtual bool ShouldCacheResult(IFile file);
}
public class JetBrains.ReSharper.Psi.Resolve.CachingNonQualifiedReferencesResolver : NonQualifiedReferencesResolverBase {
    [CanBeNullAttribute]
private HashSet`1<IScope> myLimitedScopes;
    public CachingNonQualifiedReferencesResolver(SymbolTableMode mode);
    public void Process(ITreeNode element);
    protected virtual void ProcessImpl(ITreeNode element);
    [NotNullAttribute]
[PureAttribute]
private static HashSet`1<IScope> CollectLimitedScopes(ITreeNode element);
    protected virtual bool ShouldCacheResult(IFile file);
    protected virtual bool ScopeShouldBeVisited(IScope scope);
}
public class JetBrains.ReSharper.Psi.Resolve.CandidatesResolveResult : ResolveResultBase {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private IList`1<IDeclaredElement> myCandidates;
    public IList`1<IDeclaredElement> Candidates { get; }
    public CandidatesResolveResult(IList`1<IDeclaredElement> candidates);
    public virtual IList`1<IDeclaredElement> get_Candidates();
    public virtual bool IsValid();
    public virtual string Dump();
    public virtual IResolveResult ReplaceDeclaredElement(IDeclaredElement element);
    public virtual IResolveResult ReplaceSubstitution(ISubstitution candidateSubstitution);
}
public class JetBrains.ReSharper.Psi.Resolve.CandidatesResolveResultWithSubstitution : CandidatesResolveResult {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private IList`1<ISubstitution> mySubstitutions;
    public IList`1<ISubstitution> CandidateSubstitutions { get; }
    public CandidatesResolveResultWithSubstitution(IList`1<IDeclaredElement> candidates, IList`1<ISubstitution> substitutions);
    public virtual IList`1<ISubstitution> get_CandidateSubstitutions();
    public virtual bool IsValid();
    public virtual string Dump();
    [NotNullAttribute]
protected static IList`1<ISubstitution> GetIdSubstitutions(IList`1<IDeclaredElement> candidates);
}
public class JetBrains.ReSharper.Psi.Resolve.DeclaredElementTypeFilter : SimpleSymbolFilterWithErrorType {
    private DeclaredElementType[] myExpectedTypes;
    private FilterRunType myRunType;
    public FilterRunType RunType { get; }
    public DeclaredElementTypeFilter(ResolveErrorType errorType, DeclaredElementType[] expectedTypes);
    public DeclaredElementTypeFilter(ResolveErrorType errorType, FilterRunType runType, DeclaredElementType[] expectedTypes);
    public virtual FilterRunType get_RunType();
    public virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
}
public class JetBrains.ReSharper.Psi.Resolve.DefaultAccessContext : object {
    [CompilerGeneratedAttribute]
private ITreeNode <Element>k__BackingField;
    protected ITreeNode Element { get; }
    public DefaultAccessContext(ITreeNode element);
    [CompilerGeneratedAttribute]
protected ITreeNode get_Element();
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public virtual Staticness GetStaticness();
    public virtual QualifierKind GetQualifierKind();
    public virtual ITypeElement GetQualifierTypeElement();
    public virtual IPsiModule GetPsiModule();
    public sealed virtual IPsiSourceFile GetSourceFile();
}
public class JetBrains.ReSharper.Psi.Resolve.DynamicResolveResult : ResolveResultWithSubstitution {
    [NotNullAttribute]
public static DynamicResolveResult Instance;
    public DynamicResolveResult(IDeclaredElement element, ISubstitution substitution, IList`1<IDeclaredElement> candidates, IList`1<ISubstitution> candidateSubstitutions);
    public DynamicResolveResult(DeclaredElementInstance candidate);
    public DynamicResolveResult(IList`1<IDeclaredElement> candidates);
    public DynamicResolveResult(ICollection`1<DeclaredElementInstance> candidates);
    private static DynamicResolveResult();
    public virtual IResolveResult ReplaceDeclaredElement(IDeclaredElement element);
    public virtual IResolveResult ReplaceSubstitution(ISubstitution candidateSubstitution);
}
public class JetBrains.ReSharper.Psi.Resolve.ElementAccessContext : object {
    [NotNullAttribute]
private ITreeNode myElement;
    public ElementAccessContext(ITreeNode element);
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
    public sealed virtual IPsiModule GetPsiModule();
    public sealed virtual IPsiSourceFile GetSourceFile();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Resolve.EmptyFilter : object {
    public static ISymbolFilter INSTANCE;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    private static EmptyFilter();
    public sealed virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public sealed virtual ResolveErrorType get_ErrorType();
    public sealed virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.Resolve.EmptyQualifier : object {
    [NotNullAttribute]
public static EmptyQualifier INSTANCE;
    public bool Resolved { get; }
    private static EmptyQualifier();
    public sealed virtual ISymbolTable GetSymbolTable(SymbolTableMode mode);
    public sealed virtual QualifierKind GetKind();
    public sealed virtual bool get_Resolved();
    public sealed virtual ITypeElement GetQualifierTypeElement();
}
public class JetBrains.ReSharper.Psi.Resolve.EmptyResolveResult : ResolveResultBase {
    [NotNullAttribute]
public static IResolveResult Instance;
    public bool IsEmpty { get; }
    private static EmptyResolveResult();
    public virtual bool get_IsEmpty();
    public sealed virtual string Dump();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Empty")]
public class JetBrains.ReSharper.Psi.Resolve.EmptySubstitution : object {
    [NotNullAttribute]
public static EmptySubstitution INSTANCE;
    public IList`1<ITypeParameter> Domain { get; }
    public IType Item { get; }
    public IType Item { get; }
    private static EmptySubstitution();
    public sealed virtual ISubstitution Apply(ISubstitution substitution);
    public sealed virtual IType Apply(ITypeParameter typeParameter);
    public sealed virtual IType Apply(IType type);
    public sealed virtual bool IsIdempotent(ITypeParameter typeParameter);
    public sealed virtual ISubstitution Extend(ITypeParameter typeParameter, IType value);
    public sealed virtual ISubstitution Extend(IList`1<ITypeParameter> typeParameters, IList`1<IType> values);
    public sealed virtual ISubstitution Extend(IDictionary`2<ITypeParameter, IType> map);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual IList`1<ITypeParameter> get_Domain();
    public sealed virtual bool HasInDomain(ITypeParameter typeParameter);
    public sealed virtual IType get_Item(ITypeParameter tp);
    public sealed virtual IType get_Item(IType t);
    public sealed virtual bool IsEmpty();
    public sealed virtual bool IsValid();
    public sealed virtual ISubstitution TryTranslateToCurrentFork(IContentModelForkTranslator translator);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Resolve.ExactNameFilter : SimpleSymbolInfoFilter {
    [CompilerGeneratedAttribute]
private string <name>P;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public ExactNameFilter(string name);
    public virtual bool Accepts(ISymbolInfo info);
    public virtual ResolveErrorType get_ErrorType();
    public virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.Resolve.ExtensionMethods.ExtensionInstance`1 : DeclaredElementInstance`1<TDeclaredElement> {
    [CompilerGeneratedAttribute]
private bool <IsExtensionMethod>k__BackingField;
    public bool IsExtensionMethod { get; }
    public ExtensionInstance`1(TDeclaredElement element, ISubstitution substitution, bool isExtensionMethod);
    [CompilerGeneratedAttribute]
public bool get_IsExtensionMethod();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Resolve.ExtensionMethods.ExtensionInstanceExtensions : object {
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => null")]
[PureAttribute]
public static ExtensionInstance`1<TTargetElement> Cast(ExtensionInstance`1<TSourceElement> instance);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => null")]
[PureAttribute]
public static ExtensionInstance`1<TTargetElement> TryCast(ExtensionInstance`1<TSourceElement> instance);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Resolve.ExtensionMethods.ExtensionMethodResolveResultExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ExtensionInstance`1<IDeclaredElement> ElementAsExtension(IResolveResult resolveResult);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ExtensionInstance`1<IDeclaredElement> ResolveAsExtensionInstance(IReference reference);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<ExtensionInstance`1<IDeclaredElement>> CandidatesAsExtension(IResolveResult resolveResult);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<ExtensionInstance`1<IDeclaredElement>> ElementsAsExtension(IResolveResult resolveResult);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsExtensionMethodInvocation(IResolveResult resolveResult);
}
public static class JetBrains.ReSharper.Psi.Resolve.FileFilters : object {
    public static ISymbolFilter Exists;
    public static ISymbolFilter FileExists;
    public static ISymbolFilter DirectoryExists;
    public static ISymbolFilter InSolution;
    public static ISymbolFilter IsProjectFolder;
    private static FileFilters();
}
public class JetBrains.ReSharper.Psi.Resolve.FileResolveErrorType : ResolveErrorType {
    public static ResolveErrorType PATH_NOT_RESOLVED;
    public static ResolveErrorType INVALID_CHARS;
    public static ResolveErrorType NOT_EXIST;
    public static ResolveErrorType NOT_IN_PROJECT;
    public static ResolveErrorType NOT_IN_SOLUTION;
    public static ResolveErrorType PROJECT_FILE_EXPECTED;
    public static ResolveErrorType PROJECT_FOLDER_EXPECTED;
    public static ResolveErrorType PROJECT_FILE_TYPE_MISMATCH;
    public static ResolveErrorType PROJECT_FILE_BUILD_ACTION_MISMATCH;
    public static ResolveErrorType CASE_MISMATCH;
    public static ResolveErrorType PATH_IGNORED;
    public static ResolveErrorType PATH_MAPPED;
    public static ResolveErrorType[] AllFileErrors;
    private FileResolveErrorType(string name);
    private static FileResolveErrorType();
}
public enum JetBrains.ReSharper.Psi.Resolve.FilterRunType : Enum {
    public int value__;
    public static FilterRunType REGULAR;
    public static FilterRunType MUST_RUN;
    public static FilterRunType MUST_RUN_NO_CANDIDATES;
}
public interface JetBrains.ReSharper.Psi.Resolve.IAccessContext {
    [CanBeNullAttribute]
public abstract virtual ITypeElement GetAccessContainingTypeElement();
    public abstract virtual Staticness GetStaticness();
    public abstract virtual QualifierKind GetQualifierKind();
    [CanBeNullAttribute]
public abstract virtual ITypeElement GetQualifierTypeElement();
    [NotNullAttribute]
public abstract virtual IPsiModule GetPsiModule();
    [CanBeNullAttribute]
public abstract virtual IPsiSourceFile GetSourceFile();
}
public interface JetBrains.ReSharper.Psi.Resolve.ICompletableReference {
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISymbolTable GetCompletionSymbolTable();
}
public interface JetBrains.ReSharper.Psi.Resolve.IFileReference {
    public ProjectFileType ExpectedFileType { get; }
    public BuildAction ExpectedBuildAction { get; }
    public ICollection`1<string> ExpectedExtensions { get; }
    public abstract virtual ProjectFileType get_ExpectedFileType();
    public abstract virtual BuildAction get_ExpectedBuildAction();
    public abstract virtual ICollection`1<string> get_ExpectedExtensions();
    public abstract virtual ISymbolTable GetSmartCompletionSymbolTable();
}
public interface JetBrains.ReSharper.Psi.Resolve.IIgnorablePathReference {
    public bool CanBeMappedOrIgnored { get; }
    public bool AllowEmptyName { get; }
    public abstract virtual bool get_CanBeMappedOrIgnored();
    public abstract virtual bool get_AllowEmptyName();
}
public interface JetBrains.ReSharper.Psi.Resolve.ILanguageTypeElementOwnMembersSymbolTableProvider {
    [CanBeNullAttribute]
public abstract virtual ISymbolTable GetOwnMembersSymbolTable(ITypeElement typeElement, SymbolTableMode mode);
}
public interface JetBrains.ReSharper.Psi.Resolve.ILateBoundReference {
    public abstract virtual Refers RefersToDeclaredElement(IDeclaredElement declaredElement);
}
public interface JetBrains.ReSharper.Psi.Resolve.IPathReference {
    [NotNullAttribute]
public abstract virtual VirtualFileSystemPath GetBasePath();
    public abstract virtual ISymbolFilter[] GetPathFilters();
}
public interface JetBrains.ReSharper.Psi.Resolve.IPreferredReference {
}
public interface JetBrains.ReSharper.Psi.Resolve.IQualifier {
    public bool Resolved { get; }
    [NotNullAttribute]
public abstract virtual ISymbolTable GetSymbolTable(SymbolTableMode mode);
    public abstract virtual QualifierKind GetKind();
    public abstract virtual bool get_Resolved();
}
public interface JetBrains.ReSharper.Psi.Resolve.IQualifierWithExpressionType {
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IExpressionType GetQualifierExpressionType();
}
public interface JetBrains.ReSharper.Psi.Resolve.IQualifierWithTypeElement {
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual ITypeElement GetQualifierTypeElement();
}
public interface JetBrains.ReSharper.Psi.Resolve.IReference {
    public bool HasMultipleNames { get; }
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ITreeNode GetTreeNode();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual string GetName();
    public abstract virtual bool get_HasMultipleNames();
    public abstract virtual HybridCollection`1<string> GetAllNames();
    [NotNullAttribute]
public abstract virtual ISymbolTable GetReferenceSymbolTable(bool useReferenceName);
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public abstract virtual ResolveResultWithInfo Resolve();
    public abstract virtual TreeTextRange GetTreeTextRange();
    [NotNullAttribute]
public abstract virtual IReference BindTo(IDeclaredElement element);
    [NotNullAttribute]
public abstract virtual IReference BindTo(IDeclaredElement element, ISubstitution substitution);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IAccessContext GetAccessContext();
    public abstract virtual bool IsValid();
}
public interface JetBrains.ReSharper.Psi.Resolve.IReferenceFactory {
    public abstract virtual ReferenceCollection GetReferences(ITreeNode element, ReferenceCollection oldReferences);
    public abstract virtual bool HasReference(ITreeNode element, IReferenceNameContainer names);
}
public interface JetBrains.ReSharper.Psi.Resolve.IReferenceFromStringLiteral {
}
public interface JetBrains.ReSharper.Psi.Resolve.IReferenceNameContainer {
    public bool IsEmpty { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool Contains(string name);
    public abstract virtual bool Contains(StringSlice name);
    public abstract virtual bool ContainsIgnoreCase(string name);
    public abstract virtual bool ContainsIgnoreCase(StringSlice name);
    public abstract virtual bool HasAnyNameIn(string value);
    public abstract virtual bool HasAnyNameIn(StringSlice value);
    public abstract virtual IEnumerable`1<string> AsEnumerable();
}
public interface JetBrains.ReSharper.Psi.Resolve.IReferenceProvider {
    public abstract virtual ReferenceCollection GetReferences(ITreeNode element, IReferenceNameContainer names);
    public abstract virtual bool ContainsReference(ITreeNode element, IReference reference);
}
public interface JetBrains.ReSharper.Psi.Resolve.IReferenceProviderFactory {
    public ISignal`1<IReferenceProviderFactory> Changed { get; }
    [CanBeNullAttribute]
public abstract virtual IReferenceFactory CreateFactory(IPsiSourceFile sourceFile, IFile file, IWordIndex wordIndexForChecks);
    public abstract virtual ISignal`1<IReferenceProviderFactory> get_Changed();
}
public interface JetBrains.ReSharper.Psi.Resolve.IReferenceQualifier {
    [NotNullAttribute]
public abstract virtual ISymbolTable GetSymbolTable(SymbolTableMode mode, IReference reference, bool useReferenceName);
}
public interface JetBrains.ReSharper.Psi.Resolve.IReferenceToDelegateCreation {
    [NotNullAttribute]
public IDeclaredType Delegate { get; }
    public bool IsEventSubscription { get; }
    public abstract virtual IDeclaredType get_Delegate();
    public abstract virtual bool get_IsEventSubscription();
}
public interface JetBrains.ReSharper.Psi.Resolve.IResolveResult {
    [CanBeNullAttribute]
public IDeclaredElement DeclaredElement { get; }
    [NotNullAttribute]
public ISubstitution Substitution { get; }
    [NotNullAttribute]
public IList`1<IDeclaredElement> Candidates { get; }
    [NotNullAttribute]
public IList`1<ISubstitution> CandidateSubstitutions { get; }
    public bool IsEmpty { get; }
    public abstract virtual IDeclaredElement get_DeclaredElement();
    public abstract virtual ISubstitution get_Substitution();
    public abstract virtual IList`1<IDeclaredElement> get_Candidates();
    public abstract virtual IList`1<ISubstitution> get_CandidateSubstitutions();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IResolveResult ReplaceDeclaredElement(IDeclaredElement element);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IResolveResult ReplaceSubstitution(ISubstitution candidateSubstitution);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool IsValid();
    [NotNullAttribute]
public abstract virtual string Dump();
}
[DefaultMemberAttribute("Item")]
public interface JetBrains.ReSharper.Psi.Resolve.ISubstitution {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
public IList`1<ITypeParameter> Domain { get; }
    [NotNullAttribute]
public IType Item { get; }
    [NotNullAttribute]
public IType Item { get; }
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType Apply(ITypeParameter typeParameter);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType Apply(IType type);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISubstitution Apply(ISubstitution substitution);
    public abstract virtual IList`1<ITypeParameter> get_Domain();
    [PureAttribute]
public abstract virtual bool HasInDomain(ITypeParameter typeParameter);
    [PureAttribute]
public abstract virtual bool IsIdempotent(ITypeParameter typeParameter);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISubstitution Extend(ITypeParameter typeParameter, IType value);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISubstitution Extend(IList`1<ITypeParameter> typeParameters, IList`1<IType> values);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISubstitution Extend(IDictionary`2<ITypeParameter, IType> map);
    public abstract virtual IType get_Item(ITypeParameter tp);
    public abstract virtual IType get_Item(IType t);
    public abstract virtual bool IsEmpty();
    public abstract virtual bool IsValid();
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.Resolve.ISymbolFilter {
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public abstract virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public abstract virtual ResolveErrorType get_ErrorType();
    public abstract virtual FilterRunType get_RunType();
}
public interface JetBrains.ReSharper.Psi.Resolve.ISymbolInfo {
    [NotNullAttribute]
public string ShortName { get; }
    public int Level { get; }
    public Nullable`1<int> InheritanceLevel { get; }
    public abstract virtual string get_ShortName();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IDeclaredElement GetDeclaredElement();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISubstitution GetSubstitution();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISymbolInfo ReplaceSubstitution(ISubstitution substitution);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISymbolInfo ReplaceLevel(int level);
    public abstract virtual int get_Level();
    public abstract virtual Nullable`1<int> get_InheritanceLevel();
}
public interface JetBrains.ReSharper.Psi.Resolve.ISymbolTable {
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public abstract virtual IEnumerable`1<string> Names();
    [NotNullAttribute]
[MustUseReturnValueAttribute]
public abstract virtual IList`1<ISymbolInfo> GetSymbolInfos(string name);
    public abstract virtual void AppendSymbolInfos(string name, List`1<ISymbolInfo> consumer);
    [NotNullAttribute]
public abstract virtual IList`1<ISymbolInfo> GetSymbolInfosConstitutingResolveResult(string name, IResolveInfo& resolveInfo);
    [CanBeNullAttribute]
public abstract virtual ISymbolTableDependencySet GetDependencySet();
    public abstract virtual void ForAllSymbolInfos(Action`1<ISymbolInfo> processor);
    public abstract virtual bool ForAllSymbolInfos(TState state, Func`3<TState, ISymbolInfo, bool> processor);
}
public interface JetBrains.ReSharper.Psi.Resolve.IUriPathResolver {
    public abstract virtual ReferenceCollection GetPathReferences(Uri uri, TOwner owner, TToken token, IQualifier baseQualifier, Func`5<TOwner, IQualifier, TToken, TreeTextRange, IPathReference> createFolderReferenceDelegate, Func`5<TOwner, IQualifier, TToken, TreeTextRange, IPathReference> createFileReferenceDelegate, string stringValue, int valueStartOffset);
}
public interface JetBrains.ReSharper.Psi.Resolve.IWebPathQualifier {
    [NotNullAttribute]
public VirtualFileSystemPath Path { get; }
    public bool AllowedOutsideOfSite { get; }
    public abstract virtual VirtualFileSystemPath get_Path();
    public abstract virtual bool get_AllowedOutsideOfSite();
}
public interface JetBrains.ReSharper.Psi.Resolve.Managed.ICalculationInfo {
}
public interface JetBrains.ReSharper.Psi.Resolve.Managed.IManagedConstantValueOwner {
}
public interface JetBrains.ReSharper.Psi.Resolve.Managed.IManagedConvertible {
}
public interface JetBrains.ReSharper.Psi.Resolve.Managed.IManagedExpression {
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType Type(IResolveContext resolveContext);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType GetImplicitlyConvertedTo(IResolveContext resolveContext);
    [PureAttribute]
public abstract virtual bool IsConstantValue(IResolveContext resolveContext);
    [PureAttribute]
public abstract virtual ExpressionAccessType GetAccessType(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.Resolve.Managed.IManagedNonQualifiableReference {
}
public interface JetBrains.ReSharper.Psi.Resolve.Managed.IManagedOnePhaseReference {
}
public interface JetBrains.ReSharper.Psi.Resolve.Managed.IManagedQualifiableReference {
    [CanBeNullAttribute]
public abstract virtual IQualifier GetQualifier(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.Resolve.Managed.IManagedReference {
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IAccessContext GetAccessContext(IResolveContext resolveContext);
    [NotNullAttribute]
public abstract virtual ISymbolTable GetReferenceSymbolTable(IResolveContext resolveContext);
}
public interface JetBrains.ReSharper.Psi.Resolve.Managed.IManagedTwoPhaseReference {
}
public interface JetBrains.ReSharper.Psi.Resolve.Managed.IManagedVariable {
}
public interface JetBrains.ReSharper.Psi.Resolve.Managed.IResolveContext {
    [NotNullAttribute]
public IPsiModule PsiModule { get; }
    [CanBeNullAttribute]
public abstract virtual IResolveContext TryFork(IList`1<ValueTuple`2<IManagedVariable, IType>> assumptions);
    [CanBeNullAttribute]
public abstract virtual IResolveContext TryForkOnImplicitlyConvertedTo(IList`1<ValueTuple`2<IManagedConvertible, IType>> assumptions);
    public abstract virtual void Join(IResolveContext resolveContext);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType TypeOf(IManagedVariable typeOwner);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IExpressionType ExpressionType(IManagedExpression expression);
    [PureAttribute]
public abstract virtual ResolveResultWithInfo PreResolve(IManagedTwoPhaseReference reference, ISymbolTable table);
    [PureAttribute]
public abstract virtual ResolveResultWithInfo ResolveWithInfo(IManagedReference reference);
    [PureAttribute]
public abstract virtual bool HasResolveInfo(IManagedReference reference);
    public abstract virtual bool HasForkedImplicitlyConvertedTo(IManagedConvertible managedConvertible);
    [CanBeNullAttribute]
public abstract virtual object Verify(ITreeNode element, IVerifier verifier);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ConstantValue ConstantValue(IManagedConstantValueOwner constantValueOwner);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ConstantValue ConstantValue(IManagedExpression expression, ICalculationInfo info);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType GetImplicitlyConvertedTo(IManagedConvertible convertible);
    public abstract virtual IPsiModule get_PsiModule();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Resolve.Managed.ManagedExtensionsDispatcher : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IPsiServices GetPsiServices(IResolveContext resolveContext);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IResolveResult Resolve(IResolveContext resolveContext, IManagedReference managedReference);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IResolveResult Resolve(IReference reference, IResolveContext resolveContext);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ResolveResultWithInfo ResolveWithInfo(IReference reference, IResolveContext resolveContext);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ResolveResultWithInfo ResolveWithOptionalContext(IReference reference, IResolveContext resolveContext);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IType TypeIn(ITypeOwner typeOwner, IResolveContext resolveContext);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IType TypeInOptionalContext(ITypeOwner typeOwner, IResolveContext resolveContext);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IType TypeWithOptionalContext(IManagedExpression expression, IResolveContext resolveContext);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IExpressionType GetExpressionType(IExpression expression, IResolveContext resolveContext);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IExpressionType ExpressionTypeWithOptionalContext(IManagedExpression managedExpression, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsConstantValue(IExpression expression, IResolveContext resolveContext);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ConstantValue ConstantValue(IConstantValueOwner constantValueOwner, IResolveContext resolveContext);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ConstantValue ConstantValueWithOptionalContext(IManagedConstantValueOwner constantValueOwner, IResolveContext resolveContext);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IType GetImplicitlyConvertedTo(IManagedConvertible managedConvertible, IResolveContext resolveContext);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ISymbolTable GetSymbolTableForResolve(IManagedQualifiableReference reference, IResolveContext resolveContext);
}
public class JetBrains.ReSharper.Psi.Resolve.MultipleReferencesResolver : CachingNonQualifiedReferencesResolver {
    [NotNullAttribute]
private JetHashSet`1<ITreeNode> myTargetElementsSet;
    [NotNullAttribute]
private JetHashSet`1<IScope> myScopeHashset;
    private int myVisitedTargetsCount;
    public bool ProcessingIsFinished { get; }
    private MultipleReferencesResolver(IEnumerable`1<IReference> refs);
    protected virtual bool ShouldCacheResult(IFile file);
    protected virtual void VisitElement(ITreeNode element);
    protected virtual bool ScopeShouldBeVisited(IScope scope);
    public virtual bool get_ProcessingIsFinished();
    public static void ResolveReferences(ITreeNode scope, IEnumerable`1<IReference> references);
}
public static class JetBrains.ReSharper.Psi.Resolve.NonQualifiedReferencesResolver : object {
    public static Key`1<object> ALL_REFERENCES_RESOLVED_TIMESTAMP;
    private static NonQualifiedReferencesResolver();
}
public abstract class JetBrains.ReSharper.Psi.Resolve.NonQualifiedReferencesResolverBase : Resolver {
    [CompilerGeneratedAttribute]
private ResolveContext <ResolveContext>k__BackingField;
    protected ResolveContext ResolveContext { get; protected set; }
    protected NonQualifiedReferencesResolverBase(SymbolTableMode mode);
    [CompilerGeneratedAttribute]
protected ResolveContext get_ResolveContext();
    [CompilerGeneratedAttribute]
protected void set_ResolveContext(ResolveContext value);
    protected virtual void ProcessImpl(ITreeNode topElement);
    protected virtual void VisitElement(ITreeNode element);
    protected virtual ResolveResultWithInfo ResolveReference(IResolverQualifiableReference reference);
}
public class JetBrains.ReSharper.Psi.Resolve.NonStaticAccessContext : DefaultAccessContext {
    public NonStaticAccessContext(ITreeNode element);
    public virtual Staticness GetStaticness();
    public virtual QualifierKind GetQualifierKind();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Resolve.PathReferenceExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[ObsoleteAttribute("In reality can be multiple project files")]
public static IProjectFile ResolveProjectFile(IPathReference pathReference);
    [CanBeNullAttribute]
[ObsoleteAttribute("In reality can be multiple project items")]
public static TProjectItem ResolveProjectItemInCurrentProject(IReference reference);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ObsoleteAttribute("In reality can be multiple project items")]
public static IProjectFile ResolveProjectFileInCurrentProject(IPathReference pathReference);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Resolve.PredicateFilter : SimpleSymbolInfoFilter {
    [CompilerGeneratedAttribute]
private Func`2<ISymbolInfo, bool> <predicate>P;
    [CompilerGeneratedAttribute]
private ResolveErrorType <ErrorType>k__BackingField;
    [CompilerGeneratedAttribute]
private FilterRunType <RunType>k__BackingField;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public PredicateFilter(Func`2<ISymbolInfo, bool> predicate, ResolveErrorType errorType, FilterRunType runType);
    public PredicateFilter(Func`2<ISymbolInfo, bool> predicate);
    public PredicateFilter(Func`2<ISymbolInfo, bool> predicate, ResolveErrorType errorType);
    [DebuggerStepThroughAttribute]
public virtual bool Accepts(ISymbolInfo info);
    [CompilerGeneratedAttribute]
public virtual ResolveErrorType get_ErrorType();
    [CompilerGeneratedAttribute]
public virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.Resolve.QualifierAccessContext : object {
    [NotNullAttribute]
private ITreeNode myOwner;
    [NotNullAttribute]
private IQualifierWithTypeElement myQualifier;
    public QualifierAccessContext(ITreeNode owner, IQualifierWithTypeElement qualifier);
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
    public sealed virtual IPsiModule GetPsiModule();
    public sealed virtual IPsiSourceFile GetSourceFile();
}
public enum JetBrains.ReSharper.Psi.Resolve.QualifierKind : Enum {
    public int value__;
    public static QualifierKind NONE;
    public static QualifierKind THIS;
    public static QualifierKind BASE;
    public static QualifierKind OBJECT;
    public static QualifierKind TYPE;
    public static QualifierKind NAMESPACE;
    public static QualifierKind UNKNOWN;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Resolve.ReferenceExtension : object {
    [ExtensionAttribute]
[PureAttribute]
public static DocumentRange GetDocumentRange(IReference reference);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertIsValid(IReference reference);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IModuleReferenceResolveContext GetResolveContext(IReference reference);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ResolveErrorType CheckResolveResult(IReference reference);
    [ExtensionAttribute]
[ObsoleteAttribute("It was a bad idea, Deconstruct() must be pure")]
public static void Deconstruct(IReference reference, IDeclaredElement& declaredElement);
    [ExtensionAttribute]
[ObsoleteAttribute("It was a bad idea, Deconstruct() must be pure")]
public static void Deconstruct(IReference reference, IDeclaredElement& declaredElement, ISubstitution& substitution);
    [ExtensionAttribute]
[ObsoleteAttribute("It was a bad idea, Deconstruct() must be pure")]
public static void Deconstruct(IReference reference, IDeclaredElement& declaredElement, ISubstitution& substitution, ResolveErrorType& resolveErrorType);
}
public class JetBrains.ReSharper.Psi.Resolve.ReferenceNameContainer : object {
    private bool myCaseSensitive;
    private string mySingleReferenceName;
    private JetHashSet`1<string> myDefaultSet;
    private JetHashSet`1<string> myIgnoreCaseSet;
    private bool myIsEmpty;
    public bool IsEmpty { get; }
    public ReferenceNameContainer(ICollection`1<string> referenceNames, bool caseSensitive);
    public sealed virtual bool get_IsEmpty();
    public sealed virtual bool Contains(string name);
    public sealed virtual bool Contains(StringSlice name);
    public sealed virtual bool ContainsIgnoreCase(string name);
    public sealed virtual bool ContainsIgnoreCase(StringSlice name);
    public sealed virtual bool HasAnyNameIn(string value);
    public sealed virtual bool HasAnyNameIn(StringSlice value);
    public sealed virtual IEnumerable`1<string> AsEnumerable();
}
[BaseTypeRequiredAttribute("JetBrains.ReSharper.Psi.Resolve.IReferenceProviderFactory")]
[MeansImplicitUseAttribute]
public class JetBrains.ReSharper.Psi.Resolve.ReferenceProviderFactoryAttribute : SolutionComponentAttribute {
    [CompilerGeneratedAttribute]
private Type[] <ReferenceTypes>k__BackingField;
    public Type[] ReferenceTypes { get; public set; }
    public ReferenceProviderFactoryAttribute(Instantiation instantiation);
    [CompilerGeneratedAttribute]
public Type[] get_ReferenceTypes();
    [CompilerGeneratedAttribute]
public void set_ReferenceTypes(Type[] value);
}
public enum JetBrains.ReSharper.Psi.Resolve.Refers : Enum {
    public int value__;
    public static Refers NO;
    public static Refers MAYBE;
    public static Refers YES;
}
[LocalizableAttribute("False")]
public class JetBrains.ReSharper.Psi.Resolve.ResolveErrorType : EnumPattern {
    [CompilerGeneratedAttribute]
private bool <IsAcceptable>k__BackingField;
    [NotNullAttribute]
public static ResolveErrorType OK;
    [NotNullAttribute]
public static ResolveErrorType DYNAMIC;
    [NotNullAttribute]
public static ResolveErrorType IGNORABLE;
    [NotNullAttribute]
public static ResolveErrorType NAMEOF_ARGUMENT;
    [NotNullAttribute]
public static ResolveErrorType NOT_RESOLVED;
    [NotNullAttribute]
public static ResolveErrorType MULTIPLE_CANDIDATES;
    [NotNullAttribute]
public static ResolveErrorType WRONG_NAME_CASE;
    [NotNullAttribute]
public static ResolveErrorType ACCESS_RIGHTS;
    [NotNullAttribute]
public static ResolveErrorType STATIC_PROBLEM;
    [NotNullAttribute]
public static ResolveErrorType NOT_INVOCABLE;
    [NotNullAttribute]
public static ResolveErrorType INCORRECT_PARAMETER_NUMBER;
    [NotNullAttribute]
public static ResolveErrorType INCORRECT_PARAMETER_TYPE;
    [NotNullAttribute]
public static ResolveErrorType INCORRECT_PARAMETER_KIND;
    [NotNullAttribute]
public static ResolveErrorType TYPE_INFERENCE_FAILED;
    [NotNullAttribute]
public static ResolveErrorType TYPE_INFERENCE_CONSTRAINTS_FAILED;
    [NotNullAttribute]
public static ResolveErrorType ARGUMENTS_MISMATCH;
    [NotNullAttribute]
public static ResolveErrorType TYPE_EXPECTED;
    [NotNullAttribute]
public static ResolveErrorType NAMESPACE_EXPECTED;
    [NotNullAttribute]
public static ResolveErrorType INCORRECT_SIGNATURE;
    [NotNullAttribute]
public static ResolveErrorType NOT_VARIABLE;
    [NotNullAttribute]
public static ResolveErrorType IS_NOT_ATTRIBUTE;
    [NotNullAttribute]
public static ResolveErrorType NOT_RESOLVED_IN_DOCCOMMENT;
    [NotNullAttribute]
public static ResolveErrorType INCORRECT_TYPE_PARAMETER_NUMBER;
    [NotNullAttribute]
public static ResolveErrorType CANT_INVOKE_DIRECTLY;
    [NotNullAttribute]
public static ResolveErrorType EMBEDDED_INTEROP_TYPE;
    [NotNullAttribute]
public static ResolveErrorType UNSUPPORTED_TYPE;
    [NotNullAttribute]
public static ResolveErrorType EXPLICIT_IMPLEMENTATION_PROBLEM;
    [NotNullAttribute]
public static ResolveErrorType DECONSTRUCT_METHOD_NOT_FOUND;
    [NotNullAttribute]
public static ResolveErrorType FIXED_PATTERN_METHOD_NOT_FOUND;
    [NotNullAttribute]
public static ResolveErrorType NATIVE_INTEGER_NOT_AVAILABLE;
    [NotNullAttribute]
public static ResolveErrorType OVERLOADING_AMBIGUITY;
    [NotNullAttribute]
public static ResolveErrorType BUILTIN;
    [NotNullAttribute]
public static ResolveErrorType DEREF_SEQUENCE;
    [NotNullAttribute]
public static ResolveErrorType BAD_DEREF_SEQUENCE;
    [NotNullAttribute]
public static ResolveErrorType COPY_ELIDED;
    [NotNullAttribute]
public static ResolveErrorType AGGREGATE_INIT;
    [NotNullAttribute]
public static ResolveErrorType SCALAR_CAST_OR_VALUE_INIT;
    [NotNullAttribute]
public static ResolveErrorType DIFFERENT_OPERATOR;
    [NotNullAttribute]
public static ResolveErrorType REVERSED_ARGUMENTS;
    [NotNullAttribute]
public static ResolveErrorType DEPENDENT_QUALIFIED_MEMBER;
    [DebuggerBrowsableAttribute("0")]
private ResolveErrorType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IResolveInfo.ResolveErrorType { get; }
    public bool IsAcceptable { get; }
    protected ResolveErrorType(string name, bool isAcceptable);
    private static ResolveErrorType();
    private sealed virtual override ResolveErrorType JetBrains.ReSharper.Psi.ExtensionsAPI.Resolve.IResolveInfo.get_ResolveErrorType();
    [CompilerGeneratedAttribute]
public bool get_IsAcceptable();
}
public abstract class JetBrains.ReSharper.Psi.Resolve.ResolveErrorTypeWithTooltip : ResolveErrorType {
    private string myTooltip;
    protected ResolveErrorTypeWithTooltip(string name, string tooltip);
    public virtual string CreateTooltip(IReference reference);
}
public abstract class JetBrains.ReSharper.Psi.Resolve.Resolver : object {
    private ITreeNode myTopElement;
    private ISymbolTable mySymbols;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Stack`1<ValueTuple`2<IDeclaration, IAccessContext>> myAccessContextStack;
    private SymbolTableMode mySymbolTableMode;
    private Stack`1<ScopePair> myScopeStack;
    private IIncrementalScope myCurrentScopeAsIncremental;
    [NotNullAttribute]
protected ISymbolTable SymbolTable { get; }
    protected int Level { get; }
    protected IAccessContext AccessContext { get; }
    public bool ProcessingIsFinished { get; }
    protected Resolver(SymbolTableMode mode);
    public static void UpdateCachedTable(ICachingScope scope, ISymbolTable table, int level, SymbolTableMode mode);
    public void Process(IFile topElement);
    protected virtual void ProcessImpl(ITreeNode topElement);
    public virtual void ProcessBeforeInterior(ITreeNode element);
    private void ProcessScopeBeforeInterior(IScope scope);
    public virtual void ProcessAfterInterior(ITreeNode element);
    protected virtual void AppendTableTable(IScope scope, ISymbolTable table);
    private void PushAccessContext(IDeclaration declaration);
    private void PopAccessContext(IDeclaration declaration);
    protected ISymbolTable get_SymbolTable();
    protected int get_Level();
    protected IAccessContext get_AccessContext();
    protected virtual ValueTuple`2<ISymbolTable, int> GetInitialSymbolTable(SymbolTableMode mode);
    [NotNullAttribute]
protected virtual IAccessContext GetInitialAccessContext();
    protected virtual void VisitElement(ITreeNode element);
    protected virtual bool ScopeShouldBeVisited(IScope scope);
    public virtual bool get_ProcessingIsFinished();
    public sealed virtual bool InteriorShouldBeProcessed(ITreeNode element);
}
public abstract class JetBrains.ReSharper.Psi.Resolve.ResolveResult : CandidatesResolveResult {
    [DebuggerBrowsableAttribute("0")]
[CanBeNullAttribute]
private IDeclaredElement myDeclaredElement;
    public IDeclaredElement DeclaredElement { get; }
    protected ResolveResult(IDeclaredElement element, IList`1<IDeclaredElement> candidates);
    protected ResolveResult(IList`1<IDeclaredElement> candidates);
    public virtual IDeclaredElement get_DeclaredElement();
    public virtual bool IsValid();
}
public abstract class JetBrains.ReSharper.Psi.Resolve.ResolveResultBase : object {
    [CanBeNullAttribute]
public IDeclaredElement DeclaredElement { get; }
    [NotNullAttribute]
public ISubstitution Substitution { get; }
    [NotNullAttribute]
public IList`1<IDeclaredElement> Candidates { get; }
    [NotNullAttribute]
public IList`1<ISubstitution> CandidateSubstitutions { get; }
    public bool IsEmpty { get; }
    public virtual IDeclaredElement get_DeclaredElement();
    public virtual ISubstitution get_Substitution();
    public virtual IList`1<IDeclaredElement> get_Candidates();
    public virtual IList`1<ISubstitution> get_CandidateSubstitutions();
    public virtual bool get_IsEmpty();
    public virtual bool IsValid();
    [NotNullAttribute]
public virtual IResolveResult ReplaceDeclaredElement(IDeclaredElement element);
    [NotNullAttribute]
public virtual IResolveResult ReplaceSubstitution(ISubstitution candidateSubstitution);
    protected static bool AreCandidatesValid(IList`1<IDeclaredElement> candidates);
    protected static bool AreCandidateSubstitutionsValid(IList`1<ISubstitution> candidates);
    [NotNullAttribute]
protected string Dump(bool dumpSubstitutions);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Resolve.ResolveResultExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static void Deconstruct(IResolveResult resolveResult, IDeclaredElement& declaredElement, ISubstitution& substitution);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static DeclaredElementInstance Element(IResolveResult result);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static DeclaredElementInstance`1<TDeclaredElement> Element(IResolveResult result);
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IList`1<DeclaredElementInstance> Elements(IResolveResult result);
    [ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IList`1<DeclaredElementInstance> CandidateElements(IResolveResult result);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IList`1<DeclaredElementInstance`1<TDeclaredElement>> Elements(IResolveResult result);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertIsValid(IResolveResult result, IReference reference);
    [ExtensionAttribute]
public static bool ResolveResultEquals(IResolveResult resolveResult1, IResolveResult resolveResult2);
}
public static class JetBrains.ReSharper.Psi.Resolve.ResolveResultFactory : object {
    [NotNullAttribute]
[PureAttribute]
public static IResolveResult CreateResolveResult(IList`1<IDeclaredElement> candidates);
    [NotNullAttribute]
[PureAttribute]
public static IResolveResult CreateResolveResult(IList`1<IDeclaredElement> candidates, IList`1<ISubstitution> candidateSubstitutions);
    [NotNullAttribute]
[PureAttribute]
public static IResolveResult CreateResolveResult(IDeclaredElement element);
    [NotNullAttribute]
[PureAttribute]
public static IResolveResult CreateResolveResult(ISymbolInfo symbolInfo);
    [NotNullAttribute]
[PureAttribute]
public static IResolveResult CreateResolveResult(IList`1<ISymbolInfo> symbolInfos);
    [NotNullAttribute]
[PureAttribute]
public static IResolveResult CreateResolveResult(IDeclaredElement element, ISubstitution substitution);
    [NotNullAttribute]
[PureAttribute]
public static IResolveResult CreateResolveResult(DeclaredElementInstance elementInstance);
    [NotNullAttribute]
[PureAttribute]
public static IResolveResult CreateResolveResult(IList`1<DeclaredElementInstance> candidateInstances);
    [NotNullAttribute]
[PureAttribute]
public static IResolveResult CreateResolveResultFinally(IList`1<DeclaredElementInstance> elementInstances);
}
public abstract class JetBrains.ReSharper.Psi.Resolve.ResolveResultWithSubstitution : CandidatesResolveResultWithSubstitution {
    [DebuggerBrowsableAttribute("0")]
[CanBeNullAttribute]
private IDeclaredElement myDeclaredElement;
    [DebuggerBrowsableAttribute("0")]
[CanBeNullAttribute]
private ISubstitution mySubstitution;
    public IDeclaredElement DeclaredElement { get; }
    public ISubstitution Substitution { get; }
    protected ResolveResultWithSubstitution(IDeclaredElement element, ISubstitution substitution, IList`1<IDeclaredElement> candidates, IList`1<ISubstitution> candidateSubstitutions);
    protected ResolveResultWithSubstitution(IList`1<IDeclaredElement> candidates, IList`1<ISubstitution> candidateSubstitutions);
    public virtual IDeclaredElement get_DeclaredElement();
    public virtual ISubstitution get_Substitution();
    public virtual bool IsValid();
}
public class JetBrains.ReSharper.Psi.Resolve.SimpleResolveResult : ResolveResultBase {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private IDeclaredElement myDeclaredElement;
    [NotNullAttribute]
public IDeclaredElement DeclaredElement { get; }
    public SimpleResolveResult(IDeclaredElement declaredElement);
    public virtual IDeclaredElement get_DeclaredElement();
    public virtual bool IsValid();
    public virtual string Dump();
    public virtual IResolveResult ReplaceDeclaredElement(IDeclaredElement element);
    public virtual IResolveResult ReplaceSubstitution(ISubstitution candidateSubstitution);
}
public class JetBrains.ReSharper.Psi.Resolve.SimpleResolveResultWithSubstitution : SimpleResolveResult {
    [DebuggerBrowsableAttribute("0")]
[NotNullAttribute]
private ISubstitution mySubstitution;
    public ISubstitution Substitution { get; }
    public SimpleResolveResultWithSubstitution(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ISubstitution get_Substitution();
    public virtual bool IsValid();
    public virtual string Dump();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.Resolve.SimpleSymbolFilter : SimpleSymbolInfoFilter {
    public abstract virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    [DebuggerStepThroughAttribute]
public sealed virtual bool Accepts(ISymbolInfo info);
}
public abstract class JetBrains.ReSharper.Psi.Resolve.SimpleSymbolFilterWithErrorType : SimpleSymbolFilter {
    private ResolveErrorType myErrorType;
    public ResolveErrorType ErrorType { get; }
    protected SimpleSymbolFilterWithErrorType(ResolveErrorType errorType);
    public abstract virtual bool Accepts(IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual ResolveErrorType get_ErrorType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.Resolve.SimpleSymbolInfoFilter : object {
    public FilterRunType RunType { get; }
    public ResolveErrorType ErrorType { get; }
    public virtual FilterRunType get_RunType();
    public virtual bool TryFilterToDestination(List`1<ISymbolInfo> source, List`1<ISymbolInfo> destination);
    public abstract virtual bool Accepts(ISymbolInfo info);
    public abstract virtual ResolveErrorType get_ErrorType();
}
public abstract class JetBrains.ReSharper.Psi.Resolve.StatelessReferenceProviderFactoryBase : object {
    [CompilerGeneratedAttribute]
private ISignal`1<IReferenceProviderFactory> <Changed>k__BackingField;
    [CompilerGeneratedAttribute]
private Action OnChanged;
    public ISignal`1<IReferenceProviderFactory> Changed { get; }
    protected StatelessReferenceProviderFactoryBase(Lifetime lifetime);
    [CompilerGeneratedAttribute]
public sealed virtual ISignal`1<IReferenceProviderFactory> get_Changed();
    public sealed virtual IReferenceFactory CreateFactory(IPsiSourceFile sourceFile, IFile file, IWordIndex wordIndexForChecks);
    [CompilerGeneratedAttribute]
public void add_OnChanged(Action value);
    [CompilerGeneratedAttribute]
public void remove_OnChanged(Action value);
    public virtual bool CheckWords(IWordIndex wordIndex, IPsiSourceFile sourceFile);
    public abstract virtual bool IsApplicableToFile(IPsiSourceFile sourceFile, IFile file);
    protected abstract virtual ReferenceCollection GetReferences(ITreeNode element, ReferenceCollection oldReferences);
    protected abstract virtual bool HasReference(ITreeNode element, IReferenceNameContainer names);
}
public class JetBrains.ReSharper.Psi.Resolve.StaticAccessContext : DefaultAccessContext {
    public StaticAccessContext(ITreeNode node);
    public virtual Staticness GetStaticness();
}
public enum JetBrains.ReSharper.Psi.Resolve.Staticness : Enum {
    public int value__;
    public static Staticness Any;
    public static Staticness OnlyStatic;
    public static Staticness OnlyInstance;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Resolve.SubstitutionExtensions : object {
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsId(ISubstitution substitution);
    [ExtensionAttribute]
public static bool IsIdempotentAll(ISubstitution substitution, IEnumerable`1<ITypeParameter> typeParameter);
    [ExtensionAttribute]
public static bool IsNotIdempotentAll(ISubstitution substitution, IEnumerable`1<ITypeParameter> typeParameter);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsEmpty(ISubstitution substitution);
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsIdOrEmpty(ISubstitution substitution);
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<TType> ApplySubstitution(IEnumerable`1<TType> source, ISubstitution substitution);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static Dictionary`2<ITypeParameter, IType> ToDictionary(ISubstitution substitution);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ISubstitution Replace(ISubstitution substitution, ITypeParameter typeParameter, IType typeArgument);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ISubstitution Reverse(ISubstitution substitution);
}
public class JetBrains.ReSharper.Psi.Resolve.SymbolInfoComparer : object {
    public static IEqualityComparer`1<ISymbolInfo> Ordinal;
    public static IEqualityComparer`1<ISymbolInfo> OrdinalIgnoreCase;
    public static IEqualityComparer`1<ISymbolInfo> ByDeclaredElement;
    [NotNullAttribute]
private StringComparer myComparer;
    private SymbolInfoComparer(StringComparer comparer);
    private static SymbolInfoComparer();
    public virtual bool Equals(ISymbolInfo x, ISymbolInfo y);
    public virtual int GetHashCode(ISymbolInfo obj);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Resolve.SymbolInfoExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ISymbolInfo Substitute(ISymbolInfo info, ISubstitution substitution);
    [ExtensionAttribute]
public static void Deconstruct(ISymbolInfo info, IDeclaredElement& declaredElement, ISubstitution& substitution);
}
public static class JetBrains.ReSharper.Psi.Resolve.SymbolTableBuilder : object {
    [PureAttribute]
[NotNullAttribute]
public static ISymbolTable GetTable(ITreeNode element);
    [PureAttribute]
[NotNullAttribute]
public static ISymbolTable GetTable(ITreeNode element, SymbolTableMode mode);
    [PureAttribute]
public static ValueTuple`2<ISymbolTable, int> GetInnerTableAndLevel(ITreeNode element, SymbolTableMode mode);
    [PureAttribute]
[NotNullAttribute]
private static Stack`1<IScope> GetScopeStack(ITreeNode element, SymbolTableMode mode, bool includeThis, Pair`2& ceedTable);
    [PureAttribute]
private static ValueTuple`2<ISymbolTable, int> WalkScopeStack(ITreeNode element, int level, SymbolTableMode mode, bool includeThis);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Resolve.SymbolTableExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IList`1<ISymbolInfo> GetAllSymbolInfos(ISymbolTable table);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ISymbolTable Distinct(ISymbolTable table, IEqualityComparer`1<ISymbolInfo> comparer);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ISymbolTable Substitute(ISymbolTable table, ISubstitution substitution);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ResolveResultWithInfo GetResolveResult(ISymbolTable this, string name);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static ISymbolTable Merge(ISymbolTable table1, ISymbolTable table2);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static ISymbolTable Merge(IEnumerable`1<ISymbolTable> tables, ISymbolTable seed);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static ISymbolTable Filter(ISymbolTable table, string name, ISymbolFilter[] filters);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static ISymbolTable Filter(ISymbolTable table, string name, IList`1<ISymbolFilter> filters);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static ISymbolTable Filter(ISymbolTable table, ISymbolFilter filter);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static ISymbolTable Filter(ISymbolTable table, ISymbolFilter[] filters);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static String[] DumpShortNames(ISymbolTable table);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void TransformInplace(List`1<T> source, TState state, Func`3<T, TState, T> transform);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void TransformTailInplace(List`1<T> list, TState state, int startIndex, Func`3<T, TState, T> transform);
    [ExtensionAttribute]
[PureAttribute]
public static IList`1<ISymbolInfo> FilterArray(ISymbolFilter symbolFilter, IList`1<ISymbolInfo> source);
}
public abstract class JetBrains.ReSharper.Psi.Resolve.SymbolTableMode : object {
    [CompilerGeneratedAttribute]
private string <name>P;
    [NotNullAttribute]
public static SymbolTableMode TYPE_AND_NAMESPACES;
    [NotNullAttribute]
public static SymbolTableMode FULL;
    protected SymbolTableMode(string name);
    private static SymbolTableMode();
    public virtual string ToString();
    public abstract virtual bool Accepts(SymbolTableMode mode);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.KnownLanguage", "16")]
public class JetBrains.ReSharper.Psi.Resolve.TypeInference.CLRTypeInferenceMatcher : TypeInferenceMatcher {
    public static CLRTypeInferenceMatcher Instance;
    private static CLRTypeInferenceMatcher();
}
public class JetBrains.ReSharper.Psi.Resolve.TypeInference.ExactConsumer : object {
    [CanBeNullAttribute]
private IReadOnlyCollection`1<ITypeParameter> myInferableTypeParameters;
    [CanBeNullAttribute]
private Dictionary`2<ITypeParameter, IType> myResult;
    public Dictionary`2<ITypeParameter, IType> Result { get; }
    public bool IsEmpty { get; }
    [NotNullAttribute]
public ISubstitution InferredResult { get; }
    public ExactConsumer(IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters);
    public Dictionary`2<ITypeParameter, IType> get_Result();
    public bool AllTypeParametersFixed();
    public bool get_IsEmpty();
    [NotNullAttribute]
public Dictionary`2<ITypeParameter, IType> GetResultOrCreateEmpty();
    public sealed virtual bool Assign(ITypeParameter parameter, TypeInferenceBound bound);
    public sealed virtual bool Accept(ITypeParameter typeParameter);
    [NotNullAttribute]
public sealed virtual ITypeInferenceConsumer GetNextConsumer();
    public ISubstitution get_InferredResult();
    public bool ContainsKey(ITypeParameter typeParameter);
}
public interface JetBrains.ReSharper.Psi.Resolve.TypeInference.ITypeInferenceBoundsSolver {
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<ISubstitution> Solve(IList`1<Dictionary`2<ITypeParameter, TypeInferenceBoundsSet>> typeBounds, ITypeConversionRule conversionRule);
    public abstract virtual ISubstitution SolveLikeResolve(IList`1<Dictionary`2<ITypeParameter, TypeInferenceBoundsSet>> typeBounds, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ITypeConversionRule conversionRule);
}
public interface JetBrains.ReSharper.Psi.Resolve.TypeInference.ITypeInferenceConsumer {
    public abstract virtual bool Assign(ITypeParameter typeParameter, TypeInferenceBound bound);
    public abstract virtual bool Accept(ITypeParameter typeParameter);
    public abstract virtual ITypeInferenceConsumer GetNextConsumer();
}
public interface JetBrains.ReSharper.Psi.Resolve.TypeInference.ITypeInferenceMatcher {
    public abstract virtual bool Match(TypeInferenceKind inferenceKind, IType actualType, IType formalTypeWithVariables, ITypeInferenceConsumer consumer);
}
public class JetBrains.ReSharper.Psi.Resolve.TypeInference.RecursiveConsumer : object {
    private IReadOnlyCollection`1<ITypeParameter> myTypeParameters;
    [NotNullAttribute]
private List`1<RecursiveConsumer> myChildrenConsumers;
    [NotNullAttribute]
private Dictionary`2<ITypeParameter, TypeInferenceBoundsSet> myResult;
    public RecursiveConsumer(IReadOnlyCollection`1<ITypeParameter> typeParameters);
    public sealed virtual ITypeInferenceConsumer GetNextConsumer();
    public sealed virtual bool Assign(ITypeParameter typeParameter, TypeInferenceBound bound);
    public bool RegisterNullOrDefaultArgument(ITypeParameter typeParameter, bool annotation);
    public sealed virtual bool Accept(ITypeParameter typeParameter);
    [NotNullAttribute]
public IList`1<Dictionary`2<ITypeParameter, TypeInferenceBoundsSet>> Constraints();
}
public static class JetBrains.ReSharper.Psi.Resolve.TypeInference.TypeEquationsSolver : object {
    [NotNullAttribute]
public static IReadOnlyList`1<ISubstitution> SolveSubtypingForTo(PsiLanguageType language, IType from, IType to, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParametersOfTo, ITypeConversionRule conversionRule);
    [NotNullAttribute]
public static IReadOnlyList`1<ISubstitution> SolveSubtypingForFrom(PsiLanguageType language, IType from, IType to, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParametersOfFrom, ITypeConversionRule conversionRule);
    [NotNullAttribute]
private static IReadOnlyList`1<ISubstitution> Solve(PsiLanguageType language, IType actualType, IType formalType, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, TypeInferenceKind boundKind, ITypeConversionRule typeConversionRule);
    [NotNullAttribute]
private static IList`1<Dictionary`2<ITypeParameter, TypeInferenceBoundsSet>> GetConstraints(TypeInferenceKind boundKind, IType actualType, IType formalType, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters);
    [NotNullAttribute]
public static IList`1<Dictionary`2<ITypeParameter, TypeInferenceBoundsSet>> GetSubtypingConstraintsForTo(IType from, IType to, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParametersOfTo);
    [NotNullAttribute]
public static IList`1<Dictionary`2<ITypeParameter, TypeInferenceBoundsSet>> GetSubtypingConstraintsForFrom(IType from, IType to, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParametersOfFrom);
    [NotNullAttribute]
public static IDictionary`2<ITypeParameter, IType> GetEqualityConstraints(IType actualType, IType formalType, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters);
    [CanBeNullAttribute]
public static ISubstitution SolveEquality(IType actualType, IType formalType, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Resolve.TypeInference.TypeInferenceBound : ValueType {
    [CompilerGeneratedAttribute]
private TypeInferenceKind <BoundKind>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    public TypeInferenceKind BoundKind { get; }
    [NotNullAttribute]
public IType Type { get; }
    public TypeInferenceBound(IType type, IType formalParameterType, TypeInferenceKind boundKind);
    [CompilerGeneratedAttribute]
public TypeInferenceKind get_BoundKind();
    [CompilerGeneratedAttribute]
public IType get_Type();
    public bool Equals(TypeInferenceBound other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Accept(IType type, ITypeConversionRule conversionRule, IEqualityComparer`1<IType> typeComparer);
    [CompilerGeneratedAttribute]
internal static bool <.ctor>g__IsNullableOnly|0_0(IType type);
}
public class JetBrains.ReSharper.Psi.Resolve.TypeInference.TypeInferenceBoundsSet : object {
    [CompilerGeneratedAttribute]
private ISet`1<TypeInferenceBound> <Bounds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustAllowNullOrDefaultLiteral>k__BackingField;
    [NotNullAttribute]
public ISet`1<TypeInferenceBound> Bounds { get; }
    public bool MustAllowNullOrDefaultLiteral { get; public set; }
    public TypeInferenceBoundsSet(TypeInferenceBoundsSet clone);
    [CompilerGeneratedAttribute]
public ISet`1<TypeInferenceBound> get_Bounds();
    [CompilerGeneratedAttribute]
public bool get_MustAllowNullOrDefaultLiteral();
    [CompilerGeneratedAttribute]
public void set_MustAllowNullOrDefaultLiteral(bool value);
}
public enum JetBrains.ReSharper.Psi.Resolve.TypeInference.TypeInferenceKind : Enum {
    public int value__;
    public static TypeInferenceKind Exact;
    public static TypeInferenceKind LowerBound;
    public static TypeInferenceKind LowerBoundPredefined;
    public static TypeInferenceKind UpperBound;
    public static TypeInferenceKind UpperBoundPredefined;
}
public abstract class JetBrains.ReSharper.Psi.Resolve.TypeInference.TypeInferenceMatcher : object {
    public virtual bool Match(TypeInferenceKind inferenceKind, IType actualType, IType formalTypeWithVariables, ITypeInferenceConsumer consumer);
    [PureAttribute]
private static TypeInferenceKind PredefinedKind(TypeInferenceKind inferenceKind);
    private TypeParameterVariance InferenceToTypeParameterVariance(TypeInferenceKind inferenceKind);
    [NotNullAttribute]
[ItemNotNullAttribute]
private static IList`1<IDeclaredType> ModuloReferenceTypeNullabilityDifferences(IList`1<IDeclaredType> interfaces, TypeParameterVariance variance);
    private static IType To(TypeInferenceKind inferenceKind, IType actualType, IType formalType);
    private static IType From(TypeInferenceKind inferenceKind, IType actualType, IType formalType);
    private static ISubstitution ActualSubstitution(TypeInferenceKind inferenceKind, ISubstitution fromSubstitution, ISubstitution toSubstitution);
    private static ISubstitution FormalSubstitution(TypeInferenceKind inferenceKind, ISubstitution fromSubstitution, ISubstitution toSubstitution);
    protected virtual TypeInferenceKind NextKind(TypeInferenceKind inferenceKind, ITypeParameter typeParameter, IType typeArgument, bool isArray);
    protected TypeInferenceKind Opposite(TypeInferenceKind inferenceKind);
    protected virtual bool HasTypeParameters(IType type, ITypeInferenceConsumer consumer);
    protected virtual IList`1<IDeclaredType> GetSuperType(TypeInferenceKind inferenceKind, IType fromType, ITypeElement toTypeElement, Boolean& isArray);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Resolve.TypeInference.TypeInferenceMatcherExtension : object {
    [ExtensionAttribute]
public static bool Match(ITypeInferenceMatcher matcher, IType actualType, IType formalType, ITypeInferenceConsumer consumer, bool subtypingOk);
}
public static class JetBrains.ReSharper.Psi.Resolve.TypeInference.TypeInferenceUtil : object {
    public static bool ValidatePartialInferenceResultAgainstConstraints(ITypeConstraintsVerifier typeConstraintsVerifier, ISubstitution result);
    public static bool TypeParametersAreInferrable(TMethodLike method);
    public static bool ValidateInferenceResultAgainstConstraints(ITypeConstraintsVerifier typeConstraintsVerifier, ISubstitution inferredSubstitution);
    public static bool ValidateInferenceResultAgainstConstraints(ITypeConstraintsVerifier typeConstraintsVerifier, ISubstitution constraintsSubstitution, ISubstitution inferredSubstitution);
    private static void RemoveReferred(IType type, ICollection`1<ITypeParameter> typeParameters);
    [CanBeNullAttribute]
public static ISubstitution GetExplicitExtendedSubstitution(ITypeParametersOwner element, ISubstitution substitution, IList`1<IType> typeArguments);
    [NotNullAttribute]
public static IReadOnlyList`1<ITypeParameter> GetIdTypeParameters(IMethod method, ISubstitution substitution);
    [CanBeNullAttribute]
[PureAttribute]
public static ISubstitution InferTypes(PsiLanguageType language, IType argumentType, IType parameterType, IReadOnlyCollection`1<ITypeParameter> inferrableTypeParameters, ITypeConversionRule conversionRule);
    [CanBeNullAttribute]
private static ISubstitution SolveDefaultWay(IList`1<Dictionary`2<ITypeParameter, TypeInferenceBoundsSet>> typeBounds, ITypeConversionRule conversionRule);
    [CanBeNullAttribute]
private static IDictionary`2<ITypeParameter, IType> SolveSingleSolution(OneToSetMap`2<ITypeParameter, TypeInferenceBound> solution, ITypeConversionRule conversionRule);
    [NotNullAttribute]
public static ICollection`1<IType> SolveTypeInferenceBounds(ICollection`1<TypeInferenceBound> bounds, ITypeConversionRule conversionRule);
}
public class JetBrains.ReSharper.Psi.Resolve.TypeMemberAccessContext : object {
    [NotNullAttribute]
private ITypeMember myTypeMember;
    [CanBeNullAttribute]
private IPsiSourceFile mySourceFile;
    public TypeMemberAccessContext(ITypeMember typeMember, IPsiSourceFile sourceFile);
    public sealed virtual ITypeElement GetAccessContainingTypeElement();
    public sealed virtual Staticness GetStaticness();
    public sealed virtual QualifierKind GetQualifierKind();
    public sealed virtual ITypeElement GetQualifierTypeElement();
    public sealed virtual IPsiModule GetPsiModule();
    public sealed virtual IPsiSourceFile GetSourceFile();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Resolve.ValidNamesFilter : SimpleSymbolInfoFilter {
    [NullableAttribute("2")]
private LanguageService myLanguageService;
    public ResolveErrorType ErrorType { get; }
    public FilterRunType RunType { get; }
    public ValidNamesFilter(PsiLanguageType languageType);
    public virtual bool Accepts(ISymbolInfo info);
    public virtual ResolveErrorType get_ErrorType();
    public virtual FilterRunType get_RunType();
}
public class JetBrains.ReSharper.Psi.Resolve.WebResolveErrorType : ResolveErrorTypeWithTooltip {
    public static ResolveErrorType INVALID_DIRECTIVE;
    public static ResolveErrorType PATH_OUTSIDE_WEBSITE;
    public static ResolveErrorType EXTENSION_MISMATCH;
    public static ResolveErrorType[] PathErrors;
    public WebResolveErrorType(string name, string tooltip);
    private static WebResolveErrorType();
}
public class JetBrains.ReSharper.Psi.Resources.PsiSymbolsThemedIcons : object {
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public static class JetBrains.ReSharper.Psi.Resources.Strings : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string AccessorImplementationKindSettingDescription { get; }
    public static string AddSpacesAroundWhenWritingToANewEditorConfigSettingDescription { get; }
    public static string AlignEvenIfTheResultingIndentationIsTooLargeSettingDescription { get; }
    public static string AnnotationNamespacesSettingDescription { get; }
    public static string AnyField_PresentableName_Text { get; }
    public static string AutoDetectIndentSizeAndIndentStyleSettingDescription { get; }
    public static string AutoImportSettingsSettingDescription { get; }
    public static string AverageLineLengthThresholdAfterWhichAnalysisIsNotRunUnlessExplicitlySpecifiedByUserIEMinimizedJavascriptsKeyIsLanguageValueIsFileSizeInCharactersSettingDescription { get; }
    public static string BlockListMaskSettingDescription { get; }
    public static string ClassOrRecord_PresentableName_Text { get; }
    public static string CodeAnnotationSettingsSettingDescription { get; }
    public static string CodeFormatterSettingsSettingDescription { get; }
    public static string CommonFormatterSettingsSettingDescription { get; }
    public static string ContinuousLineIndentMultiplierSettingDescription { get; }
    public static string CouldNotChangeANamingPolicyMaybeItWas_Text { get; }
    public static string DebuggerStepThroughAccessorsSettingDescription { get; }
    public static string DefaultFileHeaderSettingDescription { get; }
    public static string DefaultLineEndingStyleSettingDescription { get; }
    public static string DefaultNameForExceptionVariableSettingDescription { get; }
    public static string DefaultNamespaceSettingDescription { get; }
    public static string Delegate_PresentableName_Text { get; }
    public static string DisableAlignInColumnsSettingDescription { get; }
    public static string DisableBlankLineChangesSettingDescription { get; }
    public static string DisableFormatterInGeneralSettingDescription { get; }
    public static string DisableIndenterSettingDescription { get; }
    public static string DisableLineBreakChangesSettingDescription { get; }
    public static string DisableLineBreakRemovalSettingDescription { get; }
    public static string DisableSpaceChangesSettingDescription { get; }
    public static string DocumentationGenerationKindSettingDescription { get; }
    public static string ECMAScriptRegularExpression_Text { get; }
    public static string EditorconfigGeneratedCodeSettingDescription { get; }
    public static string EnableClangFormatSupportSettingDescription { get; }
    public static string EnabledSettingDescription { get; }
    public static string EnableEditorConfigSupportSettingDescription { get; }
    public static string EnableStyleCopSupportSettingDescription { get; }
    public static string EnforceLineEndingStyleOnFullReformatSettingDescription { get; }
    public static string EnumMember_PresentableName_Text { get; }
    public static string Enum_PresentableName_Text { get; }
    public static string EventHandlerNamePatternLongVersionWithObjectNameSettingDescription { get; }
    public static string EventHandlerNamePatternSettingDescription { get; }
    public static string Event_PresentableName_Text { get; }
    public static string ExperimentalElementMessage { get; }
    public static string ExtensionMethod_PresentableName_Text { get; }
    public static string ExtraSpacesInsideSettingDescription { get; }
    public static string FieldConstant_PresentableName_Text { get; }
    public static string FileHeaderRegionNameSettingDescription { get; }
    public static string FileHeaderRegexSettingDescription { get; }
    public static string FileHeaderTextSettingDescription { get; }
    public static string FileHeaderVariablesSettingDescription { get; }
    public static string FileHeaderDecorationSettingDescription { get; }
    public static string GenericSQL { get; }
    public static string NativeVisualStudioHighlighting { get; }
    public static string UnknownElement_Text { get; }
    public static string Interface_PresentableName_Text { get; }
    public static string Label_PresentableName_Text { get; }
    public static string LocalConstant_PresentableName_Text { get; }
    public static string LocalVariablesAndConstants_PresentableName_Text { get; }
    public static string LocalVariable_PresentableName_Text { get; }
    public static string Method_PresentableName_Text { get; }
    public static string Namespace_PresentableName_Text { get; }
    public static string Parameter_PresentableName_Text { get; }
    public static string Property_PresentableName_Text { get; }
    public static string ReadonlyField_PresentableName_Text { get; }
    public static string RouteTemplate_Text { get; }
    public static string SimpleField_PresentableName_Text { get; }
    public static string Struct_PresentableName_Text { get; }
    public static string TypeMember_PresentableName_Text { get; }
    public static string TypeParameter_PresentableName_Text { get; }
    public static string Type_PresentableName_Text { get; }
    public static string Unknown_Text { get; }
    public static string Unknown_PresentableName_Text { get; }
    public static string UseStyleCopStyleXmlHeaderSettingDescription { get; }
    public static string FileMasksToSkipSettingDescription { get; }
    public static string SourceGeneratedFilesToSkipSettingDescription { get; }
    public static string FilesAndFoldersToSkipSettingDescription { get; }
    public static string FilesExcludedFromCodeAnalysisSettingDescription { get; }
    public static string FilesSizeThresholdAfterWhichAnalysisIsNotRunUnlessExplicitlySpecifiedByUserKeyIsLanguageValueIsFileSizeInCharactersSettingDescription { get; }
    public static string FilesSizeThresholdAfterWhichPSIIsNotBuiltKeyIsLanguageValueIsFileSizeInCharactersSettingDescription { get; }
    public static string FixColumnAlignmentInAdjacentLinesSettingDescription { get; }
    public static string FormatLeadingFileSpacesViaDeclarativeFormatterSettingDescription { get; }
    public static string FullyQualifiedImportsSettingDescription { get; }
    public static string GeneratedCodeDetectionSettingDescription { get; }
    public static string GeneratedCodeRegionsSettingDescription { get; }
    public static string GeneratedFilesAndFoldersToSkipSettingDescription { get; }
    public static string GeneratedFilesCacheSettingsSettingDescription { get; }
    public static string GeneratedFilesCacheTimestampSettingDescription { get; }
    public static string GeneratedFilesMaskSettingDescription { get; }
    public static string GuidSettingDescription { get; }
    public static string HardWrapAtSettingDescription { get; }
    public static string HowToAlignWhenTabsAreUsedForIndentsSettingDescription { get; }
    public static string IgnoredPathsRelativeToProjectLocationSettingDescription { get; }
    public static string IndentSizeSettingDescription { get; }
    public static string IndentStyleSettingDescription { get; }
    public static string KeepUserWrappingSettingDescription { get; }
    public static string LanguageInjectionsSettingDescription { get; }
    public static string LineFeedAtEndOfFileSettingDescription { get; }
    public static string ListOfAbbreviationsSettingDescription { get; }
    public static string ListOfNamingRulesSettingDescription { get; }
    public static string MapFromUpperCasedPathsToProperlyCasedSettingDescription { get; }
    public static string MappedPathsRelativeToProjectLocationSettingDescription { get; }
    public static string MaximumPSITreeDepthUsedToPreventStackOverflowExceptionSettingDescription { get; }
    public static string MemberGenerationSettingsSettingDescription { get; }
    public static string MethodImplementationKindSettingDescription { get; }
    public static string NamingSettingsSettingDescription { get; }
    public static string PathMappingsInWebProjectSettingDescription { get; }
    public static string PlaceBackingFieldAbovePropertySettingDescription { get; }
    public static string PropagateAnnotationsSettingDescription { get; }
    public static string ProvideReSharperIndentSettingsToVisualStudioSettingDescription { get; }
    public static string ReadConfigFilesAboveSolutionLevelSettingDescription { get; }
    public static string RemoveSpacesOnBlankLines { get; }
    public static string SettingsForFormatConfigurationFilesSettingDescription { get; }
    public static string ShouldAutoDetectedRulesBeAppliedSettingDescription { get; }
    public static string ShouldTriggerStyleCopSeverityConverters { get; }
    public static string ShowAutodetectAndConfigureFormattingTipSettingDescription { get; }
    public static string ShowIndicatorInStatusBarWhenEditorConfigIsPresentSettingDescription { get; }
    public static string SpecifiesWhetherFilesShouldBeCheckedForBeingCompressedKeyIsLanguageIfValueItIstrueSettingDescription { get; }
    public static string SpecifiesWhetherFilesShouldIndexedForTextSearchDescription { get; }
    public static string SupportVisualStudioEventNamingPatternSettingDescription { get; }
    public static string TabWidthSettingDescription { get; }
    public static string ThresholdsToDisablePSIOrAnalysisInTheSakeOfPerformanceReasonsSettingDescription { get; }
    public static string UseIndentSettingsFromMainLanguageInFileAsVisualStudioDoesSettingDescription { get; }
    public static string UseIndentStyleAndSizeFromVisualStudioSettingDescription { get; }
    public static string UsePreviousElementsIndentOnPartialFormatSettingDescription { get; }
    public static string WarnAboutUsingPrefixesAndSuffixesFromThisRule { get; }
    public static string WindowsExperimentalElementMessage { get; }
    public static string WrapGeneratedMembersInRegionSettingDescription { get; }
    public static string WrapLongLinesSettingDescription { get; }
    public static string StyleCopRulesSourceSettingDescription { get; }
    public static string ExcludedFilesSettingsKey_SourceGeneratedFilesSweaEnabled_Description { get; }
    public static string MergingAssembliesIndex_Text { get; }
    public static string LoadingCaches_Text { get; }
    public static string PredefinedExcludedFilesSettings_Text { get; }
    public static string PredefinedGeneratedCodeSettings_Text { get; }
    public static string Indenting_Text { get; }
    public static string Formatting_Text { get; }
    public static string AligningInColumns_Text { get; }
    public static string ExternalConfigurationFiles_Text { get; }
    public static string ScanningFile__Text { get; }
    public static string ScanningAssembly__Text { get; }
    public static string DefaultPerformanceThresholdSettings_Text { get; }
    public static string ProcessingAssemblies_Text { get; }
    public static string RemovingAssemblies_Text { get; }
    public static string ProcessingSourceFiles_Text { get; }
    public static string SavingCaches_Text { get; }
    public static string ProcessingFiles_Text { get; }
    public static string InitialFileProcessing_Text { get; }
    public static string MakingBlankLines_Text { get; }
    public static string DetectingWrapLimit_Text { get; }
    public static string FailedToAddNuGetPackage_Text { get; }
    public static string Project_LoadFinishedWithWarnings_Text { get; }
    public static string TheSameFileIsListedIn_MultipleTimes_Text { get; }
    public static string Solution_Text { get; }
    public static string Cancel_Text { get; }
    public static string Color_Text { get; }
    public static string __IsObsolete_Text { get; }
    public static string ExternalDependencyFile_Text { get; }
    public static string FileIsBinary_Text { get; }
    public static string FileSizeExceedsThresholdItMightBeAdjusted_Text { get; }
    public static string FileBelongsToExcludedProject_Text { get; }
    public static string SourceGeneratorOutputFile_Text { get; }
    public static string FileFromNuGetPackage__Text { get; }
    public static string ContentFileFromNuGetPackage_Text { get; }
    public static string FileWithExtension_Expected_Text { get; }
    public static string _DirectiveIsNotAllowedIn_File_Text { get; }
    public static string PathIsOutsideOfTheWebsite_ToolTip { get; }
    public static string PathIgnored_ToolTip { get; }
    public static string PathMapped_ToolTip { get; }
    public static string SyntaxError_Text { get; }
    public static string SearchScope_Empty_Text { get; }
    public static string SearchScope_UnknownSearchDomain_Text { get; }
    public static string ComplexSearchDomain_Text { get; }
    public static string _DummyElements_Text { get; }
    public static string SearchScope_Solution_Text { get; }
    public static string SearchScope_SolutionAndLibraries_Text { get; }
    public static string SearchScope_ReferencedLibraries_Text { get; }
    public static string Assembly__Text { get; }
    public static string Project__Text { get; }
    public static string File__Text { get; }
    public static string File___Text { get; }
    public static string Element_In___Text { get; }
    public static string NamedElementKinds_TypesAndNamespaces { get; }
    public static string NamedElementKinds_Interfaces { get; }
    public static string NamedElementKinds_TypeParameters { get; }
    public static string NamedElementKinds_Method { get; }
    public static string NamedElementKinds_Property { get; }
    public static string NamedElementKinds_Event { get; }
    public static string NamedElementKinds_Locals { get; }
    public static string NamedElementKinds_LocalConstants { get; }
    public static string NamedElementKinds_Parameters { get; }
    public static string NamedElementKinds_Constants { get; }
    public static string NamedElementKinds_PrivateConstants { get; }
    public static string NamedElementKinds_StaticReadonly { get; }
    public static string NamedElementKinds_PrivateStaticReadonly { get; }
    public static string NamedElementKinds_PublicFields { get; }
    public static string NamedElementKinds_EnumMember { get; }
    public static string NamedElementKinds_PrivateStaticFields { get; }
    public static string NamedElementKinds_PrivateInstanceFields { get; }
    public static string NamedElementKinds_LocalFunctions { get; }
    public static string NamedElementKinds_Other { get; }
    public static string ChunkedMarkAsDirtySettingsKeyDescription { get; }
    public static string ChunkSizeDescription { get; }
    public static string ScheduleNextChunkTimeoutMs { get; }
    public static string Align_Description_Text { get; }
    public static string AlignExceptWhenNested_Description_Text { get; }
    public static string Always_Description_Text { get; }
    public static string Apostrophe_Description_Text { get; }
    public static string Quote_Description_Text { get; }
    public static string AtEndOfLineKRStyle_Description_Text { get; }
    public static string AtEndOfLineNoSpace_Description_Text { get; }
    public static string AtNextLineBSDStyle_Description_Text { get; }
    public static string AtNextLineIndented2GNUStyle_Description_Text { get; }
    public static string AtNextLineIndentedWhitesmithsStyle_Description_Text { get; }
    public static string ChopAlways_Description_Text { get; }
    public static string ChopIfLongOrMultiline_Description_Text { get; }
    public static string ChopInCompactStyle_Description_Text { get; }
    public static string ChopInExistingStyle_Description_Text { get; }
    public static string ChopInExpandedStyle_Description_Text { get; }
    public static string CompactPicoStyle_Description_Text { get; }
    public static string CRLFWindows_Description_Text { get; }
    public static string CRMacOSClassic_Description_Text { get; }
    public static string DoNotChange_Description_Text { get; }
    public static string None_Description_Text { get; }
    public static string Single_Description_Text { get; }
    public static string Double_Description_Text { get; }
    public static string DoNotWrapEvenIfLong_Description_Text { get; }
    public static string ForceLineBreaks_Description_Text { get; }
    public static string ForcePutOnSingleLine_Description_Text { get; }
    public static string IfOwnerIsSingleline_Description_Text { get; }
    public static string IndentAsUsual_Description_Text { get; }
    public static string InsideParenthesisBSDKRStyle_Description_Text { get; }
    public static string LeaveAllExtraSpacesAndTabs_Description_Text { get; }
    public static string LeaveExtraTabs_Description_Text { get; }
    public static string LeaveMultipleExtraSpaces_Description_Text { get; }
    public static string LFUnixMacOSX_Description_Text { get; }
    public static string MixTabsAndSpacesForOptimalFill_Description_Text { get; }
    public static string Never_Description_Text { get; }
    public static string NoAlign_Description_Text { get; }
    public static string NoIndent_Description_Text { get; }
    public static string OnDifferentLines_Description_Text { get; }
    public static string OnlyUseTabsInaccurate_Description_Text { get; }
    public static string Outdent_Description_Text { get; }
    public static string Parenthesis1xInside2xGNUStyle_Description_Text { get; }
    public static string ParenthesisAndInsideEquallyWhitesmithsStyle_Description_Text { get; }
    public static string PlaceBracesTogether_Description_Text { get; }
    public static string RemoveAllExtraSpaces_Description_Text { get; }
    public static string RuleSetFiles_Description_Text { get; }
    public static string SettingsStyleCop_Description_Text { get; }
    public static string SimpleWrap_Description_Text { get; }
    public static string SimpleWrapDoNotChange_Description_Text { get; }
    public static string Spaces_Description_Text { get; }
    public static string SystemDependentNativeForOS_Description_Text { get; }
    public static string Tab_Description_Text { get; }
    public static string TogetherOnTheSameLine_Description_Text { get; }
    public static string UseSpacesLooksAlignedOnAnyTabSize_Description_Text { get; }
    public static string Namespace_Text { get; }
    public static string Class_Text { get; }
    public static string Module_Text { get; }
    public static string TypeParameter_Text { get; }
    public static string Parameter_Text { get; }
    public static string Event_Text { get; }
    public static string Property_Text { get; }
    public static string EnumMember_Text { get; }
    public static string Constant_Text { get; }
    public static string Field_Text { get; }
    public static string Operator_Text { get; }
    public static string Constructor_Text { get; }
    public static string Method_Text { get; }
    public static string Accessor_Text { get; }
    public static string Enum_Text { get; }
    public static string Delegate_Text { get; }
    public static string Struct_Text { get; }
    public static string Interface_Text { get; }
    public static string Path_Text { get; }
    public static string UnknownName_Text { get; }
    public static string Or_Text { get; }
    public static string WindowsFormDesignerGeneratedCode_Text { get; }
    public static string ComponentDesignerGeneratedCode_Text { get; }
    public static string DesignerGeneratedCode_Text { get; }
    public static string WebFormDesignerGeneratedCode_Text { get; }
    public static string InContainerText { get; }
    public static string InContainerBracketsText { get; }
    public static string InContainerKindText { get; }
    public static string InContainerKindBracketsText { get; }
    public static string OfParameterText { get; }
    public static string OfParameterBracketsText { get; }
    public static string AutodetectedSettingsConfigSourceName { get; }
    public static string GlobalAnalyzerConfigConfigSourceName { get; }
    public static string DotNetRegularExpression { get; }
    public static string PathReference { get; }
    public static string UseNewFileHeaderEngineSettingDescription { get; }
    public static string AreStyleCopConversionsTriggeredDescription { get; }
    public static string IsDocumentHeaderParserTriggeredDescription { get; }
    public static string IsIndentationParserTriggeredDescription { get; }
    public static string Sa1633State { get; }
    private static Strings();
    public static JetResourceManager get_ResourceManager();
    public static string Choice(string format, Object[] args);
    public static string get_AccessorImplementationKindSettingDescription();
    public static string get_AddSpacesAroundWhenWritingToANewEditorConfigSettingDescription();
    public static string get_AlignEvenIfTheResultingIndentationIsTooLargeSettingDescription();
    public static string get_AnnotationNamespacesSettingDescription();
    public static string get_AnyField_PresentableName_Text();
    public static string get_AutoDetectIndentSizeAndIndentStyleSettingDescription();
    public static string get_AutoImportSettingsSettingDescription();
    public static string get_AverageLineLengthThresholdAfterWhichAnalysisIsNotRunUnlessExplicitlySpecifiedByUserIEMinimizedJavascriptsKeyIsLanguageValueIsFileSizeInCharactersSettingDescription();
    public static string get_BlockListMaskSettingDescription();
    public static string get_ClassOrRecord_PresentableName_Text();
    public static string get_CodeAnnotationSettingsSettingDescription();
    public static string get_CodeFormatterSettingsSettingDescription();
    public static string get_CommonFormatterSettingsSettingDescription();
    public static string get_ContinuousLineIndentMultiplierSettingDescription();
    public static string get_CouldNotChangeANamingPolicyMaybeItWas_Text();
    public static string get_DebuggerStepThroughAccessorsSettingDescription();
    public static string get_DefaultFileHeaderSettingDescription();
    public static string get_DefaultLineEndingStyleSettingDescription();
    public static string get_DefaultNameForExceptionVariableSettingDescription();
    public static string get_DefaultNamespaceSettingDescription();
    public static string get_Delegate_PresentableName_Text();
    public static string get_DisableAlignInColumnsSettingDescription();
    public static string get_DisableBlankLineChangesSettingDescription();
    public static string get_DisableFormatterInGeneralSettingDescription();
    public static string get_DisableIndenterSettingDescription();
    public static string get_DisableLineBreakChangesSettingDescription();
    public static string get_DisableLineBreakRemovalSettingDescription();
    public static string get_DisableSpaceChangesSettingDescription();
    public static string get_DocumentationGenerationKindSettingDescription();
    public static string get_ECMAScriptRegularExpression_Text();
    public static string get_EditorconfigGeneratedCodeSettingDescription();
    public static string get_EnableClangFormatSupportSettingDescription();
    public static string get_EnabledSettingDescription();
    public static string get_EnableEditorConfigSupportSettingDescription();
    public static string get_EnableStyleCopSupportSettingDescription();
    public static string get_EnforceLineEndingStyleOnFullReformatSettingDescription();
    public static string get_EnumMember_PresentableName_Text();
    public static string get_Enum_PresentableName_Text();
    public static string get_EventHandlerNamePatternLongVersionWithObjectNameSettingDescription();
    public static string get_EventHandlerNamePatternSettingDescription();
    public static string get_Event_PresentableName_Text();
    public static string get_ExperimentalElementMessage();
    public static string get_ExtensionMethod_PresentableName_Text();
    public static string get_ExtraSpacesInsideSettingDescription();
    public static string get_FieldConstant_PresentableName_Text();
    public static string get_FileHeaderRegionNameSettingDescription();
    public static string get_FileHeaderRegexSettingDescription();
    public static string get_FileHeaderTextSettingDescription();
    public static string get_FileHeaderVariablesSettingDescription();
    public static string get_FileHeaderDecorationSettingDescription();
    public static string get_GenericSQL();
    public static string get_NativeVisualStudioHighlighting();
    public static string get_UnknownElement_Text();
    public static string get_Interface_PresentableName_Text();
    public static string get_Label_PresentableName_Text();
    public static string get_LocalConstant_PresentableName_Text();
    public static string get_LocalVariablesAndConstants_PresentableName_Text();
    public static string get_LocalVariable_PresentableName_Text();
    public static string get_Method_PresentableName_Text();
    public static string get_Namespace_PresentableName_Text();
    public static string get_Parameter_PresentableName_Text();
    public static string get_Property_PresentableName_Text();
    public static string get_ReadonlyField_PresentableName_Text();
    public static string get_RouteTemplate_Text();
    public static string get_SimpleField_PresentableName_Text();
    public static string get_Struct_PresentableName_Text();
    public static string get_TypeMember_PresentableName_Text();
    public static string get_TypeParameter_PresentableName_Text();
    public static string get_Type_PresentableName_Text();
    public static string get_Unknown_Text();
    public static string get_Unknown_PresentableName_Text();
    public static string get_UseStyleCopStyleXmlHeaderSettingDescription();
    public static string get_FileMasksToSkipSettingDescription();
    public static string get_SourceGeneratedFilesToSkipSettingDescription();
    public static string get_FilesAndFoldersToSkipSettingDescription();
    public static string get_FilesExcludedFromCodeAnalysisSettingDescription();
    public static string get_FilesSizeThresholdAfterWhichAnalysisIsNotRunUnlessExplicitlySpecifiedByUserKeyIsLanguageValueIsFileSizeInCharactersSettingDescription();
    public static string get_FilesSizeThresholdAfterWhichPSIIsNotBuiltKeyIsLanguageValueIsFileSizeInCharactersSettingDescription();
    public static string get_FixColumnAlignmentInAdjacentLinesSettingDescription();
    public static string get_FormatLeadingFileSpacesViaDeclarativeFormatterSettingDescription();
    public static string get_FullyQualifiedImportsSettingDescription();
    public static string get_GeneratedCodeDetectionSettingDescription();
    public static string get_GeneratedCodeRegionsSettingDescription();
    public static string get_GeneratedFilesAndFoldersToSkipSettingDescription();
    public static string get_GeneratedFilesCacheSettingsSettingDescription();
    public static string get_GeneratedFilesCacheTimestampSettingDescription();
    public static string get_GeneratedFilesMaskSettingDescription();
    public static string get_GuidSettingDescription();
    public static string get_HardWrapAtSettingDescription();
    public static string get_HowToAlignWhenTabsAreUsedForIndentsSettingDescription();
    public static string get_IgnoredPathsRelativeToProjectLocationSettingDescription();
    public static string get_IndentSizeSettingDescription();
    public static string get_IndentStyleSettingDescription();
    public static string get_KeepUserWrappingSettingDescription();
    public static string get_LanguageInjectionsSettingDescription();
    public static string get_LineFeedAtEndOfFileSettingDescription();
    public static string get_ListOfAbbreviationsSettingDescription();
    public static string get_ListOfNamingRulesSettingDescription();
    public static string get_MapFromUpperCasedPathsToProperlyCasedSettingDescription();
    public static string get_MappedPathsRelativeToProjectLocationSettingDescription();
    public static string get_MaximumPSITreeDepthUsedToPreventStackOverflowExceptionSettingDescription();
    public static string get_MemberGenerationSettingsSettingDescription();
    public static string get_MethodImplementationKindSettingDescription();
    public static string get_NamingSettingsSettingDescription();
    public static string get_PathMappingsInWebProjectSettingDescription();
    public static string get_PlaceBackingFieldAbovePropertySettingDescription();
    public static string get_PropagateAnnotationsSettingDescription();
    public static string get_ProvideReSharperIndentSettingsToVisualStudioSettingDescription();
    public static string get_ReadConfigFilesAboveSolutionLevelSettingDescription();
    public static string get_RemoveSpacesOnBlankLines();
    public static string get_SettingsForFormatConfigurationFilesSettingDescription();
    public static string get_ShouldAutoDetectedRulesBeAppliedSettingDescription();
    public static string get_ShouldTriggerStyleCopSeverityConverters();
    public static string get_ShowAutodetectAndConfigureFormattingTipSettingDescription();
    public static string get_ShowIndicatorInStatusBarWhenEditorConfigIsPresentSettingDescription();
    public static string get_SpecifiesWhetherFilesShouldBeCheckedForBeingCompressedKeyIsLanguageIfValueItIstrueSettingDescription();
    public static string get_SpecifiesWhetherFilesShouldIndexedForTextSearchDescription();
    public static string get_SupportVisualStudioEventNamingPatternSettingDescription();
    public static string get_TabWidthSettingDescription();
    public static string get_ThresholdsToDisablePSIOrAnalysisInTheSakeOfPerformanceReasonsSettingDescription();
    public static string get_UseIndentSettingsFromMainLanguageInFileAsVisualStudioDoesSettingDescription();
    public static string get_UseIndentStyleAndSizeFromVisualStudioSettingDescription();
    public static string get_UsePreviousElementsIndentOnPartialFormatSettingDescription();
    public static string get_WarnAboutUsingPrefixesAndSuffixesFromThisRule();
    public static string get_WindowsExperimentalElementMessage();
    public static string get_WrapGeneratedMembersInRegionSettingDescription();
    public static string get_WrapLongLinesSettingDescription();
    public static string get_StyleCopRulesSourceSettingDescription();
    public static string get_ExcludedFilesSettingsKey_SourceGeneratedFilesSweaEnabled_Description();
    public static string get_MergingAssembliesIndex_Text();
    public static string get_LoadingCaches_Text();
    public static string get_PredefinedExcludedFilesSettings_Text();
    public static string get_PredefinedGeneratedCodeSettings_Text();
    public static string get_Indenting_Text();
    public static string get_Formatting_Text();
    public static string get_AligningInColumns_Text();
    public static string get_ExternalConfigurationFiles_Text();
    public static string get_ScanningFile__Text();
    public static string get_ScanningAssembly__Text();
    public static string get_DefaultPerformanceThresholdSettings_Text();
    public static string get_ProcessingAssemblies_Text();
    public static string get_RemovingAssemblies_Text();
    public static string get_ProcessingSourceFiles_Text();
    public static string get_SavingCaches_Text();
    public static string get_ProcessingFiles_Text();
    public static string get_InitialFileProcessing_Text();
    public static string get_MakingBlankLines_Text();
    public static string get_DetectingWrapLimit_Text();
    public static string get_FailedToAddNuGetPackage_Text();
    public static string get_Project_LoadFinishedWithWarnings_Text();
    public static string get_TheSameFileIsListedIn_MultipleTimes_Text();
    public static string get_Solution_Text();
    public static string get_Cancel_Text();
    public static string get_Color_Text();
    public static string get___IsObsolete_Text();
    public static string get_ExternalDependencyFile_Text();
    public static string get_FileIsBinary_Text();
    public static string get_FileSizeExceedsThresholdItMightBeAdjusted_Text();
    public static string get_FileBelongsToExcludedProject_Text();
    public static string get_SourceGeneratorOutputFile_Text();
    public static string get_FileFromNuGetPackage__Text();
    public static string get_ContentFileFromNuGetPackage_Text();
    public static string get_FileWithExtension_Expected_Text();
    public static string get__DirectiveIsNotAllowedIn_File_Text();
    public static string get_PathIsOutsideOfTheWebsite_ToolTip();
    public static string get_PathIgnored_ToolTip();
    public static string get_PathMapped_ToolTip();
    public static string get_SyntaxError_Text();
    public static string get_SearchScope_Empty_Text();
    public static string get_SearchScope_UnknownSearchDomain_Text();
    public static string get_ComplexSearchDomain_Text();
    public static string get__DummyElements_Text();
    public static string get_SearchScope_Solution_Text();
    public static string get_SearchScope_SolutionAndLibraries_Text();
    public static string get_SearchScope_ReferencedLibraries_Text();
    public static string get_Assembly__Text();
    public static string get_Project__Text();
    public static string get_File__Text();
    public static string get_File___Text();
    public static string get_Element_In___Text();
    public static string get_NamedElementKinds_TypesAndNamespaces();
    public static string get_NamedElementKinds_Interfaces();
    public static string get_NamedElementKinds_TypeParameters();
    public static string get_NamedElementKinds_Method();
    public static string get_NamedElementKinds_Property();
    public static string get_NamedElementKinds_Event();
    public static string get_NamedElementKinds_Locals();
    public static string get_NamedElementKinds_LocalConstants();
    public static string get_NamedElementKinds_Parameters();
    public static string get_NamedElementKinds_Constants();
    public static string get_NamedElementKinds_PrivateConstants();
    public static string get_NamedElementKinds_StaticReadonly();
    public static string get_NamedElementKinds_PrivateStaticReadonly();
    public static string get_NamedElementKinds_PublicFields();
    public static string get_NamedElementKinds_EnumMember();
    public static string get_NamedElementKinds_PrivateStaticFields();
    public static string get_NamedElementKinds_PrivateInstanceFields();
    public static string get_NamedElementKinds_LocalFunctions();
    public static string get_NamedElementKinds_Other();
    public static string get_ChunkedMarkAsDirtySettingsKeyDescription();
    public static string get_ChunkSizeDescription();
    public static string get_ScheduleNextChunkTimeoutMs();
    public static string get_Align_Description_Text();
    public static string get_AlignExceptWhenNested_Description_Text();
    public static string get_Always_Description_Text();
    public static string get_Apostrophe_Description_Text();
    public static string get_Quote_Description_Text();
    public static string get_AtEndOfLineKRStyle_Description_Text();
    public static string get_AtEndOfLineNoSpace_Description_Text();
    public static string get_AtNextLineBSDStyle_Description_Text();
    public static string get_AtNextLineIndented2GNUStyle_Description_Text();
    public static string get_AtNextLineIndentedWhitesmithsStyle_Description_Text();
    public static string get_ChopAlways_Description_Text();
    public static string get_ChopIfLongOrMultiline_Description_Text();
    public static string get_ChopInCompactStyle_Description_Text();
    public static string get_ChopInExistingStyle_Description_Text();
    public static string get_ChopInExpandedStyle_Description_Text();
    public static string get_CompactPicoStyle_Description_Text();
    public static string get_CRLFWindows_Description_Text();
    public static string get_CRMacOSClassic_Description_Text();
    public static string get_DoNotChange_Description_Text();
    public static string get_None_Description_Text();
    public static string get_Single_Description_Text();
    public static string get_Double_Description_Text();
    public static string get_DoNotWrapEvenIfLong_Description_Text();
    public static string get_ForceLineBreaks_Description_Text();
    public static string get_ForcePutOnSingleLine_Description_Text();
    public static string get_IfOwnerIsSingleline_Description_Text();
    public static string get_IndentAsUsual_Description_Text();
    public static string get_InsideParenthesisBSDKRStyle_Description_Text();
    public static string get_LeaveAllExtraSpacesAndTabs_Description_Text();
    public static string get_LeaveExtraTabs_Description_Text();
    public static string get_LeaveMultipleExtraSpaces_Description_Text();
    public static string get_LFUnixMacOSX_Description_Text();
    public static string get_MixTabsAndSpacesForOptimalFill_Description_Text();
    public static string get_Never_Description_Text();
    public static string get_NoAlign_Description_Text();
    public static string get_NoIndent_Description_Text();
    public static string get_OnDifferentLines_Description_Text();
    public static string get_OnlyUseTabsInaccurate_Description_Text();
    public static string get_Outdent_Description_Text();
    public static string get_Parenthesis1xInside2xGNUStyle_Description_Text();
    public static string get_ParenthesisAndInsideEquallyWhitesmithsStyle_Description_Text();
    public static string get_PlaceBracesTogether_Description_Text();
    public static string get_RemoveAllExtraSpaces_Description_Text();
    public static string get_RuleSetFiles_Description_Text();
    public static string get_SettingsStyleCop_Description_Text();
    public static string get_SimpleWrap_Description_Text();
    public static string get_SimpleWrapDoNotChange_Description_Text();
    public static string get_Spaces_Description_Text();
    public static string get_SystemDependentNativeForOS_Description_Text();
    public static string get_Tab_Description_Text();
    public static string get_TogetherOnTheSameLine_Description_Text();
    public static string get_UseSpacesLooksAlignedOnAnyTabSize_Description_Text();
    public static string get_Namespace_Text();
    public static string get_Class_Text();
    public static string get_Module_Text();
    public static string get_TypeParameter_Text();
    public static string get_Parameter_Text();
    public static string get_Event_Text();
    public static string get_Property_Text();
    public static string get_EnumMember_Text();
    public static string get_Constant_Text();
    public static string get_Field_Text();
    public static string get_Operator_Text();
    public static string get_Constructor_Text();
    public static string get_Method_Text();
    public static string get_Accessor_Text();
    public static string get_Enum_Text();
    public static string get_Delegate_Text();
    public static string get_Struct_Text();
    public static string get_Interface_Text();
    public static string get_Path_Text();
    public static string get_UnknownName_Text();
    public static string get_Or_Text();
    public static string get_WindowsFormDesignerGeneratedCode_Text();
    public static string get_ComponentDesignerGeneratedCode_Text();
    public static string get_DesignerGeneratedCode_Text();
    public static string get_WebFormDesignerGeneratedCode_Text();
    public static string get_InContainerText();
    public static string get_InContainerBracketsText();
    public static string get_InContainerKindText();
    public static string get_InContainerKindBracketsText();
    public static string get_OfParameterText();
    public static string get_OfParameterBracketsText();
    public static string get_AutodetectedSettingsConfigSourceName();
    public static string get_GlobalAnalyzerConfigConfigSourceName();
    public static string get_DotNetRegularExpression();
    public static string get_PathReference();
    public static string get_UseNewFileHeaderEngineSettingDescription();
    public static string get_AreStyleCopConversionsTriggeredDescription();
    public static string get_IsDocumentHeaderParserTriggeredDescription();
    public static string get_IsIndentationParserTriggeredDescription();
    public static string get_Sa1633State();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public class JetBrains.ReSharper.Psi.Resources.W3CEntities : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
public static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static UnmanagedMemoryStream Stream { get; }
    public static ResourceManager get_ResourceManager();
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static UnmanagedMemoryStream get_Stream();
}
public class JetBrains.ReSharper.Psi.RetryingAsyncCommitClient : object {
    [CompilerGeneratedAttribute]
private Action`1<Lifetime> <OnCommited>k__BackingField;
    private string myName;
    private Lifetime myLifetime;
    private AsyncCommitService myAsyncCommitService;
    public Action`1<Lifetime> OnCommited { get; public set; }
    public RetryingAsyncCommitClient(string name, Action`1<Lifetime> onCommited, Lifetime lifetime, AsyncCommitService asyncCommitService);
    [CompilerGeneratedAttribute]
public Action`1<Lifetime> get_OnCommited();
    [CompilerGeneratedAttribute]
public void set_OnCommited(Action`1<Lifetime> value);
    public virtual string ToString();
    public sealed virtual Action BeforeCommit();
    public sealed virtual void OnInterrupt();
    public void Run();
    public bool RunIfNotYet();
    [CompilerGeneratedAttribute]
private void <BeforeCommit>b__9_0();
    [CompilerGeneratedAttribute]
private void <Run>b__11_0();
    [CompilerGeneratedAttribute]
private void <Run>b__11_1();
}
public enum JetBrains.ReSharper.Psi.SandBoxContextType : Enum {
    public int value__;
    public static SandBoxContextType Replace;
    public static SandBoxContextType Child;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.SandBoxExtensions : object {
    [ExtensionAttribute]
public static void SetResolveContextForSandBox(ITreeNode node, ITreeNode context, SandBoxContextType contextType);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITreeNode GetParentNode(ISandBox holder);
}
public enum JetBrains.ReSharper.Psi.ScopedKind : Enum {
    public byte value__;
    public static ScopedKind None;
    public static ScopedKind ScopedRef;
    public static ScopedKind ScopedValue;
}
public class JetBrains.ReSharper.Psi.Search.ConstantExpressionDomainSpecificSearcher`1 : object {
    private ConstantValue myConstantValue;
    private bool myOnlyLiteralExpression;
    public ConstantExpressionDomainSpecificSearcher`1(ConstantValue constantValue, bool onlyLiteralExpression);
    public sealed virtual bool ProcessProjectItem(IPsiSourceFile sourceFile, IFindResultConsumer`1<TResult> consumer);
    public sealed virtual bool ProcessElement(ITreeNode element, IFindResultConsumer`1<TResult> consumer);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Search.ConstantExpressionDomainSpecificSearcher`1/<GetCandidateExpressions>d__5")]
private IEnumerable`1<IExpression> GetCandidateExpressions(ITreeNode element);
}
public class JetBrains.ReSharper.Psi.Search.CustomAttributeTargetPosition : TargetPositionBase {
    [CompilerGeneratedAttribute]
private MetadataToken <ParentToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IConstructor <AttributeConstructor>k__BackingField;
    private string myAttributeName;
    public MetadataToken ParentToken { get; }
    [CanBeNullAttribute]
public IConstructor AttributeConstructor { get; }
    [CanBeNullAttribute]
public string AttributeName { get; }
    public CustomAttributeTargetPosition(int index, MetadataToken parentToken, IConstructor attributeConstructor);
    [CompilerGeneratedAttribute]
public MetadataToken get_ParentToken();
    [CompilerGeneratedAttribute]
public IConstructor get_AttributeConstructor();
    public string get_AttributeName();
    public virtual int CompareTo(ITargetPosition other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CustomAttributeTargetPosition other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Search.DeclaredElementSearchExtensions : object {
    private static ILogger ourLog;
    private static DeclaredElementSearchExtensions();
    [ExtensionAttribute]
[NotNullAttribute]
public static ISearchDomain GetSearchDomain(IDeclaredElement declaredElement, bool includeRelated);
    [ExtensionAttribute]
[NotNullAttribute]
public static ISearchDomain UnionSearchDomains(IEnumerable`1<IDeclaredElement> declaredElements);
}
public class JetBrains.ReSharper.Psi.Search.DllImportAttributeTargetPosition : TargetPositionBase {
    public DllImportAttributeTargetPosition(int index);
}
public class JetBrains.ReSharper.Psi.Search.ElementsSearchDomainNode : object {
    [CompilerGeneratedAttribute]
private List`1<ITreeNode> <Elements>k__BackingField;
    [NotNullAttribute]
public List`1<ITreeNode> Elements { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public ElementsSearchDomainNode(IEnumerable`1<ITreeNode> elements);
    [CompilerGeneratedAttribute]
public List`1<ITreeNode> get_Elements();
    public int get_Count();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual ElementsSearchDomainNode Clone();
    [NotNullAttribute]
public sealed virtual ElementsSearchDomainNode Intersect(ElementsSearchDomainNode otherNode);
    private bool Contains(ITreeNode element);
    public sealed virtual bool Contains(ElementsSearchDomainNode otherNode);
    public sealed virtual void Accept(SearchDomainVisitor visitor);
    public sealed virtual bool HasIntersectionWith(IDeclaredElement declaredElement);
    public sealed virtual void Dump(TextWriter output, int indent);
    public sealed virtual ElementsSearchDomainNode Union(ElementsSearchDomainNode otherNode);
    public void AddElement(ITreeNode element);
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Search.EntityFrameworkMigrationsSearchFilter : object {
    [NotNullAttribute]
public static IClrTypeName DB_CONTEXT_TYPE;
    private static ILogger ourLog;
    private static Regex ourGeneratedMigrationName;
    public SearchFilterKind Kind { get; }
    private static EntityFrameworkMigrationsSearchFilter();
    public sealed virtual SearchFilterKind get_Kind();
    public sealed virtual object TryGetKey(IDeclaredElement declaredElement);
    public sealed virtual bool IsAvailable(SearchPattern pattern);
    public sealed virtual bool CanContainReferences(IPsiSourceFile sourceFile, object key);
    private static bool IsGeneratedMigrationFile(IPsiSourceFile sourceFile);
}
public class JetBrains.ReSharper.Psi.Search.FilteringResultConsumer`1 : object {
    [NotNullAttribute]
private IFindResultConsumer`1<T> myConsumer;
    [NotNullAttribute]
private Func`2<FindResult, FindResult> myTransformer;
    public FilteringResultConsumer`1(IFindResultConsumer`1<T> consumer, Func`2<FindResult, FindResult> transformer);
    public sealed virtual T Build(FindResult result);
    public sealed virtual FindExecution Merge(T data);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Search.FinderExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[MustUseReturnValueAttribute]
public static ITypeElement[] FindImmediateInheritors(IFinder finder, ITypeElement typeElement, ISearchDomain searchDomain, IProgressIndicator pi);
    [ExtensionAttribute]
[NotNullAttribute]
[MustUseReturnValueAttribute]
public static ITypeElement[] FindImmediateInheritors(IFinder finder, ITypeElement typeElement, IProgressIndicator pi);
    [ExtensionAttribute]
[NotNullAttribute]
[MustUseReturnValueAttribute]
public static IReference[] FindReferences(IFinder finder, ICollection`1<T> elements, ISearchDomain domain, IProgressIndicator pi, bool includeDynamic);
    [ExtensionAttribute]
[NotNullAttribute]
[MustUseReturnValueAttribute]
public static IReference[] FindReferences(IFinder finder, IDeclaredElement element, ISearchDomain domain, IProgressIndicator pi, bool includeDynamic);
    [ExtensionAttribute]
[NotNullAttribute]
[MustUseReturnValueAttribute]
public static IReference[] FindAllReferences(IFinder finder, IDeclaredElement element, bool includeDynamic);
    [CanBeNullAttribute]
private static ISubstitution CalculateInheritedSubstitution(ITypeElement typeElement, ISubstitution substitution, ITypeElement inheritor, ISubstitution ancestorSubstitution);
    [ExtensionAttribute]
[ObsoleteAttribute("this method is incorrect because base type substitition applied to a derived class has no sense")]
public static void FindInheritors(IFinder finder, IDeclaredType type, Func`2<IDeclaredType, FindExecution> consumer, ISearchDomain searchDomain, IProgressIndicator pi);
    [ExtensionAttribute]
[NotNullAttribute]
[MustUseReturnValueAttribute]
public static IDeclaredType[] FindAllInheritors(IFinder finder, IDeclaredType type, IProgressIndicator progress);
    [ExtensionAttribute]
public static void FindImplementingMembers(IFinder finder, IOverridableMember overridableMember, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, bool searchQuasi, IProgressIndicator pi);
    [ExtensionAttribute]
public static void FindImmediateImplementingMembers(IFinder finder, IOverridableMember overridableMember, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, bool searchQuasi, IProgressIndicator pi);
    [ExtensionAttribute]
[MustDisposeResourceAttribute]
internal static ITaskBarrier CreateTaskBarrier(Finder finder);
}
public enum JetBrains.ReSharper.Psi.Search.FindExecution : Enum {
    public int value__;
    public static FindExecution Continue;
    public static FindExecution Stop;
}
public abstract class JetBrains.ReSharper.Psi.Search.FindResult : object {
    [CompilerGeneratedAttribute]
private FindResult <MasterResult>k__BackingField;
    public FindResult MasterResult { get; internal set; }
    [CompilerGeneratedAttribute]
public FindResult get_MasterResult();
    [CompilerGeneratedAttribute]
internal void set_MasterResult(FindResult value);
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Search.FindResultAnonymousType : FindResult {
    private ITreeNode myElement;
    [NotNullAttribute]
public ITreeNode Element { get; }
    public FindResultAnonymousType(ITreeNode element);
    public ITreeNode get_Element();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Search.FindResultAssemblyAttribute : FindResult {
    private IPsiAssemblyFile myPsiAssemblyFile;
    private IDeclaredElement myTarget;
    [CompilerGeneratedAttribute]
private CustomAttributeTargetPosition <TargetPosition>k__BackingField;
    [NotNullAttribute]
public IPsiAssemblyFile PsiAssemblyFile { get; }
    [NotNullAttribute]
public IDeclaredElement Target { get; }
    public CustomAttributeTargetPosition TargetPosition { get; }
    public FindResultAssemblyAttribute(IPsiAssemblyFile psiAssemblyFile, IDeclaredElement target, CustomAttributeTargetPosition targetPosition);
    public IPsiAssemblyFile get_PsiAssemblyFile();
    public IDeclaredElement get_Target();
    [CompilerGeneratedAttribute]
public CustomAttributeTargetPosition get_TargetPosition();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Search.FindResultColor : FindResultText {
    public FindResultColor(IColorReference colorReference);
    private static DocumentRange ColorConstantValue(IColorReference colorReference);
}
public class JetBrains.ReSharper.Psi.Search.FindResultConsumer : FindResultConsumer`1<FindResult> {
    public FindResultConsumer(Func`2<FindResult, FindExecution> merge);
}
public class JetBrains.ReSharper.Psi.Search.FindResultConsumer`1 : object {
    [NotNullAttribute]
private Func`2<FindResult, T> myBuild;
    [NotNullAttribute]
private Func`2<T, FindExecution> myMerge;
    public FindResultConsumer`1(Func`2<FindResult, T> build, Func`2<T, FindExecution> merge);
    public sealed virtual T Build(FindResult result);
    public sealed virtual FindExecution Merge(T data);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Search.FindResultConsumerExtensions : object {
    [ExtensionAttribute]
public static FindExecution Accept(IFindResultConsumer`1<TResult> consumer, FindResult result);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IFindResultConsumer`1<TReference> ConsumeReferences(ICollection`1<TReference> collection);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IFindResultConsumer`1<TDeclaredElement> ConsumeFilteredDeclaredElements(ICollection`1<TDeclaredElement> collection, Func`2<TDeclaredElement, bool> predicate);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IFindResultConsumer`1<TDeclaredElement> ConsumeDeclaredElements(ICollection`1<TDeclaredElement> collection);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IFindResultConsumer`1<TDeclaredElement> ConsumeDeclaredElements(ICollection`1<TResult> collection, Func`2<TDeclaredElement, TResult> converter);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IFindResultConsumer`1<TExpression> ConsumeExpressions(ICollection`1<TExpression> collection);
}
public class JetBrains.ReSharper.Psi.Search.FindResultDeclaration : FindResultText {
    private IDeclaredElement myDeclaredElement;
    private PsiLanguageType myLanguageType;
    private TreeTextRange myNameRange;
    private IPsiSourceFile mySourceFile;
    [NotNullAttribute]
public IDeclaredElement DeclaredElement { get; }
    [CanBeNullAttribute]
public IDeclaration Declaration { get; }
    public FindResultDeclaration(IDeclaredElement element, IDeclaration declaration, DocumentRange range);
    public IDeclaredElement get_DeclaredElement();
    public IDeclaration get_Declaration();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Search.FindResultDeclaredElement : FindResult {
    private IDeclaredElement myDeclaredElement;
    [NotNullAttribute]
public IDeclaredElement DeclaredElement { get; }
    public FindResultDeclaredElement(IDeclaredElement declaredElement);
    public IDeclaredElement get_DeclaredElement();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Search.FindResultDefaultConstructorInvocation : FindResultDeclaredElement {
    public FindResultDefaultConstructorInvocation(IDeclaredElement declaredElement);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Search.FindResultExpression : FindResult {
    private IExpression myExpression;
    [NotNullAttribute]
public IExpression Expression { get; }
    public FindResultExpression(IExpression expression);
    public IExpression get_Expression();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Search.FindResultInheritedElement : FindResultDeclaredElement {
    private InheritanceKind myKind;
    public InheritanceKind Kind { get; }
    public FindResultInheritedElement(IDeclaredElement declaredElement, InheritanceKind kind);
    public InheritanceKind get_Kind();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Search.FindResultLateBoundReference : FindResult {
    private ILateBoundReference myReference;
    private IDeclaredElement myDeclaredElement;
    public IDeclaredElement DeclaredElement { get; }
    private IReference JetBrains.ReSharper.Psi.Search.IFindResultReference.Reference { get; }
    private IDeclaredElement JetBrains.ReSharper.Psi.Search.IFindResultWithTarget.Target { get; }
    public ILateBoundReference Reference { get; }
    public FindResultLateBoundReference(ILateBoundReference reference, IDeclaredElement declaredElement);
    public sealed virtual IDeclaredElement get_DeclaredElement();
    private sealed virtual override IReference JetBrains.ReSharper.Psi.Search.IFindResultReference.get_Reference();
    private sealed virtual override IDeclaredElement JetBrains.ReSharper.Psi.Search.IFindResultWithTarget.get_Target();
    public ILateBoundReference get_Reference();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Search.FindResultLibraryReference : FindResultDeclaredElement {
    [CompilerGeneratedAttribute]
private IDeclaredElement <SearchingTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private SearchTargetRole <Role>k__BackingField;
    [CompilerGeneratedAttribute]
private ITargetPosition <TargetPosition>k__BackingField;
    [CanBeNullAttribute]
public IDeclaredElement SearchingTarget { get; }
    public SearchTargetRole Role { get; }
    [NotNullAttribute]
public ITargetPosition TargetPosition { get; }
    private IDeclaredElement JetBrains.ReSharper.Psi.Search.IFindResultWithTarget.Target { get; }
    public FindResultLibraryReference(IDeclaredElement declaredElement, SearchTargetRole role, ITargetPosition targetPosition, IDeclaredElement searchingTarget);
    [CompilerGeneratedAttribute]
public IDeclaredElement get_SearchingTarget();
    [CompilerGeneratedAttribute]
public SearchTargetRole get_Role();
    [CompilerGeneratedAttribute]
public ITargetPosition get_TargetPosition();
    private sealed virtual override IDeclaredElement JetBrains.ReSharper.Psi.Search.IFindResultWithTarget.get_Target();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Search.FindResultOverridableMember : FindResultInheritedElement {
    private ITypeElement myQuasiBasis;
    [CompilerGeneratedAttribute]
private ISubstitution <SubstitutionOfBaseMember>k__BackingField;
    public IOverridableMember OverridableMember { get; }
    public ISubstitution SubstitutionOfBaseMember { get; }
    public ITypeElement QuasiBasisElement { get; }
    public FindResultOverridableMember(IOverridableMember member, ISubstitution substitution, ITypeElement quasiBasis, InheritanceKind kind);
    public IOverridableMember get_OverridableMember();
    [CompilerGeneratedAttribute]
public ISubstitution get_SubstitutionOfBaseMember();
    public ITypeElement get_QuasiBasisElement();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Search.FindResultReference : FindResult {
    [CompilerGeneratedAttribute]
private IDeclaredElement <DeclaredElement>k__BackingField;
    [CompilerGeneratedAttribute]
private IReference <Reference>k__BackingField;
    public IDeclaredElement DeclaredElement { get; }
    public IReference Reference { get; }
    private IDeclaredElement JetBrains.ReSharper.Psi.Search.IFindResultWithTarget.Target { get; }
    public FindResultReference(IReference reference);
    public FindResultReference(IReference reference, IDeclaredElement declaredElement);
    [CompilerGeneratedAttribute]
public sealed virtual IDeclaredElement get_DeclaredElement();
    [CompilerGeneratedAttribute]
public sealed virtual IReference get_Reference();
    private sealed virtual override IDeclaredElement JetBrains.ReSharper.Psi.Search.IFindResultWithTarget.get_Target();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Search.FindResultReferenceExtensions : object {
    [ExtensionAttribute]
public static ReferenceAccessType GetAccessType(IFindResultReference reference);
    [ExtensionAttribute]
public static EventAccessType GetEventAccessType(IFindResultReference reference);
}
public class JetBrains.ReSharper.Psi.Search.FindResultText : FindResult {
    private DocumentRange myDocumentRange;
    private IPsiSourceFile mySourceFile;
    public ISolution Solution { get; }
    public DocumentRange DocumentRange { get; }
    public IPsiSourceFile SourceFile { get; }
    public FindResultText(IPsiSourceFile sourceFile, DocumentRange documentRange);
    public ISolution get_Solution();
    public DocumentRange get_DocumentRange();
    public IPsiSourceFile get_SourceFile();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface JetBrains.ReSharper.Psi.Search.IFinder {
    public ISolution Solution { get; }
    public SearchDomainFactory SearchDomainFactory { get; }
    public IWordIndex WordIndex { get; }
    public IReadOnlyList`1<ISearchFilter> SearchFilters { get; }
    public IReadOnlyList`1<IDomainSpecificSearcherFactory> DomainSpecificSearcherFactories { get; }
    public abstract virtual ISolution get_Solution();
    public abstract virtual SearchDomainFactory get_SearchDomainFactory();
    public abstract virtual IWordIndex get_WordIndex();
    public abstract virtual IReadOnlyList`1<ISearchFilter> get_SearchFilters();
    public abstract virtual IReadOnlyList`1<IDomainSpecificSearcherFactory> get_DomainSpecificSearcherFactories();
    public abstract virtual void FindReferences(IDeclaredElement element, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi, bool includeDynamic);
    public abstract virtual void FindReferences(IDeclaredElement element, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi, bool includeDynamic, bool onlyExplicitlyTyped);
    public abstract virtual void FindReferencesAsync(IDeclaredElement element, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi, bool includeDynamic, IFinderAsyncCallback callback);
    public abstract virtual void FindReferences(ICollection`1<TElement> elements, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi, bool includeDynamic);
    public abstract virtual void FindReferencesAsync(ICollection`1<TElement> elements, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi, bool includeDynamic, IFinderAsyncCallback callback);
    public abstract virtual void FindInheritors(ITypeElement typeElement, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi);
    public abstract virtual void FindInheritors(ITypeElement typeElement, ISymbolScope scope, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi);
    public abstract virtual void FindImmediateInheritors(ITypeElement typeElement, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi);
    public abstract virtual void FindImplementingMembers(IOverridableMember member, ITypeElement originType, ISubstitution originSubstitution, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, SearchImplementorsPattern pattern, IProgressIndicator pi);
    public abstract virtual void FindMethodsReferencedByDelegate(IDelegate delegate, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi);
    public abstract virtual void FindTextOccurrences(string subject, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi);
    public abstract virtual void Find(ICollection`1<IDeclaredElement> elements, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, SearchPattern pattern, IProgressIndicator pi, IFinderSearchRoot root);
    public abstract virtual void FindAsync(ICollection`1<IDeclaredElement> elements, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, SearchPattern pattern, IProgressIndicator pi, IFinderSearchRoot root, IFinderAsyncCallback callback);
    public abstract virtual IDeclaredElement[] FindImmediateBaseElements(IDeclaredElement declaredElement, IProgressIndicator progress, bool searchQuasi);
    public abstract virtual void FindAnonymousTypes(IList`1<AnonymousTypeDescriptor> signature, ISearchDomain domain, IFindResultConsumer`1<TResult> consumer, bool caseSensitive, IProgressIndicator pi);
    public abstract virtual ICollection`1<RelatedDeclaredElement> GetRelatedElements(IDeclaredElement element);
    public abstract virtual IList`1<TElement> FindExpressionOccurrences(TElement expression, ITreeNode scope);
    public abstract virtual IOccurrencesComparer GetOccurrencesComparer(ITreeNode element);
    public abstract virtual void FindConstantExpressions(ConstantValue constantValue, bool onlyLiteral, ISearchDomain searchDomain, IFindResultConsumer`1<TResult> consumer, IProgressIndicator pi);
    public abstract virtual void FindDeclarations(IDeclaredElement declaredElement, IProgressIndicator progressIndicator, IFindResultConsumer`1<TResult> consumer);
}
public interface JetBrains.ReSharper.Psi.Search.IFindResultConsumer`1 {
    public abstract virtual T Build(FindResult result);
    public abstract virtual FindExecution Merge(T data);
}
public interface JetBrains.ReSharper.Psi.Search.IFindResultReference {
    [CanBeNullAttribute]
public IDeclaredElement DeclaredElement { get; }
    [NotNullAttribute]
public IReference Reference { get; }
    public abstract virtual IDeclaredElement get_DeclaredElement();
    public abstract virtual IReference get_Reference();
}
public interface JetBrains.ReSharper.Psi.Search.IFindResultWithTarget {
    [CanBeNullAttribute]
public IDeclaredElement Target { get; }
    public abstract virtual IDeclaredElement get_Target();
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.Search.IObjectCreationSearchService {
    public abstract virtual bool IsApplicable(IPsiSourceFile sourceFile);
    public abstract virtual bool CanContainConstructorInvocation(IPsiSourceFile sourceFile, IConstructor constructor);
}
public interface JetBrains.ReSharper.Psi.Search.IOccurrencesComparer {
    public abstract virtual bool CompareWith(ITreeNode element);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.Search.IParameterSearchLanguageService {
    public abstract virtual HybridCollection`1<IPsiSourceFile> GetScope(IParameter parameter);
}
public interface JetBrains.ReSharper.Psi.Search.ISearchDomain {
    public bool IsEmpty { get; }
    public bool HasPhysicalPart { get; }
    public abstract virtual bool get_IsEmpty();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISearchDomain Intersect(ISearchDomain otherDomain);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISearchDomain Union(ISearchDomain otherDomain);
    public abstract virtual bool Contains(ISearchDomain otherDomain);
    public abstract virtual bool HasIntersectionWith(IDeclaredElement declaredElement);
    public abstract virtual void Accept(SearchDomainVisitor visitor);
    public abstract virtual void Dump(TextWriter to);
    public abstract virtual bool get_HasPhysicalPart();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISearchDomain ExtractLibraryDomain();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISearchDomain ExtractNonPhysicalDomain();
    public abstract virtual bool IsValid();
}
public interface JetBrains.ReSharper.Psi.Search.ISearchDomainNode`1 {
    public bool IsEmpty { get; }
    public abstract virtual bool get_IsEmpty();
    [NotNullAttribute]
public abstract virtual TSelf Clone();
    [CanBeNullAttribute]
public abstract virtual TSelf Intersect(TSelf otherNode);
    [NotNullAttribute]
public abstract virtual TSelf Union(TSelf otherNode);
    public abstract virtual bool Contains(TSelf otherNode);
    public abstract virtual void Accept(SearchDomainVisitor visitor);
    public abstract virtual bool HasIntersectionWith(IDeclaredElement declaredElement);
    public abstract virtual void Dump(TextWriter output, int indent);
}
public interface JetBrains.ReSharper.Psi.Search.ITargetPosition {
    public int Index { get; }
    public TargetPositionKind Kind { get; }
    public abstract virtual int get_Index();
    public abstract virtual TargetPositionKind get_Kind();
}
public class JetBrains.ReSharper.Psi.Search.MethodBodyTargetPosition : TargetPositionBase {
    public MethodBodyTargetPosition(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PsiComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Search.ParameterSearchFilter : object {
    [CompilerGeneratedAttribute]
private NamedArgumentCache <namedArgumentCache>P;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IObjectCreationSearchService> <objectCreationSearchServices>P;
    public SearchFilterKind Kind { get; }
    public ParameterSearchFilter(NamedArgumentCache namedArgumentCache, IEnumerable`1<IObjectCreationSearchService> objectCreationSearchServices);
    public sealed virtual SearchFilterKind get_Kind();
    public sealed virtual bool IsAvailable(SearchPattern pattern);
    public sealed virtual object TryGetKey(IDeclaredElement declaredElement);
    public sealed virtual bool CanContainReferences(IPsiSourceFile sourceFile, object key);
    public bool CanContainReferences(IPsiSourceFile sourceFile, object key, string newParameterName);
    private bool CanContainConstructorInvocation(IPsiSourceFile sourceFile, IConstructor constructor);
}
public class JetBrains.ReSharper.Psi.Search.PsiModuleSearchDomainNode : object {
    [CompilerGeneratedAttribute]
private IPsiModule <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<IPsiSourceFile, PsiSourceFileSearchDomainNode> <PsiSourceFiles>k__BackingField;
    [NotNullAttribute]
public IPsiModule Module { get; }
    [CanBeNullAttribute]
public Dictionary`2<IPsiSourceFile, PsiSourceFileSearchDomainNode> PsiSourceFiles { get; private set; }
    [MemberNotNullWhenAttribute("False", "PsiSourceFiles")]
public bool WholePsiModule { get; }
    public bool IsEmpty { get; }
    public PsiModuleSearchDomainNode(IPsiModule module);
    public PsiModuleSearchDomainNode(IPsiSourceFile sourceFile);
    [CompilerGeneratedAttribute]
public IPsiModule get_Module();
    [CompilerGeneratedAttribute]
public Dictionary`2<IPsiSourceFile, PsiSourceFileSearchDomainNode> get_PsiSourceFiles();
    [CompilerGeneratedAttribute]
private void set_PsiSourceFiles(Dictionary`2<IPsiSourceFile, PsiSourceFileSearchDomainNode> value);
    [MemberNotNullWhenAttribute("False", "PsiSourceFiles")]
public bool get_WholePsiModule();
    public sealed virtual PsiModuleSearchDomainNode Intersect(PsiModuleSearchDomainNode otherNode);
    public sealed virtual PsiModuleSearchDomainNode Union(PsiModuleSearchDomainNode otherNode);
    public sealed virtual bool Contains(PsiModuleSearchDomainNode otherNode);
    public sealed virtual void Accept(SearchDomainVisitor visitor);
    public sealed virtual bool HasIntersectionWith(IDeclaredElement declaredElement);
    public sealed virtual void Dump(TextWriter output, int indent);
    public sealed virtual bool get_IsEmpty();
    public sealed virtual PsiModuleSearchDomainNode Clone();
}
public class JetBrains.ReSharper.Psi.Search.PsiSourceFileSearchDomainNode : object {
    private IPsiSourceFile mySourceFile;
    [CompilerGeneratedAttribute]
private ElementsSearchDomainNode <Elements>k__BackingField;
    public ElementsSearchDomainNode Elements { get; public set; }
    public IPsiSourceFile SourceFile { get; }
    public bool WholePsiSourceFile { get; }
    public bool IsEmpty { get; }
    public PsiSourceFileSearchDomainNode(IPsiSourceFile sourceFile);
    [CompilerGeneratedAttribute]
public ElementsSearchDomainNode get_Elements();
    [CompilerGeneratedAttribute]
public void set_Elements(ElementsSearchDomainNode value);
    public IPsiSourceFile get_SourceFile();
    public bool get_WholePsiSourceFile();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual PsiSourceFileSearchDomainNode Clone();
    public sealed virtual PsiSourceFileSearchDomainNode Intersect(PsiSourceFileSearchDomainNode otherNode);
    public sealed virtual PsiSourceFileSearchDomainNode Union(PsiSourceFileSearchDomainNode otherNode);
    public sealed virtual bool Contains(PsiSourceFileSearchDomainNode otherNode);
    public sealed virtual void Accept(SearchDomainVisitor visitor);
    public sealed virtual bool HasIntersectionWith(IDeclaredElement declaredElement);
    public sealed virtual void Dump(TextWriter output, int indent);
}
public class JetBrains.ReSharper.Psi.Search.RootSearchDomainNode : object {
    private Dictionary`2<IPsiModule, PsiModuleSearchDomainNode> myPsiModules;
    [CompilerGeneratedAttribute]
private ISolution <Solution>k__BackingField;
    private ElementsSearchDomainNode mySandBoxElementsNode;
    [CompilerGeneratedAttribute]
private TrivialType <Trivial>k__BackingField;
    [CanBeNullAttribute]
public ISolution Solution { get; private set; }
    public bool IsTrivial { get; }
    internal TrivialType Trivial { get; internal set; }
    public bool IsEmpty { get; }
    public bool HasPhysicalPart { get; }
    [CanBeNullAttribute]
public IDictionary`2<IPsiModule, PsiModuleSearchDomainNode> PsiModules { get; }
    public ElementsSearchDomainNode SandBoxElementsNode { get; }
    internal RootSearchDomainNode(ISolution solution, TrivialType domain);
    [CompilerGeneratedAttribute]
public ISolution get_Solution();
    [CompilerGeneratedAttribute]
private void set_Solution(ISolution value);
    public bool get_IsTrivial();
    [CompilerGeneratedAttribute]
internal TrivialType get_Trivial();
    [CompilerGeneratedAttribute]
internal void set_Trivial(TrivialType value);
    public sealed virtual bool get_IsEmpty();
    public bool get_HasPhysicalPart();
    public sealed virtual RootSearchDomainNode Clone();
    [NotNullAttribute]
public sealed virtual RootSearchDomainNode Intersect(RootSearchDomainNode otherNode);
    public sealed virtual RootSearchDomainNode Union(RootSearchDomainNode otherNode);
    [NotNullAttribute]
public RootSearchDomainNode ExtractNonPhysical();
    [NotNullAttribute]
public RootSearchDomainNode ExtractLibrary();
    public sealed virtual bool HasIntersectionWith(IDeclaredElement declaredElement);
    public sealed virtual void Accept(SearchDomainVisitor visitor);
    public sealed virtual void Dump(TextWriter output, int indent);
    public sealed virtual bool Contains(RootSearchDomainNode otherNode);
    public bool Contains(IPsiModule module);
    private bool ContainsModules(RootSearchDomainNode otherNode);
    public IDictionary`2<IPsiModule, PsiModuleSearchDomainNode> get_PsiModules();
    public ElementsSearchDomainNode get_SandBoxElementsNode();
    public Dictionary`2<IPsiModule, PsiModuleSearchDomainNode> TransformToPsiModulesList();
    private void VisitTrivial(Func`2<IPsiModule, bool> visit);
    private void VisitTrivial(Action`1<IPsiModule> visit);
    public bool IsAssemblyModule(IPsiModule psiModule);
    public void AddSandboxElement(ITreeNode element);
    [CompilerGeneratedAttribute]
internal static void <Intersect>g__IntersectTrivial|20_0(RootSearchDomainNode trivial, RootSearchDomainNode nonTrivial, <>c__DisplayClass20_0& );
}
public class JetBrains.ReSharper.Psi.Search.SearchAction : object {
    private IFinder myFinder;
    private IDeclaredElement myDeclaredElement;
    private IFindResultConsumer`1<FindResult> myConsumer;
    private SearchPattern mySearchPattern;
    private ISearchDomain mySearchDomain;
    public Func`2<IProgressIndicator, object> Task { get; }
    public SearchAction(IFinder finder, IDeclaredElement declaredElement, IFindResultConsumer`1<FindResult> consumer, SearchPattern searchPattern);
    private object RunEx(IProgressIndicator pi);
    public Func`2<IProgressIndicator, object> get_Task();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Search.SearchDomainExtensions : object {
    [ExtensionAttribute]
public static string DumpToString(ISearchDomain domain);
    [ExtensionAttribute]
public static ISearchDomain UnionSearchDomains(IEnumerable`1<ISearchDomain> domains);
    [ExtensionAttribute]
public static bool ContainedInSingleProjectFile(ISearchDomain domain);
    [ExtensionAttribute]
public static string GetPresentableDescription(ISearchDomain searchDomain);
}
[DerivedComponentsInstantiationRequirementAttribute("1")]
public abstract class JetBrains.ReSharper.Psi.Search.SearchDomainFactory : object {
    public static SearchDomainFactory Instance { get; }
    public static SearchDomainFactory get_Instance();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISearchDomain CreateSearchDomain(IProjectModelElement item);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISearchDomain CreateSearchDomain(IPsiSourceFile sourceFile);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISearchDomain CreateSearchDomain(IEnumerable`1<IPsiSourceFile> psiSourceFiles);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISearchDomain CreateSearchDomain(HybridCollection`1<IPsiSourceFile> psiSourceFiles);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISearchDomain CreateSearchDomain(IPsiModule module);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISearchDomain CreateSearchDomain(IEnumerable`1<IPsiModule> modules);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISearchDomain CreateLibrariesDomain(ISolution solution);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISearchDomain CreateSearchDomain(ISolution solution, bool includeLibraries);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISearchDomain CreateSearchDomain(ITreeNode sourceElement);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISearchDomain CreateSearchDomain(IEnumerable`1<ITreeNode> sourceElements);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISearchDomain CreatePublicAccessibilityDomain(IPsiModule module);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISearchDomain CreatePublicAccessibilityDomain(IEnumerable`1<IPsiModule> modules);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual ISearchDomain CreateInternalAccessibilityDomain(IPsiModule module);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Search.SearchDomainFactoryExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static ISearchDomain CreateSearchDomainOfModuleAndItsReferences(SearchDomainFactory factory, IPsiModule psiModule);
    [ExtensionAttribute]
[NotNullAttribute]
public static ISearchDomain CreateSearchDomainWithModulesFilteredBy(SearchDomainFactory factory, Func`2<IPsiModule, bool> predicate, ISolution solution);
}
public abstract class JetBrains.ReSharper.Psi.Search.SearchDomainVisitor : object {
    public bool ProcessingIsFinished { get; }
    [CanBeNullAttribute]
public IComparer`1<IPsiModule> PsiModulesComparer { get; }
    [CanBeNullAttribute]
public IComparer`1<IPsiSourceFile> PsiSourceFileComparer { get; }
    public abstract virtual bool get_ProcessingIsFinished();
    public virtual IComparer`1<IPsiModule> get_PsiModulesComparer();
    public virtual IComparer`1<IPsiSourceFile> get_PsiSourceFileComparer();
    public virtual void VisitPsiModule(IPsiModule module);
    public virtual void VisitAssembly(IPsiAssembly assembly);
    public virtual void VisitPsiSourceFile(IPsiSourceFile sourceFile);
    public virtual void VisitElement(ITreeNode element);
    public virtual void VisitRootSearchDomainNode(RootSearchDomainNode rootNode);
    public virtual void VisitPsiModuleSearchDomainNode(PsiModuleSearchDomainNode psiModuleNode);
    public virtual void VisitPsiSourceFileSearchDomainNode(PsiSourceFileSearchDomainNode psiSourceFileNode);
    public virtual void VisitElementsSearchDomainNode(ElementsSearchDomainNode elementsNode);
    [NotNullAttribute]
private static IEnumerable`1<TValue> Sort(IDictionary`2<TKey, TValue> origin, IComparer`1<TKey> comparer);
    [NotNullAttribute]
private static IEnumerable`1<T> Sort(IEnumerable`1<T> origin, IComparer`1<T> comparer);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Search.SearchImplementorsPattern : Enum {
    public int value__;
    public static SearchImplementorsPattern DEFAULT;
    public static SearchImplementorsPattern QUASI;
    public static SearchImplementorsPattern RECURSIVE;
    public static SearchImplementorsPattern NEW_OVERRIDES;
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Search.SearchPattern : Enum {
    public int value__;
    public static SearchPattern FIND_NONE;
    public static SearchPattern FIND_USAGES;
    public static SearchPattern FIND_DERIVED_CLASSES_AND_STRUCTS;
    public static SearchPattern FIND_DERIVED_INTERFACES;
    public static SearchPattern FIND_DERIVED_TYPES;
    public static SearchPattern FIND_IMPLEMENTING_MEMBERS;
    public static SearchPattern FIND_MEMBER_USAGES;
    public static SearchPattern FIND_IMPLEMENTORS_USAGES;
    public static SearchPattern FIND_TEXT_OCCURRENCES;
    public static SearchPattern FIND_LATEBOUND_REFERENCES;
    public static SearchPattern FIND_RELATED_ELEMENTS;
    public static SearchPattern FIND_CANDIDATES;
    public static SearchPattern FIND_EXPLICITLY_TYPED_USAGES_ONLY;
}
public enum JetBrains.ReSharper.Psi.Search.SearchTargetRole : Enum {
    public int value__;
    public static SearchTargetRole Unknown;
    public static SearchTargetRole ElementType;
    public static SearchTargetRole BaseType;
    public static SearchTargetRole ImmediateBaseType;
    public static SearchTargetRole QuasyBaseType;
    public static SearchTargetRole UsageInBaseTypes;
    public static SearchTargetRole Attribute;
    public static SearchTargetRole ExtensionObject;
    public static SearchTargetRole HiddenMember;
}
public class JetBrains.ReSharper.Psi.Search.SynchronizedConsumer`1 : object {
    private object myLock;
    private IFindResultConsumer`1<T> myOriginalConsumer;
    public SynchronizedConsumer`1(IFindResultConsumer`1<T> consumer);
    public sealed virtual void Dispose();
    public sealed virtual T Build(FindResult result);
    public sealed virtual FindExecution Merge(T data);
}
public abstract class JetBrains.ReSharper.Psi.Search.TargetPositionBase : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetPositionKind <Kind>k__BackingField;
    public int Index { get; }
    public TargetPositionKind Kind { get; }
    protected TargetPositionBase(int index, TargetPositionKind kind);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Index();
    [CompilerGeneratedAttribute]
public sealed virtual TargetPositionKind get_Kind();
    public virtual int CompareTo(ITargetPosition other);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Search.TargetPositionExtensions : object {
    [ExtensionAttribute]
public static bool IsValidIndex(ITargetPosition targetPosition);
    [ExtensionAttribute]
public static bool IsEqualTo(ITargetPosition tp1, ITargetPosition tp2);
    [ExtensionAttribute]
public static bool InAttribute(ITargetPosition targetPosition);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string AttributeName(ITargetPosition targetPosition);
}
public enum JetBrains.ReSharper.Psi.Search.TargetPositionKind : Enum {
    public int value__;
    public static TargetPositionKind Unknown;
    public static TargetPositionKind CustomAttribute;
    public static TargetPositionKind DllImportAttribute;
    public static TargetPositionKind MethodBody;
}
public class JetBrains.ReSharper.Psi.Search.UnknownTargetPosition : TargetPositionBase {
    public static UnknownTargetPosition Instance;
    private static UnknownTargetPosition();
}
public abstract class JetBrains.ReSharper.Psi.Services.LiteralService : object {
    [NotNullAttribute]
public static LiteralService Get(ITreeNode element);
    [NotNullAttribute]
public static LiteralService Get(PsiLanguageType language);
    [CanBeNullAttribute]
public static LiteralService TryGet(PsiLanguageType language);
    public virtual bool IsStringLiteral(ITreeNode element);
    public abstract virtual bool IsConstantLiteral(ITreeNode element);
    public virtual Nullable`1<StringVerbatimity> TryGetStringVerbatimity(ILiteralExpression expression);
    public virtual TreeTextRange GetValueWithinRange(ITreeNode element);
    public abstract virtual TreeTextRange GetValueTextRange(ITreeNode element);
    [CanBeNullAttribute]
public virtual string ParseStringLiteral(ILiteralExpression literal, RangeTranslator& translator);
    [CanBeNullAttribute]
public abstract virtual string ParseStringLiteral(string literalText, RangeTranslator& translator);
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.ShellLevelAbstractAsyncCommitService : object {
    public virtual void RequestCommit(IAsyncCommitClient client, Nullable`1<int> delay);
}
public static class JetBrains.ReSharper.Psi.SignatureComparers : object {
    [NotNullAttribute]
public static ISignatureComparer Strict;
    private static SignatureComparers();
}
public static class JetBrains.ReSharper.Psi.SimpleTypeRewriter : object {
    public static IType Process(IType type, Func`2<IType, IType> rewriteFunc);
    public static IType Process(IType type, TState state, Func`3<IType, TState, IType> rewriteFunc);
}
public class JetBrains.ReSharper.Psi.SimpleTypeRewriter`1 : TypeRewriterBase`1<TContext> {
    [NotNullAttribute]
private Func`3<IType, TContext, IType> myTypeProcessor;
    public SimpleTypeRewriter`1(Func`3<IType, TContext, IType> typeProcessor);
    public virtual IType VisitType(IType type, TContext context);
}
[AttributeUsageAttribute("4")]
[MeansImplicitUseAttribute]
[ComponentInstantiationAttribute("-32758")]
public class JetBrains.ReSharper.Psi.SolutionFeaturePartAttribute : ComponentAttribute {
    public SolutionFeaturePartAttribute(Instantiation instantiation);
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.SolutionLevelAbstractAsyncCommitService : ShellLevelAbstractAsyncCommitService {
    private ISolution mySolution;
    public SolutionLevelAbstractAsyncCommitService(ISolution solution);
    public virtual void RequestCommit(IAsyncCommitClient client, Nullable`1<int> delay);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.SourceGenerators.Cache.CachedGeneratedDocuments : ValueType {
    [CompilerGeneratedAttribute]
private DateTime <ProjectLastWriteTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<CachedSourceGeneratedDocumentMetadata> <GeneratedDocuments>k__BackingField;
    public static IUnsafeMarshaller`1<CachedGeneratedDocuments> Marshaller;
    public DateTime ProjectLastWriteTimeUtc { get; }
    [NotNullAttribute]
public IList`1<CachedSourceGeneratedDocumentMetadata> GeneratedDocuments { get; }
    public CachedGeneratedDocuments(DateTime projectLastWriteTimeUtc, IList`1<CachedSourceGeneratedDocumentMetadata> documents);
    private static CachedGeneratedDocuments();
    [CompilerGeneratedAttribute]
public DateTime get_ProjectLastWriteTimeUtc();
    [CompilerGeneratedAttribute]
public IList`1<CachedSourceGeneratedDocumentMetadata> get_GeneratedDocuments();
    private static CachedGeneratedDocuments Read(UnsafeReader reader);
    private static void Write(UnsafeWriter writer, CachedGeneratedDocuments value);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.SourceGenerators.Cache.CachedSourceGeneratedDocumentMetadata : ValueType {
    [CompilerGeneratedAttribute]
private Guid <CacheId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CodePage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RelativePath>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastWriteTimeUtc>k__BackingField;
    public Guid CacheId { get; }
    public int CodePage { get; }
    [NotNullAttribute]
public string RelativePath { get; }
    public DateTime LastWriteTimeUtc { get; }
    public CachedSourceGeneratedDocumentMetadata(Guid cacheId, int codePage, string relativePath, DateTime lastWriteTimeUtc);
    [CompilerGeneratedAttribute]
public Guid get_CacheId();
    [CompilerGeneratedAttribute]
public int get_CodePage();
    [CompilerGeneratedAttribute]
public string get_RelativePath();
    [CompilerGeneratedAttribute]
public DateTime get_LastWriteTimeUtc();
    public static CachedSourceGeneratedDocumentMetadata Read(UnsafeReader reader);
    public static void Write(UnsafeWriter writer, CachedSourceGeneratedDocumentMetadata data);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.SourceGenerators.Cache.CachedSourceGeneratedFile : ValueType {
    [CompilerGeneratedAttribute]
private Guid <CacheId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceText>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CodePage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RelativePath>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastWriteTimeUtc>k__BackingField;
    public Guid CacheId { get; }
    [NotNullAttribute]
public string SourceText { get; }
    public int CodePage { get; }
    [NotNullAttribute]
public string RelativePath { get; }
    public DateTime LastWriteTimeUtc { get; }
    public CachedSourceGeneratedFile(string content, CachedSourceGeneratedDocumentMetadata metadata);
    [CompilerGeneratedAttribute]
public Guid get_CacheId();
    [CompilerGeneratedAttribute]
public string get_SourceText();
    [CompilerGeneratedAttribute]
public int get_CodePage();
    [CompilerGeneratedAttribute]
public string get_RelativePath();
    [CompilerGeneratedAttribute]
public DateTime get_LastWriteTimeUtc();
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Psi.SourceGenerators.Cache.ProjectWithTargetFrameworkCacheKey : ValueType {
    [CompilerGeneratedAttribute]
private string <ProjectPersistentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkIdUniqueString>k__BackingField;
    public static IUnsafeMarshaller`1<ProjectWithTargetFrameworkCacheKey> Marshaller;
    [NotNullAttribute]
public string ProjectPersistentId { get; }
    [NotNullAttribute]
public string TargetFrameworkIdUniqueString { get; }
    public ProjectWithTargetFrameworkCacheKey(string projectPersistentId, string targetFrameworkIdUniqueString);
    private static ProjectWithTargetFrameworkCacheKey();
    [CompilerGeneratedAttribute]
public string get_ProjectPersistentId();
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkIdUniqueString();
    private static ProjectWithTargetFrameworkCacheKey Read(UnsafeReader reader);
    private static void Write(UnsafeWriter writer, ProjectWithTargetFrameworkCacheKey id);
    public virtual bool Equals(object obj);
    public bool Equals(ProjectWithTargetFrameworkCacheKey other);
    public virtual int GetHashCode();
}
[SolutionComponentAttribute("18")]
public class JetBrains.ReSharper.Psi.SourceGenerators.Cache.SourceGeneratedFilesCache : object {
    private static int CacheCommitThrottling;
    [NotNullAttribute]
private ExplicitCommitMap`2<ProjectWithTargetFrameworkCacheKey, CachedGeneratedDocuments> myCacheMap;
    [NotNullAttribute]
private FreeThreadedGroupingEvent myCommitEvent;
    [NotNullAttribute]
private SourceGeneratedFilesDiskCache mySourceGeneratedFilesDiskCache;
    public SourceGeneratedFilesCache(Lifetime lifetime, ChangeManager changeManager, ISolutionCaches solutionCaches, IShellLocks locks, SourceGeneratedFilesDiskCache diskCache);
    private void Commit();
    internal void OnFileRemoved(SourceGeneratorOutputFile file);
    internal void OnFileModified(SourceGeneratorOutputFile file, string newText);
    internal void OnFileAdded(SourceGeneratorOutputFile file);
    [NotNullAttribute]
internal IDictionary`2<TargetFrameworkId, List`1<CachedSourceGeneratedFile>> Load(IProject project);
    internal void Write(IProject project, TargetFrameworkId targetFrameworkId, HashSet`1<IPsiSourceFile> sourceGeneratedFiles);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <.ctor>b__4_0(ChangeEventArgs args);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_1(bool _);
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.SourceGenerators.Cache.SourceGeneratedFilesDiskCache : object {
    private static int LevelDbCacheSizeThreshold;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NotNullAttribute]
private ConcurrentDictionary`2<Guid, ValueTuple`2<string, int>> myInMemoryContent;
    [NotNullAttribute]
private IOptimizedPersistentSortedMap`2<Guid, string> myLevelDbCache;
    [NotNullAttribute]
private ISolutionCaches mySolutionCaches;
    [NotNullAttribute]
private FileSystemPath CacheFolder { get; }
    public SourceGeneratedFilesDiskCache(Lifetime lifetime, ISolutionCaches solutionCaches);
    private bool ShouldUseDiskCache(string fileContent);
    private FileSystemPath get_CacheFolder();
    [CanBeNullAttribute]
public string Load(Guid key, int codePage);
    public void Add(Guid key, string content, int codePage);
    public void Update(Guid key, string content, int codePage);
    public void Delete(Guid key);
    public void Commit();
}
internal class JetBrains.ReSharper.Psi.SourceGenerators.GeneratedFilesProvider : object {
    private Lifetime myLifetime;
    [NotNullAttribute]
private ChangeManager myChangeManager;
    [NotNullAttribute]
private ISourceGeneratedFilesLanguageProvider myLanguageProvider;
    [NotNullAttribute]
private ISolution mySolution;
    [NotNullAttribute]
private IShellLocks myLocks;
    [NotNullAttribute]
private ILogger myLogger;
    [NotNullAttribute]
private IInMemoryDocumentFactory myDocumentFactory;
    [NotNullAttribute]
internal IPsiModule OwnerModule;
    [NotNullAttribute]
private Dictionary`2<string, SourceGeneratorOutputFile> myData;
    [NotNullAttribute]
private PsiSourceFilePropertiesManager myPsiSourceFilePropertiesManager;
    [NotNullAttribute]
private SourceGeneratedFilesCache mySourceGeneratedFilesCache;
    [NotNullAttribute]
private SourceGeneratorMonitor mySourceGeneratorMonitor;
    [NotNullAttribute]
[ItemNotNullAttribute]
private IEnumerable`1<IPsiSourceFile> myFiles;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IPsiSourceFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private GroupingEvent <SourceGeneratedFilesChangedEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private IModuleReferenceResolveContext <ResolveContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ISourceGeneratedFileManager <SourceGeneratedFileManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IProject <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <RoslynProjectId>k__BackingField;
    [NotNullAttribute]
[ItemNotNullAttribute]
public IEnumerable`1<IPsiSourceFile> Files { get; private set; }
    [NotNullAttribute]
public GroupingEvent SourceGeneratedFilesChangedEvent { get; }
    [NotNullAttribute]
public IModuleReferenceResolveContext ResolveContext { get; }
    [CanBeNullAttribute]
public ISourceGeneratedFileManager SourceGeneratedFileManager { get; }
    [NotNullAttribute]
public IProject Project { get; }
    public Guid RoslynProjectId { get; private set; }
    public GeneratedFilesProvider(Lifetime lifetime, ISolution solution, IProject project, IShellLocks locks, ILogger logger, IInMemoryDocumentFactory documentFactory, IPsiModule ownerModule, IModuleReferenceResolveContext resolveContext, ChangeManager changeManager, ISourceGeneratorDataProvider provider, ISourceGeneratedFileManager sourceGeneratedFileManager, ISourceGeneratedFilesLanguageProvider languageProvider, PsiSourceFilePropertiesManager psiSourceFilePropertiesManager, SourceGeneratorMonitor sourceGeneratorMonitor, SourceGeneratedFilesCache sourceGeneratedFilesCache);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<IPsiSourceFile> get_Files();
    [CompilerGeneratedAttribute]
private void set_Files(IEnumerable`1<IPsiSourceFile> value);
    [CompilerGeneratedAttribute]
public GroupingEvent get_SourceGeneratedFilesChangedEvent();
    [CompilerGeneratedAttribute]
public IModuleReferenceResolveContext get_ResolveContext();
    [CompilerGeneratedAttribute]
public ISourceGeneratedFileManager get_SourceGeneratedFileManager();
    [CompilerGeneratedAttribute]
public IProject get_Project();
    [CompilerGeneratedAttribute]
public Guid get_RoslynProjectId();
    [CompilerGeneratedAttribute]
private void set_RoslynProjectId(Guid value);
    private void BuildFiles(VirtualFileSystemPath projectFilePath, TargetFrameworkId targetFrameworkId, SourceGeneratorProjectData generatorsRunData);
    private void HandleOverwrittenFiles(IDictionary`2<string, SourceGeneratorFileData> generatedSources);
    private void OnGeneratedFilesChanged(OneToSetMap`2<ChangeType, IPsiSourceFile> changes);
}
public interface JetBrains.ReSharper.Psi.SourceGenerators.ISourceGeneratedFileManager {
    [CanBeNullAttribute]
public abstract virtual VirtualFileSystemPath GetSourceGeneratedFilePath(Guid roslynProjectId, Guid documentId, string fileName, string analyzerReferencePath);
    public abstract virtual bool IsSourceGeneratedFile(VirtualFileSystemPath filePath);
    public abstract virtual void EnsureSourceGeneratedFileOnDisk(VirtualFileSystemPath filePath);
    public abstract virtual void OnFileAdded(ISourceGeneratorOutputFile file, Guid roslynProjectId, Guid documentId, string fileName, string content, int codePage);
    public abstract virtual void OnFileModified(ISourceGeneratorOutputFile file, Guid roslynProjectId, Guid documentId, string fileName, string content, int codePage);
    public abstract virtual void OnFileRemoved(ISourceGeneratorOutputFile file, Guid roslynProjectId, Guid documentId, string fileName);
    [CanBeNullAttribute]
public abstract virtual ISourceGeneratorOutputFile TryGetSourceGeneratedFileByPath(VirtualFileSystemPath filePath);
    [NotNullAttribute]
[ItemNotNullAttribute]
public abstract virtual IEnumerable`1<ISourceGeneratorOutputFile> GetAllSourceGeneratedFiles();
}
public interface JetBrains.ReSharper.Psi.SourceGenerators.ISourceGeneratedFilesLanguageProvider {
    public ProjectLanguage SupportedProjectLanguage { get; }
    public PsiLanguageType PsiLanguageType { get; }
    public ProjectFileType ProjectFileType { get; }
    public abstract virtual ProjectLanguage get_SupportedProjectLanguage();
    public abstract virtual PsiLanguageType get_PsiLanguageType();
    public abstract virtual ProjectFileType get_ProjectFileType();
}
internal interface JetBrains.ReSharper.Psi.SourceGenerators.ISourceGeneratedFilesProvider {
    [CanBeNullAttribute]
public IEnumerable`1<IPsiSourceFile> Files { get; }
    public abstract virtual IEnumerable`1<IPsiSourceFile> get_Files();
}
public interface JetBrains.ReSharper.Psi.SourceGenerators.ISourceGeneratorOutputFile {
    public Guid CacheId { get; }
    [CanBeNullAttribute]
public IDocument AssociatedEditorDocument { get; }
    [CanBeNullAttribute]
public IDocument AssociatedEmbeddedSourceDocument { get; }
    public string RelativePath { get; }
    public int CodePage { get; public set; }
    [CanBeNullAttribute]
public string AnalyzerReferencePath { get; }
    public abstract virtual Guid get_CacheId();
    public abstract virtual IDocument get_AssociatedEditorDocument();
    public abstract virtual IDocument get_AssociatedEmbeddedSourceDocument();
    public abstract virtual string get_RelativePath();
    public abstract virtual int get_CodePage();
    public abstract virtual void set_CodePage(int value);
    public abstract virtual string get_AnalyzerReferencePath();
    public abstract virtual void BindToEmbeddedSourceProjectFile(IProjectFile projectFile);
    public abstract virtual void UnbindFromEmbeddedSourceProjectFile(IProjectFile projectFile);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.SourceGenerators.SourceGeneratedFilesProvider : object {
    [NotNullAttribute]
private ILogger myLogger;
    [NotNullAttribute]
private IInMemoryDocumentFactory myDocumentFactory;
    [NotNullAttribute]
private ISolution mySolution;
    [NotNullAttribute]
private ChangeManager myChangeManager;
    [NotNullAttribute]
private PsiSourceFilePropertiesManager myPsiSourceFilePropertiesManager;
    [NotNullAttribute]
private SourceGeneratorMonitor mySourceGeneratorMonitor;
    [NotNullAttribute]
private SourceGeneratedFilesCache mySourceGeneratedFilesCache;
    [NotNullAttribute]
private IShellLocks myLocks;
    [CanBeNullAttribute]
private ISourceGeneratorDataProvider mySourceGeneratedDataProvider;
    [CanBeNullAttribute]
private ISourceGeneratedFileManager mySourceGeneratedFileManager;
    [NotNullAttribute]
private Dictionary`2<ProjectLanguage, ISourceGeneratedFilesLanguageProvider> myLanguageProviders;
    public SourceGeneratedFilesProvider(IShellLocks locks, ILogger logger, IInMemoryDocumentFactory documentFactory, ISolution solution, ChangeManager changeManager, PsiSourceFilePropertiesManager psiSourceFilePropertiesManager, SourceGeneratorMonitor sourceGeneratorMonitor, SourceGeneratedFilesCache sourceGeneratedFilesCache, ISourceGeneratorDataProvider sourceGeneratedDataProvider, ISourceGeneratedFileManager sourceGeneratedFileManager, IEnumerable`1<ISourceGeneratedFilesLanguageProvider> languageProviders);
    public sealed virtual Tuple`2<IProjectPsiModuleHandler, IPsiModuleDecorator> OverrideHandler(Lifetime lifetime, IProject project, IProjectPsiModuleHandler handler);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SolutionComponentAttribute("18")]
public class JetBrains.ReSharper.Psi.SourceGenerators.SourceGeneratorMonitor : object {
    private SequentialScheduler mySequentialScheduler;
    private object myLocker;
    private ILogger myLogger;
    private ISolution mySolution;
    private List`1<string> myPendingOperations;
    private OneToSetMap`2<ProjectKey, AnalyzerReferenceInfo> myPendingProjects;
    private HashSet`1<AnalyzerReferenceInfo> myProcessedAnalyzerReferences;
    private HashSet`1<ProjectKey> myPendingSourceGeneratorsRequests;
    private bool myInitialized;
    private bool myRoslynEnabled;
    [CompilerGeneratedAttribute]
private Property`1<bool> <IsUpToDate>k__BackingField;
    [CompilerGeneratedAttribute]
private Property`1<bool> <Initialized>k__BackingField;
    public Property`1<bool> IsUpToDate { get; }
    public Property`1<bool> Initialized { get; }
    public SourceGeneratorMonitor(Lifetime lifetime, ILogger logger, ISolution solution, ChangeManager changeManager, SynchronizationPoints synchronizationPoints);
    [CompilerGeneratedAttribute]
public sealed virtual Property`1<bool> get_IsUpToDate();
    [CompilerGeneratedAttribute]
public sealed virtual Property`1<bool> get_Initialized();
    private void ProcessChange(ProjectModelChange projectModelChange);
    public void Initialize(bool enabled);
    public sealed virtual void OnOperation(Lifetime lifetime, string operationName);
    public sealed virtual void OnRoslynResultRequested(VirtualFileSystemPath projectFilePath, TargetFrameworkId targetFrameworkId);
    public sealed virtual void OnRoslynResultReceived(VirtualFileSystemPath projectFilePath, TargetFrameworkId targetFrameworkId);
    public sealed virtual void OnRoslynResultWithoutSourceGenerators(VirtualFileSystemPath projectFilePath, TargetFrameworkId targetFrameworkId);
    private void HandlePendingProject(VirtualFileSystemPath projectFilePath, TargetFrameworkId targetFrameworkId);
    [NullableContextAttribute("2")]
private void UpdateState(string caller);
    private static IReadOnlyCollection`1<AnalyzerReferenceInfo> CollectAnalyzerReferencesUnderReadLock(ISolution solution);
    [CompilerGeneratedAttribute]
private void <ProcessChange>g__HandleAnalyzerReference|17_0(ProjectModelChange change, IRoslynAnalyzerReference reference, IProject project);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.SourceGenerators.SourceGeneratorMonitorStarter : object {
    public SourceGeneratorMonitorStarter(ISolutionLoadTasksScheduler scheduler, SourceGeneratorMonitor sourceGeneratorMonitor);
    protected virtual void Initialize(SourceGeneratorMonitor sourceGeneratorMonitor);
}
internal class JetBrains.ReSharper.Psi.SourceGenerators.SourceGeneratorOutputFile : UserDataHolder {
    [NotNullAttribute]
private IInMemoryDocumentFactory myDocumentFactory;
    [NotNullAttribute]
private PsiSourceFileStorage myPsiSourceFileStorage;
    [NotNullAttribute]
private GeneratedFilesProvider myProvider;
    [NotNullAttribute]
private PsiSourceFilePropertiesManager myPsiSourceFilePropertiesManager;
    [CanBeNullAttribute]
private IProjectFile myProjectFile;
    [CanBeNullAttribute]
private IProjectFile myEmbeddedSourceProjectFile;
    private bool myIsValid;
    private string myCurrentTextFromRoslyn;
    [CompilerGeneratedAttribute]
private string <AnalyzerReferencePath>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <CacheId>k__BackingField;
    private Guid myDocumentId;
    [CompilerGeneratedAttribute]
private string <RelativePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CodePage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceText>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastWriteTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DocumentModified>k__BackingField;
    private JetWeakReference`1 modreq(System.Runtime.CompilerServices.IsVolatile) myDocument;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectFileType <LanguageType>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiLanguageType <PrimaryPsiLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiModule <PsiModule>k__BackingField;
    public string AnalyzerReferencePath { get; public set; }
    public Guid CacheId { get; public set; }
    public Guid DocumentId { get; public set; }
    public IDocument AssociatedEditorDocument { get; }
    public IDocument AssociatedEmbeddedSourceDocument { get; }
    [NotNullAttribute]
public string RelativePath { get; }
    public Guid RoslynProjectId { get; }
    public int CodePage { get; public set; }
    public string SourceText { get; private set; }
    public DateTime LastWriteTimeUtc { get; public set; }
    public bool DocumentModified { get; private set; }
    public IDocument Document { get; }
    public string Name { get; }
    public IModuleReferenceResolveContext ResolveContext { get; }
    public IPsiSourceFileStorage PsiStorage { get; }
    public string DisplayName { get; }
    public ProjectFileType LanguageType { get; }
    public PsiLanguageType PrimaryPsiLanguage { get; }
    public IPsiSourceFileProperties Properties { get; }
    public Nullable`1<ModificationStamp> InMemoryModificationStamp { get; }
    public Nullable`1<ModificationStamp> ExternalModificationStamp { get; }
    public IPsiModule PsiModule { get; }
    public VirtualFileSystemPath NavigationPath { get; }
    public SourceGeneratorOutputFile(IInMemoryDocumentFactory documentFactory, IPsiModule module, GeneratedFilesProvider provider, PsiSourceFilePropertiesManager psiSourceFilePropertiesManager, string sourceText, int codePage, string path, Guid documentId, ProjectFileType projectFileType, PsiLanguageType primaryPsiLanguage);
    [CompilerGeneratedAttribute]
public sealed virtual string get_AnalyzerReferencePath();
    [CompilerGeneratedAttribute]
public void set_AnalyzerReferencePath(string value);
    public void ScheduleTextChanges(string newText);
    public void ProcessTextChanges();
    public void OnRemoved();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_CacheId();
    [CompilerGeneratedAttribute]
public void set_CacheId(Guid value);
    public Guid get_DocumentId();
    public void set_DocumentId(Guid value);
    public sealed virtual IDocument get_AssociatedEditorDocument();
    public sealed virtual IDocument get_AssociatedEmbeddedSourceDocument();
    [CompilerGeneratedAttribute]
public sealed virtual string get_RelativePath();
    public Guid get_RoslynProjectId();
    [CompilerGeneratedAttribute]
public sealed virtual int get_CodePage();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CodePage(int value);
    [CompilerGeneratedAttribute]
public string get_SourceText();
    [CompilerGeneratedAttribute]
private void set_SourceText(string value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_LastWriteTimeUtc();
    [CompilerGeneratedAttribute]
public void set_LastWriteTimeUtc(DateTime value);
    [CompilerGeneratedAttribute]
public bool get_DocumentModified();
    [CompilerGeneratedAttribute]
private void set_DocumentModified(bool value);
    public sealed virtual IDocument get_Document();
    private void OnDocumentChanged(object sender, EventArgs`1<DocumentChange> args);
    public sealed virtual bool IsValid();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [NotNullAttribute]
public sealed virtual string GetPersistentID();
    public sealed virtual IModuleReferenceResolveContext get_ResolveContext();
    public virtual string ToString();
    public sealed virtual IPsiSourceFileStorage get_PsiStorage();
    public sealed virtual string get_DisplayName();
    [CompilerGeneratedAttribute]
public sealed virtual ProjectFileType get_LanguageType();
    [CompilerGeneratedAttribute]
public sealed virtual PsiLanguageType get_PrimaryPsiLanguage();
    public sealed virtual IPsiSourceFileProperties get_Properties();
    public sealed virtual Nullable`1<ModificationStamp> get_InMemoryModificationStamp();
    public sealed virtual Nullable`1<ModificationStamp> get_ExternalModificationStamp();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiModule get_PsiModule();
    public sealed virtual VirtualFileSystemPath get_NavigationPath();
    public sealed virtual void BindToProjectFile(IProjectFile projectFile);
    public sealed virtual void UnbindFromProjectFile(IProjectFile projectFile);
    public sealed virtual void BindToEmbeddedSourceProjectFile(IProjectFile projectFile);
    public sealed virtual void UnbindFromEmbeddedSourceProjectFile(IProjectFile projectFile);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.SourceGenerators.SourceGeneratorOutputFileExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetGeneratorName(ISourceGeneratorOutputFile file);
}
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.SourceGenerators.SourceGeneratorOutputFilePropertiesProvider : object {
    public double Order { get; }
    public sealed virtual double get_Order();
    public sealed virtual IPsiSourceFileProperties GetPsiProperties(IPsiSourceFileProperties prevProperties, IProject project, IProjectFile projectFile, IPsiSourceFile sourceFile);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.SourceGeneratorsUtil : object {
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSourceGeneratedFile(IPsiSourceFile psiSourceFile);
    [ExtensionAttribute]
public static ValueTuple`3<string, string, string> GetGeneratorInfo(ISourceGeneratorOutputFile sourceGeneratedFile);
}
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.StandardPsiSourceFilePropertiesProvider : object {
    private CachedProjectFileLanguageService myLanguageService;
    private IsCompileService myIsCompileService;
    public double Order { get; }
    public StandardPsiSourceFilePropertiesProvider(CachedProjectFileLanguageService languageService, IsCompileService isCompileService);
    public sealed virtual double get_Order();
    public sealed virtual IPsiSourceFileProperties GetPsiProperties(IPsiSourceFileProperties prevProperties, IProject project, IProjectFile projectFile, IPsiSourceFile sourceFile);
}
public enum JetBrains.ReSharper.Psi.StringVerbatimity : Enum {
    public int value__;
    public static StringVerbatimity Regular;
    public static StringVerbatimity Verbatim;
    public static StringVerbatimity Raw;
}
public static class JetBrains.ReSharper.Psi.StringVerbatimityUtil : object {
    public static StringVerbatimity GetMaximumVerbatimity(StringVerbatimity left, StringVerbatimity right);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.StructExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static StructLayoutKind GetStructLayoutKind(ITypeElement typeElement);
}
public enum JetBrains.ReSharper.Psi.StructLayoutKind : Enum {
    public int value__;
    public static StructLayoutKind Error;
    public static StructLayoutKind ImplicitSequential;
    public static StructLayoutKind Sequential;
    public static StructLayoutKind Auto;
    public static StructLayoutKind Explicit;
}
public static class JetBrains.ReSharper.Psi.SyntheticAttribute : object {
    public static string Name;
}
public static class JetBrains.ReSharper.Psi.SyntheticPublicApiAttribute : object {
    public static string Name;
}
public class JetBrains.ReSharper.Psi.Threading.PsiTaskBarrier : object {
    private ITaskBarrier myUnderlyingTaskBarrier;
    private IModuleReferenceResolveContext myModuleReferenceResolveContext;
    private ThreadTransitionCookie myThreadTransition;
    public bool IsSync { get; }
    private PsiTaskBarrier(ITaskBarrier underlyingTaskBarrier);
    [MustDisposeResourceAttribute]
public static ITaskBarrier Create(Lifetime lifetime, IShellLocks shellLocks, bool sync, TaskCreationOptions options);
    [MustDisposeResourceAttribute]
public static ITaskBarrier Create(ITaskBarrier underlyingTaskBarrier);
    public sealed virtual bool get_IsSync();
    public sealed virtual void EnqueueJob(Action action);
    public sealed virtual void EnqueueJob(string name, Action action);
    public sealed virtual void WaitAll();
    public sealed virtual void Dispose();
}
internal class JetBrains.ReSharper.Psi.Transactions.AddNodesAction : object {
    private ITreeNode[] myNodes;
    private IList`1<DocumentChange> myDocumentChanges;
    [CompilerGeneratedAttribute]
private ITreeNode <AffectedElement>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiChangedElementType <AffectedElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    public ITreeNode AffectedElement { get; }
    public PsiChangedElementType AffectedElementType { get; }
    public IPsiSourceFile SourceFile { get; }
    public AddNodesAction(ITreeNode affectedElement, PsiChangedElementType affectedElementType, ITreeNode[] nodes);
    [CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_AffectedElement();
    [CompilerGeneratedAttribute]
public sealed virtual PsiChangedElementType get_AffectedElementType();
    [NotNullAttribute]
public static IList`1<DocumentChange> CalcDocumentChanges(ITreeNode[] nodes);
    public sealed virtual void RollBack();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiSourceFile get_SourceFile();
    public sealed virtual ICollection`1<DocumentChange> GetDocumentChanges();
    public sealed virtual IEnumerable`1<ITreeNode> GetAddedNodes();
}
internal class JetBrains.ReSharper.Psi.Transactions.DeleteNodesAction : object {
    private ITreeNode myRoot;
    private ITreeNode myAnchor;
    private ITreeNode[] myNodes;
    private IList`1<DocumentChange> myDocumentChanges;
    [CompilerGeneratedAttribute]
private PsiChangedElementType <AffectedElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    public ITreeNode AffectedElement { get; }
    public PsiChangedElementType AffectedElementType { get; }
    public IPsiSourceFile SourceFile { get; }
    public DeleteNodesAction(ITreeNode root, PsiChangedElementType elementAffectedElementType, ITreeNode anchor, ITreeNode[] nodes);
    public sealed virtual ITreeNode get_AffectedElement();
    [CompilerGeneratedAttribute]
public sealed virtual PsiChangedElementType get_AffectedElementType();
    [NotNullAttribute]
public static IList`1<DocumentChange> CalcDocumentChanges(ITreeNode[] nodes);
    public sealed virtual void RollBack();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiSourceFile get_SourceFile();
    public sealed virtual ICollection`1<DocumentChange> GetDocumentChanges();
    public sealed virtual IEnumerable`1<ITreeNode> GetDeletedNodes();
    public sealed virtual ITreeNode GetParent();
}
public class JetBrains.ReSharper.Psi.Transactions.FailPsiTransactionException : Exception {
    public FailPsiTransactionException(string message);
}
public interface JetBrains.ReSharper.Psi.Transactions.IAddPsiNodesAction {
    public abstract virtual IEnumerable`1<ITreeNode> GetAddedNodes();
}
public interface JetBrains.ReSharper.Psi.Transactions.IDeletePsiNodesAction {
    public abstract virtual IEnumerable`1<ITreeNode> GetDeletedNodes();
    [CanBeNullAttribute]
public abstract virtual ITreeNode GetParent();
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.Transactions.IOnTransactionDocumentChangeCookie {
    public abstract virtual void ApplyTransactionDocumentChange(DocumentChange documentChange, string oldText, IPsiTransactionAction transactionAction);
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.Transactions.IPsiTransaction {
    public bool Failing { get; }
    public bool Failed { get; }
    public bool Succeed { get; }
    public int NestingLevel { get; }
    public IEnumerable`1<IPsiSourceFile> AffectedFiles { get; }
    public abstract virtual bool get_Failing();
    public abstract virtual bool get_Failed();
    public abstract virtual bool get_Succeed();
    public abstract virtual int get_NestingLevel();
    public abstract virtual IEnumerable`1<IPsiSourceFile> get_AffectedFiles();
    public abstract virtual void AddProperty(object key, object value);
    public abstract virtual IEnumerable`1<object> GetProperties(object key);
}
public interface JetBrains.ReSharper.Psi.Transactions.IPsiTransactionAction {
    [CanBeNullAttribute]
public ITreeNode AffectedElement { get; }
    public PsiChangedElementType AffectedElementType { get; }
    [CanBeNullAttribute]
public IPsiSourceFile SourceFile { get; }
    public abstract virtual ITreeNode get_AffectedElement();
    public abstract virtual PsiChangedElementType get_AffectedElementType();
    public abstract virtual IPsiSourceFile get_SourceFile();
    [NotNullAttribute]
public abstract virtual ICollection`1<DocumentChange> GetDocumentChanges();
    public abstract virtual void RollBack();
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.Transactions.IPsiTransactions {
    [NullableAttribute("2")]
public IPsiTransaction Current { get; }
    public int CurrentNestingLevel { get; }
    public DocumentTransactionManager DocumentTransactionManager { get; }
    [NullableContextAttribute("2")]
public abstract virtual IPsiTransaction get_Current();
    public abstract virtual int get_CurrentNestingLevel();
    public abstract virtual void StartTransaction(string commandName);
    public abstract virtual TransactionResult CommitTransaction();
    public abstract virtual void RollbackTransaction();
    public abstract virtual void Cancel(string reason);
    public abstract virtual void Observe(Lifetime lifetime, IPsiTransactionsObserver observer);
    [ObsoleteAttribute("Use overload with IPsiTransactionsObserver")]
public abstract virtual void Observe(Lifetime lifetime, Action`1<IPsiTransaction> start, Action`1<IPsiTransaction> commit, Action`1<IPsiTransaction> rollback, Action`1<IPsiTransactionAction> action);
    public abstract virtual DocumentTransactionManager get_DocumentTransactionManager();
    public abstract virtual TransactionResult Execute(string commandName, Action handler);
    public abstract virtual void AddTransactionAction(IPsiTransactionAction action);
    public abstract virtual bool HasActiveOperation();
    public abstract virtual bool HasActiveRollbackOperation();
    [MustDisposeResourceAttribute]
public abstract virtual IDisposable CreateCustomCookie(T data);
    [NullableContextAttribute("2")]
public abstract virtual bool HasCustomCookieOfType();
    public abstract virtual IEnumerable`1<T> GetCustomCookiesOfType();
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.Transactions.IPsiTransactionsObserver {
    public bool HandlesPsiTransactionsInForks { get; }
    public abstract virtual bool get_HandlesPsiTransactionsInForks();
    public abstract virtual void OnPsiTransactionStart(IPsiTransaction transaction);
    public abstract virtual void OnPsiTransactionAttemptToCommit(IPsiTransaction transaction);
    public abstract virtual void OnPsiTransactionCommit(IPsiTransaction transaction);
    public abstract virtual void OnPsiTransactionRollback(IPsiTransaction transaction);
    public abstract virtual void OnPsiTransactionAction(IPsiTransactionAction transactionAction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Transactions.MinimizedReparsePsiAction : object {
    [CompilerGeneratedAttribute]
private CachedPsiFile <PsiFile>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentChange <DocumentChange>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode[] <OldNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode[] <NewNodes>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ITreeNode <Parent>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ITreeNode <LeftAnchor>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    private CachedPsiFile PsiFile { get; }
    private DocumentChange DocumentChange { get; }
    private ITreeNode[] OldNodes { get; }
    private ITreeNode[] NewNodes { get; }
    [NullableAttribute("2")]
private ITreeNode Parent { get; }
    [NullableAttribute("2")]
private ITreeNode LeftAnchor { get; }
    public IPsiSourceFile SourceFile { get; }
    public ITreeNode AffectedElement { get; }
    public PsiChangedElementType AffectedElementType { get; }
    public MinimizedReparsePsiAction(CachedPsiFile cachedPsiFile, DocumentChange documentChange, TreeRange oldNodes, TreeRange newNodes, ITreeNode parent, ITreeNode leftAnchor);
    [CompilerGeneratedAttribute]
private CachedPsiFile get_PsiFile();
    [CompilerGeneratedAttribute]
private DocumentChange get_DocumentChange();
    [CompilerGeneratedAttribute]
private ITreeNode[] get_OldNodes();
    [CompilerGeneratedAttribute]
private ITreeNode[] get_NewNodes();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private ITreeNode get_Parent();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private ITreeNode get_LeftAnchor();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiSourceFile get_SourceFile();
    public sealed virtual ICollection`1<DocumentChange> GetDocumentChanges();
    public sealed virtual IEnumerable`1<ITreeNode> GetAddedNodes();
    public sealed virtual IEnumerable`1<ITreeNode> GetDeletedNodes();
    [NullableContextAttribute("2")]
public sealed virtual ITreeNode GetParent();
    public sealed virtual ITreeNode get_AffectedElement();
    public sealed virtual PsiChangedElementType get_AffectedElementType();
    public sealed virtual void RollBack();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Psi.Transactions.PsiTransaction : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private OneToListMap`2<object, object> myProperties;
    private int myNestingLevel;
    private List`1<IPsiTransactionAction> myEntries;
    private HashSet`1<IPsiSourceFile> myAffectedSourceFiles;
    private string myErrorDescription;
    private bool myFailed;
    private bool mySucceed;
    public int NestingLevel { get; }
    public IEnumerable`1<IPsiSourceFile> AffectedFiles { get; }
    public bool Failing { get; }
    public bool Failed { get; }
    public bool Succeed { get; }
    public string ErrorDescription { get; public set; }
    public PsiTransaction(int nestingLevel);
    public sealed virtual int get_NestingLevel();
    public sealed virtual IEnumerable`1<IPsiSourceFile> get_AffectedFiles();
    public sealed virtual void AddProperty(object key, object value);
    public sealed virtual IEnumerable`1<object> GetProperties(object key);
    public sealed virtual bool get_Failing();
    public sealed virtual bool get_Failed();
    public sealed virtual bool get_Succeed();
    public string get_ErrorDescription();
    public void set_ErrorDescription(string value);
    public void Add(IPsiTransactionAction transactionAction);
    public void CommitTo(PsiTransaction transaction);
    public void RollBack();
    public void Commit();
    public IList`1<IPsiSourceFile> GetAffectedSourceFiles();
}
[ExtensionAttribute]
internal static class JetBrains.ReSharper.Psi.Transactions.PsiTransactionActionUtil : object {
    [ExtensionAttribute]
public static Nullable`1<DocumentRange> GetParsedDocumentRange(ITreeNode node);
    public static TextModificationSide ModificationSideByNodes(ITreeNode[] nodes);
}
[MustDisposeResourceAttribute]
public class JetBrains.ReSharper.Psi.Transactions.PsiTransactionCookie : object {
    [NotNullAttribute]
private IPsiServices myPsiServices;
    private DefaultAction myDefaultAction;
    private bool myUpdateCachesAfterCommit;
    private bool myIsDisposed;
    public PsiTransactionCookie(IPsiServices psiServices, DefaultAction defaultAction, string commandName);
    private PsiTransactionCookie(IPsiServices psiServices, DefaultAction defaultAction, bool updateCachesAfterCommit, string commandName);
    public sealed virtual void Dispose();
    public bool Commit();
    public void Rollback();
    [NotNullAttribute]
[MustDisposeResourceAttribute]
public static PsiTransactionCookie CreateTemporaryChangeCookie(IPsiServices psiServices, string commandName);
    [NotNullAttribute]
[MustDisposeResourceAttribute]
public static PsiTransactionCookie CreateAutoCommitCookieWithCachesUpdate(IPsiServices psiServices, string commandName);
    public static bool ExecuteConditionally(IPsiServices psiServices, Func`1<bool> action, string commandName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PsiComponentAttribute("0")]
internal class JetBrains.ReSharper.Psi.Transactions.PsiTransactions : object {
    [CompilerGeneratedAttribute]
private SolutionDocumentTransactionManager <documentTransactionManager>P;
    [CompilerGeneratedAttribute]
private IGeneratedDocumentsManager <generatedDocumentsManager>P;
    [CompilerGeneratedAttribute]
private DocumentToProjectFileMappingStorage <documentToProjectFileMappingStorage>P;
    private LazyForkedContentModelData`1<CurrentTransactionsPerFork> myTransactionState;
    private LazyForkedContentModelData`1<HashSet`1<CustomCookie>> myCustomCookies;
    private IShellLocks myLocks;
    private List`1<IPsiTransactionsObserver> myObservers;
    public DocumentTransactionManager DocumentTransactionManager { get; }
    [NullableAttribute("2")]
private IPsiTransaction JetBrains.ReSharper.Psi.Transactions.IPsiTransactions.Current { get; }
    [NullableAttribute("2")]
private PsiTransaction Current { get; }
    public int CurrentNestingLevel { get; }
    public PsiTransactions(IShellLocks locks, SolutionDocumentTransactionManager documentTransactionManager, IGeneratedDocumentsManager generatedDocumentsManager, DocumentToProjectFileMappingStorage documentToProjectFileMappingStorage);
    public sealed virtual DocumentTransactionManager get_DocumentTransactionManager();
    [NullableContextAttribute("2")]
private sealed virtual override IPsiTransaction JetBrains.ReSharper.Psi.Transactions.IPsiTransactions.get_Current();
    [NullableContextAttribute("2")]
private PsiTransaction get_Current();
    public sealed virtual int get_CurrentNestingLevel();
    public sealed virtual void StartTransaction(string commandName);
    public sealed virtual TransactionResult CommitTransaction();
    public sealed virtual void Cancel(string reason);
    public sealed virtual bool HasActiveOperation();
    private bool HasActiveOperation(OperationType operationType);
    public sealed virtual bool HasActiveRollbackOperation();
    public sealed virtual void AddTransactionAction(IPsiTransactionAction transactionAction);
    [NullableContextAttribute("2")]
private void AssertGeneratedFilesOk(IPsiSourceFile psiSourceFile);
    private void RollbackTransaction(bool rollbackDocumentTransaction);
    public sealed virtual void RollbackTransaction();
    public sealed virtual TransactionResult Execute(string commandName, Action handler);
    public sealed virtual void Observe(Lifetime lifetime, IPsiTransactionsObserver observer);
    public sealed virtual void Observe(Lifetime lifetime, Action`1<IPsiTransaction> start, Action`1<IPsiTransaction> commit, Action`1<IPsiTransaction> rollback, Action`1<IPsiTransactionAction> action);
    private void NotifyStart(IPsiTransaction transaction);
    private void NotifyAction(IPsiTransactionAction transactionAction);
    private void NotifyCommit(IPsiTransaction transaction);
    private void NotifyAttemptToCommit(IPsiTransaction transaction);
    private void NotifyRollback(IPsiTransaction transaction);
    public sealed virtual IDisposable CreateCustomCookie(T data);
    [NullableContextAttribute("2")]
public sealed virtual bool HasCustomCookieOfType();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Transactions.PsiTransactions/<GetCustomCookiesOfType>d__39`1")]
public sealed virtual IEnumerable`1<T> GetCustomCookiesOfType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Transactions.PsiTransactionsExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[ContractAnnotationAttribute("=>halt")]
public static void FailActiveTransactionViaException(IPsiTransactions transactions, string errorDescription, string messageForUser);
    [ExtensionAttribute]
public static TReturn Execute(IPsiTransactions transactions, string commandName, Func`1<TReturn> handler);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
[MustDisposeResourceAttribute]
public static IDisposable WithSharedFilesPsiUpdate(IPsiTransactions psiTransactions, ISolution solution);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Transactions.PsiTransactionsObserver : object {
    [CompilerGeneratedAttribute]
private bool <HandlesPsiTransactionsInForks>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<IPsiTransaction> <OnTransactionStart>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<IPsiTransaction> <OnTransactionCommitAttempt>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<IPsiTransaction> <OnTransactionCommit>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<IPsiTransaction> <OnTransactionRollback>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<IPsiTransaction> <OnTransactionFinished>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<IPsiTransactionAction> <OnTransactionAction>k__BackingField;
    public bool HandlesPsiTransactionsInForks { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<IPsiTransaction> OnTransactionStart { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<IPsiTransaction> OnTransactionCommitAttempt { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<IPsiTransaction> OnTransactionCommit { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<IPsiTransaction> OnTransactionRollback { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<IPsiTransaction> OnTransactionFinished { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<IPsiTransactionAction> OnTransactionAction { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HandlesPsiTransactionsInForks();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HandlesPsiTransactionsInForks(bool value);
    [CompilerGeneratedAttribute]
public Action`1<IPsiTransaction> get_OnTransactionStart();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OnTransactionStart(Action`1<IPsiTransaction> value);
    [CompilerGeneratedAttribute]
public Action`1<IPsiTransaction> get_OnTransactionCommitAttempt();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OnTransactionCommitAttempt(Action`1<IPsiTransaction> value);
    [CompilerGeneratedAttribute]
public Action`1<IPsiTransaction> get_OnTransactionCommit();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OnTransactionCommit(Action`1<IPsiTransaction> value);
    [CompilerGeneratedAttribute]
public Action`1<IPsiTransaction> get_OnTransactionRollback();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OnTransactionRollback(Action`1<IPsiTransaction> value);
    [CompilerGeneratedAttribute]
public Action`1<IPsiTransaction> get_OnTransactionFinished();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OnTransactionFinished(Action`1<IPsiTransaction> value);
    [CompilerGeneratedAttribute]
public Action`1<IPsiTransactionAction> get_OnTransactionAction();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OnTransactionAction(Action`1<IPsiTransactionAction> value);
    [DebuggerStepThroughAttribute]
private sealed virtual override void JetBrains.ReSharper.Psi.Transactions.IPsiTransactionsObserver.OnPsiTransactionStart(IPsiTransaction transaction);
    [DebuggerStepThroughAttribute]
private sealed virtual override void JetBrains.ReSharper.Psi.Transactions.IPsiTransactionsObserver.OnPsiTransactionAttemptToCommit(IPsiTransaction transaction);
    [DebuggerStepThroughAttribute]
private sealed virtual override void JetBrains.ReSharper.Psi.Transactions.IPsiTransactionsObserver.OnPsiTransactionCommit(IPsiTransaction transaction);
    [DebuggerStepThroughAttribute]
private sealed virtual override void JetBrains.ReSharper.Psi.Transactions.IPsiTransactionsObserver.OnPsiTransactionRollback(IPsiTransaction transaction);
    [DebuggerStepThroughAttribute]
private sealed virtual override void JetBrains.ReSharper.Psi.Transactions.IPsiTransactionsObserver.OnPsiTransactionAction(IPsiTransactionAction transactionAction);
}
public class JetBrains.ReSharper.Psi.Transactions.ReparsePsiAction : object {
    private CachedPsiFile myCachedPsiFile;
    private DocumentChange myDocumentChange;
    private ITreeNode myNewNode;
    private ITreeNode myOldNode;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    public ITreeNode AffectedElement { get; }
    public PsiChangedElementType AffectedElementType { get; }
    public IPsiSourceFile SourceFile { get; }
    public ReparsePsiAction(CachedPsiFile cachedPsiFile, ITreeNode oldNode, ITreeNode newNode, DocumentChange documentChange);
    public sealed virtual ITreeNode get_AffectedElement();
    public sealed virtual PsiChangedElementType get_AffectedElementType();
    public sealed virtual void RollBack();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiSourceFile get_SourceFile();
    public sealed virtual ICollection`1<DocumentChange> GetDocumentChanges();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Transactions.ReparsePsiAction/<GetAddedNodes>d__14")]
public sealed virtual IEnumerable`1<ITreeNode> GetAddedNodes();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Transactions.ReparsePsiAction/<GetDeletedNodes>d__15")]
public sealed virtual IEnumerable`1<ITreeNode> GetDeletedNodes();
    public sealed virtual ITreeNode GetParent();
}
internal class JetBrains.ReSharper.Psi.Transactions.ReplaceNodesAction : object {
    private ITreeNode[] myOldNodes;
    private ITreeNode[] myNewNodes;
    private IList`1<DocumentChange> myRemovedNodeChange;
    [CompilerGeneratedAttribute]
private ITreeNode <AffectedElement>k__BackingField;
    [CompilerGeneratedAttribute]
private PsiChangedElementType <AffectedElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    public ITreeNode AffectedElement { get; }
    public PsiChangedElementType AffectedElementType { get; }
    public IPsiSourceFile SourceFile { get; }
    public ReplaceNodesAction(ITreeNode affectedElement, PsiChangedElementType affectedElementType, ITreeNode[] oldNodes, ITreeNode[] newNodes);
    [CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_AffectedElement();
    [CompilerGeneratedAttribute]
public sealed virtual PsiChangedElementType get_AffectedElementType();
    public sealed virtual void RollBack();
    [CompilerGeneratedAttribute]
public sealed virtual IPsiSourceFile get_SourceFile();
    public sealed virtual ICollection`1<DocumentChange> GetDocumentChanges();
    public sealed virtual IEnumerable`1<ITreeNode> GetAddedNodes();
    public sealed virtual IEnumerable`1<ITreeNode> GetDeletedNodes();
    public sealed virtual ITreeNode GetParent();
}
public class JetBrains.ReSharper.Psi.Transactions.TransactionResult : object {
    [CompilerGeneratedAttribute]
private TransactionResultEnum <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FailureDescription>k__BackingField;
    public static TransactionResult SUCCESS;
    public TransactionResultEnum Result { get; }
    public string FailureDescription { get; }
    public bool Succeded { get; }
    public TransactionResult(TransactionResultEnum result);
    public TransactionResult(EnsureWritableResult result);
    public TransactionResult(EnsureWritableResult result, string failureDescription);
    public TransactionResult(TransactionResultEnum result, string failureDescription);
    private static TransactionResult();
    [CompilerGeneratedAttribute]
public TransactionResultEnum get_Result();
    [CompilerGeneratedAttribute]
public string get_FailureDescription();
    public bool get_Succeded();
}
public enum JetBrains.ReSharper.Psi.Transactions.TransactionResultEnum : Enum {
    public int value__;
    public static TransactionResultEnum Success;
    public static TransactionResultEnum Failure;
    public static TransactionResultEnum Cancelled;
    public static TransactionResultEnum EnsureWritableFailed;
    public static TransactionResultEnum EnsureWritableChangesDetected;
}
public class JetBrains.ReSharper.Psi.Transactions.UpdateSharedFilesPsiOnTransactionDocumentChangeCookie : object {
    private DocumentToProjectFileMappingStorage myDocumentToProjectFileMappingStorage;
    private IPsiServices myPsiServices;
    private HashSet`1<VirtualFileSystemPath> myIsProcessing;
    public UpdateSharedFilesPsiOnTransactionDocumentChangeCookie(DocumentToProjectFileMappingStorage documentToProjectFileMappingStorage, IPsiServices psiServices);
    public sealed virtual void ApplyTransactionDocumentChange(DocumentChange documentChange, string oldText, IPsiTransactionAction transactionAction);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Tree.DeclarationExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static DocumentRange GetNameDocumentRange(IDeclaration declaration);
}
public class JetBrains.ReSharper.Psi.Tree.DocCommentError : object {
    [CompilerGeneratedAttribute]
private ICommentNode <CommentNode>k__BackingField;
    [CompilerGeneratedAttribute]
private TreeTextRange <LocalRange>k__BackingField;
    public DocumentRange DocumentRange { get; }
    [NotNullAttribute]
public ICommentNode CommentNode { get; }
    public TreeTextRange LocalRange { get; }
    public DocCommentError(ICommentNode commentNode, TreeTextRange localRange);
    public DocumentRange get_DocumentRange();
    [CompilerGeneratedAttribute]
public ICommentNode get_CommentNode();
    [CompilerGeneratedAttribute]
public TreeTextRange get_LocalRange();
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Tree.ExpressionAccessType : Enum {
    public int value__;
    public static ExpressionAccessType None;
    public static ExpressionAccessType Read;
    public static ExpressionAccessType Write;
    public static ExpressionAccessType ReadWrite;
    public static ExpressionAccessType Partial;
    public static ExpressionAccessType NameCapture;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Tree.FileExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static TreeTextRange Translate(IFile file, DocumentRange documentRange);
    [ExtensionAttribute]
[PureAttribute]
public static TreeOffset Translate(IFile file, DocumentOffset offset);
    [ExtensionAttribute]
[PureAttribute]
public static TreeTextRange TranslatePossiblyDisjoint(IFile file, DocumentRange documentRange);
    [ExtensionAttribute]
[PureAttribute]
[ObsoleteAttribute("Use overload with DocumentRange")]
public static TreeTextRange Translate(IFile file, IDocument document, TextRange textRange);
    [ExtensionAttribute]
[PureAttribute]
[ObsoleteAttribute("Use overload with DocumentOffset")]
public static TreeOffset Translate(IFile file, IDocument document, int textOffset);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static ITreeNode FindNodeAt(IFile file, DocumentRange documentRange);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static ITreeNode FindNodeAt(IFile file, DocumentOffset documentOffset);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static ITreeNode FindNodeAt(IFile file, TreeOffset treeOffset);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
[ObsoleteAttribute("Use overload with DocumentRange")]
public static ITreeNode FindNodeAt(IFile file, IDocument document, TextRange textRange);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static ITreeNode FindTokenAt(IFile file, DocumentOffset documentOffset);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
[ObsoleteAttribute("Use overload with DocumentOffset")]
public static ITreeNode FindTokenAt(IFile file, IDocument document, int textOffset);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentOffset GetDocumentOffset(IFile file, TreeOffset treeOffset);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentRange GetParsedDocumentRange(IFile file, TreeTextRange range);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentRange GetDocumentRange(IFile file, TreeTextRange range);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentRange GetDocumentRange(IFile file, TreeTextRange range, bool forModification);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentRange GetCoveringDocumentRange(IFile file, TreeTextRange range);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<DocumentRange> GetIntersectingRanges(IFile file, TreeTextRange range);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<DocumentRange> GetIntersectingRangesLowLevel(IFile file, TreeTextRange range, bool includeHidden, bool includeEmpty);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<TreeTextRange> GetIntersectingRanges(IFile file, DocumentRange documentRange, bool includeEmpty);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.FileExtensions/<FindNodesAt>d__19`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> FindNodesAt(IFile file, TreeTextRange range, Predicate`1<T> filter);
    [ExtensionAttribute]
public static IEnumerable`1<ITreeNode> FindNodesAt(IFile file, TreeTextRange range);
    [ExtensionAttribute]
public static IEnumerable`1<ITreeNode> FindNodesAt(IFile file, TreeTextRange range, Predicate`1<ITreeNode> filter);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.FileExtensions/<FindNodesAt>d__22")]
[ExtensionAttribute]
public static IEnumerable`1<ITreeNode> FindNodesAt(IFile file, TreeTextRange range, Predicate`1<ITreeNode> filter, bool allowTextlessNodes);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.FileExtensions/<FindTokensAt>d__23")]
[ExtensionAttribute]
public static IEnumerable`1<ITokenNode> FindTokensAt(IFile file, TreeTextRange range);
    [ExtensionAttribute]
public static LineEnding DetectLineEnding(IFile file, IPsiServices psiServices);
    [ExtensionAttribute]
public static void AssertLineEndingsInNode(ITreeNode node, LineEnding le);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IFile InsertAndReParse(IFile file, TreeOffset offset, string text);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IDeclaration FindFirstDeclarationByNameRange(IFile psiFile, DocumentRange nameRange, bool exactRange);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IDeclaration FindFirstDeclarationByNameRange(IFile psiFile, TreeTextRange nameRange, bool exactRange);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IDeclaration> FindDeclarationsByNameRange(IFile psiFile, DocumentRange nameRange, bool exactRange);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.FileExtensions/<FindDeclarationsByNameRange>d__30")]
[ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<IDeclaration> FindDeclarationsByNameRange(IFile psiFile, TreeTextRange nameRange, bool exactRange);
}
public interface JetBrains.ReSharper.Psi.Tree.IAccessRightsOwnerDeclaration {
    public bool HasAccessRights { get; }
    public abstract virtual bool get_HasAccessRights();
    public abstract virtual void SetAccessRights(AccessRights rights);
}
public interface JetBrains.ReSharper.Psi.Tree.IArgument {
    [CanBeNullAttribute]
public IExpression Expression { get; }
    public abstract virtual IPsiServices GetPsiServices();
    public abstract virtual bool IsValid();
    public abstract virtual IExpression get_Expression();
}
public interface JetBrains.ReSharper.Psi.Tree.IArgumentsOwner {
    [NotNullAttribute]
public IList`1<IArgument> Arguments { get; }
    public abstract virtual IList`1<IArgument> get_Arguments();
}
public interface JetBrains.ReSharper.Psi.Tree.IChameleonNode {
    public bool IsOpened { get; }
    [CanBeNullAttribute]
public abstract virtual IChameleonNode ReSync(CachingLexer cachingLexer, TreeTextRange changedRange, int insertedTextLen);
    public abstract virtual bool get_IsOpened();
}
public interface JetBrains.ReSharper.Psi.Tree.IComment {
    [NotNullAttribute]
public string CommentText { get; }
    public abstract virtual string get_CommentText();
    [PureAttribute]
public abstract virtual TreeTextRange GetCommentRange();
}
public interface JetBrains.ReSharper.Psi.Tree.ICommentNode {
}
public interface JetBrains.ReSharper.Psi.Tree.IDeclaration {
    [CanBeNullAttribute]
public IDeclaredElement DeclaredElement { get; }
    [NotNullAttribute]
public string DeclaredName { get; }
    public abstract virtual IDeclaredElement get_DeclaredElement();
    public abstract virtual string get_DeclaredName();
    public abstract virtual void SetName(string name);
    [PureAttribute]
public abstract virtual TreeTextRange GetNameRange();
    [PureAttribute]
public abstract virtual bool IsSynthetic();
}
public interface JetBrains.ReSharper.Psi.Tree.IDefaultNamespaceOwner {
    [NotNullAttribute]
public string DefaultNamespaceName { get; }
    [NotNullAttribute]
public INamespace DefaultNamespace { get; }
    public abstract virtual string get_DefaultNamespaceName();
    public abstract virtual INamespace get_DefaultNamespace();
}
public interface JetBrains.ReSharper.Psi.Tree.IDocCommentBlock {
    [CanBeNullAttribute]
public abstract virtual XmlNode GetXML(ITypeMember element);
    [NotNullAttribute]
public abstract virtual IReadOnlyCollection`1<DocCommentError> GetErrors();
}
public interface JetBrains.ReSharper.Psi.Tree.IDocCommentBlockOwner {
    [CanBeNullAttribute]
public IDocCommentBlock DocCommentBlock { get; }
    public abstract virtual IDocCommentBlock get_DocCommentBlock();
    public abstract virtual void SetDocCommentBlock(IDocCommentBlock block);
}
public interface JetBrains.ReSharper.Psi.Tree.IErrorElement {
    [NotNullAttribute]
public string ErrorDescription { get; }
    public abstract virtual string get_ErrorDescription();
}
public interface JetBrains.ReSharper.Psi.Tree.IExpression {
    [PureAttribute]
public abstract virtual ExpressionAccessType GetAccessType();
    [PureAttribute]
public abstract virtual bool IsConstantValue();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType Type();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IExpressionType GetExpressionType();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IType GetImplicitlyConvertedTo();
}
public interface JetBrains.ReSharper.Psi.Tree.IFile {
    [NotNullAttribute]
public CachingLexer CachingLexer { get; }
    public int ModificationCounter { get; }
    public bool CanContainCaseInsensitiveReferences { get; }
    public abstract virtual CachingLexer get_CachingLexer();
    [CanBeNullAttribute]
public abstract virtual IFile ReParse(TreeTextRange modifiedRange, string text);
    [CanBeNullAttribute]
public abstract virtual PsiFileModificationInfo GetReParseResult(TreeTextRange modifiedRange, string text);
    public abstract virtual int get_ModificationCounter();
    public abstract virtual bool get_CanContainCaseInsensitiveReferences();
    [PureAttribute]
public abstract virtual bool IsInjected();
}
public interface JetBrains.ReSharper.Psi.Tree.IFileWithEmbeds {
    public abstract virtual Nullable`1<bool> AreLineBreaksAllowed(DocumentRange range);
    public abstract virtual Nullable`1<bool> AreLineCommentsAllowed(DocumentRange range);
}
public interface JetBrains.ReSharper.Psi.Tree.IFunctionDeclaration {
    [CanBeNullAttribute]
public IFunction DeclaredElement { get; }
    public abstract virtual IFunction get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.Tree.IIdentifier {
    [NotNullAttribute]
public string Name { get; }
    public abstract virtual string get_Name();
}
public interface JetBrains.ReSharper.Psi.Tree.IInitializerOwnerDeclaration {
    [CanBeNullAttribute]
public ITreeNode Initializer { get; }
    public abstract virtual ITreeNode get_Initializer();
}
public interface JetBrains.ReSharper.Psi.Tree.ILiteralExpression {
    public ITokenNode Literal { get; }
    public abstract virtual ITokenNode get_Literal();
}
public interface JetBrains.ReSharper.Psi.Tree.IModifiersOwnerDeclaration {
    [CanBeNullAttribute]
public IModifiersOwner ModifiersOwner { get; }
    public abstract virtual void SetAbstract(bool value);
    public abstract virtual void SetSealed(bool value);
    public abstract virtual void SetVirtual(bool value);
    public abstract virtual void SetOverride(bool value);
    public abstract virtual void SetStatic(bool value);
    public abstract virtual void SetReadonly(bool value);
    public abstract virtual void SetExtern(bool value);
    public abstract virtual void SetUnsafe(bool value);
    public abstract virtual void SetVolatile(bool value);
    public abstract virtual IModifiersOwner get_ModifiersOwner();
}
public interface JetBrains.ReSharper.Psi.Tree.INamespaceDeclaration {
    [CanBeNullAttribute]
public INamespace DeclaredElement { get; }
    public string QualifiedName { get; }
    public abstract virtual INamespace get_DeclaredElement();
    public abstract virtual DocumentRange GetDeclaredNameDocumentRange();
    public abstract virtual string get_QualifiedName();
    public abstract virtual void SetQualifiedName(string qualifiedName);
}
public interface JetBrains.ReSharper.Psi.Tree.INamespaceDeclarationHolder {
    [NotNullAttribute]
public IReadOnlyList`1<INamespaceDeclaration> NamespaceDeclarations { get; }
    [NotNullAttribute]
public IEnumerable`1<INamespaceDeclaration> NamespaceDeclarationsEnumerable { get; }
    public abstract virtual IReadOnlyList`1<INamespaceDeclaration> get_NamespaceDeclarations();
    public abstract virtual IEnumerable`1<INamespaceDeclaration> get_NamespaceDeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.Tree.IParameterDeclaration {
    [NotNullAttribute]
public IParameter DeclaredElement { get; }
    public abstract virtual IParameter get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.Tree.IParametersOwnerDeclaration {
    [NotNullAttribute]
public IList`1<IParameterDeclaration> ParameterDeclarations { get; }
    [CanBeNullAttribute]
public IParametersOwner DeclaredParametersOwner { get; }
    public abstract virtual IList`1<IParameterDeclaration> get_ParameterDeclarations();
    public abstract virtual IParametersOwner get_DeclaredParametersOwner();
    [NotNullAttribute]
public abstract virtual IParameterDeclaration AddParameterDeclarationBefore(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    [NotNullAttribute]
public abstract virtual IParameterDeclaration AddParameterDeclarationAfter(ParameterKind kind, IType parameterType, string parameterName, IParameterDeclaration anchor);
    public abstract virtual void RemoveParameterDeclaration(int index);
}
public interface JetBrains.ReSharper.Psi.Tree.IStatement {
}
public interface JetBrains.ReSharper.Psi.Tree.IStatementsRange {
    [NotNullAttribute]
public ITreeRange TreeRange { get; }
    [NotNullAttribute]
public IList`1<IStatement> Statements { get; }
    public abstract virtual ITreeRange get_TreeRange();
    public abstract virtual IList`1<IStatement> get_Statements();
}
public interface JetBrains.ReSharper.Psi.Tree.ITokenNode {
    [NotNullAttribute]
[PureAttribute]
public abstract virtual TokenNodeType GetTokenType();
}
public interface JetBrains.ReSharper.Psi.Tree.ITreeNode {
    [CanBeNullAttribute]
public ITreeNode Parent { get; }
    [CanBeNullAttribute]
public ITreeNode FirstChild { get; }
    [CanBeNullAttribute]
public ITreeNode LastChild { get; }
    [CanBeNullAttribute]
public ITreeNode NextSibling { get; }
    [CanBeNullAttribute]
public ITreeNode PrevSibling { get; }
    [NotNullAttribute]
public NodeType NodeType { get; }
    [NotNullAttribute]
public PsiLanguageType Language { get; }
    public NodeUserData UserData { get; }
    public NodeUserData PersistentUserData { get; }
    public abstract virtual ITreeNode get_Parent();
    public abstract virtual ITreeNode get_FirstChild();
    public abstract virtual ITreeNode get_LastChild();
    public abstract virtual ITreeNode get_NextSibling();
    public abstract virtual ITreeNode get_PrevSibling();
    public abstract virtual NodeType get_NodeType();
    public abstract virtual PsiLanguageType get_Language();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IPsiServices GetPsiServices();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IPsiModule GetPsiModule();
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IPsiSourceFile GetSourceFile();
    [PureAttribute]
public abstract virtual ReferenceCollection GetFirstClassReferences();
    public abstract virtual void ProcessDescendantsForResolve(IRecursiveElementProcessor processor);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual TTreeNode GetContainingNode(bool returnThis);
    [ContractAnnotationAttribute("null => false")]
[PureAttribute]
public abstract virtual bool Contains(ITreeNode other);
    [PureAttribute]
public abstract virtual bool IsPhysical();
    [PureAttribute]
public abstract virtual bool IsValid();
    [PureAttribute]
public abstract virtual bool IsFiltered();
    [PureAttribute]
public abstract virtual DocumentRange GetNavigationRange();
    [PureAttribute]
public abstract virtual TreeOffset GetTreeStartOffset();
    [PureAttribute]
public abstract virtual int GetTextLength();
    [NotNullAttribute]
public abstract virtual StringBuilder GetText(StringBuilder to);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IBuffer GetTextAsBuffer();
    [NotNullAttribute]
[PureAttribute]
public abstract virtual string GetText();
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual ITreeNode FindNodeAt(TreeTextRange treeRange);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IReadOnlyCollection`1<ITreeNode> FindNodesAt(TreeOffset treeOffset);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual ITreeNode FindTokenAt(TreeOffset treeTextOffset);
    public abstract virtual NodeUserData get_UserData();
    public abstract virtual NodeUserData get_PersistentUserData();
}
public interface JetBrains.ReSharper.Psi.Tree.ITypeAndNamespaceHolderDeclaration {
    [CanBeNullAttribute]
public ITypeAndNamespaceHolderDeclaration ContainingTypeAndNamespaceHolder { get; }
    public abstract virtual ITypeAndNamespaceHolderDeclaration get_ContainingTypeAndNamespaceHolder();
}
public interface JetBrains.ReSharper.Psi.Tree.ITypeArgumentsOwnerElement {
    public int TypeArgumentsNumber { get; }
    [NotNullAttribute]
public IList`1<IType> TypeArguments { get; }
    public abstract virtual int get_TypeArgumentsNumber();
    public abstract virtual IList`1<IType> get_TypeArguments();
}
public interface JetBrains.ReSharper.Psi.Tree.ITypeDeclaration {
    [NotNullAttribute]
public string CLRName { get; }
    [NotNullAttribute]
public IEnumerable`1<IDeclaredType> SuperTypes { get; }
    [CanBeNullAttribute]
public ITypeElement DeclaredElement { get; }
    [NotNullAttribute]
public IReadOnlyList`1<ITypeDeclaration> NestedTypeDeclarations { get; }
    [NotNullAttribute]
public IEnumerable`1<ITypeDeclaration> NestedTypeDeclarationsEnumerable { get; }
    [NotNullAttribute]
public IReadOnlyList`1<ITypeMemberDeclaration> MemberDeclarations { get; }
    public abstract virtual string get_CLRName();
    public abstract virtual IEnumerable`1<IDeclaredType> get_SuperTypes();
    public abstract virtual ITypeElement get_DeclaredElement();
    public abstract virtual IReadOnlyList`1<ITypeDeclaration> get_NestedTypeDeclarations();
    public abstract virtual IEnumerable`1<ITypeDeclaration> get_NestedTypeDeclarationsEnumerable();
    public abstract virtual IReadOnlyList`1<ITypeMemberDeclaration> get_MemberDeclarations();
}
public interface JetBrains.ReSharper.Psi.Tree.ITypeDeclarationHolder {
    [NotNullAttribute]
public IReadOnlyList`1<ITypeDeclaration> TypeDeclarations { get; }
    [NotNullAttribute]
public IEnumerable`1<ITypeDeclaration> TypeDeclarationsEnumerable { get; }
    public abstract virtual IReadOnlyList`1<ITypeDeclaration> get_TypeDeclarations();
    public abstract virtual IEnumerable`1<ITypeDeclaration> get_TypeDeclarationsEnumerable();
}
public interface JetBrains.ReSharper.Psi.Tree.ITypeDeclarationWithRangeContainer {
}
public interface JetBrains.ReSharper.Psi.Tree.ITypeMemberDeclaration {
    [CanBeNullAttribute]
public ITypeMember DeclaredElement { get; }
    [CanBeNullAttribute]
public abstract virtual ITypeDeclaration GetContainingTypeDeclaration();
    public abstract virtual ITypeMember get_DeclaredElement();
}
public interface JetBrains.ReSharper.Psi.Tree.ITypeOwnerDeclaration {
    [NotNullAttribute]
public IType Type { get; }
    public abstract virtual void SetType(IType type);
    public abstract virtual IType get_Type();
}
public interface JetBrains.ReSharper.Psi.Tree.IWhitespaceNode {
    public bool IsNewLine { get; }
    public abstract virtual bool get_IsNewLine();
}
public interface JetBrains.ReSharper.Psi.Tree.IXmlDocOwnerTreeNode {
    [CanBeNullAttribute]
public abstract virtual XmlNode GetXMLDoc(bool inherit);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Tree.ModifiersOwnerDeclarationExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static AccessRights GetSemanticAccessRights(IAccessRightsOwnerDeclaration accessRightsOwnerDeclaration);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Tree.ReferenceCollection : ValueType {
    public static ReferenceCollection Empty;
    [CanBeNullAttribute]
private IReference myReference;
    [CanBeNullAttribute]
private IReadOnlyList`1<IReference> myReferences;
    public bool IsEmpty { get; }
    public int Count { get; }
    public IReference Item { get; }
    public ReferenceCollection(IReference reference);
    public ReferenceCollection(IReadOnlyList`1<IReference> references);
    public ReferenceCollection(IReference[] references);
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public sealed virtual IReference get_Item(int i);
    [PureAttribute]
public int IndexOf(IReference reference);
    [PureAttribute]
public ReferenceCollection Append(IReference reference);
    [PureAttribute]
public ReferenceCollection Append(ReferenceCollection references);
    [PureAttribute]
public ReferenceCollection Prepend(IReference reference);
    [PureAttribute]
public bool Contains(IReference reference);
    public void CopyTo(IReference[] array, int arrayIndex);
    [PureAttribute]
public ReferenceCollection`1<TReference> OfType();
    [PureAttribute]
public ReferenceCollection Where(TState state, Func`3<TState, IReference, bool> predicate);
    [PureAttribute]
public ReferenceCollection Where(Func`2<IReference, bool> predicate);
    [PureAttribute]
public bool Any();
    [PureAttribute]
public bool Any(Func`2<IReference, bool> predicate);
    [PureAttribute]
public IReference First();
    [PureAttribute]
public IReference Last();
    [PureAttribute]
public IReference FirstOrDefault();
    [PureAttribute]
public IReference FirstOrDefault(Func`2<IReference, bool> predicate);
    [PureAttribute]
public IReference LastOrDefault();
    [PureAttribute]
public IReference LastOrDefault(Func`2<IReference, bool> predicate);
    [PureAttribute]
public IReference[] ToArray();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<IReference> System.Collections.Generic.IEnumerable<JetBrains.ReSharper.Psi.Resolve.IReference>.GetEnumerator();
    [PureAttribute]
public ReferenceCollectionEnumerator GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Tree.ReferenceCollection`1 : ValueType {
    public static ReferenceCollection`1<TReference> Empty;
    [CanBeNullAttribute]
private TReference myReference;
    [CanBeNullAttribute]
private IReadOnlyList`1<TReference> myReferences;
    public bool IsEmpty { get; }
    public int Count { get; }
    public TReference Item { get; }
    public ReferenceCollection`1(TReference reference);
    public ReferenceCollection`1(IReadOnlyList`1<TReference> references);
    public ReferenceCollection`1(TReference[] references);
    private static ReferenceCollection`1();
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public sealed virtual TReference get_Item(int i);
    [PureAttribute]
public int IndexOf(TReference reference);
    [PureAttribute]
public ReferenceCollection`1<TReference> Append(TReference reference);
    [PureAttribute]
public ReferenceCollection`1<TReference> Append(ReferenceCollection`1<TReference> references);
    [PureAttribute]
public ReferenceCollection`1<TReference> Prepend(TReference reference);
    [PureAttribute]
public bool Contains(TReference reference);
    public void CopyTo(TReference[] array, int arrayIndex);
    [PureAttribute]
public ReferenceCollection`1<TRef> OfType();
    [PureAttribute]
public ReferenceCollection`1<TReference> Where(TState state, Func`3<TState, TReference, bool> predicate);
    [PureAttribute]
public ReferenceCollection`1<TReference> Where(Func`2<TReference, bool> predicate);
    [PureAttribute]
public bool Any();
    [PureAttribute]
public bool Any(Func`2<TReference, bool> predicate);
    [PureAttribute]
public TReference First();
    [PureAttribute]
public TReference Last();
    [PureAttribute]
public TReference FirstOrDefault();
    [PureAttribute]
public TReference FirstOrDefault(Func`2<TReference, bool> predicate);
    [PureAttribute]
public TReference LastOrDefault();
    [PureAttribute]
public TReference LastOrDefault(Func`2<TReference, bool> predicate);
    [PureAttribute]
public TReference[] ToArray();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<TReference> System.Collections.Generic.IEnumerable<TReference>.GetEnumerator();
    [PureAttribute]
public ReferenceCollectionEnumerator<TReference> GetEnumerator();
}
public class JetBrains.ReSharper.Psi.Tree.ShortNamesCookie : SafeDisposable {
    [CanBeNullAttribute]
[ThreadStaticAttribute]
private static ShortNamesCookie ourInstance;
    public List`1<string> ShortNames;
    [CanBeNullAttribute]
public static ShortNamesCookie Instance { get; }
    public static ShortNamesCookie get_Instance();
    protected virtual void DisposeUnmanagedResources();
    public static void AddName(string name);
    public static void ProcessShortNames(string name, List`1<string> results);
    public static void AddName(StringBuilder name);
    private static void ProcessShortNames(StringBuilder name, List`1<string> results);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Tree.StatementsRangeExtensions : object {
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertValid(IStatementsRange range);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Tree.TokenNodeExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsWhitespaceToken(ITokenNode token);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCommentToken(ITokenNode token);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsIdentifier(ITokenNode token);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
[ObsoleteAttribute("Use .GetPreviousToken() instead")]
public static ITokenNode GetPrevToken(ITokenNode tokenNode);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TokenNodeExtensions/<SelfAndPrevTokens>d__4")]
[ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITokenNode> SelfAndPrevTokens(ITokenNode node);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TokenNodeExtensions/<PrevTokens>d__5")]
[ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITokenNode> PrevTokens(ITokenNode node);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TokenNodeExtensions/<SelfAndNextTokens>d__6")]
[ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITokenNode> SelfAndNextTokens(ITokenNode node);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TokenNodeExtensions/<NextTokens>d__7")]
[ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITokenNode> NextTokens(ITokenNode node);
}
public enum JetBrains.ReSharper.Psi.Tree.TreeNodeActionType : Enum {
    public int value__;
    public static TreeNodeActionType ACCEPT;
    public static TreeNodeActionType CONTINUE;
    public static TreeNodeActionType IGNORE_SUBTREE;
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class JetBrains.ReSharper.Psi.Tree.TreeNodeCollection`1 : ValueType {
    public static TreeNodeCollection`1<T> Empty;
    [DebuggerBrowsableAttribute("3")]
[NotNullAttribute]
internal T[] myNodes;
    public bool IsEmpty { get; }
    public int Count { get; }
    public T Item { get; public set; }
    [DebuggerBrowsableAttribute("0")]
[CanBeNullAttribute]
public T SingleItem { get; }
    public TreeNodeCollection`1<T> Item { get; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public TreeNodeCollection`1(T[] nodes);
    private static TreeNodeCollection`1();
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int i);
    public sealed virtual void set_Item(int i, T value);
    [DebuggerStepThroughAttribute]
public T get_SingleItem();
    [PureAttribute]
[DebuggerStepThroughAttribute]
public int IndexOf(T node);
    public TreeNodeCollection`1<T> get_Item(Range range);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    public sealed virtual bool Contains(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    [PureAttribute]
public Enumerator<T> GetEnumerator();
    [PureAttribute]
public bool Any();
    [PureAttribute]
public bool Any(Func`2<T, bool> predicate);
    [PureAttribute]
public bool All(Func`2<T, bool> predicate);
    [LinqTunnelAttribute]
public IEnumerable`1<TResult> Select(Func`2<T, TResult> selector);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeCollection`1/<SelectImpl>d__33`1")]
private IEnumerable`1<TResult> SelectImpl(Func`2<T, TResult> selector);
    [LinqTunnelAttribute]
public IEnumerable`1<T> Where(Func`2<T, bool> predicate);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeCollection`1/<WhereImpl>d__35")]
[LinqTunnelAttribute]
private IEnumerable`1<T> WhereImpl(Func`2<T, bool> predicate);
    [PureAttribute]
[NotNullAttribute]
public List`1<T> ToList();
    [PureAttribute]
[NotNullAttribute]
public IList`1<T> ToIList();
    [PureAttribute]
[NotNullAttribute]
public IReadOnlyList`1<T> ToIReadOnlyList();
    [PureAttribute]
[NotNullAttribute]
public List`1<TResult> ToList(Func`2<T, TResult> selector);
    [PureAttribute]
[NotNullAttribute]
public List`1<T> ToListWhere(Func`2<T, bool> predicate);
    [PureAttribute]
[NotNullAttribute]
public TResult[] ToArray(Func`2<T, TResult> selector);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeCollection`1/<Reverse>d__42")]
[PureAttribute]
[NotNullAttribute]
public IEnumerable`1<T> Reverse();
    [PureAttribute]
[NotNullAttribute]
public IEnumerable`1<TTarget> OfType();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeCollection`1/<OfTypeImpl>d__44`1")]
[PureAttribute]
[NotNullAttribute]
private IEnumerable`1<TTarget> OfTypeImpl();
    [PureAttribute]
[CanBeNullAttribute]
public T FirstOrDefault();
    [PureAttribute]
[CanBeNullAttribute]
public T FirstOrDefault(Func`2<T, bool> predicate);
    [PureAttribute]
public T Single();
    [PureAttribute]
[CanBeNullAttribute]
public T SingleOrDefault();
    [PureAttribute]
public T First();
    [PureAttribute]
public T First(Func`2<T, bool> predicate);
    [PureAttribute]
[CanBeNullAttribute]
public T LastOrDefault();
    [PureAttribute]
[CanBeNullAttribute]
public T LastOrDefault(Func`2<T, bool> predicate);
    [PureAttribute]
public T Last();
    [PureAttribute]
[CanBeNullAttribute]
public T Last(Func`2<T, bool> predicate);
    [ContractAnnotationAttribute("=> halt")]
private static void ThrowNoElements();
    [ContractAnnotationAttribute("=> halt")]
private static void ThrowMoreThanOneElement();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Tree.TreeNodeCollectionExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static TreeNodeCollection`1<T> ToTreeNodeCollection(IEnumerable`1<T> nodes);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsEmpty(TreeNodeCollection`1<T> collection);
    [ExtensionAttribute]
[PureAttribute]
public static TreeNodeCollection`1<TTo> Cast(TreeNodeCollection`1<TFrom> collection);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static TTo[] ToArray(TreeNodeCollection`1<TFrom> collection);
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<TTo> ToIList(TreeNodeCollection`1<TFrom> collection);
    [ExtensionAttribute]
public static TreeNodeCollection`1<TTo> ToTreeNodeCollection(TreeNodeCollection`1<TFrom> collection, Range range);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Tree.TreeNodeEnumerable`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TreeNodeEnumerable`1<T> Empty;
    private object myRootOrEnumerable;
    private long myComplexRole;
    public T SingleItem { get; }
    public TreeNodeEnumerable`1(CompositeElement root, short role0);
    public TreeNodeEnumerable`1(CompositeElement root, short role1, short role0);
    public TreeNodeEnumerable`1(CompositeElement root, short role2, short role1, short role0);
    public TreeNodeEnumerable`1(CompositeElement root, short role3, short role2, short role1, short role0);
    [NullableContextAttribute("1")]
public TreeNodeEnumerable`1(IEnumerable`1<T> customGenerator);
    private static TreeNodeEnumerable`1();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public T get_SingleItem();
    [PureAttribute]
public bool IsEmpty();
    [PureAttribute]
public bool IsSingle();
    [PureAttribute]
public bool Any();
    [PureAttribute]
public int Count();
    [PureAttribute]
public T FirstOrDefault();
    [PureAttribute]
public T LastOrDefault();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions : object {
    public static Key`1<IModuleReferenceResolveContext> FileResolveContextKey;
    private static TreeNodeExtensions();
    [ExtensionAttribute]
[PureAttribute]
public static ThisAndDescendantsEnumerator ThisAndDescendants(ITreeNode root);
    [ExtensionAttribute]
[PureAttribute]
public static FilteredThisAndDescendantsEnumerator`1<TNode> ThisAndDescendants(ITreeNode root);
    [ExtensionAttribute]
[PureAttribute]
public static DescendantsEnumerator Descendants(ITreeNode root);
    [ExtensionAttribute]
[PureAttribute]
public static ReversedDescendantsEnumerator DescendantsReversed(ITreeNode root);
    [ExtensionAttribute]
[PureAttribute]
public static DescendantsEnumerator Descendants(ITreeNode root, ITreeNode startNode);
    [ExtensionAttribute]
[PureAttribute]
public static FilteredDescendantsEnumerator`1<TNode> Descendants(ITreeNode root);
    [ExtensionAttribute]
[PureAttribute]
public static FilteredDescendantsEnumerator`1<TNode> Descendants(ITreeNode root, ITreeNode startNode);
    [ExtensionAttribute]
[PureAttribute]
public static CompositeDescendantsEnumerator CompositeDescendants(ITreeNode root);
    [ExtensionAttribute]
[PureAttribute]
public static FilteredCompositeDescendantsEnumerator`1<TNode> FilteredCompositeDescendants(ITreeNode root);
    [ExtensionAttribute]
[PureAttribute]
public static ContainingNodeEnumerator`1<TNode> ContainingNodes(ITreeNode treeNode, bool returnThis);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<ToEnumerable>d__19")]
[ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITreeNode> ToEnumerable(ThisAndDescendantsEnumerator enumerator);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<ToEnumerable>d__20")]
[ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITreeNode> ToEnumerable(DescendantsEnumerator enumerator);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<ToEnumerable>d__21`1")]
[ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<TNode> ToEnumerable(FilteredThisAndDescendantsEnumerator`1<TNode> enumerator);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<ToEnumerable>d__22`1")]
[ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<TNode> ToEnumerable(FilteredDescendantsEnumerator`1<TNode> enumerator);
    [ExtensionAttribute]
[PureAttribute]
public static ContainingNodeEnumerator ContainingNodes(ITreeNode treeNode, bool returnThis);
    [ExtensionAttribute]
public static ChildrenNodeEnumerator ChildrenEnumerator(ITreeNode treeNode);
    [ExtensionAttribute]
public static ChildrenNodeEnumerator`1<TNode> ChildrenEnumerator(ITreeNode treeNode);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<RightSiblings>d__30")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITreeNode> RightSiblings(ITreeNode startNode);
    [ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITreeNode> RightSiblings(ITreeNode startNode, ITreeNode tillNode);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<SelfAndRightSiblings>d__32")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITreeNode> SelfAndRightSiblings(ITreeNode startNode);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<SelfAndRightSiblings>d__33")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITreeNode> SelfAndRightSiblings(ITreeNode startNode, ITreeNode tillNode);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<LeftSiblings>d__34")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITreeNode> LeftSiblings(ITreeNode startNode);
    [ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITreeNode> LeftSiblings(ITreeNode startNode, ITreeNode tillNode);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<SelfAndLeftSiblings>d__36")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITreeNode> SelfAndLeftSiblings(ITreeNode startNode);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<Children>d__37")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITreeNode> Children(ITreeNode node);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<Children>d__38`1")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<TTreeNode> Children(ITreeNode root);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<GetFilteredChildren>d__39")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITreeNode> GetFilteredChildren(ITreeNode node);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<ReverseChildren>d__40")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITreeNode> ReverseChildren(ITreeNode node);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<PathToRoot>d__41")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITreeNode> PathToRoot(ITreeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ISandBox OwningSandbox(ITreeNode node);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<PathToRootThroughSandbox>d__43")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITreeNode> PathToRootThroughSandbox(ITreeNode node);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<SelfAndPathToRoot>d__44")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITreeNode> SelfAndPathToRoot(ITreeNode node);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ITreeNode Root(ITreeNode node);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<FirstDescendants>d__46")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITreeNode> FirstDescendants(ITreeNode node);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<SelfAndFirstDescendants>d__47")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITreeNode> SelfAndFirstDescendants(ITreeNode node);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<LastDescendants>d__48")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITreeNode> LastDescendants(ITreeNode node);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<SelfAndLastDescendants>d__49")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITreeNode> SelfAndLastDescendants(ITreeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static TokenNodeType GetTokenType(ITreeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITokenNode FindFirstTokenIn(ITreeNode node);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ITokenNode GetFirstTokenIn(ITreeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITokenNode FindLastTokenIn(ITreeNode node);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ITokenNode GetLastTokenIn(ITreeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static TokenNodeType FindFirstTokenTypeIn(ITreeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static TokenNodeType FindLastTokenTypeIn(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsWhitespaceToken(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsCommentToken(ITreeNode node);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<Tokens>d__59")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITokenNode> Tokens(ITreeNode node);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<ReverseTokens>d__60")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITokenNode> ReverseTokens(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static int GetDepth(ITreeNode node);
    [ExtensionAttribute]
[NotNullAttribute]
public static ITreeNode GetCommonParent(ITreeNode node1, ITreeNode node2);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITreeNode FindCommonParent(ITreeNode node1, ITreeNode node2);
    [ExtensionAttribute]
[NotNullAttribute]
public static ITreeNode FindLCA(ITreeNode node1, ITreeNode node2);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITreeNode FindLCA(IEnumerable`1<ITreeNode> nodes);
    [ExtensionAttribute]
public static int ComparePositionTo(ITreeNode node1, ITreeNode node2, bool compareNodeEndPos);
    [ExtensionAttribute]
public static int ComparePositionToEx(ITreeNode node1, ITreeNode node2, bool useNode1End, bool useNode2End);
    public static int CompareSiblingNodesPosition(ITreeNode node1, ITreeNode node2);
    [ExtensionAttribute]
public static bool ContainsErrorElement(ITreeNode node);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IModuleReferenceResolveContext GetResolveContext(ITreeNode treeNode);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITreeNode FindPreviousNode(ITreeNode node, Func`2<ITreeNode, TreeNodeActionType> predicate);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITreeNode FindNextNode(ITreeNode node, Func`2<ITreeNode, TreeNodeActionType> predicate);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static ITreeNode GetSelfOrNextSiblingByNodeType(ITreeNode node, NodeTypeSet set);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
[ObsoleteAttribute("Use .GetNextMeaningfulSibling() instead")]
public static ITreeNode GetMeaningfulRightSib(ITreeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
[ObsoleteAttribute("Use .GetPreviousMeaningfulSibling() instead")]
public static ITreeNode GetMeaningfulLeftSib(ITreeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITreeNode GetNextMeaningfulChild(ITreeNode node, ITreeNode child);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITreeNode GetPreviousMeaningfulChild(ITreeNode node, ITreeNode child);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITreeNode GetNextMeaningfulSibling(ITreeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITreeNode GetPreviousMeaningfulSibling(ITreeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITreeNode GetNextNonWhitespaceSibling(ITreeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITreeNode GetPreviousNonWhitespaceSibling(ITreeNode node);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITreeNode> MeaningfulChildren(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
[ObsoleteAttribute("Semantic is not clear (zero-width node can contain zero-width children). Probably use 'IsZeroLength' instead")]
public static bool IsEmpty(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsZeroLength(ITreeNode node);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITokenNode GetNextToken(ITreeNode treeNode);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITokenNode GetPreviousToken(ITreeNode treeNode);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITokenNode GetNextMeaningfulToken(ITreeNode node, bool includeThisNode);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITokenNode GetPreviousMeaningfulToken(ITreeNode node, bool includeThisNode);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITokenNode GetNextNonWhitespaceToken(ITreeNode node, bool includeThisNode);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITokenNode GetPreviousNonWhitespaceToken(ITreeNode node, bool includeThisNode);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<NextTokens>d__92")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITokenNode> NextTokens(ITreeNode startNode);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<PrevTokens>d__93")]
[ExtensionAttribute]
[ItemNotNullAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<ITokenNode> PrevTokens(ITreeNode startNode);
    [ExtensionAttribute]
[PureAttribute]
public static TreeOffset GetTreeEndOffset(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static TreeTextRange GetTreeTextRange(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentOffset GetDocumentStartOffset(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentOffset GetDocumentEndOffset(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentRange GetDocumentRange(ITreeNode element);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<DocumentRange> GetIntersectingDocumentRanges(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentRange GetCoveringDocumentRange(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentRange GetJointDocumentRange(ITreeNode element);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IProject GetProject(ITreeNode element);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ISolution GetSolution(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsReference(ITreeNode element, IReference reference);
    [ExtensionAttribute]
[PureAttribute]
public static ReferenceCollection`1<T> GetReferences(ITreeNode element, IReferenceNameContainer names);
    [ExtensionAttribute]
[PureAttribute]
public static ReferenceCollection GetReferences(ITreeNode element, IReferenceNameContainer names);
    [ExtensionAttribute]
[PureAttribute]
public static ReferenceCollection GetReferences(ITreeNode element, IReferenceProvider referenceProvider, IReferenceNameContainer names);
    [ExtensionAttribute]
[PureAttribute]
public static ReferenceCollection GetReferencesWithValidCompilationContext(ITreeNode element, IReferenceProvider referenceProvider, IReferenceNameContainer names);
    [ExtensionAttribute]
private static ReferenceCollection GetReferencesImpl(ITreeNode element, IReferenceProvider referenceProvider, IReferenceNameContainer names);
    private static ReferenceCollection GetFirstClassReferencesImpl(ITreeNode element, IReferenceNameContainer names);
    [ExtensionAttribute]
public static ReferenceCollection GetSecondClassReferences(ITreeNode element);
    [ExtensionAttribute]
public static ReferenceCollection GetSecondClassReferences(ITreeNode element, IReferenceNameContainer names);
    [ExtensionAttribute]
[NotNullAttribute]
[MustUseReturnValueAttribute]
public static TTreeNode Copy(TTreeNode node, ITreeNode context);
    [ExtensionAttribute]
[NotNullAttribute]
[MustUseReturnValueAttribute]
public static TTreeNode CopyWithResolve(TTreeNode node);
    [ExtensionAttribute]
[ObsoleteAttribute("use 'using (WriteLockCookie.Create(node))' instead")]
[NotNullAttribute]
public static IDisposable CreateWriteLock(ITreeNode element);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static TReference FindReference(ITreeNode element, Predicate`1<TReference> predicate);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static TReference FindReference(ITreeNode element, TreeOffset treeOffset);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static T FindReference(ITreeNode element);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static TTreeNode GetContainingNode(ITreeNode element, Predicate`1<TTreeNode> predicate, bool returnThis);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static TTreeNode GetContainingNodeInRoot(ITreeNode element, ITreeNode root, bool returnThis);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITreeNode GetContainingNode(ITreeNode element, Type nodeType, bool returnThis);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IFile GetContainingFile(ITreeNode element);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static TTreeNode GetContainingNodeAt(ITreeNode element, TreeOffset treeOffset);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertIsValid(ITreeNode element, string messageText);
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertChildrenCorrespondsToParents(ITreeNode element);
    [ExtensionAttribute]
[ObsoleteAttribute("Use .ThisAndDescendants() instead")]
[EditorBrowsableAttribute("1")]
public static IEnumerable`1<ITreeNode> EnumerateSubTree(ITreeNode element);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Tree.TreeNodeExtensions/<EnumerateTo>d__127")]
[ExtensionAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<ITreeNode> EnumerateTo(ITreeNode from, ITreeNode to);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITreeNode ParentThroughSandBox(ITreeNode node);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IContextBoundSettingsStore GetSettingsStore(ITreeNode node);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IContextBoundSettingsStore GetSettingsStoreWithEditorConfig(ITreeNode node);
    [ExtensionAttribute]
[NotNullAttribute]
public static Func`3<Lifetime, DataContexts, IDataContext> ToDataContext(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[NotNullAttribute]
public static Func`3<Lifetime, DataContexts, IDataContext> ToDataContext(IPsiModule psiModule);
    [ExtensionAttribute]
[NotNullAttribute]
public static Func`3<Lifetime, DataContexts, IDataContext> ToDataContext(ITreeNode node);
    [ExtensionAttribute]
[NotNullAttribute]
public static PsiLanguageType GetKnownLanguage(ITreeNode node);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IReadOnlyList`1<IReference> FindReferencesAt(ITreeNode node, TreeTextRange treeTextRange);
    [ExtensionAttribute]
[NotNullAttribute]
public static StringBuilder GetTextOfCachableNodes(ITreeNode treeNode, bool processShortNames);
    [ExtensionAttribute]
[PureAttribute]
public static TreeOffset GetTreeStartOffsetThroughSandbox(ITreeNode element);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static TTreeNode UnwrapFromReplaceSandbox(TTreeNode treeNode);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IFile GetContainingFileThroughSandBox(ITreeNode element);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentOffset GetDocumentStartOffsetThroughSandbox(ITreeNode element);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ProjectedLexer TryGetLexerForClosedChameleonBody(IChameleonNode chameleonNode);
    [ExtensionAttribute]
[PureAttribute]
public static PsiLanguageCategories GetLanguageCategories(ITreeNode node);
    [CompilerGeneratedAttribute]
internal static ITreeNode <FindPreviousNode>g__GetMostInnerAcceptedNode|72_0(ITreeNode root, Func`2<ITreeNode, TreeNodeActionType> predicate);
}
public abstract class JetBrains.ReSharper.Psi.TreeBuilder.CompositeNodeWithArgumentType : CompositeNodeType {
    protected CompositeNodeWithArgumentType(string s, int index);
    [NotNullAttribute]
public abstract virtual CompositeElement Create(object message);
}
public interface JetBrains.ReSharper.Psi.TreeBuilder.ILazyCachingLexer {
    public int CurrentPosition { get; public set; }
    public TokenBuffer TokenBuffer { get; }
    public abstract virtual void SetPositionAndAdvance(int tokenNum);
    public abstract virtual int get_CurrentPosition();
    public abstract virtual void set_CurrentPosition(int value);
    public abstract virtual TokenBuffer get_TokenBuffer();
}
public interface JetBrains.ReSharper.Psi.TreeBuilder.IPsiBuilderTokenFactory {
    public abstract virtual LeafElementBase CreateToken(TokenNodeType tokenNodeType, IBuffer buffer, int startOffset, int endOffset);
}
public interface JetBrains.ReSharper.Psi.TreeBuilder.ITreeStructure`1 {
}
public class JetBrains.ReSharper.Psi.TreeBuilder.Marker : ValueType {
    public static int InvalidPointer;
    public MarkerType Type;
    public NodeType ElementType;
    public int FirstChild;
    public int LastChild;
    public int LexemeIndex;
    public int NextMarker;
    public int OppositeMarker;
    public int ParentMarker;
    public object UserData;
    public Marker(MarkerType type, int lexemeIndex);
    public static void AddChild(PsiBuilder builder, int node, int child);
}
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.TreeBuilder.MarkerListPool : AutoClearingThreadSafeObjectPool`1<List`1<Marker>> {
    private static int MaxCount;
    private static int CheckPeriod;
    public MarkerListPool(Lifetime lifetime);
    protected virtual List`1<Marker> CreateObject();
    protected virtual void ClearObject(List`1<Marker> t);
    protected virtual void InitObject(List`1<Marker> t);
    public List`1<Marker> GetOrCreateList(Lifetime lifetime);
}
public enum JetBrains.ReSharper.Psi.TreeBuilder.MarkerType : Enum {
    public int value__;
    public static MarkerType StartMarkerType;
    public static MarkerType DoneMarkerType;
    public static MarkerType DoneAlterTokenMarkerType;
}
public class JetBrains.ReSharper.Psi.TreeBuilder.PsiBuilder : object {
    public static bool DoChecks;
    private int myLexemeCount;
    private ILexer myLexer;
    public List`1<Marker> myProduction;
    private ITokenIntern myTokenIntern;
    private CompositeNodeType myRootType;
    private IPsiBuilderTokenFactory myTokenFactory;
    public TokenBuffer myTokenBuffer;
    public IArrayOfTokens myArrayOfTokens;
    private int myCurrentLexeme;
    private TokenNodeType myCurrentTokenType;
    private int myNonCommentLexeme;
    private bool myIsLazyCachingLexer;
    public int Size { get; }
    public int LexemeCount { get; }
    public PsiBuilder(ILexer lexer, CompositeNodeType rootType, IPsiBuilderTokenFactory tokenFactory, Lifetime lifetime);
    public PsiBuilder(PsiBuilderRange range, CompositeNodeType rootType, Lifetime lifetime);
    private PsiBuilder(ILexer lexer, CompositeNodeType rootType, int start, int stop, IPsiBuilderTokenFactory tokenFactory, Lifetime lifetime);
    private void Bind(int pRootMarker, CompositeElement rootNode);
    private static CompositeElement CreateCompositeElement(Marker item);
    private void InsertLeaves(Int32& curToken, int lastIdx, CompositeElement curNode);
    private void AlterLeaves(Int32& curToken, int lastIdx, CompositeElement curNode, Token token);
    private void AlterLeaves(Int32& curToken, int lastIdx, CompositeElement curNode, Token[] tokens);
    private LeafElementBase CreateToken(TokenNodeType tokenNodeType, IBuffer buffer, int startOffset, int endOffset);
    private void RewindNonCommentLexeme();
    private void UpdateMyCurrentTokenType();
    public void PrepareLightTree();
    public CompositeElement BuildTree();
    public int Mark();
    public void AlterToken(TokenNodeType newTokenNodeType, int count);
    public void AlterToken(int marker, TokenNodeType newTokenNodeType);
    public void AlterTokens(int marker, Token[] newTokens);
    public int PrecedeCurrent();
    public void Precede(int marker);
    public int PrecedeAt(int lexeme);
    public void RollbackTo(int marker);
    public void Drop(int marker);
    public void Error(int marker, string message);
    public void Error(string message);
    public void ErrorBeforeWhitespaces(string message, NodeTypeSet ws);
    public bool IsEmpty(int marker);
    public void Done(int marker, NodeType type, object userData);
    private void DoneImpl(int marker, NodeType type, MarkerType doneMarkerType, object userData);
    public void DoneBeforeWhitespaces(int marker, NodeType type, object userData);
    public bool Eof();
    public TokenNodeType AdvanceLexer();
    [CanBeNullAttribute]
public TokenNodeType GetTokenType(int lookahead);
    public TokenNodeType GetTokenType();
    public string GetTokenText();
    public string GetTokenText(int index);
    public string GetTokenTextIntern();
    public string GetTokenTextIntern(int index);
    public Token GetToken();
    public bool CompareCurrentTokenText(string text, bool caseSensitive);
    public bool CompareTokenText(int index, string text, bool caseSensitive);
    public bool CompareCurrentTokenTextStartsWith(string text);
    public Token GetToken(int index);
    public int GetCurrentLexeme();
    public int GetCurrentNonCommentLexeme();
    public int get_Size();
    public void ResetCurrentLexeme(int currentLexeme, int currentNonCommentLexeme);
    public int GetTokenOffset();
    public IBuffer GetBuffer();
    public int get_LexemeCount();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void CheckInvariant(bool do);
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void DoValidityChecks(int first, int last);
    [PureAttribute]
public ShouldParseCheck GetShouldParseSomethingCheck();
}
public class JetBrains.ReSharper.Psi.TreeBuilder.PsiBuilderTreeNode : ValueType {
    public static PsiBuilderTreeNode Root;
    public int LexemeIndex;
    public int Marker;
    public PsiBuilderTreeNode(int marker, int lexemIndex);
    private static PsiBuilderTreeNode();
}
public class JetBrains.ReSharper.Psi.TreeBuilder.PsiBuilderTreeStructure : ValueType {
    private static PsiBuilderTreeNode ourInvalidNode;
    private PsiBuilder myOwner;
    public PsiBuilderTreeNode InvalidNode { get; }
    public PsiBuilderTreeNode Root { get; }
    public CachingLexer Lexer { get; }
    private static PsiBuilderTreeStructure();
    public PsiBuilderTreeStructure(PsiBuilder owner);
    public PsiBuilderTreeNode get_InvalidNode();
    public PsiBuilderTreeNode get_Root();
    public CachingLexer get_Lexer();
    public PsiBuilderTreeNode GetFirstCompositeChild(PsiBuilderTreeNode node);
    public PsiBuilderTreeNode GetFirstChild(PsiBuilderTreeNode node);
    public PsiBuilderTreeNode GetNextCompositeChild(PsiBuilderTreeNode node);
    public PsiBuilderTreeNode GetNextChild(PsiBuilderTreeNode node);
    public PsiBuilderTreeNode GetParent(PsiBuilderTreeNode node);
    public bool IsValidNode(PsiBuilderTreeNode node);
    public bool IsEqualNodes(PsiBuilderTreeNode node1, PsiBuilderTreeNode node2);
    [CanBeNullAttribute]
public NodeType GetNodeType(PsiBuilderTreeNode node);
    public string GetNodeText(PsiBuilderTreeNode node);
    public int GetNodeOffset(PsiBuilderTreeNode node);
}
public abstract class JetBrains.ReSharper.Psi.TreeBuilder.TreeStructureBuilderBase : object {
    [CompilerGeneratedAttribute]
private ITokenIntern <IdentifierIntern>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <JustSkippedNewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WhitespacesSkipped>k__BackingField;
    protected ITokenIntern IdentifierIntern { get; }
    protected PsiBuilder Builder { get; }
    protected TokenNodeType NewLine { get; }
    protected bool JustSkippedNewLine { get; protected set; }
    protected bool WhitespacesSkipped { get; protected set; }
    protected NodeTypeSet CommentsOrWhiteSpacesTokens { get; }
    protected TreeStructureBuilderBase(Lifetime lifetime);
    [CompilerGeneratedAttribute]
protected ITokenIntern get_IdentifierIntern();
    protected abstract virtual PsiBuilder get_Builder();
    protected abstract virtual TokenNodeType get_NewLine();
    [CompilerGeneratedAttribute]
protected bool get_JustSkippedNewLine();
    [CompilerGeneratedAttribute]
protected void set_JustSkippedNewLine(bool value);
    [CompilerGeneratedAttribute]
protected bool get_WhitespacesSkipped();
    [CompilerGeneratedAttribute]
protected void set_WhitespacesSkipped(bool value);
    protected abstract virtual NodeTypeSet get_CommentsOrWhiteSpacesTokens();
    public CompositeElement GetTree();
    public ITreeStructure`1<PsiBuilderTreeNode> GetLightPsi();
    protected int Mark();
    protected void Done(int marker, NodeType type);
    protected void DoneBeforeWhitespaces(int marker, NodeType type);
    protected virtual void Advance();
    protected virtual void SkipWhitespaces();
    protected TokenNodeType GetTokenType();
    protected bool ExpectToken(NodeType token, bool dontSkipSpacesAfter);
    protected TokenNodeType NextLookAheadWithComments(Int32& index);
    protected TokenNodeType NextLookAhead(Int32& index);
    protected TokenNodeType NextLookAhead(Int32& index, Boolean& skippedNewLine);
    protected TokenNodeType LookAhead(int lookahead);
    protected TokenNodeType LookAheadSkipComments(int lookahead);
    protected TokenNodeType LookAheadSkipComments(int lookahead, Int32& shift);
    protected TokenNodeType LookAheadSkipComments(int lookahead, Int32& shift, Boolean& newLineSkipped);
    protected TokenNodeType LookAheadNoSkipWhitespaces(int lookahead);
    protected bool CheckAndMoveToNextTokenNodeTypeSkipWhitespaces(TokenNodeType type, bool allowNewlineBefore);
    protected void AlterToken(TokenNodeType newTokenNodeType);
    protected void AlterToken(TokenNodeType newTokenNodeType, int count);
    protected abstract virtual string GetExpectedMessage(string name);
    protected virtual void MarkErrorAndSkipToken(string message);
    protected void ErrorBeforeWhitespaces(string typeNameExpected);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.TreeNodeExtension : object {
    [ExtensionAttribute]
[NotNullAttribute]
[MustDisposeResourceAttribute]
public static DisposableMarker`1<TTreeNode> CreateDisposableMarker(TTreeNode node);
}
public class JetBrains.ReSharper.Psi.TreeNodeMarker : object {
    [NotNullAttribute]
private Key`1<object> myKey;
    public TreeNodeMarker(string keyName);
    public void Mark(ITreeNode node);
    public void Unmark(ITreeNode node);
    [NotNullAttribute]
[PureAttribute]
public IReadOnlyList`1<ITreeNode> FindMarkedNodes(ITreeNode tree);
    [CanBeNullAttribute]
[PureAttribute]
public ITreeNode FindMarkedNode(ITreeNode root);
    [ContractAnnotationAttribute("null => false")]
public bool IsMarked(ITreeNode element);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{Offset}")]
public class JetBrains.ReSharper.Psi.TreeOffset : ValueType {
    [DebuggerBrowsableAttribute("0")]
private int myOffset;
    [DebuggerBrowsableAttribute("0")]
public static TreeOffset InvalidOffset;
    [DebuggerBrowsableAttribute("0")]
public static TreeOffset Zero;
    [DebuggerBrowsableAttribute("0")]
public static TreeOffset MaxValue;
    public int Offset { get; }
    [DebuggerStepThroughAttribute]
public TreeOffset(int offset);
    private static TreeOffset();
    public int get_Offset();
    [PureAttribute]
public bool IsValid();
    public sealed virtual int CompareTo(TreeOffset other);
    public sealed virtual bool Equals(TreeOffset other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static TreeOffset op_Subtraction(TreeOffset offset, int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static TreeOffset op_Addition(TreeOffset offset, int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static int op_Subtraction(TreeOffset left, TreeOffset right);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static TreeOffset op_Addition(TreeOffset left, TreeOffset right);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static bool op_Equality(TreeOffset left, TreeOffset right);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static bool op_Inequality(TreeOffset left, TreeOffset right);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static bool op_GreaterThan(TreeOffset left, TreeOffset right);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static bool op_LessThan(TreeOffset left, TreeOffset right);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static bool op_GreaterThanOrEqual(TreeOffset left, TreeOffset right);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static bool op_LessThanOrEqual(TreeOffset left, TreeOffset right);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static TreeOffset Min(TreeOffset left, TreeOffset right);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static TreeOffset Max(TreeOffset left, TreeOffset right);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static TreeOffset op_Increment(TreeOffset offset);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static TreeOffset op_Decrement(TreeOffset offset);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public TreeOffset Shift(int delta);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public TreeTextRange ExtendRight(int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public TreeTextRange ExtendLeft(int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public bool ContainedIn(TreeTextRange& treeTextRange);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.TreeRangeExtensions : object {
    [ExtensionAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertValid(ITreeRange range);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static StringBuilder GetText(ITreeRange range);
    [ExtensionAttribute]
[NotNullAttribute]
public static StringBuilder GetText(ITreeRange range, StringBuilder sb);
    [ExtensionAttribute]
[PureAttribute]
public static TreeTextRange GetTreeTextRange(ITreeRange treeRange);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentRange GetDocumentRange(ITreeRange treeRange);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentRange GetJointDocumentRange(ITreeRange treeRange);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IEnumerable`1<DocumentRange> GetIntersectingDocumentRanges(ITreeRange treeRange);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ITreeRangePointer CreateSurvivableTreeRangePointer(ITreeRange range, bool trackExternals);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ITreeRangePointer CreateTreeRangePointer(ITreeRange range);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebugView,nq}")]
public class JetBrains.ReSharper.Psi.TreeTextRange : ValueType {
    [DebuggerBrowsableAttribute("0")]
private TreeOffset myStartOffset;
    [DebuggerBrowsableAttribute("0")]
private TreeOffset myEndOffset;
    [DebuggerBrowsableAttribute("0")]
public static TreeTextRange InvalidRange;
    public TreeOffset StartOffset { get; }
    public TreeOffset EndOffset { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    [NotNullAttribute]
[DebuggerBrowsableAttribute("0")]
private string DebugView { get; }
    public bool Valid { get; }
    public bool IsNormalized { get; }
    [DebuggerStepThroughAttribute]
public TreeTextRange(TreeOffset offset);
    [DebuggerStepThroughAttribute]
public TreeTextRange(TreeOffset startOffset, TreeOffset endOffset);
    [DebuggerStepThroughAttribute]
[ObsoleteAttribute("Second parameter looks like an untyped end offset, use 'FromLength()' factory method instead")]
public TreeTextRange(TreeOffset startOffset, int length);
    private static TreeTextRange();
    public TreeOffset get_StartOffset();
    public TreeOffset get_EndOffset();
    public int get_Length();
    public bool get_IsEmpty();
    private string get_DebugView();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.IEquatable<JetBrains.ReSharper.Psi.TreeTextRange>.Equals(TreeTextRange other);
    [PureAttribute]
public bool Equals(TreeTextRange& other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [PureAttribute]
public static TreeTextRange Parse(string s);
    [PureAttribute]
public static TreeTextRange FromLength(TreeOffset offset, int length);
    [PureAttribute]
public static TreeTextRange FromLength(int length);
    [PureAttribute]
public TreeOffset GetMinOffset();
    [PureAttribute]
public TreeOffset GetMaxOffset();
    [PureAttribute]
public bool ContainedIn(TreeTextRange& treeRange);
    [PureAttribute]
public bool StrictContainedIn(TreeTextRange& treeRange);
    [PureAttribute]
public bool Contains(TreeTextRange& treeRange);
    [PureAttribute]
public bool Contains(TreeOffset offset);
    [PureAttribute]
public bool ContainsCharIndex(TreeOffset charIndex);
    [PureAttribute]
public TreeTextRange SetStartTo(TreeOffset offset);
    [PureAttribute]
public TreeTextRange SetEndTo(TreeOffset offset);
    [PureAttribute]
public TreeTextRange TrimLeft(int length);
    [PureAttribute]
public TreeTextRange TrimRight(int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public TreeTextRange ExtendLeft(int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public TreeTextRange ExtendRight(int length);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public TreeTextRange Shift(int delta);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public TreeTextRange Shift(TreeOffset delta);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public TreeTextRange Join(TreeTextRange& treeRange);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public TreeTextRange JoinLeft(TreeTextRange& treeRange);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public TreeTextRange JoinRight(TreeTextRange& treeRange);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public bool IntersectsOrContacts(TreeTextRange& treeRange);
    [PureAttribute]
[DebuggerStepThroughAttribute]
public bool StrictIntersects(TreeTextRange& treeRange);
    [PureAttribute]
public TreeTextRange Intersect(TreeTextRange& treeRange);
    [PureAttribute]
public bool IsValid();
    public bool get_Valid();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertValid();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertNormalized();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertContainedIn(TreeTextRange& rangeContainer);
    public bool get_IsNormalized();
    [PureAttribute]
public TreeTextRange Normalized();
    public static bool op_Equality(TreeTextRange& range1, TreeTextRange& range2);
    public static bool op_Inequality(TreeTextRange& range1, TreeTextRange& range2);
    [PureAttribute]
public int DistanceTo(TreeOffset offset);
    [PureAttribute]
public bool IsLeftTo(TreeOffset offset);
    [PureAttribute]
public void Deconstruct(TreeOffset& startOffset, TreeOffset& endOffset);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("Range = ({StartOffset}:{EndOffset}), Length = {Length}")]
public class JetBrains.ReSharper.Psi.TreeTextRange`1 : ValueType {
    [DebuggerBrowsableAttribute("0")]
private TreeOffset myStartOffset;
    [DebuggerBrowsableAttribute("0")]
private TreeOffset myEndOffset;
    [DebuggerBrowsableAttribute("0")]
public static TreeTextRange`1<TKind> InvalidRange;
    public TreeOffset StartOffset { get; }
    public TreeOffset EndOffset { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public bool IsNormalized { get; }
    public TreeTextRange`1(TreeTextRange range);
    public TreeTextRange`1(TreeOffset offset);
    public TreeTextRange`1(TreeOffset startOffset, TreeOffset endOffset);
    private static TreeTextRange`1();
    public TreeOffset get_StartOffset();
    public TreeOffset get_EndOffset();
    public int get_Length();
    public bool get_IsEmpty();
    public bool get_IsNormalized();
    public virtual bool Equals(object obj);
    private sealed virtual override bool System.IEquatable<JetBrains.ReSharper.Psi.TreeTextRange<TKind>>.Equals(TreeTextRange`1<TKind> other);
    [PureAttribute]
public bool Equals(TreeTextRange`1& other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static TreeTextRange`1<TKind> Parse(string s);
    [PureAttribute]
public static TreeTextRange`1<TKind> FromLength(TreeOffset offset, int length);
    [PureAttribute]
public static TreeTextRange`1<TKind> FromLength(int length);
    [PureAttribute]
public TreeOffset GetMinOffset();
    [PureAttribute]
public TreeOffset GetMaxOffset();
    [PureAttribute]
public bool ContainedIn(TreeTextRange`1& treeRange, bool strict);
    [PureAttribute]
public bool StrictContainedIn(TreeTextRange`1& treeRange);
    [PureAttribute]
public bool Contains(TreeTextRange`1& treeRange, bool strict);
    [PureAttribute]
public bool Contains(TreeOffset offset, bool strictly);
    [PureAttribute]
public bool ContainsCharIndex(TreeOffset charindex);
    [PureAttribute]
public TreeTextRange`1<TKind> SetStartTo(TreeOffset offset);
    [PureAttribute]
public TreeTextRange`1<TKind> SetEndTo(TreeOffset offset);
    [PureAttribute]
public TreeTextRange`1<TKind> TrimLeft(int length);
    [PureAttribute]
public TreeTextRange`1<TKind> TrimRight(int length);
    [PureAttribute]
public TreeTextRange`1<TKind> ExtendLeft(int length);
    [PureAttribute]
public TreeTextRange`1<TKind> ExtendRight(int length);
    [PureAttribute]
public TreeTextRange`1<TKind> Shift(int delta);
    [PureAttribute]
public TreeTextRange`1<TKind> Shift(TreeOffset delta);
    [PureAttribute]
public TreeTextRange`1<TKind> Join(TreeTextRange`1& treeRange);
    [PureAttribute]
public TreeTextRange`1<TKind> JoinLeft(TreeTextRange`1& treeRange);
    [PureAttribute]
public TreeTextRange`1<TKind> JoinRight(TreeTextRange`1& treeRange);
    [PureAttribute]
public bool Intersects(TreeTextRange`1& treeRange, bool strict);
    [PureAttribute]
public bool StrictIntersects(TreeTextRange`1& treeRange);
    [PureAttribute]
public TreeTextRange`1<TKind> Intersect(TreeTextRange`1& treeRange);
    [PureAttribute]
public bool IsValid();
    public void AssertValid();
    public void AssertNormalized();
    public void AssertContainedIn(TreeTextRange`1& rangeContainer);
    [PureAttribute]
public TreeTextRange`1<TKind> Normalized();
    public static bool op_Equality(TreeTextRange`1& range1, TreeTextRange`1& range2);
    public static bool op_Inequality(TreeTextRange`1& range1, TreeTextRange`1& range2);
    [PureAttribute]
public int DistanceTo(TreeOffset offset);
    [PureAttribute]
public bool IsLeftTo(TreeOffset offset);
    [PureAttribute]
public TreeTextRange ToTreeTextRange();
    public void Deconstruct(TreeOffset& startOffset, TreeOffset& endOffset);
}
public class JetBrains.ReSharper.Psi.TreeTextRangeComparer : object {
    [NotNullAttribute]
public static IComparer`1<TreeTextRange> Default;
    private static TreeTextRangeComparer();
    public sealed virtual int Compare(TreeTextRange x, TreeTextRange y);
}
public class JetBrains.ReSharper.Psi.TreeTextRangeComparerGenerated : object {
    [NotNullAttribute]
public static TreeTextRangeComparerGenerated Default;
    private static TreeTextRangeComparerGenerated();
    public sealed virtual int Compare(TreeTextRange`1<Generated> x, TreeTextRange`1<Generated> y);
}
public class JetBrains.ReSharper.Psi.TreeTextRangeComparerOriginal : object {
    [NotNullAttribute]
public static TreeTextRangeComparerOriginal Default;
    private static TreeTextRangeComparerOriginal();
    public sealed virtual int Compare(TreeTextRange`1<Original> x, TreeTextRange`1<Original> y);
}
public class JetBrains.ReSharper.Psi.TupleAndDynamicTypeNormalizer : TypeNormalizerBase {
    [NotNullAttribute]
private static TupleAndDynamicTypeNormalizer ourNormalizerInstance;
    private static TupleAndDynamicTypeNormalizer();
    [NotNullAttribute]
public static IType Normalize(IType first, IType second);
    protected virtual string ProcessTupleTypeComponentName(TupleTypeComponent component, TupleTypeComponent context);
    protected virtual IType ProcessTypeElement(IType type, IType context);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.TupleExpressionTypeExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<TupleExpressionTypeComponent> ComponentOrNull(ITupleExpressionType tupleExpressionType, int componentIndex);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IExpressionType ComponentTypeOrUnknown(ITupleExpressionType tupleExpressionType, int componentIndex);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IDeclaredType ForcedConvertToTupleType(ITupleExpressionType tupleExpressionType);
    [ExtensionAttribute]
[PureAttribute]
public static bool AnyThroughTargetTypedExpressionTypes(IExpressionType expressionType, Func`2<IExpressionType, bool> predicate);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{ExplicitName}: {Type}")]
public class JetBrains.ReSharper.Psi.TupleTypeComponent : ValueType {
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExplicitName>k__BackingField;
    [NotNullAttribute]
public IType Type { get; }
    [CanBeNullAttribute]
public string ExplicitName { get; }
    public bool HasExplicitName { get; }
    public TupleTypeComponent(IType type, string explicitName);
    [CompilerGeneratedAttribute]
public IType get_Type();
    [CompilerGeneratedAttribute]
public string get_ExplicitName();
    public bool get_HasExplicitName();
    [PureAttribute]
public static int TryGetIndexByImplicitName(string name);
    [PureAttribute]
[NotNullAttribute]
public static string GetDefaultComponentName(int index);
    [PureAttribute]
public static bool IsForbiddenTupleComponentName(string name, bool caseSensitive);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.TupleTypeDecoration : TypeDecoration {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<TupleTypeComponent> <Components>k__BackingField;
    public IReadOnlyList`1<TupleTypeComponent> Components { get; }
    protected bool IsTemporary { get; }
    private TupleTypeDecoration(IReadOnlyList`1<TupleTypeComponent> components);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<TupleTypeComponent> get_Components();
    protected abstract virtual bool get_IsTemporary();
    internal static TupleTypeDecoration Create(IReadOnlyList`1<TupleTypeComponent> components);
    public virtual TypeDecoration OnDecorate(IType underlyingType);
    public virtual ISymbolTable GetAdditionalSymbols(IType decoratedType, ISymbolTable underlyingSymbolTable);
    public virtual ITypeDecorationPointer CreatePointer();
    public virtual TypeDecoration TryTranslateToCurrentFork(IContentModelForkTranslator translator);
    [NullableContextAttribute("2")]
public virtual bool Equals(TypeDecoration other);
    private static bool EqualComponentNames(IReadOnlyList`1<TupleTypeComponent> components, IReadOnlyList`1<TupleTypeComponent> otherComponents);
    public virtual int GetHashCode();
    private static int GetComponentNamesHashCode(IReadOnlyList`1<TupleTypeComponent> components);
    public virtual string PresentType(IType decoratedType);
    public virtual string ToString();
    private TupleTypeDecoration ApplySubstitution(ITypeElement typeElement, ISubstitution substitution);
    private static ISymbolTable CreateSymbolTableWithNamedComponents(DecoratedType`1<TupleTypeDecoration> tupleType, ISymbolTable rawSymbolTable, int baseComponentIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.TupleTypeExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsTupleType(IType type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Nullable`1<DecoratedType`1<TupleTypeDecoration>> AsTupleType(IType type);
    [ExtensionAttribute]
public static IReadOnlyList`1<TupleTypeComponent> GetComponents(DecoratedType`1<TupleTypeDecoration> tupleType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ITypeElement GetTypeElement(DecoratedType`1<TupleTypeDecoration> tupleType);
    [ExtensionAttribute]
public static ISubstitution GetSubstitution(DecoratedType`1<TupleTypeDecoration> tupleType);
    [ExtensionAttribute]
public static IType GetComponentTypeOrUnknown(DecoratedType`1<TupleTypeDecoration> tupleType, int componentIndex);
    [ExtensionAttribute]
public static Nullable`1<TupleTypeComponent> GetComponentOrNull(DecoratedType`1<TupleTypeDecoration> tupleType, int componentIndex);
    [ExtensionAttribute]
public static IType GetTupleComponentTypeByIndexOrUnknown(IType type, int componentIndex);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static int IndexOfComponent(DecoratedType`1<TupleTypeDecoration> tupleType, string componentName, bool caseSensitive);
    [ExtensionAttribute]
public static bool HasNamedComponents(DecoratedType`1<TupleTypeDecoration> tupleType);
    [ExtensionAttribute]
public static bool IsAnyComponentNamed(IReadOnlyList`1<TupleTypeComponent> tupleTypeComponents);
    [ExtensionAttribute]
public static bool HasNamedTupleComponentsInStructure(IType type);
}
public abstract class JetBrains.ReSharper.Psi.TypeArgumentValidationResult : object {
    public bool IsOk { get; }
    public abstract virtual bool get_IsOk();
}
public enum JetBrains.ReSharper.Psi.TypeClassification : Enum {
    public int value__;
    public static TypeClassification UNKNOWN;
    public static TypeClassification VALUE_TYPE;
    public static TypeClassification REFERENCE_TYPE;
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.TypeComparisonFlags : Enum {
    public int value__;
    public static TypeComparisonFlags None;
    public static TypeComparisonFlags IgnoreUnknownTypes;
    public static TypeComparisonFlags IgnoreIdentityConversion;
    public static TypeComparisonFlags IgnoreTupleNames;
    public static TypeComparisonFlags IgnoreNullableAnnotations;
    public static TypeComparisonFlags IgnoreUnknownNullabilityModifier;
    public static TypeComparisonFlags IgnoreValueTrackingNullabilityModifiers;
    public static TypeComparisonFlags IgnoreNativeIntegers;
    public static TypeComparisonFlags AllIgnoreOptions;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.TypeConstraintsVerifierExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool CanBeUsedAsTypeArgument(ITypeConstraintsVerifier typeConstraintsVerifier, IType typeArgument, bool allowByRefLikeType);
}
public enum JetBrains.ReSharper.Psi.TypeContainerStyle : Enum {
    public int value__;
    public static TypeContainerStyle NONE;
    public static TypeContainerStyle AFTER;
    public static TypeContainerStyle AFTER_WITH_KIND;
    public static TypeContainerStyle AFTER_IN_PARENTHESIS;
    public static TypeContainerStyle AFTER_IN_PARENTHESIS_WITH_KIND;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.TypeDecoration : object {
    public virtual TypeDecoration OnDecorate(IType underlyingType);
    public virtual TUnderlyingType GetUnderlyingTypeProxy(TUnderlyingType underlyingType);
    public virtual ISymbolTable GetAdditionalSymbols(IType decoratedType, ISymbolTable underlyingSymbolTable);
    public virtual ISymbolTable TransformSymbolTable(IType decoratedType, ISymbolTable symbolTable);
    public virtual RichText PresentType(IType decoratedType, PsiLanguageType language, TypePresentationStyle style);
    public virtual string PresentType(IType decoratedType);
    public abstract virtual ITypeDecorationPointer CreatePointer();
    public virtual TypeDecoration TryTranslateToCurrentFork(IContentModelForkTranslator translator);
    [NullableContextAttribute("2")]
public abstract virtual bool Equals(TypeDecoration other);
    public abstract virtual int GetHashCode();
    public abstract virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(TypeDecoration left, TypeDecoration right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(TypeDecoration left, TypeDecoration right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public abstract class JetBrains.ReSharper.Psi.TypeDecorationSet : object {
    public static TypeDecorationSet Empty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<TypeDecoration, TypeDecorationSet> ourLazyCachedSets;
    public int Count { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public IList`1<TypeModifier> TypeModifiers { get; }
    private static Dictionary`2<TypeDecoration, TypeDecorationSet> CachedSets { get; }
    protected TypeDecoration Item { get; }
    private static TypeDecorationSet();
    [PureAttribute]
public abstract virtual TypeDecorationSet Decorate(IType type);
    public abstract virtual int get_Count();
    [PureAttribute]
public Enumerator GetEnumerator();
    [NullableContextAttribute("0")]
[PureAttribute]
public abstract virtual TDecoration Get();
    [NullableContextAttribute("0")]
[PureAttribute]
public bool Contains();
    public virtual NullableAnnotation get_NullableAnnotation();
    public virtual IList`1<TypeModifier> get_TypeModifiers();
    [PureAttribute]
public abstract virtual TypeDecorationSet Add(TypeDecoration decoration);
    [PureAttribute]
public abstract virtual TypeDecorationSet Remove();
    [PureAttribute]
public virtual TypeDecorationSet WithNullableAnnotation(NullableAnnotation nullableAnnotation);
    [PureAttribute]
public abstract virtual ITypeDecorationSetPointer CreatePointer();
    [PureAttribute]
public static TypeDecorationSet Create(NullableAnnotation nullableAnnotation);
    [PureAttribute]
public static TypeDecorationSet Create(IList`1<TypeModifier> typeModifiers);
    [PureAttribute]
public static TypeDecorationSet Create(NullableAnnotation nullableAnnotation, IList`1<TypeModifier> typeModifiers);
    private static Dictionary`2<TypeDecoration, TypeDecorationSet> get_CachedSets();
    private static Dictionary`2<TypeDecoration, TypeDecorationSet> CreatePredefinedSets();
    [PureAttribute]
public static TypeDecorationSet Create(TypeDecoration decoration);
    [PureAttribute]
public static TypeDecorationSet Create(TypeDecoration decoration1, TypeDecoration decoration2);
    [PureAttribute]
public static TypeDecorationSet Create(TypeDecoration decoration1, TypeDecoration decoration2, TypeDecoration decoration3);
    [PureAttribute]
public static Builder CreateBuilder(int initialCapacity);
    [PureAttribute]
public virtual TypeDecorationSet Union(TypeDecorationSet other, Func`3<TypeDecoration, TypeDecoration, TypeDecoration> mergeFunc);
    [PureAttribute]
public virtual TypeDecorationSet Intersect(TypeDecorationSet other, Func`3<TypeDecoration, TypeDecoration, TypeDecoration> mergeFunc);
    [PureAttribute]
private static TypeDecorationSet UnionSingletonWith(TypeDecorationSet self, TypeDecorationSet otherSet, Func`3<TypeDecoration, TypeDecoration, TypeDecoration> mergeFunc);
    [PureAttribute]
private static TypeDecorationSet IntersectSingletonWith(TypeDecorationSet self, TypeDecorationSet otherSet, Func`3<TypeDecoration, TypeDecoration, TypeDecoration> mergeFunc);
    [PureAttribute]
private static int FindIndex(TypeDecorationSet typeDecorationSet, Type decorationType);
    public virtual string ToString();
    protected abstract virtual TypeDecoration get_Item(int index);
    private static TypeDecoration ThrowOutOfRange();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.TypeElementExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IType WithIdSubstitution(ITypeElement typeElement);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IDeclaredType WithSubstitutionFromMember(ITypeElement typeElement, ISubstitution substitution, NullableAnnotation nullableAnnotation);
    [ExtensionAttribute]
[PureAttribute]
public static HybridCollection`1<ISubstitution> GetAncestorSubstitution(ITypeElement typeElement, ITypeElement ancestorTypeElement);
    [ExtensionAttribute]
[PureAttribute]
public static int GetDistance(ITypeElement typeElement, ITypeElement ancestorTypeElement);
    [ExtensionAttribute]
[CanBeNullAttribute]
[ContractAnnotationAttribute("null => null")]
[PureAttribute]
internal static ICacheTrieNodeOwner TryGetCacheTrieNodeOwner(ITypeElement embeddedType);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("otherType: null => false")]
public static bool IsDescendantOf(ITypeElement typeElement, ITypeElement otherType);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasTypeParameters(ITypeElement element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsClassLike(ITypeElement element);
    [ExtensionAttribute]
[ObsoleteAttribute("Do not use this method. Use TypeElementUtil.EnumerateMembers or TypeElementUtil.HasMember instead")]
public static IList`1<ITypeMember> GetMembers(ITypeElement element, string name);
    [ExtensionAttribute]
[PureAttribute]
public static HybridCollection`1<ITypeParameter> GetAllTypeParameters(ITypeElement typeElement);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITypeParameter GetTypeParameter(ITypeElement type, int globalIndex);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
private static ITypeParameter GetTypeParameter(ITypeElement type, int globalIndex, Int32& typeParametersCount);
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<ISignOperator> GetSignOperators(ITypeElement typeElement);
}
public class JetBrains.ReSharper.Psi.TypeElementPartIterator : object {
    private ITypeElement myTypeElement;
    private INamespace myNamespace;
    public TypeElementPartIterator(ITypeElement element);
    internal static int GetPartCount(ITypeElement typeElement);
    internal static int GetPartCount(CompiledTypeElement typeElement);
    public sealed virtual bool GetNextPart(TypeNameAndTypeParameterNumber& name);
}
public class JetBrains.ReSharper.Psi.TypeEqualityComparer : TypeVisitor`2<IType, bool> {
    private static TypeComparisonFlags DefaultFlags;
    private static TypeComparisonFlags DefaultOrUnknownFlags;
    private static TypeComparisonFlags DefaultWithNullabilityFlags;
    private static TypeComparisonFlags DefaultWithStrictNullabilityAndValueTrackingAnnotationsFlags;
    private static TypeComparisonFlags DefaultWithTupleNamesFlags;
    private static TypeComparisonFlags DefaultWithTupleNamesFlagsAndNativeIntegerMismatch;
    private static TypeComparisonFlags DefaultWithTupleNamesAndNullabilityFlags;
    private static TypeComparisonFlags DefaultWithTupleNamesAndNullabilityFlagsAndNativeIntegerMismatch;
    private static TypeComparisonFlags DefaultWithTupleNamesAndStrictNullabilityFlagsAndNativeIntegerMismatch;
    private static TypeComparisonFlags DefaultWithTupleNamesAndStrictNullabilityWithValueTrackingAnnotationsFlagsAndNativeIntegerMismatch;
    private static TypeComparisonFlags IdentityFlags;
    private static TypeComparisonFlags IdentityWithNullabilityFlags;
    private static TypeComparisonFlags IdentityWithTupleNamesFlags;
    private static TypeComparisonFlags IdentityOrUnknownFlags;
    private static TypeComparisonFlags IdentityOrUnknownWithNullabilityFlags;
    private static TypeComparisonFlags IdentityOrUnknownWithTupleNamesFlags;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> ConsiderEverything;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> Default;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> DefaultWithValidityCheck;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> DefaultOrUnknown;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> DefaultWithNullability;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> DefaultWithStrictNullabilityAndValueTrackingAnnotations;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> DefaultWithTupleNames;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> DefaultWithTupleNamesAndNativeIntegerMismatch;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> DefaultWithTupleNamesAndNullability;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> DefaultWithTupleNamesAndNullabilityAndNativeIntegerMismatch;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> DefaultWithTupleNamesAndStrictNullabilityAndNativeIntegerMismatch;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> Identity;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> IdentityWithNullability;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> IdentityWithNullabilityAndNativeIntegerMismatch;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> IdentityWithTupleNames;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> IdentityWithNativeIntegerMismatch;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> IdentityOrUnknown;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> IdentityOrUnknownWithNullability;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> IdentityOrUnknownWithTupleNames;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> DefaultWithTupleNamesAndStrictNullabilityWithValueTrackingAnnotations;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> DefaultWithNativeIntegerMismatch;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> DefaultWithNullabilityAndNativeIntegerMismatch;
    [NotNullAttribute]
public static IEqualityComparer`1<IType> AllIgnoreOptions;
    private TypeComparisonFlags myComparisonOptions;
    private bool AllowUnknownTypes { get; }
    private bool AllowObjectDynamicMismatch { get; }
    private bool AllowTupleNamesMismatch { get; }
    private bool AllowNullableAnnotationMismatch { get; }
    private bool AllowUnknownNullableAnnotationMatchAny { get; }
    private bool AllowUnknownFlowAnnotationToMatchNotNullable { get; }
    private bool AllowNativeIntegerMismatch { get; }
    public TypeEqualityComparer(TypeComparisonFlags comparisonOptions);
    private static TypeEqualityComparer();
    private bool get_AllowUnknownTypes();
    private bool get_AllowObjectDynamicMismatch();
    private bool get_AllowTupleNamesMismatch();
    private bool get_AllowNullableAnnotationMismatch();
    private bool get_AllowUnknownNullableAnnotationMatchAny();
    private bool get_AllowUnknownFlowAnnotationToMatchNotNullable();
    private bool get_AllowNativeIntegerMismatch();
    public virtual bool VisitType(IType type, IType otherType);
    public virtual bool VisitDeclaredType(IDeclaredType declaredType, IType otherType);
    public virtual bool Equals(IType x, IType y);
    public virtual int GetHashCode(IType obj);
    protected bool NullableAnnotationsAreEqual(IType typeA, IType typeB);
    protected bool TupleElementNamesAreEqual(IType typeA, IType typeB);
    protected static bool HasExplicitTupleNames(IReadOnlyList`1<TupleTypeComponent> components);
    protected virtual bool TupleElementNamesAreEqual(IReadOnlyList`1<TupleTypeComponent> componentsA, IReadOnlyList`1<TupleTypeComponent> componentsB);
    public virtual bool VisitMultitype(IMultitype multitype, IType otherType);
    [CompilerGeneratedAttribute]
private NullableAnnotation <NullableAnnotationsAreEqual>g__CoalesceNullableAnnotation|59_0(IType type);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.TypeExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static bool IsPointerOrFunctionPointer(IType type);
    [ExtensionAttribute]
[PureAttribute]
public static Nullable`1<DecoratedType`1<TDecoration>> AsDecorated(IType type);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static IType MergeEquivalentTypes(IType latest, IType newCandidate, TypeParameterVariance variance);
}
public static class JetBrains.ReSharper.Psi.TypeFactory : object {
    [PureAttribute]
[NotNullAttribute]
public static IArrayType CreateArrayType(IType elementType, int rank);
    [PureAttribute]
[NotNullAttribute]
public static IArrayType CreateArrayType(IType elementType, int rank, NullableAnnotation nullableAnnotation);
    [PureAttribute]
[NotNullAttribute]
public static IArrayType CreateArrayType(IType elementType, int rank, TypeDecorationSet typeDecorations);
    [PureAttribute]
[NotNullAttribute]
public static IPointerType CreatePointerType(IType elementType);
    [PureAttribute]
[NotNullAttribute]
public static IPointerType CreatePointerType(IType elementType, TypeDecorationSet typeDecorations);
    [PureAttribute]
[NotNullAttribute]
public static IFunctionPointerType CreateFunctionPointerType(IType returnType, ReferenceKind returnKind, IReadOnlyList`1<FunctionPointerParameter> parameters, CallingConvention callingConvention);
    [PureAttribute]
[NotNullAttribute]
public static IFunctionPointerType CreateFunctionPointerType(IType returnType, ReferenceKind returnKind, IReadOnlyList`1<FunctionPointerParameter> parameters, CallingConvention callingConvention, TypeDecorationSet typeDecorations);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateNullableType(IType elementType, IPsiModule psiModule);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateSpanType(IType elementType, IPsiModule psiModule);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateTupleType(IPsiModule module, IReadOnlyList`1<TupleTypeComponent> tupleTypeComponents);
    private static void CalculateTypeElementAndSubstitution(IPsiModule module, ITypeElement& typeElement, ISubstitution& substitution, IReadOnlyList`1<TupleTypeComponent> components, int baseIndex);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateType(ITypeElement typeElement);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateType(ITypeElement typeElement, NullableAnnotation nullableAnnotation);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateType(ITypeElement typeElement, TypeDecorationSet typeDecorations);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateTypeWithDynamicSubstitution(ITypeElement typeElement, IPsiModule psiModule);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateType(ITypeElement typeElement, IType[] typeArguments, TypeDecorationSet typeDecorations);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateType(ITypeElement typeElement, ISubstitution substitution);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateType(ITypeElement typeElement, ISubstitution substitution, NullableAnnotation nullableAnnotation);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateType(ITypeElement typeElement, ISubstitution substitution, TypeDecorationSet typeDecorations);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateTypeByCLRName(string clrName, IPsiModule psiModule);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateTypeByCLRName(string clrName, IPsiModule psiModule, bool useModuleForSymbolScope);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateTypeByCLRName(string clrName, IPsiModule psiModule, NullableAnnotation nullableAnnotation);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateTypeByCLRName(string clrName, IPsiModule psiModule, NullableAnnotation nullableAnnotation, bool useModuleForSymbolScope);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateTypeByCLRName(string clrName, IPsiModule psiModule, TypeDecorationSet typeDecorations);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateTypeByCLRName(string clrName, IPsiModule psiModule, TypeDecorationSet typeDecorations, bool useModuleForSymbolScope);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateTypeByCLRName(IClrTypeName clrName, IPsiModule psiModule);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateTypeByCLRName(IClrTypeName clrName, IPsiModule psiModule, bool useModuleForSymbolScope);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateTypeByCLRName(IClrTypeName clrName, NullableAnnotation nullableAnnotation, IPsiModule psiModule);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateTypeByCLRName(IClrTypeName clrName, NullableAnnotation nullableAnnotation, IPsiModule psiModule, bool useModuleForSymbolScope);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateTypeByCLRName(IClrTypeName clrName, IPsiModule psiModule, TypeDecorationSet typeDecorations);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateTypeByCLRName(IClrTypeName clrName, IPsiModule psiModule, TypeDecorationSet typeDecorations, bool useModuleForSymbolScope);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateUnknownType(IPsiModule module);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateUnknownType(ITreeNode contextNode);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateUninferredType(ITypeParameter typeParameter);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateDynamicType(IPsiModule psiModule);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateDynamicType(IPsiModule psiModule, NullableAnnotation nullableAnnotation);
    [PureAttribute]
[NotNullAttribute]
public static IDeclaredType CreateDynamicType(ITreeNode contextNode, NullableAnnotation nullableAnnotation);
    [PureAttribute]
[NotNullAttribute]
public static IType CreateMultitype(IPsiModule psiModule, IEnumerable`1<IType> types);
    [CanBeNullAttribute]
public static IDeclaredType TryCreateTupleType(ResolveResultWithInfo resolveResult);
    [CanBeNullAttribute]
[ContractAnnotationAttribute("typeElement: null => null")]
private static IDeclaredType TryCreateTupleType(ITypeElement typeElement, ISubstitution substitution);
    [CompilerGeneratedAttribute]
internal static void <CreateMultitype>g__AddConstituent|37_0(HashSet`1& list, IType type);
}
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.TypeKeywordsManager : object {
    [NotNullAttribute]
private ILanguageManager myLanguageManager;
    [NotNullAttribute]
private PsiProjectFileTypeCoordinator myProjectFileTypeCoordinator;
    [NotNullAttribute]
public static TypeKeywordsManager Instance { get; }
    public TypeKeywordsManager(ILanguageManager languageManager, PsiProjectFileTypeCoordinator projectFileTypeCoordinator);
    public static TypeKeywordsManager get_Instance();
    [CanBeNullAttribute]
private ITypeKeywordsService TryGetService(PsiLanguageType languageType);
    [CanBeNullAttribute]
private ITypeKeywordsService TryGetService(ProjectFileType languageType);
    public IEnumerable`1<string> GetTypeKeywords(ProjectFileType language, IPsiModule psiModule);
    public string GetFullQualifiedTypeName(ProjectFileType language, string keyword, IPsiModule psiModule);
    public string GetFullQualifiedTypeName(PsiLanguageType language, string keyword, IPsiModule psiModule);
    public string GetKeyword(PsiLanguageType language, ITypeElement typeElement);
    public string GetKeyword(ProjectFileType language, ITypeElement typeElement);
    public bool IsTypeKeywordReference(PsiLanguageType keywordLanguage, IReference reference);
    public bool IsDynamicKeyword(PsiLanguageType language, string keyword);
}
public class JetBrains.ReSharper.Psi.TypeMemberInstance : DeclaredElementInstance`1<ITypeMember> {
    [NotNullAttribute]
public ITypeMember Member { get; }
    [CanBeNullAttribute]
public IType Type { get; }
    public TypeMemberInstance(ITypeMember typeMember);
    public TypeMemberInstance(ITypeMember typeMember, ISubstitution substitution);
    public ITypeMember get_Member();
    public IType get_Type();
    [NotNullAttribute]
public IList`1<TypeMemberInstance> GetHiddenMembers();
}
public class JetBrains.ReSharper.Psi.TypeMemberInstance`1 : TypeMemberInstance {
    [NotNullAttribute]
public TTypeMember Member { get; }
    public TypeMemberInstance`1(TTypeMember typeMember);
    public TypeMemberInstance`1(TTypeMember typeMember, ISubstitution substitution);
    public TTypeMember get_Member();
    public void Deconstruct(TTypeMember& member, ISubstitution& substitution);
}
public class JetBrains.ReSharper.Psi.TypeModifier : object {
    [CompilerGeneratedAttribute]
private TypeModifierKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private IType <Type>k__BackingField;
    public TypeModifierKind Kind { get; }
    [NotNullAttribute]
public IType Type { get; }
    public TypeModifier(TypeModifierKind kind, IType type);
    [CompilerGeneratedAttribute]
public TypeModifierKind get_Kind();
    [CompilerGeneratedAttribute]
public IType get_Type();
    public static bool CompareSet(IList`1<TypeModifier> set1, IList`1<TypeModifier> set2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.TypeModifiersDecoration : TypeDecoration {
    [CompilerGeneratedAttribute]
private IList`1<TypeModifier> <TypeModifiers>k__BackingField;
    public IList`1<TypeModifier> TypeModifiers { get; }
    public TypeModifiersDecoration(IList`1<TypeModifier> typeModifiers);
    [CompilerGeneratedAttribute]
public IList`1<TypeModifier> get_TypeModifiers();
    public virtual ITypeDecorationPointer CreatePointer();
    public virtual TypeDecoration TryTranslateToCurrentFork(IContentModelForkTranslator translator);
    [NullableContextAttribute("2")]
public virtual bool Equals(TypeDecoration other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.TypeNameCompaction : ValueType {
    public static TypeNameCompaction Disabled;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TypeArgumentsDepthLimit>k__BackingField;
    public bool IsEnabled { get; }
    public int TypeArgumentsDepthLimit { get; }
    private TypeNameCompaction(bool isEnabled, int typeArgumentsDepthLimit);
    public TypeNameCompaction(int typeArgumentsDepthLimit);
    private static TypeNameCompaction();
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    [CompilerGeneratedAttribute]
public int get_TypeArgumentsDepthLimit();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TypeNameCompaction left, TypeNameCompaction right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TypeNameCompaction left, TypeNameCompaction right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TypeNameCompaction other);
}
public abstract class JetBrains.ReSharper.Psi.TypeNormalizerBase : TypeRewriterBase`1<IType> {
    public virtual IType VisitArrayType(IArrayType arrayType, IType context);
    public virtual IType VisitPointerType(IPointerType pointerType, IType context);
    public virtual IType VisitFunctionPointerType(IFunctionPointerType functionPointerType, IType context);
    public virtual IType VisitType(IType type, IType context);
    public virtual IType VisitDeclaredType(IDeclaredType declaredType, IType context);
    private IType VisitTupleType(DecoratedType`1<TupleTypeDecoration> tupleType, DecoratedType`1<TupleTypeDecoration> otherTupleType);
    [NotNullAttribute]
protected virtual IType ProcessTypeElement(IType type, IType context);
    [CanBeNullAttribute]
protected virtual string ProcessTupleTypeComponentName(TupleTypeComponent component, TupleTypeComponent context);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.TypeParameterConstraintFlags : Enum {
    public ushort value__;
    public static TypeParameterConstraintFlags None;
    public static TypeParameterConstraintFlags ValueType;
    public static TypeParameterConstraintFlags ReferenceType;
    public static TypeParameterConstraintFlags Constructor;
    public static TypeParameterConstraintFlags Unmanaged;
    public static TypeParameterConstraintFlags HasNullabilityAnnotation;
    public static TypeParameterConstraintFlags NotNullableAnnotation;
    public static TypeParameterConstraintFlags HasUnknownNullability;
    public static TypeParameterConstraintFlags HasNotNullableAnnotation;
    public static TypeParameterConstraintFlags Default;
    public static TypeParameterConstraintFlags AllowsByRefLikeType;
    public static TypeParameterConstraintFlags Unknown;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.TypeParameterConstraintFlagsExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNotNullableValueOrClassType(TypeParameterConstraintFlags flags);
    [ExtensionAttribute]
[PureAttribute]
public static TypeParameterNullability ToNullability(TypeParameterConstraintFlags flags);
}
public enum JetBrains.ReSharper.Psi.TypeParameterNullability : Enum {
    public byte value__;
    public static TypeParameterNullability Unknown;
    public static TypeParameterNullability NotNullableValueType;
    public static TypeParameterNullability NotNullableValueOrReferenceType;
    public static TypeParameterNullability NullableValueOrReferenceType;
    public static TypeParameterNullability NotNullableReferenceType;
    public static TypeParameterNullability NullableReferenceType;
    public static TypeParameterNullability NotNullableSuperType;
    public static TypeParameterNullability NullableSuperType;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.TypeParameterNullabilityExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsAnyNotNullable(TypeParameterNullability nullability);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsAnyNullable(TypeParameterNullability nullability);
}
public class JetBrains.ReSharper.Psi.TypeParameterProcessor : TypeVisitor {
    [CompilerGeneratedAttribute]
private Action`1<ITypeParameter> <Processor>k__BackingField;
    public Action`1<ITypeParameter> Processor { get; public set; }
    [CompilerGeneratedAttribute]
public Action`1<ITypeParameter> get_Processor();
    [CompilerGeneratedAttribute]
public void set_Processor(Action`1<ITypeParameter> value);
    public virtual void VisitDeclaredType(IDeclaredType declaredType);
    public static void Process(IType type, Action`1<ITypeParameter> processor);
}
public class JetBrains.ReSharper.Psi.TypeParametersCollectingVisitor : TypeVisitor {
    private Func`2<ITypeParameter, bool> myPredicate;
    [CompilerGeneratedAttribute]
private HashSet`1<ITypeParameter> <TypeParameters>k__BackingField;
    public HashSet`1<ITypeParameter> TypeParameters { get; }
    public TypeParametersCollectingVisitor(Func`2<ITypeParameter, bool> predicate);
    [CompilerGeneratedAttribute]
public HashSet`1<ITypeParameter> get_TypeParameters();
    public virtual void VisitDeclaredType(IDeclaredType declaredType);
    public static HashSet`1<ITypeParameter> Collect(IType type);
}
public enum JetBrains.ReSharper.Psi.TypeParameterStyle : Enum {
    public int value__;
    public static TypeParameterStyle NONE;
    public static TypeParameterStyle CLR;
    public static TypeParameterStyle INDICATE;
    public static TypeParameterStyle FULL;
    public static TypeParameterStyle FULL_WITH_VARIANCE;
}
public enum JetBrains.ReSharper.Psi.TypeParameterVariance : Enum {
    public byte value__;
    public static TypeParameterVariance INVARIANT;
    public static TypeParameterVariance IN;
    public static TypeParameterVariance OUT;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.TypeParameterVarianceExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static string GetDescription(TypeParameterVariance variance);
    [ExtensionAttribute]
[PureAttribute]
public static TypeParameterVariance Invert(TypeParameterVariance variance);
}
public class JetBrains.ReSharper.Psi.TypeParameterVerifier : TypeVisitor {
    private Func`2<ITypeParameter, bool> myPredicate;
    private bool myIsFinished;
    [CompilerGeneratedAttribute]
private bool <Result>k__BackingField;
    public bool Result { get; private set; }
    public bool IsFinished { get; }
    private TypeParameterVerifier(Func`2<ITypeParameter, bool> predicate);
    [CompilerGeneratedAttribute]
public bool get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(bool value);
    public virtual void VisitDeclaredType(IDeclaredType declaredType);
    public virtual bool get_IsFinished();
    public static bool ForAny(IType type, Func`2<ITypeParameter, bool> predicate);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.TypePointerUtil : object {
    [ExtensionAttribute]
public static ITypePointer GetScalarTypePointer(ITypePointer typePointer);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.TypePresentationOptions : Enum {
    public int value__;
    public static TypePresentationOptions None;
    public static TypePresentationOptions UseKeywordsForPredefinedTypes;
    public static TypePresentationOptions IncludeNullableAnnotations;
    public static TypePresentationOptions IncludeNotNullableAnnotations;
    public static TypePresentationOptions UseTupleSyntax;
    public static TypePresentationOptions UseKeywordsForNativeIntegerTypes;
    public static TypePresentationOptions UseAliasName;
    public static TypePresentationOptions UseExplicitGlobalExternAlias;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.TypePresentationOptionsExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool HasFlagFast(TypePresentationOptions value, TypePresentationOptions flag);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.TypePresentationStyle : object {
    public static TypePresentationStyle Default;
    public static TypePresentationStyle DefaultWithQualifiedName;
    [CompilerGeneratedAttribute]
private bool <QualifyType>k__BackingField;
    [CompilerGeneratedAttribute]
private TypePresentationOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclaredElementPresenterTextStyles <TextStyles>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeNameCompaction <TypeNameCompaction>k__BackingField;
    [CompilerGeneratedAttribute]
private Type EqualityContract { get; }
    public bool QualifyType { get; public set; }
    public TypePresentationOptions Options { get; public set; }
    public DeclaredElementPresenterTextStyles TextStyles { get; public set; }
    public TypeNameCompaction TypeNameCompaction { get; public set; }
    [CompilerGeneratedAttribute]
private TypePresentationStyle(TypePresentationStyle original);
    private static TypePresentationStyle();
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public bool get_QualifyType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_QualifyType(bool value);
    [CompilerGeneratedAttribute]
public TypePresentationOptions get_Options();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Options(TypePresentationOptions value);
    [CompilerGeneratedAttribute]
public DeclaredElementPresenterTextStyles get_TextStyles();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TextStyles(DeclaredElementPresenterTextStyles value);
    [CompilerGeneratedAttribute]
public TypeNameCompaction get_TypeNameCompaction();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TypeNameCompaction(TypeNameCompaction value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(TypePresentationStyle left, TypePresentationStyle right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(TypePresentationStyle left, TypePresentationStyle right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(TypePresentationStyle other);
    [CompilerGeneratedAttribute]
public TypePresentationStyle <Clone>$();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.TypePresenterExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string GetPresentableName(ITypePresenter typePresenter, IType type);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string GetLongPresentableName(ITypePresenter typePresenter, IType type);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static string GetUnresolvedScalarTypePresentation(ITypePresenter typePresenter, string name, ICollection`1<IType> typeArguments, NullableAnnotation nullableAnnotation);
}
public abstract class JetBrains.ReSharper.Psi.TypeRewriterBase`1 : TypeVisitor`2<TContext, IType> {
    public virtual IType VisitType(IType type, TContext context);
    public virtual IType VisitArrayType(IArrayType arrayType, TContext context);
    public virtual IType VisitPointerType(IPointerType pointerType, TContext context);
    public virtual IType VisitFunctionPointerType(IFunctionPointerType functionPointerType, TContext context);
    public virtual IType VisitDeclaredType(IDeclaredType declaredType, TContext context);
    public virtual IType VisitMultitype(IMultitype multitype, TContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Types.ReferenceKindTypeDecoration : TypeDecoration {
    public static ReferenceKindTypeDecoration MutableReference;
    public static ReferenceKindTypeDecoration ReadonlyReference;
    private static ReferenceKindTypeDecoration();
    public virtual ITypeDecorationPointer CreatePointer();
    private sealed virtual override TypeDecoration JetBrains.ReSharper.Psi.ITypeDecorationPointer.Find();
    [NullableContextAttribute("2")]
public virtual bool Equals(TypeDecoration other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Types.ReferenceKindTypeDecorationExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static IType DecorateWithReturnReferenceKind(IType type, ReferenceKind referenceKind);
    [ExtensionAttribute]
[PureAttribute]
public static ReferenceKind GetReturnReferenceKindFromDecoration(IType type);
}
public enum JetBrains.ReSharper.Psi.TypeStyle : Enum {
    public int value__;
    public static TypeStyle NONE;
    public static TypeStyle DEFAULT;
    public static TypeStyle AFTER;
}
public abstract class JetBrains.ReSharper.Psi.TypeVisitor : object {
    public bool IsFinished { get; }
    public virtual bool get_IsFinished();
    public virtual void VisitType(IType type);
    public virtual void VisitDeclaredType(IDeclaredType declaredType);
    public virtual void VisitArrayType(IArrayType arrayType);
    public virtual void VisitPointerType(IPointerType pointerType);
    public virtual void VisitFunctionPointerType(IFunctionPointerType functionPointerType);
    public virtual void VisitMultitype(IMultitype multitype);
    public virtual void VisitAnonymousType(IAnonymousType anonymousType);
}
public abstract class JetBrains.ReSharper.Psi.TypeVisitor`2 : object {
    public virtual TResult VisitType(IType type, TContext context);
    public virtual TResult VisitDeclaredType(IDeclaredType declaredType, TContext context);
    public virtual TResult VisitArrayType(IArrayType arrayType, TContext context);
    public virtual TResult VisitPointerType(IPointerType pointerType, TContext context);
    public virtual TResult VisitFunctionPointerType(IFunctionPointerType functionPointerType, TContext context);
    public virtual TResult VisitMultitype(IMultitype multitype, TContext context);
    public virtual TResult VisitAnonymousType(IAnonymousType anonymousType, TContext context);
}
[LanguageDefinitionAttribute("UNKNOWN")]
public class JetBrains.ReSharper.Psi.UnknownLanguage : PsiLanguageType {
    public static string Name;
    [CompilerGeneratedAttribute]
private static UnknownLanguage <Instance>k__BackingField;
    [CanBeNullAttribute]
[UsedImplicitlyAttribute]
public static UnknownLanguage Instance { get; private set; }
    [CompilerGeneratedAttribute]
public static UnknownLanguage get_Instance();
    [CompilerGeneratedAttribute]
private static void set_Instance(UnknownLanguage value);
}
[LanguageDefinitionAttribute("UNMANAGED")]
public class JetBrains.ReSharper.Psi.UnmanagedKnownLanguage : KnownLanguage {
    public static string Name;
    [CompilerGeneratedAttribute]
private static UnmanagedKnownLanguage <UNMANAGED>k__BackingField;
    [CanBeNullAttribute]
[UsedImplicitlyAttribute]
public static UnmanagedKnownLanguage UNMANAGED { get; private set; }
    protected UnmanagedKnownLanguage(string name);
    protected UnmanagedKnownLanguage(string name, string presentableName);
    [CompilerGeneratedAttribute]
public static UnmanagedKnownLanguage get_UNMANAGED();
    [CompilerGeneratedAttribute]
private static void set_UNMANAGED(UnmanagedKnownLanguage value);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.UnmanagedKnownLanguageEx : object {
    [ExtensionAttribute]
public static bool AllUnmanaged(IEnumerable`1<PsiLanguageType> langs);
    [ExtensionAttribute]
public static bool IsUnmanaged(PsiLanguageType lang);
}
[ThreadUnsafeAttribute]
public abstract class JetBrains.ReSharper.Psi.Util.AbstractObjectPool`1 : object {
    private int myMaximalCapacity;
    private int myMinimalCapacity;
    protected Stack`1<T> myFreeObjects;
    protected int myObjectsInUse;
    public bool Unused { get; }
    protected Stack`1<T> FreeObjects { get; }
    protected int ObjectsInUse { get; }
    protected AbstractObjectPool`1(int capacity, int maximalCapacity);
    protected abstract virtual T CreateObject();
    protected abstract virtual void ClearObject(T t);
    protected abstract virtual void InitObject(T t);
    public virtual T Alloc();
    public virtual T Alloc(Lifetime lifetime);
    public virtual void Free(T t);
    public sealed virtual void DropToMinimalCapacity();
    public sealed virtual bool get_Unused();
    protected Stack`1<T> get_FreeObjects();
    protected int get_ObjectsInUse();
}
[ThreadUnsafeAttribute]
public abstract class JetBrains.ReSharper.Psi.Util.AbstractObjectPoolWithSubPools`1 : AbstractObjectPool`1<T> {
    private ObjectSubPoolsPool`1<T> myInternalPool;
    protected AbstractObjectPoolWithSubPools`1(int capacityOfSubPools, int capacity, int maximalCapacity);
    public ObjectSubPool`1<T> AllocSubPool(Lifetime lifetime);
    public ObjectSubPool`1<T> AllocSubPool();
    public void FreeSubPool(ObjectSubPool`1<T> subPool);
    public void DumpDebugInfo();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.AccessUtil : object {
    [PureAttribute]
private static bool IsPrivateSymbolAccessible(ITypeMember typeMember, IAccessContext context);
    [PureAttribute]
private static bool IsFileLocalTypeAccessible(ITypeElement typeElement, IAccessContext context);
    [PureAttribute]
private static bool IsProtectedSymbolAccessible(ITypeMember typeMember, IAccessContext context);
    [PureAttribute]
private static bool IsInternalSymbolAccessible(ITypeMember typeMember, IAccessContext context);
    [PureAttribute]
public static bool IsSymbolAccessible(ITypeMember typeMember, IAccessContext context, AccessRights rights, bool checkModuleIsReferenced);
    [ContractAnnotationAttribute("typeMember: null => false")]
[PureAttribute]
public static bool IsSymbolAccessible(ITypeMember typeMember, IAccessContext context, bool checkModuleIsReferenced);
    [PureAttribute]
public static Staticness GetQualifierStaticness(IQualifier qualifier);
    [PureAttribute]
public static bool IsStatic(IDeclaredElement declaredElement);
    [PureAttribute]
public static bool HasProblemWithStatic(IDeclaredElement declaredElement, IAccessContext context);
    [PureAttribute]
public static bool IsStatic(ITypeMember typeMember);
    [PureAttribute]
public static bool IsAccessibilityConsistent(AccessibilityDomain testDomain, AccessibilityDomain contextDomain);
    private static bool IsNestedOrEqualTypeOf(ITypeElement type1, ITypeElement type2);
    private static bool IsNestedOrDerivedTypeOf(ITypeElement type1, ITypeElement type2);
    [ExtensionAttribute]
[PureAttribute]
public static AccessRights GetAccessRightsVisibleToModule(IAccessRightsOwner accessRightsOwner, IPsiModule targetModule);
}
[PsiComponentAttribute("16")]
public class JetBrains.ReSharper.Psi.Util.ApplicationWideContextBoundSettingStore : object {
    [CompilerGeneratedAttribute]
private IContextBoundSettingsStoreLive <BoundSettingsStore>k__BackingField;
    public IContextBoundSettingsStoreLive BoundSettingsStore { get; }
    public ApplicationWideContextBoundSettingStore(Lifetime lifetime, ISettingsStore settingsStore);
    [CompilerGeneratedAttribute]
public sealed virtual IContextBoundSettingsStoreLive get_BoundSettingsStore();
}
public class JetBrains.ReSharper.Psi.Util.AutoClearingObjectArrayPool`1 : ObjectArrayPool`1<T> {
    private Timer myTimer;
    private int myClearProbeInterval;
    public AutoClearingObjectArrayPool`1(Lifetime lifetime, int checkPeriod);
    public virtual void Free(T[] t);
    private void DisableTimer();
    private void EnableTimer();
    private void AutoClear(object _);
}
[ThreadSafeAttribute]
public abstract class JetBrains.ReSharper.Psi.Util.AutoClearingThreadSafeObjectPool`1 : ThreadSafeObjectPool`1<T> {
    private Timer myTimer;
    private Lifetime myLifetime;
    private int myMinimalCapacity;
    private int myClearProbeInterval;
    protected AutoClearingThreadSafeObjectPool`1(Lifetime lifetime, int capacity, int minimalCapacity, int maximalCapacity, int checkPeriod);
    public virtual void Free(T t);
    protected void ResetTimer();
    public virtual T Alloc();
    protected void SnoozeTimer();
    private void AutoClear(object _);
}
public abstract class JetBrains.ReSharper.Psi.Util.Caches.AbstractPersistendIdIndex`1 : object {
    private static int FormatVersion;
    private Dictionary`2<string, TData> myIdToSourceFile;
    private Dictionary`2<TData, string> mySourceFileToId;
    private Dictionary`2<string, int> myIdToIndex;
    private Dictionary`2<int, string> myIndexToId;
    private int myTopIndex;
    protected void Initialize();
    protected void Load(BinaryReader reader);
    protected void Save(BinaryWriter writer);
    [CanBeNullAttribute]
public TData GetFileByPersistentIdIndex(int indx);
    private IEnumerable`1<TData> OutdatedFiles();
    public void Update();
    private Dictionary`2<string, TData> BuildIdToSourceFile(IEnumerable`1<TData> files);
    public int GetPersistenIdIndex(TData sourceFile);
    protected abstract virtual bool IsValid(TData data);
    protected abstract virtual string GetPersistentID(TData data);
    protected abstract virtual IEnumerable`1<TData> GetAllFiles();
    [CompilerGeneratedAttribute]
private bool <Update>b__11_0(TData file);
}
[ObsoleteAttribute("Use SimpleICache instead wherever possible")]
public abstract class JetBrains.ReSharper.Psi.Util.Caches.AbstractPersistentCache`2 : object {
    private static int FILE_SIZE_MIN;
    private static int FILE_SIZE_MAX;
    private MyRecordsStorage<TKey, TData> myStorage;
    private CompactMap`2<TKey, TData> myDataToSave;
    private JetHashSet`1<TKey> myDataToDelete;
    private bool mySaving;
    private bool myLoadStarted;
    private ILogger myLogger;
    protected int FormatVersion { get; }
    protected FileSystemPath CacheDirectory { get; }
    protected bool CheckTotalConsistency { get; }
    protected string LoadSaveProgressText { get; }
    protected int FileSizeMin { get; }
    protected int FileSizeMax { get; }
    public IEnumerable`1<KeyValuePair`2<TKey, TData>> StoredData { get; }
    public bool LoadStarted { get; }
    protected abstract virtual int get_FormatVersion();
    protected abstract virtual FileSystemPath get_CacheDirectory();
    protected abstract virtual bool get_CheckTotalConsistency();
    protected abstract virtual string get_LoadSaveProgressText();
    protected abstract virtual IDisposable DataLock();
    protected abstract virtual bool IsKeyValid(TKey key);
    protected abstract virtual void WriteKey(BinaryWriter writer, TKey key);
    [ContractAnnotationAttribute("=>true, key:notnull; =>false, key:null")]
protected abstract virtual bool ReadKey(BinaryReader reader, TKey& key);
    protected abstract virtual void WriteData(BinaryWriter writer, TKey key, TData data);
    protected virtual TData ReadData(ArraySegment`1<byte> bytes, TKey key);
    protected abstract virtual TData ReadData(BinaryReader reader, TKey key);
    protected abstract virtual void DataLoaded(TKey key, TData data, bool keyValid, Action& waitToContinue);
    private void Log(string comment, bool error);
    protected virtual int get_FileSizeMin();
    protected virtual int get_FileSizeMax();
    public void AddDataToSave(TKey key, TData data);
    public void MarkDataToDelete(TKey key);
    public IEnumerable`1<KeyValuePair`2<TKey, TData>> get_StoredData();
    public bool get_LoadStarted();
    public LoadResult Load(ITaskHost taskHost, IProgressIndicator progress, bool multiThread);
    public void Save(IProgressIndicator progress, bool releaseDiskCache);
    public void Save(IProgressIndicator progress, Func`1<bool> checkForInterrupt, bool releaseDiskCache);
    public virtual bool ResetCacheDirectory();
    protected bool HasChangesToSave();
    public FetchDataResult FetchDataForKey(TKey key, TData& data);
}
public enum JetBrains.ReSharper.Psi.Util.Caches.FetchDataResult : Enum {
    public int value__;
    public static FetchDataResult OK;
    public static FetchDataResult NO_DATA;
    public static FetchDataResult CACHE_CORRUPT;
}
public enum JetBrains.ReSharper.Psi.Util.Caches.LoadResult : Enum {
    public int value__;
    public static LoadResult OK;
    public static LoadResult CACHE_INVALID_CLEARED;
    public static LoadResult CACHE_INVALID_IO_PROBLEM;
}
internal abstract class JetBrains.ReSharper.Psi.Util.Caches.RecordsStorage`2 : object {
    private CompactMap`2<TKey, RecordInfo<TKey, TData>> myKeyToRecord;
    private CompactMap`2<string, DataFileInfo<TKey, TData>> myPathToFileInfo;
    private CompactMap`2<string, int> myIncompleteFiles;
    private CompactSet`1<RecordInfo<TKey, TData>> myInvalidRecords;
    private Random myRandom;
    protected int FormatVersion { get; }
    protected FileSystemPath CacheDirectory { get; }
    protected bool CheckTotalConsistency { get; }
    protected int FileSizeMin { get; }
    protected int FileSizeMax { get; }
    private FileSystemPath CrcFile { get; }
    private FileSystemPath FormatVersionFile { get; }
    protected abstract virtual int get_FormatVersion();
    protected abstract virtual FileSystemPath get_CacheDirectory();
    protected abstract virtual bool get_CheckTotalConsistency();
    protected abstract virtual bool IsKeyValid(TKey key);
    protected abstract virtual void WriteKey(BinaryWriter writer, TKey key);
    protected abstract virtual bool ReadKey(BinaryReader reader, TKey& key);
    protected abstract virtual void WriteData(BinaryWriter writer, TKey key, TData data);
    protected abstract virtual TData ReadData(ArraySegment`1<byte> bytes, TKey key);
    protected abstract virtual void DataLoaded(TKey key, TData data, bool keyValid, Action& waitToContinue);
    protected abstract virtual IDisposable DataLock();
    protected abstract virtual int get_FileSizeMin();
    protected abstract virtual int get_FileSizeMax();
    public bool Load(ITaskHost taskHost, IProgressIndicator progress, bool multiThread);
    private bool SingleThreadLoad(IProgressIndicator progress, List`1<string> files);
    private bool MultiThreadLoad(ITaskHost taskHost, IProgressIndicator progress, List`1<string> files);
    public void UpdateData(IDictionary`2<TKey, TData> dataToSave, JetHashSet`1<TKey> dataToDelete, IProgressIndicator progress);
    public FetchDataResult FetchDataForKey(TKey key, TData& data);
    public bool ResetCacheDirectory();
    [CanBeNullAttribute]
private Byte[][] ReadCurrentData(string relativePath);
    private DataInBytes<TKey, TData> WriteDataToBytes(TKey key, TData data);
    [CanBeNullAttribute]
private Byte[] ReadData(string relativePath, DataFileInfo& dataFileInfo);
    private bool LoadData(Byte[] buffer, string relativePath, DataFileInfo<TKey, TData> dataFileInfo, IProgressIndicator progress, object _lock);
    private bool WriteTotalCrc();
    private bool CheckTotalCrc();
    private int ComputeTotalCrc();
    private bool WriteVersion();
    private bool CheckVersion();
    private void InvalidateVersion();
    private FileSystemPath get_CrcFile();
    private FileSystemPath get_FormatVersionFile();
    private string NewDataPath();
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Load>b__25_0(FileSystemPath dir);
    [CompilerGeneratedAttribute]
private string <Load>b__25_1(FileSystemPath path);
    [CompilerGeneratedAttribute]
private void <WriteVersion>b__38_0(BinaryWriter stream);
}
internal static class JetBrains.ReSharper.Psi.Util.Caches.RecordsUtil : object {
    private static int RECORD_SIGNATURE;
    public static void WriteRecordData(BinaryWriter writer, ArraySegment`1<byte> bytes, Int32& crc);
    [CanBeNullAttribute]
public static Byte[] ReadRecordData(BinaryReader reader, Int32& crc);
    public static bool ReadRecordData(ReadOnlySpan`1<byte> input, Int32& crc, Int32& dataOffset, Int32& length);
    private static bool ReadInt(ReadOnlySpan`1& input, Int32& result);
    private static int ComputeCRC(ArraySegment`1<byte> bytes);
    private static int ComputeCRC(ReadOnlySpan`1<byte> bytes);
}
[ObsoleteAttribute("Use SimpleICache instead wherever possible")]
public class JetBrains.ReSharper.Psi.Util.Caches.SimplePersistentCache`1 : AbstractPersistentCache`2<IPsiSourceFile, TData> {
    private IShellLocks myLocks;
    private string myCacheDirectoryName;
    private IPersistentIndexManager myPersistentIdIndex;
    private Func`3<IPsiSourceFile, BinaryReader, TData> myReadData;
    private Action`3<BinaryWriter, IPsiSourceFile, TData> mySaveData;
    private FileSystemPath mySolutionCacheFolder;
    [CompilerGeneratedAttribute]
private int <FormatVersion>k__BackingField;
    protected FileSystemPath CacheDirectory { get; }
    protected int FormatVersion { get; }
    protected bool CheckTotalConsistency { get; }
    protected string LoadSaveProgressText { get; }
    public SimplePersistentCache`1(IShellLocks locks, int formatVersion, string cacheDirectoryName, IPsiConfiguration psiConfiguration);
    protected sealed virtual bool IsKeyValid(IPsiSourceFile key);
    protected sealed virtual FileSystemPath get_CacheDirectory();
    protected sealed virtual void WriteKey(BinaryWriter writer, IPsiSourceFile sourceFile);
    protected sealed virtual bool ReadKey(BinaryReader reader, IPsiSourceFile& sourceFile);
    protected sealed virtual void DataLoaded(IPsiSourceFile key, TData data, bool keyValid, Action& waitToContinue);
    protected sealed virtual IDisposable DataLock();
    [CompilerGeneratedAttribute]
protected sealed virtual int get_FormatVersion();
    protected sealed virtual bool get_CheckTotalConsistency();
    protected virtual string get_LoadSaveProgressText();
    protected sealed virtual void WriteData(BinaryWriter writer, IPsiSourceFile key, TData data);
    protected sealed virtual TData ReadData(BinaryReader reader, IPsiSourceFile key);
    public LoadResult Load(IProgressIndicator progressIndicator, IPersistentIndexManager persistentIdIndex, Func`3<IPsiSourceFile, BinaryReader, TData> readData, Action`2<IPsiSourceFile, TData> dataLoaded);
    public void Save(IProgressIndicator progressIndicator, IPersistentIndexManager persistentIdIndex, Action`3<BinaryWriter, IPsiSourceFile, TData> saveData);
}
public class JetBrains.ReSharper.Psi.Util.ClassInitialization.ClassInitializationInfo : object {
    [CompilerGeneratedAttribute]
private ConstructorFlags <constructorFlags>P;
    [CompilerGeneratedAttribute]
private IConstructor <InitializerConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<InitializationFact> <Initializations>k__BackingField;
    [CanBeNullAttribute]
public IConstructor InitializerConstructor { get; }
    [NotNullAttribute]
public IReadOnlyList`1<InitializationFact> Initializations { get; }
    public ConstructorFlags Flags { get; }
    public bool HasThisInitializer { get; }
    public ClassInitializationInfo(IConstructor initializerConstructor, IReadOnlyList`1<InitializationFact> initializations, ConstructorFlags constructorFlags);
    [CompilerGeneratedAttribute]
public IConstructor get_InitializerConstructor();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<InitializationFact> get_Initializations();
    public ConstructorFlags get_Flags();
    public bool get_HasThisInitializer();
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Psi.Util.ClassInitialization.ConstructorFlags : Enum {
    public int value__;
    public static ConstructorFlags None;
    public static ConstructorFlags IsPrimary;
    public static ConstructorFlags IsTrivial;
    public static ConstructorFlags HasThisInitializer;
    public static ConstructorFlags HasBaseInitializer;
    public static ConstructorFlags DefaultBaseConstructor;
    public static ConstructorFlags BrokenOrUnfinished;
    public static ConstructorFlags UnresolvedBaseConstructorCall;
}
public class JetBrains.ReSharper.Psi.Util.ClassInitialization.ConstructorParameter : object {
    [CompilerGeneratedAttribute]
private IParameter <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ParameterIndex>k__BackingField;
    [CanBeNullAttribute]
public IParameter Parameter { get; }
    public int ParameterIndex { get; }
    public ConstructorParameter(IParameter parameter);
    public ConstructorParameter(int parameterIndex);
    [CompilerGeneratedAttribute]
public IParameter get_Parameter();
    [CompilerGeneratedAttribute]
public int get_ParameterIndex();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class JetBrains.ReSharper.Psi.Util.ClassInitialization.InitializationFact : object {
    [CompilerGeneratedAttribute]
private IDeclaredElement <Destination>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ITreeNode <TreeNode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ChecksSourceForNull>k__BackingField;
    public IDeclaredElement Destination { get; }
    [NullableAttribute("2")]
public ITreeNode TreeNode { get; }
    public bool ChecksSourceForNull { get; public set; }
    protected InitializationFact(IDeclaredElement destination, ITreeNode treeNode);
    [CompilerGeneratedAttribute]
public IDeclaredElement get_Destination();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ITreeNode get_TreeNode();
    [CompilerGeneratedAttribute]
public bool get_ChecksSourceForNull();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ChecksSourceForNull(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Psi.Util.ClassInitialization.ParameterPassInitialization : InitializationFact {
    [CompilerGeneratedAttribute]
private IParameter <SourceParameter>k__BackingField;
    public IParameter SourceParameter { get; }
    public ParameterPassInitialization(IDeclaredElement destination, IParameter sourceParameter, ITreeNode treeNode);
    [CompilerGeneratedAttribute]
public IParameter get_SourceParameter();
}
public class JetBrains.ReSharper.Psi.Util.ClassInitialization.TypeMemberInitialization : InitializationFact {
    [NullableContextAttribute("1")]
public TypeMemberInitialization(IDeclaredElement destination, ITreeNode treeNode);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Util.ClassInitialization.ValueInfo : ValueType {
    [NotNullAttribute]
public IExpression Expression;
    public bool CapturesParameters;
    public ValueInfo(IExpression expression, bool capturesParameters);
}
public class JetBrains.ReSharper.Psi.Util.ClassInitialization.ValueInitialization : InitializationFact {
    [CompilerGeneratedAttribute]
private ValueInfo <Value>k__BackingField;
    public ValueInfo Value { get; }
    [NullableContextAttribute("1")]
public ValueInitialization(IDeclaredElement destination, ITreeNode treeNode, ValueInfo value);
    [CompilerGeneratedAttribute]
public ValueInfo get_Value();
}
public class JetBrains.ReSharper.Psi.Util.ClrPredefinedTypeConversionRule : object {
    [NotNullAttribute]
public static ITypeConversionRule INSTANCE;
    public IEqualityComparer`1<IType> EqualityComparer { get; }
    private static ClrPredefinedTypeConversionRule();
    public sealed virtual IEqualityComparer`1<IType> get_EqualityComparer();
    public sealed virtual bool IsImplicitlyConvertibleTo(IType from, IType to);
    public sealed virtual bool IsExplicitlyConvertibleTo(IType from, IType to);
    public sealed virtual bool IsImplicitlyConvertibleTo(IExpressionType from, IType to);
    public sealed virtual bool IsExplicitlyConvertibleTo(IExpressionType from, IType to);
    public sealed virtual bool IsExplicitlyConvertiblePredefined(IType from, IType to);
    public sealed virtual bool HasStandardImplicitConversion(IType from, IType to);
    public sealed virtual bool HasExtensionMethodThisArgumentConversion(IType from, IType to, ParameterKind thisParameterKind);
    public sealed virtual bool HasIdentityConversion(IType from, IType to);
    public sealed virtual bool IsImplicitlyConvertiblePredefined(IType from, IType to);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.CLRTypeConversionUtil : object {
    [ThreadStaticAttribute]
private static HashSet`1<IType> ourVisitedEffectiveInterfacesConstraints;
    [ThreadStaticAttribute]
private static HashSet`1<Pair`2<IDeclaredType, IDeclaredType>> ourImplicitVariantConvertibleCirculationCheck;
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static IType EffectiveBaseClass(ITypeParameter typeParameter);
    [CanBeNullAttribute]
private static IType EffectiveBaseClass(ITypeParameter baseParameter, FrugalLocalHashSet`1& processed);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static List`1<IDeclaredType> EffectiveImmediateInterfaces(ITypeParameter typeParameter);
    private static void CollectEffectiveInterfaces(ITypeParameter typeParameter, HashSet`1<ITypeParameter> visited, List`1<IDeclaredType> consumer);
    [NotNullAttribute]
[ItemNotNullAttribute]
public static HashSet`1<IType> EffectiveInterfaces(ITypeParameter typeParameter, ISubstitution substitution);
    [NotNullAttribute]
[ItemNotNullAttribute]
private static HashSet`1<IType> EffectiveInterfacesImpl(ITypeParameter typeParameter, ISubstitution substitution, HashSet`1<IType> visited);
    private static bool CheckArrayCovariance(IArrayType fromArrayType, IArrayType toArrayType);
    public static bool IdentityConvertible(IType typeA, IType typeB, bool allowUnknownTypeEquality, bool compareTupleElementNames);
    public static bool ImplicitVariantConvertible(IDeclaredType from, IDeclaredType to, Func`3<IType, IType, bool> implicitReferenceConversionCheck);
    private static bool VariantConvertible(IList`1<ITypeParameter> typeParameters, ISubstitution from, ISubstitution to, Func`3<IType, IType, bool> implicitReferenceConversionCheck);
    public static bool ImplicitReferenceConversionExist(IType from, IType to);
    public static bool ClrIsImplicitlyConvertiblePredefined(IType from, IType to);
    [CanBeNullAttribute]
public static IType MostEncompassedType(IList`1<IType> types);
    public static bool IsRuntimeSimilar(IType typeA, IType typeB);
    [CompilerGeneratedAttribute]
internal static bool <ClrIsImplicitlyConvertiblePredefined>g__IsDescendantOfGenericListOrReadOnlyList|13_0(IDeclaredType declaredType, <>c__DisplayClass13_0& );
    [CompilerGeneratedAttribute]
internal static Nullable`1<ValueTuple`2<IType, IType>> <IsRuntimeSimilar>g__GetArrayElementTypes|15_0(IType firstType, IType secondType);
    [CompilerGeneratedAttribute]
internal static bool <IsRuntimeSimilar>g__HasNumericSameSizeConversion|15_1(IType e1, IType e2);
    [CompilerGeneratedAttribute]
internal static bool <IsRuntimeSimilar>g__HasNumericToIntPtrSameSizeConversion|15_2(IType e1, IType e2);
}
public class JetBrains.ReSharper.Psi.Util.CodeRegion : object {
    [CompilerGeneratedAttribute]
private ITreeNode <First>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <Last>k__BackingField;
    [CompilerGeneratedAttribute]
private ICodeRegionIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ICodeRegion> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private Predicate`1<ITreeNode> <IsSignificantNode>k__BackingField;
    public ITreeNode First { get; public set; }
    public ITreeNode Last { get; public set; }
    public ICodeRegionIdentity Identity { get; }
    public IList`1<ICodeRegion> Children { get; }
    public Predicate`1<ITreeNode> IsSignificantNode { get; }
    private bool JetBrains.ReSharper.Psi.ITreeRange.IsEmpty { get; }
    private IList`1<ICodeRegion> JetBrains.ReSharper.Psi.Util.ICodeRegion.Children { get; }
    private IEnumerable`1<ITreeNode> JetBrains.ReSharper.Psi.Util.ICodeRegion.SignificantNodes { get; }
    public CodeRegion(ICodeRegionIdentity identity, Predicate`1<ITreeNode> significantNodeMatcher);
    private CodeRegion(ICodeRegionIdentity identity, Predicate`1<ITreeNode> significantNodeMatcher, IEnumerable`1<CodeRegion> children);
    [CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_First();
    [CompilerGeneratedAttribute]
public void set_First(ITreeNode value);
    [CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_Last();
    [CompilerGeneratedAttribute]
public void set_Last(ITreeNode value);
    [CompilerGeneratedAttribute]
public sealed virtual ICodeRegionIdentity get_Identity();
    [CompilerGeneratedAttribute]
public IList`1<ICodeRegion> get_Children();
    [CompilerGeneratedAttribute]
public sealed virtual Predicate`1<ITreeNode> get_IsSignificantNode();
    private sealed virtual override bool JetBrains.ReSharper.Psi.ITreeRange.get_IsEmpty();
    private sealed virtual override IList`1<ICodeRegion> JetBrains.ReSharper.Psi.Util.ICodeRegion.get_Children();
    private sealed virtual override IEnumerable`1<ITreeNode> JetBrains.ReSharper.Psi.Util.ICodeRegion.get_SignificantNodes();
    private IEnumerable`1<ITreeNode> GetSignificantNodes();
    public sealed virtual IEnumerator`1<ITreeNode> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    public sealed virtual void ExpandToIncludeComments(IWhitespaceChecker wsChecker, ITreeRangeBuilder rangeBuilder, bool canExpand, TreeOffset mayExpandLeftTo, TreeOffset mayExpandRightTo, IRegionStructureProvider provider);
    private static ITreeNode WithPrecedingComments(ITreeNode node, IWhitespaceChecker wsChecker, ITreeRangeBuilder rangeBuilder, TreeOffset mayExpandTo, IRegionStructureProvider provider);
    private static ITreeNode WithCommentsOnTheSameLine(ITreeNode node, IWhitespaceChecker wsChecker, ITreeRangeBuilder rangeBuilder, TreeOffset mayExpandTo, IRegionStructureProvider provider);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.CodeRegionExtensions : object {
    [ExtensionAttribute]
public static void Add(ICodeRegion ths, ICodeRegion region);
    private static void AddSharedChildren(ICodeRegion child, ICodeRegion region);
    [ExtensionAttribute]
private static void AddRegionToChildren(ICodeRegion ths, int targetIndex, ICodeRegion region);
    [ExtensionAttribute]
private static bool InsertChild(ICodeRegion ths, int index, ICodeRegion child);
    private static CodeRegion CreateEnvelopFor(ICodeRegion firstRegion, ICodeRegion secondRegion);
    [CanBeNullAttribute]
private static ITreeNode LeftMost(IEnumerable`1<ITreeNode> nodes);
    [CanBeNullAttribute]
private static ITreeNode RightMost(IEnumerable`1<ITreeNode> nodes);
    [ExtensionAttribute]
public static bool CreatedFor(ICodeRegion region);
    [ExtensionAttribute]
public static RangeDisposition GetDisposition(ITreeRange ths, ITreeRange other);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static ITreeNode GetSingleSignificantNode(ICodeRegion ths);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Util.CodeRegionExtensions/<GetSafeRange>d__10")]
[ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
public static IEnumerable`1<ITreeNode> GetSafeRange(ICodeRegion ths, ITreeRange range);
}
public class JetBrains.ReSharper.Psi.Util.CodeRegionSlice : object {
    private ICodeRegion myParent;
    private IList`1<ICodeRegion> myChildren;
    [CompilerGeneratedAttribute]
private ITreeNode <First>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <Last>k__BackingField;
    public ITreeNode First { get; }
    public ITreeNode Last { get; }
    public ICodeRegionIdentity Identity { get; }
    public IList`1<ICodeRegion> Children { get; }
    public IEnumerable`1<ITreeNode> SignificantNodes { get; }
    public Predicate`1<ITreeNode> IsSignificantNode { get; }
    public bool IsEmpty { get; }
    public CodeRegionSlice(ICodeRegion parent, ITreeNode newFirst, ITreeNode newLast);
    [CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_First();
    [CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_Last();
    public sealed virtual ICodeRegionIdentity get_Identity();
    public sealed virtual IList`1<ICodeRegion> get_Children();
    public sealed virtual IEnumerable`1<ITreeNode> get_SignificantNodes();
    public sealed virtual Predicate`1<ITreeNode> get_IsSignificantNode();
    public sealed virtual void ExpandToIncludeComments(IWhitespaceChecker wsChecker, ITreeRangeBuilder rangeBuilder, bool canExpand, TreeOffset mayExpandLeftTo, TreeOffset mayExpandRightTo, IRegionStructureProvider provider);
    public sealed virtual bool get_IsEmpty();
    public sealed virtual IEnumerator`1<ITreeNode> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.CollectionTypeExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsGenericOrNonIEnumerator(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsGenericOrNonIEnumerable(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSingleEnumerationInterface(IType type);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsCollectionLike(IType type);
    [ExtensionAttribute]
[PureAttribute]
public static bool ConstructorHasCollectionAccessAnnotation(IType type, ITreeNode context);
}
public class JetBrains.ReSharper.Psi.Util.CollectionTypeUtil : object {
    public static string Entry;
    [CanBeNullAttribute]
[PureAttribute]
public static IType ElementTypeByCollectionType(IType type, ITreeNode context, bool isAsyncContext, IAccessContext accessContext);
    [CanBeNullAttribute]
[PureAttribute]
public static DeclaredElementInstance`1<IMethod> GetEnumeratorMethod(bool isAsyncEnumerator, IType type, IAccessContext accessContext, ITreeNode context);
    [NotNullAttribute]
[PureAttribute]
public static IList`1<IType> GetElementTypesForGenericEnumerable(IDeclaredType declaredType, bool isAsync);
    [CanBeNullAttribute]
[PureAttribute]
public static IList`1<IType> GetElementTypesForGenericType(IDeclaredType declaredType, IDeclaredType genericType, int typeParameterIndex);
    [CanBeNullAttribute]
[PureAttribute]
public static IList`1<IType> GetElementTypesForGenericType(IDeclaredType declaredType, ITypeElement genericTypeElement, int typeParameterIndex);
    [CanBeNullAttribute]
[PureAttribute]
public static IDeclaredType GetTypeContainingEnumerable(IType type, ITreeNode context, bool isAsyncContext, IAccessContext accessContext);
    [CanBeNullAttribute]
[PureAttribute]
public static IDeclaredType CreateIEnumerableOf(IPsiModule module, IType elementType);
    [CanBeNullAttribute]
[PureAttribute]
public static DeclaredElementInstance`1<IMethod> GetIEnumerableEnumeratorMethod(PredefinedType predefinedType);
    [CanBeNullAttribute]
[PureAttribute]
public static DeclaredElementInstance`1<IMethod> GetGenericIEnumerableEnumeratorMethod(PredefinedType predefinedType, IType elementType);
    [CanBeNullAttribute]
public static IType TrySubstituteDifferentElementType(IType collectionType, IType newElementType, ITreeNode context, IAccessContext accessContext, bool isAsyncContext);
    private static void CollectTypeArgumentsOfImplementedEnumerableTypeElement(bool isAsyncEnumerable, ITypeElement genericEnumerableTypeElement, IDeclaredType type, IAccessContext accessContext, HashSet`1<IType> typeArguments);
    [CanBeNullAttribute]
[PureAttribute]
public static DeclaredElementInstance`1<IMethod> TryResolveGenericEnumerableMember(bool isAsyncEnumerable, IDeclaredType declaredType, IAccessContext accessContext, PredefinedType predefinedType, IList`1& candidates);
    [CanBeNullAttribute]
[PureAttribute]
public static DeclaredElementInstance`1<IMethod> TryResolveNonGenericIEnumerableMember(IDeclaredType declaredType, ITypeConversionRule typeConversionRule, PredefinedType predefinedType);
    public static bool IsArray(IType type, IType& elementType);
    [CanBeNullAttribute]
[PureAttribute]
public static IType GuessCollectionElementType(IType collectionType, ITreeNode context);
    [CanBeNullAttribute]
[PureAttribute]
private static IType GuessElementTypeByEntryProperty(IType collectionType, ITreeNode context);
}
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.Util.CommonIdentifierIntern : ThreadSafeInternsObjectPool`1<ITokenIntern> {
    private static int MaxInternCapacity;
    private static int InitialInternCapacity;
    protected virtual ITokenIntern CreateObject();
    protected virtual void ClearObject(ITokenIntern t);
    protected virtual void InitObject(ITokenIntern t);
    [ThreadSafeAttribute]
public ITokenIntern GetOrCreateIntern(Lifetime lifetime);
    public void ClearInterns();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.CommonIdentifierInternExtensions : object {
    [ExtensionAttribute]
public static void DoWithIdentifierIntern(CommonIdentifierIntern interns, Action`1<ITokenIntern> action);
    [ExtensionAttribute]
public static T DoWithIdentifierIntern(CommonIdentifierIntern interns, Func`2<ITokenIntern, T> action);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.KnownLanguage", "16")]
public class JetBrains.ReSharper.Psi.Util.ContainingNodesWalker : object {
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Util.ContainingNodesWalker/<WalkThroughFirstDeclaredElements>d__0")]
public virtual IEnumerable`1<IDeclaredElement> WalkThroughFirstDeclaredElements(ITreeNode treeNode, bool returnThis);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.DeclaredElementUtil : object {
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsExtensionMethod(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsDelegateInvokeMethod(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsConstant(IDeclaredElement element);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsEnumMember(IDeclaredElement element);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsLocalConstant(IDeclaredElement element);
    public static bool IsAsyncAwaitablePatternMember(IDeclaredElement declaredElement, ISubstitution substitution);
    [PureAttribute]
[ContractAnnotationAttribute("declaredElement: null => false")]
public static bool IsAsyncGetAwaiterMethod(IDeclaredElement declaredElement, ISubstitution substitution);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsAwaiterType(IType type);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
private static bool IsAwaiterGetResultCandidate(IDeclaredElement declaredElement);
    [PureAttribute]
[ContractAnnotationAttribute("declaredElement: null => false")]
public static bool IsAwaiterOnCompletedCandidate(IDeclaredElement declaredElement, ISubstitution substitution);
    [PureAttribute]
[ContractAnnotationAttribute("declaredElement: null => false")]
private static bool IsAwaiterIsCompletedCandidate(IDeclaredElement declaredElement, ISubstitution substitution);
    [PureAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static IDeclaredElement EliminateDelegateInvokeMethod(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
public static ReferenceKind GetExtensionMethodThisParameterReferenceKind(IMethod method);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsMutableRefThisExtensionMethod(IMethod method);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsByRefThisExtensionMethod(IMethod method);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsPolymorphicNonSealedTypeMember(ITypeMember typeMember);
    [ExtensionAttribute]
[PureAttribute]
[NotNullAttribute]
public static IReadOnlyList`1<IAccessor> GetAllAccessors(ITypeMember typeMember);
    [ExtensionAttribute]
[PureAttribute]
[CanBeNullAttribute]
public static IAccessor TryGetAccessor(ITypeMember typeMember, AccessorKind accessorKind);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNotFullyPublicAccessMember(IOverridableMember member);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool HasImplicitInstanceConstructor(IClass classType);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasCompilerGeneratedAttribute(IDeclaredElement element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsStaticPolymorphicInterfaceMember(IOverridableMember member);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsStaticPolymorphicInterfaceMember(IDeclaredElement element);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsImplementableInterfaceMember(ITypeMember member);
    [PureAttribute]
public static bool CanContainCustomConversionOperator(IDeclaredType declaredType, bool isExplicit);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static ReferenceKind GetReferenceKind(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsRequiredFieldOrProperty(ITypeMember typeMember);
    [ExtensionAttribute]
[PureAttribute]
public static bool SetsRequiredMembers(IConstructor constructor);
    [CompilerGeneratedAttribute]
internal static bool <CanContainCustomConversionOperator>g__CanContainCustomCustomConversionOperatorCore|24_0(ITypeElement typeElement, <>c__DisplayClass24_0& );
    [CompilerGeneratedAttribute]
internal static void <CanContainCustomConversionOperator>g__AddDependency|24_1(ITypeElement typeElement, <>c__DisplayClass24_0& );
    [CompilerGeneratedAttribute]
internal static bool <CanContainCustomConversionOperator>g__HasMemberPresenceFlag|24_2(ITypeElement typeElement, <>c__DisplayClass24_0& );
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.Util.Deconstruction.IDeconstruction {
    public IReadOnlyList`1<IDeconstructionComponent> Components { get; }
    public abstract virtual bool IsValid();
    public abstract virtual IReadOnlyList`1<IDeconstructionComponent> get_Components();
}
public interface JetBrains.ReSharper.Psi.Util.Deconstruction.IDeconstructionComponent {
    [NotNullAttribute]
public IType Type { get; }
    public abstract virtual IType get_Type();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Util.DisjointedTreeTextRange : ValueType {
    [NullableAttribute("1")]
private List`1<DisjointedRangeNode> myTreeElements;
    [NullableContextAttribute("1")]
private DisjointedTreeTextRange(List`1<DisjointedRangeNode> list);
    [PureAttribute]
public static DisjointedTreeTextRange From(ITreeNode treeNode);
    [NullableContextAttribute("1")]
[PureAttribute]
public static DisjointedTreeTextRange From(TTreeNode element, Func`2<TTreeNode, DisjointedTreeTextRange> rangeSelector);
    [PureAttribute]
public static DisjointedTreeTextRange FromAll(IEnumerable`1<T> collection, Func`2<T, DisjointedTreeTextRange> rangeSelector);
    [PureAttribute]
public static DisjointedTreeTextRange FromAll(IEnumerable`1<T> collection, Func`2<T, ITreeNode> nodeSelector);
    [PureAttribute]
public static DisjointedTreeTextRange FromAll(IEnumerable`1<ITreeNode> nodes);
    [PureAttribute]
public static DisjointedTreeTextRange Empty();
    [PureAttribute]
public bool Contains(TreeTextRange range);
    [NullableContextAttribute("1")]
[PureAttribute]
public IReadOnlyList`1<TreeTextRange> BuildRanges();
    [PureAttribute]
public DisjointedTreeTextRange Then(ITreeNode treeNode);
    [NullableContextAttribute("1")]
[PureAttribute]
public DisjointedTreeTextRange Then(ITokenNodeType tokenNodeType);
    [NullableContextAttribute("1")]
[PureAttribute]
public DisjointedTreeTextRange Switch(DisjointedTreeTextRange[] alternatives);
    [PureAttribute]
public DisjointedTreeTextRange ThenAll(DisjointedTreeTextRange other);
    [PureAttribute]
public DisjointedTreeTextRange ThenAll(IEnumerable`1<T> collection, Func`2<T, DisjointedTreeTextRange> rangeSelector);
    [PureAttribute]
public DisjointedTreeTextRange ThenAll(IEnumerable`1<ITreeNode> nodes);
    [PureAttribute]
public DisjointedTreeTextRange ThenAll(IEnumerable`1<T> collection, Func`2<T, ITreeNode> nodeSelector);
    [NullableContextAttribute("1")]
[PureAttribute]
public DisjointedTreeTextRange Then(TTreeNode element, Func`2<TTreeNode, DisjointedTreeTextRange> rangeSelector);
    [PureAttribute]
public TreeRangeChecker OrExactly(ITreeNode treeNode);
    [PureAttribute]
public TreeRangeChecker OrExactlyBefore(ITreeNode treeNode);
    [PureAttribute]
public TreeRangeChecker OrExactlyAfter(ITreeNode treeNode);
    [PureAttribute]
public TreeRangeChecker OrExactlyFromTo(ITreeNode from, ITreeNode to);
    private static bool CanJoinNodes(ITreeNode left, ITreeNode right);
}
public class JetBrains.ReSharper.Psi.Util.EnableUsingListPreprocessorRegionAnalysisCookie : object {
    [CanBeNullAttribute]
[ThreadStaticAttribute]
private static EnableUsingListPreprocessorRegionAnalysisCookie ourCookie;
    [NotNullAttribute]
[MustDisposeResourceAttribute]
public static IDisposable Create(bool enableAnalysis);
    public static bool Exists();
    public sealed virtual void Dispose();
}
public class JetBrains.ReSharper.Psi.Util.EnvelopeCodeRegionIdentity : object {
    public sealed virtual string Format(ITreeNode startNode, ITreeNode endNode);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Util.ExpectedNamespaceAndNamespaceChecker : ValueType {
    [CanBeNullAttribute]
public string ExpectedNamespace;
    [CanBeNullAttribute]
public Func`2<string, bool> NamespaceChecker;
    public ExpectedNamespaceAndNamespaceChecker(string expectedNamespace, Func`2<string, bool> namespaceChecker);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.ExpressionExtensions : object {
    [ExtensionAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsPure(IExpression expression);
    [ExtensionAttribute]
[ContractAnnotationAttribute("expression: null => false")]
public static bool IsPure(IExpression expression, Func`2<IExpression, bool> isWriteAccessAllowed);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.KnownLanguage", "16")]
public class JetBrains.ReSharper.Psi.Util.ExpressionPurityService : object {
    [ContractAnnotationAttribute("expression: null => false")]
public bool IsPure(IExpression expression, Func`2<IExpression, bool> customCheck);
    [PureAttribute]
protected virtual bool IsPureImpl(ITreeNode node, Func`2<IExpression, bool> isWriteAccessAllowed);
    protected virtual bool CheckWriteAccess(IExpression expression, Func`2<IExpression, bool> isWriteAccessAllowed);
    protected virtual bool IsPure(IReference reference);
    protected virtual bool IsPure(IDeclaredElement declaredElement);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Util.ExtensionManager`2 : object {
    [CompilerGeneratedAttribute]
private Func`2<TExtendable, TExtension> <extensionFactory>P;
    private Dictionary`2<TExtendable, TExtension> myExtensions;
    public TExtension Item { get; }
    public ExtensionManager`2(Func`2<TExtendable, TExtension> extensionFactory);
    public bool HasExtension(TExtendable extendable);
    public bool RemoveExtension(TExtendable extendable);
    public TExtension get_Item(TExtendable extendable);
}
public static class JetBrains.ReSharper.Psi.Util.FileResolveUtil : object {
    public static ResolveResultWithInfo CheckResolveResut(ResolveResultWithInfo resolveResult, string name);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.FileSpecificUtil : object {
    [NotNullAttribute]
public static IFileTypeSpecificOwnerUtil GetFileSpecificService(IPsiSourceFile sourceFile);
    [NotNullAttribute]
private static IFileTypeSpecificOwnerUtil GetFileSpecificService(ProjectFileType projectFileType);
    public static IReadOnlyCollection`1<IDeclaration> SortDeclarationsByWritability(ITypeElement typeElement, IDeclaration preferredDeclaration, PsiLanguageType language);
    [NotNullAttribute]
public static IReadOnlyCollection`1<IDeclaration> SortDeclarationsByWritability(IEnumerable`1<IDeclaration> declarations, IDeclaration preferredDeclaration, PsiLanguageType language);
    private static bool LanguageIsPrimaryForFile(IPsiSourceFile sourceFile, PsiLanguageType language);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Util.FileSpecificUtil/<GetExtraDeclarations>d__5")]
[NotNullAttribute]
private static IEnumerable`1<IDeclaration> GetExtraDeclarations(IDeclaration declaration);
    [NotNullAttribute]
public static IList`1<ITypeDeclaration> GetRelatedAndFilterHidden(IEnumerable`1<ITypeDeclaration> declarations);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Util.FileSpecificUtil/<GetVisibleDeclarations>d__7")]
[NotNullAttribute]
public static IEnumerable`1<ITypeDeclaration> GetVisibleDeclarations(ITypeElement typeElement);
    public static bool HasHiddenDeclarations(ITypeElement typeElement);
    public static bool IsHidden(ITypeDeclaration declaration);
    [ObsoleteAttribute("Use more specific method from this class or IDeclaration.IsSynthetic")]
public static bool IsCodeBehindClass(ITypeElement typeElement);
    public static bool IsUserTextDeclaration(IDeclaration declaration);
    public static bool CanContainSeveralClasses(IPsiSourceFile sourceFile);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static string GetDefaultNamespace(IProject project);
    public static string GetNamespaceForElementsMovedToExternalScope(ITypeDeclaration typeDeclaration, ITreeNode referenceNode);
    public static string GetNamespaceForElementsMovedToExternalScope(ITypeElement typeElement, ITreeNode referenceNode);
    public static VirtualFileSystemPath GetFolderForElementsMovedToExternalScope(IProjectFile projectFile, string namespace, ITreeNode referenceNode);
    public static bool CanImplementInterfaces(ITypeElement typeElement);
    public static bool CanHaveConstructors(ITypeElement typeElement);
    public static bool CanAnotherClassBePlacedBeside(ITypeElement typeElement);
    public static bool SuperClassCanBeChanged(ITypeElement typeElement);
    public static bool HasUglyName(ITypeElement typeElement);
    [NotNullAttribute]
public static string GetPrettyName(ITypeElement typeElement, bool mustBeIdentifier);
    public static bool CanDeclarationBeOverloaded(IDeclaration declaration);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasChangeableDocumentRange(ITreeRange range);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasChangeableDocumentRange(ITreeNode node);
    [ExtensionAttribute]
[PureAttribute]
public static DocumentRange GetExtendedDocumentRange(ITreeNode node);
}
public static class JetBrains.ReSharper.Psi.Util.FormatStringParser : object {
    [NotNullAttribute]
public static IReadOnlyList`1<FormatItem> Parse(string formatString, bool parseForNetCore);
    [NotNullAttribute]
public static IReadOnlyList`1<FormatItem> Parse(string formatString, IReadOnlyList`1& unescapedRightBraces, IReadOnlyList`1& unescapedLeftBraces, bool parseForNetCore);
}
public enum JetBrains.ReSharper.Psi.Util.FormattingFunctionKind : Enum {
    public int value__;
    public static FormattingFunctionKind None;
    public static FormattingFunctionKind StringFormat;
    public static FormattingFunctionKind StructuredMessageTemplate;
}
public static class JetBrains.ReSharper.Psi.Util.FunctionInvocationUtil : object {
    [CanBeNullAttribute]
public static IFunctionInvocationClrWrapper GetFunctionInvocationByArgument(IExpression expression);
    [CanBeNullAttribute]
public static IFunctionInvocationClrWrapper SurroundWithStaticMethodInvocation(IFunction method, IExpression expression, IPsiModule psiModule);
    [PureAttribute]
public static bool IsArgumentOfMethodThatHasSimilarFormattingMethod(IExpression expression, IFunction& similarFormattingFunction);
    [PureAttribute]
public static bool IsArgumentOfFormatingFunction(IExpression expression, FormattingFunctionKind& formattingFunctionKind);
    [PureAttribute]
public static bool ExpressionCanBeReplacedByMethodInvocation(IExpression expression);
    [CanBeNullAttribute]
public static IFunctionInvocationClrWrapper GetFunctionInvocationByArgumentsOwner(IArgumentsOwner argumentsOwner, ILanguageManager languageManager);
    [CanBeNullAttribute]
public static IExpression GetNarrowestContainingArgumentExpression(IExpression expression);
}
public static class JetBrains.ReSharper.Psi.Util.HierarchyUtil : object {
    public static bool HaveCommonSubtype(IExpressionType type1, IExpressionType type2);
    public static bool IsCompatibleSubtype(IType subType, IType superType);
    public static bool CanHaveCommonSubtype(IExpressionType type1, IExpressionType type2);
    private static Nullable`1<bool> HaveCommonSubtypeSwitch(ITypeElement t1, ISubstitution s1, ITypeElement t2, IDeclaredType dt2);
    private static bool HaveCommonSubtypeInHierarchy(ITypeElement t1, ISubstitution s1, ITypeElement t2, ISubstitution s2);
    private static bool IsPossibleArrayCoVariance(ITypeElement subTypeElement, ISubstitution subTypeSubstitution, ITypeElement superTypeElement, ISubstitution superTypeSubstitution);
    [PureAttribute]
private static bool IsCompatibleType(ITypeElement subTypeElement, ITypeElement t1, ISubstitution s1, ITypeElement t2, ISubstitution s2);
    [PureAttribute]
private static bool IsTypeParameterCompatible(ITypeParameter typeParameter, IType type);
    [CanBeNullAttribute]
private static ISubstitution GetAncestorSubstitution(ITypeElement subTypeElement, ITypeElement typeElement, ISubstitution substitution, int depth);
    [NotNullAttribute]
private static ISubstitution CreateSubstitutionForSubtype(ISubstitution ancestorSubstitution, ISubstitution sourceSubstitution);
    private static bool IsCompatibleType(ITypeElement subTypeElement, ISubstitution subTypeSubstitution, ITypeElement superTypeElement, ISubstitution superTypeSubstitution);
    private static bool IsCompatibleSubstitution(HybridCollection`1<ITypeParameter> typeParameters, Func`2<ITypeParameter, IType> foundSubst, ISubstitution originalSubst, int depth);
    [NotNullAttribute]
public static HashSet`1<IOverridableMember> FindCompleteTypeMemberHierarchy(IOverridableMember overridableMember);
    [CompilerGeneratedAttribute]
internal static bool <IsCompatibleSubstitution>g__CanBeInherritor|11_0(IType superType, IType possibleInheritorType, <>c__DisplayClass11_0& );
}
public interface JetBrains.ReSharper.Psi.Util.IApplicationWideContextBoundSettingStore {
    public IContextBoundSettingsStoreLive BoundSettingsStore { get; }
    public abstract virtual IContextBoundSettingsStoreLive get_BoundSettingsStore();
}
public interface JetBrains.ReSharper.Psi.Util.ICodeRegion {
    [NotNullAttribute]
public ICodeRegionIdentity Identity { get; }
    [NotNullAttribute]
public IList`1<ICodeRegion> Children { get; }
    [NotNullAttribute]
public IEnumerable`1<ITreeNode> SignificantNodes { get; }
    [NotNullAttribute]
public Predicate`1<ITreeNode> IsSignificantNode { get; }
    public abstract virtual ICodeRegionIdentity get_Identity();
    public abstract virtual IList`1<ICodeRegion> get_Children();
    public abstract virtual IEnumerable`1<ITreeNode> get_SignificantNodes();
    public abstract virtual Predicate`1<ITreeNode> get_IsSignificantNode();
    public abstract virtual void ExpandToIncludeComments(IWhitespaceChecker wsChecker, ITreeRangeBuilder rangeBuilder, bool canExpand, TreeOffset mayExpandLeftTo, TreeOffset mayExpandRightTo, IRegionStructureProvider provider);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.ICodeRegionExtensions : object {
    [ExtensionAttribute]
public static void Add2(ICodeRegion ths, ICodeRegion region2);
    private static CodeRegion CreateEnvelopFor(ICodeRegion firstRegion, ICodeRegion secondRegion);
    [CanBeNullAttribute]
private static ITreeNode LeftMost(ITreeNode[] nodes);
    [CanBeNullAttribute]
private static ITreeNode RightMost(ITreeNode[] nodes);
}
public interface JetBrains.ReSharper.Psi.Util.ICodeRegionIdentity {
    [NotNullAttribute]
public abstract virtual string Format(ITreeNode startNode, ITreeNode endNode);
}
public interface JetBrains.ReSharper.Psi.Util.ICollectionTypeHelper {
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IType ElementTypeByCollectionType(IType type, IAccessContext accessContext, ITreeNode context, bool isAsyncContext);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual DeclaredElementInstance`1<IMethod> GetEnumeratorMethod(IType type, IAccessContext accessContext, ITreeNode context, bool isAsyncContext);
}
public interface JetBrains.ReSharper.Psi.Util.ICreateNewFileTarget {
    public IProjectFolder TargetFolder { get; }
    public ProjectFileType FileType { get; }
    public VirtualFileSystemPath TargetPath { get; }
    public string FileName { get; }
    public string TargetNamespaceName { get; }
    public PsiLanguageType TargetLanguage { get; }
    [CanBeNullAttribute]
public IReference ReferenceToBind { get; }
    public abstract virtual IProjectFolder get_TargetFolder();
    public abstract virtual ProjectFileType get_FileType();
    public abstract virtual VirtualFileSystemPath get_TargetPath();
    public abstract virtual string get_FileName();
    public abstract virtual string get_TargetNamespaceName();
    public abstract virtual PsiLanguageType get_TargetLanguage();
    public abstract virtual IReference get_ReferenceToBind();
}
public interface JetBrains.ReSharper.Psi.Util.ICreationTarget {
    [CanBeNullAttribute]
public ITreeNode Anchor { get; }
    public abstract virtual ITreeNode get_Anchor();
    [NotNullAttribute]
public abstract virtual ITreeNode GetTargetDeclaration();
    [NotNullAttribute]
public abstract virtual IFile GetTargetDeclarationFile();
    [ItemCanBeNullAttribute]
public abstract virtual IEnumerable`1<ITreeNode> GetPossibleTargetDeclarations();
}
public interface JetBrains.ReSharper.Psi.Util.ICustomDefaultNamespaceProvider {
    public abstract virtual ExpectedNamespaceAndNamespaceChecker CalculateCustomNamespace(IProjectItem projectItem, PsiLanguageType language);
}
public interface JetBrains.ReSharper.Psi.Util.IFileTarget {
    public IFile TargetFile { get; }
    public abstract virtual IFile get_TargetFile();
}
public interface JetBrains.ReSharper.Psi.Util.IFileTypeSpecificOwnerUtil {
    public abstract virtual IEnumerable`1<IDeclaration> GetRelatedDeclarations(ITypeDeclaration typeDeclaration);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<ITypeDeclaration> GetRelatedAndFilterHidden(ITypeDeclaration declaration);
    [CanBeNullAttribute]
public abstract virtual ITypeElement GetContainingTypeForReference(IReference reference);
    public abstract virtual bool IsHidden(ITypeDeclaration declaration);
    [ObsoleteAttribute("Use more specific method from this interface or IDeclaration.IsSynthetic")]
public abstract virtual bool IsCodeBehindClass(ITypeDeclaration declaration);
    public abstract virtual bool IsUserTextDeclaration(IDeclaration declaration);
    public abstract virtual bool CanContainSeveralClasses(IPsiSourceFile sourceFile);
    public abstract virtual bool CanImplementInterfaces(ITypeDeclaration typeElement);
    public abstract virtual bool CanHaveConstructors(ITypeDeclaration typeElement);
    public abstract virtual bool SuperClassCanBeChanged(ITypeDeclaration typeElement);
    public abstract virtual bool SuperClassNameMustBeFull(ITypeDeclaration typeElement);
    public abstract virtual string GetNamespaceForElementsMovedToExternalScope(ITypeDeclaration typeDeclaration, ITreeNode referenceNode);
    public abstract virtual VirtualFileSystemPath GetFolderForElementsMovedToExternalScope(IProjectFile projectFile, string namespace, ITreeNode referenceNode);
    public abstract virtual string GetPrettyName(ITypeDeclaration typeDeclaration, bool mustBeIdentifier);
    public abstract virtual bool IsOperationPossibleOnUnmappedRange(ITreeNode node);
    public abstract virtual DocumentRange GetDocumentRangeForPartiallyUnmappedNode(ITreeNode node);
    public abstract virtual bool IsOperationPossibleOnUnmappedRange(ITreeRange range);
    public abstract virtual bool CanDeclarationBeOverloaded(IDeclaration declaration);
    public abstract virtual bool HasUglyName(ITypeDeclaration declaration);
}
public interface JetBrains.ReSharper.Psi.Util.IFunctionInvocationClrWrapper {
    [CanBeNullAttribute]
public IParametersOwner InvokedFunction { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IReadOnlyList`1<IParametersOwner> InvokedFunctionCandidates { get; }
    [NotNullAttribute]
public IArgumentsOwner ArgumentsOwner { get; }
    [NotNullAttribute]
[ItemCanBeNullAttribute]
public IReadOnlyList`1<IExpression> Arguments { get; }
    public bool ArgumentsByValueAndPositional { get; }
    public abstract virtual IParametersOwner get_InvokedFunction();
    public abstract virtual IReadOnlyList`1<IParametersOwner> get_InvokedFunctionCandidates();
    public abstract virtual IArgumentsOwner get_ArgumentsOwner();
    public abstract virtual IReadOnlyList`1<IExpression> get_Arguments();
    public abstract virtual bool get_ArgumentsByValueAndPositional();
    public abstract virtual void AddArgument(IExpression newArgumentExpression, int newArgumentIndex);
    public abstract virtual void ChangeInvokedMethod(IMethod newFunction);
    public abstract virtual void RemoveArgumentAt(int argumentToDeleteIndex);
    public abstract virtual void SetArgumentAt(int currentItemIndex, IExpression argumentExpression);
}
public interface JetBrains.ReSharper.Psi.Util.IFunctionInvocationProvider {
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IFunctionInvocationClrWrapper GetFunctionInvocationByArgument(IExpression expression);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IFunctionInvocationClrWrapper GetFunctionInvocationByArgumentsOwner(IArgumentsOwner argumentsOwner);
    [CanBeNullAttribute]
[PureAttribute]
public abstract virtual IExpression GetNarrowestContainingArgumentExpression(IExpression expression);
    [NotNullAttribute]
public abstract virtual IFunctionInvocationClrWrapper SurroundWithStaticMethodInvocation(IFunction method, IExpression surroundedExpression, IPsiModule psiModule);
    [PureAttribute]
public abstract virtual bool IsArgumentOfMethodThatHasSimilarFormattingMethod(IExpression argumentExpression, IFunction& properFormattingMethod);
    [PureAttribute]
public abstract virtual bool IsArgumentOfFormattingFunction(IExpression argumentExpression, FormattingFunctionKind& formattingFunctionKind);
    [PureAttribute]
public abstract virtual bool ExpressionCanBeReplacedByMethodInvocation(IExpression expression);
}
public interface JetBrains.ReSharper.Psi.Util.IInsertionAnchorResult`1 {
    public TDeclaration Declaration { get; }
    public BeforeOrAfter Type { get; }
    public abstract virtual TDeclaration get_Declaration();
    public abstract virtual BeforeOrAfter get_Type();
}
public interface JetBrains.ReSharper.Psi.Util.ILanguageFeatures {
    [PureAttribute]
public abstract virtual bool AutoPropertiesAreSupported(ITreeNode context);
}
public interface JetBrains.ReSharper.Psi.Util.ILanguageReferenceSelector {
    public abstract virtual IConstructor GetBaseConstructor(IConstructor constructor);
    [CanBeNullAttribute]
public abstract virtual IDeclaredElement TryGetNavigatableCorrespondingElementForImplicitElement(IDeclaredElement declaredElement);
    [CanBeNullAttribute]
public abstract virtual IEnumerable`1<DeclaredElementInstance> GetCandidates(IReference reference, IDataContext dataContext, ReferencePreferenceKind preferenceKind);
    [CanBeNullAttribute]
public abstract virtual IEnumerable`1<DeclaredElementInstance> GetDeclaredElementsCandidates(DeclaredElementInstance instance, IDataContext dataContext, ReferencePreferenceKind preferenceKind);
}
public interface JetBrains.ReSharper.Psi.Util.IMemberInserter`1 {
    public IInsertionAnchorResult`1<TDeclaration> Anchor { get; }
    public abstract virtual TDeclaration InsertMethod();
    public abstract virtual bool TryFindDeclarationAnchor();
    public abstract virtual IInsertionAnchorResult`1<TDeclaration> get_Anchor();
}
public interface JetBrains.ReSharper.Psi.Util.INamespaceByNameTarget {
    public IFile TargetFile { get; }
    public string TargetNamespaceName { get; }
    public abstract virtual IFile get_TargetFile();
    public abstract virtual string get_TargetNamespaceName();
}
public interface JetBrains.ReSharper.Psi.Util.INamespaceTarget {
    public IFile TargetFile { get; }
    public INamespace TargetNamespace { get; }
    public abstract virtual IFile get_TargetFile();
    public abstract virtual INamespace get_TargetNamespace();
}
public interface JetBrains.ReSharper.Psi.Util.INodeTreeNavigator {
    public abstract virtual ITreeRange GetRange(ITreeNode node);
    public abstract virtual TreeNodeActionType GetAction(ITreeNode node);
    public abstract virtual bool IsSignificant(ITreeNode node);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.ReSharper.Psi.Util.Intern.InternatingBufferAdapter : object {
    [NotNullAttribute]
private IBuffer myTarget;
    [NotNullAttribute]
private ITokenIntern myIntern;
    private bool myThreshold;
    [NotNullAttribute]
public ITokenIntern Intern { get; }
    public int Length { get; }
    public char Item { get; }
    public InternatingBufferAdapter(IBuffer target, ITokenIntern intern);
    public InternatingBufferAdapter(IBuffer target, ITokenIntern intern, bool threshold);
    public ITokenIntern get_Intern();
    public sealed virtual int get_Length();
    public sealed virtual string GetText();
    public sealed virtual string GetText(TextRange range);
    public sealed virtual void AppendTextTo(StringBuilder builder, TextRange range);
    public sealed virtual char get_Item(int index);
    public sealed virtual void CopyTo(int sourceIndex, Char[] destinationArray, int destinationIndex, int length);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.InteropTypesUtil : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITypeElement GetOriginalTypeByEmbeddedInteropType(ITypeElement embeddedType, IPsiModule targetModule);
    [ExtensionAttribute]
[CanBeNullAttribute]
[PureAttribute]
public static ITypeElement GetOriginalTypeByEmbeddedInteropType(ITypeElement embeddedType);
    [ExtensionAttribute]
[PureAttribute]
public static bool ContainsEmbeddedInteropType(IType type);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsEmbeddedInteropType(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsImportedComType(IDeclaredElement declaredElement);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsImportedComTypeMember(ITypeMember typeMember);
}
public interface JetBrains.ReSharper.Psi.Util.INullLiteralProvider {
    [CanBeNullAttribute]
public abstract virtual IExpression CreateNullLiteral(IPsiModule psiModule);
}
public interface JetBrains.ReSharper.Psi.Util.IObjectArrayPool`1 {
    public abstract virtual T[] Alloc(UInt32 size);
    public abstract virtual T[] Alloc(UInt32 size, Lifetime lifetime);
}
public interface JetBrains.ReSharper.Psi.Util.IObjectPool`1 {
    public bool Unused { get; }
    public abstract virtual T Alloc();
    public abstract virtual T Alloc(Lifetime lifetime);
    public abstract virtual void Free(T t);
    public abstract virtual void DropToMinimalCapacity();
    public abstract virtual bool get_Unused();
}
public interface JetBrains.ReSharper.Psi.Util.IParameterDeclarationSearchDomainUtil {
    public abstract virtual bool SearchParameterUsagesInTypeDeclaration(IConstructor constructor);
}
public interface JetBrains.ReSharper.Psi.Util.IPolyadicBuilder`1 {
    [CanBeNullAttribute]
public abstract virtual TNode GetBinaryOperator(TNode binaryNode);
    [CanBeNullAttribute]
public abstract virtual TokenNodeType GetBinaryOperatorSign(TNode binaryNode);
    [NotNullAttribute]
public abstract virtual TNode GetContainingParenthesizedNode(TNode node);
    [CanBeNullAttribute]
public abstract virtual TNode GetContainingNode(TNode node);
    public abstract virtual bool AreOperatorsEquivalent(TNode binaryNode, TNode otherNode, bool skipSemanticCheck);
    public abstract virtual void GetBinaryOperands(TNode binaryNode, TNode& leftOperand, TNode& rightOperand, ITokenNode& sign);
    public abstract virtual void CollectOperands(TNode rootBinaryNode, TNode node, ICollection`1<TNode> operands, ICollection`1<ITokenNode> operatorSigns, bool skipSemanticCheck);
    [NotNullAttribute]
public abstract virtual TNode BuildChain(IList`1<TNode> operands, List`1<ITokenNode> signs, ITokenNodeType operatorSign, Polyadic`1<TNode> originalPolyadicForFormattingInference);
    public abstract virtual void SetCombinedFormatting(ITokenNode middleSignNode, Polyadic`1<TNode> left, Polyadic`1<TNode> right);
}
public interface JetBrains.ReSharper.Psi.Util.IRegionStructure {
    [NotNullAttribute]
public IEnumerable`1<ICodeRegion> TopLevelRegions { get; }
    public abstract virtual IEnumerable`1<ICodeRegion> get_TopLevelRegions();
    [NotNullAttribute]
public abstract virtual IEnumerable`1<ICodeRegion> GetParentRegions(ITreeNode node, bool excludeRegionsCommonWithParentNode);
    [NotNullAttribute]
public abstract virtual IEnumerable`1<ICodeRegion> GetParentRegions(ITreeRange treeRange);
}
public interface JetBrains.ReSharper.Psi.Util.IRegionStructureAcceptor {
    public abstract virtual void AcceptCodeRegionStart(ITreeNode node, ICodeRegionIdentity identity);
    public abstract virtual void AcceptCodeRegionEnd(ITreeNode node, ICodeRegionIdentity identity);
}
public interface JetBrains.ReSharper.Psi.Util.IRegionStructureProvider {
    public abstract virtual void ProcessNode(ITreeNode node, IRegionStructureAcceptor acceptor);
    public abstract virtual bool IsSpecialComment(IComment comment);
}
public interface JetBrains.ReSharper.Psi.Util.IRegionStructureProviderProvider {
    public abstract virtual IRegionStructureProvider ProvideRegionStructureProvider(PsiLanguageType languageType);
}
public interface JetBrains.ReSharper.Psi.Util.IStringConcatenationClrWrapper {
    [NotNullAttribute]
public IExpression Expression { get; }
    [NotNullAttribute]
[ItemNotNullAttribute]
public IList`1<IExpression> Arguments { get; }
    public abstract virtual IExpression get_Expression();
    public abstract virtual IList`1<IExpression> get_Arguments();
    public abstract virtual void SetArgumentAt(int index, IExpression argument);
    public abstract virtual void TryMergeArgumentWithNext(int index);
    public abstract virtual void ReplaceInAllLiterals(string oldValue, string newValue);
    [ItemNotNullAttribute]
[NotNullAttribute]
public abstract virtual IEnumerable`1<string> GetWidestConstantValues();
    public abstract virtual void RemoveAtValueRange(TextRange range);
    public abstract virtual void ReplaceAtValueRange(TextRange range, string newValue);
    public abstract virtual void InsertAtValueIndex(int index, string newValue);
    public abstract virtual IEnumerable`1<IExpression> GetConcatenationArgumentsThatContainValueRange(TextRange range);
    public abstract virtual IList`1<IExpression> GetConcatenationArgumentsThatContainValueRange(TextRange range, IList`1& localRanges, bool includeNonLiterals);
}
public interface JetBrains.ReSharper.Psi.Util.IStringConcatenationWrapperProvider {
    [CanBeNullAttribute]
public abstract virtual IStringConcatenationClrWrapper TryCreateWidestContaining(IExpression expression);
    [CanBeNullAttribute]
public abstract virtual IStringConcatenationClrWrapper TryCreate(IExpression expression);
}
public interface JetBrains.ReSharper.Psi.Util.IStringLiteralAlterer {
    [NotNullAttribute]
public ILiteralExpression Expression { get; }
    public TreeTextRange UnderQuotesRange { get; }
    [NotNullAttribute]
public string CompiledValue { get; }
    public abstract virtual ILiteralExpression get_Expression();
    public abstract virtual TreeTextRange get_UnderQuotesRange();
    public abstract virtual string get_CompiledValue();
    [PureAttribute]
public abstract virtual DocumentRange ValueTextRangeToPresentationDocumentRange(TextRange range);
    [PureAttribute]
public abstract virtual TreeTextRange ValueTextRangeToPresentationTreeTextRange(TextRange range);
    [PureAttribute]
public abstract virtual int PresentationDocumentOffsetToValueOffset(DocumentOffset documentOffset);
    [PureAttribute]
public abstract virtual int PresentationTreeOffsetToValueOffset(TreeOffset treeOffset);
    public abstract virtual void Insert(int valueOffset, string valueToInsert);
    public abstract virtual void Replace(string oldValue, string newValue);
    public abstract virtual void Remove(TextRange valueRange);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual IStringLiteralAlterer Substring(TextRange valueRange);
}
public interface JetBrains.ReSharper.Psi.Util.IStringLiteralAltererProvider {
    [CanBeNullAttribute]
public abstract virtual IStringLiteralAlterer TryCreateStringLiteralByExpression(IExpression expression);
    [NotNullAttribute]
public abstract virtual IStringLiteralAlterer CreateStringLiteralByCompiledValue(string value, ITreeNode context);
    [NotNullAttribute]
public abstract virtual IStringLiteralAlterer CreateStringLiteralByExpression(IExpression expression);
}
public interface JetBrains.ReSharper.Psi.Util.ITargetPostExecute {
    public abstract virtual void PostExecute(IDeclaredElement creationResult);
}
public interface JetBrains.ReSharper.Psi.Util.ITargetPreExecute {
    public abstract virtual void PreExecute();
}
public interface JetBrains.ReSharper.Psi.Util.ITargetSetPart {
    public IEnumerable`1<IDeclaration> AvailableTargets { get; }
    public abstract virtual IEnumerable`1<IDeclaration> get_AvailableTargets();
    public abstract virtual void SetPart(IDeclaration typePart);
}
public interface JetBrains.ReSharper.Psi.Util.ITokenIntern {
    [NotNullAttribute]
[PureAttribute]
public abstract virtual string Intern(string value);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual string InternWithoutThreshold(string value);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual string Intern(ILexer lexer);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual string Intern(IBuffer buffer, int startOffset, int endOffset);
    [NotNullAttribute]
[PureAttribute]
public abstract virtual string InternWithoutThreshold(IBuffer buffer, int startOffset, int endOffset);
}
public interface JetBrains.ReSharper.Psi.Util.ITopLevelScopeTarget {
    public abstract virtual IProject GetTargetProject();
}
public interface JetBrains.ReSharper.Psi.Util.ITreeRangeBuilder {
    [ContractAnnotationAttribute("null => false")]
public abstract virtual bool IsWhitespaceTokenOrSpecialToken(ITreeNode node);
    public abstract virtual bool SupportsLanguage(PsiLanguageType language);
}
public interface JetBrains.ReSharper.Psi.Util.ITypeDeclarationTarget {
    public ITypeDeclaration TargetTypeDeclaration { get; }
    public abstract virtual ITypeDeclaration get_TargetTypeDeclaration();
}
public interface JetBrains.ReSharper.Psi.Util.ITypeMemberDeclarationService {
    public abstract virtual IDeclaration FindDeclarationByOffset(DocumentRange documentRange, IFile file);
}
public interface JetBrains.ReSharper.Psi.Util.ITypeTarget {
    public ITypeElement TargetType { get; }
    public abstract virtual ITypeElement get_TargetType();
}
[NullableContextAttribute("1")]
public interface JetBrains.ReSharper.Psi.Util.ITypeUtilLanguageService {
    public abstract virtual bool CanUseExplicitly(IType type, ITreeNode context);
}
public interface JetBrains.ReSharper.Psi.Util.IUsingRegionsInspector {
    [CanBeNullAttribute]
public abstract virtual ITreeRange FindUsingListStartBorder();
    [CanBeNullAttribute]
public abstract virtual ITreeRange FindUsingListEndBorder();
    public abstract virtual Nullable`1<bool> IsContainingPreprocessorRegionRecommended(ITreeNode anchorImport);
    [NotNullAttribute]
public abstract virtual ICodeRegion FindStartAnchorRegion(ITreeNode anchorImport);
    [NotNullAttribute]
public abstract virtual ICodeRegion FindEndAnchorRegion(ITreeNode anchorImport);
}
public interface JetBrains.ReSharper.Psi.Util.IXmlDocBaseElementsProvider {
    [NotNullAttribute]
public abstract virtual IReadOnlyCollection`1<IDeclaredElement> GetBaseElements(IDeclaredElement element);
}
public interface JetBrains.ReSharper.Psi.Util.IXmlDocVisitor {
    public abstract virtual void VisitUnknownTag(XmlElement element);
    public abstract virtual void VisitC(XmlElement element);
    public abstract virtual void VisitCode(XmlElement element);
    public abstract virtual void VisitExample(XmlElement element);
    public abstract virtual void VisitException(XmlElement element);
    public abstract virtual void VisitInclude(XmlElement element);
    public abstract virtual void VisitList(XmlElement element);
    public abstract virtual void VisitMember(XmlElement element);
    public abstract virtual void VisitPara(XmlElement element);
    public abstract virtual void VisitParam(XmlElement element);
    public abstract virtual void VisitParamRef(XmlElement element);
    public abstract virtual void VisitPermission(XmlElement element);
    public abstract virtual void VisitRemarks(XmlElement element);
    public abstract virtual void VisitReturns(XmlElement element);
    public abstract virtual void VisitSee(XmlElement element);
    public abstract virtual void VisitSeeAlso(XmlElement element);
    public abstract virtual void VisitCommonSee(XmlElement element);
    public abstract virtual void VisitSummary(XmlElement element);
    public abstract virtual void VisitTypeParam(XmlElement element);
    public abstract virtual void VisitTypeParamRef(XmlElement element);
    public abstract virtual void VisitValue(XmlElement element);
    public abstract virtual void VisitCRefAttribute(XmlAttribute attribute);
}
public interface JetBrains.ReSharper.Psi.Util.IXmlVisitor {
    public abstract virtual void Visit(XmlNode node);
    public abstract virtual void VisitNode(XmlNode node);
    public abstract virtual void VisitElement(XmlElement element);
    public abstract virtual void VisitAttribute(XmlAttribute attribute);
    public abstract virtual void VisitText(XmlText text);
    public abstract virtual void VisitCData(XmlCDataSection cdataSection);
    public abstract virtual void VisitEntityReference(XmlEntityReference entityReference);
    public abstract virtual void VisitEntity(XmlEntity entity);
    public abstract virtual void VisitProcessingInstruction(XmlProcessingInstruction processingInstruction);
    public abstract virtual void VisitComment(XmlComment comment);
    public abstract virtual void VisitDocument(XmlDocument document);
    public abstract virtual void VisitDocumentType(XmlDocumentType documentType);
    public abstract virtual void VisitDocumentFragment(XmlDocumentFragment documentFragment);
    public abstract virtual void VisitNotation(XmlNotation notation);
    public abstract virtual void VisitWhitespace(XmlWhitespace whitespace);
    public abstract virtual void VisitSignificantWhitespace(XmlSignificantWhitespace significantWhitespace);
    public abstract virtual void VisitEndElement(XmlElement endElement);
    public abstract virtual void VisitEndEntity(XmlEntity endEntity);
    public abstract virtual void VisitXmlDeclaration(XmlDeclaration xmlDeclaration);
}
public static class JetBrains.ReSharper.Psi.Util.LateBoundReferenceUtil : object {
    public static Refers RefersToDeclaredElement(ILateBoundReference reference, IDeclaredElement declaredElement, Predicate`1<IDeclaredElement> canReferTo);
}
public abstract class JetBrains.ReSharper.Psi.Util.ListCache`1 : object {
    private static int CheckPeriod;
    private int myProcessorCount;
    private List`1<ListCacheItem<T>> myLists;
    private int myHasItemToDrop;
    private bool myCachesActivelyUsed;
    protected ListCache`1(Lifetime lifetime, IThreading threading);
    private void FlushCaches();
    protected abstract virtual int GetMaxCount();
    [ThreadSafeAttribute]
public List`1<T> GetOrCreateList(Lifetime lifetime);
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_0(object _);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.MiscUtil : object {
    [NotNullAttribute]
public static ISearchDomain GetParameterLocalSearchDomain(IParameter parameter);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsOverridesObjectGetHashCode(IMethod method);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsOverridesObjectFinalize(IMethod method);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsOverridesObjectToString(IMethod method);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsOverridesObjectEquals(IMethod method);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsOverridesObjectMemberwiseClone(IMethod method);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsObjectReferenceEqualsMethod(IMethod method);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsObjectEqualsMethod(IMethod method);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsInterlockedCompareExchangeMethod(IMethod method);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("method:null => false")]
public static bool IsIEqualityComparerEqualsMethod(IMethod method, bool searchQuasi);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("method:null => false")]
public static bool IsImplementsIEquatableEqualsMethod(IMethod method, bool searchQuasi);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsObjectOrValueTypeGetHashCodeMethod(IMethod method);
    [PureAttribute]
private static bool IsObjectMethodOverride(IMethod method, string name);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsEnumerableGetEnumeratorMethod(IMethod method);
    [PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsIDisposableDisposeMethod(IMethod method);
    public static bool MatchesBySignature(ITypeMember newElement, ITypeMember existingElement);
    [CanBeNullAttribute]
public static ITreeNode FindNodeAtOffset(IPsiSourceFile psiSourceFile, int offset);
    [CanBeNullAttribute]
public static T FindNodeAtOffset(IPsiSourceFile psiSourceFile, int offset);
    [CanBeNullAttribute]
public static T FindNodeAtOffset(IFile sourceFile, IDocument doc, int offset);
    [CanBeNullAttribute]
public static ITreeNode FindNodeAtOffset(IFile sourceFile, IDocument doc, int offset);
    [PureAttribute]
public static int FindLastNonOptionalParameterPlacement(IParametersOwner constructor);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static ILexerFactory GetLexerFactory(ITreeNode node, PsiLanguageType languageType);
    [ExtensionAttribute]
[PureAttribute]
public static LineEnding GetLineEnding(IPsiConfiguration psiConfiguration, IPsiSourceFile sourceFile, IDocument document, bool prohibitAutodection, IContextBoundSettingsStore store);
    [ExtensionAttribute]
[PureAttribute]
public static LineEnding GetLineEnding(IDocument document, bool prohibitAutodection, IContextBoundSettingsStore store);
    [ExtensionAttribute]
[PureAttribute]
public static LineEnding DetectLineEnding(IPsiSourceFile psiSourceFile, bool prohibitAutodection, IContextBoundSettingsStore store);
    [PureAttribute]
public static LineEnding DetectLineEnding(IPsiServices psiServices, IPsiSourceFile psiSourceFile, bool prohibitAutodection, IContextBoundSettingsStore store);
    [ExtensionAttribute]
[PureAttribute]
public static bool GetBaseTypeOfSynthetic(IExpressionType type, IType& baseType);
    [CanBeNullAttribute]
[PureAttribute]
[ObsoleteAttribute("Use FindContainingStatementEnsurableNode instead")]
public static ITreeNode GetScope(ITreeNode element);
    [NotNullAttribute]
[PureAttribute]
public static TTreeNode[] FindOccurrences(TTreeNode expression, ITreeNode scope);
    public static bool AreExpressionsEquivalent(IExpression ex1, IExpression ex2);
    public static bool AreNodesEquivalent(ITreeNode node1, ITreeNode node2);
    public static bool AreNodesEquivalentBySyntax(ITreeNode node1, ITreeNode node2);
    private static bool AreNodesEquivalentBySemantic(ITreeNode node1, ITreeNode node2);
}
public static class JetBrains.ReSharper.Psi.Util.ModuleDeclaredElementUtil : object {
    public static ISymbolTable GetReferenceSymbolTable(IReference reference, bool useReferenceName, bool includeCurrentModule);
    public static ISymbolTable GetReferenceSymbolTableFromWholeSolution(IReference reference);
    [CanBeNullAttribute]
public static IModuleDeclaredElement CreateModuleElement(IPsiModule psiModule);
    [CanBeNullAttribute]
public static IModuleDeclaredElement CreateModuleElement(IModule module, TargetFrameworkId targetFrameworkId);
    [NotNullAttribute]
public static ResolveResultWithInfo CheckResolveResult(ResolveResultWithInfo resolveResult, AssemblyNameInfo name);
}
public interface JetBrains.ReSharper.Psi.Util.MoveComments.IMoveCommentHandler {
    public abstract virtual bool IsEndOfLineComment(IComment comment);
    public abstract virtual bool IsSyntheticComment(IComment comment);
}
public class JetBrains.ReSharper.Psi.Util.MoveComments.MoveCommentHandlerBase : object {
    public virtual bool IsEndOfLineComment(IComment comment);
    public virtual bool IsSyntheticComment(IComment comment);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.MoveComments.MoveCommentsUtil : object {
    public static ITreeSnapshot DoSnapshotTree(ITreeNode oldTreeRoot);
    private static void SnapshotOneRoot(ITreeNode oldTreeRoot, TreeSnapshot snapshot);
    public static TNode MoveComments(ITreeSnapshot commentsSnapshot, TNode newTreeRoot);
    [ExtensionAttribute]
public static object GetCommentMarkerFromOldNode(ITreeSnapshot commentsSnapshot, ITreeNode node);
    private static ValueTuple`2<ITokenNode, ITokenNode> GetTokenPair(ITreeNode node);
    [ExtensionAttribute]
public static void AssignCommentMarkerToNewNode(ITreeSnapshot commentsSnapshot, ITreeNode node, object marker, bool overwrite);
    public static TNode DoWithSaveComments(ITreeNode treeRoot, Func`1<TNode> action);
    public static void DoWithSaveComments(ITreeNode treeRoot, Action action);
    public static void DoWithSaveComments(ITreeNode treeRoot, Action`1<ITreeSnapshot> action);
    private static void CleanupPersistentUserData(ITreeNode root, TreeSnapshot snapshot);
    public static void DeleteCommentsInRange(ITreeNode from, ITreeNode to);
    public static void DeleteCommentsInsideAndAroundNode(ITreeNode node);
    public static void DeleteCommentsInsideAndBeforeNode(ITreeNode node);
    public static void DeleteCommentsInsideNode(ITreeNode node);
    private static void DeleteCommentsForNode(ITreeNode node, bool before, bool after);
    public static ITreeNode GetCommonParent(ITreeNode node, IEnumerable`1<ITreeNode> list);
    [CompilerGeneratedAttribute]
internal static ITreeRange <DeleteCommentsForNode>g__GetCommentsNear|19_0(ITreeNode anchor, bool backwards, <>c__DisplayClass19_0& );
}
public static class JetBrains.ReSharper.Psi.Util.MultiTargetingUtil : object {
    [MustUseReturnValueAttribute]
public static bool TrueInAllTargets(ITreeNode context, Func`2<IFile, bool> predicate);
    [MustUseReturnValueAttribute]
public static bool TrueInAllTargets(ITreeNode context, TData data, Func`3<IFile, TData, bool> predicate);
    [MustUseReturnValueAttribute]
[NotNullAttribute]
public static IReadOnlyCollection`1<TData> IntersectDataFromAllTargets(ITreeNode context, Func`2<IFile, IEnumerable`1<TData>> dataSelector);
    [MustUseReturnValueAttribute]
public static bool TruForAllTargets(IPsiSourceFile sourceFile, Func`2<IPsiSourceFile, bool> predicate);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Util.MultiTargetingUtil/<EnumerateFilesInOtherContexts>d__4")]
private static IEnumerable`1<IFile> EnumerateFilesInOtherContexts(IFile thisFile);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.NamespaceFolderUtil : object {
    private static string DEFAULT_NAMESPACE;
    private static NamespaceFolderUtil();
    [ExtensionAttribute]
public static string CalculateExpectedNamespace(IProjectItem projectItem, PsiLanguageType language, bool ignoreNamespaceFolderSettings);
    [ExtensionAttribute]
public static ExpectedNamespaceAndNamespaceChecker CalculateExpectedNamespaceAndNamespaceChecker(IProjectItem projectItem, PsiLanguageType language, bool ignoreNamespaceFolderSettings);
    public static string CalculateExpectedNamespaceSkippingFolder(IProjectItem projectItem, PsiLanguageType language, IProjectFolder folderToSkip, bool ignoreNamespaceFolderSettings);
    [CanBeNullAttribute]
private static string CalculateExpectedNamespaceByProject(IProject project, PsiLanguageType language);
    [CanBeNullAttribute]
private static string CalculateExpectedNamespaceImpl(IProjectItem item, PsiLanguageType language, IProjectFolder folderToSkip, bool ignoreNamespaceFolderSettings);
    [CanBeNullAttribute]
private static string TryMakeValidNamespaceName(string name, LanguageService languageService);
    [NotNullAttribute]
public static string MakeValidQualifiedName(string name, LanguageService languageService);
}
public class JetBrains.ReSharper.Psi.Util.NodeBoundCodeRegionIdentity : object {
    [CompilerGeneratedAttribute]
private ITreeNode <Node>k__BackingField;
    public ITreeNode Node { get; }
    public NodeBoundCodeRegionIdentity(ITreeNode node);
    [CompilerGeneratedAttribute]
public ITreeNode get_Node();
    public sealed virtual string Format(ITreeNode startNode, ITreeNode endNode);
    protected bool Equals(NodeBoundCodeRegionIdentity other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class JetBrains.ReSharper.Psi.Util.NullLiteralUtil : object {
    [CanBeNullAttribute]
public static IExpression CreateNullLiteral(IPsiModule psiModule, PsiLanguageType language);
}
[ThreadUnsafeAttribute]
public class JetBrains.ReSharper.Psi.Util.ObjectArrayPool`1 : object {
    private static int INITIAL_BUCKET_SIZE;
    private Stack`1[] myFreeStorage;
    private int myObjectsInUse;
    private object myLockObject;
    public bool Unused { get; }
    protected object LockObject { get; }
    public sealed virtual T[] Alloc(UInt32 size);
    public sealed virtual T[] Alloc(UInt32 size, Lifetime lifetime);
    public sealed virtual T[] Alloc();
    public sealed virtual T[] Alloc(Lifetime lifetime);
    public virtual void Free(T[] t);
    public sealed virtual void DropToMinimalCapacity();
    public sealed virtual bool get_Unused();
    protected object get_LockObject();
    private static int GetBitLength(UInt32 n);
}
public class JetBrains.ReSharper.Psi.Util.ObjectSubPool`1 : object {
    private IObjectPool`1<T> myPool;
    private List`1<T> myAllocated;
    public ObjectSubPool`1(IObjectPool`1<T> pool, int capacity);
    public T Alloc();
    public void FreeAll();
}
internal class JetBrains.ReSharper.Psi.Util.ObjectSubPoolsPool`1 : AbstractObjectPool`1<ObjectSubPool`1<T>> {
    private IObjectPool`1<T> myOwner;
    private int myCapacity;
    public ObjectSubPoolsPool`1(IObjectPool`1<T> owner, int capacity);
    protected virtual ObjectSubPool`1<T> CreateObject();
    protected virtual void ClearObject(ObjectSubPool`1<T> t);
    protected virtual void InitObject(ObjectSubPool`1<T> t);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Util.ObsoleteInfo : ValueType {
    [NullableAttribute("1")]
private ObsoleteAnnotationInfo myAnnotationInfo;
    public static ObsoleteInfo NotObsolete;
    [CompilerGeneratedAttribute]
private RichText <Message>k__BackingField;
    public RichText Message { get; }
    public ObsoleteAttributeKind Kind { get; }
    public bool IsError { get; }
    public string OriginalMessage { get; }
    public string DiagnosticId { get; }
    public string UrlFormat { get; }
    public bool IsAnyObsoleteLike { get; }
    public bool HasMessage { get; }
    [NullableContextAttribute("1")]
public ObsoleteInfo(ObsoleteAnnotationInfo annotationInfo, RichText message);
    private static ObsoleteInfo();
    [CompilerGeneratedAttribute]
public RichText get_Message();
    public ObsoleteAttributeKind get_Kind();
    public bool get_IsError();
    public string get_OriginalMessage();
    public string get_DiagnosticId();
    public string get_UrlFormat();
    public bool get_IsAnyObsoleteLike();
    public bool get_HasMessage();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.Util.ObsoleteUtil : object {
    private static DeclaredElementPresenterStyle ourObsoleteNamePresenterStyle;
    private static ObsoleteUtil();
    [PureAttribute]
public static ObsoleteInfo GetObsoleteInfo(IReference reference);
    public static ObsoleteInfo GetObsoleteInfo(IDeclaredElement declaredElement, ITreeNode referenceNode, bool isBaseReceiver);
    private static ValueTuple`2<ObsoleteAnnotationInfo, IDeclaredElement> GetObsoleteAnnotationInfo(IDeclaredElement declaredElement, bool isBaseReceiver, ObsoleteInfoProvider obsoleteInfoProvider);
    [NullableContextAttribute("2")]
private static IDeclaredElement GetLeastOverridenSymbol(IDeclaredElement declaredElement);
    [PureAttribute]
private static bool IsObsoletedKindAllowed(ITreeNode treeNode, ObsoleteAttributeKind obsoleteKind);
    [NullableContextAttribute("2")]
[PureAttribute]
private static bool IsObsoleteOrExperimentalAllowedInContext(IDeclaredElement declaredElement, ObsoleteAttributeKind obsoleteKind);
    private static ObsoleteInfo CreateObsoleteInfo(ObsoleteAnnotationInfo obsoleteAnnotationInfo, PsiLanguageType language, IDeclaredElement element);
    [PureAttribute]
private static RichText GetDefaultObsoleteMessage(IDeclaredElement attributesOwner, PsiLanguageType language);
    [PureAttribute]
public static bool IsObsoleteEntity(IDeclaredElement declaredElement);
    [PureAttribute]
public static bool IsObsoleteEntity(IDeclaredElement declaredElement, RichTextBlock& description);
    [PureAttribute]
public static bool IsObsoleteOrExperimentalEntity(IDeclaredElement declaredElement);
    [PureAttribute]
public static ObsoleteAttributeKind GetObsoleteAttributeKind(IDeclaredElement declaredElement);
    [PureAttribute]
public static bool IsRequiredMemberObsoleteInNonObsoleteContext(ITypeMember requiredMember);
    [CompilerGeneratedAttribute]
internal static ObsoleteAnnotationInfo <GetObsoleteAnnotationInfo>g__GetObsoleteInfoForDeclaredElement|2_0(IDeclaredElement declaredElement, ObsoleteInfoProvider obsoleteInfoProvider);
    [CompilerGeneratedAttribute]
internal static Nullable`1<ObsoleteAttributeKind> <IsObsoleteOrExperimentalAllowedInContext>g__GetDeclaredElementObsoleteKind|5_0(<>c__DisplayClass5_0& );
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Util.OverloadInfo : ValueType {
    private IParameter myOriginalParameter;
    private IParameter myOverloadParameter;
    private IFunction myOriginalFunction;
    private IFunction myOverloadFunction;
    public static OverloadInfo Empty;
    public bool IsEmpty { get; }
    public IParameter OriginalParameter { get; }
    public IParameter OverloadParameter { get; }
    public IFunction OriginalFunction { get; }
    public IFunction OverloadFunction { get; }
    public bool IsOptionalParameterFound { get; }
    public OverloadInfo(IParameter parameter, IFunction function);
    public OverloadInfo(IParameter originalParameter, IParameter overloadParameter, IFunction originalFunction, IFunction overloadFunction);
    private static OverloadInfo();
    public bool get_IsEmpty();
    public IParameter get_OriginalParameter();
    public IParameter get_OverloadParameter();
    public IFunction get_OriginalFunction();
    public IFunction get_OverloadFunction();
    public bool get_IsOptionalParameterFound();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.OverloadsUtil : object {
    [ExtensionAttribute]
[PureAttribute]
public static OverloadInfo FindOverloadWithReturnType(IFunction currentFunction, string overloadName, Predicate`1<IType> returnTypePredicate);
    [ExtensionAttribute]
[PureAttribute]
public static OverloadInfo FindOverloadWithParameter(IFunction currentFunction, Predicate`1<IParameter> parameterPredicate);
    [ExtensionAttribute]
[PureAttribute]
public static OverloadInfo FindOverloadWithParameterAndReturnType(IFunction currentFunction, string overloadName, Predicate`1<IParameter> parameterPredicate, Predicate`1<IType> returnTypePredicate);
    [ExtensionAttribute]
[PureAttribute]
public static OverloadInfo FindOverloadWithoutParameter(IFunction currentFunction, Predicate`1<IParameter> parameterPredicate);
}
public class JetBrains.ReSharper.Psi.Util.OverridesUtil : object {
    public static IDictionary`2<IReference, IReference> CompareMaps(IDictionary`2<ReferenceAnchor, IReference> initial, IDictionary`2<ReferenceAnchor, IReference> target, IReferencesComparer referencesComparer);
    private static void PerformChecks(ReferenceAnchor anchor, IReferencesComparer referencesComparer, bool inInitial);
}
public class JetBrains.ReSharper.Psi.Util.PathReferenceContext : object {
    [NotNullAttribute]
private IPsiServices myPsiServices;
    [NotNullAttribute]
private VirtualFileSystemPath myBasePath;
    [NotNullAttribute]
private VirtualFileSystemPath myRootPath;
    [NotNullAttribute]
private VirtualFileSystemPath myLevelUp;
    [NotNullAttribute]
private VirtualFileSystemPath myBeforeMapping;
    [NotNullAttribute]
public IPsiServices PsiServices { get; }
    [NotNullAttribute]
public VirtualFileSystemPath BasePath { get; }
    [NotNullAttribute]
public VirtualFileSystemPath RootPath { get; }
    [NotNullAttribute]
public VirtualFileSystemPath LevelUpPath { get; }
    [NotNullAttribute]
public VirtualFileSystemPath BasePathBeforeMapping { get; }
    public PathReferenceContext(IPsiServices psiServices, VirtualFileSystemPath basePath, VirtualFileSystemPath rootPath, VirtualFileSystemPath levelUpPath, VirtualFileSystemPath basePathBeforeMapping);
    public IPsiServices get_PsiServices();
    public VirtualFileSystemPath get_BasePath();
    public VirtualFileSystemPath get_RootPath();
    public VirtualFileSystemPath get_LevelUpPath();
    public VirtualFileSystemPath get_BasePathBeforeMapping();
}
public static class JetBrains.ReSharper.Psi.Util.PathReferenceUtil : object {
    public static Uri DefaultUri;
    public static int MAX_PATH_LENGTH;
    [NotNullAttribute]
public static ISymbolFilter DistinctLogicPath;
    private static string _uric;
    private static string _uricDirectSlash;
    private static string _fragment;
    private static string _query;
    private static string _pchar;
    private static string _param;
    private static string _segment;
    private static string _pathSegments;
    private static string _ipv4Address;
    private static string _topLabel;
    private static string _domainLabel;
    private static string _hostName;
    private static string _host;
    private static string _hostPort;
    private static string _userInfo;
    private static string _server;
    private static string _regName;
    private static string _authority;
    private static string _scheme;
    private static string _absPath;
    private static string _netPath;
    private static string _uricNoSlash;
    private static string _opaquePart;
    private static string _hierPart;
    private static string _absoluteURI;
    private static string _wwwHostPort;
    private static string _wwwPath;
    private static string _wwwRelativeURI;
    private static string _uriReference;
    public static Regex UrlRegex;
    private static string _limitedAbsoluteURI;
    private static string _limitedUriReference;
    public static Regex LimitedUrlRegex;
    public static Regex AbsoluteUrlRegex;
    private static Regex UriPlaceholderMacther;
    private static PathReferenceUtil();
    [NotNullAttribute]
public static ISymbolTable GetSymbolTableByPath(PathReferenceContext referenceContext, bool addCurrentDir, bool recursive, Func`2<VirtualFileSystemPath, string> namer, Func`3<IProjectItem, VirtualFileSystemPath, bool> preFilter, ISymbolTableDependencySet symbolTableDependencySet, string defaultExtension);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Util.PathReferenceUtil/<GetFiles>d__1")]
private static IEnumerable`1<PathDeclaredElement> GetFiles(VirtualFileSystemPath basePath, bool recursive, Func`3<IProjectItem, VirtualFileSystemPath, bool> preFilter, ISolution solution, IPsiServices psiServices);
    public static bool CheckPathChars(string name);
    public static ReferenceCollection CreatePathReferences(TOwner owner, TToken token, IQualifier baseQualifier, Func`5<TOwner, IQualifier, TToken, TreeTextRange, IPathReference> createFolderReferenceDelegate, Func`5<TOwner, IQualifier, TToken, TreeTextRange, IPathReference> createFileReferenceDelegate, Func`2<TToken, string> getStringValueDelegate, Func`2<TToken, int> getValueStartOffset);
    public static string DetectUrls(string input, Func`2<string, string> postProcessor, MatchEvaluator matchEvaluator);
    [NotNullAttribute]
public static RichText DetectUrls(RichText input, Func`2<string, string> postProcessor, MatchEvaluator matchEvaluator);
    public static string GetLinkFromUrlMatch(Match match);
    [NotNullAttribute]
public static ISymbolTable GetReferenceSymbolTable(PathReferenceContext referenceContext, IPathReference pathReference, bool useReferenceName, bool addCurrentDir, string defaultExtension, Func`3<IProjectItem, VirtualFileSystemPath, bool> preFilter);
    [NotNullAttribute]
private static ISymbolTable GetSharedProjectsSymbolTable(IProject project, PathReferenceContext referenceContext, string referenceName);
    [NotNullAttribute]
private static ISymbolTable GetSharedProjectSymbolTable(PathReferenceContext referenceContext, IProjectFolder sharedBaseFolder, string referenceName);
    [ContractAnnotationAttribute("null => false")]
public static bool IsSharedProjectFolder(IProjectItem projectItem);
    private static bool IsSharedProjectFolderName(string name);
    [CanBeNullAttribute]
private static SymbolTableDependencySet CreateDependencySet(IProjectFolder folder);
    [NotNullAttribute]
private static ISymbolTable GetSymbolTableByName(PathReferenceContext referenceContext, string referenceName, IProjectFolder baseProjectFolder, string defaultExtension);
    [NotNullAttribute]
private static VirtualFileSystemPath CalculateLevelUpPath(PathReferenceContext referenceContext, IProjectFolder baseFolder);
    [CanBeNullAttribute]
private static IProjectFolder GetBaseProjectFolder(PathReferenceContext referenceContext, IProject project);
    private static int FolderWeight(IProjectFolder folder);
    [NotNullAttribute]
public static ResolveResultWithInfo FixResolveResultByPathMapping(IPathReference pathReference, ResolveResultWithInfo resolveResult);
    [NotNullAttribute]
public static ResolveResultWithInfo FixResolveResultByVirtualPaths(IPathReference pathReference, ResolveResultWithInfo resolveResult);
    [NotNullAttribute]
public static ISymbolTable GetImportCompletionSymbolTable(IPathReference reference);
    [NotNullAttribute]
public static ISymbolTable GetImportCompletionSymbolTable(PathReferenceContext referenceContext, Func`2<PathReferenceContext, ImportFilesCollector> collectorFactory);
}
public class JetBrains.ReSharper.Psi.Util.Polyadic`1 : object {
    [CompilerGeneratedAttribute]
private TreeNodeCollection`1<TNode> <Operands>k__BackingField;
    [CompilerGeneratedAttribute]
private TreeNodeCollection`1<ITokenNode> <OperatorSigns>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenNodeType <OperatorSign>k__BackingField;
    [CompilerGeneratedAttribute]
private TNode <ContainingNode>k__BackingField;
    [NotNullAttribute]
public static Key ParenthesesRemovalKey;
    [ItemCanBeNullAttribute]
public TreeNodeCollection`1<TNode> Operands { get; }
    public TreeNodeCollection`1<ITokenNode> OperatorSigns { get; }
    [NotNullAttribute]
public TokenNodeType OperatorSign { get; }
    [CanBeNullAttribute]
public TNode ContainingNode { get; }
    public bool HasBrokenOperands { get; }
    private Polyadic`1(TNode[] operands, ITokenNode[] operatorSigns, TokenNodeType operatorSign, TNode containingNode);
    private static Polyadic`1();
    [CompilerGeneratedAttribute]
public TreeNodeCollection`1<TNode> get_Operands();
    [CompilerGeneratedAttribute]
public TreeNodeCollection`1<ITokenNode> get_OperatorSigns();
    [CompilerGeneratedAttribute]
public TokenNodeType get_OperatorSign();
    [CompilerGeneratedAttribute]
public TNode get_ContainingNode();
    public bool IsValid();
    public bool get_HasBrokenOperands();
    [PureAttribute]
public int IndexOfOperatorSignAt(TreeOffset treeOffset);
    [PureAttribute]
public int IndexOfOperatorSignAt(TreeTextRange textRange);
    [PureAttribute]
public int IndexOfOperandAt(TreeOffset treeOffset);
    [PureAttribute]
public Nullable`1<ValueTuple`3<TNode, ValueTuple`2<ITokenNode, int>, TNode>> FindPairByRange(TreeTextRange textRange);
    [CanBeNullAttribute]
[PureAttribute]
public Polyadic`1<TNode> GetRange(int startIndex, int count);
    [NotNullAttribute]
[PureAttribute]
public Polyadic`1<TNode> Remove(int operandToRemoveIndex);
    [PureAttribute]
public Pair`2<Polyadic`1<TNode>, Polyadic`1<TNode>> SplitBy(int signIndex);
    [NotNullAttribute]
[PureAttribute]
public TNode Create();
    [NotNullAttribute]
[PureAttribute]
public TNode Create(Polyadic`1<TNode> originalPolyadicForFormattingInference);
    public virtual string ToString();
    [NotNullAttribute]
private List`1<TNode> GetNormalizedOperands(IPolyadicBuilder`1<TNode> provider, List`1& signs);
    [NotNullAttribute]
[PureAttribute]
private IPolyadicBuilder`1<TNode> GetPolyadicBuilder();
    [CanBeNullAttribute]
[ContractAnnotationAttribute("node: null => null")]
[PureAttribute]
public static Polyadic`1<TNode> Build(TNode node, TokenNodeType signToken, PolyadicBuildMode mode, bool skipSemanticCheck);
    [NotNullAttribute]
[PureAttribute]
public static Polyadic`1<TNode> BuildEvenFromSingleOperand(TNode operand, TokenNodeType signToken, PolyadicBuildMode mode, bool skipSemanticCheck);
    [NotNullAttribute]
[PureAttribute]
public static Polyadic`1<TNode> FromOperands(TokenNodeType operatorSign, TNode[] operands);
    [ContractAnnotationAttribute("left:null, right:null => null; => notnull")]
[PureAttribute]
public static Polyadic`1<TNode> Combine(Polyadic`1<TNode> left, Polyadic`1<TNode> right);
    [NotNullAttribute]
[PureAttribute]
public Polyadic`1<TNode> ReplaceRange(Polyadic`1<TNode> newPolyadic, TreeTextRange rangeToReplace);
    [NotNullAttribute]
[PureAttribute]
public Polyadic`1<TNode> InsertBefore(Polyadic`1<TNode> newPolyadic, int index);
    [NotNullAttribute]
[PureAttribute]
public Polyadic`1<TNode> ReplaceOperandAt(int index, TNode operand);
}
public enum JetBrains.ReSharper.Psi.Util.PolyadicBuildMode : Enum {
    public int value__;
    public static PolyadicBuildMode FromAny;
    public static PolyadicBuildMode FromAnyStopOnParentheses;
    public static PolyadicBuildMode FromBottom;
}
public static class JetBrains.ReSharper.Psi.Util.PreviewFeaturesUtil : object {
    [PureAttribute]
public static Nullable`1<PreviewFeatureInfo> GetPreviewFeatureInfo(IDeclaredElement declaredElement, ITreeNode referenceNode);
    [PureAttribute]
private static PreviewFeatureInfo CreateInfo(IAttributeInstance attributeInstance);
    [PureAttribute]
private static bool IsRecursiveReference(ITreeNode treeNode, IDeclaredElement declaredElement);
    [PureAttribute]
private static bool HasContainingPreviewMemberDeclaration(ITreeNode treeNode);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.Util.ProjectFileCacheCleanup : object {
    public ProjectFileCacheCleanup(ISolutionLoadTasksScheduler scheduler, IPsiServices psiServices, ISolution solution, Lifetime lifetime, IShellLocks locks, bool isForbidden);
    private void StartBackgroundCleanup(Lifetime lifetime, IShellLocks locks, ISolution solution);
    private void CleanProcess(ISolution solution);
    private void CleanItem(IProjectItem item);
}
public class JetBrains.ReSharper.Psi.Util.ProjectModelElementPointersMap`1 : object {
    private ISolution mySolution;
    private ProjectModelElementPointerManager myPointerManager;
    private Dictionary`2<IProjectModelElementPointer, T> myItems;
    private IEqualityComparer`1<T> myValuesEqualityComparer;
    private object myCachedLockObject;
    private List`1<ValueTuple`2<IProjectModelElement, T>> myCachedAllProjectModelElements;
    private int myCachedTimestamp;
    [CompilerGeneratedAttribute]
private ISignal`1<IProjectFile> <FileAdded>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignal`1<IProjectFolder> <FolderAdded>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignal`1<IProjectFile> <FileRemoved>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignal`1<IProjectFolder> <FolderRemoved>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignal`1<IProjectFile> <FileValueModified>k__BackingField;
    [CompilerGeneratedAttribute]
private ISignal`1<IProjectFolder> <FolderValueModified>k__BackingField;
    [CompilerGeneratedAttribute]
private ISimpleSignal <Changed>k__BackingField;
    [NotNullAttribute]
public ISignal`1<IProjectFile> FileAdded { get; }
    [NotNullAttribute]
public ISignal`1<IProjectFolder> FolderAdded { get; }
    [NotNullAttribute]
public ISignal`1<IProjectFile> FileRemoved { get; }
    [NotNullAttribute]
public ISignal`1<IProjectFolder> FolderRemoved { get; }
    [NotNullAttribute]
public ISignal`1<IProjectFile> FileValueModified { get; }
    [NotNullAttribute]
public ISignal`1<IProjectFolder> FolderValueModified { get; }
    public bool IsEmpty { get; }
    public ISimpleSignal Changed { get; }
    public ProjectModelElementPointersMap`1(Lifetime lifetime, ISolution solution, ProjectModelElementPointerManager pointerManager, ILogger logger, string name, IEqualityComparer`1<T> valuesEqualityComparer);
    [CompilerGeneratedAttribute]
public ISignal`1<IProjectFile> get_FileAdded();
    [CompilerGeneratedAttribute]
public ISignal`1<IProjectFolder> get_FolderAdded();
    [CompilerGeneratedAttribute]
public ISignal`1<IProjectFile> get_FileRemoved();
    [CompilerGeneratedAttribute]
public ISignal`1<IProjectFolder> get_FolderRemoved();
    [CompilerGeneratedAttribute]
public ISignal`1<IProjectFile> get_FileValueModified();
    [CompilerGeneratedAttribute]
public ISignal`1<IProjectFolder> get_FolderValueModified();
    public bool get_IsEmpty();
    [CompilerGeneratedAttribute]
public ISimpleSignal get_Changed();
    public void Update(Dictionary`2<string, T> filesPersistentIdValuesMap);
    private void RemoveFile(string persistentId, bool raiseEvents);
    private void RemoveFile(IProjectModelElementPointer pointer, bool raiseEvents);
    private void AddFile(string persistentId, T value, bool raiseEvents);
    private void AddFile(IProjectModelElementPointer pointer, T value, bool raiseEvents);
    private void ModifyFileValue(string persistentId, T value, bool raiseEvents);
    private void ModifyFileValue(IProjectModelElementPointer pointer, T value, bool raiseEvents);
    public bool Contains(IProjectModelElement fileOrFolder);
    [ContractAnnotationAttribute("=> true, value: notnull; => false, value: null")]
public bool TryGetValue(IProjectModelElement fileOrFolder, T& value);
    [NotNullAttribute]
public IEnumerable`1<ValueTuple`2<IProjectModelElement, T>> GetAllValidProjectItems();
    private void ClearCachedAllProjectModelElements();
    [NotNullAttribute]
private IEnumerable`1<ValueTuple`2<IProjectModelElement, T>> EnsureAllProjectModelElements();
    private static DictionaryDiff`2<T, TKey, TValue> DictionaryDifference(Dictionary`2<TKey, TValue> oldDict, Dictionary`2<TKey, TValue> newDict, IEqualityComparer`1<TValue> valueComparer);
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_0(bool _);
    [CompilerGeneratedAttribute]
private ValueTuple`2<IProjectModelElement, T> <EnsureAllProjectModelElements>b__42_0(KeyValuePair`2<IProjectModelElementPointer, T> pair);
}
[PsiComponentAttribute("0")]
public class JetBrains.ReSharper.Psi.Util.ProperFormattingMethodFinder : object {
    [CompilerGeneratedAttribute]
private StringFormatAnnotationProvider <stringFormatAnnotationProvider>P;
    [NotNullAttribute]
private PredefinedData[] myPredefinedData;
    [NotNullAttribute]
private ISymbolCache mySymbolCache;
    public ProperFormattingMethodFinder(IPsiServices psiServices, StringFormatAnnotationProvider stringFormatAnnotationProvider);
    [NotNullAttribute]
public static ProperFormattingMethodFinder GetInstance(ISolution solution);
    [CanBeNullAttribute]
private static IMethod FindMappings(ISymbolScope symbolScope, ITypeElement methodType, IMethod method, PredefinedData data);
    [CanBeNullAttribute]
public IMethod GetFormattingMethod(IMethod usedMethod, ITreeNode context);
    private static Nullable`1<FormattingArgumentKind> GetFormattingArgumentKind(IParameter parameter);
    [CanBeNullAttribute]
public IMethod GetNonFormattingMethod(IMethod usedMethod, IReadOnlyList`1<IArgument> formatArguments, bool allowInterpolatedStringHandlerOnly);
    [CanBeNullAttribute]
private static IMethod FindNonFormattingMethod(ITypeElement type, bool isStatic, string suggestedMethodName, IType expectedReturnType, IParameter originalFormatParameter, IList`1<IParameter> expectedParameters, StringFormatAnnotationProvider stringFormatAnnotationProvider, bool allowInterpolatedStringHandlerOnly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.ReSharper.Psi.Util.PsiFileCachedDataUtil : object {
    private static Key`1<ConcurrentUserDataHolder> CACHED_DATA;
    private static PsiFileCachedDataUtil();
    [NullableContextAttribute("0")]
[PureAttribute]
public static TData GetPsiModuleData(ITreeNode element, Key`1<Boxed`1<TData>> dataKey, Func`2<IPsiModule, TData> dataFactory);
    [PureAttribute]
public static TData GetPsiModuleData(ITreeNode element, Key`1<TData> dataKey, Func`2<IPsiModule, TData> dataFactory);
    [NullableContextAttribute("0")]
[PureAttribute]
public static TData GetPsiFileData(TFile file, Key`1<Boxed`1<TData>> dataKey, Func`2<TFile, TData> dataFactory);
    [PureAttribute]
public static TData GetPsiFileData(TFile file, Key`1<TData> dataKey, TState state, Func`3<TFile, TState, TData> dataFactory);
    [PureAttribute]
public static TData GetPsiFileData(IFile file, Key`1<TData> dataKey, Func`2<IFile, TData> dataFactory);
    [PureAttribute]
public static TData GetPsiFileData(IFile file, Key`1<TData> dataKey);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Nullable`1<TData> GetPsiFileData(IFile file, Key`1<Boxed`1<TData>> dataKey);
    public static void Invalidate(ITreeNode element, Key`1<TData> dataKey);
    public static void InvalidateInAllProjectFiles(IProject project, PsiLanguageType language, Key`1<TData> dataKey);
    public static void InvalidateAllDataInAllProjectFiles(IProject project, PsiLanguageType language);
    public static void InvalidateAllData(ITreeNode element);
}
public enum JetBrains.ReSharper.Psi.Util.RangeDisposition : Enum {
    public int value__;
    public static RangeDisposition Preceding;
    public static RangeDisposition Following;
    public static RangeDisposition Enclosed;
    public static RangeDisposition Enclosing;
    public static RangeDisposition Overlapping;
    public static RangeDisposition Equal;
}
public static class JetBrains.ReSharper.Psi.Util.RealParser : object {
    private static BigInteger BigZero;
    private static BigInteger BigOne;
    private static BigInteger BigTwo;
    private static BigInteger BigTen;
    private static RealParser();
    public static double ParseDouble(string s);
    public static float ParseFloat(string s);
    public static decimal ParseDecimal(string s);
    private static Status ConvertDecimalToFloatingPointBits(DecimalFloatingPointString data, FloatingPointType type, UInt64& result);
    private static Status ConvertBigIntegerToFloatingPointBits(Byte[] integerValueAsBytes, UInt32 integerBitsOfPrecision, bool hasNonzeroFractionalPart, FloatingPointType type, UInt64& result);
    private static BigInteger AccumulateDecimalDigitsIntoBigInteger(DecimalFloatingPointString data, UInt32 integerFirstIndex, UInt32 integerLastIndex);
    private static UInt32 CountSignificantBits(ulong data);
    private static UInt32 CountSignificantBits(byte data);
    private static UInt32 CountSignificantBits(BigInteger data, Byte[]& dataBytes);
    private static UInt32 CountSignificantBits(BigInteger data);
    private static ulong RightShiftWithRounding(ulong value, int shift, bool hasZeroTail);
    private static bool ShouldRoundUp(bool lsbBit, bool roundBit, bool hasTailBits);
    private static void ShiftLeft(BigInteger& number, UInt32 shift);
    private static void MultiplyByPowerOfTen(BigInteger& number, UInt32 power);
    private static UInt32 FloatToInt32Bits(float f);
    private static float Int32BitsToFloat(UInt32 i);
}
public enum JetBrains.ReSharper.Psi.Util.ReferencePreferenceKind : Enum {
    public int value__;
    public static ReferencePreferenceKind Default;
    public static ReferencePreferenceKind ToDeclaration;
    public static ReferencePreferenceKind ToUsage;
    public static ReferencePreferenceKind ToBase;
    public static ReferencePreferenceKind ToInheritors;
    public static ReferencePreferenceKind ToType;
}
internal class JetBrains.ReSharper.Psi.Util.RegionStructure : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<ICodeRegion> <TopLevelRegions>k__BackingField;
    public IEnumerable`1<ICodeRegion> TopLevelRegions { get; }
    public RegionStructure(IEnumerable`1<ICodeRegion> topLevelRegions);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<ICodeRegion> get_TopLevelRegions();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Util.RegionStructure/<GetParentRegions>d__4")]
public sealed virtual IEnumerable`1<ICodeRegion> GetParentRegions(ITreeNode node, bool excludeRegionsCommonWithParentNode);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Util.RegionStructure/<GetParentRegions>d__5")]
public sealed virtual IEnumerable`1<ICodeRegion> GetParentRegions(ITreeRange range);
}
internal class JetBrains.ReSharper.Psi.Util.RegionStructureAcceptor : object {
    private IWhitespaceChecker myWsChecker;
    private Predicate`1<ITreeNode> mySignificantNodeMatcher;
    private List`1<CodeRegion> myRegions;
    private Dictionary`2<ICodeRegionIdentity, Stack`1<CodeRegion>> myOpenRegions;
    public RegionStructureAcceptor(Predicate`1<ITreeNode> significantNodeMatcher, IWhitespaceChecker wsChecker);
    public sealed virtual void AcceptCodeRegionStart(ITreeNode node, ICodeRegionIdentity identity);
    public sealed virtual void AcceptCodeRegionEnd(ITreeNode node, ICodeRegionIdentity identity);
    public IEnumerable`1<ICodeRegion> GetTopLevelRegions(ITreeRangeBuilder rangeBuilder, IRegionStructureProvider provider);
    public IEnumerable`1<ICodeRegion> GetTopLevelRegionsFixed(ITreeRangeBuilder rangeBuilder, IRegionStructureProvider provider);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.RegionStructureAcceptorExtensions : object {
    [ExtensionAttribute]
public static bool TryCreateNodeBoundRegion(IRegionStructureAcceptor acceptor, ITreeNode node);
}
[PsiSharedComponentAttribute]
public class JetBrains.ReSharper.Psi.Util.RegionStructureBuilder : object {
    private ILanguageManager myLanguageManager;
    public RegionStructureBuilder(ILanguageManager languageManager);
    public bool IsSupported(ITreeNode node);
    public IRegionStructure BuildRegionStructure(ITreeNode node, INodeTreeNavigator treeNodeNavigator);
    public IRegionStructure BuildRegionStructureFixed(ITreeNode node, INodeTreeNavigator treeNodeNavigator);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.RegionStructureBuilderExtensions : object {
    [ExtensionAttribute]
[CanBeNullAttribute]
public static IRegionStructureProvider GetRegionStructureProvider(ITreeNode node, ILanguageManager languageManager);
}
public class JetBrains.ReSharper.Psi.Util.ResharperControlConstructCodeRegionIdentity : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public string Id { get; }
    public ResharperControlConstructCodeRegionIdentity(string id);
    [CompilerGeneratedAttribute]
public string get_Id();
    public sealed virtual string Format(ITreeNode startNode, ITreeNode endNode);
    public bool Equals(ResharperControlConstructCodeRegionIdentity other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Psi.Util.ResharperFormatterCodeRegionIdentity : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public string Id { get; }
    public ResharperFormatterCodeRegionIdentity(string id);
    [CompilerGeneratedAttribute]
public string get_Id();
    public sealed virtual string Format(ITreeNode startNode, ITreeNode endNode);
    public bool Equals(ResharperFormatterCodeRegionIdentity other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.ResolveHelper : object {
    [ExtensionAttribute]
public static IResolveInfo CheckResolveInfo(IResolveInfo result, ResolveErrorType notResolved);
}
public abstract class JetBrains.ReSharper.Psi.Util.StatementVisibleForAllCalculator`1 : object {
    [PureAttribute]
protected abstract virtual TStatement AsStatement(ITreeNode treeNode, ITreeNode contextTreeNode);
    [CanBeNullAttribute]
[PureAttribute]
public TStatement Calculate(IReadOnlyCollection`1<ITreeNode> elements);
    [MustUseReturnValueAttribute]
private static PooledHashSet`1<ITreeNode> NormalizeToTheSameDepthNodes(IReadOnlyCollection`1<ITreeNode> elements);
    [PureAttribute]
protected abstract virtual bool IsStatementOwnerParent(ITreeNode singleParent, HashSet`1<ITreeNode> childNodes);
    [CanBeNullAttribute]
protected abstract virtual ITreeNode ChooseFirstStatementInStatementOwner(ITreeNode singleParent, HashSet`1<ITreeNode> childNodes);
    [CanBeNullAttribute]
private TStatement ChooseContainingStatement(ITreeNode commonParentNode);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.StringConcatenationClrWrapperExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static IList`1<IList`1<IExpression>> GetWidestSequencesOfConstantArguments(IStringConcatenationClrWrapper stringConcatenationWrapper);
}
public static class JetBrains.ReSharper.Psi.Util.StringConcatenationClrWrapperUtil : object {
    [CanBeNullAttribute]
public static IStringConcatenationClrWrapper TryCreateWidestContaining(IExpression expression);
    [CanBeNullAttribute]
public static IStringConcatenationClrWrapper TryCreate(IExpression expression);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.StringLiteralAltererUtil : object {
    [CanBeNullAttribute]
[PureAttribute]
public static IStringLiteralAlterer TryCreateStringLiteralByExpression(IExpression expression);
    [NotNullAttribute]
[PureAttribute]
public static IStringLiteralAlterer CreateStringLiteralByCompiledValue(string value, ITreeNode context);
    [NotNullAttribute]
[PureAttribute]
public static IStringLiteralAlterer CreateStringLiteralByExpression(IExpression expression);
    [NotNullAttribute]
public static IList`1<DocumentRange> GetDocumentRangesByTextRangeInSequence(IList`1<IExpression> expressions, TextRange range, bool includeNonLiteralRanges);
    [ExtensionAttribute]
[ContractAnnotationAttribute("=> true, substring:notnull;=> false, substring:null")]
public static bool TryGetValueSubstring(IStringLiteralAlterer stringLiteralAlterer, DocumentRange range, String& substring);
}
public static class JetBrains.ReSharper.Psi.Util.StringLiteralConverter : object {
    public static string UnescapeStringLiteral(string value);
    public static string UnescapeCharLiteral(string value);
    public static string UnescapeLiteral(string value, int start, int end);
    public static string UnescapeVerbatimLiteral(string value, int start, int end);
    public static CharSequence GetHexEscapeSequence(string value, int start);
    public static CharSequence GetUnicodeSmallEscapeSequence(string value, int start);
    public static CharSequence GetUnicodeLargeEscapeSequence(string value, int start);
    private static CharSequence GetEscapeSequence(string value, int start, int min, int max);
    public static string EscapeToRegular(string value);
    public static string EscapeToVerbatim(string value);
    public static string EscapeChar(char c);
}
public class JetBrains.ReSharper.Psi.Util.StringLiteralQuoteChecker : object {
    private static Dictionary`2<char, string> ourQuoteMnemonics;
    private static StringLiteralQuoteChecker();
    public static bool IsQuoteNormalized(string text, char expectedQuoteChar, bool formatQuotesIfQuoteInsideValue, bool deleteQuotesInSpaceFreeText);
    private static bool DoesLiteralContainsInsideExpectedChar(string text, char expectedQuoteChar);
    public static string GetNormalizedStringLineral(ITreeNode treeNode, char expectedQuoteChar, char unExpectedQuoteChar, bool formatQuotesIfQuoteInsideValue, bool deleteQuotesInSpaceFreeText);
    public static string GetNormalizedStringLineral(string originalText, char expectedQuoteChar, char unExpectedQuoteChar, bool formatQuotesIfQuoteInsideValue, bool deleteQuotesInSpaceFreeText);
}
internal class JetBrains.ReSharper.Psi.Util.SurvivableTreeRangePointer : object {
    [NotNullAttribute]
private PsiLanguageType myLanguageType;
    [NotNullAttribute]
private WeakReference`1<ITreeNode> myFirstElement;
    [NotNullAttribute]
private WeakReference`1<ITreeNode> myLastElement;
    [CanBeNullAttribute]
private IRangeMarker myRangeMarker;
    [CanBeNullAttribute]
private IRangeMarker myExternalRangeMarker;
    [CompilerGeneratedAttribute]
private IPsiSourceFile <SourceFile>k__BackingField;
    public IPsiSourceFile SourceFile { get; }
    public SurvivableTreeRangePointer(IPsiSourceFile sourceFile, PsiLanguageType language, ITreeRange treeRange, bool trackExternals);
    [CompilerGeneratedAttribute]
public IPsiSourceFile get_SourceFile();
    protected DocumentRange GetDocumentRange(ITreeRange treeRange, bool trackExternals);
    public sealed virtual ITreeRange GetTreeRange();
    public void FreeRangeMarkers();
}
[ThreadSafeAttribute]
public abstract class JetBrains.ReSharper.Psi.Util.ThreadSafeInternsObjectPool`1 : ThreadSafeObjectPool`1<T> {
    private BidirectionalMap`2<Thread, T> myThreadAndIntern;
    private CountingSet`1<T> myInternUsages;
    protected ThreadSafeInternsObjectPool`1(int capacity, int maximalCapacity);
    public virtual T Alloc();
    public virtual void Free(T t);
}
[ThreadSafeAttribute]
public abstract class JetBrains.ReSharper.Psi.Util.ThreadSafeObjectPool`1 : AbstractObjectPool`1<T> {
    private object myLockObject;
    public object LockObject { get; }
    protected ThreadSafeObjectPool`1(int capacity, int maximalCapacity);
    public virtual T Alloc(Lifetime lifetime);
    public virtual T Alloc();
    public virtual void Free(T t);
    public object get_LockObject();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.TokenUtil : object {
    private static Char[] Quotes;
    private static TokenUtil();
    [ExtensionAttribute]
[NotNullAttribute]
public static string GetUnquotedText(ITreeNode tokenNode, Char[] quoteChars);
    [ExtensionAttribute]
public static TreeTextRange GetUnquotedTreeTextRange(ITreeNode tokenNode, Char[] quoteChars);
    [ExtensionAttribute]
public static DocumentRange GetUnquotedDocumentRange(ITreeNode tokenNode, Char[] quoteChars);
    [ExtensionAttribute]
public static StringSlice GetUnquotedTextSlice(ITreeNode treeNode);
    [ExtensionAttribute]
public static StringSlice GetUnquotedTextSlice(ITreeNode treeNode, Char[] quoteChars);
    [ExtensionAttribute]
public static TreeTextRange GetUnquotedRangeWithin(ITreeNode tokenNode);
    [ExtensionAttribute]
public static TreeTextRange GetUnquotedRangeWithin(ITreeNode tokenNode, Char[] quoteChars);
    [ExtensionAttribute]
private static TextRange GetUnquotedTextRangeWithin(ITreeNode tokenNode, Char[] quoteChars);
}
public class JetBrains.ReSharper.Psi.Util.TreeRange : object {
    [NotNullAttribute]
public static TreeRange Empty;
    [CompilerGeneratedAttribute]
private ITreeNode <First>k__BackingField;
    [CompilerGeneratedAttribute]
private ITreeNode <Last>k__BackingField;
    public ITreeNode First { get; }
    public ITreeNode Last { get; }
    public bool IsEmpty { get; }
    public TreeRange(ITreeNode first, ITreeNode last);
    public TreeRange(ITreeNode node);
    private static TreeRange();
    [CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_First();
    [CompilerGeneratedAttribute]
public sealed virtual ITreeNode get_Last();
    public sealed virtual bool get_IsEmpty();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<ITreeNode> GetEnumerator();
    [ConditionalAttribute("JET_MODE_ASSERT")]
public void AssertConnectedness();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Util.TreeRange/<GetEnumerator>d__14")]
public static IEnumerator`1<ITreeNode> GetEnumerator(ITreeRange range);
    [NotNullAttribute]
[PureAttribute]
public static TreeRange Create(IList`1<TTreeNode> nodes);
    [NotNullAttribute]
[PureAttribute]
public static TreeRange Build(ITreeNode first, ITreeNode last);
    [NotNullAttribute]
[PureAttribute]
public static TreeRange Build(ITreeNode first, ITreeNode last, ITreeRangeBuilder builder);
    public static void NodeIterator(ITreeRange range, Func`2<ITreeNode, TreeNodeActionType> predicate);
    [NotNullAttribute]
public static TreeRange BuildByTextRange(ITreeRange nodes, TreeTextRange textRange);
    [NotNullAttribute]
protected static TreeRange BuildByTextRange(IEnumerable`1<ITreeNode> nodes, TreeTextRange textRange);
    private static IEnumerable`1<ITreeNode> GetPlainNodes(IEnumerable`1<ITreeNode> nodes);
    [NotNullAttribute]
[PureAttribute]
public static ITreeRange CreateFromElement(ITreeNode element);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.TreeRangeBuilderUtils : object {
    private static DefaultTreeRangeBuilder ourDefault;
    private static TreeRangeBuilderUtils();
    [ExtensionAttribute]
[PureAttribute]
public static ITreeRangeBuilder GetTreeRangeBuilder(ITreeNode node);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Psi.Util.TreeRangeChecker : ValueType {
    private List`1<TreeTextRange> myExactMatches;
    private DisjointedTreeTextRange myDisjointedTreeTextRange;
    public TreeRangeChecker(DisjointedTreeTextRange disjointedRanges);
    [PureAttribute]
public bool Contains(TreeTextRange treeTextRange);
    [MustUseReturnValueAttribute]
public TreeRangeChecker OrExactly(ITreeNode treeNode);
    [MustUseReturnValueAttribute]
public TreeRangeChecker OrExactlyBefore(ITreeNode treeNode);
    [MustUseReturnValueAttribute]
public TreeRangeChecker OrExactlyAfter(ITreeNode treeNode);
    [MustUseReturnValueAttribute]
public TreeRangeChecker OrExactlyFromTo(ITreeNode from, ITreeNode to);
}
internal class JetBrains.ReSharper.Psi.Util.TreeRangePointer : object {
    [NotNullAttribute]
private ITreeNodePointer`1<ITreeNode> myFirstPointer;
    [NotNullAttribute]
private ITreeNodePointer`1<ITreeNode> myLastPointer;
    public TreeRangePointer(ITreeRange treeRange);
    public sealed virtual ITreeRange GetTreeRange();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.TreeRangeUtil : object {
    [CanBeNullAttribute]
public static ITreeNode PrepareAnchorForAddingBefore(ITreeNode parent, ITreeRange range);
    private static void AddChildrenAndFormat(ITreeNode anchor, TreeRange range, Action`2<ITreeNode, ITreeNode[]> add);
    public static bool NeedModificationForAddingBefore(ITreeNode parent, ITreeRange range);
    [CanBeNullAttribute]
public static ITreeNode PrepareAnchorForAddingAfter(ITreeNode parent, ITreeRange range);
    public static bool NeedModificationForAddingAfter(ITreeNode parent, ITreeRange range);
    [ExtensionAttribute]
[PureAttribute]
public static bool Contains(ITreeRange treeRange, ITreeNode treeNode);
    [ExtensionAttribute]
public static bool IsValid(ITreeRange treeRange);
    [ExtensionAttribute]
[CanBeNullAttribute]
public static TTreeNode GetContainingNode(ITreeRange treeRange);
}
public class JetBrains.ReSharper.Psi.Util.TreeTextRangeTree`2 : JetBinaryTree`2<TreeTextRange`1<TKind>, TData> {
    protected TreeTextRangeTree`2(TreeTextRangeTree`2<TKind, TData> treeTextRangeTree);
    public JetBinaryTreeNode`2<TreeTextRange`1<TKind>, TData> GetNode(TreeTextRange`1<TKind> key);
    public FrugalLocalList`1<TData> FindRangeByOffset(TreeOffset offset, bool strict);
    public FrugalLocalList`1<TData> FindIntersectingRanges(TreeTextRange`1<TKind> rangeToCompare, bool strict);
    public FrugalLocalList`1<TData> FindCoveredRanges(TreeTextRange`1<TKind> rangeToCompare, bool strict);
    public FrugalLocalList`1<TData> FindCoveringRanges(TreeTextRange`1<TKind> rangeToCompare, bool strict);
    public sealed virtual TreeTextRangeTree`2<TKind, TData> Clone();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.TypeElementUtil : object {
    [ThreadStaticAttribute]
private static HashSet`1<ITypeElement> ourSuperTypeExploration;
    public static bool IsSuperTypeExplorationProcessContains(ITypeElement typeElement);
    public static bool IsSuperTypeExplorationProcessRunning();
    public static void AddTypeHierarchyDependency(ITypeElement typeElement);
    public static void RemoveTypeHierarchyDependency(ITypeElement typeElement);
    [CanBeNullAttribute]
public static ITypeElement GetTypeElementByClrName(IClrTypeName clrName, IPsiModule module);
    [CanBeNullAttribute]
public static ITypeElement GetTypeElementFromAssembly(IClrTypeName clrName, IPsiModule module, string assemblyName);
    [CanBeNullAttribute]
public static ITypeElement GetTypeElementFromModule(IClrTypeName clrName, IPsiModule module);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDeclaredType[] GetAllSuperTypes(IDeclaredType type, IPsiModule retargetToModule, IEqualityComparer`1<IType> comparer);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDeclaredType[] GetSuperTypesWithoutCircularDependent(IDeclaredType type, IPsiModule retargetToModule, IEqualityComparer`1<IType> comparer);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDeclaredType[] GetAllSuperTypes(ITypeElement typeElement, IPsiModule retargetToModule, IEqualityComparer`1<IType> comparer);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDeclaredType[] GetSuperTypesWithoutCircularDependent(ITypeElement typeElement, IPsiModule retargetToModule, IEqualityComparer`1<IType> comparer);
    [ExtensionAttribute]
[NotNullAttribute]
public static ITypeElement[] GetAllSuperTypeElements(ITypeElement typeElement, IPsiModule retargetToModule, IEqualityComparer`1<ITypeElement> comparer);
    private static void GetAllSuperTypeElements(ITypeElement typeElement, HashSet`1<ITypeElement> typeElements, Boolean& hasCircularDependency);
    [NotNullAttribute]
public static IDeclaredType[] GetAllSuperTypesReversed(ITypeElement typeElement);
    [NotNullAttribute]
private static IDeclaredType[] GetAllSuperTypes(ITypeElement typeElement, ISubstitution substitution, IPsiModule retargetToModule, bool allowCircularDependent, IEqualityComparer`1<IType> comparer);
    [NotNullAttribute]
private static IDeclaredType[] GetAllSuperTypesReversed(ITypeElement typeElement, ISubstitution substitution);
    private static void GetAllSuperTypes(IDeclaredType type, HashSet`1<IDeclaredType> superTypes, Boolean& hasCircularDependency);
    private static void GetAllSuperTypesReversed(IDeclaredType type, HashSet`1<IDeclaredType> superTypes, HashSet`1<ITypeElement> visited);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<IDeclaredType> GetAllSuperClasses(ITypeElement classElement);
    [ExtensionAttribute]
[NotNullAttribute]
public static IDeclaredType[] GetSuperClassesWithoutCircularDependent(IDeclaredType classType, IPsiModule retargetToModule);
    [ExtensionAttribute]
private static bool GetAllSuperClassesInternal(IDeclaredType classType, IDeclaredType[]& superClasses, IPsiModule retargetToModule);
    private static bool BuildSuperClassList(IDeclaredType declaredType, List`1<IDeclaredType> result);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<TypeMemberInstance> GetAllClassMembers(ITypeElement class, string name);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<TypeMemberInstance`1<TMember>> GetAllClassMembers(ITypeElement class, string name);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Util.TypeElementUtil/<GetTypeMembers>d__25")]
[ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
[PureAttribute]
public static IEnumerable`1<TypeMemberInstance`1<ITypeMember>> GetTypeMembers(ITypeElement type, Func`2<ITypeMember, bool> predicate);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Util.TypeElementUtil/<TypeMemberInstancesImpl>d__26`1")]
[NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<TypeMemberInstance`1<TMember>> TypeMemberInstancesImpl(ITypeElement class, string name);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<ITypeMember> EnumerateMembers(ITypeElement typeElement, string name, bool caseSensitive);
    [ExtensionAttribute]
[NotNullAttribute]
public static IEnumerable`1<TTypeMember> EnumerateMembers(ITypeElement typeElement, string name, bool caseSensitive);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasMembers(ITypeElement typeElement, string name, bool caseSensitive);
    [PureAttribute]
[NotNullAttribute]
public static IReadOnlyCollection`1<TypeMemberInstance> GetAllMembers(ITypeElement typeElement);
    [PureAttribute]
[NotNullAttribute]
public static IEnumerable`1<OverridableMemberInstance> GetAllOverridableMembers(ITypeElement typeElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsObjectClass(ITypeElement typeElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSystemObject(ITypeElement typeElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSystemEnumClass(ITypeElement typeElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSystemValueTypeClass(ITypeElement typeElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSystemDelegateClass(ITypeElement typeElement);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsSystemMulticastDelegateClass(ITypeElement typeElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSystemString(ITypeElement typeElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsSystemArray(ITypeElement typeElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsAttribute(ITypeElement typeElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsValueTuple(ITypeElement typeElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsNullableOfT(ITypeElement typeElement);
    [NotNullAttribute]
private static IEnumerable`1<ITypeElement> FindReferencedTypeElements(string fullyQualifiedName, IPsiModule module);
    [NotNullAttribute]
private static IEnumerable`1<ITypeElement> FindReferencedTypeElements(string fullyQualifiedName, ITreeNode element);
    [CanBeNullAttribute]
public static ITypeElement FindReferencedTypeElement(string fullyQualifiedName, string moduleName, IPsiModule module);
    [CanBeNullAttribute]
public static ITypeElement FindReferencedTypeElement(string fullyQualifiedName, string moduleName, ITreeNode element);
    [CanBeNullAttribute]
private static ITypeElement FindTypeElement(IEnumerable`1<ITypeElement> elements, string moduleName);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Util.TypeElementUtil/<GetAllBaseClasses>d__48")]
[ItemNotNullAttribute]
public static IEnumerable`1<IClass> GetAllBaseClasses(ITypeElement implementor);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNestedTypeOf(ITypeElement type1, ITypeElement type2);
    [ExtensionAttribute]
[PureAttribute]
public static bool CanInstantiateWithPublicDefaultConstructor(ITypeElement typeElement);
    [ExtensionAttribute]
[PureAttribute]
public static bool HasRequiredMembersInHierarchy(ITypeElement typeElement);
    public static bool ContainsPossibleInfiniteInheritanceGraph(ITypeElement typeElement);
    private static bool HasLoop(HashSet`1<ITypeParameter> visited, ITypeParameter waveOrigin, ITypeParameter node, Func`2<ITypeParameter, IEnumerable`1<ITypeParameter>> edges);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Util.TypeElementUtil/<EnumerateTypeArgumentClosure>d__54")]
private static IEnumerable`1<IDeclaredType> EnumerateTypeArgumentClosure(ITypeElement typeElement, HashSet`1<IDeclaredType> visited);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Util.TypeElementUtil/<EnumerateAllTypeArguments>d__55")]
private static IEnumerable`1<IDeclaredType> EnumerateAllTypeArguments(IDeclaredType declaredType, bool lookInSuperTypes, HashSet`1<IDeclaredType> visited);
    [ExtensionAttribute]
[NotNullAttribute]
public static TTypeElement RetargetTo(TTypeElement typeElement, IPsiModule targetModule);
    [ExtensionAttribute]
[NotNullAttribute]
public static TTypeElement RetargetTo(TTypeElement typeElement, IModuleReferenceResolveContext resolveContext);
    [PureAttribute]
public static bool StructFieldHasLayoutProblems(ITypeMember member);
    [PureAttribute]
public static bool StructFieldHasLayoutProblems(IStruct structElement, IType fieldType, bool isFieldStatic);
    private static bool AddToFlatteningGraph(Dictionary`2<IDeclaredType, HashSet`1<IDeclaredType>> graph, IDeclaredType fromType, IType type, bool isStatic);
    private static bool AddToFlatteningGraphAndCheckForInfinity(Dictionary`2<IDeclaredType, HashSet`1<IDeclaredType>> graph, IDeclaredType type);
    private static bool HasCycleInFlatteningGraph(Dictionary`2<IDeclaredType, HashSet`1<IDeclaredType>> graph, IDeclaredType seed, HashSet`1<IDeclaredType> path);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.TypesUtil : object {
    [NullableAttribute("1")]
private static HashSet`1<IClrTypeName> ourRestrictedClrTypes;
    private static TypesUtil();
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
private static bool IsTypeElementType(IType type);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
private static DeclaredElementInstance`1<TTypeElement> GetTypeElementInstance(IType type);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static TTypeElement GetTypeElement(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeElement GetTypeElement(IType type);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static IList`1<ITypeElement> ToTypeElements(IList`1<IDeclaredType> declaredTypes);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsEnumType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IEnum GetEnumType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static DeclaredElementInstance`1<IEnum> GetEnumTypeInstance(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsInterfaceType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IInterface GetInterfaceType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static DeclaredElementInstance`1<IInterface> GetInterfaceTypeInstance(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsClassType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IClass GetClassType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static DeclaredElementInstance`1<IClass> GetClassTypeInstance(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsStructType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IStruct GetStructType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static DeclaredElementInstance`1<IStruct> GetStructTypeInstance(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsDelegateType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IDelegate GetDelegateType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static DeclaredElementInstance`1<IDelegate> GetDelegateTypeInstance(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsTypeParameterType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("=> false, typeParameter: null; => true, typeParameter: notnull")]
public static bool IsTypeParameterType(IType type, ITypeParameter& typeParameter);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsTypeParameterTypeWithEnumConstraint(IType type);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("type: null => false")]
public static bool IsTypeParameterTypeWithDelegateConstraint(IType type, ITypeConversionRule typeConversionRule);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static ITypeParameter GetTypeParameterType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static DeclaredElementInstance`1<ITypeParameter> GetTypeParameterTypeInstance(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IType GetEnumUnderlying(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IType GetIEnumerableUnderlyingType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IType GetNullableUnderlyingType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool CanBeNullable(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IType GetSystemLinqExpressionUnderlyingType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("type: null => null; typeElement: null => null")]
public static IType GetGenericUnderlyingType(IType type, ITypeElement typeElement);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static IType Unlift(IType type);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null; notnull => notnull")]
public static IType LiftToNullable(IType type);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<DeclaredElementInstance`1<IDelegate>> GetDelegateTypes(IType type);
    [ExtensionAttribute]
[PureAttribute]
public static DeclaredElementInstance`1<IDelegate> GetDelegateTypeThroughExpression(IType type);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<DeclaredElementInstance`1<IDelegate>> GetDelegateTypesThroughExpression(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsReferenceType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsPointerType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsValueType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsUnconstrainedGenericType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsTrueValueType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool CanContainNullValue(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsEffectivelyNullable(IType sourceType);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static IType Type(IDeclaredElement element, IResolveContext resolveContext);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => null")]
public static IType Type(IDeclaredElement element);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static T MostEncompassedType(ICollection`1<T> types, ITypeConversionRule rule);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static IType MostEncompassingType(ICollection`1<IType> types, ITypeConversionRule rule);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static IType GetDelegateReturnMultitype(IPsiModule module, IType targetDelegateType, bool canTransformToExpression);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static IType GetDelegateParameterMultitype(IPsiModule module, IType targetDelegateType, int parameterIndex);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
private static IType GetDelegateParameterType(IPsiModule module, IType targetDelegateType, int index);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTypeBoxable(IType type);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsRestrictedClrType(IType type, bool ignoreSpanLikeTypes);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsByRefLikeType(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("null => false")]
public static bool IsByRefLikeOrAllowsByRefLikeType(IType type);
    [NullableContextAttribute("1")]
[PureAttribute]
public static IList`1<Pair`2<IType, ParameterKind>> GetParameterTypesAndKindsFromDelegate(IDelegate delegate, ISubstitution substitution);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static IReadOnlyList`1<IType> GetParameterTypesFromDelegate(IDelegate delegate, ISubstitution substitution);
    [NullableContextAttribute("1")]
[PureAttribute]
public static IType GetEnumerableOrArrayElementType(IType arrayLikeType);
    [NullableContextAttribute("1")]
[PureAttribute]
public static IType GetEnumerableOrArrayElementType(IType arrayLikeType, int rank);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Util.TypesUtil/<GetEnumerableSubtypeElementType>d__60")]
[PureAttribute]
public static IEnumerable`1<IType> GetEnumerableSubtypeElementType(IType enumerableSubtype);
    [NullableContextAttribute("1")]
[PureAttribute]
public static IType GetTypeArgumentValue(IType type, int typeParameterIndex);
    [NullableContextAttribute("1")]
[PureAttribute]
public static IList`1<ITypeParameter> GetTypeParameters(IType type);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static bool IsSubtypeOf(IType type, IType baseType, ITypeConversionRule typeConversionRule);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Util.TypesUtil/<GetAllSuperTypes>d__64")]
[PureAttribute]
private static IEnumerable`1<IDeclaredType> GetAllSuperTypes(IArrayType arrayType, IPsiModule module);
    [NullableContextAttribute("1")]
[PureAttribute]
public static IEnumerable`1<IDeclaredType> GetAllSuperTypes(IType type);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static IType Type(IParameter parameter);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static IType Type(IParameter parameter, ISubstitution substitution);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IResolveResult TryRetargetResolveResult(IResolveResult resolveResult, IModuleReferenceResolveContext moduleReferenceResolveContext);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ISubstitution RetargetSubstitution(ISubstitution substitution, IModuleReferenceResolveContext context, IList`1<ITypeParameter> sourceTypeParameters, IList`1<ITypeParameter> retargetedTypeParameters);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static IType RetargetType(IType type, IPsiModule sourceModule);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsUninferredType(IType type);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static bool IsUnknownOrUnresolvedTypeElementType(IExpressionType expressionType);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static bool IsUnknownOrUnresolvedTypeElementType(IType type);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static int DistanceTo(IType type, IType otherType, int undefinedDistance);
    [PureAttribute]
public static bool IsPossiblyMutableStructType(IType type);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool IsPossiblyNonTrivialStructTypeWorthCareAboutCopying(IType type);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static bool HasDeclarationsIn(IType type, IPsiSourceFile sourceFile);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsDefinitelyNotImplements(IType type, IType interfaceType, ITypeConversionRule conversionRule);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Util.TypesUtil/<EnumerateAllTypeDeclarationsLazily>d__79")]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<IDeclaration> EnumerateAllTypeDeclarationsLazily(ITypeElement typeElement);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool IsPredefinedTypeAvailable(IType type, IPsiModule sourceModule);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("type: null => false")]
public static bool IsInterpolatedStringHandlerType(IType type);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static bool IsStaticAbstractMembersOnlyInterface(IType type);
    [ExtensionAttribute]
[PureAttribute]
[ContractAnnotationAttribute("type: null => false")]
public static bool IsCollectionBuilderType(IType type);
    [ExtensionAttribute]
[PureAttribute]
public static bool IsTypeAllowedInBlobWrapper(IType type);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <IsEffectivelyNullable>g__IsNullable|43_0(IType type, LocalHashSet`1<ITypeParameter> visitedTypeParameters);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <IsSubtypeOf>g__IsIdentityConvertible|63_0(IType from, IType to, <>c__DisplayClass63_0& );
}
public class JetBrains.ReSharper.Psi.Util.UnrecognizedEscapeSequenceException : Exception {
    private int myLength;
    private int myPosition;
    public int Position { get; }
    public int Length { get; }
    protected UnrecognizedEscapeSequenceException(SerializationInfo info, StreamingContext context);
    public UnrecognizedEscapeSequenceException(string message, int position, int length);
    public int get_Position();
    public int get_Length();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.UsingRegionsInspectorExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
public static T AddAfter(IUsingRegionsInspector inspector, ITreeNode parent, IList`1<T> nodes, Predicate`1<T> shouldInsertAfter, Func`2<ITreeNode, T> insertAfter, Func`2<ITreeNode, T> insertBefore, bool saveUsingListPosition);
}
public static class JetBrains.ReSharper.Psi.Util.WebPathReferenceUtil : object {
    private static Key`1<CachedProjectItemValue`2<IProject, VirtualFileSystemPath>> ourCachedWwwRoot;
    private static string HOSTING_JSON;
    private static string DEFAULT_WWWROOT;
    private static WebPathReferenceUtil();
    public static ISymbolFilter[] GetPathInWebsiteFilter(IPathReference pathReference, WebRootCalculationKind rootCalculationKind);
    private static CachedProjectItemValue`2<IProject, VirtualFileSystemPath> CalculateWwwRootPath(IProject project);
    [NotNullAttribute]
public static VirtualFileSystemPath GetRootPath(IProject project, WebRootCalculationKind rootCalculationKind);
    [NotNullAttribute]
public static VirtualFileSystemPath GetRootPath(IProjectItem projectItem, WebRootCalculationKind rootCalculationKind);
    [NotNullAttribute]
public static VirtualFileSystemPath GetRootPath(IPsiSourceFile sourceFile, WebRootCalculationKind rootCalculationKind);
    [NotNullAttribute]
public static VirtualFileSystemPath GetRootPath(IPathReference pathReference, WebRootCalculationKind rootCalculationKind);
    [NotNullAttribute]
public static string ConvertToRootRelativePath(IProjectItem projectItem, VirtualFileSystemPath path, WebRootCalculationKind rootCalculationKind);
    [NotNullAttribute]
public static string ConvertToRootRelativePath(VirtualFileSystemPath root, VirtualFileSystemPath path);
    [NotNullAttribute]
private static VirtualFileSystemPath GetBasePathBeforeMapping(IQualifiableReference pathReference, WebRootCalculationKind rootCalculationKind);
    [NotNullAttribute]
public static VirtualFileSystemPath GetBasePath(IQualifiableReference pathReference, WebRootCalculationKind rootCalculationKind);
    [NotNullAttribute]
public static ISymbolTable GetReferenceSymbolTable(IPathReference pathReference, bool useReferenceName, WebRootCalculationKind rootCalculationKind, bool addCurrentDir, string defaultExtension);
    [NotNullAttribute]
public static ISymbolFilter[] GetSmartSymbolFilters(IPathReference pathReference, WebRootCalculationKind rootCalculationKind);
    [NotNullAttribute]
public static ISymbolFilter[] GetSmartSymbolFilters(IFileReference fileReference, WebRootCalculationKind rootCalculationKind);
    [NotNullAttribute]
public static ISymbolFilter[] GetFolderSmartSymbolFilters(IPathReference folderReference, WebRootCalculationKind rootCalculationKind);
    [NotNullAttribute]
public static ISymbolFilter[] GetCompletionFilters(IPathReference pathReference, WebRootCalculationKind rootCalculationKind);
    [NotNullAttribute]
public static ISymbolTable GetQualifierSymbolTable(IPathReference pathReference, WebRootCalculationKind rootCalculationKind);
    [NotNullAttribute]
public static ISymbolFilter[] AddNoCircularPathReferenceFilter(ISymbolFilter[] filters, IPathReference pathReference);
    [NotNullAttribute]
public static ResolveResultWithInfo CheckResolveResult(IIgnorablePathReference pathReference, ResolveResultWithInfo resolveResultWithInfo);
    [NotNullAttribute]
public static VirtualFileSystemPath GetPathUnmapped(IIgnorablePathReference pathReference, IPathDeclaredElement pathElement);
    public static VirtualFileSystemPath GetVirtualPathInWebsite(IPathDeclaredElement pathDeclaredElement, IProject project);
    [NotNullAttribute]
public static VirtualFileSystemPath GetVirtualPathInWebsite(IProjectItem projectItem);
}
public enum JetBrains.ReSharper.Psi.Util.WebRootCalculationKind : Enum {
    public int value__;
    public static WebRootCalculationKind NotSupported;
    public static WebRootCalculationKind ClientSide;
    public static WebRootCalculationKind ServerSide;
}
internal enum JetBrains.ReSharper.Psi.Util.XmlDocListType : Enum {
    public int value__;
    public static XmlDocListType TABLE;
    public static XmlDocListType BULLET;
    public static XmlDocListType NUMBER;
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.XmlDocPresenterUtil : object {
    [NotNullAttribute]
public static DeclaredElementPresenterStyle MemberPresentationStyle;
    [NotNullAttribute]
public static DeclaredElementPresenterStyle LinkedElementPresentationStyle;
    [NotNullAttribute]
public static DeclaredElementPresenterStyle LinkedElementWithContainerPresentationStyle;
    private static Regex ourMemberIdPrefixRegex;
    private static Regex ourIndentWhitespaceRegex;
    private static XmlDocPresenterUtil();
    [NotNullAttribute]
public static string ProcessCref(string cref);
    [NotNullAttribute]
[ObsoleteAttribute("Use the overload with RichText", "True")]
public static string PrepareText(string text, bool processLinks, string lineSeparator, bool trim);
    [NotNullAttribute]
public static RichText PrepareText(RichText text, bool processLinks, string lineSeparator, bool trim);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.Util.XmlDocPresenterUtil/<SplitByNewLine>d__7")]
[ExtensionAttribute]
[NotNullAttribute]
[ItemNotNullAttribute]
private static IEnumerable`1<RichText> SplitByNewLine(RichText s);
    [NotNullAttribute]
public static string FormatLink(Match match);
    [NotNullAttribute]
public static string EscapeHtmlString(string text);
    [NotNullAttribute]
public static RichText EscapeHtmlString(RichText text);
    public static void LayoutXml(XmlNode node, TextWriter writer);
    private static void LayoutXmlElement(TextWriter writer, XmlElement element);
    [NotNullAttribute]
private static string TrimIndentAndNormalizeNewlines(string content, bool skipFirstLine);
}
public class JetBrains.ReSharper.Psi.Util.XmlDocRichTextPresenter : XmlDocVisitor {
    private static TextStyle ourCodeStyle;
    private static TextStyle ourCRefStyle;
    private static TextStyle ourNormalStyle;
    private PsiLanguageType myLanguageType;
    [CanBeNullAttribute]
private DeclaredElementPresenterTextStyles myTextStyles;
    private IPsiModule myModule;
    private List`1<RichText> myStrings;
    private RichText myLastString;
    private int myLevel;
    [NotNullAttribute]
protected RichTextBlock RichTextBlock { get; }
    protected XmlDocRichTextPresenter(XmlNode node, PsiLanguageType languageType, DeclaredElementPresenterTextStyles textStyles, IPsiModule module);
    private static XmlDocRichTextPresenter();
    protected RichTextBlock get_RichTextBlock();
    public virtual void VisitExample(XmlElement element);
    public virtual void VisitException(XmlElement element);
    public virtual void VisitInclude(XmlElement element);
    public virtual void VisitPermission(XmlElement element);
    public virtual void VisitReturns(XmlElement element);
    public virtual void VisitParam(XmlElement element);
    public virtual void VisitTypeParam(XmlElement element);
    public virtual void VisitElement(XmlElement element);
    public virtual void VisitValue(XmlElement element);
    public virtual void VisitText(XmlText text);
    public virtual void VisitCData(XmlCDataSection cdataSection);
    public virtual void VisitWhitespace(XmlWhitespace whitespace);
    public virtual void VisitSignificantWhitespace(XmlSignificantWhitespace significantWhitespace);
    public virtual void VisitUnknownTag(XmlElement element);
    public virtual void VisitCommonSee(XmlElement element);
    private void WrapInNewLine(Action`1<XmlElement> action, XmlElement element);
    public virtual void VisitPara(XmlElement element);
    public virtual void VisitSummary(XmlElement element);
    public virtual void VisitRemarks(XmlElement element);
    public virtual void VisitC(XmlElement element);
    public virtual void VisitCode(XmlElement element);
    public virtual void VisitList(XmlElement element);
    private void ProcessRefTagNameAttr(XmlElement element);
    public virtual void VisitParamRef(XmlElement element);
    public virtual void VisitTypeParamRef(XmlElement element);
    private RichText ProcessCRef(string value);
    public static RichText ProcessCRef(string crefValue, PsiLanguageType languageType, IPsiModule psiModule, DeclaredElementPresenterStyle presenterStyle);
    private static int GetListItemTermSize(XmlNode node);
    protected void NewLine();
    protected void Append(RichText richText);
    protected void Append(string str, TextStyle style);
    protected void Append(string str);
    protected static string RemoveExtraSpaces(string str);
    [NotNullAttribute]
public static RichTextBlock Run(XmlNode node, bool includeHeader, PsiLanguageType languageType, DeclaredElementPresenterTextStyles textStyles, IPsiModule module);
}
public static class JetBrains.ReSharper.Psi.Util.XMLDocUtil : object {
    public static string Constructor;
    public static string ClassConstructor;
    private static string DTD;
    public static HashSet`1<string> InheritdocSingleOccurrenceTags;
    public static HashSet`1<string> InheritdocMultipleOccurrenceTags;
    [ThreadStaticAttribute]
[CanBeNullAttribute]
private static HashSet`1<IDeclaredElement> ourInheritDocDeclaredElementsInProgress;
    private static XMLDocUtil();
    public static XmlNode ExtractSummary(XmlNode node);
    public static XmlNode ExtractParameterSummary(XmlNode node, string name);
    public static XmlNode ExtractTypeParameterSummary(XmlNode node, string name);
    private static XmlElement ExtractTag(XmlNode node, string tagName, string name);
    public static XmlNode BuildEmptyNode(IXmlDocIdOwner element);
    [NotNullAttribute]
public static string GetTypeMemberXmlDocId(ITypeMember element, string shortName);
    public static bool IsObjectFinalize(IExplicitImplementation explicitImplementation);
    public static string GetTypeElementXmlDocId(ITypeElement element);
    public static string GetNamespaceXmlDocId(INamespace ns);
    private static string GetTypeElementQualifiedName(ITypeElement element);
    private static void BuildQualifyingInterfaceString(StringBuilder builder, IType type);
    public static string GetTypeString(IType type);
    private static void BuildTypeString(StringBuilder builder, IType type);
    public static void BuildArrayRankString(StringBuilder builder, int rank);
    [CanBeNullAttribute]
public static IDeclaredElement ResolveId(IPsiServices psiServices, string id, IPsiModule module, bool caseSensitive);
    [CanBeNullAttribute]
public static IDeclaredElement ResolveId(IPsiServices psiServices, string id, IPsiModule module, bool caseSensitive, bool withReferences);
    private static ISymbolScope GetDeclarationsCache(IPsiServices psiServices, IPsiModule module, bool caseSensitive, bool withReferences);
    private static bool CompareString(string str1, string str2, bool caseSensitive);
    public static void SubstituteHeader(XmlNode node, IXmlDocIdOwner element);
    [NotNullAttribute]
internal static string GetTypeElementXmlDocId(CompiledTypeElement element);
    [ContractAnnotationAttribute("=>true,node:notnull;=>false")]
public static bool Load(StringBuilder text, XmlNode& node);
    public static void ExtendWithInheritedDocTag(CompiledElementBase typeElement, XmlNode root);
    public static void ExtendWithInheritedDocTag(IClrDeclaredElement declaredElement, XmlNode root);
    private static void ExtendWithInheritedDocTag(IDeclaredElement declaredElement, XmlNode root, IPsiModule psiModule);
    private static void ExtendWithInheritedDocTagImpl(XmlNode root, IDeclaredElement baseElement, IPsiModule psiModule, string tagName);
    [NotNullAttribute]
public static string GetTypeMemberXmlDocId(IMetadataTypeMember typeMember);
    public static string GetShortName(IMetadataTypeMember typeMember, bool transformConstructorName);
    private static string GetTypeXmlDocId(IMetadataTypeInfo type);
    private static string GetTypeQualifiedName(IMetadataTypeInfo type);
    private static IMetadataClassType GetExplicitImplementation(IMetadataTypeMember typeMember);
    private static IMetadataClassType GetMethodExplicitImplementation(IMetadataMethod method);
    private static void BuildParametersString(StringBuilder builder, IMetadataParameter[] parameters);
    private static void BuildQualifyingInterfaceString(StringBuilder builder, IMetadataType type);
    private static void BuildTypeString(StringBuilder builder, IMetadataType type);
    private static int BuildQualifyingInterfaceString(StringBuilder builder, IMetadataTypeInfo type, IMetadataType[] arguments);
    private static int BuildTypeString(StringBuilder builder, IMetadataTypeInfo type, IMetadataType[] arguments);
    public static string GetNonGenericName(string name, Int32& genericParametersCount);
    private static void BuildArrayRankString(StringBuilder builder, IMetadataArrayType arrayType);
}
public class JetBrains.ReSharper.Psi.Util.XmlDocVisitor : XmlVisitor {
    private IDictionary`2<string, Action`1<XmlElement>> mySpecificTagVisitors;
    public virtual void Visit(XmlNode node);
    public virtual void VisitUnknownTag(XmlElement element);
    public virtual void VisitC(XmlElement element);
    public virtual void VisitCode(XmlElement element);
    public virtual void VisitExample(XmlElement element);
    public virtual void VisitException(XmlElement element);
    public virtual void VisitInclude(XmlElement element);
    public virtual void VisitList(XmlElement element);
    public virtual void VisitMember(XmlElement element);
    public virtual void VisitPara(XmlElement element);
    public virtual void VisitParam(XmlElement element);
    public virtual void VisitParamRef(XmlElement element);
    public virtual void VisitPermission(XmlElement element);
    public virtual void VisitRemarks(XmlElement element);
    public virtual void VisitReturns(XmlElement element);
    public virtual void VisitSee(XmlElement element);
    public virtual void VisitSeeAlso(XmlElement element);
    public virtual void VisitCommonSee(XmlElement element);
    public virtual void VisitSummary(XmlElement element);
    public virtual void VisitTypeParam(XmlElement element);
    public virtual void VisitTypeParamRef(XmlElement element);
    public virtual void VisitValue(XmlElement element);
    public virtual void VisitCRefAttribute(XmlAttribute attribute);
}
public class JetBrains.ReSharper.Psi.Util.XmlVisitor : object {
    public virtual void Visit(XmlNode node);
    public virtual void VisitNode(XmlNode node);
    public virtual void VisitElement(XmlElement element);
    public virtual void VisitAttribute(XmlAttribute attribute);
    public virtual void VisitText(XmlText text);
    public virtual void VisitCData(XmlCDataSection cdataSection);
    public virtual void VisitEntityReference(XmlEntityReference entityReference);
    public virtual void VisitEntity(XmlEntity entity);
    public virtual void VisitProcessingInstruction(XmlProcessingInstruction processingInstruction);
    public virtual void VisitComment(XmlComment comment);
    public virtual void VisitDocument(XmlDocument document);
    public virtual void VisitDocumentType(XmlDocumentType documentType);
    public virtual void VisitDocumentFragment(XmlDocumentFragment documentFragment);
    public virtual void VisitNotation(XmlNotation notation);
    public virtual void VisitWhitespace(XmlWhitespace whitespace);
    public virtual void VisitSignificantWhitespace(XmlSignificantWhitespace significantWhitespace);
    public virtual void VisitEndElement(XmlElement endElement);
    public virtual void VisitEndEntity(XmlEntity endEntity);
    public virtual void VisitXmlDeclaration(XmlDeclaration xmlDeclaration);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Psi.Util.XmlVisitorEx : object {
    [ExtensionAttribute]
public static void AcceptVisitor(XmlNode node, IXmlVisitor visitor);
}
public class JetBrains.ReSharper.Psi.ValidTypeEqualityComparer : object {
    private IEqualityComparer`1<IType> myUnderlyingComparer;
    public ValidTypeEqualityComparer(IEqualityComparer`1<IType> underlyingComparer);
    public sealed virtual bool Equals(IType x, IType y);
    public sealed virtual int GetHashCode(IType declaredType);
}
[SettingsKeyAttribute("JetBrains.ReSharper.Resources.Settings.CodeInspectionSettings", "JetBrains.ReSharper.Psi.Resources.Strings", "PathMappingsInWebProjectSettingDescription")]
internal class JetBrains.ReSharper.Psi.Web.Impl.Paths.WebPathMappingSettings : object {
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "IgnoredPathsRelativeToProjectLocationSettingDescription")]
public IIndexedEntry`2<VirtualFileSystemPath, VirtualFileSystemPath> IgnoredPaths;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "MappedPathsRelativeToProjectLocationSettingDescription")]
public IIndexedEntry`2<VirtualFileSystemPath, VirtualFileSystemPath> MappedPaths;
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Psi.Resources.Strings", "MapFromUpperCasedPathsToProperlyCasedSettingDescription")]
public IIndexedEntry`2<VirtualFileSystemPath, VirtualFileSystemPath> PathsInCorrectCasing;
}
[SolutionComponentAttribute("16")]
[DerivedComponentsInstantiationRequirementAttribute("0")]
public class JetBrains.ReSharper.Psi.XmlIndex.CompiledElementXmlDocProvider : object {
    public virtual XmlNode GetXmlDoc(CompiledElementBase element, bool inherit);
    [UsedImplicitlyAttribute]
[CanBeNullAttribute]
[ThreadSafeAttribute]
protected XmlNode GetDotNetXmlDoc(CompiledElementBase element, bool inherit);
}
public class JetBrains.ReSharper.Psi.XmlIndex.IndexEntry : ValueType {
    public int Hash;
    public TextRange Range;
    public static IUnsafeMarshaller`1<IndexEntry> Marshaller;
    public IndexEntry(int hash, TextRange range);
    private static IndexEntry();
}
public static class JetBrains.ReSharper.Psi.XmlIndex.MemberTagIndexer : object {
    public static ChunkList`1<IndexEntry> ReIndex(XmlIndexingLexer lexer, Action`1<XmlScannerTag> customProcessor);
}
[DebuggerDisplayAttribute("{FileName}")]
public class JetBrains.ReSharper.Psi.XmlIndex.XmlDocIndex : object {
    private static string REDIRECT_ATTRIBUTE_NAME;
    private static string DOC_TAG_NAME;
    private static string PROGRAMFILESDIR;
    private static XmlTokenTypes ourTokenTypes;
    private static Dictionary`2<string, String[]> ourAssemblyToXmlDocList;
    private object myLock;
    private bool myPersistCaches;
    private FileSystemPath myCacheDirectory;
    private DateTime myFileStamp;
    private Encoding myEncoding;
    private ChunkList`1<IndexEntry> myIndex;
    private XmlDocIndex myRedirectedIndex;
    private XmlDocIndex[] myExtraIndices;
    [CompilerGeneratedAttribute]
private VirtualFileSystemPath <FileName>k__BackingField;
    [CanBeNullAttribute]
protected VirtualFileSystemPath FileName { get; }
    protected int FormatVersion { get; }
    protected internal XmlDocIndex(VirtualFileSystemPath fileName, FileSystemPath cacheDirectory, bool persistCaches, VirtualFileSystemPath[] extraFiles);
    public XmlDocIndex(IPsiAssembly assembly, bool sync, IPsiConfiguration psiConfiguration, IPlatformManager platformManager, XmlIndexThread indexThread);
    public XmlDocIndex(VirtualFileSystemPath path, bool sync, IPsiConfiguration psiConfiguration, XmlIndexThread indexThread, VirtualFileSystemPath[] extraFiles);
    private static XmlDocIndex();
    [CompilerGeneratedAttribute]
protected VirtualFileSystemPath get_FileName();
    public static XmlDocIndex CreateUniversalIndex(TargetFrameworkId targetFrameworkId, IPlatformManager platformManager, IPsiConfiguration psiConfiguration);
    private string GetText(Stream stream, TextRange range);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Psi.XmlIndex.XmlDocIndex/<EnumerateXml>d__23")]
protected IEnumerable`1<XmlElement> EnumerateXml(string nodeName, string rootNodeName);
    private void Clear();
    public void UpdateIndex();
    private bool DoUpdateIndex();
    protected virtual void OnIndexUpdated();
    private OperationResult Load(FileSystemPath& cacheFilePath);
    private void Save(FileSystemPath cacheFilePath);
    protected virtual int get_FormatVersion();
    protected virtual OperationResult Load(BinaryReader reader);
    protected virtual void Save(BinaryWriter writer);
    private OperationResult ReIndex();
    [CanBeNullAttribute]
public XmlNode GetXml(string id, VirtualFileSystemPath& xmlDocPath);
    [CanBeNullAttribute]
public VirtualFileSystemPath GetXmlDocPath();
    [CanBeNullAttribute]
public VirtualFileSystemPath GetXmlDocPath(string id);
    public bool HasMultipleXmlDocPaths();
    protected ChunkList`1<IndexEntry> ReIndex(XmlIndexingLexer lexer);
    [CanBeNullAttribute]
private static VirtualFileSystemPath GetXmlDocPath(IPsiAssembly assembly, IPlatformManager platformManager);
    [NotNullAttribute]
private static VirtualFileSystemPath[] GetExtraXmlDocPaths(IPsiAssembly assembly, IPlatformManager platformManager);
    [CanBeNullAttribute]
private static VirtualFileSystemPath TryFindInReferenceAssembliesFolders(string xmlDocFileName, TargetFrameworkId targetFrameworkId, bool includeNetFramework4, IPlatformManager platformManager);
    private static bool IsPlatformAssembly(IPsiAssembly assembly, ICollection`1<IAssemblyFile> assemblyFiles);
    private static bool IsBclAssemblyInsideBundle(ICollection`1<IAssemblyFile> assemblyFiles);
    [CanBeNullAttribute]
private static CultureInfo TryGetEnCultureInfo();
    private static IList`1<CultureInfo> ExpandCulture(CultureInfo currentCulture, CultureInfo enCulture);
    private static IList`1<CultureInfo> GetCultureInfos();
    private static VirtualFileSystemPath FindXmlFilePath(VirtualFileSystemPath directoryPath, string name);
    [CanBeNullAttribute]
private static VirtualFileSystemPath TryPath(VirtualFileSystemPath folder, string fileName, string cultureSuffix);
    private static VirtualFileSystemPath GetFilePathFromCulture(VirtualFileSystemPath folder, string name, CultureInfo cultureInfo);
}
public class JetBrains.ReSharper.Psi.XmlIndex.XmlIndexingLexer : object {
    private VirtualFileSystemPath myFileName;
    private XmlBuffer myBuffer;
    private XmlLexerGenerated myLexer;
    private int myStartOffsetInBytes;
    private int myEndOffsetInBytes;
    private XmlTokenNodeType myPistart;
    private XmlTokenNodeType myTtSpace;
    private XmlTokenNodeType myTtNewLine;
    private XmlTokenNodeType myTtCommentBody;
    private XmlTokenNodeType myTtCommentStart;
    private XmlTokenNodeType myTtCommentEnd;
    private XmlTokenNodeType myTtPiend;
    public bool HasLexer { get; }
    public Encoding Encoding { get; }
    public XmlTokenTypes XmlTokenType { get; }
    public object CurrentPosition { get; public set; }
    public TokenNodeType TokenType { get; }
    public string CurrentPositionText { get; }
    public int TokenStart { get; }
    public int TokenEnd { get; }
    public IBuffer Buffer { get; }
    public int StartOffsetInBytes { get; }
    public int EndOffsetInBytes { get; }
    public XmlIndexingLexer(VirtualFileSystemPath fileName, XmlTokenTypes tokenTypes);
    public sealed virtual void Dispose();
    public bool get_HasLexer();
    public Encoding get_Encoding();
    public XmlTokenTypes get_XmlTokenType();
    public sealed virtual void Start();
    public sealed virtual object get_CurrentPosition();
    public sealed virtual void set_CurrentPosition(object value);
    public sealed virtual void Advance();
    private void AdvanceImpl();
    public sealed virtual TokenNodeType get_TokenType();
    public string get_CurrentPositionText();
    public sealed virtual int get_TokenStart();
    public sealed virtual int get_TokenEnd();
    public sealed virtual IBuffer get_Buffer();
    public int get_StartOffsetInBytes();
    public int get_EndOffsetInBytes();
    public void ExpectToken(XmlTokenNodeType tagStart);
    public void SkipWhitespaces();
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Psi.XmlIndex.XmlIndexThread : object {
    private SingleThreadExecutor myExecutor;
    private IPsiCachesState myPsiCaches;
    private ITaskHost myTasks;
    private Lifetime myLifetime;
    public XmlIndexThread(Lifetime lifetime, IPsiCachesState psiCaches, IThreading threading);
    public void Enqueue(XmlDocIndex index);
}
internal class JetBrains.ReSharper.Psi.XmlIndex.XmlTokenTypesImpl : XmlTokenTypes {
    private static int BASE_INDEX;
    private static XmlTokenTypesImpl();
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Psi.ZoneMarker : object {
}
public class JetBrains.Roslyn.Host.RuleSets.RoslynRuleSet : object {
    [NotNullAttribute]
public string Name;
    [CanBeNullAttribute]
public string Description;
    [NotNullAttribute]
public string ToolsVersion;
    [NotNullAttribute]
public FileSystemPath FilePath;
    public Nullable`1<RoslynRuleSetAction> IncludedAction;
    private List`1<RoslynRuleSet> myIncludes;
    private Dictionary`2<RoslynRulesSection, Dictionary`2<string, RoslynRuleSetAction>> myAllRules;
    public IReadOnlyDictionary`2<string, RoslynRuleSetAction> FlatActions;
    public RoslynRuleSet(FileSystemPath filePath, string name, string description, string toolsVersion, List`1<RoslynRuleSet> includes, Dictionary`2<RoslynRulesSection, Dictionary`2<string, RoslynRuleSetAction>> allRules, Nullable`1<RoslynRuleSetAction> includedAction);
    [IteratorStateMachineAttribute("JetBrains.Roslyn.Host.RuleSets.RoslynRuleSet/<GetFileSources>d__7")]
public IEnumerable`1<FileSystemPath> GetFileSources();
    private void FlattenRules(IDictionary`2<string, RoslynRuleSetAction> existingRules);
}
public enum JetBrains.Roslyn.Host.RuleSets.RoslynRuleSetAction : Enum {
    public int value__;
    public static RoslynRuleSetAction Default;
    public static RoslynRuleSetAction None;
    public static RoslynRuleSetAction Hidden;
    public static RoslynRuleSetAction Info;
    public static RoslynRuleSetAction Warning;
    public static RoslynRuleSetAction Error;
}
public class JetBrains.Roslyn.Host.RuleSets.RoslynRulesSection : ValueType {
    public string AnalyzerId;
    public string RuleNamespace;
    public RoslynRulesSection(string analyzerId, string ruleNamespace);
}
public static class JetBrains.Roslyn.Host.RuleSets.RuleSetParser : object {
    private static ILogger ourLogger;
    private static RuleSetParser();
    public static RoslynRuleSet ParseRuleSet(FileSystemPath path, Nullable`1<RoslynRuleSetAction> includedAction, HashSet`1<FileSystemPath> visitedFiles);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
