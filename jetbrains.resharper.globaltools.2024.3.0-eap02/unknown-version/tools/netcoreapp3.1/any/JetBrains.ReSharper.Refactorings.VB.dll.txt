public class JetBrains.ReSharper.Refactorings.VB.AdjustNamespaces.VBAdjustNamespaceHelper : AdjustNamespacesHelperBase {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual void FixFile(IFile file, string expectedNamespaceName, ResolveImagesRepository repository, List`1<IDeclaredElement> elements);
    public virtual bool IsFromExtendsList(ITreeNode element);
    public virtual bool IsReferenceName(ITreeNode element);
    public virtual void SaveUnusedUsings(IFile file, UnusedUsingSaver saver);
    public virtual void RemoveUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public virtual bool IsExternallyVisibleSymbol(IDeclaredElement element);
    public virtual void RemoveUsing(ITreeNode element);
    public virtual IEnumerable`1<ITreeNode> GetUsingsFromFile(IFile file, IList`1<INamespace> namespaces);
    public virtual IDeclaredElement GetImportedSymbolOfUsing(ITreeNode element);
    public virtual bool FileHasProblems(IFile file, string expectedNamespace);
    public virtual IReadOnlyList`1<ITypeDeclaration> GetTopLevelTypeDeclarations(IFile file);
    private bool HasDeclarationWithWrongNamespace(IVBTypeAndNamespaceHolderDeclaration holder, string expectedNamespace);
    private bool IsDisableCheckNamespaceComment(ControlConstructInfo controlConstructInfo);
    private bool IsSuppressedCheckNamespace(ITreeNode node);
    [CompilerGeneratedAttribute]
private bool _Lambda$__14-0(IVBTypeDeclaration x);
    [CompilerGeneratedAttribute]
private bool _Lambda$__14-3(IVBNamespaceDeclaration x);
    [CompilerGeneratedAttribute]
private bool _Lambda$__16-1(ControlConstructInfo c);
}
public class JetBrains.ReSharper.Refactorings.VB.AdjustNamespaces.VBMoveIntoMatchingFilesHelper : MoveIntoMatchingFilesHelperBase {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual IReadOnlyList`1<IDeclaration> GetTopLevelTypeDeclarations(IFile file, Boolean& hasTopLevelCode);
    public virtual bool IsFromExtendsList(ITreeNode element);
    public virtual bool IsReferenceName(ITreeNode element);
    public virtual bool IsExternallyVisibleSymbol(IDeclaredElement element);
    public virtual void MoveDeclarationFromFile(MovedDeclaration declaration, ResolveImagesRepository repository);
    public virtual void SaveUnusedUsings(IFile file, UnusedUsingSaver saver);
    public virtual void RemoveUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public virtual ITreeNode GetOwnerNamespaceDeclaration(IDeclaration typeDeclaration);
}
public class JetBrains.ReSharper.Refactorings.VB.AdjustNamespaces.VBMoveToFileHelper : MoveToFileHelperBase {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual bool FileHasOtherDeclarations(IDeclaration declaration);
    private bool ScanForOtherDeclarations(IVBTypeAndNamespaceHolderDeclaration holder, IDeclaration typeDeclaration);
    public virtual bool IsFromExtendsList(ITreeNode element);
    public virtual bool IsReferenceName(ITreeNode element);
    public virtual void SaveUnusedUsings(IFile file, UnusedUsingSaver saver);
    public virtual void RemoveUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public virtual bool IsExternallyVisibleSymbol(IDeclaredElement element);
    public virtual bool MoveDeclaration(IDeclaration declaration, ResolveImagesRepository repository, IFile file, MoveToFileWorkflow workflow, IRefactoringDriver driver);
}
public class JetBrains.ReSharper.Refactorings.VB.AdjustNamespaces.VBMoveToFolderHelper : MoveToFolderHelperBase {
    public bool IsLanguageSupported { get; }
    public bool CanMoveSingleTypeDeclaration { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual bool get_CanMoveSingleTypeDeclaration();
    public virtual IReadOnlyList`1<IDeclaration> GetTopLevelTypeDeclarations(IFile file);
    public virtual bool IsFromExtendsList(ITreeNode element);
    public virtual bool IsReferenceName(ITreeNode element);
    public virtual void SaveUnusedUsings(IFile file, UnusedUsingSaver saver);
    public virtual void RemoveUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public virtual bool IsExternallyVisibleSymbol(IDeclaredElement element);
    public virtual void RemoveUsing(ITreeNode element);
    public virtual bool MoveWholeFile(MoveToFolderHierarchyProjectItem item, IFile sourceFile, IFile targetFile, bool fixNamespaces, string expectedNamespaceName, ResolveImagesRepository repository, bool searchInRelatedFiles1);
    public virtual bool MoveFewDeclarations(IFile sourceFile, IFile targetFile, bool fixNamespaces, string expectedNamespaceName, ResolveImagesRepository repository, IList`1<IDeclaration> children, bool searchInRelatedFiles1);
    private IVBFile RemoveUsings(IVBFile holder);
    private bool RemoveDeclarationsInFiles(IVBTypeAndNamespaceHolderDeclaration sourceHolder, IVBTypeAndNamespaceHolderDeclaration targetHolder, IList`1<IDeclaration> children);
    private void RemoveTypeDeclaration(IVBTypeDeclaration declaration);
    private void RemoveNamespace(IVBNamespaceDeclaration declaration);
    public virtual bool MoveSingleDeclaration(IDeclaration typeDeclaration, IFile targetFile, string expectedNamespaceName, ResolveImagesRepository repository, bool searchInRelatedFiles1);
    private void RemoveTypeDeclarationWithNamespaces(IVBTypeDeclaration declaration);
    public virtual IEnumerable`1<ITreeNode> GetUsingsFromFile(IFile file, IList`1<INamespace> namespaces);
    public virtual void MakePublic(IDeclaration declaration);
    public virtual bool DeclarationCanProvideName(IDeclaration declaration);
}
public class JetBrains.ReSharper.Refactorings.VB.AdjustNamespaces.VBMoveToNamespaceHelper : MoveToNamespaceHelperBase {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual bool IsFromExtendsList(ITreeNode element);
    public virtual bool IsReferenceName(ITreeNode element);
    public virtual void SaveUnusedUsings(IFile file, UnusedUsingSaver saver);
    public virtual void RemoveUnusedUsing(IFile file, HashSet`1<ITreeNode> usings);
    public virtual bool IsExternallyVisibleSymbol(IDeclaredElement element);
    public virtual IEnumerable`1<ITreeNode> GetUsingsFromFile(IFile file, IList`1<INamespace> namespaces);
    public virtual void MovePrimaryDeclaration(IDeclaration typeDeclaration, string newNamespaceName, ResolveImagesRepository repository, IRefactoringDriver driver);
    private IVBTypeAndNamespaceHolderDeclaration GetNewTypeDeclarationHolder(ITypeDeclaration typeDeclaration, string namespaceName);
    private void FixContainingHolderIfNeeded(ITypeAndNamespaceHolderDeclaration containingHolder);
    public virtual void RemoveUsing(ITreeNode element);
    public virtual string ValidateNamespaceName(string newNamespace, IDeclaration declaration);
}
public class JetBrains.ReSharper.Refactorings.VB.AdjustNamespaces.VBMoveUtil : object {
    public static string GetNamespaceName(string namespaceName, string defaultNamespaceName);
    public static IReadOnlyList`1<ITypeDeclaration> GetTopLevelTypeDeclarations(IFile file);
    private static IEnumerable`1<ITypeDeclaration> GetDeclarationsFromFile(IVBTypeAndNamespaceHolderDeclaration holder);
    public static IVBFile CopyFileAndFixNamespaces(IVBFile newFile, IVBFile oldFile, string expectedNamespaceName, IList`1<IDeclaredElement> importedNamespaces);
    private static void AddImports(IVBFile newFile, IList`1<IDeclaredElement> importedNamespaces);
    private static void CleanImports(IVBFile holder);
    private static IVBTypeAndNamespaceHolderDeclaration StripNamespacesAndUsingsOff(IVBTypeAndNamespaceHolderDeclaration holder);
    private static void StripNamespaces(IVBTypeAndNamespaceHolderDeclaration holder, IVBNamespaceDeclaration declaration);
    public static IEnumerable`1<ITreeNode> GetUsingsFromFile(IFile file, IList`1<INamespace> namespaces);
    private static bool IsRemovedUsing(IImportClause clause, IList`1<INamespace> namespaces, List`1<string> list);
    private static bool NamespacesEquals(INamespace ns1, INamespace ns2);
    private static IReferenceName GetImportedSymbol(IImportClause import);
    public static bool IsExternallyVisibleSymbol(IDeclaredElement declaredElement);
}
public class JetBrains.ReSharper.Refactorings.VB.ChangeStaticness.VBMakeStatic : MakeStatic {
    private VBInlineHelper myInlineHelper;
    public InlineHelper InlineHelper { get; }
    public VBMakeStatic(MakeStaticWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void BindTo(IReference reference, IDeclaredElement declaredElement, ISubstitution substitution);
    public virtual void Qualify(ITreeNode node, IParameter parameter);
    public virtual void AddArgumentAndBind(IReference reference, IDeclaredElement declaredElement, ISubstitution substitution, DisposableMarker marker);
    public virtual void SetStatic(IDeclaration declaration);
    public virtual IParameter AddParameter(IDeclaration declaration, IType type, string name);
    public virtual int ReferencesToThis(IExpression expression);
    public virtual InlineHelper get_InlineHelper();
    public virtual void Replace(ITreeNode node, string name);
    public virtual void CallInline(IReference reference, CallSiteContext context, IntroduceParameterInlineCallInfo info, IList`1<string> lambdaParameterNames);
    public virtual void FixOtherArguments(IReference reference, Dictionary`2<int, InlinedArgumentInfo> inlinedArgumentInfos);
    public virtual void AddArgument(IReference reference, string name);
    public virtual IReference ConvertMethodGroupToLambda(IReference reference, IList`1<IParameter> parameters);
}
public class JetBrains.ReSharper.Refactorings.VB.ChangeStaticness.VBMakeStaticHelper : object {
    public bool IsLanguageSupported { get; }
    public sealed virtual override bool get_IsLanguageSupported();
    public sealed virtual override bool CheckElement(IDeclaredElement overridableMember, ITypeElement& containingTypeElement);
    public sealed virtual override void CollectUsages(ThisUsagesCollector collector, IParametersOwnerDeclaration parametersOwnerDeclaration, IPsiServices psiServices);
    public sealed virtual override string GetTitle();
}
public class JetBrains.ReSharper.Refactorings.VB.Constructor2FactoryMethod.VBConstructor2FactoryMethod : ConstructorToFactoryMethodBase {
    public VBConstructor2FactoryMethod(Constructor2FactoryMethodWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual bool IsBaseConstructorInitializer(ITreeNode constructorUsageNode);
    public virtual ITypeMember CreateFactoryMethodDeclaration(ITypeElement targetTypeElement, IConstructor constructorToCall, string factoryMethodName);
    public virtual ITypeMember CreateSingleInstanceMemberDeclaration(ITypeElement targetTypeElement, IConstructor constructorToCall, string instancePropertyName);
    public virtual void ConvertUsage(ITypeMember factoryMember, IReference reference);
    private void CheckAccessExpression(IVBExpression expression, IReference reference);
    public virtual string GetModifiersString(IParameter parameter);
}
public class JetBrains.ReSharper.Refactorings.VB.Convert.InterfaceMembersCollector : InterfaceMembersCollectorBase {
    public InterfaceMembersCollector(bool keepAllExplicitlyImplemented);
    public static IList`1<ElementInstancePointer> GetInterfaceMembers(ITypeDeclaration typeDeclaration, bool keepAllNotExplicitlyImplemented);
    protected virtual void ProcessPrivateImplementations(IOverridableMember overridableMember, ISubstitution substitution, OverridableMemberInfo overridableMemberInfo, bool processingInheritedMembers);
    protected virtual bool IsPrimaryTypeMember(ITypeMember overridableMember);
}
public class JetBrains.ReSharper.Refactorings.VB.Convert.VBConvert : ConvertTypeBase`2<ITypeMemberDeclaration, IClassLikeDeclaration> {
    public Dictionary`2<IClassLikeDeclaration, IClassLikeDeclaration> myPartsMap;
    private Dictionary`2<IClass, ISubstitution> myClassToSubst;
    private List`1<Pair`2<ISubstitution, IOverridableMember>> myImplementsSpecificationsToAdd;
    public VBConvert(IConvertTypeWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void ReplaceMembers(IClass clsss);
    private void CopyMethods(IClassDeclaration interfaceDeclaration, IInterfaceDeclaration newDecl);
    public virtual void CreateClassDeclaration(IInterface interfccc);
    protected virtual void AddSuperInterface(ITypeDeclaration newDecl, IDeclaredType newSuprtType);
    private void Decorate(ITypeElement interfccc, IClassLikeDeclaration oldDecl, IClassLikeDeclaration newDecl);
    public virtual void RemoveDeclaration(IOverridableMember member);
    public virtual void MakePublicOverride(IOverridableMember member, IDeclaredType declTypeToRemove);
    public virtual void RemoveInterface(ITypeElement implementor, IInterface interfaceToRemove);
    public virtual void AddInterface(ITypeElement typeElement, IExplicitImplementation interfaceToAdd);
    public virtual void ImplementsMembersAbstract();
    protected virtual void Privatizate(ITypeMemberDeclaration newDecl);
    protected virtual bool CanCallMoreGeneric(OverridableMemberInstance moreGenericInstance, OverridableMemberInstance lessGenericInstance, IClassLikeDeclaration clsss);
    protected virtual void MakeCallMoreGeneric(IClassLikeDeclaration classToAddNewDeclaration, ElementInstancePointer memberCaller, ElementInstancePointer memberCallee, IType type);
    protected virtual IEnumerable`1<ITypeMemberDeclaration> MakeAbstractDeclaration(IClassLikeDeclaration classDecl, ElementInstancePointer pointer, int indexForVB, IEnumerable`1<IType> lsitOfTypes, bool makePrivate);
    protected virtual void MakePrivateImplementation(ElementInstancePointer pointer, ITypeMemberDeclaration newDecl);
    public virtual void AddImplements(IClass inheritor);
    public virtual void RemoveInherits(IClass clsss, IClass source);
    public virtual void FixSignature(ITypeElement implementor, IInterface initialInterface);
    public virtual void ProcessOtherMember(ITypeMember member);
    public virtual bool MakeVirtual(IOverridableMember member);
    public virtual void MakePublic(IOverridableMember member);
    public virtual bool ProcessOverridableMember(IOverridableMember overridable, IProgressIndicator pi);
    public virtual void AddInterfaceSpecificationToOverride(IOverridableMember over, IClass class);
    public virtual void AddImplementsSpecifications();
}
public class JetBrains.ReSharper.Refactorings.VB.ConvertRefactoringUtil : object {
    public static Data Analyse(IReferenceExpression referenceExpression, IMethod method, bool isGetter);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.VB.CopyType.VBLanguageSpecificCopyType : CLRLanguageSpecificCopyTypeBase {
    public virtual bool IsAvailable(IDeclaration typeDeclaration);
    public virtual string GenerateFileName(IDeclaration typeDeclaration, string name);
    public virtual IDeclaration CreateCopy(IDeclaration typeDeclaration, IFile file, string qualifiedName, ITreeNode& alreadyCreatedScope);
    public virtual IConflictSearcher GetConflictSearcher(IDeclaredElement typeElement, string qualifiedName);
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.VB.DefaultPropertyToFunction.DefaultProperty2FunctionProvider : object {
    public sealed virtual override IEnumerable`1<IRefactoringWorkflow> IWorkflowProvider_CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.VB.DefaultPropertyToFunction.DefaultPropertyToFunctionWorkflow : Indexer2FunctionWorkflow {
    public string Title { get; }
    public DefaultPropertyToFunctionWorkflow(ISolution solution, string actionId);
    public virtual bool Initialize(IDataContext context);
    protected virtual bool CheckLanguage(IDeclaredElement element);
    public virtual string get_Title();
}
public class JetBrains.ReSharper.Refactorings.VB.EncapsulateField.VBEncapsulateField : EncapsulateFieldBase {
    public VBEncapsulateField(EncapsulateFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IDeclaredElement CreatePropertyDeclaration(IDeclaredElement fieldElement);
    public virtual void RemoveFieldDeclaration(IDeclaredElement field);
    private static IVBExpression CreatePropertyExpression(IReferenceExpression referenceExpression, IProperty property);
    private static void CopyXmlDocumenation(IVBTypeMemberDeclaration fieldDeclaration, IPropertyDeclaration propertyDeclaration);
    private static void ReplaceReference(IReference reference, IProperty property);
    private void ReplaceComplexReference(IAssignmentStatement assignmentStatement, IReferenceExpression referenceExpression, IProperty property);
    protected virtual void ProcessReference(IReference reference, ReferenceAccessType accessType, IDeclaredElement property);
    public virtual IDeclaredElement EnsureReadable(IDeclaredElement property, IDeclaredElement field);
    public virtual IDeclaredElement EnsureWriteable(IDeclaredElement property, IDeclaredElement field);
    [NotNullAttribute]
public IAccessorDeclaration CreateWriteAccessor(IField field);
    [NotNullAttribute]
public IAccessorDeclaration CreateReadAccessor(IField field);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.VB.EncapsulateField.VBEncapsulateFieldUtil : ClrEncapsulateFieldUtilBase {
    public virtual bool CanEncapsulateToAutoProperty(IDeclaredElement field);
    public virtual bool LanguageSupportsPrivateProtectedModifier(IDeclaredElement field);
}
public class JetBrains.ReSharper.Refactorings.VB.ExtractClass.VbExtractClassAnalyzer : ExtractClassAnalyzer {
    public virtual void LoadGraph(List`1<ExtractClassMemberNode> members);
    private void FillParents(IExpression expression, ExtractClassMemberNode typeMember, List`1<ExtractClassMemberNode> members);
}
public class JetBrains.ReSharper.Refactorings.VB.ExtractClass.VbExtractClassHelper : ExtractClassHelper {
    public bool IsLanguageSupported { get; }
    public virtual ITypeDeclaration CreateTargetTypeElement(Dictionary`2& typeParams, ExtractClassWorkflow workflow);
    private static Dictionary`2<ITypeParameter, ITypeParameter> AddTypeParameters(IVBTypeDeclaration targetTypeDeclaration, IVBTypeDeclaration sourceTypeDeclaration, ExtractClassDataModel model);
    protected static JetHashSet`1<ITypeParameterOfTypeDeclaration> CollectParameters(JetHashSet`1<ITypeParameterOfTypeDeclaration> sourceTypeTypeParameters, ITypeParameterOfTypeOwnerDeclaration source);
    protected static List`1<ITypeParameterOfTypeDeclaration> GetUsedTypeParameters(ITypeParameterOfTypeOwnerDeclaration sourceTypeDeclaration);
    public virtual ITypeDeclaration InsertSibling(ITypeDeclaration declarationToInsert, ITypeDeclaration tagDeclaration);
    public virtual ITypeDeclaration InsertToNewFile(ITypeDeclaration declarationToInsert, ITypeDeclaration tagDeclaration, string targetNamespace, IProjectFile fileNearby);
    public virtual ExtractClassAnalyzer GetAnalyzer(ITypeElement owner, string name, VirtualFileSystemPath fileSystemPath, Lifetime lifetime);
    public virtual bool TryProcessMultyFieldForResolve(IRecursiveElementProcessor collector, IDeclaration declaration);
    public virtual bool get_IsLanguageSupported();
}
public class JetBrains.ReSharper.Refactorings.VB.ExtractClass.VbExtractClassRefactoringExec : ExtractClassRefactoringExec {
    private ExtractClassDataModel myDataModel;
    public VbExtractClassRefactoringExec(ExtractClassWorkflow extractClassWorkflow, IRefactoringDriver refactoringDriver);
    public virtual void AddProperties();
    private IPropertyDeclaration CreatePropertyDeclaration(ITypeDeclaration sourceTypeDeclaration, IType type, ITypeMemberDeclaration fieldDeclaration, bool addSetter, bool isStatic);
    private void AddAccessorsToProperty(IProperty localProperty, IField field);
    public virtual void Rebind(IReference reference, ExtractClassMemberNode memberToRebind, IDeclaredElement propertyMember);
    private void RebindReferenceName(ExtractClassMemberNode memberToRebind, IReference reference);
    private void RebindSupertypeMember(IVBTypeMemberDeclaration containingTypeMemberDeclaration, IReferenceExpression refExpression);
    public virtual void AddField(ITypeElement sourceTypeElement, ITypeElement targetTypeElement);
    public virtual void CreateConstructors();
    private void AddConstructors();
    public virtual bool CutAndPaste(ResolveImagesRepository repository, Dictionary`2<ITypeParameter, ITypeParameter> createdTypeParametersMap, IProgressIndicator pi);
    private void CreateConstructorDeclarations(IList`1<ConstructorNode> constructorInfos, bool insertThis);
    private void AddCall(VBElementFactory factory, ConstructorCall constructorCall, bool insertThis);
    private void AddThisParameter(IConstructorDeclaration targetConstructorDeclaration);
    private void AddParameter(VBElementFactory factory, IConstructorDeclaration targetConstructorDeclaration, IDeclaredElement parameter);
    private bool CreateDelegatingCopy(ExtractClassMemberNode member, IVBTypeMemberDeclaration memberDeclaration, IClassLikeDeclaration targetTypeDeclaration, ResolveImagesRepository repository);
    private void RebindCopy(IVBTypeMemberDeclaration newMemberDeclaration, ISubstitution substitution);
    private ISubstitution GetSubstitution(IVBTypeMemberDeclaration memberDeclaration, IVBTypeMemberDeclaration newMemberDeclaration);
    private void CopyMethod(IVBTypeMemberDeclaration targetClassMemberDeclaration, IMethodDeclaration sourceMethodDeclaration, IDeclaredElement caller);
    private void CopyProperty(IVBTypeMemberDeclaration targetClassMemberDeclaration, IDeclaredElement caller, ExtractClassMemberNode data, IProperty property);
    public virtual void ResolveConflicts(IProgressIndicator subPi);
    private void ResolveThisConflict(MemberNode member);
    private void ResolveReadonlyConflict(MemberNode member);
    private bool ResolveChangeAccessConflict(ExtractClassMemberNode member);
    private void ChangeAccessModifiers(IProperty property);
    public virtual void CreateConstructors(ExtractClassDataModel dataModel);
    private void ProceedConstructorCopy(List`1<ConstructorNode> constructorInfos, ConstructorNode constructorNode, ConstructorCall constructorCall);
    private void ProceedStatement(IStatement statement, List`1& parameters, ConstructorCall& constructorCall, List`1& possibleBody, bool useAutoProperties, string targetClassName, ExtractClassDataModel dataModel);
    private ReferenceResult ProcessReference(IExpression expression, ExtractClassDataModel dataModel);
    [CompilerGeneratedAttribute]
private bool _Lambda$__2-1(IReference reference);
    [CompilerGeneratedAttribute]
private bool _Lambda$__8-3(ExtractClassMemberNode selectedMember);
    [CompilerGeneratedAttribute]
private bool _Lambda$__8-4(IReference reference);
}
public class JetBrains.ReSharper.Refactorings.VB.ExtractMethod.VBExpressionExtractMethod : ExpressionExtractMethodBase {
    private ManuallyRemappedTreeNodePointer myUnpassedParametersMarker;
    private bool myIsModule;
    private VBElementFactory Factory { get; }
    public PsiLanguageType Language { get; }
    public PsiLanguageType LanguageType { get; }
    public VBExpressionExtractMethod(IVBExpression expression, ICollection`1<LocalVariable> localVariables);
    private VBElementFactory get_Factory();
    protected virtual ExtractMethodParameter CreateParameter(LocalVariable variable);
    public virtual bool Execute(IProgressIndicator pi);
    private IVBTypeMemberDeclaration GetOwnerTypeMemberDeclaration();
    private void ReplaceExpressionWithInvocation();
    public virtual string PreviewDeclaration();
    public virtual PsiLanguageType get_Language();
    private IMethodDeclaration CreateDeclaration(IProgressIndicator indicator);
    public virtual void PostExecute(IProgressIndicator progressIndicator);
    public virtual PsiLanguageType get_LanguageType();
}
internal class JetBrains.ReSharper.Refactorings.VB.Helpers.VBNamespaceRedundanceFileFixer : object {
    private IProjectFile myProjectFile;
    public bool IsEmpty { get; }
    public IProjectFile ProjectFile { get; }
    public VBNamespaceRedundanceFileFixer(INamespace namespace, IVBFile file);
    public sealed virtual override void FixUsages();
    public sealed virtual override bool get_IsEmpty();
    public sealed virtual override IProjectFile get_ProjectFile();
}
public class JetBrains.ReSharper.Refactorings.VB.Inline.ArgUtil.VBArgumentsUtil : object {
    public static ArgumentFromParameter GetArgumentFromParameter(IParameter parameter, IVBArgumentsOwner argumentsOwner, IParametersOwner parametersOwner);
}
public class JetBrains.ReSharper.Refactorings.VB.Inline.CodeTransformers.VBInlineCodeTransformerHelper : object {
    [CompilerGeneratedAttribute]
private ITreeNode _TargetContext;
    public ITreeNode TargetContext { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual override ITreeNode get_TargetContext();
    [CompilerGeneratedAttribute]
public sealed virtual override void set_TargetContext(ITreeNode AutoPropertyValue);
    public sealed virtual override ITreeNode ChangeName(ITreeNode element, string name);
    public sealed virtual override ITreeNode AddActionReplaceWithDefaultParamValue(IReferenceExpression expression, IParameter parameter);
    public sealed virtual override ITreeNode AddActionReplaceParameterWithArgumentExpression(IReferenceExpression expression, IParameter parameter, InlinedArgumentInfo info, ArgumentFromParameter argumentFromParameter);
    public sealed virtual override ITreeNode AddActionReplaceExpressionWithTemp(IExpression expression, string newTempName);
    public sealed virtual override ITreeNode AddActionSetQualifier(IReferenceExpression expression, IQualifierOwnerCallInfo info);
    public sealed virtual override ITreeNode ReplaceByQualifier(IReferenceExpression expression, IQualifierOwnerCallInfo info);
    public sealed virtual override bool IsExtensionMethod(IReferenceExpression expression);
}
public class JetBrains.ReSharper.Refactorings.VB.Inline.CodeTransformers.VBInlinedPropertyCodeTransformer : InlinedPropertyCodeTransformerBase`1<IReferenceExpression> {
    public VBInlinedPropertyCodeTransformer(ITreeNode expression, InlinedParameterCallSiteInfo inlinedCallInfo, CallSiteContext context);
    protected virtual void TransformElement(ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.VB.Inline.CodeTransformers.VBInlinedTypeOwnerInitializerTransformer : InlinedTypeOwnerInitializerTransformerBase`1<IReferenceExpression> {
    public VBInlinedTypeOwnerInitializerTransformer(ITreeNode expression, InlineTypeOwnerInitializerCallInfo inlinedCallInfo, CallSiteContext context);
    protected virtual void TransformElement(ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.VB.Inline.CodeTransformers.VBInlineMethodCodeTransformer : InlineMethodCodeTransformerBase`2<IReferenceExpression, IReturnStatement> {
    private VBElementFactory myFactory;
    public VBInlineMethodCodeTransformer(ITreeNode expression, InlineMethodCallInfo inlinedCallInfo, CallSiteContext context);
    protected virtual void TransformElement(ITreeNode element);
    protected virtual ITreeNode AddActionReplaceReturnWithAssignmentToTemp(IReturnStatement returnStatement);
    protected virtual ITreeNode ReplaceReturnWithAssignment(IReturnStatement returnStatement);
    protected virtual ITreeNode AddActionReplaceExpressionWithAssignedExpression(IReferenceExpression expression);
    protected virtual ITreeNode AddActionRemoveReturn(IReturnStatement returnStatement);
    protected virtual bool IsSetterParameter(IParameter parameter);
    protected virtual bool IsExtensionMethod(IReferenceExpression expression);
    protected virtual ITreeNode ReplaceByQualifier(IReferenceExpression expression, InlineMethodCallInfo info);
}
public class JetBrains.ReSharper.Refactorings.VB.Inline.CodeTransformers.VBIntroduceParameterCodeTransformer : IntroduceParameterCodeTransformerBase`1<IReferenceExpression> {
    public VBIntroduceParameterCodeTransformer(ITreeNode expression, IntroduceParameterInlineCallInfo inlinedCallInfo, CallSiteContext context);
    protected virtual void TransformElement(ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.VB.Inline.ReturnProblemAnalyser : object {
    public static bool AllReturnStatementsAreLast(IBlock block);
    private static void AllReturnStatementsAreLast(IVBStatement statement, bool isLast, bool inLoop);
    private static void AllReturnStatementsAreLast(IBlock block, bool isLast, bool inLoop);
    private static void AllReturnStatementsAreLast(IList`1<IVBStatement> statements, bool isLast, bool inLoop);
}
public class JetBrains.ReSharper.Refactorings.VB.Inline.ThisReferenceCounter : object {
    private List`1<IExpression> myReferences;
    public bool HasOneReference { get; }
    public bool HasReferences { get; }
    public bool ProcessingIsFinished { get; }
    public int ReferencesCount { get; }
    public IReadOnlyList`1<IExpression> References { get; }
    public ThisReferenceCounter(ITreeNode element);
    public bool get_HasOneReference();
    public bool get_HasReferences();
    public sealed virtual override bool get_ProcessingIsFinished();
    public int get_ReferencesCount();
    public IReadOnlyList`1<IExpression> get_References();
    public sealed virtual override void ProcessBeforeInterior(ITreeNode element);
    public sealed virtual override void ProcessAfterInterior(ITreeNode element);
    public sealed virtual override bool InteriorShouldBeProcessed(ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.VB.Inline.VBInlineHelper : InlineHelper {
    public VBInlineHelper(IRefactoringDriver driver);
    public virtual ITreeNode GetContainingStatement(ITreeNode element);
    public virtual void ReplaceTypeParameter(IReference reference, ITypeParameter parameter, ISubstitution substitution);
    public virtual void RemoveCastFromElement(ITreeNode element);
    public virtual IDeclaredElement InsertTempForArgument(IParameter parameter, InlinedArgumentInfo argumentInfo, IReference reference, CallSiteContext context, ReferenceIdentitySaver saver, ArgumentFromParameter argumentFromParameter);
    public virtual IDeclaredElement InsertTempForQualifier(IExpression qualifierExpression, IReference reference, CallSiteContext context, ReferenceIdentitySaver saver, ReferenceKind referenceKind);
    public virtual IDeclaredElement InsertTempVariableForAssignedValue(IExpression assignedExpression, IReference reference, CallSiteContext context, ReferenceIdentitySaver referenceIdentitySaver);
    public virtual IDeclaredElement SplitDeclarationAndInitializer(IDeclaredElement declaredElement);
    public virtual IDeclaredElement InsertReturnValueTempVariable(InlineMethodCallInfo inlineMethodCallInfo, IType returnType, IReference reference, CallSiteContext context);
    public virtual Dictionary`2<IParameter, ArgumentFromParameter> GetParameter2Argument(IReference reference, IParametersOwner parametersOwner);
    public virtual Dictionary`2<ArgumentFromParameter, InlinedArgumentInfo> GetArgument2Infos(IReference reference, Dictionary`2<IParameter, ArgumentFromParameter> parameter2argument, Dictionary`2<int, IParameter> inlinedMethodParameterInfos);
    public virtual bool CanHaveSideEffects(IExpression expression);
    public virtual bool CanHaveSideEffects(IArgument argument);
    public virtual IExpression GetQualifierExpression(IReference reference);
    public virtual IEnumerable`1<IReference> AllNotQualifiableReferences(IReference reference);
    public virtual IArgumentsOwner GetArgumentOwner(IReference& reference, bool replaceMethodGroup);
    public static IBlock EnBlock(IReference reference, IVBStatement& tag, ReferenceIdentitySaver parentSaver);
    public static IVBExpression GetArgumentValue(IArgument arguemnt);
    public static ILocalDeclarationStatement CreateVariableDeclarationStatement(IVBExpression newExpression, ITreeNode contextNode, String& name, string suggestName, IExpressionType expressionType, CallSiteContext context);
    private static IVBStatement MultiLineIf(ILineIfStatement lineIf, VBElementFactory factory);
    public static IVBExpression GetInvokedElement(IReference reference);
}
public class JetBrains.ReSharper.Refactorings.VB.Inline.VBInlineMethod : InlineMethod {
    private InlineHelper myInlineHelper;
    public InlineHelper InlineHelper { get; }
    public VBInlineMethod(InlineMethodWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual bool ReplaceStatement(IReference& reference, ITreeNode elementOfStatements, InlineMethodCallInfo inlinedCallInfo, CallSiteContext context, bool replaceOriginal);
    public virtual bool IsFromExpressionBody(IReference reference);
    public virtual bool ReplaceCall(IReference reference, ITreeNode returnedExpression, InlineMethodCallInfo inlinedCallInfo, CallSiteContext context);
    private void RemoveOriginalExpression(InlineMethodCallInfo inlinedCallInfo, IVBExpression expressionToReplace);
    public virtual bool IsReturnStatementOnly(IDeclaredElement element, IExpression& returnedExpression, ITreeNode& blockOfStatements);
    public virtual void ReplaceConditionalAccess(IReference& reference, InlineMethodCallInfo inlinedCallInfo, CallSiteContext context);
    public virtual bool IsReturned(IReference reference, InlinedElementKinds inlinedElementKind);
    public virtual bool IsLastStatement(IReference reference);
    public virtual bool IsLastStatementInScope(IReference reference);
    public virtual AssignmentInfo FindContainingAssignment(InlinedElementKinds inlinedElementKind, IReference reference);
    public virtual bool CanIntroduceStatementsBefore(IReference reference);
    public virtual InlineHelper get_InlineHelper();
    public virtual bool GetUsedAsDelegate(InlinedMethodInfo info, IReference reference);
    public virtual IReadOnlyList`1<IExpression> GetExpressionsReferencingThis(ITreeNode methodBody);
    public virtual bool GetIsDestinationOfAssignment(IReference reference, IExpression& assignmentSource);
    public virtual bool AllReturnsAreLast(IDeclaredElement element);
    private ITreeNode PatchElement(ITreeNode element, InlineMethodCallInfo info, ISubstitution substitution, CallSiteContext context);
    private static bool CanBeUnderExpressionStatement(IVBExpression expression);
    private static bool IsReturnStatementOnly(IBlock body, IExpression& returnedExpression, ITreeNode& blockOfStatements);
    private IBlock GetBlock(IDeclaredElement element);
    public virtual bool IsSetterParameter(IParameter parameter);
    public static bool IsSetterParameterShared(IParameter parameter);
    public virtual ITreeNode GetBody(IDeclaredElement element);
    public virtual bool IsCollectionInitializer(IReference reference);
    public virtual bool IsDeconstruction(IReference reference);
    public virtual IType FindRealReturnType(IParametersOwner parametersOwner, ITreeNode context);
    public virtual InlinedReferenceContext InspectReferenceContext(ITreeNode treeNode);
    private bool ExpressionIsInTryFinallyBlock(ITreeNode treeNode);
}
public class JetBrains.ReSharper.Refactorings.VB.InlineClass.VBInlineClassAnalyzer : InlineClassAnalyzer {
    public VBInlineClassAnalyzer(InlineClassWorkflow inlineClassWorkflow, ITypeOwner element, ITypeElement owner);
    protected virtual void AddMemberInfo(ITypeMember member);
    private IDeclaredElement GetBackingProperty(ITypeMember typeMember);
    private IDeclaredElement GetDelegationMethod(ITypeMember typeMember);
    private IDeclaredElement GetMethod(IMethodDeclaration methodDeclaration);
    private IDeclaredElement GetProperty(ITypeMember typeMember);
    private ITypeMember GetBackingElement(IPropertyDeclaration propertyDeclaration);
    public virtual void Analyze();
    private void AnalyzeUsages(MemberInfo memberInfo);
    protected virtual void FillTargetTypeElements();
    protected virtual void InitializeMembers(ITypeOwner member, ITypeElement owner);
    [CompilerGeneratedAttribute]
private bool _Lambda$__8-0(IReference reference);
}
public class JetBrains.ReSharper.Refactorings.VB.InlineClass.VbInlineClassHelper : InlineClassHelper {
    public virtual InlineClassAnalyzer GetAnalyzer(InlineClassWorkflow inlineClassWorkflow, ITypeOwner element, ITypeElement owner);
}
public class JetBrains.ReSharper.Refactorings.VB.InlineClass.VBInlineClassRefactoringExec : object {
    private IRefactoringDriver myRefactoringDriver;
    [CompilerGeneratedAttribute]
private InlineClassWorkflow _Workflow;
    [CompilerGeneratedAttribute]
private IPsiModule _PsiModule;
    [CompilerGeneratedAttribute]
private ResolveImagesRepository _Repository;
    protected InlineClassWorkflow Workflow { get; protected set; }
    protected IPsiModule PsiModule { get; protected set; }
    protected ResolveImagesRepository Repository { get; protected set; }
    unknown IRefactoringDriver RefactoringDriver {public set; }
    public VBInlineClassRefactoringExec(InlineClassWorkflow myWorkflow);
    [CompilerGeneratedAttribute]
protected InlineClassWorkflow get_Workflow();
    [CompilerGeneratedAttribute]
protected void set_Workflow(InlineClassWorkflow AutoPropertyValue);
    [CompilerGeneratedAttribute]
protected IPsiModule get_PsiModule();
    [CompilerGeneratedAttribute]
protected void set_PsiModule(IPsiModule AutoPropertyValue);
    [CompilerGeneratedAttribute]
protected ResolveImagesRepository get_Repository();
    [CompilerGeneratedAttribute]
protected void set_Repository(ResolveImagesRepository AutoPropertyValue);
    public sealed virtual override void CutAndPaste(IProgressIndicator subPi);
    public sealed virtual override void Rebind(IProgressIndicator subPi);
    private void ProceedConstructor(Dictionary`2<IParameterDeclaration, IArgument> parameters2Arguments, IConstructorDeclaration ctor);
    private void RemoveUnusedElements();
    private IVBTypeMemberDeclaration GetClassMemberDeclaration(ITypeOwner declaredelement);
    private void ProceedDelegation(MemberInfo member);
    private void RebindTargetElementMemberUsage();
    private void ProceedTargetObjectCreation(IAssignmentStatement assignmentStatement);
    private void RebindSourceClassReferencesInsideTargetClass();
    private void RebindTargetMembersEverywhere();
    private void RebindTargetMembersInsideSourceClass();
    public sealed virtual override void set_RefactoringDriver(IRefactoringDriver value);
    [CompilerGeneratedAttribute]
private IResolveImagesLanguageSupport _Lambda$__1-0(PsiLanguageType x);
    [CompilerGeneratedAttribute]
private bool _Lambda$__24-0(MemberInfo toRebind);
}
public class JetBrains.ReSharper.Refactorings.VB.InlineField.InlineFieldInspectionContextFactory : object {
    public InlineFieldInspectionContext InitialContext { get; }
    public sealed virtual override InlineFieldInspectionContext get_InitialContext();
    public sealed virtual override InlineFieldInspectionContext CloneContext(InlineFieldInspectionContext context);
    public sealed virtual override InlineFieldInspectionContext Merge(IList`1<InlineFieldInspectionContext> contexts);
}
public class JetBrains.ReSharper.Refactorings.VB.InlineField.VBInlineField : InlineFieldBase {
    private VBInlineHelper myInlineHelper;
    public InlineHelper InlineHelper { get; }
    public VBInlineField(InlineFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual bool CanInlineReference(IReference reference);
    public virtual bool GetCanUseRefOut(IExpression expression);
    public virtual IExpression GetInitializerExpression(IField field);
    public virtual IExpression GetInitializerExpression(IReference reference);
    public virtual InlineHelper get_InlineHelper();
    public virtual void ProcessReferenceWithContext(IReference reference, CallSiteContext context, InlineTypeOwnerInitializerCallInfo info);
    public virtual void RemoveAssignment(IReference reference);
    public virtual void RemoveField(IDeclaration declaration);
    public virtual bool ThisIsUsed(IExpression expression);
    public static bool IsInitializationOfField(IReference reference, IField field, IExpression& initializer);
    public virtual bool HasSideEffects(IExpression expression);
    public virtual string InsertTempVariable(ITreeNode tag, string name, IExpression expression);
    public virtual void ReplaceExpression(IReference reference, string localName);
}
public class JetBrains.ReSharper.Refactorings.VB.InlineField.VBInlineFieldInspector : RDInspectorOfVariable`1<InlineFieldInspectionContext> {
    private InlineFieldRefactoring myExecuter;
    public VBInlineFieldInspector(ControlFlowGraph controlFlowGraph, InlineFieldRefactoring executer);
    protected virtual bool CustomInspection(IControlFlowElement controlFlowElement, InlineFieldInspectionContext context, ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.VB.InlineVar.InlineVarContextFactory : object {
    public InlineVarContext InitialContext { get; }
    public sealed virtual override InlineVarContext get_InitialContext();
    public sealed virtual override InlineVarContext CloneContext(InlineVarContext context);
    public sealed virtual override InlineVarContext Merge(IList`1<InlineVarContext> contexts);
}
public class JetBrains.ReSharper.Refactorings.VB.InlineVar.VBInlineVar : InlineVarBase {
    private VBInlineHelper myInlineHelper;
    public InlineHelper InlineHelper { get; }
    public VBInlineVar(InlineVarWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineHelper get_InlineHelper();
    public virtual void ProcessReferenceWithContext(IReference reference, CallSiteContext context, InlineTypeOwnerInitializerCallInfo info);
    public virtual void RemoveAssignment(ITreeNode expression);
    public virtual void RemoveVariableDeclaration(IDeclaration declaration);
}
public class JetBrains.ReSharper.Refactorings.VB.InlineVar.VBInlineVarAnalyser : InlineVarAnalyserBase {
    private bool myInlineAll;
    private IAssignmentStatement myAssignmentExpression;
    private IExpression myExpression;
    private IExpression myExpressionInitializer;
    private IVBExpression myInitialiler;
    private List`1<IReference> myReferences;
    public ITreeNode AssignmentExpression { get; }
    public ITreeNode Expression { get; }
    public bool InlineAll { get; public set; }
    public List`1<IReference> References { get; }
    public VBInlineVarAnalyser(InlineVarWorkflow workflow);
    public virtual Pair`2<bool, string> Run(IDeclaredElement variable, ITreeNode element, IList`1<IReference> foundReferences);
    public IVBControlFlowGraph GetControlFlowGraph(ITreeNode element);
    public virtual ITreeNode get_AssignmentExpression();
    public virtual ITreeNode get_Expression();
    public virtual bool get_InlineAll();
    public virtual void set_InlineAll(bool value);
    public virtual List`1<IReference> get_References();
}
public class JetBrains.ReSharper.Refactorings.VB.InlineVar.VBInlineVarInspector : RDInspectorOfVariable`1<InlineVarContext> {
    private IAssignmentStatement myAssignmentStatement;
    public VBInlineVarInspector(ControlFlowGraph controlFlowGraph, ITypeOwner element, IAssignmentStatement assignmentStatement);
    protected virtual bool CustomInspection(IControlFlowElement controlFlowElement, InlineVarContext context, ITreeNode element);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Refactorings.VB.InplaceRefactorings.VBExtensionMethodOnPasteProvider : ExtensionMethodImportOnPasteProviderBase {
    protected virtual bool IsYourReference(IReference reference);
    protected virtual ExtensionMethodReferenceData CreateReferenceData(string referenceName, IMethod targetExtensionMethod);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
internal class JetBrains.ReSharper.Refactorings.VB.InplaceRefactorings.VbInplaceChangeSignatureHelper : object {
    public sealed virtual override TreeTextRange GetSignatureRange(IDeclaration declaration);
    public sealed virtual override TreeTextRange GetParameterListRange(IDeclaration declaration);
    public sealed virtual override bool IsValidConstructorName(ITypeMemberDeclaration constructorDeclaration, ITypeElement containingType);
    public sealed virtual override string IsValidParametersOwner(IDeclaration initialDeclaration, string text);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
internal class JetBrains.ReSharper.Refactorings.VB.InplaceRefactorings.VBInplaceMoveStaticMembersHelper : object {
    public sealed virtual override ITypeMemberDeclaration AddMemberDeclaration(ITypeDeclaration typeDeclaration, ITypeMemberDeclaration memberDeclaration);
    public sealed virtual override ITypeMemberDeclaration ReplaceMemberDeclaration(ITypeMemberDeclaration oldDeclaration, ITypeMemberDeclaration newDeclaration);
    public sealed virtual override void DeleteMemberDeclaration(ITypeMemberDeclaration memberDeclaration);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
internal class JetBrains.ReSharper.Refactorings.VB.InplaceRefactorings.VBInplaceRefactoringsLanguageSpecifics : object {
    public IVisualizationModelLanguageHelper VisualizationModelLanguageHelper { get; }
    public sealed virtual override IVisualizationModelLanguageHelper get_VisualizationModelLanguageHelper();
    public sealed virtual override IEnumerable`1<DocumentRange> UsingListRanges(IFile file);
    public sealed virtual override SignatureKind GetSignatureKind(IDeclaration declaration);
    public sealed virtual override bool IsInplaceRenameAvailable(IDeclaredElement declaredElement);
}
internal class JetBrains.ReSharper.Refactorings.VB.InplaceRefactorings.VBVisualizationModelLanguageHelper : object {
    public static VBVisualizationModelLanguageHelper Instance;
    public bool ParameterTypeBeforeName { get; }
    public string ParameterTypeAndNameSeparator { get; }
    public bool ReturnTypeFirst { get; }
    public string ReturnTypeSeparator { get; }
    public bool SkipVoidReturnType { get; }
    public bool SkipEmptyParameterList { get; }
    private static VBVisualizationModelLanguageHelper();
    public sealed virtual override string StartKeyword(SignatureData signature);
    public sealed virtual override bool get_ParameterTypeBeforeName();
    public sealed virtual override string get_ParameterTypeAndNameSeparator();
    public sealed virtual override string ParameterModifierText(ParameterKind kind, bool isParams, bool isVarArg, bool isThis);
    public sealed virtual override bool get_ReturnTypeFirst();
    public sealed virtual override string get_ReturnTypeSeparator();
    public sealed virtual override bool get_SkipVoidReturnType();
    public sealed virtual override bool get_SkipEmptyParameterList();
}
public class JetBrains.ReSharper.Refactorings.VB.IntroducePartOfString.IntroducePartOfStringRefactoring : IntroduceLocalRefactoring {
    private IntroducePartOfStringWorkflow NewWorkflow { get; }
    protected string CanNotPerformActionText { get; }
    public IntroducePartOfStringRefactoring(IntroduceLocalWorkflowBase workflow, ISolution solution, IRefactoringDriver driver);
    private IntroducePartOfStringWorkflow get_NewWorkflow();
    protected virtual IntroduceVariableResult Execute();
    private ITreeNode TransformSubstring(IVBLiteralExpression literalExpression, TreeTextRange range);
    private bool IsFormattingMethodCall(IMethod method, IList`1<IVBArgument> arguments, IPositionalArgument argument);
    protected virtual string get_CanNotPerformActionText();
}
public class JetBrains.ReSharper.Refactorings.VB.IntroducePartOfString.IntroducePartOfStringWorkflow : IntroduceLocalWorkflowBase {
    private TreeTextRange mySelectionTreeRange;
    private IVBLiteralExpression myOwnerExpression;
    public TreeTextRange SelectionTreeRange { get; }
    public IVBLiteralExpression OwnerExpression { get; }
    public string Title { get; }
    public IntroducePartOfStringWorkflow(ISolution solution, string aid);
    public TreeTextRange get_SelectionTreeRange();
    public IVBLiteralExpression get_OwnerExpression();
    public virtual IRefactoringExecuter CreateRefactoring(IRefactoringDriver driver);
    public virtual bool IsAvailable(IDataContext context);
    public virtual bool Initialize(IDataContext context);
    public virtual string get_Title();
}
[RefactoringWorkflowProviderAttribute("16")]
internal class JetBrains.ReSharper.Refactorings.VB.IntroducePartOfString.IntroducePartOfStringWorkflowProvider : object {
    public sealed virtual override IEnumerable`1<IRefactoringWorkflow> CreateWorkflow(IDataContext dataContext);
}
public class JetBrains.ReSharper.Refactorings.VB.IntroduceVariable.VBIntroduceVariable : IntroduceVariableBase {
    public VBIntroduceVariable(IntroduceLocalWorkflowBase workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IntroduceVariableResult Process(IntroduceVariableData introduceVariableData);
}
public class JetBrains.ReSharper.Refactorings.VB.IntroduceVariable.VBIntroduceVariableHelper : IntroduceVariableHelper {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual bool CheckAvailability(ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.VB.IntroduceVariable.VBIntroduceVariableResult : IntroduceVariableResult {
    [CompilerGeneratedAttribute]
private ITreeNodePointer`1<ILocalDeclarationStatement> _InsertedStatementPointer;
    public ITreeNodePointer`1<ILocalDeclarationStatement> InsertedStatementPointer { get; public set; }
    public VBIntroduceVariableResult(HotspotsRegistry hotspotsRegistry, ITreeNodePointer`1<ITreeNode> caretTargetPointer, ITreeNodePointer`1<ILocalDeclarationStatement> insertedStatementPointer);
    [CompilerGeneratedAttribute]
public ITreeNodePointer`1<ILocalDeclarationStatement> get_InsertedStatementPointer();
    [CompilerGeneratedAttribute]
public void set_InsertedStatementPointer(ITreeNodePointer`1<ILocalDeclarationStatement> AutoPropertyValue);
}
public class JetBrains.ReSharper.Refactorings.VB.IntroduceVariable.VBIntroduceVariableUtil : object {
    public static VBIntroduceVariableResult IntroduceVariable(IList`1<ITreeNode> expressions, ITreeNode sourceExpression, bool preferImplicit);
    private static bool RemoveStatement(IBlock block, IVBStatement containingStatement);
}
public class JetBrains.ReSharper.Refactorings.VB.IntroField.VBIntroField : IntroduceFieldBase {
    private IntroFieldData myDataModel;
    public VBIntroField(IntroduceFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void AddAssignment(IParameter parameter, ITypeMember member, IExpression expression);
    public virtual bool ReplaceUsages(IList`1<ITreeNode> expressions, ITypeMember field, ITreeNode initializer);
    public virtual bool ReplaceVariableDeclaration(ILocalVariable variable, ITypeMember field, IExpression initializer);
    public virtual IExpression GetInitializer(ILocalVariable variable);
    public virtual ITypeMember AddField(ITypeDeclaration typeDeclaration, IExpression initExpression, IList`1<ITreeNode> tags, object type);
}
public class JetBrains.ReSharper.Refactorings.VB.IntroField.VBIntroFieldAnalyser : IntroduceFieldAnalyser {
    public virtual bool IsFromConstructor(ILocalVariable variable, bool isStatic);
    public virtual bool IsFromConstructor(ITreeNode element, bool isStatic);
    public virtual ITreeNode GetInitializer(ILocalVariable variable);
    public virtual bool CanBeConstant(ILocalVariable variable);
    public virtual ITreeNode GetBody(IDeclaration declaration);
    public static ITreeNode GetBodyOfDeclaration(IDeclaration decl);
}
public class JetBrains.ReSharper.Refactorings.VB.IntroParameter.VBIntroParameter : IntroduceParameterBase {
    private InlineHelper myInlineHelper;
    private IntroduceParameterDataModel myDataModel;
    public InlineHelper InlineHelper { get; }
    public VBIntroParameter(IntroduceParameterWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineHelper get_InlineHelper();
    public virtual bool ThisIsUsed(ITreeNode expression);
    public virtual void ReplaceExpression(ITreeNode element);
    private IVBExpression CreateNewParameterExpression(IPsiModule psiModule);
    public int inc(Int32& he);
    public virtual void FixOtherArguments(IReference reference, Dictionary`2<int, InlinedArgumentInfo> inlinedArgumentInfos);
    public virtual void CallInline(IReference reference, CallSiteContext context, IntroduceParameterInlineCallInfo info, IList`1<string> lambdaParameterNames, int index);
    public virtual void AddParameter(IType type, string name, IDeclaration declaration, ISubstitution substitution, ITreeNode defaultValue);
    private IRegularParameterDeclaration CreateParameterDeclaration(VBElementFactory factory, IType type, string name, IPsiModule psiModule, ISubstitution substitution);
    public virtual IReference AddBaseClause(IDeclaredElement element);
    public virtual void RemoveLocalVariable(ILocalVariable variable);
    public virtual void RemoveArguments(IReference reference, IList`1<DeclaredElementNode> parametersToRemove);
}
public class JetBrains.ReSharper.Refactorings.VB.IntroParameter.VBIntroParameterUtil : object {
    public static void FixArguments(IReference reference, Dictionary`2<int, InlinedArgumentInfo> inlinedArgumentInfos);
    public static void RemoveArguments(IReference reference, IList`1<DeclaredElementNode> parametersToRemove);
}
public class JetBrains.ReSharper.Refactorings.VB.InvertBool.VbInvertBoolHelper : InvertBoolHelper {
    public virtual bool IsAvailable(IDeclaration declaration);
    public virtual void ProcessDeclaration(IDeclaration declaration, InvertBoolDataModel model);
    public virtual bool ProcessReference(IReference reference);
    private IVBExpression CreateLogicallyNegatedExpression(IVBExpression vbExpression);
    public bool ProcessWriteReference(ITreeNode treeNode, IDeclaredElement declaredElement);
    private bool ProcessAssignmentExpression(IAssignmentStatement getByLValue, IDeclaredElement declaredElement);
    public bool ProcessReadReference(ITreeNode treeNode, IDeclaredElement element);
    public bool ProcessReadWriteReference(ITreeNode treeNode, IDeclaredElement declaredElement);
}
public class JetBrains.ReSharper.Refactorings.VB.JetBrains.ReSharper.Refactorings.VB.InlineParameter.VBInlineParameter : InlineParameterBase {
    private InlineHelper myInlineHelper;
    public InlineHelper InlineHelper { get; }
    public VBInlineParameter(InlineParameterWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineHelper get_InlineHelper();
    public virtual void ReplaceDeclarations(IParametersOwner parametersOwner);
    public virtual IExpression ReplaceWithThis(IExpression expression);
    public virtual void RemoveArguments(IArgumentsOwner owner, List`1<IArgument> arguments);
    public virtual void ReplaceBody(CallSiteContext context, InlinedParameterCallSiteInfo info, IParametersOwner owner, ITreeNode body, InlineParameterEngine engine);
    private void ReplaceDeclarations(IEnumerable`1<IDeclaration> declarations);
    public virtual IParametersOwnerDeclaration CreateNewDeclaration(IParametersOwner owner);
    public virtual IParameter AddParameter(IDeclaration declaration, IParameter parameter);
    protected virtual IArgumentsOwner CreateCallToMethod(IMethod method);
    protected virtual IArgumentsOwner CreateCallToConstructor(IConstructor constructor);
    public virtual void AddArgumentFromParameter(IArgumentsOwner argumentsOwner, IParameter parameter, ParameterKind kind);
    public virtual IExpression ReplaceExpression(T expression, string name);
    public virtual void AddArgumentFromExpression(IArgumentsOwner argumentsOwner, IExpression expression);
    public virtual IParametersOwnerDeclaration AddDeclarationToFile(IParametersOwnerDeclaration newParametersOwnerDeclaration, IParametersOwner parametersOwner);
    public virtual IArgument CreateArgument(ITreeNode expression);
    public virtual void ReplaceArguments(IArgumentsOwner owner, List`1<IArgument> arguments);
    public virtual void AddArgument(IArgumentsOwner owner, IArgument copy);
    private static T InlineAssignHelper(T& target, T value);
}
public class JetBrains.ReSharper.Refactorings.VB.JetBrains.ReSharper.Refactorings.VB.InlineParameter.VbInlineParameterHelper : InlineParameterHelper {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual IParametersOwner GetCalledMember(IArgumentsOwner owner);
    public virtual IExpression GetQualifier(IArgumentsOwner owner, Boolean& hasThisQualifier);
    public virtual ITreeNode GetContextOfParameterOwner(IParametersOwner owner);
    public virtual IExpression GetArgumentValue(IArgument argument);
    public virtual IReference GetReference(IArgumentsOwner argumentsOwner);
    public virtual ITreeNode ReplaceThisReferences(ITreeNode element, IDeclaredType type, ReferenceIdentitySaver saver, Key`1<string> key, Boolean& hasUnresolvedThis, bool hasThisQualifier);
    public virtual IExpression CreateThisExpression(IPsiModule project);
    public virtual IExpression GetInvocation(ITreeNode element);
    public virtual ITreeNode Qualify(ITreeNode element, string name, IEnumerable`1<ParameterOwnerUsageUpdater> updaters, SuggestedParameterNode thisSuggestion);
    private static bool MatchQualifier(IExpression expression, Action`1<IExpression> update);
    public virtual bool IsThisExpression(IArgument argument);
    public virtual IArgumentsOwner CopyArgumentsOwner(IArgumentsOwner owner);
    public virtual bool IsAnonymousMethod(IParametersOwner parametersOwner);
}
[ShellFeaturePartAttribute("16")]
public class JetBrains.ReSharper.Refactorings.VB.JetBrains.ReSharper.Refactorings.VB.Rename.VBAnonymousPropertyRenamesFactory : AtomicRenamesFactory {
    public virtual bool IsApplicable(IDeclaredElement declaredElement);
    public virtual IEnumerable`1<AtomicRenameBase> CreateAtomicRenames(IDeclaredElement declaredElement, string newName, bool doNotAddBindingConflicts);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.VB.JetBrains.ReSharper.Refactorings.VB.Rename.VBRenameHelper : RenameHelperBase {
    public bool IsLanguageSupported { get; }
    public virtual void AdditionalReferenceProcessing(IDeclaredElement newTarget, IReference reference, ICollection`1<IReference> newReferences);
    public virtual CustomRenameModel GetOptionsModel(IDeclaredElement primaryDeclaredElement, IReference reference, Lifetime lifetime);
    public virtual IList`1<IConflictSearcher> AdditionalConflictsSearchers(IDeclaredElement element, string newName);
    public virtual IReference TransformProjectedInitializer(IReference reference);
    public virtual void JoinTransformAnonymous(IReference reference);
    public virtual bool get_IsLanguageSupported();
    public virtual IReference BindReference(IReference reference, IDeclaredElement declaredElement, ISubstitution substSubstitution);
    public virtual bool IsLocalRename(IDeclaredElement primevalDeclaredElement);
    public virtual IReference BindReferenceToNamespace(IReference reference, INamespace ns);
    public virtual bool RenameInReferencesInThisLanguageFirst(PsiLanguageType psiLanguageType);
    public virtual SuspiciousReferencesSearchProcessor CreateSuspiciousReferenceSearchProcessor(ITreeNode root, SuspiciousReferenceSearchContext context);
}
[ShellFeaturePartAttribute("16")]
public class JetBrains.ReSharper.Refactorings.VB.JetBrains.ReSharper.Refactorings.VB.Rename.VBSpecificElementsRenamesFactory : AtomicRenamesFactory {
    public virtual bool IsApplicable(IDeclaredElement element);
    public virtual RenameAvailabilityCheckResult CheckRenameAvailability(IDeclaredElement element);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
internal class JetBrains.ReSharper.Refactorings.VB.MethodAccessChecker : AccessRightsChecker {
    protected virtual IAccessContext BuildAccessContext(IReference reference, ITypeElement targetType, ITypeMember& accessedElement, AccessRights accessRights);
}
internal class JetBrains.ReSharper.Refactorings.VB.MoveInstanceMethod.VbMoveInstanceMethodHelper : MoveInstanceMethodHelper {
    private MoveInstanceMethodWorkflow myWorkflow;
    private IParameter myThisParameter;
    public bool IsLanguageSupported { get; }
    public VbMoveInstanceMethodHelper(MoveInstanceMethodWorkflow workflow);
    public virtual bool get_IsLanguageSupported();
    public virtual MoveInstanceMethodModel GetModel(MoveInstanceMethodWorkflow moveInstanceMethodWorkflow, IMethod method, Lifetime lifetime);
    public virtual void Rebind(IProgressIndicator pi, MoveInstanceMethodDataModel model);
    public virtual void AddSourceElementParameter(MoveInstanceMethodDataModel model);
    public virtual void AddAdditionalElements(MoveInstanceMethodDataModel model);
    public virtual void ReplaceWithDelegation(IProgressIndicator pi, MoveInstanceMethodDataModel model);
    private bool AddQualifier(IReference reference, VBElementFactory factory, IExpression newQualifier, bool resetQualifier, MoveInstanceMethodDataModel model);
    public IPropertyDeclaration CreatePropertyDeclaration(ITypeDeclaration sourceTypeDeclaration, IType type, IVariableDeclaration fieldDeclaration);
}
internal class JetBrains.ReSharper.Refactorings.VB.MoveInstanceMethod.VbMoveInstanceMethodModel : MoveInstanceMethodModel {
    public VbMoveInstanceMethodModel(IMethod method, Lifetime lifetime);
    public virtual bool AnalyzeDeclaration();
    [CompilerGeneratedAttribute]
private bool _Lambda$__1-1(ITypeDeclaration typeDecl);
}
public class JetBrains.ReSharper.Refactorings.VB.MoveMembers.VBExtractInterface : VBExtractInterfaceBase {
    public VBExtractInterface(ISolution solution, IRefactoringDriver driver);
    public virtual bool IsInstanceSpecificEventAccess(IReference reference);
    public virtual MoveMembersHelper GetHelper();
}
public class JetBrains.ReSharper.Refactorings.VB.MoveMembers.VBExtractSuperclass : VBExtractSuperclassBase {
    public VBExtractSuperclass(ISolution solution, IRefactoringDriver driver);
    public virtual bool IsInstanceSpecificEventAccess(IReference reference);
    public virtual MoveMembersHelper GetHelper();
}
public class JetBrains.ReSharper.Refactorings.VB.MoveMembers.VBMoveMembersHelper : MoveMembersHelper {
    public VBMoveMembersHelper(IMoveMembersExecuter executer);
    public virtual IList`1<Pair`2<DeclaredElementNode, IDeclaration>> CutDeclarations(IEnumerable`1<DeclaredElementNode> memberInfos, SubProgressIndicator pi);
    public virtual ITypeDeclaration CreateTargetTypeElement(string name, ITypeElement sourceType, List`1<ITypeParameter> parameters, bool createBaseType, bool preserveAccessRights);
    public virtual void PasteDeclarations(IList`1<Pair`2<DeclaredElementNode, IDeclaration>> declarations, ITypeElement targetType, IProjectFile projectFile, ITypeDeclaration targetTypeDeclaration, SubProgressIndicator pi);
    public virtual void MakeTypeElementAbstract(ITypeElement element);
    public virtual void RemoveDeclaration(ITypeMember member);
    public virtual void MakeOverride(ITypeMember member);
    public virtual ITypeDeclaration InsertSibling(ITypeDeclaration decl, ITypeDeclaration sourceClass);
    public virtual ITypeDeclaration InsertToNewFile(ITypeDeclaration decl, ITypeDeclaration sourceClass, string ns, IProjectFile fileNearby);
    public virtual void SetSuperclass(ITypeDeclaration sourceTypeDeclaration, ITypeElement newSuperTypeElement, ISubstitution substitution);
    public virtual void AddBaseInterface(ITypeElement element, IDeclaredType info);
    public virtual bool TryProcessMultiFieldForResolve(IRecursiveElementProcessor collector, IDeclaration declaration);
    public virtual void CheckConstructorReferenceConflict(IReference reference);
    public virtual void AddImplementsSpecification(IDeclaration decl, ITypeElement element, bool nameIsItem, IRefactoringDriver driver);
    public virtual void RemoveSuperType(ITypeDeclaration typeDeclaration, IDeclaredType type);
    public virtual IConstructor GetBaseConstructorDeclarationToInsert(IDeclaration declaration);
    public virtual void GenerateConstructors(ITypeElement targetType, ITypeDeclaration typeDeclaration, IDeclaredElementPointer`1<IConstructor> baseConstructor);
}
public class JetBrains.ReSharper.Refactorings.VB.MoveMembers.VBPullUp : VBPullUpBase {
    public VBPullUp(ISolution solution, IRefactoringDriver driver);
    public virtual bool IsInstanceSpecificEventAccess(IReference reference);
    public virtual MoveMembersHelper GetHelper();
}
public class JetBrains.ReSharper.Refactorings.VB.MoveMembers.VBPushDown : PushDownBase {
    public VBPushDown(ISolution solution, IRefactoringDriver driver);
    public virtual bool CheckConflictsWithTargetClassName(ITypeElement element, string name);
    public virtual bool IsInstanceSpecificEventAccess(IReference reference);
    public virtual MoveMembersHelper GetHelper();
}
public class JetBrains.ReSharper.Refactorings.VB.MoveTypeToOuterScope.VBMoveTypeToOuterScope : MoveTypeToOuterScopeBase`2<IVBNestedTypeDeclaration, IClassLikeDeclaration> {
    internal VBMoveTypeToOuterScope(MoveTypeToOuterScopeRefactoring refactoring);
    protected virtual AccessRights GetAccessRights(IVBNestedTypeDeclaration typeDeclaration);
    protected virtual AccessRights GetAccessRights(IClassLikeDeclaration typeDeclaration);
    protected virtual IClassLikeDeclaration GetContainingTypeDeclaration(IVBNestedTypeDeclaration declaration);
    protected virtual IVBNestedTypeDeclaration CutDeclaration(IVBNestedTypeDeclaration declaration);
    protected virtual IVBNestedTypeDeclaration PasteDeclaration(IVBNestedTypeDeclaration declarationCopy, IClassLikeDeclaration containingDeclaration);
    protected virtual void SetAccessRights(IVBNestedTypeDeclaration typeDeclaration, AccessRights accessRights);
}
public class JetBrains.ReSharper.Refactorings.VB.ParamsModifier.VBParamsModifier : ParamsModifierConvertBase {
    public VBParamsModifier(ParamsModifierWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void ExecuteDeclarationRefactoring(IDeclaredElement declaredElement, IProgressIndicator progressIndicator);
    public virtual void ExecuteReferencesRefactoring(IReference reference);
    public virtual void ExecuteReferencesRebinding(IReference reference);
    private static bool TryGetArgumentsOwner(IReference reference, IVBArgumentsOwner& argumentsOwner);
}
public class JetBrains.ReSharper.Refactorings.VB.Property2Auto.VBProperty2Auto : Property2AutoBase {
    public VBProperty2Auto(Property2AutoWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void TransformDeclaration();
    private void MakePropertyWriteable();
    public static void MoveFieldInitializer(IVBTypeMemberDeclaration variableDeclaration, IPropertyDeclaration propertyDeclaration);
    private static void FixPropertyInitializer(IPropertyDeclaration oldDeclaration, IPropertyDeclaration newDeclaration, IVBExpression initializer);
    public static void MoveFieldAttributesToProperty(IVBTypeMemberDeclaration variableDeclaration, IPropertyDeclaration propertyDeclaration, IRefactoringDriver driver);
    public virtual void RemoveFieldDeclaration();
    public virtual void BindUsage(IReference reference);
    public virtual void ExpandInitializerToAssignments();
    public virtual void CheckAccessInStructConstructorDeclaration(IReference reference);
}
public class JetBrains.ReSharper.Refactorings.VB.Property2Auto.VBProperty2AutoChecker : object {
    public sealed virtual override bool IsPropertyWithBackingField(IProperty prop, IField& backingField);
}
public class JetBrains.ReSharper.Refactorings.VB.Property2FunctionScope.VBPropertyToFunction : Property2FunctionBase {
    public VBPropertyToFunction(Property2FunctionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    private IVBExpression CreateGetterExpression(VBElementFactory factory, IVBExpression qualifier);
    private IVBStatement CreateSetterExpression(VBElementFactory factory, IVBExpression value, IVBExpression qualifier);
    public virtual void ProcessProperty(IDeclaredElement propOrMethod);
    public virtual bool TryTransformMethodCall(IExpression expression);
    protected virtual bool AreEquals(string name1, string name2);
    public virtual void TryMakeConflictForNotExpression(IReference reference);
    protected virtual bool SkipIndexerReference(IReference reference);
}
[DerivedRenamesEvaluatorAttribute("16")]
public class JetBrains.ReSharper.Refactorings.VB.Rename.DerivedRenames.ConstructorParameterRenameEvaluator : object {
    public bool SuggestedElementsHaveDerivedName { get; }
    public sealed virtual override bool get_SuggestedElementsHaveDerivedName();
    public sealed virtual override IEnumerable`1<IDeclaredElement> CreateFromElement(IEnumerable`1<IDeclaredElement> initialElements, DerivedElement derivedElement, IProgressIndicator pi);
    public sealed virtual override IEnumerable`1<IDeclaredElement> CreateFromReference(IReference reference, IDeclaredElement declaredElement, IProgressIndicator pi);
    private IDeclaredElement[] GetDerivedElements(IReference reference, IDeclaredElement declaredElement);
}
[DerivedRenamesEvaluatorAttribute("16")]
public class JetBrains.ReSharper.Refactorings.VB.Rename.DerivedRenames.EventRenameEvaluator : object {
    public bool SuggestedElementsHaveDerivedName { get; }
    public sealed virtual override bool get_SuggestedElementsHaveDerivedName();
    public sealed virtual override IEnumerable`1<IDeclaredElement> CreateFromElement(IEnumerable`1<IDeclaredElement> initialElements, DerivedElement derivedElement, IProgressIndicator pi);
    public sealed virtual override IEnumerable`1<IDeclaredElement> CreateFromReference(IReference reference, IDeclaredElement declaredElement, IProgressIndicator pi);
    private IDeclaredElement GetMethod(IDeclaredElement declaredElement, IReference reference);
    private IDeclaredElement[] GetDerivedElements(IReference reference);
}
[DerivedRenamesEvaluatorAttribute("16")]
public class JetBrains.ReSharper.Refactorings.VB.Rename.DerivedRenames.FieldDerivedRenames : object {
    public bool SuggestedElementsHaveDerivedName { get; }
    public sealed virtual override bool get_SuggestedElementsHaveDerivedName();
    public sealed virtual override IEnumerable`1<IDeclaredElement> CreateFromElement(IEnumerable`1<IDeclaredElement> initialElements, DerivedElement derivedElement, IProgressIndicator pi);
    public sealed virtual override IEnumerable`1<IDeclaredElement> CreateFromReference(IReference reference, IDeclaredElement declaredElement, IProgressIndicator pi);
    private IDeclaredElement[] FromConstructorParameter(IReferenceExpression referenceExpression);
    private IDeclaredElement[] TryBackingField(IReferenceExpression referenceExpression);
}
[DerivedRenamesEvaluatorAttribute("16")]
public class JetBrains.ReSharper.Refactorings.VB.Rename.DerivedRenames.PropertyDerivedRenameEvaluator : object {
    public bool SuggestedElementsHaveDerivedName { get; }
    public sealed virtual override bool get_SuggestedElementsHaveDerivedName();
    public sealed virtual override IEnumerable`1<IDeclaredElement> CreateFromElement(IEnumerable`1<IDeclaredElement> initialElements, DerivedElement derivedElement, IProgressIndicator pi);
    private IDeclaredElement GetField(IProperty property);
    public sealed virtual override IEnumerable`1<IDeclaredElement> CreateFromReference(IReference reference, IDeclaredElement declaredElement, IProgressIndicator pi);
}
[DerivedRenamesEvaluatorAttribute("16")]
public class JetBrains.ReSharper.Refactorings.VB.Rename.DerivedRenames.TypeDerivedRenamesEvaluator : object {
    public bool SuggestedElementsHaveDerivedName { get; }
    public sealed virtual override bool get_SuggestedElementsHaveDerivedName();
    public sealed virtual override IEnumerable`1<IDeclaredElement> CreateFromElement(IEnumerable`1<IDeclaredElement> initialElements, DerivedElement derivedElement, IProgressIndicator pi);
    public sealed virtual override IEnumerable`1<IDeclaredElement> CreateFromReference(IReference reference, IDeclaredElement declaredElement, IProgressIndicator pi);
}
internal class JetBrains.ReSharper.Refactorings.VB.Rename.LocalElementsConflictSearcher : object {
    private string myName;
    private IList`1<ILocalScope> myParentScopes;
    private IList`1<ILocalScope> myDeclarationScopes;
    private ConflictSearchResult myConflictSearchResult;
    private IDeclaredElement myDeclaredElement;
    public ConflictSearchResult LastResult { get; }
    public LocalElementsConflictSearcher(ILocalVariable localVariable, string name);
    public LocalElementsConflictSearcher(IParameter parameter, string name);
    public sealed virtual override ConflictSearchResult SearchConflicts(IProgressIndicator pi, bool canPerformRefactoring);
    public sealed virtual override ConflictSearchResult get_LastResult();
}
internal class JetBrains.ReSharper.Refactorings.VB.RenameNamespace.DeclarationUpdater : object {
    private QName myNewName;
    private QName myOldName;
    private IVBNamespaceDeclaration myNamespaceDeclaration;
    private QName myNewDeclarationName;
    private INamespace myNamespace;
    private ITreeNodePointer`1<IVBNamespaceDeclaration> myDeclarationPointer;
    private ReferenceRebinder myReferenceRebinder;
    public DeclarationUpdater(INamespace namespace, IVBNamespaceDeclaration namespaceDeclaration, string newName);
    public sealed virtual override void PreProcess();
    public sealed virtual override void RestoreReferences();
    public sealed virtual override void SetNewName();
}
internal class JetBrains.ReSharper.Refactorings.VB.RenameNamespace.QualificationUpdater : object {
    private INamespace myNamespace;
    private QName myOldName;
    private QName myNewName;
    private QName myNewDeclarationName;
    private IVBNamespaceDeclaration myNamespaceDeclaration;
    private IQualifiedNamespaceName myQualifiedNamespaceName;
    private ITreeNodePointer`1<IVBNamespaceDeclaration> myNodePointer;
    private ReferenceRebinder myReferenceRebinder;
    public QualificationUpdater(INamespace namespace, IVBNamespaceDeclaration namespaceDeclaration, IQualifiedNamespaceName qualifiedNamespaceName, string newName);
    public sealed virtual override void PreProcess();
    public sealed virtual override void RestoreReferences();
    public sealed virtual override void SetNewName();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.VB.RenameNamespace.VBRenameNamespace : object {
    public sealed virtual override IEnumerable`1<INamespaceDeclarationUpdater> BuildNamespaceDeclarationUpdatersForFile(INamespace namespace, IFile file, string newName);
    private static bool SameNamespace(IDeclaredElement declaredElement, INamespace namespace);
    public sealed virtual override IConflictSearcher GetConflictSearcher(INamespace namespace, string newName);
    private static string GetDefaultNamespace(IProjectFile projectFile, IProject& project);
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public class JetBrains.ReSharper.Refactorings.VB.Resources.Strings : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string Attribute_OfTheFieldDeclarationWill_Text { get; }
    public static string AssignedValueHasNoReachableUsages_Text { get; }
    public static string CannotRunControlFlowAnalysisFromThis_Text { get; }
    public static string MaKeMethodNonShared_Text { get; }
    public static string MethodDeclarationHasEventSpecification_Text { get; }
    public static string BackingFieldIsUsedFromThe1Structure_Text { get; }
    public static string AccessRightsFor0MemberWillBeExtended_Text { get; }
    public static string BackingField_AccessBecamePolymorphic_Text { get; }
    public static string CannotChangeWriteabilityOfPolymorphic_Text { get; }
    public static string FieldInitializerWillNotBeMovedFor__Text { get; }
    public static string FieldWillBeEncapsulated_Text { get; }
    public static string CallerCannotBeNull_Text { get; }
    public static string InstantiationOfTargetClass_WillBeBroken_Text { get; }
    public static string NullPassedAsInstanceParameter_Text { get; }
    public static string CannotAccessParameterType_InInstance_Text { get; }
    public static string CannotIntroduceVariableFromTheSelected_Text { get; }
    public static string ConditionalAccessWillBeDiscarded_Text { get; }
    public static string IntroDuceVariableForSubstring_Text { get; }
    public static string OnlyAbstractDeclarationsCanBeMovedTo_Text { get; }
    public static string OverridingOfEvent_IsNotAllowedVB_Text { get; }
    public static string Project_HasDefaultNamespace_WhichDoes_Text { get; }
    public static string SignatureChangeConflictsWithSignature_Text { get; }
    public static string SystemRuntimeCompilerServicesExtension_Text { get; }
    public static string ThereExistsSourceClassObjectCreation_Text { get; }
    public static string ThereIsAmbiguousConstructorReference_Text { get; }
    public static string TypeSystemFuncIsNotAvailable_Text { get; }
    public static string UsageCannotBeProcessedBecauseNotAll_Text { get; }
    public static string AllParametersOf_ShouldHaveByValModifier_Text { get; }
    public static string ConflictWithModifiersListFoundIn__Text { get; }
    public static string ConvertDefaultPropertyToMethodS_Text { get; }
    public static string InstantiationCannotBeTransformedInto_Text { get; }
    public static string CannotChangeSignatureOf__Text { get; }
    public static string LastArgumentOfMethod_ShouldnTBeOptional_Text { get; }
    public static string MaKeShared_Text { get; }
    public static string Member_HasNotEnoughAccess_Text { get; }
    public static string Property_HasNotEnoughAccess_Text { get; }
    public static string Property_OverridingBaseClassProperty_Text { get; }
    public static string ReadonlyModifierOfProperty_WillBeRemoved_Text { get; }
    public static string ReturnedValueOf0CallIsNotUsed_Text { get; }
    public static string UnableToAddWriteAccessorTo__Text { get; }
    public static string UsageOf_WillBeBrokenStructAccessShould_Text { get; }
    public static string VariableDoesnTHaveDeclarationsInSource_Text { get; }
    public static string VariableDoesnTHaveInitializer_Text { get; }
    public static string VariableHasUnsupportedUsageKind_Text { get; }
    public static string VariableHasWriteUsages_Text { get; }
    public static string _HasBaseClassUsage_Text { get; }
    public static string _HasHandlesClause_Text { get; }
    public static string _IsAMethodGroup_Text { get; }
    public static string _IsNotDeclaredAbstractBodyWillBeRemoved_Text { get; }
    public static string _IsUsedWithUnpresentableType_Text { get; }
    public static string _NeedsWiderAccess_Text { get; }
    private static Strings();
    public static JetResourceManager get_ResourceManager();
    public static string Choice(string format, Object[] args);
    public static string get_Attribute_OfTheFieldDeclarationWill_Text();
    public static string get_AssignedValueHasNoReachableUsages_Text();
    public static string get_CannotRunControlFlowAnalysisFromThis_Text();
    public static string get_MaKeMethodNonShared_Text();
    public static string get_MethodDeclarationHasEventSpecification_Text();
    public static string get_BackingFieldIsUsedFromThe1Structure_Text();
    public static string get_AccessRightsFor0MemberWillBeExtended_Text();
    public static string get_BackingField_AccessBecamePolymorphic_Text();
    public static string get_CannotChangeWriteabilityOfPolymorphic_Text();
    public static string get_FieldInitializerWillNotBeMovedFor__Text();
    public static string get_FieldWillBeEncapsulated_Text();
    public static string get_CallerCannotBeNull_Text();
    public static string get_InstantiationOfTargetClass_WillBeBroken_Text();
    public static string get_NullPassedAsInstanceParameter_Text();
    public static string get_CannotAccessParameterType_InInstance_Text();
    public static string get_CannotIntroduceVariableFromTheSelected_Text();
    public static string get_ConditionalAccessWillBeDiscarded_Text();
    public static string get_IntroDuceVariableForSubstring_Text();
    public static string get_OnlyAbstractDeclarationsCanBeMovedTo_Text();
    public static string get_OverridingOfEvent_IsNotAllowedVB_Text();
    public static string get_Project_HasDefaultNamespace_WhichDoes_Text();
    public static string get_SignatureChangeConflictsWithSignature_Text();
    public static string get_SystemRuntimeCompilerServicesExtension_Text();
    public static string get_ThereExistsSourceClassObjectCreation_Text();
    public static string get_ThereIsAmbiguousConstructorReference_Text();
    public static string get_TypeSystemFuncIsNotAvailable_Text();
    public static string get_UsageCannotBeProcessedBecauseNotAll_Text();
    public static string get_AllParametersOf_ShouldHaveByValModifier_Text();
    public static string get_ConflictWithModifiersListFoundIn__Text();
    public static string get_ConvertDefaultPropertyToMethodS_Text();
    public static string get_InstantiationCannotBeTransformedInto_Text();
    public static string get_CannotChangeSignatureOf__Text();
    public static string get_LastArgumentOfMethod_ShouldnTBeOptional_Text();
    public static string get_MaKeShared_Text();
    public static string get_Member_HasNotEnoughAccess_Text();
    public static string get_Property_HasNotEnoughAccess_Text();
    public static string get_Property_OverridingBaseClassProperty_Text();
    public static string get_ReadonlyModifierOfProperty_WillBeRemoved_Text();
    public static string get_ReturnedValueOf0CallIsNotUsed_Text();
    public static string get_UnableToAddWriteAccessorTo__Text();
    public static string get_UsageOf_WillBeBrokenStructAccessShould_Text();
    public static string get_VariableDoesnTHaveDeclarationsInSource_Text();
    public static string get_VariableDoesnTHaveInitializer_Text();
    public static string get_VariableHasUnsupportedUsageKind_Text();
    public static string get_VariableHasWriteUsages_Text();
    public static string get__HasBaseClassUsage_Text();
    public static string get__HasHandlesClause_Text();
    public static string get__IsAMethodGroup_Text();
    public static string get__IsNotDeclaredAbstractBodyWillBeRemoved_Text();
    public static string get__IsUsedWithUnpresentableType_Text();
    public static string get__NeedsWiderAccess_Text();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.VB.SafeDeleteFolder.VBSafeDeleteFolderHelper : SafeDeleteFolderLanguageSpecific {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual IList`1<IDeclaredElement> GetExternalDeclaredElements(IFile file);
    private void ProcessTopClasses(IVBTypeAndNamespaceHolderDeclaration holder, List`1<ITypeElement> ret);
    public virtual void RemoveUsing(ITreeNode element);
    public virtual IEnumerable`1<ITreeNode> GetUsingsFromFile(IFile file, IList`1<INamespace> namespaces);
}
public class JetBrains.ReSharper.Refactorings.VB.SafeDeleteTheSecond.VBSafeDelete : SafeDeleteBase {
    public VBSafeDelete(SafeDeleteWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IList`1<IArgument> GetArgumentsToRemove(IReference reference, IParametersOwner owner, IParameter parameter);
    public virtual bool IsExtensionCall(IReference reference);
    public virtual bool IsMethodGroup(IReference reference);
    public virtual bool RemoveInterfaceMemberSpecification(IReference reference, bool remove);
    public virtual void RemoveImplicitAccessor(IAccessor accessor);
    private static bool IsNull(IVBExpression expression);
    private static bool IsNullCheck(IVBStatement statement, IParameter parameter);
    public virtual bool IsPartial(IMethod method);
    public virtual bool IsReferenceOnConstructor(IReference reference);
    public virtual bool IsSingleAndCallsToBase(IConstructor constructor);
    private static bool IsValidStatementExpression(IVBExpression expression);
    public virtual void MakeVirtual(IDeclaration declaration, bool sealedType);
    public virtual void RemoveArgument(IReference reference, ArgumentRemover remover, PerReferenceData data);
    public virtual bool RemoveCallToBaseMethod(IReference reference);
    public virtual void RemoveDeclaration(IDeclaration declaration);
    public virtual bool CanRemoveExpression(IExpression expression);
    public virtual bool RemoveExpression(IExpression expression);
    public virtual void RemoveNewRedundantUsings(IFile file, HashSet`1<ITreeNode> oldUsings, IProgressIndicator progress);
    public virtual bool RemoveSubscription(IReference reference);
    public virtual void RemoveTypeParameterDeclaration(IDeclaration declaration);
    public virtual bool ReplaceExplicitImplementation(IReference reference);
    private void RemoveInterfaceSpecification(IReferenceName referenceName, IImplementsClause implementsClause);
    public virtual void ReplaceExplicitImplementation(IDeclaration declaration);
    public virtual void SaveUnusedUsings(IFile file);
    private void AddSuperInterface(ITypeDeclaration newDecl, IDeclaredType newSuprtType);
    public virtual void SetBaseTypes(IDeclaration declaration, IDeclaredType baseClass, IList`1<IDeclaredType> allSuperTypes, ITypeElement baseElementToRemove);
    public virtual void TryRemoveNullChecking(IDeclaration declaration);
}
public class JetBrains.ReSharper.Refactorings.VB.SafeDeleteTheSecond.VBSafeDeleteHelper : SafeDeleteHelperUnsupported {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
    public virtual bool CanBeRemoved(IDeclaredElement element);
    public virtual bool CanBeRemoved(IDeclaration declaration);
    public virtual bool IsBaseClassSpecifier(IReference reference);
    public virtual bool IsInterfaceImplementationSpecifier(IReference reference);
    public virtual IEnumerable`1<ITreeNode> GetUsingsFromFile(IFile file, IList`1<INamespace> namespaces);
    public virtual void RemoveUsing(ITreeNode element);
}
public class JetBrains.ReSharper.Refactorings.VB.Static2Extension.VBStatic2Extension : Static2ExtensionBase {
    public VBStatic2Extension(Static2ExtensionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void MakeCallExtension(IReference reference);
    public virtual void MakeCallPlainStatic(IReference reference);
}
public class JetBrains.ReSharper.Refactorings.VB.TransformParameters.VbTransformParameters : TransformParametersBase {
    public static string TUPLE_METHOD_CREATE;
    [CompilerGeneratedAttribute]
private TransformParametersDataModel _DataModel;
    public TransformParametersDataModel DataModel { get; public set; }
    public VbTransformParameters(TransformParametersWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    [CompilerGeneratedAttribute]
public TransformParametersDataModel get_DataModel();
    [CompilerGeneratedAttribute]
public void set_DataModel(TransformParametersDataModel AutoPropertyValue);
    public virtual PreProcessedCall PreProcessCall(IReference reference);
    public virtual void FixUsage(PreProcessedCall call, string name);
    private void ReplaceInvocation(PreProcessedCall call, IVBStatement markerStatement, IBlock block, string name, IVBArgumentsOwner vbArgumentsOwner);
    private void ProcessArguments(PreProcessedCall call, IVBArgumentsOwner vbArgumentsOwner, IVBExpression expression, VBElementFactory factory);
    public void JoinDeclarationsAndAssignments(IDeclaration method, ICollection`1<IStatement> statementsToUse);
    private IVBExpression ReturnValueCreationExpression(IPsiModule module, IList`1<IVBExpression> parameters, ISubstitution substitution, ITypeEntity entity);
    private IVBExpression ReturnValueCreationExpression(IPsiModule module, IVBExpression previousReturnExpr, IEnumerable`1<IVBExpression> outParamReferences, OutTypeInfo outTypeInfo, ISubstitution substitution);
    public virtual void TransformDeclaration(IParametersOwner method, IRefactoringDriver driver, ISubstitution substsOfOverrides);
    private void ProcessReturnStatements(IParametersOwner method, IBlock body, IParametersOwnerDeclaration declaration, VBElementFactory factory, List`1<IParameterDeclaration> outParameterDeclarations, ISubstitution substsOfOverrides);
    private void ProcessReturnType(IParametersOwnerDeclaration decl, ISubstitution substsOfOverrides);
    private void ProcessParameters(ISubstitution substsOfOverrides, IParametersOwnerDeclaration declaration);
    private IVBExpression ContainingExpression(ITreeNode expr);
    private bool ReferenceCanBeTransformed(IVBArgumentsOwner invocationExpression, IVBStatement& containingStatement);
    [CanBeNullAttribute]
private IVBExpression GetNewExpression(PreProcessedCall call, IVBArgumentsOwner owner, ISubstitution substitution, string name, VBElementFactory factory, ITypeEntity typeEntity, bool returnTypeIsSimpleType);
    public virtual bool IsPureRecursiveCall(IReference reference);
    private void Transform(IReference reference, string property, IParameter parameter);
}
public class JetBrains.ReSharper.Refactorings.VB.UseBaseType.VBConstraintSearcherUtil : ConstraintSearcherUtil {
    private UseBaseTypeRefactoring myExecuter;
    public GraphBuilder Builder { get; }
    public VBConstraintSearcherUtil(UseBaseTypeRefactoring executer);
    public GraphBuilder get_Builder();
    public virtual ITreeNode GetDirectlyUsedElement(ITreeNode someElement);
    public virtual void ProcessUp(ITreeNode directlyUsedElement, TypeElementUsage usage);
    public virtual bool TryFindInitializerConstraint(ITreeNode preparedElement, IDeclaredElement& initializedElement);
    public virtual bool TryFindAssignmentConstraint(ITreeNode preparedElement, IDeclaredElement& assignmentDest);
    public virtual bool TryFindSimpleReturnConstraint(ITreeNode preparedElement, ITypeMember& returnFromMember);
    public virtual bool TryFindArgumentConstraint(ITreeNode preparedElement, IParameter& parameter);
    public virtual bool TryFindTypeMemberConstraint(ITreeNode preparedElement, ITypeMember& memberCalled, ExpressionAccessType& memberAccessType);
    private static IVBExpression SkipParenthesis(IVBExpression expression);
}
public class JetBrains.ReSharper.Refactorings.VB.UseBaseType.VBTypeUsageSearcherUtil : TypeUsageSearcherUtil {
    public virtual int GetArrayRank(ITreeNode typUsageElement);
    public virtual bool TryFindConstrainedParameter(IReference reference, ITypeParameter& parameter);
    public virtual bool TryFindChilidTypeElement(IReference reference, ITypeElement& childTypeElement);
    public virtual bool TryFindDelegateDeclaration(IReference reference, ITypeElement& delegateElement);
    public virtual bool TryFindTypeParameterOwner(IReference reference, ITreeNode& typeUsageElement, ITypeParameter& parameter);
}
public class JetBrains.ReSharper.Refactorings.VB.UseBaseType.VBUseBaseType : UseBaseTypeBase {
    private TypeUsageSearcherUtil myTypeUsageSearcherUtil;
    private VBConstraintSearcherUtil myConstraintsUtil;
    public bool MethodGroupTypeMatch { get; }
    public VBUseBaseType(UseBaseTypeWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IDeclaredElement[] GetDeclaredElements(IReference reference);
    public virtual bool CheckConstraintElement(IDeclaredElement element);
    public virtual TypeUsageSearcherUtil GetTypeUsageSearcherUtil();
    public virtual ConstraintSearcherUtil GetConstraintSearcherUtil();
    public virtual IDeclaredElement GetDelegateDeclaration(ITreeNode directlyUsedElement);
    public virtual IReference BindUsage(IReference reference);
    public virtual bool GetConstructedExpression(IReference reference, IExpression& expression);
    public virtual bool GetCastExpressionExpression(IReference reference, IExpression& expression);
    public virtual bool GetIsExpression(IReference reference, IExpression& expression);
    public virtual bool GetTypeOfExpression(IReference reference, IExpression& expression);
    public virtual bool get_MethodGroupTypeMatch();
}
public class JetBrains.ReSharper.Refactorings.VB.Util.ClassLikeDeclarationReplacer : object {
    public static ITag Replace(IClassLikeDeclaration decl, IClassLikeDeclaration newDecl, ReplaceActions action);
}
public abstract class JetBrains.ReSharper.Refactorings.VB.Util.RDInspectorOfVariable`1 : ControlFlowGraphInspector`1<TInspectorContext> {
    private ITypeOwner myElement;
    private JetHashSet`1<ITreeNode> myDelayedAssignments;
    protected RDInspectorOfVariable`1(ControlFlowGraph controlFlowGraph, ITypeOwner element, IControlFlowContextFactory`1<TInspectorContext> factory);
    protected virtual void InspectLeafElementAndSetContextToExits(IControlFlowElement controlFlowElement, TInspectorContext context);
    protected abstract virtual bool CustomInspection(IControlFlowElement controlFlowElement, TInspectorContext context, ITreeNode element);
}
public enum JetBrains.ReSharper.Refactorings.VB.Util.ReplaceActions : Enum {
    public int value__;
    public static ReplaceActions Replace;
    public static ReplaceActions PlaceBefore;
    public static ReplaceActions PlaceAfter;
}
public class JetBrains.ReSharper.Refactorings.VB.Util.VBAbstractor : object {
    private IMoveMembersExecuter myExecuter;
    private IPsiModule myPsiModule;
    public VBAbstractor(IMoveMembersExecuter executer, IPsiModule module);
    public T MakeDeclaration(IDeclaration initialDecl, bool abstr);
    private T MakeField(IField field);
    private T MakeEvent(bool abstr, IEvent eventt);
    private T MakeIndexer(bool abstr, IProperty prop);
    private T MakeProperty(bool abstr, IProperty prop);
    private static void SetModifiers(IModifiersOwner initialDecl, IVBModifiersOwnerDeclaration targetDecl);
    private T MakeMethod(IMethod method, bool abstr);
    private void AddParameters(IParametersOwner method, IVBParametersOwnerDeclaration declaration);
    private void AddDocComments(ITypeMember method, IDeclaration declaration);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.VB.Util.VBConstructionUtil : ConstructionUtil {
    public virtual void RemoveParameter(IParametersOwner owner, IParameter parameter);
    public virtual void ChangeToOrFromExtension(IMethod method, bool addThis, IRefactoringDriver driver);
    public virtual void InitElementInConstructor(IDeclaration constructorDecl, IDeclaration fieldDecl, string name, DefaultValue defaultValue);
    public virtual IParameter AddFirstParameter(IParametersOwner owner, string name, IDeclaredType type);
    public virtual void InitElementInConstructor(IDeclaration constructorDecl, IDeclaration fieldDecl, IParameter parameter);
    public virtual IDeclaration AddEmptyConstructor(ITypeElement class, IDeclaration tag);
    public virtual IDeclaration AddProperty(ITypeElement class, IDeclaration fieldDeclaration, NameRoot basicName, IDeclaration tag, bool isWritable, AccessRights accessRights, JetHashSet`1<string> namesSet);
    public virtual IDeclaration AddField(ITypeElement class, NameRoot name, IType type, IDeclaration tag, AccessRights accessRights, JetHashSet`1<string> namesSet);
    public virtual IDeclaration AddTypeParameter(ITypeElement class, string name, ITypeParameter originalTypeParameter);
    public virtual void SetAccessRights(IDeclaredElement o, AccessRights rights);
    public virtual ITypeElement AddClassBeforeFromMember(string className, ITypeMember typeMember, bool topLevel, bool isClass);
    public virtual ITypeElement AddClassBefore(string className, IDeclaration tag, bool topLevel, bool isClass);
    public virtual ITypeMember AddTypeMemberDeclaration(ITypeElement element, IDeclaration declaration, IDeclaration tag, bool after);
    public virtual ITypeParameter AddTypeParameter(IDeclaration declaration, string shortName);
    protected virtual bool IsInCollection(JetHashSet`1<string> namesSet, string fieldName);
    public virtual void RemoveTypeMember(ITypeMemberDeclaration member);
    public virtual void RemoveFunction(IDeclaration element);
    protected virtual void AddToCollection(JetHashSet`1<string> namesSet, string fieldName);
    public virtual IDeclaration AddAutoProperty(ITypeElement class, IType type, NameRoot basicName, IDeclaration tag, bool isWritable, AccessRights accessRights, JetHashSet`1<string> namesSet);
}
[StandardModuleAttribute]
internal class JetBrains.ReSharper.Refactorings.VB.Util.VBPsiUtil : object {
    public static IVBTypeAndNamespaceHolderDeclaration GetNewTypeAndNamespaceHolder(IVBFile file, string namespaceName, IVBNamespaceDeclaration anchor);
    [CanBeNullAttribute]
public static IVBNamespaceDeclaration CreateNamespaceDeclaration(IVBFile file, string defaultNamespaceName, string name, IVBNamespaceDeclaration anchor);
    private static bool CheckNestedNamespacesExist(IVBFile file);
    private static IVBNamespaceDeclaration GetExistingNamespaceDeclaration(IVBFile file, string defaultNamespaceName, string namespaceName);
    private static IVBNamespaceDeclaration GetRealAnchorInDeclaration(IVBTypeAndNamespaceHolderDeclaration declaration, IVBNamespaceDeclaration anchor);
    public static IVBNamespaceDeclaration GetNamespaceDeclaration(IVBTypeAndNamespaceHolderDeclaration holder, string searchedName);
    private static IVBExpression GetInitializerExpression(IDeclaration decl);
    public static IVBExpression InitializerToExpression(ILocalVariableDeclaration declaration);
    public static IVBExpression AsArrayCreationExpression(IAnonymousArrayCreationExpression arrayInitializer);
    public static void RemoveLocalVariableDeclaration(IDeclaration declaration);
    public static void RemoveOrReplaceExpression(IVBExpression expr, IVBExpression replacement);
    public static IVBExpression TransformComplexAssignment(IAssignmentStatement assignmentStatement, IVBExpression operand);
    public static IDelegate GetDelegate(IReferenceExpression refExpr);
    public static IVBArgument FindArgument(int thisParameter, IList`1<IVBArgument> args);
}
public class JetBrains.ReSharper.Refactorings.VB.Util.VBPullPushEditor : object {
    public static List`1<Pair`2<DeclaredElementNode, IDeclaration>> CutDeclarations(IEnumerable`1<DeclaredElementNode> includedMembers, IMoveMembersExecuter executer);
    public static void PasteDeclarations(IList`1<Pair`2<DeclaredElementNode, IDeclaration>> declarations, ITypeElement targetType, IMoveMembersExecuter executer);
    private static void MakeDeclarationAbstract(IVBTypeMemberDeclaration classMemberDeclaration, bool isInterface);
    private static void UpdateReferences(ReferenceIdentitySaver saver, IMoveMembersExecuter executer, ITypeElement targetElementType);
    public static void AddImplementsSpecification(IDeclaration newAbstractDecl, ITypeElement targetInterface, bool nameIsItem, IRefactoringDriver driver);
    public static bool TryStoreReferencesForField(IDeclaration declaration, IRecursiveElementProcessor collector);
    public static void MakePublic(ITypeMember member);
    public static void MakeTypeElementAbstract(ITypeElement element);
    public static void RemoveDeclaration(ITypeMember member);
    public static void MakeOverride(ITypeMember member);
    public static void MakeProtected(IDeclaredElement element);
    public static ITypeDeclaration CreateTargetTypeElement(string name, ITypeElement sourceClass, List`1<ITypeParameter> typeParameters, bool createClass, bool preserveAccessRights);
    private static void AddTypeParametersWithConstraints(IClassLikeDeclaration targetClassDecl, ITypeElement sourceClass, List`1<ITypeParameter> typeParameters, IPsiModule module);
    public static ITypeDeclaration InsertSibling(ITypeDeclaration declarationToInsert, ITypeDeclaration tagDeclaration);
    public static void SetSuperType(ITypeDeclaration sourceClass, ITypeElement newSuper, ISubstitution substitution);
    public static ITypeDeclaration InsertToNewFile(ITypeDeclaration decl, ITypeDeclaration sourceClass, string ns, IProjectFile fileNearby);
    public static void AddBaseInterface(ITypeElement element, IDeclaredType baseType);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.VB.Util.VBRefactoringDataConstantsService : object {
    public sealed virtual override bool IsNameNodeSelected(ITreeNode node, DocumentRange documentRange);
}
public class JetBrains.ReSharper.Refactorings.VB.Util.VBUnusedUsingsUtil : object {
    public static void AddFileToUsingSaver(UnusedUsingSaver saver, IFile file);
    public static void RemoveNewUnusedUsings(IFile file, HashSet`1<ITreeNode> oldUnusedUsings);
    private static void RemoveImportClause(IImportClause clause, IFile file);
}
public class JetBrains.ReSharper.Refactorings.VB.VBAnonymousTypeAtomicRename : AnonymousTypePropertyAtomicRenameBase {
    public VBAnonymousTypeAtomicRename(IDeclaredElement originalElement, string newName);
    protected virtual int CompareReferencesOnMemberDeclarations(IReference r1, IReference r2);
    protected virtual IDeclaredElement SetName(IDeclaredElement element, string name);
}
public class JetBrains.ReSharper.Refactorings.VB.VBArgumentsOwnerUsage : SignatureUsage`1<IVBArgument> {
    private ITreeNode myContext;
    private bool myWasNamed;
    public VBArgumentsOwnerUsage(ITreeNode argumentsOwner, ClrChangeSignatureModel changeSignatureModel, RebindableReference rebindableReference);
    protected virtual IVBArgument AddItemAfter(IVBArgument item, IVBArgument anchor, ClrChangeSignatureParameter parameter);
    protected virtual void RemoveItem(IVBArgument item);
    protected virtual IVBArgument ReplaceItemBy(IVBArgument argument, IVBArgument newArgument, ClrChangeSignatureParameter parameter);
    protected virtual bool TryGetItem(int index, IVBArgument& item);
    protected virtual ArgumentLikeInfo CreateItemForParameter(ClrChangeSignatureParameter parameter, bool isRecursivePass);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Refactorings.VB.VBArgumentsOwnerUsage/VB$StateMachine_8_GetUpdateReferenceConflicts")]
public virtual IEnumerable`1<IConflict> GetUpdateReferenceConflicts();
    public virtual bool TryUpdateSignatureUsage(List`1<ArgumentLikeInfo> postActionsList);
    private static IVBArgument MakeNamed(IVBArgument argument, bool wasNamed, ClrChangeSignatureParameter parameter);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.VB.VBCallPreviewProvider : object {
    public sealed virtual override IArgumentsOwner GetCallPreview(IArgumentsOwner call, ClrChangeSignatureParameter changeSignatureParameter, object argumentvalue, bool addFake);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.VB.VBChangeSignature : ChangeSignature {
    public virtual IParametersOwner AddDefaultConstructorDeclaration(IConstructor defaultConstructor);
    public virtual ISignatureUsage CreateSignatureUsage(ClrChangeSignatureModel changeSignatureModel, RebindableReference rebindableReference);
    public virtual void MaterializeReferenceIfNeeded(RebindableReference rebindableReference, ClrChangeSignatureModel model);
    public virtual void ChangeReference(ClrChangeSignatureModel changeSignatureModel, RebindableReference rebindableReference, List`1<ArgumentLikeInfo> postActionsList);
    public virtual void ChangeDeclaration(IDeclaration declaration, IList`1<IDeclaration> parameterDeclarations, ClrChangeSignatureModel changeSignatureModel, ISubstitution substitution, List`1<ArgumentLikeInfo> postActionsList);
    public virtual void CreateProxy(ClrChangeSignatureModel changeSignatureModel, List`1<ArgumentLikeInfo> postActionsList);
    private void DelegateCall(IVBArgumentsOwner owner, ClrChangeSignatureModel changeSignatureModel, IList`1<IRegularParameterDeclaration> originalParameters, List`1<ArgumentLikeInfo> postActionsList);
    public virtual ClrChangeSignatureModel CreateModel(IParametersOwner owner, IProgressIndicator progressIndicator);
    public virtual ClrChangeSignatureModel CreateModel(IParametersOwner owner, ChangeSignatureFixNode fix, IProgressIndicator progressIndicator);
    public virtual IParameterDeclaration CreateParameterDeclaration(IPsiModule module, string name, IType type, ParameterKind parameterKind, bool isParams, bool isVarArg, IDeclaration originalDeclaration, bool isThis, IParameterValue defaultValue, ClrChangeSignatureModel model);
    public virtual bool IsAvailable(IParametersOwner owner);
    public virtual Dictionary`2<int, int> GetArgumentToParameterMapping(IReference reference, bool isExtensionCall, IArgumentsOwner owner);
    public virtual bool IsExtensionCallReference(IReference reference);
    public virtual IExpression CreateExpression(string text, ITreeNode context);
    public virtual IExpression CreateReferenceExpression(string name, ITreeNode context);
    public virtual IExpression CreateThisExpression(ITreeNode context);
    public virtual void BindReferenceExpression(IExpression expression, IDeclaredElement element);
    public virtual bool IsIgnoredInternal(ITreeNode element);
    protected virtual void ChangeDefaultConstructor(IConstructor constructor, ClrChangeSignatureModel model, List`1<ArgumentLikeInfo> postActions);
    public virtual bool IsLocalEqualToFieldOrAutoProperty(ITypeMember fieldOrProperty, IDeclaredElement local, ITreeNode place);
    public virtual ILocalVariable DeclareLocalOutVariable(string variableName, IType variableType, IExpression& beforeExpression, IElementsSet elementsToKeep);
}
public class JetBrains.ReSharper.Refactorings.VB.VBChangeSignatureModel : ClrChangeSignatureModel {
    private bool myIsProperty;
    public VBChangeSignatureModel(IParametersOwner parametersOwner, bool isClone, IProgressIndicator progressIndicator);
    public VBChangeSignatureModel(IParametersOwner parametersOwner, ChangeSignatureFixNode fix, bool isClone, IProgressIndicator progressIndicator, Lifetime lifetime);
    public virtual bool CanHaveParameters();
    public virtual IList`1<IDeclaration> BuildParameters(IParametersOwner parametersOwner, ISubstitution substitution);
    public virtual object Clone();
    public virtual bool ConflictsWithOtherInstance(TypeMemberInstance typeMemberInstance);
    public virtual string GetParameterKindDescription(ParameterKind kind, bool nullIfNotSupported, bool isParams, bool isVarArg, bool isThis, bool isOptional);
    public virtual string GetPreview();
    public virtual bool CanChangeType();
    public virtual bool HasHandler(IMethod method);
    public virtual string PresentDefaultValue(IParameter value);
}
public class JetBrains.ReSharper.Refactorings.VB.VBControlFlowAnalyzer : object {
    [CanBeNullAttribute]
private VBControlFlowAnalyzerImpl myAnalyzer;
    public IEnumerable`1<IControlFlowEdge> ExitEdges { get; }
    public VBControlFlowAnalyzer(ITreeRange treeRange);
    public IEnumerable`1<IControlFlowEdge> get_ExitEdges();
    public ICollection`1<LocalVariable> GetVariables();
    public ExtractMethodAvailabilityCheckResult CheckEntriesAndExits();
    public bool CrossUsedAnotypes();
}
public class JetBrains.ReSharper.Refactorings.VB.VBCopyTypeConflictSearcher : object {
    private ITypeElement myTypeElement;
    private string myNewName;
    private ConflictSearchResult _conflictSearchResult;
    public ConflictSearchResult LastResult { get; }
    public VBCopyTypeConflictSearcher(ITypeElement typeElement, string newName);
    public sealed virtual override ConflictSearchResult SearchConflicts(IProgressIndicator pi, bool canPerformRefactoring);
    public sealed virtual override ConflictSearchResult get_LastResult();
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.VB.VBExtractMethodFactory : object {
    public sealed virtual override ExtractMethodAvailabilityCheckResult CheckAvailability(ISolution solution, ITextControl textControl);
    public ITreeRange GetTreeRange(ISolution solution, DocumentRange documentRange);
    public sealed virtual override IExtractMethod CreateExtractMethod(ISolution solution, ITextControl textControl);
    private IVBStatementsRange GetStatementsRange(ISolution solution, DocumentRange documentRange);
}
[StandardModuleAttribute]
internal class JetBrains.ReSharper.Refactorings.VB.VBExtractMethodUtil : object {
    public static T AddTypeMemberDeclarationNear(IVBTypeMemberDeclaration anchor, T member);
    public static bool CanBeInstance(IVBStatementsRange statementsRange);
    public static bool CanBeInstance(IVBExpression expression);
    public static bool CanBeStatic(ITreeNode element);
    public static bool CanBeStatic(ITreeRange treeRange);
    public static ExtractMethodParameter CreateParameter(LocalVariable localVariable, bool isReturned);
    public static IVBArgument CreateArgument(VBElementFactory factory, ExtractMethodParameter parameter);
    public static ExtractMethodParameter UpdateParameter(ExtractMethodParameter parameter, bool isReturned);
    public static IMethodDeclaration CreateMethodDeclaration(ExtractMethodBase extractMethodBase, IProgressIndicator progressIndicator, IType returnType, IVBStatementsRange body, ManuallyRemappedTreeNodePointer unpassedParametersMarker, bool isModule);
    public static IType UpType(IType type);
    public static T Replace(IVBStatementsRange statementsRange, T statement);
}
public class JetBrains.ReSharper.Refactorings.VB.VBFunction2Indexer : VBFunction2Property {
    private bool IsGetter;
    public VBFunction2Indexer(Function2PropertyWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    protected virtual void CheckConflictWithClassName(ITypeElement element);
    protected virtual IPropertyDeclaration CreatePropertyDeclaration(VBElementFactory factory, bool isInterface, bool isAbstract);
    protected virtual PropertySearchResultBase TestPropertyParameters(IProperty prop);
    protected virtual IPropertyDeclaration ValidatePropertyToComplete(IPropertyDeclaration propertyToComplete);
    public virtual void CheckConflictWithMethod(IMethod method, IDeclaredElement existingDeclaration, bool isBase, bool isInheritor);
    public virtual void CheckConflictWithProperty(IProperty property, IDeclaredElement existingDeclaration, bool isBase, bool isInheritor);
}
public class JetBrains.ReSharper.Refactorings.VB.VBFunction2Property : Function2PropertyBase {
    private bool myIsGetter;
    public VBFunction2Property(Function2PropertyWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    protected virtual void ProcessMethod(IDeclaredElement element);
    protected virtual IPropertyDeclaration ValidatePropertyToComplete(IPropertyDeclaration propertyToComplete);
    public virtual bool InitialValidate();
    protected virtual PropertySearchResultBase TestPropertyParameters(IProperty prop);
    private PropertySearchResultBase ReturnNotMatched(IProperty prop);
    protected virtual bool CheckExplicitImplementationList(IOverridableMember accessor, IMethod method);
    protected virtual IPropertyDeclaration CreatePropertyDeclaration(VBElementFactory factory, bool isInterface, bool isAbstract);
    public virtual void ExecuteReferencesRefactoring(IReference reference);
    public IAccessorDeclaration CreateAccessorDeclaration(VBElementFactory factory, AccessorKind kind, string name, IType propertyType);
    public virtual void CheckConflictWithMethod(IMethod method, IDeclaredElement existingDeclaration, bool isBase, bool isInheritor);
    protected virtual void RenameParameter(IMethod method, IProperty existingProperty);
    protected virtual bool AreEquals(string name1, string name2);
    public virtual void CheckConflictWithProperty(IProperty property, IDeclaredElement existingDeclaration, bool isBase, bool isInheritor);
}
public class JetBrains.ReSharper.Refactorings.VB.VBIndexer2Function : Indexer2FunctionBase {
    public VBIndexer2Function(Property2FunctionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    protected virtual bool AreEquals(string name1, string name2);
    public virtual void ExecuteDeclarationRefactoring(IDeclaredElement propertyOrMethod, IProgressIndicator pi);
    protected virtual bool SkipIndexerReference(IReference reference);
    public virtual bool TryNewTypeDeclaration(IndexersSearchData data, IReference reference);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.VB.VBInstanceObjectUsageChecker : object {
    public sealed virtual override InstanceObjectUsageResult GetCheckResult(ITreeNode element);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.VB.VBMakeMethodNonStatic : object {
    public sealed virtual override IDeclaration AddDeclaration(IDeclaration declaration, IDeclaration methodOwnerDeclaration, IRefactoringDriver driver);
    public sealed virtual override IDeclaredElement PatchDeclaration(IDeclaration declaration, int thisParameterIndex, bool createDim, ITypeElement newMethodOwner, IList`1<ITypeParameter> typeParams, IInterface interface, AccessRights accessRights, Dictionary`2<ITypeParameter, ITypeParameter> newToOldTypeParameters);
    public sealed virtual override void PatchRecursiveCall(ITreeNode referenceElement, int thisParameter, IRefactoringDriver driver);
    public sealed virtual override void RemoveDeclaration(IDeclaration methodDeclaration);
    public sealed virtual override bool Suitable(IDeclaration declaration);
    public sealed virtual override void BindToThis(IReference reference);
    public sealed virtual override void PatchMethodReference(IReference reference, ISubstitution substitution, Dictionary`2<ITypeParameter, ITypeParameter> newToOldTypeParametersMap, IList`1<ITypeParameter> methodTypeParams, IRefactoringDriver driver, int parameterIndex);
    private static void CheckConflicts(int thisParameter, IReferenceExpression referenceExpression, IRefactoringDriver driver, IIndexExpression invocationExpression);
}
public class JetBrains.ReSharper.Refactorings.VB.VBMoveStaticMembers : MoveStaticMembers {
    public VBMoveStaticMembers(MoveStaticMembersWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual void RemoveOldDeclaration(IDeclaration declaration);
    public virtual Dictionary`2<ITypeParameter, ITypeParameter> PasteDeclaration(StaticMemberInfo memberInfo, ITypeMember& newTypeMember);
}
public class JetBrains.ReSharper.Refactorings.VB.VBMoveStaticMembersHelper : MoveStaticMembersHelper {
    public bool IsLanguageSupported { get; }
    public virtual bool get_IsLanguageSupported();
}
public class JetBrains.ReSharper.Refactorings.VB.VBProperty2FunctionDeclarationProcessor : Property2FunctionDeclarationProcessor`1<IMethodDeclaration> {
    public VBProperty2FunctionDeclarationProcessor(Property2FunctionDataModel property2FunctionDataModel);
    private static IVBTypeMemberDeclaration GetDeclaration(IProperty prop);
    protected virtual void RemoveBaseDeclaration(IProperty property);
    protected virtual IMethodDeclaration AddAccessor(IMethodDeclaration declaration, IProperty property);
    protected virtual void RemoveSetter(IProperty property);
    protected virtual void RemoveGetter(IProperty property);
    protected virtual string GetterPattern(bool isAbstract, bool isInterface);
    protected virtual string SetterPattern(bool isAbstract, bool isInterface, IProperty prop);
    public static IMethodDeclaration CreateAccessorDeclaration(bool withBody, IProperty prop, IAccessor accessor, string accessorName, string accessorTemplate);
    protected virtual IProperty CreateFieldForAutoProperty(IProperty propty);
}
public class JetBrains.ReSharper.Refactorings.VB.VBProperty2FunctionReferencesProcessor : Property2FunctionReferencesProcessor {
    public VBProperty2FunctionReferencesProcessor(Property2FunctionBase refactoring, Property2FunctionWorkflow workflow);
    private static bool AnalzieReference(IExpression expression, IVBExpression& vbExpression, IVBExpression& qualifierExpression, IVBArgument[]& arguments);
    public virtual bool ReplaceWriteProperty(IExpression expression, IReference reference);
    public virtual void ReplaceReadOccurrence(IExpression expression);
    public virtual bool ReplaceReadWriteOccurrence(IReference reference, IExpression expression);
    private IVBExpression CreateGetterExpression(VBElementFactory factory, IList`1<IVBArgument> arguments, IVBExpression qualifier);
    private IVBStatement CreateSetterExpression(VBElementFactory factory, IList`1<IVBArgument> arguments, IVBExpression value, IVBExpression qualifier);
    private static IVBExpression PatchWithArgiments(IVBExpression expression, IEnumerable`1<IVBArgument> args);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.VB.VBRefactoringLanguageService : InternalRefactoringLanguageService {
    public RefactoringsHelper Helper { get; }
    public virtual IMoveTypeToOuterScope MoveTypeToOuterScope(MoveTypeToOuterScopeRefactoring refactoring);
    public virtual IConvertRefactoring Property2Function(Property2FunctionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IConvertRefactoring Function2Property(Function2PropertyWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IConvertRefactoring Function2Indexer(Function2PropertyWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IConvertRefactoring Indexer2Function(Property2FunctionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IPullUp PullUpRefactoring(ISolution solution, IRefactoringDriver driver);
    public virtual IExtractSuperclass ExtractSuperclassRefactoring(ISolution solution, IRefactoringDriver driver);
    public virtual IExtractInterface ExtractInterfaceRefactoring(ISolution solution, IRefactoringDriver driver);
    public virtual IPushDown PushDownRefactoring(ISolution solution, IRefactoringDriver driver);
    public virtual IConvert CreateInterface2Abstract(Interface2AbstractWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IConvert CreateAbstract2Interface(Abstract2InterfaceWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual TransformParametersBase CreateTransformParameters(TransformParametersWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IntroduceVariableBase CreateIntroduceVariable(IntroduceLocalWorkflowBase workflow, ISolution solution, IRefactoringDriver driver);
    public virtual Static2ExtensionBase CreateStatic2Extension(Static2ExtensionWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual ConstructorToFactoryMethodBase CreateConstructor2FactoryMethod(Constructor2FactoryMethodWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual IntroduceParameterBase CreateIntroRefactoring(IntroduceParameterWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineMethod CreateInlineMethod(InlineMethodWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual UseBaseTypeBase CreateUseBaseType(UseBaseTypeWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual EncapsulateFieldBase CreateEncapsulateField(EncapsulateFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual MoveStaticMembers CreateMoveStaticMembers(MoveStaticMembersWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual MoveStaticMembersHelper CreateMoveStaticMembersHelper();
    public virtual IntroduceFieldBase CreateIntroduceField(IntroduceFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual Property2AutoBase CreateProperty2Auto(Property2AutoWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineFieldBase CreateInlineField(InlineFieldWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineVarBase CreateInlineVar(InlineVarWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual InlineParameterBase CreateInlineParameter(InlineParameterWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual RefactoringsHelper get_Helper();
    public virtual InlineParameterHelper CreateInlineParameterHelper();
    public virtual IMakeStaticHelper CreateMakeStaticHelper();
    public virtual SafeDeleteHelperUnsupported CreateSafeDeleteHelper();
    public virtual AdjustNamespacesHelperBase CreateAdjustNamespaceHelper();
    public virtual SafeDeleteBase CreateSafeDeleteBase(SafeDeleteWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual MakeStatic CreateMakeStaticHelper(MakeStaticWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual ParamsModifierConvertBase CreateParamsModifier(ParamsModifierWorkflow workflow, ISolution solution, IRefactoringDriver driver);
    public virtual MoveIntoMatchingFilesHelperBase CreateMoveIntoMatchingFilesHelper();
    public virtual MoveToFileHelperBase CreateMoveToFileHelper();
    public virtual MoveToNamespaceHelperBase CreateMoveToNamespaceHelper();
    public virtual IntroduceVariableHelper CreateIntroduceVariableHelper();
    public virtual MoveToFolderHelperBase CreateMoveToFolderHelper();
    public virtual ExtractClassHelper CreateExtractClassHelper(ExtractClassWorkflow workflow);
    public virtual ExtractClassRefactoringExec ExtractClassExec(ExtractClassWorkflow workflow, IRefactoringDriver driver);
    public virtual InlineClassHelper CreateInlineClassHelper(InlineClassWorkflow workflow);
    public virtual IInlineClassRefactoringExec InlineClassExec(InlineClassWorkflow workflow);
    public virtual MoveInstanceMethodHelper CreateMoveInstanceMethodHelper(MoveInstanceMethodWorkflow moveInstanceMethodWorkflow);
    public virtual IUnresolvedTypesChooser GetUnresolvedTypesChooser(ITreeNode context);
}
[LanguageAttribute("JetBrains.ReSharper.Psi.VB.VBLanguage", "16")]
public class JetBrains.ReSharper.Refactorings.VB.VBRefactoringService : object {
    public sealed virtual override ILocalScope[] FindScopesByDeclaredElement(IDeclaredElement declaredElement);
}
public class JetBrains.ReSharper.Refactorings.VB.VBRefactoringsHelper : RefactoringsHelper {
    public virtual bool ExtensionMethodsSupported(ITypeDeclaration typeDeclaration);
    public virtual IProperty2AutoChecker CreateProperty2AutoChecker();
    public virtual bool CheckForIntroduceAccessible(ITreeNode expression, IParametersOwner parametersOwner);
    public virtual bool DeclarationHasBody(IDeclaredElement element);
    public virtual bool Function2PropertyAvailable(IMethod method);
    public virtual bool IndexerIsPresented();
    public virtual string GetMakeMethodNonStaticTitle();
    public virtual INamespaceRedundancyProblemFixer NamespaceRedundancyFileFixer(INamespace namespace, IFile file);
    public virtual IExpression IntroParameterGetInitializer(ILocalVariable variable);
    public virtual bool CanUseExplicitly(IType type, ITreeNode context);
    public virtual IEnumerable`1<IDeclaredElement> GetLocals(IExpression expression, IParametersOwner owner);
    public virtual bool IsPartialMethod(ITypeMember member);
    public virtual ITypeDeclaration GetTypeDeclarationForField(ITypeDeclaration typeDeclaration, Boolean& baseTypeChoosed);
    public virtual IntroduceFieldAnalyser CreateIntroFieldAnalyser();
    public virtual bool CanUseInstanceFields(ITreeNode element);
    public virtual bool ReferencesRangeVariables(IExpression expression);
    public virtual string PresentAccessRights(AccessRights rights, bool useMnemonics);
    public virtual ITreeNode GetStatementVisibleForAll(IReadOnlyList`1<IExpression> expressions);
    public virtual IArgumentsOwner GetArgumentsOwner(IReference& reference, bool replaceMethodGroup);
    public virtual void SetNew(ITypeMemberDeclaration typeMember, bool isNew);
    public virtual bool IsNew(IDeclaration declaration);
    public virtual InlineVarAnalyserBase CreateInlineVarAnalyser(InlineVarWorkflow workflow);
    public virtual bool FailOnReferencesToLocals(IExpression expression);
    public virtual bool CanContainExtensionMethods(IClass class, IMethod candidate);
    public virtual bool IsIterator(IDeclaration declaration);
    public virtual bool IsReferenceName(ITreeNode element);
    public virtual bool CanExtractSuperclass(IDeclaration declaration);
    public virtual bool CanHaveDefaultProperty();
}
public class JetBrains.ReSharper.Refactorings.VB.VBRenameAvailabilityCheckResult : RenameAvailabilityCheckResult {
    public static VBRenameAvailabilityCheckResult CannotRenamePropertyAccessor;
    public static VBRenameAvailabilityCheckResult CannotRenameLambda;
    private static VBRenameAvailabilityCheckResult();
    private VBRenameAvailabilityCheckResult(string name, string message);
}
public class JetBrains.ReSharper.Refactorings.VB.VBStatementExtractMethod : StatementExtractMethodBase {
    private IEnumerable`1<IControlFlowEdge> myExitEdges;
    private ICollection`1<LocalVariable> myLocalVariables;
    private IVBStatementsRange myStatementsRange;
    private VBControlFlowAnalyzer myAnalyzer;
    private bool myIsModule;
    public ICollection`1<LocalVariable> LocalVariables { get; }
    protected IEnumerable`1<IControlFlowEdge> ExitEdges { get; }
    private VBElementFactory Factory { get; }
    public PsiLanguageType Language { get; }
    public bool IsValid { get; }
    public PsiLanguageType LanguageType { get; }
    public VBStatementExtractMethod(IVBStatementsRange statementsRange);
    public virtual bool Execute(IProgressIndicator pi);
    public virtual ICollection`1<LocalVariable> get_LocalVariables();
    protected virtual IEnumerable`1<IControlFlowEdge> get_ExitEdges();
    private VBElementFactory get_Factory();
    public virtual PsiLanguageType get_Language();
    public virtual bool get_IsValid();
    public virtual PsiLanguageType get_LanguageType();
    private IVBStatement CreateInvocation();
    private Pair`2<Nullable`1<GotoType>, string> DetermineExitType();
    private void AddGotoStatement(Pair`2<Nullable`1<GotoType>, string> exitType, IVBStatement invocationStatement);
    private IMethodDeclaration CreateDeclaration(IProgressIndicator progressIndicator);
    private Nullable`1<bool> GetValueReturnedFromFlagMethod();
    private static IParametersOwner GetContainingParametersOwner(IVBStatementsRange statementsRange);
    private void PlaceReturnStatement(IVBStatement statement, bool replace);
    protected virtual ExtractMethodParameter CreateParameter(LocalVariable localVariable, bool isReturned);
    protected virtual ExtractMethodParameter UpdateParameter(ExtractMethodParameter parameter, bool isReturned);
    public virtual string PreviewDeclaration();
    public virtual ExtractMethodAvailabilityCheckResult Check();
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Refactorings.VB.ZoneMarker : object {
}
