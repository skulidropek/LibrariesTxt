[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.<UnknownLanguageStage>FA45FDE0AA602878A10928BC57BABE346E36BB14D820733203BCF15FEC34A20D2__UnknownLanguageStageProcess : object {
    [CompilerGeneratedAttribute]
private IDaemonProcess <daemonProcess>P;
    [CompilerGeneratedAttribute]
private IFile <file>P;
    private List`1<ITypeElement> myDeclaredTypes;
    private List`1<MemberInheritanceInfo> myMemberInheritanceInfos;
    private List`1<ITypeDeclaration> myTopLevelTypeDeclarations;
    [CompilerGeneratedAttribute]
private IDaemonProcess <DaemonProcess>k__BackingField;
    private IFile JetBrains.ReSharper.Feature.Services.Daemon.IDaemonStageProcessWithPsiFile.File { get; }
    public IDaemonProcess DaemonProcess { get; }
    public <UnknownLanguageStage>FA45FDE0AA602878A10928BC57BABE346E36BB14D820733203BCF15FEC34A20D2__UnknownLanguageStageProcess(IDaemonProcess daemonProcess, IFile file);
    private sealed virtual override IFile JetBrains.ReSharper.Feature.Services.Daemon.IDaemonStageProcessWithPsiFile.get_File();
    [CompilerGeneratedAttribute]
public sealed virtual IDaemonProcess get_DaemonProcess();
    public sealed virtual void Execute(Action`1<DaemonStageResult> committer);
}
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.ActitivityTimeTracker : object {
    private int myEndTime;
    public bool ShouldStop { get; }
    public ActitivityTimeTracker(int ticks);
    public sealed virtual bool get_ShouldStop();
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.ActitivityTimeTrackerFactory : object {
    public virtual IActitivityTimeTracker Create(int ticks);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.AdditionalAnalysisInfo : object {
    [CanBeNullAttribute]
public UsagesInfo UsagesInfo;
    [CanBeNullAttribute]
public HierarchyInfo HierarchyInfo;
    [CanBeNullAttribute]
public FileContentInfo FileContentInfo;
    private AdditionalAnalysisInfo(UsagesInfo usagesInfo, HierarchyInfo hierarchyInfo, FileContentInfo fileContentInfo);
    [NotNullAttribute]
public static AdditionalAnalysisInfo Build(UsagesInfo usagesInfo, HierarchyInfo hierarchyInfo, FileContentInfo fileContentInfo);
    private static void SetFlags(Dictionary`2<ElementId, UsageState> map, IEnumerable`1<ElementId> elementIds, UsageState mask);
    private static void SetFlag(Dictionary`2<ElementId, UsageState> map, ElementId elementId, UsageState mask);
    public void WriteTo(UnsafeWriter writer);
    [NotNullAttribute]
public static AdditionalAnalysisInfo ReadFrom(UnsafeReader reader, IPsiSourceFile file, SolutionAnalysisConfiguration configuration);
}
[SolutionAnalysisComponentAttribute("10")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.AdditionalAnalysisInfoIndex : object {
    private Dictionary`2<int, SlimCountingSet`1<ElementId>> myCounters;
    private SlimDictionary`2<int, SlimCountingSet`1<ElementId>> myUseCountingMaps;
    private SlimOneToCountingSet`2<ElementId, ElementId> myTypeElementIdToInheritorsMap;
    private SlimOneToCountingSet`2<ElementId, ElementId> myMemberIdToSuperIdMap;
    private SlimOneToCountingSet`2<ElementId, ElementId> mySuperIdToMemberIdMap;
    private SlimOneToCountingSet`2<ElementId, ElementId> myMemberIdToQuasiSuperIdMap;
    private SlimOneToCountingSet`2<ElementId, ElementId> myQuasiSuperIdToMemberIdMap;
    private bool myHasErrorAtExtensionMerge;
    private int myTimestamp;
    private object LOCK;
    private SolutionAnalysisConfiguration mySweaConfiguration;
    private IImmutableList`1<SwaExtensionProviderBase> mySwaExtensionProviders;
    private MyHierarchyMembersChecker myHierarchyMembersChecker;
    private ILogger myLogger;
    private UsageCheckScope JetBrains.ReSharper.Daemon.UsageChecking.IUsageChecker.Scope { get; }
    private int JetBrains.ReSharper.Daemon.UsageChecking.IGlobalUsageChecker.Timestamp { get; }
    public AdditionalAnalysisInfoIndex(Lifetime lifetime, ISolution solution, SolutionAnalysisConfiguration sweaConfiguration, IEnumerable`1<IUsageCounter> counters, IImmutableList`1<SwaExtensionProviderBase> swaExtensionProviders, ILogger logger);
    public void Clear();
    public void UpdateInfo(AdditionalAnalysisInfo oldInfo, AdditionalAnalysisInfo newInfo);
    private void DropInfo(AdditionalAnalysisInfo info);
    private void UpdateMaps(AdditionalAnalysisInfo info, Action`2<SlimCountingSet`1<ElementId>, ElementId> processor1, Action`3<SlimOneToCountingSet`2<ElementId, ElementId>, ElementId, ElementId> processor2);
    internal void TrimExcessAfterFullLoad();
    private sealed virtual override UsageCheckScope JetBrains.ReSharper.Daemon.UsageChecking.IUsageChecker.get_Scope();
    private sealed virtual override bool JetBrains.ReSharper.Daemon.UsageChecking.IUsageChecker.HasUsages(IMemberInfo member, UsageState stateMask);
    private sealed virtual override bool JetBrains.ReSharper.Daemon.UsageChecking.IUsageChecker.HasUsages(IParameterInfo parameter, UsageState stateMask);
    private sealed virtual override UsageState JetBrains.ReSharper.Daemon.UsageChecking.IUsageChecker.GetUsageSubstate(IMemberInfo member, UsageState stateMask);
    private sealed virtual override UsageState JetBrains.ReSharper.Daemon.UsageChecking.IUsageChecker.GetUsageSubstate(IParameterInfo parameter, UsageState stateMask);
    private UsageState GetUsageSubstate(ElementId id, UsageState stateMask);
    private sealed virtual override bool JetBrains.ReSharper.Daemon.UsageChecking.IUsageChecker.HasSuperMembers(IMemberInfo member, bool includeQuasi);
    private sealed virtual override bool JetBrains.ReSharper.Daemon.UsageChecking.IUsageChecker.HasImplementingMembers(IMemberInfo member, bool includeQuasi);
    private sealed virtual override bool JetBrains.ReSharper.Daemon.UsageChecking.IUsageChecker.HasHierarchyMemberUsages(IMemberInfo member, UsageState stateMask, HierarchyWalkDirection walkDirection, HierarchyCheckMode mode);
    private sealed virtual override bool JetBrains.ReSharper.Daemon.UsageChecking.IUsageChecker.HasHierarchyParameterUsages(IParameterInfo parameter, UsageState stateMask, HierarchyWalkDirection walkDirection, HierarchyCheckMode mode);
    private sealed virtual override bool JetBrains.ReSharper.Daemon.UsageChecking.IUsageChecker.HasInheritors(IMembersOwnerInfo typeElement);
    public sealed virtual IType SuggestParameterTypeByUsage(IParameterInfo parameter);
    private sealed virtual override int JetBrains.ReSharper.Daemon.UsageChecking.IGlobalUsageChecker.get_Timestamp();
    public sealed virtual bool HasUsages(ElementId id, UsageState stateMask);
    public sealed virtual int GetExtensionMethodsCount(ElementId id);
    public sealed virtual int GetExposingApiCount(ElementId id);
    public sealed virtual int GetExposingApiCountWithDerived(ElementId id);
    public sealed virtual int GetMembersUsageCountWithSupers(ElementId id);
    public sealed virtual int GetUsageCount(ElementId id);
    public sealed virtual int GetCounterValue(ElementId id, IUsageCounter usageCounter);
    private int GetCount(ElementId id, int counterId);
    public sealed virtual int GetDerivedTypeElementsCount(ElementId id);
    public sealed virtual int GetDerivedTypeMembersCount(ElementId id);
    [MustUseReturnValueAttribute]
private PooledHashSet`1<ElementId> CollectAllTypeMembers(ElementId root, SlimOneToCountingSet`2<ElementId, ElementId> set);
    [CompilerGeneratedAttribute]
internal static void <CollectAllTypeMembers>g__Rec|46_0(ElementId id, <>c__DisplayClass46_0& );
}
[SolutionAnalysisComponentAttribute("0")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.AnalysisResultsManager : object {
    private DaemonResults myDaemonResults;
    private DependencyManager myDependencyManager;
    private SolutionAnalysisConfiguration mySweaConfiguration;
    [CompilerGeneratedAttribute]
private AdditionalAnalysisInfoIndex <AdditionalAnalysisInfoIndex>k__BackingField;
    public AdditionalAnalysisInfoIndex AdditionalAnalysisInfoIndex { get; }
    public AnalysisResultsManager(Lifetime lifetime, DaemonResults daemonResults, AdditionalAnalysisInfoIndex additionalAnalysisInfoIndex, DependencyManager dependencyManager, SolutionAnalysisConfiguration sweaConfiguration);
    [CompilerGeneratedAttribute]
public AdditionalAnalysisInfoIndex get_AdditionalAnalysisInfoIndex();
    [CanBeNullAttribute]
public AdditionalAnalysisInfo GetAdditionalAnalysisInfo(IPsiSourceFile psiSourceFile);
    public void UpdateAdditionalInfo(SourceFilePtr file, AdditionalAnalysisInfo additionalInfo);
    public void SetFileResults(SourceFilePtr file, HighlightingResult highlightingResult, DependencySet dependencySet, AdditionalAnalysisInfo additionalInfo);
    public void UpdateHighlightingResult(SourceFilePtr file, HighlightingResult highlightingResult);
    public void DropFileResults(SourceFilePtr file);
    public void ClearAll();
    [CanBeNullAttribute]
public AdditionalAnalysisInfo GetAdditionalInfo(SourceFilePtr file);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.BuildSweaSuppressor : object {
    public BuildSweaSuppressor(Lifetime lifetime, BuildIsRunning builder, SolutionAnalysisConfiguration sweaConf);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Cache.SolutionAnalysisDependenciesAndHashesCache : object {
    private IPersistentSortedMap`2<Dependency, Hash> myDependencyToHash;
    private IPersistentSortedMap`2<Dependency, Hash> myTouchedDependencyToHash;
    private IPersistentSortedMap`2<ISpecialDependency, ISpecialHash> mySpecialDependencyToHash;
    private IPersistentSortedMap`2<ISpecialDependency, ISpecialHash> myTouchedSpecialDependencyToHash;
    private ILogger myLogger;
    public SolutionAnalysisDependenciesAndHashesCache(ILogger logger, Lifetime lifetime, IPersistentIndexManager persistentIndexManager, SpecialDependencyManager specialDependencyManager);
    public string Dump();
    private void Add(Dependency dep, Hash hash, bool affectTouchedDependencies);
    internal void AddHashes(IEnumerable`1<KeyValuePair`2<Dependency, Hash>> dependenciesAndHashes, bool affectTouchedDependencies);
    internal void SubtractHashes(IEnumerable`1<KeyValuePair`2<Dependency, Hash>> dependenciesAndHashes, bool affectTouchedDependencies);
    internal void Compare(KeyValuePair`2[] olddep, KeyValuePair`2[] newdep, bool affectTouchedDependencies);
    public void PopulateChangedDependencies(IDictionary`2<Dependency, HashPair> res);
    private void Add(ISpecialDependency dep, ISpecialHash toSubtract, ISpecialHash toAdd, bool affectTouchedDependencies);
    internal void AddSpecialHashes(IEnumerable`1<KeyValuePair`2<ISpecialDependency, ISpecialHash>> dependenciesAndHashes, bool affectTouchedDependencies);
    internal void SubtractSpecialHashes(IEnumerable`1<KeyValuePair`2<ISpecialDependency, ISpecialHash>> dependenciesAndHashes, bool affectTouchedDependencies);
    internal void Compare(IList`1<KeyValuePair`2<ISpecialDependency, ISpecialHash>> olddep, IList`1<KeyValuePair`2<ISpecialDependency, ISpecialHash>> newdep, bool affectTouchedDependencies);
    internal void PopulateChangedSpecialDependencies(Dictionary`2<Dependency, HashPair> res);
    public void ClearTouched();
    public bool IsTouchedEmpty();
}
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ActionAttribute("CallGraphDump", "JetBrains.ReSharper.Daemon.SolutionAnalysis.Resources.Strings", "DumpCallGraphActionText")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.CallGraphDumpAction : object {
    public sealed virtual bool Update(IDataContext context, ActionPresentation presentation, DelegateUpdate nextUpdate);
    public sealed virtual void Execute(IDataContext context, DelegateExecute nextExecute);
}
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ActionAttribute("CallGraphDumpFile", "JetBrains.ReSharper.Daemon.SolutionAnalysis.Resources.Strings", "DumpCallGraphForFileActionText")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.CallGraphDumpFileAction : object {
    public sealed virtual bool Update(IDataContext context, ActionPresentation presentation, DelegateUpdate nextUpdate);
    public sealed virtual void Execute(IDataContext context, DelegateExecute nextExecute);
}
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ActionAttribute("CallGraphSize", "JetBrains.ReSharper.Daemon.SolutionAnalysis.Resources.Strings", "CallGraphElementsCountActionText")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.CallGraphSizeAction : object {
    public sealed virtual bool Update(IDataContext context, ActionPresentation presentation, DelegateUpdate nextUpdate);
    public sealed virtual void Execute(IDataContext context, DelegateExecute nextExecute);
}
[ZoneMarkerAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ActionGroupAttribute("1", "10")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.CallGraphTestMenu : object {
    public CallGraphTestMenu(CallGraphDumpAction callGraphDumpAction, CallGraphDumpFileAction callGraphDumpFileAction, CallGraphSizeAction callGraphSizeAction);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.CollectInspectionResults : object {
    private ISolution mySolution;
    private LifetimeDefinition myLifetimeDefinition;
    private IProgressIndicator myProgress;
    public CollectInspectionResults(ISolution solution, LifetimeDefinition lifetimeDefinition, IProgressIndicator progress);
    public void RunGlobalInspections(ITaskExecutor taskExecutor, Stack`1<IPsiSourceFile> filesToAnalyze, Action`1<List`1<IssuePointer>> consumer, IssueTypeGroup issueTypeGroup);
    private static void EnsureSweaIsCompleted(ISolution solution, SolutionAnalysisConfiguration sweaConf, SolutionAnalysisService sweaService, IProgressIndicator progress);
    public void RunLocalInspections(Stack`1<IPsiSourceFile> filesToAnalyze, Action`2<IPsiSourceFile, List`1<IssuePointer>> consumer, IssueTypeGroup issueTypeGroup);
    private void RunInspectionTask(IReadOnlyList`1<AnalyzerTask> analyzerTasks);
    public static bool IsFileForGlobalAnalysis(IPsiSourceFile sourceFile);
    private List`1<IssuePointer> CollectIssuesFromSolutionInspectionResults(ICollection`1<IPsiSourceFile> files, SolutionAnalysisManager solutionAnalysisManager, IIssueSet issueSet, IssueTypeGroup issueTypeGroup, IProgressIndicator progress);
    public static void CollectIssuesFromSolutionAnalysis(SolutionAnalysisManager manager, IIssueSet issueSet, IPsiSourceFile sourceFile, Action`1<IssuePointer> issueConsumer, IssueTypeGroup issueTypeGroup);
    public static void RunGlobalWarningsDaemon(ISolution solution, IProgressIndicator progress, IPsiSourceFile sourceFile, IGlobalUsageChecker usageChecker, Action`1<IssuePointer> issueConsumer, IssueTypeGroup issueTypeGroup, SolutionAnalysisConfiguration sweaConf, SolutionAnalysisService sweaService);
    private static void RunLocalDaemon(IProgressIndicator progress, IPsiSourceFile sourceFile, Action`1<IssuePointer> issueConsumer, IssueTypeGroup issueTypeGroup);
    [NotNullAttribute]
[PureAttribute]
private static Action`1<IssuePointer> ConsumeIssuesWithFiltering(List`1<IssuePointer> consumer, IssueTypeGroup issueTypeGroup);
}
[SolutionAnalysisComponentAttribute("0")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.DaemonResults : object {
    private Lifetime myLifetime;
    private IPersistentIndexManager myPersistentIndexManager;
    private IUnsafeMarshaller`1<DaemonResultsData> myMarshaller;
    private OptimizedPersistentSortedMap`2<SourceFilePtr, DaemonResultsData> myMap;
    private OptimizedPersistentSortedMap`2<int, int> myDaemonResultCount;
    private IShellLocks myShellLocks;
    private ILogger myLogger;
    private DependencyManager myDependencyManager;
    private DaemonEnablePolicy myDaemonEnablePolicy;
    public ISignal`1<DaemonResultsData> DataLoaded;
    public ISignal`1<AdditionalAnalysisInfo> AdditionalInfoReady;
    public ISignal`1<bool> DataLoadFinished;
    private int DaemonResultCount { get; private set; }
    public DaemonResults(Lifetime lifetime, ISolution solution, IPersistentIndexManager persistentIndexManager, StageIdManager stageIdManager, IssueStrings issueStrings, IssueClasses issueClasses, IShellLocks shellLocks, ILogger logger, DependencyManager dependencyManager, DaemonEnablePolicy daemonEnablePolicy, SolutionAnalysisConfiguration configuration);
    private int get_DaemonResultCount();
    private void set_DaemonResultCount(int value);
    private bool ShouldBeLoaded(DaemonResultsData data);
    public void Load(IProgressIndicator progress);
    internal void Set(SourceFilePtr sf, DaemonResultsData data, bool updatingExistingData);
    internal bool TryGet(SourceFilePtr sf, DaemonResultsData& data);
    public void Clear();
    [CompilerGeneratedAttribute]
private SourceFilePtr <.ctor>b__11_0(UnsafeReader reader);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[UsedImplicitlyAttribute("3")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.DataStructures.SlimCountingSet`1 : SlimHashSet`1<T> {
    [NotNullAttribute]
private SlimDictionary`2<T, int> myMultipleItems;
    public int Count { get; }
    public int Capacity { get; }
    public KeyEnumerable<T> Keys { get; }
    public int Add(T item);
    public int Add(T item, int count);
    public int Remove(T item);
    public sealed virtual int GetCount(T item);
    public sealed virtual bool Contains(T item);
    public void TrimExcess();
    public sealed virtual int get_Count();
    public int get_Capacity();
    public Enumerator<T> GetEnumerator();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Daemon.SolutionAnalysis.DataStructures.SlimCountingSet`1/<System-Collections-Generic-IEnumerable<System-Collections-Generic-KeyValuePair<T,System-Int32>>-GetEnumerator>d__12")]
private sealed virtual override IEnumerator`1<KeyValuePair`2<T, int>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<T,System.Int32>>.GetEnumerator();
    public KeyEnumerable<T> get_Keys();
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.DataStructures.SlimOneToCountingSet`2 : object {
    private SlimDictionary`2<TKey, TValue> myOnesMap;
    private SlimDictionary`2<TKey, SlimCountingSet`1<TValue>> myMultiMap;
    private static SlimCountingSet`1<TValue> ourEmpty;
    private static SlimOneToCountingSet`2();
    public int Add(TKey key, TValue item, int count);
    public bool Remove(TKey key);
    public bool ContainsKey(TKey key);
    public int GetCount(TKey key, TValue value);
    public void Clear();
    public ValuesEnumerable<TKey, TValue> GetValues(TKey key);
    public ValuesAndCountsEnumerable<TKey, TValue> GetValuesAndCounts(TKey key);
    public void TrimExcessRecursively(int spareItemsCount);
    [CompilerGeneratedAttribute]
private SlimCountingSet`1<TValue> <Add>g__GetCountingSetForKey|2_0(TKey key1);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.DeferredCachesSweaSuppressor : object {
    public DeferredCachesSweaSuppressor(Lifetime lifetime, DeferredCacheController controller, SolutionAnalysisConfiguration sweaConf);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.DependenciesInfo : object {
    public static DependenciesInfo Empty;
    [NotNullAttribute]
public IDictionary`2<Dependency, Hash> DependencyToHash;
    [NotNullAttribute]
public JetHashSet`1<Dependency> TouchedDependencies;
    [NotNullAttribute]
public IEnumerable`1<Dependency> Dependencies { get; }
    public DependenciesInfo(IDictionary`2<Dependency, Hash> dependencyToHash, JetHashSet`1<Dependency> touchedDependencies);
    private static DependenciesInfo();
    public static DependenciesInfo Build(ICollection`1<Dependency> dependencies, Func`2<Dependency, Hash> hashProducer);
    public IEnumerable`1<Dependency> get_Dependencies();
    public void WriteTo(BinaryWriter writer);
    [NotNullAttribute]
public static DependenciesInfo ReadFrom(BinaryReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SolutionAnalysisComponentAttribute("0")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.DependencyManager : object {
    private ILogger myLogger;
    private OptimizedPersistentSortedMap`2<SourceFilePtr, Int32[]> myMap;
    private OptimizedPersistentSortedMap`2<int, HashSet`1<SourceFilePtr>> myInvalidatedMap;
    [CompilerGeneratedAttribute]
private HashSet`1<SourceFilePtr> <InvalidatedFiles>k__BackingField;
    private static int InvalidatedKey;
    public HashSet`1<SourceFilePtr> InvalidatedFiles { get; }
    public DependencyManager(Lifetime lifetime, ILogger logger, IPersistentIndexManager persistentIndexManager);
    [CompilerGeneratedAttribute]
public HashSet`1<SourceFilePtr> get_InvalidatedFiles();
    public void Load();
    public void Clear();
    public IKeyValueEnumerator`2<SourceFilePtr, Int32[]> GetEnumerator(Int32[] changedDeps);
    public void SetFileDependencies(SourceFilePtr file, ICollection`1<Dependency> newDependencies);
    public void PersistInvalidated();
    private static Int32[] ToIntArray(ICollection`1<Dependency> newDependencies);
    public void DropFileOnLoad(SourceFilePtr file);
    public static int FilterDependenciesForFile(IKeyValueEnumerator`2<SourceFilePtr, Int32[]> en, Int32[] changedDeps, Int32[] changedForFile);
}
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.DummyDeclarationInfoParent : object {
    private IPsiSourceFile myFile;
    private PsiLanguageType myLanguage;
    private int myDeclarationIndex;
    public DummyDeclarationInfoParent(IFile psiFile, int topDeclarationIndex);
    private DummyDeclarationInfoParent(IPsiSourceFile file, PsiLanguageType language, int declarationIndex);
    public IDeclaration FindDeclaration();
    public void WriteTo(UnsafeWriter writer);
    [CanBeNullAttribute]
public static DummyDeclarationInfoParent Read(UnsafeReader reader, IPsiSourceFile file);
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.ErrorsView.IIssueOccurrence {
    public IIssue Issue { get; }
    public int StartOffset { get; }
    public abstract virtual IIssue get_Issue();
    public abstract virtual bool Navigate(PopupWindowContextSource windowContext, bool transferFocus);
    public abstract virtual int get_StartOffset();
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.ErrorsView.IIssueOccurrenceErrorViewNavigator {
    public abstract virtual void Navigate(IPsiSourceFile file);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.ErrorsView.IssueOccurrence : object {
    [CanBeNullAttribute]
private ProjectModelElementEnvoy myFileEnvoy;
    private OccurrenceMergeContext myMergeContext;
    [CompilerGeneratedAttribute]
private IIssue <Issue>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartOffset>k__BackingField;
    public IIssue Issue { get; }
    public TextRange TextRange { get; }
    public ProjectModelElementEnvoy ProjectModelElementEnvoy { get; }
    public DeclaredElementEnvoy`1<ITypeMember> TypeMember { get; }
    public DeclaredElementEnvoy`1<ITypeElement> TypeElement { get; }
    public DeclaredElementEnvoy`1<INamespace> Namespace { get; }
    private OccurrenceType JetBrains.ReSharper.Feature.Services.Occurrences.IOccurrence.OccurrenceType { get; }
    private bool JetBrains.ReSharper.Feature.Services.Occurrences.IOccurrence.IsValid { get; }
    public int StartOffset { get; }
    public OccurrencePresentationOptions PresentationOptions { get; public set; }
    public OccurrenceMergeContext MergeContext { get; }
    private IssueOccurrence(IIssue issue, ProjectModelElementEnvoy fileEnvoy, Nullable`1<TextRange> range);
    [CompilerGeneratedAttribute]
public sealed virtual IIssue get_Issue();
    public static IIssueOccurrence Create(IIssue issue, ProjectModelElementEnvoy fileEnvoy);
    public sealed virtual ISolution GetSolution();
    public TextRange get_TextRange();
    public ProjectModelElementEnvoy get_ProjectModelElementEnvoy();
    public DeclaredElementEnvoy`1<ITypeMember> get_TypeMember();
    public DeclaredElementEnvoy`1<ITypeElement> get_TypeElement();
    public DeclaredElementEnvoy`1<INamespace> get_Namespace();
    private sealed virtual override OccurrenceType JetBrains.ReSharper.Feature.Services.Occurrences.IOccurrence.get_OccurrenceType();
    private sealed virtual override bool JetBrains.ReSharper.Feature.Services.Occurrences.IOccurrence.get_IsValid();
    private sealed virtual override bool JetBrains.ReSharper.Feature.Services.Occurrences.INavigatable.Navigate(ISolution solution, PopupWindowContextSource windowContext, bool transferFocus, TabOptions tabOptions);
    public sealed virtual bool Navigate(PopupWindowContextSource windowContext, bool transferFocus);
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartOffset();
    private sealed virtual override string JetBrains.ReSharper.Feature.Services.Occurrences.IOccurrence.DumpToString();
    public sealed virtual OccurrencePresentationOptions get_PresentationOptions();
    public sealed virtual void set_PresentationOptions(OccurrencePresentationOptions value);
    public OccurrenceMergeContext get_MergeContext();
    public bool Equals(IssueOccurrence other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[SolutionFeaturePartAttribute("16")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.ErrorsView.IssueOccurrenceInfoProvider : object {
    public sealed virtual IDeclaredElementEnvoy GetTypeMember(IOccurrence occurrence);
    public sealed virtual IDeclaredElementEnvoy GetTypeElement(IOccurrence occurrence);
    public sealed virtual IDeclaredElementEnvoy GetNamespace(IOccurrence occurrence);
    public sealed virtual OccurrenceMergeContext GetMergeContext(IOccurrence occurrence);
    public sealed virtual TextRange GetTextRange(IOccurrence occurrence);
    public sealed virtual ProjectModelElementEnvoy GetProjectModelElementEnvoy(IOccurrence occurrence);
    public sealed virtual SourceFilePtr GetSourceFilePtr(IOccurrence occurrence);
    public sealed virtual bool IsApplicable(IOccurrence occurrence);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.ErrorsView.MissingFileIssueOccurrence : ProjectItemOccurrence {
    [CompilerGeneratedAttribute]
private IIssue <Issue>k__BackingField;
    public IIssue Issue { get; }
    public int StartOffset { get; }
    public MissingFileIssueOccurrence(IIssue issue);
    [CompilerGeneratedAttribute]
public sealed virtual IIssue get_Issue();
    public sealed virtual int get_StartOffset();
    public bool Equals(MissingFileIssueOccurrence other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Navigate(PopupWindowContextSource windowContext, bool transferFocus);
    private sealed virtual override string JetBrains.ReSharper.Feature.Services.Occurrences.IOccurrence.DumpToString();
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Daemon.SolutionAnalysis.ExternalizationUtil : object {
    [ExtensionAttribute]
public static void WriteNullableString(BinaryWriter writer, string s);
    [ExtensionAttribute]
public static string ReadNullableString(BinaryReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.FileContentInfo : object {
    private PsiLanguageType myLanguage;
    private MemberDeclarationInfo[] myTopLevelDeclarations;
    public PsiLanguageType Language { get; }
    public IEnumerable`1<IDeclarationInfo> TopLevelDeclarations { get; }
    private FileContentInfo(PsiLanguageType language, MemberDeclarationInfo[] topLevelDeclarations);
    [NullableContextAttribute("2")]
[PureAttribute]
public static FileContentInfo FromDaemonProcess(IDaemonProcess process, FileContentInfo oldInfo);
    public sealed virtual PsiLanguageType get_Language();
    public sealed virtual IEnumerable`1<IDeclarationInfo> get_TopLevelDeclarations();
    public void WriteTo(UnsafeWriter writer);
    public static FileContentInfo ReadFrom(UnsafeReader reader, IPsiSourceFile file);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.FileImages.FileImage : object {
    [NotNullAttribute]
private SpecialDependencyManager mySpecialDependencyManager;
    [NotNullAttribute]
private static ILogger ourLogger;
    [NotNullAttribute]
private KeyValuePair`2[] myDependencyToHash;
    [NotNullAttribute]
private IList`1<ModulePropertyValue> myPropertyDependencies;
    [NotNullAttribute]
private List`1<KeyValuePair`2<ISpecialDependency, ISpecialHash>> mySpecialDependencyToHash;
    [NotNullAttribute]
public KeyValuePair`2[] DependencyToHash { get; }
    [NotNullAttribute]
public List`1<KeyValuePair`2<ISpecialDependency, ISpecialHash>> SpecialDependencyToHash { get; }
    public FileImage(ISolution solution, KeyValuePair`2[] dependencyToHash, IList`1<ModulePropertyValue> propertyDependencies, List`1<KeyValuePair`2<ISpecialDependency, ISpecialHash>> specialDependencyToHash);
    private static FileImage();
    public static int Compare(KeyValuePair`2<Dependency, Hash> p1, KeyValuePair`2<Dependency, Hash> p2);
    public static int Compare(KeyValuePair`2<ISpecialDependency, ISpecialHash> p1, KeyValuePair`2<ISpecialDependency, ISpecialHash> p2);
    public static KeyValuePair`2[] MixDependencies(OneToListMap`2<Dependency, Hash> dependencyToHashes);
    public KeyValuePair`2[] get_DependencyToHash();
    public List`1<KeyValuePair`2<ISpecialDependency, ISpecialHash>> get_SpecialDependencyToHash();
    public void WriteData(UnsafeWriter writer);
    public static FileImage ReadData(UnsafeReader reader, ISolution solution);
    public bool CheckForModulePropertiesChange(IPsiModule module);
    public void TestDump(TextWriter builder);
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.FileImages.FileImages : object {
    private JetHashSet`1<SourceFilePtr> myDirtyFiles;
    private IDictionary`2<SourceFilePtr, ImagesData> myFileImagesToProcess;
    private JetHashSet`1<PsiModulePtr> myDirtyModules;
    private IDictionary`2<PsiModulePtr, ImagesData> myModuleImagesToProcess;
    private bool myModuleImagesSubtracted;
    private bool myLoadedFileImagesSubtracted;
    private LifetimeDefinition myCurrentSweaLifecycle;
    private OptimizedPersistentSortedMap`2<SourceFilePtr, ImagesData> myFileImages;
    private OptimizedPersistentSortedMap`2<SourceFilePtr, long> myImagesTimestamp;
    private OptimizedPersistentSortedMap`2<SourceFilePtr, long> myImagesTextHash;
    private OptimizedPersistentSortedMap`2<PsiModulePtr, ImagesData> myModuleImages;
    [CompilerGeneratedAttribute]
private IProperty`1<bool> <Active>k__BackingField;
    private SolutionAnalysisDependenciesAndHashesCache myDependenciesCache;
    private InternalsVisibleToCache myInternalsVisibleToCache;
    private ISolution mySolution;
    private IPsiCachesState myCachesState;
    private IDaemonThread myDaemonThread;
    private IShellLocks myShellLocks;
    private IPsiModules myPsiModules;
    private FileImagesBuilder myImagesBuilder;
    private ILogger myLogger;
    private Lifetime myLifetime;
    private IPersistentIndexManager myPersistentIndexManager;
    private SolutionAnalysisConfiguration mySweaConfiguratuion;
    private IAutocommitTransaction myTx;
    private int myDisableCheckThread;
    public IProperty`1<bool> Active { get; }
    public bool HasDirtyFiles { get; }
    public FileImages(ILogger logger, Lifetime lifetime, ISolution solution, IPsiCachesState cachesState, IDaemonThread daemonThread, IShellLocks shellLocks, PsiModules psiModules, FileImagesBuilder imagesBuilder, ISolutionLoadTasksScheduler scheduler, IPersistentIndexManager persistentIndexManager, ChangeManager changeManager, ISettingsStore settingsStore, ISolutionOwner solutionOwner, SolutionAnalysisConfiguration sweaConfiguration, SolutionAnalysisDependenciesAndHashesCache dependenciesCache, FileImagesMarshaller fileImagesMarshaller, InternalsVisibleToCache internalsVisibleToCache);
    [CompilerGeneratedAttribute]
public sealed virtual IProperty`1<bool> get_Active();
    [NotNullAttribute]
public static FileImages GetInstance(ISolution solution);
    [NotNullAttribute]
public IDictionary`2<Dependency, HashPair> FlushChanges(bool optimizeInitialLoad);
    public void ClearTouched();
    public void MarkModuleAsDirty(IPsiModule psiModule);
    private void AddAllModulesToDirty();
    private void ProcessDirtyFiles();
    private void ProcessDirtyModules();
    private void SubtractLoadedFileImages(bool affectTouched);
    private void SubtractInvalidModuleImages(bool affectTouched);
    private void ProcessModuleImages(bool affectTouched);
    private void ProcessFileImages(bool affectTouched);
    public void TestDump(IEnumerable`1<KeyValuePair`2<Dependency, HashPair>> depToHash, TextWriter builder);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.ISwitchingCache.Initialize();
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.ISwitchingCache.Release();
    private sealed virtual override object JetBrains.ReSharper.Psi.Caches.ICache.Load(IProgressIndicator progress, bool enablePersistence);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.ICache.MergeLoaded(object data);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.ICache.Save(IProgressIndicator progress, bool enablePersistence);
    public sealed virtual bool get_HasDirtyFiles();
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.SyncUpdate(bool underTransaction);
    public sealed virtual void Dump(TextWriter writer, IPsiSourceFile sourceFile);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.OnDocumentChange(IPsiSourceFile sourceFile, ProjectFileDocumentCopyChange change);
    public sealed virtual void MarkAsDirty(IPsiSourceFile sourceFile);
    public sealed virtual bool UpToDate(IPsiSourceFile sourceFile);
    public object Build(IPsiSourceFile sourceFile);
    public sealed virtual object Build(IPsiSourceFile sourceFile, bool isStartup);
    public sealed virtual void Merge(IPsiSourceFile sourceFile, object builtPart);
    private void CompareImageDatas(ImagesData oldData, ImagesData newData, bool affectTouchedDependencies);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.Drop(IPsiSourceFile sourceFile);
    private sealed virtual override void JetBrains.ReSharper.Psi.Caches.IPsiSourceFileCache.OnPsiChange(ITreeNode elementContainingChanges, PsiChangedElementType type);
    public sealed virtual object Execute(IChangeMap changeMap);
    [MustDisposeResourceAttribute]
public IDisposable DisableCheckThread();
    [ConditionalAttribute("JET_MODE_ASSERT")]
private void AssertCorrectThread();
    [CompilerGeneratedAttribute]
private bool <JetBrains.ReSharper.Psi.Caches.ICache.Load>b__42_0();
    [CompilerGeneratedAttribute]
private void <DisableCheckThread>b__60_0();
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.FileImages.FileImagesBuilder : object {
    private ISolution mySolution;
    private IEnumerable`1<IFileImageContributor> myFileImageContributors;
    private IShellLocks myShellLocks;
    private IPsiModules myPsiModules;
    private DependencyFactory myDependencyFactory;
    private InternalsVisibleToCache myInternalsVisibleToCache;
    private ILogger myLogger;
    public static Key`1<FileImagesBuilderAllowKey> FileImagesBuilderAllowKey;
    public FileImagesBuilder(ISolution solution, IEnumerable`1<IFileImageContributor> fileImageContributors, IShellLocks shellLocks, IPsiModules psiModules, DependencyFactory dependencyFactory, InternalsVisibleToCache internalsVisibleToCache);
    private static FileImagesBuilder();
    public bool ShouldBuildImageData(IPsiSourceFile sf);
    [CanBeNullAttribute]
public ImagesData BuildImagesData(IPsiSourceFile sourceFile);
    [CanBeNullAttribute]
public ImagesData BuildImagesData(IPsiModule module);
    private FileImage[] BuildImages(IPsiSourceFile sf, IEnumerable`1<IFileWithDependencies> fileWithDependencies);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.FileImages.FileImagesBuilderAllowKey : object {
    public static FileImagesBuilderAllowKey Instance;
    private static FileImagesBuilderAllowKey();
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.FileImages.FileImagesMarshaller : object {
    private ISolution mySolution;
    public FileImagesMarshaller(ISolution solution);
    public sealed virtual void Marshal(UnsafeWriter writer, ImagesData data);
    public sealed virtual ImagesData Unmarshal(UnsafeReader reader);
}
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.FileImages.FileScanner : object {
    private IFileWithDependencies myFile;
    private IPsiModule myPsiModule;
    private OneToListMap`2<Dependency, Hash> myDependencyToHashes;
    private JetHashSet`1<string> myDeclaredNamespaces;
    private List`1<KeyValuePair`2<ISpecialDependency, ISpecialHash>> mySpecialDependencies;
    private SpecialUsingsDependencyContributor myUsingsContributor;
    public FileScanner(IFileWithDependencies file, IPsiModule psiModule, OneToListMap`2<Dependency, Hash> dependencyToHashes);
    public FileImage Run();
    private void ProcessEntity(object entity, IUsingsInfo usingsInfo, string parentQualifiedName, Boolean& hasAnythingInternal);
    [NotNullAttribute]
private static List`1<T> DistinctSorted(List`1<T> list);
    [NotNullAttribute]
private FileImage GetResult();
    private void ProduceNamespaceSpecialDependencies(IEnumerable`1<string> namespaces);
    [CompilerGeneratedAttribute]
private ModulePropertyValue <GetResult>b__10_0(ModuleProperty dependency);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.FileImages.ImagesData : object {
    public FileImage[] Images;
    public long Timestamp;
    public Nullable`1<long> TextHash;
    public ImagesData(FileImage[] images, long timestamp, Nullable`1<long> textHash);
}
internal static class JetBrains.ReSharper.Daemon.SolutionAnalysis.FileImages.InternedNamespacesMap : object {
    private static WeakToWeakDictionary`2<string, string> ourMap;
    private static InternedNamespacesMap();
    public static string Intern(string ns);
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.FileImages.ModulePropertyValue : ValueType {
    public ModuleProperty Property;
    public Hash ValueHash;
    public ModulePropertyValue(ModuleProperty property, Hash valueHash);
    public void WriteTo(UnsafeWriter writer);
    public static ModulePropertyValue ReadFrom(UnsafeReader reader);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.FileImages.NamespaceDependency : object {
    public string QualfierNamespaceName;
    public bool HasAnythingInternal;
    private int myNameHash;
    private static ILogger ourLogger;
    private static Dictionary`2<int, string> ourTestNamePresentationsMap;
    private string NamePresentation { get; }
    public NamespaceDependency(string qualfierNamespaceName, string name, bool hasAnythingInternal);
    private NamespaceDependency(string qualfierNamespaceName, int nameHash, bool hasAnythingInternal);
    private static NamespaceDependency();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal static void InitTestPresentationsMap();
    internal static void ReleaseTestPresentationsMap();
    private string get_NamePresentation();
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.FileImages.SpecialNamespaceCountHash : object {
    [CompilerGeneratedAttribute]
private int <value>P;
    [CompilerGeneratedAttribute]
private ISpecialDependencyContributor <Contributor>k__BackingField;
    public ISpecialDependencyContributor Contributor { get; }
    public int Value { get; }
    public SpecialNamespaceCountHash(ISpecialDependencyContributor contributor, int value);
    [CompilerGeneratedAttribute]
public sealed virtual ISpecialDependencyContributor get_Contributor();
    public int get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual ISpecialHash AddSub(ISpecialHash toSub, ISpecialHash toAdd);
    public sealed virtual bool IsEmpty();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.FileImages.SpecialNamespaceDependency : object {
    [CompilerGeneratedAttribute]
private SpecialNamespaceDependencyContributor <contributor>P;
    private string myModuleName;
    private string myNamespace;
    public string Ns { get; }
    public string ModuleName { get; }
    public ISpecialDependencyContributor Contributor { get; }
    public SpecialNamespaceDependency(SpecialNamespaceDependencyContributor contributor, string ns, string moduleName);
    public sealed virtual bool Equals(SpecialNamespaceDependency other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string get_Ns();
    public string get_ModuleName();
    public sealed virtual ISpecialDependencyContributor get_Contributor();
    public sealed virtual void ProduceDependencies(ISpecialHash old, ISpecialHash new, Dictionary`2<Dependency, HashPair> resultSet);
    private Dependency GetDependency(string namespace);
    public sealed virtual int CompareTo(ISpecialDependency other);
    public virtual string ToString();
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.FileImages.SpecialNamespaceDependencyContributor : object {
    public static SpecialNamespaceDependencyContributor GetInstance(ISolution solution);
    public sealed virtual ISpecialDependency ReadDepedency(UnsafeReader reader);
    public sealed virtual ISpecialHash ReadHash(UnsafeReader reader);
    public sealed virtual void WriteDependency(UnsafeWriter writer, ISpecialDependency dependency);
    public sealed virtual void WriteHash(UnsafeWriter writer, ISpecialHash hash);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.FileImages.SpecialUsingsDependency : object {
    private SpecialUsingsDependencyContributor myContributor;
    private UsingsTypeInfo myInfo;
    public UsingsTypeInfo Info { get; }
    public ISpecialDependencyContributor Contributor { get; }
    public SpecialUsingsDependency(SpecialUsingsDependencyContributor contributor, UsingsTypeInfo info);
    public UsingsTypeInfo get_Info();
    public sealed virtual ISpecialDependencyContributor get_Contributor();
    public sealed virtual void ProduceDependencies(ISpecialHash oldHash, ISpecialHash newHash, Dictionary`2<Dependency, HashPair> resultSet);
    private void CompareMatching(List`1<IUsingsInfo> oldInfos, List`1<IUsingsInfo> newInfos, Func`3<IUsingsInfo, IUsingsInfo, bool> equality, Dictionary`2<Dependency, HashPair> resultSet);
    public virtual string ToString();
    public sealed virtual bool Equals(SpecialUsingsDependency other);
    public virtual bool Equals(object obj);
    public sealed virtual int CompareTo(ISpecialDependency other);
    public virtual int GetHashCode();
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.FileImages.SpecialUsingsDependencyContributor : object {
    [CompilerGeneratedAttribute]
private PsiModules <PsiModules>k__BackingField;
    public PsiModules PsiModules { get; }
    public SpecialUsingsDependencyContributor(PsiModules psiModules);
    [CompilerGeneratedAttribute]
public PsiModules get_PsiModules();
    public static SpecialUsingsDependencyContributor GetInstance(ISolution solution);
    public sealed virtual ISpecialDependency ReadDepedency(UnsafeReader reader);
    public sealed virtual ISpecialHash ReadHash(UnsafeReader reader);
    public sealed virtual void WriteDependency(UnsafeWriter writer, ISpecialDependency dependency);
    public sealed virtual void WriteHash(UnsafeWriter writer, ISpecialHash hash);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.FileImages.SpecialUsingsHash : object {
    [CompilerGeneratedAttribute]
private ISpecialDependencyContributor <Contributor>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IUsingsInfo> <Value>k__BackingField;
    public ISpecialDependencyContributor Contributor { get; }
    public List`1<IUsingsInfo> Value { get; }
    public SpecialUsingsHash(ISpecialDependencyContributor contributor, List`1<IUsingsInfo> value);
    [CompilerGeneratedAttribute]
public sealed virtual ISpecialDependencyContributor get_Contributor();
    [CompilerGeneratedAttribute]
public List`1<IUsingsInfo> get_Value();
    public sealed virtual ISpecialHash AddSub(ISpecialHash toSub, ISpecialHash toAdd);
    private static int Compare(IUsingsInfo info1, IUsingsInfo info2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool IsEmpty();
    public virtual string ToString();
}
internal static class JetBrains.ReSharper.Daemon.SolutionAnalysis.FileImages.UsingsDependenciesUtil : object {
    public static void Compare(IUsingsInfo oldInfo, IUsingsInfo newInfo, UsingsTypeInfo typeInfo, PsiModules psiModules, IDictionary`2<Dependency, HashPair> resultDependencies);
    private static bool CompareSymbolInfoLists(IList`1<ISymbolInfo> infos1, IList`1<ISymbolInfo> infos2);
    private static bool CompareSymbolInfoSets(IList`1<ISymbolInfo> infos1, IList`1<ISymbolInfo> infos2);
    private static void AssignNewLevels(ICollection`1<ISymbolInfo> infos, Int32& levelsCount, OneToListMap`2& levelToInfo);
    private static bool CompareSymbolInfos(ISymbolInfo info1, ISymbolInfo info2);
}
[DebuggerTypeProxyAttribute("JetBrains.ReSharper.Daemon.SolutionAnalysis.HighlightingResultDebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.HighlightingResult : object {
    private SourceFilePtr myFile;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`2<string, byte>, StageHighlightingResult> myStageToResult;
    private JetHashSet`1<string> myCurrentStages;
    private bool myCompleted;
    private static ILogger ourLogger;
    public bool Completed { get; }
    [UsedImplicitlyAttribute]
private int Count { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<ValueTuple`2<string, byte>, StageHighlightingResult>> StageResults { get; }
    public HighlightingResult(SourceFilePtr file);
    private HighlightingResult(SourceFilePtr file, Dictionary`2<ValueTuple`2<string, byte>, StageHighlightingResult> stageToResult);
    private static HighlightingResult();
    [NotNullAttribute]
public HighlightingResult Clone();
    public bool get_Completed();
    public void AddStageResult(string stageId, byte layer, StageHighlightingResult result, bool fullRehighlight, IEnumerable`1<DocumentRange> ranges);
    [NotNullAttribute]
private static StageHighlightingResult MergeIssues(StageHighlightingResult prevResult, StageHighlightingResult newResult, bool fullRehighlight, IEnumerable`1<DocumentRange> ranges);
    private static bool IsToKeep(IssueData issue, IEnumerable`1<DocumentRange> ranges);
    public void Complete(bool incrementalPass, Boolean& anythingDropped);
    private int get_Count();
    public bool HasAnyIssues();
    [NotNullAttribute]
public IEnumerable`1<IssueData> EnumerateIssueDatas();
    [NotNullAttribute]
[PureAttribute]
public StageHighlightingResult[] GetStageHighlightingResultsSnapshot();
    public IEnumerable`1<KeyValuePair`2<ValueTuple`2<string, byte>, StageHighlightingResult>> get_StageResults();
    public void WriteTo(UnsafeWriter writer);
    public static HighlightingResult ReadFrom(UnsafeReader reader, SourceFilePtr file, StageIdManager stageIdManager, IssueStrings issueStrings, IssueClasses issueClasses);
    public void UpdatableRanges(Func`2<TextRange, TextRange> updateFunc);
    [PureAttribute]
public bool HasIssuesOfType(HashSet`1<IIssueType> issueTypes);
    [CompilerGeneratedAttribute]
private bool <Complete>b__13_0(ValueTuple`2<string, byte> stageResultKey);
}
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.HighlightingResultDebugView : object {
    [CompilerGeneratedAttribute]
private HighlightingResult <result>P;
    [NotNullAttribute]
[UsedImplicitlyAttribute]
[DebuggerBrowsableAttribute("3")]
public IssueData[] Issues { get; }
    public HighlightingResultDebugView(HighlightingResult result);
    public IssueData[] get_Issues();
}
[DefaultMemberAttribute("Item")]
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.HighlightingResultsMap : object {
    private Lifetime myLifetime;
    private ISolution mySolution;
    private IShellLocks myShellLocks;
    private IActitivityTimeTrackerFactory myActitivityTimeTrackerFactory;
    private CompactMap`2<SourceFilePtr, HighlightingResult> myFileToResultMap;
    private HashSet`1<SourceFilePtr> myFilesToBeReanalyzed;
    private HashSet`1<SourceFilePtr> myFilesToBeReanalyzedQuickly;
    private HashSet`1<PsiModulePtr> myModulesToIgnore;
    private int myTotalFilesToBeAnalyzed;
    private object myLock;
    private List`1<IssueGroup> myIssueGroups;
    private IssueGroup myAllIssuesGroup;
    private IssueGroup myErrorsGroup;
    private IssueGroup myWarningsGroup;
    private GroupingEvent myGrouping;
    private ConcurrentDictionary`2<SourceFilePtr, IReadOnlyList`1<IssuePointer>> myFilesWithIssuesToUpdate;
    private AsyncItemsProcessor`1<SourceFilePtr> myIssueListCalculator;
    private static ILogger ourLogger;
    [CompilerGeneratedAttribute]
private ISignal`1<Pair`2<SourceFilePtr, HighlightingResult>> <IgnoreChanged>k__BackingField;
    [CompilerGeneratedAttribute]
private Signal`1<ICollection`1<SourceFilePtr>> <FilesToBeReanalyzedChanged>k__BackingField;
    public ISignal`1<Pair`2<SourceFilePtr, HighlightingResult>> IgnoreChanged { get; }
    public Signal`1<ICollection`1<SourceFilePtr>> FilesToBeReanalyzedChanged { get; }
    [CanBeNullAttribute]
public HighlightingResult Item { get; }
    public IIssueGroup AllIssues { get; }
    public IIssueGroup Errors { get; }
    public IIssueGroup Warnings { get; }
    public int FilesToBeReanalyzedCount { get; }
    public int TotalFilesToBeAnalyzed { get; }
    public IProperty`1<bool> GroupingEventIsWaiting { get; }
    public HighlightingResultsMap(Lifetime lifetime, ISolution solution, IShellLocks shellLocks, ISettingsStore settingsStore, UpdatableTextRangesSources updatableTextRangesSources, IActitivityTimeTrackerFactory actitivityTimeTrackerFactory, SolutionAnalysisConfiguration configuration, ICalculatedSettingsSchema calculatedSettingsSchema);
    private static HighlightingResultsMap();
    [CompilerGeneratedAttribute]
public ISignal`1<Pair`2<SourceFilePtr, HighlightingResult>> get_IgnoreChanged();
    [CompilerGeneratedAttribute]
public sealed virtual Signal`1<ICollection`1<SourceFilePtr>> get_FilesToBeReanalyzedChanged();
    public sealed virtual void OnHighlightingSettingsChanged();
    [NotNullAttribute]
private static IReadOnlyList`1<IssuePointer> CreatePointersToIssues(StageHighlightingResult[] results, SourceFilePtr file, ISolution solution, IContextBoundSettingsStore boundSettingsStore);
    private void IssuesUpdatedUnderReadLock(SourceFilePtr file);
    private void IssuesUpdated(SourceFilePtr file);
    private void IssuesUpdated(IEnumerable`1<SourceFilePtr> files);
    public void SyncUpdate();
    public void RunOperationWithLock(Action operation);
    private void UpdateGroups();
    private void UpdateGroups(bool sync);
    public void OnIgnoreChanged(SourceFilePtr ptr);
    internal void ChangeModuleIgnore(IPsiModule module, bool ignore);
    public void Clear();
    public HighlightingResult get_Item(SourceFilePtr file);
    public void ResultLoaded(SourceFilePtr file, HighlightingResult result);
    public void AddStageResult(SourceFilePtr file, string stageId, byte layer, Nullable`1<int> settingsHash, IssueData[] issues, bool fullRehighlight, IEnumerable`1<DocumentRange> ranges);
    [NotNullAttribute]
public HighlightingResult CompleteResult(SourceFilePtr file, bool incrementalPass);
    private HighlightingResult GetResult(SourceFilePtr file);
    public void FileAnalyzed(SourceFilePtr file);
    public void RemoveResult(SourceFilePtr file);
    private static void DiffSets(HashSet`1<SourceFilePtr> set1, HashSet`1<SourceFilePtr> set2, LocalList`1& diff);
    public void SetFilesToBeReanalyzed(HashSet`1<SourceFilePtr> slowFiles, int totalSlowFiles, HashSet`1<SourceFilePtr> filesToAnalyzeQuickly);
    public sealed virtual IIssueGroup get_AllIssues();
    public sealed virtual IIssueGroup get_Errors();
    public sealed virtual IIssueGroup get_Warnings();
    public sealed virtual int get_FilesToBeReanalyzedCount();
    public sealed virtual int get_TotalFilesToBeAnalyzed();
    public IProperty`1<bool> get_GroupingEventIsWaiting();
    public sealed virtual bool IsFileToBeReanalyzed(SourceFilePtr file);
    private void FireFilesToBeReanalyzedChanged(ICollection`1<SourceFilePtr> changedForFiles);
    public sealed virtual void UpdatableRangesInFile(SourceFilePtr file, Func`2<TextRange, TextRange> updateFunc);
    [CompilerGeneratedAttribute]
private void <.ctor>b__18_3(Nullable`1<bool> invalidate);
    [CompilerGeneratedAttribute]
private void <.ctor>b__18_4();
    [CompilerGeneratedAttribute]
private void <.ctor>b__18_5(Lifetime lt);
    [CompilerGeneratedAttribute]
private bool <UpdateGroups>b__33_0();
    [CompilerGeneratedAttribute]
private void <Clear>b__36_0();
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.IActitivityTimeTracker {
    public bool ShouldStop { get; }
    public abstract virtual bool get_ShouldStop();
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.IActitivityTimeTrackerFactory {
    public abstract virtual IActitivityTimeTracker Create(int ticks);
}
internal interface JetBrains.ReSharper.Daemon.SolutionAnalysis.IDeclarationInfoParent {
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.IIssue {
    public SourceFilePtr File { get; }
    public Nullable`1<TextRange> Range { get; }
    public int NavigationOffset { get; }
    public bool IsValid { get; }
    public string Message { get; }
    public IIssueType IssueType { get; }
    public bool Ignored { get; }
    public abstract virtual SourceFilePtr get_File();
    public abstract virtual Nullable`1<TextRange> get_Range();
    public abstract virtual int get_NavigationOffset();
    public abstract virtual bool get_IsValid();
    public abstract virtual string get_Message();
    public abstract virtual IIssueType get_IssueType();
    public abstract virtual Severity GetSeverity();
    public abstract virtual bool get_Ignored();
    public abstract virtual void SetIgnored(HighlightingResultsMap resultsMap, bool value);
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.IIssueGroup {
    public ISignal`1<Nullable`1<SourceFilePtr>> Changed { get; }
    public abstract virtual void RunOperationWithLock(Action operation);
    public abstract virtual bool IsEmpty(bool includeIgnored);
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<IssuePointer> GetIssues(bool includeIgnored);
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<IssuePointer> GetIssues(SourceFilePtr file, bool includeIgnored);
    [NotNullAttribute]
public abstract virtual IReadOnlyList`1<SourceFilePtr> GetFilesWithIssues(bool includeIgnored);
    public abstract virtual int GetIssueCount(bool includeIgnored);
    public abstract virtual int GetIssueCount(SourceFilePtr file, bool includeIgnored);
    public abstract virtual int GetFilesWithIssuesCount(bool includeIgnored);
    public abstract virtual ISignal`1<Nullable`1<SourceFilePtr>> get_Changed();
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.IIssueSet {
    public IIssueGroup AllIssues { get; }
    public IIssueGroup Errors { get; }
    public IIssueGroup Warnings { get; }
    public int FilesToBeReanalyzedCount { get; }
    public int TotalFilesToBeAnalyzed { get; }
    public Signal`1<ICollection`1<SourceFilePtr>> FilesToBeReanalyzedChanged { get; }
    public abstract virtual IIssueGroup get_AllIssues();
    public abstract virtual IIssueGroup get_Errors();
    public abstract virtual IIssueGroup get_Warnings();
    public abstract virtual int get_FilesToBeReanalyzedCount();
    public abstract virtual int get_TotalFilesToBeAnalyzed();
    public abstract virtual bool IsFileToBeReanalyzed(SourceFilePtr file);
    public abstract virtual Signal`1<ICollection`1<SourceFilePtr>> get_FilesToBeReanalyzedChanged();
}
[TypeConverterAttribute("JetBrains.ReSharper.Daemon.SolutionAnalysis.IssueTypeConverter")]
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.IIssueType {
    [CanBeNullAttribute]
public string LeafPresentation { get; }
    [CanBeNullAttribute]
public string Presentation { get; }
    [NotNullAttribute]
public string GroupId { get; }
    [CanBeNullAttribute]
public string CompoundItemName { get; }
    public SolutionAnalysisMode SolutionAnalysisMode { get; }
    [CanBeNullAttribute]
public string ConfigurableSeverityId { get; }
    public abstract virtual Severity GetSeverity(IPsiSourceFile sourceFile, ISolution solution, IContextBoundSettingsStore settingsStore);
    public abstract virtual string get_LeafPresentation();
    public abstract virtual string get_Presentation();
    public abstract virtual string get_GroupId();
    public abstract virtual string get_CompoundItemName();
    public abstract virtual SolutionAnalysisMode get_SolutionAnalysisMode();
    public abstract virtual string get_ConfigurableSeverityId();
    public abstract virtual void WriteTo(UnsafeWriter writer);
}
[FlagsAttribute]
public enum JetBrains.ReSharper.Daemon.SolutionAnalysis.Indicator.IndicatorState : Enum {
    public int value__;
    public static IndicatorState IDLE;
    public static IndicatorState ANALYZING;
    public static IndicatorState OFF;
    public static IndicatorState LOADING;
    public static IndicatorState NOT_LOADED;
    public static IndicatorState CACHE_LOCKED;
    public static IndicatorState CACHE_IO_PROBLEM;
    public static IndicatorState ANALYZING_CHANGES;
    public static IndicatorState ANALYSIS_PAUSED;
    public static IndicatorState LOADING_PAUSED;
    public static IndicatorState MAIN_STATE_PART;
    public static IndicatorState ERRORS;
    public static IndicatorState INTERRUPTED;
    public static IndicatorState WARNINGS;
}
public static class JetBrains.ReSharper.Daemon.SolutionAnalysis.Indicator.SolutionAnalysisIndicatorRoundImages : object {
    public static int ROUND_PROGRESS_CHUNK_COUNT;
    public static IconId[] ourAnalyzingChangesImages;
    public static IconId ourCacheLockedImage;
    public static IconId[] ourErrorsProgressAnimationImages;
    public static IconId[] ourWarningsProgressAnimationImages;
    public static IconId[] ourErrorsProgressImages;
    public static IconId[] ourWarningsProgressImages;
    public static IconId ourFinsihedErrorsImage;
    public static IconId ourFinsihedWarningsImage;
    public static IconId ourFinsihedNoErrorsImage;
    public static IconId[] ourLoadingProgressAnimationImages;
    public static IconId[] ourLoadingProgressImages;
    public static IconId[] ourNoErrorsProgressAnimationImages;
    public static IconId[] ourNoErrorsProgressImages;
    public static IconId ourOffImage;
    public static IconId ourPausedImage;
    public static int PHASE_COUNT;
    private static SolutionAnalysisIndicatorRoundImages();
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.InspectCode.InspectCodeDaemon : DaemonProcessBaseImpl {
    [NotNullAttribute]
private IssueClasses myIssueClasses;
    [NotNullAttribute]
private FileImages myFileImages;
    public bool InterruptFlag { get; }
    public bool FullRehighlightingRequired { get; }
    public InspectCodeDaemon(IssueClasses issueClasses, IPsiSourceFile sourceFile, FileImages fileImages);
    public void DoHighlighting(DaemonProcessKind daemonProcessKind, Action`1<IIssue> issueConsumer);
    public virtual bool get_InterruptFlag();
    public virtual bool IsRangeInvalidated(DocumentRange range);
    public virtual bool get_FullRehighlightingRequired();
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.InspectCode.InspectCodeFinder : object {
    [NotNullAttribute]
private UITaskExecutor myUITaskExecutor;
    [NotNullAttribute]
private IShellLocks myLocks;
    [NotNullAttribute]
private DaemonEnablePolicy myDaemonEnablePolicy;
    [NotNullAttribute]
private ISolution mySolution;
    [NotNullAttribute]
private IssueClasses myIssueClasses;
    [NotNullAttribute]
private FileImages myFileImages;
    [NotNullAttribute]
private SolutionAnalysisService myAnalysisService;
    public InspectCodeFinder(UITaskExecutor uiTaskExecutor, IShellLocks locks, DaemonEnablePolicy daemonEnablePolicy, ISolution solution, IssueClasses issueClasses, FileImages fileImages, SolutionAnalysisService analysisService);
    [MustDisposeResourceAttribute]
private ITaskBarrier CreateTaskBarrier(int parallelJobs);
    public bool RunFindCodeIssues(IList`1<IPsiSourceFile> files, Action`1<IIssue> issueConsumer, int parallelJobs);
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Intentions.DaemonSuppressorService : object {
    [NotNullAttribute]
private DaemonBase myDaemon;
    public DaemonSuppressorService(DaemonBase daemon);
    public sealed virtual IDisposable Suspend();
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Intentions.SolutionAnalysisCompletionService : object {
    [NotNullAttribute]
private SolutionAnalysisService mySolutionAnalysisService;
    [NotNullAttribute]
private SolutionAnalysisConfiguration mySolutionAnalysisConfiguration;
    [NotNullAttribute]
private FileImages myFileImages;
    public SolutionAnalysisCompletionService(SolutionAnalysisService solutionAnalysisService, SolutionAnalysisConfiguration solutionAnalysisConfiguration, FileImages fileImages);
    public sealed virtual bool IsEnabled();
    public sealed virtual void WaitForGlobalAnalysisToComplete(IProgressIndicator progress);
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Intentions.SolutionAnalysisResultsFileFilter : object {
    private Lifetime myLifetime;
    [NotNullAttribute]
private DaemonEnablePolicy myDaemonEnablePolicy;
    [NotNullAttribute]
private SolutionAnalysisService mySolutionAnalysisService;
    [NotNullAttribute]
private SolutionAnalysisConfiguration mySolutionAnalysisConfiguration;
    [NotNullAttribute]
private HighlightingSettingsManager myHighlightingSettingsManager;
    [NotNullAttribute]
private IShellLocks myShellLocks;
    public SolutionAnalysisResultsFileFilter(Lifetime lifetime, DaemonEnablePolicy daemonEnablePolicy, SolutionAnalysisService solutionAnalysisService, SolutionAnalysisConfiguration solutionAnalysisConfiguration, HighlightingSettingsManager highlightingSettingsManager, IShellLocks shellLocks);
    public sealed virtual FilteringResults FilterFilesWithoutIssues(IReadOnlyList`1<ScopedApplyFile> filesToProcess, IReadOnlyCollection`1<Type> highlightingTypes, IReadOnlyCollection`1<IHighlighting> highlightings, IProgressIndicator progress);
    [PureAttribute]
[CanBeNullAttribute]
private HashSet`1<IIssueType> CollectIssueTypes(IReadOnlyCollection`1<Type> highlightingTypes, IReadOnlyCollection`1<IHighlighting> highlightings, Boolean& hasOnlyErrors);
    private HighlightingClassification ClassifyHighlighting(HighlightingAttributeBase attribute);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.InvisibleDocumentDaemonProcess : DaemonProcessBaseImpl {
    private bool mySync;
    public bool FullRehighlightingRequired { get; }
    protected bool AnalyzeMembersInParallel { get; }
    protected bool RunStagesInParallel { get; }
    [NullableContextAttribute("1")]
public InvisibleDocumentDaemonProcess(IPsiSourceFile sourceFile, bool sync);
    public virtual bool get_FullRehighlightingRequired();
    public virtual bool IsRangeInvalidated(DocumentRange range);
    protected virtual bool get_AnalyzeMembersInParallel();
    protected virtual bool get_RunStagesInParallel();
    public void DoHighlighting();
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.IssueClass : object {
    private static HashSet`1<char> ourEscapeChars1;
    private static HashSet`1<char> ourEscapeChars2;
    private IIssueType myIssueType;
    private string myFormatString;
    private int myFormatArgCount;
    private Regex myRegEx;
    private int myNavigationOffset;
    public IIssueType IssueType { get; }
    public int NavigationOffset { get; }
    internal IssueClass(IIssueType issueType, string formatString, int navigationOffset);
    private static IssueClass();
    private static string EscapeChars(string text, HashSet`1<char> chars);
    public IIssueType get_IssueType();
    public int get_NavigationOffset();
    public object ExtractFormatStringArguments(string message, IssueStrings issueStrings);
    public string FormMessage(object arguments);
    public void WriteTo(UnsafeWriter writer);
    [CompilerGeneratedAttribute]
private object <FormMessage>b__14_0();
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.IssueClasses : object {
    private IssueStrings myIssueStrings;
    private DocumentManager myDocumentManager;
    private Dictionary`2<IssueClassKey, IssueClass> myIssueClasses;
    public IssueClasses(IssueStrings issueStrings, DocumentManager documentManager);
    [NotNullAttribute]
public IssueClass GetIssueClass(HighlightingAttributeBase attribute, int navigationOffsetPatch);
    [NotNullAttribute]
public IssueClass GetIssueClass(HighlightingSettingsManager highlightingManager, HighlightingInfo highlightingInfo, IPsiSourceFile sourceFile, IContextBoundSettingsStore settingsStore);
    [NotNullAttribute]
public IssueClass ReadFrom(UnsafeReader reader, HighlightingSettingsManager manager);
    [NotNullAttribute]
private IssueClass GetIssueClass(IIssueType issueType, string formatString, int navigationOffset);
    [NotNullAttribute]
public IssueData[] BuildIssues(IEnumerable`1<HighlightingInfo> highlightings, IPsiSourceFile psiSourceFile, IContextBoundSettingsStore settingsStore, Predicate`1<IIssueType> issueFilter);
}
[DebuggerDisplayAttribute("Message = {Message}, IssueType={IssueType}")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.IssueData : ValueType {
    private IssueClass myIssueClass;
    private object myFormatStringArguments;
    private bool myHasRange;
    private TextRange myRange;
    private bool myIgnored;
    public Nullable`1<TextRange> Range { get; }
    public bool IsValid { get; }
    public string Message { get; }
    public IIssueType IssueType { get; }
    public bool Ignored { get; public set; }
    public int NavigationOffset { get; }
    public IssueData(TextRange range, IssueClass issueClass, string message, bool ignored, IssueStrings issueStrings);
    public IssueData(string message, IssueClass issueClass, bool ignored, IssueStrings issueStrings);
    private IssueData(Nullable`1<TextRange> range, IssueClass issueClass, object formatStringArguments, bool ignored);
    public IssueData Clone();
    public Nullable`1<TextRange> get_Range();
    public bool get_IsValid();
    public void UpdateRange(Func`2<TextRange, TextRange> updateFunc);
    public string get_Message();
    public IIssueType get_IssueType();
    public Severity GetSeverity(IPsiSourceFile file, ISolution solution, IContextBoundSettingsStore settingsStore);
    public bool get_Ignored();
    public void set_Ignored(bool value);
    public int get_NavigationOffset();
    public void WriteTo(UnsafeWriter writer);
    public static IssueData ReadFrom(UnsafeReader reader, IssueStrings issueStrings, IssueClasses issueClasses, HighlightingSettingsManager highlightingSettingsManager);
    public virtual bool Equals(object obj);
    public bool Equals(IssueData other);
    private static bool ArgumentsEqual(object args1, object args2);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.IssuePointer : ValueType {
    [NotNullAttribute]
public IssueData[] Array;
    public int Index;
    private SourceFilePtr myFile;
    private Severity mySeverity;
    public SourceFilePtr File { get; }
    public Nullable`1<TextRange> Range { get; }
    public int NavigationOffset { get; }
    public string Message { get; }
    public IIssueType IssueType { get; }
    public bool IsValid { get; }
    public bool Ignored { get; }
    public IssuePointer(IssueData[] array, int index, SourceFilePtr file, IContextBoundSettingsStore settingsStore, ISolution solution);
    public IssuePointer(IssueData[] array, int index, SourceFilePtr file, Severity severity);
    public sealed virtual SourceFilePtr get_File();
    public sealed virtual Nullable`1<TextRange> get_Range();
    public sealed virtual int get_NavigationOffset();
    public sealed virtual string get_Message();
    public sealed virtual IIssueType get_IssueType();
    public sealed virtual Severity GetSeverity();
    public sealed virtual bool get_IsValid();
    public sealed virtual bool get_Ignored();
    public sealed virtual void SetIgnored(HighlightingResultsMap resultsMap, bool value);
    public bool Equals(IssuePointer other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Issues.ConfigurableIssueType : ConfigurableIssueTypeBase {
    [NotNullAttribute]
private HighlightingSettingsManager myHighlightingsManager;
    [CanBeNullAttribute]
private ConfigurableSeverityItem myItem;
    public ConfigurableIssueType(string configurableSeverityId, HighlightingSettingsManager highlightingsManager);
    public virtual Severity GetSeverity(IPsiSourceFile sourceFile, ISolution solution, IContextBoundSettingsStore settingsStore);
    protected virtual ConfigurableSeverityItem GetItemOrNull();
}
public abstract class JetBrains.ReSharper.Daemon.SolutionAnalysis.Issues.ConfigurableIssueTypeBase : object {
    public static byte IssueTypeFlag;
    [CompilerGeneratedAttribute]
private string <ConfigurableSeverityId>k__BackingField;
    [NotNullAttribute]
public string ConfigurableSeverityId { get; }
    public string Presentation { get; }
    public string LeafPresentation { get; }
    public SolutionAnalysisMode SolutionAnalysisMode { get; }
    public string GroupId { get; }
    public string CompoundItemName { get; }
    protected ConfigurableIssueTypeBase(string configurableSeverityId);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ConfigurableSeverityId();
    public sealed virtual string get_Presentation();
    [CanBeNullAttribute]
protected abstract virtual ConfigurableSeverityItem GetItemOrNull();
    public abstract virtual Severity GetSeverity(IPsiSourceFile sourceFile, ISolution solution, IContextBoundSettingsStore settingsStore);
    public sealed virtual string get_LeafPresentation();
    public sealed virtual SolutionAnalysisMode get_SolutionAnalysisMode();
    public sealed virtual string get_GroupId();
    public sealed virtual string get_CompoundItemName();
    public sealed virtual void WriteTo(UnsafeWriter writer);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Issues.ConfigurableIssueTypeWithHighlightingType : ConfigurableIssueType {
    [CompilerGeneratedAttribute]
private Type <HighlightingType>k__BackingField;
    [NotNullAttribute]
public Type HighlightingType { get; }
    public ConfigurableIssueTypeWithHighlightingType(Type highlightingType, string configurableSeverityId, HighlightingSettingsManager highlightingsManager);
    [CompilerGeneratedAttribute]
public Type get_HighlightingType();
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Issues.ConfigurableIssueTypeWithItem : ConfigurableIssueTypeBase {
    private ConfigurableSeverityItem myConfigurableSeverityItem;
    public ConfigurableIssueTypeWithItem(ConfigurableSeverityItem configurableSeverityItem);
    protected virtual ConfigurableSeverityItem GetItemOrNull();
    public virtual Severity GetSeverity(IPsiSourceFile sourceFile, ISolution solution, IContextBoundSettingsStore settingsStore);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Issues.OverriddenSeverityIssueType : object {
    [NotNullAttribute]
private IIssueType myIssueType;
    private Severity myOverriddenSeverity;
    public static byte IssueTypeFlag;
    public string LeafPresentation { get; }
    public string Presentation { get; }
    public string GroupId { get; }
    public string CompoundItemName { get; }
    public SolutionAnalysisMode SolutionAnalysisMode { get; }
    public string ConfigurableSeverityId { get; }
    internal IIssueType OriginalIssueType { get; }
    public OverriddenSeverityIssueType(IIssueType issueType, Severity overriddenSeverity);
    public sealed virtual Severity GetSeverity(IPsiSourceFile sourceFile, ISolution solution, IContextBoundSettingsStore settingsStore);
    public sealed virtual string get_LeafPresentation();
    public sealed virtual string get_Presentation();
    public sealed virtual string get_GroupId();
    public sealed virtual string get_CompoundItemName();
    public sealed virtual SolutionAnalysisMode get_SolutionAnalysisMode();
    public sealed virtual string get_ConfigurableSeverityId();
    internal IIssueType get_OriginalIssueType();
    public sealed virtual void WriteTo(UnsafeWriter writer);
    private bool Equals(OverriddenSeverityIssueType other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Issues.StaticIssueType : object {
    private Severity myStaticSeverity;
    [NotNullAttribute]
private string myGroupId;
    [CanBeNullAttribute]
private string myStaticSeverityTitle;
    public static byte IssueTypeFlag;
    public Severity StaticSeverity { get; }
    public string ConfigurableSeverityId { get; }
    public string Presentation { get; }
    public string LeafPresentation { get; }
    public SolutionAnalysisMode SolutionAnalysisMode { get; }
    public string GroupId { get; }
    public string CompoundItemName { get; }
    public StaticIssueType(Severity staticSeverity, string groupId, string title);
    public sealed virtual Severity GetSeverity(IPsiSourceFile sourceFile, ISolution solution, IContextBoundSettingsStore settingsStore);
    public Severity get_StaticSeverity();
    public sealed virtual string get_ConfigurableSeverityId();
    public sealed virtual string get_Presentation();
    public sealed virtual string get_LeafPresentation();
    public sealed virtual SolutionAnalysisMode get_SolutionAnalysisMode();
    public sealed virtual string get_GroupId();
    public sealed virtual string get_CompoundItemName();
    public sealed virtual void WriteTo(UnsafeWriter writer);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Issues.StructuralSearchPatternIssueType : object {
    private Severity mySeverity;
    public static byte IssueTypeFlag;
    [CompilerGeneratedAttribute]
private string <ConfigurableSeverityId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Presentation>k__BackingField;
    [NotNullAttribute]
public string ConfigurableSeverityId { get; }
    public string LeafPresentation { get; }
    public string Presentation { get; }
    public string GroupId { get; }
    public string CompoundItemName { get; }
    public SolutionAnalysisMode SolutionAnalysisMode { get; }
    public StructuralSearchPatternIssueType(IStructuralSearchHighlighting highlighting);
    public StructuralSearchPatternIssueType(UnsafeReader reader);
    public sealed virtual Severity GetSeverity(IPsiSourceFile sourceFile, ISolution solution, IContextBoundSettingsStore settingsStore);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ConfigurableSeverityId();
    public sealed virtual string get_LeafPresentation();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Presentation();
    public sealed virtual string get_GroupId();
    public sealed virtual string get_CompoundItemName();
    public sealed virtual SolutionAnalysisMode get_SolutionAnalysisMode();
    public sealed virtual void WriteTo(UnsafeWriter writer);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.IssuesSerializer.IssueComparer : object {
    public static IComparer`1<IIssue> Instance;
    private static IssueComparer();
    public sealed virtual int Compare(IIssue x, IIssue y);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.IssuesSerializer.IssuesReportReader : object {
    private ISolution mySolution;
    private Dictionary`2<string, IIssueType> myId2IssueType;
    private List`1<IIssue> myIssues;
    private HashSet`1<IProjectModelElement> myScope;
    public IssuesReportReader(ISolution solution);
    public void Load(Stream stream);
    public Data GetData();
    public static Data LoadFromFile(ISolution solution, VirtualFileSystemPath path);
    private void ReadRoot(XmlReader reader);
    private void ReadIssues(XmlReader reader);
    private void ReadIssueProject(XmlReader reader);
    private void ReadIssue(XmlReader reader, IProject project);
    private void ReadIssueTypes(XmlReader reader);
    private void ReadIssueType(XmlReader reader);
    private void ReadInformation(XmlReader reader);
    private void ReadInspectionScope(XmlReader reader);
    private void ReadScopeElement(XmlReader reader);
    [CompilerGeneratedAttribute]
private void <ReadRoot>b__8_0(XmlReader r);
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.IssuesSerializer.IssuesReportTransformer : object {
    private XslCompiledTransform myXmlToTextTransformation;
    private XslCompiledTransform myXmlToHtmlTransformation;
    public XslCompiledTransform XmlToTextTransformation { get; }
    public XslCompiledTransform XmlToHtmlTransformation { get; }
    public XslCompiledTransform get_XmlToTextTransformation();
    public XslCompiledTransform get_XmlToHtmlTransformation();
    private static XslCompiledTransform LoadTransformation(string name);
    public Action`2<IProgressIndicator, Stream> TransformToHtml(Action`2<IProgressIndicator, Stream> xmlExporter, string title);
    public Action`2<IProgressIndicator, Stream> TransformToText(Action`2<IProgressIndicator, Stream> xmlExporter, string title);
    public Action`2<IProgressIndicator, Stream> Transform(Action`2<IProgressIndicator, Stream> exporter, XslCompiledTransform transformation, IDictionary`2<string, object> parameters);
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.IssuesSerializer.IssuesReportWriter : IssuesTypesWriter {
    private ISolution mySolution;
    public IssuesReportWriter(ISolution solution, IssueTypesManager issueTypesManager, ISettingsStore settingsStore, IEnumerable`1<ICodeInspectionWikiDataProvider> inspectionWikiData, HighlightingSettingsManager highlightingSettingsManager, IApplicationHost applicationHost);
    public void WriteReport(IProgressIndicator progress, Stream writer, IEnumerable`1<IProjectModelElement> scope, ICollection`1<IIssue> issues);
    public void WriteReport(IProgressIndicator progress, Stream stream, VirtualFileSystemPath baseDirectory, IEnumerable`1<IProjectModelElement> scope, ICollection`1<IIssue> issues);
    public void WriteReport(IProgressIndicator progress, TextWriter writer, VirtualFileSystemPath baseDirectory, IEnumerable`1<IProjectModelElement> scope, ICollection`1<IIssue> issues);
    private void WriteReportInformation(XmlWriter writer, VirtualFileSystemPath baseDirectory, IEnumerable`1<IProjectModelElement> scope);
    private static string GetScopeElementPresentation(IProjectModelElement element);
    private string GetRelativePath(VirtualFileSystemPath path);
    private void WriteIssues(IProgressIndicator progress, XmlWriter writer, ICollection`1<IIssue> issues, ISolution ctx, JetHashSet`1<IIssueType> types, bool useAbsolutePaths);
}
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.IssuesSerializer.IssuesTypesWriter : object {
    private IEnumerable`1<ICodeInspectionWikiDataProvider> myInspectionWikiData;
    private HighlightingSettingsManager myHighlightingSettingsManager;
    protected IssueTypesManager myIssueTypesManager;
    protected ISettingsStore mySettingsStore;
    protected IApplicationHost myApplicationHost;
    public IssuesTypesWriter(IssueTypesManager issueTypesManager, IEnumerable`1<ICodeInspectionWikiDataProvider> inspectionWikiData, HighlightingSettingsManager highlightingSettingsManager, ISettingsStore settingsStore, IApplicationHost applicationHost);
    public void WriteIssuesTypesReport(IProgressIndicator progress, Stream stream);
    protected void WriteIssueTypes(IProgressIndicator progress, XmlWriter writer, ICollection`1<IIssueType> types, ISolution ctx);
    protected static string GetTypeId(IIssueType type);
    private string GetWikiUrl(string issueTypeId);
}
[SolutionComponentAttribute("16")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.IssueStrings : object {
    private ChunkHashSet`1<string> myStrings;
    public string Intern(string s);
}
[UsedImplicitlyAttribute]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.IssueTypeConverter : TypeConverterBase`1<IIssueType> {
    private static string ConfigurableSeverityElementName;
    private static string StaticSeverityElementName;
    private static string SeverityAttributeName;
    private static string TitleAttributeName;
    private static string GroupIdAttributeName;
    private static string IdAttributeName;
    private static IIssueType StringToIssueType(ITypeDescriptorContext arg1, CultureInfo arg2, string s);
    private static string IssueTypeToString(ITypeDescriptorContext arg1, CultureInfo arg2, IIssueType issueType);
}
[ExtensionAttribute]
public static class JetBrains.ReSharper.Daemon.SolutionAnalysis.IssueTypeExtensions : object {
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IIssueType GetIssueType(IHighlighting highlighting, HighlightingSettingsManager highlightingSettingsManager);
    [ExtensionAttribute]
[NotNullAttribute]
[PureAttribute]
public static IIssueType GetIssueType(HighlightingAttributeBase attribute, HighlightingSettingsManager highlightingSettingsManager);
    [NotNullAttribute]
public static IIssueType ReadFrom(UnsafeReader reader, HighlightingSettingsManager highlightingsManager);
}
[ShellComponentAttribute("20")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.IssueTypesManager : object {
    [NotNullAttribute]
private HighlightingSettingsManager myHighlightingSettingsManager;
    [NotNullAttribute]
private HashSet`1<IIssueType> myStaticSeverityTypes;
    [NotNullAttribute]
private OneToListMap`2<string, IIssueType> myStaticIssuesByGroup;
    [ObsoleteAttribute("Inject me!")]
public static IssueTypesManager Instance { get; }
    public IEnumerable`1<IIssueType> AllIssueTypes { get; }
    private IEnumerable`1<IIssueType> ConfigurableSeverityTypes { get; }
    public IssueTypesManager(Lifetime lifetime, ShellPartCatalogSet catalog, HighlightingSettingsManager highlightingSettingsManager);
    public static IssueTypesManager get_Instance();
    public IEnumerable`1<IIssueType> get_AllIssueTypes();
    public IEnumerable`1<IIssueType> GetIssueTypesByGroupId(string groupId);
    public IEnumerable`1<IIssueType> GetIssueTypesByCompoundItemName(string compoundItemName);
    private IEnumerable`1<IIssueType> get_ConfigurableSeverityTypes();
    [CompilerGeneratedAttribute]
private IIssueType <GetIssueTypesByGroupId>b__8_0(string id);
    [CompilerGeneratedAttribute]
private IIssueType <GetIssueTypesByCompoundItemName>b__9_0(string id);
    [CompilerGeneratedAttribute]
private IIssueType <get_ConfigurableSeverityTypes>b__11_0(ConfigurableSeverityItem item);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.MemberDataItem : ValueType {
    public MemberDataItem[] Children;
    public ElementId Id;
    public int ElementTypeIndex;
    public int Flags;
    public ParametersData ParametersData;
    public MembersOwnerData MembersOwnerData;
    private MemberDataItem(MemberDataItem[] children, ElementId id, int elementTypeIndex, int flags, ParametersData parametersData, MembersOwnerData membersOwnerData);
    public MemberDataItem(UnsafeReader reader);
    public static Nullable`1<MemberDataItem> Build(IDeclaration declaration);
    public static Nullable`1<MemberDataItem> Build(IDeclaredElement element, MemberDataItem[] children, PsiLanguageType language, bool forceCreateForPrivateMembers);
    public void WriteTo(UnsafeWriter writer);
}
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.MemberDeclarationInfo : object {
    [NotNullAttribute]
private MemberInfo myMemberInfo;
    private IDeclarationInfoParent myParent;
    private PsiLanguageType myLanguage;
    public IElementInfo Element { get; }
    public IEnumerable`1<IDeclarationInfo> MemberDeclarations { get; }
    public IEnumerable`1<IDeclarationInfo> AccessorDeclarations { get; }
    public IEnumerable`1<IDeclarationInfo> ParameterDeclarations { get; }
    private MemberDeclarationInfo(MemberInfo memberInfo, IDeclarationInfoParent parent, PsiLanguageType language);
    [CanBeNullAttribute]
public static MemberDeclarationInfo BuildForTopLevelDeclaration(IDeclaration declaration, int declarationIndex);
    public void WriteTopLevelDeclarationTo(UnsafeWriter writer);
    [CanBeNullAttribute]
public static MemberDeclarationInfo ReadTopLevelDeclaration(UnsafeReader reader, IPsiSourceFile file, PsiLanguageType language);
    public sealed virtual IElementInfo get_Element();
    public sealed virtual IDeclaration FindDeclaration(DeclarationInfoCache cache);
    [CanBeNullAttribute]
private IDeclaration CheckDeclarationOk(IDeclaration declaration);
    public sealed virtual IDeclaredElement FindDeclaredElement(DeclarationInfoCache cache);
    public sealed virtual IEnumerable`1<IDeclarationInfo> get_MemberDeclarations();
    public sealed virtual IEnumerable`1<IDeclarationInfo> get_AccessorDeclarations();
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Daemon.SolutionAnalysis.MemberDeclarationInfo/<get_ParameterDeclarations>d__17")]
public sealed virtual IEnumerable`1<IDeclarationInfo> get_ParameterDeclarations();
    [CompilerGeneratedAttribute]
private IDeclarationInfo <get_MemberDeclarations>b__13_0(MemberDataItem childItem);
    [CompilerGeneratedAttribute]
private IDeclarationInfo <get_AccessorDeclarations>b__15_0(MemberDataItem childItem);
}
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.MemberInfo : object {
    [NotNullAttribute]
protected PsiLanguageType Language;
    [CanBeNullAttribute]
private IMemberInfo myOwner;
    [CompilerGeneratedAttribute]
private MemberDataItem <DataItem>k__BackingField;
    public MemberDataItem DataItem { get; }
    public ElementId Id { get; }
    public DeclaredElementType ElementType { get; }
    public IMemberInfo Owner { get; }
    public IMembersOwnerInfo MembersOwner { get; }
    protected MemberInfo(MemberDataItem dataItem, IMemberInfo owner, PsiLanguageType language);
    [NotNullAttribute]
public static MemberInfo Create(MemberDataItem item, IMemberInfo owner, PsiLanguageType language);
    [CompilerGeneratedAttribute]
public MemberDataItem get_DataItem();
    public ElementId get_Id();
    public sealed virtual DeclaredElementType get_ElementType();
    public sealed virtual IMemberInfo get_Owner();
    public sealed virtual IMembersOwnerInfo get_MembersOwner();
    public sealed virtual int GetFlags(int mask);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.MembersOwnerData : ValueType {
    [CanBeNullAttribute]
public MemberDataItem[] Constructors;
    [CanBeNullAttribute]
public MemberDataItem[] PositionalMembers;
    public bool IsMembersOwner { get; }
    private MembersOwnerData(MemberDataItem[] constructors, MemberDataItem[] positionalMembers);
    public MembersOwnerData(UnsafeReader reader);
    public static MembersOwnerData Build(IDeclaredElement element, UsageCheckingServices services, PsiLanguageType language);
    public bool get_IsMembersOwner();
    public void WriteTo(UnsafeWriter writer);
}
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.MembersOwnerInfo : MemberInfo {
    public IEnumerable`1<IMemberInfo> Constructors { get; }
    public IEnumerable`1<IMemberInfo> PositionalMembers { get; }
    public MembersOwnerInfo(MemberDataItem item, IMemberInfo owner, PsiLanguageType language);
    public sealed virtual IEnumerable`1<IMemberInfo> get_Constructors();
    public sealed virtual IEnumerable`1<IMemberInfo> get_PositionalMembers();
    [CompilerGeneratedAttribute]
private IMemberInfo <get_Constructors>b__2_0(MemberDataItem data);
    [CompilerGeneratedAttribute]
private IMemberInfo <get_PositionalMembers>b__4_0(MemberDataItem data);
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Navigation.SweaFindUsages : object {
    [NotNullAttribute]
private IPersistentIndexManager myPersistentIndexManager;
    [NotNullAttribute]
private SolutionAnalysisService mySolutionAnalysisService;
    public SweaFindUsages(IPersistentIndexManager persistentIndexManager, SolutionAnalysisService solutionAnalysisService);
    public sealed virtual Predicate`1<IPsiSourceFile> GetChecker(IDeclaredElement element);
    public bool CanContainReferences(IPsiSourceFile sourceFile, ElementId elementId, DaemonResults daemonResults);
}
[PsiComponentAttribute("0")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Navigation.SweaSearchFilter : object {
    [NotNullAttribute]
private ISolution mySolution;
    [NotNullAttribute]
private NavigationSettings mySettings;
    [CanBeNullAttribute]
private ISweaFindUsages mySweaFindUsages;
    public SearchFilterKind Kind { get; }
    public SweaSearchFilter(ISolution solution, NavigationSettings settings);
    public sealed virtual SearchFilterKind get_Kind();
    public sealed virtual bool IsAvailable(SearchPattern pattern);
    public sealed virtual object TryGetKey(IDeclaredElement declaredElement);
    public sealed virtual bool CanContainReferences(IPsiSourceFile sourceFile, object key);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Navigation.ZoneMarker : object {
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.NextPrevActions.NextPrevErrorInFileHandler : NextPrevProblemInFileHandler {
    private bool myIsNext;
    public NextPrevErrorInFileHandler(Lifetime lifetime, ISolution solution, IDataContext dataContext, bool isNext);
    protected virtual bool IsSuitableByType(IHighlighter highlighter);
    protected virtual bool IsSuitableByPosition(IHighlighter marker);
    protected virtual bool IsBetter(IHighlighter first, IHighlighter second);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.NextPrevActions.NextPrevErrorInSolutionHandler : NextPrevHandler {
    private bool myIsNext;
    [NotNullAttribute]
private SolutionAnalysisConfiguration mySweaConfiguration;
    [NotNullAttribute]
private SolutionAnalysisManager myManager;
    [CanBeNullAttribute]
private NextPrevErrorInFileHandler myInFileHandler;
    public NextPrevErrorInSolutionHandler(Lifetime lifetime, ISolution solution, IDataContext dataContext, bool isNext);
    public virtual bool FindTarget(IProjectFile& file, Int32& offset, RichTextBlock& message);
    private bool FileHasErrorsOrNoErrorsInSolution(IProjectFile file);
    private bool FindTarget(IList`1<IProjectFile> filesWithIssues, IProjectFile currentFile, IProjectFile& file, Int32& offset, RichTextBlock& message);
    [CanBeNullAttribute]
private IProjectFile FindNextFile(IEnumerable`1<IProjectFile> files, IProjectFile currentFile);
    private int FindIssueOffsetInFile(IProjectFile file, int afterOffset, RichTextBlock& message);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(Lifetime lf);
}
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.ParameterDeclarationInfo : object {
    [NotNullAttribute]
private ParameterInfo myParameterInfo;
    [NotNullAttribute]
private MemberDeclarationInfo myOwnerDeclarationInfo;
    public IElementInfo Element { get; }
    public IEnumerable`1<IDeclarationInfo> MemberDeclarations { get; }
    public IEnumerable`1<IDeclarationInfo> AccessorDeclarations { get; }
    public IEnumerable`1<IDeclarationInfo> ParameterDeclarations { get; }
    public ParameterDeclarationInfo(ParameterInfo parameterInfo, MemberDeclarationInfo ownerDeclarationInfo);
    public sealed virtual IElementInfo get_Element();
    public sealed virtual IDeclaration FindDeclaration(DeclarationInfoCache cache);
    [CanBeNullAttribute]
private IDeclaration CheckDeclarationOk(IDeclaration declaration);
    public sealed virtual IDeclaredElement FindDeclaredElement(DeclarationInfoCache cache);
    public sealed virtual IEnumerable`1<IDeclarationInfo> get_MemberDeclarations();
    public sealed virtual IEnumerable`1<IDeclarationInfo> get_AccessorDeclarations();
    public sealed virtual IEnumerable`1<IDeclarationInfo> get_ParameterDeclarations();
}
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.ParameterInfo : object {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    private int myFlags;
    [CompilerGeneratedAttribute]
private IMemberInfo <Owner>k__BackingField;
    [CompilerGeneratedAttribute]
private ElementId <Id>k__BackingField;
    public int Index { get; }
    public IMemberInfo Owner { get; }
    public ElementId Id { get; }
    public DeclaredElementType ElementType { get; }
    public ParameterInfo(MemberInfo owner, int index, int flags);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Index();
    [CompilerGeneratedAttribute]
public sealed virtual IMemberInfo get_Owner();
    [CompilerGeneratedAttribute]
public ElementId get_Id();
    public sealed virtual DeclaredElementType get_ElementType();
    public sealed virtual int GetFlags(int mask);
}
[IsReadOnlyAttribute]
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.ParametersData : ValueType {
    [CanBeNullAttribute]
private ParameterInfo[] myInfos;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; }
    private ParametersData(int count, ParameterInfo[] infos);
    private ParametersData(Int16[] flags);
    public ParametersData(UnsafeReader reader);
    public static ParametersData Build(IDeclaredElement element, UsageCheckingServices services, PsiLanguageType language);
    public void WriteTo(UnsafeWriter writer);
    [CompilerGeneratedAttribute]
public int get_Count();
    public int Flags(int index);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.PsiCachesForceUpdatedFilesAnalyzer : object {
    private ISolution mySolution;
    private FileImages myFileImages;
    private SolutionAnalysisConfiguration mySolutionAnalysisConfiguration;
    private ILogger myLogger;
    public PsiCachesForceUpdatedFilesAnalyzer(Lifetime lifetime, ISolution solution, FileImages fileImages, PsiCachesRepairService psiCachesRepairService, SolutionAnalysisConfiguration solutionAnalysisConfiguration, ILogger logger);
    private void FilesForceUpdated(ICollection`1<IPsiSourceFile> repairedFiles);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Qodana.AdditionalSeverityItem : ValueType {
    [CompilerGeneratedAttribute]
private ConfigurableSeverityItem <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRoslyn>k__BackingField;
    public ConfigurableSeverityItem Item { get; public set; }
    public string Language { get; public set; }
    public bool IsRoslyn { get; public set; }
    public AdditionalSeverityItem(ConfigurableSeverityItem Item, string Language, bool IsRoslyn);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ConfigurableSeverityItem get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(ConfigurableSeverityItem value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsRoslyn();
    [CompilerGeneratedAttribute]
public void set_IsRoslyn(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(AdditionalSeverityItem left, AdditionalSeverityItem right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(AdditionalSeverityItem left, AdditionalSeverityItem right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(AdditionalSeverityItem other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(ConfigurableSeverityItem& Item, String& Language, Boolean& IsRoslyn);
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.Qodana.IAdditionalInspectionsRetriever {
    public abstract virtual IList`1<AdditionalSeverityItem> RetrieveSeverities();
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.ReanalyzeActions.IUpdatableHighlightingResultsMap {
    public abstract virtual void OnHighlightingSettingsChanged();
}
[ActionAttribute("ErrorsView.ReanalyzeFilesWithErrors", "JetBrains.ReSharper.Daemon.SolutionAnalysis.Resources.Strings", "ReanalyzeFilesWithErrorsAction_Text")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.ReanalyzeActions.ReanalyzeFilesWithErrorsAction : object {
    public sealed virtual bool Update(IDataContext context, ActionPresentation presentation, DelegateUpdate nextUpdate);
    public sealed virtual void Execute(IDataContext context, DelegateExecute nextExecute);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.RefactoringsSweaSuppressor : object {
    public RefactoringsSweaSuppressor(Lifetime lifetime, SolutionAnalysisConfiguration sweaConf);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Resources.SolutionAnalysisThemedIcons : object {
}
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
public static class JetBrains.ReSharper.Daemon.SolutionAnalysis.Resources.Strings : object {
    private static ILogger ourLog;
    private static Lazy`1<JetResourceManager> ourResourceManager;
    [EditorBrowsableAttribute("2")]
public static JetResourceManager ResourceManager { get; }
    public static string CallGraphActionGroupText { get; }
    public static string CallGraphElementsCountActionText { get; }
    public static string CodeIssueFiltersSettingDescription { get; }
    public static string CodeIssuesInCurrentProjectActionText { get; }
    public static string CodeIssuesInSolutionActionText { get; }
    public static string ContextActionPageUISettingsSettingDescription { get; }
    public static string DumpCallGraphActionText { get; }
    public static string DumpCallGraphForFileActionText { get; }
    public static string FindCodeIssuesActionText { get; }
    public static string GroupBySettingDescription { get; }
    public static string InspectionResultsViewSettingsSettingDescription { get; }
    public static string IssueTypesToHideSettingDescription { get; }
    public static string UseNewTreeForSweaSettingDescription { get; }
    public static string ReanalyzeFilesWithErrorsAction_Text { get; }
    public static string SolutionWideAnalysisWillMonitorWarnings_Text { get; }
    public static string RestartAnalysisWithWarnings_Text { get; }
    public static string WaitingForSolutionWideAnalysis_Text { get; }
    public static string WaitingForSolutionWideAnalysisToComplete_Text { get; }
    public static string Analyzing__Text { get; }
    public static string AnalyzingFile__Text { get; }
    public static string Processing__Text { get; }
    public static string AnalysingFile___Text { get; }
    public static string FilteringFilesBySolutionWideAnalysis_Text { get; }
    public static string InspectingFile___Text { get; }
    public static string FindSimilarIssuesIn__Text { get; }
    public static string DoNotShow_Error_Severity_Text { get; }
    public static string Info_Error_Severity_Text { get; }
    public static string Hint_Error_Severity_Text { get; }
    public static string Suggestion_Error_Severity_Text { get; }
    public static string Warning_Error_Severity_Text { get; }
    public static string Error_Error_Severity_Text { get; }
    public static string Issue_Plural { get; }
    public static string Inspecting__Text { get; }
    public static string Inspecting_Text { get; }
    public static string NoIssuesFound_Caption { get; }
    public static string CodeISsues_Caption { get; }
    public static string MonitorWarnings_Caption { get; }
    public static string UnknownIssue_Text { get; }
    public static string ConfigurableIssue_Presentation___Text { get; }
    public static string FindSimilarIssuesInFile_Caption { get; }
    public static string FindIn_Project_Caption { get; }
    public static string FindIn_Solution_Caption { get; }
    private static Strings();
    public static JetResourceManager get_ResourceManager();
    public static string Choice(string format, Object[] args);
    public static string get_CallGraphActionGroupText();
    public static string get_CallGraphElementsCountActionText();
    public static string get_CodeIssueFiltersSettingDescription();
    public static string get_CodeIssuesInCurrentProjectActionText();
    public static string get_CodeIssuesInSolutionActionText();
    public static string get_ContextActionPageUISettingsSettingDescription();
    public static string get_DumpCallGraphActionText();
    public static string get_DumpCallGraphForFileActionText();
    public static string get_FindCodeIssuesActionText();
    public static string get_GroupBySettingDescription();
    public static string get_InspectionResultsViewSettingsSettingDescription();
    public static string get_IssueTypesToHideSettingDescription();
    public static string get_UseNewTreeForSweaSettingDescription();
    public static string get_ReanalyzeFilesWithErrorsAction_Text();
    public static string get_SolutionWideAnalysisWillMonitorWarnings_Text();
    public static string get_RestartAnalysisWithWarnings_Text();
    public static string get_WaitingForSolutionWideAnalysis_Text();
    public static string get_WaitingForSolutionWideAnalysisToComplete_Text();
    public static string get_Analyzing__Text();
    public static string get_AnalyzingFile__Text();
    public static string get_Processing__Text();
    public static string get_AnalysingFile___Text();
    public static string get_FilteringFilesBySolutionWideAnalysis_Text();
    public static string get_InspectingFile___Text();
    public static string get_FindSimilarIssuesIn__Text();
    public static string get_DoNotShow_Error_Severity_Text();
    public static string get_Info_Error_Severity_Text();
    public static string get_Hint_Error_Severity_Text();
    public static string get_Suggestion_Error_Severity_Text();
    public static string get_Warning_Error_Severity_Text();
    public static string get_Error_Error_Severity_Text();
    public static string get_Issue_Plural();
    public static string get_Inspecting__Text();
    public static string get_Inspecting_Text();
    public static string get_NoIssuesFound_Caption();
    public static string get_CodeISsues_Caption();
    public static string get_MonitorWarnings_Caption();
    public static string get_UnknownIssue_Text();
    public static string get_ConfigurableIssue_Presentation___Text();
    public static string get_FindSimilarIssuesInFile_Caption();
    public static string get_FindIn_Project_Caption();
    public static string get_FindIn_Solution_Caption();
}
[SettingsKeyAttribute("JetBrains.ReSharper.Feature.Services.Daemon.HighlightingSettings", "JetBrains.ReSharper.Daemon.SolutionAnalysis.Resources.Strings", "CodeIssueFiltersSettingDescription")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.CodeIssueFilterSettings : object {
    [SettingsIndexedEntryAttribute("JetBrains.ReSharper.Daemon.SolutionAnalysis.Resources.Strings", "IssueTypesToHideSettingDescription")]
public IIndexedEntry`2<IIssueType, DoHideIssue> IssueTypesToHide;
}
[InspectThisProviderAttribute("16")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.CodeIssuesInspectThisProvider : object {
    private static int Order;
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.CodeIssuesInspectThisProvider/<CreateWorkflow>d__1")]
public sealed virtual IEnumerable`1<InspectGroupWorkflow> CreateWorkflow(IDataContext context);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.CollectFilesVisitor : RecursiveProjectVisitor {
    [NotNullAttribute]
private DaemonExcludedFilesManager mySettings;
    [NotNullAttribute]
private List`1<IProjectFile> myFiles;
    [CanBeNullAttribute]
private IPsiModules myPsiModules;
    private bool myStopOnFirstFile;
    [NotNullAttribute]
public IReadOnlyList`1<IProjectFile> Files { get; }
    public bool ProcessingIsFinished { get; }
    public CollectFilesVisitor(DaemonExcludedFilesManager settings, bool stopOnFirstFile);
    public IReadOnlyList`1<IProjectFile> get_Files();
    public virtual void VisitSolution(ISolution solution);
    private static Nullable`1<int> CompareProjectsByWeight(IProject project1, IProject project2);
    private static int GetProjectWeight(IProject project);
    public virtual void VisitProjectFile(IProjectFile projectFile);
    public virtual bool get_ProcessingIsFinished();
    [CompilerGeneratedAttribute]
private bool <VisitProjectFile>g__IncludeFile|10_0(<>c__DisplayClass10_0& );
}
public enum JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.DoHideIssue : Enum {
    public int value__;
    public static DoHideIssue Default;
    public static DoHideIssue DoHide;
    public static DoHideIssue DoShow;
}
[ActionAttribute("JetBrains.ReSharper.Daemon.SolutionAnalysis.Resources.Strings", "FindCodeIssuesActionText")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.FindCodeIssuesAction : object {
    public sealed virtual bool Update(IDataContext context, ActionPresentation presentation, DelegateUpdate nextUpdate);
    public sealed virtual void Execute(IDataContext context, DelegateExecute nextExecute);
}
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.FindSimilarIssuesAction : object {
    [NotNullAttribute]
private IProjectModelElement myScope;
    [NotNullAttribute]
private IssueTypeGroup myIssueType;
    [NotNullAttribute]
private string myTitleFormat;
    public string Text { get; }
    public bool IsReadOnly { get; }
    public FindSimilarIssuesAction(IssueTypeGroup issueType, IProjectModelElement scope, string titleFormat);
    public sealed virtual string get_Text();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Execute(ISolution solution, ITextControl textControl);
    [CompilerGeneratedAttribute]
private void <Execute>b__8_0();
}
[CustomHighlightingActionProviderAttribute("JetBrains.ProjectModel.KnownProjectFileType")]
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.FindSimilarIssuesActionProvider : object {
    [NotNullAttribute]
private HighlightingSettingsManager mySettingsManager;
    public FindSimilarIssuesActionProvider(HighlightingSettingsManager settingsManager);
    [IteratorStateMachineAttribute("JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.FindSimilarIssuesActionProvider/<GetActions>d__2")]
public sealed virtual IEnumerable`1<IntentionAction> GetActions(IHighlighting highlighting, DocumentRange highlightingRange, IPsiSourceFile sourceFile, IAnchor configureAnchor);
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.IInspectionResultDescriptorProvider {
    public abstract virtual IRunInspectionResultDescriptor CreateDescriptor(ISolution solution, IList`1<IProjectModelElement> scope, IssueTypeGroup issuesToShow);
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.IIssueTypeGroupName {
    public string Name { get; }
    public abstract virtual string get_Name();
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.InspectionResultPresenter : TreeModelBrowserPresenter {
    private static IconId ERROR_ICON;
    private static IconId WARNING_ICON;
    private static IconId SUGGESTION_ICON;
    private static IconId HINT_ICON;
    private static IconId GROUP_ICON;
    private static InspectionResultPresenter();
    protected virtual void PresentIssue(IIssueOccurrence occurrence, IPresentableItem item, TreeModelNode structureelement, PresentationState state);
    private static IconId GetSeverityIcon(Severity severity);
    private void PresentIssueTypeGroup(IssueTypeGroup value, IPresentableItem item, TreeModelNode structureelement, PresentationState state);
    private void PresentIssueTypeGroupName(IssueTypeGroupName value, IPresentableItem item, TreeModelNode structureelement, PresentationState state);
    private void PresentIssueSeverityGroup(IssueSeverityGroup value, IPresentableItem item, TreeModelNode structureelement, PresentationState state);
    protected virtual void AppendOccurrencesCount(IPresentableItem item, TreeModelNode node);
}
[SettingsKeyAttribute("JetBrains.Application.UI.Utils.UserInterfaceSettings", "JetBrains.ReSharper.Daemon.SolutionAnalysis.Resources.Strings", "InspectionResultsViewSettingsSettingDescription")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.InspectionResultViewSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Daemon.SolutionAnalysis.Resources.Strings", "GroupBySettingDescription")]
public int GroupingIndex;
}
[GlobalSettingsUpgraderAttribute("16")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.InspectionResultViewSettingsUpgrader : SettingTablesUpgrader {
    public InspectionResultViewSettingsUpgrader(ProductConfigurations productConfigurations);
    protected virtual void DoUpgrade(IComponentSettingsProvider legacySettingsProvider, IContextBoundSettingsStore boundSettingsStore, Lifetime upgradeLifetime, SettingsTableBase workspaceSettingsTable, SettingsTableBase globalSettingsTable);
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.IOpenFindSimilarIssuesActionProvider {
    public abstract virtual IBulbAction CreateAction(IProjectFile projectFile, IssueTypeGroup issueType);
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.IRunInspectionResultDescriptor {
    public ICollection`1<object> Issues { get; }
    public OneToListMap`2<SourceFilePtr, IssuePointer> IssuesToUpdate { get; }
    public IssueTypeGroup ShownIssueType { get; }
    public abstract virtual ICollection`1<object> get_Issues();
    public abstract virtual OneToListMap`2<SourceFilePtr, IssuePointer> get_IssuesToUpdate();
    public abstract virtual IssueTypeGroup get_ShownIssueType();
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.IssueSeverityGroup : object {
    private Severity mySeverity;
    public Severity Severity { get; }
    public IssueSeverityGroup(Severity severity);
    public Severity get_Severity();
    protected bool Equals(IssueSeverityGroup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(IssueSeverityGroup other);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.IssueTypeGroup : object {
    private FrugalLocalHashSet`1<IIssueType> myIssueTypes;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GroupId>k__BackingField;
    public IEnumerable`1<IIssueType> IssueTypes { get; }
    [CanBeNullAttribute]
public string Name { get; }
    [CanBeNullAttribute]
public string GroupId { get; }
    public IssueTypeGroup(IEnumerable`1<IIssueType> issueTypes);
    public IssueTypeGroup(IIssueType issueType, bool mergeCompound);
    public IssueTypeGroup(string groupId);
    public IEnumerable`1<IIssueType> get_IssueTypes();
    [PureAttribute]
public bool Contains(IIssueType issueType);
    private static IIssueType UnwrapOverriddenSeverityIssueType(IIssueType issueType);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public string get_GroupId();
    public bool Equals(IssueTypeGroup other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.IssueTypeGroupName : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GroupId>k__BackingField;
    public string Name { get; }
    [CanBeNullAttribute]
public string GroupId { get; }
    public IssueTypeGroupName(string groupId);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public string get_GroupId();
    public bool Equals(IssueTypeGroupName other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.NoIssuesFoundFakeNode : TreeSeparator {
    public NoIssuesFoundFakeNode(string title);
}
public static class JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.RunInspection : object {
    public static void Execute(IList`1<IProjectModelElement> scope, IssueTypeGroup issuesToShow);
    private static void ExecuteInBackground(ISolution solution, IList`1<IProjectModelElement> scope, IssueTypeGroup issuesToShow, IRunInspectionResultDescriptor descriptor);
    private static bool ShouldUseSwa(ISolution solution, Stack`1<IPsiSourceFile> scope, IssueTypeGroup issuesToShow);
    private static void ClearDescriptor(ISolution solution, IRunInspectionResultDescriptor descriptor);
    public static bool IsAvailable(IList`1<IProjectModelElement> scope);
    private static Stack`1<IPsiSourceFile> CollectFilesToAnalyze(ISolution solution, IEnumerable`1<IProjectModelElement> scope);
}
[ActionAttribute("RunInspection.CurrentProject", "JetBrains.ReSharper.Daemon.SolutionAnalysis.Resources.Strings", "CodeIssuesInCurrentProjectActionText")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.RunInspectionInCurrentProjectAction : object {
    public sealed virtual bool Update(IDataContext context, ActionPresentation presentation, DelegateUpdate nextUpdate);
    public sealed virtual void Execute(IDataContext context, DelegateExecute nextExecute);
}
[ActionAttribute("RunInspection.Solution", "JetBrains.ReSharper.Daemon.SolutionAnalysis.Resources.Strings", "CodeIssuesInSolutionActionText")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.RunInspectionInSolutionAction : object {
    public sealed virtual bool Update(IDataContext context, ActionPresentation presentation, DelegateUpdate nextUpdate);
    public sealed virtual void Execute(IDataContext context, DelegateExecute nextExecute);
}
[SolutionComponentAttribute("18")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.RunInspectionSettings : object {
    private ISolution mySolution;
    private ISettingsStore mySettingsStore;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IIssueType> <DefaultIssueTypesToHide>k__BackingField;
    public IEnumerable`1<IIssueType> DefaultIssueTypesToHide { get; }
    public IEnumerable`1<IIssueType> IssueTypesToHide { get; public set; }
    public RunInspectionSettings(IssueTypesManager issueTypesManager, ISolution solution, ISettingsStore settingsStore);
    public static RunInspectionSettings GetInstance(ISolution solution);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IIssueType> get_DefaultIssueTypesToHide();
    public IEnumerable`1<IIssueType> get_IssueTypesToHide();
    public void set_IssueTypesToHide(IEnumerable`1<IIssueType> value);
}
[GlobalSettingsUpgraderAttribute("16")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.RunInspectionSettingsUpgrader : object {
    public sealed virtual void Upgrade(IComponentSettingsProvider legacySettingsProvider, IContextBoundSettingsStore boundSettingsStore, Lifetime upgradeLifetime);
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.UI.IInspectionResultBrowserDescriptor {
}
[ShellFeaturePartAttribute("16")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.RunInspection.UI.InspectionResultGroupingProvider : OccurrenceBrowserGroupingProvider {
    private static TreeModelGrouping`1[] ourGroupings;
    private static InspectionResultGroupingProvider();
    public virtual ICollection`1<TreeModelGrouping`1<IOccurrence>> GetGroupings(TreeModelBrowserDescriptorBase descriptor);
    public virtual bool IsApplicable(TreeModelBrowserDescriptorBase descriptor);
}
[AttributeUsageAttribute("4")]
[MeansImplicitUseAttribute]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.SolutionAnalysisComponentAttribute : ComponentAttribute {
    public SolutionAnalysisComponentAttribute(Instantiation instantiation);
}
[SolutionAnalysisComponentAttribute("10")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.SolutionAnalysisManager : object {
    private bool myOptimizeInitialLoad;
    private bool myExcludedChanged;
    private IDisposable myFullCycleStopwatchCookie;
    private IDisposable myFirstCycleStopwatchCookie;
    private bool myFirstCycleIsStarted;
    private ISolution mySolution;
    private IssueClasses myIssueClasses;
    private DaemonResults myDaemonResults;
    private AnalysisResultsManager myAnalysisResultsManager;
    private HighlightingResultsMap myHighlightingResultsMap;
    private DocumentManager myDocumentManager;
    private IShellLocks myLocks;
    private FileImages myFileImages;
    private ILogger myLogger;
    private ILogger myPerfLogger;
    private Lifetime myLifetime;
    private DaemonEnablePolicy myEnablePolicy;
    private StageIdManager myStageIdManager;
    private SolutionAnalysisConfiguration mySweaConfiguration;
    private IPsiModules myPsiModules;
    private UpdatableTextRangesSources myUpdatableTextRangesSources;
    private IPersistentIndexManager myPersistentIndexManager;
    private DependencyManager myDependencyManager;
    private ISolutionAnalysisIndicator myIndicator;
    private IDictionary`2<SourceFilePtr, IList`1<KeyValuePair`2<Dependency, Hash>>> myRehighlightOptimizationMap;
    private CompactMap`2<SourceFilePtr, FileInfo> myFileToStateMap;
    private JetHashSet`1<SourceFilePtr> myAllFilesForProgress;
    private object myLock;
    private ProjectModelChangeAggregator myCurrentChange;
    private static Key`1<UsagesInfo> USAGES_INFO_KEY;
    private static Key`1<HierarchyInfo> HIERARCHY_INFO_KEY;
    private static Key`1<FileContentInfo> FILE_CONTENT_INFO_KEY;
    [CompilerGeneratedAttribute]
private ISimpleSignal <Reanalyzing>k__BackingField;
    public ISolution Solution { get; }
    public bool Loaded { get; }
    public IIssueSet IssueSet { get; }
    internal AdditionalAnalysisInfoIndex AdditionalAnalysisInfoIndex { get; }
    public ISimpleSignal Reanalyzing { get; }
    public SolutionAnalysisManager(ILogger logger, Lifetime lifetime, ISolution solution, DocumentManager documentManager, IShellLocks locks, FileImages fileImages, StageIdManager stageIdManager, IssueClasses issueClasses, IPsiConfiguration psiConfiguration, SolutionAnalysisConfiguration sweaConfiguration, ISettingsStore settingsStore, DaemonResults daemonResults, AnalysisResultsManager analysisResultsManager, DaemonEnablePolicy enablePolicy, HighlightingResultsMap highlightingResultsMap, ChangeManager changeManager, DaemonExcludedFilesManager daemonExcludedFilesManager, IPsiModules psiModules, IPersistentIndexManager persistentIndexManager, DependencyManager dependencyManager, ISolutionAnalysisIndicator indicator);
    private static SolutionAnalysisManager();
    public ISolution get_Solution();
    [CanBeNullAttribute]
public static SolutionAnalysisManager GetInstance(ISolution solution);
    private void SetFileState(SourceFilePtr file, FileState state);
    private FileState GetFileState(SourceFilePtr file);
    public bool IsFileUpToDate(IPsiSourceFile psiSourceFile);
    public bool get_Loaded();
    public bool Load();
    private bool ShouldIgnoreAllErrorsInModule(IPsiModule module);
    private void DataLoaded(DaemonResultsData data);
    private void AdditionalInfoReady(AdditionalAnalysisInfo additionalInfo);
    private void DataLoadFinished(bool result);
    public void Unload();
    private void ExcludedFilesChanged();
    private void CreateNewChange();
    public sealed virtual object Execute(IChangeMap changeMap);
    [NotNullAttribute]
internal IEnumerable`1<IPsiSourceFile> GetFilesToAnalyzeByDependencies();
    [NotNullAttribute]
internal IList`1<IPsiSourceFile> GetFilesToAnalyze();
    private void FlushChanges();
    private void DropFile(SourceFilePtr file);
    private void FlushProjectModelChanges();
    private void FlushExcludedChanges();
    private void ApplyChanges(IDictionary`2<Dependency, HashPair> changes);
    private bool RehighlightOptimized(SourceFilePtr file, int changedCount, Int32[] changedForFile, IDictionary`2<Dependency, HashPair> changes);
    private void PromotePartlyReanalyzedToModified();
    public IIssueSet get_IssueSet();
    public void AnalysisStageCompleted(SourceFilePtr file, Type stageType, byte layer, Nullable`1<int> settingsHash, IEnumerable`1<HighlightingInfo> highlightings, bool fullRehighlight, IEnumerable`1<DocumentRange> ranges, DaemonProcessKind processKind, IContextBoundSettingsStore settingsStore);
    internal void AnalysisStageCompleted(SourceFilePtr file, Type stageType, byte layer, Nullable`1<int> settingsHash, IssueData[] issues, bool fullRehighlight, IEnumerable`1<DocumentRange> ranges, DaemonProcessKind processKind, IContextBoundSettingsStore settingsStore);
    public void AnalysisCompleted(SourceFilePtr sourceFile, IDaemonProcess process, DependencySet dependencies, bool analysisSupported, DaemonProcessKind processKind, IContextBoundSettingsStore settingsStore);
    private bool ContainsIssuesOnlyFromSolutionAnalysisService(SourceFilePtr sourceFile);
    public void FilePartlyReanalyzed(SourceFilePtr file, IDaemonProcess process, DaemonProcessKind processKind);
    public void AllFilesAnalyzed();
    internal AdditionalAnalysisInfoIndex get_AdditionalAnalysisInfoIndex();
    public bool FetchGlobalUsageAnalysisData(SourceFilePtr file, IGlobalUsageChecker& usageChecker, IFileContentInfo& fileContentInfo);
    private static void StoreAdditionalInfo(IDaemonProcess process, IGlobalUsageChecker globalUsageChecker);
    private static AdditionalAnalysisInfo BuildAdditionalInfo(IDaemonProcess daemonProcess);
    [CompilerGeneratedAttribute]
public ISimpleSignal get_Reanalyzing();
    public void ReanalyzeAll();
    public void ReanalyzeFile(SourceFilePtr file);
    private void AddAllFilesInSolution(bool dropResults);
    public void ReanalyzeIfSettingsChanged(IPsiSourceFile sourceFile);
    [CompilerGeneratedAttribute]
private bool <Load>g__CheckForInterrupt|39_0();
    [CompilerGeneratedAttribute]
private bool <GetFilesToAnalyzeByDependencies>b__51_0(IPsiSourceFile file);
}
[SolutionComponentAttribute("10")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.SolutionAnalysisServiceImpl : SolutionAnalysisServiceDefault {
    [NotNullAttribute]
private ILogger myLogger;
    private IComponentContainer mySweaComponentContainer;
    private LifetimeDefinition mySweaLifetimeDef;
    [NotNullAttribute]
private IComponentContainer myParentComponentContainer;
    private Lifetime myLifetime;
    [NotNullAttribute]
private IPartCatalogSet myCatalogueSet;
    private SolutionAnalysisManager mySolutionAnalysisManager;
    private IDisposable myLoadStopwatchCookie;
    private ILogger myPerfLogger;
    [NotNullAttribute]
private FileImages myFileImages;
    [NotNullAttribute]
private IAsyncComposeManager myAsyncComposeManager;
    [NotNullAttribute]
private UsageCheckingServiceManager myUsageCheckingServiceManager;
    [NotNullAttribute]
private ISolutionAnalysisIndicator mySolutionAnalysisIndicator;
    [NotNullAttribute]
private DaemonEnablePolicy myDaemonEnablePolicy;
    [NotNullAttribute]
private IShellLocks myLocks;
    [NotNullAttribute]
private SolutionAnalysisConfiguration mySweaConfiguration;
    [NotNullAttribute]
private IssueClasses myIssueClasses;
    [NotNullAttribute]
public SolutionAnalysisConfiguration Configuration { get; }
    public bool Loaded { get; }
    public IGlobalUsageChecker UsageChecker { get; }
    public ISimpleSignal Reanalyzing { get; }
    public SolutionAnalysisServiceImpl(ILogger logger, Lifetime lifetime, ShellPartCatalogSet catalogueSet, IComponentContainer parentComponentContainer, ISolutionAnalysisIndicator solutionAnalysisIndicator, DaemonEnablePolicy daemonEnablePolicy, IShellLocks locks, SolutionAnalysisConfiguration sweaConfiguration, IssueClasses issueClasses, FileImages fileImages, IAsyncComposeManager asyncComposeManager, UsageCheckingServiceManager usageCheckingServiceManager);
    public virtual SolutionAnalysisConfiguration get_Configuration();
    public virtual bool get_Loaded();
    public virtual IDisposable RunAnalysisCookie();
    public virtual bool Load();
    private void InitializeContainer();
    private void DisposeContainer();
    public virtual void Unload();
    public virtual IGlobalUsageChecker get_UsageChecker();
    public virtual bool FetchGlobalUsageAnalysisData(IPsiSourceFile sourceFile, IGlobalUsageChecker& usageChecker, IFileContentInfo& fileContentInfo);
    public virtual Nullable`1<ElementId> GetElementId(IDeclaredElement element);
    [NotNullAttribute]
public virtual IList`1<IPsiSourceFile> GetFilesToAnalyze(IInterruptable interruptable);
    public virtual void AnalyzeInvisibleFile(IPsiSourceFile sourceFile, bool sync);
    internal IssueData BuildFileError(string message);
    public virtual void AnalysisStageCompleted(IPsiSourceFile sourceFile, IDaemonStage stage, byte layer, IEnumerable`1<HighlightingInfo> highlightings, bool fullRehighlight, IEnumerable`1<DocumentRange> ranges, DaemonProcessKind processKind, IContextBoundSettingsStore settingsStore);
    public virtual void AnalysisCompleted(IPsiSourceFile sourceFile, IDaemonProcess daemonProcess, DependencySet dependencies, bool analysisSupported, DaemonProcessKind processKind);
    public virtual void FilePartlyReanalyzed(IPsiSourceFile sourceFile, IDaemonProcess daemonProcess, DaemonProcessKind processKind);
    public virtual void AllFilesAnalyzed();
    public virtual void NavigateInErrorsView(IPsiSourceFile sourceFile);
    public virtual bool ShowEnablingAnalysisWarning(IWin32Window parent, IWindowBranding windowBranding);
    public virtual void ReanalyzeFile(IPsiSourceFile psiSourceFile);
    public virtual ISimpleSignal get_Reanalyzing();
    public virtual void ReanalyzeAll();
    public virtual void MarkModuleAsDirty(IPsiModule psiModule);
    public virtual T GetComponent();
    public virtual bool ShouldNotifySwea(IPsiSourceFile sourceFile);
    [CompilerGeneratedAttribute]
private void <.ctor>b__19_0(Lifetime _, bool isEnabled);
    [CompilerGeneratedAttribute]
private void <.ctor>b__19_1(Lifetime _);
    [CompilerGeneratedAttribute]
private void <RunAnalysisCookie>b__22_0();
    [CompilerGeneratedAttribute]
private void <InitializeContainer>b__24_0(Lifetime lifetime);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.StageHighlightingResult : object {
    [NotNullAttribute]
public IssueData[] Issues;
    public Nullable`1<int> SettingsHash;
    public bool IsEmpty { get; }
    public StageHighlightingResult(IssueData[] issues, Nullable`1<int> settingsHash);
    public bool get_IsEmpty();
    public void WriteTo(UnsafeWriter writer);
    public static StageHighlightingResult ReadFrom(UnsafeReader reader, SourceFilePtr file, IssueStrings issueStrings, IssueClasses issueClasses, HighlightingSettingsManager highlightingSettingsManager);
    public void UpdatableRanges(Func`2<TextRange, TextRange> updateFunc);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ShellComponentAttribute("16")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.StageIdManager : object {
    private HashSet`1<string> myStageIds;
    private Dictionary`2<Type, string> myTypeToStageId;
    [PureAttribute]
public string StageId(Type stageType);
    public string InternId(string id);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Statistics.SolutionAnalysisCompletedMark : object {
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Statistics.SolutionAnalysisEnabledAndReadyMark : object {
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Statistics.SolutionAnalysisEnabledMark : object {
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ElementProblemAnalyzerAttribute("16", "Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Statistics.SolutionAnalysisFileStatisticsAnalyzer : ElementProblemAnalyzer`1<IFile> {
    [NullableContextAttribute("1")]
public sealed virtual bool ShouldRun(IFile file, ElementProblemAnalyzerData data);
    [NullableContextAttribute("1")]
protected virtual void Run(IFile file, ElementProblemAnalyzerData data, IHighlightingConsumer consumer);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Statistics.SolutionAnalysisPausedByUserMark : object {
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Statistics.SolutionAnalysisPausedMark : object {
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Statistics.SolutionAnalysisResourcesUtilizationModeMark : object {
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.Statistics.SolutionAnalysisWarningsModeMark : object {
}
[PsiComponentAttribute("10")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.SweaUsagesPublisher : UsagesPublisherStub {
    private object mySyncRoot;
    private HashSet`1<IProperty`1<bool>> myResourcesSubscriptions;
    private Dictionary`2<ElementId, IProperty`1<bool>> myResourcesSubscriptionsById;
    private IShellLocks myShellLocks;
    [NotNullAttribute]
private SolutionAnalysisService mySolutionAnalysisService;
    public SweaUsagesPublisher(Lifetime lifetime, IShellLocks shellLocks, SolutionAnalysisService solutionAnalysisService);
    private void Invalidate();
    public virtual bool IsSubscribed(IProperty`1<bool> property);
    public virtual void Subscribe(Lifetime lifetime, IEnumerable`1<IDeclaredElement> relatedDeclaredElements, IProperty`1<bool> property);
}
[SettingsKeyAttribute("JetBrains.Application.Settings.WellKnownRootKeys.HousekeepingSettings", "JetBrains.ReSharper.Daemon.SolutionAnalysis.Resources.Strings", "ContextActionPageUISettingsSettingDescription")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.SweaViewSettings : object {
    [SettingsEntryAttribute("Mono.Cecil.CustomAttributeArgument", "JetBrains.ReSharper.Daemon.SolutionAnalysis.Resources.Strings", "UseNewTreeForSweaSettingDescription")]
public bool UseNewTree;
}
[ZoneDefinitionAttribute]
[ZoneLicenseAttribute("3145720492160894540861205022590510994015486567574670580789")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.SweaZone : object {
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.SyncReanalyzeCookie : object {
    private SolutionAnalysisManager mySolutionAnalysisManager;
    [ThreadStaticAttribute]
private static bool ourIsSuppressed;
    public static bool IsActive { get; }
    private SyncReanalyzeCookie(IShellLocks shellLocks, SolutionAnalysisManager solutionAnalysisManager);
    public static bool get_IsActive();
    public sealed virtual void Dispose();
    public static SyncReanalyzeCookie Create(IShellLocks shellLocks, SolutionAnalysisManager solutionAnalysisManager);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.Common.IssueOccurenceComparer : object {
    public IEnumerable`1<IDependencyDefinition> Dependencies { get; }
    public sealed virtual int Compare(ITreeModelNode x, ITreeModelNode y);
    public sealed virtual IEnumerable`1<IDependencyDefinition> get_Dependencies();
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.Common.IssueOccurenceReferenceEqualityComparer : object {
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Object>.Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
}
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.EnvoysCaches : object {
    private Dictionary`2<IPsiSourceFile, ProjectModelElementEnvoy> myFileToEnvoy;
    [CanBeNullAttribute]
public ProjectModelElementEnvoy GetEnvoy(IssuePointer issuePointer);
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.IErrorsTreeContext {
    public IIssueSet IssueSet { get; }
    public bool ShowIgnoredIssues { get; }
    public IIssueGroup IssueGroup { get; }
    public bool CanSetStyleForEnvoy { get; }
    public bool CanSetIssueCount { get; }
    public abstract virtual IIssueSet get_IssueSet();
    public abstract virtual bool get_ShowIgnoredIssues();
    public abstract virtual IIssueGroup get_IssueGroup();
    public abstract virtual bool get_CanSetStyleForEnvoy();
    public abstract virtual bool get_CanSetIssueCount();
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.IErrorsTreeContextWithMutableIssueGroup {
    [NotNullAttribute]
public ISimpleSignal ShowIgnoredIssuesChanged { get; }
    public abstract virtual bool RecalculateIssueGroup();
    public abstract virtual ISimpleSignal get_ShowIgnoredIssuesChanged();
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.IIssueInfo {
    public IIssue Issue { get; }
    public Severity IssueSeverity { get; }
    public abstract virtual IIssue get_Issue();
    public abstract virtual Severity get_IssueSeverity();
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.IIssueInfoCache {
    public abstract virtual IIssueInfo GetInfo(IIssueOccurrence occurence);
    public abstract virtual ICollection`1<IIssueInfo> GetAll();
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.INodeViewModelUpdater {
    public abstract virtual void BeginUpdate(ITreeModelNode node);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.IssueInfo : object {
    [CompilerGeneratedAttribute]
private IIssue <Issue>k__BackingField;
    [CompilerGeneratedAttribute]
private Severity <IssueSeverity>k__BackingField;
    public IIssue Issue { get; }
    public Severity IssueSeverity { get; }
    public IssueInfo(IIssue issue);
    [CompilerGeneratedAttribute]
public sealed virtual IIssue get_Issue();
    [CompilerGeneratedAttribute]
public sealed virtual Severity get_IssueSeverity();
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.IssueInfoCache : object {
    private Dictionary`2<IIssueOccurrence, IIssueInfo> myCache;
    public sealed virtual IIssueInfo GetInfo(IIssueOccurrence occurence);
    public sealed virtual ICollection`1<IIssueInfo> GetAll();
    public void Add(IIssueOccurrence item);
    public void Remove(IIssueOccurrence item);
    public void Clear();
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.ISweaBrowserDescriptor {
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.ISweaItemStyleUpdater {
    public abstract virtual void SetStyle(IRichTextLiveTreeNode node, bool canResetToDefault);
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.ISweaLiveTreeNode {
    public IBindable`1<int> CanIgnore { get; }
    public IBindable`1<double> Ignored { get; }
    public IBindable`1<bool> IsToBeReanalyzed { get; }
    public abstract virtual IBindable`1<int> get_CanIgnore();
    public abstract virtual IBindable`1<double> get_Ignored();
    public abstract virtual IBindable`1<bool> get_IsToBeReanalyzed();
}
internal interface JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.ISweaModelChangeCommand {
}
internal interface JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.ISweaModelUpdateBatcher {
    public abstract virtual void BeginNewUpdate();
    [NotNullAttribute]
public abstract virtual ISweaModelChangeCommand GetNextCommand();
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.ISweaProgressIndicatorTracker {
    public bool IsBusy { get; public set; }
    public abstract virtual bool get_IsBusy();
    public abstract virtual void set_IsBusy(bool value);
}
public interface JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.ITreeModelLock {
    public abstract virtual bool TryEnterWriting();
    public abstract virtual bool CheckShouldInterrupt();
    public abstract virtual void ExitWriting();
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.MutableErrorsTreePresenterContext : object {
    [NotNullAttribute]
private IProperty`1<SweaWarningsMode> myIncludeWarningsInSwea;
    private IShellLocks myLocks;
    private bool myShowIgnoredIssues;
    [CompilerGeneratedAttribute]
private IIssueSet <IssueSet>k__BackingField;
    [CompilerGeneratedAttribute]
private IIssueGroup <IssueGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private ISimpleSignal <ShowIgnoredIssuesChanged>k__BackingField;
    public bool CanSetStyleForEnvoy { get; }
    public bool CanSetIssueCount { get; }
    [NotNullAttribute]
public IIssueSet IssueSet { get; }
    public bool ShowIgnoredIssues { get; public set; }
    public IIssueGroup IssueGroup { get; private set; }
    public ISimpleSignal ShowIgnoredIssuesChanged { get; }
    public MutableErrorsTreePresenterContext(Lifetime lifetime, IIssueSet issueSet, IProperty`1<SweaWarningsMode> includeWarningsInSwea, IShellLocks locks);
    public sealed virtual bool get_CanSetStyleForEnvoy();
    public sealed virtual bool get_CanSetIssueCount();
    [CompilerGeneratedAttribute]
public sealed virtual IIssueSet get_IssueSet();
    public sealed virtual bool get_ShowIgnoredIssues();
    public void set_ShowIgnoredIssues(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IIssueGroup get_IssueGroup();
    [CompilerGeneratedAttribute]
private void set_IssueGroup(IIssueGroup value);
    [CompilerGeneratedAttribute]
public sealed virtual ISimpleSignal get_ShowIgnoredIssuesChanged();
    public sealed virtual bool RecalculateIssueGroup();
}
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.NodeViewModelAsyncUpdater : AsyncCommitClientBase {
    private ILogger myLogger;
    private ISync myTreeLock;
    private Action`1<IEnumerable`1<ITreeModelNode>> myAddNodesToUpdateCallback;
    private ISweaItemStyleUpdater mySweaItemStyleUpdater;
    private List`1<ITreeModelNode> myNodesToUpdate;
    public NodeViewModelAsyncUpdater(Lifetime lifetime, ISweaItemStyleUpdater sweaItemStyleUpdater, List`1<ITreeModelNode> nodesToUpdate, IGroupingEvent refreshEvent, IShellLocks locks, ISync treeLock, Action`1<IEnumerable`1<ITreeModelNode>> addNodesToUpdateCallback);
    protected virtual void Run();
    private void ProcessNode(ITreeModelNode node);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.NodeViewModelUpdater : object {
    private Lifetime myLifetime;
    private RichTextLiveTreeModel myModel;
    private IAbstractAsyncCommitService myAsyncCommitService;
    private IShellLocks myLocks;
    private IGroupingEvent myUpdateNodesEvent;
    [NotNullAttribute]
private ICollection`1<ITreeModelNode> myNodesToUpdate;
    public NodeViewModelUpdater(Lifetime lifetime, RichTextLiveTreeModel model, IAbstractAsyncCommitService asyncCommitService, IGroupingEventFactory groupingEventFactory, IShellLocks locks);
    public sealed virtual void BeginUpdate(ITreeModelNode node);
    private void Update();
    private void AddNodesToUpdate(IEnumerable`1<ITreeModelNode> nodes);
}
[SolutionComponentAttribute("0")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.SolutionAnalysisWarningsModeConfirmation : object {
    private Lifetime myLifetime;
    private ISolution mySolution;
    private SolutionAnalysisConfiguration mySolutionAnalysisConfiguration;
    public SolutionAnalysisWarningsModeConfirmation(Lifetime lifetime, ISolution solution, SolutionAnalysisConfiguration solutionAnalysisConfiguration);
    public bool ShouldShowUserConfirmation();
    public virtual void ShowUserConfirmation(Lifetime outerLifetime, Action onEnabled, Action onCancelled);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.SweaCompositeRichTextLiveTreeNode : CompositeRichTextLiveTreeNode {
    private LifetimeDefinition myLifetimeDefinition;
    private NodeViewModelUpdater myNodeViewModelUpdater;
    [CompilerGeneratedAttribute]
private IBindable`1<int> <CanIgnore>k__BackingField;
    [CompilerGeneratedAttribute]
private IBindable`1<double> <Ignored>k__BackingField;
    [CompilerGeneratedAttribute]
private IBindable`1<bool> <IsToBeReanalyzed>k__BackingField;
    public IBindable`1<int> CanIgnore { get; private set; }
    public IBindable`1<double> Ignored { get; private set; }
    public IBindable`1<bool> IsToBeReanalyzed { get; private set; }
    public SweaCompositeRichTextLiveTreeNode(LifetimeDefinition lifetimeDefinition, RichTextLiveTreeModel model, object dataItem, IFreeThreadedThrottlingGroupingEvent throttlingGroupingEvent, NodeViewModelUpdater nodeViewModelUpdater);
    [CompilerGeneratedAttribute]
public sealed virtual IBindable`1<int> get_CanIgnore();
    [CompilerGeneratedAttribute]
private void set_CanIgnore(IBindable`1<int> value);
    [CompilerGeneratedAttribute]
public sealed virtual IBindable`1<double> get_Ignored();
    [CompilerGeneratedAttribute]
private void set_Ignored(IBindable`1<double> value);
    [CompilerGeneratedAttribute]
public sealed virtual IBindable`1<bool> get_IsToBeReanalyzed();
    [CompilerGeneratedAttribute]
private void set_IsToBeReanalyzed(IBindable`1<bool> value);
    public virtual void Dispose();
    public virtual string ToString();
    protected virtual IEnumerable`1<ISuspendable> GetAggreagors();
    protected virtual void CreateAggregators(IBindableView`1<IRichTextLiveTreeNode> filteredChildrenRaw);
    private static int GetCanIgnore(IRichTextLiveTreeNode node);
    private static double GetContainsIgnored(IRichTextLiveTreeNode node);
    private static bool GetIsToBeReanalyzed(IRichTextLiveTreeNode node);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.SweaLiveTreeModel : RichTextLiveTreeModel {
    [NotNullAttribute]
private ILogger myLogger;
    [NotNullAttribute]
private IErrorsTreeContextWithMutableIssueGroup myTreeContext;
    [NotNullAttribute]
private IShellLocks myLocks;
    [NotNullAttribute]
private IGroupingEventFactory myGroupingEventFactory;
    [NotNullAttribute]
private IAbstractAsyncCommitService myAbstractAsyncCommitService;
    [NotNullAttribute]
private ISweaProgressIndicatorTracker mySweaProgressIndicatorTracker;
    [NotNullAttribute]
private BindableSetCollectionWithoutIndexTracking`1<IIssueOccurrence> myEditableItems;
    [NotNullAttribute]
private IDictionary`2<SourceFilePtr, ICollection`1<IIssueOccurrence>> myIssuesPerFile;
    [NotNullAttribute]
private IGroupingEvent myUpdateEvent;
    [NotNullAttribute]
private UpdateRequestStore myCurrentRequestStore;
    [NotNullAttribute]
private SequentialLifetimes mySweaTreeAsyncCommitClientLifetimes;
    public bool SuspendDuringModelChanging { get; }
    public SweaLiveTreeModel(Lifetime lifetime, MutableErrorsTreePresenterContext treeContext, IssueInfoCache issueInfoCache, IEnumerable`1<ISignal`1<Nullable`1<SourceFilePtr>>> updateFileSignals, ISignal`1<ICollection`1<SourceFilePtr>> updateFilesSignal, UpdateRequestStore updateRequestStore, IShellLocks locks, IGroupingEventFactory groupingEventFactory, ReadWriteLock lock, StructuredPresenter`2<TreeModelNode, IPresentableItem> presenter, IAbstractAsyncCommitService abstractAsyncCommitService, IFreeThreadedThrottlingGroupingEventFactory freeThreadedThrottlingGroupingEventFactory, ISweaProgressIndicatorTracker sweaProgressIndicatorTracker, INodeChildrenUpdaterFactory nodeChildrenUpdaterFactory);
    public virtual bool get_SuspendDuringModelChanging();
    private void UpdateFile(Nullable`1<SourceFilePtr> ptrOptional);
    private void UpdateFiles(ICollection`1<SourceFilePtr> files);
    private void RequestUpdateAll();
    private void RequestUpdate(SourceFilePtr ptr);
    private void HandleUpdateShouldBeExecuted();
    private void Update();
    private void SubscribeFillCache(IssueInfoCache issueInfoCache);
    [CompilerGeneratedAttribute]
private void <.ctor>b__11_1(Lifetime lt, bool val);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.SweaLiveTreeModelNodeFactory : object {
    private RichTextLiveTreeModel myModel;
    private IIssueInfoCache myIssueInfoCache;
    [NotNullAttribute]
private IFreeThreadedThrottlingGroupingEvent myThrottlingGroupingEvent;
    private NodeViewModelUpdater myNodeViewModelUpdater;
    private IErrorsTreeContext myContext;
    private Func`2<object, bool> myIsMeaningful;
    public SweaLiveTreeModelNodeFactory(RichTextLiveTreeModel model, IIssueInfoCache issueInfoCache, IFreeThreadedThrottlingGroupingEvent throttlingGroupingEvent, NodeViewModelUpdater nodeViewModelUpdater, IErrorsTreeContext context);
    public sealed virtual CompositeRichTextLiveTreeNode CreateRoot();
    public sealed virtual ITreeModelNode CreateNode(object dataItem);
    protected virtual ITreeModelNode CreateMeaningfullNode(object dataItem);
    protected virtual ITreeModelNode CreateCompositeNode(object dataItem);
}
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.SweaModelChangeCleanCommand : object {
}
internal abstract class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.SweaModelChangeCommandWithFiles : object {
    [CompilerGeneratedAttribute]
private ICollection`1<SourceFilePtr> <Files>k__BackingField;
    public ICollection`1<SourceFilePtr> Files { get; }
    protected SweaModelChangeCommandWithFiles(ICollection`1<SourceFilePtr> files);
    [CompilerGeneratedAttribute]
public ICollection`1<SourceFilePtr> get_Files();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.SweaModelChangeFilterCommand : SweaModelChangeCommandWithFiles {
    public SweaModelChangeFilterCommand(ICollection`1<SourceFilePtr> files);
}
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.SweaModelChangeStopCommand : object {
}
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.SweaModelChangeWaitCommand : object {
}
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.SweaModelDeltaPortion : SweaModelChangeCommandWithFiles {
    public SweaModelDeltaPortion(ICollection`1<SourceFilePtr> files);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.SweaProgressIndicatorTracker : object {
    private IProperty`1<bool> myIsUpdatingContent;
    private ILogger myLogger;
    private GroupingEvent myUpdateStateEvent;
    private bool myIsBusy;
    private object mySyncObject;
    public bool IsBusy { get; public set; }
    public SweaProgressIndicatorTracker(Lifetime lifetime, IProperty`1<bool> isBusy, IProperty`1<bool> isUpdatingContent, IThreading threading);
    public sealed virtual bool get_IsBusy();
    public sealed virtual void set_IsBusy(bool value);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.SweaRichTextLiveTreeNode : RichTextLiveTreeNode {
    [CompilerGeneratedAttribute]
private IBindable`1<int> <CanIgnore>k__BackingField;
    [CompilerGeneratedAttribute]
private IBindable`1<double> <Ignored>k__BackingField;
    [CompilerGeneratedAttribute]
private IBindable`1<bool> <IsToBeReanalyzed>k__BackingField;
    public IBindable`1<int> CanIgnore { get; }
    public IBindable`1<double> Ignored { get; }
    public IBindable`1<bool> IsToBeReanalyzed { get; }
    public SweaRichTextLiveTreeNode(RichTextLiveTreeModel model, object dataItem, IIssueInfoCache issueInfoCache, IErrorsTreeContext context);
    [CompilerGeneratedAttribute]
public sealed virtual IBindable`1<int> get_CanIgnore();
    [CompilerGeneratedAttribute]
public sealed virtual IBindable`1<double> get_Ignored();
    [CompilerGeneratedAttribute]
public sealed virtual IBindable`1<bool> get_IsToBeReanalyzed();
    public virtual string ToString();
}
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.SweaTreeAsyncCommitClient : object {
    private Guid myId;
    private Lifetime myLifetime;
    private ILogger myLogger;
    private ISweaModelUpdateBatcher mySweaModelUpdateBatcher;
    private IShellLocks myLocks;
    private ITreeModelLock myBackendLock;
    private ITreeModelLock myTreeLock;
    private BindableSetCollectionWithoutIndexTracking`1<IIssueOccurrence> myElements;
    private IDictionary`2<SourceFilePtr, ICollection`1<IIssueOccurrence>> myIssuesPerFile;
    private ISweaProgressIndicatorTracker mySweaProgressIndicatorTracker;
    private ICleanableModel myCleanableModel;
    private IErrorsTreeContextWithMutableIssueGroup myTreeContext;
    private IGroupingEvent myQueueCommitClientAgain;
    private LifetimeDefinition myLifetimeDefinition;
    public SweaTreeAsyncCommitClient(Lifetime lifetime, ISweaModelUpdateBatcher sweaModelUpdateBatcher, IShellLocks locks, IGroupingEventFactory groupingEventFactory, IAbstractAsyncCommitService abstractAsyncCommitService, ITreeModelLock backendLock, ITreeModelLock treeLock, BindableSetCollectionWithoutIndexTracking`1<IIssueOccurrence> elements, IDictionary`2<SourceFilePtr, ICollection`1<IIssueOccurrence>> issuedPerFile, ISweaProgressIndicatorTracker sweaProgressIndicatorTracker, ICleanableModel cleanableModel, IErrorsTreeContextWithMutableIssueGroup treeContext);
    public sealed virtual Action BeforeCommit();
    public sealed virtual void OnInterrupt();
    private void BeforeCommitImpl();
    private UpdatingDelta UpdateIssuesInFiles(ICollection`1<SourceFilePtr> files);
}
[ShellFeaturePartAttribute("16")]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.SweaTreeGroupingProvider : InspectionResultGroupingProvider {
    public virtual bool IsApplicable(TreeModelBrowserDescriptorBase descriptor);
    public virtual ICollection`1<TreeModelGrouping`1<IOccurrence>> GetGroupings(TreeModelBrowserDescriptorBase descriptor);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.TreeModelLock : object {
    private ISuspendable mySuspendable;
    private NoContentLockInsideReadWriteLock myTreeLock;
    public TreeModelLock(ISuspendable suspendable, NoContentLockInsideReadWriteLock treeLock);
    public sealed virtual bool TryEnterWriting();
    public sealed virtual bool CheckShouldInterrupt();
    public sealed virtual void ExitWriting();
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.TreeModelLockWrapper : object {
    private ISync myLockWriteLock;
    public TreeModelLockWrapper(ReadWriteLock lock);
    public sealed virtual bool TryEnterWriting();
    public sealed virtual bool CheckShouldInterrupt();
    public sealed virtual void ExitWriting();
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.UpdateRequestStore : object {
    private IErrorsTreeContextWithMutableIssueGroup myErrorsTreeContext;
    private ILogger myLogger;
    private object mySyncLock;
    private bool myUpdateAll;
    private bool myUpdating;
    private JetHashSet`1<SourceFilePtr> myFiles;
    private Queue`1<SourceFilePtr> myOrderedFiles;
    public UpdateRequestStore(IErrorsTreeContextWithMutableIssueGroup errorsTreeContext);
    public bool RequestUpdateAll();
    public bool RequestUpdate(SourceFilePtr ptr);
    protected virtual void PatchOrderedFiles(Queue`1<SourceFilePtr> orderedFiles);
    private void Add(SourceFilePtr ptr);
    private SourceFilePtr Dequeue();
    public sealed virtual void BeginNewUpdate();
    private sealed virtual override ISweaModelChangeCommand JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.ISweaModelUpdateBatcher.GetNextCommand();
}
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.UpdatingDelta : object {
    private Dictionary`2<SourceFilePtr, UpdatingDeltaForFile> myDeltas;
    public ICollection`1<UpdatingDeltaForFile> Deltas { get; }
    public ICollection`1<UpdatingDeltaForFile> get_Deltas();
    public void AddItemToAdd(IIssueOccurrence occurrence);
    public void AddItemToDelete(IIssueOccurrence occurrence);
    private UpdatingDeltaForFile GetDelta(IIssueOccurrence occurrence);
}
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.UI.UpdatingDeltaForFile : object {
    [CompilerGeneratedAttribute]
private SourceFilePtr <File>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IIssueOccurrence> <ItemsToDelete>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IIssueOccurrence> <ItemsToAdd>k__BackingField;
    public SourceFilePtr File { get; }
    public IList`1<IIssueOccurrence> ItemsToDelete { get; }
    public IList`1<IIssueOccurrence> ItemsToAdd { get; }
    public UpdatingDeltaForFile(SourceFilePtr file);
    [CompilerGeneratedAttribute]
public SourceFilePtr get_File();
    [CompilerGeneratedAttribute]
public IList`1<IIssueOccurrence> get_ItemsToDelete();
    [CompilerGeneratedAttribute]
public IList`1<IIssueOccurrence> get_ItemsToAdd();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DaemonStageAttribute("16")]
internal class JetBrains.ReSharper.Daemon.SolutionAnalysis.UnknownLanguageStage : object {
    [CompilerGeneratedAttribute]
private UsageCheckingServiceManager <usageCheckingServiceManager>P;
    public UnknownLanguageStage(UsageCheckingServiceManager usageCheckingServiceManager);
    public sealed virtual IEnumerable`1<IDaemonStageProcess> CreateProcess(IDaemonProcess process, IContextBoundSettingsStore settings, DaemonProcessKind processKind);
}
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.UsagesInfo : object {
    public Dictionary`2<ElementId, UsageState> ElementsUsed;
    public ValueTuple`2[] Counters;
    public Dictionary`2<SwaExtensionProviderId, ISwaExtensionInfo> SwaExtensionUsageDataInfo;
    private UsagesInfo(CollectUsagesStageProcess daemonStage);
    public UsagesInfo(Dictionary`2<ElementId, UsageState> elementsUsed, ValueTuple`2[] counters, Dictionary`2<SwaExtensionProviderId, ISwaExtensionInfo> swaExtensionUsageDataInfo);
    [CanBeNullAttribute]
public static UsagesInfo FromDaemonProcess(IDaemonProcess process);
    [NotNullAttribute]
private static Dictionary`2<ElementId, UsageState> FillIdsMap(Dictionary`2<ElementId, UsageState> map, IEnumerable`1<KeyValuePair`2<ElementId, UsageState>> members);
    public void WriteTo(UnsafeWriter writer);
    public static UsagesInfo ReadFrom(SolutionAnalysisConfiguration configuration, UnsafeReader reader);
}
[ZoneMarkerAttribute]
public class JetBrains.ReSharper.Daemon.SolutionAnalysis.ZoneMarker : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
