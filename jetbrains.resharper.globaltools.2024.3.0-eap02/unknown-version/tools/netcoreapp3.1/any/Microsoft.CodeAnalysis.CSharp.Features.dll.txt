[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CodeStyle.CSharpFormattingAnalyzer : AbstractFormattingAnalyzer {
    protected ISyntaxFormatting SyntaxFormatting { get; }
    protected virtual ISyntaxFormatting get_SyntaxFormatting();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CodeStyle.CSharpFormattingCodeFixProvider : AbstractFormattingCodeFixProvider {
    protected ISyntaxFormatting SyntaxFormatting { get; }
    protected virtual ISyntaxFormatting get_SyntaxFormatting();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.AddAccessibilityModifiers.CSharpAddAccessibilityModifiers : AbstractAddAccessibilityModifiers`1<MemberDeclarationSyntax> {
    public static CSharpAddAccessibilityModifiers Instance;
    private static CSharpAddAccessibilityModifiers();
    public virtual bool ShouldUpdateAccessibilityModifier(IAccessibilityFacts accessibilityFacts, MemberDeclarationSyntax member, AccessibilityModifiersRequired option, SyntaxToken& name, Boolean& modifierAdded);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddAccessibilityModifiers.CSharpAddAccessibilityModifiersCodeFixProvider : AbstractAddAccessibilityModifiersCodeFixProvider {
    [NullableContextAttribute("1")]
protected virtual SyntaxNode MapToDeclarator(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.AddAccessibilityModifiers.CSharpAddAccessibilityModifiersDiagnosticAnalyzer : AbstractAddAccessibilityModifiersDiagnosticAnalyzer`1<CompilationUnitSyntax> {
    protected virtual void ProcessCompilationUnit(SyntaxTreeAnalysisContext context, CodeStyleOption2`1<AccessibilityModifiersRequired> option, CompilationUnitSyntax compilationUnit);
    private void ProcessMembers(SyntaxTreeAnalysisContext context, CodeStyleOption2`1<AccessibilityModifiersRequired> option, SyntaxList`1<MemberDeclarationSyntax> members);
    private void ProcessMemberDeclaration(SyntaxTreeAnalysisContext context, CodeStyleOption2`1<AccessibilityModifiersRequired> option, MemberDeclarationSyntax member);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.AddAccessibilityModifiers.IAddAccessibilityModifiersService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddAccessibilityModifiers.CSharpAddAccessibilityModifiersService : CSharpAddAccessibilityModifiers {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddAnonymousTypeMemberName.CSharpAddAnonymousTypeMemberNameCodeFixProvider : AbstractAddAnonymousTypeMemberNameCodeFixProvider`3<ExpressionSyntax, AnonymousObjectCreationExpressionSyntax, AnonymousObjectMemberDeclaratorSyntax> {
    private static string CS0746;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool HasName(AnonymousObjectMemberDeclaratorSyntax declarator);
    protected virtual ExpressionSyntax GetExpression(AnonymousObjectMemberDeclaratorSyntax declarator);
    protected virtual AnonymousObjectMemberDeclaratorSyntax WithName(AnonymousObjectMemberDeclaratorSyntax declarator, SyntaxToken name);
    protected virtual IEnumerable`1<string> GetAnonymousObjectMemberNames(AnonymousObjectCreationExpressionSyntax initializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddDebuggerDisplay.CSharpAddDebuggerDisplayCodeRefactoringProvider : AbstractAddDebuggerDisplayCodeRefactoringProvider`2<TypeDeclarationSyntax, MethodDeclarationSyntax> {
    protected bool CanNameofAccessNonPublicMembersFromAttributeArgument { get; }
    protected virtual bool get_CanNameofAccessNonPublicMembersFromAttributeArgument();
    protected virtual bool SupportsConstantInterpolatedStrings(Document document);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddFileBanner.CSharpAddFileBannerCodeRefactoringProvider : AbstractAddFileBannerCodeRefactoringProvider {
    protected virtual bool IsCommentStartCharacter(char ch);
    [NullableContextAttribute("1")]
protected virtual SyntaxTrivia CreateTrivia(SyntaxTrivia trivia, string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportNewDocumentFormattingProviderAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddFileBanner.CSharpAddFileBannerNewDocumentFormattingProvider : AbstractAddFileBannerNewDocumentFormattingProvider {
    protected SyntaxGenerator SyntaxGenerator { get; }
    protected SyntaxGeneratorInternal SyntaxGeneratorInternal { get; }
    protected AbstractFileHeaderHelper FileHeaderHelper { get; }
    protected virtual SyntaxGenerator get_SyntaxGenerator();
    protected virtual SyntaxGeneratorInternal get_SyntaxGeneratorInternal();
    protected virtual AbstractFileHeaderHelper get_FileHeaderHelper();
}
internal static class Microsoft.CodeAnalysis.CSharp.AddImport.AddImportDiagnosticIds : object {
    public static string CS0103;
    public static string CS0246;
    public static string CS0305;
    public static string CS1061;
    public static string CS1935;
    public static string CS0308;
    public static string CS0122;
    public static string CS0307;
    public static string CS0616;
    public static string CS1501;
    public static string CS1503;
    public static string CS1574;
    public static string CS1580;
    public static string CS1581;
    public static string CS1584;
    public static string CS1929;
    public static string CS1955;
    public static string CS0428;
    public static string CS7036;
    public static string CS8129;
    public static string CS0281;
    public static string CS4036;
    public static string CS1579;
    public static string CS8414;
    public static string CS8411;
    public static string CS8415;
    public static ImmutableArray`1<string> FixableTypeIds;
    public static ImmutableArray`1<string> FixableDiagnosticIds;
    private static AddImportDiagnosticIds();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddImport.CSharpAddImportCodeFixProvider : AbstractAddImportCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CSharpAddImportCodeFixProvider(IPackageInstallerService installerService, ISymbolSearchService symbolSearchService);
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.AddImport.IAddImportFeatureService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddImport.CSharpAddImportFeatureService : AbstractAddImportFeatureService`1<SimpleNameSyntax> {
    protected virtual bool CanAddImport(SyntaxNode node, bool allowInHiddenRegions, CancellationToken cancellationToken);
    protected virtual bool CanAddImportForMethod(string diagnosticId, ISyntaxFacts syntaxFacts, SyntaxNode node, SimpleNameSyntax& nameNode);
    protected virtual bool CanAddImportForDeconstruct(string diagnosticId, SyntaxNode node);
    protected virtual bool CanAddImportForGetAwaiter(string diagnosticId, ISyntaxFacts syntaxFactsService, SyntaxNode node);
    protected virtual bool CanAddImportForGetEnumerator(string diagnosticId, ISyntaxFacts syntaxFactsService, SyntaxNode node);
    protected virtual bool CanAddImportForGetAsyncEnumerator(string diagnosticId, ISyntaxFacts syntaxFactsService, SyntaxNode node);
    protected virtual bool CanAddImportForNamespace(string diagnosticId, SyntaxNode node, SimpleNameSyntax& nameNode);
    protected virtual bool CanAddImportForQuery(string diagnosticId, SyntaxNode node);
    protected virtual bool CanAddImportForType(string diagnosticId, SyntaxNode node, SimpleNameSyntax& nameNode);
    private static bool TryFindStandaloneType(SyntaxNode node, SimpleNameSyntax& nameNode);
    private static SimpleNameSyntax GetLeftMostSimpleName(QualifiedNameSyntax qn);
    protected virtual ISet`1<INamespaceSymbol> GetImportNamespacesInScope(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual ITypeSymbol GetDeconstructInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual ITypeSymbol GetQueryClauseInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    private static bool InfoBoundSuccessfully(SymbolInfo symbolInfo);
    private static bool InfoBoundSuccessfully(QueryClauseInfo semanticInfo);
    private static bool InfoBoundSuccessfully(ISymbol operation);
    protected virtual string GetDescription(IReadOnlyList`1<string> nameParts);
    protected virtual ValueTuple`2<string, bool> GetDescription(Document document, AddImportPlacementOptions options, INamespaceOrTypeSymbol namespaceOrTypeSymbol, SemanticModel semanticModel, SyntaxNode contextNode, CancellationToken cancellationToken);
    private static string GetUsingDirectiveString(INamespaceOrTypeSymbol namespaceOrTypeSymbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.AddImport.CSharpAddImportFeatureService/<AddImportAsync>d__21")]
protected virtual Task`1<Document> AddImportAsync(SyntaxNode contextNode, INamespaceOrTypeSymbol namespaceOrTypeSymbol, Document document, AddImportPlacementOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.AddImport.CSharpAddImportFeatureService/<AddImportWorkerAsync>d__22")]
private static Task`1<CompilationUnitSyntax> AddImportWorkerAsync(Document document, CompilationUnitSyntax root, SyntaxNode contextNode, INamespaceOrTypeSymbol namespaceOrTypeSymbol, AddImportPlacementOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.AddImport.CSharpAddImportFeatureService/<AddImportAsync>d__23")]
protected virtual Task`1<Document> AddImportAsync(SyntaxNode contextNode, IReadOnlyList`1<string> namespaceParts, Document document, AddImportPlacementOptions options, CancellationToken cancellationToken);
    private static NameSyntax CreateNameSyntax(IReadOnlyList`1<string> namespaceParts, int index);
    private static ValueTuple`2<ExternAliasDirectiveSyntax, bool> GetExternAliasDirective(INamespaceOrTypeSymbol namespaceSymbol, SemanticModel semanticModel, SyntaxNode contextNode);
    private static ValueTuple`2<UsingDirectiveSyntax, bool> GetUsingDirective(Document document, AddImportPlacementOptions options, INamespaceOrTypeSymbol namespaceOrTypeSymbol, SemanticModel semanticModel, CompilationUnitSyntax root, SyntaxNode contextNode);
    private static NameSyntax RemoveGlobalAliasIfUnnecessary(SemanticModel semanticModel, NameSyntax nameSyntax, BaseNamespaceDeclarationSyntax namespaceToAddTo);
    private static bool ConflictsWithExistingMember(SemanticModel semanticModel, BaseNamespaceDeclarationSyntax namespaceToAddTo, string rightOfAliasName);
    private static NameSyntax AddOrReplaceAlias(NameSyntax nameSyntax, IdentifierNameSyntax alias);
    private static ValueTuple`2<string, bool> GetExternAliasString(INamespaceOrTypeSymbol namespaceSymbol, SemanticModel semanticModel, SyntaxNode contextNode);
    private static bool HasExistingExternAlias(string alias, SyntaxNode contextNode);
    private static CompilationUnitSyntax GetCompilationUnitSyntaxNode(SyntaxNode contextNode, CancellationToken cancellationToken);
    protected virtual bool IsViableExtensionMethod(IMethodSymbol method, SyntaxNode expression, SemanticModel semanticModel, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
    protected virtual bool IsAddMethodContext(SyntaxNode node, SemanticModel semanticModel);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.AddMissingImports.IAddMissingImportsFeatureService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddMissingImports.CSharpAddMissingImportsFeatureService : AbstractAddMissingImportsFeatureService {
    protected ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual ImmutableArray`1<AbstractFormattingRule> GetFormatRules(SourceText text);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddMissingReference.CSharpAddMissingReferenceCodeFixProvider : AbstractAddMissingReferenceCodeFixProvider {
    private static string CS0012;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CSharpAddMissingReferenceCodeFixProvider(IPackageInstallerService installerService, ISymbolSearchService symbolSearchService);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddObsoleteAttribute.CSharpAddObsoleteAttributeCodeFixProvider : AbstractAddObsoleteAttributeCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddPackage.CSharpAddSpecificPackageCodeFixProvider : AbstractAddSpecificPackageCodeFixProvider {
    private static string CS8179;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual string GetAssemblyName(string id);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AddParameter.CSharpAddParameterCodeFixProvider : AbstractAddParameterCodeFixProvider`6<ArgumentSyntax, AttributeArgumentSyntax, ArgumentListSyntax, AttributeArgumentListSyntax, InvocationExpressionSyntax, BaseObjectCreationExpressionSyntax> {
    private static string CS1501;
    private static string CS1503;
    private static string CS1660;
    private static string CS1729;
    private static string CS1739;
    private static ImmutableArray`1<string> AddParameterFixableDiagnosticIds;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected ImmutableArray`1<string> TooManyArgumentsDiagnosticIds { get; }
    protected ImmutableArray`1<string> CannotConvertDiagnosticIds { get; }
    private static CSharpAddParameterCodeFixProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual ImmutableArray`1<string> get_TooManyArgumentsDiagnosticIds();
    protected virtual ImmutableArray`1<string> get_CannotConvertDiagnosticIds();
    protected virtual ITypeSymbol GetArgumentType(SyntaxNode argumentNode, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual RegisterFixData`1<ArgumentSyntax> TryGetLanguageSpecificFixInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.AddRequiredParentheses.CSharpAddRequiredExpressionParenthesesDiagnosticAnalyzer : AbstractAddRequiredParenthesesDiagnosticAnalyzer`3<ExpressionSyntax, ExpressionSyntax, SyntaxKind> {
    [NullableAttribute("0")]
private static ImmutableArray`1<SyntaxKind> s_kinds;
    private static CSharpAddRequiredExpressionParenthesesDiagnosticAnalyzer();
    [NullableContextAttribute("0")]
protected virtual ImmutableArray`1<SyntaxKind> GetSyntaxNodeKinds();
    protected virtual int GetPrecedence(ExpressionSyntax binaryLike);
    protected virtual bool IsBinaryLike(ExpressionSyntax node);
    protected virtual ValueTuple`3<ExpressionSyntax, SyntaxToken, ExpressionSyntax> GetPartsOfBinaryLike(ExpressionSyntax binaryLike);
    protected virtual ExpressionSyntax TryGetAppropriateParent(ExpressionSyntax binaryLike);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.AddRequiredParentheses.CSharpAddRequiredPatternParenthesesDiagnosticAnalyzer : AbstractAddRequiredParenthesesDiagnosticAnalyzer`3<PatternSyntax, BinaryPatternSyntax, SyntaxKind> {
    [NullableAttribute("0")]
private static ImmutableArray`1<SyntaxKind> s_kinds;
    private static CSharpAddRequiredPatternParenthesesDiagnosticAnalyzer();
    [NullableContextAttribute("0")]
protected virtual ImmutableArray`1<SyntaxKind> GetSyntaxNodeKinds();
    protected virtual int GetPrecedence(BinaryPatternSyntax pattern);
    protected virtual bool IsBinaryLike(PatternSyntax node);
    protected virtual ValueTuple`3<PatternSyntax, SyntaxToken, PatternSyntax> GetPartsOfBinaryLike(BinaryPatternSyntax binaryPattern);
    protected virtual PatternSyntax TryGetAppropriateParent(BinaryPatternSyntax binaryLike);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AliasAmbiguousType.CSharpAliasAmbiguousTypeCodeFixProvider : AbstractAliasAmbiguousTypeCodeFixProvider {
    private static string CS0104;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual string GetTextPreviewOfChange(string alias, ITypeSymbol typeSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Analyzers.ConvertProgram.ConvertProgramAnalysis : object {
    public static bool CanOfferUseTopLevelStatements(CodeStyleOption2`1<bool> option, bool forAnalyzer);
    public static Location GetUseTopLevelStatementsDiagnosticLocation(MethodDeclarationSyntax methodDeclaration, bool isHidden);
    public static string GetMainTypeName(Compilation compilation);
    public static bool IsProgramMainMethod(SemanticModel semanticModel, MethodDeclarationSyntax methodDeclaration, string mainTypeName, CancellationToken cancellationToken, Boolean& canConvertToTopLevelStatements);
    private static bool TypeCanBeConverted(INamedTypeSymbol containingType, TypeDeclarationSyntax typeDeclaration);
    public static bool IsApplication(Compilation compilation);
    public static bool IsApplication(CompilationOptions options);
    public static bool CanOfferUseProgramMain(CodeStyleOption2`1<bool> option, CompilationUnitSyntax root, Compilation compilation, bool forAnalyzer);
    private static bool CanOfferUseProgramMain(CodeStyleOption2`1<bool> option, bool forAnalyzer);
    public static Location GetUseProgramMainDiagnosticLocation(CompilationUnitSyntax root, bool isHidden);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Analyzers.ForEachCast.CSharpForEachCastDiagnosticAnalyzer : AbstractForEachCastDiagnosticAnalyzer`2<SyntaxKind, CommonForEachStatementSyntax> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
    [NullableContextAttribute("0")]
protected virtual ImmutableArray`1<SyntaxKind> GetSyntaxKinds();
    protected virtual ValueTuple`2<CommonConversion, ITypeSymbol> GetForEachInfo(SemanticModel semanticModel, CommonForEachStatementSyntax node);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Analyzers.MakeFieldReadonly.CSharpMakeFieldReadonlyDiagnosticAnalyzer : AbstractMakeFieldReadonlyDiagnosticAnalyzer`2<SyntaxKind, ThisExpressionSyntax> {
    protected ISyntaxKinds SyntaxKinds { get; }
    protected virtual ISyntaxKinds get_SyntaxKinds();
    protected virtual bool IsWrittenTo(SemanticModel semanticModel, ThisExpressionSyntax expression, CancellationToken cancellationToken);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportAttribute("Microsoft.CodeAnalysis.CSharp.Analyzers.MatchFolderAndNamespace.CSharpMatchFolderAndNamespaceDiagnosticAnalyzer")]
[SharedAttribute]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Analyzers.MatchFolderAndNamespace.CSharpMatchFolderAndNamespaceDiagnosticAnalyzer : AbstractMatchFolderAndNamespaceDiagnosticAnalyzer`2<SyntaxKind, BaseNamespaceDeclarationSyntax> {
    [NullableContextAttribute("1")]
protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual ImmutableArray`1<SyntaxKind> GetSyntaxKindsToAnalyze();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Analyzers.RemoveUnnecessaryNullableDirective.CSharpRemoveRedundantNullableDirectiveDiagnosticAnalyzer : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    internal static Nullable`1<NullableContextOptions> GetNullableContextOptions(NullableContextOptions compilationOptions, Nullable`1<NullableContextOptions> options, NullableDirectiveTriviaSyntax directive);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Analyzers.RemoveUnnecessaryNullableDirective.NullableImpactingSpanWalker : CSharpSyntaxWalker {
    private SemanticModel _semanticModel;
    private int _positionOfFirstReducingNullableDirective;
    [NullableAttribute("2")]
private TextSpanIntervalTree _ignoredSpans;
    private CancellationToken _cancellationToken;
    [NullableAttribute("2")]
private Builder<TextSpan> _spans;
    public bool HasSpans { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<TextSpan> Spans { get; }
    public Builder<TextSpan> SpansBuilder { get; }
    public NullableImpactingSpanWalker(SemanticModel semanticModel, int positionOfFirstReducingNullableDirective, TextSpanIntervalTree ignoredSpans, CancellationToken cancellationToken);
    public bool get_HasSpans();
    [NullableContextAttribute("0")]
public ImmutableArray`1<TextSpan> get_Spans();
    public Builder<TextSpan> get_SpansBuilder();
    private bool IsIgnored(SyntaxNode node);
    private static bool IsLanguageRestrictedToNonNullForm(TypeSyntax node);
    public sealed virtual void Dispose();
    public virtual void DefaultVisit(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static TypeSyntax <IsLanguageRestrictedToNonNullForm>g__WalkUpCurrentQualifiedName|13_0(TypeSyntax node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Analyzers.SimplifyInterpolation.CSharpSimplifyInterpolationHelpers : AbstractSimplifyInterpolationHelpers {
    [CompilerGeneratedAttribute]
private static CSharpSimplifyInterpolationHelpers <Instance>k__BackingField;
    public static CSharpSimplifyInterpolationHelpers Instance { get; }
    protected bool PermitNonLiteralAlignmentComponents { get; }
    private static CSharpSimplifyInterpolationHelpers();
    [CompilerGeneratedAttribute]
public static CSharpSimplifyInterpolationHelpers get_Instance();
    protected virtual bool get_PermitNonLiteralAlignmentComponents();
    protected virtual SyntaxNode GetPreservedInterpolationExpressionSyntax(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Analyzers.UseCoalesceExpression.CSharpUseCoalesceExpressionForIfNullStatementCheckDiagnosticAnalyzer : AbstractUseCoalesceExpressionForIfNullStatementCheckDiagnosticAnalyzer`5<SyntaxKind, ExpressionSyntax, StatementSyntax, VariableDeclaratorSyntax, IfStatementSyntax> {
    protected SyntaxKind IfStatementKind { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual SyntaxKind get_IfStatementKind();
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual bool IsSingle(VariableDeclaratorSyntax declarator);
    protected virtual SyntaxNode GetDeclarationNode(VariableDeclaratorSyntax declarator);
    protected virtual ExpressionSyntax GetConditionOfIfStatement(IfStatementSyntax ifStatement);
    protected virtual bool IsNullCheck(ExpressionSyntax condition, ExpressionSyntax& checkedExpression);
    protected virtual bool TryGetEmbeddedStatement(IfStatementSyntax ifStatement, StatementSyntax& whenTrueStatement);
    protected virtual bool HasElseBlock(IfStatementSyntax ifStatement);
    protected virtual StatementSyntax TryGetPreviousStatement(IfStatementSyntax ifStatement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.AssignOutParameters.AbstractAssignOutParametersCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string CS0177;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.AssignOutParameters.AbstractAssignOutParametersCodeFixProvider/<RegisterCodeFixesAsync>d__4")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected abstract virtual void TryRegisterFix(CodeFixContext context, Document document, SyntaxNode container, SyntaxNode location);
    private static ValueTuple`2<SyntaxNode, SyntaxNode> GetContainer(SyntaxNode root, TextSpan span);
    private static bool IsValidLocation(SyntaxNode location);
    private static SyntaxNode GetContainer(SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.AssignOutParameters.AbstractAssignOutParametersCodeFixProvider/<GetUnassignedParametersAsync>d__9")]
private static Task`1<MultiDictionary`2<SyntaxNode, ValueTuple`2<SyntaxNode, ImmutableArray`1<IParameterSymbol>>>> GetUnassignedParametersAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.AssignOutParameters.AbstractAssignOutParametersCodeFixProvider/<FixAllAsync>d__10")]
protected sealed virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected abstract virtual void AssignOutParameters(SyntaxEditor editor, SyntaxNode container, ValueSet<SyntaxNode, ValueTuple`2<SyntaxNode, ImmutableArray`1<IParameterSymbol>>> values, CancellationToken cancellationToken);
    protected static ImmutableArray`1<SyntaxNode> GenerateAssignmentStatements(SyntaxGenerator generator, ImmutableArray`1<IParameterSymbol> unassignedParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AssignOutParameters.AssignOutParametersAboveReturnCodeFixProvider : AbstractAssignOutParametersCodeFixProvider {
    protected virtual void TryRegisterFix(CodeFixContext context, Document document, SyntaxNode container, SyntaxNode location);
    protected virtual void AssignOutParameters(SyntaxEditor editor, SyntaxNode container, ValueSet<SyntaxNode, ValueTuple`2<SyntaxNode, ImmutableArray`1<IParameterSymbol>>> values, CancellationToken cancellationToken);
    private static void AddAssignmentStatements(SyntaxEditor editor, SyntaxNode exprOrStatement, ImmutableArray`1<SyntaxNode> statements);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.AssignOutParameters.AssignOutParametersAtStartCodeFixProvider : AbstractAssignOutParametersCodeFixProvider {
    protected virtual void TryRegisterFix(CodeFixContext context, Document document, SyntaxNode container, SyntaxNode location);
    protected virtual void AssignOutParameters(SyntaxEditor editor, SyntaxNode container, ValueSet<SyntaxNode, ValueTuple`2<SyntaxNode, ImmutableArray`1<IParameterSymbol>>> values, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.BraceCompletion.AbstractCSharpBraceCompletionService : AbstractBraceCompletionService {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.BraceCompletion.AbstractCurlyBraceOrBracketCompletionService : AbstractCSharpBraceCompletionService {
    private static SyntaxAnnotation s_closingBraceFormatAnnotation;
    private static SyntaxAnnotation s_closingBraceNewlineAnnotation;
    private static AbstractCurlyBraceOrBracketCompletionService();
    protected abstract virtual ImmutableArray`1<AbstractFormattingRule> GetBraceFormattingIndentationRulesAfterReturn(IndentationOptions options);
    protected abstract virtual int AdjustFormattingEndPoint(ParsedDocument document, int startPoint, int endPoint);
    public sealed virtual Nullable`1<BraceCompletionResult> GetTextChangesAfterCompletion(BraceCompletionContext context, IndentationOptions options, CancellationToken cancellationToken);
    private static bool ContainsOnlyWhitespace(SourceText text, int openingPosition, int closingBraceEndPoint);
    public sealed virtual Nullable`1<BraceCompletionResult> GetTextChangeAfterReturn(BraceCompletionContext context, IndentationOptions options, CancellationToken cancellationToken);
    private ValueTuple`3<SyntaxNode, ImmutableArray`1<TextChange>, int> FormatTrackingSpan(ParsedDocument document, int openingPoint, int closingPoint, ImmutableArray`1<AbstractFormattingRule> braceFormattingIndentationRules, IndentationOptions options, CancellationToken cancellationToken);
    private SyntaxToken FindClosingBraceToken(SyntaxNode root, int closingBraceEndPoint);
    [CompilerGeneratedAttribute]
internal static TextLine <GetTextChangeAfterReturn>g__GetLineBetweenCurlys|6_0(int closingPosition, SourceText text);
    [CompilerGeneratedAttribute]
internal static LinePosition <GetTextChangeAfterReturn>g__GetIndentedLinePosition|6_1(ParsedDocument document, SourceText sourceText, int lineNumber, IndentationOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static ImmutableArray`1<TextChange> <GetTextChangeAfterReturn>g__GetMergedChanges|6_2(Nullable`1<TextChange> newLineEdit, ImmutableArray`1<TextChange> formattingChanges, SourceText formattedText);
    [CompilerGeneratedAttribute]
private SyntaxNode <FormatTrackingSpan>g__GetSyntaxRootWithAnnotatedClosingBrace|7_0(SyntaxNode originalRoot, int closingBraceEndPoint);
}
[ExportAttribute("C#", "Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceCompletion.BracketBraceCompletionService : AbstractCurlyBraceOrBracketCompletionService {
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    protected virtual char get_OpeningBrace();
    protected virtual char get_ClosingBrace();
    public virtual bool AllowOverType(BraceCompletionContext context, CancellationToken cancellationToken);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
    protected virtual int AdjustFormattingEndPoint(ParsedDocument document, int startPoint, int endPoint);
    protected virtual ImmutableArray`1<AbstractFormattingRule> GetBraceFormattingIndentationRulesAfterReturn(IndentationOptions options);
}
[ExportAttribute("C#", "Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceCompletion.CharLiteralBraceCompletionService : AbstractCSharpBraceCompletionService {
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    protected virtual char get_OpeningBrace();
    protected virtual char get_ClosingBrace();
    public virtual bool AllowOverType(BraceCompletionContext braceCompletionContext, CancellationToken cancellationToken);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
}
[ExportAttribute("C#", "Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceCompletion.CurlyBraceCompletionService : AbstractCurlyBraceOrBracketCompletionService {
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    protected virtual char get_OpeningBrace();
    protected virtual char get_ClosingBrace();
    public virtual bool AllowOverType(BraceCompletionContext context, CancellationToken cancellationToken);
    public virtual bool CanProvideBraceCompletion(char brace, int openingPosition, ParsedDocument document, CancellationToken cancellationToken);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
    protected virtual int AdjustFormattingEndPoint(ParsedDocument document, int startPoint, int endPoint);
    protected virtual ImmutableArray`1<AbstractFormattingRule> GetBraceFormattingIndentationRulesAfterReturn(IndentationOptions options);
}
[ExportAttribute("C#", "Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceCompletion.InterpolatedStringBraceCompletionService : AbstractCSharpBraceCompletionService {
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    protected virtual char get_OpeningBrace();
    protected virtual char get_ClosingBrace();
    public virtual bool AllowOverType(BraceCompletionContext context, CancellationToken cancellationToken);
    public virtual bool CanProvideBraceCompletion(char brace, int openingPosition, ParsedDocument document, CancellationToken cancellationToken);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken leftToken);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken rightToken);
    [NullableContextAttribute("1")]
protected virtual bool IsValidOpenBraceTokenAtPosition(SourceText text, SyntaxToken token, int position);
    public static bool IsPositionInInterpolatedStringContext(ParsedDocument document, int position, CancellationToken cancellationToken);
}
[ExportAttribute("C#", "Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceCompletion.InterpolationBraceCompletionService : AbstractCSharpBraceCompletionService {
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    protected virtual char get_OpeningBrace();
    protected virtual char get_ClosingBrace();
    public virtual bool AllowOverType(BraceCompletionContext context, CancellationToken cancellationToken);
    public virtual bool CanProvideBraceCompletion(char brace, int openingPosition, ParsedDocument document, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
protected virtual bool IsValidOpenBraceTokenAtPosition(SourceText text, SyntaxToken token, int position);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
    public static bool IsPositionInInterpolationContext(ParsedDocument document, int position);
}
[ExportAttribute("C#", "Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceCompletion.LessAndGreaterThanBraceCompletionService : AbstractCSharpBraceCompletionService {
    protected bool NeedsSemantics { get; }
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    protected virtual bool get_NeedsSemantics();
    protected virtual char get_OpeningBrace();
    protected virtual char get_ClosingBrace();
    public virtual bool AllowOverType(BraceCompletionContext context, CancellationToken cancellationToken);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
    [NullableContextAttribute("1")]
protected virtual Task`1<bool> IsValidOpenBraceTokenAtPositionAsync(Document document, SyntaxToken token, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.BraceCompletion.LessAndGreaterThanBraceCompletionService/<<IsValidOpenBraceTokenAtPositionAsync>g__IsSemanticTypeArgumentAsync|10_3>d")]
[CompilerGeneratedAttribute]
internal static Task`1<bool> <IsValidOpenBraceTokenAtPositionAsync>g__IsSemanticTypeArgumentAsync|10_3(Document document, int position, IdentifierNameSyntax identifier, CancellationToken cancellationToken);
}
[ExportAttribute("C#", "Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceCompletion.ParenthesisBraceCompletionService : AbstractCSharpBraceCompletionService {
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    protected virtual char get_OpeningBrace();
    protected virtual char get_ClosingBrace();
    public virtual bool AllowOverType(BraceCompletionContext context, CancellationToken cancellationToken);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
    [NullableContextAttribute("1")]
protected virtual bool IsValidOpenBraceTokenAtPosition(SourceText text, SyntaxToken token, int position);
}
[ExportAttribute("C#", "Microsoft.CodeAnalysis.BraceCompletion.IBraceCompletionService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceCompletion.StringLiteralBraceCompletionService : AbstractCSharpBraceCompletionService {
    protected char OpeningBrace { get; }
    protected char ClosingBrace { get; }
    protected virtual char get_OpeningBrace();
    protected virtual char get_ClosingBrace();
    public virtual bool AllowOverType(BraceCompletionContext context, CancellationToken cancellationToken);
    public virtual bool CanProvideBraceCompletion(char brace, int openingPosition, ParsedDocument document, CancellationToken cancellationToken);
    protected virtual bool IsValidOpeningBraceToken(SyntaxToken token);
    protected virtual bool IsValidClosingBraceToken(SyntaxToken token);
    [NullableContextAttribute("1")]
protected virtual bool IsValidOpenBraceTokenAtPosition(SourceText text, SyntaxToken token, int position);
    private static bool RestOfLineContainsDiagnostics(SyntaxToken token);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.BraceMatching.AbstractCSharpBraceMatcher : AbstractBraceMatcher {
    protected AbstractCSharpBraceMatcher(SyntaxKind openBrace, SyntaxKind closeBrace);
}
[ExportBraceMatcherAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceMatching.BlockCommentBraceMatcher : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.BraceMatching.BlockCommentBraceMatcher/<FindBracesAsync>d__1")]
public sealed virtual Task`1<Nullable`1<BraceMatchingResult>> FindBracesAsync(Document document, int position, BraceMatchingOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportBraceMatcherAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceMatching.CSharpDirectiveTriviaBraceMatcher : AbstractDirectiveTriviaBraceMatcher`7<DirectiveTriviaSyntax, IfDirectiveTriviaSyntax, ElifDirectiveTriviaSyntax, ElseDirectiveTriviaSyntax, EndIfDirectiveTriviaSyntax, RegionDirectiveTriviaSyntax, EndRegionDirectiveTriviaSyntax> {
    protected virtual ImmutableArray`1<DirectiveTriviaSyntax> GetMatchingConditionalDirectives(DirectiveTriviaSyntax directive, CancellationToken cancellationToken);
    protected virtual DirectiveTriviaSyntax GetMatchingDirective(DirectiveTriviaSyntax directive, CancellationToken cancellationToken);
    internal virtual TextSpan GetSpanForTagging(DirectiveTriviaSyntax directive);
}
[ExportBraceMatcherAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceMatching.CSharpEmbeddedLanguageBraceMatcher : AbstractEmbeddedLanguageBraceMatcher {
    [NullableContextAttribute("1")]
[ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public CSharpEmbeddedLanguageBraceMatcher(IEnumerable`1<Lazy`2<IEmbeddedLanguageBraceMatcher, EmbeddedLanguageMetadata>> services);
}
[ExportBraceMatcherAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceMatching.LessThanGreaterThanBraceMatcher : AbstractCSharpBraceMatcher {
}
[ExportBraceMatcherAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceMatching.OpenCloseBraceBraceMatcher : AbstractCSharpBraceMatcher {
}
[ExportBraceMatcherAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceMatching.OpenCloseBracketBraceMatcher : AbstractCSharpBraceMatcher {
}
[ExportBraceMatcherAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceMatching.OpenCloseParenBraceMatcher : AbstractCSharpBraceMatcher {
}
[ExportBraceMatcherAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BraceMatching.StringLiteralBraceMatcher : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.BraceMatching.StringLiteralBraceMatcher/<FindBracesAsync>d__1")]
public sealed virtual Task`1<Nullable`1<BraceMatchingResult>> FindBracesAsync(Document document, int position, BraceMatchingOptions options, CancellationToken cancellationToken);
    private static BraceMatchingResult GetSimpleStringBraceMatchingResult(SyntaxToken token, int endTokenLength);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.BracePairs.IBracePairsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.BracePairs.CSharpBracePairsService : AbstractBracePairsService {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ChangeNamespace.IChangeNamespaceService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ChangeNamespace.CSharpChangeNamespaceService : AbstractChangeNamespaceService`3<BaseNamespaceDeclarationSyntax, CompilationUnitSyntax, MemberDeclarationSyntax> {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ChangeNamespace.CSharpChangeNamespaceService/<GetValidContainersFromAllLinkedDocumentsAsync>d__1")]
protected virtual Task`1<ImmutableArray`1<ValueTuple`2<DocumentId, SyntaxNode>>> GetValidContainersFromAllLinkedDocumentsAsync(Document document, SyntaxNode container, CancellationToken cancellationToken);
    protected virtual string GetDeclaredNamespace(SyntaxNode container);
    protected virtual SyntaxList`1<MemberDeclarationSyntax> GetMemberDeclarationsInContainer(SyntaxNode container);
    public virtual bool TryGetReplacementReferenceSyntax(SyntaxNode reference, ImmutableArray`1<string> newNamespaceParts, ISyntaxFactsService syntaxFacts, SyntaxNode& oldNode, SyntaxNode& newNode);
    [NullableContextAttribute("2")]
private static bool TryGetGlobalQualifiedName(ImmutableArray`1<string> newNamespaceParts, SimpleNameSyntax nameNode, string aliasQualifier, SyntaxNode& newNode);
    protected virtual CompilationUnitSyntax ChangeNamespaceDeclaration(CompilationUnitSyntax root, ImmutableArray`1<string> declaredNamespaceParts, ImmutableArray`1<string> targetNamespaceParts);
    private static CompilationUnitSyntax MoveMembersFromNamespaceToGlobal(CompilationUnitSyntax root, BaseNamespaceDeclarationSyntax namespaceDecl);
    private static CompilationUnitSyntax MoveMembersFromGlobalToNamespace(CompilationUnitSyntax compilationUnit, ImmutableArray`1<string> targetNamespaceParts);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ChangeNamespace.CSharpChangeNamespaceService/<TryGetApplicableContainerFromSpanAsync>d__9")]
protected virtual Task`1<SyntaxNode> TryGetApplicableContainerFromSpanAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static string GetAliasQualifier(SyntaxNode name);
    private static NameSyntax CreateNamespaceAsQualifiedName(ImmutableArray`1<string> namespaceParts, string aliasQualifier, int index);
    private static ExpressionSyntax CreateNamespaceAsMemberAccess(ImmutableArray`1<string> namespaceParts, string aliasQualifier, int index);
    [NullableContextAttribute("0")]
private static ValueTuple`2<ImmutableArray`1<SyntaxTrivia>, ImmutableArray`1<SyntaxTrivia>> GetOpeningAndClosingTriviaOfNamespaceDeclaration(BaseNamespaceDeclarationSyntax baseNamespace);
    [CompilerGeneratedAttribute]
internal static bool <TryGetApplicableContainerFromSpanAsync>g__ContainsNamespaceDeclaration|9_0(SyntaxNode node);
}
internal class Microsoft.CodeAnalysis.CSharp.ChangeSignature.ChangeSignatureFormattingRule : BaseFormattingRule {
    private static ImmutableArray`1<SyntaxKind> s_allowableKinds;
    private static ChangeSignatureFormattingRule();
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static void AddChangeSignatureIndentOperation(List`1<IndentBlockOperation> list, SyntaxNode node);
    public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ChangeSignature.AbstractChangeSignatureService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ChangeSignature.CSharpChangeSignatureService : AbstractChangeSignatureService {
    [NullableAttribute("0")]
private static ImmutableArray`1<SyntaxKind> _declarationKinds;
    [NullableAttribute("0")]
private static ImmutableArray`1<SyntaxKind> _declarationAndInvocableKinds;
    [NullableAttribute("0")]
private static ImmutableArray`1<SyntaxKind> _updatableAncestorKinds;
    [NullableAttribute("0")]
private static ImmutableArray`1<SyntaxKind> _updatableNodeKinds;
    protected SyntaxGenerator Generator { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    private static CSharpChangeSignatureService();
    protected virtual SyntaxGenerator get_Generator();
    protected virtual ISyntaxFacts get_SyntaxFacts();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ChangeSignature.CSharpChangeSignatureService/<GetInvocationSymbolAsync>d__9")]
public virtual Task`1<ValueTuple`2<ISymbol, int>> GetInvocationSymbolAsync(Document document, int position, bool restrictToDeclarations, CancellationToken cancellationToken);
    private static int TryGetSelectedIndexFromDeclaration(int position, SyntaxNode matchingNode);
    private static SyntaxNode GetMatchingNode(SyntaxNode node, bool restrictToDeclarations);
    private static bool InSymbolHeader(SyntaxNode matchingNode, int position);
    public virtual SyntaxNode FindNodeToUpdate(Document document, SyntaxNode node);
    private static SyntaxNode GetNodeContainingTargetNode(SyntaxNode matchingNode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ChangeSignature.CSharpChangeSignatureService/<ChangeSignatureAsync>d__15")]
public virtual Task`1<SyntaxNode> ChangeSignatureAsync(Document document, ISymbol declarationSymbol, SyntaxNode potentiallyUpdatedNode, SyntaxNode originalNode, SignatureChange signaturePermutation, LineFormattingOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ChangeSignature.CSharpChangeSignatureService/<UpdateArgumentListAsync>d__16`1")]
private Task`1<T> UpdateArgumentListAsync(ISymbol declarationSymbol, SignatureChange signaturePermutation, T argumentList, bool isReducedExtensionMethod, bool isParamsArrayExpanded, Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ChangeSignature.CSharpChangeSignatureService/<UpdateAttributeArgumentListAsync>d__17")]
private Task`1<AttributeArgumentListSyntax> UpdateAttributeArgumentListAsync(ISymbol declarationSymbol, SignatureChange signaturePermutation, AttributeArgumentListSyntax argumentList, bool isReducedExtensionMethod, bool isParamsArrayExpanded, Document document, int position, CancellationToken cancellationToken);
    private static bool IsParamsArrayExpanded(SemanticModel semanticModel, SyntaxNode node, SymbolInfo symbolInfo, CancellationToken cancellationToken);
    private static ParameterSyntax CreateNewParameterSyntax(AddedParameter addedParameter);
    private static ParameterSyntax CreateNewParameterSyntax(AddedParameter addedParameter, bool skipParameterType);
    private static CrefParameterSyntax CreateNewCrefParameterSyntax(AddedParameter addedParameter);
    private SeparatedSyntaxList`1<T> UpdateDeclaration(SeparatedSyntaxList`1<T> list, SignatureChange updatedSignature, Func`2<AddedParameter, T> createNewParameterMethod);
    protected virtual T TransferLeadingWhitespaceTrivia(T newArgument, SyntaxNode oldArgument);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ChangeSignature.CSharpChangeSignatureService/<AddNewArgumentsToListAsync>d__24`1")]
private Task`1<SeparatedSyntaxList`1<TArgumentSyntax>> AddNewArgumentsToListAsync(ISymbol declarationSymbol, SeparatedSyntaxList`1<TArgumentSyntax> newArguments, SeparatedSyntaxList`1<TArgumentSyntax> originalArguments, SignatureChange signaturePermutation, bool isReducedExtensionMethod, bool isParamsArrayExpanded, bool generateAttributeArguments, Document document, int position, CancellationToken cancellationToken);
    private SeparatedSyntaxList`1<AttributeArgumentSyntax> PermuteAttributeArgumentList(ISymbol declarationSymbol, SeparatedSyntaxList`1<AttributeArgumentSyntax> arguments, SignatureChange updatedSignature);
    private SeparatedSyntaxList`1<ArgumentSyntax> PermuteArgumentList(ISymbol declarationSymbol, SeparatedSyntaxList`1<ArgumentSyntax> arguments, SignatureChange updatedSignature, bool isReducedExtensionMethod);
    private ImmutableArray`1<T> TransferLeadingWhitespaceTrivia(IEnumerable`1<T> newArguments, SeparatedSyntaxList`1<U> oldArguments);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ChangeSignature.CSharpChangeSignatureService/<UpdateParamTagsInLeadingTriviaAsync>d__28")]
private ValueTask`1<ImmutableArray`1<SyntaxTrivia>> UpdateParamTagsInLeadingTriviaAsync(Document document, CSharpSyntaxNode node, ISymbol declarationSymbol, SignatureChange updatedSignature, LineFormattingOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private ImmutableArray`1<SyntaxNode> VerifyAndPermuteParamNodes(IEnumerable`1<XmlElementSyntax> paramNodes, ISymbol declarationSymbol, SignatureChange updatedSignature);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ChangeSignature.CSharpChangeSignatureService/<DetermineCascadedSymbolsFromDelegateInvokeAsync>d__30")]
public virtual Task`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsFromDelegateInvokeAsync(IMethodSymbol symbol, Document document, CancellationToken cancellationToken);
    protected virtual IEnumerable`1<AbstractFormattingRule> GetFormattingRules(Document document);
    protected virtual TArgumentSyntax AddNameToArgument(TArgumentSyntax newArgument, string name);
    protected virtual TArgumentSyntax CreateExplicitParamsArrayFromIndividualArguments(SeparatedSyntaxList`1<TArgumentSyntax> newArguments, int indexInExistingList, IParameterSymbol parameterSymbol);
    protected virtual bool SupportsOptionalAndParamsArrayParametersSimultaneously();
    protected virtual SyntaxToken CommaTokenWithElasticSpace();
    protected virtual bool TryGetRecordPrimaryConstructor(INamedTypeSymbol typeSymbol, IMethodSymbol& primaryConstructor);
    protected virtual ImmutableArray`1<IParameterSymbol> GetParameters(ISymbol declarationSymbol);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ChangeSignature.UnifiedArgumentSyntax : ValueType {
    private SyntaxNode _argument;
    public SyntaxNode NameColon { get; }
    public SyntaxNode Expression { get; }
    public bool IsDefault { get; }
    public bool IsNamed { get; }
    private UnifiedArgumentSyntax(SyntaxNode argument);
    public static IUnifiedArgumentSyntax Create(ArgumentSyntax argument);
    public static IUnifiedArgumentSyntax Create(AttributeArgumentSyntax argument);
    public SyntaxNode get_NameColon();
    public IUnifiedArgumentSyntax WithNameColon(SyntaxNode nameColonSyntax);
    public sealed virtual string GetName();
    public sealed virtual IUnifiedArgumentSyntax WithName(string name);
    public sealed virtual IUnifiedArgumentSyntax WithAdditionalAnnotations(SyntaxAnnotation annotation);
    public SyntaxNode get_Expression();
    public sealed virtual bool get_IsDefault();
    public sealed virtual bool get_IsNamed();
    public static SyntaxNode op_Explicit(UnifiedArgumentSyntax unified);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Classification.IEmbeddedLanguageClassificationService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Classification.CSharpEmbeddedLanguageClassificationService : AbstractEmbeddedLanguageClassificationService {
    [NullableContextAttribute("1")]
[ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public CSharpEmbeddedLanguageClassificationService(IEnumerable`1<Lazy`2<IEmbeddedLanguageClassifier, EmbeddedLanguageMetadata>> classifiers);
}
internal class Microsoft.CodeAnalysis.CSharp.Classification.CSharpFallbackEmbeddedLanguageClassifier : AbstractFallbackEmbeddedLanguageClassifier {
    [NullableAttribute("1")]
public static CSharpFallbackEmbeddedLanguageClassifier Instance;
    private static CSharpFallbackEmbeddedLanguageClassifier();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.AddExplicitCast.CSharpAddExplicitCastCodeFixProvider : AbstractAddExplicitCastCodeFixProvider`1<ExpressionSyntax> {
    private static string CS0266;
    private static string CS1503;
    private ArgumentFixer _argumentFixer;
    private AttributeArgumentFixer _attributeArgumentFixer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual void GetPartsOfCastOrConversionExpression(ExpressionSyntax expression, SyntaxNode& type, SyntaxNode& castedExpression);
    protected virtual ExpressionSyntax Cast(ExpressionSyntax expression, ITypeSymbol type);
    protected virtual bool TryGetTargetTypeInfo(Document document, SemanticModel semanticModel, SyntaxNode root, string diagnosticId, ExpressionSyntax spanNode, CancellationToken cancellationToken, ImmutableArray`1& potentialConversionTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.AddInheritdoc.AddInheritdocCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string CS1591;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.AddInheritdoc.AddInheritdocCodeFixProvider/<RegisterCodeFixesAsync>d__4")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.AddInheritdoc.AddInheritdocCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.ConvertToAsync.CSharpConvertToAsyncMethodCodeFixProvider : AbstractConvertToAsyncCodeFixProvider {
    private static string CS4008;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.ConvertToAsync.CSharpConvertToAsyncMethodCodeFixProvider/<GetDescriptionAsync>d__4")]
protected virtual Task`1<string> GetDescriptionAsync(Diagnostic diagnostic, SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.ConvertToAsync.CSharpConvertToAsyncMethodCodeFixProvider/<GetRootInOtherSyntaxTreeAsync>d__5")]
protected virtual Task`1<Tuple`2<SyntaxTree, SyntaxNode>> GetRootInOtherSyntaxTreeAsync(SyntaxNode node, SemanticModel semanticModel, Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.ConvertToAsync.CSharpConvertToAsyncMethodCodeFixProvider/<GetMethodDeclarationAsync>d__6")]
private static Task`1<MethodDeclarationSyntax> GetMethodDeclarationAsync(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static MethodDeclarationSyntax ConvertToAsyncFunction(MethodDeclarationSyntax methodDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.DeclareAsNullable.CSharpDeclareAsNullableCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string AssigningNullLiteralLocallyEquivalenceKey;
    private static string AssigningNullLiteralRemotelyEquivalenceKey;
    private static string ConditionalOperatorEquivalenceKey;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.DeclareAsNullable.CSharpDeclareAsNullableCodeFixProvider/<RegisterCodeFixesAsync>d__6")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static string GetEquivalenceKey(SyntaxNode node, SemanticModel model);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.DeclareAsNullable.CSharpDeclareAsNullableCodeFixProvider/<FixAllAsync>d__8")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic, Document document, SemanticModel model, string equivalenceKey, CancellationToken cancellationToken);
    private static void MakeDeclarationNullable(SyntaxEditor editor, SemanticModel model, SyntaxNode node, HashSet`1<TypeSyntax> alreadyHandled, CancellationToken cancellationToken);
    private static TypeSyntax TryGetDeclarationTypeToFix(SemanticModel model, SyntaxNode node, CancellationToken cancellationToken);
    private static bool IsExpressionSupported(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static bool <GetEquivalenceKey>g__IsRemoteApiUsage|7_0(SyntaxNode node, SemanticModel model);
    [CompilerGeneratedAttribute]
internal static TypeSyntax <TryGetDeclarationTypeToFix>g__TryGetReturnType|11_0(TypeSyntax returnType, SyntaxTokenList modifiers, bool onYield);
    [CompilerGeneratedAttribute]
internal static TypeSyntax <TryGetDeclarationTypeToFix>g__TryGetSingleTypeArgument|11_1(TypeSyntax type);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static TypeSyntax <TryGetDeclarationTypeToFix>g__TryGetParameterTypeSyntax|11_2(IParameterSymbol parameterSymbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.FixIncorrectConstraint.CSharpFixIncorrectConstraintCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string CS9010;
    private static string CS9011;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    private static bool TryGetConstraint(Diagnostic diagnostic, CancellationToken cancellationToken, TypeConstraintSyntax& constraint, SyntaxToken& enumOrDelegateKeyword);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.FixIncorrectConstraint.CSharpFixIncorrectConstraintCodeFixProvider/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.FixReturnType.CSharpFixReturnTypeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.FixReturnType.CSharpFixReturnTypeCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.FixReturnType.CSharpFixReturnTypeCodeFixProvider/<TryGetOldAndNewReturnTypeAsync>d__4")]
private static Task`1<ValueTuple`2<TypeSyntax, TypeSyntax>> TryGetOldAndNewReturnTypeAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.FixReturnType.CSharpFixReturnTypeCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static ValueTuple`2<TypeSyntax, bool> TryGetDeclarationTypeToFix(SyntaxNode node);
    private static ITypeSymbol InferTupleType(TupleExpressionSyntax tuple, SemanticModel semanticModel, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <RegisterCodeFixesAsync>g__IsVoid|3_0(TypeSyntax typeSyntax);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<TypeSyntax, bool> <TryGetDeclarationTypeToFix>g__TryGetReturnTypeToFix|6_1(SyntaxNode containingMember);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.ForEachCast.CSharpForEachCastCodeFixProvider : AbstractForEachCastCodeFixProvider`1<CommonForEachStatementSyntax> {
    protected virtual ITypeSymbol GetForEachElementType(SemanticModel semanticModel, CommonForEachStatementSyntax forEachStatement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.FullyQualify.CSharpFullyQualifyCodeFixProvider : AbstractFullyQualifyCodeFixProvider {
    private static string CS0103;
    private static string CS0104;
    private static string CS0246;
    private static string CS0305;
    private static string CS0308;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CodeFixes.FullyQualify.IFullyQualifyService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.FullyQualify.CSharpFullyQualifyService : AbstractFullyQualifyService`1<SimpleNameSyntax> {
    protected virtual bool CanFullyQualify(SyntaxNode node, SimpleNameSyntax& simpleName);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.FullyQualify.CSharpFullyQualifyService/<ReplaceNodeAsync>d__2")]
protected virtual Task`1<SyntaxNode> ReplaceNodeAsync(SimpleNameSyntax simpleName, string containerName, bool resultingSymbolIsType, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.GenerateDeconstructMethod.GenerateDeconstructMethodCodeFixProvider : CodeFixProvider {
    private static string CS8129;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.GenerateDeconstructMethod.GenerateDeconstructMethodCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.GenerateEnumMember.GenerateEnumMemberCodeFixProvider : AbstractGenerateMemberCodeFixProvider {
    private static string CS0117;
    private static string CS1061;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected virtual bool IsCandidate(SyntaxNode node, SyntaxToken token, Diagnostic diagnostic);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.GenerateMethod.GenerateConversionCodeFixProvider : AbstractGenerateMemberCodeFixProvider {
    private static string CS0029;
    private static string CS0030;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsCandidate(SyntaxNode node, SyntaxToken token, Diagnostic diagnostic);
    protected virtual SyntaxNode GetTargetNode(SyntaxNode node);
    protected virtual Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
[ExtensionOrderAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.GenerateMethod.GenerateMethodCodeFixProvider : AbstractGenerateMemberCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsCandidate(SyntaxNode node, SyntaxToken token, Diagnostic diagnostic);
    protected virtual SyntaxNode GetTargetNode(SyntaxNode node);
    protected virtual Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeFixes.GenerateMethod.GenerateMethodDiagnosticIds : object {
    private static string CS0103;
    private static string CS0117;
    private static string CS0118;
    private static string CS0122;
    private static string CS0305;
    private static string CS0308;
    private static string CS0539;
    private static string CS1061;
    private static string CS1501;
    private static string CS1503;
    private static string CS1660;
    private static string CS1739;
    private static string CS7036;
    private static string CS1955;
    private static string CS0123;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableArray`1<string> FixableDiagnosticIds;
    private static GenerateMethodDiagnosticIds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.GenerateType.GenerateTypeCodeFixProvider : AbstractGenerateMemberCodeFixProvider {
    private static string CS0103;
    private static string CS0117;
    private static string CS0234;
    private static string CS0246;
    private static string CS0305;
    private static string CS0308;
    private static string CS0426;
    private static string CS0616;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsCandidate(SyntaxNode node, SyntaxToken token, Diagnostic diagnostic);
    protected virtual SyntaxNode GetTargetNode(SyntaxNode node);
    protected virtual Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.HideBase.HideBaseCodeFixProvider : CodeFixProvider {
    internal static string CS0108;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.HideBase.HideBaseCodeFixProvider/<RegisterCodeFixesAsync>d__6")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpAddYieldCodeFixProvider : AbstractIteratorCodeFixProvider {
    private static string CS0029;
    private static string CS0266;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpAddYieldCodeFixProvider/<GetCodeFixAsync>d__5")]
protected virtual Task`1<CodeAction> GetCodeFixAsync(SyntaxNode root, SyntaxNode node, Document document, Diagnostic diagnostics, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static bool TryGetExpressionType(SemanticModel model, ExpressionSyntax expression, ITypeSymbol& returnExpressionType);
    private static bool TryGetMethodReturnType(SyntaxNode node, SemanticModel model, CancellationToken cancellationToken, ITypeSymbol& methodReturnType);
    private static bool IsCorrectTypeForYieldReturn(ITypeSymbol typeArgument, ITypeSymbol returnExpressionType, ITypeSymbol methodReturnType, SemanticModel model);
    private static bool CanConvertTypes(ITypeSymbol typeArgument, ITypeSymbol returnExpressionType, SemanticModel model);
    private static bool IsCorrectTypeForYieldReturn(ITypeSymbol methodReturnType, SemanticModel model);
    protected virtual bool TryGetNode(SyntaxNode root, TextSpan span, SyntaxNode& node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpChangeToIEnumerableCodeFixProvider : AbstractIteratorCodeFixProvider {
    private static string CS1624;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpChangeToIEnumerableCodeFixProvider/<GetCodeFixAsync>d__4")]
protected virtual Task`1<CodeAction> GetCodeFixAsync(SyntaxNode root, SyntaxNode node, Document document, Diagnostic diagnostics, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static bool TryGetIEnumerableSymbols(SemanticModel model, INamedTypeSymbol& ienumerableSymbol, INamedTypeSymbol& ienumerableGenericSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.MakeMemberRequired.CSharpMakeMemberRequiredCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string CS8618;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.MakeMemberRequired.CSharpMakeMemberRequiredCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <RegisterCodeFixesAsync>g__CanBeAccessed|5_0(SymbolVisibility containingTypeVisibility, Accessibility accessibility);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.MakeStatementAsynchronous.CSharpMakeStatementAsynchronousCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.MakeStatementAsynchronous.CSharpMakeStatementAsynchronousCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void MakeStatementAsynchronous(SyntaxEditor editor, SyntaxNode statementToFix);
    private static SyntaxNode TryGetStatementToFix(SyntaxNode node);
}
[ExportAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.MatchFolderAndNamespace.CSharpChangeNamespaceToMatchFolderCodeFixProvider")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.MatchFolderAndNamespace.CSharpChangeNamespaceToMatchFolderCodeFixProvider : AbstractChangeNamespaceToMatchFolderCodeFixProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.RemoveNewModifier.RemoveNewModifierCodeFixProvider : CodeFixProvider {
    private static string CS0109;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual FixAllProvider GetFixAllProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.RemoveNewModifier.RemoveNewModifierCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeFixes.RemoveNewModifier.RemoveNewModifierCodeFixProvider/<FixAsync>d__6")]
private static Task`1<Document> FixAsync(Document document, SyntaxGenerator generator, MemberDeclarationSyntax memberDeclaration, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.RemoveUnnecessaryNullableDirective.CSharpRemoveUnnecessaryNullableDirectiveCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[ExportConfigurationFixProviderAttribute("Suppression", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.Suppression.CSharpSuppressionCodeFixProvider : AbstractSuppressionCodeFixProvider {
    protected string DefaultFileExtension { get; }
    protected string SingleLineCommentStart { get; }
    protected virtual SyntaxTriviaList CreatePragmaRestoreDirectiveTrivia(Diagnostic diagnostic, Func`3<SyntaxNode, CancellationToken, SyntaxNode> formatNode, bool needsLeadingEndOfLine, bool needsTrailingEndOfLine, CancellationToken cancellationToken);
    protected virtual SyntaxTriviaList CreatePragmaDisableDirectiveTrivia(Diagnostic diagnostic, Func`3<SyntaxNode, CancellationToken, SyntaxNode> formatNode, bool needsLeadingEndOfLine, bool needsTrailingEndOfLine, CancellationToken cancellationToken);
    private static SyntaxTriviaList CreatePragmaDirectiveTrivia(SyntaxToken disableOrRestoreKeyword, Diagnostic diagnostic, Func`3<SyntaxNode, CancellationToken, SyntaxNode> formatNode, bool needsLeadingEndOfLine, bool needsTrailingEndOfLine, CancellationToken cancellationToken);
    protected virtual string get_DefaultFileExtension();
    protected virtual string get_SingleLineCommentStart();
    protected virtual bool IsAttributeListWithAssemblyAttributes(SyntaxNode node);
    protected virtual bool IsEndOfLine(SyntaxTrivia trivia);
    protected virtual bool IsEndOfFileToken(SyntaxToken token);
    protected virtual SyntaxNode AddGlobalSuppressMessageAttribute(SyntaxNode newRoot, ISymbol targetSymbol, INamedTypeSymbol suppressMessageAttribute, Diagnostic diagnostic, SolutionServices services, SyntaxFormattingOptions options, IAddImportsService addImportsService, CancellationToken cancellationToken);
    protected virtual SyntaxNode AddLocalSuppressMessageAttribute(SyntaxNode targetNode, ISymbol targetSymbol, INamedTypeSymbol suppressMessageAttribute, Diagnostic diagnostic);
    private static AttributeListSyntax CreateAttributeList(ISymbol targetSymbol, NameSyntax attributeName, Diagnostic diagnostic, bool isAssemblyAttribute, SyntaxTriviaList leadingTrivia);
    private static AttributeArgumentListSyntax CreateAttributeArguments(ISymbol targetSymbol, Diagnostic diagnostic, bool isAssemblyAttribute);
    protected virtual bool IsSingleAttributeInAttributeList(SyntaxNode attribute);
    protected virtual bool IsAnyPragmaDirectiveForId(SyntaxTrivia trivia, string id, Boolean& enableDirective, Boolean& hasMultipleIds);
    protected virtual SyntaxTrivia TogglePragmaDirective(SyntaxTrivia trivia);
    protected virtual SyntaxNode GetContainingStatement(SyntaxToken token);
    protected virtual bool TokenHasTrailingLineContinuationChar(SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.TransposeRecordKeyword.CSharpTransposeRecordKeywordCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string CS9012;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    private static bool TryGetRecordDeclaration(Diagnostic diagnostic, CancellationToken cancellationToken, RecordDeclarationSyntax& recordDeclaration);
    private static bool TryGetTokens(RecordDeclarationSyntax recordDeclaration, SyntaxToken& classOrStructKeyword, SyntaxToken& recordKeyword);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.CodeFixes.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeActionHelpers : object {
    internal static LambdaExpressionSyntax Update(SemanticModel semanticModel, LambdaExpressionSyntax originalDeclaration, LambdaExpressionSyntax currentDeclaration, CancellationToken cancellationToken);
    private static LambdaExpressionSyntax UpdateWorker(SemanticModel semanticModel, LambdaExpressionSyntax originalDeclaration, LambdaExpressionSyntax currentDeclaration, CancellationToken cancellationToken);
    private static LambdaExpressionSyntax WithExpressionBody(LambdaExpressionSyntax declaration, LanguageVersion languageVersion, CancellationToken cancellationToken);
    private static LambdaExpressionSyntax WithBlockBody(SemanticModel semanticModel, LambdaExpressionSyntax originalDeclaration, LambdaExpressionSyntax currentDeclaration, ExpressionSyntax expressionBody);
    private static bool CreateReturnStatementForExpression(SemanticModel semanticModel, LambdaExpressionSyntax declaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeFixes.UseNameofInAttribute.CSharpUseNameofInAttributeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CodeLens.ICodeLensDisplayInfoService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeLens.CSharpCodeLensDisplayInfoService : object {
    private static SymbolDisplayFormat Format;
    private static CSharpCodeLensDisplayInfoService();
    public sealed virtual SyntaxNode GetDisplayNode(SyntaxNode node);
    public sealed virtual string GetDisplayName(SemanticModel semanticModel, SyntaxNode node);
    private static string GetEnclosingScopeString(SyntaxNode node, SemanticModel semanticModel, SymbolDisplayFormat symbolDisplayFormat);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CodeLens.ICodeLensMemberFinder", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeLens.CSharpCodeLensMemberFinder : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeLens.CSharpCodeLensMemberFinder/<GetCodeLensMembersAsync>d__1")]
public sealed virtual Task`1<ImmutableArray`1<CodeLensMember>> GetCodeLensMembersAsync(Document document, CancellationToken cancellationToken);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.AddAwait.CSharpAddAwaitCodeRefactoringProvider : AbstractAddAwaitCodeRefactoringProvider`1<ExpressionSyntax> {
    protected virtual string GetTitle();
    protected virtual string GetTitleWithConfigureAwait();
    protected virtual bool IsInAsyncContext(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.AddMissingImports.CSharpAddMissingImportsRefactoringProvider : AbstractAddMissingImportsRefactoringProvider {
    protected string CodeActionTitle { get; }
    [NullableContextAttribute("2")]
[ImportingConstructorAttribute]
public CSharpAddMissingImportsRefactoringProvider(IPasteTrackingService pasteTrackingService);
    protected virtual string get_CodeActionTitle();
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.ConvertLocalFunctionToMethod.CSharpConvertLocalFunctionToMethodCodeRefactoringProvider : CodeRefactoringProvider {
    private static SyntaxAnnotation s_delegateToReplaceAnnotation;
    private static CSharpConvertLocalFunctionToMethodCodeRefactoringProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.ConvertLocalFunctionToMethod.CSharpConvertLocalFunctionToMethodCodeRefactoringProvider/<ComputeRefactoringsAsync>d__2")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.ConvertLocalFunctionToMethod.CSharpConvertLocalFunctionToMethodCodeRefactoringProvider/<UpdateDocumentAsync>d__3")]
private static Task`1<Document> UpdateDocumentAsync(SyntaxNode root, Document document, BlockSyntax parentBlock, LocalFunctionStatementSyntax localFunction, MemberDeclarationSyntax container, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static bool SupportsNonTrailingNamedArguments(ParseOptions options);
    private static SyntaxNode GenerateArgument(IParameterSymbol p, string name, bool shouldUseNamedArguments);
    private static List`1<string> GenerateUniqueParameterNames(ImmutableArray`1<IParameterSymbol> parameters, List`1<string> reservedNames);
    private static List`1<string> GetReservedNames(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ParameterSyntax GenerateParameter(IParameterSymbol p, string name);
    private static MethodDeclarationSyntax WithBodyFrom(MethodDeclarationSyntax method, LocalFunctionStatementSyntax localFunction);
    private static void AddCapturedTypeParameters(ISymbol symbol, List`1<ITypeParameterSymbol> typeParameters);
    private static void RemoveUnusedTypeParameters(SyntaxNode localFunction, SemanticModel semanticModel, List`1<ITypeParameterSymbol> typeParameters, IEnumerable`1<ITypeParameterSymbol> reservedTypeParameters);
    private static string GenerateUniqueMethodName(ISymbol declaredSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CodeRefactorings.IRefactoringHelpersService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.CSharpRefactoringHelpersService : AbstractRefactoringHelpersService`3<ExpressionSyntax, ArgumentSyntax, ExpressionStatementSyntax> {
    protected IHeaderFacts HeaderFacts { get; }
    protected virtual IHeaderFacts get_HeaderFacts();
    public virtual bool IsBetweenTypeMembers(SourceText sourceText, SyntaxNode root, int position, SyntaxNode& typeDeclaration);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.CSharpRefactoringHelpersService/<ExtractNodesSimple>d__4")]
protected virtual IEnumerable`1<SyntaxNode> ExtractNodesSimple(SyntaxNode node, ISyntaxFactsService syntaxFacts);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<SyntaxNode> <>n__0(SyntaxNode node, ISyntaxFactsService syntaxFacts);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.EnableNullable.EnableNullableCodeRefactoringProvider : CodeRefactoringProvider {
    private static Func`2<DirectiveTriviaSyntax, bool> s_isNullableDirectiveTriviaPredicate;
    private static EnableNullableCodeRefactoringProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.EnableNullable.EnableNullableCodeRefactoringProvider/<ComputeRefactoringsAsync>d__2")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static bool ShouldOfferRefactoring(Project project);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.EnableNullable.EnableNullableCodeRefactoringProvider/<EnableNullableReferenceTypesAsync>d__4")]
private static Task`1<Solution> EnableNullableReferenceTypesAsync(Project project, CodeActionPurpose purpose, CodeActionOptionsProvider fallbackOptions, IProgress`1<CodeAnalysisProgress> _, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.EnableNullable.EnableNullableCodeRefactoringProvider/<EnableNullableReferenceTypesAsync>d__5")]
private static Task`1<SyntaxNode> EnableNullableReferenceTypesAsync(Document document, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static ValueTuple`2<SyntaxNode, SyntaxToken> RewriteExistingDirectives(SyntaxNode root, SyntaxToken firstToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.EnableNullable.EnableNullableCodeRefactoringProvider/<DisableNullableReferenceTypesInExistingDocumentIfNecessaryAsync>d__7")]
private static Task`1<SyntaxNode> DisableNullableReferenceTypesInExistingDocumentIfNecessaryAsync(Document document, SyntaxNode root, SyntaxToken firstToken, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static int GetInsertionPoint(SyntaxTriviaList list);
    private static SyntaxToken GetFirstTokenOfInterest(SyntaxNode root);
    private static bool HasLeadingNullableDirective(SyntaxNode root, NullableDirectiveTriviaSyntax& leadingNullableDirective);
    [NullableContextAttribute("2")]
internal sealed virtual FixAllProvider GetFixAllProvider();
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.ExtractClass.CSharpExtractClassCodeRefactoringProvider : AbstractExtractClassRefactoringProvider {
    [NullableContextAttribute("1")]
internal CSharpExtractClassCodeRefactoringProvider(IExtractClassOptionsService optionsService);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.ExtractClass.CSharpExtractClassCodeRefactoringProvider/<GetSelectedClassDeclarationAsync>d__2")]
protected virtual Task`1<SyntaxNode> GetSelectedClassDeclarationAsync(CodeRefactoringContext context);
    protected virtual Task`1<ImmutableArray`1<SyntaxNode>> GetSelectedNodesAsync(CodeRefactoringContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExportAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineMethod.CSharpInlineMethodRefactoringProvider")]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineMethod.CSharpInlineMethodRefactoringProvider : AbstractInlineMethodRefactoringProvider`4<BaseMethodDeclarationSyntax, StatementSyntax, ExpressionSyntax, InvocationExpressionSyntax> {
    protected virtual ExpressionSyntax GetRawInlineExpression(BaseMethodDeclarationSyntax methodDeclarationSyntax);
    protected virtual SyntaxNode GenerateTypeSyntax(ITypeSymbol symbol, bool allowVar);
    protected virtual ExpressionSyntax GenerateLiteralExpression(ITypeSymbol typeSymbol, object value);
    protected virtual bool IsFieldDeclarationSyntax(SyntaxNode node);
    protected virtual bool IsValidExpressionUnderExpressionStatement(ExpressionSyntax expressionNode);
    protected virtual bool CanBeReplacedByThrowExpression(SyntaxNode syntaxNode);
    private static bool IsNullConditionalInvocationExpression(ExpressionSyntax expressionSyntax);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineTemporary.CSharpInlineTemporaryCodeRefactoringProvider : AbstractInlineTemporaryCodeRefactoringProvider`2<IdentifierNameSyntax, VariableDeclaratorSyntax> {
    private static SyntaxAnnotation DefinitionAnnotation;
    private static SyntaxAnnotation ReferenceAnnotation;
    private static SyntaxAnnotation ExpressionAnnotation;
    private static CSharpInlineTemporaryCodeRefactoringProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineTemporary.CSharpInlineTemporaryCodeRefactoringProvider/<ComputeRefactoringsAsync>d__4")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static bool HasConflict(IdentifierNameSyntax identifier, VariableDeclaratorSyntax variableDeclarator);
    private static SyntaxAnnotation CreateConflictAnnotation();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineTemporary.CSharpInlineTemporaryCodeRefactoringProvider/<InlineTemporaryAsync>d__7")]
private static Task`1<Document> InlineTemporaryAsync(Document document, VariableDeclaratorSyntax declarator, CancellationToken cancellationToken);
    private static bool MayContainSideEffects(SyntaxNode expression);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineTemporary.CSharpInlineTemporaryCodeRefactoringProvider/<FindDeclaratorAsync>d__9")]
private static Task`1<VariableDeclaratorSyntax> FindDeclaratorAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineTemporary.CSharpInlineTemporaryCodeRefactoringProvider/<FindNodeWithAnnotationAsync>d__10`1")]
private static Task`1<T> FindNodeWithAnnotationAsync(Document document, SyntaxAnnotation annotation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineTemporary.CSharpInlineTemporaryCodeRefactoringProvider/<FindReferenceAnnotatedNodesAsync>d__11")]
private static Task`1<ImmutableArray`1<IdentifierNameSyntax>> FindReferenceAnnotatedNodesAsync(Document document, CancellationToken cancellationToken);
    private static SyntaxNode GetScope(VariableDeclaratorSyntax variableDeclarator);
    private static VariableDeclaratorSyntax FindDeclarator(SyntaxNode node);
    private static SyntaxNode RemoveDeclaratorFromVariableList(VariableDeclaratorSyntax variableDeclarator, VariableDeclarationSyntax variableDeclaration);
    private static SyntaxNode RemoveDeclaratorFromScope(VariableDeclaratorSyntax variableDeclarator, SyntaxNode scope);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineTemporary.CSharpInlineTemporaryCodeRefactoringProvider/<CreateExpressionToInlineAsync>d__16")]
private static Task`1<ExpressionSyntax> CreateExpressionToInlineAsync(Document document, VariableDeclaratorSyntax variableDeclarator, CancellationToken cancellationToken);
    private static SyntaxNode GetTopMostParentingExpression(ExpressionSyntax expression);
    private static bool IsInDeconstructionAssignmentLeft(ExpressionSyntax node);
    [CompilerGeneratedAttribute]
internal static ExpressionSyntax <CreateExpressionToInlineAsync>g__CreateExpressionToInline|16_0(<>c__DisplayClass16_0& );
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.MoveStaticMembers.CSharpMoveStaticMembersRefactoringProvider : AbstractMoveStaticMembersRefactoringProvider {
    protected virtual Task`1<ImmutableArray`1<SyntaxNode>> GetSelectedNodesAsync(CodeRefactoringContext context);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CodeRefactorings.MoveType.IMoveTypeService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.MoveType.CSharpMoveTypeService : AbstractMoveTypeService`5<CSharpMoveTypeService, BaseTypeDeclarationSyntax, BaseNamespaceDeclarationSyntax, MemberDeclarationSyntax, CompilationUnitSyntax> {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.MoveType.CSharpMoveTypeService/<GetRelevantNodeAsync>d__1")]
protected virtual Task`1<BaseTypeDeclarationSyntax> GetRelevantNodeAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.NodeSelectionHelpers : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.NodeSelectionHelpers/<GetSelectedDeclarationsOrVariablesAsync>d__0")]
internal static Task`1<ImmutableArray`1<SyntaxNode>> GetSelectedDeclarationsOrVariablesAsync(CodeRefactoringContext context);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.PullMemberUp.CSharpPullMemberUpCodeRefactoringProvider : AbstractPullMemberUpRefactoringProvider {
    public CSharpPullMemberUpCodeRefactoringProvider(IPullMemberUpOptionsService service);
    protected virtual Task`1<ImmutableArray`1<SyntaxNode>> GetSelectedNodesAsync(CodeRefactoringContext context);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ReplaceMethodWithProperty.IReplaceMethodWithPropertyService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.ReplaceMethodWithProperty.CSharpReplaceMethodWithPropertyService : AbstractReplaceMethodWithPropertyService`1<MethodDeclarationSyntax> {
    private static Action`4<SyntaxEditor, InvocationExpressionSyntax, SimpleNameSyntax, SimpleNameSyntax> s_replaceGetReferenceInvocation;
    private static Action`4<SyntaxEditor, InvocationExpressionSyntax, SimpleNameSyntax, SimpleNameSyntax> s_replaceSetReferenceInvocation;
    private static CSharpReplaceMethodWithPropertyService();
    public sealed virtual void RemoveSetMethod(SyntaxEditor editor, SyntaxNode setMethodDeclaration);
    public sealed virtual void ReplaceGetMethodWithProperty(CodeGenerationOptions options, ParseOptions parseOptions, SyntaxEditor editor, SemanticModel semanticModel, GetAndSetMethods getAndSetMethods, string propertyName, bool nameChanged, CancellationToken cancellationToken);
    public static SyntaxNode ConvertMethodsToProperty(CSharpCodeGenerationOptions options, LanguageVersion languageVersion, SemanticModel semanticModel, SyntaxGenerator generator, GetAndSetMethods getAndSetMethods, string propertyName, bool nameChanged, CancellationToken cancellationToken);
    public static PropertyDeclarationSyntax ConvertMethodsToPropertyWorker(CSharpCodeGenerationOptions options, LanguageVersion languageVersion, SemanticModel semanticModel, SyntaxGenerator generator, GetAndSetMethods getAndSetMethods, string propertyName, bool nameChanged, CancellationToken cancellationToken);
    private static SyntaxToken GetPropertyName(SyntaxToken identifier, string propertyName, bool nameChanged);
    private static AccessorDeclarationSyntax CreateGetAccessor(GetAndSetMethods getAndSetMethods, CSharpCodeGenerationOptions options, LanguageVersion languageVersion, CancellationToken cancellationToken);
    private static AccessorDeclarationSyntax UseExpressionOrBlockBodyIfDesired(CSharpCodeGenerationOptions options, LanguageVersion languageVersion, AccessorDeclarationSyntax accessorDeclaration, CancellationToken cancellationToken);
    private static AccessorDeclarationSyntax CreateGetAccessorWorker(GetAndSetMethods getAndSetMethods);
    private static AccessorDeclarationSyntax CreateSetAccessor(SemanticModel semanticModel, SyntaxGenerator generator, GetAndSetMethods getAndSetMethods, CSharpCodeGenerationOptions options, LanguageVersion languageVersion, CancellationToken cancellationToken);
    private static AccessorDeclarationSyntax CreateSetAccessorWorker(SemanticModel semanticModel, SyntaxGenerator generator, GetAndSetMethods getAndSetMethods);
    private static TNode ReplaceReferencesToParameterWithValue(SemanticModel semanticModel, IParameterSymbol parameter, TNode node);
    public sealed virtual void ReplaceGetReference(SyntaxEditor editor, SyntaxToken nameToken, string propertyName, bool nameChanged);
    public sealed virtual void ReplaceSetReference(SyntaxEditor editor, SyntaxToken nameToken, string propertyName, bool nameChanged);
    public static void ReplaceInvocation(SyntaxEditor editor, SyntaxToken nameToken, string propertyName, bool nameChanged, Action`4<SyntaxEditor, InvocationExpressionSyntax, SimpleNameSyntax, SimpleNameSyntax> replace);
    private static bool IsInvocationName(IdentifierNameSyntax nameNode, ExpressionSyntax invocationExpression);
    private sealed virtual override Task`1<SyntaxNode> Microsoft.CodeAnalysis.ReplaceMethodWithProperty.IReplaceMethodWithPropertyService.GetMethodDeclarationAsync(CodeRefactoringContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.SyncNamespace.CSharpSyncNamespaceCodeRefactoringProvider : AbstractSyncNamespaceCodeRefactoringProvider`3<BaseNamespaceDeclarationSyntax, CompilationUnitSyntax, MemberDeclarationSyntax> {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.SyncNamespace.CSharpSyncNamespaceCodeRefactoringProvider/<TryGetApplicableInvocationNodeAsync>d__1")]
protected virtual Task`1<SyntaxNode> TryGetApplicableInvocationNodeAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    protected virtual string EscapeIdentifier(string identifier);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.UseExplicitType.UseExplicitTypeCodeRefactoringProvider : AbstractUseTypeCodeRefactoringProvider {
    protected string Title { get; }
    protected virtual string get_Title();
    protected virtual TypeSyntax FindAnalyzableType(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual TypeStyleResult AnalyzeTypeName(TypeSyntax typeName, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    protected virtual Task HandleDeclarationAsync(Document document, SyntaxEditor editor, TypeSyntax node, CancellationToken cancellationToken);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.UseImplicitType.UseImplicitTypeCodeRefactoringProvider : AbstractUseTypeCodeRefactoringProvider {
    protected string Title { get; }
    protected virtual string get_Title();
    protected virtual TypeSyntax FindAnalyzableType(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual TypeStyleResult AnalyzeTypeName(TypeSyntax typeName, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    protected virtual Task HandleDeclarationAsync(Document document, SyntaxEditor editor, TypeSyntax type, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.UseRecursivePatterns.UseRecursivePatternsCodeRefactoringProvider : SyntaxEditorBasedCodeRefactoringProvider {
    private static PatternSyntax s_trueConstantPattern;
    private static PatternSyntax s_falseConstantPattern;
    [NullableAttribute("0")]
protected ImmutableArray`1<FixAllScope> SupportedFixAllScopes { get; }
    private static UseRecursivePatternsCodeRefactoringProvider();
    [NullableContextAttribute("0")]
protected virtual ImmutableArray`1<FixAllScope> get_SupportedFixAllScopes();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.UseRecursivePatterns.UseRecursivePatternsCodeRefactoringProvider/<ComputeRefactoringsAsync>d__5")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static Func`2<SyntaxNode, SyntaxNode> GetReplacementFunc(SyntaxNode node, SemanticModel model);
    private static bool IsFixableNode(SyntaxNode node);
    private static Func`2<SyntaxNode, SyntaxNode> CombineLogicalAndOperands(BinaryExpressionSyntax logicalAnd, SemanticModel model);
    private static Func`2<SyntaxNode, SyntaxNode> CombineWhenClauseCondition(PatternSyntax switchPattern, ExpressionSyntax condition, SemanticModel model);
    private static PatternSyntax RewriteContainingPattern(PatternSyntax containingPattern, PatternSyntax generatedPattern, ImmutableArray`1<IdentifierNameSyntax> namesOpt);
    private static PatternSyntax CreatePattern(ExpressionSyntax originalReceiver, ExpressionOrPatternSyntax target, bool flipped);
    private static Nullable`1<ValueTuple`2<PatternSyntax, ImmutableArray`1<IdentifierNameSyntax>>> TryFindVariableDesignation(PatternSyntax leftPattern, ExpressionSyntax rightReceiver, SemanticModel model);
    private static Nullable`1<ValueTuple`3<ExpressionSyntax, ExpressionOrPatternSyntax, bool>> TryDetermineReceiver(ExpressionSyntax node, SemanticModel model, bool inWhenClause);
    private static SubpatternSyntax CreateSubpattern(ImmutableArray`1<IdentifierNameSyntax> names, PatternSyntax pattern);
    private static SubpatternSyntax Subpattern(IdentifierNameSyntax name, PatternSyntax pattern);
    private static RecursivePatternSyntax RecursivePattern(SubpatternSyntax[] subpatterns);
    private static RecursivePatternSyntax RecursivePattern(TypeSyntax type, SubpatternSyntax subpattern, VariableDesignationSyntax designation);
    private static RecursivePatternSyntax RecursivePattern(SubpatternSyntax subpattern);
    private static Nullable`1<ValueTuple`3<ExpressionSyntax, ImmutableArray`1<IdentifierNameSyntax>, ImmutableArray`1<IdentifierNameSyntax>>> TryGetCommonReceiver(ExpressionSyntax left, ExpressionSyntax right, SemanticModel model);
    private static ExpressionSyntax GetInnermostReceiver(ExpressionSyntax node, ArrayBuilder`1<IdentifierNameSyntax> builder, SemanticModel model);
    private static ExpressionSyntax GetInnermostReceiver(ExpressionSyntax node, TArg arg, Func`3<IdentifierNameSyntax, TArg, bool> canConvertToSubpattern, ArrayBuilder`1<IdentifierNameSyntax> builder);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.UseRecursivePatterns.UseRecursivePatternsCodeRefactoringProvider/<FixAllAsync>d__22")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<TextSpan> fixAllSpans, SyntaxEditor editor, CodeActionOptionsProvider optionsProvider, string equivalenceKey, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <CombineLogicalAndOperands>g__AdjustBinaryExpressionOperands|8_2(BinaryExpressionSyntax logicalAnd, ExpressionSyntax replacement);
    [CompilerGeneratedAttribute]
internal static PatternSyntax <RewriteContainingPattern>g__Combine|10_0(PatternSyntax containingPattern, PatternSyntax generatedPattern);
    [CompilerGeneratedAttribute]
internal static PatternSyntax <RewriteContainingPattern>g__AddSubpattern|10_1(PatternSyntax containingPattern, SubpatternSyntax subpattern);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static PropertyPatternClauseSyntax <RewriteContainingPattern>g__Concat|10_2(PropertyPatternClauseSyntax left, PropertyPatternClauseSyntax right);
    [CompilerGeneratedAttribute]
internal static SyntaxToken <CreatePattern>g__Flip|11_0(SyntaxToken token);
    [CompilerGeneratedAttribute]
internal static Nullable`1<ValueTuple`3<ExpressionSyntax, ExpressionSyntax, bool>> <TryDetermineReceiver>g__TryDetermineConstant|13_0(BinaryExpressionSyntax node, SemanticModel model);
    [CompilerGeneratedAttribute]
internal static bool <TryGetCommonReceiver>g__TryGetInnermostReceiver|19_1(ExpressionSyntax node, ArrayBuilder`1<IdentifierNameSyntax> builder, ExpressionSyntax& receiver, SemanticModel model);
    [CompilerGeneratedAttribute]
internal static IdentifierNameSyntax <TryGetCommonReceiver>g__SkipCommonNames|19_2(ArrayBuilder`1<IdentifierNameSyntax> leftNames, ArrayBuilder`1<IdentifierNameSyntax> rightNames);
    [CompilerGeneratedAttribute]
internal static bool <GetInnermostReceiver>g__CanConvertToSubpattern|20_0(IdentifierNameSyntax name, SemanticModel model);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static ExpressionSyntax <GetInnermostReceiver>g__GetInnermostReceiver|21_0(ExpressionSyntax node, <>c__DisplayClass21_0`1& );
}
internal abstract class Microsoft.CodeAnalysis.CSharp.CodeRefactorings.UseType.AbstractUseTypeCodeRefactoringProvider : CodeRefactoringProvider {
    protected string Title { get; }
    protected abstract virtual string get_Title();
    protected abstract virtual Task HandleDeclarationAsync(Document document, SyntaxEditor editor, TypeSyntax type, CancellationToken cancellationToken);
    protected abstract virtual TypeSyntax FindAnalyzableType(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected abstract virtual TypeStyleResult AnalyzeTypeName(TypeSyntax typeName, SemanticModel semanticModel, CSharpSimplifierOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.UseType.AbstractUseTypeCodeRefactoringProvider/<ComputeRefactoringsAsync>d__5")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.UseType.AbstractUseTypeCodeRefactoringProvider/<GetDeclarationAsync>d__6")]
private static Task`1<SyntaxNode> GetDeclarationAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CodeRefactorings.UseType.AbstractUseTypeCodeRefactoringProvider/<UpdateDocumentAsync>d__7")]
private Task`1<Document> UpdateDocumentAsync(Document document, TypeSyntax type, CancellationToken cancellationToken);
}
[ExportCompletionProviderAttribute("CSharpSnippetCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.CompletionProviders.Snippets.CSharpSnippetCompletionProvider : AbstractSnippetCompletionProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.CSharpCompletionService : CommonCompletionService {
    private CompletionRules _latestRules;
    public string Language { get; }
    private CSharpCompletionService(SolutionServices services, IAsynchronousOperationListenerProvider listenerProvider);
    public virtual string get_Language();
    public virtual TextSpan GetDefaultCompletionListSpan(SourceText text, int caretPosition);
    internal virtual CompletionRules GetRules(CompletionOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AbstractKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validNonInterfaceMemberModifiers;
    private static ISet`1<SyntaxKind> s_validInterfaceMemberModifiers;
    private static ISet`1<SyntaxKind> s_validTypeModifiers;
    private static AbstractKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AbstractNativeIntegerKeywordRecommender : object {
    protected RecommendedKeyword Keyword { get; }
    protected abstract virtual RecommendedKeyword get_Keyword();
    private static bool IsValidContext(CSharpSyntaxContext context);
    public sealed virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AbstractSpecialTypePreselectingKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected SpecialType SpecialType { get; }
    protected int PreselectMatchPriority { get; }
    protected AbstractSpecialTypePreselectingKeywordRecommender(SyntaxKind keywordKind, bool isValidInPreprocessorContext, bool shouldFormatOnCommit);
    protected abstract virtual SpecialType get_SpecialType();
    protected abstract virtual bool IsValidContextWorker(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual int get_PreselectMatchPriority();
    protected virtual bool ShouldPreselect(CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected sealed virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsAfterRefOrReadonlyInTopLevelOrMemberDeclaration(CSharpSyntaxContext context, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AbstractSyntacticSingleKeywordRecommender : object {
    public SyntaxKind KeywordKind;
    private bool _isValidInPreprocessorContext;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<RecommendedKeyword> _keywordPriorityRecommendedKeywords;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<RecommendedKeyword> _defaultPriorityRecommendedKeywords;
    protected int DefaultMatchPriority { get; }
    protected int PreselectMatchPriority { get; }
    protected AbstractSyntacticSingleKeywordRecommender(SyntaxKind keywordKind, bool isValidInPreprocessorContext, bool shouldFormatOnCommit);
    protected virtual int get_DefaultMatchPriority();
    protected virtual int get_PreselectMatchPriority();
    protected abstract virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual bool ShouldPreselect(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private Nullable`1<SyntaxKind> RecommendKeyword(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    internal TestAccessor GetTestAccessor();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AddKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AliasKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AndKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AnnotationsKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AscendingKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AsKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AssemblyKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.AsyncKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validLocalFunctionModifiers;
    private static AsyncKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool InMemberDeclarationContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.BaseKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsInstanceExpressionOrStatement(CSharpSyntaxContext context);
    private static bool IsConstructorInitializerContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.BoolKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    [NullableContextAttribute("1")]
protected virtual bool IsValidContextWorker(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.BreakKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsInBreakableConstructContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ByKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ByteKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    [NullableContextAttribute("1")]
protected virtual bool IsValidContextWorker(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.CaseKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    internal static bool IsAfterGotoInSwitchContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.CatchKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.CharKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    [NullableContextAttribute("1")]
protected virtual bool IsValidContextWorker(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.CheckedKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ChecksumKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ClassKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validModifiers;
    private static ClassKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ConstKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validModifiers;
    private static ISet`1<SyntaxKind> s_validGlobalModifiers;
    private static ConstKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsMemberDeclarationContext(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsLocalVariableDeclaration(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ContinueKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.DecimalKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    [NullableContextAttribute("1")]
protected virtual bool IsValidContextWorker(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.DefaultKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidPreProcessorContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.DefineKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.DelegateKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validModifiers;
    private static DelegateKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsAfterAsyncKeywordInExpressionContext(CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.DescendingKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.DisableKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.DoKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.DoubleKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    [NullableContextAttribute("1")]
protected virtual bool IsValidContextWorker(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.DynamicKeywordRecommender : object {
    private static bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected static bool IsDynamicTypeContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsAfterRefTypeContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ElifKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ElseKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.EnableKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.EndIfKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.EndRegionKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.EnumKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validModifiers;
    private static EnumKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.EqualsKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ErrorKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.EventKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validClassModifiers;
    private static ISet`1<SyntaxKind> s_validStructModifiers;
    private static EventKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ExplicitKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validNonInterfaceMemberModifiers;
    private static ISet`1<SyntaxKind> s_validInterfaceMemberModifiers;
    private static ExplicitKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ExternKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validModifiers;
    private static ISet`1<SyntaxKind> s_validGlobalModifiers;
    private static ISet`1<SyntaxKind> s_validLocalFunctionModifiers;
    private static ExternKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsExternAliasContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.FalseKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.FieldKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validTypeDeclarations;
    private static FieldKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.FileKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validModifiers;
    private static FileKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.FinallyKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.FixedKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validModifiers;
    private static FixedKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsMemberDeclarationContext(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsUnsafeStatementContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.FloatKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    [NullableContextAttribute("1")]
protected virtual bool IsValidContextWorker(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ForEachKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ForKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.FromKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.GetKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.GlobalKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.GotoKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.GroupKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.HiddenKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.IfKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ImplicitKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validNonInterfaceMemberModifiers;
    private static ISet`1<SyntaxKind> s_validInterfaceMemberModifiers;
    private static ImplicitKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.InitKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.InKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsInParameterModifierContext(int position, CSharpSyntaxContext context);
    private static bool IsValidContextInForEachClause(CSharpSyntaxContext context);
    private static bool IsValidContextInFromClause(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextInJoinClause(CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.InterfaceKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validModifiers;
    private static InterfaceKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.InternalKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForAccessor(CSharpSyntaxContext context);
    private static bool IsValidContextForMember(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForType(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool CheckPreviousAccessibilityModifiers(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.IntKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    [NullableContextAttribute("1")]
protected virtual bool IsValidContextWorker(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.IntoKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForSelect(CSharpSyntaxContext context);
    private static bool IsValidContextForGroup(CSharpSyntaxContext context);
    private static bool IsValidContextForJoin(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.IsKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.JoinKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.LetKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.LineKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.LoadKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.LockKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.LongKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    [NullableContextAttribute("1")]
protected virtual bool IsValidContextWorker(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ManagedKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.MethodKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ModuleKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.NameOfKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.NamespaceKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.NewKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validMemberModifiers;
    protected static ISet`1<SyntaxKind> ValidTypeModifiers;
    private static NewKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsTypeDeclarationContext(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsMemberDeclarationContext(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsNewConstraintContext(CSharpSyntaxContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.NintKeywordRecommender : AbstractNativeIntegerKeywordRecommender {
    protected RecommendedKeyword Keyword { get; }
    protected virtual RecommendedKeyword get_Keyword();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.NotKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.NotNullKeywordRecommender : object {
    [NullableContextAttribute("1")]
public sealed virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.NuintKeywordRecommender : AbstractNativeIntegerKeywordRecommender {
    protected RecommendedKeyword Keyword { get; }
    protected virtual RecommendedKeyword get_Keyword();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.NullableKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.NullKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ObjectKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    [NullableContextAttribute("1")]
protected virtual bool IsValidContextWorker(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.OnKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.OperatorKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.OrderByKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.OrKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.OutKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsOutParameterModifierContext(int position, CSharpSyntaxContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.OverrideKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validMemberModifiers;
    private static OverrideKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ParamKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ParamsKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.PartialKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validMemberModifiers;
    private static PartialKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsMemberDeclarationContext(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsTypeDeclarationContext(CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.PragmaKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.PrivateKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForAccessor(CSharpSyntaxContext context);
    private static bool IsValidContextForMember(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForType(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool CheckPreviousAccessibilityModifiers(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.PropertyKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ProtectedKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForAccessor(CSharpSyntaxContext context);
    private static bool IsValidContextForMember(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForType(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool CheckPreviousAccessibilityModifiers(CSharpSyntaxContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.PublicKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForMember(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForType(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool CheckPreviousAccessibilityModifiers(CSharpSyntaxContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ReadOnlyKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validMemberModifiers;
    private static ReadOnlyKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsRefReadOnlyContext(CSharpSyntaxContext context);
    private static bool IsValidContextForType(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsStructAccessorContext(CSharpSyntaxContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.RecordKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validModifiers;
    private static RecordKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ReferenceKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.RefKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> RefMemberModifiers;
    private static ISet`1<SyntaxKind> RefGlobalMemberModifiers;
    private static ISet`1<SyntaxKind> RefGlobalMemberScriptModifiers;
    private static RefKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsRefParameterModifierContext(int position, CSharpSyntaxContext context);
    private static bool IsValidNewByRefContext(SyntaxTree syntaxTree, int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidRefExpressionContext(CSharpSyntaxContext context);
    private static bool IsValidContextForType(CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.RegionKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.RemoveKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.RequiredKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validModifiers;
    private static ISet`1<SyntaxKind> s_validTypeDeclarations;
    private static RequiredKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.RestoreKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ReturnKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsAttributeContext(CSharpSyntaxContext context, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <IsAttributeContext>g__IsAccessorAttributeContext|2_0(<>c__DisplayClass2_0& );
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.SByteKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    [NullableContextAttribute("1")]
protected virtual bool IsValidContextWorker(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ScopedKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidScopedLocalContext(CSharpSyntaxContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.SealedKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validNonInterfaceMemberModifiers;
    private static ISet`1<SyntaxKind> s_validInterfaceMemberModifiers;
    private static ISet`1<SyntaxKind> s_validTypeModifiers;
    private static SealedKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.SelectKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.SetKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ShortKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    [NullableContextAttribute("1")]
protected virtual bool IsValidContextWorker(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.SizeOfKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.StackAllocKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.StaticKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validTypeModifiers;
    private static ISet`1<SyntaxKind> s_validNonInterfaceMemberModifiers;
    private static ISet`1<SyntaxKind> s_validInterfaceMemberModifiers;
    private static ISet`1<SyntaxKind> s_validGlobalMemberModifiers;
    private static ISet`1<SyntaxKind> s_validLocalFunctionModifiers;
    private static StaticKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForMember(CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsValidContextForType(CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.StringKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    protected virtual SpecialType get_SpecialType();
    [NullableContextAttribute("1")]
protected virtual bool IsValidContextWorker(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.StructKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validModifiers;
    private static StructKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.SwitchKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ThisKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsInstanceExpressionOrStatement(CSharpSyntaxContext context);
    private static bool IsConstructorInitializerContext(CSharpSyntaxContext context);
    private static bool IsThisParameterModifierContext(CSharpSyntaxContext context);
    protected virtual bool ShouldPreselect(CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ThrowKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.TrueKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.TryKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.TypeKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.TypeOfKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsAttributeArgumentContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.TypeVarKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.UIntKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    [NullableContextAttribute("1")]
protected virtual bool IsValidContextWorker(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.ULongKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected SpecialType SpecialType { get; }
    [NullableContextAttribute("1")]
protected virtual bool IsValidContextWorker(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.UncheckedKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.UndefKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.UnmanagedKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.UnsafeKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validTypeModifiers;
    private static ISet`1<SyntaxKind> s_validMemberModifiers;
    private static ISet`1<SyntaxKind> s_validGlobalMemberModifiers;
    private static ISet`1<SyntaxKind> s_validLocalFunctionModifiers;
    private static UnsafeKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.UShortKeywordRecommender : AbstractSpecialTypePreselectingKeywordRecommender {
    protected int DefaultMatchPriority { get; }
    protected SpecialType SpecialType { get; }
    protected virtual int get_DefaultMatchPriority();
    [NullableContextAttribute("1")]
protected virtual bool IsValidContextWorker(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    protected virtual SpecialType get_SpecialType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.UsingKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    internal static bool IsUsingDirectiveContext(CSharpSyntaxContext context, bool forGlobalKeyword, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <IsUsingDirectiveContext>g__IsValidContextAtTheRoot|2_0(CSharpSyntaxContext context, SyntaxToken originalToken, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.VarKeywordRecommender : object {
    private static bool IsValidContext(CSharpSyntaxContext context);
    public sealed virtual ImmutableArray`1<RecommendedKeyword> RecommendKeywords(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.VirtualKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validNonInterfaceMemberModifiers;
    private static ISet`1<SyntaxKind> s_validInterfaceMemberModifiers;
    private static VirtualKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.VoidKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validClassInterfaceRecordModifiers;
    private static ISet`1<SyntaxKind> s_validStructModifiers;
    private static VoidKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsUnsafeDefaultExpressionContext(CSharpSyntaxContext context);
    private static bool IsUnsafeCastTypeContext(CSharpSyntaxContext context);
    private static bool IsUnsafeParameterTypeContext(CSharpSyntaxContext context);
    private static bool IsUnsafeLocalVariableDeclarationContext(CSharpSyntaxContext context);
    private static bool IsUnsafeUsingDirectiveContext(CSharpSyntaxContext context);
    private static bool IsMemberReturnTypeContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.VolatileKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    private static ISet`1<SyntaxKind> s_validMemberModifiers;
    private static VolatileKeywordRecommender();
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.WarningKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.WarningsKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.WhenKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsAtEndOfPatternInSwitchExpression(CSharpSyntaxContext context);
    private static bool IsAfterCompleteExpressionOrPatternInCaseLabel(CSharpSyntaxContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.WhereKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
    private static bool IsTypeParameterConstraintContext(CSharpSyntaxContext context);
    private static bool IsQueryContext(CSharpSyntaxContext context);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.WhileKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.WithKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Completion.KeywordRecommenders.YieldKeywordRecommender : AbstractSyntacticSingleKeywordRecommender {
    [NullableContextAttribute("1")]
protected virtual bool IsValidContext(int position, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("AggregateEmbeddedLanguageCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.AggregateEmbeddedLanguageCompletionProvider : AbstractAggregateEmbeddedLanguageCompletionProvider {
    internal string Language { get; }
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public AggregateEmbeddedLanguageCompletionProvider(IEnumerable`1<Lazy`2<ILanguageService, LanguageServiceMetadata>> languageServices);
    internal virtual string get_Language();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("AttributeNamedParameterCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.AttributeNamedParameterCompletionProvider : LSPCompletionProvider {
    private static string EqualsString;
    private static string SpaceEqualsString;
    private static string ColonString;
    private static CompletionItemRules _spaceItemFilterRule;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static AttributeNamedParameterCompletionProvider();
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.AttributeNamedParameterCompletionProvider/<ProvideCompletionsAsync>d__11")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    private static bool IsAfterNameColonArgument(SyntaxToken token);
    private static bool IsAfterNameEqualsArgument(SyntaxToken token);
    private static ImmutableArray`1<CompletionItem> GetNameEqualsItems(CompletionContext context, SemanticModel semanticModel, SyntaxToken token, AttributeSyntax attributeSyntax, ISet`1<string> existingNamedParameters);
    private static IEnumerable`1<CompletionItem> GetNameColonItems(CompletionContext context, SemanticModel semanticModel, SyntaxToken token, AttributeSyntax attributeSyntax, ISet`1<string> existingNamedParameters);
    internal virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    private static bool IsValid(ImmutableArray`1<IParameterSymbol> parameterList, ISet`1<string> existingNamedParameters);
    private static ISet`1<string> GetExistingNamedParameters(AttributeArgumentListSyntax argumentList, int position);
    private static IEnumerable`1<ImmutableArray`1<IParameterSymbol>> GetParameterLists(SemanticModel semanticModel, int position, AttributeSyntax attribute, CancellationToken cancellationToken);
    private static IEnumerable`1<ISymbol> GetAttributeNamedParameters(SemanticModel semanticModel, int position, AttributeSyntax attribute, CancellationToken cancellationToken);
    protected virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
    private static Nullable`1<TextChange> GetTextChange(CompletionItem selectedItem, Nullable`1<char> ch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("AwaitCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.AwaitCompletionProvider : AbstractAwaitCompletionProvider {
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal virtual string get_Language();
    public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual bool IsAwaitKeywordContext(SyntaxContext syntaxContext);
    protected virtual int GetSpanStart(SyntaxNode declaration);
    [NullableContextAttribute("2")]
protected virtual SyntaxNode GetAsyncSupportingDeclaration(SyntaxToken token);
    protected virtual SyntaxNode GetExpressionToPlaceAwaitInFrontOf(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    protected virtual Nullable`1<SyntaxToken> GetDotTokenLeftOfPosition(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    protected virtual ITypeSymbol GetTypeSymbolOfExpression(SemanticModel semanticModel, SyntaxNode potentialAwaitableExpression, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.Completion.Providers.CompletionUtilities : object {
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<char> <CommonTriggerCharacters>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<char> <CommonTriggerCharactersWithArgumentList>k__BackingField;
    internal static ImmutableHashSet`1<char> CommonTriggerCharacters { get; }
    internal static ImmutableHashSet`1<char> CommonTriggerCharactersWithArgumentList { get; }
    internal static ImmutableHashSet`1<char> SpaceTriggerCharacter { get; }
    private static CompletionUtilities();
    internal static TextSpan GetCompletionItemSpan(SourceText text, int position);
    public static bool IsWordStartCharacter(char ch);
    public static bool IsWordCharacter(char ch);
    public static bool IsCompletionItemStartCharacter(char ch);
    public static bool TreatAsDot(SyntaxToken token, int characterPosition);
    public static Nullable`1<SyntaxToken> GetDotTokenLeftOfPosition(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    internal static bool IsTriggerCharacter(SourceText text, int characterPosition, CompletionOptions& options);
    internal static bool IsCompilerDirectiveTriggerCharacter(SourceText text, int characterPosition);
    [CompilerGeneratedAttribute]
internal static ImmutableHashSet`1<char> get_CommonTriggerCharacters();
    [CompilerGeneratedAttribute]
internal static ImmutableHashSet`1<char> get_CommonTriggerCharactersWithArgumentList();
    internal static bool IsTriggerCharacterOrArgumentListCharacter(SourceText text, int characterPosition, CompletionOptions& options);
    private static bool IsArgumentListCharacter(SourceText text, int characterPosition);
    internal static bool IsArgumentListCharacter(char ch);
    internal static bool IsTriggerAfterSpaceOrStartOfWordCharacter(SourceText text, int characterPosition, CompletionOptions& options);
    internal static ImmutableHashSet`1<char> get_SpaceTriggerCharacter();
    private static bool SpaceTypedNotBeforeWord(char ch, SourceText text, int characterPosition);
    public static bool IsStartingNewWord(SourceText text, int characterPosition);
    public static ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(ISymbol symbol, SyntaxContext context);
    public static string GetInsertionText(ISymbol symbol, SyntaxContext context);
    public static int GetTargetCaretPositionForMethod(MethodDeclarationSyntax methodDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportArgumentProviderAttribute("ContextVariableArgumentProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.ContextVariableArgumentProvider : AbstractContextVariableArgumentProvider {
    protected string ThisOrMeKeyword { get; }
    protected virtual string get_ThisOrMeKeyword();
    protected virtual bool IsInstanceContext(SyntaxTree syntaxTree, SyntaxToken targetToken, SemanticModel semanticModel, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.ContextVariableArgumentProvider/<ProvideArgumentAsync>d__4")]
public virtual Task ProvideArgumentAsync(ArgumentContext context);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(ArgumentContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("CrefCompletionProvider", "C#")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.CrefCompletionProvider : AbstractCrefCompletionProvider {
    private static SymbolDisplayFormat QualifiedCrefFormat;
    private static SymbolDisplayFormat CrefFormat;
    private static SymbolDisplayFormat MinimalParameterTypeFormat;
    [NullableAttribute("2")]
private Action`1<SyntaxNode> _testSpeculativeNodeCallback;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    private static CharacterSetModificationRule s_WithoutOpenBrace;
    private static CharacterSetModificationRule s_WithoutOpenParen;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static CrefCompletionProvider();
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.CrefCompletionProvider/<ProvideCompletionsAsync>d__11")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.CrefCompletionProvider/<GetSymbolsAsync>d__12")]
protected virtual Task`1<ValueTuple`3<SyntaxToken, SemanticModel, ImmutableArray`1<ISymbol>>> GetSymbolsAsync(Document document, int position, CompletionOptions options, CancellationToken cancellationToken);
    private static bool IsCrefStartContext(SyntaxToken token);
    private static bool IsCrefParameterListContext(SyntaxToken token);
    private static bool IsCrefQualifiedNameContext(SyntaxToken token);
    private static ImmutableArray`1<ISymbol> GetSymbols(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ImmutableArray`1<ISymbol> GetUnqualifiedSymbols(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ImmutableArray`1<ISymbol> GetQualifiedSymbols(QualifiedCrefSyntax parent, SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static TextSpan GetCompletionItemSpan(SourceText text, int position);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.CrefCompletionProvider/<CreateCompletionItems>d__20")]
private static IEnumerable`1<CompletionItem> CreateCompletionItems(SemanticModel semanticModel, ImmutableArray`1<ISymbol> symbols, SyntaxToken token, int position, ImmutableArray`1<KeyValuePair`2<string, string>> options);
    private static bool TryCreateSpecialTypeItem(SemanticModel semanticModel, ISymbol symbol, SyntaxToken token, int position, StringBuilder builder, ImmutableArray`1<KeyValuePair`2<string, string>> options, CompletionItem& item);
    private static CompletionItem CreateItem(SemanticModel semanticModel, ISymbol symbol, int groupCount, SyntaxToken token, int position, StringBuilder builder, string sortText, ImmutableArray`1<KeyValuePair`2<string, string>> options, SymbolDisplayFormat unqualifiedCrefFormat);
    private static CompletionItem CreateItemFromBuilder(ISymbol symbol, int position, StringBuilder builder, string sortText, ImmutableArray`1<KeyValuePair`2<string, string>> options);
    private static CompletionItemRules GetRules(string displayText);
    protected virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
    internal TestAccessor GetTestAccessor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("CSharpSuggestionModeCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.CSharpSuggestionModeCompletionProvider : AbstractSuggestionModeCompletionProvider {
    internal string Language { get; }
    internal virtual string get_Language();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.CSharpSuggestionModeCompletionProvider/<GetSuggestionModeItemAsync>d__3")]
protected virtual Task`1<CompletionItem> GetSuggestionModeItemAsync(Document document, int position, TextSpan itemSpan, CompletionTrigger trigger, CancellationToken cancellationToken);
    private static bool IsAnonymousObjectCreation(SyntaxToken token);
    private static bool IsLambdaExpression(SemanticModel semanticModel, SyntaxTree tree, int position, SyntaxToken token, ITypeInferenceService typeInferrer, CancellationToken cancellationToken);
    private static ITypeSymbol GetDelegateType(TypeInferenceInfo typeInferenceInfo, Compilation compilation);
    private static bool IsPotentialPatternVariableDeclaration(SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportDeclarationNameRecommenderAttribute("DeclarationNameRecommender")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.DeclarationName.DeclarationNameRecommender : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.DeclarationName.DeclarationNameRecommender/<ProvideRecommendedNamesAsync>d__1")]
public sealed virtual Task`1<ImmutableArray`1<ValueTuple`2<string, Glyph>>> ProvideRecommendedNamesAsync(CompletionContext completionContext, Document document, CSharpSyntaxContext context, NameDeclarationInfo nameInfo, CancellationToken cancellationToken);
    private ImmutableArray`1<ImmutableArray`1<string>> GetBaseNames(SemanticModel semanticModel, NameDeclarationInfo nameInfo);
    [NullableContextAttribute("2")]
private static bool IsValidType(ITypeSymbol type);
    private ValueTuple`2<ITypeSymbol, bool> UnwrapType(ITypeSymbol type, Compilation compilation, bool wasPlural, HashSet`1<ITypeSymbol> seenTypes);
    private bool LooksLikeWellKnownCollectionType(Compilation compilation, string name);
    private static void GetRecommendedNames(ImmutableArray`1<ImmutableArray`1<string>> baseNames, NameDeclarationInfo declarationInfo, CSharpSyntaxContext context, ArrayBuilder`1<ValueTuple`2<string, Glyph>> result, NamingStylePreferences namingStyleOptions, CancellationToken cancellationToken);
    private static void AddNamesFromExistingOverloads(CSharpSyntaxContext context, NameDeclarationInfo declarationInfo, ArrayBuilder`1<ValueTuple`2<string, Glyph>> result, CancellationToken cancellationToken);
    private static bool IsRelevantSymbolKind(ISymbol symbol);
    private static bool CanRemovePrefix(string name, char prefix);
    [CompilerGeneratedAttribute]
internal static bool <LooksLikeWellKnownCollectionType>g__Check|5_0(INamespaceSymbol namespaceSymbol, string name);
    [CompilerGeneratedAttribute]
internal static void <GetRecommendedNames>g__ProcessRules|6_0(ImmutableArray`1<NamingRule> rules, bool firstMatchOnly, SymbolKindOrTypeKind kind, ImmutableArray`1<ImmutableArray`1<string>> baseNames, NameDeclarationInfo declarationInfo, CSharpSyntaxContext context, ArrayBuilder`1<ValueTuple`2<string, Glyph>> result, ISemanticFactsService semanticFactsService, PooledHashSet`1<string> seenBaseNames, PooledHashSet`1<string> seenUniqueNames, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<IMethodSymbol> <AddNamesFromExistingOverloads>g__GetOverloads|7_2(INamedTypeSymbol namedType, BaseMethodDeclarationSyntax baseMethod);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.DeclarationName.ExportDeclarationNameRecommenderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public ExportDeclarationNameRecommenderAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CSharp.Completion.Providers.DeclarationName.IDeclarationNameRecommender {
    public abstract virtual Task`1<ImmutableArray`1<ValueTuple`2<string, Glyph>>> ProvideRecommendedNamesAsync(CompletionContext completionContext, Document document, CSharpSyntaxContext context, NameDeclarationInfo nameInfo, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.DeclarationName.NameDeclarationInfo : ValueType {
    [NullableAttribute("0")]
private static ImmutableArray`1<SymbolKindOrTypeKind> s_parameterSyntaxKind;
    [NullableAttribute("0")]
private static ImmutableArray`1<SymbolKindOrTypeKind> s_propertySyntaxKind;
    [NullableAttribute("0")]
private ImmutableArray`1<SymbolKindOrTypeKind> _possibleSymbolKinds;
    public DeclarationModifiers Modifiers;
    public Nullable`1<Accessibility> DeclaredAccessibility;
    [NullableAttribute("2")]
public ITypeSymbol Type;
    [NullableAttribute("2")]
public IAliasSymbol Alias;
    [NullableAttribute("2")]
public ISymbol Symbol;
    [NullableAttribute("0")]
public ImmutableArray`1<SymbolKindOrTypeKind> PossibleSymbolKinds { get; }
    [NullableContextAttribute("2")]
public NameDeclarationInfo(ImmutableArray`1<SymbolKindOrTypeKind> possibleSymbolKinds, Nullable`1<Accessibility> accessibility, DeclarationModifiers declarationModifiers, ITypeSymbol type, IAliasSymbol alias, ISymbol symbol);
    private static NameDeclarationInfo();
    [NullableContextAttribute("0")]
public ImmutableArray`1<SymbolKindOrTypeKind> get_PossibleSymbolKinds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.DeclarationName.NameDeclarationInfo/<GetDeclarationInfoAsync>d__11")]
public static Task`1<NameDeclarationInfo> GetDeclarationInfoAsync(Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.DeclarationName.NameDeclarationInfo/<GetDeclarationInfoWorkerAsync>d__12")]
private static Task`1<NameDeclarationInfo> GetDeclarationInfoWorkerAsync(Document document, int position, CancellationToken cancellationToken);
    private static bool IsTupleTypeElement(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, NameDeclarationInfo& result);
    private static bool IsTupleLiteralElement(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, NameDeclarationInfo& result);
    private static bool IsPossibleOutVariableDeclaration(SyntaxToken token, SemanticModel semanticModel, ITypeInferenceService typeInferenceService, CancellationToken cancellationToken, NameDeclarationInfo& result);
    private static bool IsPossibleLocalVariableOrFunctionDeclaration(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, NameDeclarationInfo& result);
    private static bool IsPropertyDeclaration(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, NameDeclarationInfo& result);
    private static bool IsMethodDeclaration(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, NameDeclarationInfo& result);
    private static NameDeclarationInfo IsFollowingTypeOrComma(SyntaxToken token, SemanticModel semanticModel, Func`2<TSyntaxNode, SyntaxNode> typeSyntaxGetter, Func`2<TSyntaxNode, Nullable`1<SyntaxTokenList>> modifierGetter, Func`2<DeclarationModifiers, ImmutableArray`1<SymbolKindOrTypeKind>> possibleDeclarationComputer, CancellationToken cancellationToken);
    private static NameDeclarationInfo IsLastTokenOfType(SyntaxToken token, SemanticModel semanticModel, Func`2<TSyntaxNode, SyntaxNode> typeSyntaxGetter, Func`2<TSyntaxNode, SyntaxTokenList> modifierGetter, Func`2<DeclarationModifiers, ImmutableArray`1<SymbolKindOrTypeKind>> possibleDeclarationComputer, CancellationToken cancellationToken);
    private static NameDeclarationInfo IsLastTokenOfType(SyntaxToken token, SemanticModel semanticModel, Func`2<TSyntaxNode, SyntaxNode> typeSyntaxGetter, Func`2<TSyntaxNode, SyntaxTokenList> modifierGetter, Func`2<DeclarationModifiers, ImmutableArray`1<SymbolKindOrTypeKind>> possibleDeclarationComputer, CancellationToken cancellationToken, SyntaxNode& typeSyntax);
    private static bool IsFieldDeclaration(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, NameDeclarationInfo& result);
    private static bool IsIncompleteMemberDeclaration(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, NameDeclarationInfo& result);
    private static bool IsLocalFunctionDeclaration(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, NameDeclarationInfo& result);
    private static bool IsLocalVariableDeclaration(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, NameDeclarationInfo& result);
    private static bool IsEmbeddedVariableDeclaration(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, NameDeclarationInfo& result);
    private static bool IsForEachVariableDeclaration(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, NameDeclarationInfo& result);
    private static bool IsTypeParameterDeclaration(SyntaxToken token, NameDeclarationInfo& result);
    private static bool IsPrimaryConstructorParameter(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, NameDeclarationInfo& result);
    private static bool IsParameterDeclaration(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, NameDeclarationInfo& result);
    private static bool IsPatternMatching(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken, NameDeclarationInfo& result);
    private static bool IsPossibleTypeToken(SyntaxToken token);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<SymbolKindOrTypeKind> GetPossibleMemberDeclarations(DeclarationModifiers modifiers);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<SymbolKindOrTypeKind> GetPossibleLocalDeclarations(DeclarationModifiers modifiers);
    private static DeclarationModifiers GetDeclarationModifiers(SyntaxTokenList modifiers);
    private static Nullable`1<Accessibility> GetAccessibility(SyntaxTokenList modifiers);
    private static SyntaxNode GetNodeDenotingTheTypeOfTupleArgument(ArgumentSyntax argumentSyntax);
    public static Glyph GetGlyph(SymbolKind kind, Nullable`1<Accessibility> declaredAccessibility);
    public static SymbolKind GetSymbolKind(SymbolKindOrTypeKind symbolKindOrTypeKind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("DeclarationNameCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.DeclarationNameCompletionProvider : LSPCompletionProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<Lazy`2<IDeclarationNameRecommender, OrderableMetadata>> <Recommenders>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<Lazy`2<IDeclarationNameRecommender, OrderableMetadata>> Recommenders { get; }
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public DeclarationNameCompletionProvider(IEnumerable`1<Lazy`2<IDeclarationNameRecommender, OrderableMetadata>> recommenders);
    [CompilerGeneratedAttribute]
private ImmutableArray`1<Lazy`2<IDeclarationNameRecommender, OrderableMetadata>> get_Recommenders();
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int insertedCharacterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.DeclarationNameCompletionProvider/<ProvideCompletionsAsync>d__10")]
public virtual Task ProvideCompletionsAsync(CompletionContext completionContext);
    private static CompletionItem CreateCompletionItem(string name, Glyph glyph, string sortText);
}
[ExportArgumentProviderAttribute("DefaultArgumentProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.DefaultArgumentProvider : AbstractDefaultArgumentProvider {
    [NullableContextAttribute("1")]
public virtual Task ProvideArgumentAsync(ArgumentContext context);
}
internal static class Microsoft.CodeAnalysis.CSharp.Completion.Providers.DirectiveCompletionProviderUtilities : object {
    [NullableContextAttribute("1")]
internal static bool TryGetStringLiteralToken(SyntaxTree tree, int position, SyntaxKind directiveKind, SyntaxToken& stringLiteral, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("EnumAndCompletionListTagCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.EnumAndCompletionListTagCompletionProvider : LSPCompletionProvider {
    private static CompletionItemRules s_enumTypeRules;
    private static ImmutableHashSet`1<char> s_triggerCharacters;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static EnumAndCompletionListTagCompletionProvider();
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.EnumAndCompletionListTagCompletionProvider/<ProvideCompletionsAsync>d__8")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.EnumAndCompletionListTagCompletionProvider/<HandleSingleTypeAsync>d__9")]
private static Task HandleSingleTypeAsync(CompletionContext context, SemanticModel semanticModel, SyntaxToken token, ITypeSymbol type, bool isParams, CancellationToken cancellationToken);
    private static ITypeSymbol TryGetEnumTypeInEnumInitializer(SemanticModel semanticModel, SyntaxToken token, ITypeSymbol type, CancellationToken cancellationToken);
    internal virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    private static INamedTypeSymbol TryGetCompletionListType(ITypeSymbol type, INamedTypeSymbol within, Compilation compilation);
    private static INamedTypeSymbol TryGetTypeWithStaticMembers(ITypeSymbol type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("ExplicitInterfaceMemberCompletionProvider", "C#")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.ExplicitInterfaceMemberCompletionProvider : LSPCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.ExplicitInterfaceMemberCompletionProvider/<ProvideCompletionsAsync>d__8")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    private static ValueTuple`2<string, string> SplitMemberName(string memberString);
    internal virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(Document document, CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCompletionProviderAttribute("ExplicitInterfaceTypeCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.ExplicitInterfaceTypeCompletionProvider : AbstractSymbolCompletionProvider`1<CSharpSyntaxContext> {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int insertedCharacterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(ISymbol symbol, CSharpSyntaxContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.ExplicitInterfaceTypeCompletionProvider/<ProvideCompletionsAsync>d__8")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    protected virtual Task`1<ImmutableArray`1<SymbolAndSelectionInfo<CSharpSyntaxContext>>> GetSymbolsAsync(CompletionContext completionContext, CSharpSyntaxContext context, int position, CompletionOptions options, CancellationToken cancellationToken);
    private static bool IsPreviousTokenValid(SyntaxToken tokenBeforeType);
    private static bool IsClassOrStructOrInterfaceOrRecord(SyntaxNode node);
    protected virtual CompletionItem CreateItem(CompletionContext completionContext, string displayText, string displayTextSuffix, string insertionText, ImmutableArray`1<SymbolAndSelectionInfo<CSharpSyntaxContext>> symbols, CSharpSyntaxContext context, SupportedPlatformData supportedPlatformData);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(CompletionContext completionContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("ExtensionMethodImportCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.ExtensionMethodImportCompletionProvider : AbstractExtensionMethodImportCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    internal string Language { get; }
    protected string GenericSuffix { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal virtual string get_Language();
    protected virtual string get_GenericSuffix();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual bool IsFinalSemicolonOfUsingOrExtern(SyntaxNode directive, SyntaxToken token);
    protected virtual Task`1<bool> ShouldProvideParenthesisCompletionAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("ExternAliasCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.ExternAliasCompletionProvider : LSPCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.ExternAliasCompletionProvider/<ProvideCompletionsAsync>d__7")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
}
[ExportArgumentProviderAttribute("FirstBuiltInArgumentProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.FirstBuiltInArgumentProvider : ArgumentProvider {
    [NullableContextAttribute("1")]
public virtual Task ProvideArgumentAsync(ArgumentContext context);
}
[ExportCompletionProviderAttribute("FirstBuiltInCompletionProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.FirstBuiltInCompletionProvider : CompletionProvider {
    [NullableContextAttribute("1")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("FunctionPointerUnmanagedCallingConventionCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.FunctionPointerUnmanagedCallingConventionCompletionProvider : LSPCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_predefinedCallingConventions;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static FunctionPointerUnmanagedCallingConventionCompletionProvider();
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.FunctionPointerUnmanagedCallingConventionCompletionProvider/<ProvideCompletionsAsync>d__8")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    private static void AddTypes(HashSet`1<CompletionItem> completionItems, int contextPosition, SemanticModel semanticModel, CancellationToken cancellationToken);
    internal virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("InternalsVisibleToCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.InternalsVisibleToCompletionProvider : AbstractInternalsVisibleToCompletionProvider {
    internal string Language { get; }
    internal virtual string get_Language();
    protected virtual IImmutableList`1<SyntaxNode> GetAssemblyScopedAttributeSyntaxNodesOfDocument(SyntaxNode documentRoot);
    protected virtual SyntaxNode GetConstructorArgumentOfInternalsVisibleToAttribute(SyntaxNode internalsVisibleToAttribute);
    protected virtual bool ShouldTriggerAfterQuotes(SourceText text, int insertedCharacterPosition);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCompletionProviderAttribute("KeywordCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.KeywordCompletionProvider : AbstractKeywordCompletionProvider`1<CSharpSyntaxContext> {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    private static CompletionItemRules s_tupleRules;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static KeywordCompletionProvider();
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual CompletionItem CreateItem(RecommendedKeyword keyword, CSharpSyntaxContext context, CancellationToken cancellationToken);
}
[ExportArgumentProviderAttribute("LastBuiltInArgumentProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.LastBuiltInArgumentProvider : ArgumentProvider {
    [NullableContextAttribute("1")]
public virtual Task ProvideArgumentAsync(ArgumentContext context);
}
[ExportCompletionProviderAttribute("LastBuiltInCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.LastBuiltInCompletionProvider : CompletionProvider {
    [NullableContextAttribute("1")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("LoadDirectiveCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.LoadDirectiveCompletionProvider : AbstractLoadDirectiveCompletionProvider {
    protected string DirectiveName { get; }
    protected virtual string get_DirectiveName();
    protected virtual bool TryGetStringLiteralToken(SyntaxTree tree, int position, SyntaxToken& stringLiteral, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("NamedParameterCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.NamedParameterCompletionProvider : LSPCompletionProvider {
    private static string ColonString;
    private static CompletionItemRules s_rules;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static NamedParameterCompletionProvider();
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.NamedParameterCompletionProvider/<ProvideCompletionsAsync>d__9")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    internal virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    private static bool IsValid(ImmutableArray`1<IParameterSymbol> parameterList, ISet`1<string> existingNamedParameters);
    private static ISet`1<string> GetExistingNamedParameters(BaseArgumentListSyntax argumentList, int position);
    private static IEnumerable`1<ImmutableArray`1<IParameterSymbol>> GetParameterLists(SemanticModel semanticModel, int position, SyntaxNode invocableNode, CancellationToken cancellationToken);
    private static IEnumerable`1<ImmutableArray`1<IParameterSymbol>> GetObjectCreationExpressionParameterLists(SemanticModel semanticModel, int position, BaseObjectCreationExpressionSyntax objectCreationExpression, CancellationToken cancellationToken);
    private static IEnumerable`1<ImmutableArray`1<IParameterSymbol>> GetElementAccessExpressionParameterLists(SemanticModel semanticModel, int position, ElementAccessExpressionSyntax elementAccessExpression, CancellationToken cancellationToken);
    private static IEnumerable`1<ImmutableArray`1<IParameterSymbol>> GetConstructorInitializerParameterLists(SemanticModel semanticModel, int position, ConstructorInitializerSyntax constructorInitializer, CancellationToken cancellationToken);
    private static IEnumerable`1<ImmutableArray`1<IParameterSymbol>> GetPrimaryConstructorParameterLists(SemanticModel semanticModel, PrimaryConstructorBaseTypeSyntax baseType, CancellationToken cancellationToken);
    private static IEnumerable`1<ImmutableArray`1<IParameterSymbol>> GetInvocationExpressionParameterLists(SemanticModel semanticModel, int position, InvocationExpressionSyntax invocationExpression, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.Generic.IEqualityComparer<Microsoft.CodeAnalysis.IParameterSymbol>.Equals(IParameterSymbol x, IParameterSymbol y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<Microsoft.CodeAnalysis.IParameterSymbol>.GetHashCode(IParameterSymbol obj);
    protected virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("ObjectAndWithInitializerCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.ObjectAndWithInitializerCompletionProvider : AbstractObjectInitializerCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal virtual string get_Language();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.ObjectAndWithInitializerCompletionProvider/<IsExclusiveAsync>d__3")]
protected virtual Task`1<bool> IsExclusiveAsync(Document document, int position, CancellationToken cancellationToken);
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual Tuple`2<ITypeSymbol, Location> GetInitializedType(Document document, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    private static ITypeSymbol GetInitializedType(SyntaxToken token, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual HashSet`1<string> GetInitializedMembers(SyntaxTree tree, int position, CancellationToken cancellationToken);
    protected virtual bool IsInitializable(ISymbol member, INamedTypeSymbol containingType);
    protected virtual string EscapeIdentifier(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCompletionProviderAttribute("ObjectCreationCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.ObjectCreationCompletionProvider : AbstractObjectCreationCompletionProvider`1<CSharpSyntaxContext> {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    private static CompletionItemRules s_arrayRules;
    private static CompletionItemRules s_objectRules;
    private static CompletionItemRules s_defaultRules;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static ObjectCreationCompletionProvider();
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual SyntaxNode GetObjectCreationNewExpression(SyntaxTree tree, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.ObjectCreationCompletionProvider/<GetSymbolsAsync>d__8")]
protected virtual Task`1<ImmutableArray`1<SymbolAndSelectionInfo<CSharpSyntaxContext>>> GetSymbolsAsync(CompletionContext completionContext, CSharpSyntaxContext context, int position, CompletionOptions options, CancellationToken cancellationToken);
    protected virtual ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(ISymbol symbol, CSharpSyntaxContext context);
    protected virtual CompletionItemRules GetCompletionItemRules(ImmutableArray`1<SymbolAndSelectionInfo<CSharpSyntaxContext>> symbols);
    protected virtual string GetInsertionText(CompletionItem item, char ch);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<ImmutableArray`1<SymbolAndSelectionInfo<CSharpSyntaxContext>>> <>n__0(CompletionContext completionContext, CSharpSyntaxContext context, int position, CompletionOptions options, CancellationToken cancellationToken);
}
[ExportArgumentProviderAttribute("OutVariableArgumentProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.OutVariableArgumentProvider : ArgumentProvider {
    [NullableContextAttribute("1")]
public virtual Task ProvideArgumentAsync(ArgumentContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("OverrideCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.OverrideCompletionProvider : AbstractOverrideCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal virtual string get_Language();
    protected virtual SyntaxNode GetSyntax(SyntaxToken token);
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual SyntaxToken GetToken(CompletionItem completionItem, SyntaxTree tree, CancellationToken cancellationToken);
    public virtual bool TryDetermineReturnType(SyntaxToken startToken, SemanticModel semanticModel, CancellationToken cancellationToken, ITypeSymbol& returnType, SyntaxToken& nextToken);
    public virtual bool TryDetermineModifiers(SyntaxToken startToken, SourceText text, int startLine, Accessibility& seenAccessibility, DeclarationModifiers& modifiers);
    public virtual SyntaxToken FindStartingToken(SyntaxTree tree, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public virtual ImmutableArray`1<ISymbol> FilterOverrides(ImmutableArray`1<ISymbol> members, ITypeSymbol returnType);
    protected virtual int GetTargetCaretPosition(SyntaxNode caretTarget);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("PartialMethodCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.PartialMethodCompletionProvider : AbstractPartialMethodCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal virtual string get_Language();
    protected virtual bool IncludeAccessibility(IMethodSymbol method, CancellationToken cancellationToken);
    protected virtual SyntaxNode GetSyntax(SyntaxToken token);
    protected virtual int GetTargetCaretPosition(SyntaxNode caretTarget);
    protected virtual SyntaxToken GetToken(CompletionItem completionItem, SyntaxTree tree, CancellationToken cancellationToken);
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual bool IsPartial(IMethodSymbol method);
    protected virtual bool IsPartialMethodCompletionContext(SyntaxTree tree, int position, CancellationToken cancellationToken, DeclarationModifiers& modifiers, SyntaxToken& token);
    private static bool VerifyModifiers(SyntaxTree tree, int position, CancellationToken cancellationToken, DeclarationModifiers& modifiers);
    private static bool IsOnSameLine(SyntaxToken syntaxToken, SyntaxToken touchingToken, SourceText text);
    protected virtual string GetDisplayText(IMethodSymbol method, SemanticModel semanticModel, int position);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCompletionProviderAttribute("PartialTypeCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.PartialTypeCompletionProvider : AbstractPartialTypeCompletionProvider`1<CSharpSyntaxContext> {
    private static string InsertionTextOnLessThan;
    private static SymbolDisplayFormat _symbolFormatWithGenerics;
    private static SymbolDisplayFormat _symbolFormatWithoutGenerics;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static PartialTypeCompletionProvider();
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual SyntaxNode GetPartialTypeSyntaxNode(SyntaxTree tree, int position, CancellationToken cancellationToken);
    protected virtual ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(INamedTypeSymbol symbol, CSharpSyntaxContext context);
    protected virtual IEnumerable`1<INamedTypeSymbol> LookupCandidateSymbols(CSharpSyntaxContext context, INamedTypeSymbol declaredSymbol, CancellationToken cancellationToken);
    private static bool IsPartialTypeDeclaration(SyntaxNode syntax);
    protected virtual ImmutableArray`1<KeyValuePair`2<string, string>> GetProperties(INamedTypeSymbol symbol, CSharpSyntaxContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.PartialTypeCompletionProvider/<GetTextChangeAsync>d__15")]
public virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(Document document, CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Nullable`1<TextChange>> <>n__0(Document document, CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("PreprocessorCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.PreprocessorCompletionProvider : AbstractPreprocessorCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("PropertySubpatternCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.PropertySubpatternCompletionProvider : LSPCompletionProvider {
    private static CompletionItemRules s_rules;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static PropertySubpatternCompletionProvider();
    internal virtual string get_Language();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.PropertySubpatternCompletionProvider/<ProvideCompletionsAsync>d__3")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    private static bool IsFieldOrReadableProperty(ISymbol symbol);
    internal virtual Task`1<CompletionDescription> GetDescriptionWorkerAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    private static ValueTuple`2<PropertyPatternClauseSyntax, ExpressionSyntax> TryGetPropertyPatternClause(SyntaxTree tree, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static ITypeSymbol <ProvideCompletionsAsync>g__GetMemberAccessType|3_1(ITypeSymbol type, ExpressionSyntax expression, Document document, SemanticModel semanticModel, int position);
    [CompilerGeneratedAttribute]
internal static ITypeSymbol <ProvideCompletionsAsync>g__GetMemberType|3_2(ITypeSymbol type, string name, Document document, SemanticModel semanticModel, int position);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<ISymbol> <ProvideCompletionsAsync>g__GetCandidatePropertiesAndFields|3_3(Document document, SemanticModel semanticModel, int position, ITypeSymbol type);
    [CompilerGeneratedAttribute]
internal static bool <TryGetPropertyPatternClause>g__IsExtendedPropertyPattern|11_0(MemberAccessExpressionSyntax memberAccess, PropertyPatternClauseSyntax& propertyPatternClause);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("ReferenceDirectiveCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.ReferenceDirectiveCompletionProvider : AbstractReferenceDirectiveCompletionProvider {
    protected string DirectiveName { get; }
    protected virtual string get_DirectiveName();
    protected virtual bool TryGetStringLiteralToken(SyntaxTree tree, int position, SyntaxToken& stringLiteral, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("SnippetCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.SnippetCompletionProvider : LSPCompletionProvider {
    private static HashSet`1<string> s_snippetsWithReplacements;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    internal bool IsSnippetProvider { get; }
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static SnippetCompletionProvider();
    internal virtual bool get_IsSnippetProvider();
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.SnippetCompletionProvider/<ProvideCompletionsAsync>d__10")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.SnippetCompletionProvider/<GetSnippetsForDocumentAsync>d__11")]
private static Task`1<ImmutableArray`1<CompletionItem>> GetSnippetsForDocumentAsync(Document document, CompletionContext completionContext, CancellationToken cancellationToken);
    private static ImmutableArray`1<CompletionItem> GetSnippetCompletionItems(CompletionContext context, SolutionServices services, SemanticModel semanticModel, bool isPreProcessorContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("SpeculativeTCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.SpeculativeTCompletionProvider : LSPCompletionProvider {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.SpeculativeTCompletionProvider/<ProvideCompletionsAsync>d__7")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.SpeculativeTCompletionProvider/<ShouldShowSpeculativeTCompletionItemAsync>d__8")]
private static Task`1<bool> ShouldShowSpeculativeTCompletionItemAsync(Document document, CompletionContext completionContext, CancellationToken cancellationToken);
    private static bool IsStartOfSpeculativeTContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    private static int WalkOutOfGenericType(SyntaxTree syntaxTree, int position, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static int WalkOutOfRefType(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    private static int WalkOutOfTupleType(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCompletionProviderAttribute("SymbolCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.SymbolCompletionProvider : AbstractRecommendationServiceBasedCompletionProvider`1<CSharpSyntaxContext> {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<ValueTuple`3<bool, bool, bool>, CompletionItemRules> s_cachedRules;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal string Language { get; }
    protected CompletionItemSelectionBehavior PreselectedItemSelectionBehavior { get; }
    private static SymbolCompletionProvider();
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    internal virtual string get_Language();
    protected virtual CompletionItemSelectionBehavior get_PreselectedItemSelectionBehavior();
    protected virtual string GetFilterText(ISymbol symbol, string displayText, CSharpSyntaxContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.SymbolCompletionProvider/<ShouldPreselectInferredTypesAsync>d__11")]
protected virtual Task`1<bool> ShouldPreselectInferredTypesAsync(CompletionContext context, int position, CompletionOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.SymbolCompletionProvider/<ShouldProvideAvailableSymbolsInCurrentContextAsync>d__12")]
protected virtual Task`1<bool> ShouldProvideAvailableSymbolsInCurrentContextAsync(CompletionContext completionContext, CSharpSyntaxContext context, int position, CompletionOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.SymbolCompletionProvider/<IsTriggeredInArgumentListAsync>d__13")]
private static Task`1<bool> IsTriggeredInArgumentListAsync(CompletionContext completionContext, int position, CompletionOptions options, CancellationToken cancellationToken);
    protected virtual bool IsInstrinsic(ISymbol s);
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.SymbolCompletionProvider/<IsSyntacticTriggerCharacterAsync>d__16")]
internal virtual Task`1<bool> IsSyntacticTriggerCharacterAsync(Document document, int caretPosition, CompletionTrigger trigger, CompletionOptions options, CancellationToken cancellationToken);
    protected virtual bool IsTriggerOnDot(SyntaxToken token, int characterPosition);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.SymbolCompletionProvider/<IsTriggerInArgumentListAsync>d__18")]
private static Task`1<Nullable`1<bool>> IsTriggerInArgumentListAsync(Document document, int characterPosition, CancellationToken cancellationToken);
    protected virtual ValueTuple`3<string, string, string> GetDisplayAndSuffixAndInsertionText(ISymbol symbol, CSharpSyntaxContext context);
    protected virtual CompletionItemRules GetCompletionItemRules(ImmutableArray`1<SymbolAndSelectionInfo<CSharpSyntaxContext>> symbols, CSharpSyntaxContext context);
    protected virtual CompletionItem CreateItem(CompletionContext completionContext, string displayText, string displayTextSuffix, string insertionText, ImmutableArray`1<SymbolAndSelectionInfo<CSharpSyntaxContext>> symbols, CSharpSyntaxContext context, SupportedPlatformData supportedPlatformData);
    protected virtual string GetInsertionText(CompletionItem item, char ch);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static CompletionItemRules <.cctor>g__MakeRule|1_0(ValueTuple`3<bool, bool, bool> context);
    [CompilerGeneratedAttribute]
internal static bool <ShouldProvideAvailableSymbolsInCurrentContextAsync>g__IsTopNodeInPrimaryConstructorArgumentList|12_0(<>c__DisplayClass12_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("TupleNameCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.TupleNameCompletionProvider : LSPCompletionProvider {
    private static string ColonString;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal virtual string get_Language();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.TupleNameCompletionProvider/<ProvideCompletionsAsync>d__4")]
public virtual Task ProvideCompletionsAsync(CompletionContext completionContext);
    private static Nullable`1<int> GetElementIndex(CSharpSyntaxContext context);
    private static void AddItems(ImmutableArray`1<INamedTypeSymbol> inferredTypes, int index, CompletionContext context, int spanStart);
    protected virtual Task`1<Nullable`1<TextChange>> GetTextChangeAsync(CompletionItem selectedItem, Nullable`1<char> ch, CancellationToken cancellationToken);
    public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCompletionProviderAttribute("TypeImportCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.TypeImportCompletionProvider : AbstractTypeImportCompletionProvider`1<UsingDirectiveSyntax> {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    protected virtual bool IsFinalSemicolonOfUsingOrExtern(SyntaxNode directive, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.TypeImportCompletionProvider/<ShouldProvideParenthesisCompletionAsync>d__8")]
protected virtual Task`1<bool> ShouldProvideParenthesisCompletionAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    protected virtual ImmutableArray`1<UsingDirectiveSyntax> GetAliasDeclarationNodes(SyntaxNode node);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.Completion.Providers.ITypeImportCompletionService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.TypeImportCompletionServiceFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCompletionProviderAttribute("UnnamedSymbolCompletionProvider", "C#")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider : LSPCompletionProvider {
    private static string SortingPrefix;
    internal static string KindName;
    internal static string IndexerKindName;
    internal static string OperatorKindName;
    internal static string ConversionKindName;
    private static string DocumentationCommentXmlName;
    private static int ConversionSortingGroupIndex;
    private static string RehydrateName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<KeyValuePair`2<string, string>> s_conversionProperties;
    private static CompletionItemRules s_conversionRules;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<KeyValuePair`2<string, string>> IndexerProperties;
    private int OperatorSortingGroupIndex;
    private string OperatorName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<KeyValuePair`2<string, string>> OperatorProperties;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<ValueTuple`2<string, OperatorPosition>> s_operatorInfo;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, ValueTuple`2<int, OperatorPosition>> s_operatorNameToInfo;
    private static CompletionItemRules s_operatorRules;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static UnnamedSymbolCompletionProvider();
    internal virtual string get_Language();
    public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    public virtual bool IsInsertionTrigger(SourceText text, int insertedCharacterPosition, CompletionOptions options);
    private static string SortText(int sortingGroupIndex, string sortTextSymbolPart);
    [NullableContextAttribute("0")]
private static ValueTuple`2<SyntaxToken, int> GetDotAndExpressionStart(SyntaxNode root, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider/<ProvideCompletionsAsync>d__14")]
public virtual Task ProvideCompletionsAsync(CompletionContext context);
    private void AddUnnamedSymbols(CompletionContext context, int position, SemanticModel semanticModel, ImmutableArray`1<ISymbol> unnamedSymbols, CancellationToken cancellationToken);
    public virtual Task`1<CompletionChange> GetChangeAsync(Document document, CompletionItem item, Nullable`1<char> commitKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider/<GetDescriptionAsync>d__17")]
internal virtual Task`1<CompletionDescription> GetDescriptionAsync(Document document, CompletionItem item, CompletionOptions options, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    private static Task`1<CompletionChange> ReplaceTextAfterOperatorAsync(Document document, CompletionItem item, string text, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider/<ReplaceTextAfterOperatorAsync>d__19")]
private static Task`1<CompletionChange> ReplaceTextAfterOperatorAsync(Document document, CompletionItem item, string text, bool keepQuestion, int positionOffset, CancellationToken cancellationToken);
    private static void AddConversion(CompletionContext context, SemanticModel semanticModel, int position, IMethodSymbol conversion);
    private static ValueTuple`2<ImmutableArray`1<ISymbol>, ImmutableArray`1<KeyValuePair`2<string, string>>> GetConversionSymbolsAndProperties(CompletionContext context, IMethodSymbol conversion);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider/<GetConversionChangeAsync>d__26")]
private static Task`1<CompletionChange> GetConversionChangeAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider/<GetConversionDescriptionAsync>d__27")]
private static Task`1<CompletionDescription> GetConversionDescriptionAsync(Document document, CompletionItem item, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider/<TryRehydrateAsync>d__28")]
private static Task`1<ISymbol> TryRehydrateAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    private void AddIndexers(CompletionContext context, ImmutableArray`1<ISymbol> indexers);
    private static Task`1<CompletionChange> GetIndexerChangeAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    private static Task`1<CompletionDescription> GetIndexerDescriptionAsync(Document document, CompletionItem item, SymbolDescriptionOptions options, CancellationToken cancellationToken);
    private void AddOperatorGroup(CompletionContext context, string opName, IEnumerable`1<ISymbol> operators);
    private static string GetOperatorText(string opName);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.UnnamedSymbolCompletionProvider/<GetOperatorChangeAsync>d__43")]
private Task`1<CompletionChange> GetOperatorChangeAsync(Document document, CompletionItem item, CancellationToken cancellationToken);
    private static OperatorPosition GetOperatorPosition(string operatorName);
    private static Task`1<CompletionDescription> GetOperatorDescriptionAsync(Document document, CompletionItem item, SymbolDescriptionOptions displayOptions, CancellationToken cancellationToken);
    private static string GetOperatorInlineDescription(string opName);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCompletionProviderAttribute("XmlDocCommentCompletionProvider", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Completion.Providers.XmlDocCommentCompletionProvider : AbstractDocCommentCompletionProvider`1<DocumentationCommentTriviaSyntax> {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<char> <TriggerCharacters>k__BackingField;
    private static CompletionItemRules s_defaultRules;
    internal string Language { get; }
    public ImmutableHashSet`1<char> TriggerCharacters { get; }
    private static XmlDocCommentCompletionProvider();
    internal virtual string get_Language();
    public virtual bool IsInsertionTrigger(SourceText text, int characterPosition, CompletionOptions options);
    [CompilerGeneratedAttribute]
public virtual ImmutableHashSet`1<char> get_TriggerCharacters();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.XmlDocCommentCompletionProvider/<GetItemsWorkerAsync>d__7")]
protected virtual Task`1<IEnumerable`1<CompletionItem>> GetItemsWorkerAsync(Document document, int position, CompletionTrigger trigger, CancellationToken cancellationToken);
    private void AddXmlElementItems(List`1<CompletionItem> items, XmlElementStartTagSyntax startTag);
    [NullableContextAttribute("2")]
private bool IsAttributeNameContext(SyntaxToken token, int position, String& elementName, ISet`1& attributeNames);
    private static ValueTuple`2<string, SyntaxList`1<XmlAttributeSyntax>> GetElementNameAndAttributes(SyntaxNode node);
    [NullableContextAttribute("2")]
private static bool IsAttributeValueContext(SyntaxToken token, String& tagName, String& attributeName);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Completion.Providers.XmlDocCommentCompletionProvider/<GetKeywordNames>d__12")]
protected virtual IEnumerable`1<string> GetKeywordNames();
    protected virtual IEnumerable`1<string> GetExistingTopLevelElementNames(DocumentationCommentTriviaSyntax syntax);
    protected virtual IEnumerable`1<string> GetExistingTopLevelAttributeValues(DocumentationCommentTriviaSyntax syntax, string elementName, string attributeName);
    private string GetElementName(XmlNodeSyntax node);
    private string GetAttributeName(XmlAttributeSyntax attribute);
    private string GetAttributeValue(XmlAttributeSyntax attribute);
    protected virtual ImmutableArray`1<IParameterSymbol> GetParameters(ISymbol declarationSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConditionalExpressionInStringInterpolation.CSharpAddParenthesesAroundConditionalExpressionInInterpolatedStringCodeFixProvider : CodeFixProvider {
    private static string CS8361;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConditionalExpressionInStringInterpolation.CSharpAddParenthesesAroundConditionalExpressionInInterpolatedStringCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConditionalExpressionInStringInterpolation.CSharpAddParenthesesAroundConditionalExpressionInInterpolatedStringCodeFixProvider/<GetChangedDocumentAsync>d__6")]
private static Task`1<Document> GetChangedDocumentAsync(Document document, int conditionalExpressionSyntaxStartPosition, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConditionalExpressionInStringInterpolation.CSharpAddParenthesesAroundConditionalExpressionInInterpolatedStringCodeFixProvider/<InsertCloseParenthesisAsync>d__7")]
private static Task`1<Document> InsertCloseParenthesisAsync(Document document, ParenthesizedExpressionSyntax parenthesizedExpression, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConflictMarkerResolution.CSharpResolveConflictMarkerCodeFixProvider : AbstractResolveConflictMarkerCodeFixProvider {
    [NullableAttribute("1")]
private static string CS8300;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExtensionOrderAttribute]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertAnonymousType.CSharpConvertAnonymousTypeToClassCodeRefactoringProvider : AbstractConvertAnonymousTypeToClassCodeRefactoringProvider`6<ExpressionSyntax, NameSyntax, IdentifierNameSyntax, ObjectCreationExpressionSyntax, AnonymousObjectCreationExpressionSyntax, BaseNamespaceDeclarationSyntax> {
    protected virtual ObjectCreationExpressionSyntax CreateObjectCreationExpression(NameSyntax nameNode, AnonymousObjectCreationExpressionSyntax anonymousObject);
    private ArgumentListSyntax CreateArgumentList(AnonymousObjectCreationExpressionSyntax anonymousObject);
    private SeparatedSyntaxList`1<ArgumentSyntax> CreateArguments(SeparatedSyntaxList`1<AnonymousObjectMemberDeclaratorSyntax> initializers);
    private static SyntaxNodeOrTokenList OmitTrailingComma(SyntaxNodeOrTokenList list);
    private SyntaxNodeOrTokenList CreateArguments(SyntaxNodeOrTokenList list);
    private SyntaxNodeOrToken CreateArgumentOrComma(SyntaxNodeOrToken declOrComma);
    private static ArgumentSyntax CreateArgument(AnonymousObjectMemberDeclaratorSyntax decl);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertAnonymousType.CSharpConvertAnonymousTypeToTupleCodeRefactoringProvider : AbstractConvertAnonymousTypeToTupleCodeRefactoringProvider`3<ExpressionSyntax, TupleExpressionSyntax, AnonymousObjectCreationExpressionSyntax> {
    protected virtual int GetInitializerCount(AnonymousObjectCreationExpressionSyntax anonymousType);
    protected virtual TupleExpressionSyntax ConvertToTuple(AnonymousObjectCreationExpressionSyntax anonCreation);
    private static SeparatedSyntaxList`1<ArgumentSyntax> ConvertInitializers(SeparatedSyntaxList`1<AnonymousObjectMemberDeclaratorSyntax> initializers);
    private static ArgumentSyntax ConvertInitializer(AnonymousObjectMemberDeclaratorSyntax declarator);
    [NullableContextAttribute("2")]
private static NameColonSyntax ConvertName(NameEqualsSyntax nameEquals);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertAutoPropertyToFullProperty.CSharpConvertAutoPropertyToFullPropertyCodeRefactoringProvider : AbstractConvertAutoPropertyToFullPropertyCodeRefactoringProvider`3<PropertyDeclarationSyntax, TypeDeclarationSyntax, CSharpCodeGenerationContextInfo> {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertAutoPropertyToFullProperty.CSharpConvertAutoPropertyToFullPropertyCodeRefactoringProvider/<GetFieldNameAsync>d__1")]
protected virtual Task`1<string> GetFieldNameAsync(Document document, IPropertySymbol property, NamingStylePreferencesProvider fallbackOptions, CancellationToken cancellationToken);
    protected virtual ValueTuple`2<SyntaxNode, SyntaxNode> GetNewAccessors(CSharpCodeGenerationContextInfo info, SyntaxNode property, string fieldName, SyntaxGenerator generator, CancellationToken cancellationToken);
    private static ValueTuple`2<AccessorDeclarationSyntax, AccessorDeclarationSyntax> GetExistingAccessors(AccessorListSyntax accessorListSyntax);
    private static SyntaxNode GetUpdatedAccessor(CSharpCodeGenerationContextInfo info, SyntaxNode accessor, SyntaxNode statement, CancellationToken cancellationToken);
    internal static SyntaxNode AddStatement(SyntaxNode accessor, SyntaxNode statement);
    protected virtual SyntaxNode ConvertPropertyToExpressionBodyIfDesired(CSharpCodeGenerationContextInfo info, SyntaxNode property);
    protected virtual SyntaxNode GetTypeBlock(SyntaxNode syntaxNode);
    protected virtual SyntaxNode GetInitializerValue(SyntaxNode property);
    protected virtual SyntaxNode GetPropertyWithoutInitializer(SyntaxNode property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.ConvertBetweenRegularAndVerbatimString.AbstractConvertBetweenRegularAndVerbatimStringCodeRefactoringProvider`1 : CodeRefactoringProvider {
    private static char OpenBrace;
    private static char CloseBrace;
    protected static char DoubleQuote;
    protected bool IsInterpolation { get; }
    protected abstract virtual bool get_IsInterpolation();
    protected abstract virtual bool IsAppropriateLiteralKind(TStringExpressionSyntax literalExpression);
    protected abstract virtual void AddSubStringTokens(TStringExpressionSyntax literalExpression, ArrayBuilder`1<SyntaxToken> subTokens);
    protected abstract virtual bool IsVerbatim(TStringExpressionSyntax literalExpression);
    protected abstract virtual TStringExpressionSyntax CreateVerbatimStringExpression(IVirtualCharService charService, StringBuilder sb, TStringExpressionSyntax stringExpression);
    protected abstract virtual TStringExpressionSyntax CreateRegularStringExpression(IVirtualCharService charService, StringBuilder sb, TStringExpressionSyntax stringExpression);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertBetweenRegularAndVerbatimString.AbstractConvertBetweenRegularAndVerbatimStringCodeRefactoringProvider`1/<ComputeRefactoringsAsync>d__10")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertBetweenRegularAndVerbatimString.AbstractConvertBetweenRegularAndVerbatimStringCodeRefactoringProvider`1/<ConvertAsync>d__11")]
private static Task`1<Document> ConvertAsync(Func`4<IVirtualCharService, StringBuilder, TStringExpressionSyntax, TStringExpressionSyntax> convert, Document document, TStringExpressionSyntax stringExpression, CancellationToken cancellationToken);
    private Task`1<Document> ConvertToVerbatimStringAsync(Document document, TStringExpressionSyntax stringExpression, CancellationToken cancellationToken);
    private Task`1<Document> ConvertToRegularStringAsync(Document document, TStringExpressionSyntax stringExpression, CancellationToken cancellationToken);
    protected void AddVerbatimStringText(IVirtualCharService charService, StringBuilder sb, SyntaxToken stringToken);
    private static bool IsOpenOrCloseBrace(VirtualChar ch);
    protected void AddRegularStringText(IVirtualCharService charService, StringBuilder sb, SyntaxToken stringToken);
    private static bool ContainsSimpleEscape(IVirtualCharService charService, ArrayBuilder`1<SyntaxToken> subTokens);
    private static bool ContainsSimpleEscape(VirtualCharSequence chars);
    [CompilerGeneratedAttribute]
internal static bool <AddVerbatimStringText>g__ShouldDouble|14_0(VirtualChar ch, bool isInterpolation);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertBetweenRegularAndVerbatimString.ConvertBetweenRegularAndVerbatimInterpolatedStringCodeRefactoringProvider : AbstractConvertBetweenRegularAndVerbatimStringCodeRefactoringProvider`1<InterpolatedStringExpressionSyntax> {
    [CompilerGeneratedAttribute]
private bool <IsInterpolation>k__BackingField;
    protected bool IsInterpolation { get; }
    [CompilerGeneratedAttribute]
protected virtual bool get_IsInterpolation();
    protected virtual bool IsAppropriateLiteralKind(InterpolatedStringExpressionSyntax literalExpression);
    protected virtual void AddSubStringTokens(InterpolatedStringExpressionSyntax literalExpression, ArrayBuilder`1<SyntaxToken> subStringTokens);
    protected virtual bool IsVerbatim(InterpolatedStringExpressionSyntax literalExpression);
    private static InterpolatedStringExpressionSyntax Convert(IVirtualCharService charService, StringBuilder sb, InterpolatedStringExpressionSyntax stringExpression, SyntaxKind newStartKind, Action`3<IVirtualCharService, StringBuilder, SyntaxToken> addStringText);
    private static SyntaxToken CreateTextToken(SyntaxToken textToken, StringBuilder sb);
    protected virtual InterpolatedStringExpressionSyntax CreateVerbatimStringExpression(IVirtualCharService charService, StringBuilder sb, InterpolatedStringExpressionSyntax stringExpression);
    protected virtual InterpolatedStringExpressionSyntax CreateRegularStringExpression(IVirtualCharService charService, StringBuilder sb, InterpolatedStringExpressionSyntax stringExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertBetweenRegularAndVerbatimString.ConvertBetweenRegularAndVerbatimStringCodeRefactoringProvider : AbstractConvertBetweenRegularAndVerbatimStringCodeRefactoringProvider`1<LiteralExpressionSyntax> {
    [CompilerGeneratedAttribute]
private bool <IsInterpolation>k__BackingField;
    protected bool IsInterpolation { get; }
    [CompilerGeneratedAttribute]
protected virtual bool get_IsInterpolation();
    protected virtual bool IsAppropriateLiteralKind(LiteralExpressionSyntax literalExpression);
    protected virtual void AddSubStringTokens(LiteralExpressionSyntax literalExpression, ArrayBuilder`1<SyntaxToken> subStringTokens);
    protected virtual bool IsVerbatim(LiteralExpressionSyntax literalExpression);
    protected virtual LiteralExpressionSyntax CreateVerbatimStringExpression(IVirtualCharService charService, StringBuilder sb, LiteralExpressionSyntax stringExpression);
    protected virtual LiteralExpressionSyntax CreateRegularStringExpression(IVirtualCharService charService, StringBuilder sb, LiteralExpressionSyntax stringExpression);
    private static SyntaxToken CreateStringToken(StringBuilder sb);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertCast.CSharpConvertDirectCastToTryCastCodeRefactoringProvider : AbstractConvertCastCodeRefactoringProvider`3<TypeSyntax, CastExpressionSyntax, BinaryExpressionSyntax> {
    protected int FromKind { get; }
    protected virtual string GetTitle();
    protected virtual int get_FromKind();
    protected virtual TypeSyntax GetTypeNode(CastExpressionSyntax from);
    protected virtual BinaryExpressionSyntax ConvertExpression(CastExpressionSyntax castExpression, NullableContext nullableContext, bool isReferenceType);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertCast.CSharpConvertTryCastToDirectCastCodeRefactoringProvider : AbstractConvertCastCodeRefactoringProvider`3<TypeSyntax, BinaryExpressionSyntax, CastExpressionSyntax> {
    protected int FromKind { get; }
    protected virtual string GetTitle();
    protected virtual int get_FromKind();
    protected virtual TypeSyntax GetTypeNode(BinaryExpressionSyntax expression);
    protected virtual CastExpressionSyntax ConvertExpression(BinaryExpressionSyntax asExpression, NullableContext nullableContext, bool isReferenceType);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertForEachToFor.CSharpConvertForEachToForCodeRefactoringProvider : AbstractConvertForEachToForCodeRefactoringProvider`2<StatementSyntax, ForEachStatementSyntax> {
    protected string Title { get; }
    protected virtual string get_Title();
    protected virtual bool IsValid(ForEachStatementSyntax foreachStatement);
    protected virtual bool ValidLocation(ForEachInfo<StatementSyntax, ForEachStatementSyntax> foreachInfo);
    protected virtual ValueTuple`2<SyntaxNode, SyntaxNode> GetForEachBody(ForEachStatementSyntax foreachStatement);
    protected virtual void ConvertToForStatement(SemanticModel model, ForEachInfo<StatementSyntax, ForEachStatementSyntax> foreachInfo, SyntaxEditor editor, CancellationToken cancellationToken);
    private StatementSyntax GetForLoopBody(SyntaxGenerator generator, ForEachInfo<StatementSyntax, ForEachStatementSyntax> foreachInfo, SyntaxNode collectionVariableName, SyntaxToken indexVariable, bool donotCastElement);
    protected virtual bool IsSupported(ILocalSymbol foreachVariable, IForEachLoopOperation forEachOperation, ForEachStatementSyntax foreachStatement);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertForToForEach.CSharpConvertForToForEachCodeRefactoringProvider : AbstractConvertForToForEachCodeRefactoringProvider`6<StatementSyntax, ForStatementSyntax, ExpressionSyntax, MemberAccessExpressionSyntax, TypeSyntax, VariableDeclaratorSyntax> {
    protected virtual string GetTitle();
    protected virtual SyntaxList`1<StatementSyntax> GetBodyStatements(ForStatementSyntax forStatement);
    [NullableContextAttribute("2")]
protected virtual bool TryGetForStatementComponents(ForStatementSyntax forStatement, SyntaxToken& iterationVariable, ExpressionSyntax& initializer, MemberAccessExpressionSyntax& memberAccess, ExpressionSyntax& stepValueExpressionOpt, CancellationToken cancellationToken);
    private static bool TryGetStepValue(SyntaxToken iterationVariable, ExpressionSyntax incrementor, ExpressionSyntax& stepValue);
    protected virtual SyntaxNode ConvertForNode(ForStatementSyntax forStatement, TypeSyntax typeNode, SyntaxToken foreachIdentifier, ExpressionSyntax collectionExpression, ITypeSymbol iterationVariableType);
    protected virtual bool IsValidVariableDeclarator(VariableDeclaratorSyntax firstVariable);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertIfToSwitch.CSharpConvertIfToSwitchCodeRefactoringProvider : AbstractConvertIfToSwitchCodeRefactoringProvider`4<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax> {
    private static Dictionary`2<BinaryOperatorKind, SyntaxKind> s_operatorMap;
    private static CSharpConvertIfToSwitchCodeRefactoringProvider();
    public virtual string GetTitle(bool forSwitchExpression);
    public virtual Analyzer<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax> CreateAnalyzer(ISyntaxFacts syntaxFacts, ParseOptions options);
    protected virtual SyntaxTriviaList GetLeadingTriviaToTransfer(SyntaxNode syntaxToRemove);
    public virtual SyntaxNode CreateSwitchExpressionStatement(SyntaxNode target, ImmutableArray`1<AnalyzedSwitchSection<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax>> sections, Feature<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax> feature);
    private static SwitchExpressionArmSyntax AsSwitchExpressionArmSyntax(AnalyzedSwitchSection<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax> section, Feature<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax> feature);
    private static ExpressionSyntax AsExpressionSyntax(IOperation operation);
    public virtual SyntaxNode CreateSwitchStatement(IfStatementSyntax ifStatement, SyntaxNode expression, IEnumerable`1<SyntaxNode> sectionList);
    private static WhenClauseSyntax AsWhenClause(AnalyzedSwitchLabel<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax> label);
    [NullableContextAttribute("2")]
private static WhenClauseSyntax AsWhenClause(ExpressionSyntax expression);
    public virtual SyntaxNode AsSwitchLabelSyntax(AnalyzedSwitchLabel<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax> label, Feature<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax> feature);
    private static PatternSyntax AsPatternSyntax(AnalyzedPattern<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax> pattern, Feature<IfStatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, PatternSyntax> feature);
    public virtual IEnumerable`1<SyntaxNode> AsSwitchSectionStatements(IOperation operation);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.AbstractConverter : object {
    [CompilerGeneratedAttribute]
private ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> <ForEachInfo>k__BackingField;
    public ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> ForEachInfo { get; }
    protected AbstractConverter(ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> forEachInfo);
    [CompilerGeneratedAttribute]
public sealed virtual ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> get_ForEachInfo();
    public abstract virtual void Convert(SyntaxEditor editor, bool convertToQuery, CancellationToken cancellationToken);
    protected ExpressionSyntax CreateQueryExpressionOrLinqInvocation(ExpressionSyntax selectExpression, IEnumerable`1<SyntaxToken> leadingTokensForSelect, IEnumerable`1<SyntaxToken> trailingTokensForSelect, bool convertToQuery);
    private QueryExpressionSyntax CreateQueryExpression(ExpressionSyntax selectExpression, IEnumerable`1<SyntaxToken> leadingTokensForSelect, IEnumerable`1<SyntaxToken> trailingTokensForSelect);
    private static QueryClauseSyntax CreateQueryClause(ExtendedSyntaxNode node);
    private static FromClauseSyntax CreateFromClause(ForEachStatementSyntax forEachStatement, IEnumerable`1<SyntaxTrivia> extraLeadingTrivia, IEnumerable`1<SyntaxTrivia> extraTrailingTrivia);
    private ExpressionSyntax CreateLinqInvocationOrSimpleExpression(ExpressionSyntax selectExpression, IEnumerable`1<SyntaxToken> leadingTokensForSelect, IEnumerable`1<SyntaxToken> trailingTokensForSelect);
    private ExpressionSyntax CreateLinqInvocationOrSimpleExpression(ForEachStatementSyntax forEachStatement, ExpressionSyntax receiverForInvocation, IEnumerable`1<SyntaxTrivia> leadingCommentsTrivia, IEnumerable`1<SyntaxTrivia> trailingCommentsTrivia, ExpressionSyntax selectExpression, Int32& currentExtendedNodeIndex);
    private ExpressionSyntax CreateLinqInvocationForExtendedNode(ExpressionSyntax selectExpression, Int32& extendedNodeIndex, ExpressionSyntax& receiver, Boolean& hasForEachChild);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.AbstractToMethodConverter : AbstractConverter {
    private ExpressionSyntax _selectExpression;
    private ExpressionSyntax _modifyingExpression;
    private SyntaxTrivia[] _trivia;
    protected string MethodName { get; }
    protected AbstractToMethodConverter(ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> forEachInfo, ExpressionSyntax selectExpression, ExpressionSyntax modifyingExpression, SyntaxTrivia[] trivia);
    protected abstract virtual string get_MethodName();
    protected abstract virtual bool CanReplaceInitialization(ExpressionSyntax expressionSyntax, CancellationToken cancellationToken);
    protected abstract virtual StatementSyntax CreateDefaultStatement(ExpressionSyntax queryOrLinqInvocationExpression, ExpressionSyntax expression);
    public virtual void Convert(SyntaxEditor editor, bool convertToQuery, CancellationToken cancellationToken);
    protected InvocationExpressionSyntax CreateInvocationExpression(ExpressionSyntax queryOrLinqInvocationExpression);
    [CompilerGeneratedAttribute]
private void <Convert>g__Convert|8_0(ExpressionSyntax replacingExpression, SyntaxNode nodeToRemoveIfFollowedByReturn, <>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
internal static SyntaxTrivia[] <Convert>g__GetTriviaFromVariableDeclarator|8_1(VariableDeclaratorSyntax variableDeclarator);
    [CompilerGeneratedAttribute]
internal static SyntaxTrivia[] <Convert>g__GetTriviaFromNode|8_2(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.CSharpConvertForEachToLinqQueryProvider : AbstractConvertForEachToLinqQueryProvider`2<ForEachStatementSyntax, StatementSyntax> {
    protected virtual IConverter`2<ForEachStatementSyntax, StatementSyntax> CreateDefaultConverter(ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> forEachInfo);
    protected virtual ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> CreateForEachInfo(ForEachStatementSyntax forEachStatement, SemanticModel semanticModel, bool convertLocalDeclarations);
    protected virtual bool TryBuildSpecificConverter(ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> forEachInfo, SemanticModel semanticModel, StatementSyntax statementCannotBeConverted, CancellationToken cancellationToken, IConverter`2& converter);
    protected virtual SyntaxNode AddLinqUsing(IConverter`2<ForEachStatementSyntax, StatementSyntax> converter, SemanticModel semanticModel, SyntaxNode root);
    internal static bool TypeSymbolIsList(ITypeSymbol typeSymbol, SemanticModel semanticModel);
    [CompilerGeneratedAttribute]
internal static bool <CreateForEachInfo>g__TryProcessLocalDeclarationStatement|2_0(LocalDeclarationStatementSyntax localDeclarationStatement, <>c__DisplayClass2_0& );
}
internal class Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.DefaultConverter : AbstractConverter {
    private static TypeSyntax VarNameIdentifier;
    public DefaultConverter(ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> forEachInfo);
    private static DefaultConverter();
    public virtual void Convert(SyntaxEditor editor, bool convertToQuery, CancellationToken cancellationToken);
    private StatementSyntax CreateDefaultReplacementStatement(IEnumerable`1<SyntaxToken> identifiers, BlockSyntax block, bool convertToQuery);
    private static BlockSyntax WrapWithBlockIfNecessary(ImmutableArray`1<StatementSyntax> statements);
}
internal class Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.ToCountConverter : AbstractToMethodConverter {
    protected string MethodName { get; }
    public ToCountConverter(ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> forEachInfo, ExpressionSyntax selectExpression, ExpressionSyntax modifyingExpression, SyntaxTrivia[] trivia);
    protected virtual string get_MethodName();
    protected virtual bool CanReplaceInitialization(ExpressionSyntax expression, CancellationToken cancellationToken);
    protected virtual StatementSyntax CreateDefaultStatement(ExpressionSyntax queryOrLinqInvocationExpression, ExpressionSyntax expression);
}
internal class Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.ToToListConverter : AbstractToMethodConverter {
    protected string MethodName { get; }
    public ToToListConverter(ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> forEachInfo, ExpressionSyntax selectExpression, ExpressionSyntax modifyingExpression, SyntaxTrivia[] trivia);
    protected virtual string get_MethodName();
    protected virtual bool CanReplaceInitialization(ExpressionSyntax expression, CancellationToken cancellationToken);
    protected virtual StatementSyntax CreateDefaultStatement(ExpressionSyntax queryOrLinqInvocationExpression, ExpressionSyntax expression);
}
internal class Microsoft.CodeAnalysis.CSharp.ConvertLinq.ConvertForEachToLinqQuery.YieldReturnConverter : AbstractConverter {
    private YieldStatementSyntax _yieldReturnStatement;
    private YieldStatementSyntax _yieldBreakStatement;
    public YieldReturnConverter(ForEachInfo`2<ForEachStatementSyntax, StatementSyntax> forEachInfo, YieldStatementSyntax yieldReturnStatement, YieldStatementSyntax yieldBreakStatement);
    public virtual void Convert(SyntaxEditor editor, bool convertToQuery, CancellationToken cancellationToken);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertLinq.CSharpConvertLinqQueryToForEachProvider : AbstractConvertLinqQueryToForEachProvider`2<QueryExpressionSyntax, StatementSyntax> {
    private static TypeSyntax VarNameIdentifier;
    protected string Title { get; }
    private static CSharpConvertLinqQueryToForEachProvider();
    protected virtual string get_Title();
    protected virtual bool TryConvert(QueryExpressionSyntax queryExpression, SemanticModel semanticModel, ISemanticFactsService semanticFacts, CancellationToken cancellationToken, DocumentUpdateInfo& documentUpdateInfo);
    protected virtual Task`1<QueryExpressionSyntax> FindNodeToRefactorAsync(CodeRefactoringContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertNamespaceAnalysis : object {
    public static ValueTuple`2<string, string> GetInfo(NamespaceDeclarationPreference preference);
    public static bool CanOfferUseBlockScoped(CodeStyleOption2`1<NamespaceDeclarationPreference> option, BaseNamespaceDeclarationSyntax declaration, bool forAnalyzer);
    internal static bool CanOfferUseFileScoped(CodeStyleOption2`1<NamespaceDeclarationPreference> option, CompilationUnitSyntax root, BaseNamespaceDeclarationSyntax declaration, bool forAnalyzer);
    internal static bool CanOfferUseFileScoped(CodeStyleOption2`1<NamespaceDeclarationPreference> option, CompilationUnitSyntax root, BaseNamespaceDeclarationSyntax declaration, bool forAnalyzer, LanguageVersion version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertNamespaceCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertNamespaceCodeFixProvider/<FixAllAsync>d__4")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertNamespaceCodeRefactoringProvider : SyntaxEditorBasedCodeRefactoringProvider {
    [NullableAttribute("0")]
protected ImmutableArray`1<FixAllScope> SupportedFixAllScopes { get; }
    [NullableContextAttribute("0")]
protected virtual ImmutableArray`1<FixAllScope> get_SupportedFixAllScopes();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertNamespaceCodeRefactoringProvider/<ComputeRefactoringsAsync>d__3")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static bool CanOfferRefactoring(BaseNamespaceDeclarationSyntax namespaceDecl, CompilationUnitSyntax root, CSharpCodeFixOptionsProvider options, Nullable`1& info);
    private static bool IsValidPosition(BaseNamespaceDeclarationSyntax baseDeclaration, int position);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertNamespaceCodeRefactoringProvider/<FixAllAsync>d__6")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<TextSpan> fixAllSpans, SyntaxEditor editor, CodeActionOptionsProvider optionsProvider, string equivalenceKey, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertNamespaceTransform : object {
    public static Task`1<Document> ConvertAsync(Document document, BaseNamespaceDeclarationSyntax baseNamespace, CSharpSyntaxFormattingOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertNamespaceTransform/<ConvertNamespaceDeclarationAsync>d__1")]
public static Task`1<Document> ConvertNamespaceDeclarationAsync(Document document, NamespaceDeclarationSyntax namespaceDeclaration, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    public static ValueTuple`2<SourceText, TextSpan> ConvertNamespaceDeclaration(ParsedDocument document, NamespaceDeclarationSyntax namespaceDeclaration, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    private static ValueTuple`2<SyntaxNode, TextSpan> ReplaceWithFileScopedNamespace(ParsedDocument document, NamespaceDeclarationSyntax namespaceDeclaration, SyntaxAnnotation annotation);
    private static string GetIndentation(ParsedDocument document, NamespaceDeclarationSyntax namespaceDeclaration, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    private static ValueTuple`2<SourceText, TextSpan> DedentNamespace(ParsedDocument document, string indentation, SyntaxAnnotation annotation, CancellationToken cancellationToken);
    private static SourceText IndentNamespace(ParsedDocument document, string indentation, SyntaxAnnotation annotation, CancellationToken cancellationToken);
    private static Nullable`1<TextChange> TryIndentLine(SyntaxTree tree, SyntaxNode root, string indentation, TextLine textLine, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertNamespaceTransform/<ConvertFileScopedNamespaceAsync>d__8")]
public static Task`1<Document> ConvertFileScopedNamespaceAsync(Document document, FileScopedNamespaceDeclarationSyntax fileScopedNamespace, CSharpSyntaxFormattingOptions options, CancellationToken cancellationToken);
    private static SyntaxNode ReplaceWithBlockScopedNamespace(ParsedDocument document, FileScopedNamespaceDeclarationSyntax namespaceDeclaration, string lineEnding, NewLinePlacement newLinePlacement, SyntaxAnnotation annotation);
    private static bool HasLeadingBlankLine(SyntaxToken token, SyntaxToken& withoutBlankLine);
    private static FileScopedNamespaceDeclarationSyntax ConvertNamespaceDeclaration(NamespaceDeclarationSyntax namespaceDeclaration);
    private static NamespaceDeclarationSyntax ConvertFileScopedNamespace(ParsedDocument document, FileScopedNamespaceDeclarationSyntax fileScopedNamespace, string lineEnding, NewLinePlacement newLinePlacement);
    [CompilerGeneratedAttribute]
internal static Nullable`1<TextChange> <DedentNamespace>g__TryDedentLine|5_0(TextLine textLine, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static int <DedentNamespace>g__ComputeCommonIndentationLength|5_1(TextLine textLine, <>c__DisplayClass5_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertToBlockScopedNamespaceDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeNamespace(SyntaxNodeAnalysisContext context);
    private Diagnostic AnalyzeNamespace(SyntaxNodeAnalysisContext context, FileScopedNamespaceDeclarationSyntax declaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.ConvertNamespace.ConvertToFileScopedNamespaceDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeNamespace(SyntaxNodeAnalysisContext context);
    private Diagnostic AnalyzeNamespace(SyntaxNodeAnalysisContext context, CompilationUnitSyntax root, BaseNamespaceDeclarationSyntax declaration);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertNumericLiteral.CSharpConvertNumericLiteralCodeRefactoringProvider : AbstractConvertNumericLiteralCodeRefactoringProvider`1<LiteralExpressionSyntax> {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertPrimaryToRegularConstructor.ConvertPrimaryToRegularConstructorCodeRefactoringProvider : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertPrimaryToRegularConstructor.ConvertPrimaryToRegularConstructorCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertPrimaryToRegularConstructor.ConvertPrimaryToRegularConstructorCodeRefactoringProvider/<ConvertAsync>d__2")]
private static Task`1<Solution> ConvertAsync(Document document, TypeDeclarationSyntax typeDeclaration, ParameterListSyntax parameterList, CodeActionOptionsProvider optionsProvider, CancellationToken cancellationToken);
    private static SyntaxTrivia GetDocComment(SyntaxTriviaList trivia);
    [NullableContextAttribute("2")]
private static DocumentationCommentTriviaSyntax GetDocCommentStructure(SyntaxTrivia trivia);
    private static bool IsXmlElement(XmlNodeSyntax node, string name, XmlElementSyntax& element);
    private static TypeDeclarationSyntax RemoveParamXmlElements(TypeDeclarationSyntax typeDeclaration);
    private static ConstructorDeclarationSyntax WithTypeDeclarationParamDocComments(TypeDeclarationSyntax typeDeclaration, ConstructorDeclarationSyntax constructor);
    private static bool IsDocCommentNewLine(XmlNodeSyntax node);
    [CompilerGeneratedAttribute]
internal static TListSyntax <ConvertAsync>g__AddElementIndentation|2_14(TypeDeclarationSyntax typeDeclaration, ConstructorDeclarationSyntax constructorDeclaration, TListSyntax list, Func`2<TListSyntax, IEnumerable`1<SyntaxNode>> getElements);
    [CompilerGeneratedAttribute]
internal static string <ConvertAsync>g__GetLeadingWhitespace|2_15(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static void <RemoveParamXmlElements>g__FixupLastTextNode|6_1(<>c__DisplayClass6_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.ConvertProgram.ConvertProgramTransform : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertProgram.ConvertProgramTransform/<ConvertToProgramMainAsync>d__0")]
public static Task`1<Document> ConvertToProgramMainAsync(Document document, AccessibilityModifiersRequired accessibilityModifiersRequired, CancellationToken cancellationToken);
    private static bool IsProgramClass(ClassDeclarationSyntax declaration);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertProgram.ConvertProgramTransform/<GenerateProgramClassAsync>d__2")]
private static Task`1<ClassDeclarationSyntax> GenerateProgramClassAsync(Document document, ClassDeclarationSyntax oldClassDeclaration, IMethodSymbol mainMethod, AccessibilityModifiersRequired accessibilityModifiersRequired, CancellationToken cancellationToken);
    private static ImmutableArray`1<StatementSyntax> GenerateProgramMainStatements(CompilationUnitSyntax root, SyntaxTriviaList& triviaToMove);
    private static TSyntaxNode FixupComments(TSyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertProgram.ConvertProgramTransform/<ConvertToTopLevelStatementsAsync>d__5")]
public static Task`1<Document> ConvertToTopLevelStatementsAsync(Document document, MethodDeclarationSyntax methodDeclaration, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertProgram.ConvertProgramTransform/<ConvertFileScopedNamespaceAsync>d__6")]
private static Task`1<Document> ConvertFileScopedNamespaceAsync(Document document, CodeCleanupOptions cleanupOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertProgram.ConvertProgramTransform/<AddUsingDirectivesAsync>d__7")]
private static Task`1<Document> AddUsingDirectivesAsync(Document document, SyntaxNode root, BaseNamespaceDeclarationSyntax namespaceDeclaration, CodeCleanupOptions options, CancellationToken cancellationToken);
    private static void AddUsingDirectives(NameSyntax name, SyntaxAnnotation annotation, ArrayBuilder`1<UsingDirectiveSyntax> directives);
    private static SyntaxNode GetRootWithGlobalStatements(SemanticModel semanticModel, SyntaxGenerator generator, SyntaxNode root, TypeDeclarationSyntax typeDeclaration, MethodDeclarationSyntax methodDeclaration, CancellationToken cancellationToken);
    private static ImmutableArray`1<GlobalStatementSyntax> GetGlobalStatements(SemanticModel semanticModel, TypeDeclarationSyntax typeDeclaration, MethodDeclarationSyntax methodDeclaration, CancellationToken cancellationToken);
    private static VariableDeclarationSyntax ConvertDeclaration(SemanticModel semanticModel, VariableDeclarationSyntax declaration, CancellationToken cancellationToken);
    private static VariableDeclaratorSyntax ConvertVariable(SemanticModel semanticModel, VariableDeclaratorSyntax variable, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertProgram.ConvertToProgramMainCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertProgram.ConvertToProgramMainCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertProgram.ConvertToProgramMainCodeFixProvider/<FixAllAsync>d__4")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertProgram.ConvertToProgramMainCodeRefactoringProvider : CodeRefactoringProvider {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertProgram.ConvertToProgramMainCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertProgram.ConvertToTopLevelStatementsCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertProgram.ConvertToTopLevelStatementsCodeFixProvider/<RegisterCodeFixesAsync>d__3")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertProgram.ConvertToTopLevelStatementsCodeFixProvider/<FixAllAsync>d__4")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertProgram.ConvertToTopLevelStatementsCodeRefactoringProvider : CodeRefactoringProvider {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertProgram.ConvertToTopLevelStatementsCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertSwitchStatementToExpression.ConvertSwitchStatementToExpressionCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertSwitchStatementToExpression.ConvertSwitchStatementToExpressionCodeFixProvider/<FixAllAsync>d__4")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.ConvertSwitchStatementToExpression.ConvertSwitchStatementToExpressionConstants : object {
    public static string NodeToGenerateKey;
    public static string ShouldRemoveNextStatementKey;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.ConvertSwitchStatementToExpression.ConvertSwitchStatementToExpressionDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.CSharp.ConvertSwitchStatementToExpression.ConvertSwitchStatementToExpressionHelpers : object {
    [NullableContextAttribute("1")]
public static bool IsDefaultSwitchLabel(SwitchLabelSyntax node);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertToInterpolatedString.CSharpConvertConcatenationToInterpolatedStringRefactoringProvider : AbstractConvertConcatenationToInterpolatedStringRefactoringProvider`1<ExpressionSyntax> {
    protected virtual bool SupportsInterpolatedStringHandler(Compilation compilation);
    protected virtual string GetTextWithoutQuotes(string text, bool isVerbatim, bool isCharacterLiteral);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertToInterpolatedString.CSharpConvertPlaceholderToInterpolatedStringRefactoringProvider : AbstractConvertPlaceholderToInterpolatedStringRefactoringProvider`7<ExpressionSyntax, LiteralExpressionSyntax, InvocationExpressionSyntax, InterpolatedStringExpressionSyntax, ArgumentSyntax, ArgumentListSyntax, InterpolationSyntax> {
    protected virtual ExpressionSyntax ParseExpression(string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.ConvertToRawString.AbstractConvertStringProvider`1 : object {
    protected abstract virtual bool CheckSyntax(TStringExpression expression);
    public sealed virtual bool CanConvert(ParsedDocument document, ExpressionSyntax expression, SyntaxFormattingOptions formattingOptions, CanConvertParams& convertParams, CancellationToken cancellationToken);
    public sealed virtual ExpressionSyntax Convert(ParsedDocument document, ExpressionSyntax expression, ConvertToRawKind kind, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    protected abstract virtual bool CanConvert(ParsedDocument document, TStringExpression expression, SyntaxFormattingOptions formattingOptions, CanConvertParams& convertParams, CancellationToken cancellationToken);
    protected abstract virtual TStringExpression Convert(ParsedDocument document, TStringExpression expression, ConvertToRawKind kind, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertToRawString.CanConvertParams : ValueType {
    [CompilerGeneratedAttribute]
private CodeActionPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeSingleLine>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeMultiLineWithoutLeadingWhiteSpaces>k__BackingField;
    public CodeActionPriority Priority { get; }
    public bool CanBeSingleLine { get; }
    public bool CanBeMultiLineWithoutLeadingWhiteSpaces { get; }
    public CanConvertParams(CodeActionPriority priority, bool canBeSingleLine, bool canBeMultiLineWithoutLeadingWhiteSpaces);
    [CompilerGeneratedAttribute]
public CodeActionPriority get_Priority();
    [CompilerGeneratedAttribute]
public bool get_CanBeSingleLine();
    [CompilerGeneratedAttribute]
public bool get_CanBeMultiLineWithoutLeadingWhiteSpaces();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.ConvertToRawString.ConvertInterpolatedStringToRawStringProvider : AbstractConvertStringProvider`1<InterpolatedStringExpressionSyntax> {
    public static IConvertStringProvider Instance;
    private static ConvertInterpolatedStringToRawStringProvider();
    protected virtual bool CheckSyntax(InterpolatedStringExpressionSyntax stringExpression);
    private static VirtualCharSequence ConvertToVirtualChars(InterpolatedStringTextSyntax textSyntax);
    private static VirtualCharSequence TryConvertToVirtualChars(InterpolatedStringTextSyntax textSyntax);
    private static VirtualCharSequence TryConvertToVirtualChars(SyntaxToken token);
    protected virtual bool CanConvert(ParsedDocument document, InterpolatedStringExpressionSyntax stringExpression, SyntaxFormattingOptions formattingOptions, CanConvertParams& convertParams, CancellationToken cancellationToken);
    protected virtual InterpolatedStringExpressionSyntax Convert(ParsedDocument document, InterpolatedStringExpressionSyntax stringExpression, ConvertToRawKind kind, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    private static string DetermineAnchorIndentation(string rootAnchorIndentation, SourceText text, SyntaxFormattingOptions formattingOptions, InterpolatedStringExpressionSyntax stringExpression, int start);
    private static InterpolatedStringExpressionSyntax GetInitialMultiLineRawInterpolatedString(InterpolatedStringExpressionSyntax stringExpression, SyntaxFormattingOptions formattingOptions);
    private static ValueTuple`4<string, string, string, string> GetDelimiters(InterpolatedStringExpressionSyntax stringExpression);
    [NullableContextAttribute("0")]
private static ValueTuple`2<int, int> GetLongestSequences(InterpolatedStringExpressionSyntax stringExpression);
    private static SyntaxList`1<InterpolatedStringContentSyntax> ConvertContents(InterpolatedStringExpressionSyntax stringExpression, string openBraceString, string closeBraceString);
    private static string GetIndentationStringForToken(SourceText text, SyntaxFormattingOptions options, SyntaxToken token);
    private static string GetIndentationStringForPosition(SourceText text, SyntaxFormattingOptions options, int position);
    private static void AppendFullLine(StringBuilder builder, TextLine line);
    private static ValueTuple`2<TextSpanIntervalTree, TextSpanIntervalTree> GetInterpolationSpans(InterpolatedStringExpressionSyntax stringExpression, CancellationToken cancellationToken);
    private static InterpolatedStringExpressionSyntax CleanInterpolatedString(InterpolatedStringExpressionSyntax stringExpression, CancellationToken cancellationToken);
    private static string ComputeCommonWhitespacePrefix(ArrayBuilder`1<TextLine> lines, TextSpanIntervalTree interpolationInteriorSpans);
    private static string ComputeCommonWhitespacePrefix(string leadingWhitespace1, string leadingWhitespace2);
    public static SyntaxToken UpdateToken(SyntaxToken token, string text, string valueText, Nullable`1<SyntaxKind> kind);
    [CompilerGeneratedAttribute]
internal static InterpolatedStringExpressionSyntax <Convert>g__ConvertToSingleLineRawString|7_0(<>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static InterpolatedStringExpressionSyntax <Convert>g__ConvertToMultiLineRawIndentedString|7_1(ParsedDocument document, string indentation, <>c__DisplayClass7_0& );
    [CompilerGeneratedAttribute]
internal static SyntaxNode <Convert>g__GetAnchorNode|7_2(ParsedDocument parsedDocument, SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static string <Convert>g__Indent|7_3(InterpolatedStringExpressionSyntax stringExpression, SyntaxFormattingOptions formattingOptions, string indentation, string rootAnchorIndentation, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static InterpolationFormatClauseSyntax <ConvertContents>g__RewriteFormatClause|12_0(InterpolationFormatClauseSyntax formatClause);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.ConvertToRawString.ConvertRegularStringToRawStringProvider : AbstractConvertStringProvider`1<LiteralExpressionSyntax> {
    public static IConvertStringProvider Instance;
    private static ConvertRegularStringToRawStringProvider();
    protected virtual bool CheckSyntax(LiteralExpressionSyntax stringExpression);
    protected virtual bool CanConvert(ParsedDocument document, LiteralExpressionSyntax stringExpression, SyntaxFormattingOptions formattingOptions, CanConvertParams& convertParams, CancellationToken cancellationToken);
    private static bool CanConvertStringLiteral(SyntaxToken token, CanConvertParams& convertParams);
    protected virtual LiteralExpressionSyntax Convert(ParsedDocument document, LiteralExpressionSyntax stringExpression, ConvertToRawKind kind, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    private static SyntaxToken GetReplacementToken(ParsedDocument parsedDocument, SyntaxToken token, ConvertToRawKind kind, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    private static VirtualCharSequence CleanupWhitespace(VirtualCharSequence characters);
    private static void AddRange(Builder<VirtualChar> result, VirtualCharSequence sequence);
    private static int ComputeCommonWhitespacePrefix(ArrayBuilder`1<VirtualCharSequence> lines);
    private static VirtualCharSequence ComputeCommonWhitespacePrefix(VirtualCharSequence leadingWhitespace1, VirtualCharSequence leadingWhitespace2);
    private static VirtualCharSequence GetLeadingWhitespace(VirtualCharSequence line);
    private static void BreakIntoLines(VirtualCharSequence characters, ArrayBuilder`1<VirtualCharSequence> lines);
    private static VirtualCharSequence GetNextLine(VirtualCharSequence characters, Int32& index);
    private static bool AllWhitespace(VirtualCharSequence line);
    [CompilerGeneratedAttribute]
internal static bool <CanConvertStringLiteral>g__HasLeadingWhitespace|4_0(VirtualCharSequence characters);
    [CompilerGeneratedAttribute]
internal static bool <CanConvertStringLiteral>g__HasTrailingWhitespace|4_1(VirtualCharSequence characters);
    [CompilerGeneratedAttribute]
internal static SyntaxToken <GetReplacementToken>g__ConvertToSingleLineRawString|6_0(<>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static SyntaxToken <GetReplacementToken>g__ConvertToMultiLineRawIndentedString|6_1(string indentation, <>c__DisplayClass6_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertToRawString.ConvertStringToRawStringCodeRefactoringProvider : SyntaxEditorBasedCodeRefactoringProvider {
    private static BidirectionalMap`2<ConvertToRawKind, string> s_kindToEquivalenceKeyMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<IConvertStringProvider> s_convertStringProviders;
    [NullableAttribute("0")]
protected ImmutableArray`1<FixAllScope> SupportedFixAllScopes { get; }
    private static ConvertStringToRawStringCodeRefactoringProvider();
    [NullableContextAttribute("0")]
protected virtual ImmutableArray`1<FixAllScope> get_SupportedFixAllScopes();
    private static bool CanConvert(ParsedDocument parsedDocument, ExpressionSyntax expression, SyntaxFormattingOptions formattingOptions, CanConvertParams& canConvertParams, IConvertStringProvider& provider, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertToRawString.ConvertStringToRawStringCodeRefactoringProvider/<ComputeRefactoringsAsync>d__6")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertToRawString.ConvertStringToRawStringCodeRefactoringProvider/<UpdateDocumentAsync>d__7")]
private static Task`1<Document> UpdateDocumentAsync(Document document, ExpressionSyntax expression, ConvertToRawKind kind, CodeActionOptionsProvider optionsProvider, IConvertStringProvider provider, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertToRawString.ConvertStringToRawStringCodeRefactoringProvider/<FixAllAsync>d__8")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<TextSpan> fixAllSpans, SyntaxEditor editor, CodeActionOptionsProvider optionsProvider, string equivalenceKey, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.CSharp.ConvertToRawString.ConvertToRawKind : Enum {
    public int value__;
    public static ConvertToRawKind SingleLine;
    public static ConvertToRawKind MultiLineIndented;
    public static ConvertToRawKind MultiLineWithoutLeadingWhitespace;
}
internal static class Microsoft.CodeAnalysis.CSharp.ConvertToRawString.ConvertToRawStringHelpers : object {
    public static bool CanBeSingleLine(VirtualCharSequence characters);
    public static bool IsCSharpNewLine(VirtualChar ch);
    public static bool IsCSharpWhitespace(VirtualChar ch);
    public static bool IsCarriageReturnNewLine(VirtualCharSequence characters, int index);
    public static bool AllEscapesAreQuotes(VirtualCharSequence sequence);
    [NullableContextAttribute("1")]
public static bool AllEscapesAre(VirtualCharSequence sequence, Func`2<VirtualChar, bool> predicate);
    [NullableContextAttribute("2")]
public static bool IsInDirective(SyntaxNode node);
    public static bool CanConvert(VirtualCharSequence characters);
    public static bool CanConvert(VirtualChar ch);
    public static int GetLongestQuoteSequence(VirtualCharSequence characters);
    public static int GetLongestBraceSequence(VirtualCharSequence characters);
    private static int GetLongestCharacterSequence(VirtualCharSequence characters, char c);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CSharp.ConvertToRawString.IConvertStringProvider {
    public abstract virtual bool CanConvert(ParsedDocument document, ExpressionSyntax expression, SyntaxFormattingOptions formattingOptions, CanConvertParams& convertParams, CancellationToken cancellationToken);
    public abstract virtual ExpressionSyntax Convert(ParsedDocument document, ExpressionSyntax expression, ConvertToRawKind kind, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordEngine : object {
    private static SyntaxRemoveOptions RemovalOptions;
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordEngine/<GetCodeActionAsync>d__1")]
public static Task`1<CodeAction> GetCodeActionAsync(Document document, TypeDeclarationSyntax typeDeclaration, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordEngine/<ConvertToPositionalRecordAsync>d__2")]
private static Task`1<Solution> ConvertToPositionalRecordAsync(Document document, INamedTypeSymbol type, ImmutableArray`1<PositionalParameterInfo> positionalParameterInfos, TypeDeclarationSyntax typeDeclaration, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static RecordDeclarationSyntax CreateRecordDeclaration(INamedTypeSymbol type, TypeDeclarationSyntax typeDeclaration, SyntaxTriviaList modifiedClassTrivia, IEnumerable`1<ParameterSyntax> propertiesToAddAsParams, SyntaxToken recordKeyword, SyntaxTriviaList constructorTrivia, BaseListSyntax baseList);
    private static SyntaxList`1<AttributeListSyntax> GetModifiedAttributeListsForProperty(PositionalParameterInfo result);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordEngine/<RefactorInitializersAsync>d__5")]
private static Task RefactorInitializersAsync(INamedTypeSymbol type, SolutionEditor solutionEditor, ImmutableArray`1<IPropertySymbol> positionalParameters, CancellationToken cancellationToken);
    private static SyntaxTriviaList GetModifiedClassTrivia(ImmutableArray`1<PositionalParameterInfo> propertyResults, TypeDeclarationSyntax typeDeclaration, LineFormattingOptions lineFormattingOptions);
    private static Nullable`1<SyntaxTriviaList> GetExteriorTrivia(SyntaxNode declaration);
    private static Nullable`1<SyntaxTriviaList> SearchInNodes(SyntaxList`1<XmlNodeSyntax> nodes);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordEngine/<CreateParamComments>d__9")]
private static IEnumerable`1<XmlNodeSyntax> CreateParamComments(ImmutableArray`1<PositionalParameterInfo> propertyResults, SyntaxTriviaList exteriorTrivia, LineFormattingOptions lineFormattingOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.ConvertToRecord.ConvertToRecordHelpers : object {
    public static bool IsSimpleEqualsMethod(Compilation compilation, IMethodSymbol methodSymbol, IMethodBodyOperation methodBodyOperation, ImmutableArray`1<IFieldSymbol> expectedComparedFields);
    public static INamedTypeSymbol GetIEquatableType(Compilation compilation, INamedTypeSymbol containingType);
    public static bool IsSimpleHashCodeMethod(Compilation compilation, IMethodSymbol methodSymbol, IMethodBodyOperation methodOperation, ImmutableArray`1<IFieldSymbol> expectedHashedFields);
    public static bool IsDefaultEqualsOperator(IMethodBodyOperation operation);
    internal static bool IsDefaultNotEqualsOperator(IMethodBodyOperation operation);
    public static bool IsSimplePrimaryConstructor(IConstructorBodyOperation operation, ImmutableArray`1& properties, ImmutableArray`1<IParameterSymbol> parameters);
    public static bool IsSimpleCopyConstructor(IConstructorBodyOperation operation, ImmutableArray`1<IFieldSymbol> fields, IParameterSymbol parameter);
    public static ImmutableArray`1<ExpressionSyntax> GetAssignmentValuesForNonPrimaryConstructor(IConstructorBodyOperation operation, ImmutableArray`1<IPropertySymbol> positionalParams);
    public static ImmutableArray`1<ExpressionSyntax> GetAssignmentValuesFromObjectCreation(IObjectCreationOperation operation, ImmutableArray`1<IPropertySymbol> positionalParams);
    private static ImmutableArray`1<ExpressionSyntax> GetAssignmentExpressionsFromValuesMap(ImmutableArray`1<IPropertySymbol> positionalParams, ImmutableDictionary`2<ISymbol, ExpressionSyntax> assignmentValues);
    private static ImmutableDictionary`2<ISymbol, T> GetAssignmentValuesForConstructor(IConstructorBodyOperation constructorOperation, Func`2<IOperation, T> captureAssignedSymbol);
    private static bool IsSafeAssignment(IOperation operation);
    private static ImmutableArray`1<IFieldSymbol> GetEqualizedFields(IMethodBodyOperation operation, IMethodSymbol methodSymbol);
    [NullableContextAttribute("2")]
private static bool TryGetAssignmentFromParameterWithExplicitCast(IOperation operation, IParameterSymbol parameter, ISymbol& assignedVariable);
    private static IParameterSymbol GetParamFromArgument(IOperation operation);
    private static ISymbol GetReferencedSymbolObject(IOperation reference);
    private static bool IsDotEqualsInvocation(IOperation operation);
    private static bool IsNullCheck(IOperation operation, bool successRequirement, ISymbol otherObject);
    private static bool ReturnsFalseImmediately(IEnumerable`1<IOperation> operation);
    private static bool TryAddEqualizedFieldsForCondition(IOperation condition, bool successRequirement, ISymbol currentObject, ISymbol otherObject, ArrayBuilder`1<IFieldSymbol> builder);
    private static bool TryAddEqualizedFieldsForConditionWithoutTypedVariable(IOperation condition, bool successRequirement, ISymbol currentObject, ArrayBuilder`1<IFieldSymbol> builder, ISymbol& boundVariable, IEnumerable`1<IOperation> additionalConditions);
    private static bool TryAddEqualizedFieldsForStatements(IEnumerable`1<IOperation> statementsToCheck, ISymbol otherC, INamedTypeSymbol type, ArrayBuilder`1<IFieldSymbol> builder);
    private static bool TryAddFieldFromComparison(IMemberReferenceOperation memberReference1, IMemberReferenceOperation memberReference2, ISymbol currentObject, ISymbol otherObject, ArrayBuilder`1<IFieldSymbol> builder);
    private static bool TryGetBindingCastInFirstIfStatement(ImmutableArray`1<IOperation> bodyOps, IParameterSymbol parameter, INamedTypeSymbol type, ArrayBuilder`1<IFieldSymbol> builder, ISymbol& otherC, IEnumerable`1& statementsToCheck);
    private static bool TryGetSuccessCondition(IOperation whenTrue, IOperation whenFalse, IEnumerable`1<IOperation> otherOps, Boolean& successRequirement, IEnumerable`1& remainingStatements);
    private static bool OverridesEquals(Compilation compilation, IMethodSymbol equals, INamedTypeSymbol equatableType);
    private static IBlockOperation GetBlockOfMethodBody(IMethodBodyBaseOperation body);
    private static IFieldSymbol UnwrapPropertyToField(ISymbol propertyOrField);
    private static bool AreConditionsSatisfiedEitherOrder(T firstItem, T secondItem, Func`2<T, bool> firstCondition, Func`2<T, bool> secondCondition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertToRecord.CSharpConvertToRecordCodeFixProvider : CodeFixProvider {
    private static string CS8865;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertToRecord.CSharpConvertToRecordCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertToRecord.CSharpConvertToRecordRefactoringProvider : CodeRefactoringProvider {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ConvertToRecord.CSharpConvertToRecordRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.ConvertToRecord.PositionalParameterInfo : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PropertyDeclarationSyntax <Declaration>k__BackingField;
    [CompilerGeneratedAttribute]
private IPropertySymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepAsOverride>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [NullableAttribute("2")]
public PropertyDeclarationSyntax Declaration { get; public set; }
    public IPropertySymbol Symbol { get; public set; }
    public bool KeepAsOverride { get; public set; }
    [MemberNotNullWhenAttribute("False", "Declaration")]
public bool IsInherited { get; }
    public PositionalParameterInfo(PropertyDeclarationSyntax Declaration, IPropertySymbol Symbol, bool KeepAsOverride);
    [CompilerGeneratedAttribute]
protected PositionalParameterInfo(PositionalParameterInfo original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public PropertyDeclarationSyntax get_Declaration();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Declaration(PropertyDeclarationSyntax value);
    [CompilerGeneratedAttribute]
public IPropertySymbol get_Symbol();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Symbol(IPropertySymbol value);
    [CompilerGeneratedAttribute]
public bool get_KeepAsOverride();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_KeepAsOverride(bool value);
    [MemberNotNullWhenAttribute("False", "Declaration")]
public bool get_IsInherited();
    public static ImmutableArray`1<PositionalParameterInfo> GetPropertiesForPositionalParameters(ImmutableArray`1<PropertyDeclarationSyntax> properties, INamedTypeSymbol type, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static ImmutableArray`1<IPropertySymbol> GetInheritedPositionalParams(INamedTypeSymbol currentType, CancellationToken cancellationToken);
    private static ConvertStatus ShouldConvertProperty(PropertyDeclarationSyntax property, IPropertySymbol propertySymbol, INamedTypeSymbol containingType);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(PositionalParameterInfo left, PositionalParameterInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(PositionalParameterInfo left, PositionalParameterInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(PositionalParameterInfo other);
    [CompilerGeneratedAttribute]
public virtual PositionalParameterInfo <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(PropertyDeclarationSyntax& Declaration, IPropertySymbol& Symbol, Boolean& KeepAsOverride);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExtensionOrderAttribute]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ConvertTupleToStruct.IConvertTupleToStructCodeRefactoringProvider", "C#", "Default")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertTupleToStruct.CSharpConvertTupleToStructCodeRefactoringProvider : AbstractConvertTupleToStructCodeRefactoringProvider`10<ExpressionSyntax, NameSyntax, IdentifierNameSyntax, LiteralExpressionSyntax, ObjectCreationExpressionSyntax, TupleExpressionSyntax, ArgumentSyntax, TupleTypeSyntax, TypeDeclarationSyntax, BaseNamespaceDeclarationSyntax> {
    protected virtual ArgumentSyntax GetArgumentWithChangedName(ArgumentSyntax argument, string name);
    [NullableContextAttribute("2")]
private static NameColonSyntax ChangeName(NameColonSyntax nameColon, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ConvertTypeOfToNameOf.CSharpConvertTypeOfToNameOfCodeFixProvider : AbstractConvertTypeOfToNameOfCodeFixProvider`1<MemberAccessExpressionSyntax> {
    protected virtual string GetCodeFixTitle();
    protected virtual SyntaxNode GetSymbolTypeExpression(SemanticModel model, MemberAccessExpressionSyntax node, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.ConvertTypeOfToNameOf.CSharpConvertTypeOfToNameOfDiagnosticAnalyzer : AbstractConvertTypeOfToNameOfDiagnosticAnalyzer {
    [NullableAttribute("1")]
private static string s_title;
    private static CSharpConvertTypeOfToNameOfDiagnosticAnalyzer();
    protected virtual bool IsValidTypeofAction(OperationAnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.CSharp.CSharpAnalyzersResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Convert_switch_statement_to_expression { get; }
    internal static string Use_switch_expression { get; }
    internal static string Use_explicit_type_instead_of_var { get; }
    internal static string Use_explicit_type { get; }
    internal static string use_var_instead_of_explicit_type { get; }
    internal static string Use_implicit_type { get; }
    internal static string Using_directive_is_unnecessary { get; }
    internal static string Add_braces { get; }
    internal static string Add_braces_to_0_statement { get; }
    internal static string Misplaced_using_directive { get; }
    internal static string Move_misplaced_using_directives { get; }
    internal static string Using_directives_must_be_placed_inside_of_a_namespace_declaration { get; }
    internal static string Using_directives_must_be_placed_outside_of_a_namespace_declaration { get; }
    internal static string Warning_colon_Moving_using_directives_may_change_code_meaning { get; }
    internal static string Use_expression_body_for_method { get; }
    internal static string Use_block_body_for_method { get; }
    internal static string Use_block_body_for_accessor { get; }
    internal static string Use_block_body_for_constructor { get; }
    internal static string Use_block_body_for_indexer { get; }
    internal static string Use_block_body_for_operator { get; }
    internal static string Use_block_body_for_conversion_operator { get; }
    internal static string Use_block_body_for_property { get; }
    internal static string Use_expression_body_for_accessor { get; }
    internal static string Use_expression_body_for_constructor { get; }
    internal static string Use_expression_body_for_indexer { get; }
    internal static string Use_expression_body_for_operator { get; }
    internal static string Use_expression_body_for_conversion_operator { get; }
    internal static string Use_expression_body_for_property { get; }
    internal static string Use_block_body_for_local_function { get; }
    internal static string Use_expression_body_for_local_function { get; }
    internal static string Unreachable_code_detected { get; }
    internal static string Use_pattern_matching { get; }
    internal static string Use_is_null_check { get; }
    internal static string Prefer_null_check_over_type_check { get; }
    internal static string Use_simple_using_statement { get; }
    internal static string using_statement_can_be_simplified { get; }
    internal static string if_statement_can_be_simplified { get; }
    internal static string Simplify_default_expression { get; }
    internal static string default_expression_can_be_simplified { get; }
    internal static string Make_readonly_fields_writable { get; }
    internal static string Struct_contains_assignment_to_this_outside_of_constructor_Make_readonly_fields_writable { get; }
    internal static string Deconstruct_variable_declaration { get; }
    internal static string Variable_declaration_can_be_deconstructed { get; }
    internal static string Local_function_can_be_made_static { get; }
    internal static string Make_local_function_static { get; }
    internal static string _0_can_be_simplified { get; }
    internal static string Indexing_can_be_simplified { get; }
    internal static string Use_local_function { get; }
    internal static string Use_index_operator { get; }
    internal static string Use_range_operator { get; }
    internal static string Delegate_invocation_can_be_simplified { get; }
    internal static string Inline_variable_declaration { get; }
    internal static string Variable_declaration_can_be_inlined { get; }
    internal static string Negate_expression_changes_semantics { get; }
    internal static string Remove_operator_preserves_semantics { get; }
    internal static string Remove_suppression_operators { get; }
    internal static string Remove_unnecessary_suppression_operator { get; }
    internal static string Suppression_operator_has_no_effect_and_can_be_misinterpreted { get; }
    internal static string typeof_can_be_converted__to_nameof { get; }
    internal static string Use_new { get; }
    internal static string new_expression_can_be_simplified { get; }
    internal static string Discard_can_be_removed { get; }
    internal static string Remove_unnessary_discard { get; }
    internal static string Embedded_statements_must_be_on_their_own_line { get; }
    internal static string Consecutive_braces_must_not_have_a_blank_between_them { get; }
    internal static string Blank_line_not_allowed_after_constructor_initializer_colon { get; }
    internal static string Null_check_can_be_clarified { get; }
    internal static string Convert_to_file_scoped_namespace { get; }
    internal static string Convert_to_block_scoped_namespace { get; }
    internal static string Use_pattern_matching_may_change_code_meaning { get; }
    internal static string Property_pattern_can_be_simplified { get; }
    internal static string Simplify_property_pattern { get; }
    internal static string Use_tuple_to_swap_values { get; }
    internal static string Lambda_expression_can_be_removed { get; }
    internal static string Remove_unnecessary_lambda_expression { get; }
    internal static string Simplify_delegate_invocation { get; }
    internal static string Use_is_not_null_check { get; }
    internal static string Use_is_object_check { get; }
    internal static string Convert_to_Program_Main_style_program { get; }
    internal static string Convert_to_top_level_statements { get; }
    internal static string Use_Utf8_string_literal { get; }
    internal static string Nullable_directive_is_unnecessary { get; }
    internal static string Remove_unnecessary_nullable_directive { get; }
    internal static string Nullable_directive_is_redundant { get; }
    internal static string Remove_redundant_nullable_directive { get; }
    internal static string Use_expression_body_for_lambda_expression { get; }
    internal static string Use_block_body_for_lambda_expression { get; }
    internal static string Make_struct_readonly { get; }
    internal static string Struct_can_be_made_readonly { get; }
    internal static string Blank_line_not_allowed_after_conditional_expression_token { get; }
    internal static string Blank_line_not_allowed_after_arrow_expression_clause_token { get; }
    internal static string Use_nameof { get; }
    internal static string Make_member_readonly { get; }
    internal static string Member_can_be_made_readonly { get; }
    internal static string Use_primary_constructor { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Convert_switch_statement_to_expression();
    internal static string get_Use_switch_expression();
    internal static string get_Use_explicit_type_instead_of_var();
    internal static string get_Use_explicit_type();
    internal static string get_use_var_instead_of_explicit_type();
    internal static string get_Use_implicit_type();
    internal static string get_Using_directive_is_unnecessary();
    internal static string get_Add_braces();
    internal static string get_Add_braces_to_0_statement();
    internal static string get_Misplaced_using_directive();
    internal static string get_Move_misplaced_using_directives();
    internal static string get_Using_directives_must_be_placed_inside_of_a_namespace_declaration();
    internal static string get_Using_directives_must_be_placed_outside_of_a_namespace_declaration();
    internal static string get_Warning_colon_Moving_using_directives_may_change_code_meaning();
    internal static string get_Use_expression_body_for_method();
    internal static string get_Use_block_body_for_method();
    internal static string get_Use_block_body_for_accessor();
    internal static string get_Use_block_body_for_constructor();
    internal static string get_Use_block_body_for_indexer();
    internal static string get_Use_block_body_for_operator();
    internal static string get_Use_block_body_for_conversion_operator();
    internal static string get_Use_block_body_for_property();
    internal static string get_Use_expression_body_for_accessor();
    internal static string get_Use_expression_body_for_constructor();
    internal static string get_Use_expression_body_for_indexer();
    internal static string get_Use_expression_body_for_operator();
    internal static string get_Use_expression_body_for_conversion_operator();
    internal static string get_Use_expression_body_for_property();
    internal static string get_Use_block_body_for_local_function();
    internal static string get_Use_expression_body_for_local_function();
    internal static string get_Unreachable_code_detected();
    internal static string get_Use_pattern_matching();
    internal static string get_Use_is_null_check();
    internal static string get_Prefer_null_check_over_type_check();
    internal static string get_Use_simple_using_statement();
    internal static string get_using_statement_can_be_simplified();
    internal static string get_if_statement_can_be_simplified();
    internal static string get_Simplify_default_expression();
    internal static string get_default_expression_can_be_simplified();
    internal static string get_Make_readonly_fields_writable();
    internal static string get_Struct_contains_assignment_to_this_outside_of_constructor_Make_readonly_fields_writable();
    internal static string get_Deconstruct_variable_declaration();
    internal static string get_Variable_declaration_can_be_deconstructed();
    internal static string get_Local_function_can_be_made_static();
    internal static string get_Make_local_function_static();
    internal static string get__0_can_be_simplified();
    internal static string get_Indexing_can_be_simplified();
    internal static string get_Use_local_function();
    internal static string get_Use_index_operator();
    internal static string get_Use_range_operator();
    internal static string get_Delegate_invocation_can_be_simplified();
    internal static string get_Inline_variable_declaration();
    internal static string get_Variable_declaration_can_be_inlined();
    internal static string get_Negate_expression_changes_semantics();
    internal static string get_Remove_operator_preserves_semantics();
    internal static string get_Remove_suppression_operators();
    internal static string get_Remove_unnecessary_suppression_operator();
    internal static string get_Suppression_operator_has_no_effect_and_can_be_misinterpreted();
    internal static string get_typeof_can_be_converted__to_nameof();
    internal static string get_Use_new();
    internal static string get_new_expression_can_be_simplified();
    internal static string get_Discard_can_be_removed();
    internal static string get_Remove_unnessary_discard();
    internal static string get_Embedded_statements_must_be_on_their_own_line();
    internal static string get_Consecutive_braces_must_not_have_a_blank_between_them();
    internal static string get_Blank_line_not_allowed_after_constructor_initializer_colon();
    internal static string get_Null_check_can_be_clarified();
    internal static string get_Convert_to_file_scoped_namespace();
    internal static string get_Convert_to_block_scoped_namespace();
    internal static string get_Use_pattern_matching_may_change_code_meaning();
    internal static string get_Property_pattern_can_be_simplified();
    internal static string get_Simplify_property_pattern();
    internal static string get_Use_tuple_to_swap_values();
    internal static string get_Lambda_expression_can_be_removed();
    internal static string get_Remove_unnecessary_lambda_expression();
    internal static string get_Simplify_delegate_invocation();
    internal static string get_Use_is_not_null_check();
    internal static string get_Use_is_object_check();
    internal static string get_Convert_to_Program_Main_style_program();
    internal static string get_Convert_to_top_level_statements();
    internal static string get_Use_Utf8_string_literal();
    internal static string get_Nullable_directive_is_unnecessary();
    internal static string get_Remove_unnecessary_nullable_directive();
    internal static string get_Nullable_directive_is_redundant();
    internal static string get_Remove_redundant_nullable_directive();
    internal static string get_Use_expression_body_for_lambda_expression();
    internal static string get_Use_block_body_for_lambda_expression();
    internal static string get_Make_struct_readonly();
    internal static string get_Struct_can_be_made_readonly();
    internal static string get_Blank_line_not_allowed_after_conditional_expression_token();
    internal static string get_Blank_line_not_allowed_after_arrow_expression_clause_token();
    internal static string get_Use_nameof();
    internal static string get_Make_member_readonly();
    internal static string get_Member_can_be_made_readonly();
    internal static string get_Use_primary_constructor();
}
internal static class Microsoft.CodeAnalysis.CSharp.CSharpCodeFixesResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Remove_unnecessary_usings { get; }
    internal static string Add_this { get; }
    internal static string Remove_unreachable_code { get; }
    internal static string Pass_in_captured_variables_as_arguments { get; }
    internal static string Warning_colon_Adding_parameters_to_local_function_declaration_may_produce_invalid_code { get; }
    internal static string Convert_typeof_to_nameof { get; }
    internal static string Place_statement_on_following_line { get; }
    internal static string Remove_blank_lines_between_braces { get; }
    internal static string Fix_record_declaration { get; }
    internal static string Fix_constraint { get; }
    internal static string Change_return_type_from_0_to_1 { get; }
    internal static string Hide_base_member { get; }
    internal static string Add_Obsolete { get; }
    internal static string Explicitly_inherit_documentation { get; }
    internal static string Unseal_class_0 { get; }
    internal static string Use_interpolated_verbatim_string { get; }
    internal static string Add_await { get; }
    internal static string Assign_to_0 { get; }
    internal static string Compare_to_0 { get; }
    internal static string Fix_return_type { get; }
    internal static string Replace_return_with_yield_return { get; }
    internal static string Declare_as_nullable { get; }
    internal static string Place_token_on_following_line { get; }
    internal static string Assign_out_parameters { get; }
    internal static string Assign_out_parameters_at_start { get; }
    internal static string Add_parentheses_around_conditional_expression_in_interpolated_string { get; }
    internal static string Make_0_return_Task_instead_of_void { get; }
    internal static string Allow_unsafe_code_in_this_project { get; }
    internal static string Make_ref_struct { get; }
    internal static string Remove_unused_function { get; }
    internal static string Upgrade_all_csharp_projects_to_language_version_0 { get; }
    internal static string Upgrade_this_project_to_csharp_language_version_0 { get; }
    internal static string Use_0 { get; }
    internal static string Remove_in_keyword { get; }
    internal static string Remove_new_modifier { get; }
    internal static string Convert_to_positional_record { get; }
    internal static string Make_method_async { get; }
    internal static string Make_method_async_remain_void { get; }
    internal static string Make_field_required { get; }
    internal static string Make_property_required { get; }
    internal static string Use_primary_constructor_and_remove_members { get; }
    internal static string Use_primary_constructor_and_remove_fields { get; }
    internal static string Use_primary_constructor_and_remove_properties { get; }
    internal static string Use_collection_expression { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Remove_unnecessary_usings();
    internal static string get_Add_this();
    internal static string get_Remove_unreachable_code();
    internal static string get_Pass_in_captured_variables_as_arguments();
    internal static string get_Warning_colon_Adding_parameters_to_local_function_declaration_may_produce_invalid_code();
    internal static string get_Convert_typeof_to_nameof();
    internal static string get_Place_statement_on_following_line();
    internal static string get_Remove_blank_lines_between_braces();
    internal static string get_Fix_record_declaration();
    internal static string get_Fix_constraint();
    internal static string get_Change_return_type_from_0_to_1();
    internal static string get_Hide_base_member();
    internal static string get_Add_Obsolete();
    internal static string get_Explicitly_inherit_documentation();
    internal static string get_Unseal_class_0();
    internal static string get_Use_interpolated_verbatim_string();
    internal static string get_Add_await();
    internal static string get_Assign_to_0();
    internal static string get_Compare_to_0();
    internal static string get_Fix_return_type();
    internal static string get_Replace_return_with_yield_return();
    internal static string get_Declare_as_nullable();
    internal static string get_Place_token_on_following_line();
    internal static string get_Assign_out_parameters();
    internal static string get_Assign_out_parameters_at_start();
    internal static string get_Add_parentheses_around_conditional_expression_in_interpolated_string();
    internal static string get_Make_0_return_Task_instead_of_void();
    internal static string get_Allow_unsafe_code_in_this_project();
    internal static string get_Make_ref_struct();
    internal static string get_Remove_unused_function();
    internal static string get_Upgrade_all_csharp_projects_to_language_version_0();
    internal static string get_Upgrade_this_project_to_csharp_language_version_0();
    internal static string get_Use_0();
    internal static string get_Remove_in_keyword();
    internal static string get_Remove_new_modifier();
    internal static string get_Convert_to_positional_record();
    internal static string get_Make_method_async();
    internal static string get_Make_method_async_remain_void();
    internal static string get_Make_field_required();
    internal static string get_Make_property_required();
    internal static string get_Use_primary_constructor_and_remove_members();
    internal static string get_Use_primary_constructor_and_remove_fields();
    internal static string get_Use_primary_constructor_and_remove_properties();
    internal static string get_Use_collection_expression();
}
internal class Microsoft.CodeAnalysis.CSharp.CSharpDeclarationComputer : DeclarationComputer {
    public static void ComputeDeclarationsInSpan(SemanticModel model, TextSpan span, bool getSymbol, ArrayBuilder`1<DeclarationInfo> builder, CancellationToken cancellationToken);
    public static void ComputeDeclarationsInNode(SemanticModel model, ISymbol associatedSymbol, SyntaxNode node, bool getSymbol, ArrayBuilder`1<DeclarationInfo> builder, CancellationToken cancellationToken, Nullable`1<int> levelsToCompute);
    private static bool InvalidLevel(Nullable`1<int> level);
    private static Nullable`1<int> DecrementLevel(Nullable`1<int> level);
    private static void ComputeDeclarations(SemanticModel model, ISymbol associatedSymbol, SyntaxNode node, Func`3<SyntaxNode, Nullable`1<int>, bool> shouldSkip, bool getSymbol, ArrayBuilder`1<DeclarationInfo> builder, Nullable`1<int> levelsToCompute, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CSharpDeclarationComputer/<GetAttributes>d__5")]
private static IEnumerable`1<SyntaxNode> GetAttributes(SyntaxList`1<AttributeListSyntax> attributeLists);
    private static IEnumerable`1<SyntaxNode> GetParameterListInitializersAndAttributes(BaseParameterListSyntax parameterList);
    private static IEnumerable`1<SyntaxNode> GetParameterInitializersAndAttributes(ParameterSyntax parameter);
    private static IEnumerable`1<SyntaxNode> GetTypeParameterListAttributes(TypeParameterListSyntax typeParameterList);
    private static DeclarationInfo GetExpressionBodyDeclarationInfo(BasePropertyDeclarationSyntax declarationWithExpressionBody, ArrowExpressionClauseSyntax expressionBody, SemanticModel model, bool getSymbol, CancellationToken cancellationToken);
    internal static ArrowExpressionClauseSyntax GetExpressionBodySyntax(CSharpSyntaxNode node);
}
internal static class Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Conflict_s_detected { get; }
    internal static string Invert_if { get; }
    internal static string Add_await_and_ConfigureAwaitFalse { get; }
    internal static string lambda_expression { get; }
    internal static string Autoselect_disabled_due_to_potential_lambda_declaration { get; }
    internal static string member_name { get; }
    internal static string Autoselect_disabled_due_to_possible_explicitly_named_anonymous_type_member_creation { get; }
    internal static string pattern_variable { get; }
    internal static string Autoselect_disabled_due_to_potential_pattern_variable_declaration { get; }
    internal static string range_variable { get; }
    internal static string Autoselect_disabled_due_to_potential_range_variable_declaration { get; }
    internal static string Simplify_name_0 { get; }
    internal static string Simplify_member_access_0 { get; }
    internal static string Remove_this_qualification { get; }
    internal static string Cannot_determine_valid_range_of_statements_to_extract { get; }
    internal static string Not_all_code_paths_return { get; }
    internal static string Selection_does_not_contain_a_valid_node { get; }
    internal static string Contains_invalid_selection { get; }
    internal static string The_selection_contains_syntactic_errors { get; }
    internal static string Selection_can_not_cross_over_preprocessor_directives { get; }
    internal static string Selection_can_not_contain_a_yield_statement { get; }
    internal static string Selection_can_not_contain_throw_statement { get; }
    internal static string Selection_can_not_be_part_of_constant_initializer_expression { get; }
    internal static string Selection_can_not_contain_a_pattern_expression { get; }
    internal static string The_selected_code_is_inside_an_unsafe_context { get; }
    internal static string No_valid_statement_range_to_extract { get; }
    internal static string deprecated { get; }
    internal static string extension { get; }
    internal static string awaitable { get; }
    internal static string awaitable_extension { get; }
    internal static string Organize_Usings { get; }
    internal static string Generate_explicit_conversion_operator_in_0 { get; }
    internal static string Generate_implicit_conversion_operator_in_0 { get; }
    internal static string try_block { get; }
    internal static string catch_clause { get; }
    internal static string filter_clause { get; }
    internal static string finally_clause { get; }
    internal static string fixed_statement { get; }
    internal static string using_statement { get; }
    internal static string lock_statement { get; }
    internal static string foreach_statement { get; }
    internal static string asynchronous_foreach_statement { get; }
    internal static string using_declaration { get; }
    internal static string asynchronous_using_declaration { get; }
    internal static string checked_statement { get; }
    internal static string unchecked_statement { get; }
    internal static string yield_return_statement { get; }
    internal static string yield_break_statement { get; }
    internal static string await_expression { get; }
    internal static string lambda { get; }
    internal static string anonymous_method { get; }
    internal static string from_clause { get; }
    internal static string join_clause { get; }
    internal static string let_clause { get; }
    internal static string where_clause { get; }
    internal static string orderby_clause { get; }
    internal static string select_clause { get; }
    internal static string groupby_clause { get; }
    internal static string query_body { get; }
    internal static string into_clause { get; }
    internal static string is_pattern { get; }
    internal static string deconstruction { get; }
    internal static string tuple { get; }
    internal static string local_function { get; }
    internal static string out_var { get; }
    internal static string ref_local_or_expression { get; }
    internal static string switch_statement { get; }
    internal static string top_level_statement { get; }
    internal static string top_level_code { get; }
    internal static string extern_alias { get; }
    internal static string using_directive { get; }
    internal static string struct_ { get; }
    internal static string event_field { get; }
    internal static string conversion_operator { get; }
    internal static string destructor { get; }
    internal static string indexer { get; }
    internal static string property_getter { get; }
    internal static string indexer_getter { get; }
    internal static string property_setter { get; }
    internal static string indexer_setter { get; }
    internal static string attribute_target { get; }
    internal static string The_name_0_does_not_exist_in_the_current_context { get; }
    internal static string Properties { get; }
    internal static string Autoselect_disabled_due_to_namespace_declaration { get; }
    internal static string namespace_name { get; }
    internal static string Autoselect_disabled_due_to_type_declaration { get; }
    internal static string Autoselect_disabled_due_to_possible_deconstruction_declaration { get; }
    internal static string class_name { get; }
    internal static string interface_name { get; }
    internal static string designation_name { get; }
    internal static string struct_name { get; }
    internal static string Convert_to_switch_statement { get; }
    internal static string Convert_to_switch_expression { get; }
    internal static string Use_recursive_patterns { get; }
    internal static string Name { get; }
    internal static string Autoselect_disabled_due_to_member_declaration { get; }
    internal static string Suggested_name { get; }
    internal static string Convert_to_foreach { get; }
    internal static string Convert_to_for { get; }
    internal static string Convert_to_method { get; }
    internal static string Add_required_braces_for_single_line_control_statements { get; }
    internal static string Apply_expression_block_body_preferences { get; }
    internal static string Apply_inline_out_variable_preferences { get; }
    internal static string Make_private_field_readonly_when_possible { get; }
    internal static string Add_missing_usings { get; }
    internal static string Introduce_using_statement { get; }
    internal static string Warning_Inlining_temporary_into_conditional_method_call { get; }
    internal static string Warning_Inlining_temporary_variable_may_change_code_meaning { get; }
    internal static string local_variable_declaration { get; }
    internal static string switch_statement_case_clause { get; }
    internal static string Reverse_for_statement { get; }
    internal static string Convert_to_regular_string { get; }
    internal static string Convert_to_verbatim_string { get; }
    internal static string Change_to_as_expression { get; }
    internal static string Change_to_cast { get; }
    internal static string record_ { get; }
    internal static string record_struct { get; }
    internal static string Enable_nullable_reference_types_in_project { get; }
    internal static string Enable_nullable_reference_types_in_solution { get; }
    internal static string Selection_cannot_include_global_statements { get; }
    internal static string Selection_cannot_include_top_level_statements { get; }
    internal static string Convert_to_raw_string { get; }
    internal static string without_leading_whitespace_may_change_semantics { get; }
    internal static string Apply_blank_lines_between_consecutive_braces_preferences_experimental { get; }
    internal static string Apply_blank_line_after_colon_in_constructor_initializer_preferences_experimental { get; }
    internal static string Apply_conditional_delegate_call_preferences { get; }
    internal static string Apply_deconstruct_preferences { get; }
    internal static string Apply_default_T_preferences { get; }
    internal static string Apply_embedded_statements_on_same_line_preferences_experimental { get; }
    internal static string Apply_local_over_anonymous_function_preferences { get; }
    internal static string Apply_method_group_conversion_preferences { get; }
    internal static string Apply_namespace_preferences { get; }
    internal static string Apply_new_preferences { get; }
    internal static string Apply_parameter_null_preferences { get; }
    internal static string Apply_pattern_matching_preferences { get; }
    internal static string Apply_range_preferences { get; }
    internal static string Apply_static_local_function_preferences { get; }
    internal static string Apply_throw_expression_preferences { get; }
    internal static string Apply_using_statement_preferences { get; }
    internal static string Apply_var_preferences { get; }
    internal static string Add_await { get; }
    internal static string Global_using_directives { get; }
    internal static string Convert_0_to_record { get; }
    internal static string Apply_readonly_struct_preferences { get; }
    internal static string Selection_cannot_be_in_constructor_initializer { get; }
    internal static string init_only_property { get; }
    internal static string for_loop { get; }
    internal static string reversed_for_loop { get; }
    internal static string static_void_Main { get; }
    internal static string static_int_Main { get; }
    internal static string Convert_to_regular_constructor { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Conflict_s_detected();
    internal static string get_Invert_if();
    internal static string get_Add_await_and_ConfigureAwaitFalse();
    internal static string get_lambda_expression();
    internal static string get_Autoselect_disabled_due_to_potential_lambda_declaration();
    internal static string get_member_name();
    internal static string get_Autoselect_disabled_due_to_possible_explicitly_named_anonymous_type_member_creation();
    internal static string get_pattern_variable();
    internal static string get_Autoselect_disabled_due_to_potential_pattern_variable_declaration();
    internal static string get_range_variable();
    internal static string get_Autoselect_disabled_due_to_potential_range_variable_declaration();
    internal static string get_Simplify_name_0();
    internal static string get_Simplify_member_access_0();
    internal static string get_Remove_this_qualification();
    internal static string get_Cannot_determine_valid_range_of_statements_to_extract();
    internal static string get_Not_all_code_paths_return();
    internal static string get_Selection_does_not_contain_a_valid_node();
    internal static string get_Contains_invalid_selection();
    internal static string get_The_selection_contains_syntactic_errors();
    internal static string get_Selection_can_not_cross_over_preprocessor_directives();
    internal static string get_Selection_can_not_contain_a_yield_statement();
    internal static string get_Selection_can_not_contain_throw_statement();
    internal static string get_Selection_can_not_be_part_of_constant_initializer_expression();
    internal static string get_Selection_can_not_contain_a_pattern_expression();
    internal static string get_The_selected_code_is_inside_an_unsafe_context();
    internal static string get_No_valid_statement_range_to_extract();
    internal static string get_deprecated();
    internal static string get_extension();
    internal static string get_awaitable();
    internal static string get_awaitable_extension();
    internal static string get_Organize_Usings();
    internal static string get_Generate_explicit_conversion_operator_in_0();
    internal static string get_Generate_implicit_conversion_operator_in_0();
    internal static string get_try_block();
    internal static string get_catch_clause();
    internal static string get_filter_clause();
    internal static string get_finally_clause();
    internal static string get_fixed_statement();
    internal static string get_using_statement();
    internal static string get_lock_statement();
    internal static string get_foreach_statement();
    internal static string get_asynchronous_foreach_statement();
    internal static string get_using_declaration();
    internal static string get_asynchronous_using_declaration();
    internal static string get_checked_statement();
    internal static string get_unchecked_statement();
    internal static string get_yield_return_statement();
    internal static string get_yield_break_statement();
    internal static string get_await_expression();
    internal static string get_lambda();
    internal static string get_anonymous_method();
    internal static string get_from_clause();
    internal static string get_join_clause();
    internal static string get_let_clause();
    internal static string get_where_clause();
    internal static string get_orderby_clause();
    internal static string get_select_clause();
    internal static string get_groupby_clause();
    internal static string get_query_body();
    internal static string get_into_clause();
    internal static string get_is_pattern();
    internal static string get_deconstruction();
    internal static string get_tuple();
    internal static string get_local_function();
    internal static string get_out_var();
    internal static string get_ref_local_or_expression();
    internal static string get_switch_statement();
    internal static string get_top_level_statement();
    internal static string get_top_level_code();
    internal static string get_extern_alias();
    internal static string get_using_directive();
    internal static string get_struct_();
    internal static string get_event_field();
    internal static string get_conversion_operator();
    internal static string get_destructor();
    internal static string get_indexer();
    internal static string get_property_getter();
    internal static string get_indexer_getter();
    internal static string get_property_setter();
    internal static string get_indexer_setter();
    internal static string get_attribute_target();
    internal static string get_The_name_0_does_not_exist_in_the_current_context();
    internal static string get_Properties();
    internal static string get_Autoselect_disabled_due_to_namespace_declaration();
    internal static string get_namespace_name();
    internal static string get_Autoselect_disabled_due_to_type_declaration();
    internal static string get_Autoselect_disabled_due_to_possible_deconstruction_declaration();
    internal static string get_class_name();
    internal static string get_interface_name();
    internal static string get_designation_name();
    internal static string get_struct_name();
    internal static string get_Convert_to_switch_statement();
    internal static string get_Convert_to_switch_expression();
    internal static string get_Use_recursive_patterns();
    internal static string get_Name();
    internal static string get_Autoselect_disabled_due_to_member_declaration();
    internal static string get_Suggested_name();
    internal static string get_Convert_to_foreach();
    internal static string get_Convert_to_for();
    internal static string get_Convert_to_method();
    internal static string get_Add_required_braces_for_single_line_control_statements();
    internal static string get_Apply_expression_block_body_preferences();
    internal static string get_Apply_inline_out_variable_preferences();
    internal static string get_Make_private_field_readonly_when_possible();
    internal static string get_Add_missing_usings();
    internal static string get_Introduce_using_statement();
    internal static string get_Warning_Inlining_temporary_into_conditional_method_call();
    internal static string get_Warning_Inlining_temporary_variable_may_change_code_meaning();
    internal static string get_local_variable_declaration();
    internal static string get_switch_statement_case_clause();
    internal static string get_Reverse_for_statement();
    internal static string get_Convert_to_regular_string();
    internal static string get_Convert_to_verbatim_string();
    internal static string get_Change_to_as_expression();
    internal static string get_Change_to_cast();
    internal static string get_record_();
    internal static string get_record_struct();
    internal static string get_Enable_nullable_reference_types_in_project();
    internal static string get_Enable_nullable_reference_types_in_solution();
    internal static string get_Selection_cannot_include_global_statements();
    internal static string get_Selection_cannot_include_top_level_statements();
    internal static string get_Convert_to_raw_string();
    internal static string get_without_leading_whitespace_may_change_semantics();
    internal static string get_Apply_blank_lines_between_consecutive_braces_preferences_experimental();
    internal static string get_Apply_blank_line_after_colon_in_constructor_initializer_preferences_experimental();
    internal static string get_Apply_conditional_delegate_call_preferences();
    internal static string get_Apply_deconstruct_preferences();
    internal static string get_Apply_default_T_preferences();
    internal static string get_Apply_embedded_statements_on_same_line_preferences_experimental();
    internal static string get_Apply_local_over_anonymous_function_preferences();
    internal static string get_Apply_method_group_conversion_preferences();
    internal static string get_Apply_namespace_preferences();
    internal static string get_Apply_new_preferences();
    internal static string get_Apply_parameter_null_preferences();
    internal static string get_Apply_pattern_matching_preferences();
    internal static string get_Apply_range_preferences();
    internal static string get_Apply_static_local_function_preferences();
    internal static string get_Apply_throw_expression_preferences();
    internal static string get_Apply_using_statement_preferences();
    internal static string get_Apply_var_preferences();
    internal static string get_Add_await();
    internal static string get_Global_using_directives();
    internal static string get_Convert_0_to_record();
    internal static string get_Apply_readonly_struct_preferences();
    internal static string get_Selection_cannot_be_in_constructor_initializer();
    internal static string get_init_only_property();
    internal static string get_for_loop();
    internal static string get_reversed_for_loop();
    internal static string get_static_void_Main();
    internal static string get_static_int_Main();
    internal static string get_Convert_to_regular_constructor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.SnippetFunctionService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.CSharpSnippetFunctionService : SnippetFunctionService {
    public string SwitchCaseFormat { get; }
    public string SwitchDefaultCaseForm { get; }
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CSharpSnippetFunctionService/<GetContainingClassNameAsync>d__1")]
public virtual Task`1<string> GetContainingClassNameAsync(Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CSharpSnippetFunctionService/<GetEnumSymbolAsync>d__2")]
protected virtual Task`1<ITypeSymbol> GetEnumSymbolAsync(Document document, TextSpan switchExpressionSpan, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.CSharpSnippetFunctionService/<GetDocumentWithEnumCaseAsync>d__3")]
protected virtual Task`1<ValueTuple`2<Document, TextSpan>> GetDocumentWithEnumCaseAsync(Document document, string fullyQualifiedTypeName, string firstEnumMemberName, TextSpan caseGenerationLocation, CancellationToken cancellationToken);
    public virtual string get_SwitchCaseFormat();
    public virtual string get_SwitchDefaultCaseForm();
}
internal class Microsoft.CodeAnalysis.CSharp.Debugging.BreakpointResolver : AbstractBreakpointResolver {
    public BreakpointResolver(Solution solution, string text);
    protected virtual IEnumerable`1<ISymbol> GetMembers(INamedTypeSymbol type, string name);
    protected virtual bool HasMethodBody(IMethodSymbol method, CancellationToken cancellationToken);
    protected virtual void ParseText(IList`1& nameParts, Nullable`1& parameterCount);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Debugging.IBreakpointResolutionService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Debugging.CSharpBreakpointResolutionService : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Debugging.CSharpBreakpointResolutionService/<ResolveBreakpointAsync>d__1")]
public sealed virtual Task`1<BreakpointResolutionResult> ResolveBreakpointAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual Task`1<IEnumerable`1<BreakpointResolutionResult>> ResolveBreakpointsAsync(Solution solution, string name, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Debugging.ILanguageDebugInfoService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Debugging.CSharpLanguageDebugInfoService : object {
    public sealed virtual Task`1<DebugLocationInfo> GetLocationInfoAsync(Document document, int position, CancellationToken cancellationToken);
    public sealed virtual Task`1<DebugDataTipInfo> GetDataTipInfoAsync(Document document, int position, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Debugging.IProximityExpressionsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Debugging.CSharpProximityExpressionsService : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Debugging.CSharpProximityExpressionsService/<IsValidAsync>d__1")]
public sealed virtual Task`1<bool> IsValidAsync(Document document, int position, string expressionValue, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Debugging.CSharpProximityExpressionsService/<GetProximityExpressionsAsync>d__2")]
public sealed virtual Task`1<IList`1<string>> GetProximityExpressionsAsync(Document document, int position, CancellationToken cancellationToken);
    public static IList`1<string> GetProximityExpressions(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use GetProximityExpressions.")]
private static IList`1<string> Do(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    private static void AddRelevantExpressions(StatementSyntax statement, IList`1<string> expressions, bool includeDeclarations);
    private static string ConvertToString(ExpressionSyntax expression);
    private static void AddExpressionTerms(ExpressionSyntax expression, IList`1<string> terms);
    private static void AddIfValidTerm(ExpressionSyntax expression, ExpressionType type, IList`1<string> terms);
    private static bool IsValidTerm(ExpressionType type);
    private static bool IsValidExpression(ExpressionType type);
    private static void AddSubExpressionTerms(ExpressionSyntax expression, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddCastExpressionTerms(CastExpressionSyntax castExpression, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddMemberAccessExpressionTerms(MemberAccessExpressionSyntax memberAccessExpression, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddObjectCreationExpressionTerms(ObjectCreationExpressionSyntax objectionCreationExpression, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddArrayCreationExpressionTerms(ArrayCreationExpressionSyntax arrayCreationExpression, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddInvocationExpressionTerms(InvocationExpressionSyntax invocationExpression, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddPrefixUnaryExpressionTerms(PrefixUnaryExpressionSyntax prefixUnaryExpression, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddAwaitExpressionTerms(AwaitExpressionSyntax awaitExpression, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddPostfixUnaryExpressionTerms(PostfixUnaryExpressionSyntax postfixUnaryExpression, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddConditionalExpressionTerms(ConditionalExpressionSyntax conditionalExpression, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddBinaryExpressionTerms(ExpressionSyntax binaryExpression, ExpressionSyntax left, ExpressionSyntax right, IList`1<string> terms, ExpressionType& expressionType);
    private static void AddArgumentTerms(ArgumentListSyntax argumentList, IList`1<string> terms, ExpressionType& expressionType);
}
internal static class Microsoft.CodeAnalysis.CSharp.Debugging.DataTipInfoGetter : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Debugging.DataTipInfoGetter/<GetInfoAsync>d__0")]
internal static Task`1<DebugDataTipInfo> GetInfoAsync(Document document, int position, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.Debugging.LocationInfoGetter : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Debugging.LocationInfoGetter/<GetInfoAsync>d__0")]
internal static Task`1<DebugLocationInfo> GetInfoAsync(Document document, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.DecompiledSource.CSharpDecompiledSourceFormattingRule : AbstractFormattingRule {
    [NullableAttribute("1")]
public static AbstractFormattingRule Instance;
    private static CSharpDecompiledSourceFormattingRule();
    public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private static AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken previousToken, SyntaxToken currentToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.DecompiledSource.IDecompiledSourceService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.DecompiledSource.CSharpDecompiledSourceService : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.DecompiledSource.CSharpDecompiledSourceService/<AddSourceToAsync>d__1")]
public sealed virtual Task`1<Document> AddSourceToAsync(Document document, Compilation symbolCompilation, ISymbol symbol, MetadataReference metadataReference, string assemblyLocation, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.DecompiledSource.CSharpDecompiledSourceService/<FormatDocumentAsync>d__2")]
public static Task`1<Document> FormatDocumentAsync(Document document, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.DecompiledSource.CSharpDecompiledSourceService/<AddAssemblyInfoRegionAsync>d__3")]
private static Task`1<Document> AddAssemblyInfoRegionAsync(Document document, ISymbol symbol, IDecompilationService decompilationService, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.DecompiledSource.CSharpDecompiledSourceService/<ConvertDocCommentsToRegularCommentsAsync>d__4")]
private static Task`1<Document> ConvertDocCommentsToRegularCommentsAsync(Document document, IDocumentationCommentFormattingService docCommentFormattingService, CancellationToken cancellationToken);
    private static string GetFullReflectionName(INamedTypeSymbol containingType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.AddBraces.CSharpAddBracesCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.AddBraces.CSharpAddBracesDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected virtual void InitializeWorker(AnalysisContext context);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    public void AnalyzeNode(SyntaxNodeAnalysisContext context);
    private static bool ContainsInterleavedDirective(SyntaxNode statement, StatementSyntax embeddedStatement, CancellationToken cancellationToken);
    private static bool IsConsideredMultiLine(SyntaxNode statement, SyntaxNode embeddedStatement);
    private static bool RequiresBracesToMatchContext(SyntaxNode statement);
    private static IfStatementSyntax GetOutermostIfStatementOfSequence(SyntaxNode ifStatementOrElseClause);
    [NullableContextAttribute("2")]
private static bool AnyPartOfIfSequenceUsesBraces(IfStatementSyntax statement);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.Analyzers.CSharpPreferFrameworkTypeDiagnosticAnalyzer : PreferFrameworkTypeDiagnosticAnalyzerBase`5<SyntaxKind, ExpressionSyntax, TypeSyntax, IdentifierNameSyntax, PredefinedTypeSyntax> {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxKind> <SyntaxKindsOfInterest>k__BackingField;
    protected ImmutableArray`1<SyntaxKind> SyntaxKindsOfInterest { get; }
    [CompilerGeneratedAttribute]
protected virtual ImmutableArray`1<SyntaxKind> get_SyntaxKindsOfInterest();
    [NullableContextAttribute("1")]
protected virtual bool IsPredefinedTypeReplaceableWithFrameworkType(PredefinedTypeSyntax node);
    [NullableContextAttribute("1")]
protected virtual bool IsIdentifierNameReplaceableWithFrameworkType(SemanticModel semanticModel, IdentifierNameSyntax node);
    [NullableContextAttribute("1")]
protected virtual bool IsInMemberAccessOrCrefReferenceContext(ExpressionSyntax node);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Diagnostics.IAnalyzerDriverService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.CSharpAnalyzerDriverService : object {
    public sealed virtual void ComputeDeclarationsInSpan(SemanticModel model, TextSpan span, bool getSymbol, ArrayBuilder`1<DeclarationInfo> builder, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.CSharpUnboundIdentifiersDiagnosticAnalyzer : UnboundIdentifiersDiagnosticAnalyzerBase`4<SyntaxKind, SimpleNameSyntax, QualifiedNameSyntax, IncompleteMemberSyntax> {
    private LocalizableString _nameNotInContextMessageFormat;
    private static ImmutableArray`1<SyntaxKind> s_kindsOfInterest;
    protected ImmutableArray`1<SyntaxKind> SyntaxKindsOfInterest { get; }
    protected DiagnosticDescriptor DiagnosticDescriptor { get; }
    private static CSharpUnboundIdentifiersDiagnosticAnalyzer();
    protected virtual ImmutableArray`1<SyntaxKind> get_SyntaxKindsOfInterest();
    protected virtual DiagnosticDescriptor get_DiagnosticDescriptor();
    protected virtual bool IsNameOf(SyntaxNode node);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.NamingStyles.CSharpNamingStyleDiagnosticAnalyzer : NamingStyleDiagnosticAnalyzerBase`1<SyntaxKind> {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxKind> <SupportedSyntaxKinds>k__BackingField;
    protected ImmutableArray`1<SyntaxKind> SupportedSyntaxKinds { get; }
    [CompilerGeneratedAttribute]
protected virtual ImmutableArray`1<SyntaxKind> get_SupportedSyntaxKinds();
    [NullableContextAttribute("1")]
protected virtual bool ShouldIgnore(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.CSharpSimplifyTypeNamesDiagnosticAnalyzer : SimplifyTypeNamesDiagnosticAnalyzerBase`2<SyntaxKind, CSharpSimplifierOptions> {
    [NullableAttribute("0")]
private static ImmutableArray`1<SyntaxKind> s_kindsOfInterest;
    private static CSharpSimplifyTypeNamesDiagnosticAnalyzer();
    protected virtual bool IsIgnoredCodeBlock(SyntaxNode codeBlock);
    protected virtual ImmutableArray`1<Diagnostic> AnalyzeCodeBlock(CodeBlockAnalysisContext context, SyntaxNode root);
    protected virtual ImmutableArray`1<Diagnostic> AnalyzeSemanticModel(SemanticModelAnalysisContext context, SyntaxNode root, TextSpanIntervalTree codeBlockIntervalTree);
    internal virtual bool IsCandidate(SyntaxNode node);
    internal virtual bool CanSimplifyTypeNameExpression(SemanticModel model, SyntaxNode node, CSharpSimplifierOptions options, TextSpan& issueSpan, String& diagnosticId, Boolean& inDeclaration, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.SimplifyTypeNames.TypeSyntaxSimplifierWalker : CSharpSyntaxWalker {
    private static ImmutableHashSet`1<string> s_predefinedTypeMetadataNames;
    private CSharpSimplifyTypeNamesDiagnosticAnalyzer _analyzer;
    private SemanticModel _semanticModel;
    private CSharpSimplifierOptions _options;
    [NullableAttribute("2")]
private TextSpanIntervalTree _ignoredSpans;
    private CancellationToken _cancellationToken;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Builder<Diagnostic> _diagnostics;
    private PooledHashSet`1<string> _aliasedNames;
    public bool HasDiagnostics { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Diagnostic> Diagnostics { get; }
    public Builder<Diagnostic> DiagnosticsBuilder { get; }
    public TypeSyntaxSimplifierWalker(CSharpSimplifyTypeNamesDiagnosticAnalyzer analyzer, SemanticModel semanticModel, CSharpSimplifierOptions options, TextSpanIntervalTree ignoredSpans, CancellationToken cancellationToken);
    private static TypeSyntaxSimplifierWalker();
    public bool get_HasDiagnostics();
    public ImmutableArray`1<Diagnostic> get_Diagnostics();
    public Builder<Diagnostic> get_DiagnosticsBuilder();
    public sealed virtual void Dispose();
    private void AddAliasedNames(CompilationUnitSyntax compilationUnit);
    public virtual void VisitQualifiedName(QualifiedNameSyntax node);
    public virtual void VisitAliasQualifiedName(AliasQualifiedNameSyntax node);
    public virtual void VisitGenericName(GenericNameSyntax node);
    public virtual void VisitIdentifierName(IdentifierNameSyntax node);
    public virtual void VisitMemberAccessExpression(MemberAccessExpressionSyntax node);
    public virtual void VisitQualifiedCref(QualifiedCrefSyntax node);
    private bool TrySimplify(SyntaxNode node);
    [CompilerGeneratedAttribute]
private void <AddAliasedNames>g__AddAliasedName|16_0(UsingDirectiveSyntax usingDirective);
    [CompilerGeneratedAttribute]
private void <AddAliasedNames>g__AddAliasedNames|16_1(BaseNamespaceDeclarationSyntax namespaceDeclaration);
    [CompilerGeneratedAttribute]
private bool <VisitIdentifierName>g__CanReplaceIdentifierWithAlias|20_0(string identifier);
    [CompilerGeneratedAttribute]
internal static bool <VisitIdentifierName>g__CanReplaceIdentifierWithPredefinedType|20_1(string identifier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.Diagnostics.TypeStyle.CSharpTypeStyleDiagnosticAnalyzerBase : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected CSharpTypeStyleHelper Helper { get; }
    protected CSharpTypeStyleDiagnosticAnalyzerBase(string diagnosticId, EnforceOnBuild enforceOnBuild, LocalizableString title, LocalizableString message);
    protected abstract virtual CSharpTypeStyleHelper get_Helper();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("2")]
public virtual bool OpenFileOnly(SimplifierOptions options);
    protected virtual void InitializeWorker(AnalysisContext context);
    private void HandleVariableDeclaration(SyntaxNodeAnalysisContext context);
    private static Diagnostic CreateDiagnostic(DiagnosticDescriptor descriptor, SyntaxNode declaration, TextSpan diagnosticSpan, NotificationOption2 notificationOption);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.TypeStyle.CSharpUseExplicitTypeDiagnosticAnalyzer : CSharpTypeStyleDiagnosticAnalyzerBase {
    private static LocalizableString s_Title;
    private static LocalizableString s_Message;
    protected CSharpTypeStyleHelper Helper { get; }
    private static CSharpUseExplicitTypeDiagnosticAnalyzer();
    protected virtual CSharpTypeStyleHelper get_Helper();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Diagnostics.TypeStyle.CSharpUseImplicitTypeDiagnosticAnalyzer : CSharpTypeStyleDiagnosticAnalyzerBase {
    private static LocalizableString s_Title;
    private static LocalizableString s_Message;
    protected CSharpTypeStyleHelper Helper { get; }
    private static CSharpUseImplicitTypeDiagnosticAnalyzer();
    protected virtual CSharpTypeStyleHelper get_Helper();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.DisambiguateSameVariable.CSharpDisambiguateSameVariableCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string CS1717;
    private static string CS1718;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.DisambiguateSameVariable.CSharpDisambiguateSameVariableCodeFixProvider/<RegisterCodeFixesAsync>d__6")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [NullableContextAttribute("2")]
private static bool CanFix(SemanticModel semanticModel, Diagnostic diagnostic, CancellationToken cancellationToken, SimpleNameSyntax& leftName, ISymbol& matchingMember, String& title);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.DisambiguateSameVariable.CSharpDisambiguateSameVariableCodeFixProvider/<FixAllAsync>d__8")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.DocumentationComments.CSharpAddDocCommentNodesCodeFixProvider : AbstractAddDocCommentNodesCodeFixProvider`4<XmlElementSyntax, XmlNameAttributeSyntax, XmlTextSyntax, MemberDeclarationSyntax> {
    private static string CS1573;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected string NodeName { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [CompilerGeneratedAttribute]
protected virtual string get_NodeName();
    protected virtual List`1<XmlNameAttributeSyntax> GetNameAttributes(XmlElementSyntax node);
    protected virtual string GetValueFromNameAttribute(XmlNameAttributeSyntax attribute);
    [NullableContextAttribute("2")]
protected virtual SyntaxNode TryGetDocCommentNode(SyntaxTriviaList leadingTrivia);
    protected virtual string GetXmlElementLocalName(XmlElementSyntax element);
    protected virtual ImmutableArray`1<string> GetParameterNames(MemberDeclarationSyntax member);
    protected virtual XmlElementSyntax GetNewNode(string parameterName, bool isFirstNodeInComment);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <TryGetDocCommentNode>b__10_1(XmlElementSyntax element);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.DocumentationComments.IDocumentationCommentFormattingService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.DocumentationComments.CSharpDocumentationCommentFormattingService : AbstractDocumentationCommentFormattingService {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.DocumentationComments.IDocumentationCommentSnippetService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.DocumentationComments.CSharpDocumentationCommentSnippetService : AbstractDocumentationCommentSnippetService`2<DocumentationCommentTriviaSyntax, MemberDeclarationSyntax> {
    private static SymbolDisplayFormat s_format;
    public string DocumentationCommentCharacter { get; }
    protected bool AddIndent { get; }
    protected string ExteriorTriviaText { get; }
    private static CSharpDocumentationCommentSnippetService();
    public virtual string get_DocumentationCommentCharacter();
    protected virtual bool get_AddIndent();
    protected virtual string get_ExteriorTriviaText();
    protected virtual MemberDeclarationSyntax GetContainingMember(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    protected virtual bool SupportsDocumentationComments(MemberDeclarationSyntax member);
    protected virtual bool HasDocumentationComment(MemberDeclarationSyntax member);
    protected virtual int GetPrecedingDocumentationCommentCount(MemberDeclarationSyntax member);
    protected virtual List`1<string> GetDocumentationCommentStubLines(MemberDeclarationSyntax member, string existingCommentText);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.DocumentationComments.CSharpDocumentationCommentSnippetService/<GetExceptions>d__13")]
private static IEnumerable`1<string> GetExceptions(SyntaxNode member);
    private static bool IsExceptionCaughtAndNotRethrown(bool hasUsingSystem, TypeSyntax exceptionType);
    protected virtual SyntaxToken GetTokenToRight(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    protected virtual SyntaxToken GetTokenToLeft(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    protected virtual bool IsDocCommentNewLine(SyntaxToken token);
    protected virtual bool IsEndOfLineTrivia(SyntaxTrivia trivia);
    protected virtual bool IsSingleExteriorTrivia(DocumentationCommentTriviaSyntax documentationComment, String& existingCommentText);
    private static IList`1<SyntaxToken> GetTextTokensFollowingExteriorTrivia(XmlTextSyntax xmlText);
    [NullableContextAttribute("2")]
protected virtual bool EndsWithSingleExteriorTrivia(DocumentationCommentTriviaSyntax documentationComment);
    [NullableContextAttribute("2")]
protected virtual bool IsMultilineDocComment(DocumentationCommentTriviaSyntax documentationComment);
    protected virtual bool HasSkippedTrailingTrivia(SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.DocumentationComments.CSharpRemoveDocCommentNodeCodeFixProvider : AbstractRemoveDocCommentNodeCodeFixProvider`2<XmlElementSyntax, XmlTextSyntax> {
    private static string CS1571;
    private static string CS1572;
    private static string CS1710;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocCommentSignifierToken>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected string DocCommentSignifierToken { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [CompilerGeneratedAttribute]
protected virtual string get_DocCommentSignifierToken();
    protected virtual SyntaxTriviaList GetRevisedDocCommentTrivia(string docCommentText);
    protected virtual SyntaxTokenList GetTextTokens(XmlTextSyntax xmlText);
    protected virtual bool IsXmlWhitespaceToken(SyntaxToken token);
    protected virtual bool IsXmlNewLineToken(SyntaxToken token);
    private static bool IsWhitespace(string text);
}
internal class Microsoft.CodeAnalysis.CSharp.DocumentationComments.DocCommentConverter : CSharpSyntaxRewriter {
    private IDocumentationCommentFormattingService _formattingService;
    private CancellationToken _cancellationToken;
    private DocCommentConverter(IDocumentationCommentFormattingService formattingService, CancellationToken cancellationToken);
    public static SyntaxNode ConvertToRegularComments(SyntaxNode node, IDocumentationCommentFormattingService formattingService, CancellationToken cancellationToken);
    public virtual SyntaxNode Visit(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.DocumentationComments.DocCommentConverter/<ConvertDocCommentToRegularComment>d__5")]
private IEnumerable`1<SyntaxTrivia> ConvertDocCommentToRegularComment(DocumentationCommentTriviaSyntax structuredTrivia);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.DocumentHighlighting.IDocumentHighlightsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.DocumentHighlighting.CSharpDocumentHighlightsService : AbstractDocumentHighlightsService {
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public CSharpDocumentHighlightsService(IEnumerable`1<Lazy`2<IEmbeddedLanguageDocumentHighlighter, EmbeddedLanguageMetadata>> services);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.DocumentHighlighting.CSharpDocumentHighlightsService/<GetAdditionalReferencesAsync>d__1")]
protected virtual Task`1<ImmutableArray`1<Location>> GetAdditionalReferencesAsync(Document document, ISymbol symbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.EditAndContinue.BreakpointSpans : object {
    public static bool TryGetBreakpointSpan(SyntaxTree tree, int position, CancellationToken cancellationToken, TextSpan& breakpointSpan);
    private static bool IsBlank(TextLine line);
    public static bool TryGetClosestBreakpointSpan(SyntaxNode root, int position, int minLength, TextSpan& span);
    private static TextSpan CreateSpan(SyntaxToken startToken, SyntaxToken endToken);
    private static TextSpan CreateSpan(SyntaxNode node);
    private static TextSpan CreateSpan(SyntaxNode node, SyntaxToken token);
    private static TextSpan CreateSpan(SyntaxToken token);
    private static TextSpan CreateSpan(SyntaxTokenList startOpt, SyntaxNodeOrToken startFallbackOpt, SyntaxNodeOrToken endOpt);
    private static int GetEndPosition(SyntaxNodeOrToken nodeOrToken);
    private static Nullable`1<TextSpan> TryCreateSpanForNode(SyntaxNode node, int position);
    internal static Nullable`1<TextSpan> CreateSpanForConstructorDeclaration(ConstructorDeclarationSyntax constructorSyntax, int position);
    internal static TextSpan CreateSpanForImplicitConstructorInitializer(ConstructorDeclarationSyntax constructor);
    internal static IEnumerable`1<SyntaxToken> GetActiveTokensForImplicitConstructorInitializer(ConstructorDeclarationSyntax constructor);
    internal static TextSpan CreateSpanForExplicitConstructorInitializer(ConstructorInitializerSyntax constructorInitializer);
    internal static IEnumerable`1<SyntaxToken> GetActiveTokensForExplicitConstructorInitializer(ConstructorInitializerSyntax constructorInitializer);
    internal static TextSpan CreateSpanForImplicitPrimaryConstructorInitializer(TypeDeclarationSyntax typeDeclaration);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.EditAndContinue.BreakpointSpans/<GetActiveTokensForImplicitPrimaryConstructorInitializer>d__16")]
internal static IEnumerable`1<SyntaxToken> GetActiveTokensForImplicitPrimaryConstructorInitializer(TypeDeclarationSyntax typeDeclaration);
    internal static TextSpan CreateSpanForExplicitPrimaryConstructorInitializer(PrimaryConstructorBaseTypeSyntax baseTypeSyntax);
    internal static IEnumerable`1<SyntaxToken> GetActiveTokensForExplicitPrimaryConstructorInitializer(PrimaryConstructorBaseTypeSyntax baseTypeSyntax);
    internal static TextSpan CreateSpanForCopyConstructor(RecordDeclarationSyntax recordDeclaration);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.EditAndContinue.BreakpointSpans/<GetActiveTokensForCopyConstructor>d__20")]
internal static IEnumerable`1<SyntaxToken> GetActiveTokensForCopyConstructor(RecordDeclarationSyntax recordDeclaration);
    internal static TextSpan CreateSpanForRecordParameter(ParameterSyntax parameter);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.EditAndContinue.BreakpointSpans/<GetActiveTokensForRecordParameter>d__22")]
internal static IEnumerable`1<SyntaxToken> GetActiveTokensForRecordParameter(ParameterSyntax parameter);
    internal static TextSpan CreateSpanForAutoPropertyAccessor(AccessorDeclarationSyntax accessor);
    internal static IEnumerable`1<SyntaxToken> GetActiveTokensForAutoPropertyAccessor(AccessorDeclarationSyntax accessor);
    private static Nullable`1<TextSpan> TryCreateSpanForFieldDeclaration(BaseFieldDeclarationSyntax fieldDeclaration, int position);
    private static Nullable`1<TextSpan> TryCreateSpanForSwitchLabel(SwitchLabelSyntax switchLabel, int position);
    private static TextSpan CreateSpanForBlock(BlockSyntax block, int position);
    private static Nullable`1<TextSpan> TryCreateSpanForStatement(StatementSyntax statement, int position);
    private static SyntaxToken LastNotMissing(SyntaxToken token1, SyntaxToken token2);
    private static Nullable`1<TextSpan> TryCreateSpanForVariableDeclaration(VariableDeclarationSyntax declaration, int position);
    private static Nullable`1<TextSpan> TryCreateSpanForVariableDeclaration(VariableDeclarationSyntax variableDeclaration, SyntaxTokenList modifiersOpt, SyntaxToken semicolonOpt, int position);
    internal static TextSpan CreateSpanForVariableDeclarator(VariableDeclaratorSyntax variableDeclarator, SyntaxTokenList modifiers, SyntaxToken semicolon);
    internal static IEnumerable`1<SyntaxToken> GetActiveTokensForVariableDeclarator(VariableDeclaratorSyntax variableDeclarator, SyntaxTokenList modifiers, SyntaxToken semicolon);
    [NullableContextAttribute("2")]
private static VariableDeclaratorSyntax FindClosestDeclaratorWithInitializer(SeparatedSyntaxList`1<VariableDeclaratorSyntax> declarators, int position);
    [NullableContextAttribute("0")]
private static int GetItemIndexByPosition(SeparatedSyntaxList`1<TNode> list, int position);
    private static TextSpan CreateSpanForCatchClause(CatchClauseSyntax catchClause);
    private static bool IsBreakableExpression(ExpressionSyntax expression);
    private static Nullable`1<TextSpan> CreateSpanForAccessors(SyntaxList`1<AccessorDeclarationSyntax> accessors, int position);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static ParameterSyntax <TryCreateSpanForNode>g__GetParameter|9_3(int position, SeparatedSyntaxList`1<ParameterSyntax> parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.EditAndContinue.CopyConstructorDeclarationBody : InstanceConstructorDeclarationBody {
    [CompilerGeneratedAttribute]
private RecordDeclarationSyntax <recordDeclaration>P;
    public bool HasExplicitInitializer { get; }
    [NullableAttribute("2")]
public SyntaxNode ExplicitBody { get; }
    [NullableAttribute("2")]
public SyntaxNode ParameterClosure { get; }
    [NullableAttribute("2")]
public SyntaxNode MatchRoot { get; }
    public SyntaxNode InitializerActiveStatement { get; }
    public TextSpan InitializerActiveStatementSpan { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public OneOrMany`1<SyntaxNode> RootNodes { get; }
    public SyntaxNode EncompassingAncestor { get; }
    public TextSpan Envelope { get; }
    public CopyConstructorDeclarationBody(RecordDeclarationSyntax recordDeclaration);
    public virtual bool get_HasExplicitInitializer();
    [NullableContextAttribute("2")]
public virtual SyntaxNode get_ExplicitBody();
    [NullableContextAttribute("2")]
public virtual SyntaxNode get_ParameterClosure();
    [NullableContextAttribute("2")]
public virtual SyntaxNode get_MatchRoot();
    public virtual SyntaxNode get_InitializerActiveStatement();
    public virtual TextSpan get_InitializerActiveStatementSpan();
    public virtual OneOrMany`1<SyntaxNode> get_RootNodes();
    public virtual SyntaxNode get_EncompassingAncestor();
    public virtual TextSpan get_Envelope();
    public virtual ImmutableArray`1<ISymbol> GetCapturedVariables(SemanticModel model);
    [NullableContextAttribute("2")]
public virtual IEnumerable`1<SyntaxToken> GetActiveTokens();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer : AbstractEditAndContinueAnalyzer {
    protected string LineDirectiveKeyword { get; }
    protected ushort LineDirectiveSyntaxKind { get; }
    internal SyntaxNode EmptyCompilationUnit { get; }
    internal Func`2<SyntaxNode, bool> IsLambda { get; }
    internal Func`2<SyntaxNode, bool> IsNotLambda { get; }
    protected SymbolDisplayFormat ErrorDisplayFormat { get; }
    public CSharpEditAndContinueAnalyzer(Action`1<SyntaxNode> testFaultInjector);
    internal virtual bool TryFindMemberDeclaration(SyntaxNode root, SyntaxNode node, TextSpan activeSpan, OneOrMany`1& declarations);
    [NullableContextAttribute("2")]
internal virtual MemberBody TryGetDeclarationBody(SyntaxNode node, ISymbol symbol);
    internal virtual bool IsDeclarationWithSharedBody(SyntaxNode declaration, ISymbol member);
    protected virtual bool AreHandledEventsEqual(IMethodSymbol oldMethod, IMethodSymbol newMethod);
    protected virtual IEnumerable`1<SyntaxNode> GetVariableUseSites(IEnumerable`1<SyntaxNode> roots, ISymbol localOrParameter, SemanticModel model, CancellationToken cancellationToken);
    internal static SyntaxNode FindStatementAndPartner(TextSpan span, SyntaxNode body, SyntaxNode partnerBody, SyntaxNode& partnerStatement, Int32& statementPart);
    private static BlockPart GetStatementPart(BlockSyntax node, int position);
    private static TextSpan GetActiveSpan(BlockSyntax node, BlockPart part);
    private static ForEachPart GetStatementPart(CommonForEachStatementSyntax node, int position);
    private static TextSpan GetActiveSpan(ForEachStatementSyntax node, ForEachPart part);
    private static TextSpan GetActiveSpan(ForEachVariableStatementSyntax node, ForEachPart part);
    private static TextSpan GetActiveSpan(SwitchExpressionSyntax node, SwitchExpressionPart part);
    private static bool AreEquivalentIgnoringLambdaBodies(SyntaxNode left, SyntaxNode right);
    internal virtual bool IsClosureScope(SyntaxNode node);
    internal virtual SyntaxNode GetCapturedParameterScope(SyntaxNode methodOrLambda);
    protected virtual LambdaBody FindEnclosingLambdaBody(SyntaxNode encompassingAncestor, SyntaxNode node);
    protected virtual Match`1<SyntaxNode> ComputeTopLevelMatch(SyntaxNode oldCompilationUnit, SyntaxNode newCompilationUnit);
    protected virtual Nullable`1<BidirectionalMap`1<SyntaxNode>> ComputeParameterMap(SyntaxNode oldDeclaration, SyntaxNode newDeclaration);
    private static SyntaxNode GetDeclarationParameterList(SyntaxNode declaration);
    internal static Match`1<SyntaxNode> ComputeBodyMatch(SyntaxNode oldBody, SyntaxNode newBody, IEnumerable`1<KeyValuePair`2<SyntaxNode, SyntaxNode>> knownMatches);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer/<GetChildNodes>d__25")]
private static IEnumerable`1<SyntaxNode> GetChildNodes(SyntaxNode root, SyntaxNode body);
    internal static bool TryMatchActiveStatement(SyntaxNode oldBody, SyntaxNode newBody, SyntaxNode oldStatement, SyntaxNode& newStatement);
    protected virtual bool IsNamespaceDeclaration(SyntaxNode node);
    private static bool IsTypeDeclaration(SyntaxNode node);
    protected virtual bool IsCompilationUnitWithGlobalStatements(SyntaxNode node);
    protected virtual bool IsGlobalStatement(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer/<GetTopLevelTypeDeclarations>d__31")]
protected virtual IEnumerable`1<SyntaxNode> GetTopLevelTypeDeclarations(SyntaxNode compilationUnit);
    protected virtual string get_LineDirectiveKeyword();
    protected virtual ushort get_LineDirectiveSyntaxKind();
    protected virtual IEnumerable`1<SequenceEdit> GetSyntaxSequenceEdits(ImmutableArray`1<SyntaxNode> oldNodes, ImmutableArray`1<SyntaxNode> newNodes);
    internal virtual SyntaxNode get_EmptyCompilationUnit();
    internal virtual bool ExperimentalFeaturesEnabled(SyntaxTree tree);
    protected virtual bool StatementLabelEquals(SyntaxNode node1, SyntaxNode node2);
    protected virtual bool TryGetEnclosingBreakpointSpan(SyntaxToken token, TextSpan& span);
    protected virtual bool TryGetActiveSpan(SyntaxNode node, int statementPart, int minLength, TextSpan& span);
    public static ValueTuple`2<SyntaxNode, int> GetFirstBodyActiveStatement(SyntaxNode memberBody);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer/<EnumerateNearStatements>d__44")]
protected virtual IEnumerable`1<ValueTuple`2<SyntaxNode, int>> EnumerateNearStatements(SyntaxNode statement);
    protected virtual bool AreEquivalentActiveStatements(SyntaxNode oldStatement, SyntaxNode newStatement, int statementPart);
    private static bool HasEquivalentUsingDeclarations(BlockSyntax oldBlock, BlockSyntax newBlock);
    private static bool AreEquivalentActiveStatements(IfStatementSyntax oldNode, IfStatementSyntax newNode);
    private static bool AreEquivalentActiveStatements(WhileStatementSyntax oldNode, WhileStatementSyntax newNode);
    private static bool AreEquivalentActiveStatements(DoStatementSyntax oldNode, DoStatementSyntax newNode);
    private static bool AreEquivalentActiveStatements(SwitchStatementSyntax oldNode, SwitchStatementSyntax newNode);
    private static bool AreEquivalentActiveStatements(LockStatementSyntax oldNode, LockStatementSyntax newNode);
    private static bool AreEquivalentActiveStatements(FixedStatementSyntax oldNode, FixedStatementSyntax newNode);
    private static bool AreEquivalentActiveStatements(UsingStatementSyntax oldNode, UsingStatementSyntax newNode);
    private static bool AreEquivalentActiveStatements(CommonForEachStatementSyntax oldNode, CommonForEachStatementSyntax newNode);
    private static bool AreSimilarActiveStatements(CommonForEachStatementSyntax oldNode, CommonForEachStatementSyntax newNode);
    protected virtual bool AreEquivalentImpl(SyntaxToken oldToken, SyntaxToken newToken);
    internal virtual bool IsInterfaceDeclaration(SyntaxNode node);
    internal virtual bool IsRecordDeclaration(SyntaxNode node);
    internal virtual SyntaxNode TryGetContainingTypeDeclaration(SyntaxNode node);
    internal virtual bool IsDeclarationWithInitializer(SyntaxNode declaration);
    internal virtual bool IsPrimaryConstructorDeclaration(SyntaxNode declaration);
    internal virtual bool IsConstructorWithMemberInitializers(ISymbol symbol, CancellationToken cancellationToken);
    internal virtual bool IsPartial(INamedTypeSymbol type);
    protected virtual SyntaxNode GetSymbolDeclarationSyntax(ISymbol symbol, Func`2<ImmutableArray`1<SyntaxReference>, SyntaxReference> selector, CancellationToken cancellationToken);
    protected virtual ISymbol GetDeclaredSymbol(SemanticModel model, SyntaxNode declaration, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
protected virtual OneOrMany`1<ValueTuple`2<ISymbol, ISymbol>> GetEditedSymbols(EditKind editKind, SyntaxNode oldNode, SyntaxNode newNode, SemanticModel oldModel, SemanticModel newModel, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
protected virtual void AddSymbolEdits(TemporaryArray`1& result, EditKind editKind, SyntaxNode oldNode, ISymbol oldSymbol, SyntaxNode newNode, ISymbol newSymbol, SemanticModel oldModel, SemanticModel newModel, Match`1<SyntaxNode> topMatch, IReadOnlyDictionary`2<SyntaxNode, EditKind> editMap, SymbolInfoCache symbolCache, CancellationToken cancellationToken);
    private ISymbol GetSymbolForEdit(SyntaxNode node, SemanticModel model, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private ISymbol GetParameterContainingMemberOrType(SyntaxNode node, SyntaxNode otherNode, SemanticModel model, IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> fromOtherMap, CancellationToken cancellationToken);
    private static bool SupportsMove(SyntaxNode node);
    internal virtual Func`2<SyntaxNode, bool> get_IsLambda();
    internal virtual Func`2<SyntaxNode, bool> get_IsNotLambda();
    internal virtual bool IsLocalFunction(SyntaxNode node);
    internal virtual bool IsGenericLocalFunction(SyntaxNode node);
    internal virtual bool IsNestedFunction(SyntaxNode node);
    [NullableContextAttribute("2")]
internal virtual bool TryGetLambdaBodies(SyntaxNode node, LambdaBody& body1, LambdaBody& body2);
    internal virtual IMethodSymbol GetLambdaExpressionSymbol(SemanticModel model, SyntaxNode lambdaExpression, CancellationToken cancellationToken);
    internal virtual SyntaxNode GetContainingQueryExpression(SyntaxNode node);
    internal virtual bool QueryClauseLambdasTypeEquivalent(SemanticModel oldModel, SyntaxNode oldNode, SemanticModel newModel, SyntaxNode newNode, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static bool GroupBySignatureEquivalent(IMethodSymbol oldMethod, IMethodSymbol newMethod);
    protected virtual SymbolDisplayFormat get_ErrorDisplayFormat();
    protected virtual Nullable`1<TextSpan> TryGetDiagnosticSpan(SyntaxNode node, EditKind editKind);
    internal static TextSpan GetDiagnosticSpan(SyntaxNode node, EditKind editKind);
    private static Nullable`1<TextSpan> TryGetDiagnosticSpanImpl(SyntaxNode node, EditKind editKind);
    internal static Nullable`1<TextSpan> TryGetDiagnosticSpanImpl(SyntaxKind kind, SyntaxNode node, EditKind editKind);
    private static TextSpan GetDiagnosticSpan(SyntaxTokenList modifiers, SyntaxNodeOrToken start, SyntaxNodeOrToken end);
    private static TextSpan CombineSpans(TextSpan first, TextSpan second, TextSpan defaultSpan);
    internal virtual TextSpan GetLambdaParameterDiagnosticSpan(SyntaxNode lambda, int ordinal);
    internal virtual string GetDisplayName(INamedTypeSymbol symbol);
    internal virtual string GetDisplayName(IEventSymbol symbol);
    internal virtual string GetDisplayName(IPropertySymbol symbol);
    internal virtual string GetDisplayName(IMethodSymbol symbol);
    protected virtual string TryGetDisplayName(SyntaxNode node, EditKind editKind);
    internal static string GetDisplayName(SyntaxNode node, EditKind editKind);
    internal static string TryGetDisplayNameImpl(SyntaxNode node, EditKind editKind);
    protected virtual string GetSuspensionPointDisplayName(SyntaxNode node, EditKind editKind);
    internal virtual void ReportTopLevelSyntacticRudeEdits(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, Match`1<SyntaxNode> match, Edit`1<SyntaxNode> edit, Dictionary`2<SyntaxNode, EditKind> editMap);
    internal virtual bool HasUnsupportedOperation(IEnumerable`1<SyntaxNode> nodes, SyntaxNode& unsupportedNode, RudeEditKind& rudeEdit);
    internal virtual void ReportInsertedMemberSymbolRudeEdits(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, ISymbol newSymbol, SyntaxNode newNode, bool insertingIntoExistingContainingType);
    protected virtual List`1<SyntaxNode> GetExceptionHandlingAncestors(SyntaxNode node, SyntaxNode root, bool isNonLeaf);
    internal virtual void ReportEnclosingExceptionHandlingRudeEdits(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, IEnumerable`1<Edit`1<SyntaxNode>> exceptionHandlingEdits, SyntaxNode oldStatement, TextSpan newStatementSpan);
    private static bool AreExceptionClausesEquivalent(SyntaxNode oldNode, SyntaxNode newNode);
    protected virtual TextSpan GetExceptionHandlingRegion(SyntaxNode node, Boolean& coversAllChildren);
    internal virtual bool IsStateMachineMethod(SyntaxNode declaration);
    internal virtual void ReportStateMachineSuspensionPointRudeEdits(DiagnosticContext diagnosticContext, SyntaxNode oldNode, SyntaxNode newNode);
    private static SyntaxNode FindContainingStatementPart(SyntaxNode node);
    private static bool HasNoSpilledState(SyntaxNode awaitExpression, SyntaxNode containingStatementPart);
    private static ExpressionSyntax GetExpressionFromStatementPart(SyntaxNode statement);
    private static bool IsSimpleAwaitAssignment(SyntaxNode node, SyntaxNode awaitExpression);
    internal virtual void ReportOtherRudeEditsAroundActiveStatement(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> reverseMap, SyntaxNode oldActiveStatement, DeclarationBody oldBody, SyntaxNode newActiveStatement, DeclarationBody newBody, bool isNonLeaf);
    private void ReportRudeEditsForSwitchWhenClauses(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, SyntaxNode oldActiveStatement, SyntaxNode newActiveStatement);
    private static bool AreEquivalentSwitchStatementDecisionTrees(SwitchStatementSyntax oldSwitch, SwitchStatementSyntax newSwitch);
    private static bool AreSwitchSectionsEquivalent(SwitchSectionSyntax oldSection, SwitchSectionSyntax newSection);
    private static bool AreLabelsEquivalent(SwitchLabelSyntax oldLabel, SwitchLabelSyntax newLabel);
    private void ReportRudeEditsForCheckedStatements(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, SyntaxNode oldActiveStatement, SyntaxNode newActiveStatement, bool isNonLeaf);
    [NullableContextAttribute("2")]
private static CheckedStatementSyntax TryGetCheckedStatementAncestor(SyntaxNode node);
    private void ReportRudeEditsForAncestorsDeclaringInterStatementTemps(ArrayBuilder`1<RudeEditDiagnostic> diagnostics, IReadOnlyDictionary`2<SyntaxNode, SyntaxNode> reverseMap, SyntaxNode oldActiveStatement, SyntaxNode oldEncompassingAncestor, SyntaxNode newActiveStatement, SyntaxNode newEncompassingAncestor);
    private static bool DeclareSameIdentifiers(SeparatedSyntaxList`1<VariableDeclaratorSyntax> oldVariables, SeparatedSyntaxList`1<VariableDeclaratorSyntax> newVariables);
    private static bool DeclareSameIdentifiers(SyntaxToken[] oldVariables, SyntaxToken[] newVariables);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <ComputeBodyMatch>g__GetMatchingRoot|24_0(SyntaxNode body);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <AddSymbolEdits>g__DiffersInReadOnlyModifier|67_2(IMethodSymbol oldMethod, IMethodSymbol newMethod);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <GetParameterContainingMemberOrType>g__GetContainingDeclaration|69_0(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpLambdaBody : LambdaBody {
    [CompilerGeneratedAttribute]
private SyntaxNode <node>P;
    public SyntaxNode Node { get; }
    public SyntaxTree SyntaxTree { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public OneOrMany`1<SyntaxNode> RootNodes { get; }
    public SyntaxNode EncompassingAncestor { get; }
    public CSharpLambdaBody(SyntaxNode node);
    public SyntaxNode get_Node();
    public sealed virtual SyntaxTree get_SyntaxTree();
    public virtual OneOrMany`1<SyntaxNode> get_RootNodes();
    public virtual SyntaxNode get_EncompassingAncestor();
    public virtual StateMachineInfo GetStateMachineInfo();
    public virtual ImmutableArray`1<ISymbol> GetCapturedVariables(SemanticModel model);
    public virtual Match`1<SyntaxNode> ComputeSingleRootMatch(DeclarationBody newBody, IEnumerable`1<KeyValuePair`2<SyntaxNode, SyntaxNode>> knownMatches);
    public virtual DeclarationBodyMap ComputeMap(DeclarationBody newBody, IEnumerable`1<KeyValuePair`2<SyntaxNode, SyntaxNode>> knownMatches);
    public virtual bool TryMatchActiveStatement(DeclarationBody newBody, SyntaxNode oldStatement, Int32& statementPart, SyntaxNode& newStatement);
    public virtual LambdaBody TryGetPartnerLambdaBody(SyntaxNode newLambda);
    public virtual IEnumerable`1<SyntaxNode> GetExpressionsAndStatements();
    public virtual SyntaxNode GetLambda();
    public virtual bool IsSyntaxEquivalentTo(LambdaBody other);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.EditAndContinue.ExplicitAutoPropertyAccessorDeclarationBody : PropertyOrIndexerAccessorDeclarationBody {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private AccessorDeclarationSyntax <accessor>P;
    public SyntaxNode ExplicitBody { get; }
    public SyntaxNode HeaderActiveStatement { get; }
    public TextSpan HeaderActiveStatementSpan { get; }
    public SyntaxNode MatchRoot { get; }
    [NullableContextAttribute("1")]
public ExplicitAutoPropertyAccessorDeclarationBody(AccessorDeclarationSyntax accessor);
    public virtual SyntaxNode get_ExplicitBody();
    public virtual SyntaxNode get_HeaderActiveStatement();
    public virtual TextSpan get_HeaderActiveStatementSpan();
    public virtual IEnumerable`1<SyntaxToken> GetActiveTokens();
    public virtual SyntaxNode get_MatchRoot();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.EditAndContinue.FieldWithInitializerDeclarationBody : MemberBody {
    [CompilerGeneratedAttribute]
private VariableDeclaratorSyntax <variableDeclarator>P;
    public ExpressionSyntax InitializerExpression { get; }
    public SyntaxTree SyntaxTree { get; }
    public TextSpan Envelope { get; }
    public SyntaxNode EncompassingAncestor { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public OneOrMany`1<SyntaxNode> RootNodes { get; }
    public FieldWithInitializerDeclarationBody(VariableDeclaratorSyntax variableDeclarator);
    public ExpressionSyntax get_InitializerExpression();
    private BaseFieldDeclarationSyntax GetFieldDeclaration();
    public virtual SyntaxTree get_SyntaxTree();
    public virtual ImmutableArray`1<ISymbol> GetCapturedVariables(SemanticModel model);
    public virtual TextSpan get_Envelope();
    public virtual SyntaxNode get_EncompassingAncestor();
    public virtual IEnumerable`1<SyntaxToken> GetActiveTokens();
    public virtual StateMachineInfo GetStateMachineInfo();
    public virtual OneOrMany`1<SyntaxNode> get_RootNodes();
    public virtual Match`1<SyntaxNode> ComputeSingleRootMatch(DeclarationBody newBody, IEnumerable`1<KeyValuePair`2<SyntaxNode, SyntaxNode>> knownMatches);
    public virtual bool TryMatchActiveStatement(DeclarationBody newBody, SyntaxNode oldStatement, Int32& statementPart, SyntaxNode& newStatement);
    [NullableContextAttribute("2")]
public virtual SyntaxNode FindStatementAndPartner(TextSpan span, MemberBody partnerDeclarationBody, SyntaxNode& partnerStatement, Int32& statementPart);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.EditAndContinue.InstanceConstructorDeclarationBody : MemberBody {
    public bool HasExplicitInitializer { get; }
    public TextSpan InitializerActiveStatementSpan { get; }
    public SyntaxNode InitializerActiveStatement { get; }
    [NullableAttribute("2")]
public SyntaxNode MatchRoot { get; }
    [NullableAttribute("2")]
public SyntaxNode ExplicitBody { get; }
    [NullableAttribute("2")]
public SyntaxNode ParameterClosure { get; }
    public SyntaxTree SyntaxTree { get; }
    public abstract virtual bool get_HasExplicitInitializer();
    public abstract virtual TextSpan get_InitializerActiveStatementSpan();
    public abstract virtual SyntaxNode get_InitializerActiveStatement();
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode get_MatchRoot();
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode get_ExplicitBody();
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode get_ParameterClosure();
    public sealed virtual SyntaxTree get_SyntaxTree();
    public sealed virtual StateMachineInfo GetStateMachineInfo();
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode FindStatementAndPartner(TextSpan span, MemberBody partnerDeclarationBody, SyntaxNode& partnerStatement, Int32& statementPart);
    public sealed virtual bool TryMatchActiveStatement(DeclarationBody newBody, SyntaxNode oldStatement, Int32& statementPart, SyntaxNode& newStatement);
    public sealed virtual Match`1<SyntaxNode> ComputeSingleRootMatch(DeclarationBody newBody, IEnumerable`1<KeyValuePair`2<SyntaxNode, SyntaxNode>> knownMatches);
    public virtual DeclarationBodyMap ComputeMap(DeclarationBody newBody, IEnumerable`1<KeyValuePair`2<SyntaxNode, SyntaxNode>> knownMatches);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.EditAndContinue.OrdinaryInstanceConstructorDeclarationBody : InstanceConstructorDeclarationBody {
    [CompilerGeneratedAttribute]
private ConstructorDeclarationSyntax <constructor>P;
    public ConstructorDeclarationSyntax Constructor { get; }
    public SyntaxNode Body { get; }
    [NullableAttribute("2")]
public SyntaxNode ExplicitBody { get; }
    public SyntaxNode EncompassingAncestor { get; }
    [NullableAttribute("2")]
public SyntaxNode MatchRoot { get; }
    [NullableAttribute("2")]
public SyntaxNode ParameterClosure { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public OneOrMany`1<SyntaxNode> RootNodes { get; }
    protected OrdinaryInstanceConstructorDeclarationBody(ConstructorDeclarationSyntax constructor);
    public ConstructorDeclarationSyntax get_Constructor();
    public SyntaxNode get_Body();
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode get_ExplicitBody();
    public sealed virtual SyntaxNode get_EncompassingAncestor();
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode get_MatchRoot();
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode get_ParameterClosure();
    public virtual OneOrMany`1<SyntaxNode> get_RootNodes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.EditAndContinue.OrdinaryInstanceConstructorWithExplicitInitializerDeclarationBody : OrdinaryInstanceConstructorDeclarationBody {
    private ConstructorInitializerSyntax Initializer { get; }
    public bool HasExplicitInitializer { get; }
    public SyntaxNode InitializerActiveStatement { get; }
    public TextSpan InitializerActiveStatementSpan { get; }
    public TextSpan Envelope { get; }
    public OrdinaryInstanceConstructorWithExplicitInitializerDeclarationBody(ConstructorDeclarationSyntax constructor);
    private ConstructorInitializerSyntax get_Initializer();
    public virtual bool get_HasExplicitInitializer();
    public virtual SyntaxNode get_InitializerActiveStatement();
    public virtual TextSpan get_InitializerActiveStatementSpan();
    public virtual ImmutableArray`1<ISymbol> GetCapturedVariables(SemanticModel model);
    public virtual TextSpan get_Envelope();
    public virtual IEnumerable`1<SyntaxToken> GetActiveTokens();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.EditAndContinue.OrdinaryInstanceConstructorWithImplicitInitializerDeclarationBody : OrdinaryInstanceConstructorDeclarationBody {
    public SyntaxNode InitializerActiveStatement { get; }
    public bool HasExplicitInitializer { get; }
    public TextSpan InitializerActiveStatementSpan { get; }
    public TextSpan Envelope { get; }
    public OrdinaryInstanceConstructorWithImplicitInitializerDeclarationBody(ConstructorDeclarationSyntax constructor);
    public virtual SyntaxNode get_InitializerActiveStatement();
    public virtual bool get_HasExplicitInitializer();
    public virtual TextSpan get_InitializerActiveStatementSpan();
    public virtual ImmutableArray`1<ISymbol> GetCapturedVariables(SemanticModel model);
    public virtual TextSpan get_Envelope();
    public virtual IEnumerable`1<SyntaxToken> GetActiveTokens();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.EditAndContinue.PrimaryConstructorDeclarationBody : InstanceConstructorDeclarationBody {
    [CompilerGeneratedAttribute]
private TypeDeclarationSyntax <typeDeclaration>P;
    public TypeDeclarationSyntax TypeDeclaration { get; }
    [NullableAttribute("2")]
public SyntaxNode ExplicitBody { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public OneOrMany`1<SyntaxNode> RootNodes { get; }
    [NullableAttribute("2")]
public SyntaxNode ParameterClosure { get; }
    public TextSpan Envelope { get; }
    protected PrimaryConstructorDeclarationBody(TypeDeclarationSyntax typeDeclaration);
    public TypeDeclarationSyntax get_TypeDeclaration();
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode get_ExplicitBody();
    public sealed virtual OneOrMany`1<SyntaxNode> get_RootNodes();
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode get_ParameterClosure();
    public sealed virtual TextSpan get_Envelope();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.EditAndContinue.PrimaryConstructorWithExplicitInitializerDeclarationBody : PrimaryConstructorDeclarationBody {
    public PrimaryConstructorBaseTypeSyntax Initializer { get; }
    public bool HasExplicitInitializer { get; }
    public SyntaxNode InitializerActiveStatement { get; }
    public TextSpan InitializerActiveStatementSpan { get; }
    [NullableAttribute("2")]
public SyntaxNode MatchRoot { get; }
    public SyntaxNode EncompassingAncestor { get; }
    public PrimaryConstructorWithExplicitInitializerDeclarationBody(TypeDeclarationSyntax typeDeclaration);
    public PrimaryConstructorBaseTypeSyntax get_Initializer();
    public virtual bool get_HasExplicitInitializer();
    public virtual SyntaxNode get_InitializerActiveStatement();
    public virtual TextSpan get_InitializerActiveStatementSpan();
    [NullableContextAttribute("2")]
public virtual SyntaxNode get_MatchRoot();
    [NullableContextAttribute("2")]
public virtual IEnumerable`1<SyntaxToken> GetActiveTokens();
    public sealed virtual SyntaxNode get_EncompassingAncestor();
    public virtual ImmutableArray`1<ISymbol> GetCapturedVariables(SemanticModel model);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.EditAndContinue.PrimaryConstructorWithImplicitInitializerDeclarationBody : PrimaryConstructorDeclarationBody {
    public ParameterListSyntax ParameterList { get; }
    public bool HasExplicitInitializer { get; }
    public SyntaxNode InitializerActiveStatement { get; }
    public TextSpan InitializerActiveStatementSpan { get; }
    [NullableAttribute("2")]
public SyntaxNode MatchRoot { get; }
    public SyntaxNode EncompassingAncestor { get; }
    public PrimaryConstructorWithImplicitInitializerDeclarationBody(TypeDeclarationSyntax typeDeclaration);
    public ParameterListSyntax get_ParameterList();
    public virtual bool get_HasExplicitInitializer();
    public virtual SyntaxNode get_InitializerActiveStatement();
    public virtual TextSpan get_InitializerActiveStatementSpan();
    [NullableContextAttribute("2")]
public virtual SyntaxNode get_MatchRoot();
    [NullableContextAttribute("2")]
public virtual IEnumerable`1<SyntaxToken> GetActiveTokens();
    public sealed virtual SyntaxNode get_EncompassingAncestor();
    public virtual ImmutableArray`1<ISymbol> GetCapturedVariables(SemanticModel model);
    public virtual bool IsExcludedActiveStatementSpanWithinEnvelope(TextSpan span);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.EditAndContinue.PropertyOrIndexerAccessorDeclarationBody : MemberBody {
    [NullableAttribute("2")]
public SyntaxNode ExplicitBody { get; }
    [NullableAttribute("2")]
public SyntaxNode HeaderActiveStatement { get; }
    public TextSpan HeaderActiveStatementSpan { get; }
    [NullableAttribute("2")]
public SyntaxNode MatchRoot { get; }
    public SyntaxNode RootNode { get; }
    public SyntaxTree SyntaxTree { get; }
    public TextSpan Envelope { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public OneOrMany`1<SyntaxNode> RootNodes { get; }
    public SyntaxNode EncompassingAncestor { get; }
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode get_ExplicitBody();
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode get_HeaderActiveStatement();
    public abstract virtual TextSpan get_HeaderActiveStatementSpan();
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode get_MatchRoot();
    public SyntaxNode get_RootNode();
    public sealed virtual SyntaxTree get_SyntaxTree();
    public sealed virtual TextSpan get_Envelope();
    public sealed virtual OneOrMany`1<SyntaxNode> get_RootNodes();
    public sealed virtual SyntaxNode get_EncompassingAncestor();
    public sealed virtual StateMachineInfo GetStateMachineInfo();
    public sealed virtual ImmutableArray`1<ISymbol> GetCapturedVariables(SemanticModel model);
    [NullableContextAttribute("2")]
public sealed virtual SyntaxNode FindStatementAndPartner(TextSpan span, MemberBody partnerDeclarationBody, SyntaxNode& partnerStatement, Int32& statementPart);
    public sealed virtual bool TryMatchActiveStatement(DeclarationBody newBody, SyntaxNode oldStatement, Int32& statementPart, SyntaxNode& newStatement);
    public sealed virtual Match`1<SyntaxNode> ComputeSingleRootMatch(DeclarationBody newBody, IEnumerable`1<KeyValuePair`2<SyntaxNode, SyntaxNode>> knownMatches);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.EditAndContinue.PropertyOrIndexerAccessorWithExplicitBodyDeclarationBody : PropertyOrIndexerAccessorDeclarationBody {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private AccessorDeclarationSyntax <accessor>P;
    [NullableAttribute("1")]
public SyntaxNode Body { get; }
    public SyntaxNode ExplicitBody { get; }
    public SyntaxNode HeaderActiveStatement { get; }
    public TextSpan HeaderActiveStatementSpan { get; }
    public SyntaxNode MatchRoot { get; }
    [NullableContextAttribute("1")]
public PropertyOrIndexerAccessorWithExplicitBodyDeclarationBody(AccessorDeclarationSyntax accessor);
    [NullableContextAttribute("1")]
public SyntaxNode get_Body();
    public virtual SyntaxNode get_ExplicitBody();
    public virtual SyntaxNode get_HeaderActiveStatement();
    public virtual TextSpan get_HeaderActiveStatementSpan();
    public virtual SyntaxNode get_MatchRoot();
    public sealed virtual IEnumerable`1<SyntaxToken> GetActiveTokens();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.EditAndContinue.PropertyOrIndexerWithExplicitBodyDeclarationBody : PropertyOrIndexerAccessorDeclarationBody {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private BasePropertyDeclarationSyntax <propertyOrIndexer>P;
    [NullableAttribute("1")]
public ArrowExpressionClauseSyntax Body { get; }
    [NullableAttribute("1")]
public ExpressionSyntax BodyExpression { get; }
    public SyntaxNode ExplicitBody { get; }
    public SyntaxNode HeaderActiveStatement { get; }
    public TextSpan HeaderActiveStatementSpan { get; }
    public SyntaxNode MatchRoot { get; }
    [NullableContextAttribute("1")]
public PropertyOrIndexerWithExplicitBodyDeclarationBody(BasePropertyDeclarationSyntax propertyOrIndexer);
    [NullableContextAttribute("1")]
public ArrowExpressionClauseSyntax get_Body();
    [NullableContextAttribute("1")]
public ExpressionSyntax get_BodyExpression();
    public virtual SyntaxNode get_ExplicitBody();
    public virtual SyntaxNode get_HeaderActiveStatement();
    public virtual TextSpan get_HeaderActiveStatementSpan();
    public virtual SyntaxNode get_MatchRoot();
    public sealed virtual IEnumerable`1<SyntaxToken> GetActiveTokens();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.EditAndContinue.RecordParameterDeclarationBody : PropertyOrIndexerAccessorDeclarationBody {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ParameterSyntax <parameter>P;
    public SyntaxNode ExplicitBody { get; }
    public SyntaxNode HeaderActiveStatement { get; }
    public TextSpan HeaderActiveStatementSpan { get; }
    public SyntaxNode MatchRoot { get; }
    [NullableContextAttribute("1")]
public RecordParameterDeclarationBody(ParameterSyntax parameter);
    public virtual SyntaxNode get_ExplicitBody();
    public virtual SyntaxNode get_HeaderActiveStatement();
    public virtual TextSpan get_HeaderActiveStatementSpan();
    public virtual SyntaxNode get_MatchRoot();
    public virtual IEnumerable`1<SyntaxToken> GetActiveTokens();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.EditAndContinue.SimpleMemberBody : AbstractSimpleMemberBody {
    public SimpleMemberBody(SyntaxNode node);
    [NullableContextAttribute("2")]
public virtual SyntaxNode FindStatementAndPartner(TextSpan span, MemberBody partnerDeclarationBody, SyntaxNode& partnerStatement, Int32& statementPart);
    public virtual StateMachineInfo GetStateMachineInfo();
    public virtual Match`1<SyntaxNode> ComputeSingleRootMatch(DeclarationBody newBody, IEnumerable`1<KeyValuePair`2<SyntaxNode, SyntaxNode>> knownMatches);
    public virtual bool TryMatchActiveStatement(DeclarationBody newBody, SyntaxNode oldStatement, Int32& statementPart, SyntaxNode& newStatement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer : AbstractSyntaxComparer {
    internal static SyntaxComparer TopLevel;
    internal static SyntaxComparer Statement;
    protected internal int LabelCount { get; }
    [NullableContextAttribute("2")]
public SyntaxComparer(SyntaxNode oldRoot, SyntaxNode newRoot, IEnumerable`1<SyntaxNode> oldRootChildren, IEnumerable`1<SyntaxNode> newRootChildren, bool compareStatementSyntax);
    private static SyntaxComparer();
    protected virtual bool IsLambdaBodyStatementOrExpression(SyntaxNode node);
    private static int TiedToAncestor(Label label);
    [NullableContextAttribute("2")]
internal virtual int Classify(int kind, SyntaxNode node, Boolean& isLeaf);
    [NullableContextAttribute("2")]
internal Label Classify(SyntaxKind kind, SyntaxNode node, Boolean& isLeaf);
    [NullableContextAttribute("2")]
private static Label ClassifyStatementSyntax(SyntaxKind kind, SyntaxNode node, Boolean& isLeaf);
    [NullableContextAttribute("2")]
private static Label ClassifyTopSyntax(SyntaxKind kind, SyntaxNode node, Boolean& isLeaf);
    internal bool HasLabel(SyntaxKind kind);
    protected internal virtual int get_LabelCount();
    protected internal virtual int TiedToAncestor(int label);
    public virtual bool ValuesEqual(SyntaxNode left, SyntaxNode right);
    private bool Equal(SwitchSectionSyntax left, SwitchSectionSyntax right);
    private static SyntaxNode GetBody(SyntaxNode node);
    protected virtual bool TryComputeWeightedDistance(SyntaxNode leftNode, SyntaxNode rightNode, Double& distance);
    private static double ComputeWeightedDistanceOfNestedFunctions(SyntaxNode leftNode, SyntaxNode rightNode);
    private static void GetNestedFunctionsParts(SyntaxNode nestedFunction, IEnumerable`1& parameters, SyntaxToken& asyncKeyword, SyntaxNode& body, SyntaxTokenList& modifiers, TypeSyntax& returnType, SyntaxToken& identifier, TypeParameterListSyntax& typeParameters);
    private bool TryComputeWeightedDistance(BlockSyntax leftBlock, BlockSyntax rightBlock, Double& distance);
    private double ComputeWeightedDistance(SingleVariableDesignationSyntax leftNode, SingleVariableDesignationSyntax rightNode);
    private static double ComputeWeightedBlockDistance(BlockSyntax leftBlock, BlockSyntax rightBlock);
    private static double ComputeWeightedDistance(CatchClauseSyntax left, CatchClauseSyntax right);
    private static double ComputeWeightedDistance(CommonForEachStatementSyntax leftCommonForEach, CommonForEachStatementSyntax rightCommonForEach);
    private static double ComputeWeightedDistance(ForStatementSyntax left, ForStatementSyntax right);
    private static double ComputeWeightedDistance(VariableDeclarationSyntax leftVariables, StatementSyntax leftStatement, VariableDeclarationSyntax rightVariables, StatementSyntax rightStatement);
    private static double ComputeWeightedDistance(SyntaxNode leftHeader, StatementSyntax leftStatement, SyntaxNode rightHeader, StatementSyntax rightStatement);
    private static double AdjustForLocalsInBlock(double distance, StatementSyntax leftStatement, StatementSyntax rightStatement, double localsWeight);
    [NullableContextAttribute("2")]
private static bool TryComputeLocalsDistance(VariableDeclarationSyntax left, VariableDeclarationSyntax right, Double& distance);
    private static bool TryComputeLocalsDistance(BlockSyntax left, BlockSyntax right, Double& distance);
    private static void GetLocalNames(BlockSyntax block, List`1& result);
    private static void GetLocalNames(VariableDeclarationSyntax localDeclaration, List`1& result);
    internal static void GetLocalNames(CommonForEachStatementSyntax commonForEach, List`1& result);
    private static void GetLocalNames(ExpressionSyntax expression, List`1& result);
    private static void GetLocalNames(VariableDesignationSyntax designation, List`1& result);
    [NullableContextAttribute("2")]
private static void GetLocalNames(SyntaxToken syntaxToken, List`1& result);
    [NullableContextAttribute("2")]
private static double CombineOptional(double distance0, SyntaxNode left1, SyntaxNode right1, SyntaxNode left2, SyntaxNode right2, double weight0, double weight1);
    private static Nullable`1<SyntaxNodeOrToken> TryGetName(SyntaxNode node);
    public sealed virtual double GetDistance(SyntaxNode oldNode, SyntaxNode newNode);
    [NullableContextAttribute("2")]
internal static double ComputeValueDistance(SyntaxNode oldNode, SyntaxNode newNode);
    internal static double ComputeDistance(SyntaxNodeOrToken oldNodeOrToken, SyntaxNodeOrToken newNodeOrToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer/<GetDescendantTokensIgnoringSeparators>d__42`1")]
internal static IEnumerable`1<SyntaxToken> GetDescendantTokensIgnoringSeparators(SeparatedSyntaxList`1<TSyntaxNode> list);
    [NullableContextAttribute("2")]
public static double ComputeDistance(SyntaxNode oldNode, SyntaxNode newNode);
    public static double ComputeDistance(SyntaxToken oldToken, SyntaxToken newToken);
    [NullableContextAttribute("2")]
private static ImmutableArray`1<T> CreateArrayForDistanceCalculation(IEnumerable`1<T> enumerable);
    [NullableContextAttribute("2")]
public static double ComputeDistance(IEnumerable`1<SyntaxToken> oldTokens, IEnumerable`1<SyntaxToken> newTokens);
    public static double ComputeDistance(IEnumerable`1<SyntaxNode> oldNodes, IEnumerable`1<SyntaxNode> newNodes);
    public static IEnumerable`1<SequenceEdit> GetSequenceEdits(IEnumerable`1<SyntaxNode> oldNodes, IEnumerable`1<SyntaxNode> newNodes);
    public static IEnumerable`1<SequenceEdit> GetSequenceEdits(ImmutableArray`1<SyntaxNode> oldNodes, ImmutableArray`1<SyntaxNode> newNodes);
    [NullableContextAttribute("2")]
public static IEnumerable`1<SequenceEdit> GetSequenceEdits(IEnumerable`1<SyntaxToken> oldTokens, IEnumerable`1<SyntaxToken> newTokens);
    [NullableContextAttribute("0")]
public static IEnumerable`1<SequenceEdit> GetSequenceEdits(ImmutableArray`1<SyntaxToken> oldTokens, ImmutableArray`1<SyntaxToken> newTokens);
    [CompilerGeneratedAttribute]
private bool <ValuesEqual>b__14_0(SyntaxKind childKind);
    [CompilerGeneratedAttribute]
private bool <ValuesEqual>b__14_1(SyntaxKind childKind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxUtilities : object {
    public static LambdaBody CreateLambdaBody(SyntaxNode node);
    [NullableContextAttribute("2")]
public static MemberBody TryGetDeclarationBody(SyntaxNode node, ISymbol symbol);
    [NullableContextAttribute("2")]
internal static MemberBody CreateSimpleBody(SyntaxNode body);
    [NullableContextAttribute("2")]
public static SyntaxNode BlockOrExpression(BlockSyntax blockBody, ArrowExpressionClauseSyntax expressionBody);
    [ConditionalAttribute("DEBUG")]
public static void AssertIsBody(SyntaxNode syntax, bool allowLambda);
    [ExtensionAttribute]
public static bool ContainsGlobalStatements(CompilationUnitSyntax compilationUnit);
    [NullableContextAttribute("2")]
public static bool Any(TypeParameterListSyntax list);
    public static SyntaxNode TryGetEffectiveGetterBody(SyntaxNode declaration);
    [NullableContextAttribute("2")]
public static SyntaxNode TryGetEffectiveGetterBody(ArrowExpressionClauseSyntax propertyBody, AccessorListSyntax accessorList);
    public static Nullable`1<SyntaxTokenList> TryGetFieldOrPropertyModifiers(SyntaxNode node);
    public static bool IsParameterlessConstructor(SyntaxNode declaration);
    public static bool HasBackingField(PropertyDeclarationSyntax property);
    public static bool IsAsyncDeclaration(SyntaxNode declaration);
    public static IEnumerable`1<SyntaxNode> GetSuspensionPoints(SyntaxNode body);
    public static bool IsIterator(SyntaxNode body);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.EditAndContinue.TopLevelCodeDeclarationBody : MemberBody {
    [CompilerGeneratedAttribute]
private CompilationUnitSyntax <unit>P;
    public CompilationUnitSyntax Unit { get; }
    private IEnumerable`1<GlobalStatementSyntax> GlobalStatements { get; }
    public SyntaxTree SyntaxTree { get; }
    public TextSpan Envelope { get; }
    public SyntaxNode EncompassingAncestor { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public OneOrMany`1<SyntaxNode> RootNodes { get; }
    public TopLevelCodeDeclarationBody(CompilationUnitSyntax unit);
    public CompilationUnitSyntax get_Unit();
    private IEnumerable`1<GlobalStatementSyntax> get_GlobalStatements();
    public virtual SyntaxTree get_SyntaxTree();
    public virtual ImmutableArray`1<ISymbol> GetCapturedVariables(SemanticModel model);
    public virtual TextSpan get_Envelope();
    public virtual SyntaxNode get_EncompassingAncestor();
    [NullableContextAttribute("2")]
public virtual IEnumerable`1<SyntaxToken> GetActiveTokens();
    public virtual StateMachineInfo GetStateMachineInfo();
    public virtual OneOrMany`1<SyntaxNode> get_RootNodes();
    public virtual Match`1<SyntaxNode> ComputeSingleRootMatch(DeclarationBody newBody, IEnumerable`1<KeyValuePair`2<SyntaxNode, SyntaxNode>> knownMatches);
    [NullableContextAttribute("2")]
public virtual SyntaxNode FindStatementAndPartner(TextSpan span, MemberBody partnerDeclarationBody, SyntaxNode& partnerStatement, Int32& statementPart);
    public virtual bool TryMatchActiveStatement(DeclarationBody newBody, SyntaxNode oldStatement, Int32& statementPart, SyntaxNode& newStatement);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.EmbeddedLanguages.CSharpJsonDetectionAnalyzer : AbstractJsonDetectionAnalyzer {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.EmbeddedLanguages.CSharpJsonDetectionCodeFixProvider : AbstractJsonDetectionCodeFixProvider {
    [NullableContextAttribute("1")]
protected virtual void AddComment(SyntaxEditor editor, SyntaxToken stringLiteral, string commentContents);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.EmbeddedLanguages.CSharpJsonDiagnosticAnalyzer : AbstractJsonDiagnosticAnalyzer {
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.EmbeddedLanguages.CSharpRegexDiagnosticAnalyzer : AbstractRegexDiagnosticAnalyzer {
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.EmbeddedLanguages.IEmbeddedLanguagesProvider", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.EmbeddedLanguages.LanguageServices.CSharpEmbeddedLanguagesProvider : AbstractEmbeddedLanguagesProvider {
    public static EmbeddedLanguageInfo Info;
    private static CSharpEmbeddedLanguagesProvider();
    [NullableContextAttribute("1")]
public virtual string EscapeText(string text, SyntaxToken token);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.EncapsulateField.AbstractEncapsulateFieldService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.EncapsulateField.CSharpEncapsulateFieldService : AbstractEncapsulateFieldService {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.EncapsulateField.CSharpEncapsulateFieldService/<RewriteFieldNameAndAccessibilityAsync>d__1")]
protected virtual Task`1<SyntaxNode> RewriteFieldNameAndAccessibilityAsync(string originalFieldName, bool makePrivate, Document document, SyntaxAnnotation declarationAnnotation, CodeAndImportGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.EncapsulateField.CSharpEncapsulateFieldService/<GetFieldsAsync>d__2")]
protected virtual Task`1<ImmutableArray`1<IFieldSymbol>> GetFieldsAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    private bool CanEncapsulate(FieldDeclarationSyntax field);
    protected virtual ValueTuple`2<string, string> GenerateFieldAndPropertyNames(IFieldSymbol field);
    private static bool IsNew(IFieldSymbol field);
    private static string GenerateFieldName(string correspondingPropertyName);
    protected static string MakeUnique(string baseName, INamedTypeSymbol containingType);
    internal virtual IEnumerable`1<SyntaxNode> GetConstructorNodes(INamedTypeSymbol containingType);
}
internal interface Microsoft.CodeAnalysis.CSharp.ExternalAccess.Pythia.Api.IPythiaDeclarationNameRecommenderImplementation {
    public abstract virtual Task`1<ImmutableArray`1<string>> ProvideRecommendationsAsync(PythiaDeclarationNameContext context, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ExternalAccess.Pythia.Api.PythiaDeclarationNameContext : ValueType {
    private CSharpSyntaxContext _context;
    public Document Document { get; }
    public int Position { get; }
    public SemanticModel SemanticModel { get; }
    public SyntaxToken LeftToken { get; }
    public PythiaDeclarationNameContext(CSharpSyntaxContext context);
    public Document get_Document();
    public int get_Position();
    public SemanticModel get_SemanticModel();
    public SyntaxToken get_LeftToken();
}
[ExportDeclarationNameRecommenderAttribute("PythiaDeclarationNameRecommender")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ExternalAccess.Pythia.PythiaDeclarationNameRecommender : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<IPythiaDeclarationNameRecommenderImplementation> _lazyImplementation;
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public PythiaDeclarationNameRecommender(Lazy`1<IPythiaDeclarationNameRecommenderImplementation> implementation);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ExternalAccess.Pythia.PythiaDeclarationNameRecommender/<ProvideRecommendedNamesAsync>d__2")]
public sealed virtual Task`1<ImmutableArray`1<ValueTuple`2<string, Glyph>>> ProvideRecommendedNamesAsync(CompletionContext completionContext, Document document, CSharpSyntaxContext syntaxContext, NameDeclarationInfo nameInfo, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ExtractInterface.AbstractExtractInterfaceService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ExtractInterface.CSharpExtractInterfaceService : AbstractExtractInterfaceService {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ExtractInterface.CSharpExtractInterfaceService/<GetTypeDeclarationAsync>d__1")]
protected virtual Task`1<SyntaxNode> GetTypeDeclarationAsync(Document document, int position, TypeDiscoveryRule typeDiscoveryRule, CancellationToken cancellationToken);
    internal virtual string GetContainingNamespaceDisplay(INamedTypeSymbol typeSymbol, CompilationOptions compilationOptions);
    internal virtual bool IsExtractableMember(ISymbol m);
    internal virtual bool ShouldIncludeAccessibilityModifier(SyntaxNode typeNode);
    protected virtual Task`1<Solution> UpdateMembersWithExplicitImplementationsAsync(Solution unformattedSolution, IReadOnlyList`1<DocumentId> documentIds, INamedTypeSymbol extractedInterface, INamedTypeSymbol typeToExtractFrom, IEnumerable`1<ISymbol> includedMembers, ImmutableDictionary`2<ISymbol, SyntaxAnnotation> symbolToDeclarationMap, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportAttribute("Microsoft.CodeAnalysis.ExtractMethod.IExtractMethodService")]
[SharedAttribute]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ExtractMethod.IExtractMethodService", "C#", "Default")]
internal class Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpExtractMethodService : AbstractExtractMethodService`5<CSharpSelectionValidator, CSharpMethodExtractor, CSharpSelectionResult, StatementSyntax, ExpressionSyntax> {
    protected virtual CSharpSelectionValidator CreateSelectionValidator(SemanticDocument document, TextSpan textSpan, ExtractMethodOptions options, bool localFunction);
    protected virtual CSharpMethodExtractor CreateMethodExtractor(CSharpSelectionResult selectionResult, ExtractMethodGenerationOptions options, bool localFunction);
}
internal class Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor : MethodExtractor`3<CSharpSelectionResult, StatementSyntax, ExpressionSyntax> {
    public CSharpMethodExtractor(CSharpSelectionResult result, ExtractMethodGenerationOptions options, bool localFunction);
    protected virtual CodeGenerator<CSharpSelectionResult, StatementSyntax, ExpressionSyntax> CreateCodeGenerator(AnalyzerResult<CSharpSelectionResult, StatementSyntax, ExpressionSyntax> analyzerResult);
    protected virtual AnalyzerResult<CSharpSelectionResult, StatementSyntax, ExpressionSyntax> Analyze(CSharpSelectionResult selectionResult, bool localFunction, CancellationToken cancellationToken);
    protected virtual SyntaxNode GetInsertionPointNode(AnalyzerResult<CSharpSelectionResult, StatementSyntax, ExpressionSyntax> analyzerResult, CancellationToken cancellationToken);
    private bool OriginalSelectionWithin(SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor/<PreserveTriviaAsync>d__6")]
protected virtual Task`1<TriviaResult<CSharpSelectionResult, StatementSyntax, ExpressionSyntax>> PreserveTriviaAsync(CSharpSelectionResult selectionResult, CancellationToken cancellationToken);
    protected virtual Task`1<GeneratedCode<CSharpSelectionResult, StatementSyntax, ExpressionSyntax>> GenerateCodeAsync(InsertionPoint insertionPoint, CSharpSelectionResult selectionResult, AnalyzerResult<CSharpSelectionResult, StatementSyntax, ExpressionSyntax> analyzeResult, CodeGenerationOptions options, CancellationToken cancellationToken);
    protected virtual AbstractFormattingRule GetCustomFormattingRule(Document document);
    protected virtual Nullable`1<SyntaxToken> GetInvocationNameToken(IEnumerable`1<SyntaxToken> methodNames);
    protected virtual SyntaxNode ParseTypeName(string name);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpMethodExtractor/<InsertNewLineBeforeLocalFunctionIfNecessaryAsync>d__11")]
protected virtual Task`1<ValueTuple`2<Document, Nullable`1<SyntaxToken>>> InsertNewLineBeforeLocalFunctionIfNecessaryAsync(Document document, Nullable`1<SyntaxToken> invocationNameToken, SyntaxNode methodDefinition, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private SyntaxNode <GetInsertionPointNode>g__GetInsertionPointForGlobalStatement|4_0(GlobalStatementSyntax globalStatement, MemberDeclarationSyntax memberNode, <>c__DisplayClass4_0& );
}
internal abstract class Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSelectionResult : SelectionResult`1<StatementSyntax> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected CSharpSelectionResult(TextSpan originalSpan, TextSpan finalSpan, ExtractMethodOptions options, bool selectionInExpression, SemanticDocument document, SyntaxAnnotation firstTokenAnnotation, SyntaxAnnotation lastTokenAnnotation, bool selectionChanged);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSelectionResult/<CreateAsync>d__0")]
public static Task`1<CSharpSelectionResult> CreateAsync(TextSpan originalSpan, TextSpan finalSpan, ExtractMethodOptions options, bool selectionInExpression, SemanticDocument document, SyntaxToken firstToken, SyntaxToken lastToken, bool selectionChanged, CancellationToken cancellationToken);
    protected virtual ISyntaxFacts get_SyntaxFacts();
    public virtual SyntaxNode GetNodeForDataFlowAnalysis();
    protected virtual bool UnderAnonymousOrLocalMethod(SyntaxToken token, SyntaxToken firstToken, SyntaxToken lastToken);
    public virtual SyntaxNode GetOutermostCallSiteContainerToProcess(CancellationToken cancellationToken);
    public virtual StatementSyntax GetFirstStatementUnderContainer();
    public virtual StatementSyntax GetLastStatementUnderContainer();
    public SyntaxNode GetInnermostStatementContainer();
    public bool ShouldPutUnsafeModifier();
    public SyntaxKind UnderCheckedExpressionContext();
    public SyntaxKind UnderCheckedStatementContext();
    private SyntaxKind UnderCheckedContext();
    [NullableContextAttribute("2")]
private static bool IsCoClassImplicitConversion(TypeInfo info, Conversion conversion, ISymbol coclassSymbol);
}
internal class Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSelectionValidator : SelectionValidator`2<CSharpSelectionResult, StatementSyntax> {
    private bool _localFunction;
    public CSharpSelectionValidator(SemanticDocument document, TextSpan textSpan, ExtractMethodOptions options, bool localFunction);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSelectionValidator/<GetValidSelectionAsync>d__2")]
public virtual Task`1<ValueTuple`2<CSharpSelectionResult, OperationStatus>> GetValidSelectionAsync(CancellationToken cancellationToken);
    private SelectionInfo<CSharpSelectionResult, StatementSyntax> ApplySpecialCases(SelectionInfo<CSharpSelectionResult, StatementSyntax> selectionInfo, SourceText text, ParseOptions options, bool localFunction);
    private static TextSpan GetControlFlowSpan(SelectionInfo<CSharpSelectionResult, StatementSyntax> selectionInfo);
    private static SelectionInfo<CSharpSelectionResult, StatementSyntax> AdjustFinalTokensBasedOnContext(SelectionInfo<CSharpSelectionResult, StatementSyntax> selectionInfo, SemanticModel semanticModel, CancellationToken cancellationToken);
    private SelectionInfo<CSharpSelectionResult, StatementSyntax> GetInitialSelectionInfo(SyntaxNode root, SourceText text);
    private static bool UnderValidContext(SyntaxToken token);
    private static bool CheckTopLevel(SyntaxNode node, TextSpan span);
    private static bool ContainsInBlockBody(BlockSyntax block, TextSpan textSpan);
    private static bool ContainsInExpressionBodiedMemberBody(ArrowExpressionClauseSyntax expressionBodiedMember, TextSpan textSpan);
    private static SelectionInfo<CSharpSelectionResult, StatementSyntax> CheckErrorCasesAndAppendDescriptions(SelectionInfo<CSharpSelectionResult, StatementSyntax> selectionInfo, SyntaxNode root);
    private static SelectionInfo<CSharpSelectionResult, StatementSyntax> AssignInitialFinalTokens(SelectionInfo<CSharpSelectionResult, StatementSyntax> selectionInfo, SyntaxNode root, CancellationToken cancellationToken);
    private static SelectionInfo<CSharpSelectionResult, StatementSyntax> AssignFinalSpan(SelectionInfo<CSharpSelectionResult, StatementSyntax> selectionInfo, SourceText text);
    public virtual bool ContainsNonReturnExitPointsStatements(IEnumerable`1<SyntaxNode> jumpsOutOfRegion);
    public virtual IEnumerable`1<SyntaxNode> GetOuterReturnStatements(SyntaxNode commonRoot, IEnumerable`1<SyntaxNode> jumpsOutOfRegion);
    public virtual bool IsFinalSpanSemanticallyValidSpan(SyntaxNode root, TextSpan textSpan, IEnumerable`1<SyntaxNode> returnStatements, CancellationToken cancellationToken);
    private static TextSpan GetAdjustedSpan(SourceText text, TextSpan textSpan);
    public static bool Check(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    private static bool CheckGlobalStatement();
    private static bool CheckBlock(BlockSyntax block);
    private static bool CheckExpression(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    private static bool CheckStatement(StatementSyntax statement);
}
internal class Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSyntaxTriviaService : AbstractSyntaxTriviaService {
    [NullableAttribute("1")]
public static CSharpSyntaxTriviaService Instance;
    private static CSharpSyntaxTriviaService();
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.ExtractMethod.ISyntaxTriviaService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ExtractMethod.CSharpSyntaxTriviaServiceFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.ExtractMethod.Extensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ExpressionSyntax GetUnparenthesizedExpression(ExpressionSyntax node);
    [ExtensionAttribute]
public static StatementSyntax GetStatementUnderContainer(SyntaxNode node);
    [ExtensionAttribute]
public static StatementSyntax GetParentLabeledStatementIfPossible(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsStatementContainerNode(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static BlockSyntax GetBlockBody(SyntaxNode node);
    [ExtensionAttribute]
public static bool UnderValidContext(SyntaxNode node);
    [ExtensionAttribute]
public static bool ContainsInArgument(ConstructorInitializerSyntax initializer, TextSpan textSpan);
    [ExtensionAttribute]
public static bool ContainedInValidType(SyntaxNode node);
    [ExtensionAttribute]
public static bool PartOfConstantInitializerExpression(SyntaxNode node);
    [ExtensionAttribute]
private static bool PartOfConstantInitializerExpression(SyntaxNode node, Func`2<T, SyntaxTokenList> modifiersGetter);
    [ExtensionAttribute]
public static bool ContainArgumentlessThrowWithoutEnclosingCatch(IEnumerable`1<SyntaxToken> tokens, TextSpan textSpan);
    [ExtensionAttribute]
public static bool ContainPreprocessorCrossOver(IEnumerable`1<SyntaxToken> tokens, TextSpan textSpan);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ExtractMethod.Extensions/<GetAllTrivia>d__12")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxTrivia> GetAllTrivia(IEnumerable`1<SyntaxToken> tokens);
    [ExtensionAttribute]
public static bool HasSyntaxAnnotation(HashSet`1<SyntaxAnnotation> set, SyntaxNode node);
    [ExtensionAttribute]
public static bool HasHybridTriviaBetween(SyntaxToken token1, SyntaxToken token2);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsArrayInitializer(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsExpressionInCast(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsObjectType(ITypeSymbol type);
    [ExtensionAttribute]
public static bool BetweenFieldAndNonFieldMember(SyntaxToken token1, SyntaxToken token2);
}
[ExportEmbeddedLanguageClassifierAttribute("C#-Test", "Mono.Cecil.CustomAttributeArgument[]", "False", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Features.EmbeddedLanguages.CSharpTestEmbeddedLanguageClassifier : object {
    private static TextSpan FromBounds(VirtualChar vc1, VirtualChar vc2);
    public sealed virtual void RegisterClassifications(EmbeddedLanguageClassificationContext context);
    [NullableContextAttribute("1")]
private static IEnumerable`1<ClassifiedSpan> GetTestFileClassifiedSpans(SolutionServices solutionServices, SemanticModel semanticModel, VirtualCharSequence virtualCharsWithoutMarkup, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private static VirtualCharSequence StripMarkupCharacters(VirtualCharSequence virtualChars, ArrayBuilder`1<TextSpan> markdownSpans, CancellationToken cancellationToken);
    private static void AddClassifications(EmbeddedLanguageClassificationContext context, VirtualCharSequence virtualChars, ClassifiedSpan classifiedSpan);
    [CompilerGeneratedAttribute]
internal static bool <StripMarkupCharacters>g__TryConsumeNamedSpanStart|4_0(Int32& i, int n, <>c__DisplayClass4_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Features.EmbeddedLanguages.EmbeddedLanguageUtilities : object {
    internal static void AddComment(SyntaxEditor editor, SyntaxToken stringLiteral, string commentContents);
    public static string EscapeText(string text, SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.FileHeaders.CSharpFileHeaderCodeFixProvider : AbstractFileHeaderCodeFixProvider {
    protected AbstractFileHeaderHelper FileHeaderHelper { get; }
    protected virtual AbstractFileHeaderHelper get_FileHeaderHelper();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.FileHeaders.CSharpFileHeaderDiagnosticAnalyzer : AbstractFileHeaderDiagnosticAnalyzer {
    protected AbstractFileHeaderHelper FileHeaderHelper { get; }
    protected virtual AbstractFileHeaderHelper get_FileHeaderHelper();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.FileHeaders.CSharpFileHeaderHelper : AbstractFileHeaderHelper {
    public static CSharpFileHeaderHelper Instance;
    public string CommentPrefix { get; }
    private static CSharpFileHeaderHelper();
    public virtual string get_CommentPrefix();
    [NullableContextAttribute("0")]
protected virtual ReadOnlyMemory`1<char> GetTextContextOfComment(SyntaxTrivia commentTrivia);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.FindUsages.IFindUsagesLSPService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.FindUsages.CSharpFindUsagesLSPService : AbstractFindUsagesService {
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.FindUsages.IFindUsagesService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.FindUsages.CSharpFindUsagesService : AbstractFindUsagesService {
}
[ExportNewDocumentFormattingProviderAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpNamespaceDeclarationNewDocumentFormattingProvider : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Formatting.CSharpNamespaceDeclarationNewDocumentFormattingProvider/<FormatNewDocumentAsync>d__1")]
public sealed virtual Task`1<Document> FormatNewDocumentAsync(Document document, Document hintDocument, CodeCleanupOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Formatting.CSharpNamespaceDeclarationNewDocumentFormattingProvider/<GetNamespacesToReplace>d__2")]
private static IEnumerable`1<BaseNamespaceDeclarationSyntax> GetNamespacesToReplace(Document document, CompilationUnitSyntax root, CodeStyleOption2`1<NamespaceDeclarationPreference> option);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Formatting.INewDocumentFormattingService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpNewDocumentFormattingService : AbstractNewDocumentFormattingService {
    protected string Language { get; }
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public CSharpNewDocumentFormattingService(IEnumerable`1<Lazy`2<INewDocumentFormattingProvider, LanguageMetadata>> providers);
    protected virtual string get_Language();
}
[ExportNewDocumentFormattingProviderAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpOrganizeUsingsNewDocumentFormattingProvider : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Formatting.CSharpOrganizeUsingsNewDocumentFormattingProvider/<FormatNewDocumentAsync>d__1")]
public sealed virtual Task`1<Document> FormatNewDocumentAsync(Document document, Document hintDocument, CodeCleanupOptions options, CancellationToken cancellationToken);
}
[ExportNewDocumentFormattingProviderAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Formatting.CSharpUseProgramMainNewDocumentFormattingProvider : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Formatting.CSharpUseProgramMainNewDocumentFormattingProvider/<FormatNewDocumentAsync>d__1")]
public sealed virtual Task`1<Document> FormatNewDocumentAsync(Document document, Document hintDocument, CodeCleanupOptions options, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateConstructor.IGenerateConstructorService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateConstructor.CSharpGenerateConstructorService : AbstractGenerateConstructorService`2<CSharpGenerateConstructorService, ExpressionSyntax> {
    protected virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    protected virtual bool IsSimpleNameGeneration(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual bool IsConstructorInitializerGeneration(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual bool IsImplicitObjectCreation(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken);
    protected virtual bool TryInitializeConstructorInitializerGeneration(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& token, ImmutableArray`1& arguments, INamedTypeSymbol& typeToGenerateIn);
    private static ImmutableArray`1<Argument<CSharpGenerateConstructorService, ExpressionSyntax>> GetArguments(SeparatedSyntaxList`1<ArgumentSyntax> arguments);
    private static ImmutableArray`1<Argument<CSharpGenerateConstructorService, ExpressionSyntax>> GetArguments(SeparatedSyntaxList`1<AttributeArgumentSyntax> arguments);
    protected virtual bool TryInitializeSimpleNameGenerationState(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& token, ImmutableArray`1& arguments, INamedTypeSymbol& typeToGenerateIn);
    protected virtual bool TryInitializeSimpleAttributeNameGenerationState(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& token, ImmutableArray`1& arguments, INamedTypeSymbol& typeToGenerateIn);
    protected virtual bool TryInitializeImplicitObjectCreation(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& token, ImmutableArray`1& arguments, INamedTypeSymbol& typeToGenerateIn);
    protected virtual string GenerateNameForExpression(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    protected virtual ITypeSymbol GetArgumentType(SemanticModel semanticModel, Argument<CSharpGenerateConstructorService, ExpressionSyntax> argument, CancellationToken cancellationToken);
    protected virtual bool IsConversionImplicit(Compilation compilation, ITypeSymbol sourceType, ITypeSymbol targetType);
    protected virtual IMethodSymbol GetCurrentConstructor(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    protected virtual IMethodSymbol GetDelegatedConstructor(SemanticModel semanticModel, IMethodSymbol constructor, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateConstructor.GenerateConstructorCodeFixProvider : AbstractGenerateMemberCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected virtual bool IsCandidate(SyntaxNode node, SyntaxToken token, Diagnostic diagnostic);
    protected virtual SyntaxNode GetTargetNode(SyntaxNode node);
}
internal static class Microsoft.CodeAnalysis.CSharp.GenerateConstructor.GenerateConstructorDiagnosticIds : object {
    public static string CS0122;
    public static string CS1729;
    public static string CS1739;
    public static string CS1503;
    public static string CS1660;
    public static string CS7036;
    public static ImmutableArray`1<string> AllDiagnosticIds;
    public static ImmutableArray`1<string> TooManyArgumentsDiagnosticIds;
    public static ImmutableArray`1<string> CannotConvertDiagnosticIds;
    private static GenerateConstructorDiagnosticIds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
[IntentProviderAttribute("GenerateConstructor", "C#")]
internal class Microsoft.CodeAnalysis.CSharp.GenerateConstructorFromMembers.CSharpGenerateConstructorFromMembersCodeRefactoringProvider : AbstractGenerateConstructorFromMembersCodeRefactoringProvider {
    internal CSharpGenerateConstructorFromMembersCodeRefactoringProvider(IPickMembersService pickMembersService_forTesting);
    protected virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    protected virtual string ToDisplayString(IParameterSymbol parameter, SymbolDisplayFormat format);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.GenerateConstructorFromMembers.CSharpGenerateConstructorFromMembersCodeRefactoringProvider/<PrefersThrowExpressionAsync>d__4")]
protected virtual ValueTask`1<bool> PrefersThrowExpressionAsync(Document document, SimplifierOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected virtual IFieldSymbol TryMapToWritableInstanceField(IPropertySymbol property, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static string GetAccessedMemberName(SyntaxNode body);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateDefaultConstructors.CSharpGenerateDefaultConstructorsCodeFixProvider : AbstractGenerateDefaultConstructorCodeFixProvider {
    private static string CS1729;
    private static string CS7036;
    private static string CS8983;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Nullable`1<SyntaxToken> TryGetTypeName(SyntaxNode typeDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateDefaultConstructors.IGenerateDefaultConstructorsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateDefaultConstructors.CSharpGenerateDefaultConstructorsService : AbstractGenerateDefaultConstructorsService`1<CSharpGenerateDefaultConstructorsService> {
    protected virtual bool TryInitializeState(SemanticDocument semanticDocument, TextSpan textSpan, CancellationToken cancellationToken, INamedTypeSymbol& classType);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateEqualsAndGetHashCodeFromMembers.IGenerateEqualsAndGetHashCodeService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateEqualsAndGetHashCodeFromMembers.CSharpGenerateEqualsAndGetHashCodeService : AbstractGenerateEqualsAndGetHashCodeService {
    protected virtual bool TryWrapWithUnchecked(ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1& wrappedStatements);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateEnumMember.IGenerateEnumMemberService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateMember.GenerateEnumMember.CSharpGenerateEnumMemberService : AbstractGenerateEnumMemberService`3<CSharpGenerateEnumMemberService, SimpleNameSyntax, ExpressionSyntax> {
    protected virtual bool IsIdentifierNameGeneration(SyntaxNode node);
    protected virtual bool TryInitializeIdentifierNameState(SemanticDocument document, SimpleNameSyntax identifierName, CancellationToken cancellationToken, SyntaxToken& identifierToken, ExpressionSyntax& simpleNameOrMemberAccessExpression);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.IGenerateDeconstructMemberService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateMember.GenerateMethod.CSharpGenerateDeconstructMethodService : AbstractGenerateDeconstructMethodService`4<CSharpGenerateDeconstructMethodService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> {
    protected virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    protected virtual AbstractInvocationInfo<CSharpGenerateDeconstructMethodService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> CreateInvocationMethodInfo(SemanticDocument document, State<CSharpGenerateDeconstructMethodService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> state);
    protected virtual bool AreSpecialOptionsActive(SemanticModel semanticModel);
    protected virtual bool IsValidSymbol(ISymbol symbol, SemanticModel semanticModel);
    public virtual ImmutableArray`1<IParameterSymbol> TryMakeParameters(SemanticModel semanticModel, SyntaxNode target, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.IGenerateParameterizedMemberService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateMember.GenerateMethod.CSharpGenerateMethodService : AbstractGenerateMethodService`4<CSharpGenerateMethodService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> {
    protected virtual bool IsExplicitInterfaceGeneration(SyntaxNode node);
    protected virtual bool IsSimpleNameGeneration(SyntaxNode node);
    protected virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    protected virtual AbstractInvocationInfo<CSharpGenerateMethodService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> CreateInvocationMethodInfo(SemanticDocument document, State<CSharpGenerateMethodService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> state);
    protected virtual bool AreSpecialOptionsActive(SemanticModel semanticModel);
    protected virtual bool IsValidSymbol(ISymbol symbol, SemanticModel semanticModel);
    protected virtual bool TryInitializeExplicitInterfaceState(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& identifierToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    protected virtual bool TryInitializeSimpleNameState(SemanticDocument document, SimpleNameSyntax simpleName, CancellationToken cancellationToken, SyntaxToken& identifierToken, ExpressionSyntax& simpleNameOrMemberAccessExpression, InvocationExpressionSyntax& invocationExpressionOpt, Boolean& isInConditionalAccessExpression);
    protected virtual ITypeSymbol DetermineReturnTypeForSimpleNameOrMemberAccessExpression(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.GenerateMember.GenerateMethod.CSharpGenerateParameterizedMemberService`1 : AbstractGenerateParameterizedMemberService`4<TService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> {
}
internal static class Microsoft.CodeAnalysis.CSharp.GenerateMember.GenerateParameterizedMember.CSharpCommonGenerationServiceMethods : object {
    public static bool AreSpecialOptionsActive();
    public static bool IsValidSymbol();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateParameterizedMember.IGenerateConversionService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateMember.GenerateParameterizedMember.CSharpGenerateConversionService : AbstractGenerateConversionService`4<CSharpGenerateConversionService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> {
    protected virtual bool IsImplicitConversionGeneration(SyntaxNode node);
    protected virtual bool IsExplicitConversionGeneration(SyntaxNode node);
    protected virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    protected virtual AbstractInvocationInfo<CSharpGenerateConversionService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> CreateInvocationMethodInfo(SemanticDocument document, State<CSharpGenerateConversionService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> state);
    protected virtual bool AreSpecialOptionsActive(SemanticModel semanticModel);
    protected virtual bool IsValidSymbol(ISymbol symbol, SemanticModel semanticModel);
    protected virtual bool TryInitializeImplicitConversionState(SemanticDocument document, SyntaxNode expression, ISet`1<TypeKind> classInterfaceModuleStructTypes, CancellationToken cancellationToken, SyntaxToken& identifierToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    protected virtual bool TryInitializeExplicitConversionState(SemanticDocument document, SyntaxNode expression, ISet`1<TypeKind> classInterfaceModuleStructTypes, CancellationToken cancellationToken, SyntaxToken& identifierToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    private static bool TryGetConversionMethodAndTypeToGenerateIn(SemanticDocument document, SyntaxNode expression, ISet`1<TypeKind> classInterfaceModuleStructTypes, CancellationToken cancellationToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    private static bool TryGetExplicitConversionMethodAndTypeToGenerateIn(SemanticDocument document, CastExpressionSyntax castExpression, ISet`1<TypeKind> classInterfaceModuleStructTypes, CancellationToken cancellationToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    private static bool TryGetImplicitConversionMethodAndTypeToGenerateIn(SemanticDocument document, SyntaxNode expression, ISet`1<TypeKind> classInterfaceModuleStructTypes, CancellationToken cancellationToken, IMethodSymbol& methodSymbol, INamedTypeSymbol& typeToGenerateIn);
    private static IMethodSymbol GenerateMethodSymbol(INamedTypeSymbol typeToGenerateIn, INamedTypeSymbol parameterSymbol);
    protected virtual string GetImplicitConversionDisplayText(State<CSharpGenerateConversionService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> state);
    protected virtual string GetExplicitConversionDisplayText(State<CSharpGenerateConversionService, SimpleNameSyntax, ExpressionSyntax, InvocationExpressionSyntax> state);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateMember.GenerateVariable.IGenerateVariableService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateMember.GenerateVariable.CSharpGenerateVariableService : AbstractGenerateVariableService`3<CSharpGenerateVariableService, SimpleNameSyntax, ExpressionSyntax> {
    protected virtual bool IsExplicitInterfaceGeneration(SyntaxNode node);
    protected virtual bool IsIdentifierNameGeneration(SyntaxNode node);
    private static bool IsProbablySyntacticConstruct(SyntaxToken token);
    protected virtual bool ContainingTypesOrSelfHasUnsafeKeyword(INamedTypeSymbol containingType);
    protected virtual bool TryInitializeExplicitInterfaceState(SemanticDocument document, SyntaxNode node, CancellationToken cancellationToken, SyntaxToken& identifierToken, IPropertySymbol& propertySymbol, INamedTypeSymbol& typeToGenerateIn);
    protected virtual bool TryInitializeIdentifierNameState(SemanticDocument document, SimpleNameSyntax identifierName, CancellationToken cancellationToken, SyntaxToken& identifierToken, ExpressionSyntax& simpleNameOrMemberAccessExpression, Boolean& isInExecutableBlock, Boolean& isConditionalAccessExpression);
    private static bool IsProbablyGeneric(SimpleNameSyntax identifierName, CancellationToken cancellationToken);
    private static bool IsLegal(SemanticDocument document, ExpressionSyntax expression, CancellationToken cancellationToken);
    protected virtual bool TryConvertToLocalDeclaration(ITypeSymbol type, SyntaxToken identifierToken, SemanticModel semanticModel, CancellationToken cancellationToken, SyntaxNode& newRoot);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GenerateType.IGenerateTypeService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateType.CSharpGenerateTypeService : AbstractGenerateTypeService`6<CSharpGenerateTypeService, SimpleNameSyntax, ObjectCreationExpressionSyntax, ExpressionSyntax, TypeDeclarationSyntax, ArgumentSyntax> {
    private static IMethodSymbol s_accessor;
    protected string DefaultFileExtension { get; }
    private static CSharpGenerateTypeService();
    protected virtual string get_DefaultFileExtension();
    protected virtual ExpressionSyntax GetLeftSideOfDot(SimpleNameSyntax simpleName);
    protected virtual bool IsInCatchDeclaration(ExpressionSyntax expression);
    protected virtual bool IsArrayElementType(ExpressionSyntax expression);
    protected virtual bool IsInValueTypeConstraintContext(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    protected virtual bool IsInInterfaceList(ExpressionSyntax expression);
    protected virtual bool TryGetNameParts(ExpressionSyntax expression, IList`1& nameParts);
    protected virtual bool TryInitializeState(SemanticDocument document, SimpleNameSyntax simpleName, CancellationToken cancellationToken, GenerateTypeServiceStateOptions& generateTypeServiceStateOptions);
    private static IMethodSymbol GetMethodSymbolIfPresent(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    private static Accessibility DetermineAccessibilityConstraint(State<CSharpGenerateTypeService, SimpleNameSyntax, ObjectCreationExpressionSyntax, ExpressionSyntax, TypeDeclarationSyntax, ArgumentSyntax> state, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool AllContainingTypesArePublicOrProtected(State<CSharpGenerateTypeService, SimpleNameSyntax, ObjectCreationExpressionSyntax, ExpressionSyntax, TypeDeclarationSyntax, ArgumentSyntax> state, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual ImmutableArray`1<ITypeParameterSymbol> GetTypeParameters(State<CSharpGenerateTypeService, SimpleNameSyntax, ObjectCreationExpressionSyntax, ExpressionSyntax, TypeDeclarationSyntax, ArgumentSyntax> state, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected virtual bool TryGetArgumentList(ObjectCreationExpressionSyntax objectCreationExpression, IList`1& argumentList);
    protected virtual IList`1<ParameterName> GenerateParameterNames(SemanticModel semanticModel, IList`1<ArgumentSyntax> arguments, CancellationToken cancellationToken);
    public virtual string GetRootNamespace(CompilationOptions options);
    protected virtual bool IsInVariableTypeContext(ExpressionSyntax expression);
    protected virtual INamedTypeSymbol DetermineTypeToGenerateIn(SemanticModel semanticModel, SimpleNameSyntax simpleName, CancellationToken cancellationToken);
    protected virtual Accessibility GetAccessibility(State<CSharpGenerateTypeService, SimpleNameSyntax, ObjectCreationExpressionSyntax, ExpressionSyntax, TypeDeclarationSyntax, ArgumentSyntax> state, SemanticModel semanticModel, bool intoNamespace, CancellationToken cancellationToken);
    protected virtual ITypeSymbol DetermineArgumentType(SemanticModel semanticModel, ArgumentSyntax argument, CancellationToken cancellationToken);
    protected virtual bool IsConversionImplicit(Compilation compilation, ITypeSymbol sourceType, ITypeSymbol targetType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.GenerateType.CSharpGenerateTypeService/<GetOrGenerateEnclosingNamespaceSymbolAsync>d__22")]
public virtual Task`1<ValueTuple`3<INamespaceSymbol, INamespaceOrTypeSymbol, Location>> GetOrGenerateEnclosingNamespaceSymbolAsync(INamedTypeSymbol namedTypeSymbol, String[] containers, Document selectedDocument, SyntaxNode selectedDocumentRoot, CancellationToken cancellationToken);
    private BaseNamespaceDeclarationSyntax FindNamespaceInMemberDeclarations(SyntaxList`1<MemberDeclarationSyntax> members, int indexDone, List`1<string> containers);
    private BaseNamespaceDeclarationSyntax FindNamespaceInNamespace(BaseNamespaceDeclarationSyntax namespaceDecl, int indexDone, List`1<string> containers);
    private static bool IdentifierMatches(int indexDone, List`1<string> namespaceContainers, List`1<string> containers);
    private static void GetNamespaceContainers(NameSyntax name, List`1<string> namespaceContainers);
    internal virtual bool TryGetBaseList(ExpressionSyntax expression, TypeKindOptions& typeKindValue);
    internal virtual bool IsPublicOnlyAccessibility(ExpressionSyntax expression, Project project);
    private static bool IsAllContainingTypeDeclsPublic(SyntaxNode node);
    internal virtual bool IsGenericName(SimpleNameSyntax simpleName);
    internal virtual bool IsSimpleName(ExpressionSyntax expression);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.GenerateType.CSharpGenerateTypeService/<TryAddUsingsOrImportToDocumentAsync>d__32")]
internal virtual Task`1<Solution> TryAddUsingsOrImportToDocumentAsync(Solution updatedSolution, SyntaxNode modifiedRoot, Document document, SimpleNameSyntax simpleName, string includeUsingsOrImports, AddImportPlacementOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static ITypeSymbol GetPropertyType(SimpleNameSyntax propertyName, SemanticModel semanticModel, ITypeInferenceService typeInference, CancellationToken cancellationToken);
    private static IPropertySymbol CreatePropertySymbol(SimpleNameSyntax propertyName, ITypeSymbol propertyType);
    internal virtual bool TryGenerateProperty(SimpleNameSyntax propertyName, SemanticModel semanticModel, ITypeInferenceService typeInference, CancellationToken cancellationToken, IPropertySymbol& property);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GenerateVariable.CSharpGenerateVariableCodeFixProvider : AbstractGenerateMemberCodeFixProvider {
    private static string CS1061;
    private static string CS0103;
    private static string CS0117;
    private static string CS0539;
    private static string CS0246;
    private static string CS0120;
    private static string CS0118;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsCandidate(SyntaxNode node, SyntaxToken token, Diagnostic diagnostic);
    protected virtual SyntaxNode GetTargetNode(SyntaxNode node);
    protected virtual Task`1<ImmutableArray`1<CodeAction>> GetCodeActionsAsync(Document document, SyntaxNode node, CleanCodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GoToDefinition.IGoToDefinitionSymbolService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.GoToDefinition.CSharpGoToDefinitionSymbolService : AbstractGoToDefinitionSymbolService {
    protected virtual ISymbol FindRelatedExplicitlyDeclaredSymbol(ISymbol symbol, Compilation compilation);
    protected virtual Nullable`1<int> GetTargetPositionIfControlFlow(SemanticModel semanticModel, SyntaxToken token);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static SyntaxNode <GetTargetPositionIfControlFlow>g__TryFindContinuableConstruct|2_0(SyntaxNode node);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static SyntaxNode <GetTargetPositionIfControlFlow>g__TryFindBreakableConstruct|2_1(SyntaxNode node);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static SyntaxNode <GetTargetPositionIfControlFlow>g__TryFindContainingReturnableConstruct|2_2(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ImplementAbstractClass.CSharpImplementAbstractClassCodeFixProvider : AbstractImplementAbstractClassCodeFixProvider`1<TypeDeclarationSyntax> {
    private static string CS0534;
    protected virtual SyntaxToken GetClassIdentifier(TypeDeclarationSyntax classNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.ImplementInterface.AbstractChangeImplementationCodeRefactoringProvider : CodeRefactoringProvider {
    private static SymbolDisplayFormat NameAndTypeParametersFormat;
    protected string Implement_0 { get; }
    protected string Implement_all_interfaces { get; }
    protected string Implement { get; }
    private static AbstractChangeImplementationCodeRefactoringProvider();
    protected abstract virtual string get_Implement_0();
    protected abstract virtual string get_Implement_all_interfaces();
    protected abstract virtual string get_Implement();
    [NullableContextAttribute("2")]
protected abstract virtual bool CheckExplicitNameAllowsConversion(ExplicitInterfaceSpecifierSyntax explicitName);
    protected abstract virtual bool CheckMemberCanBeConverted(ISymbol member);
    protected abstract virtual SyntaxNode ChangeImplementation(SyntaxGenerator generator, SyntaxNode currentDecl, ISymbol implMember, ISymbol interfaceMember);
    protected abstract virtual Task UpdateReferencesAsync(Project project, SolutionEditor solutionEditor, ISymbol implMember, INamedTypeSymbol containingType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ImplementInterface.AbstractChangeImplementationCodeRefactoringProvider/<ComputeRefactoringsAsync>d__11")]
public sealed virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ImplementInterface.AbstractChangeImplementationCodeRefactoringProvider/<GetContainerAsync>d__12")]
private static Task`1<ValueTuple`3<SyntaxNode, ExplicitInterfaceSpecifierSyntax, SyntaxToken>> GetContainerAsync(CodeRefactoringContext context);
    private static ValueTuple`3<SyntaxNode, ExplicitInterfaceSpecifierSyntax, SyntaxToken> GetContainer(SyntaxToken token);
    private static int TotalCount(OrderedMultiDictionary`2<ISymbol, ISymbol> dictionary);
    private OrderedMultiDictionary`2<ISymbol, ISymbol> GetImplementedMembers(INamedTypeSymbol containingType, ImmutableArray`1<INamedTypeSymbol> interfaceTypes);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ImplementInterface.AbstractChangeImplementationCodeRefactoringProvider/<ChangeImplementationAsync>d__16")]
private Task`1<Solution> ChangeImplementationAsync(Project project, OrderedMultiDictionary`2<ISymbol, ISymbol> implMemberToInterfaceMembers, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ImplementInterface.CSharpImplementExplicitlyCodeRefactoringProvider : AbstractChangeImplementationCodeRefactoringProvider {
    protected string Implement_0 { get; }
    protected string Implement_all_interfaces { get; }
    protected string Implement { get; }
    protected virtual string get_Implement_0();
    protected virtual string get_Implement_all_interfaces();
    protected virtual string get_Implement();
    [NullableContextAttribute("2")]
protected virtual bool CheckExplicitNameAllowsConversion(ExplicitInterfaceSpecifierSyntax explicitName);
    protected virtual bool CheckMemberCanBeConverted(ISymbol member);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ImplementInterface.CSharpImplementExplicitlyCodeRefactoringProvider/<UpdateReferencesAsync>d__9")]
protected virtual Task UpdateReferencesAsync(Project project, SolutionEditor solutionEditor, ISymbol implMember, INamedTypeSymbol interfaceType, CancellationToken cancellationToken);
    private static void UpdateLocation(SemanticModel semanticModel, INamedTypeSymbol interfaceType, SyntaxEditor editor, ISyntaxFactsService syntaxFacts, Location location, CancellationToken cancellationToken);
    protected virtual SyntaxNode ChangeImplementation(SyntaxGenerator generator, SyntaxNode decl, ISymbol implMember, ISymbol interfaceMember);
    private static bool AllDefaultValuesMatch(ISymbol implMember, ISymbol interfaceMember);
    private static bool DefaultValueMatches(IParameterSymbol parameterSymbol1, IParameterSymbol parameterSymbol2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ImplementInterface.CSharpImplementImplicitlyCodeRefactoringProvider : AbstractChangeImplementationCodeRefactoringProvider {
    protected string Implement_0 { get; }
    protected string Implement_all_interfaces { get; }
    protected string Implement { get; }
    protected virtual string get_Implement_0();
    protected virtual string get_Implement_all_interfaces();
    protected virtual string get_Implement();
    [NullableContextAttribute("2")]
protected virtual bool CheckExplicitNameAllowsConversion(ExplicitInterfaceSpecifierSyntax explicitName);
    protected virtual bool CheckMemberCanBeConverted(ISymbol member);
    protected virtual Task UpdateReferencesAsync(Project project, SolutionEditor solutionEditor, ISymbol implMember, INamedTypeSymbol containingType, CancellationToken cancellationToken);
    protected virtual SyntaxNode ChangeImplementation(SyntaxGenerator generator, SyntaxNode decl, ISymbol _1, ISymbol _2);
    private static SyntaxNode WithoutExplicitImpl(SyntaxNode decl);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ImplementInterface.CSharpImplementInterfaceCodeFixProvider : CodeFixProvider {
    private Func`2<TypeSyntax, bool> _interfaceName;
    private static string CS0535;
    private static string CS0737;
    private static string CS0738;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ImplementInterface.CSharpImplementInterfaceCodeFixProvider/<RegisterCodeFixesAsync>d__8")]
public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    public sealed virtual FixAllProvider GetFixAllProvider();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ImplementInterface.IImplementInterfaceService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ImplementInterface.CSharpImplementInterfaceService : AbstractImplementInterfaceService {
    protected bool CanImplementImplicitly { get; }
    protected bool HasHiddenExplicitImplementation { get; }
    protected virtual string ToDisplayString(IMethodSymbol disposeImplMethod, SymbolDisplayFormat format);
    protected virtual bool AllowDelegateAndEnumConstraints(ParseOptions options);
    protected virtual bool TryInitializeState(Document document, SemanticModel model, SyntaxNode node, CancellationToken cancellationToken, SyntaxNode& classOrStructDecl, INamedTypeSymbol& classOrStructType, IEnumerable`1& interfaceTypes);
    protected virtual bool get_CanImplementImplicitly();
    protected virtual bool get_HasHiddenExplicitImplementation();
    protected virtual SyntaxNode AddCommentInsideIfStatement(SyntaxNode ifStatement, SyntaxTriviaList trivia);
    protected virtual SyntaxNode CreateFinalizer(SyntaxGenerator g, INamedTypeSymbol classType, string disposeMethodDisplayString);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.InheritanceMargin.IInheritanceMarginService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InheritanceMargin.CSharpInheritanceMarginService : AbstractInheritanceMarginService {
    protected string GlobalImportsTitle { get; }
    protected virtual string get_GlobalImportsTitle();
    protected virtual ImmutableArray`1<SyntaxNode> GetMembers(IEnumerable`1<SyntaxNode> nodesToSearch);
    protected virtual SyntaxToken GetDeclarationToken(SyntaxNode declarationNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InitializeParameter.CSharpAddParameterCheckCodeRefactoringProvider : AbstractAddParameterCheckCodeRefactoringProvider`6<BaseTypeDeclarationSyntax, ParameterSyntax, StatementSyntax, ExpressionSyntax, BinaryExpressionSyntax, CSharpSimplifierOptions> {
    protected virtual bool IsFunctionDeclaration(SyntaxNode node);
    protected virtual SyntaxNode GetBody(SyntaxNode functionDeclaration);
    protected virtual void InsertStatement(SyntaxEditor editor, SyntaxNode functionDeclaration, bool returnsVoid, SyntaxNode statementToAddAfter, StatementSyntax statement);
    protected virtual bool IsImplicitConversion(Compilation compilation, ITypeSymbol source, ITypeSymbol destination);
    protected virtual bool CanOffer(SyntaxNode body);
    protected virtual bool PrefersThrowExpression(CSharpSimplifierOptions options);
    protected virtual string EscapeResourceString(string input);
    protected virtual StatementSyntax CreateParameterCheckIfStatement(ExpressionSyntax condition, StatementSyntax ifTrueStatement, CSharpSimplifierOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InitializeParameter.CSharpInitializeMemberFromParameterCodeRefactoringProvider : AbstractInitializeMemberFromParameterCodeRefactoringProvider`4<BaseTypeDeclarationSyntax, ParameterSyntax, StatementSyntax, ExpressionSyntax> {
    protected virtual bool IsFunctionDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
protected virtual SyntaxNode TryGetLastStatement(IBlockOperation blockStatement);
    protected virtual void InsertStatement(SyntaxEditor editor, SyntaxNode functionDeclaration, bool returnsVoid, SyntaxNode statementToAddAfter, StatementSyntax statement);
    protected virtual bool IsImplicitConversion(Compilation compilation, ITypeSymbol source, ITypeSymbol destination);
    protected virtual Accessibility DetermineDefaultFieldAccessibility(INamedTypeSymbol containingType);
    protected virtual Accessibility DetermineDefaultPropertyAccessibility();
    protected virtual SyntaxNode GetBody(SyntaxNode functionDeclaration);
    protected virtual SyntaxNode GetAccessorBody(IMethodSymbol accessor, CancellationToken cancellationToken);
    protected virtual SyntaxNode RemoveThrowNotImplemented(SyntaxNode node);
    protected virtual bool TryUpdateTupleAssignment(IBlockOperation blockStatement, IParameterSymbol parameter, ISymbol fieldOrProperty, SyntaxEditor editor);
    private static bool TryFindSiblingAssignment(ITupleOperation tupleLeft, ITupleOperation tupleRight, IParameterSymbol sibling, Int32& index);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.InitializeParameter.CSharpInitializeMemberFromParameterCodeRefactoringProvider/<TryGetAssignmentExpressions>d__12")]
private static IEnumerable`1<ValueTuple`2<ITupleOperation, ITupleOperation>> TryGetAssignmentExpressions(IBlockOperation blockOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InitializeParameter.CSharpInitializeMemberFromPrimaryConstructorParameterCodeRefactoringProvider : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.InitializeParameter.CSharpInitializeMemberFromPrimaryConstructorParameterCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static ValueTuple`2<IOperation, ISymbol> TryFindFieldOrPropertyInitializerValue(Compilation compilation, IParameterSymbol parameter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.InitializeParameter.CSharpInitializeMemberFromPrimaryConstructorParameterCodeRefactoringProvider/<AddMultipleMembersAsync>d__3")]
private static Task`1<Solution> AddMultipleMembersAsync(Document document, TypeDeclarationSyntax typeDeclaration, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<ISymbol> fieldsOrProperties, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.InitializeParameter.CSharpInitializeMemberFromPrimaryConstructorParameterCodeRefactoringProvider/<UpdateParameterReferencesAsync>d__4")]
private static Task UpdateParameterReferencesAsync(SolutionEditor solutionEditor, IParameterSymbol parameter, ISymbol fieldOrProperty, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.InitializeParameter.CSharpInitializeMemberFromPrimaryConstructorParameterCodeRefactoringProvider/<UpdateExistingMemberAsync>d__5")]
private static Task`1<Solution> UpdateExistingMemberAsync(Document document, IParameterSymbol parameter, ISymbol fieldOrProperty, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static CodeAction <ComputeRefactoringsAsync>g__CreateCodeAction|1_1(string title, Func`2<CancellationToken, Task`1<Solution>> createSolution);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.InitializeParameter.CSharpInitializeMemberFromPrimaryConstructorParameterCodeRefactoringProvider/<<AddMultipleMembersAsync>g__AddSingleMemberAsync|3_0>d")]
[CompilerGeneratedAttribute]
internal static Task`1<Solution> <AddMultipleMembersAsync>g__AddSingleMemberAsync|3_0(Document document, TypeDeclarationSyntax typeDeclaration, IParameterSymbol parameter, ISymbol fieldOrProperty, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static ValueTuple`3<ISymbol, SyntaxNode, CodeGenerationContext> <AddMultipleMembersAsync>g__GetAddContext|3_1(Compilation compilation, IParameterSymbol parameter, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.InitializeParameter.InitializeParameterHelpers : object {
    public static bool IsFunctionDeclaration(SyntaxNode node);
    public static SyntaxNode GetBody(SyntaxNode functionDeclaration);
    private static Nullable`1<SyntaxToken> TryGetSemicolonToken(SyntaxNode functionDeclaration);
    public static bool IsImplicitConversion(Compilation compilation, ITypeSymbol source, ITypeSymbol destination);
    [NullableContextAttribute("2")]
public static SyntaxNode TryGetLastStatement(IBlockOperation blockStatement);
    public static void InsertStatement(SyntaxEditor editor, SyntaxNode functionDeclaration, bool returnsVoid, SyntaxNode statementToAddAfterOpt, StatementSyntax statement);
    public static bool IsExpressionBody(SyntaxNode body);
    public static bool TryConvertExpressionBodyToStatement(SyntaxNode body, SyntaxToken semicolonToken, bool createReturnStatementForExpression, StatementSyntax& statement);
    public static SyntaxNode GetAccessorBody(IMethodSymbol accessor, CancellationToken cancellationToken);
    public static SyntaxNode RemoveThrowNotImplemented(SyntaxNode node);
    public static PropertyDeclarationSyntax RemoveThrowNotImplemented(PropertyDeclarationSyntax propertyDeclaration);
    private static AccessorDeclarationSyntax RemoveThrowNotImplemented(AccessorDeclarationSyntax accessorDeclaration);
    public static bool IsThrowNotImplementedProperty(Compilation compilation, IPropertySymbol property, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InlineDeclaration.CSharpInlineDeclarationCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.InlineDeclaration.CSharpInlineDeclarationCodeFixProvider/<FixAllAsync>d__4")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static ValueTuple`3<VariableDeclaratorSyntax, IdentifierNameSyntax, SyntaxNode> FindDiagnosticNodes(Diagnostic diagnostic, CancellationToken cancellationToken);
    private static SyntaxNode ReplaceIdentifierWithInlineDeclaration(Document document, CSharpCodeFixOptionsProvider options, SemanticModel semanticModel, SyntaxNode currentRoot, VariableDeclaratorSyntax declarator, IdentifierNameSyntax identifier, SyntaxNode currentNode, HashSet`1<StatementSyntax> declarationsToRemove, CancellationToken cancellationToken);
    public static TypeSyntax GenerateTypeSyntaxOrVar(ITypeSymbol symbol, CSharpCodeFixOptionsProvider options);
    private static bool IsVarDesired(ITypeSymbol type, CSharpCodeFixOptionsProvider options);
    private static DeclarationExpressionSyntax GetDeclarationExpression(SourceText sourceText, IdentifierNameSyntax identifier, TypeSyntax newType, VariableDeclaratorSyntax declaratorOpt);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.InlineDeclaration.CSharpInlineDeclarationCodeFixProvider/<MassageTrivia>d__10")]
private static IEnumerable`1<SyntaxTrivia> MassageTrivia(IEnumerable`1<SyntaxTrivia> triviaList);
    private static bool SemanticsChanged(SemanticModel semanticModel, SyntaxNode nodeToReplace, IdentifierNameSyntax identifier, DeclarationExpressionSyntax declarationExpression, CancellationToken cancellationToken);
    private static SyntaxNode GetTopmostContainer(SyntaxNode expression);
    private static bool TryGetSpeculativeSemanticModel(SemanticModel semanticModel, int position, SyntaxNode topmostContainer, SemanticModel& speculativeModel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.InlineDeclaration.CSharpInlineDeclarationDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static string CS0165;
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("2")]
private void AnalyzeSyntaxNode(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
    private static bool WouldCauseDefiniteAssignmentErrors(SemanticModel semanticModel, LocalDeclarationStatementSyntax localStatement, BlockSyntax enclosingBlock, ILocalSymbol outLocalSymbol);
    private static SyntaxNode GetOutArgumentScope(SyntaxNode argumentExpression);
    private static bool IsAccessed(SemanticModel semanticModel, ISymbol outSymbol, BlockSyntax enclosingBlockOfLocalStatement, LocalDeclarationStatementSyntax localStatement, ArgumentSyntax argumentNode, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__3_0(CompilationStartAnalysisContext compilationContext);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.InlineHints.IInlineHintsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InlineHints.CSharpInlineHintsService : AbstractInlineHintsService {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.InlineHints.IInlineParameterNameHintsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InlineHints.CSharpInlineParameterNameHintsService : AbstractInlineParameterNameHintsService {
    protected virtual void AddAllParameterNameHintLocations(SemanticModel semanticModel, ISyntaxFactsService syntaxFacts, SyntaxNode node, ArrayBuilder`1<ValueTuple`4<int, string, IParameterSymbol, HintKind>> buffer, CancellationToken cancellationToken);
    private static void AddArguments(SemanticModel semanticModel, ISyntaxFactsService syntaxFacts, ArrayBuilder`1<ValueTuple`4<int, string, IParameterSymbol, HintKind>> buffer, AttributeArgumentListSyntax argumentList, CancellationToken cancellationToken);
    private static void AddArguments(SemanticModel semanticModel, ISyntaxFactsService syntaxFacts, ArrayBuilder`1<ValueTuple`4<int, string, IParameterSymbol, HintKind>> buffer, BaseArgumentListSyntax argumentList, CancellationToken cancellationToken);
    private static HintKind GetKind(ExpressionSyntax arg);
    protected virtual bool IsIndexer(SyntaxNode node, IParameterSymbol parameter);
    protected virtual string GetReplacementText(string parameterName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.InlineHints.IInlineTypeHintsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InlineHints.CSharpInlineTypeHintsService : AbstractInlineTypeHintsService {
    protected virtual Nullable`1<TypeHint> TryGetTypeHint(SemanticModel semanticModel, SyntaxNode node, bool displayAllOverride, bool forImplicitVariableTypes, bool forLambdaParameterTypes, bool forImplicitObjectCreation, CancellationToken cancellationToken);
    private static TypeHint CreateTypeHint(ITypeSymbol type, bool displayAllOverride, bool normalOption, SyntaxNodeOrToken displayAllSpan, SyntaxNodeOrToken normalSpan);
    private static TextSpan GetSpan(bool displayAllOverride, bool normalOption, SyntaxNodeOrToken displayAllSpan, SyntaxNodeOrToken normalSpan);
    [NullableContextAttribute("2")]
private static bool IsValidType(ITypeSymbol type);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.IntroduceParameter.CSharpIntroduceParameterCodeRefactoringProvider : AbstractIntroduceParameterCodeRefactoringProvider`5<ExpressionSyntax, InvocationExpressionSyntax, ObjectCreationExpressionSyntax, IdentifierNameSyntax, ArgumentSyntax> {
    protected virtual SyntaxNode GenerateExpressionFromOptionalParameter(IParameterSymbol parameterSymbol);
    protected virtual SyntaxNode GetLocalDeclarationFromDeclarator(SyntaxNode variableDecl);
    protected virtual bool IsDestructor(IMethodSymbol methodSymbol);
    protected virtual SyntaxNode UpdateArgumentListSyntax(SyntaxNode argumentList, SeparatedSyntaxList`1<ArgumentSyntax> arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExtensionOrderAttribute]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.IntroduceUsingStatement.CSharpIntroduceUsingStatementCodeRefactoringProvider : AbstractIntroduceUsingStatementCodeRefactoringProvider`3<StatementSyntax, LocalDeclarationStatementSyntax, TryStatementSyntax> {
    protected string CodeActionTitle { get; }
    protected virtual string get_CodeActionTitle();
    protected virtual bool HasCatchBlocks(TryStatementSyntax tryStatement);
    protected virtual ValueTuple`2<SyntaxList`1<StatementSyntax>, SyntaxList`1<StatementSyntax>> GetTryFinallyStatements(TryStatementSyntax tryStatement);
    protected virtual bool CanRefactorToContainBlockStatements(SyntaxNode parent);
    protected virtual SyntaxList`1<StatementSyntax> GetSurroundingStatements(LocalDeclarationStatementSyntax declarationStatement);
    protected virtual SyntaxNode WithStatements(SyntaxNode parentOfStatementsToSurround, SyntaxList`1<StatementSyntax> statements);
    protected virtual StatementSyntax CreateUsingStatement(LocalDeclarationStatementSyntax declarationStatement, SyntaxList`1<StatementSyntax> statementsToSurround);
    protected virtual bool TryCreateUsingLocalDeclaration(ParseOptions options, LocalDeclarationStatementSyntax declarationStatement, LocalDeclarationStatementSyntax& usingDeclarationStatement);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.IntroduceVariable.CSharpIntroduceLocalForExpressionCodeRefactoringProvider : AbstractIntroduceLocalForExpressionCodeRefactoringProvider`4<ExpressionSyntax, StatementSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax> {
    protected virtual bool IsValid(ExpressionStatementSyntax expressionStatement, TextSpan span);
    protected virtual LocalDeclarationStatementSyntax FixupLocalDeclaration(ExpressionStatementSyntax expressionStatement, LocalDeclarationStatementSyntax localDeclaration);
    protected virtual ExpressionStatementSyntax FixupDeconstruction(ExpressionStatementSyntax expressionStatement, ExpressionStatementSyntax deconstruction);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.IntroduceVariable.CSharpIntroduceLocalForExpressionCodeRefactoringProvider/<CreateTupleDeconstructionAsync>d__4")]
protected virtual Task`1<ExpressionStatementSyntax> CreateTupleDeconstructionAsync(Document document, CodeActionOptionsProvider optionsProvider, INamedTypeSymbol tupleType, ExpressionSyntax expression, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.IntroduceVariable.IIntroduceVariableService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.IntroduceVariable.CSharpIntroduceVariableService : AbstractIntroduceVariableService`6<CSharpIntroduceVariableService, ExpressionSyntax, TypeSyntax, TypeDeclarationSyntax, QueryExpressionSyntax, NameSyntax> {
    protected virtual bool IsInNonFirstQueryClause(ExpressionSyntax expression);
    protected virtual bool IsInFieldInitializer(ExpressionSyntax expression);
    protected virtual bool IsInParameterInitializer(ExpressionSyntax expression);
    protected virtual bool IsInConstructorInitializer(ExpressionSyntax expression);
    protected virtual bool IsInAutoPropertyInitializer(ExpressionSyntax expression);
    protected virtual bool IsInExpressionBodiedMember(ExpressionSyntax expression);
    protected virtual bool IsInAttributeArgumentInitializer(ExpressionSyntax expression);
    protected virtual bool CanIntroduceVariableFor(ExpressionSyntax expression);
    protected virtual IEnumerable`1<SyntaxNode> GetContainingExecutableBlocks(ExpressionSyntax expression);
    protected virtual IList`1<bool> GetInsertionIndices(TypeDeclarationSyntax destination, CancellationToken cancellationToken);
    protected virtual bool CanReplace(ExpressionSyntax expression);
    protected virtual bool IsExpressionInStaticLocalFunction(ExpressionSyntax expression);
    protected virtual TNode RewriteCore(TNode node, SyntaxNode replacementNode, ISet`1<ExpressionSyntax> matches);
    protected virtual Task`1<Document> IntroduceFieldAsync(SemanticDocument document, ExpressionSyntax expression, bool allOccurrences, bool isConstant, CancellationToken cancellationToken);
    protected virtual int DetermineConstantInsertPosition(TypeDeclarationSyntax oldType, TypeDeclarationSyntax newType);
    protected static int DetermineConstantInsertPosition(SyntaxList`1<MemberDeclarationSyntax> oldMembers, SyntaxList`1<MemberDeclarationSyntax> newMembers);
    protected virtual int DetermineFieldInsertPosition(TypeDeclarationSyntax oldType, TypeDeclarationSyntax newType);
    protected static int DetermineFieldInsertPosition(SyntaxList`1<MemberDeclarationSyntax> oldMembers, SyntaxList`1<MemberDeclarationSyntax> newMembers);
    private static bool IsConstantField(MemberDeclarationSyntax member);
    protected static int DetermineFirstChange(SyntaxList`1<MemberDeclarationSyntax> oldMembers, SyntaxList`1<MemberDeclarationSyntax> newMembers);
    protected static TypeDeclarationSyntax InsertMember(TypeDeclarationSyntax typeDeclaration, MemberDeclarationSyntax memberDeclaration, int index);
    private static SyntaxTokenList MakeFieldModifiers(bool isConstant, bool inScript);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.IntroduceVariable.CSharpIntroduceVariableService/<IntroduceLocalAsync>d__24")]
protected virtual Task`1<Document> IntroduceLocalAsync(SemanticDocument document, ExpressionSyntax expression, bool allOccurrences, bool isConstant, CancellationToken cancellationToken);
    private Document IntroduceLocalDeclarationIntoLambda(SemanticDocument document, LambdaExpressionSyntax oldLambda, ExpressionSyntax expression, IdentifierNameSyntax newLocalName, LocalDeclarationStatementSyntax declarationStatement, bool allOccurrences, CancellationToken cancellationToken);
    private static bool ShouldIncludeReturnStatement(SemanticDocument document, LambdaExpressionSyntax oldLambda, CancellationToken cancellationToken);
    private static BlockSyntax GetNewBlockBodyForLambda(LocalDeclarationStatementSyntax declarationStatement, bool isEntireLambdaBodySelected, ExpressionSyntax rewrittenBody, bool includeReturnStatement);
    private static TypeSyntax GetTypeSyntax(SemanticDocument document, ExpressionSyntax expression, CancellationToken cancellationToken);
    private Document RewriteExpressionBodiedMemberAndIntroduceLocalDeclaration(SemanticDocument document, ArrowExpressionClauseSyntax arrowExpression, ExpressionSyntax expression, NameSyntax newLocalName, LocalDeclarationStatementSyntax declarationStatement, bool allOccurrences, bool createReturnStatement, CancellationToken cancellationToken);
    private static SyntaxNode WithBlockBody(SyntaxNode node, BlockSyntax body);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.IntroduceVariable.CSharpIntroduceVariableService/<IntroduceLocalDeclarationIntoBlockAsync>d__31")]
private Task`1<Document> IntroduceLocalDeclarationIntoBlockAsync(SemanticDocument document, BlockSyntax block, ExpressionSyntax expression, NameSyntax newLocalName, LocalDeclarationStatementSyntax declarationStatement, bool allOccurrences, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.IntroduceVariable.CSharpIntroduceVariableService/<GetApplicableStatementAncestors>d__32")]
private static IEnumerable`1<StatementSyntax> GetApplicableStatementAncestors(ExpressionSyntax expr);
    private static int GetFirstStatementAffectedIndex(SyntaxNode innermostCommonBlock, ISet`1<ExpressionSyntax> matches, int firstStatementAffectedIndex);
    private static SyntaxList`1<StatementSyntax> InsertWithinTriviaOfNext(SyntaxList`1<StatementSyntax> oldStatements, StatementSyntax newStatement, int statementIndex);
    private static bool IsBlockLike(SyntaxNode node);
    private static SyntaxList`1<StatementSyntax> GetStatements(SyntaxNode blockLike);
    private static SyntaxNode WithStatements(SyntaxNode blockLike, SyntaxList`1<StatementSyntax> statements);
    private static bool IsAnyQueryClause(SyntaxNode node);
    protected virtual Task`1<Document> IntroduceQueryLocalAsync(SemanticDocument document, ExpressionSyntax expression, bool allOccurrences, CancellationToken cancellationToken);
    private Document IntroduceQueryLocalForSingleOccurrence(SemanticDocument document, ExpressionSyntax expression, NameSyntax newLocalName, LetClauseSyntax letClause, bool allOccurrences, CancellationToken cancellationToken);
    private static QueryBodySyntax GetNewQuery(QueryBodySyntax oldQuery, SyntaxNode oldClause, SyntaxNode newClause, LetClauseSyntax letClause);
}
[ExtensionOrderAttribute]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InvertConditional.CSharpInvertConditionalCodeRefactoringProvider : AbstractInvertConditionalCodeRefactoringProvider`1<ConditionalExpressionSyntax> {
    protected virtual bool ShouldOffer(ConditionalExpressionSyntax conditional);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InvertIf.CSharpInvertIfCodeRefactoringProvider : AbstractInvertIfCodeRefactoringProvider`4<SyntaxKind, StatementSyntax, IfStatementSyntax, StatementSyntax> {
    protected virtual string GetTitle();
    protected virtual bool IsElseless(IfStatementSyntax ifNode);
    protected virtual bool CanInvert(IfStatementSyntax ifNode);
    protected virtual SyntaxNode GetCondition(IfStatementSyntax ifNode);
    protected virtual StatementRange<SyntaxKind, StatementSyntax, IfStatementSyntax, StatementSyntax> GetIfBodyStatementRange(IfStatementSyntax ifNode);
    protected virtual bool IsStatementContainer(SyntaxNode node);
    protected virtual bool IsNoOpSyntaxNode(SyntaxNode node);
    protected virtual bool IsExecutableStatement(SyntaxNode node);
    protected virtual StatementSyntax GetNextStatement(StatementSyntax node);
    protected virtual StatementSyntax GetIfBody(IfStatementSyntax ifNode);
    protected virtual StatementSyntax GetEmptyEmbeddedStatement();
    protected virtual StatementSyntax GetElseBody(IfStatementSyntax ifNode);
    protected virtual bool CanControlFlowOut(SyntaxNode node);
    protected virtual SyntaxList`1<StatementSyntax> GetStatements(SyntaxNode node);
    protected virtual Nullable`1<SyntaxKind> GetJumpStatementKind(SyntaxNode node);
    protected virtual StatementSyntax GetJumpStatement(SyntaxKind kind);
    protected virtual StatementSyntax AsEmbeddedStatement(IEnumerable`1<StatementSyntax> statements, StatementSyntax original);
    protected virtual IfStatementSyntax UpdateIf(SourceText sourceText, IfStatementSyntax ifNode, SyntaxNode condition, StatementSyntax trueStatement, StatementSyntax falseStatementOpt);
    private static bool ShouldKeepFalse(IfStatementSyntax originalIfStatement, StatementSyntax falseStatement);
    protected virtual SyntaxNode WithStatements(SyntaxNode node, IEnumerable`1<StatementSyntax> statements);
    protected virtual IEnumerable`1<StatementSyntax> UnwrapBlock(StatementSyntax ifBody);
    protected virtual bool IsSingleStatementStatementRange(StatementRange<SyntaxKind, StatementSyntax, IfStatementSyntax, StatementSyntax> statementRange);
    [CompilerGeneratedAttribute]
internal static bool <ShouldKeepFalse>g__BlockHasComment|19_0(BlockSyntax block);
    [CompilerGeneratedAttribute]
internal static bool <ShouldKeepFalse>g__HasCommentTrivia|19_1(SyntaxTrivia trivia);
    [CompilerGeneratedAttribute]
internal static bool <IsSingleStatementStatementRange>g__IsSingleStatement|22_0(StatementSyntax statement);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExtensionOrderAttribute]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InvertLogical.CSharpInvertLogicalCodeRefactoringProvider : AbstractInvertLogicalCodeRefactoringProvider`3<SyntaxKind, ExpressionSyntax, BinaryExpressionSyntax> {
    protected virtual string GetOperatorText(SyntaxKind binaryExprKind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.InvokeDelegateWithConditionalAccess.Constants : object {
    public static string Kind;
    public static string VariableAndIfStatementForm;
    public static string SingleIfStatementForm;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.InvokeDelegateWithConditionalAccess.InvokeDelegateWithConditionalAccessAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected virtual void InitializeWorker(AnalysisContext context);
    private void SyntaxNodeAction(SyntaxNodeAnalysisContext syntaxContext);
    private bool TryCheckSingleIfStatementForm(SyntaxNodeAnalysisContext syntaxContext, IfStatementSyntax ifStatement, BinaryExpressionSyntax condition, ExpressionStatementSyntax expressionStatement, InvocationExpressionSyntax invocationExpression, NotificationOption2 notificationOption);
    private void ReportDiagnostics(SyntaxNodeAnalysisContext syntaxContext, StatementSyntax firstStatement, IfStatementSyntax ifStatement, ExpressionStatementSyntax expressionStatement, NotificationOption2 notificationOption, ImmutableArray`1<Location> additionalLocations, string kind);
    private bool TryCheckVariableAndIfStatementForm(SyntaxNodeAnalysisContext syntaxContext, IfStatementSyntax ifStatement, BinaryExpressionSyntax condition, ExpressionStatementSyntax expressionStatement, InvocationExpressionSyntax invocationExpression, NotificationOption2 notificationOption);
    private static bool IsNullCheckExpression(ExpressionSyntax left, ExpressionSyntax right);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [CompilerGeneratedAttribute]
internal static bool <TryCheckSingleIfStatementForm>g__InvocationExpressionIsEquivalent|3_0(ExpressionSyntax expression, InvocationExpressionSyntax invocationExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.InvokeDelegateWithConditionalAccess.InvokeDelegateWithConditionalAccessCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void AddEdits(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static void HandleSingleIfStatementForm(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static void HandleVariableAndIfStatementForm(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static T AppendTriviaWithoutEndOfLines(T newStatement, IfStatementSyntax ifStatement);
}
[ExportHighlighterAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.KeywordHighlighting.IfStatementHighlighter : AbstractKeywordHighlighter`1<IfStatementSyntax> {
    protected virtual void AddHighlights(IfStatementSyntax ifStatement, List`1<TextSpan> highlights, CancellationToken cancellationToken);
    private static void ComputeSpans(IfStatementSyntax ifStatement, List`1<TextSpan> highlights);
    public static bool OnlySpacesBetween(SyntaxToken first, SyntaxToken second);
}
[ExportHighlighterAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.KeywordHighlighting.KeywordHighlighters.AsyncAwaitHighlighter : AbstractKeywordHighlighter {
    private static ObjectPool`1<Stack`1<SyntaxNode>> s_stackPool;
    private static AsyncAwaitHighlighter();
    protected virtual bool IsHighlightableNode(SyntaxNode node);
    protected virtual void AddHighlightsForNode(SyntaxNode node, List`1<TextSpan> highlights, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.KeywordHighlighting.KeywordHighlighters.AsyncAwaitHighlighter/<WalkChildren>d__4")]
private static IEnumerable`1<SyntaxNode> WalkChildren(SyntaxNode node);
    private static bool HighlightRelatedKeywords(SyntaxNode node, List`1<TextSpan> spans);
    private static bool TryAddAsyncModifier(SyntaxTokenList modifiers, List`1<TextSpan> spans);
    private static bool TryAddAsyncOrAwaitKeyword(SyntaxToken mod, List`1<TextSpan> spans);
}
[ExportHighlighterAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.KeywordHighlighting.KeywordHighlighters.CheckedExpressionHighlighter : AbstractKeywordHighlighter`1<CheckedExpressionSyntax> {
    protected virtual void AddHighlights(CheckedExpressionSyntax checkedExpressionSyntax, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.KeywordHighlighting.KeywordHighlighters.CheckedStatementHighlighter : AbstractKeywordHighlighter`1<CheckedStatementSyntax> {
    protected virtual void AddHighlights(CheckedStatementSyntax checkedStatement, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportHighlighterAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.KeywordHighlighting.KeywordHighlighters.ConditionalPreprocessorHighlighter : AbstractKeywordHighlighter`1<DirectiveTriviaSyntax> {
    protected virtual void AddHighlights(DirectiveTriviaSyntax directive, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.KeywordHighlighting.KeywordHighlighters.LockStatementHighlighter : AbstractKeywordHighlighter`1<LockStatementSyntax> {
    protected virtual void AddHighlights(LockStatementSyntax lockStatement, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.KeywordHighlighting.KeywordHighlighters.LoopHighlighter : AbstractKeywordHighlighter {
    protected virtual bool IsHighlightableNode(SyntaxNode node);
    protected virtual void AddHighlightsForNode(SyntaxNode node, List`1<TextSpan> spans, CancellationToken cancellationToken);
    private static void HighlightDoStatement(DoStatementSyntax statement, List`1<TextSpan> spans);
    private static void HighlightForStatement(ForStatementSyntax statement, List`1<TextSpan> spans);
    private static void HighlightForEachStatement(CommonForEachStatementSyntax statement, List`1<TextSpan> spans);
    private static void HighlightWhileStatement(WhileStatementSyntax statement, List`1<TextSpan> spans);
    private static void HighlightRelatedKeywords(SyntaxNode node, List`1<TextSpan> spans, bool highlightBreaks, bool highlightContinues);
}
[ExportHighlighterAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.KeywordHighlighting.KeywordHighlighters.RegionHighlighter : AbstractKeywordHighlighter`1<DirectiveTriviaSyntax> {
    protected virtual void AddHighlights(DirectiveTriviaSyntax directive, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.KeywordHighlighting.KeywordHighlighters.ReturnStatementHighlighter : AbstractKeywordHighlighter`1<ReturnStatementSyntax> {
    protected virtual void AddHighlights(ReturnStatementSyntax returnStatement, List`1<TextSpan> spans, CancellationToken cancellationToken);
    private static void HighlightRelatedKeywords(SyntaxNode node, List`1<TextSpan> spans);
}
[ExportHighlighterAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.KeywordHighlighting.KeywordHighlighters.SwitchStatementHighlighter : AbstractKeywordHighlighter`1<SwitchStatementSyntax> {
    protected virtual void AddHighlights(SwitchStatementSyntax switchStatement, List`1<TextSpan> spans, CancellationToken cancellationToken);
    private static void HighlightRelatedKeywords(SyntaxNode node, List`1<TextSpan> spans, bool highlightBreaks, bool highlightGotos);
}
[ExportHighlighterAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.KeywordHighlighting.KeywordHighlighters.TryStatementHighlighter : AbstractKeywordHighlighter`1<TryStatementSyntax> {
    protected virtual void AddHighlights(TryStatementSyntax tryStatement, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.KeywordHighlighting.KeywordHighlighters.UnsafeStatementHighlighter : AbstractKeywordHighlighter`1<UnsafeStatementSyntax> {
    protected virtual void AddHighlights(UnsafeStatementSyntax unsafeStatement, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.KeywordHighlighting.KeywordHighlighters.UsingStatementHighlighter : AbstractKeywordHighlighter`1<UsingStatementSyntax> {
    protected virtual void AddHighlights(UsingStatementSyntax usingStatement, List`1<TextSpan> highlights, CancellationToken cancellationToken);
}
[ExportHighlighterAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.KeywordHighlighting.KeywordHighlighters.YieldStatementHighlighter : AbstractKeywordHighlighter`1<YieldStatementSyntax> {
    protected virtual void AddHighlights(YieldStatementSyntax yieldStatement, List`1<TextSpan> spans, CancellationToken cancellationToken);
    private static void HighlightRelatedKeywords(SyntaxNode node, List`1<TextSpan> spans);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.LambdaUtilities : object {
    public static bool IsLambda(SyntaxNode node);
    public static bool IsNotLambda(SyntaxNode node);
    public static SyntaxNode GetLambda(SyntaxNode lambdaBody);
    internal static SyntaxNode TryGetCorrespondingLambdaBody(SyntaxNode oldBody, SyntaxNode newLambda);
    public static SyntaxNode GetNestedFunctionBody(SyntaxNode nestedFunction);
    public static bool IsNotLambdaBody(SyntaxNode node);
    public static bool IsLambdaBody(SyntaxNode node, bool allowReducedLambdas);
    private static bool IsReducedSelectOrGroupByClause(SelectOrGroupClauseSyntax selectOrGroupClause, ExpressionSyntax selectOrGroupExpression);
    public static bool IsLambdaBodyStatementOrExpression(SyntaxNode node);
    public static bool IsLambdaBodyStatementOrExpression(SyntaxNode node, SyntaxNode& lambdaBody);
    [NullableContextAttribute("2")]
public static bool TryGetLambdaBodies(SyntaxNode node, SyntaxNode& lambdaBody1, SyntaxNode& lambdaBody2);
    public static bool AreEquivalentIgnoringLambdaBodies(SyntaxNode oldNode, SyntaxNode newNode);
    internal static bool IsQueryPairLambda(SyntaxNode syntax);
    internal static bool IsClosureScope(SyntaxNode node);
    internal static int GetDeclaratorPosition(SyntaxNode node);
    private static SyntaxNode GetLocalFunctionBody(LocalFunctionStatementSyntax localFunctionStatementSyntax);
}
[LspBuildOnlyDiagnosticsAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.LanguageServer.CSharpLspBuildOnlyDiagnostics : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LineSeparators.ILineSeparatorService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.LineSeparators.CSharpLineSeparatorService : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.LineSeparators.CSharpLineSeparatorService/<GetLineSeparatorsAsync>d__1")]
public sealed virtual Task`1<ImmutableArray`1<TextSpan>> GetLineSeparatorsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    private static bool IsSeparableBlock(SyntaxNode node);
    private static bool IsSeparableContainer(SyntaxNode node);
    private static bool IsBadType(SyntaxNode node);
    private static bool IsBadEnum(SyntaxNode node);
    private static bool IsBadMethod(SyntaxNode node);
    private static bool IsBadProperty(SyntaxNode node);
    private static bool IsBadEvent(SyntaxNode node);
    private static bool IsBadIndexer(SyntaxNode node);
    [NullableContextAttribute("2")]
private static bool IsBadAccessorList(BasePropertyDeclarationSyntax baseProperty);
    private static bool IsBadConstructor(SyntaxNode node);
    private static bool IsBadDestructor(SyntaxNode node);
    private static bool IsBadOperator(SyntaxNode node);
    private static bool IsBadConversionOperator(SyntaxNode node);
    private static bool IsBadNode(SyntaxNode node);
    private static void ProcessUsings(SyntaxList`1<UsingDirectiveSyntax> usings, ArrayBuilder`1<TextSpan> spans, CancellationToken cancellationToken);
    private static void ProcessNodeList(SyntaxList`1<T> children, ArrayBuilder`1<TextSpan> spans, CancellationToken cancellationToken);
    private static void AddLineSeparatorSpanForNode(SyntaxNode node, ArrayBuilder`1<TextSpan> spans, CancellationToken cancellationToken);
    private static bool IsLegalSpanForLineSeparator(SyntaxTree syntaxTree, TextSpan textSpan, CancellationToken cancellationToken);
    private static TextSpan GetLineSeparatorSpanForNode(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeFieldReadonly.CSharpMakeFieldReadonlyCodeFixProvider : AbstractMakeFieldReadonlyCodeFixProvider`2<VariableDeclaratorSyntax, FieldDeclarationSyntax> {
    protected virtual SyntaxNode GetInitializerNode(VariableDeclaratorSyntax declaration);
    protected virtual ImmutableList`1<VariableDeclaratorSyntax> GetVariableDeclarators(FieldDeclarationSyntax fieldDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticCodeFixHelper : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticCodeFixHelper/<MakeLocalFunctionStaticAsync>d__0")]
public static Task`1<Document> MakeLocalFunctionStaticAsync(Document document, LocalFunctionStatementSyntax localFunction, ImmutableArray`1<ISymbol> captures, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticCodeFixHelper/<MakeLocalFunctionStaticAsync>d__1")]
public static Task MakeLocalFunctionStaticAsync(Document document, LocalFunctionStatementSyntax localFunction, ImmutableArray`1<ISymbol> captures, SyntaxEditor syntaxEditor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    public static SyntaxNode AddStaticModifier(SyntaxNode localFunction, SyntaxGenerator generator);
    private static ImmutableArray`1<ValueTuple`2<IParameterSymbol, ISymbol>> CreateParameterSymbols(ImmutableArray`1<ISymbol> captures);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticCodeRefactoringProvider : CodeRefactoringProvider {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.MakeLocalFunctionStaticHelper : object {
    public static bool IsStaticLocalFunctionSupported(LanguageVersion languageVersion);
    private static bool TryGetDataFlowAnalysis(LocalFunctionStatementSyntax localFunction, SemanticModel semanticModel, DataFlowAnalysis& dataFlow);
    private static bool CanBeCalledFromStaticContext(LocalFunctionStatementSyntax localFunction, DataFlowAnalysis dataFlow);
    public static bool CanMakeLocalFunctionStaticBecauseNoCaptures(LocalFunctionStatementSyntax localFunction, SemanticModel semanticModel);
    public static bool CanMakeLocalFunctionStaticByRefactoringCaptures(LocalFunctionStatementSyntax localFunction, SemanticModel semanticModel, ImmutableArray`1& captures);
    [CompilerGeneratedAttribute]
internal static bool <CanBeCalledFromStaticContext>g__IsChildOrSelf|2_1(LocalFunctionStatementSyntax containingLocalFunction, ISymbol calledLocationFunction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.PassInCapturedVariablesAsArgumentsCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string CS8421;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MakeLocalFunctionStatic.PassInCapturedVariablesAsArgumentsCodeFixProvider/<WrapFixAsync>d__7")]
private static Task WrapFixAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, Func`4<Document, LocalFunctionStatementSyntax, ImmutableArray`1<ISymbol>, Task> fixer, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeMemberStatic.CSharpMakeMemberStaticCodeFixProvider : AbstractMakeMemberStaticCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
protected virtual bool TryGetMemberDeclaration(SyntaxNode node, SyntaxNode& memberDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeMethodAsynchronous.CSharpMakeMethodAsynchronousCodeFixProvider : AbstractMakeMethodAsynchronousCodeFixProvider {
    private static string CS4032;
    private static string CS4033;
    private static string CS4034;
    private static string CS0246;
    private static SyntaxToken s_asyncToken;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static CSharpMakeMethodAsynchronousCodeFixProvider();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsSupportedDiagnostic(Diagnostic diagnostic, CancellationToken cancellationToken);
    protected virtual string GetMakeAsyncTaskFunctionResource();
    protected virtual string GetMakeAsyncVoidFunctionResource();
    protected virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected virtual bool IsAsyncReturnType(ITypeSymbol type, KnownTaskTypes knownTypes);
    protected virtual SyntaxNode AddAsyncTokenAndFixReturnType(bool keepVoid, IMethodSymbol methodSymbol, SyntaxNode node, KnownTaskTypes knownTypes, CancellationToken cancellationToken);
    private static MethodDeclarationSyntax FixMethod(bool keepVoid, IMethodSymbol methodSymbol, MethodDeclarationSyntax method, KnownTaskTypes knownTypes, CancellationToken cancellationToken);
    private static LocalFunctionStatementSyntax FixLocalFunction(bool keepVoid, IMethodSymbol methodSymbol, LocalFunctionStatementSyntax localFunction, KnownTaskTypes knownTypes, CancellationToken cancellationToken);
    private static TypeSyntax FixMethodReturnType(bool keepVoid, IMethodSymbol methodSymbol, TypeSyntax returnTypeSyntax, KnownTaskTypes knownTypes, CancellationToken cancellationToken);
    private static bool IsIterator(IMethodSymbol method, CancellationToken cancellationToken);
    private static bool IsIAsyncEnumerableOrEnumerator(ITypeSymbol returnType, KnownTaskTypes knownTypes);
    private static bool IsIEnumerable(ITypeSymbol returnType, KnownTaskTypes knownTypes);
    private static bool IsIEnumerator(ITypeSymbol returnType, KnownTaskTypes knownTypes);
    private static SyntaxTokenList AddAsyncModifierWithCorrectedTrivia(SyntaxTokenList modifiers, TypeSyntax& newReturnType);
    private static AnonymousFunctionExpressionSyntax FixAnonymousFunction(AnonymousFunctionExpressionSyntax anonymous);
    [CompilerGeneratedAttribute]
internal static TypeSyntax <FixMethodReturnType>g__MakeGenericType|17_0(string type, ITypeSymbol typeArgumentFrom);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeMethodSynchronous.CSharpMakeMethodSynchronousCodeFixProvider : AbstractMakeMethodSynchronousCodeFixProvider {
    private static string CS1998;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected virtual SyntaxNode RemoveAsyncTokenAndFixReturnType(IMethodSymbol methodSymbol, SyntaxNode node, KnownTaskTypes knownTypes);
    private static SyntaxNode FixMethod(IMethodSymbol methodSymbol, MethodDeclarationSyntax method, KnownTaskTypes knownTypes);
    private static SyntaxNode FixLocalFunction(IMethodSymbol methodSymbol, LocalFunctionStatementSyntax localFunction, KnownTaskTypes knownTypes);
    private static TypeSyntax FixMethodReturnType(IMethodSymbol methodSymbol, TypeSyntax returnTypeSyntax, KnownTaskTypes knownTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeRefStruct.MakeRefStructCodeFixProvider : CodeFixProvider {
    private static string CS8345;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MakeRefStruct.MakeRefStructCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MakeRefStruct.MakeRefStructCodeFixProvider/<FixCodeAsync>d__6")]
private static Task`1<Document> FixCodeAsync(Document document, StructDeclarationSyntax structDeclaration, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeStructFieldsWritable.CSharpMakeStructFieldsWritableCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.MakeStructFieldsWritable.CSharpMakeStructFieldsWritableDiagnosticAnalyzer : AbstractCodeQualityDiagnosticAnalyzer {
    private static DiagnosticDescriptor s_diagnosticDescriptor;
    private static CSharpMakeStructFieldsWritableDiagnosticAnalyzer();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeStructMemberReadOnly.CSharpMakeStructMemberReadOnlyCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.MakeStructMemberReadOnly.CSharpMakeStructMemberReadOnlyDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeBlock(OperationBlockAnalysisContext context, NotificationOption2 notificationOption, Dictionary`2<IMethodSymbol, Diagnostic> methodToDiagnostic);
    private static ValueTuple`2<Location, Location> GetDiagnosticLocation(IMethodSymbol owningMethod, CancellationToken cancellationToken);
    private static bool BlockOperationPotentiallyMutatesThis(IMethodSymbol owningMethod, IOperation blockOperation, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static bool IsPotentiallyValueType(IOperation instance);
    private static bool OperationPotentiallyMutatesThis(SemanticModel semanticModel, IMethodSymbol owningMethod, IOperation instanceOperation, CancellationToken cancellationToken);
    private static bool IsPotentiallyMutatingMethod(IMethodSymbol owningMethod, IOperation instance, IMethodSymbol methodReference);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_1(SymbolStartAnalysisContext context);
    [CompilerGeneratedAttribute]
private bool <InitializeWorker>g__ShouldAnalyze|2_2(SymbolStartAnalysisContext context, CodeStyleOption2`1& option);
    [CompilerGeneratedAttribute]
internal static void <InitializeWorker>g__ProcessResults|2_3(SymbolAnalysisContext context, ReportDiagnostic severity, PooledDictionary`2<IMethodSymbol, Diagnostic> methodToDiagnostic);
    [CompilerGeneratedAttribute]
internal static bool <BlockOperationPotentiallyMutatesThis>g__ReferencesThisInstance|5_0(IOperation operation, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeStructReadOnly.CSharpMakeStructReadOnlyCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.MakeStructReadOnly.CSharpMakeStructReadOnlyDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("2")]
private bool IsCandidate(SymbolStartAnalysisContext context, Location& primaryLocation, Location& additionalLocation, CodeStyleOption2`1& option);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_1(SymbolStartAnalysisContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeTypeAbstract.CSharpMakeTypeAbstractCodeFixProvider : AbstractMakeTypeAbstractCodeFixProvider`1<TypeDeclarationSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsValidRefactoringContext(SyntaxNode node, TypeDeclarationSyntax& typeDeclaration);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MakeTypePartial.CSharpMakeTypePartialCodeFixProvider : AbstractMakeTypePartialCodeFixProvider {
    [NullableAttribute("1")]
private static string CS0260;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
}
internal class Microsoft.CodeAnalysis.CSharp.MetadataAsSource.CSharpMetadataAsSourceService : AbstractMetadataAsSourceService {
    private static AbstractFormattingRule s_memberSeparationRule;
    public static CSharpMetadataAsSourceService Instance;
    private static CSharpMetadataAsSourceService();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MetadataAsSource.CSharpMetadataAsSourceService/<AddAssemblyInfoRegionAsync>d__3")]
protected virtual Task`1<Document> AddAssemblyInfoRegionAsync(Document document, Compilation symbolCompilation, ISymbol symbol, CancellationToken cancellationToken);
    protected virtual IEnumerable`1<AbstractFormattingRule> GetFormattingRules(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MetadataAsSource.CSharpMetadataAsSourceService/<ConvertDocCommentsToRegularCommentsAsync>d__5")]
protected virtual Task`1<Document> ConvertDocCommentsToRegularCommentsAsync(Document document, IDocumentationCommentFormattingService docCommentFormattingService, CancellationToken cancellationToken);
    protected virtual ImmutableArray`1<AbstractReducer> GetReducers();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MetadataAsSource.CSharpMetadataAsSourceService/<AddNullableRegionsAsync>d__7")]
protected virtual Task`1<Document> AddNullableRegionsAsync(Document document, CancellationToken cancellationToken);
    private static ValueTuple`2<bool, bool> GetNullableAnnotations(SyntaxNode node);
    private static bool HasAnnotation(SyntaxNode node, SyntaxAnnotation annotation);
    private static SyntaxTrivia[] CreateNullableTrivia(bool enable);
    private TSyntax AddNullableRegions(TSyntax node, CancellationToken cancellationToken);
    private SyntaxList`1<MemberDeclarationSyntax> AddNullableRegions(SyntaxList`1<MemberDeclarationSyntax> members, CancellationToken cancellationToken);
    private TypeDeclarationSyntax AddNullableRegionsAroundTypeMembers(TypeDeclarationSyntax type, CancellationToken cancellationToken);
    private static MemberDeclarationSyntax TransitionTo(MemberDeclarationSyntax member, bool enabled, Boolean& currentlyEnabled);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.MetadataAsSource.IMetadataAsSourceService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MetadataAsSource.CSharpMetadataAsSourceServiceFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider : CodeFixProvider {
    private static SyntaxAnnotation s_usingPlacementCodeFixAnnotation;
    private static SyntaxAnnotation s_warningAnnotation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static MisplacedUsingDirectivesCodeFixProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider/<RegisterCodeFixesAsync>d__6")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider/<TransformDocumentIfRequiredAsync>d__7")]
internal static Task`1<Document> TransformDocumentIfRequiredAsync(Document document, SimplifierOptions simplifierOptions, CodeStyleOption2`1<AddImportPlacement> importPlacementStyleOption, CancellationToken cancellationToken);
    private static ImmutableArray`1<UsingDirectiveSyntax> GetAllUsingDirectives(CompilationUnitSyntax compilationUnit);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider/<GetTransformedDocumentAsync>d__9")]
private static Task`1<Document> GetTransformedDocumentAsync(Document document, CompilationUnitSyntax compilationUnit, ImmutableArray`1<UsingDirectiveSyntax> allUsingDirectives, AddImportPlacement placement, SimplifierOptions simplifierOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider/<ExpandUsingDirectivesAsync>d__10")]
private static Task`1<CompilationUnitSyntax> ExpandUsingDirectivesAsync(Document document, CompilationUnitSyntax compilationUnit, ImmutableArray`1<UsingDirectiveSyntax> allUsingDirectives, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider/<ExpandUsingDirectiveAsync>d__11")]
private static Task`1<SyntaxNode> ExpandUsingDirectiveAsync(Document document, UsingDirectiveSyntax usingDirective, CancellationToken cancellationToken);
    private static CompilationUnitSyntax MoveUsingsInsideNamespace(CompilationUnitSyntax compilationUnit);
    private static CompilationUnitSyntax MoveUsingsOutsideNamespaces(CompilationUnitSyntax compilationUnit);
    private static ValueTuple`2<BaseNamespaceDeclarationSyntax, ImmutableArray`1<UsingDirectiveSyntax>> RemoveUsingsFromNamespace(BaseNamespaceDeclarationSyntax usingContainer);
    private static ValueTuple`2<IEnumerable`1<UsingDirectiveSyntax>, IEnumerable`1<SyntaxTrivia>> RemoveDuplicateUsings(IEnumerable`1<UsingDirectiveSyntax> existingUsings, ImmutableArray`1<UsingDirectiveSyntax> usingsToAdd);
    private static SyntaxList`1<MemberDeclarationSyntax> GetMembers(SyntaxNode node);
    private static TSyntaxNode RemoveLeadingBlankLinesFromFirstMember(TSyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesCodeFixProvider/<SplitIntoLines>d__18")]
private static IEnumerable`1<IEnumerable`1<SyntaxTrivia>> SplitIntoLines(SyntaxTriviaList triviaList);
    private static TSyntaxNode EnsureLeadingBlankLineBeforeFirstMember(TSyntaxNode node);
    private static ValueTuple`2<AddImportPlacement, bool> DeterminePlacement(CompilationUnitSyntax compilationUnit, CodeStyleOption2`1<AddImportPlacement> styleOption);
    private static bool HasOneNamespace(CompilationUnitSyntax compilationUnit);
    private static ValueTuple`2<CompilationUnitSyntax, ImmutableArray`1<SyntaxTrivia>> RemoveFileHeader(CompilationUnitSyntax syntaxRoot, IFileBannerFactsService bannerService);
    private static CompilationUnitSyntax AddFileHeader(CompilationUnitSyntax compilationUnit, ImmutableArray`1<SyntaxTrivia> fileHeader);
    [CompilerGeneratedAttribute]
internal static void <GetAllUsingDirectives>g__Recurse|8_0(SyntaxList`1<MemberDeclarationSyntax> members, <>c__DisplayClass8_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.MisplacedUsingDirectives.MisplacedUsingDirectivesDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static LocalizableResourceString s_localizableTitle;
    private static LocalizableResourceString s_localizableOutsideMessage;
    private static DiagnosticDescriptor s_outsideDiagnosticDescriptor;
    private static LocalizableResourceString s_localizableInsideMessage;
    private static DiagnosticDescriptor s_insideDiagnosticDescriptor;
    private static MisplacedUsingDirectivesDiagnosticAnalyzer();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeNamespaceNode(SyntaxNodeAnalysisContext context);
    private void AnalyzeCompilationUnitNode(SyntaxNodeAnalysisContext context);
    private static bool ShouldSuppressDiagnostic(CompilationUnitSyntax compilationUnit);
    private static void ReportDiagnostics(SyntaxNodeAnalysisContext context, DiagnosticDescriptor descriptor, IEnumerable`1<UsingDirectiveSyntax> usingDirectives, CodeStyleOption2`1<AddImportPlacement> option);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MoveDeclarationNearReference.CSharpMoveDeclarationNearReferenceCodeRefactoringProvider : AbstractMoveDeclarationNearReferenceCodeRefactoringProvider`1<LocalDeclarationStatementSyntax> {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.MoveToNamespace.IMoveToNamespaceService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.MoveToNamespace.CSharpMoveToNamespaceService : AbstractMoveToNamespaceService`3<CompilationUnitSyntax, BaseNamespaceDeclarationSyntax, BaseTypeDeclarationSyntax> {
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public CSharpMoveToNamespaceService(IMoveToNamespaceOptionsService optionsService);
    protected virtual string GetNamespaceName(SyntaxNode container);
    protected virtual bool IsContainedInNamespaceDeclaration(BaseNamespaceDeclarationSyntax baseNamespace, int position);
}
[ExtensionOrderAttribute]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.NameTupleElement.CSharpNameTupleElementCodeRefactoringProvider : AbstractNameTupleElementCodeRefactoringProvider`2<ArgumentSyntax, TupleExpressionSyntax> {
    protected virtual ArgumentSyntax WithName(ArgumentSyntax argument, string argumentName);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.NavigateTo.INavigateToSearchService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.NavigateTo.CSharpNavigateToSearchService : AbstractNavigateToSearchService {
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Navigation.INavigableItemsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Navigation.CSharpFindDefinitionService : AbstractNavigableItemsService {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.NavigationBar.INavigationBarItemService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.NavigationBar.CSharpNavigationBarItemService : AbstractNavigationBarItemService {
    private static SymbolDisplayFormat s_typeFormat;
    private static SymbolDisplayFormat s_memberFormat;
    private static CSharpNavigationBarItemService();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.NavigationBar.CSharpNavigationBarItemService/<GetItemsInCurrentProcessAsync>d__3")]
protected virtual Task`1<ImmutableArray`1<RoslynNavigationBarItem>> GetItemsInCurrentProcessAsync(Document document, bool supportsCodeGeneration, CancellationToken cancellationToken);
    private static ImmutableArray`1<RoslynNavigationBarItem> GetMembersInTypes(Solution solution, SyntaxTree tree, IEnumerable`1<INamedTypeSymbol> types, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.NavigationBar.CSharpNavigationBarItemService/<GetTypesInFileAsync>d__5")]
private static Task`1<IEnumerable`1<INamedTypeSymbol>> GetTypesInFileAsync(Document document, CancellationToken cancellationToken);
    private static IEnumerable`1<INamedTypeSymbol> GetTypesInFile(SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ISymbol GetType(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    private static bool IsAccessor(ISymbol member);
    private static RoslynNavigationBarItem CreateItemForMember(Solution solution, ISymbol member, SyntaxTree tree, CancellationToken cancellationToken);
    private static Nullable`1<SymbolItemLocation> GetSymbolLocation(Solution solution, ISymbol symbol, SyntaxTree tree, CancellationToken cancellationToken);
    private static TextSpan GetFieldReferenceSpan(SyntaxReference reference);
    private static TextSpan GetEnumMemberSpan(SyntaxReference reference);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ArrowExpressionClausePlacement.ArrowExpressionClausePlacementCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.NewLines.ArrowExpressionClausePlacement.ArrowExpressionClausePlacementCodeFixProvider/<UpdateDocumentAsync>d__4")]
private static Task`1<Document> UpdateDocumentAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    private static void AddEdits(SourceText text, SyntaxToken token, ExpressionSyntax nextExpression, ArrayBuilder`1<TextChange> edits);
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ArrowExpressionClausePlacement.ArrowExpressionClausePlacementDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    private void Recurse(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, SyntaxNode node);
    private void ProcessArrowExpressionClause(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, ArrowExpressionClauseSyntax arrowExpressionClause);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <ProcessArrowExpressionClause>g__IsOk|5_1(SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ConditionalExpressionPlacement.ConditionalExpressionPlacementCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.NewLines.ConditionalExpressionPlacement.ConditionalExpressionPlacementCodeFixProvider/<UpdateDocumentAsync>d__4")]
private static Task`1<Document> UpdateDocumentAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    private static void AddEdits(SourceText text, SyntaxToken token, ExpressionSyntax nextExpression, ArrayBuilder`1<TextChange> edits);
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ConditionalExpressionPlacement.ConditionalExpressionPlacementDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    private void Recurse(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, SyntaxNode node);
    private void ProcessConditionalExpression(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, ConditionalExpressionSyntax conditionalExpression);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <ProcessConditionalExpression>g__IsOk|5_1(SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ConsecutiveBracePlacement.ConsecutiveBracePlacementCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static Task`1<Document> UpdateDocumentAsync(Document document, Diagnostic diagnostic, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.NewLines.ConsecutiveBracePlacement.ConsecutiveBracePlacementCodeFixProvider/<FixAllAsync>d__5")]
public static Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    private static void FixOne(SyntaxNode root, SourceText text, Dictionary`2<SyntaxToken, SyntaxToken> tokenToToken, Diagnostic diagnostic, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ConsecutiveBracePlacement.ConsecutiveBracePlacementDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    private void Recurse(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, ArrayBuilder`1<SyntaxNode> stack);
    private void ProcessToken(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, SourceText text, SyntaxToken token);
    public static bool HasExcessBlankLinesAfter(SourceText text, SyntaxToken token, SyntaxToken& secondBrace, SyntaxTrivia& endOfLineTrivia);
    private static bool IsAllWhitespace(TextLine textLine);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ConsecutiveStatementPlacement.CSharpConsecutiveStatementPlacementDiagnosticAnalyzer : AbstractConsecutiveStatementPlacementDiagnosticAnalyzer`1<StatementSyntax> {
    protected virtual bool IsBlockLikeStatement(SyntaxNode node);
    protected virtual Location GetDiagnosticLocation(SyntaxNode block);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ConstructorInitializerPlacement.ConstructorInitializerPlacementCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.NewLines.ConstructorInitializerPlacement.ConstructorInitializerPlacementCodeFixProvider/<UpdateDocumentAsync>d__4")]
private static Task`1<Document> UpdateDocumentAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    private static void MoveTriviaWhenOnSameLine(Dictionary`2<SyntaxToken, SyntaxToken> replacementMap, SyntaxToken colonToken, SyntaxToken thisBaseKeyword);
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    [CompilerGeneratedAttribute]
internal static SyntaxToken <MoveTriviaWhenOnSameLine>g__ComputeNewCloseParen|5_0(SyntaxToken colonToken, SyntaxToken previousToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.ConstructorInitializerPlacement.ConstructorInitializerPlacementDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    private void Recurse(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, SyntaxNode node);
    private void ProcessConstructorInitializer(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, ConstructorInitializerSyntax initializer);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.EmbeddedStatementPlacement.EmbeddedStatementPlacementCodeFixProvider : CodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.NewLines.EmbeddedStatementPlacement.EmbeddedStatementPlacementCodeFixProvider/<FixAllAsync>d__4")]
public static Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CodeActionOptionsProvider codeActionOptionsProvider, CancellationToken cancellationToken);
    private static void FixOne(SyntaxEditor editor, Diagnostic diagnostic, SyntaxTrivia endOfLineTrivia, CancellationToken cancellationToken);
    private static SyntaxNode AddLeadingTrivia(SyntaxNode node, SyntaxTrivia trivia);
    private static SyntaxToken AddLeadingTrivia(SyntaxToken token, SyntaxTrivia trivia);
    public virtual FixAllProvider GetFixAllProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.EmbeddedStatementPlacement.EmbeddedStatementPlacementDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeTree(SyntaxTreeAnalysisContext context, CompilationOptions compilationOptions);
    private void Recurse(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, SyntaxNode node);
    private bool CheckStatementSyntax(SyntaxTreeAnalysisContext context, NotificationOption2 notificationOption, StatementSyntax statement);
    public static bool StatementNeedsWrapping(StatementSyntax statement);
    public static bool ContainsEndOfLineBetween(SyntaxToken previous, SyntaxToken next);
    private static bool ContainsEndOfLine(SyntaxTriviaList triviaList);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.NewLines.MultipleBlankLines.CSharpMultipleBlankLinesDiagnosticAnalyzer : AbstractMultipleBlankLinesDiagnosticAnalyzer {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.OrderModifiers.CSharpOrderModifiersCodeFixProvider : AbstractOrderModifiersCodeFixProvider {
    private static string CS0267;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableCompilerErrorIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected ImmutableArray`1<string> FixableCompilerErrorIds { get; }
    protected virtual CodeStyleOption2`1<string> GetCodeStyleOption(AnalyzerOptionsProvider options);
    [CompilerGeneratedAttribute]
protected virtual ImmutableArray`1<string> get_FixableCompilerErrorIds();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.OrderModifiers.CSharpOrderModifiersDiagnosticAnalyzer : AbstractOrderModifiersDiagnosticAnalyzer {
    protected virtual CodeStyleOption2`1<string> GetPreferredOrderStyle(SyntaxTreeAnalysisContext context);
    protected virtual void Recurse(SyntaxTreeAnalysisContext context, Dictionary`2<int, int> preferredOrder, NotificationOption2 notificationOption, SyntaxNode root);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.OrderModifiers.CSharpOrderModifiersHelper : AbstractOrderModifiersHelpers {
    public static CSharpOrderModifiersHelper Instance;
    private static CSharpOrderModifiersHelper();
    protected virtual int GetKeywordKind(string trimmed);
    protected virtual bool TryParse(string value, Dictionary`2& parsed);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Organizing.IOrganizingService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.CSharpOrganizingService : AbstractOrganizingService {
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public CSharpOrganizingService(IEnumerable`1<Lazy`2<ISyntaxOrganizer, LanguageMetadata>> organizers);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Organizing.CSharpOrganizingService/<ProcessAsync>d__1")]
protected virtual Task`1<Document> ProcessAsync(Document document, IEnumerable`1<ISyntaxOrganizer> organizers, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.ClassDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<ClassDeclarationSyntax> {
    protected virtual ClassDeclarationSyntax Organize(ClassDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.ConstructorDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<ConstructorDeclarationSyntax> {
    protected virtual ConstructorDeclarationSyntax Organize(ConstructorDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.DestructorDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<DestructorDeclarationSyntax> {
    protected virtual DestructorDeclarationSyntax Organize(DestructorDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.EnumDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<EnumDeclarationSyntax> {
    protected virtual EnumDeclarationSyntax Organize(EnumDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.EventDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<EventDeclarationSyntax> {
    protected virtual EventDeclarationSyntax Organize(EventDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.EventFieldDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<EventFieldDeclarationSyntax> {
    protected virtual EventFieldDeclarationSyntax Organize(EventFieldDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.FieldDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<FieldDeclarationSyntax> {
    protected virtual FieldDeclarationSyntax Organize(FieldDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.IndexerDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<IndexerDeclarationSyntax> {
    protected virtual IndexerDeclarationSyntax Organize(IndexerDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.InterfaceDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<InterfaceDeclarationSyntax> {
    protected virtual InterfaceDeclarationSyntax Organize(InterfaceDeclarationSyntax syntax, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.MemberDeclarationsOrganizer : object {
    public static SyntaxList`1<MemberDeclarationSyntax> Organize(SyntaxList`1<MemberDeclarationSyntax> members, CancellationToken cancellationToken);
    private static void TransferTrivia(IList`1<TSyntaxNode> originalList, IList`1<TSyntaxNode> finalList);
    private static void FixupOriginalFirstNode(IList`1<TSyntaxNode> originalList, IList`1<TSyntaxNode> finalList);
    private static void CopyBanner(IList`1<TSyntaxNode> originalList, IList`1<TSyntaxNode> finalList);
    private static IList`1<MemberDeclarationSyntax> OrganizeMemberGroup(IList`1<MemberDeclarationSyntax> members);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.MethodDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<MethodDeclarationSyntax> {
    protected virtual MethodDeclarationSyntax Organize(MethodDeclarationSyntax syntax, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.ModifiersOrganizer : object {
    public static SyntaxTokenList Organize(SyntaxTokenList modifiers);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.OperatorDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<OperatorDeclarationSyntax> {
    protected virtual OperatorDeclarationSyntax Organize(OperatorDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.PropertyDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<PropertyDeclarationSyntax> {
    protected virtual PropertyDeclarationSyntax Organize(PropertyDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.RecordDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<RecordDeclarationSyntax> {
    protected virtual RecordDeclarationSyntax Organize(RecordDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[ExportSyntaxNodeOrganizerAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Organizing.Organizers.StructDeclarationOrganizer : AbstractSyntaxNodeOrganizer`1<StructDeclarationSyntax> {
    protected virtual StructDeclarationSyntax Organize(StructDeclarationSyntax syntax, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.PopulateSwitch.CSharpPopulateSwitchExpressionCodeFixProvider : AbstractPopulateSwitchExpressionCodeFixProvider`4<ExpressionSyntax, SwitchExpressionSyntax, SwitchExpressionArmSyntax, MemberAccessExpressionSyntax> {
    protected virtual SwitchExpressionArmSyntax CreateDefaultSwitchArm(SyntaxGenerator generator, Compilation compilation);
    protected virtual SwitchExpressionArmSyntax CreateSwitchArm(SyntaxGenerator generator, Compilation compilation, MemberAccessExpressionSyntax caseLabel);
    protected virtual SwitchExpressionArmSyntax CreateNullSwitchArm(SyntaxGenerator generator, Compilation compilation);
    protected virtual SwitchExpressionSyntax InsertSwitchArms(SyntaxGenerator generator, SwitchExpressionSyntax switchNode, int insertLocation, List`1<SwitchExpressionArmSyntax> newArms);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.PopulateSwitch.CSharpPopulateSwitchExpressionDiagnosticAnalyzer : AbstractPopulateSwitchExpressionDiagnosticAnalyzer`1<SwitchExpressionSyntax> {
    protected virtual Location GetDiagnosticLocation(SwitchExpressionSyntax switchBlock);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.PopulateSwitch.CSharpPopulateSwitchStatementCodeFixProvider : AbstractPopulateSwitchStatementCodeFixProvider`3<SwitchStatementSyntax, SwitchSectionSyntax, MemberAccessExpressionSyntax> {
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.PopulateSwitch.CSharpPopulateSwitchStatementDiagnosticAnalyzer : AbstractPopulateSwitchStatementDiagnosticAnalyzer`1<SwitchStatementSyntax> {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.QualifyMemberAccess.CSharpQualifyMemberAccessCodeFixProvider : AbstractQualifyMemberAccessCodeFixprovider`2<SimpleNameSyntax, InvocationExpressionSyntax> {
    protected virtual SimpleNameSyntax GetNode(Diagnostic diagnostic, CancellationToken cancellationToken);
    protected virtual string GetTitle();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.QualifyMemberAccess.CSharpQualifyMemberAccessDiagnosticAnalyzer : AbstractQualifyMemberAccessDiagnosticAnalyzer`3<SyntaxKind, ExpressionSyntax, SimpleNameSyntax> {
    protected ISimplification Simplification { get; }
    protected virtual ISimplification get_Simplification();
    protected virtual bool IsAlreadyQualifiedMemberAccess(ExpressionSyntax node);
    protected virtual bool CanMemberAccessBeQualified(ISymbol containingSymbol, SyntaxNode node);
    private static bool IsInPropertyOrFieldInitialization(ISymbol containingSymbol, SyntaxNode node);
    private static bool IsInPropertyInitialization(SyntaxNode declarationSyntax, SyntaxNode node);
    private static bool IsInFieldInitialization(SyntaxNode declarationSyntax, SyntaxNode node);
    protected virtual Location GetLocation(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportQuickInfoProviderAttribute("DiagnosticAnalyzer", "C#")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.QuickInfo.CSharpDiagnosticAnalyzerQuickInfoProvider : CommonQuickInfoProvider {
    private DiagnosticAnalyzerInfoCache _diagnosticAnalyzerInfoCache;
    [ImportingConstructorAttribute]
public CSharpDiagnosticAnalyzerQuickInfoProvider(SharedGlobalCache globalCache);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.QuickInfo.CSharpDiagnosticAnalyzerQuickInfoProvider/<BuildQuickInfoAsync>d__2")]
protected virtual Task`1<QuickInfoItem> BuildQuickInfoAsync(QuickInfoContext context, SyntaxToken token);
    protected virtual Task`1<QuickInfoItem> BuildQuickInfoAsync(CommonQuickInfoContext context, SyntaxToken token);
    private QuickInfoItem GetQuickinfoForPragmaWarning(Document document, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.QuickInfo.CSharpDiagnosticAnalyzerQuickInfoProvider/<GetQuickInfoForSuppressMessageAttributeAsync>d__5")]
private Task`1<QuickInfoItem> GetQuickInfoForSuppressMessageAttributeAsync(Document document, SyntaxToken token, CancellationToken cancellationToken);
    private QuickInfoItem GetQuickInfoFromSupportedDiagnosticsOfProjectAnalyzers(Document document, string errorCode, TextSpan location);
    private static QuickInfoItem CreateQuickInfo(TextSpan location, DiagnosticDescriptor descriptor, TextSpan[] relatedSpans);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.QuickInfo.CSharpDiagnosticAnalyzerQuickInfoProviderExtensions : object {
    [ExtensionAttribute]
public static string ToStringOrNull(LocalizableString this);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsSuppressMessageAttribute(NameSyntax name);
    [ExtensionAttribute]
public static string ExtractErrorCodeFromCheckId(string checkId);
}
[ExportQuickInfoProviderAttribute("EmbeddedLanguages", "C#")]
[ExtensionOrderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.QuickInfo.CSharpEmbeddedLanguageQuickInfoProvider : AbstractEmbeddedLanguageQuickInfoProvider {
    [NullableContextAttribute("1")]
[ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public CSharpEmbeddedLanguageQuickInfoProvider(IEnumerable`1<Lazy`2<IEmbeddedLanguageQuickInfoProvider, EmbeddedLanguageMetadata>> services);
}
internal class Microsoft.CodeAnalysis.CSharp.QuickInfo.CSharpQuickInfoService : QuickInfoServiceWithProviders {
    [NullableContextAttribute("1")]
internal CSharpQuickInfoService(LanguageServices services);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.QuickInfo.QuickInfoService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.QuickInfo.CSharpQuickInfoServiceFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExportQuickInfoProviderAttribute("Semantic", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.QuickInfo.CSharpSemanticQuickInfoProvider : CommonSemanticQuickInfoProvider {
    protected virtual bool GetBindableNodeForTokenIndicatingLambda(SyntaxToken token, SyntaxNode& found);
    protected virtual bool GetBindableNodeForTokenIndicatingPossibleIndexerAccess(SyntaxToken token, SyntaxNode& found);
    protected virtual bool GetBindableNodeForTokenIndicatingMemberAccess(SyntaxToken token, SyntaxToken& found);
    protected virtual bool ShouldCheckPreviousToken(SyntaxToken token);
    [NullableContextAttribute("1")]
protected virtual NullableFlowState GetNullabilityAnalysis(SemanticModel semanticModel, ISymbol symbol, SyntaxNode node, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportQuickInfoProviderAttribute("Syntactic", "C#")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.QuickInfo.CSharpSyntacticQuickInfoProvider : CommonQuickInfoProvider {
    protected virtual Task`1<QuickInfoItem> BuildQuickInfoAsync(QuickInfoContext context, SyntaxToken token);
    protected virtual Task`1<QuickInfoItem> BuildQuickInfoAsync(CommonQuickInfoContext context, SyntaxToken token);
    [NullableContextAttribute("2")]
private static QuickInfoItem BuildQuickInfo(SyntaxToken token, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static QuickInfoItem BuildQuickInfoCloseBrace(SyntaxToken token);
    private static bool IsScopeBlock(SyntaxNode node);
    private static void MarkInterestedSpanNearbyScopeBlock(SyntaxNode block, SyntaxToken openBrace, Int32& spanStart, Int32& spanEnd);
    private static bool TryFindFurthestNearbyComment(T& triviaSearchList, SyntaxTrivia& nearbyTrivia);
    [NullableContextAttribute("2")]
private static QuickInfoItem BuildQuickInfoDirectives(SyntaxToken token, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveAsyncModifier.CSharpRemoveAsyncModifierCodeFixProvider : AbstractRemoveAsyncModifierCodeFixProvider`2<ReturnStatementSyntax, ExpressionSyntax> {
    private static string CS1998;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsAsyncSupportingFunctionSyntax(SyntaxNode node);
    protected virtual SyntaxNode ConvertToBlockBody(SyntaxNode node, ExpressionSyntax expressionBody);
    protected virtual SyntaxNode RemoveAsyncModifier(SyntaxGenerator generator, SyntaxNode methodLikeNode);
    private static SyntaxNode AnnotateBlock(SyntaxGenerator generator, SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.RemoveAsyncModifier.RemoveAsyncModifierHelpers : object {
    internal static SyntaxNode WithoutAsyncModifier(MethodDeclarationSyntax method, TypeSyntax returnType);
    internal static SyntaxNode WithoutAsyncModifier(LocalFunctionStatementSyntax localFunction, TypeSyntax returnType);
    internal static SyntaxNode WithoutAsyncModifier(ParenthesizedLambdaExpressionSyntax lambda);
    internal static SyntaxNode WithoutAsyncModifier(SimpleLambdaExpressionSyntax lambda);
    internal static SyntaxNode WithoutAsyncModifier(AnonymousMethodExpressionSyntax method);
    private static SyntaxTokenList RemoveAsyncModifier(SyntaxTokenList modifiers, TypeSyntax& newReturnType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveConfusingSuppression.CSharpRemoveConfusingSuppressionCodeFixProvider : CodeFixProvider {
    public static string RemoveOperator;
    public static string NegateExpression;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.RemoveConfusingSuppression.CSharpRemoveConfusingSuppressionCodeFixProvider/<FixAllAsync>d__6")]
private static Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, bool negate, CancellationToken cancellationToken);
    public virtual FixAllProvider GetFixAllProvider();
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveConfusingSuppression.CSharpRemoveConfusingSuppressionDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveInKeyword.RemoveInKeywordCodeFixProvider : CodeFixProvider {
    private static string CS1615;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual FixAllProvider GetFixAllProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.RemoveInKeyword.RemoveInKeywordCodeFixProvider/<RegisterCodeFixesAsync>d__5")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.RemoveInKeyword.RemoveInKeywordCodeFixProvider/<FixAsync>d__6")]
private static Task`1<Document> FixAsync(Document document, ArgumentSyntax argumentSyntax, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveRedundantEquality.CSharpRemoveRedundantEqualityDiagnosticAnalyzer : AbstractRemoveRedundantEqualityDiagnosticAnalyzer {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryCast.CSharpRemoveUnnecessaryCastCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryCast.CSharpRemoveUnnecessaryCastCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static ExpressionSyntax Recurse(ExpressionSyntax old);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryCast.CSharpRemoveUnnecessaryCastDiagnosticAnalyzer : AbstractRemoveUnnecessaryCastDiagnosticAnalyzer`2<SyntaxKind, ExpressionSyntax> {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxKind> <SyntaxKindsOfInterest>k__BackingField;
    protected ImmutableArray`1<SyntaxKind> SyntaxKindsOfInterest { get; }
    [CompilerGeneratedAttribute]
protected virtual ImmutableArray`1<SyntaxKind> get_SyntaxKindsOfInterest();
    [NullableContextAttribute("1")]
protected virtual bool IsUnnecessaryCast(SemanticModel model, ExpressionSyntax cast, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
protected virtual TextSpan GetFadeSpan(ExpressionSyntax node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryDiscardDesignation.CSharpRemoveUnnecessaryDiscardDesignationCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryDiscardDesignation.CSharpRemoveUnnecessaryDiscardDesignationDiagnosticAnalyzer : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeDiscardDesignation(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <AnalyzeDiscardDesignation>g__Report|3_0(DiscardDesignationSyntax discard, <>c__DisplayClass3_0& );
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryImports.CSharpRemoveUnnecessaryImportsCodeFixProvider : AbstractRemoveUnnecessaryImportsCodeFixProvider {
    protected virtual string GetTitle();
    protected virtual ISyntaxFormatting GetSyntaxFormatting();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryImports.CSharpRemoveUnnecessaryImportsDiagnosticAnalyzer : AbstractRemoveUnnecessaryImportsDiagnosticAnalyzer`1<UsingDirectiveSyntax> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected IUnnecessaryImportsProvider`1<UsingDirectiveSyntax> UnnecessaryImportsProvider { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual ImmutableArray`1<SyntaxNode> MergeImports(ImmutableArray`1<UsingDirectiveSyntax> unnecessaryImports);
    protected virtual IUnnecessaryImportsProvider`1<UsingDirectiveSyntax> get_UnnecessaryImportsProvider();
    protected virtual bool IsRegularCommentOrDocComment(SyntaxTrivia trivia);
    protected virtual Nullable`1<SyntaxToken> TryGetLastToken(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryImports.CSharpRemoveUnnecessaryImportsDiagnosticAnalyzer/<GetFixableDiagnosticSpans>d__8")]
protected virtual IEnumerable`1<TextSpan> GetFixableDiagnosticSpans(IEnumerable`1<SyntaxNode> nodes, SyntaxTree tree, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryLambdaExpression.CSharpRemoveUnnecessaryLambdaExpressionCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryLambdaExpression.CSharpRemoveUnnecessaryLambdaExpressionDiagnosticAnalyzer : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("2")]
private void AnalyzeSyntax(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType, INamedTypeSymbol conditionalAttributeType);
    private static bool OverloadsChanged(SemanticModel semanticModel1, SyntaxNode node1, SemanticModel semanticModel2, SyntaxNode node2, CancellationToken cancellationToken);
    private static bool IsIdentityOrImplicitConversion(Compilation compilation, ITypeSymbol type1, ITypeSymbol type2);
    private static bool MayHaveSideEffects(ExpressionSyntax expression);
    private static SeparatedSyntaxList`1<ParameterSyntax> GetParameters(AnonymousFunctionExpressionSyntax expression);
    public static bool TryGetAnonymousFunctionInvocation(AnonymousFunctionExpressionSyntax anonymousFunction, InvocationExpressionSyntax& invocation, Boolean& wasAwaited);
    private static bool TryGetInvocation(ExpressionSyntax expression, InvocationExpressionSyntax& invocation, Boolean& wasAwaited);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryParentheses.CSharpRemoveUnnecessaryExpressionParenthesesDiagnosticAnalyzer : AbstractRemoveUnnecessaryParenthesesDiagnosticAnalyzer`2<SyntaxKind, ParenthesizedExpressionSyntax> {
    protected virtual SyntaxKind GetSyntaxKind();
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual bool CanRemoveParentheses(ParenthesizedExpressionSyntax parenthesizedExpression, SemanticModel semanticModel, CancellationToken cancellationToken, PrecedenceKind& precedence, Boolean& clarifiesPrecedence);
    public static bool CanRemoveParenthesesHelper(ParenthesizedExpressionSyntax parenthesizedExpression, SemanticModel semanticModel, CancellationToken cancellationToken, PrecedenceKind& parentPrecedenceKind, Boolean& clarifiesPrecedence);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryParentheses.CSharpRemoveUnnecessaryParenthesesCodeFixProvider : AbstractRemoveUnnecessaryParenthesesCodeFixProvider`1<SyntaxNode> {
    protected virtual bool CanRemoveParentheses(SyntaxNode current, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessaryParentheses.CSharpRemoveUnnecessaryPatternParenthesesDiagnosticAnalyzer : AbstractRemoveUnnecessaryParenthesesDiagnosticAnalyzer`2<SyntaxKind, ParenthesizedPatternSyntax> {
    protected virtual SyntaxKind GetSyntaxKind();
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual bool CanRemoveParentheses(ParenthesizedPatternSyntax parenthesizedExpression, SemanticModel semanticModel, CancellationToken cancellationToken, PrecedenceKind& precedence, Boolean& clarifiesPrecedence);
    public static bool CanRemoveParenthesesHelper(ParenthesizedPatternSyntax parenthesizedPattern, PrecedenceKind& parentPrecedenceKind, Boolean& clarifiesPrecedence);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessarySuppressions.CSharpRemoveUnnecessaryAttributeSuppressionsDiagnosticAnalyzer : AbstractRemoveUnnecessaryAttributeSuppressionsDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
protected virtual void RegisterAttributeSyntaxAction(CompilationStartAnalysisContext context, CompilationAnalyzer compilationAnalyzer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnnecessarySuppressions.CSharpRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer : AbstractRemoveUnnecessaryInlineSuppressionsDiagnosticAnalyzer {
    protected string CompilerErrorCodePrefix { get; }
    protected int CompilerErrorCodeDigitCount { get; }
    protected ISyntaxFacts SyntaxFacts { get; }
    protected ISemanticFacts SemanticFacts { get; }
    protected virtual string get_CompilerErrorCodePrefix();
    protected virtual int get_CompilerErrorCodeDigitCount();
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual ISemanticFacts get_SemanticFacts();
    protected virtual ValueTuple`2<Assembly, string> GetCompilerDiagnosticAnalyzerInfo();
    protected virtual bool ContainsPragmaDirective(SyntaxNode root);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnreachableCode.CSharpRemoveUnreachableCodeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    private static bool IsSubsequentSection(Diagnostic diagnostic);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <FixAllAsync>g__RemoveStatement|7_0(SyntaxEditor editor, SyntaxNode statement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnreachableCode.CSharpRemoveUnreachableCodeDiagnosticAnalyzer : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    private static string CS0162;
    public static string IsSubsequentSection;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_subsequentSectionProperties;
    private static CSharpRemoveUnreachableCodeDiagnosticAnalyzer();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSemanticModel(SemanticModelAnalysisContext context);
    private void ProcessUnreachableDiagnostic(SemanticModelAnalysisContext context, SyntaxNode root, TextSpan sourceSpan);
}
internal static class Microsoft.CodeAnalysis.CSharp.RemoveUnreachableCode.RemoveUnreachableCodeHelpers : object {
    [NullableContextAttribute("1")]
public static ImmutableArray`1<ImmutableArray`1<StatementSyntax>> GetSubsequentUnreachableSections(StatementSyntax firstUnreachableStatement);
    private static void AddIfNonEmpty(ArrayBuilder`1<ImmutableArray`1<StatementSyntax>> sections, ImmutableArray`1<StatementSyntax> lastSection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnusedLocalFunction.CSharpRemoveUnusedLocalFunctionCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string CS8321;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnusedMembers.CSharpRemoveUnusedMembersCodeFixProvider : AbstractRemoveUnusedMembersCodeFixProvider`1<FieldDeclarationSyntax> {
    protected virtual void AdjustAndAddAppropriateDeclaratorsToRemove(HashSet`1<FieldDeclarationSyntax> fieldDeclarators, HashSet`1<SyntaxNode> declarators);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnusedMembers.CSharpRemoveUnusedMembersDiagnosticAnalyzer : AbstractRemoveUnusedMembersDiagnosticAnalyzer`4<DocumentationCommentTriviaSyntax, IdentifierNameSyntax, TypeDeclarationSyntax, MemberDeclarationSyntax> {
    protected virtual IEnumerable`1<TypeDeclarationSyntax> GetTypeDeclarations(INamedTypeSymbol namedType, CancellationToken cancellationToken);
    protected virtual SyntaxList`1<MemberDeclarationSyntax> GetMembers(TypeDeclarationSyntax typeDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnusedParametersAndValues.CSharpRemoveUnusedParametersAndValuesDiagnosticAnalyzer : AbstractRemoveUnusedParametersAndValuesDiagnosticAnalyzer {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual bool SupportsDiscard(SyntaxTree tree);
    protected virtual bool MethodHasHandlesClause(IMethodSymbol method);
    protected virtual bool IsIfConditionalDirective(SyntaxNode node);
    protected virtual bool ReturnsThrow(SyntaxNode node);
    protected virtual CodeStyleOption2`1<UnusedValuePreference> GetUnusedValueExpressionStatementOption(AnalyzerOptionsProvider provider);
    protected virtual CodeStyleOption2`1<UnusedValuePreference> GetUnusedValueAssignmentOption(AnalyzerOptionsProvider provider);
    protected virtual bool ShouldBailOutFromRemovableAssignmentAnalysis(IOperation unusedSymbolWriteOperation);
    protected virtual bool IsCallStatement(IExpressionStatementOperation expressionStatement);
    protected virtual bool IsExpressionOfExpressionBody(IExpressionStatementOperation expressionStatementOperation);
    protected virtual Location GetDefinitionLocationToFade(IOperation unusedDefinition);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnusedParametersAndValues.CSharpRemoveUnusedValuesCodeFixProvider : AbstractRemoveUnusedValuesCodeFixProvider`11<ExpressionSyntax, StatementSyntax, BlockSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, ForEachStatementSyntax, SwitchSectionSyntax, SwitchLabelSyntax, CatchClauseSyntax, CatchClauseSyntax> {
    protected virtual ISyntaxFormatting GetSyntaxFormatting();
    protected virtual BlockSyntax WrapWithBlockIfNecessary(IEnumerable`1<StatementSyntax> statements);
    protected virtual SyntaxToken GetForEachStatementIdentifier(ForEachStatementSyntax node);
    protected virtual LocalDeclarationStatementSyntax GetCandidateLocalDeclarationForRemoval(VariableDeclaratorSyntax declarator);
    protected virtual SyntaxNode TryUpdateNameForFlaggedNode(SyntaxNode node, SyntaxToken newName);
    protected virtual SyntaxNode TryUpdateParentOfUpdatedNode(SyntaxNode parent, SyntaxNode newNameNode, SyntaxEditor editor, ISyntaxFacts syntaxFacts, SemanticModel semanticModel);
    protected virtual SyntaxNode ComputeReplacementNode(SyntaxNode originalOldNode, SyntaxNode changedOldNode, SyntaxNode proposedReplacementNode);
    protected virtual void InsertAtStartOfSwitchCaseBlockForDeclarationInCaseLabelOrClause(SwitchSectionSyntax switchCaseBlock, SyntaxEditor editor, LocalDeclarationStatementSyntax declarationStatement);
    protected virtual SyntaxNode GetReplacementNodeForCompoundAssignment(SyntaxNode originalCompoundAssignment, SyntaxNode newAssignmentTarget, SyntaxEditor editor, ISyntaxFactsService syntaxFacts);
    protected virtual SyntaxNode GetReplacementNodeForVarPattern(SyntaxNode originalVarPattern, SyntaxNode newNameNode);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.RemoveUnusedVariable.CSharpRemoveUnusedVariableCodeFixProvider : AbstractRemoveUnusedVariableCodeFixProvider`3<LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, VariableDeclarationSyntax> {
    public static string CS0168;
    public static string CS0219;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IsCatchDeclarationIdentifier(SyntaxToken token);
    protected virtual SyntaxNode GetNodeToRemoveOrReplace(SyntaxNode node);
    protected virtual void RemoveOrReplaceNode(SyntaxEditor editor, SyntaxNode node, IBlockFactsService blockFacts);
    protected virtual SeparatedSyntaxList`1<SyntaxNode> GetVariables(LocalDeclarationStatementSyntax localDeclarationStatement);
    protected virtual bool ShouldOfferFixForLocalDeclaration(IBlockFactsService blockFacts, SyntaxNode node);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Rename.IRenameIssuesService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameIssuesService : object {
    [NullableContextAttribute("1")]
public sealed virtual bool CheckLanguageSpecificIssues(SemanticModel semanticModel, ISymbol symbol, SyntaxToken triggerToken, String& langError);
    private static bool IsTypeNamedVarInVariableOrFieldDeclaration(SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ReplaceConditionalWithStatements.CSharpReplaceConditionalWithStatementsCodeRefactoringProvider : AbstractReplaceConditionalWithStatementsCodeRefactoringProvider`9<ExpressionSyntax, ConditionalExpressionSyntax, StatementSyntax, LocalDeclarationStatementSyntax, ArgumentSyntax, BaseArgumentListSyntax, VariableDeclaratorSyntax, VariableDeclaratorSyntax, EqualsValueClauseSyntax> {
    protected virtual bool CanRewriteLocalDeclarationStatement(LocalDeclarationStatementSyntax localDeclarationStatement);
    protected virtual bool HasSingleVariable(LocalDeclarationStatementSyntax localDeclarationStatement, VariableDeclaratorSyntax& variable);
    protected virtual LocalDeclarationStatementSyntax GetUpdatedLocalDeclarationStatement(SyntaxGenerator generator, LocalDeclarationStatementSyntax localDeclarationStatement, ILocalSymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ReplaceDefaultLiteral.CSharpReplaceDefaultLiteralCodeFixProvider : CodeFixProvider {
    private static string CS8313;
    private static string CS8505;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ReplaceDefaultLiteral.CSharpReplaceDefaultLiteralCodeFixProvider/<RegisterCodeFixesAsync>d__7")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ReplaceDefaultLiteral.CSharpReplaceDefaultLiteralCodeFixProvider/<ReplaceAsync>d__8")]
private static Task`1<Document> ReplaceAsync(Document document, TextSpan span, SyntaxNode newExpression, CancellationToken cancellationToken);
    private static ValueTuple`2<SyntaxNode, string> GetReplacementExpressionAndText(Document document, SemanticModel semanticModel, LiteralExpressionSyntax defaultLiteral, CancellationToken cancellationToken);
    private static bool IsFlagsEnum(ITypeSymbol type, Compilation compilation);
    [NullableContextAttribute("2")]
private static bool IsZero(object o);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<SyntaxNode, string> <GetReplacementExpressionAndText>g__GenerateMemberAccess|9_0(string memberName, <>c__DisplayClass9_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ReplaceDocCommentTextWithTag.CSharpReplaceDocCommentTextWithTagCodeRefactoringProvider : AbstractReplaceDocCommentTextWithTagCodeRefactoringProvider {
    protected virtual bool IsXmlTextToken(SyntaxToken token);
    protected virtual bool IsInXMLAttribute(SyntaxToken token);
    protected virtual bool IsKeyword(string text);
    protected virtual SyntaxNode ParseExpression(string text);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ReplacePropertyWithMethods.IReplacePropertyWithMethodsService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ReplacePropertyWithMethods.CSharpReplacePropertyWithMethodsService : AbstractReplacePropertyWithMethodsService`5<IdentifierNameSyntax, ExpressionSyntax, NameMemberCrefSyntax, StatementSyntax, PropertyDeclarationSyntax> {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ReplacePropertyWithMethods.CSharpReplacePropertyWithMethodsService/<GetReplacementMembersAsync>d__3")]
public virtual Task`1<ImmutableArray`1<SyntaxNode>> GetReplacementMembersAsync(Document document, IPropertySymbol property, SyntaxNode propertyDeclarationNode, IFieldSymbol propertyBackingField, string desiredGetMethodName, string desiredSetMethodName, CodeGenerationOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static ImmutableArray`1<SyntaxNode> ConvertPropertyToMembers(LanguageVersion languageVersion, SyntaxGenerator generator, IPropertySymbol property, PropertyDeclarationSyntax propertyDeclaration, IFieldSymbol propertyBackingField, ExpressionBodyPreference expressionBodyPreference, string desiredGetMethodName, string desiredSetMethodName, CancellationToken cancellationToken);
    private static SyntaxNode GetSetMethod(LanguageVersion languageVersion, SyntaxGenerator generator, PropertyDeclarationSyntax propertyDeclaration, IFieldSymbol propertyBackingField, IMethodSymbol setMethod, string desiredSetMethodName, ExpressionBodyPreference expressionBodyPreference, CancellationToken cancellationToken);
    private static SyntaxNode GetGetMethod(LanguageVersion languageVersion, SyntaxGenerator generator, PropertyDeclarationSyntax propertyDeclaration, IFieldSymbol propertyBackingField, IMethodSymbol getMethod, string desiredGetMethodName, ExpressionBodyPreference expressionBodyPreference, CancellationToken cancellationToken);
    private static MethodDeclarationSyntax CopyLeadingTrivia(PropertyDeclarationSyntax propertyDeclaration, MethodDeclarationSyntax methodDeclaration, CSharpSyntaxRewriter documentationCommentRewriter);
    private static SyntaxTrivia ConvertTrivia(SyntaxTrivia trivia, CSharpSyntaxRewriter rewriter);
    private static SyntaxTrivia ConvertDocumentationComment(SyntaxTrivia trivia, CSharpSyntaxRewriter rewriter);
    private static SyntaxNode UseExpressionOrBlockBodyIfDesired(LanguageVersion languageVersion, MethodDeclarationSyntax methodDeclaration, ExpressionBodyPreference expressionBodyPreference, bool createReturnStatementForExpression, CancellationToken cancellationToken);
    private static bool IsValueName(XmlNameSyntax name);
    public virtual SyntaxNode GetPropertyNodeToReplace(SyntaxNode propertyDeclaration);
    protected virtual NameMemberCrefSyntax TryGetCrefSyntax(IdentifierNameSyntax identifierName);
    protected virtual NameMemberCrefSyntax CreateCrefSyntax(NameMemberCrefSyntax originalCref, SyntaxToken identifierToken, SyntaxNode parameterType);
    protected virtual ExpressionSyntax UnwrapCompoundAssignment(SyntaxNode compoundAssignment, ExpressionSyntax readExpression);
    [CompilerGeneratedAttribute]
internal static MethodDeclarationSyntax <GetSetMethod>g__GetSetMethodWorker|5_0(<>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static MethodDeclarationSyntax <GetGetMethod>g__GetGetMethodWorker|6_0(<>c__DisplayClass6_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.ReverseForStatement.CSharpReverseForStatementCodeRefactoringProvider : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ReverseForStatement.CSharpReverseForStatementCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static bool IsUnsignedBoundary(SemanticModel semanticModel, VariableDeclaratorSyntax variable, ExpressionSyntax start, ExpressionSyntax end, CancellationToken cancellationToken);
    private static bool IsUnsignedBoundary(Optional`1<object> startValue, Optional`1<object> endValue, ulong maxValue);
    private static bool ValueEquals(Optional`1<object> valueOpt, ulong value);
    private static bool MatchesIncrementPattern(VariableDeclaratorSyntax variable, BinaryExpressionSyntax condition, ExpressionSyntax after, ExpressionSyntax& start, Boolean& equals, ExpressionSyntax& end);
    private static bool MatchesDecrementPattern(VariableDeclaratorSyntax variable, BinaryExpressionSyntax condition, ExpressionSyntax after, ExpressionSyntax& end, ExpressionSyntax& start);
    private static bool IsIncrementInitializer(VariableDeclaratorSyntax variable, ExpressionSyntax& start);
    private static bool IsIncrementCondition(VariableDeclaratorSyntax variable, BinaryExpressionSyntax condition, Boolean& equals, ExpressionSyntax& end);
    private static bool IsIncrementAfter(VariableDeclaratorSyntax variable, ExpressionSyntax after);
    private static bool IsLiteralOne(ExpressionSyntax expression);
    private static bool IsDecrementInitializer(VariableDeclaratorSyntax variable, ExpressionSyntax& end);
    private static bool IsDecrementCondition(VariableDeclaratorSyntax variable, BinaryExpressionSyntax condition, ExpressionSyntax& start);
    private static bool IsDecrementAfter(VariableDeclaratorSyntax variable, ExpressionSyntax after);
    private static bool IsVariableReference(VariableDeclaratorSyntax variable, ExpressionSyntax expr);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.ReverseForStatement.CSharpReverseForStatementCodeRefactoringProvider/<ReverseForStatementAsync>d__15")]
private static Task`1<Document> ReverseForStatementAsync(Document document, ForStatementSyntax forStatement, CancellationToken cancellationToken);
    private static ExpressionSyntax Reduce(ExpressionSyntax expr);
    private static BinaryExpressionSyntax Invert(VariableDeclaratorSyntax variable, BinaryExpressionSyntax condition, ExpressionSyntax operand);
    private static ExpressionSyntax InvertAfter(ExpressionSyntax after);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.SignatureHelp.AbstractCSharpSignatureHelpProvider : AbstractSignatureHelpProvider {
    private static SymbolDisplayFormat s_allowDefaultLiteralFormat;
    private static IList`1<SymbolDisplayPart> _separatorParts;
    private static AbstractCSharpSignatureHelpProvider();
    protected static SymbolDisplayPart Keyword(SyntaxKind kind);
    protected static SymbolDisplayPart Operator(SyntaxKind kind);
    protected static SymbolDisplayPart Punctuation(SyntaxKind kind);
    protected static SymbolDisplayPart Text(string text);
    protected static SymbolDisplayPart Space();
    protected static SymbolDisplayPart NewLine();
    protected static IList`1<SymbolDisplayPart> GetSeparatorParts();
    protected static SignatureHelpSymbolParameter Convert(IParameterSymbol parameter, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService formatter);
    [ObsoleteAttribute("Expected to exist by IntelliCode. This can be removed once their unnecessary use of this is removed.")]
protected IList`1<TaggedText> GetAwaitableUsage(IMethodSymbol method, SemanticModel semanticModel, int position);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.SignatureHelp.AbstractOrdinaryMethodSignatureHelpProvider : AbstractCSharpSignatureHelpProvider {
    internal static SignatureHelpItem ConvertMethodGroupMethod(Document document, IMethodSymbol method, int position, SemanticModel semanticModel);
    internal static SignatureHelpItem ConvertMethodGroupMethod(Document document, IMethodSymbol method, int position, SemanticModel semanticModel, IList`1<SymbolDisplayPart> descriptionParts);
    private static IList`1<SymbolDisplayPart> GetMethodGroupPreambleParts(IMethodSymbol method, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetMethodGroupPostambleParts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSignatureHelpProviderAttribute("AttributeSignatureHelpProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.AttributeSignatureHelpProvider : AbstractCSharpSignatureHelpProvider {
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    private bool TryGetAttributeExpression(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, AttributeSyntax& attribute);
    private bool IsTriggerToken(SyntaxToken token);
    private static bool IsArgumentListToken(AttributeSyntax expression, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.AttributeSignatureHelpProvider/<GetItemsWorkerAsync>d__6")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
    private Nullable`1<SignatureHelpState> GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
    private static SignatureHelpItem Convert(IMethodSymbol constructor, ISymbol within, AttributeSyntax attribute, SemanticModel semanticModel, IStructuralTypeDisplayService structuralTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormatter, CancellationToken cancellationToken);
    private static IList`1<SignatureHelpSymbolParameter> GetParameters(IMethodSymbol constructor, SemanticModel semanticModel, int position, IList`1<ISymbol> namedParameters, IDocumentationCommentFormattingService documentationCommentFormatter, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static List`1<SymbolDisplayPart> GetParameterPrefixDisplayParts(int i);
    private static IList`1<SymbolDisplayPart> GetPreambleParts(IMethodSymbol method, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetPostambleParts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSignatureHelpProviderAttribute("ConstructorInitializerSignatureHelpProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.ConstructorInitializerSignatureHelpProvider : AbstractCSharpSignatureHelpProvider {
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.ConstructorInitializerSignatureHelpProvider/<TryGetConstructorInitializerAsync>d__3")]
private Task`1<ConstructorInitializerSyntax> TryGetConstructorInitializerAsync(Document document, int position, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken);
    private bool IsTriggerToken(SyntaxToken token);
    private static bool IsArgumentListToken(ConstructorInitializerSyntax expression, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.ConstructorInitializerSignatureHelpProvider/<GetItemsWorkerAsync>d__6")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.ConstructorInitializerSignatureHelpProvider/<GetCurrentArgumentStateAsync>d__7")]
private Task`1<Nullable`1<SignatureHelpState>> GetCurrentArgumentStateAsync(Document document, int position, TextSpan currentSpan, CancellationToken cancellationToken);
    private static SignatureHelpItem Convert(IMethodSymbol constructor, SyntaxToken openToken, SemanticModel semanticModel, IStructuralTypeDisplayService structuralTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService);
    private static IList`1<SymbolDisplayPart> GetPreambleParts(IMethodSymbol method, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetPostambleParts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSignatureHelpProviderAttribute("ElementAccessExpressionSignatureHelpProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.ElementAccessExpressionSignatureHelpProvider : AbstractCSharpSignatureHelpProvider {
    public virtual bool IsTriggerCharacter(char ch);
    private static bool IsTriggerCharacterInternal(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    private static bool TryGetElementAccessExpression(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, ExpressionSyntax& identifier, SyntaxToken& openBrace);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.ElementAccessExpressionSignatureHelpProvider/<GetItemsWorkerAsync>d__5")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
    private static TextSpan GetTextSpan(ExpressionSyntax expression, SyntaxToken openBracket);
    private static Nullable`1<SignatureHelpState> GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
    private static bool TryGetComIndexers(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken, ImmutableArray`1& indexers, ITypeSymbol& expressionType);
    private static bool TryGetIndexers(int position, SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken, ImmutableArray`1& indexers, ITypeSymbol& expressionType);
    private static SignatureHelpItem Convert(IPropertySymbol indexer, SyntaxToken openToken, SemanticModel semanticModel, IStructuralTypeDisplayService structuralTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService);
    private static IList`1<SymbolDisplayPart> GetPreambleParts(IPropertySymbol indexer, int position, SemanticModel semanticModel);
    private static IList`1<SymbolDisplayPart> GetPostambleParts();
}
[ExportSignatureHelpProviderAttribute("GenericNamePartiallyWrittenSignatureHelpProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.GenericNamePartiallyWrittenSignatureHelpProvider : GenericNameSignatureHelpProvider {
    [NullableContextAttribute("1")]
protected virtual bool TryGetGenericIdentifier(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, SyntaxToken& genericIdentifier, SyntaxToken& lessThanToken);
    protected virtual TextSpan GetTextSpan(SyntaxToken genericIdentifier, SyntaxToken lessThanToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSignatureHelpProviderAttribute("GenericNameSignatureHelpProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.GenericNameSignatureHelpProvider : AbstractCSharpSignatureHelpProvider {
    private static SymbolDisplayFormat s_minimallyQualifiedFormat;
    private static GenericNameSignatureHelpProvider();
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    protected virtual bool TryGetGenericIdentifier(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, SyntaxToken& genericIdentifier, SyntaxToken& lessThanToken);
    private bool IsTriggerToken(SyntaxToken token);
    private bool IsArgumentListToken(GenericNameSyntax node, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.GenericNameSignatureHelpProvider/<GetItemsWorkerAsync>d__6")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
    private Nullable`1<SignatureHelpState> GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, CancellationToken cancellationToken);
    protected virtual TextSpan GetTextSpan(SyntaxToken genericIdentifier, SyntaxToken lessThanToken);
    private static SignatureHelpItem Convert(ISymbol symbol, SyntaxToken lessThanToken, SemanticModel semanticModel, IStructuralTypeDisplayService structuralTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService);
    private static SignatureHelpSymbolParameter Convert(ITypeParameterSymbol parameter, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService formatter);
    private static IList`1<SymbolDisplayPart> GetSelectedDisplayParts(ITypeParameterSymbol typeParam, SemanticModel semanticModel, int position);
    private static bool TypeParameterHasConstraints(ITypeParameterSymbol typeParam);
    private static IList`1<SymbolDisplayPart> GetPreambleParts(IMethodSymbol method, SemanticModel semanticModel, int position);
    private static ITypeSymbol GetContainingType(IMethodSymbol method);
    private static IList`1<SymbolDisplayPart> GetPostambleParts(IMethodSymbol method, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetPreambleParts(INamedTypeSymbol namedType, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetPostambleParts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSignatureHelpProviderAttribute("InitializerExpressionSignatureHelpProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.InitializerExpressionSignatureHelpProvider : AbstractOrdinaryMethodSignatureHelpProvider {
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    private bool TryGetInitializerExpression(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, InitializerExpressionSyntax& expression);
    private bool IsTriggerToken(SyntaxToken token);
    private static bool IsInitializerExpressionToken(InitializerExpressionSyntax expression, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.InitializerExpressionSignatureHelpProvider/<GetItemsWorkerAsync>d__6")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
    private Nullable`1<SignatureHelpState> GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
}
[ExportSignatureHelpProviderAttribute("InvocationExpressionSignatureHelpProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.InvocationExpressionSignatureHelpProvider : InvocationExpressionSignatureHelpProviderBase {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.InvocationExpressionSignatureHelpProviderBase : AbstractOrdinaryMethodSignatureHelpProvider {
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.InvocationExpressionSignatureHelpProviderBase/<TryGetInvocationExpressionAsync>d__2")]
private Task`1<InvocationExpressionSyntax> TryGetInvocationExpressionAsync(Document document, int position, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken);
    private bool IsTriggerToken(SyntaxToken token);
    private static bool IsArgumentListToken(InvocationExpressionSyntax expression, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.InvocationExpressionSignatureHelpProviderBase/<GetItemsWorkerAsync>d__5")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.InvocationExpressionSignatureHelpProviderBase/<GetItemsWorkerForDelegateOrFunctionPointerAsync>d__6")]
protected Task`1<SignatureHelpItems> GetItemsWorkerForDelegateOrFunctionPointerAsync(Document document, int position, InvocationExpressionSyntax invocationExpression, ISymbol within, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.InvocationExpressionSignatureHelpProviderBase/<GetCurrentArgumentStateAsync>d__7")]
private Task`1<Nullable`1<SignatureHelpState>> GetCurrentArgumentStateAsync(Document document, int position, TextSpan currentSpan, CancellationToken cancellationToken);
    private static IMethodSymbol GetDelegateInvokeMethod(InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel, ISymbol within, INamedTypeSymbol delegateType, CancellationToken cancellationToken);
    private static IList`1<SignatureHelpItem> GetDelegateOrFunctionPointerInvokeItems(InvocationExpressionSyntax invocationExpression, IMethodSymbol invokeMethod, SemanticModel semanticModel, IStructuralTypeDisplayService structuralTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService, Nullable`1& selectedItem, CancellationToken cancellationToken);
    private static IList`1<SymbolDisplayPart> GetDelegateOrFunctionPointerInvokePreambleParts(IMethodSymbol invokeMethod, SemanticModel semanticModel, int position);
    private static IList`1<SignatureHelpSymbolParameter> GetDelegateOrFunctionPointerInvokeParameters(IMethodSymbol invokeMethod, SemanticModel semanticModel, int position, IDocumentationCommentFormattingService formattingService, CancellationToken cancellationToken);
    private static IList`1<SymbolDisplayPart> GetDelegateOrFunctionPointerInvokePostambleParts();
    internal virtual Task`1<ValueTuple`2<ImmutableArray`1<SignatureHelpItem>, Nullable`1<int>>> GetMethodGroupItemsAndSelectionAsync(ImmutableArray`1<IMethodSymbol> accessibleMethods, Document document, InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel, SymbolInfo symbolInfo, IMethodSymbol currentSymbol, CancellationToken cancellationToken);
    private static ImmutableArray`1<IMethodSymbol> GetAccessibleMethods(InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel, ISymbol within, IEnumerable`1<IMethodSymbol> methodGroup, CancellationToken cancellationToken);
    private static bool IsHiddenByOtherMethod(IMethodSymbol method, ISet`1<IMethodSymbol> methodSet);
    private static bool IsHiddenBy(IMethodSymbol method1, IMethodSymbol method2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.LightweightOverloadResolution : ValueType {
    [CompilerGeneratedAttribute]
private SemanticModel <semanticModel>P;
    [CompilerGeneratedAttribute]
private int <position>P;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private SeparatedSyntaxList`1<ArgumentSyntax> <arguments>P;
    public LightweightOverloadResolution(SemanticModel semanticModel, int position, SeparatedSyntaxList`1<ArgumentSyntax> arguments);
    public ValueTuple`2<IMethodSymbol, int> RefineOverloadAndPickParameter(SymbolInfo symbolInfo, ImmutableArray`1<IMethodSymbol> candidates);
    public int FindParameterIndexIfCompatibleMethod(IMethodSymbol method);
    private ValueTuple`2<IMethodSymbol, int> GuessCurrentSymbolAndParameter(ImmutableArray`1<IMethodSymbol> methodGroup);
    private ValueTuple`2<IMethodSymbol, int> TryFindParameterIndexIfCompatibleMethod(IMethodSymbol method);
    private bool IsCompatibleArgument(ArgumentSyntax argument, IParameterSymbol parameter);
    [NullableContextAttribute("0")]
private int FirstUnspecifiedParameter(TemporaryArray`1& argumentToParameterMap);
    [NullableContextAttribute("0")]
private bool TryPrepareArgumentToParameterMap(IMethodSymbol method, TemporaryArray`1& argumentToParameterMap);
    private static bool IsEmptyArgument(ExpressionSyntax expression);
    private int GetArgumentIndex();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <TryPrepareArgumentToParameterMap>g__AddArgumentToParameterMapping|10_0(int argumentIndex, int parameterIndex, TemporaryArray`1& argumentToParameterMap, <>c__DisplayClass10_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSignatureHelpProviderAttribute("ObjectCreationExpressionSignatureHelpProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.ObjectCreationExpressionSignatureHelpProvider : AbstractCSharpSignatureHelpProvider {
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.ObjectCreationExpressionSignatureHelpProvider/<TryGetObjectCreationExpressionAsync>d__3")]
private Task`1<BaseObjectCreationExpressionSyntax> TryGetObjectCreationExpressionAsync(Document document, int position, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken);
    private bool IsTriggerToken(SyntaxToken token);
    private static bool IsArgumentListToken(BaseObjectCreationExpressionSyntax expression, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.ObjectCreationExpressionSignatureHelpProvider/<GetItemsWorkerAsync>d__6")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.ObjectCreationExpressionSignatureHelpProvider/<GetItemsWorkerForDelegateAsync>d__7")]
private Task`1<SignatureHelpItems> GetItemsWorkerForDelegateAsync(Document document, int position, BaseObjectCreationExpressionSyntax objectCreationExpression, INamedTypeSymbol type, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.ObjectCreationExpressionSignatureHelpProvider/<GetCurrentArgumentStateAsync>d__8")]
private Task`1<Nullable`1<SignatureHelpState>> GetCurrentArgumentStateAsync(Document document, int position, TextSpan currentSpan, CancellationToken cancellationToken);
    private static ImmutableArray`1<SignatureHelpItem> ConvertDelegateTypeConstructor(BaseObjectCreationExpressionSyntax objectCreationExpression, IMethodSymbol invokeMethod, SemanticModel semanticModel, IStructuralTypeDisplayService structuralTypeDisplayService, int position);
    private static IList`1<SymbolDisplayPart> GetDelegateTypePreambleParts(IMethodSymbol invokeMethod, SemanticModel semanticModel, int position);
    private static IList`1<SignatureHelpSymbolParameter> GetDelegateTypeParameters(IMethodSymbol invokeMethod, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetDelegateTypePostambleParts();
    private static SignatureHelpItem ConvertNormalTypeConstructor(IMethodSymbol constructor, BaseObjectCreationExpressionSyntax objectCreationExpression, SemanticModel semanticModel, IStructuralTypeDisplayService structuralTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService);
    private static IList`1<SymbolDisplayPart> GetNormalTypePreambleParts(IMethodSymbol method, SemanticModel semanticModel, int position);
    private static IList`1<SymbolDisplayPart> GetNormalTypePostambleParts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSignatureHelpProviderAttribute("PrimaryConstructorBaseTypeSignatureHelpProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.PrimaryConstructorBaseTypeSignatureHelpProvider : AbstractCSharpSignatureHelpProvider {
    public virtual bool IsTriggerCharacter(char ch);
    public virtual bool IsRetriggerCharacter(char ch);
    private bool TryGetBaseTypeSyntax(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, SignatureHelpTriggerReason triggerReason, CancellationToken cancellationToken, PrimaryConstructorBaseTypeSyntax& expression);
    private bool IsTriggerToken(SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.PrimaryConstructorBaseTypeSignatureHelpProvider/<GetItemsWorkerAsync>d__5")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
    private Nullable`1<SignatureHelpState> GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
    private static SignatureHelpItem Convert(IMethodSymbol constructor, SyntaxToken openToken, SemanticModel semanticModel, IStructuralTypeDisplayService structuralTypeDisplayService, IDocumentationCommentFormattingService documentationCommentFormattingService);
    [CompilerGeneratedAttribute]
internal static bool <TryGetBaseTypeSyntax>g__IsArgumentListToken|3_0(PrimaryConstructorBaseTypeSyntax expression, SyntaxToken token);
    [CompilerGeneratedAttribute]
internal static IList`1<SymbolDisplayPart> <Convert>g__GetPreambleParts|7_1(IMethodSymbol method, SemanticModel semanticModel, int position);
    [CompilerGeneratedAttribute]
internal static IList`1<SymbolDisplayPart> <Convert>g__GetPostambleParts|7_2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.SignatureHelp.SignatureHelpUtilities : object {
    private static Func`2<BaseArgumentListSyntax, SyntaxToken> s_getBaseArgumentListOpenToken;
    private static Func`2<TypeArgumentListSyntax, SyntaxToken> s_getTypeArgumentListOpenToken;
    private static Func`2<InitializerExpressionSyntax, SyntaxToken> s_getInitializerExpressionOpenToken;
    private static Func`2<AttributeArgumentListSyntax, SyntaxToken> s_getAttributeArgumentListOpenToken;
    private static Func`2<BaseArgumentListSyntax, SyntaxToken> s_getBaseArgumentListCloseToken;
    private static Func`2<TypeArgumentListSyntax, SyntaxToken> s_getTypeArgumentListCloseToken;
    private static Func`2<InitializerExpressionSyntax, SyntaxToken> s_getInitializerExpressionCloseToken;
    private static Func`2<AttributeArgumentListSyntax, SyntaxToken> s_getAttributeArgumentListCloseToken;
    private static Func`2<BaseArgumentListSyntax, SyntaxNodeOrTokenList> s_getBaseArgumentListArgumentsWithSeparators;
    private static Func`2<TypeArgumentListSyntax, SyntaxNodeOrTokenList> s_getTypeArgumentListArgumentsWithSeparators;
    private static Func`2<InitializerExpressionSyntax, SyntaxNodeOrTokenList> s_getInitializerExpressionArgumentsWithSeparators;
    private static Func`2<AttributeArgumentListSyntax, SyntaxNodeOrTokenList> s_getAttributeArgumentListArgumentsWithSeparators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<BaseArgumentListSyntax, IEnumerable`1<string>> s_getBaseArgumentListNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<TypeArgumentListSyntax, IEnumerable`1<string>> s_getTypeArgumentListNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<InitializerExpressionSyntax, IEnumerable`1<string>> s_getInitializerExpressionNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<AttributeArgumentListSyntax, IEnumerable`1<string>> s_getAttributeArgumentListNames;
    private static SignatureHelpUtilities();
    public static Nullable`1<SignatureHelpState> GetSignatureHelpState(BaseArgumentListSyntax argumentList, int position);
    internal static Nullable`1<SignatureHelpState> GetSignatureHelpState(TypeArgumentListSyntax argumentList, int position);
    internal static Nullable`1<SignatureHelpState> GetSignatureHelpState(InitializerExpressionSyntax argumentList, int position);
    internal static Nullable`1<SignatureHelpState> GetSignatureHelpState(AttributeArgumentListSyntax argumentList, int position);
    internal static TextSpan GetSignatureHelpSpan(BaseArgumentListSyntax argumentList);
    internal static TextSpan GetSignatureHelpSpan(TypeArgumentListSyntax argumentList);
    internal static TextSpan GetSignatureHelpSpan(InitializerExpressionSyntax initializer);
    internal static TextSpan GetSignatureHelpSpan(AttributeArgumentListSyntax argumentList);
    internal static bool IsTriggerParenOrComma(SyntaxToken token, Func`2<char, bool> isTriggerCharacter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSignatureHelpProviderAttribute("TupleSignatureHelpProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SignatureHelp.TupleConstructionSignatureHelpProvider : AbstractCSharpSignatureHelpProvider {
    private static Func`2<TupleExpressionSyntax, SyntaxToken> s_getOpenToken;
    private static Func`2<TupleExpressionSyntax, SyntaxToken> s_getCloseToken;
    private static Func`2<TupleExpressionSyntax, SyntaxNodeOrTokenList> s_getArgumentsWithSeparators;
    private static Func`2<TupleExpressionSyntax, IEnumerable`1<string>> s_getArgumentNames;
    private static TupleConstructionSignatureHelpProvider();
    private Nullable`1<SignatureHelpState> GetCurrentArgumentState(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken);
    private bool GetOuterMostTupleExpressionInSpan(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken, TupleExpressionSyntax& result);
    private bool GetOuterMostParenthesizedExpressionInSpan(SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, TextSpan currentSpan, CancellationToken cancellationToken, ParenthesizedExpressionSyntax& result);
    public virtual bool IsRetriggerCharacter(char ch);
    public virtual bool IsTriggerCharacter(char ch);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.SignatureHelp.TupleConstructionSignatureHelpProvider/<GetItemsWorkerAsync>d__10")]
protected virtual Task`1<SignatureHelpItems> GetItemsWorkerAsync(Document document, int position, SignatureHelpTriggerInfo triggerInfo, SignatureHelpOptions options, CancellationToken cancellationToken);
    private IEnumerable`1<INamedTypeSymbol> FindNearestTupleConstructionWithInferrableType(SyntaxNode root, SemanticModel semanticModel, int position, SignatureHelpTriggerInfo triggerInfo, ITypeInferenceService typeInferrer, ISyntaxFactsService syntaxFacts, CancellationToken cancellationToken, ExpressionSyntax& targetExpression);
    private SignatureHelpItems CreateItems(int position, SyntaxNode root, ISyntaxFactsService syntaxFacts, SyntaxNode targetExpression, SemanticModel semanticModel, IEnumerable`1<INamedTypeSymbol> tupleTypes, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private static SignatureHelpItem Convert(INamedTypeSymbol tupleType, ImmutableArray`1<TaggedText> prefixParts, ImmutableArray`1<TaggedText> suffixParts, ImmutableArray`1<TaggedText> separatorParts, SemanticModel semanticModel, int position);
    private static IEnumerable`1<SignatureHelpParameter> ConvertTupleMembers(INamedTypeSymbol tupleType, SemanticModel semanticModel, int position);
    private bool TryGetTupleExpression(SignatureHelpTriggerReason triggerReason, SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, CancellationToken cancellationToken, TupleExpressionSyntax& tupleExpression);
    private bool IsTupleExpressionTriggerToken(SyntaxToken token);
    [NullableContextAttribute("2")]
private static bool IsTupleArgumentListToken(TupleExpressionSyntax tupleExpression, SyntaxToken token);
    private bool TryGetParenthesizedExpression(SignatureHelpTriggerReason triggerReason, SyntaxNode root, int position, ISyntaxFactsService syntaxFacts, CancellationToken cancellationToken, ParenthesizedExpressionSyntax& parenthesizedExpression);
    private bool IsParenthesizedExpressionTriggerToken(SyntaxToken token);
    [NullableContextAttribute("2")]
private static bool IsParenthesizedExpressionToken(ParenthesizedExpressionSyntax expr, SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyBooleanExpression.CSharpSimplifyConditionalDiagnosticAnalyzer : AbstractSimplifyConditionalDiagnosticAnalyzer`3<SyntaxKind, ExpressionSyntax, ConditionalExpressionSyntax> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual CommonConversion GetConversion(SemanticModel semanticModel, ExpressionSyntax node, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyInterpolation.CSharpSimplifyInterpolationCodeFixProvider : AbstractSimplifyInterpolationCodeFixProvider`5<InterpolationSyntax, ExpressionSyntax, InterpolationAlignmentClauseSyntax, InterpolationFormatClauseSyntax, InterpolatedStringExpressionSyntax> {
    protected virtual AbstractSimplifyInterpolationHelpers GetHelpers();
    protected virtual InterpolationSyntax WithExpression(InterpolationSyntax interpolation, ExpressionSyntax expression);
    protected virtual InterpolationSyntax WithAlignmentClause(InterpolationSyntax interpolation, InterpolationAlignmentClauseSyntax alignmentClause);
    protected virtual InterpolationSyntax WithFormatClause(InterpolationSyntax interpolation, InterpolationFormatClauseSyntax formatClause);
    protected virtual string Escape(InterpolatedStringExpressionSyntax interpolatedString, string formatString);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyInterpolation.CSharpSimplifyInterpolationDiagnosticAnalyzer : AbstractSimplifyInterpolationDiagnosticAnalyzer`2<InterpolationSyntax, ExpressionSyntax> {
    protected virtual IVirtualCharService GetVirtualCharService();
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual AbstractSimplifyInterpolationHelpers GetHelpers();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyLinqExpression.CSharpSimplifyLinqExpressionCodeFixProvider : AbstractSimplifyLinqExpressionCodeFixProvider`3<InvocationExpressionSyntax, SimpleNameSyntax, ExpressionSyntax> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyLinqExpression.CSharpSimplifyLinqExpressionDiagnosticAnalyzer : AbstractSimplifyLinqExpressionDiagnosticAnalyzer`2<InvocationExpressionSyntax, MemberAccessExpressionSyntax> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual IInvocationOperation TryGetNextInvocationInChain(IInvocationOperation invocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyPropertyPattern.CSharpSimplifyPropertyPatternCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static SubpatternSyntax TrySimplify(SubpatternSyntax currentSubpattern);
    private static BaseExpressionColonSyntax Merge(BaseExpressionColonSyntax outerExpressionColon, BaseExpressionColonSyntax innerExpressionColon);
    [NullableContextAttribute("2")]
private static MemberAccessExpressionSyntax Merge(ExpressionSyntax outerExpression, ExpressionSyntax innerExpression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyPropertyPattern.CSharpSimplifyPropertyPatternDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSubpattern(SyntaxNodeAnalysisContext syntaxContext);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.SimplifyPropertyPattern.SimplifyPropertyPatternHelpers : object {
    public static bool IsSimplifiable(SubpatternSyntax subpattern, SubpatternSyntax& innerSubpattern, BaseExpressionColonSyntax& outerExpressionColon);
    public static bool IsMergable(ExpressionSyntax expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyThisOrMe.CSharpSimplifyThisOrMeCodeFixProvider : AbstractSimplifyThisOrMeCodeFixProvider`1<MemberAccessExpressionSyntax> {
    protected virtual string GetTitle();
    protected virtual SyntaxNode Rewrite(SyntaxNode root, ISet`1<MemberAccessExpressionSyntax> memberAccessNodes);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyThisOrMe.CSharpSimplifyThisOrMeDiagnosticAnalyzer : AbstractSimplifyThisOrMeDiagnosticAnalyzer`4<SyntaxKind, ExpressionSyntax, ThisExpressionSyntax, MemberAccessExpressionSyntax> {
    protected ISyntaxKinds SyntaxKinds { get; }
    protected ISimplification Simplification { get; }
    protected AbstractMemberAccessExpressionSimplifier`3<ExpressionSyntax, MemberAccessExpressionSyntax, ThisExpressionSyntax> Simplifier { get; }
    protected virtual ISyntaxKinds get_SyntaxKinds();
    protected virtual ISimplification get_Simplification();
    protected virtual AbstractMemberAccessExpressionSimplifier`3<ExpressionSyntax, MemberAccessExpressionSyntax, ThisExpressionSyntax> get_Simplifier();
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SimplifyTypeNames.SimplifyTypeNamesCodeFixProvider : AbstractSimplifyTypeNamesCodeFixProvider`2<SyntaxKind, CSharpSimplifierOptions> {
    protected virtual string GetTitle(string diagnosticId, string nodeText);
    protected virtual SyntaxNode AddSimplificationAnnotationTo(SyntaxNode expressionSyntax);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.Snippets.AbstractCSharpAutoPropertySnippetProvider : AbstractPropertySnippetProvider {
    protected virtual AccessorDeclarationSyntax GenerateGetAccessorDeclaration(CSharpSyntaxContext syntaxContext, SyntaxGenerator generator);
    protected virtual AccessorDeclarationSyntax GenerateSetAccessorDeclaration(CSharpSyntaxContext syntaxContext, SyntaxGenerator generator);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Snippets.AbstractCSharpAutoPropertySnippetProvider/<IsValidSnippetLocationAsync>d__2")]
protected virtual Task`1<bool> IsValidSnippetLocationAsync(Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Snippets.AbstractCSharpAutoPropertySnippetProvider/<GenerateSnippetSyntaxAsync>d__3")]
protected virtual Task`1<SyntaxNode> GenerateSnippetSyntaxAsync(Document document, int position, CancellationToken cancellationToken);
    protected virtual int GetTargetCaretPosition(ISyntaxFactsService syntaxFacts, SyntaxNode caretTarget, SourceText sourceText);
    protected virtual ImmutableArray`1<SnippetPlaceholder> GetPlaceHolderLocationsList(SyntaxNode node, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
    protected virtual SyntaxNode FindAddedSnippetSyntaxNode(SyntaxNode root, int position, Func`2<SyntaxNode, bool> isCorrectContainer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.Snippets.AbstractCSharpForLoopSnippetProvider : AbstractForLoopSnippetProvider {
    private static String[] s_iteratorBaseNames;
    protected SyntaxKind ConditionKind { get; }
    protected SyntaxKind IncrementorKind { get; }
    private static AbstractCSharpForLoopSnippetProvider();
    protected abstract virtual SyntaxKind get_ConditionKind();
    protected abstract virtual SyntaxKind get_IncrementorKind();
    protected abstract virtual ExpressionSyntax GenerateInitializerValue(SyntaxGenerator generator, SyntaxNode inlineExpression);
    protected abstract virtual ExpressionSyntax GenerateRightSideOfCondition(SyntaxGenerator generator, SyntaxNode inlineExpression);
    protected abstract virtual void AddSpecificPlaceholders(MultiDictionary`2<string, int> placeholderBuilder, ExpressionSyntax initializer, ExpressionSyntax rightOfCondition);
    protected virtual SyntaxNode GenerateStatement(SyntaxGenerator generator, SyntaxContext syntaxContext, SyntaxNode inlineExpression);
    protected virtual ImmutableArray`1<SnippetPlaceholder> GetPlaceHolderLocationsList(SyntaxNode node, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
    protected virtual int GetTargetCaretPosition(ISyntaxFactsService syntaxFacts, SyntaxNode caretTarget, SourceText sourceText);
    protected virtual Task`1<Document> AddIndentationToDocumentAsync(Document document, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static void GetPartsOfForStatement(SyntaxNode node, SyntaxNode& declaration, SyntaxNode& condition, SyntaxNode& incrementor, SyntaxNode& statement);
}
internal abstract class Microsoft.CodeAnalysis.CSharp.Snippets.AbstractCSharpMainMethodSnippetProvider : AbstractMainMethodSnippetProvider {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Snippets.AbstractCSharpMainMethodSnippetProvider/<IsValidSnippetLocationAsync>d__0")]
protected virtual Task`1<bool> IsValidSnippetLocationAsync(Document document, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.Snippets.AbstractCSharpTypeSnippetProvider : AbstractTypeSnippetProvider {
    protected ISet`1<SyntaxKind> ValidModifiers { get; }
    protected abstract virtual ISet`1<SyntaxKind> get_ValidModifiers();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Snippets.AbstractCSharpTypeSnippetProvider/<IsValidSnippetLocationAsync>d__2")]
protected virtual Task`1<bool> IsValidSnippetLocationAsync(Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Snippets.AbstractCSharpTypeSnippetProvider/<GetAccessibilityModifiersChangeAsync>d__3")]
protected virtual Task`1<Nullable`1<TextChange>> GetAccessibilityModifiersChangeAsync(Document document, int position, CancellationToken cancellationToken);
    protected virtual int GetTargetCaretPosition(ISyntaxFactsService syntaxFacts, SyntaxNode caretTarget, SourceText sourceText);
    protected virtual SyntaxNode FindAddedSnippetSyntaxNode(SyntaxNode root, int position, Func`2<SyntaxNode, bool> isCorrectContainer);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Snippets.AbstractCSharpTypeSnippetProvider/<AddIndentationToDocumentAsync>d__6")]
protected virtual Task`1<Document> AddIndentationToDocumentAsync(Document document, CancellationToken cancellationToken);
    protected virtual void GetTypeDeclarationIdentifier(SyntaxNode node, SyntaxToken& identifier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSnippetProviderAttribute("ISnippetProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Snippets.CSharpClassSnippetProvider : AbstractCSharpTypeSnippetProvider {
    private static ISet`1<SyntaxKind> s_validModifiers;
    public string Identifier { get; }
    public string Description { get; }
    protected ISet`1<SyntaxKind> ValidModifiers { get; }
    private static CSharpClassSnippetProvider();
    public virtual string get_Identifier();
    public virtual string get_Description();
    protected virtual ISet`1<SyntaxKind> get_ValidModifiers();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Snippets.CSharpClassSnippetProvider/<GenerateTypeDeclarationAsync>d__8")]
protected virtual Task`1<SyntaxNode> GenerateTypeDeclarationAsync(Document document, int position, CancellationToken cancellationToken);
    protected virtual Func`2<SyntaxNode, bool> GetSnippetContainerFunction(ISyntaxFacts syntaxFacts);
}
[ExportSnippetProviderAttribute("ISnippetProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Snippets.CSharpConsoleSnippetProvider : AbstractConsoleSnippetProvider {
    [NullableContextAttribute("2")]
protected virtual SyntaxNode GetAsyncSupportingDeclaration(SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSnippetProviderAttribute("ISnippetProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Snippets.CSharpConstructorSnippetProvider : AbstractConstructorSnippetProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Snippets.CSharpConstructorSnippetProvider/<IsValidSnippetLocationAsync>d__1")]
protected virtual Task`1<bool> IsValidSnippetLocationAsync(Document document, int position, CancellationToken cancellationToken);
    protected virtual int GetTargetCaretPosition(ISyntaxFactsService syntaxFacts, SyntaxNode caretTarget, SourceText sourceText);
    protected virtual Task`1<Document> AddIndentationToDocumentAsync(Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSnippetProviderAttribute("ISnippetProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Snippets.CSharpElseSnippetProvider : AbstractElseSnippetProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Snippets.CSharpElseSnippetProvider/<IsValidSnippetLocationAsync>d__1")]
protected virtual Task`1<bool> IsValidSnippetLocationAsync(Document document, int position, CancellationToken cancellationToken);
    protected virtual Task`1<TextChange> GenerateSnippetTextChangeAsync(Document document, int position, CancellationToken cancellationToken);
    protected virtual int GetTargetCaretPosition(ISyntaxFactsService syntaxFacts, SyntaxNode caretTarget, SourceText sourceText);
    protected virtual Task`1<Document> AddIndentationToDocumentAsync(Document document, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<bool> <>n__0(Document document, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSnippetProviderAttribute("ISnippetProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Snippets.CSharpEnumSnippetProvider : AbstractCSharpTypeSnippetProvider {
    private static ISet`1<SyntaxKind> s_validModifiers;
    public string Identifier { get; }
    public string Description { get; }
    protected ISet`1<SyntaxKind> ValidModifiers { get; }
    private static CSharpEnumSnippetProvider();
    public virtual string get_Identifier();
    public virtual string get_Description();
    protected virtual ISet`1<SyntaxKind> get_ValidModifiers();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Snippets.CSharpEnumSnippetProvider/<GenerateTypeDeclarationAsync>d__8")]
protected virtual Task`1<SyntaxNode> GenerateTypeDeclarationAsync(Document document, int position, CancellationToken cancellationToken);
    protected virtual Func`2<SyntaxNode, bool> GetSnippetContainerFunction(ISyntaxFacts syntaxFacts);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSnippetProviderAttribute("ISnippetProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Snippets.CSharpForEachLoopSnippetProvider : AbstractForEachLoopSnippetProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Snippets.CSharpForEachLoopSnippetProvider/<IsValidSnippetLocationAsync>d__1")]
protected virtual Task`1<bool> IsValidSnippetLocationAsync(Document document, int position, CancellationToken cancellationToken);
    protected virtual SyntaxNode GenerateStatement(SyntaxGenerator generator, SyntaxContext syntaxContext, SyntaxNode inlineExpression);
    protected virtual ImmutableArray`1<SnippetPlaceholder> GetPlaceHolderLocationsList(SyntaxNode node, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
    protected virtual int GetTargetCaretPosition(ISyntaxFactsService syntaxFacts, SyntaxNode caretTarget, SourceText sourceText);
    protected virtual Task`1<Document> AddIndentationToDocumentAsync(Document document, CancellationToken cancellationToken);
    private static void GetPartsOfForEachStatement(SyntaxNode node, SyntaxToken& identifier, SyntaxNode& expression, SyntaxNode& statement);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<bool> <>n__0(Document document, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSnippetProviderAttribute("ISnippetProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Snippets.CSharpForLoopSnippetProvider : AbstractCSharpForLoopSnippetProvider {
    public string Identifier { get; }
    public string Description { get; }
    protected SyntaxKind ConditionKind { get; }
    protected SyntaxKind IncrementorKind { get; }
    public virtual string get_Identifier();
    public virtual string get_Description();
    protected virtual SyntaxKind get_ConditionKind();
    protected virtual SyntaxKind get_IncrementorKind();
    protected virtual ExpressionSyntax GenerateInitializerValue(SyntaxGenerator generator, SyntaxNode inlineExpression);
    protected virtual ExpressionSyntax GenerateRightSideOfCondition(SyntaxGenerator generator, SyntaxNode inlineExpression);
    protected virtual void AddSpecificPlaceholders(MultiDictionary`2<string, int> placeholderBuilder, ExpressionSyntax initializer, ExpressionSyntax rightOfCondition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSnippetProviderAttribute("ISnippetProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Snippets.CSharpIfSnippetProvider : AbstractIfSnippetProvider {
    protected virtual SyntaxNode GetCondition(SyntaxNode node);
    protected virtual int GetTargetCaretPosition(ISyntaxFactsService syntaxFacts, SyntaxNode caretTarget, SourceText sourceText);
    protected virtual Task`1<Document> AddIndentationToDocumentAsync(Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSnippetProviderAttribute("ISnippetProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Snippets.CSharpInterfaceSnippetProvider : AbstractCSharpTypeSnippetProvider {
    private static ISet`1<SyntaxKind> s_validModifiers;
    public string Identifier { get; }
    public string Description { get; }
    protected ISet`1<SyntaxKind> ValidModifiers { get; }
    private static CSharpInterfaceSnippetProvider();
    public virtual string get_Identifier();
    public virtual string get_Description();
    protected virtual ISet`1<SyntaxKind> get_ValidModifiers();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Snippets.CSharpInterfaceSnippetProvider/<GenerateTypeDeclarationAsync>d__8")]
protected virtual Task`1<SyntaxNode> GenerateTypeDeclarationAsync(Document document, int position, CancellationToken cancellationToken);
    protected virtual Func`2<SyntaxNode, bool> GetSnippetContainerFunction(ISyntaxFacts syntaxFacts);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSnippetProviderAttribute("ISnippetProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Snippets.CSharpIntMainSnippetProvider : AbstractCSharpMainMethodSnippetProvider {
    public string Identifier { get; }
    public string Description { get; }
    public virtual string get_Identifier();
    public virtual string get_Description();
    protected virtual SyntaxNode GenerateReturnType(SyntaxGenerator generator);
    protected virtual IEnumerable`1<SyntaxNode> GenerateInnerStatements(SyntaxGenerator generator);
    protected virtual int GetTargetCaretPosition(ISyntaxFactsService syntaxFacts, SyntaxNode caretTarget, SourceText sourceText);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Snippets.CSharpIntMainSnippetProvider/<AddIndentationToDocumentAsync>d__8")]
protected virtual Task`1<Document> AddIndentationToDocumentAsync(Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSnippetProviderAttribute("ISnippetProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Snippets.CSharpLockSnippetProvider : AbstractLockSnippetProvider {
    public string Identifier { get; }
    public string Description { get; }
    public virtual string get_Identifier();
    public virtual string get_Description();
    protected virtual ImmutableArray`1<SnippetPlaceholder> GetPlaceHolderLocationsList(SyntaxNode node, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
    protected virtual int GetTargetCaretPosition(ISyntaxFactsService syntaxFacts, SyntaxNode caretTarget, SourceText sourceText);
    protected virtual Task`1<Document> AddIndentationToDocumentAsync(Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSnippetProviderAttribute("ISnippetProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Snippets.CSharpPropgSnippetProvider : AbstractCSharpAutoPropertySnippetProvider {
    public string Identifier { get; }
    public string Description { get; }
    public virtual string get_Identifier();
    public virtual string get_Description();
    protected virtual AccessorDeclarationSyntax GenerateSetAccessorDeclaration(CSharpSyntaxContext syntaxContext, SyntaxGenerator generator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSnippetProviderAttribute("ISnippetProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Snippets.CSharpPropiSnippetProvider : AbstractCSharpAutoPropertySnippetProvider {
    public string Identifier { get; }
    public string Description { get; }
    public virtual string get_Identifier();
    public virtual string get_Description();
    protected virtual AccessorDeclarationSyntax GenerateSetAccessorDeclaration(CSharpSyntaxContext syntaxContext, SyntaxGenerator generator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSnippetProviderAttribute("ISnippetProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Snippets.CSharpPropSnippetProvider : AbstractCSharpAutoPropertySnippetProvider {
    public string Identifier { get; }
    public string Description { get; }
    public virtual string get_Identifier();
    public virtual string get_Description();
    protected virtual AccessorDeclarationSyntax GenerateSetAccessorDeclaration(CSharpSyntaxContext syntaxContext, SyntaxGenerator generator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSnippetProviderAttribute("ISnippetProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Snippets.CSharpReversedForLoopSnippetProvider : AbstractCSharpForLoopSnippetProvider {
    public string Identifier { get; }
    public string Description { get; }
    protected SyntaxKind ConditionKind { get; }
    protected SyntaxKind IncrementorKind { get; }
    public virtual string get_Identifier();
    public virtual string get_Description();
    protected virtual SyntaxKind get_ConditionKind();
    protected virtual SyntaxKind get_IncrementorKind();
    protected virtual ExpressionSyntax GenerateInitializerValue(SyntaxGenerator generator, SyntaxNode inlineExpression);
    protected virtual ExpressionSyntax GenerateRightSideOfCondition(SyntaxGenerator generator, SyntaxNode inlineExpression);
    protected virtual void AddSpecificPlaceholders(MultiDictionary`2<string, int> placeholderBuilder, ExpressionSyntax initializer, ExpressionSyntax rightOfCondition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Snippets.CSharpSnippetHelpers : object {
    public static int GetTargetCaretPositionInBlock(SyntaxNode caretTarget, Func`2<TTargetNode, BlockSyntax> getBlock, SourceText sourceText);
    public static string GetBlockLikeIndentationString(Document document, int startPositionOfOpenCurlyBrace, SyntaxFormattingOptions syntaxFormattingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Snippets.CSharpSnippetHelpers/<AddBlockIndentationToDocumentAsync>d__2`1")]
public static Task`1<Document> AddBlockIndentationToDocumentAsync(Document document, SyntaxAnnotation findSnippetAnnotation, Func`2<TTargetNode, BlockSyntax> getBlock, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Snippets.ISnippetService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Snippets.CSharpSnippetService : AbstractSnippetService {
    [NullableContextAttribute("1")]
[ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public CSharpSnippetService(IEnumerable`1<Lazy`2<ISnippetProvider, LanguageMetadata>> snippetProviders);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSnippetProviderAttribute("ISnippetProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Snippets.CSharpStructSnippetProvider : AbstractCSharpTypeSnippetProvider {
    private static ISet`1<SyntaxKind> s_validModifiers;
    public string Identifier { get; }
    public string Description { get; }
    protected ISet`1<SyntaxKind> ValidModifiers { get; }
    private static CSharpStructSnippetProvider();
    public virtual string get_Identifier();
    public virtual string get_Description();
    protected virtual ISet`1<SyntaxKind> get_ValidModifiers();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.Snippets.CSharpStructSnippetProvider/<GenerateTypeDeclarationAsync>d__8")]
protected virtual Task`1<SyntaxNode> GenerateTypeDeclarationAsync(Document document, int position, CancellationToken cancellationToken);
    protected virtual Func`2<SyntaxNode, bool> GetSnippetContainerFunction(ISyntaxFacts syntaxFacts);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSnippetProviderAttribute("ISnippetProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Snippets.CSharpVoidMainSnippetProvider : AbstractCSharpMainMethodSnippetProvider {
    public string Identifier { get; }
    public string Description { get; }
    public virtual string get_Identifier();
    public virtual string get_Description();
    protected virtual SyntaxNode GenerateReturnType(SyntaxGenerator generator);
    protected virtual IEnumerable`1<SyntaxNode> GenerateInnerStatements(SyntaxGenerator generator);
    protected virtual int GetTargetCaretPosition(ISyntaxFactsService syntaxFacts, SyntaxNode caretTarget, SourceText sourceText);
    protected virtual Task`1<Document> AddIndentationToDocumentAsync(Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSnippetProviderAttribute("ISnippetProvider", "C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Snippets.CSharpWhileLoopSnippetProvider : AbstractWhileLoopSnippetProvider {
    protected virtual SyntaxNode GetCondition(SyntaxNode node);
    protected virtual int GetTargetCaretPosition(ISyntaxFactsService syntaxFacts, SyntaxNode caretTarget, SourceText sourceText);
    protected virtual Task`1<Document> AddIndentationToDocumentAsync(Document document, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.SolutionCrawler.IDocumentDifferenceService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SolutionCrawler.CSharpDocumentDifferenceService : AbstractDocumentDifferenceService {
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SpellCheck.CSharpSpellCheckCodeFixProvider : AbstractSpellCheckCodeFixProvider`1<SimpleNameSyntax> {
    private static string CS0426;
    private static string CS1520;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool ShouldSpellCheck(SimpleNameSyntax name);
    protected virtual bool DescendIntoChildren(SyntaxNode arg);
    protected virtual bool IsGeneric(SyntaxToken token);
    protected virtual bool IsGeneric(SimpleNameSyntax nameNode);
    protected virtual bool IsGeneric(CompletionItem completionItem);
    protected virtual SyntaxToken CreateIdentifier(SyntaxToken nameToken, string newName);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.SpellCheck.ISpellCheckSpanService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SpellCheck.CSharpSpellCheckSpanService : AbstractSpellCheckSpanService {
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.SplitOrMergeIfStatements.IIfLikeStatementGenerator", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SplitOrMergeIfStatements.CSharpIfLikeStatementGenerator : object {
    public sealed virtual bool IsIfOrElseIf(SyntaxNode node);
    public sealed virtual bool IsCondition(SyntaxNode expression, SyntaxNode& ifOrElseIf);
    public sealed virtual bool IsElseIfClause(SyntaxNode node, SyntaxNode& parentIfOrElseIf);
    public sealed virtual bool HasElseIfClause(SyntaxNode ifOrElseIf, SyntaxNode& elseIfClause);
    public sealed virtual SyntaxNode GetCondition(SyntaxNode ifOrElseIf);
    public sealed virtual SyntaxNode GetRootIfStatement(SyntaxNode ifOrElseIf);
    public sealed virtual ImmutableArray`1<SyntaxNode> GetElseIfAndElseClauses(SyntaxNode ifOrElseIf);
    public sealed virtual SyntaxNode WithCondition(SyntaxNode ifOrElseIf, SyntaxNode condition);
    public sealed virtual SyntaxNode WithStatementInBlock(SyntaxNode ifOrElseIf, SyntaxNode statement);
    public sealed virtual SyntaxNode WithStatementsOf(SyntaxNode ifOrElseIf, SyntaxNode otherIfOrElseIf);
    public sealed virtual SyntaxNode WithElseIfAndElseClausesOf(SyntaxNode ifStatement, SyntaxNode otherIfStatement);
    public sealed virtual SyntaxNode ToIfStatement(SyntaxNode ifOrElseIf);
    public sealed virtual SyntaxNode ToElseIfClause(SyntaxNode ifOrElseIf);
    public sealed virtual void InsertElseIfClause(SyntaxEditor editor, SyntaxNode afterIfOrElseIf, SyntaxNode elseIfClause);
    public sealed virtual void RemoveElseIfClause(SyntaxEditor editor, SyntaxNode elseIfClause);
    private static bool ContainsEmbeddedIfStatement(IfStatementSyntax ifStatement);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SplitOrMergeIfStatements.CSharpMergeConsecutiveIfStatementsCodeRefactoringProvider : AbstractMergeConsecutiveIfStatementsCodeRefactoringProvider {
    protected virtual bool IsApplicableSpan(SyntaxNode node, TextSpan span, SyntaxNode& ifOrElseIf);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SplitOrMergeIfStatements.CSharpMergeNestedIfStatementsCodeRefactoringProvider : AbstractMergeNestedIfStatementsCodeRefactoringProvider {
    protected virtual bool IsApplicableSpan(SyntaxNode node, TextSpan span, SyntaxNode& ifOrElseIf);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SplitOrMergeIfStatements.CSharpSplitIntoConsecutiveIfStatementsCodeRefactoringProvider : AbstractSplitIntoConsecutiveIfStatementsCodeRefactoringProvider {
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SplitOrMergeIfStatements.CSharpSplitIntoNestedIfStatementsCodeRefactoringProvider : AbstractSplitIntoNestedIfStatementsCodeRefactoringProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.SplitStringLiteral.StringSplitter : object {
    protected SyntaxAnnotation RightNodeAnnotation;
    protected ParsedDocument Document;
    protected int CursorPosition;
    protected IndentationOptions IndentationOptions;
    protected CancellationToken CancellationToken;
    protected SyntaxToken PlusNewLineToken;
    protected int TabSize { get; }
    protected bool UseTabs { get; }
    protected StringSplitter(ParsedDocument document, int position, IndentationOptions& indentationOptions, CancellationToken cancellationToken);
    protected int get_TabSize();
    protected bool get_UseTabs();
    [NullableContextAttribute("2")]
public static StringSplitter TryCreate(ParsedDocument document, int position, IndentationOptions& indentationOptions, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static InterpolatedStringExpressionSyntax TryGetInterpolatedStringExpression(SyntaxToken token, int position);
    private static bool IsInterpolationOpenBrace(SyntaxToken token, int position);
    protected abstract virtual int StringOpenQuoteLength();
    protected abstract virtual bool CheckToken();
    protected abstract virtual SyntaxNode GetNodeToReplace();
    protected abstract virtual BinaryExpressionSyntax CreateSplitString();
    [NullableContextAttribute("2")]
public bool TrySplit(SyntaxNode& newRoot, Int32& newPosition);
    private ValueTuple`2<SyntaxNode, int> SplitString();
    private string GetIndentString(SyntaxNode newRoot);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.StringIndentation.IStringIndentationService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.StringIndentation.CSharpStringIndentationService : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.StringIndentation.CSharpStringIndentationService/<GetStringIndentationRegionsAsync>d__1")]
public sealed virtual Task`1<ImmutableArray`1<StringIndentationRegion>> GetStringIndentationRegionsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    private static void Recurse(SourceText text, SyntaxNode root, TextSpan textSpan, ArrayBuilder`1<StringIndentationRegion> result, CancellationToken cancellationToken);
    private static void ProcessMultiLineRawStringLiteralToken(SourceText text, SyntaxToken token, ArrayBuilder`1<StringIndentationRegion> result, CancellationToken cancellationToken);
    private static void ProcessInterpolatedStringExpression(SourceText text, InterpolatedStringExpressionSyntax interpolatedString, ArrayBuilder`1<StringIndentationRegion> result, CancellationToken cancellationToken);
    private static bool IsInHole(InterpolatedStringExpressionSyntax interpolatedString, TextSpan sourceSpan);
    private static bool IgnoreInterpolation(SourceText text, int offset, InterpolationSyntax interpolation);
    private static bool TryGetIndentSpan(SourceText text, ExpressionSyntax expression, Int32& offset, TextSpan& indentSpan);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.AccessorDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<AccessorDeclarationSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, AccessorDeclarationSyntax accessorDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.AnonymousMethodExpressionStructureProvider : AbstractSyntaxNodeStructureProvider`1<AnonymousMethodExpressionSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, AnonymousMethodExpressionSyntax anonymousMethod, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Structure.AnonymousObjectCreationExpressionStructureProvider : AbstractSyntaxNodeStructureProvider`1<AnonymousObjectCreationExpressionSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, AnonymousObjectCreationExpressionSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Structure.ArrowExpressionClauseStructureProvider : AbstractSyntaxNodeStructureProvider`1<ArrowExpressionClauseSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, ArrowExpressionClauseSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.BlockSyntaxStructureProvider : AbstractSyntaxNodeStructureProvider`1<BlockSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, BlockSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
    private static bool IsNonBlockStatement(SyntaxNode node);
    private static TextSpan GetHintSpan(BlockSyntax node);
    private static TextSpan GetTextSpan(BlockSyntax node);
    private static int GetEnd(BlockSyntax node);
    [NullableContextAttribute("2")]
private static string GetType(SyntaxNode parent);
}
internal class Microsoft.CodeAnalysis.CSharp.Structure.CompilationUnitStructureProvider : AbstractSyntaxNodeStructureProvider`1<CompilationUnitSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, CompilationUnitSyntax compilationUnit, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.ConstructorDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<ConstructorDeclarationSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, ConstructorDeclarationSyntax constructorDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Structure.ConversionOperatorDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<ConversionOperatorDeclarationSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, ConversionOperatorDeclarationSyntax operatorDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Structure.CSharpBlockStructureProvider : AbstractBlockStructureProvider {
    private static ImmutableDictionary`2<Type, ImmutableArray`1<AbstractSyntaxStructureProvider>> CreateDefaultNodeProviderMap();
    private static ImmutableDictionary`2<int, ImmutableArray`1<AbstractSyntaxStructureProvider>> CreateDefaultTriviaProviderMap();
}
internal class Microsoft.CodeAnalysis.CSharp.Structure.CSharpBlockStructureService : BlockStructureServiceWithProviders {
    public string Language { get; }
    public CSharpBlockStructureService(SolutionServices services);
    protected virtual ImmutableArray`1<BlockStructureProvider> GetBuiltInProviders();
    public virtual string get_Language();
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.Structure.BlockStructureService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Structure.CSharpBlockStructureServiceFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Structure.CSharpStructureHelpers : object {
    public static string Ellipsis;
    public static string MultiLineCommentSuffix;
    public static int MaxXmlDocCommentBannerLength;
    private static Char[] s_newLineCharacters;
    private static CSharpStructureHelpers();
    private static int GetCollapsibleStart(SyntaxToken firstToken);
    [NullableContextAttribute("0")]
private static ValueTuple`2<int, int> GetCollapsibleEnd(SyntaxToken lastToken, bool compressEmptyLines);
    public static SyntaxToken GetLastInlineMethodBlockToken(SyntaxNode node);
    private static string CreateCommentBannerTextWithPrefix(string text, string prefix);
    public static string GetCommentBannerText(SyntaxTrivia comment);
    private static BlockSpan CreateCommentBlockSpan(SyntaxTrivia startComment, SyntaxTrivia endComment);
    [NullableContextAttribute("0")]
public static void CollectCommentBlockSpans(SyntaxTriviaList triviaList, TemporaryArray`1& spans);
    public static void CollectCommentBlockSpans(SyntaxNode node, TemporaryArray`1& spans, BlockStructureOptions& options);
    private static BlockSpan CreateBlockSpan(TextSpan textSpan, string bannerText, bool autoCollapse, string type, bool isCollapsible);
    private static BlockSpan CreateBlockSpan(TextSpan textSpan, TextSpan hintSpan, string bannerText, bool autoCollapse, string type, bool isCollapsible, bool isDefaultCollapsed);
    public static BlockSpan CreateBlockSpan(SyntaxNode node, string bannerText, bool autoCollapse, string type, bool isCollapsible);
    public static Nullable`1<BlockSpan> CreateBlockSpan(SyntaxNode node, SyntaxToken syntaxToken, bool compressEmptyLines, string bannerText, bool autoCollapse, string type, bool isCollapsible);
    public static Nullable`1<BlockSpan> CreateBlockSpan(SyntaxNode node, SyntaxToken startToken, int spanEndPos, int hintEndPos, string bannerText, bool autoCollapse, string type, bool isCollapsible);
    private static TextSpan GetHintSpan(SyntaxNode node, int endPos);
    public static Nullable`1<BlockSpan> CreateBlockSpan(SyntaxNode node, SyntaxToken startToken, SyntaxToken endToken, bool compressEmptyLines, string bannerText, bool autoCollapse, string type, bool isCollapsible);
    public static BlockSpan CreateBlockSpan(SyntaxNode node, bool autoCollapse, string type, bool isCollapsible);
    public static Nullable`1<BlockSpan> CreateBlockSpan(SyntaxNode node, SyntaxToken syntaxToken, bool compressEmptyLines, bool autoCollapse, string type, bool isCollapsible);
    public static Nullable`1<BlockSpan> CreateBlockSpan(SyntaxNode node, SyntaxToken startToken, SyntaxToken endToken, bool compressEmptyLines, bool autoCollapse, string type, bool isCollapsible);
    public static Nullable`1<BlockSpan> CreateBlockSpan(IEnumerable`1<SyntaxNode> syntaxList, bool compressEmptyLines, bool autoCollapse, string type, bool isCollapsible, bool isDefaultCollapsed);
    [CompilerGeneratedAttribute]
internal static bool <GetCollapsibleEnd>g__ProcessTrivia|5_0(SyntaxTrivia trivia, bool compressEmptyLines, Int32& end, Nullable`1& hintEnd);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <CollectCommentBlockSpans>g__completeSingleLineCommentGroup|10_0(TemporaryArray`1& spans, <>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static bool <CollectCommentBlockSpans>g__TryGetLeadingCollapsibleSpan|11_0(SyntaxNode node, BlockSpan& span);
    [CompilerGeneratedAttribute]
internal static SyntaxToken <CollectCommentBlockSpans>g__GetEndToken|11_1(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static SyntaxToken <CollectCommentBlockSpans>g__GetHintTextEndToken|11_2(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.DelegateDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<DelegateDeclarationSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, DelegateDeclarationSyntax delegateDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.DestructorDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<DestructorDeclarationSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, DestructorDeclarationSyntax destructorDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Structure.DisabledTextTriviaStructureProvider : AbstractSyntaxTriviaStructureProvider {
    public virtual void CollectBlockSpans(SyntaxTrivia trivia, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
    public static void CollectBlockSpans(SyntaxTree syntaxTree, SyntaxTrivia trivia, TemporaryArray`1& spans, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private static int GetEndPositionExludingLastNewLine(SyntaxTree syntaxTree, SyntaxTrivia trivia, CancellationToken cancellationToken);
    private static SyntaxTrivia GetCorrespondingEndTrivia(SyntaxTrivia trivia, SyntaxTriviaList triviaList, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.DocumentationCommentStructureProvider : AbstractSyntaxNodeStructureProvider`1<DocumentationCommentTriviaSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, DocumentationCommentTriviaSyntax documentationComment, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.EnumDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<EnumDeclarationSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, EnumDeclarationSyntax enumDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.EnumMemberDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<EnumMemberDeclarationSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, EnumMemberDeclarationSyntax enumMemberDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.EventDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<EventDeclarationSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, EventDeclarationSyntax eventDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.EventFieldDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<EventFieldDeclarationSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, EventFieldDeclarationSyntax eventFieldDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.FieldDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<FieldDeclarationSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, FieldDeclarationSyntax fieldDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.FileScopedNamespaceDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<FileScopedNamespaceDeclarationSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, FileScopedNamespaceDeclarationSyntax fileScopedNamespaceDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.IfDirectiveTriviaStructureProvider : AbstractSyntaxNodeStructureProvider`1<IfDirectiveTriviaSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, IfDirectiveTriviaSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.IndexerDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<IndexerDeclarationSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, IndexerDeclarationSyntax indexerDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Structure.InitializerExpressionStructureProvider : AbstractSyntaxNodeStructureProvider`1<InitializerExpressionSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, InitializerExpressionSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.InterpolatedStringExpressionStructureProvider : AbstractSyntaxNodeStructureProvider`1<InterpolatedStringExpressionSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, InterpolatedStringExpressionSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.MethodDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<MethodDeclarationSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, MethodDeclarationSyntax methodDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Structure.MultilineCommentBlockStructureProvider : AbstractSyntaxTriviaStructureProvider {
    public virtual void CollectBlockSpans(SyntaxTrivia trivia, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.NamespaceDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<NamespaceDeclarationSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, NamespaceDeclarationSyntax namespaceDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.OperatorDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<OperatorDeclarationSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, OperatorDeclarationSyntax operatorDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.ParenthesizedLambdaExpressionStructureProvider : AbstractSyntaxNodeStructureProvider`1<ParenthesizedLambdaExpressionSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, ParenthesizedLambdaExpressionSyntax lambdaExpression, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.PropertyDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<PropertyDeclarationSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, PropertyDeclarationSyntax propertyDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.RegionDirectiveStructureProvider : AbstractSyntaxNodeStructureProvider`1<RegionDirectiveTriviaSyntax> {
    private static string GetBannerText(DirectiveTriviaSyntax simpleDirective);
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, RegionDirectiveTriviaSyntax regionDirective, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.SimpleLambdaExpressionStructureProvider : AbstractSyntaxNodeStructureProvider`1<SimpleLambdaExpressionSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, SimpleLambdaExpressionSyntax lambdaExpression, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.StringLiteralExpressionStructureProvider : AbstractSyntaxNodeStructureProvider`1<LiteralExpressionSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, LiteralExpressionSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <CollectBlockSpans>g__CouldBeMultiLine|0_0(<>c__DisplayClass0_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Structure.SwitchStatementStructureProvider : AbstractSyntaxNodeStructureProvider`1<SwitchStatementSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, SwitchStatementSyntax node, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CSharp.Structure.TypeDeclarationStructureProvider : AbstractSyntaxNodeStructureProvider`1<TypeDeclarationSyntax> {
    protected virtual void CollectBlockSpans(SyntaxToken previousToken, TypeDeclarationSyntax typeDeclaration, TemporaryArray`1& spans, BlockStructureOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.SyncNamespaces.ISyncNamespacesService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.SyncNamespaces.CSharpSyncNamespacesService : AbstractSyncNamespacesService`2<SyntaxKind, BaseNamespaceDeclarationSyntax> {
    [CompilerGeneratedAttribute]
private AbstractMatchFolderAndNamespaceDiagnosticAnalyzer`2<SyntaxKind, BaseNamespaceDeclarationSyntax> <DiagnosticAnalyzer>k__BackingField;
    [CompilerGeneratedAttribute]
private AbstractChangeNamespaceToMatchFolderCodeFixProvider <CodeFixProvider>k__BackingField;
    public AbstractMatchFolderAndNamespaceDiagnosticAnalyzer`2<SyntaxKind, BaseNamespaceDeclarationSyntax> DiagnosticAnalyzer { get; }
    public AbstractChangeNamespaceToMatchFolderCodeFixProvider CodeFixProvider { get; }
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public CSharpSyncNamespacesService(CSharpMatchFolderAndNamespaceDiagnosticAnalyzer diagnosticAnalyzer, CSharpChangeNamespaceToMatchFolderCodeFixProvider codeFixProvider);
    [CompilerGeneratedAttribute]
public virtual AbstractMatchFolderAndNamespaceDiagnosticAnalyzer`2<SyntaxKind, BaseNamespaceDeclarationSyntax> get_DiagnosticAnalyzer();
    [CompilerGeneratedAttribute]
public virtual AbstractChangeNamespaceToMatchFolderCodeFixProvider get_CodeFixProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.Syntax.SyntaxBindingUtilities : object {
    public static bool BindsToResumableStateMachineState(SyntaxNode node);
    public static bool BindsToTryStatement(SyntaxNode node);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.TaskList.ITaskListService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.TaskList.CSharpTaskListService : AbstractTaskListService {
    private static int s_multilineCommentPostfixLength;
    private static string SingleLineCommentPrefix;
    private static CSharpTaskListService();
    protected virtual void AppendTaskListItems(ImmutableArray`1<TaskListItemDescriptor> commentDescriptors, SyntacticDocument document, SyntaxTrivia trivia, ArrayBuilder`1<TaskListItem> items);
    protected virtual string GetNormalizedText(string message);
    protected virtual bool IsIdentifierCharacter(char ch);
    protected virtual int GetCommentStartingIndex(string message);
    protected virtual bool PreprocessorHasComment(SyntaxTrivia trivia);
    protected virtual bool IsSingleLineComment(SyntaxTrivia trivia);
    protected virtual bool IsMultilineComment(SyntaxTrivia trivia);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Features.Testing.ITestMethodFinder", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Testing.CSharpTestMethodFinder : AbstractTestMethodFinder`1<MethodDeclarationSyntax> {
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public CSharpTestMethodFinder(IEnumerable`1<ITestFrameworkMetadata> testFrameworks);
    protected virtual bool DescendIntoChildren(SyntaxNode node);
    protected virtual bool IsTestMethod(MethodDeclarationSyntax method);
    private bool IsTestAttribute(AttributeSyntax attribute);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.TopLevelStatements.ConvertToProgramMainDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void ProcessCompilationUnit(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.TopLevelStatements.ConvertToTopLevelStatementsDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void ProcessCompilationUnit(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.TypeStyle.UseExplicitTypeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.TypeStyle.UseExplicitTypeCodeFixProvider/<FixAllAsync>d__4")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.TypeStyle.UseExplicitTypeCodeFixProvider/<HandleDeclarationAsync>d__5")]
internal static Task HandleDeclarationAsync(Document document, SyntaxEditor editor, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.TypeStyle.UseExplicitTypeCodeFixProvider/<HandleDeclarationExpressionAsync>d__6")]
private static Task HandleDeclarationExpressionAsync(Document document, SyntaxEditor editor, DeclarationExpressionSyntax declarationExpression, CancellationToken cancellationToken);
    private static Task HandleForEachStatementAsync(Document document, SyntaxEditor editor, ForEachStatementSyntax forEach, CancellationToken cancellationToken);
    private static Task HandleVariableDeclarationAsync(Document document, SyntaxEditor editor, VariableDeclarationSyntax varDecl, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.TypeStyle.UseExplicitTypeCodeFixProvider/<UpdateTypeSyntaxAsync>d__9")]
private static Task UpdateTypeSyntaxAsync(Document document, SyntaxEditor editor, TypeSyntax typeSyntax, SyntaxNode declarationSyntax, CancellationToken cancellationToken);
    private static ITypeSymbol AdjustNullabilityOfTypeSymbol(ITypeSymbol typeSymbol, SemanticModel semanticModel, SyntaxNode declarationSyntax, CancellationToken cancellationToken);
    private static ExpressionSyntax GenerateTupleDeclaration(ITypeSymbol typeSymbol, ParenthesizedVariableDesignationSyntax parensDesignation);
    private static SyntaxNode GenerateTypeDeclaration(TypeSyntax typeSyntax, ITypeSymbol newTypeSymbol);
    private static ITypeSymbol GetConvertedType(SemanticModel semanticModel, SyntaxNode typeSyntax, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.TypeStyle.UseImplicitTypeCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    internal static void ReplaceTypeWithVar(SyntaxEditor editor, TypeSyntax type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UnsealClass.CSharpUnsealClassCodeFixProvider : AbstractUnsealClassCodeFixProvider {
    private static string CS0509;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    protected string TitleFormat { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual string get_TitleFormat();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UpdateProjectToAllowUnsafe.CSharpUpdateProjectToAllowUnsafeCodeFixProvider : CodeFixProvider {
    private static string CS0227;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    private static Solution AllowUnsafeOnProject(Project project);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UpgradeProject.CSharpUpgradeProjectCodeFixProvider : AbstractUpgradeProjectCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public string UpgradeThisProjectResource { get; }
    public string UpgradeAllProjectsResource { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual string get_UpgradeThisProjectResource();
    public virtual string get_UpgradeAllProjectsResource();
    public virtual string SuggestedVersion(ImmutableArray`1<Diagnostic> diagnostics);
    private static LanguageVersion RequiredVersion(ImmutableArray`1<Diagnostic> diagnostics);
    public virtual Solution UpgradeProject(Project project, string newVersion);
    public virtual bool IsUpgrade(Project project, string newVersion);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseAutoProperty.CSharpUseAutoPropertyAnalyzer : AbstractUseAutoPropertyAnalyzer`7<SyntaxKind, PropertyDeclarationSyntax, ConstructorDeclarationSyntax, FieldDeclarationSyntax, VariableDeclaratorSyntax, ExpressionSyntax, IdentifierNameSyntax> {
    protected SyntaxKind PropertyDeclarationKind { get; }
    protected ISemanticFacts SemanticFacts { get; }
    protected virtual SyntaxKind get_PropertyDeclarationKind();
    protected virtual ISemanticFacts get_SemanticFacts();
    protected virtual bool SupportsReadOnlyProperties(Compilation compilation);
    protected virtual bool SupportsPropertyInitializer(Compilation compilation);
    protected virtual bool CanExplicitInterfaceImplementationsBeFixed();
    protected virtual ExpressionSyntax GetFieldInitializer(VariableDeclaratorSyntax variable, CancellationToken cancellationToken);
    protected virtual void RegisterIneligibleFieldsAction(HashSet`1<string> fieldNames, ConcurrentSet`1<IFieldSymbol> ineligibleFields, SemanticModel semanticModel, SyntaxNode codeBlock, CancellationToken cancellationToken);
    private static void AddIneligibleFieldsIfAccessedOffNotDefinitelyAssignedValue(SemanticModel semanticModel, MemberAccessExpressionSyntax memberAccess, ConcurrentSet`1<IFieldSymbol> ineligibleFields, CancellationToken cancellationToken);
    private static void AddIneligibleFields(ConcurrentSet`1<IFieldSymbol> ineligibleFields, SymbolInfo symbolInfo);
    private static bool CheckExpressionSyntactically(ExpressionSyntax expression);
    protected virtual ExpressionSyntax GetGetterExpression(IMethodSymbol getMethod, CancellationToken cancellationToken);
    private static ExpressionSyntax GetGetterExpressionFromSymbol(IMethodSymbol getMethod, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static T GetSingleStatementFromAccessor(AccessorDeclarationSyntax accessorDeclaration);
    protected virtual ExpressionSyntax GetSetterExpression(IMethodSymbol setMethod, SemanticModel semanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static ExpressionSyntax GetExpressionFromSetter(AccessorDeclarationSyntax setAccessor);
    protected virtual SyntaxNode GetFieldNode(FieldDeclarationSyntax fieldDeclaration, VariableDeclaratorSyntax variableDeclarator);
    [CompilerGeneratedAttribute]
internal static bool <RegisterIneligibleFieldsAction>g__CouldReferenceField|8_0(ExpressionSyntax expression, <>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
internal static void <RegisterIneligibleFieldsAction>g__AddIneligibleFieldsForExpression|8_1(ExpressionSyntax expression, <>c__DisplayClass8_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static void <AddIneligibleFields>g__AddIneligibleField|10_0(ISymbol symbol, <>c__DisplayClass10_0& );
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseAutoProperty.CSharpUseAutoPropertyCodeFixProvider : AbstractUseAutoPropertyCodeFixProvider`5<TypeDeclarationSyntax, PropertyDeclarationSyntax, VariableDeclaratorSyntax, ConstructorDeclarationSyntax, ExpressionSyntax> {
    protected virtual PropertyDeclarationSyntax GetPropertyDeclaration(SyntaxNode node);
    protected virtual SyntaxNode GetNodeToRemove(VariableDeclaratorSyntax declarator);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseAutoProperty.CSharpUseAutoPropertyCodeFixProvider/<UpdatePropertyAsync>d__3")]
protected virtual Task`1<SyntaxNode> UpdatePropertyAsync(Document propertyDocument, Compilation compilation, IFieldSymbol fieldSymbol, IPropertySymbol propertySymbol, PropertyDeclarationSyntax propertyDeclaration, bool isWrittenOutsideOfConstructor, CancellationToken cancellationToken);
    protected virtual IEnumerable`1<AbstractFormattingRule> GetFormattingRules(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseAutoProperty.CSharpUseAutoPropertyCodeFixProvider/<GetFieldInitializerAsync>d__6")]
private static Task`1<ExpressionSyntax> GetFieldInitializerAsync(IFieldSymbol fieldSymbol, CancellationToken cancellationToken);
    private static bool NeedsSetter(Compilation compilation, PropertyDeclarationSyntax propertyDeclaration, bool isWrittenOutsideOfConstructor);
    private static bool SupportsReadOnlyProperties(Compilation compilation);
    private static AccessorListSyntax UpdateAccessorList(AccessorListSyntax accessorList);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseAutoProperty.CSharpUseAutoPropertyCodeFixProvider/<GetAccessors>d__10")]
private static IEnumerable`1<AccessorDeclarationSyntax> GetAccessors(SyntaxList`1<AccessorDeclarationSyntax> accessors);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCoalesceExpression.CSharpUseCoalesceExpressionForNullableTernaryConditionalCheckDiagnosticAnalyzer : AbstractUseCoalesceExpressionForNullableTernaryConditionalCheckDiagnosticAnalyzer`6<SyntaxKind, ExpressionSyntax, ConditionalExpressionSyntax, BinaryExpressionSyntax, MemberAccessExpressionSyntax, PrefixUnaryExpressionSyntax> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual bool IsTargetTyped(SemanticModel semanticModel, ConditionalExpressionSyntax conditional, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCoalesceExpression.CSharpUseCoalesceExpressionForTernaryConditionalCheckDiagnosticAnalyzer : AbstractUseCoalesceExpressionForTernaryConditionalCheckDiagnosticAnalyzer`4<SyntaxKind, ExpressionSyntax, ConditionalExpressionSyntax, BinaryExpressionSyntax> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual bool IsTargetTyped(SemanticModel semanticModel, ConditionalExpressionSyntax conditional, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.UseCoalesceExpression.UseCoalesceExpressionHelpers : object {
    [NullableContextAttribute("1")]
public static bool IsTargetTyped(SemanticModel semanticModel, ConditionalExpressionSyntax conditional, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.AbstractCSharpUseCollectionExpressionDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableDictionary`2<string, string> ChangesSemantics;
    protected DiagnosticDescriptor Descriptor;
    protected DiagnosticDescriptor UnnecessaryCodeDescriptor;
    protected AbstractCSharpUseCollectionExpressionDiagnosticAnalyzer(string diagnosticId, EnforceOnBuild enforceOnBuild);
    private static AbstractCSharpUseCollectionExpressionDiagnosticAnalyzer();
    private static DiagnosticDescriptor CreateDescriptor(string diagnosticId, EnforceOnBuild enforceOnBuild, bool isUnnecessary);
    protected abstract virtual void InitializeWorker(CodeBlockStartAnalysisContext`1<SyntaxKind> context, INamedTypeSymbol expressionType);
    protected virtual bool IsSupported(Compilation compilation);
    public sealed virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected sealed virtual void InitializeWorker(AnalysisContext context);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__8_0(CompilationStartAnalysisContext context);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CollectionExpressionMatch`1 : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private TMatchNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSpread>k__BackingField;
    [NullableAttribute("1")]
public TMatchNode Node { get; public set; }
    public bool UseSpread { get; public set; }
    [NullableContextAttribute("1")]
public CollectionExpressionMatch`1(TMatchNode Node, bool UseSpread);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public TMatchNode get_Node();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Node(TMatchNode value);
    [CompilerGeneratedAttribute]
public bool get_UseSpread();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseSpread(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CollectionExpressionMatch`1<TMatchNode> left, CollectionExpressionMatch`1<TMatchNode> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CollectionExpressionMatch`1<TMatchNode> left, CollectionExpressionMatch`1<TMatchNode> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CollectionExpressionMatch`1<TMatchNode> other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void Deconstruct(TMatchNode& Node, Boolean& UseSpread);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpCollectionExpressionRewriter : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpCollectionExpressionRewriter/<CreateCollectionExpressionAsync>d__0`2")]
public static Task`1<CollectionExpressionSyntax> CreateCollectionExpressionAsync(Document workspaceDocument, CodeActionOptionsProvider fallbackOptions, TParentExpression expressionToReplace, ImmutableArray`1<CollectionExpressionMatch`1<TMatchNode>> matches, Func`2<TParentExpression, InitializerExpressionSyntax> getInitializer, Func`3<TParentExpression, InitializerExpressionSyntax, TParentExpression> withInitializer, CancellationToken cancellationToken);
    private static SyntaxTrivia DetermineEndOfLine(ParsedDocument document, TParentExpression expressionToReplace, SyntaxFormattingOptions formattingOptions);
    private static SyntaxToken RemoveTrailingWhitespace(SyntaxToken token);
    private static SyntaxNodeOrToken RemoveTrailingWhitespace(SyntaxNodeOrToken nodeOrToken);
    [CompilerGeneratedAttribute]
internal static CollectionElementSyntax <CreateCollectionExpressionAsync>g__CreateCollectionElement|0_5(bool useSpread, ExpressionSyntax expression);
    [CompilerGeneratedAttribute]
internal static ExpressionSyntax <CreateCollectionExpressionAsync>g__TransferParentStatementComments|0_10(StatementSyntax parentStatement, ExpressionSyntax expression, string preferredIndentation);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpCollectionExpressionRewriter/<<CreateCollectionExpressionAsync>g__GetElementComponents|0_14>d`2")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<SyntaxNode> <CreateCollectionExpressionAsync>g__GetElementComponents|0_14(TMatchNode node);
    [CompilerGeneratedAttribute]
internal static StatementSyntax <CreateCollectionExpressionAsync>g__UnwrapEmbeddedStatement|0_15(StatementSyntax statement);
    [CompilerGeneratedAttribute]
internal static ExpressionSyntax <CreateCollectionExpressionAsync>g__ConvertExpression|0_16(ExpressionSyntax expression, Func`2<ExpressionSyntax, ExpressionSyntax> indent);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<ExpressionSyntax> <CreateCollectionExpressionAsync>g__ConvertExpressions|0_17(ExpressionSyntax expression, Func`2<ExpressionSyntax, ExpressionSyntax> indent);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<ExpressionSyntax> <CreateCollectionExpressionAsync>g__ConvertAssignment|0_18(AssignmentExpressionSyntax assignment, Func`2<ExpressionSyntax, ExpressionSyntax> indent);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<ExpressionSyntax> <CreateCollectionExpressionAsync>g__ConvertInvocation|0_19(InvocationExpressionSyntax invocation, Func`2<ExpressionSyntax, ExpressionSyntax> indent);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForArrayCodeFixProvider : AbstractUseCollectionExpressionCodeFixProvider`1<ExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForArrayCodeFixProvider/<FixAsync>d__4")]
protected sealed virtual Task FixAsync(Document document, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, ExpressionSyntax arrayCreationExpression, ImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <FixAsync>g__IsOnSingleLine|4_0(SourceText sourceText, SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<CollectionExpressionMatch`1<StatementSyntax>> <FixAsync>g__GetMatches|4_1(SemanticModel semanticModel, ExpressionSyntax expression, INamedTypeSymbol expressionType, <>c__DisplayClass4_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForArrayDiagnosticAnalyzer : AbstractCSharpUseCollectionExpressionDiagnosticAnalyzer {
    protected virtual void InitializeWorker(CodeBlockStartAnalysisContext`1<SyntaxKind> context, INamedTypeSymbol expressionType);
    [NullableContextAttribute("2")]
private void AnalyzeArrayCreationExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
    public static ImmutableArray`1<CollectionExpressionMatch`1<StatementSyntax>> TryGetMatches(SemanticModel semanticModel, ArrayCreationExpressionSyntax expression, INamedTypeSymbol expressionType, bool allowInterfaceConversion, CancellationToken cancellationToken, Boolean& changesSemantics);
    public static ImmutableArray`1<CollectionExpressionMatch`1<StatementSyntax>> TryGetMatches(SemanticModel semanticModel, ImplicitArrayCreationExpressionSyntax expression, INamedTypeSymbol expressionType, bool allowInterfaceConversion, CancellationToken cancellationToken, Boolean& changesSemantics);
    [NullableContextAttribute("2")]
private void AnalyzeArrayInitializerExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
    private void ReportArrayCreationDiagnostics(SyntaxNodeAnalysisContext context, SyntaxTree syntaxTree, NotificationOption2 notification, ExpressionSyntax expression, bool changesSemantics);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForBuilderCodeFixProvider : AbstractUseCollectionExpressionCodeFixProvider`1<InvocationExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForBuilderCodeFixProvider/<FixAsync>d__4")]
protected virtual Task FixAsync(Document document, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, InvocationExpressionSyntax invocationExpression, ImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static AnalysisResult <FixAsync>g__TrackAnalysisResult|4_0(SyntaxNode root, AnalysisResult analysisResult);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForBuilderCodeFixProvider/<<FixAsync>g__CreateTrackedDocumentAsync|4_1>d")]
[CompilerGeneratedAttribute]
internal static Task`1<Document> <FixAsync>g__CreateTrackedDocumentAsync|4_1(Document document, AnalysisResult analysisResult, SyntaxAnnotation annotation, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForBuilderDiagnosticAnalyzer : AbstractCSharpUseCollectionExpressionDiagnosticAnalyzer {
    private static string CreateBuilderName;
    private static string GetInstanceName;
    protected virtual void InitializeWorker(CodeBlockStartAnalysisContext`1<SyntaxKind> context, INamedTypeSymbol expressionType);
    [NullableContextAttribute("2")]
private void AnalyzeInvocationExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
    public static Nullable`1<AnalysisResult> AnalyzeInvocation(SemanticModel semanticModel, InvocationExpressionSyntax invocationExpression, INamedTypeSymbol expressionType, bool allowInterfaceConversion, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <AnalyzeInvocationExpression>g__FadeOutCode|4_0(SyntaxNodeAnalysisContext context, AnalysisResult analysisResult, ImmutableArray`1<Location> locations, <>c__DisplayClass4_0& );
    [CompilerGeneratedAttribute]
internal static InvocationExpressionSyntax <AnalyzeInvocation>g__TryFindCreationExpression|5_0(SyntaxToken identifier, StatementSyntax statement);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForCreateCodeFixProvider : AbstractUseCollectionExpressionCodeFixProvider`1<InvocationExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForCreateCodeFixProvider/<FixAsync>d__4")]
protected virtual Task FixAsync(Document document, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, InvocationExpressionSyntax invocationExpression, ImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForCreateDiagnosticAnalyzer : AbstractCSharpUseCollectionExpressionDiagnosticAnalyzer {
    public static string UnwrapArgument;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_unwrapArgumentProperties;
    private static CSharpUseCollectionExpressionForCreateDiagnosticAnalyzer();
    protected virtual void InitializeWorker(CodeBlockStartAnalysisContext`1<SyntaxKind> context, INamedTypeSymbol expressionType);
    [NullableContextAttribute("2")]
private void AnalyzeInvocationExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForEmptyCodeFixProvider : AbstractUseCollectionExpressionCodeFixProvider`1<SyntaxNode> {
    private static CollectionExpressionSyntax s_emptyCollection;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static CSharpUseCollectionExpressionForEmptyCodeFixProvider();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual Task FixAsync(Document document, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, SyntaxNode diagnosticNode, ImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForEmptyDiagnosticAnalyzer : AbstractCSharpUseCollectionExpressionDiagnosticAnalyzer {
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(CodeBlockStartAnalysisContext`1<SyntaxKind> context, INamedTypeSymbol expressionType);
    [NullableContextAttribute("2")]
private void AnalyzeMemberAccess(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForFluentCodeFixProvider : AbstractUseCollectionExpressionCodeFixProvider`1<InvocationExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForFluentCodeFixProvider/<FixAsync>d__4")]
protected virtual Task FixAsync(Document document, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, InvocationExpressionSyntax invocationExpression, ImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForFluentCodeFixProvider/<<FixAsync>g__GetArgumentsAsync|4_2>d")]
[CompilerGeneratedAttribute]
internal static Task`1<SeparatedSyntaxList`1<ArgumentSyntax>> <FixAsync>g__GetArgumentsAsync|4_2(Document document, CodeActionOptionsProvider fallbackOptions, ImmutableArray`1<CollectionExpressionMatch`1<ArgumentSyntax>> matches, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <FixAsync>g__AddOriginallyFirstArgument|4_5(ArgumentSyntax firstArgument, <>c__DisplayClass4_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForFluentDiagnosticAnalyzer : AbstractCSharpUseCollectionExpressionDiagnosticAnalyzer {
    private static string ToPrefix;
    private static string AsSpanName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_suffixes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableHashSet`1<string> s_bannedTypes;
    private static CSharpUseCollectionExpressionForFluentDiagnosticAnalyzer();
    protected virtual void InitializeWorker(CodeBlockStartAnalysisContext`1<SyntaxKind> context, INamedTypeSymbol expressionType);
    [NullableContextAttribute("2")]
private void AnalyzeMemberAccess(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
    public static Nullable`1<AnalysisResult> AnalyzeInvocation(SourceText text, UpdateExpressionState`2<ExpressionSyntax, StatementSyntax> state, InvocationExpressionSyntax invocation, INamedTypeSymbol expressionType, bool allowInterfaceConversion, bool addMatches, CancellationToken cancellationToken);
    private static bool AnalyzeInvocation(SourceText text, UpdateExpressionState`2<ExpressionSyntax, StatementSyntax> state, InvocationExpressionSyntax invocation, ArrayBuilder`1<CollectionExpressionMatch`1<ArgumentSyntax>> matchesInReverse, InitializerExpressionSyntax& existingInitializer, CancellationToken cancellationToken);
    private static void AddArgumentsInReverse(ArrayBuilder`1<CollectionExpressionMatch`1<ArgumentSyntax>> matchesInReverse, SeparatedSyntaxList`1<ArgumentSyntax> arguments, bool useSpread);
    private static bool IsMatch(UpdateExpressionState`2<ExpressionSyntax, StatementSyntax> state, MemberAccessExpressionSyntax memberAccess, InvocationExpressionSyntax invocation, bool allowLinq, ArrayBuilder`1<CollectionExpressionMatch`1<ArgumentSyntax>> matchesInReverse, Boolean& isAdditionMatch, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <AnalyzeInvocation>g__AddFinalMatch|8_0(ExpressionSyntax expression, <>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeInvocation>g__IsListLike|8_1(ExpressionSyntax expression, <>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeInvocation>g__IsIterable|8_2(ExpressionSyntax expression, <>c__DisplayClass8_0& );
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeInvocation>g__Implements|8_3(ITypeSymbol type, INamedTypeSymbol interfaceType);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <AnalyzeInvocation>g__IsLegalInitializer|8_4(InitializerExpressionSyntax initializer);
    [CompilerGeneratedAttribute]
internal static bool <IsMatch>g__IsMatchWorker|10_0(Boolean& isAdditionMatch, <>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsMatch>g__IsAnyNameMatch|10_1(string name);
    [CompilerGeneratedAttribute]
internal static bool <IsMatch>g__HasAnySuffix|10_2(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForStackAllocCodeFixProvider : AbstractUseCollectionExpressionCodeFixProvider`1<ExpressionSyntax> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForStackAllocCodeFixProvider/<FixAsync>d__4")]
protected sealed virtual Task FixAsync(Document document, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, ExpressionSyntax stackAllocExpression, ImmutableDictionary`2<string, string> properties, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<CollectionExpressionMatch`1<StatementSyntax>> <FixAsync>g__GetMatches|4_0(<>c__DisplayClass4_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.CSharpUseCollectionExpressionForStackAllocDiagnosticAnalyzer : AbstractCSharpUseCollectionExpressionDiagnosticAnalyzer {
    protected virtual bool IsSupported(Compilation compilation);
    protected virtual void InitializeWorker(CodeBlockStartAnalysisContext`1<SyntaxKind> context, INamedTypeSymbol expressionType);
    [NullableContextAttribute("2")]
private void AnalyzeImplicitStackAllocExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
    [NullableContextAttribute("2")]
private void AnalyzeExplicitStackAllocExpression(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
    public static ImmutableArray`1<CollectionExpressionMatch`1<StatementSyntax>> TryGetMatches(SemanticModel semanticModel, StackAllocArrayCreationExpressionSyntax expression, INamedTypeSymbol expressionType, bool allowInterfaceConversion, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.UseCollectionExpression.UseCollectionExpressionHelpers : object {
    private static CollectionExpressionSyntax s_emptyCollectionExpression;
    private static SymbolEquivalenceComparer s_tupleNamesCanDifferComparer;
    private static UseCollectionExpressionHelpers();
    public static bool CanReplaceWithCollectionExpression(SemanticModel semanticModel, ExpressionSyntax expression, INamedTypeSymbol expressionType, bool allowInterfaceConversion, bool skipVerificationForReplacedNode, CancellationToken cancellationToken, Boolean& changesSemantics);
    public static bool CanReplaceWithCollectionExpression(SemanticModel semanticModel, ExpressionSyntax expression, CollectionExpressionSyntax replacementExpression, INamedTypeSymbol expressionType, bool allowInterfaceConversion, bool skipVerificationForReplacedNode, CancellationToken cancellationToken, Boolean& changesSemantics);
    private static bool IsSafeConversionOfArrayToSpanType(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    private static bool IsInTargetTypedLocation(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    public static CollectionExpressionSyntax ConvertInitializerToCollectionExpression(InitializerExpressionSyntax initializer, bool wasOnSingleLine);
    public static CollectionExpressionSyntax ReplaceWithCollectionExpression(SourceText sourceText, InitializerExpressionSyntax originalInitializer, CollectionExpressionSyntax newCollectionExpression, bool newCollectionIsSingleLine);
    private static bool ShouldReplaceExistingExpressionEntirely(SourceText sourceText, InitializerExpressionSyntax initializer, bool newCollectionIsSingleLine);
    public static ImmutableArray`1<CollectionExpressionMatch`1<StatementSyntax>> TryGetMatches(SemanticModel semanticModel, TArrayCreationExpressionSyntax expression, INamedTypeSymbol expressionType, bool allowInterfaceConversion, Func`2<TArrayCreationExpressionSyntax, TypeSyntax> getType, Func`2<TArrayCreationExpressionSyntax, InitializerExpressionSyntax> getInitializer, CancellationToken cancellationToken, Boolean& changesSemantics);
    public static bool IsCollectionFactoryCreate(SemanticModel semanticModel, InvocationExpressionSyntax invocationExpression, MemberAccessExpressionSyntax& memberAccess, Boolean& unwrapArgument, CancellationToken cancellationToken);
    public static bool IsCollectionEmptyAccess(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    public static SeparatedSyntaxList`1<ArgumentSyntax> GetArguments(InvocationExpressionSyntax invocationExpression, bool unwrapArgument);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <CanReplaceWithCollectionExpression>g__IsConstructibleCollectionType|3_1(ITypeSymbol type, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static IMethodSymbol <CanReplaceWithCollectionExpression>g__GetAccessibleInstanceConstructor|3_2(ImmutableArray`1<IMethodSymbol> constructors, Func`2<IMethodSymbol, bool> predicate, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static bool <CanReplaceWithCollectionExpression>g__IsSafeConversionWhenTypesDoNotMatch|3_3(Boolean& changesSemantics, <>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static bool <CanReplaceWithCollectionExpression>g__IsWellKnownInterface|3_4(ITypeSymbol type);
    [CompilerGeneratedAttribute]
internal static bool <IsInTargetTypedLocation>g__HasType|5_0(ExpressionSyntax expression, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsInTargetTypedLocation>g__IsInTargetTypedEqualsValueClause|5_1(EqualsValueClauseSyntax equalsValue);
    [CompilerGeneratedAttribute]
internal static bool <IsInTargetTypedLocation>g__IsInTargetTypedCastExpression|5_2(CastExpressionSyntax castExpression);
    [CompilerGeneratedAttribute]
internal static bool <IsInTargetTypedLocation>g__IsInTargetTypedConditionalExpression|5_3(ConditionalExpressionSyntax conditionalExpression, ExpressionSyntax expression, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsInTargetTypedLocation>g__IsInTargetTypedLambdaExpression|5_4(LambdaExpressionSyntax lambda, ExpressionSyntax expression, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsInTargetTypedLocation>g__IsInTargetTypedSwitchExpressionArm|5_5(SwitchExpressionArmSyntax switchExpressionArm, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsInTargetTypedLocation>g__IsInTargetTypedCollectionElement|5_6(CollectionElementSyntax collectionElement, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsInTargetTypedLocation>g__IsInTargetTypedInitializerExpression|5_7(InitializerExpressionSyntax initializerExpression, ExpressionSyntax expression, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsInTargetTypedLocation>g__IsInTargetTypedAssignmentExpression|5_8(AssignmentExpressionSyntax assignmentExpression, ExpressionSyntax expression, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsInTargetTypedLocation>g__IsInTargetTypedBinaryExpression|5_9(BinaryExpressionSyntax binaryExpression, ExpressionSyntax expression, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsCollectionFactoryCreate>g__IsCompatibleSignatureAndArguments|10_1(IMethodSymbol originalCreateMethod, Boolean& unwrapArgument, <>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsCollectionEmptyAccess>g__IsEmptyProperty|11_0(MemberAccessExpressionSyntax memberAccess, <>c__DisplayClass11_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsCollectionEmptyAccess>g__IsEmptyMethodCall|11_1(InvocationExpressionSyntax invocation, MemberAccessExpressionSyntax memberAccess, <>c__DisplayClass11_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsCollectionEmptyAccess>g__IsPossiblyDottedGenericName|11_2(ExpressionSyntax expression);
    [CompilerGeneratedAttribute]
internal static bool <IsCollectionEmptyAccess>g__IsPossiblyDottedName|11_3(ExpressionSyntax name);
}
internal static class Microsoft.CodeAnalysis.CSharp.UseCollectionInitializer.CSharpObjectCreationHelpers : object {
    [NullableContextAttribute("1")]
public static bool IsInitializerOfLocalDeclarationStatement(LocalDeclarationStatementSyntax localDeclarationStatement, BaseObjectCreationExpressionSyntax rootExpression, VariableDeclaratorSyntax& variableDeclarator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionInitializer.CSharpUpdateExpressionSyntaxHelper : object {
    public static CSharpUpdateExpressionSyntaxHelper Instance;
    private static CSharpUpdateExpressionSyntaxHelper();
    public sealed virtual void GetPartsOfForeachStatement(StatementSyntax statement, SyntaxToken& awaitKeyword, SyntaxToken& identifier, ExpressionSyntax& expression, IEnumerable`1& statements);
    public sealed virtual void GetPartsOfIfStatement(StatementSyntax statement, ExpressionSyntax& condition, IEnumerable`1& whenTrueStatements, IEnumerable`1& whenFalseStatements);
    private static IEnumerable`1<StatementSyntax> ExtractEmbeddedStatements(StatementSyntax embeddedStatement);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionInitializer.CSharpUseCollectionInitializerAnalyzer : AbstractUseCollectionInitializerAnalyzer`9<ExpressionSyntax, StatementSyntax, BaseObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, InvocationExpressionSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, CSharpUseCollectionInitializerAnalyzer> {
    protected IUpdateExpressionSyntaxHelper`2<ExpressionSyntax, StatementSyntax> SyntaxHelper { get; }
    protected virtual IUpdateExpressionSyntaxHelper`2<ExpressionSyntax, StatementSyntax> get_SyntaxHelper();
    protected virtual bool IsInitializerOfLocalDeclarationStatement(LocalDeclarationStatementSyntax localDeclarationStatement, BaseObjectCreationExpressionSyntax rootExpression, VariableDeclaratorSyntax& variableDeclarator);
    protected virtual bool IsComplexElementInitializer(SyntaxNode expression);
    protected virtual bool HasExistingInvalidInitializerForCollection();
    protected virtual bool ValidateMatchesForCollectionExpression(ArrayBuilder`1<Match`1<StatementSyntax>> matches, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionInitializer.CSharpUseCollectionInitializerCodeFixProvider : AbstractUseCollectionInitializerCodeFixProvider`10<SyntaxKind, ExpressionSyntax, StatementSyntax, BaseObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, InvocationExpressionSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, CSharpUseCollectionInitializerAnalyzer> {
    private static Task`1<CollectionExpressionSyntax> CreateCollectionExpressionAsync(Document document, CodeActionOptionsProvider fallbackOptions, BaseObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<Match`1<StatementSyntax>> matches, CancellationToken cancellationToken);
    private static BaseObjectCreationExpressionSyntax CreateObjectInitializerExpression(BaseObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<Match`1<StatementSyntax>> matches);
    protected virtual CSharpUseCollectionInitializerAnalyzer GetAnalyzer();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionInitializer.CSharpUseCollectionInitializerCodeFixProvider/<GetReplacementNodesAsync>d__4")]
protected virtual Task`1<ValueTuple`2<SyntaxNode, SyntaxNode>> GetReplacementNodesAsync(Document document, CodeActionOptionsProvider fallbackOptions, BaseObjectCreationExpressionSyntax objectCreation, bool useCollectionExpression, ImmutableArray`1<Match`1<StatementSyntax>> matches, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCollectionInitializer.CSharpUseCollectionInitializerCodeFixProvider/<GetNewObjectCreationAsync>d__5")]
private static Task`1<ExpressionSyntax> GetNewObjectCreationAsync(Document document, CodeActionOptionsProvider fallbackOptions, BaseObjectCreationExpressionSyntax objectCreation, bool useCollectionExpression, ImmutableArray`1<Match`1<StatementSyntax>> matches, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static SeparatedSyntaxList`1<ExpressionSyntax> <CreateObjectInitializerExpression>g__CreateCollectionInitializerExpressions|1_0(<>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static SeparatedSyntaxList`1<TNode> <CreateObjectInitializerExpression>g__AddLineBreaks|1_1(SeparatedSyntaxList`1<TNode> nodes);
    [CompilerGeneratedAttribute]
internal static ExpressionSyntax <CreateObjectInitializerExpression>g__ConvertExpression|1_2(ExpressionSyntax expression);
    [CompilerGeneratedAttribute]
internal static AssignmentExpressionSyntax <CreateObjectInitializerExpression>g__ConvertAssignment|1_3(AssignmentExpressionSyntax assignment);
    [CompilerGeneratedAttribute]
internal static ExpressionSyntax <CreateObjectInitializerExpression>g__ConvertInvocation|1_4(InvocationExpressionSyntax invocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCollectionInitializer.CSharpUseCollectionInitializerDiagnosticAnalyzer : AbstractUseCollectionInitializerDiagnosticAnalyzer`10<SyntaxKind, ExpressionSyntax, StatementSyntax, BaseObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, InvocationExpressionSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, CSharpUseCollectionInitializerAnalyzer> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual CSharpUseCollectionInitializerAnalyzer GetAnalyzer();
    protected virtual bool AreCollectionInitializersSupported(Compilation compilation);
    protected virtual bool AreCollectionExpressionsSupported(Compilation compilation);
    protected virtual bool CanUseCollectionExpression(SemanticModel semanticModel, BaseObjectCreationExpressionSyntax objectCreationExpression, INamedTypeSymbol expressionType, bool allowInterfaceConversion, CancellationToken cancellationToken, Boolean& changesSemantics);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCompoundAssignment.CSharpUseCompoundAssignmentCodeFixProvider : AbstractUseCompoundAssignmentCodeFixProvider`3<SyntaxKind, AssignmentExpressionSyntax, ExpressionSyntax> {
    protected virtual SyntaxToken Token(SyntaxKind kind);
    protected virtual AssignmentExpressionSyntax Assignment(SyntaxKind assignmentOpKind, ExpressionSyntax left, SyntaxToken syntaxToken, ExpressionSyntax right);
    protected virtual ExpressionSyntax Increment(ExpressionSyntax left, bool postfix);
    protected virtual ExpressionSyntax Decrement(ExpressionSyntax left, bool postfix);
    private static ExpressionSyntax Postfix(SyntaxKind kind, ExpressionSyntax operand);
    private static ExpressionSyntax Prefix(SyntaxKind kind, ExpressionSyntax operand);
    protected virtual SyntaxTriviaList PrepareRightExpressionLeadingTrivia(SyntaxTriviaList initialTrivia);
    protected virtual bool PreferPostfix(ISyntaxFactsService syntaxFacts, AssignmentExpressionSyntax currentAssignment);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCompoundAssignment.CSharpUseCompoundAssignmentDiagnosticAnalyzer : AbstractUseCompoundAssignmentDiagnosticAnalyzer`3<SyntaxKind, AssignmentExpressionSyntax, BinaryExpressionSyntax> {
    protected virtual SyntaxKind GetAnalysisKind();
    protected virtual bool IsSupported(SyntaxKind assignmentKind, ParseOptions options);
    protected virtual int TryGetIncrementOrDecrement(SyntaxKind opKind, object constantValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseCompoundAssignment.CSharpUseCompoundCoalesceAssignmentCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseCompoundAssignment.CSharpUseCompoundCoalesceAssignmentCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseCompoundAssignment.CSharpUseCompoundCoalesceAssignmentDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeCoalesceExpression(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("2")]
public static bool GetWhenTrueAssignment(IfStatementSyntax ifStatement, StatementSyntax& whenTrue, AssignmentExpressionSyntax& assignment);
    private void AnalyzeIfStatement(SyntaxNodeAnalysisContext context);
    private bool IsReferenceEqualsNullCheck(SemanticModel semanticModel, ExpressionSyntax condition, CancellationToken cancellationToken, ExpressionSyntax& testedExpression);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.CSharp.UseCompoundAssignment.Utilities : object {
    public static ImmutableArray`1<ValueTuple`3<SyntaxKind, SyntaxKind, SyntaxKind>> Kinds;
    private static Utilities();
    private static SyntaxKind FindOperatorToken(SyntaxKind assignmentExpressionKind);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseConditionalExpression.CSharpUseConditionalExpressionForAssignmentCodeFixProvider : AbstractUseConditionalExpressionForAssignmentCodeFixProvider`6<StatementSyntax, IfStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, ExpressionSyntax, ConditionalExpressionSyntax> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual AbstractFormattingRule GetMultiLineFormattingRule();
    protected virtual VariableDeclaratorSyntax WithInitializer(VariableDeclaratorSyntax variable, ExpressionSyntax value);
    protected virtual VariableDeclaratorSyntax GetDeclaratorSyntax(IVariableDeclaratorOperation declarator);
    protected virtual LocalDeclarationStatementSyntax AddSimplificationToType(LocalDeclarationStatementSyntax statement);
    protected virtual StatementSyntax WrapWithBlockIfAppropriate(IfStatementSyntax ifStatement, StatementSyntax statement);
    protected virtual ExpressionSyntax ConvertToExpression(IThrowOperation throwOperation);
    protected virtual ISyntaxFormatting GetSyntaxFormatting();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseConditionalExpression.CSharpUseConditionalExpressionForAssignmentDiagnosticAnalyzer : AbstractUseConditionalExpressionForAssignmentDiagnosticAnalyzer`1<IfStatementSyntax> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseConditionalExpression.CSharpUseConditionalExpressionForReturnCodeFixProvider : AbstractUseConditionalExpressionForReturnCodeFixProvider`4<StatementSyntax, IfStatementSyntax, ExpressionSyntax, ConditionalExpressionSyntax> {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual AbstractFormattingRule GetMultiLineFormattingRule();
    protected virtual StatementSyntax WrapWithBlockIfAppropriate(IfStatementSyntax ifStatement, StatementSyntax statement);
    protected virtual ExpressionSyntax ConvertToExpression(IThrowOperation throwOperation);
    protected virtual ISyntaxFormatting GetSyntaxFormatting();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseConditionalExpression.CSharpUseConditionalExpressionForReturnDiagnosticAnalyzer : AbstractUseConditionalExpressionForReturnDiagnosticAnalyzer`1<IfStatementSyntax> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
}
internal static class Microsoft.CodeAnalysis.CSharp.UseConditionalExpression.CSharpUseConditionalExpressionHelpers : object {
    [NullableContextAttribute("1")]
public static ExpressionSyntax ConvertToExpression(IThrowOperation throwOperation);
}
internal class Microsoft.CodeAnalysis.CSharp.UseConditionalExpression.MultiLineConditionalExpressionFormattingRule : AbstractFormattingRule {
    public static AbstractFormattingRule Instance;
    private static MultiLineConditionalExpressionFormattingRule();
    private static bool IsQuestionOrColonOfNewConditional(SyntaxToken token);
    public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseDeconstruction.CSharpUseDeconstructionCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private SyntaxNode UpdateRoot(Document document, SemanticModel semanticModel, SyntaxNode root, SyntaxNode node, CancellationToken cancellationToken);
    private ForEachVariableStatementSyntax CreateForEachVariableStatement(INamedTypeSymbol tupleType, ForEachStatementSyntax forEachStatement);
    private ExpressionStatementSyntax CreateDeconstructionStatement(INamedTypeSymbol tupleType, LocalDeclarationStatementSyntax declarationStatement, VariableDeclaratorSyntax variableDeclarator);
    private ExpressionSyntax CreateTupleOrDeclarationExpression(INamedTypeSymbol tupleType, TypeSyntax typeNode);
    private static DeclarationExpressionSyntax CreateDeclarationExpression(INamedTypeSymbol tupleType, TypeSyntax typeNode);
    private TupleExpressionSyntax CreateTupleExpression(TupleTypeSyntax typeNode);
    private SyntaxNodeOrToken ConvertTupleTypeElementComponent(SyntaxNodeOrToken nodeOrToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseDeconstruction.CSharpUseDeconstructionDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeNode(SyntaxNodeAnalysisContext context);
    private void AnalyzeVariableDeclaration(SyntaxNodeAnalysisContext context, VariableDeclarationSyntax variableDeclaration, NotificationOption2 notificationOption);
    private void AnalyzeForEachStatement(SyntaxNodeAnalysisContext context, ForEachStatementSyntax forEachStatement, NotificationOption2 notificationOption);
    public static bool TryAnalyzeVariableDeclaration(SemanticModel semanticModel, VariableDeclarationSyntax variableDeclaration, INamedTypeSymbol& tupleType, ImmutableArray`1& memberAccessExpressions, CancellationToken cancellationToken);
    public static bool TryAnalyzeForEachStatement(SemanticModel semanticModel, ForEachStatementSyntax forEachStatement, INamedTypeSymbol& tupleType, ImmutableArray`1& memberAccessExpressions, CancellationToken cancellationToken);
    private static bool TryAnalyze(SemanticModel semanticModel, ILocalSymbol local, TypeSyntax typeNode, SyntaxToken identifier, Conversion conversion, SyntaxNode searchScope, INamedTypeSymbol& tupleType, ImmutableArray`1& memberAccessExpressions, CancellationToken cancellationToken);
    private static bool AnyTupleFieldNamesCollideWithExistingNames(SemanticModel semanticModel, INamedTypeSymbol tupleType, SyntaxNode container, CancellationToken cancellationToken);
    private static bool IsViableTupleTypeSyntax(TypeSyntax type);
    private static bool OnlyUsedToAccessTupleFields(SemanticModel semanticModel, SyntaxNode searchScope, ILocalSymbol local, ArrayBuilder`1<MemberAccessExpressionSyntax> memberAccessLocations, CancellationToken cancellationToken);
    private static IEnumerable`1<ISymbol> GetExistingSymbols(SemanticModel semanticModel, SyntaxNode container, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseDefaultLiteral.CSharpUseDefaultLiteralCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseDefaultLiteral.CSharpUseDefaultLiteralCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseDefaultLiteral.CSharpUseDefaultLiteralDiagnosticAnalyzer : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseExplicitTypeForConst.UseExplicitTypeForConstCodeFixProvider : CodeFixProvider {
    private static string CS0822;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExplicitTypeForConst.UseExplicitTypeForConstCodeFixProvider/<RegisterCodeFixesAsync>d__6")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExplicitTypeForConst.UseExplicitTypeForConstCodeFixProvider/<FixAsync>d__7")]
private static Task`1<Document> FixAsync(Document document, TextSpan span, ITypeSymbol type, CancellationToken cancellationToken);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    private static ImmutableArray`1<UseExpressionBodyHelper> _helpers;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static UseExpressionBodyCodeFixProvider();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public sealed virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyCodeFixProvider/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void AddEdits(SemanticModel semanticModel, SyntaxEditor editor, Diagnostic diagnostic, HashSet`1<AccessorListSyntax> accessorLists, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyCodeRefactoringProvider : SyntaxEditorBasedCodeRefactoringProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<UseExpressionBodyHelper> _helpers;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static BidirectionalMap`2<ValueTuple`2<UseExpressionBodyHelper, bool>, string> s_equivalenceKeyMap;
    [NullableAttribute("0")]
protected ImmutableArray`1<FixAllScope> SupportedFixAllScopes { get; }
    private static UseExpressionBodyCodeRefactoringProvider();
    private static BidirectionalMap`2<ValueTuple`2<UseExpressionBodyHelper, bool>, string> CreateEquivalanceKeyMap(ImmutableArray`1<UseExpressionBodyHelper> helpers);
    [NullableContextAttribute("0")]
protected virtual ImmutableArray`1<FixAllScope> get_SupportedFixAllScopes();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyCodeRefactoringProvider/<ComputeRefactoringsAsync>d__6")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    private static SyntaxNode TryGetDeclaration(UseExpressionBodyHelper helper, SourceText text, SyntaxNode node, int position);
    private static bool TryComputeRefactoring(CodeRefactoringContext context, SyntaxNode root, SyntaxNode declaration, CSharpCodeGenerationOptions options, UseExpressionBodyHelper helper, CancellationToken cancellationToken);
    private static SyntaxNode GetDeclaration(SyntaxNode node, UseExpressionBodyHelper helper);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyCodeRefactoringProvider/<UpdateDocumentAsync>d__10")]
private static Task`1<Document> UpdateDocumentAsync(Document document, SyntaxNode root, SyntaxNode declaration, UseExpressionBodyHelper helper, bool useExpressionBody, CancellationToken cancellationToken);
    private static SyntaxNode GetUpdatedRoot(SemanticModel semanticModel, SyntaxNode root, SyntaxNode declaration, UseExpressionBodyHelper helper, bool useExpressionBody, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyCodeRefactoringProvider/<FixAllAsync>d__12")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<TextSpan> fixAllSpans, SyntaxEditor editor, CodeActionOptionsProvider optionsProvider, string equivalenceKey, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyCodeRefactoringProvider/<<CreateEquivalanceKeyMap>g__GetKeyValuePairs|3_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<KeyValuePair`2<ValueTuple`2<UseExpressionBodyHelper, bool>, string>> <CreateEquivalanceKeyMap>g__GetKeyValuePairs|3_0(ImmutableArray`1<UseExpressionBodyHelper> helpers);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyCodeRefactoringProvider/<<FixAllAsync>g__GetDeclarationsToFix|12_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<SyntaxNode> <FixAllAsync>g__GetDeclarationsToFix|12_0(ImmutableArray`1<TextSpan> fixAllSpans, SyntaxNode root, UseExpressionBodyHelper helper, bool useExpressionBody, CSharpCodeGenerationOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyCodeRefactoringProvider/<<FixAllAsync>g__FixDeclarationsAsync|12_1>d")]
[CompilerGeneratedAttribute]
internal static Task <FixAllAsync>g__FixDeclarationsAsync|12_1(Document document, SyntaxEditor editor, SyntaxNode root, ImmutableArray`1<SyntaxNode> declarationsToFix, UseExpressionBodyHelper helper, bool useExpressionBody, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static string FixesError;
    [NullableAttribute("0")]
private ImmutableArray`1<SyntaxKind> _syntaxKinds;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<UseExpressionBodyHelper> _helpers;
    private static UseExpressionBodyDiagnosticAnalyzer();
    private static ImmutableDictionary`2<DiagnosticDescriptor, IOption2> GetSupportedDescriptorsWithOptions();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    private Diagnostic AnalyzeSyntax(CSharpCodeGenerationOptions options, SyntaxNode declaration, SyntaxNodeAnalysisContext context, UseExpressionBodyHelper helper, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForAccessorsHelper : UseExpressionBodyHelper`1<AccessorDeclarationSyntax> {
    public static UseExpressionBodyForAccessorsHelper Instance;
    private static UseExpressionBodyForAccessorsHelper();
    public virtual CodeStyleOption2`1<ExpressionBodyPreference> GetExpressionBodyPreference(CSharpCodeGenerationOptions options);
    protected virtual BlockSyntax GetBody(AccessorDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(AccessorDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(AccessorDeclarationSyntax declaration);
    protected virtual AccessorDeclarationSyntax WithSemicolonToken(AccessorDeclarationSyntax declaration, SyntaxToken token);
    protected virtual AccessorDeclarationSyntax WithExpressionBody(AccessorDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual AccessorDeclarationSyntax WithBody(AccessorDeclarationSyntax declaration, BlockSyntax body);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, AccessorDeclarationSyntax declaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForConstructorsHelper : UseExpressionBodyHelper`1<ConstructorDeclarationSyntax> {
    public static UseExpressionBodyForConstructorsHelper Instance;
    private static UseExpressionBodyForConstructorsHelper();
    public virtual CodeStyleOption2`1<ExpressionBodyPreference> GetExpressionBodyPreference(CSharpCodeGenerationOptions options);
    protected virtual BlockSyntax GetBody(ConstructorDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(ConstructorDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(ConstructorDeclarationSyntax declaration);
    protected virtual ConstructorDeclarationSyntax WithSemicolonToken(ConstructorDeclarationSyntax declaration, SyntaxToken token);
    protected virtual ConstructorDeclarationSyntax WithExpressionBody(ConstructorDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual ConstructorDeclarationSyntax WithBody(ConstructorDeclarationSyntax declaration, BlockSyntax body);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, ConstructorDeclarationSyntax declaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForConversionOperatorsHelper : UseExpressionBodyHelper`1<ConversionOperatorDeclarationSyntax> {
    public static UseExpressionBodyForConversionOperatorsHelper Instance;
    private static UseExpressionBodyForConversionOperatorsHelper();
    public virtual CodeStyleOption2`1<ExpressionBodyPreference> GetExpressionBodyPreference(CSharpCodeGenerationOptions options);
    protected virtual BlockSyntax GetBody(ConversionOperatorDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(ConversionOperatorDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(ConversionOperatorDeclarationSyntax declaration);
    protected virtual ConversionOperatorDeclarationSyntax WithSemicolonToken(ConversionOperatorDeclarationSyntax declaration, SyntaxToken token);
    protected virtual ConversionOperatorDeclarationSyntax WithExpressionBody(ConversionOperatorDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual ConversionOperatorDeclarationSyntax WithBody(ConversionOperatorDeclarationSyntax declaration, BlockSyntax body);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, ConversionOperatorDeclarationSyntax declaration);
}
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForIndexersHelper : UseExpressionBodyHelper`1<IndexerDeclarationSyntax> {
    public static UseExpressionBodyForIndexersHelper Instance;
    private static UseExpressionBodyForIndexersHelper();
    public virtual CodeStyleOption2`1<ExpressionBodyPreference> GetExpressionBodyPreference(CSharpCodeGenerationOptions options);
    protected virtual BlockSyntax GetBody(IndexerDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(IndexerDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(IndexerDeclarationSyntax declaration);
    protected virtual IndexerDeclarationSyntax WithSemicolonToken(IndexerDeclarationSyntax declaration, SyntaxToken token);
    protected virtual IndexerDeclarationSyntax WithExpressionBody(IndexerDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual IndexerDeclarationSyntax WithAccessorList(IndexerDeclarationSyntax declaration, AccessorListSyntax accessorList);
    protected virtual IndexerDeclarationSyntax WithBody(IndexerDeclarationSyntax declaration, BlockSyntax body);
    protected virtual IndexerDeclarationSyntax WithGenerateBody(SemanticModel semanticModel, IndexerDeclarationSyntax declaration);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, IndexerDeclarationSyntax declaration);
    protected virtual bool TryConvertToExpressionBody(IndexerDeclarationSyntax declaration, ExpressionBodyPreference conversionPreference, CancellationToken cancellationToken, ArrowExpressionClauseSyntax& arrowExpression, SyntaxToken& semicolonToken);
    protected virtual Location GetDiagnosticLocation(IndexerDeclarationSyntax declaration);
}
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForLocalFunctionHelper : UseExpressionBodyHelper`1<LocalFunctionStatementSyntax> {
    public static UseExpressionBodyForLocalFunctionHelper Instance;
    private static UseExpressionBodyForLocalFunctionHelper();
    public virtual CodeStyleOption2`1<ExpressionBodyPreference> GetExpressionBodyPreference(CSharpCodeGenerationOptions options);
    protected virtual BlockSyntax GetBody(LocalFunctionStatementSyntax statement);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(LocalFunctionStatementSyntax statement);
    protected virtual SyntaxToken GetSemicolonToken(LocalFunctionStatementSyntax statement);
    protected virtual LocalFunctionStatementSyntax WithSemicolonToken(LocalFunctionStatementSyntax statement, SyntaxToken token);
    protected virtual LocalFunctionStatementSyntax WithExpressionBody(LocalFunctionStatementSyntax statement, ArrowExpressionClauseSyntax expressionBody);
    protected virtual LocalFunctionStatementSyntax WithBody(LocalFunctionStatementSyntax statement, BlockSyntax body);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, LocalFunctionStatementSyntax statement);
}
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForMethodsHelper : UseExpressionBodyHelper`1<MethodDeclarationSyntax> {
    public static UseExpressionBodyForMethodsHelper Instance;
    private static UseExpressionBodyForMethodsHelper();
    public virtual CodeStyleOption2`1<ExpressionBodyPreference> GetExpressionBodyPreference(CSharpCodeGenerationOptions options);
    protected virtual BlockSyntax GetBody(MethodDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(MethodDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(MethodDeclarationSyntax declaration);
    protected virtual MethodDeclarationSyntax WithSemicolonToken(MethodDeclarationSyntax declaration, SyntaxToken token);
    protected virtual MethodDeclarationSyntax WithExpressionBody(MethodDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual MethodDeclarationSyntax WithBody(MethodDeclarationSyntax declaration, BlockSyntax body);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, MethodDeclarationSyntax declaration);
}
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForOperatorsHelper : UseExpressionBodyHelper`1<OperatorDeclarationSyntax> {
    public static UseExpressionBodyForOperatorsHelper Instance;
    private static UseExpressionBodyForOperatorsHelper();
    public virtual CodeStyleOption2`1<ExpressionBodyPreference> GetExpressionBodyPreference(CSharpCodeGenerationOptions options);
    protected virtual BlockSyntax GetBody(OperatorDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(OperatorDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(OperatorDeclarationSyntax declaration);
    protected virtual OperatorDeclarationSyntax WithSemicolonToken(OperatorDeclarationSyntax declaration, SyntaxToken token);
    protected virtual OperatorDeclarationSyntax WithExpressionBody(OperatorDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual OperatorDeclarationSyntax WithBody(OperatorDeclarationSyntax declaration, BlockSyntax body);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, OperatorDeclarationSyntax declaration);
}
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyForPropertiesHelper : UseExpressionBodyHelper`1<PropertyDeclarationSyntax> {
    public static UseExpressionBodyForPropertiesHelper Instance;
    private static UseExpressionBodyForPropertiesHelper();
    public virtual CodeStyleOption2`1<ExpressionBodyPreference> GetExpressionBodyPreference(CSharpCodeGenerationOptions options);
    protected virtual BlockSyntax GetBody(PropertyDeclarationSyntax declaration);
    protected virtual ArrowExpressionClauseSyntax GetExpressionBody(PropertyDeclarationSyntax declaration);
    protected virtual SyntaxToken GetSemicolonToken(PropertyDeclarationSyntax declaration);
    protected virtual PropertyDeclarationSyntax WithSemicolonToken(PropertyDeclarationSyntax declaration, SyntaxToken token);
    protected virtual PropertyDeclarationSyntax WithExpressionBody(PropertyDeclarationSyntax declaration, ArrowExpressionClauseSyntax expressionBody);
    protected virtual PropertyDeclarationSyntax WithAccessorList(PropertyDeclarationSyntax declaration, AccessorListSyntax accessorListSyntax);
    protected virtual PropertyDeclarationSyntax WithBody(PropertyDeclarationSyntax declaration, BlockSyntax body);
    protected virtual PropertyDeclarationSyntax WithGenerateBody(SemanticModel semanticModel, PropertyDeclarationSyntax declaration);
    protected virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, PropertyDeclarationSyntax declaration);
    protected virtual bool TryConvertToExpressionBody(PropertyDeclarationSyntax declaration, ExpressionBodyPreference conversionPreference, CancellationToken cancellationToken, ArrowExpressionClauseSyntax& arrowExpression, SyntaxToken& semicolonToken);
    protected virtual Location GetDiagnosticLocation(PropertyDeclarationSyntax declaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyHelper : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableArray`1<UseExpressionBodyHelper> Helpers;
    public Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> Option { get; }
    public LocalizableString UseExpressionBodyTitle { get; }
    public LocalizableString UseBlockBodyTitle { get; }
    public string DiagnosticId { get; }
    public EnforceOnBuild EnforceOnBuild { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<SyntaxKind> SyntaxKinds { get; }
    private static UseExpressionBodyHelper();
    public abstract virtual Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> get_Option();
    public abstract virtual LocalizableString get_UseExpressionBodyTitle();
    public abstract virtual LocalizableString get_UseBlockBodyTitle();
    public abstract virtual string get_DiagnosticId();
    public abstract virtual EnforceOnBuild get_EnforceOnBuild();
    [NullableContextAttribute("0")]
public abstract virtual ImmutableArray`1<SyntaxKind> get_SyntaxKinds();
    public abstract virtual CodeStyleOption2`1<ExpressionBodyPreference> GetExpressionBodyPreference(CSharpCodeGenerationOptions options);
    public abstract virtual BlockSyntax GetBody(SyntaxNode declaration);
    public abstract virtual ArrowExpressionClauseSyntax GetExpressionBody(SyntaxNode declaration);
    public abstract virtual bool IsRelevantDeclarationNode(SyntaxNode node);
    public abstract virtual bool CanOfferUseExpressionBody(CodeStyleOption2`1<ExpressionBodyPreference> preference, SyntaxNode declaration, bool forAnalyzer, CancellationToken cancellationToken);
    public abstract virtual bool CanOfferUseBlockBody(CodeStyleOption2`1<ExpressionBodyPreference> preference, SyntaxNode declaration, bool forAnalyzer, Boolean& fixesError, ArrowExpressionClauseSyntax& expressionBody);
    public abstract virtual SyntaxNode Update(SemanticModel semanticModel, SyntaxNode declaration, bool useExpressionBody, CancellationToken cancellationToken);
    public abstract virtual Location GetDiagnosticLocation(SyntaxNode declaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.UseExpressionBody.UseExpressionBodyHelper`1 : UseExpressionBodyHelper {
    [CompilerGeneratedAttribute]
private Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> <Option>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalizableString <UseExpressionBodyTitle>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalizableString <UseBlockBodyTitle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DiagnosticId>k__BackingField;
    [CompilerGeneratedAttribute]
private EnforceOnBuild <EnforceOnBuild>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<SyntaxKind> <SyntaxKinds>k__BackingField;
    public Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> Option { get; }
    public LocalizableString UseExpressionBodyTitle { get; }
    public LocalizableString UseBlockBodyTitle { get; }
    public string DiagnosticId { get; }
    public EnforceOnBuild EnforceOnBuild { get; }
    [NullableAttribute("0")]
public ImmutableArray`1<SyntaxKind> SyntaxKinds { get; }
    protected UseExpressionBodyHelper`1(string diagnosticId, EnforceOnBuild enforceOnBuild, LocalizableString useExpressionBodyTitle, LocalizableString useBlockBodyTitle, Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> option, ImmutableArray`1<SyntaxKind> syntaxKinds);
    [CompilerGeneratedAttribute]
public virtual Option2`1<CodeStyleOption2`1<ExpressionBodyPreference>> get_Option();
    [CompilerGeneratedAttribute]
public virtual LocalizableString get_UseExpressionBodyTitle();
    [CompilerGeneratedAttribute]
public virtual LocalizableString get_UseBlockBodyTitle();
    [CompilerGeneratedAttribute]
public virtual string get_DiagnosticId();
    [CompilerGeneratedAttribute]
public virtual EnforceOnBuild get_EnforceOnBuild();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual ImmutableArray`1<SyntaxKind> get_SyntaxKinds();
    [NullableContextAttribute("2")]
protected static AccessorDeclarationSyntax GetSingleGetAccessor(AccessorListSyntax accessorList);
    protected static BlockSyntax GetBodyFromSingleGetAccessor(AccessorListSyntax accessorList);
    public virtual BlockSyntax GetBody(SyntaxNode declaration);
    public virtual ArrowExpressionClauseSyntax GetExpressionBody(SyntaxNode declaration);
    public virtual bool IsRelevantDeclarationNode(SyntaxNode node);
    public virtual bool CanOfferUseExpressionBody(CodeStyleOption2`1<ExpressionBodyPreference> preference, SyntaxNode declaration, bool forAnalyzer, CancellationToken cancellationToken);
    public virtual bool CanOfferUseBlockBody(CodeStyleOption2`1<ExpressionBodyPreference> preference, SyntaxNode declaration, bool forAnalyzer, Boolean& fixesError, ArrowExpressionClauseSyntax& expressionBody);
    public sealed virtual SyntaxNode Update(SemanticModel semanticModel, SyntaxNode declaration, bool useExpressionBody, CancellationToken cancellationToken);
    public virtual Location GetDiagnosticLocation(SyntaxNode declaration);
    protected virtual Location GetDiagnosticLocation(TDeclaration declaration);
    public bool CanOfferUseExpressionBody(CodeStyleOption2`1<ExpressionBodyPreference> preference, TDeclaration declaration, bool forAnalyzer, CancellationToken cancellationToken);
    protected virtual bool TryConvertToExpressionBody(TDeclaration declaration, ExpressionBodyPreference conversionPreference, CancellationToken cancellationToken, ArrowExpressionClauseSyntax& expressionWhenOnSingleLine, SyntaxToken& semicolonWhenOnSingleLine);
    private bool TryConvertToExpressionBodyWorker(SyntaxNode declaration, ExpressionBodyPreference conversionPreference, CancellationToken cancellationToken, ArrowExpressionClauseSyntax& expressionWhenOnSingleLine, SyntaxToken& semicolonWhenOnSingleLine);
    protected bool TryConvertToExpressionBodyForBaseProperty(BasePropertyDeclarationSyntax declaration, ExpressionBodyPreference conversionPreference, CancellationToken cancellationToken, ArrowExpressionClauseSyntax& arrowExpression, SyntaxToken& semicolonToken);
    public bool CanOfferUseBlockBody(CodeStyleOption2`1<ExpressionBodyPreference> preference, TDeclaration declaration, bool forAnalyzer, Boolean& fixesError, ArrowExpressionClauseSyntax& expressionBody);
    public TDeclaration Update(SemanticModel semanticModel, TDeclaration declaration, bool useExpressionBody, CancellationToken cancellationToken);
    protected abstract virtual BlockSyntax GetBody(TDeclaration declaration);
    protected abstract virtual ArrowExpressionClauseSyntax GetExpressionBody(TDeclaration declaration);
    protected abstract virtual bool CreateReturnStatementForExpression(SemanticModel semanticModel, TDeclaration declaration);
    protected abstract virtual SyntaxToken GetSemicolonToken(TDeclaration declaration);
    protected abstract virtual TDeclaration WithSemicolonToken(TDeclaration declaration, SyntaxToken token);
    protected abstract virtual TDeclaration WithExpressionBody(TDeclaration declaration, ArrowExpressionClauseSyntax expressionBody);
    protected abstract virtual TDeclaration WithBody(TDeclaration declaration, BlockSyntax body);
    protected virtual TDeclaration WithGenerateBody(SemanticModel semanticModel, TDeclaration declaration);
    protected TDeclaration WithAccessorList(SemanticModel semanticModel, TDeclaration declaration);
    protected virtual TDeclaration WithAccessorList(TDeclaration declaration, AccessorListSyntax accessorListSyntax);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeFixProvider/<FixAllAsync>d__6")]
private static Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    private static Task`1<Document> FixWithSyntaxEditorAsync(Document document, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static void AddEdits(SyntaxEditor editor, SemanticModel semanticModel, Diagnostic diagnostic, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeRefactoringProvider : CodeRefactoringProvider {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeRefactoringProvider/<ComputeRefactoringsAsync>d__1")]
public virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeRefactoringProvider/<ComputeRefactoringsAsync>d__2")]
private static Task ComputeRefactoringsAsync(CodeRefactoringContext context, ExpressionBodyPreference option, bool analyzerActive);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeRefactoringProvider/<ComputeOpposingRefactoringsWhenAnalyzerActiveAsync>d__3")]
private static Task`1<ImmutableArray`1<CodeAction>> ComputeOpposingRefactoringsWhenAnalyzerActiveAsync(Document document, TextSpan span, ExpressionBodyPreference option, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeRefactoringProvider/<ComputeAllRefactoringsWhenAnalyzerInactiveAsync>d__4")]
private static Task`1<ImmutableArray`1<CodeAction>> ComputeAllRefactoringsWhenAnalyzerInactiveAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeRefactoringProvider/<ComputeRefactoringsAsync>d__5")]
private static Task`1<ImmutableArray`1<CodeAction>> ComputeRefactoringsAsync(Document document, TextSpan span, ExpressionBodyPreference option, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaCodeRefactoringProvider/<UpdateDocumentAsync>d__6")]
private static Task`1<Document> UpdateDocumentAsync(Document document, SyntaxNode root, LambdaExpressionSyntax declaration, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static DiagnosticDescriptor s_useExpressionBodyForLambda;
    private static DiagnosticDescriptor s_useBlockBodyForLambda;
    private static UseExpressionBodyForLambdaDiagnosticAnalyzer();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeIfEnabled(SyntaxNodeAnalysisContext context);
    private static void AnalyzeSyntax(SyntaxNodeAnalysisContext context, CodeStyleOption2`1<ExpressionBodyPreference> option);
    private static Diagnostic AnalyzeSyntax(SemanticModel semanticModel, CodeStyleOption2`1<ExpressionBodyPreference> option, LambdaExpressionSyntax declaration, CancellationToken cancellationToken);
    private static Location GetDiagnosticLocation(LambdaExpressionSyntax declaration);
    private static DiagnosticDescriptor CreateDescriptorWithId(LocalizableString title, LocalizableString message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.UseExpressionBodyForLambda.UseExpressionBodyForLambdaHelpers : object {
    internal static LocalizableString UseExpressionBodyTitle;
    internal static LocalizableString UseBlockBodyTitle;
    private static UseExpressionBodyForLambdaHelpers();
    internal static bool CanOfferUseBlockBody(SemanticModel semanticModel, ExpressionBodyPreference preference, LambdaExpressionSyntax declaration, CancellationToken cancellationToken);
    internal static bool CanOfferUseExpressionBody(ExpressionBodyPreference preference, LambdaExpressionSyntax declaration, LanguageVersion languageVersion, CancellationToken cancellationToken);
    internal static ExpressionSyntax GetBodyAsExpression(LambdaExpressionSyntax declaration);
    internal static CodeStyleOption2`1<ExpressionBodyPreference> GetCodeStyleOption(AnalyzerOptionsProvider provider);
    internal static ReportDiagnostic GetOptionSeverity(CodeStyleOption2`1<ExpressionBodyPreference> optionValue);
    internal static bool TryConvertToExpressionBody(LambdaExpressionSyntax declaration, LanguageVersion languageVersion, ExpressionBodyPreference conversionPreference, CancellationToken cancellationToken, ExpressionSyntax& expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseImplicitObjectCreation.CSharpUseImplicitObjectCreationCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseImplicitObjectCreation.CSharpUseImplicitObjectCreationCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static SyntaxNode FixOne(SyntaxNode root, ObjectCreationExpressionSyntax objectCreation);
    private static SyntaxToken WithoutTrailingWhitespace(SyntaxToken newKeyword);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseImplicitObjectCreation.CSharpUseImplicitObjectCreationDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    public static bool Analyze(SemanticModel semanticModel, CSharpSimplifierOptions simplifierOptions, ObjectCreationExpressionSyntax objectCreation, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CodeFixHelpers : object {
    public static PrefixUnaryExpressionSyntax IndexExpression(ExpressionSyntax expr);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseIndexOperatorCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseIndexOperatorDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeInvocation(OperationAnalysisContext context, InfoCache infoCache);
    private void AnalyzePropertyReference(OperationAnalysisContext context, InfoCache infoCache);
    private void AnalyzeArrayElementReference(OperationAnalysisContext context, InfoCache infoCache, IPropertySymbol arrayLengthProperty);
    [NullableContextAttribute("2")]
private void AnalyzeInvokedMember(OperationAnalysisContext context, InfoCache infoCache, IOperation instance, IMethodSymbol targetMethod, IOperation argumentValue, IPropertySymbol lengthLikeProperty, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static IPropertySymbol TryGetLengthLikeProperty(InfoCache infoCache, IMethodSymbol targetMethod);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorCodeFixProvider/<FixAllAsync>d__5")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static SyntaxNode UpdateInvocation(SemanticModel semanticModel, SyntaxNode currentRoot, InvocationExpressionSyntax currentInvocation, SyntaxGenerator generator, CancellationToken cancellationToken);
    private static InvocationExpressionSyntax GetInvocationExpression(Diagnostic d, CancellationToken cancellationToken);
    private static ExpressionSyntax FixOne(Result result, SyntaxGenerator generator);
    private static RangeExpressionSyntax CreateRangeExpression(Result result, SyntaxGenerator generator);
    private static RangeExpressionSyntax CreateComputedRange(Result result);
    [NullableContextAttribute("2")]
private static ExpressionSyntax WalkUpCheckedExpressions(ExpressionSyntax expr);
    private static RangeExpressionSyntax CreateConstantRange(Result result, SyntaxGenerator generator);
    private static int GetInt32Value(IOperation operation);
    private static bool IsFromEnd(IPropertySymbol lengthLikeProperty, IOperation instance, IOperation& rangeOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.CSharpUseRangeOperatorDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static string ComputedRange;
    public static string ConstantRange;
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeInvocation(OperationAnalysisContext context, InfoCache infoCache);
    public static Nullable`1<Result> AnalyzeInvocation(IInvocationOperation invocation, InfoCache infoCache);
    private static Nullable`1<Result> AnalyzeOneArgumentInvocation(IInvocationOperation invocation, InfoCache infoCache, InvocationExpressionSyntax invocationSyntax);
    private static Nullable`1<Result> AnalyzeTwoArgumentInvocation(IInvocationOperation invocation, InfoCache infoCache, InvocationExpressionSyntax invocationSyntax);
    private static Nullable`1<Result> AnalyzeTwoArgumentSubtractionInvocation(IInvocationOperation invocation, InfoCache infoCache, InvocationExpressionSyntax invocationSyntax, IMethodSymbol targetMethod);
    private static Nullable`1<Result> AnalyzeTwoArgumentFromStartOrToEndInvocation(IInvocationOperation invocation, InfoCache infoCache, InvocationExpressionSyntax invocationSyntax, IMethodSymbol targetMethod);
    private static bool IsValidIndexing(IInvocationOperation invocation, InfoCache infoCache, IMethodSymbol targetMethod);
    private Diagnostic CreateDiagnostic(Result result, NotificationOption2 notificationOption);
    private static bool IsConstantInt32(IOperation operation, Nullable`1<int> value);
    private static bool IsWriteableIndexer(IInvocationOperation invocation, IPropertySymbol indexer);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__4_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.Helpers : object {
    public static IPropertySymbol TryGetLengthOrCountProperty(ITypeSymbol namedType);
    public static IPropertySymbol TryGetNoArgInt32Property(ITypeSymbol type, string name);
    public static bool IsPublicInstance(ISymbol symbol);
    public static bool IsInstanceLengthCheck(IPropertySymbol lengthLikeProperty, IOperation instance, IOperation operation);
    public static bool IsSubtraction(IOperation operation, IBinaryOperation& subtraction);
    public static bool IsIntIndexingMethod(IMethodSymbol method);
    public static bool IsTwoArgumentSliceLikeMethod(IMethodSymbol method);
    public static bool IsOneArgumentSliceLikeMethod(IMethodSymbol method);
    private static bool IsSliceFirstParameter(IParameterSymbol parameter);
    private static bool IsSliceSecondParameter(IParameterSymbol parameter);
    public static IPropertySymbol GetIndexer(ITypeSymbol type, ITypeSymbol parameterType, ITypeSymbol returnType);
    public static IMethodSymbol GetOverload(IMethodSymbol method, ITypeSymbol parameterType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseIndexOrRangeOperator.MemberInfo : ValueType {
    public IPropertySymbol LengthLikeProperty;
    [NullableAttribute("2")]
public IMethodSymbol OverloadedMethodOpt;
    public MemberInfo(IPropertySymbol lengthLikeProperty, IMethodSymbol overloadedMethodOpt);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseInferredMemberName.CSharpUseInferredMemberNameCodeFixProvider : AbstractUseInferredMemberNameCodeFixProvider {
    protected virtual void LanguageSpecificRemoveSuggestedNode(SyntaxEditor editor, SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseInferredMemberName.CSharpUseInferredMemberNameDiagnosticAnalyzer : AbstractUseInferredMemberNameDiagnosticAnalyzer {
    protected virtual void InitializeWorker(AnalysisContext context);
    protected virtual void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    private void ReportDiagnosticsIfNeeded(NameColonSyntax nameColon, SyntaxNodeAnalysisContext context);
    private void ReportDiagnosticsIfNeeded(NameEqualsSyntax nameEquals, SyntaxNodeAnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseInterpolatedVerbatimString.CSharpUseInterpolatedVerbatimStringCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string InterpolatedVerbatimText;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void AddEdits(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseIsNullCheck.CSharpUseIsNullCheckForCastAndEqualityOperatorCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    private static bool IsSupportedDiagnostic(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static ExpressionSyntax Rewrite(BinaryExpressionSyntax binary);
    private static IsPatternExpressionSyntax RewriteWorker(BinaryExpressionSyntax binary);
    private static IsPatternExpressionSyntax Rewrite(BinaryExpressionSyntax binary, ExpressionSyntax expr, ExpressionSyntax nullLiteral);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseIsNullCheck.CSharpUseIsNullCheckForCastAndEqualityOperatorDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_properties;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_NegatedProperties;
    private static CSharpUseIsNullCheckForCastAndEqualityOperatorDiagnosticAnalyzer();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    private static bool IsObjectCastAndNullCheck(SemanticModel semanticModel, ExpressionSyntax left, ExpressionSyntax right);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__4_0(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__4_1(SyntaxNodeAnalysisContext n);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseIsNullCheck.CSharpUseIsNullCheckForReferenceEqualsCodeFixProvider : AbstractUseIsNullCheckForReferenceEqualsCodeFixProvider`1<ExpressionSyntax> {
    private static LiteralExpressionSyntax s_nullLiteralExpression;
    private static ConstantPatternSyntax s_nullLiteralPattern;
    private static CSharpUseIsNullCheckForReferenceEqualsCodeFixProvider();
    protected virtual string GetTitle(bool negated, ParseOptions options);
    private static SyntaxNode CreateEqualsNullCheck(ExpressionSyntax argument);
    private static SyntaxNode CreateIsNullCheck(ExpressionSyntax argument);
    private static SyntaxNode CreateIsNotNullCheck(ExpressionSyntax argument);
    protected virtual SyntaxNode CreateNullCheck(ExpressionSyntax argument, bool isUnconstrainedGeneric);
    protected virtual SyntaxNode CreateNotNullCheck(ExpressionSyntax argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseIsNullCheck.CSharpUseIsNullCheckForReferenceEqualsDiagnosticAnalyzer : AbstractUseIsNullCheckForReferenceEqualsDiagnosticAnalyzer`1<SyntaxKind> {
    protected virtual bool IsLanguageVersionSupported(Compilation compilation);
    protected virtual bool IsUnconstrainedGenericSupported(Compilation compilation);
    protected virtual ISyntaxFacts GetSyntaxFacts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseIsNullCheck.CSharpUseNullCheckOverTypeCheckCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static ConstantPatternSyntax s_nullConstantPattern;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static CSharpUseNullCheckOverTypeCheckCodeFixProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseIsNullCheck.CSharpUseNullCheckOverTypeCheckDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private bool ShouldAnalyze(OperationAnalysisContext context, NotificationOption2& notificationOption);
    private void AnalyzeNegatedPatternOperation(OperationAnalysisContext context);
    [NullableContextAttribute("2")]
private void AnalyzeIsTypeOperation(OperationAnalysisContext context, INamedTypeSymbol expressionType);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_2(OperationAnalysisContext c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.UseIsNullCheck.UseIsNullCheckHelpers : object {
    public static string GetTitle(bool negated, ParseOptions options);
    public static bool SupportsIsNotPattern(ParseOptions options);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseLocalFunction.CSharpUseLocalFunctionCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static TypeSyntax s_objectType;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static CSharpUseLocalFunctionCodeFixProvider();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseLocalFunction.CSharpUseLocalFunctionCodeFixProvider/<FixAllAsync>d__6")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static bool MakeStatic(SemanticModel semanticModel, bool makeStaticIfPossible, LocalDeclarationStatementSyntax localDeclaration, CancellationToken cancellationToken);
    private static SyntaxNode ReplaceAnonymousWithLocalFunction(SolutionServices services, SyntaxNode currentRoot, LocalDeclarationStatementSyntax localDeclaration, AnonymousFunctionExpressionSyntax anonymousFunction, IMethodSymbol delegateMethod, ParameterListSyntax parameterList, bool makeStatic);
    private static SyntaxNode ReplaceReferences(Document document, SyntaxNode currentRoot, INamedTypeSymbol delegateType, ParameterListSyntax parameterList, ImmutableArray`1<ExpressionSyntax> references);
    private static LocalFunctionStatementSyntax CreateLocalFunctionStatement(LocalDeclarationStatementSyntax localDeclaration, AnonymousFunctionExpressionSyntax anonymousFunction, IMethodSymbol delegateMethod, ParameterListSyntax parameterList, bool makeStatic);
    private static ParameterListSyntax GenerateParameterList(SyntaxGenerator generator, AnonymousFunctionExpressionSyntax anonymousFunction, IMethodSymbol delegateMethod);
    private static ParameterListSyntax TryGetOrCreateParameterList(AnonymousFunctionExpressionSyntax anonymousFunction);
    private static InvocationExpressionSyntax WithNewParameterNames(InvocationExpressionSyntax invocation, IMethodSymbol method, ParameterListSyntax newParameterList);
    private static int TryDetermineParameterIndex(NameColonSyntax argumentNameColon, IMethodSymbol method);
    private static EqualsValueClauseSyntax GetDefaultValue(SyntaxGenerator generator, IParameterSymbol parameter);
    [CompilerGeneratedAttribute]
internal static ParameterSyntax <GenerateParameterList>g__PromoteParameter|11_2(SyntaxGenerator generator, ParameterSyntax parameterNode, IParameterSymbol delegateParameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseLocalFunction.CSharpUseLocalFunctionDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    protected virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("2")]
private void SyntaxNodeAction(SyntaxNodeAnalysisContext syntaxContext, INamedTypeSymbol expressionType);
    private static bool CheckForPattern(AnonymousFunctionExpressionSyntax anonymousFunction, LocalDeclarationStatementSyntax& localDeclaration);
    private static bool CheckForSimpleLocalDeclarationPattern(AnonymousFunctionExpressionSyntax anonymousFunction, LocalDeclarationStatementSyntax& localDeclaration);
    private static bool CanReplaceAnonymousWithLocalFunction(SemanticModel semanticModel, INamedTypeSymbol expressionTypeOpt, ISymbol local, BlockSyntax block, AnonymousFunctionExpressionSyntax anonymousFunction, ImmutableArray`1& referenceLocations, CancellationToken cancellationToken);
    private static bool CheckForCastedLocalDeclarationPattern(AnonymousFunctionExpressionSyntax anonymousFunction, LocalDeclarationStatementSyntax& localDeclaration);
    private static bool CheckForLocalDeclarationAndAssignment(AnonymousFunctionExpressionSyntax anonymousFunction, LocalDeclarationStatementSyntax& localDeclaration);
    private static bool CanReplaceDelegateWithLocalFunction(INamedTypeSymbol delegateType, LocalDeclarationStatementSyntax localDeclaration, SemanticModel semanticModel, CancellationToken cancellationToken);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [CompilerGeneratedAttribute]
internal static bool <SyntaxNodeAction>g__IsInAnalysisSpan|2_1(SyntaxNodeAnalysisContext context, LocalDeclarationStatementSyntax localDeclaration, StatementSyntax anonymousFunctionStatement, bool shouldReportOnAnonymousFunctionStatement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionOrderAttribute]
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseNamedArguments.CSharpUseNamedArgumentsCodeRefactoringProvider : AbstractUseNamedArgumentsCodeRefactoringProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseNameofInAttribute.CSharpUseNameofInAttributeDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static string NameKey;
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeAttribute(SyntaxNodeAnalysisContext context);
    private static bool MatchesParameterOnContainer(AttributeSyntax attribute, string stringValue);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__3_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseNullPropagation.CSharpUseNullPropagationCodeFixProvider : AbstractUseNullPropagationCodeFixProvider`13<SyntaxKind, ExpressionSyntax, StatementSyntax, ConditionalExpressionSyntax, BinaryExpressionSyntax, InvocationExpressionSyntax, ConditionalAccessExpressionSyntax, ElementAccessExpressionSyntax, MemberAccessExpressionSyntax, ElementBindingExpressionSyntax, IfStatementSyntax, ExpressionStatementSyntax, BracketedArgumentListSyntax> {
    [NullableContextAttribute("2")]
protected virtual bool TryGetBlock(SyntaxNode statement, StatementSyntax& block);
    protected virtual StatementSyntax ReplaceBlockStatements(StatementSyntax block, StatementSyntax newInnerStatement);
    protected virtual SyntaxNode PostProcessElseIf(IfStatementSyntax ifStatement, StatementSyntax newWhenTrueStatement);
    protected virtual ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseNullPropagation.CSharpUseNullPropagationDiagnosticAnalyzer : AbstractUseNullPropagationDiagnosticAnalyzer`11<SyntaxKind, ExpressionSyntax, StatementSyntax, ConditionalExpressionSyntax, BinaryExpressionSyntax, InvocationExpressionSyntax, ConditionalAccessExpressionSyntax, ElementAccessExpressionSyntax, MemberAccessExpressionSyntax, IfStatementSyntax, ExpressionStatementSyntax> {
    protected SyntaxKind IfStatementSyntaxKind { get; }
    protected ISemanticFacts SemanticFacts { get; }
    protected virtual SyntaxKind get_IfStatementSyntaxKind();
    protected virtual bool ShouldAnalyze(Compilation compilation);
    protected virtual ISemanticFacts get_SemanticFacts();
    protected virtual bool TryAnalyzePatternCondition(ISyntaxFacts syntaxFacts, ExpressionSyntax conditionNode, ExpressionSyntax& conditionPartToCheck, Boolean& isEquals);
    [NullableContextAttribute("2")]
protected virtual bool TryGetPartsOfIfStatement(IfStatementSyntax ifStatement, ExpressionSyntax& condition, StatementSyntax& trueStatement);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseObjectInitializer.CSharpUseNamedMemberInitializerAnalyzer : AbstractUseNamedMemberInitializerAnalyzer`8<ExpressionSyntax, StatementSyntax, BaseObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, CSharpUseNamedMemberInitializerAnalyzer> {
    protected virtual bool IsInitializerOfLocalDeclarationStatement(LocalDeclarationStatementSyntax localDeclarationStatement, BaseObjectCreationExpressionSyntax rootExpression, VariableDeclaratorSyntax& variableDeclarator);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseObjectInitializer.CSharpUseObjectInitializerCodeFixProvider : AbstractUseObjectInitializerCodeFixProvider`9<SyntaxKind, ExpressionSyntax, StatementSyntax, BaseObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, CSharpUseNamedMemberInitializerAnalyzer> {
    protected virtual CSharpUseNamedMemberInitializerAnalyzer GetAnalyzer();
    protected virtual StatementSyntax GetNewStatement(StatementSyntax statement, BaseObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<Match`4<ExpressionSyntax, StatementSyntax, MemberAccessExpressionSyntax, ExpressionStatementSyntax>> matches);
    private static BaseObjectCreationExpressionSyntax GetNewObjectCreation(BaseObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<Match`4<ExpressionSyntax, StatementSyntax, MemberAccessExpressionSyntax, ExpressionStatementSyntax>> matches);
    private static SeparatedSyntaxList`1<ExpressionSyntax> CreateExpressions(BaseObjectCreationExpressionSyntax objectCreation, ImmutableArray`1<Match`4<ExpressionSyntax, StatementSyntax, MemberAccessExpressionSyntax, ExpressionStatementSyntax>> matches);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseObjectInitializer.CSharpUseObjectInitializerDiagnosticAnalyzer : AbstractUseObjectInitializerDiagnosticAnalyzer`9<SyntaxKind, ExpressionSyntax, StatementSyntax, BaseObjectCreationExpressionSyntax, MemberAccessExpressionSyntax, ExpressionStatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax, CSharpUseNamedMemberInitializerAnalyzer> {
    protected bool FadeOutOperatorToken { get; }
    protected virtual bool get_FadeOutOperatorToken();
    protected virtual CSharpUseNamedMemberInitializerAnalyzer GetAnalyzer();
    protected virtual bool AreObjectInitializersSupported(Compilation compilation);
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual bool IsValidContainingStatement(StatementSyntax node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.UseObjectInitializer.UseInitializerHelpers : object {
    public static BaseObjectCreationExpressionSyntax GetNewObjectCreation(BaseObjectCreationExpressionSyntax baseObjectCreation, SeparatedSyntaxList`1<ExpressionSyntax> expressions);
    public static void AddExistingItems(BaseObjectCreationExpressionSyntax objectCreation, ArrayBuilder`1<SyntaxNodeOrToken> nodesAndTokens, bool addTrailingComma, Func`3<Nullable`1<TMatch>, ExpressionSyntax, TElementSyntax> createElement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.AnalyzedPattern : object {
    public IOperation Target;
    private AnalyzedPattern(IOperation target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.CSharpUsePatternCombinatorsAnalyzer : object {
    public static AnalyzedPattern Analyze(IOperation operation);
    private static AnalyzedPattern ParsePattern(IOperation operation);
    private static AnalyzedPattern ParseBinaryPattern(IBinaryOperation op, bool isDisjunctive, SyntaxToken token);
    private static ConstantResult DetermineConstant(IBinaryOperation op);
    private static AnalyzedPattern ParseRelationalPattern(IBinaryOperation op);
    private static AnalyzedPattern ParseConstantPattern(IBinaryOperation op);
    private static bool IsRelationalOperator(BinaryOperatorKind operatorKind);
    public static BinaryOperatorKind Flip(BinaryOperatorKind operatorKind);
    private static bool IsConstant(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.CSharpUsePatternCombinatorsCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static string SafeEquivalenceKey;
    private static string UnsafeEquivalenceKey;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static SyntaxKind MapToSyntaxKind(BinaryOperatorKind kind);
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic, Document document, string equivalenceKey, CancellationToken cancellationToken);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.CSharpUsePatternCombinatorsCodeFixProvider/<FixAllAsync>d__8")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static PatternSyntax AsPatternSyntax(AnalyzedPattern pattern);
    private static ExpressionSyntax AsExpressionSyntax(ExpressionSyntax expr, AnalyzedPattern p);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternCombinators.CSharpUsePatternCombinatorsDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static string SafeKey;
    private static LocalizableResourceString s_safePatternTitle;
    private static LocalizableResourceString s_unsafePatternTitle;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, string> s_safeProperties;
    private static DiagnosticDescriptor s_unsafeDescriptor;
    private static CSharpUsePatternCombinatorsDiagnosticAnalyzer();
    public static bool IsSafe(Diagnostic diagnostic);
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeNode(SyntaxNodeAnalysisContext context);
    private static bool HasIllegalPatternVariables(AnalyzedPattern pattern, bool permitDesignations, bool isTopLevel);
    private static bool IsTopmostExpression(ExpressionSyntax node);
    private static bool IsTrivial(AnalyzedPattern pattern);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpAsAndMemberAccessCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void FixOne(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static BaseExpressionColonSyntax <FixOne>g__CreateExpressionColon|5_0(ConditionalAccessExpressionSyntax conditionalAccessExpression);
    [CompilerGeneratedAttribute]
internal static ExpressionSyntax <FixOne>g__RewriteMemberBindingToExpression|5_1(ExpressionSyntax expression);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static PatternSyntax <FixOne>g__CreatePattern|5_2(BinaryExpressionSyntax binaryExpression, IsPatternExpressionSyntax isPatternExpression);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpAsAndMemberAccessDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeAsExpression(SyntaxNodeAnalysisContext context);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_1(SyntaxNodeAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <AnalyzeAsExpression>g__IsSafeToConvert|3_0(<>c__DisplayClass3_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpAsAndNullCheckCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpAsAndNullCheckCodeFixProvider/<FixAllAsync>d__4")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void AddEdits(SyntaxEditor editor, SemanticModel semanticModel, Diagnostic diagnostic, LanguageVersion languageVersion, Action`1<StatementSyntax> removeStatement, CancellationToken cancellationToken);
    private static ExpressionSyntax GetCondition(LanguageVersion languageVersion, ExpressionSyntax comparison, BinaryExpressionSyntax asExpression, DeclarationPatternSyntax declarationPattern);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpAsAndNullCheckDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void SyntaxNodeAction(SyntaxNodeAnalysisContext syntaxContext);
    [NullableContextAttribute("2")]
private static bool TryGetTypeCheckParts(SemanticModel semanticModel, SyntaxNode operand, VariableDeclaratorSyntax& declarator, BinaryExpressionSyntax& asExpression, ILocalSymbol& localSymbol);
    private static bool TryFindVariableDeclarator(SemanticModel semanticModel, IdentifierNameSyntax identifier, ILocalSymbol& localSymbol, VariableDeclaratorSyntax& declarator);
    private static ExpressionSyntax GetNullCheckOperand(ExpressionSyntax left, SyntaxKind comparisonKind, SyntaxNode right);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__3_0(CodeBlockStartAnalysisContext`1<SyntaxKind> blockStartContext);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void AddEdits(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static IfStatementSyntax GetUpdatedIfStatement(IsPatternExpressionSyntax updatedCondition, ImmutableArray`1<SyntaxTrivia> trivia, IfStatementSyntax originalIf, IfStatementSyntax currentIf);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static CSharpIsAndCastCheckDiagnosticAnalyzer Instance;
    private static CSharpIsAndCastCheckDiagnosticAnalyzer();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void SyntaxNodeAction(SyntaxNodeAnalysisContext syntaxContext);
    [NullableContextAttribute("2")]
public static bool TryGetPatternPieces(BinaryExpressionSyntax isExpression, IfStatementSyntax& ifStatement, LocalDeclarationStatementSyntax& localDeclarationStatement, VariableDeclaratorSyntax& declarator, CastExpressionSyntax& castExpression);
    private static bool ContainsVariableDeclaration(SyntaxNode scope, VariableDeclaratorSyntax variable);
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_1(CodeBlockStartAnalysisContext`1<SyntaxKind> blockStartContext);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckWithoutNameCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckWithoutNameCodeFixProvider/<FixAllAsync>d__4")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpIsAndCastCheckWithoutNameDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    private static string CS0165;
    private static string CS0103;
    private static SyntaxAnnotation s_referenceAnnotation;
    public static CSharpIsAndCastCheckWithoutNameDiagnosticAnalyzer Instance;
    private static CSharpIsAndCastCheckWithoutNameDiagnosticAnalyzer();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("2")]
private void SyntaxNodeAction(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionType);
    public static ValueTuple`2<HashSet`1<CastExpressionSyntax>, string> AnalyzeExpression(SemanticModel semanticModel, BinaryExpressionSyntax isExpression, INamedTypeSymbol expressionType, CancellationToken cancellationToken);
    private static bool ReplacementCausesError(SemanticModel updatedSemanticModel, CancellationToken cancellationToken);
    public static SemanticModel ReplaceMatches(SemanticModel semanticModel, BinaryExpressionSyntax isExpression, string localName, HashSet`1<CastExpressionSyntax> matches, CancellationToken cancellationToken);
    private static SyntaxNode GetContainer(BinaryExpressionSyntax isExpression);
    private static void AddMatches(SyntaxNode node, ExpressionSyntax expr, TypeSyntax type, HashSet`1<CastExpressionSyntax> matches);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__6_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpUseNotPatternCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpUseNotPatternCodeFixProvider/<FixAllAsync>d__4")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void ProcessDiagnostic(SemanticModel semanticModel, SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.CSharpUseNotPatternDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("2")]
private void SyntaxNodeAction(SyntaxNodeAnalysisContext context, INamedTypeSymbol expressionOfTType);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.CSharp.UsePatternMatching.UsePatternMatchingHelpers : object {
    [NullableContextAttribute("2")]
public static bool TryGetPartsOfAsAndMemberAccessCheck(BinaryExpressionSyntax asExpression, ConditionalAccessExpressionSyntax& conditionalAccessExpression, BinaryExpressionSyntax& binaryExpression, IsPatternExpressionSyntax& isPatternExpression, LanguageVersion& requiredLanguageVersion);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorCodeFixProvider : CodeFixProvider {
    private static string s_summaryTagName;
    private static string s_remarksTagName;
    private static string s_paramTagName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static SyntaxTrivia GetDocComment(SyntaxNode node);
    private static SyntaxTrivia GetDocComment(SyntaxTriviaList trivia);
    private static DocumentationCommentTriviaSyntax GetDocCommentStructure(MemberDeclarationSyntax node);
    [NullableContextAttribute("2")]
private static DocumentationCommentTriviaSyntax GetDocCommentStructure(SyntaxTriviaList trivia);
    [NullableContextAttribute("2")]
private static DocumentationCommentTriviaSyntax GetDocCommentStructure(SyntaxTrivia trivia);
    private static bool IsXmlElement(XmlNodeSyntax node, string name, XmlElementSyntax& element);
    private static XmlElementSyntax ConvertXmlElementName(XmlElementSyntax xmlElement, string name);
    private static SyntaxTriviaList CreateFinalTypeDeclarationLeadingTrivia(TypeDeclarationSyntax typeDeclaration, ConstructorDeclarationSyntax constructorDeclaration, IMethodSymbol constructor, ImmutableDictionary`2<string, string> properties, ImmutableDictionary`2<ISymbol, ValueTuple`2<MemberDeclarationSyntax, SyntaxNode>> removedMembers);
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorCodeFixProvider/<UsePrimaryConstructorAsync>d__16")]
private static Task`1<Solution> UsePrimaryConstructorAsync(Document document, ConstructorDeclarationSyntax constructorDeclaration, ImmutableDictionary`2<string, string> properties, bool removeMembers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorCodeFixProvider/<UsePrimaryConstructorAsync>d__17")]
private static Task UsePrimaryConstructorAsync(SolutionEditor solutionEditor, Document document, ConstructorDeclarationSyntax constructorDeclaration, ImmutableDictionary`2<string, string> properties, bool removeMembers, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorCodeFixProvider/<<CreateFinalTypeDeclarationLeadingTrivia>g__ConvertSummaryToParam|10_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<XmlNodeSyntax> <CreateFinalTypeDeclarationLeadingTrivia>g__ConvertSummaryToParam|10_0(IEnumerable`1<XmlNodeSyntax> content, string parameterName);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorCodeFixProvider/<<CreateFinalTypeDeclarationLeadingTrivia>g__ConvertSummaryToRemarks|10_1>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<XmlNodeSyntax> <CreateFinalTypeDeclarationLeadingTrivia>g__ConvertSummaryToRemarks|10_1(IEnumerable`1<XmlNodeSyntax> nodes);
    [CompilerGeneratedAttribute]
internal static SyntaxTriviaList <CreateFinalTypeDeclarationLeadingTrivia>g__MergeTypeDeclarationAndConstructorDocComments|10_2(TypeDeclarationSyntax typeDeclaration, ConstructorDeclarationSyntax constructorDeclaration);
    [CompilerGeneratedAttribute]
internal static SyntaxTriviaList <CreateFinalTypeDeclarationLeadingTrivia>g__InsertOrReplaceDocComments|10_3(SyntaxTriviaList leadingTrivia, SyntaxTrivia newDocComment);
    [CompilerGeneratedAttribute]
internal static SyntaxTrivia <CreateFinalTypeDeclarationLeadingTrivia>g__MergeDocComments|10_4(SyntaxTrivia typeDeclarationDocComment, SyntaxTrivia constructorDocComment);
    [CompilerGeneratedAttribute]
internal static SyntaxTriviaList <CreateFinalTypeDeclarationLeadingTrivia>g__MergeTypeDeclarationAndRemovedMembersDocComments|10_5(IMethodSymbol constructor, ImmutableDictionary`2<string, string> properties, ImmutableDictionary`2<ISymbol, ValueTuple`2<MemberDeclarationSyntax, SyntaxNode>> removedMembers, SyntaxTriviaList typeDeclarationLeadingTrivia);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <UsePrimaryConstructorAsync>g__CreateDottedName|17_24(SimpleNameSyntax originalName, SimpleNameSyntax currentName, INamedTypeSymbol containingType);
    [CompilerGeneratedAttribute]
internal static TListSyntax <UsePrimaryConstructorAsync>g__RemoveElementIndentation|17_7(TypeDeclarationSyntax typeDeclaration, ConstructorDeclarationSyntax constructorDeclaration, TListSyntax list, Func`2<TListSyntax, IEnumerable`1<SyntaxNode>> getElements);
    [CompilerGeneratedAttribute]
internal static string <UsePrimaryConstructorAsync>g__GetLeadingWhitespace|17_8(SyntaxNode node);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <UsePrimaryConstructorAsync>g__UpdateDeclaration|17_12(SyntaxNode declaration, AssignmentExpressionSyntax assignmentExpression, ExpressionStatementSyntax expressionStatement);
    [CompilerGeneratedAttribute]
internal static SyntaxRemoveOptions <UsePrimaryConstructorAsync>g__GetRemoveOptions|17_14(MemberDeclarationSyntax memberDeclaration);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UsePrimaryConstructor.CSharpUsePrimaryConstructorDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public static string AllFieldsName;
    public static string AllPropertiesName;
    private static ObjectPool`1<ConcurrentSet`1<ISymbol>> s_concurrentSetPool;
    private static CSharpUsePrimaryConstructorDiagnosticAnalyzer();
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("2")]
public static bool IsViableMemberToAssignTo(INamedTypeSymbol namedType, ISymbol member, MemberDeclarationSyntax& memberNode, SyntaxNode& nodeToRemove, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__5_0(CompilationStartAnalysisContext context);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseSimpleUsingStatement.UseSimpleUsingStatementCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static BlockSyntax RewriteBlock(BlockSyntax originalBlock, BlockSyntax currentBlock, ISet`1<UsingStatementSyntax> topmostUsingStatements);
    private static ImmutableArray`1<StatementSyntax> Expand(UsingStatementSyntax usingStatement);
    private static SyntaxTriviaList Expand(ArrayBuilder`1<StatementSyntax> result, UsingStatementSyntax usingStatement);
    private static LocalDeclarationStatementSyntax Convert(UsingStatementSyntax usingStatement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseSimpleUsingStatement.UseSimpleUsingStatementDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeSyntax(SyntaxNodeAnalysisContext context);
    private static bool CausesVariableCollision(SemanticModel semanticModel, BlockSyntax parentBlock, UsingStatementSyntax outermostUsing, UsingStatementSyntax innermostUsing, CancellationToken cancellationToken);
    private static bool DeclaredLocalCausesCollision(ILookup`2<string, ISymbol> symbolNameToExistingSymbol, ImmutableArray`1<ILocalSymbol> locals);
    private static bool PreservesSemantics(SemanticModel semanticModel, BlockSyntax parentBlock, UsingStatementSyntax outermostUsing, UsingStatementSyntax innermostUsing, CancellationToken cancellationToken);
    private static bool UsingStatementDoesNotInvolveJumps(SyntaxList`1<StatementSyntax> parentStatements, int index, UsingStatementSyntax innermostUsing);
    private static bool IsGotoOrLabeledStatement(StatementSyntax priorStatement);
    private static bool UsingValueDoesNotLeakToFollowingStatements(SemanticModel semanticModel, SyntaxList`1<StatementSyntax> statements, int index, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseThrowExpression.CSharpUseThrowExpressionDiagnosticAnalyzer : AbstractUseThrowExpressionDiagnosticAnalyzer {
    protected ISemanticFacts SemanticFacts { get; }
    protected virtual ISemanticFacts get_SemanticFacts();
    protected virtual CodeStyleOption2`1<bool> PreferThrowExpressionStyle(OperationAnalysisContext context);
    protected virtual bool IsSupported(Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseThrowExpression.UseThrowExpressionCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseTupleSwap.CSharpUseTupleSwapCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    private static void FixOne(SyntaxEditor editor, Diagnostic diagnostic, CancellationToken cancellationToken);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseTupleSwap.CSharpUseTupleSwapDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    [NullableContextAttribute("1")]
protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeLocalDeclarationStatement(SyntaxNodeAnalysisContext syntaxContext);
    [NullableContextAttribute("2")]
private static bool IsSimpleAssignment(StatementSyntax assignmentStatement, ExpressionSyntax& left, ExpressionSyntax& right);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <InitializeWorker>b__2_0(CompilationStartAnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.UseUtf8StringLiteral.UseUtf8StringLiteralCodeFixProvider : SyntaxEditorBasedCodeFixProvider {
    private static char QuoteCharacter;
    private static string Suffix;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <FixableDiagnosticIds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CSharp.UseUtf8StringLiteral.UseUtf8StringLiteralCodeFixProvider/<FixAllAsync>d__7")]
protected virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider options, CancellationToken cancellationToken);
    private static IArrayCreationOperation GetArrayCreationOperation(SemanticModel semanticModel, Diagnostic diagnostic, CancellationToken cancellationToken);
    private static string GetUtf8StringValueFromArrayInitializer(IArrayInitializerOperation initializer);
    private static SyntaxNode CreateArgumentListWithUtf8String(BaseArgumentListSyntax argumentList, Location location, string stringValue, bool isConvertedToReadOnlySpan);
    private static ExpressionSyntax CreateUtf8String(SyntaxNode nodeToTakeTriviaFrom, string stringValue, bool isConvertedToReadOnlySpan);
    private static ExpressionSyntax CreateUtf8String(SyntaxTriviaList leadingTrivia, string stringValue, SyntaxTriviaList trailingTrivia, bool isConvertedToReadOnlySpan);
    [CompilerGeneratedAttribute]
internal static IArrayCreationOperation <GetArrayCreationOperation>g__FindArrayCreationOperationAncestor|8_1(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.UseUtf8StringLiteral.UseUtf8StringLiteralDiagnosticAnalyzer : AbstractBuiltInCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    [NullableContextAttribute("2")]
private void AnalyzeOperation(OperationAnalysisContext context, INamedTypeSymbol expressionType);
    private void ReportParameterArrayDiagnostic(OperationAnalysisContext context, SyntaxNode syntaxNode, ImmutableArray`1<IOperation> elements, NotificationOption2 notificationOption, ArrayCreationOperationLocation operationLocation);
    private void ReportArrayCreationDiagnostic(OperationAnalysisContext context, SyntaxNode syntaxNode, NotificationOption2 notificationOption);
    private void ReportDiagnostic(OperationAnalysisContext context, SyntaxNode syntaxNode, NotificationOption2 notificationOption, Location location, ArrayCreationOperationLocation operationLocation);
    [NullableContextAttribute("2")]
internal static bool TryConvertToUtf8String(StringBuilder builder, ImmutableArray`1<IOperation> arrayCreationElements);
    private static bool TryGetNextRune(ImmutableArray`1<IOperation> arrayCreationElements, int startIndex, Rune& rune, Int32& bytesConsumed);
    [CompilerGeneratedAttribute]
private void <InitializeWorker>b__3_0(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <TryConvertToUtf8String>g__IsControlOrFormatRune|8_0(Rune rune);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.ValidateFormatString.CSharpValidateFormatStringDiagnosticAnalyzer : AbstractValidateFormatStringDiagnosticAnalyzer`1<SyntaxKind> {
    protected virtual ISyntaxFacts GetSyntaxFacts();
    protected virtual SyntaxNode TryGetMatchingNamedArgument(SeparatedSyntaxList`1<SyntaxNode> arguments, string searchArgumentName);
    protected virtual SyntaxNode GetArgumentExpression(SyntaxNode syntaxNode);
}
internal class Microsoft.CodeAnalysis.CSharp.Wrapping.BinaryExpression.CSharpBinaryExpressionWrapper : AbstractBinaryExpressionWrapper`1<BinaryExpressionSyntax> {
    protected virtual SyntaxTriviaList GetNewLineBeforeOperatorTrivia(SyntaxTriviaList newLine);
}
internal class Microsoft.CodeAnalysis.CSharp.Wrapping.ChainedExpression.CSharpChainedExpressionWrapper : AbstractChainedExpressionWrapper`2<NameSyntax, BaseArgumentListSyntax> {
    protected virtual SyntaxTriviaList GetNewLineBeforeOperatorTrivia(SyntaxTriviaList newLine);
}
internal class Microsoft.CodeAnalysis.CSharp.Wrapping.CSharpSyntaxWrappingOptions : SyntaxWrappingOptions {
    public bool NewLinesForBracesInObjectCollectionArrayInitializers;
    [NullableContextAttribute("1")]
public CSharpSyntaxWrappingOptions(CSharpSyntaxFormattingOptions formattingOptions, int wrappingColumn, OperatorPlacementWhenWrappingPreference operatorPlacement, bool newLinesForBracesInObjectCollectionArrayInitializers);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CSharp.Wrapping.CSharpSyntaxWrappingOptionsProviders : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static CSharpSyntaxWrappingOptions GetCSharpSyntaxWrappingOptions(IOptionsReader options, CodeActionOptions fallbackOptions);
}
[ExportCodeRefactoringProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CSharp.Wrapping.CSharpWrappingCodeRefactoringProvider : AbstractWrappingCodeRefactoringProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<ISyntaxWrapper> s_wrappers;
    private static CSharpWrappingCodeRefactoringProvider();
    [NullableContextAttribute("1")]
protected virtual SyntaxWrappingOptions GetWrappingOptions(IOptionsReader options, CodeActionOptions ideOptions);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.CSharp.Wrapping.SeparatedSyntaxList.AbstractCSharpSeparatedSyntaxListWrapper`2 : AbstractSeparatedSyntaxListWrapper`2<TListSyntax, TListItemSyntax> {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Wrapping.SeparatedSyntaxList.CSharpArgumentWrapper : AbstractCSharpSeparatedSyntaxListWrapper`2<BaseArgumentListSyntax, ArgumentSyntax> {
    protected string Align_wrapped_items { get; }
    protected string Indent_all_items { get; }
    protected string Indent_wrapped_items { get; }
    protected string Unwrap_all_items { get; }
    protected string Unwrap_and_indent_all_items { get; }
    protected string Unwrap_list { get; }
    protected string Wrap_every_item { get; }
    protected string Wrap_long_list { get; }
    public bool Supports_UnwrapGroup_WrapFirst_IndentRest { get; }
    public bool Supports_WrapEveryGroup_UnwrapFirst { get; }
    public bool Supports_WrapLongGroup_UnwrapFirst { get; }
    protected bool ShouldMoveCloseBraceToNewLine { get; }
    protected virtual string get_Align_wrapped_items();
    protected virtual string get_Indent_all_items();
    protected virtual string get_Indent_wrapped_items();
    protected virtual string get_Unwrap_all_items();
    protected virtual string get_Unwrap_and_indent_all_items();
    protected virtual string get_Unwrap_list();
    protected virtual string get_Wrap_every_item();
    protected virtual string get_Wrap_long_list();
    public virtual bool get_Supports_UnwrapGroup_WrapFirst_IndentRest();
    public virtual bool get_Supports_WrapEveryGroup_UnwrapFirst();
    public virtual bool get_Supports_WrapLongGroup_UnwrapFirst();
    protected virtual bool ShouldMoveOpenBraceToNewLine(SyntaxWrappingOptions options);
    protected virtual bool get_ShouldMoveCloseBraceToNewLine();
    protected virtual SyntaxToken FirstToken(BaseArgumentListSyntax listSyntax);
    protected virtual SyntaxToken LastToken(BaseArgumentListSyntax listSyntax);
    protected virtual SeparatedSyntaxList`1<ArgumentSyntax> GetListItems(BaseArgumentListSyntax listSyntax);
    protected virtual BaseArgumentListSyntax TryGetApplicableList(SyntaxNode node);
    protected virtual bool PositionIsApplicable(SyntaxNode root, int position, SyntaxNode declaration, bool containsSyntaxError, BaseArgumentListSyntax listSyntax);
    private static ExpressionSyntax TryGetInvokedName(ExpressionSyntax expr);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Wrapping.SeparatedSyntaxList.CSharpCollectionExpressionWrapper : AbstractCSharpSeparatedSyntaxListWrapper`2<CollectionExpressionSyntax, CollectionElementSyntax> {
    protected string Indent_all_items { get; }
    protected string Unwrap_all_items { get; }
    protected string Unwrap_list { get; }
    protected string Wrap_every_item { get; }
    protected string Wrap_long_list { get; }
    public bool Supports_UnwrapGroup_WrapFirst_IndentRest { get; }
    public bool Supports_WrapEveryGroup_UnwrapFirst { get; }
    public bool Supports_WrapLongGroup_UnwrapFirst { get; }
    protected string Align_wrapped_items { get; }
    protected string Indent_wrapped_items { get; }
    protected string Unwrap_and_indent_all_items { get; }
    protected bool ShouldMoveCloseBraceToNewLine { get; }
    protected virtual string get_Indent_all_items();
    protected virtual string get_Unwrap_all_items();
    protected virtual string get_Unwrap_list();
    protected virtual string get_Wrap_every_item();
    protected virtual string get_Wrap_long_list();
    public virtual bool get_Supports_UnwrapGroup_WrapFirst_IndentRest();
    public virtual bool get_Supports_WrapEveryGroup_UnwrapFirst();
    public virtual bool get_Supports_WrapLongGroup_UnwrapFirst();
    protected virtual string get_Align_wrapped_items();
    protected virtual string get_Indent_wrapped_items();
    protected virtual string get_Unwrap_and_indent_all_items();
    protected virtual bool ShouldMoveOpenBraceToNewLine(SyntaxWrappingOptions options);
    protected virtual bool get_ShouldMoveCloseBraceToNewLine();
    protected virtual SyntaxToken FirstToken(CollectionExpressionSyntax listSyntax);
    protected virtual SyntaxToken LastToken(CollectionExpressionSyntax listSyntax);
    protected virtual SeparatedSyntaxList`1<CollectionElementSyntax> GetListItems(CollectionExpressionSyntax listSyntax);
    protected virtual CollectionExpressionSyntax TryGetApplicableList(SyntaxNode node);
    protected virtual bool PositionIsApplicable(SyntaxNode root, int position, SyntaxNode declaration, bool containsSyntaxError, CollectionExpressionSyntax listSyntax);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Wrapping.SeparatedSyntaxList.CSharpInitializerExpressionWrapper : AbstractCSharpSeparatedSyntaxListWrapper`2<InitializerExpressionSyntax, ExpressionSyntax> {
    protected string Indent_all_items { get; }
    protected string Unwrap_all_items { get; }
    protected string Unwrap_list { get; }
    protected string Wrap_every_item { get; }
    protected string Wrap_long_list { get; }
    public bool Supports_UnwrapGroup_WrapFirst_IndentRest { get; }
    public bool Supports_WrapEveryGroup_UnwrapFirst { get; }
    public bool Supports_WrapLongGroup_UnwrapFirst { get; }
    protected string Align_wrapped_items { get; }
    protected string Indent_wrapped_items { get; }
    protected string Unwrap_and_indent_all_items { get; }
    protected bool ShouldMoveCloseBraceToNewLine { get; }
    protected virtual string get_Indent_all_items();
    protected virtual string get_Unwrap_all_items();
    protected virtual string get_Unwrap_list();
    protected virtual string get_Wrap_every_item();
    protected virtual string get_Wrap_long_list();
    public virtual bool get_Supports_UnwrapGroup_WrapFirst_IndentRest();
    public virtual bool get_Supports_WrapEveryGroup_UnwrapFirst();
    public virtual bool get_Supports_WrapLongGroup_UnwrapFirst();
    protected virtual string get_Align_wrapped_items();
    protected virtual string get_Indent_wrapped_items();
    protected virtual string get_Unwrap_and_indent_all_items();
    protected virtual bool ShouldMoveOpenBraceToNewLine(SyntaxWrappingOptions options);
    protected virtual bool get_ShouldMoveCloseBraceToNewLine();
    protected virtual SyntaxToken FirstToken(InitializerExpressionSyntax listSyntax);
    protected virtual SyntaxToken LastToken(InitializerExpressionSyntax listSyntax);
    protected virtual SeparatedSyntaxList`1<ExpressionSyntax> GetListItems(InitializerExpressionSyntax listSyntax);
    protected virtual InitializerExpressionSyntax TryGetApplicableList(SyntaxNode node);
    protected virtual bool PositionIsApplicable(SyntaxNode root, int position, SyntaxNode declaration, bool containsSyntaxError, InitializerExpressionSyntax listSyntax);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CSharp.Wrapping.SeparatedSyntaxList.CSharpParameterWrapper : AbstractCSharpSeparatedSyntaxListWrapper`2<BaseParameterListSyntax, ParameterSyntax> {
    protected string Align_wrapped_items { get; }
    protected string Indent_all_items { get; }
    protected string Indent_wrapped_items { get; }
    protected string Unwrap_all_items { get; }
    protected string Unwrap_and_indent_all_items { get; }
    protected string Unwrap_list { get; }
    protected string Wrap_every_item { get; }
    protected string Wrap_long_list { get; }
    public bool Supports_UnwrapGroup_WrapFirst_IndentRest { get; }
    public bool Supports_WrapEveryGroup_UnwrapFirst { get; }
    public bool Supports_WrapLongGroup_UnwrapFirst { get; }
    protected bool ShouldMoveCloseBraceToNewLine { get; }
    protected virtual string get_Align_wrapped_items();
    protected virtual string get_Indent_all_items();
    protected virtual string get_Indent_wrapped_items();
    protected virtual string get_Unwrap_all_items();
    protected virtual string get_Unwrap_and_indent_all_items();
    protected virtual string get_Unwrap_list();
    protected virtual string get_Wrap_every_item();
    protected virtual string get_Wrap_long_list();
    public virtual bool get_Supports_UnwrapGroup_WrapFirst_IndentRest();
    public virtual bool get_Supports_WrapEveryGroup_UnwrapFirst();
    public virtual bool get_Supports_WrapLongGroup_UnwrapFirst();
    protected virtual bool ShouldMoveOpenBraceToNewLine(SyntaxWrappingOptions options);
    protected virtual bool get_ShouldMoveCloseBraceToNewLine();
    protected virtual SyntaxToken FirstToken(BaseParameterListSyntax listSyntax);
    protected virtual SyntaxToken LastToken(BaseParameterListSyntax listSyntax);
    protected virtual SeparatedSyntaxList`1<ParameterSyntax> GetListItems(BaseParameterListSyntax listSyntax);
    protected virtual BaseParameterListSyntax TryGetApplicableList(SyntaxNode node);
    protected virtual bool PositionIsApplicable(SyntaxNode root, int position, SyntaxNode declaration, bool containsSyntaxError, BaseParameterListSyntax listSyntax);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.CSharpAnalyzerOptionsProvider : ValueType {
    private IOptionsReader _options;
    private IdeAnalyzerOptions _fallbackOptions;
    public CodeStyleOption2`1<bool> VarForBuiltInTypes { get; }
    public CodeStyleOption2`1<bool> VarWhenTypeIsApparent { get; }
    public CodeStyleOption2`1<bool> VarElsewhere { get; }
    public CodeStyleOption2`1<bool> PreferSimpleDefaultExpression { get; }
    public CodeStyleOption2`1<bool> AllowEmbeddedStatementsOnSameLine { get; }
    public CodeStyleOption2`1<bool> PreferThrowExpression { get; }
    public CodeStyleOption2`1<PreferBracesPreference> PreferBraces { get; }
    public CodeStyleOption2`1<NamespaceDeclarationPreference> NamespaceDeclarations { get; }
    public CodeStyleOption2`1<bool> PreferTopLevelStatements { get; }
    public CodeStyleOption2`1<AddImportPlacement> UsingDirectivePlacement { get; }
    public CodeStyleOption2`1<bool> ImplicitObjectCreationWhenTypeIsApparent { get; }
    public CodeStyleOption2`1<bool> PreferNullCheckOverTypeCheck { get; }
    public CodeStyleOption2`1<bool> AllowBlankLinesBetweenConsecutiveBraces { get; }
    public CodeStyleOption2`1<bool> AllowBlankLineAfterColonInConstructorInitializer { get; }
    public CodeStyleOption2`1<bool> AllowBlankLineAfterTokenInArrowExpressionClause { get; }
    public CodeStyleOption2`1<bool> AllowBlankLineAfterTokenInConditionalExpression { get; }
    public CodeStyleOption2`1<bool> PreferConditionalDelegateCall { get; }
    public CodeStyleOption2`1<bool> PreferSwitchExpression { get; }
    public CodeStyleOption2`1<bool> PreferPatternMatching { get; }
    public CodeStyleOption2`1<bool> PreferPatternMatchingOverAsWithNullCheck { get; }
    public CodeStyleOption2`1<bool> PreferPatternMatchingOverIsWithCastCheck { get; }
    public CodeStyleOption2`1<bool> PreferNotPattern { get; }
    public CodeStyleOption2`1<bool> PreferExtendedPropertyPattern { get; }
    public CodeStyleOption2`1<bool> PreferInlinedVariableDeclaration { get; }
    public CodeStyleOption2`1<bool> PreferDeconstructedVariableDeclaration { get; }
    public CodeStyleOption2`1<bool> PreferIndexOperator { get; }
    public CodeStyleOption2`1<bool> PreferRangeOperator { get; }
    public CodeStyleOption2`1<bool> PreferUtf8StringLiterals { get; }
    public CodeStyleOption2`1<string> PreferredModifierOrder { get; }
    public CodeStyleOption2`1<bool> PreferSimpleUsingStatement { get; }
    public CodeStyleOption2`1<bool> PreferLocalOverAnonymousFunction { get; }
    public CodeStyleOption2`1<bool> PreferTupleSwap { get; }
    public CodeStyleOption2`1<UnusedValuePreference> UnusedValueExpressionStatement { get; }
    public CodeStyleOption2`1<UnusedValuePreference> UnusedValueAssignment { get; }
    public CodeStyleOption2`1<bool> PreferMethodGroupConversion { get; }
    public CodeStyleOption2`1<bool> PreferPrimaryConstructors { get; }
    public CodeStyleOption2`1<ExpressionBodyPreference> PreferExpressionBodiedLambdas { get; }
    public CodeStyleOption2`1<bool> PreferReadOnlyStruct { get; }
    public CodeStyleOption2`1<bool> PreferReadOnlyStructMember { get; }
    public CodeStyleOption2`1<bool> PreferStaticLocalFunction { get; }
    private CSharpIdeCodeStyleOptions FallbackCodeStyleOptions { get; }
    private CSharpSimplifierOptions FallbackSimplifierOptions { get; }
    private CSharpSyntaxFormattingOptions FallbackSyntaxFormattingOptions { get; }
    private AddImportPlacementOptions FallbackAddImportPlacementOptions { get; }
    private CSharpCodeGenerationOptions FallbackCodeGenerationOptions { get; }
    public CSharpAnalyzerOptionsProvider(IOptionsReader options, IdeAnalyzerOptions fallbackOptions);
    public CSharpAnalyzerOptionsProvider(IOptionsReader options, AnalyzerOptions fallbackOptions);
    public CodeStyleOption2`1<bool> get_VarForBuiltInTypes();
    public CodeStyleOption2`1<bool> get_VarWhenTypeIsApparent();
    public CodeStyleOption2`1<bool> get_VarElsewhere();
    public CodeStyleOption2`1<bool> get_PreferSimpleDefaultExpression();
    public CodeStyleOption2`1<bool> get_AllowEmbeddedStatementsOnSameLine();
    public CodeStyleOption2`1<bool> get_PreferThrowExpression();
    public CodeStyleOption2`1<PreferBracesPreference> get_PreferBraces();
    internal CSharpSimplifierOptions GetSimplifierOptions();
    public CodeStyleOption2`1<NamespaceDeclarationPreference> get_NamespaceDeclarations();
    public CodeStyleOption2`1<bool> get_PreferTopLevelStatements();
    public CodeStyleOption2`1<AddImportPlacement> get_UsingDirectivePlacement();
    public CodeStyleOption2`1<bool> get_ImplicitObjectCreationWhenTypeIsApparent();
    public CodeStyleOption2`1<bool> get_PreferNullCheckOverTypeCheck();
    public CodeStyleOption2`1<bool> get_AllowBlankLinesBetweenConsecutiveBraces();
    public CodeStyleOption2`1<bool> get_AllowBlankLineAfterColonInConstructorInitializer();
    public CodeStyleOption2`1<bool> get_AllowBlankLineAfterTokenInArrowExpressionClause();
    public CodeStyleOption2`1<bool> get_AllowBlankLineAfterTokenInConditionalExpression();
    public CodeStyleOption2`1<bool> get_PreferConditionalDelegateCall();
    public CodeStyleOption2`1<bool> get_PreferSwitchExpression();
    public CodeStyleOption2`1<bool> get_PreferPatternMatching();
    public CodeStyleOption2`1<bool> get_PreferPatternMatchingOverAsWithNullCheck();
    public CodeStyleOption2`1<bool> get_PreferPatternMatchingOverIsWithCastCheck();
    public CodeStyleOption2`1<bool> get_PreferNotPattern();
    public CodeStyleOption2`1<bool> get_PreferExtendedPropertyPattern();
    public CodeStyleOption2`1<bool> get_PreferInlinedVariableDeclaration();
    public CodeStyleOption2`1<bool> get_PreferDeconstructedVariableDeclaration();
    public CodeStyleOption2`1<bool> get_PreferIndexOperator();
    public CodeStyleOption2`1<bool> get_PreferRangeOperator();
    public CodeStyleOption2`1<bool> get_PreferUtf8StringLiterals();
    public CodeStyleOption2`1<string> get_PreferredModifierOrder();
    public CodeStyleOption2`1<bool> get_PreferSimpleUsingStatement();
    public CodeStyleOption2`1<bool> get_PreferLocalOverAnonymousFunction();
    public CodeStyleOption2`1<bool> get_PreferTupleSwap();
    public CodeStyleOption2`1<UnusedValuePreference> get_UnusedValueExpressionStatement();
    public CodeStyleOption2`1<UnusedValuePreference> get_UnusedValueAssignment();
    public CodeStyleOption2`1<bool> get_PreferMethodGroupConversion();
    public CodeStyleOption2`1<bool> get_PreferPrimaryConstructors();
    internal CSharpCodeGenerationOptions GetCodeGenerationOptions();
    public CodeStyleOption2`1<ExpressionBodyPreference> get_PreferExpressionBodiedLambdas();
    public CodeStyleOption2`1<bool> get_PreferReadOnlyStruct();
    public CodeStyleOption2`1<bool> get_PreferReadOnlyStructMember();
    public CodeStyleOption2`1<bool> get_PreferStaticLocalFunction();
    private TValue GetOption(Option2`1<TValue> option, TValue defaultValue);
    private CSharpIdeCodeStyleOptions get_FallbackCodeStyleOptions();
    private CSharpSimplifierOptions get_FallbackSimplifierOptions();
    private CSharpSyntaxFormattingOptions get_FallbackSyntaxFormattingOptions();
    private AddImportPlacementOptions get_FallbackAddImportPlacementOptions();
    private CSharpCodeGenerationOptions get_FallbackCodeGenerationOptions();
    public static CSharpAnalyzerOptionsProvider op_Explicit(AnalyzerOptionsProvider provider);
    public static AnalyzerOptionsProvider op_Implicit(CSharpAnalyzerOptionsProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.CSharpAnalyzerOptionsProviders : object {
    [ExtensionAttribute]
public static CSharpAnalyzerOptionsProvider GetCSharpAnalyzerOptions(AnalyzerOptions options, SyntaxTree syntaxTree);
    [ExtensionAttribute]
public static CSharpAnalyzerOptionsProvider GetCSharpAnalyzerOptions(SemanticModelAnalysisContext context);
    [ExtensionAttribute]
public static CSharpAnalyzerOptionsProvider GetCSharpAnalyzerOptions(SyntaxNodeAnalysisContext context);
    [ExtensionAttribute]
public static CSharpAnalyzerOptionsProvider GetCSharpAnalyzerOptions(SyntaxTreeAnalysisContext context);
    [ExtensionAttribute]
public static CSharpAnalyzerOptionsProvider GetCSharpAnalyzerOptions(CodeBlockAnalysisContext context);
    [ExtensionAttribute]
public static CSharpAnalyzerOptionsProvider GetCSharpAnalyzerOptions(OperationAnalysisContext context);
    [ExtensionAttribute]
public static CSharpAnalyzerOptionsProvider GetCSharpAnalyzerOptions(SymbolStartAnalysisContext context, SyntaxTree syntaxTree);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.CommentSelection.ICommentSelectionService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Editor.CSharp.CommentSelection.CSharpCommentSelectionService : AbstractCommentSelectionService {
    public string SingleLineCommentString { get; }
    public bool SupportsBlockComment { get; }
    public string BlockCommentStartString { get; }
    public string BlockCommentEndString { get; }
    public virtual string get_SingleLineCommentString();
    public virtual bool get_SupportsBlockComment();
    public virtual string get_BlockCommentStartString();
    public virtual string get_BlockCommentEndString();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LanguageService.IStructuralTypeDisplayService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Editor.CSharp.LanguageServices.CSharpStructuralTypeDisplayService : AbstractStructuralTypeDisplayService {
    protected ISyntaxFacts SyntaxFactsService { get; }
    protected virtual ISyntaxFacts get_SyntaxFactsService();
    protected virtual ImmutableArray`1<SymbolDisplayPart> GetNormalAnonymousTypeParts(INamedTypeSymbol anonymousType, SemanticModel semanticModel, int position);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Editor.CSharp.LanguageServices.CSharpSymbolDisplayService : AbstractSymbolDisplayService {
    public CSharpSymbolDisplayService(LanguageServices services);
    protected virtual AbstractSymbolDescriptionBuilder CreateDescriptionBuilder(SemanticModel semanticModel, int position, SymbolDescriptionOptions options, CancellationToken cancellationToken);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.LanguageService.ISymbolDisplayService", "C#", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Editor.CSharp.LanguageServices.CSharpSymbolDisplayServiceFactory : object {
    public sealed virtual ILanguageService CreateLanguageService(HostLanguageServices provider);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.IPythiaSignatureHelpProviderImplementation {
    public abstract virtual Task`1<ValueTuple`2<ImmutableArray`1<PythiaSignatureHelpItemWrapper>, Nullable`1<int>>> GetMethodGroupItemsAndSelectionAsync(ImmutableArray`1<IMethodSymbol> accessibleMethods, Document document, InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel, SymbolInfo currentSymbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaSignatureHelpItemWrapper : ValueType {
    internal SignatureHelpItem UnderlyingObject;
    public PythiaSignatureHelpItemWrapper(SignatureHelpItem underlyingObject);
    public static SymbolDisplayPart CreateTextDisplayPart(string text);
    public static PythiaSignatureHelpItemWrapper CreateFromMethodGroupMethod(Document document, IMethodSymbol method, int position, SemanticModel semanticModel, IList`1<SymbolDisplayPart> descriptionParts);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportSignatureHelpProviderAttribute("PythiaSignatureHelpProvider", "C#")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.Pythia.PythiaSignatureHelpProvider : InvocationExpressionSignatureHelpProviderBase {
    private Lazy`1<IPythiaSignatureHelpProviderImplementation> _lazyImplementation;
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public PythiaSignatureHelpProvider(Lazy`1<IPythiaSignatureHelpProviderImplementation> implementation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.Pythia.PythiaSignatureHelpProvider/<GetMethodGroupItemsAndSelectionAsync>d__2")]
internal virtual Task`1<ValueTuple`2<ImmutableArray`1<SignatureHelpItem>, Nullable`1<int>>> GetMethodGroupItemsAndSelectionAsync(ImmutableArray`1<IMethodSymbol> accessibleMethods, Document document, InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel, SymbolInfo symbolInfo, IMethodSymbol currentSymbol, CancellationToken cancellationToken);
}
[ExportNewDocumentFormattingProviderAttribute("C#")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Formatting.CSharpAccessibilityModifiersNewDocumentFormattingProvider : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.CSharpAccessibilityModifiersNewDocumentFormattingProvider/<FormatNewDocumentAsync>d__1")]
public sealed virtual Task`1<Document> FormatNewDocumentAsync(Document document, Document hintDocument, CodeCleanupOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.RemoveUnnecessaryNullableDirective.CSharpRemoveUnnecessaryNullableDirectiveDiagnosticAnalyzer : AbstractBuiltInUnnecessaryCodeStyleDiagnosticAnalyzer {
    public virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    protected virtual void InitializeWorker(AnalysisContext context);
    private void AnalyzeCompilation(CompilationStartAnalysisContext context);
    private static bool IsIgnoredCodeBlock(SyntaxNode codeBlock);
    private static bool IsReducing(Nullable`1<NullableContextOptions> oldOptions, Nullable`1<NullableContextOptions> newOptions);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<TextSpan> AnalyzeCodeBlock(CodeBlockAnalysisContext context, int positionOfFirstReducingNullableDirective);
    [NullableContextAttribute("2")]
private ImmutableArray`1<Diagnostic> AnalyzeSemanticModel(SemanticModelAnalysisContext context, int positionOfFirstReducingNullableDirective, TextSpanIntervalTree codeBlockIntervalTree, TextSpanIntervalTree possibleNullableImpactIntervalTree);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
