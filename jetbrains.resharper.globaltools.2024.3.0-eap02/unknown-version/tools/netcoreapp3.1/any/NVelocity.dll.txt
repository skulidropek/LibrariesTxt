public class Commons.Collections.CollectionsUtil : object {
    public static object PutElement(IDictionary hashTable, object key, object newValue);
}
public class Commons.Collections.ExtendedProperties : Hashtable {
    private static byte DEFAULT_BYTE;
    private static bool DEFAULT_BOOLEAN;
    private static int DEFAULT_INT32;
    private static float DEFAULT_SINGLE;
    private static long DEFAULT_INT64;
    private static double DEFAULT_DOUBLE;
    private ExtendedProperties defaults;
    protected internal string file;
    protected internal string basePath;
    protected internal string fileSeparator;
    protected internal bool isInitialized;
    protected internal static string include;
    protected internal ArrayList keysAsListed;
    public string Include { get; public set; }
    public IEnumerable Keys { get; }
    public ExtendedProperties(string file);
    public ExtendedProperties(string file, string defaultFile);
    private static ExtendedProperties();
    public bool IsInitialized();
    public string get_Include();
    public void set_Include(string value);
    public IEnumerable get_Keys();
    public void Load(Stream input);
    public void Load(Stream input, string encoding);
    public object GetProperty(string key);
    public void AddProperty(string key, object token);
    private void AddPropertyDirect(string key, object obj);
    private void AddStringProperty(string key, string token);
    public void SetProperty(string key, object value);
    public void Save(TextWriter output, string Header);
    private void WriteKeyOutput(TextWriter textWriter, string key, string value);
    public void Combine(ExtendedProperties c);
    public void ClearProperty(string key);
    public IEnumerable GetKeys(string prefix);
    public ExtendedProperties Subset(string prefix);
    public virtual string ToString();
    private string ValueToString(object value);
    public string GetString(string key);
    public string GetString(string key, string defaultValue);
    public Hashtable GetProperties(string key);
    public Hashtable GetProperties(string key, Hashtable defaultProps);
    public String[] GetStringArray(string key);
    public ArrayList GetVector(string key);
    public List`1<string> GetStringList(string key);
    public ArrayList GetVector(string key, ArrayList defaultValue);
    public bool GetBoolean(string key);
    public bool GetBoolean(string key, bool defaultValue);
    public string TestBoolean(string value);
    public sbyte GetByte(string key);
    public sbyte GetByte(string key, sbyte defaultValue);
    public byte GetByte(string key, byte defaultValue);
    public int GetInt(string name);
    public int GetInt(string name, int def);
    public int GetInteger(string key);
    public int GetInteger(string key, int defaultValue);
    public long GetLong(string key);
    public long GetLong(string key, long defaultValue);
    public float GetFloat(string key);
    public float GetFloat(string key, float defaultValue);
    public double GetDouble(string key);
    public double GetDouble(string key, double defaultValue);
    public static ExtendedProperties ConvertProperties(ExtendedProperties p);
}
public interface Commons.Collections.IOrderedDictionary {
    public abstract virtual void Insert(int index, object key, object value);
    public abstract virtual void RemoveAt(int index);
}
public class Commons.Collections.KeyedListEnumerator : object {
    private int index;
    private ArrayList objs;
    public object Current { get; }
    public DictionaryEntry Entry { get; }
    public object Key { get; }
    public object Value { get; }
    internal KeyedListEnumerator(ArrayList list);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual object get_Current();
    public sealed virtual DictionaryEntry get_Entry();
    public sealed virtual object get_Key();
    public sealed virtual object get_Value();
}
[DefaultMemberAttribute("Item")]
public class Commons.Collections.LRUMap : object {
    protected internal static int DEFAULT_MAX_SIZE;
    private Hashtable objectTable;
    private ArrayList objectList;
    private int maxSize;
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public int MaxSize { get; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public object SyncRoot { get; }
    public LRUMap(int maxSize);
    public virtual void Add(object key, object value);
    public virtual void Clear();
    public virtual bool Contains(object key);
    public virtual void CopyTo(Array array, int idx);
    public virtual void Remove(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual int get_Count();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public int get_MaxSize();
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    public virtual object get_SyncRoot();
    public void AddAll(IDictionary dictionary);
    private int IndexOf(object key);
    private void RemoveLRU();
    private void MoveToMRU(object key);
    public static LRUMap Synchronized(LRUMap table);
}
internal class Commons.Collections.PropertiesReader : StreamReader {
    public PropertiesReader(StreamReader reader);
    public string ReadProperty();
}
internal class Commons.Collections.PropertiesTokenizer : StringTokenizer {
    internal static string DELIMITER;
    public PropertiesTokenizer(string str);
    public virtual string NextToken();
}
public class Commons.Collections.StringTokenizer : object {
    private static string DefaultDelimiters;
    private string source;
    private string delimiters;
    private int currentPosition;
    private int length;
    public int Count { get; }
    public StringTokenizer(string source);
    public StringTokenizer(string source, string delimiters);
    public int get_Count();
    public virtual bool HasMoreTokens();
    public virtual string NextToken();
    public string NextToken(string delimiters);
}
public class NVelocity.App.Events.EventCartridge : object {
    private EventHandler`1<ReferenceInsertionEventArgs> ReferenceInsertion;
    private NullSetEventHandler NullSet;
    private EventHandler`1<MethodExceptionEventArgs> MethodExceptionEvent;
    public void add_ReferenceInsertion(EventHandler`1<ReferenceInsertionEventArgs> value);
    public void remove_ReferenceInsertion(EventHandler`1<ReferenceInsertionEventArgs> value);
    public void add_NullSet(NullSetEventHandler value);
    public void remove_NullSet(NullSetEventHandler value);
    public void add_MethodExceptionEvent(EventHandler`1<MethodExceptionEventArgs> value);
    public void remove_MethodExceptionEvent(EventHandler`1<MethodExceptionEventArgs> value);
    internal object ReferenceInsert(Stack referenceStack, string reference, object value);
    internal bool ShouldLogOnNullSet(string lhs, string rhs);
    internal object HandleMethodException(Type type, string method, Exception e);
    public bool AttachToContext(IContext context);
}
public interface NVelocity.App.Events.EventHandler {
}
public class NVelocity.App.Events.MethodExceptionEventArgs : EventArgs {
    private object valueToRender;
    private Exception exceptionThrown;
    private Type targetClass;
    private string targetMethod;
    public object ValueToRender { get; public set; }
    public Exception ExceptionThrown { get; }
    public Type TargetClass { get; }
    public string TargetMethod { get; }
    public MethodExceptionEventArgs(Type targetClass, string targetMethod, Exception exceptionThrown);
    public object get_ValueToRender();
    public void set_ValueToRender(object value);
    public Exception get_ExceptionThrown();
    public Type get_TargetClass();
    public string get_TargetMethod();
}
public class NVelocity.App.Events.NullSetEventArgs : EventArgs {
    private bool shouldLog;
    private string lhs;
    private string rhs;
    public string LHS { get; }
    public string RHS { get; }
    public bool ShouldLog { get; public set; }
    public NullSetEventArgs(string lhs, string rhs);
    public string get_LHS();
    public string get_RHS();
    public bool get_ShouldLog();
    public void set_ShouldLog(bool value);
}
public class NVelocity.App.Events.NullSetEventHandler : MulticastDelegate {
    public NullSetEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NullSetEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NullSetEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NVelocity.App.Events.ReferenceInsertionEventArgs : EventArgs {
    private Stack referenceStack;
    private object originalValue;
    private object newValue;
    private string rootString;
    public string RootString { get; }
    public object OriginalValue { get; }
    public object NewValue { get; public set; }
    public ReferenceInsertionEventArgs(Stack referenceStack, string rootString, object value);
    public Stack GetCopyOfReferenceStack();
    public string get_RootString();
    public object get_OriginalValue();
    public object get_NewValue();
    public void set_NewValue(object value);
}
public class NVelocity.App.FieldMethodizer : object {
    private Dictionary`2<string, FieldInfo> fieldHash;
    private Dictionary`2<string, Type> classHash;
    public FieldMethodizer(string s);
    public FieldMethodizer(object o);
    public void AddObject(string s);
    public void AddObject(object o);
    public object Get(string fieldName);
    private void Inspect(Type type);
}
public class NVelocity.App.Tools.VelocityFormatter : object {
    internal IContext context;
    internal TextNumberFormat textNumberFormat;
    public VelocityFormatter(IContext context);
    public string FormatShortDate(DateTime date);
    public string FormatLongDate(DateTime date);
    public string FormatShortDateTime(DateTime date);
    public string FormatLongDateTime(DateTime date);
    public string FormatArray(object array);
    public string FormatArray(object array, string delim);
    public string FormatArray(object array, string delim, string finalDelimiter);
    public string FormatVector(IList list);
    public string FormatVector(IList list, string delim);
    public string FormatVector(IList list, string delim, string finalDelimiter);
    public string LimitLen(int maximumLength, string value);
    public string LimitLen(int maximumLength, string value, string suffix);
    public string MakeAlternator(string name, string alt1, string alt2);
    public string MakeAlternator(string name, string alt1, string alt2, string alt3);
    public string MakeAlternator(string name, string alt1, string alt2, string alt3, string alt4);
    public string MakeAutoAlternator(string name, string alt1, string alt2);
    public object IsNull(object o, object defaultValue);
}
public class NVelocity.App.Velocity : object {
    public static void Init();
    public static void Init(string propsFilename);
    public static void Init(ExtendedProperties p);
    public static void SetProperty(string key, object value);
    public static void AddProperty(string key, object value);
    public static void ClearProperty(string key);
    public static void SetExtendedProperties(ExtendedProperties value);
    public static object GetProperty(string key);
    public static bool Evaluate(IContext context, TextWriter writer, string logTag, string inString);
    [ObsoleteAttribute("Use the overload that takes a TextReader")]
public static bool Evaluate(IContext context, TextWriter writer, string logTag, Stream instream);
    public static bool Evaluate(IContext context, TextWriter writer, string logTag, TextReader reader);
    public static bool InvokeVelocimacro(string vmName, string logTag, String[] parameters, IContext context, TextWriter writer);
    [ObsoleteAttribute("Use the overload that takes an encoding")]
public static bool MergeTemplate(string templateName, IContext context, TextWriter writer);
    public static bool MergeTemplate(string templateName, string encoding, IContext context, TextWriter writer);
    public static Template GetTemplate(string name);
    public static Template GetTemplate(string name, string encoding);
    public static bool ResourceExists(string templateName);
    public static void Warn(object message);
    public static void Info(object message);
    public static void Error(object message);
    public static void Debug(object message);
    public static void SetApplicationAttribute(object key, object value);
    [ObsoleteAttribute("Use ResourceExists(String) instead")]
public static bool TemplateExists(string resourceName);
}
public class NVelocity.App.VelocityEngine : object {
    private RuntimeInstance runtimeInstance;
    public VelocityEngine(string propsFilename);
    public VelocityEngine(ExtendedProperties p);
    public void SetExtendedProperties(ExtendedProperties value);
    public void Init();
    public void Init(string propsFilename);
    public void Init(ExtendedProperties p);
    public void SetProperty(string key, object value);
    public void AddProperty(string key, object value);
    public void ClearProperty(string key);
    public object GetProperty(string key);
    public bool Evaluate(IContext context, TextWriter writer, string logTag, string inString);
    [ObsoleteAttribute("Use the overload that takes an TextReader")]
public bool Evaluate(IContext context, TextWriter writer, string logTag, Stream instream);
    public bool Evaluate(IContext context, TextWriter writer, string logTag, TextReader reader);
    public bool InvokeVelocimacro(string vmName, string logTag, String[] parameters, IContext context, TextWriter writer);
    [ObsoleteAttribute("Use the overload that takes the encoding as parameter")]
public bool MergeTemplate(string templateName, IContext context, TextWriter writer);
    public bool MergeTemplate(string templateName, string encoding, IContext context, TextWriter writer);
    public Template GetTemplate(string name);
    public Template GetTemplate(string name, string encoding);
    public bool TemplateExists(string templateName);
    public void Warn(object message);
    public void Info(object message);
    public void Error(object message);
    public void Debug(object message);
    public void SetApplicationAttribute(object key, object value);
}
public abstract class NVelocity.Context.AbstractContext : InternalContextBase {
    private IContext innerContext;
    public Object[] Keys { get; }
    public IContext ChainedContext { get; }
    public int Count { get; }
    public AbstractContext(IContext inner);
    public sealed virtual Object[] get_Keys();
    public IContext get_ChainedContext();
    public abstract virtual object InternalGet(string key);
    public abstract virtual object InternalPut(string key, object value);
    public abstract virtual bool InternalContainsKey(object key);
    public abstract virtual Object[] InternalGetKeys();
    public abstract virtual object InternalRemove(object key);
    public sealed virtual object Put(string key, object value);
    public sealed virtual object Get(string key);
    public sealed virtual bool ContainsKey(object key);
    public sealed virtual object Remove(object key);
    public abstract virtual int get_Count();
}
public interface NVelocity.Context.IContext {
    public int Count { get; }
    public Object[] Keys { get; }
    public abstract virtual int get_Count();
    public abstract virtual object Put(string key, object value);
    public abstract virtual object Get(string key);
    public abstract virtual bool ContainsKey(object key);
    public abstract virtual Object[] get_Keys();
    public abstract virtual object Remove(object key);
}
public interface NVelocity.Context.IInternalContextAdapter {
    public abstract virtual object Remove(object key);
}
public interface NVelocity.Context.IInternalEventContext {
    public EventCartridge EventCartridge { get; }
    public abstract virtual EventCartridge get_EventCartridge();
    public abstract virtual EventCartridge AttachEventCartridge(EventCartridge eventCartridge);
}
public interface NVelocity.Context.IInternalHousekeepingContext {
    public string CurrentTemplateName { get; }
    public Object[] TemplateNameStack { get; }
    public Resource CurrentResource { get; public set; }
    public abstract virtual string get_CurrentTemplateName();
    public abstract virtual Object[] get_TemplateNameStack();
    public abstract virtual Resource get_CurrentResource();
    public abstract virtual void set_CurrentResource(Resource value);
    public abstract virtual void PushCurrentTemplateName(string s);
    public abstract virtual void PopCurrentTemplateName();
    public abstract virtual IntrospectionCacheData ICacheGet(object key);
    public abstract virtual void ICachePut(object key, IntrospectionCacheData o);
}
public interface NVelocity.Context.IInternalWrapperContext {
    public IContext InternalUserContext { get; }
    public IInternalContextAdapter BaseContext { get; }
    public abstract virtual IContext get_InternalUserContext();
    public abstract virtual IInternalContextAdapter get_BaseContext();
}
[DefaultMemberAttribute("Item")]
public class NVelocity.Context.InternalContextAdapterImpl : object {
    internal IContext context;
    internal IInternalHousekeepingContext internalHousekeepingContext;
    internal IInternalEventContext internalEventContext;
    public string CurrentTemplateName { get; }
    public Object[] TemplateNameStack { get; }
    public Resource CurrentResource { get; public set; }
    public Object[] Keys { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public object Item { get; public set; }
    public IContext InternalUserContext { get; }
    public IInternalContextAdapter BaseContext { get; }
    public EventCartridge EventCartridge { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public InternalContextAdapterImpl(IContext c);
    public sealed virtual string get_CurrentTemplateName();
    public sealed virtual Object[] get_TemplateNameStack();
    public sealed virtual Resource get_CurrentResource();
    public sealed virtual void set_CurrentResource(Resource value);
    public sealed virtual Object[] get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    public sealed virtual ICollection get_Values();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual IContext get_InternalUserContext();
    public sealed virtual IInternalContextAdapter get_BaseContext();
    public sealed virtual EventCartridge get_EventCartridge();
    public sealed virtual void PushCurrentTemplateName(string s);
    public sealed virtual void PopCurrentTemplateName();
    public sealed virtual IntrospectionCacheData ICacheGet(object key);
    public sealed virtual void ICachePut(object key, IntrospectionCacheData o);
    public sealed virtual object Put(string key, object value);
    public sealed virtual object Get(string key);
    public sealed virtual bool ContainsKey(object key);
    public sealed virtual object Remove(object key);
    public sealed virtual EventCartridge AttachEventCartridge(EventCartridge eventCartridge);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool Contains(object key);
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private InternalContextAdapterImplEnumerator CreateEnumerator();
}
public class NVelocity.Context.InternalContextAdapterImplEnumerator : object {
    private int index;
    private IContext context;
    private Object[] keys;
    public object Key { get; }
    public object Value { get; }
    public DictionaryEntry Entry { get; }
    public object Current { get; }
    public InternalContextAdapterImplEnumerator(IContext context);
    public sealed virtual object get_Key();
    public sealed virtual object get_Value();
    public sealed virtual DictionaryEntry get_Entry();
    public sealed virtual void Reset();
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
}
public class NVelocity.Context.InternalContextBase : object {
    private HybridDictionary introspectionCache;
    private Stack`1<string> templateNameStack;
    private EventCartridge eventCartridge;
    private Resource currentResource;
    public string CurrentTemplateName { get; }
    public Object[] TemplateNameStack { get; }
    public Resource CurrentResource { get; public set; }
    public EventCartridge EventCartridge { get; }
    public sealed virtual string get_CurrentTemplateName();
    public sealed virtual Object[] get_TemplateNameStack();
    public sealed virtual Resource get_CurrentResource();
    public sealed virtual void set_CurrentResource(Resource value);
    public sealed virtual EventCartridge get_EventCartridge();
    public sealed virtual void PushCurrentTemplateName(string s);
    public sealed virtual void PopCurrentTemplateName();
    public sealed virtual IntrospectionCacheData ICacheGet(object key);
    public sealed virtual void ICachePut(object key, IntrospectionCacheData o);
    public sealed virtual EventCartridge AttachEventCartridge(EventCartridge eventCartridge);
}
[DefaultMemberAttribute("Item")]
public class NVelocity.Context.VMContext : object {
    internal Hashtable vmProxyHash;
    internal Hashtable localContext;
    internal IInternalContextAdapter innerContext;
    internal IInternalContextAdapter wrappedContext;
    private bool localContextScope;
    public IContext InternalUserContext { get; }
    public IInternalContextAdapter BaseContext { get; }
    public Object[] Keys { get; }
    public int Count { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public object Item { get; public set; }
    public string CurrentTemplateName { get; }
    public Object[] TemplateNameStack { get; }
    public EventCartridge EventCartridge { get; }
    public Resource CurrentResource { get; public set; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public VMContext(IInternalContextAdapter inner, IRuntimeServices runtimeServices);
    private void InitBlock();
    public sealed virtual IContext get_InternalUserContext();
    public sealed virtual IInternalContextAdapter get_BaseContext();
    public sealed virtual Object[] get_Keys();
    public sealed virtual int get_Count();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    public sealed virtual ICollection get_Values();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual string get_CurrentTemplateName();
    public sealed virtual Object[] get_TemplateNameStack();
    public sealed virtual EventCartridge get_EventCartridge();
    public sealed virtual Resource get_CurrentResource();
    public sealed virtual void set_CurrentResource(Resource value);
    public void AddVMProxyArg(VMProxyArg vmpa);
    public sealed virtual object Put(string key, object value);
    public sealed virtual object Get(string key);
    public sealed virtual bool ContainsKey(object key);
    public sealed virtual object Remove(object key);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    public sealed virtual void PushCurrentTemplateName(string s);
    public sealed virtual void PopCurrentTemplateName();
    public sealed virtual IntrospectionCacheData ICacheGet(object key);
    public sealed virtual void ICachePut(object key, IntrospectionCacheData o);
    public sealed virtual EventCartridge AttachEventCartridge(EventCartridge eventCartridge);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool Contains(object key);
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class NVelocity.Exception.MethodInvocationException : VelocityException {
    private string methodName;
    private string referenceName;
    public string MethodName { get; }
    public string ReferenceName { get; public set; }
    public MethodInvocationException(string message, Exception innerException, string methodName);
    protected MethodInvocationException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_MethodName();
    public string get_ReferenceName();
    public void set_ReferenceName(string value);
}
public class NVelocity.Exception.ParseErrorException : VelocityException {
    public ParseErrorException(string exceptionMessage);
    public ParseErrorException(string exceptionMessage, Exception innerException);
    protected ParseErrorException(SerializationInfo info, StreamingContext context);
}
public class NVelocity.Exception.ResourceNotFoundException : VelocityException {
    public ResourceNotFoundException(string exceptionMessage);
    public ResourceNotFoundException(string message, Exception innerException);
    public ResourceNotFoundException(SerializationInfo info, StreamingContext context);
}
public class NVelocity.Exception.VelocityException : Exception {
    public VelocityException(string exceptionMessage);
    public VelocityException(string message, Exception innerException);
    protected VelocityException(SerializationInfo info, StreamingContext context);
}
public interface NVelocity.IDuck {
    public abstract virtual object GetInvoke(string propName);
    public abstract virtual void SetInvoke(string propName, object value);
    public abstract virtual object Invoke(string method, Object[] args);
}
public abstract class NVelocity.Runtime.Directive.AbstractForeachSection : Directive {
    public string Name { get; public set; }
    public bool AcceptParams { get; }
    public DirectiveType Type { get; }
    public ForeachSectionEnum Section { get; }
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual bool get_AcceptParams();
    public virtual DirectiveType get_Type();
    public virtual bool Render(IInternalContextAdapter context, TextWriter writer, INode node);
    public abstract virtual ForeachSectionEnum get_Section();
}
public class NVelocity.Runtime.Directive.BlockComponent : Directive {
    public string Name { get; public set; }
    public DirectiveType Type { get; }
    public virtual bool Render(IInternalContextAdapter context, TextWriter writer, INode node);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual DirectiveType get_Type();
}
public class NVelocity.Runtime.Directive.Component : Directive {
    public string Name { get; public set; }
    public DirectiveType Type { get; }
    public virtual bool Render(IInternalContextAdapter context, TextWriter writer, INode node);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual DirectiveType get_Type();
}
public abstract class NVelocity.Runtime.Directive.Directive : object {
    protected internal IRuntimeServices runtimeServices;
    private int line;
    private int column;
    public string Name { get; public set; }
    public DirectiveType Type { get; }
    public int Line { get; }
    public int Column { get; }
    public bool AcceptParams { get; }
    public virtual void Init(IRuntimeServices rs, IInternalContextAdapter context, INode node);
    public virtual bool SupportsNestedDirective(string name);
    public virtual Directive CreateNestedDirective(string name);
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual DirectiveType get_Type();
    public int get_Line();
    public int get_Column();
    public void SetLocation(int line, int column);
    public virtual bool get_AcceptParams();
    public abstract virtual bool Render(IInternalContextAdapter context, TextWriter writer, INode node);
}
public class NVelocity.Runtime.Directive.DirectiveManager : object {
    private IDictionary name2Type;
    public virtual void Register(string directiveTypeName);
    public virtual Directive Create(string name, Stack directiveStack);
    public virtual bool Contains(string name);
}
public enum NVelocity.Runtime.Directive.DirectiveType : Enum {
    public int value__;
    public static DirectiveType BLOCK;
    public static DirectiveType LINE;
}
public class NVelocity.Runtime.Directive.Foreach : Directive {
    private static String[] SectionNames;
    private string counterName;
    private int counterInitialValue;
    private string elementKey;
    public string Name { get; public set; }
    public DirectiveType Type { get; }
    private static Foreach();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual DirectiveType get_Type();
    public virtual bool SupportsNestedDirective(string name);
    public virtual Directive CreateNestedDirective(string name);
    public virtual void Init(IRuntimeServices rs, IInternalContextAdapter context, INode node);
    private IEnumerator GetIterator(IInternalContextAdapter context, INode node);
    public virtual bool Render(IInternalContextAdapter context, TextWriter writer, INode node);
    private void ProcessSection(ForeachSectionEnum sectionEnumType, INode[][] sections, IInternalContextAdapter context, TextWriter writer);
    private INode[][] PrepareSections(INode node);
}
public class NVelocity.Runtime.Directive.ForeachAfterAllSection : AbstractForeachSection {
    public ForeachSectionEnum Section { get; }
    public virtual ForeachSectionEnum get_Section();
}
public class NVelocity.Runtime.Directive.ForeachAfterSection : AbstractForeachSection {
    public ForeachSectionEnum Section { get; }
    public virtual ForeachSectionEnum get_Section();
}
public class NVelocity.Runtime.Directive.ForeachBeforeAllSection : AbstractForeachSection {
    public ForeachSectionEnum Section { get; }
    public virtual ForeachSectionEnum get_Section();
}
public class NVelocity.Runtime.Directive.ForeachBeforeSection : AbstractForeachSection {
    public ForeachSectionEnum Section { get; }
    public virtual ForeachSectionEnum get_Section();
}
public class NVelocity.Runtime.Directive.ForeachBetweenSection : AbstractForeachSection {
    public ForeachSectionEnum Section { get; }
    public virtual ForeachSectionEnum get_Section();
}
public class NVelocity.Runtime.Directive.ForeachEachSection : AbstractForeachSection {
    public ForeachSectionEnum Section { get; }
    public virtual ForeachSectionEnum get_Section();
}
public class NVelocity.Runtime.Directive.ForeachEvenSection : AbstractForeachSection {
    public ForeachSectionEnum Section { get; }
    public virtual ForeachSectionEnum get_Section();
}
public class NVelocity.Runtime.Directive.ForeachNoDataSection : AbstractForeachSection {
    public ForeachSectionEnum Section { get; }
    public virtual ForeachSectionEnum get_Section();
}
public class NVelocity.Runtime.Directive.ForeachOddSection : AbstractForeachSection {
    public ForeachSectionEnum Section { get; }
    public virtual ForeachSectionEnum get_Section();
}
public enum NVelocity.Runtime.Directive.ForeachSectionEnum : Enum {
    public int value__;
    public static ForeachSectionEnum Each;
    public static ForeachSectionEnum Between;
    public static ForeachSectionEnum Odd;
    public static ForeachSectionEnum Even;
    public static ForeachSectionEnum NoData;
    public static ForeachSectionEnum BeforeAll;
    public static ForeachSectionEnum AfterAll;
    public static ForeachSectionEnum Before;
    public static ForeachSectionEnum After;
}
public interface NVelocity.Runtime.Directive.IDirectiveManager {
    public abstract virtual void Register(string directiveTypeName);
    public abstract virtual Directive Create(string name, Stack directiveStack);
    public abstract virtual bool Contains(string name);
}
public interface NVelocity.Runtime.Directive.IForeachSection {
    public ForeachSectionEnum Section { get; }
    public abstract virtual ForeachSectionEnum get_Section();
}
public class NVelocity.Runtime.Directive.Include : Directive {
    private string outputMsgStart;
    private string outputMsgEnd;
    public string Name { get; public set; }
    public DirectiveType Type { get; }
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual DirectiveType get_Type();
    public virtual void Init(IRuntimeServices rs, IInternalContextAdapter context, INode node);
    public virtual bool Render(IInternalContextAdapter context, TextWriter writer, INode node);
    private bool RenderOutput(INode node, IInternalContextAdapter context, TextWriter writer);
    private void OutputErrorToStream(TextWriter writer, string msg);
}
public class NVelocity.Runtime.Directive.Literal : Directive {
    internal string literalText;
    public string Name { get; public set; }
    public DirectiveType Type { get; }
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual DirectiveType get_Type();
    public virtual void Init(IRuntimeServices rs, IInternalContextAdapter context, INode node);
    public virtual bool Render(IInternalContextAdapter context, TextWriter writer, INode node);
}
public class NVelocity.Runtime.Directive.Macro : Directive {
    public string Name { get; public set; }
    public DirectiveType Type { get; }
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual DirectiveType get_Type();
    public virtual bool Render(IInternalContextAdapter context, TextWriter writer, INode node);
    public static void processAndRegister(IRuntimeServices rs, INode node, string sourceTemplate);
    private static String[] getArgArray(INode node);
    private static IList getASTAsStringArray(INode rootNode);
}
public class NVelocity.Runtime.Directive.Parse : Directive {
    public string Name { get; public set; }
    public DirectiveType Type { get; }
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual DirectiveType get_Type();
    public virtual bool Render(IInternalContextAdapter context, TextWriter writer, INode node);
    private bool AssertArgument(INode node);
    private bool AssertNodeHasValue(INode node, IInternalContextAdapter context, Object& value);
    private bool AssertTemplateStack(IInternalContextAdapter context);
    private Template GetTemplate(string arg, string encoding, IInternalContextAdapter context);
    private bool RenderTemplate(Template template, string arg, TextWriter writer, IInternalContextAdapter context);
}
public class NVelocity.Runtime.Directive.ParseDirectiveException : Exception {
    private Stack filenameStack;
    private string msg;
    private int depthCount;
    public string Message { get; }
    internal ParseDirectiveException(string m, int i);
    private void InitBlock();
    public virtual string get_Message();
    public void addFile(string s);
}
public class NVelocity.Runtime.Directive.VelocimacroProxy : Directive {
    private string macroName;
    private string macroBody;
    private String[] argArray;
    private SimpleNode nodeTree;
    private int numMacroArgs;
    private string ns;
    private bool init;
    private String[] callingArgs;
    private Int32[] callingArgTypes;
    private Hashtable proxyArgHash;
    public string Name { get; public set; }
    public DirectiveType Type { get; }
    unknown String[] ArgArray {public set; }
    unknown SimpleNode NodeTree {public set; }
    public int NumArgs { get; }
    unknown string MacroBody {public set; }
    unknown string Namespace {public set; }
    public virtual void Init(IRuntimeServices rs, IInternalContextAdapter context, INode node);
    public virtual bool Render(IInternalContextAdapter context, TextWriter writer, INode node);
    public bool setupMacro(String[] callArgs, Int32[] callArgTypes);
    private void parseTree(String[] callArgs);
    private void setupProxyArgs(String[] callArgs, Int32[] callArgTypes);
    private String[] getArgArray(INode node);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual DirectiveType get_Type();
    public void set_ArgArray(String[] value);
    public void set_NodeTree(SimpleNode value);
    public int get_NumArgs();
    public void set_MacroBody(string value);
    public void set_Namespace(string value);
}
public class NVelocity.Runtime.Directive.VMProxyArg : object {
    private static int GENERALSTATIC;
    private int type;
    private SimpleNode nodeTree;
    private object staticObject;
    private IInternalContextAdapter userContext;
    private int numTreeChildren;
    private string contextReference;
    private string callerReference;
    private string singleLevelRef;
    private bool constant;
    private IRuntimeServices runtimeServices;
    public string CallerReference { get; }
    public string ContextReference { get; }
    public SimpleNode NodeTree { get; }
    public object StaticObject { get; }
    public int Type { get; }
    public VMProxyArg(IRuntimeServices rs, string contextRef, string callerRef, int t);
    public VMProxyArg(VMProxyArg model, IInternalContextAdapter c);
    public string get_CallerReference();
    public string get_ContextReference();
    public SimpleNode get_NodeTree();
    public object get_StaticObject();
    public int get_Type();
    public bool isConstant();
    public object setObject(IInternalContextAdapter context, object o);
    public object getObject(IInternalContextAdapter context);
    private void setup();
}
public class NVelocity.Runtime.Exception.NodeException : Exception {
    public NodeException(string exceptionMessage, INode node);
    public NodeException(SerializationInfo info, StreamingContext context);
}
public class NVelocity.Runtime.Exception.ReferenceException : Exception {
    public ReferenceException(string exceptionMessage, INode node);
    public ReferenceException(SerializationInfo info, StreamingContext context);
}
public interface NVelocity.Runtime.IRuntimeLogger {
    public abstract virtual void Warn(object message);
    public abstract virtual void Info(object message);
    public abstract virtual void Error(object message);
    public abstract virtual void Debug(object message);
}
public interface NVelocity.Runtime.IRuntimeServices {
    public ExtendedProperties Configuration { get; public set; }
    public IUberspect Uberspect { get; }
    public Introspector Introspector { get; }
    public abstract virtual ExtendedProperties get_Configuration();
    public abstract virtual void set_Configuration(ExtendedProperties value);
    public abstract virtual IUberspect get_Uberspect();
    public abstract virtual Introspector get_Introspector();
    public abstract virtual void Init();
    public abstract virtual void SetProperty(string key, object value);
    public abstract virtual void AddProperty(string key, object value);
    public abstract virtual void ClearProperty(string key);
    public abstract virtual object GetProperty(string key);
    public abstract virtual void Init(string configurationFile);
    public abstract virtual SimpleNode Parse(TextReader reader, string templateName);
    public abstract virtual SimpleNode Parse(TextReader reader, string templateName, bool dumpNamespace);
    public abstract virtual Template GetTemplate(string name);
    public abstract virtual Template GetTemplate(string name, string encoding);
    public abstract virtual ContentResource GetContent(string name);
    public abstract virtual ContentResource GetContent(string name, string encoding);
    public abstract virtual string GetLoaderNameForResource(string resourceName);
    public abstract virtual string GetString(string key, string defaultValue);
    public abstract virtual Directive GetVelocimacro(string vmName, string templateName);
    public abstract virtual bool AddVelocimacro(string name, string macro, String[] argArray, string sourceTemplate);
    public abstract virtual bool IsVelocimacro(string vmName, string templateName);
    public abstract virtual bool DumpVMNamespace(string ns);
    public abstract virtual string GetString(string key);
    public abstract virtual int GetInt(string key);
    public abstract virtual int GetInt(string key, int defaultValue);
    public abstract virtual bool GetBoolean(string key, bool def);
    public abstract virtual object GetApplicationAttribute(object key);
    public abstract virtual object SetApplicationAttribute(object key, object value);
}
public interface NVelocity.Runtime.Log.ILogSystem {
    public abstract virtual void Init(IRuntimeServices rs);
    public abstract virtual void LogVelocityMessage(LogLevel level, string message);
}
public enum NVelocity.Runtime.Log.LogLevel : Enum {
    public int value__;
    public static LogLevel Debug;
    public static LogLevel Info;
    public static LogLevel Warn;
    public static LogLevel Error;
}
public class NVelocity.Runtime.Log.LogManager : object {
    public static ILogSystem CreateLogSystem(IRuntimeServices runtimeServices);
}
public class NVelocity.Runtime.Log.NullLogSystem : object {
    public sealed virtual void Init(IRuntimeServices rs);
    public sealed virtual void LogVelocityMessage(LogLevel level, string message);
}
public interface NVelocity.Runtime.Parser.ICharStream {
    public char CurrentCharacter { get; }
    public int Column { get; }
    public int Line { get; }
    public int EndColumn { get; }
    public int EndLine { get; }
    public int BeginColumn { get; }
    public int BeginLine { get; }
    public abstract virtual char get_CurrentCharacter();
    public abstract virtual bool ReadChar();
    public abstract virtual void Backup(int amount);
    public abstract virtual bool BeginToken();
    public abstract virtual string GetImage();
    public abstract virtual Char[] GetSuffix(int len);
    public abstract virtual void Done();
    public abstract virtual int get_Column();
    public abstract virtual int get_Line();
    public abstract virtual int get_EndColumn();
    public abstract virtual int get_EndLine();
    public abstract virtual int get_BeginColumn();
    public abstract virtual int get_BeginLine();
}
public abstract class NVelocity.Runtime.Parser.Node.AbstractExecutor : object {
    protected internal IRuntimeLogger runtimeLogger;
    protected internal MethodInfo method;
    protected internal PropertyInfo property;
    public bool IsAlive { get; }
    public MethodInfo Method { get; }
    public PropertyInfo Property { get; }
    public abstract virtual object Execute(object o);
    public bool get_IsAlive();
    public MethodInfo get_Method();
    public PropertyInfo get_Property();
}
public class NVelocity.Runtime.Parser.Node.ASTAddNode : SimpleNode {
    public ASTAddNode(int id);
    public ASTAddNode(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual object Value(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTAndNode : SimpleNode {
    public ASTAndNode(int id);
    public ASTAndNode(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual object Value(IInternalContextAdapter context);
    public virtual bool Evaluate(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTAssignment : SimpleNode {
    public ASTAssignment(int id);
    public ASTAssignment(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
}
public class NVelocity.Runtime.Parser.Node.ASTBlock : SimpleNode {
    public ASTBlock(int id);
    public ASTBlock(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual bool Render(IInternalContextAdapter context, TextWriter writer);
}
public class NVelocity.Runtime.Parser.Node.ASTComment : SimpleNode {
    public ASTComment(int id);
    public ASTComment(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
}
public class NVelocity.Runtime.Parser.Node.ASTDirective : SimpleNode {
    private Directive directive;
    private string directiveName;
    public string DirectiveName { get; public set; }
    public Directive Directive { get; public set; }
    public ASTDirective(int id);
    public ASTDirective(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual object Init(IInternalContextAdapter context, object data);
    public virtual bool Render(IInternalContextAdapter context, TextWriter writer);
    public string get_DirectiveName();
    public void set_DirectiveName(string value);
    public Directive get_Directive();
    public void set_Directive(Directive value);
}
public class NVelocity.Runtime.Parser.Node.ASTDivNode : SimpleNode {
    public ASTDivNode(int id);
    public ASTDivNode(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual object Value(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTElseIfStatement : SimpleNode {
    public ASTElseIfStatement(int id);
    public ASTElseIfStatement(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual bool Evaluate(IInternalContextAdapter context);
    public virtual bool Render(IInternalContextAdapter context, TextWriter writer);
}
public class NVelocity.Runtime.Parser.Node.ASTElseStatement : SimpleNode {
    public ASTElseStatement(int id);
    public ASTElseStatement(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual bool Evaluate(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTEQNode : SimpleNode {
    public ASTEQNode(int id);
    public ASTEQNode(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual bool Evaluate(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTEscape : SimpleNode {
    private string text;
    public ASTEscape(int id);
    public ASTEscape(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual object Init(IInternalContextAdapter context, object data);
    public virtual bool Render(IInternalContextAdapter context, TextWriter writer);
}
public class NVelocity.Runtime.Parser.Node.ASTEscapedDirective : SimpleNode {
    public ASTEscapedDirective(int id);
    public ASTEscapedDirective(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual bool Render(IInternalContextAdapter context, TextWriter writer);
}
public class NVelocity.Runtime.Parser.Node.ASTExpression : SimpleNode {
    public ASTExpression(int id);
    public ASTExpression(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual bool Evaluate(IInternalContextAdapter context);
    public virtual object Value(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTFalse : SimpleNode {
    private static bool val;
    public ASTFalse(int id);
    public ASTFalse(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual bool Evaluate(IInternalContextAdapter context);
    public virtual object Value(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTGENode : SimpleNode {
    public ASTGENode(int id);
    public ASTGENode(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual bool Evaluate(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTGTNode : SimpleNode {
    public ASTGTNode(int id);
    public ASTGTNode(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual bool Evaluate(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTIdentifier : SimpleNode {
    private string identifier;
    protected Info uberInfo;
    public ASTIdentifier(int id);
    public ASTIdentifier(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual object Init(IInternalContextAdapter context, object data);
    public virtual object Execute(object o, IInternalContextAdapter context);
    private static string EscapeSingleQuote(string content);
    private static string EscapeDoubleQuote(string content);
}
public class NVelocity.Runtime.Parser.Node.ASTIfStatement : SimpleNode {
    public ASTIfStatement(int id);
    public ASTIfStatement(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual bool Render(IInternalContextAdapter context, TextWriter writer);
    public void Process(IInternalContextAdapter context, IParserVisitor visitor);
}
public class NVelocity.Runtime.Parser.Node.ASTIncludeStatement : SimpleNode {
    public ASTIncludeStatement(int id);
    public ASTIncludeStatement(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
}
public class NVelocity.Runtime.Parser.Node.ASTIntegerRange : SimpleNode {
    public ASTIntegerRange(int id);
    public ASTIntegerRange(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual object Value(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTLENode : SimpleNode {
    public ASTLENode(int id);
    public ASTLENode(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual bool Evaluate(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTLTNode : SimpleNode {
    public ASTLTNode(int id);
    public ASTLTNode(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual bool Evaluate(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTMap : SimpleNode {
    public ASTMap(int id);
    public ASTMap(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual object Value(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTMethod : SimpleNode {
    private string methodName;
    private int paramCount;
    private int paramArrayIndex;
    public ASTMethod(int id);
    public ASTMethod(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual object Init(IInternalContextAdapter context, object data);
    public virtual object Execute(object o, IInternalContextAdapter context);
    private void EvalParameters(Object[] parameters, IInternalContextAdapter context);
    private object PerformIntrospection(IInternalContextAdapter context, Type data, Object[] parameters);
    private static Object[] BuildMethodArgs(MethodInfo method, Object[] parameters, int paramArrayIndex);
    private Object[] BuildMethodArgs(MethodInfo method, Object[] parameters);
}
public class NVelocity.Runtime.Parser.Node.ASTModNode : SimpleNode {
    public ASTModNode(int id);
    public ASTModNode(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual object Value(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTMulNode : SimpleNode {
    public ASTMulNode(int id);
    public ASTMulNode(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual object Value(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTNENode : SimpleNode {
    public ASTNENode(int id);
    public ASTNENode(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual bool Evaluate(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTNotNode : SimpleNode {
    public ASTNotNode(int id);
    public ASTNotNode(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual bool Evaluate(IInternalContextAdapter context);
    public virtual object Value(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTNumberLiteral : SimpleNode {
    private int valueField;
    public ASTNumberLiteral(int id);
    public ASTNumberLiteral(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual object Init(IInternalContextAdapter context, object data);
    public virtual object Value(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTObjectArray : SimpleNode {
    public ASTObjectArray(int id);
    public ASTObjectArray(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual object Value(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTOrNode : SimpleNode {
    public ASTOrNode(int id);
    public ASTOrNode(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual object Value(IInternalContextAdapter context);
    public virtual bool Evaluate(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTParameters : SimpleNode {
    public ASTParameters(int id);
    public ASTParameters(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
}
public class NVelocity.Runtime.Parser.Node.ASTprocess : SimpleNode {
    public ASTprocess(int id);
    public ASTprocess(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
}
public class NVelocity.Runtime.Parser.Node.ASTReference : SimpleNode {
    private ReferenceType referenceType;
    private string nullString;
    private string rootString;
    private bool escaped;
    private bool computableReference;
    private string escPrefix;
    private string morePrefix;
    private string identifier;
    private string literal;
    private Stack referenceStack;
    private int numChildren;
    public string RootString { get; }
    public string Literal { get; }
    private string Root { get; }
    public ASTReference(int id);
    public ASTReference(Parser p, int id);
    public string get_RootString();
    public void SetLiteral(string value);
    public virtual string get_Literal();
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual object Init(IInternalContextAdapter context, object data);
    public virtual object Execute(object o, IInternalContextAdapter context);
    public virtual bool Render(IInternalContextAdapter context, TextWriter writer);
    public virtual bool Evaluate(IInternalContextAdapter context);
    public virtual object Value(IInternalContextAdapter context);
    public bool SetValue(IInternalContextAdapter context, object value);
    public object GetVariableValue(IContext context, string variable);
    private string get_Root();
}
public class NVelocity.Runtime.Parser.Node.ASTSetDirective : SimpleNode {
    private string leftReference;
    private INode right;
    private ASTReference left;
    internal bool blather;
    private ASTReference LeftHandSide { get; }
    private INode RightHandSide { get; }
    public ASTSetDirective(int id);
    public ASTSetDirective(Parser p, int id);
    private ASTReference get_LeftHandSide();
    private INode get_RightHandSide();
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual object Init(IInternalContextAdapter context, object data);
    public virtual bool Render(IInternalContextAdapter context, TextWriter writer);
}
public class NVelocity.Runtime.Parser.Node.ASTStringLiteral : SimpleNode {
    private static string DictStart;
    private static string DictEnd;
    private bool interpolate;
    private SimpleNode nodeTree;
    private string image;
    private string interpolateImage;
    public ASTStringLiteral(int id);
    public ASTStringLiteral(Parser p, int id);
    private static ASTStringLiteral();
    public virtual object Init(IInternalContextAdapter context, object data);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual object Value(IInternalContextAdapter context);
    private HybridDictionary InterpolateDictionaryString(string str, IInternalContextAdapter context);
    private HybridDictionary RecursiveBuildDictionary(Char[] contents, int fromIndex, IInternalContextAdapter context, Int32& lastIndex);
    private void ProcessDictEntry(HybridDictionary map, StringBuilder keyBuilder, object value, IInternalContextAdapter context);
    private void ProcessDictEntry(HybridDictionary map, StringBuilder keyBuilder, StringBuilder value, bool isTextContent, IInternalContextAdapter context);
    private object EvaluateInPlace(string content, IInternalContextAdapter context);
    private object Evaluate(SimpleNode inlineNode, IInternalContextAdapter context);
    private bool IsDictionaryString(string str);
}
public class NVelocity.Runtime.Parser.Node.ASTSubtractNode : SimpleNode {
    public ASTSubtractNode(int id);
    public ASTSubtractNode(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual object Value(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTText : SimpleNode {
    private string text;
    public string Text { get; }
    public ASTText(int id);
    public ASTText(Parser p, int id);
    public string get_Text();
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual object Init(IInternalContextAdapter context, object data);
    public virtual bool Render(IInternalContextAdapter context, TextWriter writer);
}
public class NVelocity.Runtime.Parser.Node.ASTTrue : SimpleNode {
    private static bool val;
    public ASTTrue(int id);
    public ASTTrue(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
    public virtual bool Evaluate(IInternalContextAdapter context);
    public virtual object Value(IInternalContextAdapter context);
}
public class NVelocity.Runtime.Parser.Node.ASTVariable : SimpleNode {
    public ASTVariable(int id);
    public ASTVariable(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
}
public class NVelocity.Runtime.Parser.Node.ASTWord : SimpleNode {
    public ASTWord(int id);
    public ASTWord(Parser p, int id);
    public virtual object Accept(IParserVisitor visitor, object data);
}
public class NVelocity.Runtime.Parser.Node.BooleanPropertyExecutor : PropertyExecutor {
    public BooleanPropertyExecutor(IRuntimeLogger r, Introspector i, Type type, string propertyName);
    protected internal virtual void Discover(Type type, string propertyName);
}
public class NVelocity.Runtime.Parser.Node.GetExecutor : AbstractExecutor {
    private Object[] arguments;
    public GetExecutor(IRuntimeLogger r, Introspector i, Type c, string key);
    public virtual object Execute(object o);
}
public interface NVelocity.Runtime.Parser.Node.INode {
    public Token FirstToken { get; }
    public Token LastToken { get; }
    public int Type { get; }
    public int Info { get; public set; }
    public int Line { get; }
    public int Column { get; }
    public INode Parent { get; public set; }
    public int ChildrenCount { get; }
    public string Literal { get; }
    public bool IsInvalid { get; public set; }
    public abstract virtual Token get_FirstToken();
    public abstract virtual Token get_LastToken();
    public abstract virtual int get_Type();
    public abstract virtual int get_Info();
    public abstract virtual void set_Info(int value);
    public abstract virtual int get_Line();
    public abstract virtual int get_Column();
    public abstract virtual void Open();
    public abstract virtual void Close();
    public abstract virtual void set_Parent(INode value);
    public abstract virtual INode get_Parent();
    public abstract virtual void AddChild(INode n, int i);
    public abstract virtual INode GetChild(int i);
    public abstract virtual int get_ChildrenCount();
    public abstract virtual object Accept(IParserVisitor visitor, object data);
    public abstract virtual object ChildrenAccept(IParserVisitor visitor, object data);
    public abstract virtual object Init(IInternalContextAdapter context, object data);
    public abstract virtual bool Evaluate(IInternalContextAdapter context);
    public abstract virtual object Value(IInternalContextAdapter context);
    public abstract virtual bool Render(IInternalContextAdapter context, TextWriter writer);
    public abstract virtual object Execute(object o, IInternalContextAdapter context);
    public abstract virtual string get_Literal();
    public abstract virtual bool get_IsInvalid();
    public abstract virtual void set_IsInvalid(bool value);
}
public interface NVelocity.Runtime.Parser.Node.IParserVisitor {
    public abstract virtual object Visit(SimpleNode node, object data);
    public abstract virtual object Visit(ASTprocess node, object data);
    public abstract virtual object Visit(ASTComment node, object data);
    public abstract virtual object Visit(ASTNumberLiteral node, object data);
    public abstract virtual object Visit(ASTStringLiteral node, object data);
    public abstract virtual object Visit(ASTIdentifier node, object data);
    public abstract virtual object Visit(ASTWord node, object data);
    public abstract virtual object Visit(ASTDirective node, object data);
    public abstract virtual object Visit(ASTBlock node, object data);
    public abstract virtual object Visit(ASTObjectArray node, object data);
    public abstract virtual object Visit(ASTMethod node, object data);
    public abstract virtual object Visit(ASTReference node, object data);
    public abstract virtual object Visit(ASTTrue node, object data);
    public abstract virtual object Visit(ASTFalse node, object data);
    public abstract virtual object Visit(ASTText node, object data);
    public abstract virtual object Visit(ASTIfStatement node, object data);
    public abstract virtual object Visit(ASTElseStatement node, object data);
    public abstract virtual object Visit(ASTElseIfStatement node, object data);
    public abstract virtual object Visit(ASTSetDirective node, object data);
    public abstract virtual object Visit(ASTExpression node, object data);
    public abstract virtual object Visit(ASTAssignment node, object data);
    public abstract virtual object Visit(ASTOrNode node, object data);
    public abstract virtual object Visit(ASTAndNode node, object data);
    public abstract virtual object Visit(ASTEQNode node, object data);
    public abstract virtual object Visit(ASTNENode node, object data);
    public abstract virtual object Visit(ASTLTNode node, object data);
    public abstract virtual object Visit(ASTGTNode node, object data);
    public abstract virtual object Visit(ASTLENode node, object data);
    public abstract virtual object Visit(ASTGENode node, object data);
    public abstract virtual object Visit(ASTAddNode node, object data);
    public abstract virtual object Visit(ASTSubtractNode node, object data);
    public abstract virtual object Visit(ASTMulNode node, object data);
    public abstract virtual object Visit(ASTDivNode node, object data);
    public abstract virtual object Visit(ASTModNode node, object data);
    public abstract virtual object Visit(ASTNotNode node, object data);
}
public class NVelocity.Runtime.Parser.Node.MathUtil : object {
    public static object Add(Type maxType, object left, object right);
    public static object Mult(Type maxType, object left, object right);
    public static object Div(Type maxType, object left, object right);
    public static object Mod(Type maxType, object left, object right);
    public static object Sub(Type maxType, object left, object right);
    public static Type ToMaxType(Type leftType, Type rightType);
}
public class NVelocity.Runtime.Parser.Node.NodeUtils : object {
    public static string specialText(Token t);
    public static string tokenLiteral(Token t);
    public static string interpolate(string argStr, IContext vars);
}
public class NVelocity.Runtime.Parser.Node.ObjectComparer : object {
    public static int Smaller;
    public static int Equal;
    public static int Greater;
    private static IDictionary comparers;
    private static ObjectComparer instance;
    private static ObjectComparer();
    public static int CompareObjects(object x, object y);
    public sealed virtual int Compare(object x, object y);
    public int ComparePrimitive(object x, object y);
    public object ReType(object value);
}
public class NVelocity.Runtime.Parser.Node.PropertyExecutor : AbstractExecutor {
    private string propertyUsed;
    protected Introspector introspector;
    public PropertyExecutor(IRuntimeLogger r, Introspector i, Type type, string propertyName);
    protected internal virtual void Discover(Type type, string propertyName);
    public virtual object Execute(object o);
}
internal enum NVelocity.Runtime.Parser.Node.ReferenceType : Enum {
    public int value__;
    public static ReferenceType Normal;
    public static ReferenceType Formal;
    public static ReferenceType Quiet;
    public static ReferenceType Runt;
}
public class NVelocity.Runtime.Parser.Node.SimpleNode : object {
    protected internal IRuntimeServices runtimeServices;
    protected internal INode parent;
    protected internal INode[] children;
    protected internal int id;
    protected internal Parser parser;
    protected internal int info;
    public bool state;
    protected internal bool invalid;
    protected internal Token first;
    protected internal Token last;
    public Token FirstToken { get; public set; }
    public Token LastToken { get; }
    public int Type { get; }
    public int Info { get; public set; }
    public int Line { get; }
    public int Column { get; }
    public INode Parent { get; public set; }
    public int ChildrenCount { get; }
    public string Literal { get; }
    public bool IsInvalid { get; public set; }
    public SimpleNode(int i);
    public SimpleNode(Parser p, int i);
    public sealed virtual Token get_FirstToken();
    public void set_FirstToken(Token value);
    public sealed virtual Token get_LastToken();
    public sealed virtual int get_Type();
    public sealed virtual int get_Info();
    public sealed virtual void set_Info(int value);
    public sealed virtual int get_Line();
    public sealed virtual int get_Column();
    public sealed virtual void Open();
    public sealed virtual void Close();
    public sealed virtual void set_Parent(INode value);
    public sealed virtual INode get_Parent();
    public sealed virtual void AddChild(INode n, int i);
    public sealed virtual INode GetChild(int i);
    public sealed virtual int get_ChildrenCount();
    public virtual object Accept(IParserVisitor visitor, object data);
    public sealed virtual object ChildrenAccept(IParserVisitor visitor, object data);
    public string ToString(string prefix);
    public void Dump(string prefix);
    public virtual string get_Literal();
    public virtual object Init(IInternalContextAdapter context, object data);
    public virtual bool Evaluate(IInternalContextAdapter context);
    public virtual object Value(IInternalContextAdapter context);
    public virtual bool Render(IInternalContextAdapter context, TextWriter writer);
    public virtual object Execute(object o, IInternalContextAdapter context);
    public sealed virtual bool get_IsInvalid();
    public sealed virtual void set_IsInvalid(bool value);
}
public class NVelocity.Runtime.Parser.ParseException : Exception {
    protected internal string eol;
    protected internal bool specialConstructor;
    public Token currentToken;
    public Int32[][] expectedTokenSequences;
    public String[] tokenImage;
    public string Message { get; }
    public ParseException(Token currentTokenVal, Int32[][] expectedTokenSequencesVal, String[] tokenImageVal);
    public ParseException(string message);
    public virtual string get_Message();
    protected internal static string AddEscapes(string str);
}
public class NVelocity.Runtime.Parser.Parser : object {
    public ParserTokenManager token_source;
    public Token token;
    public Token jj_nt;
    private int jj_ntk_Renamed_Field;
    private Token jj_scanpos;
    private Token jj_lastpos;
    private int jj_la;
    public bool lookingAhead;
    private int jj_gen;
    private Int32[] jj_la1;
    private Int32[] jj_la1_0;
    private Int32[] jj_la1_1;
    private Calls[] callsArray;
    private bool jj_rescan;
    private int jj_gc;
    private ArrayList expEntries;
    private Int32[] jj_expEntry;
    private int jj_kind;
    private Int32[] lastTokens;
    private int endPosition;
    internal ParserState nodeTree;
    private IDirectiveManager directives;
    internal string currentTemplateName;
    internal VelocityCharStream velcharstream;
    private IRuntimeServices runtimeServices;
    protected Stack directiveStack;
    unknown IDirectiveManager Directives {public set; }
    public Token NextToken { get; }
    public Parser(IRuntimeServices rs);
    public Parser(ICharStream stream);
    public Parser(ParserTokenManager tm);
    private void InitBlock();
    public void set_Directives(IDirectiveManager value);
    public Token get_NextToken();
    public SimpleNode Parse(TextReader reader, string templateName);
    public bool IsDirective(string directive);
    private string EscapedDirective(string strImage);
    public SimpleNode Process();
    public void Statement();
    public void EscapedDirective();
    public void Escape();
    public void Comment();
    public void NumberLiteral();
    public void StringLiteral();
    public void Identifier();
    public void Word();
    public void DirectiveArg();
    public SimpleNode Directive();
    private int GetCurrentTokenKind();
    private void ConsumeWhiteSpaces();
    public void ObjectArray();
    public void IntegerRange();
    public void Parameter();
    public void Method();
    public void Reference();
    public void True();
    public void False();
    public void Text();
    public void IfStatement();
    public void ElseStatement();
    public void ElseIfStatement();
    public void SetDirective();
    public void StopStatement();
    public void Expression();
    public void Assignment();
    public void ConditionalOrExpression();
    public void ConditionalAndExpression();
    public void EqualityExpression();
    public void RelationalExpression();
    public void AdditiveExpression();
    public void MultiplicativeExpression();
    public void UnaryExpression();
    public void PrimaryExpression();
    private bool jj_3R_52();
    private bool jj_2_1(int xla);
    private bool jj_2_2(int xla);
    private bool jj_2_3(int xla);
    private bool jj_2_4(int xla);
    private bool jj_2_5(int xla);
    private bool jj_2_6(int xla);
    private bool jj_2_7(int xla);
    private bool jj_2_8(int xla);
    private bool jj_2_9(int xla);
    private bool jj_2_10(int xla);
    private bool jj_2_11(int xla);
    private bool jj_2_12(int xla);
    private bool jj_3R_58();
    private bool jj_3R_42();
    private bool jj_3_7();
    private bool jj_3R_39();
    private bool jj_3_12();
    private bool jj_3R_38();
    private bool jj_3R_19();
    private bool jj_3R_41();
    private bool jj_3R_50(bool b);
    private bool jj_3_4();
    private bool jj_3R_29();
    private bool jj_3R_31();
    private bool jj_3R_33();
    private bool jj_3_11();
    private bool jj_3R_101();
    private bool jj_3R_55();
    private bool jj_3R_40();
    private bool jj_3R_95();
    private bool jj_3R_54();
    private bool jj_3R_96();
    private bool jj_3R_91();
    private bool jj_3R_100(int ge, bool r_91);
    private bool jj_3R_51();
    private bool jj_3R_77();
    private bool jj_3R_92();
    private bool jj_3R_56();
    private bool jj_3R_89();
    private bool jj_3R_90();
    private bool jj_3R_57();
    private bool jj_3R_86();
    private bool jj_3R_84();
    private bool jj_3_2();
    private bool jj_3_10();
    private bool ToRefactor1();
    private bool jj_3R_82();
    private bool jj_3R_81();
    private bool jj_3R_60();
    private bool jj_3_3();
    private bool jj_3R_59();
    public void ReInit(ICharStream stream);
    public void ReInit(ParserTokenManager tm);
    private Token ConsumeToken(int kind);
    private int jj_ntk();
    private bool ScanToken(int kind);
    public Token GetToken(int index);
    private void AddErrorToken(int kind, int position);
    public ParseException GenerateParseException();
    private void RescanToken();
    private void Save(int index, int xla);
}
public class NVelocity.Runtime.Parser.ParserConstants : object {
    public static int EOF;
    public static int LBRACKET;
    public static int RBRACKET;
    public static int COMMA;
    public static int DOUBLEDOT;
    public static int LPAREN;
    public static int RPAREN;
    public static int REFMOD2_RPAREN;
    public static int ESCAPE_DIRECTIVE;
    public static int SET_DIRECTIVE;
    public static int DOLLAR;
    public static int DOLLARBANG;
    public static int HASH;
    public static int DOUBLE_ESCAPE;
    public static int ESCAPE;
    public static int TEXT;
    public static int SINGLE_LINE_COMMENT;
    public static int FORMAL_COMMENT;
    public static int MULTI_LINE_COMMENT;
    public static int WHITESPACE;
    public static int STRING_LITERAL;
    public static int TRUE;
    public static int FALSE;
    public static int NEWLINE;
    public static int MINUS;
    public static int PLUS;
    public static int MULTIPLY;
    public static int DIVIDE;
    public static int MODULUS;
    public static int LOGICAL_AND;
    public static int LOGICAL_OR;
    public static int LOGICAL_LT;
    public static int LOGICAL_LE;
    public static int LOGICAL_GT;
    public static int LOGICAL_GE;
    public static int LOGICAL_EQUALS;
    public static int LOGICAL_NOT_EQUALS;
    public static int LOGICAL_NOT;
    public static int EQUALS;
    public static int END;
    public static int IF_DIRECTIVE;
    public static int ELSEIF_DIRECTIVE;
    public static int ELSE_DIRECTIVE;
    public static int STOP_DIRECTIVE;
    public static int DIGIT;
    public static int NUMBER_LITERAL;
    public static int LETTER;
    public static int DIRECTIVE_CHAR;
    public static int WORD;
    public static int ALPHA_CHAR;
    public static int ALPHANUM_CHAR;
    public static int IDENTIFIER_CHAR;
    public static int IDENTIFIER;
    public static int DOT;
    public static int LCURLY;
    public static int RCURLY;
    public static int REFERENCE_TERMINATOR;
    public static int DIRECTIVE_TERMINATOR;
    public static int DIRECTIVE;
    public static int REFMOD2;
    public static int REFMODIFIER;
    public static int DEFAULT;
    public static int PRE_DIRECTIVE;
    public static int REFERENCE;
    public static int IN_MULTI_LINE_COMMENT;
    public static int IN_FORMAL_COMMENT;
    public static int IN_SINGLE_LINE_COMMENT;
    public static String[] TokenImage;
    private static ParserConstants();
}
internal class NVelocity.Runtime.Parser.ParserState : object {
    private Stack`1<INode> nodes;
    private Stack`1<int> marks;
    private int mark;
    private bool nodeCreated;
    internal INode RootNode { get; }
    internal bool NodeCreated();
    internal void Reset();
    internal INode get_RootNode();
    internal void PushNode(INode n);
    internal INode PopNode();
    internal INode PeekNode();
    internal int NodeArity();
    internal void ClearNodeScope(INode n);
    internal void OpenNodeScope(INode node);
    internal void CloseNodeScope(INode parentNode, int num);
    internal void CloseNodeScope(INode n, bool condition);
}
public class NVelocity.Runtime.Parser.ParserTokenManager : ParserConstants {
    private int lparen;
    private int rparen;
    private Stack`1<Dictionary`2<string, int>> stateStack;
    public bool debugPrint;
    public bool inDirective;
    private bool inComment;
    public bool inSet;
    public TextWriter debugStream;
    private static UInt64[] jjbitVec0;
    private static UInt64[] jjbitVec2;
    private static Int32[] jjnextStates;
    public static String[] jjstrLiteralImages;
    public static String[] lexStateNames;
    public static Int32[] jjnewLexState;
    private static Int64[] jjtoToken;
    private static Int64[] jjtoSkip;
    private static Int64[] jjtoSpecial;
    private ICharStream input_stream;
    private UInt32[] jjrounds;
    private UInt32[] jjstateSet;
    private StringBuilder image;
    private int jjimageLen;
    private int curLexState;
    private int defaultLexState;
    private int jjnewStateCnt;
    private UInt32 jjround;
    private int jjmatchedPos;
    private int jjmatchedKind;
    public Token NextToken { get; }
    public ParserTokenManager(ICharStream stream);
    public ParserTokenManager(ICharStream stream, int lexState);
    private static ParserTokenManager();
    public bool StateStackPop();
    public bool StateStackPush();
    public void ClearStateVars();
    private void RPARENHandler();
    public void SetDebugStream(StreamWriter ds);
    private int jjStopStringLiteralDfa_0(int pos, long active0);
    private int jjStartNfa_0(int pos, long active0);
    private int jjStopAtPos(int pos, int kind);
    private int jjStartNfaWithStates_0(int pos, int kind, int state);
    private int jjMoveStringLiteralDfa0_0();
    private int jjMoveStringLiteralDfa1_0(long active0);
    private int jjMoveStringLiteralDfa2_0(long old0, long active0);
    private int jjMoveStringLiteralDfa3_0(long old0, long active0);
    private int jjMoveStringLiteralDfa4_0(long old0, long active0);
    private void jjCheckNAdd(int state);
    private void jjAddStates(int start, int end);
    private void jjCheckNAddTwoStates(int state1, int state2);
    private void jjCheckNAddStates(int start, int end);
    private int jjMoveNfa_0(int startState, int curPos);
    private int jjStopStringLiteralDfa_6(int pos, long active0);
    private int jjStartNfa_6(int pos, long active0);
    private int jjStartNfaWithStates_6(int pos, int kind, int state);
    private int jjMoveStringLiteralDfa0_6();
    private int jjMoveStringLiteralDfa1_6(long active0);
    private int jjMoveNfa_6(int startState, int curPos);
    private int jjStopStringLiteralDfa_4(int pos, long active0);
    private int jjStartNfa_4(int pos, long active0);
    private int jjStartNfaWithStates_4(int pos, int kind, int state);
    private int jjMoveStringLiteralDfa0_4();
    private int jjMoveStringLiteralDfa1_4(long active0);
    private int jjMoveStringLiteralDfa2_4(long old0, long active0);
    private int jjMoveStringLiteralDfa3_4(long old0, long active0);
    private int jjMoveStringLiteralDfa4_4(long old0, long active0);
    private int jjMoveStringLiteralDfa5_4(long old0, long active0);
    private int jjMoveNfa_4(int startState, int curPos);
    private int jjStopStringLiteralDfa_3(int pos, long active0);
    private int jjStartNfa_3(int pos, long active0);
    private int jjStartNfaWithStates_3(int pos, int kind, int state);
    private int jjMoveStringLiteralDfa0_3();
    private int jjMoveStringLiteralDfa1_3(long active0);
    private int jjMoveNfa_3(int startState, int curPos);
    private int jjStopStringLiteralDfa_7(int pos, long active0);
    private int jjStartNfa_7(int pos, long active0);
    private int jjStartNfaWithStates_7(int pos, int kind, int state);
    private int jjMoveStringLiteralDfa0_7();
    private int jjMoveStringLiteralDfa1_7(long active0);
    private int jjMoveNfa_7(int startState, int curPos);
    private int jjStopStringLiteralDfa_8(int pos, long active0);
    private int jjStartNfa_8(int pos, long active0);
    private int jjStartNfaWithStates_8(int pos, int kind, int state);
    private int jjMoveStringLiteralDfa0_8();
    private int jjMoveStringLiteralDfa1_8(long active0);
    private int jjMoveNfa_8(int startState, int curPos);
    private int jjStopStringLiteralDfa_5(int pos, long active0);
    private int jjStartNfa_5(int pos, long active0);
    private int jjStartNfaWithStates_5(int pos, int kind, int state);
    private int jjMoveStringLiteralDfa0_5();
    private int jjMoveStringLiteralDfa1_5(long active0);
    private int jjMoveStringLiteralDfa2_5(long old0, long active0);
    private int jjMoveStringLiteralDfa3_5(long old0, long active0);
    private int jjMoveStringLiteralDfa4_5(long old0, long active0);
    private int jjMoveNfa_5(int startState, int curPos);
    private int jjStopStringLiteralDfa_1(int pos, long active0);
    private int jjStartNfa_1(int pos, long active0);
    private int jjStartNfaWithStates_1(int pos, int kind, int state);
    private int jjMoveStringLiteralDfa0_1();
    private int jjMoveStringLiteralDfa1_1(long active0);
    private int jjMoveStringLiteralDfa2_1(long old0, long active0);
    private int jjMoveStringLiteralDfa3_1(long old0, long active0);
    private int jjMoveStringLiteralDfa4_1(long old0, long active0);
    private int jjMoveNfa_1(int startState, int curPos);
    private int jjStopStringLiteralDfa_2(int pos, long active0);
    private int jjStartNfa_2(int pos, long active0);
    private int jjStartNfaWithStates_2(int pos, int kind, int state);
    private int jjMoveStringLiteralDfa0_2();
    private int jjMoveStringLiteralDfa1_2(long active0);
    private int jjMoveStringLiteralDfa2_2(long old0, long active0);
    private int jjMoveStringLiteralDfa3_2(long old0, long active0);
    private int jjMoveStringLiteralDfa4_2(long old0, long active0);
    private int jjMoveNfa_2(int startState, int curPos);
    private static bool jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2);
    public void ReInit(ICharStream stream);
    private void ReInitRounds();
    public void ReInit(ICharStream stream, int lexState);
    public void SwitchTo(int lexState);
    private Token jjFillToken();
    public Token get_NextToken();
    private void SkipLexicalActions();
    private void MoreLexicalActions();
    private void TokenLexicalActions(Token matchedToken);
}
public class NVelocity.Runtime.Parser.ParserTreeConstants : object {
    public static int PROCESS;
    public static int VOID;
    public static int ESCAPED_DIRECTIVE;
    public static int ESCAPE;
    public static int COMMENT;
    public static int NUMBER_LITERAL;
    public static int STRING_LITERAL;
    public static int IDENTIFIER;
    public static int WORD;
    public static int DIRECTIVE;
    public static int BLOCK;
    public static int OBJECT_ARRAY;
    public static int INTEGER_RANGE;
    public static int METHOD;
    public static int REFERENCE;
    public static int TRUE;
    public static int FALSE;
    public static int TEXT;
    public static int IF_STATEMENT;
    public static int ELSE_STATEMENT;
    public static int ELSE_IF_STATEMENT;
    public static int SET_DIRECTIVE;
    public static int EXPRESSION;
    public static int ASSIGNMENT;
    public static int OR_NODE;
    public static int AND_NODE;
    public static int EQ_NODE;
    public static int NE_NODE;
    public static int LT_NODE;
    public static int GT_NODE;
    public static int LE_NODE;
    public static int GE_NODE;
    public static int ADD_NODE;
    public static int SUBTRACT_NODE;
    public static int MUL_NODE;
    public static int DIV_NODE;
    public static int MOD_NODE;
    public static int NOT_NODE;
    public static String[] NodeName;
    private static ParserTreeConstants();
}
public class NVelocity.Runtime.Parser.Token : object {
    public int Kind;
    public int BeginLine;
    public int BeginColumn;
    public int EndLine;
    public int EndColumn;
    public string Image;
    public Token Next;
    public Token SpecialToken;
    public virtual string ToString();
    public static Token NewToken(int ofKind);
}
public class NVelocity.Runtime.Parser.TokenMgrError : ApplicationException {
    internal static int LEXICAL_ERROR;
    internal static int STATIC_LEXER_ERROR;
    internal static int INVALID_LEXICAL_STATE;
    internal static int LOOP_DETECTED;
    internal int errorCode;
    public TokenMgrError(string message, int reason);
    public TokenMgrError(bool EOFSeen, int errorLine, int errorColumn, string errorAfter, char curChar, int reason);
    protected internal static string AddEscapes(string str);
    private static string LexicalError(bool EOFSeen, int errorLine, int errorColumn, string errorAfter, char currentCharacter);
}
public class NVelocity.Runtime.Parser.VelocityCharStream : object {
    public static bool staticFlag;
    internal int bufferSize;
    internal int available;
    internal int tokenBegin;
    public int bufferPosition;
    private Int32[] bufferLine;
    private Int32[] bufferColumn;
    private int column;
    private int line;
    private bool prevCharIsCR;
    private bool prevCharIsLF;
    private TextReader inputStream;
    private Char[] buffer;
    private int maxNextCharInd;
    private int inBuf;
    private char currentCharacter;
    private bool currentCharacterAvailable;
    public int Column { get; }
    public int Line { get; }
    public int EndColumn { get; }
    public int EndLine { get; }
    public int BeginColumn { get; }
    public int BeginLine { get; }
    public char CurrentCharacter { get; }
    public bool CurrentCharacterAvailable { get; }
    public VelocityCharStream(TextReader textReader, int startLine, int startColumn, int bufferSize);
    public VelocityCharStream(TextReader textReader, int startLine, int startColumn);
    public void ReInit(TextReader textReader, int startLine, int startColumn, int bufferSize);
    public void ReInit(TextReader textReader, int startLine, int startColumn);
    public sealed virtual string GetImage();
    public sealed virtual Char[] GetSuffix(int len);
    public sealed virtual void Done();
    public void AdjustBeginLineColumn(int newLine, int newCol);
    public sealed virtual int get_Column();
    public sealed virtual int get_Line();
    public sealed virtual int get_EndColumn();
    public sealed virtual int get_EndLine();
    public sealed virtual int get_BeginColumn();
    public sealed virtual int get_BeginLine();
    public sealed virtual char get_CurrentCharacter();
    public bool get_CurrentCharacterAvailable();
    private void ExpandBuff(bool wrapAround);
    private bool FillBuff();
    private bool EndRead();
    public sealed virtual bool BeginToken();
    private void UpdateLineColumn();
    public sealed virtual bool ReadChar();
    public sealed virtual void Backup(int amount);
}
public class NVelocity.Runtime.Resource.ContentResource : Resource {
    public virtual bool Process();
}
public interface NVelocity.Runtime.Resource.IResourceManager {
    public abstract virtual void Initialize(IRuntimeServices rs);
    public abstract virtual Resource GetResource(string resourceName, ResourceType resourceType, string encoding);
    public abstract virtual string GetLoaderNameForResource(string resourceName);
}
public class NVelocity.Runtime.Resource.Loader.AssemblyRelativeResourceLoader : ResourceLoader {
    private ArrayList assemblyNames;
    private ArrayList prefixes;
    public virtual void Init(ExtendedProperties configuration);
    public virtual Stream GetResourceStream(string templateName);
    public virtual bool IsSourceModified(Resource resource);
    public virtual long GetLastModified(Resource resource);
}
public class NVelocity.Runtime.Resource.Loader.AssemblyResourceLoader : ResourceLoader {
    private List`1<string> assemblyNames;
    public virtual void Init(ExtendedProperties configuration);
    public virtual Stream GetResourceStream(string templateName);
    public virtual bool IsSourceModified(Resource resource);
    public virtual long GetLastModified(Resource resource);
}
public class NVelocity.Runtime.Resource.Loader.FileResourceLoader : ResourceLoader {
    protected ArrayList paths;
    protected Hashtable templatePaths;
    public virtual void Init(ExtendedProperties configuration);
    public virtual Stream GetResourceStream(string templateName);
    private Stream FindTemplate(string path, string template);
    public virtual bool IsSourceModified(Resource resource);
    public virtual long GetLastModified(Resource resource);
}
public abstract class NVelocity.Runtime.Resource.Loader.ResourceLoader : object {
    protected internal bool isCachingOn;
    protected internal long modificationCheckInterval;
    protected internal string className;
    protected internal IRuntimeServices runtimeServices;
    public string ClassName { get; }
    public bool CachingOn { get; public set; }
    public long ModificationCheckInterval { get; public set; }
    public void CommonInit(IRuntimeServices rs, ExtendedProperties configuration);
    public abstract virtual void Init(ExtendedProperties configuration);
    public abstract virtual Stream GetResourceStream(string source);
    public abstract virtual bool IsSourceModified(Resource resource);
    public abstract virtual long GetLastModified(Resource resource);
    public string get_ClassName();
    public void set_CachingOn(bool value);
    public bool get_CachingOn();
    public long get_ModificationCheckInterval();
    public void set_ModificationCheckInterval(long value);
}
public class NVelocity.Runtime.Resource.Loader.ResourceLoaderFactory : object {
    public static ResourceLoader getLoader(IRuntimeServices rs, string loaderClassName);
}
public abstract class NVelocity.Runtime.Resource.Resource : object {
    protected internal static long MILLIS_PER_SECOND;
    protected internal object data;
    protected internal string encoding;
    protected internal long lastModified;
    protected internal long modificationCheckInterval;
    protected internal string name;
    protected internal long nextCheck;
    protected internal ResourceLoader resourceLoader;
    protected internal IRuntimeServices runtimeServices;
    public object Data { get; public set; }
    public string Encoding { get; public set; }
    public long LastModified { get; public set; }
    unknown long ModificationCheckInterval {public set; }
    public string Name { get; public set; }
    public ResourceLoader ResourceLoader { get; public set; }
    unknown IRuntimeServices RuntimeServices {public set; }
    public bool IsSourceModified();
    public abstract virtual bool Process();
    public bool RequiresChecking();
    public void Touch();
    public object get_Data();
    public void set_Data(object value);
    public string get_Encoding();
    public void set_Encoding(string value);
    public long get_LastModified();
    public void set_LastModified(long value);
    public void set_ModificationCheckInterval(long value);
    public string get_Name();
    public void set_Name(string value);
    public ResourceLoader get_ResourceLoader();
    public void set_ResourceLoader(ResourceLoader value);
    public void set_RuntimeServices(IRuntimeServices value);
}
public interface NVelocity.Runtime.Resource.ResourceCache {
    public abstract virtual void initialize(IRuntimeServices rs);
    public abstract virtual Resource get(object resourceKey);
    public abstract virtual Resource put(object resourceKey, Resource resource);
    public abstract virtual Resource remove(object resourceKey);
    public abstract virtual IEnumerator enumerateKeys();
}
public class NVelocity.Runtime.Resource.ResourceCacheImpl : object {
    protected internal IDictionary cache;
    protected internal IRuntimeServices runtimeServices;
    public sealed virtual void initialize(IRuntimeServices rs);
    public sealed virtual Resource get(object key);
    public sealed virtual Resource put(object key, Resource value);
    public sealed virtual Resource remove(object key);
    public sealed virtual IEnumerator enumerateKeys();
}
public class NVelocity.Runtime.Resource.ResourceFactory : object {
    public static Resource GetResource(string resourceName, ResourceType resourceType);
}
public class NVelocity.Runtime.Resource.ResourceManagerImpl : object {
    private static string RESOURCE_LOADER_IDENTIFIER;
    protected internal ResourceCache globalCache;
    protected internal ArrayList resourceLoaders;
    private ArrayList sourceInitializerList;
    private bool resourceLoaderInitializersActive;
    private bool logWhenFound;
    protected internal IRuntimeServices runtimeServices;
    public sealed virtual void Initialize(IRuntimeServices rs);
    private void AssembleResourceLoaderInitializers();
    public sealed virtual Resource GetResource(string resourceName, ResourceType resourceType, string encoding);
    protected internal Resource LoadResource(string resourceName, ResourceType resourceType, string encoding);
    protected internal void RefreshResource(Resource resource, string encoding);
    public Resource GetResource(string resourceName, ResourceType resourceType);
    public sealed virtual string GetLoaderNameForResource(string resourceName);
}
public enum NVelocity.Runtime.Resource.ResourceType : Enum {
    public int value__;
    public static ResourceType Template;
    public static ResourceType Content;
}
public class NVelocity.Runtime.RuntimeConstants : ValueType {
    public static string RUNTIME_LOG;
    public static string RUNTIME_LOG_LOGSYSTEM;
    public static string RUNTIME_LOG_LOGSYSTEM_CLASS;
    public static string RUNTIME_LOG_ERROR_STACKTRACE;
    public static string RUNTIME_LOG_WARN_STACKTRACE;
    public static string RUNTIME_LOG_INFO_STACKTRACE;
    public static string RUNTIME_LOG_REFERENCE_LOG_INVALID;
    public static string DEBUG_PREFIX;
    public static string INFO_PREFIX;
    public static string WARN_PREFIX;
    public static string ERROR_PREFIX;
    public static string UNKNOWN_PREFIX;
    public static string COUNTER_NAME;
    public static string COUNTER_INITIAL_VALUE;
    public static string ERRORMSG_START;
    public static string ERRORMSG_END;
    public static string PARSE_DIRECTIVE_MAXDEPTH;
    public static string RESOURCE_MANAGER_CLASS;
    public static string RESOURCE_MANAGER_CACHE_CLASS;
    public static string RESOURCE_MANAGER_DEFAULTCACHE_SIZE;
    public static string RESOURCE_MANAGER_LOGWHENFOUND;
    public static string RESOURCE_LOADER;
    public static string FILE_RESOURCE_LOADER_PATH;
    public static string FILE_RESOURCE_LOADER_CACHE;
    public static string VM_LIBRARY;
    public static string VM_LIBRARY_AUTORELOAD;
    public static string VM_PERM_ALLOW_INLINE;
    public static string VM_PERM_ALLOW_INLINE_REPLACE_GLOBAL;
    public static string VM_PERM_INLINE_LOCAL;
    public static string VM_MESSAGES_ON;
    public static string VM_CONTEXT_LOCALSCOPE;
    public static string INTERPOLATE_STRINGLITERALS;
    public static string INPUT_ENCODING;
    public static string OUTPUT_ENCODING;
    public static string ENCODING_DEFAULT;
    public static string DEFAULT_RUNTIME_PROPERTIES;
    public static string DEFAULT_RUNTIME_DIRECTIVES;
    public static int NUMBER_OF_PARSERS;
    public static string PARSER_POOL_SIZE;
    public static string UBERSPECT_CLASSNAME;
}
public class NVelocity.Runtime.RuntimeException : Exception {
    public RuntimeException(string message);
    public RuntimeException(string message, Exception innerException);
    public RuntimeException(SerializationInfo info, StreamingContext context);
}
public class NVelocity.Runtime.RuntimeInstance : object {
    private DefaultTraceListener debugOutput;
    private VelocimacroFactory vmFactory;
    private SimplePool`1<Parser> parserPool;
    private bool initialized;
    private ExtendedProperties overridingProperties;
    private ExtendedProperties configuration;
    private IResourceManager resourceManager;
    private Introspector introspector;
    private Hashtable applicationAttributes;
    private IUberspect uberSpect;
    private IDirectiveManager directiveManager;
    public ExtendedProperties Configuration { get; public set; }
    public Introspector Introspector { get; }
    public IUberspect Uberspect { get; }
    public sealed virtual ExtendedProperties get_Configuration();
    public sealed virtual void set_Configuration(ExtendedProperties value);
    public sealed virtual Introspector get_Introspector();
    public sealed virtual void Init();
    private void initializeIntrospection();
    private void setDefaultProperties();
    public sealed virtual void SetProperty(string key, object value);
    public sealed virtual void AddProperty(string key, object value);
    public sealed virtual void ClearProperty(string key);
    public sealed virtual object GetProperty(string key);
    private void initializeProperties();
    public void Init(ExtendedProperties p);
    public sealed virtual void Init(string configurationFile);
    private void initializeResourceManager();
    private void initializeLogger();
    private void initializeDirectives();
    private void initializeDirectiveManager();
    private void initializeParserPool();
    public Parser CreateNewParser();
    public sealed virtual SimpleNode Parse(TextReader reader, string templateName);
    public sealed virtual SimpleNode Parse(TextReader reader, string templateName, bool dumpNamespace);
    public sealed virtual Template GetTemplate(string name);
    public sealed virtual Template GetTemplate(string name, string encoding);
    public sealed virtual ContentResource GetContent(string name);
    public sealed virtual ContentResource GetContent(string name, string encoding);
    public sealed virtual string GetLoaderNameForResource(string resourceName);
    private bool showStackTrace();
    private void Log(LogLevel level, object message);
    public sealed virtual void Warn(object message);
    public sealed virtual void Info(object message);
    public sealed virtual void Error(object message);
    public sealed virtual void Debug(object message);
    public sealed virtual string GetString(string key, string defaultValue);
    public sealed virtual Directive GetVelocimacro(string vmName, string templateName);
    public sealed virtual bool AddVelocimacro(string name, string macro, String[] argArray, string sourceTemplate);
    public sealed virtual bool IsVelocimacro(string vmName, string templateName);
    public sealed virtual bool DumpVMNamespace(string ns);
    public sealed virtual string GetString(string key);
    public sealed virtual int GetInt(string key);
    public sealed virtual int GetInt(string key, int defaultValue);
    public sealed virtual bool GetBoolean(string key, bool def);
    public sealed virtual object GetApplicationAttribute(object key);
    public sealed virtual object SetApplicationAttribute(object key, object o);
    public sealed virtual IUberspect get_Uberspect();
}
public class NVelocity.Runtime.RuntimeSingleton : object {
    private static RuntimeInstance ri;
    public static IRuntimeServices RuntimeServices { get; }
    public static ExtendedProperties Configuration { get; public set; }
    public static Introspector Introspector { get; }
    [ObsoleteAttribute("Use the RuntimeServices property instead")]
public static RuntimeInstance RuntimeInstance { get; }
    private static RuntimeSingleton();
    public static void Init();
    public static void SetProperty(string key, object value);
    public static void AddProperty(string key, object value);
    public static void ClearProperty(string key);
    public static object GetProperty(string key);
    public static void Init(ExtendedProperties p);
    public static void Init(string configurationFile);
    private static Parser CreateNewParser();
    public static SimpleNode Parse(TextReader reader, string templateName);
    public static SimpleNode Parse(TextReader reader, string templateName, bool dumpNamespace);
    public static Template GetTemplate(string name);
    public static Template GetTemplate(string name, string encoding);
    public static ContentResource GetContent(string name);
    public static ContentResource GetContent(string name, string encoding);
    public static string GetLoaderNameForResource(string resourceName);
    public static void Warn(object message);
    public static void Info(object message);
    public static void Error(object message);
    public static void Debug(object message);
    public static string getString(string key, string defaultValue);
    public static Directive GetVelocimacro(string vmName, string templateName);
    public static bool AddVelocimacro(string name, string macro, String[] argArray, string sourceTemplate);
    public static bool IsVelocimacro(string vmName, string templateName);
    public static bool DumpVMNamespace(string ns);
    public static string GetString(string key);
    public static int GetInt(string key);
    public static int GetInt(string key, int defaultValue);
    public static bool GetBoolean(string key, bool def);
    public static IRuntimeServices get_RuntimeServices();
    public static ExtendedProperties get_Configuration();
    public static void set_Configuration(ExtendedProperties value);
    public static Introspector get_Introspector();
    public static RuntimeInstance get_RuntimeInstance();
    public static object GetApplicationAttribute(object key);
}
public class NVelocity.Runtime.VelocimacroFactory : object {
    private IRuntimeServices runtimeServices;
    private VelocimacroManager velocimacroManager;
    private bool replaceAllowed;
    private bool addNewAllowed;
    private bool templateLocal;
    private bool blather;
    private bool autoReloadLibrary;
    private ArrayList macroLibVec;
    private Hashtable libModMap;
    private bool TemplateLocalInline { get; private set; }
    unknown bool AddMacroPermission {private set; }
    unknown bool ReplacementPermission {private set; }
    private bool Blather { get; private set; }
    private bool Autoload { get; private set; }
    public VelocimacroFactory(IRuntimeServices rs);
    private bool get_TemplateLocalInline();
    private void set_TemplateLocalInline(bool value);
    private void set_AddMacroPermission(bool value);
    private void set_ReplacementPermission(bool value);
    private bool get_Blather();
    private void set_Blather(bool value);
    private bool get_Autoload();
    private void set_Autoload(bool value);
    public void InitVelocimacro();
    public bool AddVelocimacro(string name, string macroBody, String[] argArray, string sourceTemplate);
    private bool CanAddVelocimacro(string name, string sourceTemplate);
    private void LogVMMessageInfo(string s);
    private void LogVMMessageWarn(string s);
    public bool IsVelocimacro(string vm, string sourceTemplate);
    public Directive GetVelocimacro(string vmName, string sourceTemplate);
    public bool DumpVMNamespace(string ns);
}
public class NVelocity.Runtime.VelocimacroManager : object {
    private IRuntimeServices runtimeServices;
    private static string GLOBAL_NAMESPACE;
    private bool registerFromLib;
    private Hashtable namespaceHash;
    private Hashtable libraryMap;
    private bool namespacesOn;
    private bool inlineLocalMode;
    unknown bool NamespaceUsage {public set; }
    unknown bool RegisterFromLib {public set; }
    unknown bool TemplateLocalInlineVM {public set; }
    internal VelocimacroManager(IRuntimeServices rs);
    private static VelocimacroManager();
    private void InitBlock();
    public void set_NamespaceUsage(bool value);
    public void set_RegisterFromLib(bool value);
    public void set_TemplateLocalInlineVM(bool value);
    public bool AddVM(string vmName, string macroBody, String[] argArray, string ns);
    public VelocimacroProxy get(string vmName, string ns);
    public bool DumpNamespace(string ns);
    private Hashtable GetNamespace(string ns);
    private Hashtable GetNamespace(string ns, bool addIfNew);
    private Hashtable AddNamespace(string ns);
    private bool UsingNamespaces(string ns);
    public string GetLibraryName(string vmName, string ns);
}
public abstract class NVelocity.Runtime.Visitor.BaseVisitor : object {
    protected internal IInternalContextAdapter context;
    protected internal StreamWriter writer;
    public virtual object Visit(SimpleNode node, object data);
    public virtual object Visit(ASTprocess node, object data);
    public virtual object Visit(ASTExpression node, object data);
    public virtual object Visit(ASTAssignment node, object data);
    public virtual object Visit(ASTOrNode node, object data);
    public virtual object Visit(ASTAndNode node, object data);
    public virtual object Visit(ASTEQNode node, object data);
    public virtual object Visit(ASTNENode node, object data);
    public virtual object Visit(ASTLTNode node, object data);
    public virtual object Visit(ASTGTNode node, object data);
    public virtual object Visit(ASTLENode node, object data);
    public virtual object Visit(ASTGENode node, object data);
    public virtual object Visit(ASTAddNode node, object data);
    public virtual object Visit(ASTSubtractNode node, object data);
    public virtual object Visit(ASTMulNode node, object data);
    public virtual object Visit(ASTDivNode node, object data);
    public virtual object Visit(ASTModNode node, object data);
    public virtual object Visit(ASTNotNode node, object data);
    public virtual object Visit(ASTNumberLiteral node, object data);
    public virtual object Visit(ASTStringLiteral node, object data);
    public virtual object Visit(ASTIdentifier node, object data);
    public virtual object Visit(ASTMethod node, object data);
    public virtual object Visit(ASTReference node, object data);
    public virtual object Visit(ASTTrue node, object data);
    public virtual object Visit(ASTFalse node, object data);
    public virtual object Visit(ASTBlock node, object data);
    public virtual object Visit(ASTText node, object data);
    public virtual object Visit(ASTIfStatement node, object data);
    public virtual object Visit(ASTElseStatement node, object data);
    public virtual object Visit(ASTElseIfStatement node, object data);
    public virtual object Visit(ASTComment node, object data);
    public virtual object Visit(ASTObjectArray node, object data);
    public virtual object Visit(ASTMap node, object data);
    public virtual object Visit(ASTWord node, object data);
    public virtual object Visit(ASTSetDirective node, object data);
    public virtual object Visit(ASTDirective node, object data);
}
public class NVelocity.Runtime.Visitor.NodeViewMode : BaseVisitor {
    private int indent;
    private bool showTokens;
    private string IndentString();
    private object ShowNode(INode node, object data);
    public virtual object Visit(SimpleNode node, object data);
    public virtual object Visit(ASTprocess node, object data);
    public virtual object Visit(ASTExpression node, object data);
    public virtual object Visit(ASTAssignment node, object data);
    public virtual object Visit(ASTOrNode node, object data);
    public virtual object Visit(ASTAndNode node, object data);
    public virtual object Visit(ASTEQNode node, object data);
    public virtual object Visit(ASTNENode node, object data);
    public virtual object Visit(ASTLTNode node, object data);
    public virtual object Visit(ASTGTNode node, object data);
    public virtual object Visit(ASTLENode node, object data);
    public virtual object Visit(ASTGENode node, object data);
    public virtual object Visit(ASTAddNode node, object data);
    public virtual object Visit(ASTSubtractNode node, object data);
    public virtual object Visit(ASTMulNode node, object data);
    public virtual object Visit(ASTDivNode node, object data);
    public virtual object Visit(ASTModNode node, object data);
    public virtual object Visit(ASTNotNode node, object data);
    public virtual object Visit(ASTNumberLiteral node, object data);
    public virtual object Visit(ASTStringLiteral node, object data);
    public virtual object Visit(ASTIdentifier node, object data);
    public virtual object Visit(ASTMethod node, object data);
    public virtual object Visit(ASTReference node, object data);
    public virtual object Visit(ASTTrue node, object data);
    public virtual object Visit(ASTFalse node, object data);
    public virtual object Visit(ASTBlock node, object data);
    public virtual object Visit(ASTText node, object data);
    public virtual object Visit(ASTIfStatement node, object data);
    public virtual object Visit(ASTElseStatement node, object data);
    public virtual object Visit(ASTElseIfStatement node, object data);
    public virtual object Visit(ASTObjectArray node, object data);
    public virtual object Visit(ASTDirective node, object data);
    public virtual object Visit(ASTWord node, object data);
    public virtual object Visit(ASTSetDirective node, object data);
}
public class NVelocity.Runtime.Visitor.VMReferenceMungeVisitor : BaseVisitor {
    private Hashtable argumentMap;
    public VMReferenceMungeVisitor(Hashtable map);
    public virtual object Visit(ASTReference node, object data);
}
public class NVelocity.SupportClass : object {
    public static SByte[] ToSByteArray(Byte[] byteArray);
    public static Byte[] ToByteArray(SByte[] sbyteArray);
    public static object PutElement(Hashtable hashTable, object key, object newValue);
    public static long FileLength(FileInfo file);
    public static void WriteStackTrace(Exception throwable, TextWriter stream);
    public static string FormatDateTime(DateTimeFormatInfo format, DateTime date);
    public static DateTimeFormatInfo GetDateTimeFormatInstance(int dateStyle, int timeStyle, CultureInfo culture);
    public static object CreateNewInstance(Type classType);
}
public class NVelocity.Template : Resource {
    private Exception errorCondition;
    public virtual bool Process();
    public void InitDocument();
    public void Merge(IContext context, TextWriter writer);
    protected virtual Stream ObtainStream();
}
public class NVelocity.Tool.DataInfo : object {
    public static string TYPE_STRING;
    public static string TYPE_NUMBER;
    public static string TYPE_BOOLEAN;
    private string key;
    private object data;
    public string Key { get; }
    public string Classname { get; }
    public DataInfo(string key, string type, string value);
    private static DataInfo();
    public sealed virtual string get_Key();
    public sealed virtual string get_Classname();
    public sealed virtual object getInstance(object initData);
}
public interface NVelocity.Tool.IToolInfo {
    public string Key { get; }
    public string Classname { get; }
    public abstract virtual string get_Key();
    public abstract virtual string get_Classname();
    public abstract virtual object getInstance(object initData);
}
public class NVelocity.Tool.ToolLoader : object {
    public object Load(string className);
}
public class NVelocity.Util.Introspection.AmbiguousException : Exception {
    public AmbiguousException(string message);
    public AmbiguousException(string message, Exception innerException);
    public AmbiguousException(SerializationInfo info, StreamingContext context);
}
public class NVelocity.Util.Introspection.ClassMap : object {
    private static MethodInfo CACHE_MISS;
    private static object OBJECT;
    private Type type;
    private Dictionary`2<string, MethodInfo> methodCache;
    private Dictionary`2<string, MemberInfo> propertyCache;
    private MethodMap methodMap;
    internal Type CachedClass { get; }
    public ClassMap(Type type);
    private static ClassMap();
    internal Type get_CachedClass();
    public MethodInfo FindMethod(string name, Object[] parameters);
    public PropertyInfo FindProperty(string name);
    private void PopulateMethodCache();
    private void PopulatePropertyCache();
    private static string MakeMethodKey(MethodInfo method);
    private static string MakeMethodKey(string method, Object[] parameters);
    private static MethodInfo[] GetAccessibleMethods(Type type);
    private static PropertyInfo[] GetAccessibleProperties(Type type);
}
public class NVelocity.Util.Introspection.Info : object {
    private int line;
    private int column;
    private string templateName;
    public string TemplateName { get; }
    public int Line { get; }
    public int Column { get; }
    public Info(string source, int line, int column);
    public string get_TemplateName();
    public int get_Line();
    public int get_Column();
    public virtual string ToString();
}
public class NVelocity.Util.Introspection.IntrospectionCacheData : object {
    public object Thingy;
    public Type ContextData;
    public IntrospectionCacheData(Type contextData, object thingy);
}
public class NVelocity.Util.Introspection.Introspector : IntrospectorBase {
    private IRuntimeLogger rlog;
    public Introspector(IRuntimeLogger r);
    public virtual MethodInfo GetMethod(Type c, string name, Object[] parameters);
    public virtual PropertyInfo GetProperty(Type c, string name);
}
public abstract class NVelocity.Util.Introspection.IntrospectorBase : object {
    protected internal Hashtable classMethodMaps;
    protected internal IList cachedClassNames;
    public virtual MethodInfo GetMethod(Type c, string name, Object[] parameters);
    public virtual PropertyInfo GetProperty(Type c, string name);
    protected internal ClassMap CreateClassMap(Type c);
}
public interface NVelocity.Util.Introspection.IUberspect {
    public abstract virtual void Init();
    public abstract virtual IVelMethod GetMethod(object obj, string method, Object[] args, Info info);
    public abstract virtual IVelPropertyGet GetPropertyGet(object obj, string identifier, Info info);
    public abstract virtual IVelPropertySet GetPropertySet(object obj, string identifier, object arg, Info info);
}
public interface NVelocity.Util.Introspection.IVelMethod {
    public bool Cacheable { get; }
    public string MethodName { get; }
    public Type ReturnType { get; }
    public abstract virtual bool get_Cacheable();
    public abstract virtual string get_MethodName();
    public abstract virtual Type get_ReturnType();
    public abstract virtual object Invoke(object o, Object[] paramsRenamed);
}
public interface NVelocity.Util.Introspection.IVelPropertyGet {
    public bool Cacheable { get; }
    public string MethodName { get; }
    public abstract virtual bool get_Cacheable();
    public abstract virtual string get_MethodName();
    public abstract virtual object Invoke(object o);
}
public interface NVelocity.Util.Introspection.IVelPropertySet {
    public bool Cacheable { get; }
    public string MethodName { get; }
    public abstract virtual bool get_Cacheable();
    public abstract virtual string get_MethodName();
    public abstract virtual object Invoke(object o, object arg);
}
public class NVelocity.Util.Introspection.MethodMap : object {
    private static int MORE_SPECIFIC;
    private static int LESS_SPECIFIC;
    private static int INCOMPARABLE;
    internal IDictionary methodByNameMap;
    public void Add(MethodInfo method);
    public IList Get(string key);
    public MethodInfo Find(string methodName, Object[] args);
    private static MethodInfo GetMostSpecific(IList methods, Type[] classes);
    private static int IsMoreSpecific(ParameterInfo[] c1, ParameterInfo[] c2);
    private static ArrayList GetApplicables(IList methods, Type[] classes);
    private static bool IsApplicable(MethodInfo method, Type[] classes);
    private static bool IsMethodInvocationConvertible(ParameterInfo formal, Type actual);
    private static bool IsStrictMethodInvocationConvertible(ParameterInfo formal, ParameterInfo actual);
    private static string CreateDescriptiveAmbiguousErrorMessage(IList list, Type[] classes);
    private static string CreateParametersDescription(ParameterInfo[] parameters);
}
public class NVelocity.Util.Introspection.UberspectImpl : object {
    private IRuntimeLogger runtimeLogger;
    private static Introspector introspector;
    unknown IRuntimeLogger RuntimeLogger {public set; }
    public sealed virtual void set_RuntimeLogger(IRuntimeLogger value);
    public sealed virtual void Init();
    public sealed virtual IVelMethod GetMethod(object obj, string methodName, Object[] args, Info i);
    public sealed virtual IVelPropertyGet GetPropertyGet(object obj, string identifier, Info i);
    public sealed virtual IVelPropertySet GetPropertySet(object obj, string identifier, object arg, Info i);
}
public interface NVelocity.Util.Introspection.UberspectLoggable {
    unknown IRuntimeLogger RuntimeLogger {public set; }
    public abstract virtual void set_RuntimeLogger(IRuntimeLogger value);
}
public class NVelocity.Util.SimplePool`1 : object {
    private T[] pool;
    private int maximum;
    private int current;
    public int Maximum { get; }
    public SimplePool`1(int max);
    public void put(T o);
    public object get();
    public int get_Maximum();
}
public class NVelocity.Util.StringUtils : object {
    private static string EOL;
    private static StringUtils();
    public static string FirstLetterCaps(string data);
    public static string FileContentsToString(string file);
    public static string NormalizePath(string path);
}
public class NVelocity.VelocityContext : AbstractContext {
    private Hashtable context;
    public int Count { get; }
    public VelocityContext(Hashtable context);
    public VelocityContext(IContext innerContext);
    public VelocityContext(Hashtable context, IContext innerContext);
    public virtual object InternalGet(string key);
    public virtual object InternalPut(string key, object value);
    public virtual bool InternalContainsKey(object key);
    public virtual Object[] InternalGetKeys();
    public virtual object InternalRemove(object key);
    public virtual int get_Count();
}
