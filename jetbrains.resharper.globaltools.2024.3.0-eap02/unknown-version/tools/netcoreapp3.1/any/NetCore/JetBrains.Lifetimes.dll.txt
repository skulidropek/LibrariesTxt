[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.AssertionMethodAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
[BaseTypeRequiredAttribute("System.Attribute")]
internal class JetBrains.Annotations.BaseTypeRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BaseType>k__BackingField;
    [NotNullAttribute]
public Type BaseType { get; private set; }
    public BaseTypeRequiredAttribute(Type baseType);
    [CompilerGeneratedAttribute]
public Type get_BaseType();
    [CompilerGeneratedAttribute]
private void set_BaseType(Type value);
}
[AttributeUsageAttribute("24516")]
internal class JetBrains.Annotations.CanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("1036")]
internal class JetBrains.Annotations.CannotApplyEqualityOperatorAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2044")]
internal class JetBrains.Annotations.CodeTemplateAttribute : Attribute {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <SearchTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplaceTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplaceMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FormatAfterReplace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MatchSimilarConstructs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShortenReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SuppressionKey>k__BackingField;
    [NullableAttribute("1")]
public string SearchTemplate { get; }
    public string Message { get; public set; }
    public string ReplaceTemplate { get; public set; }
    public string ReplaceMessage { get; public set; }
    public bool FormatAfterReplace { get; public set; }
    public bool MatchSimilarConstructs { get; public set; }
    public bool ShortenReferences { get; public set; }
    public string SuppressionKey { get; public set; }
    [NullableContextAttribute("1")]
public CodeTemplateAttribute(string searchTemplate);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_SearchTemplate();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_ReplaceTemplate();
    [CompilerGeneratedAttribute]
public void set_ReplaceTemplate(string value);
    [CompilerGeneratedAttribute]
public string get_ReplaceMessage();
    [CompilerGeneratedAttribute]
public void set_ReplaceMessage(string value);
    [CompilerGeneratedAttribute]
public bool get_FormatAfterReplace();
    [CompilerGeneratedAttribute]
public void set_FormatAfterReplace(bool value);
    [CompilerGeneratedAttribute]
public bool get_MatchSimilarConstructs();
    [CompilerGeneratedAttribute]
public void set_MatchSimilarConstructs(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShortenReferences();
    [CompilerGeneratedAttribute]
public void set_ShortenReferences(bool value);
    [CompilerGeneratedAttribute]
public string get_SuppressionKey();
    [CompilerGeneratedAttribute]
public void set_SuppressionKey(string value);
}
[AttributeUsageAttribute("224")]
internal class JetBrains.Annotations.CollectionAccessAttribute : Attribute {
    [CompilerGeneratedAttribute]
private CollectionAccessType <CollectionAccessType>k__BackingField;
    public CollectionAccessType CollectionAccessType { get; private set; }
    public CollectionAccessAttribute(CollectionAccessType collectionAccessType);
    [CompilerGeneratedAttribute]
public CollectionAccessType get_CollectionAccessType();
    [CompilerGeneratedAttribute]
private void set_CollectionAccessType(CollectionAccessType value);
}
[FlagsAttribute]
internal enum JetBrains.Annotations.CollectionAccessType : Enum {
    public int value__;
    public static CollectionAccessType None;
    public static CollectionAccessType Read;
    public static CollectionAccessType ModifyExistingContent;
    public static CollectionAccessType UpdatedContent;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.ContractAnnotationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Contract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceFullStates>k__BackingField;
    [NotNullAttribute]
public string Contract { get; private set; }
    public bool ForceFullStates { get; private set; }
    public ContractAnnotationAttribute(string contract);
    public ContractAnnotationAttribute(string contract, bool forceFullStates);
    [CompilerGeneratedAttribute]
public string get_Contract();
    [CompilerGeneratedAttribute]
private void set_Contract(string value);
    [CompilerGeneratedAttribute]
public bool get_ForceFullStates();
    [CompilerGeneratedAttribute]
private void set_ForceFullStates(bool value);
}
[AttributeUsageAttribute("1037")]
internal class JetBrains.Annotations.ImplicitNotNullAttribute : Attribute {
}
[FlagsAttribute]
internal enum JetBrains.Annotations.ImplicitUseKindFlags : Enum {
    public int value__;
    public static ImplicitUseKindFlags Default;
    public static ImplicitUseKindFlags Access;
    public static ImplicitUseKindFlags Assign;
    public static ImplicitUseKindFlags InstantiatedWithFixedConstructorSignature;
    public static ImplicitUseKindFlags InstantiatedNoFixedConstructorSignature;
}
[FlagsAttribute]
internal enum JetBrains.Annotations.ImplicitUseTargetFlags : Enum {
    public int value__;
    public static ImplicitUseTargetFlags Default;
    public static ImplicitUseTargetFlags Itself;
    public static ImplicitUseTargetFlags Members;
    public static ImplicitUseTargetFlags WithMembers;
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.InstantHandleAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.InvokerParameterNameAttribute : Attribute {
}
[AttributeUsageAttribute("6592")]
internal class JetBrains.Annotations.ItemCanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("6592")]
internal class JetBrains.Annotations.ItemNotNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.LinqTunnelAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
internal class JetBrains.Annotations.LocalizationRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    public bool Required { get; private set; }
    public LocalizationRequiredAttribute(bool required);
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
private void set_Required(bool value);
}
[AttributeUsageAttribute("16388")]
internal class JetBrains.Annotations.MeansImplicitUseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    [UsedImplicitlyAttribute]
public ImplicitUseKindFlags UseKindFlags { get; private set; }
    [UsedImplicitlyAttribute]
public ImplicitUseTargetFlags TargetFlags { get; private set; }
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags);
    public MeansImplicitUseAttribute(ImplicitUseTargetFlags targetFlags);
    public MeansImplicitUseAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
private void set_UseKindFlags(ImplicitUseKindFlags value);
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
    [CompilerGeneratedAttribute]
private void set_TargetFlags(ImplicitUseTargetFlags value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.MustUseReturnValueAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    public string Justification { get; private set; }
    [NullableContextAttribute("1")]
public MustUseReturnValueAttribute(string justification);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
private void set_Justification(string value);
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.NoEnumerationAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.NotifyPropertyChangedInvocatorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; private set; }
    [NullableContextAttribute("1")]
public NotifyPropertyChangedInvocatorAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
private void set_ParameterName(string value);
}
[AttributeUsageAttribute("24516")]
internal class JetBrains.Annotations.NotNullAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.PathReferenceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <BasePath>k__BackingField;
    public string BasePath { get; private set; }
    [NullableContextAttribute("1")]
public PathReferenceAttribute(string basePath);
    [CompilerGeneratedAttribute]
public string get_BasePath();
    [CompilerGeneratedAttribute]
private void set_BasePath(string value);
}
[AttributeUsageAttribute("19916")]
internal class JetBrains.Annotations.ProvidesContextAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[MeansImplicitUseAttribute("3")]
internal class JetBrains.Annotations.PublicAPIAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    public string Comment { get; private set; }
    [NullableContextAttribute("1")]
public PublicAPIAttribute(string comment);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
private void set_Comment(string value);
}
[AttributeUsageAttribute("64")]
internal class JetBrains.Annotations.PureAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class JetBrains.Annotations.RegexPatternAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4320")]
internal class JetBrains.Annotations.StringFormatMethodAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FormatParameterName>k__BackingField;
    [NotNullAttribute]
public string FormatParameterName { get; private set; }
    public StringFormatMethodAttribute(string formatParameterName);
    [CompilerGeneratedAttribute]
public string get_FormatParameterName();
    [CompilerGeneratedAttribute]
private void set_FormatParameterName(string value);
}
[AttributeUsageAttribute("32767")]
internal class JetBrains.Annotations.UsedImplicitlyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ImplicitUseKindFlags <UseKindFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplicitUseTargetFlags <TargetFlags>k__BackingField;
    public ImplicitUseKindFlags UseKindFlags { get; private set; }
    public ImplicitUseTargetFlags TargetFlags { get; private set; }
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags);
    public UsedImplicitlyAttribute(ImplicitUseTargetFlags targetFlags);
    public UsedImplicitlyAttribute(ImplicitUseKindFlags useKindFlags, ImplicitUseTargetFlags targetFlags);
    [CompilerGeneratedAttribute]
public ImplicitUseKindFlags get_UseKindFlags();
    [CompilerGeneratedAttribute]
private void set_UseKindFlags(ImplicitUseKindFlags value);
    [CompilerGeneratedAttribute]
public ImplicitUseTargetFlags get_TargetFlags();
    [CompilerGeneratedAttribute]
private void set_TargetFlags(ImplicitUseTargetFlags value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2432")]
internal class JetBrains.Annotations.ValueProviderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NotNullAttribute]
public string Name { get; private set; }
    public ValueProviderAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Collections.BlockingPriorityQueue`1 : object {
    private Lifetime myLifetime;
    private JetPriorityQueue`1<T> myQueue;
    private object mySentry;
    public int Count { get; }
    public bool IsReadOnly { get; }
    [NullableContextAttribute("2")]
public BlockingPriorityQueue`1(Lifetime lifetime, int initialCapacity, IComparer`1<T> comparer);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [NullableContextAttribute("2")]
public sealed virtual bool TryExtract(T& res);
    [NullableContextAttribute("2")]
public sealed virtual bool TryPeek(T& res);
    [NullableContextAttribute("2")]
[PublicAPIAttribute]
public bool TryExtract(T& res, int intervalMs);
    [NullableContextAttribute("2")]
[PublicAPIAttribute]
public bool TryPeek(T& res, int intervalMs);
    [NullableContextAttribute("2")]
[PublicAPIAttribute]
public T ExtractOrBlock();
    [PublicAPIAttribute]
public int Enqueue(T item);
    [PublicAPIAttribute]
public T[] ToArray();
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Collections.CollectionEx : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
[CollectionAccessAttribute("1")]
public static int ContentHashCode(ICollection`1<T> collection, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool TryDequeue(Queue`1<T> queue, T& res);
    [ExtensionAttribute]
public static T Enqueued(Queue`1<T> queue, T toEnqueue);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class JetBrains.Collections.CompactList`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static List`1<T> SingleMarker;
    private T mySingleValue;
    private List`1<T> myMultipleValues;
    public int Count { get; }
    public T Item { get; }
    private static CompactList`1();
    public CompactListEnumerator`1<T> GetEnumerator();
    public int get_Count();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("1")]
public void Add(T item);
    public void Clear();
    [NullableContextAttribute("1")]
public int LastIndexOf(T item, IEqualityComparer`1<T> comparer);
    public bool RemoveAt(int index);
    public T[] ToArray();
    public T get_Item(int index);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class JetBrains.Collections.CompactListEnumerator`1 : ValueType {
    private T mySingleValue;
    private List`1<T> myMultipleValues;
    private int myIndex;
    private T myCurrent;
    private object System.Collections.IEnumerator.Current { get; }
    public T Current { get; }
    internal CompactListEnumerator`1(T singleValue, List`1<T> multipleValues);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual T get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class JetBrains.Collections.CopyOnWriteList`1 : object {
    private T[] modreq(System.Runtime.CompilerServices.IsVolatile) myStorage;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    internal T[] GetStorageUnsafe();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void Modify(TParam param, Func`3<T[], TParam, T[]> action);
    private TOut Modify(TParam param, Func`3<T[], TParam, KeyValuePair`2<T[], TOut>> action);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Collections.EmptyEnumerator`1 : object {
    public static EmptyEnumerator`1<T> Instance;
    public T Current { get; }
    [NullableAttribute("2")]
private object System.Collections.IEnumerator.Current { get; }
    private static EmptyEnumerator`1();
    public sealed virtual T get_Current();
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
    public IEnumerator`1<T> GetEnumerator();
}
[NullableContextAttribute("2")]
public interface JetBrains.Collections.IPriorityQueue`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool TryExtract(T& res);
    public abstract virtual bool TryPeek(T& res);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Collections.JetKeyValuePair : object {
    [PureAttribute]
[DebuggerStepThroughAttribute]
public static KeyValuePair`2<TKey, TValue> Of(TKey key, TValue value);
    [ExtensionAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Collections.JetPriorityQueue`1 : object {
    public static int DefaultCapacity;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<T> myStorage;
    private List`1<long> myVersions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IComparer`1<T> myComparer;
    private long myVersionAcc;
    public int Count { get; }
    public bool IsReadOnly { get; }
    [NullableContextAttribute("2")]
public JetPriorityQueue`1(int initialCapacity, IComparer`1<T> comparer);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [NullableContextAttribute("2")]
public sealed virtual bool TryExtract(T& res);
    [NullableContextAttribute("2")]
public sealed virtual bool TryPeek(T& res);
    private void Swap(Int32& i, int j);
    private int Compare(int left, int right);
    private void HeapDown(int idx);
    private void HeapUp(int idx);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Collections.PriorityQueueEx : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PublicAPIAttribute]
public static void Enqueue(IPriorityQueue`1<T> queue, T val);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static T ExtractOrDefault(IPriorityQueue`1<T> queue);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static T Extract(IPriorityQueue`1<T> queue);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static T Peek(IPriorityQueue`1<T> queue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Collections.ReferenceEqualityComparer`1 : object {
    private static ReferenceEqualityComparer`1<T> ourDefault;
    public static IEqualityComparer`1<T> Default { get; }
    private static ReferenceEqualityComparer`1();
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T obj);
    public static IEqualityComparer`1<T> get_Default();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Collections.SingletonEnumerator`1 : ValueType {
    private bool myHasNext;
    [CompilerGeneratedAttribute]
private T <Current>k__BackingField;
    public T Current { get; }
    [NullableAttribute("2")]
private object System.Collections.IEnumerator.Current { get; }
    public SingletonEnumerator`1(T next);
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual T get_Current();
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
[ExtensionAttribute]
public static class JetBrains.Collections.SmartListExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static CompactList`1<T> ToSmartList(IEnumerable`1<T> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[PublicAPIAttribute]
public class JetBrains.Collections.Synchronized.SynchronizedDictionary`2 : object {
    private Dictionary`2<TK, TV> myImpl;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private SynchronizedValues<TK, TV> myValues;
    private object myLocker;
    private int myIsUnderReadingCount;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TK,TV>>.IsReadOnly { get; }
    public TV Item { get; public set; }
    public ICollection`1<TK> Keys { get; }
    public ICollection`1<TV> Values { get; }
    private bool System.Collections.Generic.ICollection<TK>.IsReadOnly { get; }
    public SynchronizedDictionary`2(IEqualityComparer`1<TK> comparer);
    public SynchronizedDictionary`2(int capacity, IEqualityComparer`1<TK> comparer);
    [IteratorStateMachineAttribute("JetBrains.Collections.Synchronized.SynchronizedDictionary`2/<GetEnumerator>d__6")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TK, TV>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TK,TV>>.Add(KeyValuePair`2<TK, TV> item);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TK,TV>>.Contains(KeyValuePair`2<TK, TV> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TK,TV>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private static void CopyToNoLock(ICollection`1<T> source, T[] destination, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TK,TV>>.Remove(KeyValuePair`2<TK, TV> item);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TK,TV>>.get_IsReadOnly();
    public sealed virtual bool ContainsKey(TK key);
    public sealed virtual void Add(TK key, TV value);
    public sealed virtual bool Remove(TK key);
    public sealed virtual bool TryGetValue(TK key, TV& value);
    public sealed virtual TV get_Item(TK key);
    public sealed virtual void set_Item(TK key, TV value);
    public sealed virtual ICollection`1<TK> get_Keys();
    public sealed virtual ICollection`1<TV> get_Values();
    private Dictionary`2<TK, TV> GetOrCloneMapNoLock();
    private sealed virtual override void System.Collections.Generic.ICollection<TK>.Add(TK item);
    private sealed virtual override bool System.Collections.Generic.ICollection<TK>.Contains(TK item);
    private sealed virtual override void System.Collections.Generic.ICollection<TK>.CopyTo(TK[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<TK>.get_IsReadOnly();
    [IteratorStateMachineAttribute("JetBrains.Collections.Synchronized.SynchronizedDictionary`2/<System-Collections-Generic-IEnumerable<TK>-GetEnumerator>d__35")]
private sealed virtual override IEnumerator`1<TK> System.Collections.Generic.IEnumerable<TK>.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[PublicAPIAttribute]
public class JetBrains.Collections.Synchronized.SynchronizedList`1 : object {
    private List`1<T> myList;
    private object myLocker;
    private int myIsUnderReadingCount;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public SynchronizedList`1(IEnumerable`1<T> values, int capacity);
    [IteratorStateMachineAttribute("JetBrains.Collections.Synchronized.SynchronizedList`1/<GetEnumerator>d__4")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private List`1<T> GetOrCloneListNoLock();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class JetBrains.Collections.Synchronized.SynchronizedSet`1 : object {
    private HashSet`1<T> mySet;
    private object myLocker;
    private int myIsUnderReadingCount;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public SynchronizedSet`1(IEnumerable`1<T> values);
    public SynchronizedSet`1(IEqualityComparer`1<T> comparer);
    public SynchronizedSet`1(IEnumerable`1<T> values, IEqualityComparer`1<T> comparer);
    [IteratorStateMachineAttribute("JetBrains.Collections.Synchronized.SynchronizedSet`1/<GetEnumerator>d__7")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ISet<T>.Add(T item);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public T[] ExtractAll();
    [NullableContextAttribute("2")]
public T ExtractOneOrDefault();
    private HashSet`1<T> GetOrCloneSetNoLock();
    [CompilerGeneratedAttribute]
internal static T[] <ExtractAll>g__CopyToArray|30_0(HashSet`1<T> set);
}
public enum JetBrains.Collections.Viewable.AddRemove : Enum {
    public int value__;
    public static AddRemove Add;
    public static AddRemove Remove;
}
public enum JetBrains.Collections.Viewable.AddUpdateRemove : Enum {
    public int value__;
    public static AddUpdateRemove Add;
    public static AddUpdateRemove Update;
    public static AddUpdateRemove Remove;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.Collections.Viewable.AsyncSignal`1 : object {
    private ISignal`1<T> mySignal;
    public sealed virtual void AdviseOn(Lifetime lifetime, IScheduler scheduler, Action`1<T> action);
    public void Fire(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Collections.Viewable.DefaultScheduler : TaskSchedulerWrapper {
    public static DefaultScheduler Instance { get; }
    public static DefaultScheduler get_Instance();
}
[NullableContextAttribute("1")]
public interface JetBrains.Collections.Viewable.IAppendOnlyViewableConcurrentSet`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool Add(T value);
    public abstract virtual bool Contains(T value);
    public abstract virtual void View(Lifetime lifetime, Action`2<Lifetime, T> action);
}
[NullableContextAttribute("1")]
public interface JetBrains.Collections.Viewable.IAsyncProperty`1 {
    public T Value { get; public set; }
    public abstract virtual T get_Value();
    public abstract virtual void set_Value(T value);
}
[NullableContextAttribute("1")]
public interface JetBrains.Collections.Viewable.IAsyncSource`1 {
    public abstract virtual void AdviseOn(Lifetime lifetime, IScheduler scheduler, Action`1<T> action);
}
[NullableContextAttribute("1")]
public interface JetBrains.Collections.Viewable.IReadonlyAsyncProperty`1 {
    public IAsyncSource`1<T> Change { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Maybe`1<T> Maybe { get; }
    public T Value { get; }
    [NotNullAttribute]
public abstract virtual IAsyncSource`1<T> get_Change();
    [NotNullAttribute]
public abstract virtual Maybe`1<T> get_Maybe();
    public abstract virtual T get_Value();
}
[NullableContextAttribute("1")]
public interface JetBrains.Collections.Viewable.IReadonlyProperty`1 {
    public ISource`1<T> Change { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Maybe`1<T> Maybe { get; }
    public T Value { get; }
    [NotNullAttribute]
public abstract virtual ISource`1<T> get_Change();
    [NotNullAttribute]
public abstract virtual Maybe`1<T> get_Maybe();
    public abstract virtual T get_Value();
}
[NullableContextAttribute("1")]
public interface JetBrains.Collections.Viewable.IScheduler {
    public bool IsActive { get; }
    public bool OutOfOrderExecution { get; }
    public abstract virtual void Queue(Action action);
    public abstract virtual bool get_IsActive();
    public abstract virtual bool get_OutOfOrderExecution();
}
[NullableContextAttribute("2")]
public interface JetBrains.Collections.Viewable.ISignal`1 {
    public IScheduler Scheduler { get; public set; }
    public abstract virtual IScheduler get_Scheduler();
    public abstract virtual void set_Scheduler(IScheduler value);
    [NullableContextAttribute("1")]
public abstract virtual void Fire(T value);
}
[NullableContextAttribute("1")]
public interface JetBrains.Collections.Viewable.ISource`1 {
    public abstract virtual void Advise(Lifetime lifetime, Action`1<T> handler);
}
public interface JetBrains.Collections.Viewable.IViewableConcurrentSet`1 {
    [NullableContextAttribute("1")]
public abstract virtual bool Remove(T value);
}
public interface JetBrains.Collections.Viewable.IViewableList`1 {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ISource`1<ListEvent`1<T>> Change { get; }
    public abstract virtual ISource`1<ListEvent`1<T>> get_Change();
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface JetBrains.Collections.Viewable.IViewableMap`2 {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ISource`1<MapEvent`2<K, V>> Change { get; }
    public int Count { get; }
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public V Item { get; public set; }
    public abstract virtual ISource`1<MapEvent`2<K, V>> get_Change();
    public abstract virtual int get_Count();
    public abstract virtual ICollection`1<K> get_Keys();
    public abstract virtual ICollection`1<V> get_Values();
    public abstract virtual bool ContainsKey(K key);
    public abstract virtual V get_Item(K key);
    public abstract virtual void set_Item(K key, V value);
    public abstract virtual bool TryGetValue(K key, V& value);
}
[NullableContextAttribute("1")]
public interface JetBrains.Collections.Viewable.IViewableProperty`1 {
    public T Value { get; public set; }
    public abstract virtual T get_Value();
    public abstract virtual void set_Value(T value);
}
public interface JetBrains.Collections.Viewable.IViewableSet`1 {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ISource`1<SetEvent`1<T>> Change { get; }
    public abstract virtual ISource`1<SetEvent`1<T>> get_Change();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class JetBrains.Collections.Viewable.ListEvent`1 : ValueType {
    [CompilerGeneratedAttribute]
private AddUpdateRemove <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private V <OldValue>k__BackingField;
    [CompilerGeneratedAttribute]
private V <NewValue>k__BackingField;
    public AddUpdateRemove Kind { get; private set; }
    public int Index { get; private set; }
    public V OldValue { get; private set; }
    public V NewValue { get; private set; }
    private ListEvent`1(AddUpdateRemove kind, int index, V oldValue, V newValue);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public AddUpdateRemove get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(AddUpdateRemove value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public V get_OldValue();
    [CompilerGeneratedAttribute]
private void set_OldValue(V value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public V get_NewValue();
    [CompilerGeneratedAttribute]
private void set_NewValue(V value);
    [NullableContextAttribute("1")]
public static ListEvent`1<V> Add(int index, V newValue);
    [NullableContextAttribute("1")]
public static ListEvent`1<V> Update(int index, V oldValue, V newValue);
    [NullableContextAttribute("1")]
public static ListEvent`1<V> Remove(int index, V oldValue);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Collections.Viewable.MapEvent`2 : ValueType {
    [CompilerGeneratedAttribute]
private AddUpdateRemove <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private K <Key>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private V <OldValue>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private V <NewValue>k__BackingField;
    public AddUpdateRemove Kind { get; private set; }
    public K Key { get; private set; }
    [NullableAttribute("2")]
public V OldValue { get; private set; }
    [NullableAttribute("2")]
public V NewValue { get; private set; }
    [MemberNotNullWhenAttribute("True", "NewValue")]
public bool IsAdd { get; }
    [MemberNotNullWhenAttribute("True", "NewValue")]
[MemberNotNullWhenAttribute("True", "OldValue")]
public bool IsUpdate { get; }
    [MemberNotNullWhenAttribute("True", "OldValue")]
public bool IsRemove { get; }
    private MapEvent`2(AddUpdateRemove kind, K key, V oldValue, V newValue);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public AddUpdateRemove get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(AddUpdateRemove value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public K get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(K value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public V get_OldValue();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_OldValue(V value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public V get_NewValue();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_NewValue(V value);
    [MemberNotNullWhenAttribute("True", "NewValue")]
public bool get_IsAdd();
    [MemberNotNullWhenAttribute("True", "NewValue")]
[MemberNotNullWhenAttribute("True", "OldValue")]
public bool get_IsUpdate();
    [MemberNotNullWhenAttribute("True", "OldValue")]
public bool get_IsRemove();
    public static MapEvent`2<K, V> Add(K key, V newValue);
    public static MapEvent`2<K, V> Update(K key, V oldValue, V newValue);
    public static MapEvent`2<K, V> Remove(K key, V oldValue);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Collections.Viewable.ModificationCookieViewableSet`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<TCookie> myCookieFactory;
    private IViewableSet`1<T> myBackingSet;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ISource`1<SetEvent`1<T>> Change { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ModificationCookieViewableSet`2(Func`1<TCookie> cookieFactory, IViewableSet`1<T> backingSet);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual ISource`1<SetEvent`1<T>> get_Change();
    public sealed virtual void Advise(Lifetime lifetime, Action`1<SetEvent`1<T>> handler);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual bool Contains(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual bool Add(T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void Clear();
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Collections.Viewable.PrioritizedAction : object {
    public static int HighPriority;
    public static int NormalPriority;
    public static int LowPriority;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <Action>k__BackingField;
    public int Priority { get; }
    public Action Action { get; }
    public PrioritizedAction(Action action, int priority);
    [CompilerGeneratedAttribute]
public int get_Priority();
    [CompilerGeneratedAttribute]
public Action get_Action();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(PrioritizedAction other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Collections.Viewable.ReactiveEx : object {
    [ExtensionAttribute]
public static void Fire(ISignal`1<Unit> me);
    [ExtensionAttribute]
public static void AddLifetimed(ICollection`1<T> me, Lifetime lifetime, T item);
    [ExtensionAttribute]
public static void Advise(ISource`1<Unit> me, Lifetime lifetime, Action handler);
    [ExtensionAttribute]
public static void AdviseNotNull(ISource`1<T> me, Lifetime lifetime, Action`1<T> handler);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void AdviseNotNull(ISource`1<Nullable`1<T>> me, Lifetime lifetime, Action`1<T> handler);
    [ExtensionAttribute]
public static void AdviseUntil(ISource`1<T> me, Lifetime lifetime, Func`2<T, bool> handler);
    [ExtensionAttribute]
public static void AdviseOnce(ISource`1<T> me, Lifetime lifetime, Action`1<T> handler);
    [ExtensionAttribute]
public static void View(IReadonlyProperty`1<T> me, Lifetime lifetime, Action`2<Lifetime, T> handler);
    [ExtensionAttribute]
public static void ViewNotNull(IReadonlyProperty`1<T> me, Lifetime lifetime, Action`2<Lifetime, T> handler);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void ViewNotNull(IReadonlyProperty`1<Nullable`1<T>> me, Lifetime lifetime, Action`2<Lifetime, T> handler);
    [ExtensionAttribute]
public static void ViewNull(IReadonlyProperty`1<T> me, Lifetime lifetime, Action`1<Lifetime> handler);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void ViewNull(IReadonlyProperty`1<Nullable`1<T>> me, Lifetime lifetime, Action`1<Lifetime> handler);
    [ExtensionAttribute]
public static void View(IViewableMap`2<K, V> me, Lifetime lifetime, Action`2<Lifetime, KeyValuePair`2<K, V>> handler);
    [ExtensionAttribute]
public static void FlowInto(IViewableMap`2<K, V> me, Lifetime lifetime, IDictionary`2<K, V> storage);
    [ExtensionAttribute]
[ObsoleteAttribute("This method has horrible performance when adding 100+ items")]
public static void AddOrReplaceLifetimed(IViewableMap`2<K, V> me, Lifetime lifetime, K k, Func`2<Lifetime, V> vfun);
    [ExtensionAttribute]
public static void AdviseAddRemove(IViewableMap`2<K, V> me, Lifetime lifetime, Action`3<AddRemove, K, V> handler);
    [ExtensionAttribute]
public static void Advise(IViewableSet`1<T> me, Lifetime lifetime, Action`2<AddRemove, T> handler);
    [ExtensionAttribute]
public static void View(IViewableSet`1<T> me, Lifetime lifetime, Action`2<Lifetime, T> handler);
    [ExtensionAttribute]
public static void View(IViewableMap`2<K, V> me, Lifetime lifetime, Action`3<Lifetime, K, V> handler);
    [ExtensionAttribute]
public static void AdviseAddRemove(IViewableList`1<V> me, Lifetime lifetime, Action`3<AddRemove, int, V> handler);
    [ExtensionAttribute]
public static void View(IViewableList`1<V> me, Lifetime lifetime, Action`3<Lifetime, int, V> handler);
    [ExtensionAttribute]
public static bool HasValue(IReadonlyProperty`1<T> me);
    [ExtensionAttribute]
public static bool HasTrueValue(IReadonlyProperty`1<bool> me);
    [ExtensionAttribute]
public static void Compose(IReadonlyProperty`1<T1> first, Lifetime lifetime, IReadonlyProperty`1<T2> second, Action`2<T1, T2> composer);
    [ExtensionAttribute]
public static IReadonlyProperty`1<T> Compose(IReadonlyProperty`1<T1> first, Lifetime lifetime, IReadonlyProperty`1<T2> second, Func`3<T1, T2, T> composer);
    [ExtensionAttribute]
public static void WhenTrue(IReadonlyProperty`1<bool> property, Lifetime lifetime, Action`1<Lifetime> handler);
    [ExtensionAttribute]
public static void WhenFalse(IReadonlyProperty`1<bool> property, Lifetime lifetime, Action`1<Lifetime> handler);
    [ExtensionAttribute]
public static IReadonlyProperty`1<R> Select(IViewableProperty`1<T> source, Func`2<T, R> f);
    [ExtensionAttribute]
public static Task`1<T> NextNotNullValueAsync(ISource`1<T> source, Lifetime lifetime);
    [ExtensionAttribute]
public static Task`1<bool> NextTrueValueAsync(ISource`1<bool> source, Lifetime lifetime);
    [ExtensionAttribute]
public static Task`1<bool> NextFalseValueAsync(ISource`1<bool> source, Lifetime lifetime);
    [ExtensionAttribute]
public static Task`1<T> NextValueAsync(ISource`1<T> source, Lifetime lifetime);
    [ExtensionAttribute]
public static Task`1<T> NextValueAsync(ISource`1<T> source, Lifetime lifetime, Func`2<T, bool> condition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Collections.Viewable.SchedulerEx : object {
    [ExtensionAttribute]
public static void AssertThread(IScheduler scheduler, object debugInfo);
    [ExtensionAttribute]
public static void InvokeOrQueue(IScheduler sc, Action action);
    [ExtensionAttribute]
public static void InvokeOrQueue(IScheduler sc, Lifetime lifetime, Action action);
    [ExtensionAttribute]
public static void InvokeSync(IScheduler sc, Action action);
    [ExtensionAttribute]
public static TaskScheduler AsTaskScheduler(IScheduler scheduler);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Collections.Viewable.SchedulerWrapper : TaskScheduler {
    private SyncContext mySyncContext;
    private IScheduler myRealScheduler;
    public SchedulerWrapper(IScheduler realScheduler);
    protected virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    private bool TryExecuteTaskWithContext(Task task);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Collections.Viewable.SetEvent`1 : ValueType {
    [CompilerGeneratedAttribute]
private AddRemove <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public AddRemove Kind { get; private set; }
    public T Value { get; private set; }
    private SetEvent`1(AddRemove kind, T value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public AddRemove get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(AddRemove value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
[NotNullAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(T value);
    public static SetEvent`1<T> Add(T value);
    public static SetEvent`1<T> Remove(T value);
    public virtual string ToString();
}
public class JetBrains.Collections.Viewable.Signal : object {
    [ThreadStaticAttribute]
private static int ourPriorityCookie;
    internal static bool IsPriorityAdvise { get; }
    internal static bool get_IsPriorityAdvise();
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.Collections.Viewable.Signal`1 : SignalBase`1<T> {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class JetBrains.Collections.Viewable.SignalBase`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private LifetimedList`1<Action`1<T>> myListeners;
    [CompilerGeneratedAttribute]
private IScheduler <Scheduler>k__BackingField;
    public IScheduler Scheduler { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IScheduler get_Scheduler();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Scheduler(IScheduler value);
    [NullableContextAttribute("1")]
public virtual void Fire(T value);
    [NullableContextAttribute("1")]
public virtual void Advise(Lifetime lifetime, Action`1<T> handler);
    public sealed virtual void OnTermination(Lifetime lifetime);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Collections.Viewable.SingleThreadScheduler : TaskScheduler {
    private ILog myLog;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ActionPriority>k__BackingField;
    [CompilerGeneratedAttribute]
private Thread <Thread>k__BackingField;
    private ActionQueue myQueue;
    public string Name { get; }
    public int ActionPriority { get; }
    public Thread Thread { get; private set; }
    public bool IsIdle { get; }
    public bool IsActive { get; }
    public bool OutOfOrderExecution { get; }
    private SingleThreadScheduler(string name, ActionQueue queue, int actionPriority);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_ActionPriority();
    [CompilerGeneratedAttribute]
public Thread get_Thread();
    [CompilerGeneratedAttribute]
private void set_Thread(Thread value);
    [PublicAPIAttribute]
public static void RunInCurrentStackframe(Lifetime lifetime, string name, Action`1<SingleThreadScheduler> beforeStart);
    [PublicAPIAttribute]
public static SingleThreadScheduler RunOnSeparateThread(Lifetime lifetime, string name, Action`1<SingleThreadScheduler> beforeStart);
    public static SingleThreadScheduler CreateOverExisting(SingleThreadScheduler existingScheduler, string name, int actionPriority);
    public bool get_IsIdle();
    private void ExecuteOneAction(bool blockIfNoActionAvailable);
    private void Run();
    public bool PumpAndWaitFor(Lifetime lifetime, TimeSpan timeout, Func`1<bool> condition);
    public bool PumpAndWaitFor(Lifetime lifetime, Func`1<bool> condition);
    public bool PumpAndWaitFor(Func`1<bool> condition);
    public virtual string ToString();
    public sealed virtual void Queue(Action action);
    public sealed virtual bool get_IsActive();
    public sealed virtual bool get_OutOfOrderExecution();
    protected virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    [IteratorStateMachineAttribute("JetBrains.Collections.Viewable.SingleThreadScheduler/<GetScheduledTasks>d__32")]
protected virtual IEnumerable`1<Task> GetScheduledTasks();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Collections.Viewable.SynchronousScheduler : TaskScheduler {
    public static SynchronousScheduler Instance;
    [ThreadStaticAttribute]
private static int ourActive;
    public bool IsActive { get; }
    public bool OutOfOrderExecution { get; }
    private static SynchronousScheduler();
    public void SetActive(Lifetime lifetime);
    public sealed virtual void Queue(Action action);
    private static void Execute(Action action);
    public sealed virtual bool get_IsActive();
    public sealed virtual bool get_OutOfOrderExecution();
    [IteratorStateMachineAttribute("JetBrains.Collections.Viewable.SynchronousScheduler/<GetScheduledTasks>d__10")]
protected virtual IEnumerable`1<Task> GetScheduledTasks();
    protected virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Collections.Viewable.TaskSchedulerWrapper : object {
    private ThreadLocal`1<int> myExecutionCount;
    private TaskScheduler myScheduler;
    [CompilerGeneratedAttribute]
private bool <OutOfOrderExecution>k__BackingField;
    public bool IsActive { get; }
    public bool OutOfOrderExecution { get; }
    public TaskSchedulerWrapper(TaskScheduler scheduler, bool outOfOrderExecution);
    public sealed virtual bool get_IsActive();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_OutOfOrderExecution();
    public sealed virtual void Queue(Action action);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Collections.Viewable.ViewableConcurrentSet`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Signal`1<VersionedData<T>> mySignal;
    private Dictionary`2<T, LifetimeDefinition> myMap;
    private object myLocker;
    private int myCount;
    private int myAddVersion;
    private int myIsUnderReadingCount;
    public int Count { get; }
    public ViewableConcurrentSet`1(IEqualityComparer`1<T> comparer);
    public sealed virtual int get_Count();
    public sealed virtual bool Add(T value);
    public sealed virtual bool Remove(T value);
    public sealed virtual bool Contains(T value);
    public bool TryGetLifetime(T value, Lifetime& lifetime);
    private Dictionary`2<T, LifetimeDefinition> GetOrCloneMapNoLock();
    public sealed virtual void View(Lifetime lifetime, Action`2<Lifetime, T> action);
    [IteratorStateMachineAttribute("JetBrains.Collections.Viewable.ViewableConcurrentSet`1/<GetEnumerator>d__17")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class JetBrains.Collections.Viewable.ViewableList`1 : object {
    private IList`1<T> myStorage;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Signal`1<ListEvent`1<T>> myChange;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PublicAPIAttribute]
public ISource`1<ListEvent`1<T>> Change { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public T Item { get; public set; }
    public ViewableList`1(IList`1<T> list);
    public sealed virtual ISource`1<ListEvent`1<T>> get_Change();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Advise(Lifetime lifetime, Action`1<ListEvent`1<T>> handler);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class JetBrains.Collections.Viewable.ViewableMap`2 : object {
    private IDictionary`2<TK, TV> myStorage;
    private IEqualityComparer`1<TV> myValueComparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Signal`1<MapEvent`2<TK, TV>> myChange;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ISource`1<MapEvent`2<TK, TV>> Change { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TV Item { get; public set; }
    public ICollection`1<TK> Keys { get; }
    public ICollection`1<TV> Values { get; }
    [PublicAPIAttribute]
public ViewableMap`2(IEqualityComparer`1<TV> valueComparer);
    [PublicAPIAttribute]
public ViewableMap`2(IDictionary`2<TK, TV> storage, IEqualityComparer`1<TV> valueComparer);
    public sealed virtual ISource`1<MapEvent`2<TK, TV>> get_Change();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TK, TV>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<TK, TV> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TK, TV> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TK, TV> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool ContainsKey(TK key);
    public sealed virtual void Add(TK key, TV value);
    public sealed virtual bool Remove(TK key);
    public sealed virtual bool TryGetValue(TK key, TV& value);
    public sealed virtual TV get_Item(TK key);
    public sealed virtual void set_Item(TK key, TV value);
    public sealed virtual ICollection`1<TK> get_Keys();
    public sealed virtual ICollection`1<TV> get_Values();
    public sealed virtual void Advise(Lifetime lifetime, Action`1<MapEvent`2<TK, TV>> handler);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Collections.Viewable.ViewableProperty`1 : object {
    private Signal`1<T> myChange;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Maybe`1<T> <Maybe>k__BackingField;
    public ISource`1<T> Change { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Maybe`1<T> Maybe { get; private set; }
    public T Value { get; public set; }
    public ViewableProperty`1(T value);
    public sealed virtual ISource`1<T> get_Change();
    [CompilerGeneratedAttribute]
public sealed virtual Maybe`1<T> get_Maybe();
    [CompilerGeneratedAttribute]
private void set_Maybe(Maybe`1<T> value);
    public virtual T get_Value();
    public virtual void set_Value(T value);
    public sealed virtual void Advise(Lifetime lifetime, Action`1<T> handler);
    public bool SetIfEmpty(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Collections.Viewable.ViewableSet`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Signal`1<SetEvent`1<T>> myChange;
    private ISet`1<T> myStorage;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ISource`1<SetEvent`1<T>> Change { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    [PublicAPIAttribute]
public ViewableSet`1(ISet`1<T> storage);
    public sealed virtual ISource`1<SetEvent`1<T>> get_Change();
    public sealed virtual void Advise(Lifetime lifetime, Action`1<SetEvent`1<T>> handler);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual bool Contains(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual bool Add(T item);
    public sealed virtual bool Remove(T item);
    private void BulkFire(AddRemove kind, IEnumerable`1<T> values);
    public sealed virtual void Clear();
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Collections.Viewable.WriteOnceProperty`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private WriteOnceSignal<T> mySignal;
    private object myLock;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Maybe`1<T> myMaybe;
    public ISource`1<T> Change { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Maybe`1<T> Maybe { get; }
    public T Value { get; public set; }
    public sealed virtual ISource`1<T> get_Change();
    public sealed virtual Maybe`1<T> get_Maybe();
    public sealed virtual T get_Value();
    public sealed virtual void set_Value(T value);
    public bool SetIfEmpty(T newValue);
    public sealed virtual void Advise(Lifetime lifetime, Action`1<T> handler);
    internal void fireInternal(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Core.Maybe`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PublicAPIAttribute]
public static Maybe`1<T> None;
    [CompilerGeneratedAttribute]
private bool <HasValue>k__BackingField;
    private T myValue;
    public bool HasValue { get; }
    public T Value { get; }
    [NullableAttribute("2")]
public T ValueOrDefault { get; }
    public Maybe`1(T value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_HasValue();
    public T get_Value();
    [NullableContextAttribute("2")]
public T get_ValueOrDefault();
    public T OrElseThrow(Func`1<Exception> func);
    public Maybe`1<TK> Select(Func`2<T, TK> map);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Maybe`1<T> other);
    public virtual int GetHashCode();
    public static bool op_Equality(Maybe`1<T> left, Maybe`1<T> right);
    public static bool op_Inequality(Maybe`1<T> left, Maybe`1<T> right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Core.Nothing : object {
    [PublicAPIAttribute]
public T As();
    public static T Unreachable();
    public static Nothing Unreachable();
}
[ExtensionAttribute]
[PublicAPIAttribute]
public static class JetBrains.Core.Result : object {
    public static string EmptyFailMessage;
    public static Result`1<Unit> Unit;
    private static Result();
    public static Result`1<T> Success(T value);
    public static Result`1<Nothing> Fail(Exception exception, bool captureStackTrace);
    public static Result`2<Nothing, TFailure> Fail(Exception exception, TFailure failValue, bool captureStackTrace);
    public static Result`1<Nothing> Fail(string message);
    public static Result`2<Nothing, TFailure> Fail(string message, TFailure failValue);
    public static Result`2<Nothing, TFailure> FailWithValue(TFailure failValue);
    public static Result`1<Nothing> Canceled();
    public static Result`1<Nothing> Canceled(OperationCanceledException exception, bool captureStackTrace);
    [HandleProcessCorruptedStateExceptionsAttribute]
public static Result`1<TRes> Wrap(Func`1<TRes> f);
    [HandleProcessCorruptedStateExceptionsAttribute]
public static Result`1<Unit> Wrap(Action f);
    [HandleProcessCorruptedStateExceptionsAttribute]
public static Result`1<Unit> Wrap(Action`1<T> f, T param);
    [HandleProcessCorruptedStateExceptionsAttribute]
public static Result`1<TRes> Wrap(Func`2<T, TRes> f, T param);
    [ExtensionAttribute]
public static Task UnwrapTask(Result`1<Task> result);
    [ExtensionAttribute]
public static Task`1<T> UnwrapTask(Result`1<Task`1<T>> result);
    public static Result`1<T> FromCompletedTask(Task`1<T> task);
}
[IsReadOnlyAttribute]
[PublicAPIAttribute]
public class JetBrains.Core.Result`1 : ValueType {
    public T Value;
    internal object ExceptionOrExceptionDispatchInfo;
    public Exception Exception { get; }
    public string FailMessage { get; }
    public bool Succeed { get; }
    public bool FailedNotCanceled { get; }
    public bool Canceled { get; }
    internal Result`1(T success, object failure);
    public Exception get_Exception();
    public string get_FailMessage();
    public bool get_Succeed();
    public bool get_FailedNotCanceled();
    public bool get_Canceled();
    public static Result`1<T> op_Implicit(Result`1<Nothing> me);
    public Result`1<TRes> Map(Func`2<T, TRes> transform);
    public Result`1<TRes> Map(TRes successValue);
    public T Unwrap();
    public Task`1<T> AsCompletedTask();
    public virtual string ToString();
    public sealed virtual bool Equals(Result`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Result`1<T> left, Result`1<T> right);
    public static bool op_Inequality(Result`1<T> left, Result`1<T> right);
}
[IsReadOnlyAttribute]
[PublicAPIAttribute]
public class JetBrains.Core.Result`2 : ValueType {
    public TSuccess Value;
    internal object ExceptionOrExceptionDispatchInfo;
    public TFailure FailValue;
    public Exception Exception { get; }
    public string FailMessage { get; }
    public bool Succeed { get; }
    public bool FailedNotCanceled { get; }
    public bool Canceled { get; }
    internal Result`2(TSuccess success, object failure, TFailure failValue);
    public Exception get_Exception();
    public string get_FailMessage();
    public bool get_Succeed();
    public bool get_FailedNotCanceled();
    public bool get_Canceled();
    public static Result`2<TSuccess, TFailure> op_Implicit(Result`2<Nothing, TFailure> me);
    public static Result`1<TSuccess> op_Implicit(Result`2<TSuccess, TFailure> me);
    public static Result`2<TSuccess, TFailure> op_Implicit(Result`1<TSuccess> me);
    public TSuccess Unwrap();
    public virtual string ToString();
    public sealed virtual bool Equals(Result`2<TSuccess, TFailure> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Result`2<TSuccess, TFailure> left, Result`2<TSuccess, TFailure> right);
    public static bool op_Inequality(Result`2<TSuccess, TFailure> left, Result`2<TSuccess, TFailure> right);
}
public class JetBrains.Core.ResultException : Exception {
    public ResultException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Core.Unit : object {
    public static Unit Instance;
    private static Unit();
    public virtual string ToString();
    public sealed virtual bool Equals(Unit other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(Unit left, Unit right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(Unit left, Unit right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[LocalizableAttribute("False")]
public static class JetBrains.Diagnostics.Assertion : object {
    [NullableContextAttribute("2")]
[ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message);
    [ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, JetConditionalInterpolatedStringHandler& handler);
    [AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertCurrentThread(Thread thread);
    [NullableContextAttribute("2")]
[ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, T arg);
    [NullableContextAttribute("2")]
[ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, T1 arg1, T2 arg2);
    [NullableContextAttribute("2")]
[ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, T1 arg1, T2 arg2, T3 arg3);
    [NullableContextAttribute("2")]
[ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ContractAnnotationAttribute("condition:false=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void Assert(bool condition, string message, Object[] args);
    [ContractAnnotationAttribute("=>void")]
[AssertionMethodAttribute]
[DoesNotReturnAttribute]
public static void Fail(string message);
    [ContractAnnotationAttribute("=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[DoesNotReturnAttribute]
public static void Fail(string message, object arg);
    [NullableContextAttribute("2")]
[ContractAnnotationAttribute("=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[DoesNotReturnAttribute]
public static void Fail(string message, object arg1, object arg2);
    [NullableContextAttribute("2")]
[ContractAnnotationAttribute("=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[DoesNotReturnAttribute]
public static void Fail(string message, object arg1, object arg2, object arg3);
    [ContractAnnotationAttribute("=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[DoesNotReturnAttribute]
public static void Fail(string message, Object[] args);
    [NullableContextAttribute("2")]
[ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message);
    [NullableContextAttribute("2")]
[ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, JetNotNullConditionalInterpolatedStringHandler& messageHandler);
    [NullableContextAttribute("2")]
[ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, object arg);
    [NullableContextAttribute("2")]
[ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, object arg1, object arg2);
    [NullableContextAttribute("2")]
[ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, object arg1, object arg2, object arg3);
    [ContractAnnotationAttribute("condition:null=>void")]
[AssertionMethodAttribute]
[StringFormatMethodAttribute("message")]
[ConditionalAttribute("JET_MODE_ASSERT")]
public static void AssertNotNull(object condition, string message, Object[] args);
    [ExtensionAttribute]
[ContractAnnotationAttribute("value:null => void; => value:notnull, notnull")]
public static T NotNull(T value, string message);
    [ExtensionAttribute]
[ContractAnnotationAttribute("value:null => void; => value:notnull, notnull")]
public static T NotNull(T value, JetNotNullConditionalInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
[ContractAnnotationAttribute("value:null => void; => value:notnull, notnull")]
[StringFormatMethodAttribute("args")]
public static T NotNull(T value, string message, Object[] args);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[ContractAnnotationAttribute("value:null => void; => value:notnull")]
public static T NotNull(Nullable`1<T> value, string message);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[ContractAnnotationAttribute("value:null => void; => value:notnull")]
public static T NotNull(Nullable`1<T> value, JetNotNullConditionalInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
[ContractAnnotationAttribute("value:null => void; => value:notnull, notnull")]
public static T NotNull(T value, object debugMessage);
    [NullableContextAttribute("2")]
[StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
public static void Require(bool value, string message);
    [StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
public static void Require(bool value, JetConditionalInterpolatedStringHandler& messageHandler);
    [StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
public static void Require(bool value, string message, object arg1);
    [NullableContextAttribute("2")]
[StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
public static void Require(bool value, string message, object arg1, object arg2);
    [StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
public static void Require(bool value, string message, Object[] args);
    [ContractAnnotationAttribute("=> halt")]
[StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
[DoesNotReturnAttribute]
public static T FailWithResult(T result, string message);
    [ContractAnnotationAttribute("=> halt")]
[StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
[DoesNotReturnAttribute]
public static T FailWithResult(T result, string message, object arg);
    [ContractAnnotationAttribute("=> halt")]
[StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
[DoesNotReturnAttribute]
public static T FailWithResult(T result, string message, object arg1, object arg2);
    [NullableContextAttribute("2")]
[ContractAnnotationAttribute("=> halt")]
[StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
[DoesNotReturnAttribute]
public static T FailWithResult(T result, string message, object arg1, object arg2, object arg3);
    [ContractAnnotationAttribute("=> halt")]
[StringFormatMethodAttribute("message")]
[AssertionMethodAttribute]
[DoesNotReturnAttribute]
public static T FailWithResult(T result, string message, Object[] args);
}
public static class JetBrains.Diagnostics.FirstChanceExceptionInterceptor : object {
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static Stack ourThreadLocalDebugInfo;
    [NullableAttribute("1")]
public static string ExceptionDataKey;
    private static FirstChanceExceptionInterceptor();
    [NullableContextAttribute("1")]
private static Object[] GetThreadLocalDebugInfo();
}
[NullableContextAttribute("1")]
public interface JetBrains.Diagnostics.ILog {
    public string Category { get; }
    public abstract virtual string get_Category();
    public abstract virtual bool IsEnabled(LoggingLevel level);
    [NullableContextAttribute("2")]
public abstract virtual void Log(LoggingLevel level, string message, Exception exception);
}
[NullableContextAttribute("1")]
public interface JetBrains.Diagnostics.ILogFactory {
    public abstract virtual ILog GetLog(string category);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Diagnostics.Internal.LeveledMessage : ValueType {
    [CompilerGeneratedAttribute]
private LoggingLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormattedMessage>k__BackingField;
    public LoggingLevel Level { get; }
    public string FormattedMessage { get; }
    public LeveledMessage(LoggingLevel level, string formattedMessage);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public LoggingLevel get_Level();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_FormattedMessage();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class JetBrains.Diagnostics.Internal.LogBase : object {
    [CompilerGeneratedAttribute]
private Action`1<LeveledMessage> Handlers;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggingLevel <EnabledLevel>k__BackingField;
    [NullableAttribute("1")]
public string Category { get; }
    public LoggingLevel EnabledLevel { get; public set; }
    [NullableContextAttribute("1")]
protected LogBase(string category, LoggingLevel enabledLevel);
    [CompilerGeneratedAttribute]
public void add_Handlers(Action`1<LeveledMessage> value);
    [CompilerGeneratedAttribute]
public void remove_Handlers(Action`1<LeveledMessage> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual string get_Category();
    [CompilerGeneratedAttribute]
public LoggingLevel get_EnabledLevel();
    [CompilerGeneratedAttribute]
public void set_EnabledLevel(LoggingLevel value);
    public sealed virtual bool IsEnabled(LoggingLevel level);
    protected abstract virtual string Format(LoggingLevel level, string message, Exception exception);
    public virtual void Log(LoggingLevel level, string message, Exception exception);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class JetBrains.Diagnostics.Internal.LogFactoryBase : object {
    [CompilerGeneratedAttribute]
private Action`1<LeveledMessage> Handlers;
    [CompilerGeneratedAttribute]
public void add_Handlers(Action`1<LeveledMessage> value);
    [CompilerGeneratedAttribute]
public void remove_Handlers(Action`1<LeveledMessage> value);
    [NullableContextAttribute("1")]
public sealed virtual ILog GetLog(string category);
    [NullableContextAttribute("1")]
protected abstract virtual LogBase GetLogBase(string category);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Diagnostics.Internal.NullLog : object {
    public static NullLog Instance;
    private string JetBrains.Diagnostics.ILog.Category { get; }
    private static NullLog();
    private sealed virtual override string JetBrains.Diagnostics.ILog.get_Category();
    private sealed virtual override bool JetBrains.Diagnostics.ILog.IsEnabled(LoggingLevel level);
    [NullableContextAttribute("2")]
private sealed virtual override void JetBrains.Diagnostics.ILog.Log(LoggingLevel level, string message, Exception exception);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Diagnostics.Internal.SingletonLogFactory : object {
    private ILog myLog;
    public SingletonLogFactory(ILog log);
    public sealed virtual ILog GetLog(string category);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Diagnostics.Internal.TextWriterLog : LogBase {
    [CompilerGeneratedAttribute]
private TextWriter <Writer>k__BackingField;
    [PublicAPIAttribute]
public TextWriter Writer { get; }
    public TextWriterLog(TextWriter writer, string category, LoggingLevel enabledLevel);
    [CompilerGeneratedAttribute]
public TextWriter get_Writer();
    [NullableContextAttribute("2")]
protected virtual string Format(LoggingLevel level, string message, Exception exception);
    private void WriteMessage(LeveledMessage msg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Diagnostics.Internal.TextWriterLogFactory : LogFactoryBase {
    [CompilerGeneratedAttribute]
private LoggingLevel <EnabledLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <Writer>k__BackingField;
    public LoggingLevel EnabledLevel { get; }
    public TextWriter Writer { get; }
    public TextWriterLogFactory(TextWriter writer, LoggingLevel enabledLevel);
    [CompilerGeneratedAttribute]
public LoggingLevel get_EnabledLevel();
    [CompilerGeneratedAttribute]
public TextWriter get_Writer();
    protected virtual LogBase GetLogBase(string category);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Diagnostics.Log : object {
    private static StaticsForType`1<ILogFactory> ourStatics;
    private static ILogFactory modreq(System.Runtime.CompilerServices.IsVolatile) ourCurrentFactory;
    public static ILog Root;
    public static ILogFactory ConsoleVerboseFactory;
    public static string DefaultDateFormat;
    public static ILogFactory DefaultFactory { get; public set; }
    private static Log();
    public static ILogFactory get_DefaultFactory();
    public static void set_DefaultFactory(ILogFactory value);
    public static IDisposable UsingLogFactory(ILogFactory factory);
    public static ILog GetLog(string category);
    public static ILog GetLog(Type type);
    public static ILog GetLog();
    [NullableContextAttribute("2")]
public static string DefaultFormat(Nullable`1<DateTime> date, LoggingLevel loggingLevel, string category, Thread thread, string message, Exception exception);
    public static TextWriterLogFactory CreateFileLogFactory(Lifetime lifetime, string path, bool append, LoggingLevel enabledLevel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Diagnostics.LogEx : object {
    [ExtensionAttribute]
public static ILog GetSublogger(ILog log, string subcategory);
    [ExtensionAttribute]
public static bool IsTraceEnabled(ILog this);
    [ExtensionAttribute]
public static bool IsVersboseEnabled(ILog this);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogFormat(ILog this, LoggingLevel level, string message, T1 t1);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogFormat(ILog this, LoggingLevel level, string message, T1 t1, T2 t2);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogFormat(ILog this, LoggingLevel level, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogFormat(ILog this, LoggingLevel level, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void LogFormat(ILog this, LoggingLevel level, string message, Object[] args);
    [ExtensionAttribute]
public static void Trace(ILog this, string message);
    [ExtensionAttribute]
public static void Trace(ILog logger, JetLogTraceInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILog this, string message, T1 t1);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILog this, string message, T1 t1, T2 t2);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILog this, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILog this, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILog this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Trace(ILog this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6);
    [ExtensionAttribute]
public static void Verbose(ILog this, string message);
    [ExtensionAttribute]
public static void Verbose(ILog logger, JetLogVerboseInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
public static void Verbose(ILog logger, Exception ex, JetLogVerboseInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILog this, string message, T1 t1);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILog this, string message, T1 t1, T2 t2);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILog this, string message, T1 t1, T2 t2, T3 t3);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILog this, string message, T1 t1, T2 t2, T3 t3, T4 t4);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILog this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILog this, string message, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Verbose(ILog this, string message, Object[] args);
    [ExtensionAttribute]
public static void Verbose(ILog this, Exception ex, string message);
    [ExtensionAttribute]
public static void Info(ILog this, string message);
    [ExtensionAttribute]
public static void Info(ILog logger, JetLogInfoInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
public static void Info(ILog logger, Exception ex, JetLogInfoInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Info(ILog this, string message, Object[] args);
    [ExtensionAttribute]
public static void Info(ILog this, Exception ex, string message);
    [ExtensionAttribute]
public static void Warn(ILog this, string message);
    [ExtensionAttribute]
public static void Warn(ILog logger, JetLogWarnInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
public static void Warn(ILog logger, Exception ex, JetLogWarnInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Warn(ILog this, string message, Object[] args);
    [ExtensionAttribute]
public static void Warn(ILog this, Exception ex, string message);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILog this, string message);
    [ExtensionAttribute]
public static void Error(ILog logger, JetLogErrorInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILog logger, Exception ex, JetLogErrorInterpolatedStringHandler& messageHandler);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILog this, string message, Object[] args);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILog this, string message, Exception e);
    [ExtensionAttribute]
[StringFormatMethodAttribute("message")]
public static void Error(ILog this, Exception ex, string message);
    [ExtensionAttribute]
public static void Assert(ILog this, bool condition, string message);
    [ExtensionAttribute]
public static void Assert(ILog this, bool condition, string message, T t1);
    [ExtensionAttribute]
public static void Assert(ILog this, bool condition, string message, Object[] args);
    [ExtensionAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
public static void Catch(ILog log, Action action);
    [ExtensionAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[PublicAPIAttribute]
public static T Catch(ILog log, Func`1<T> action);
    [ExtensionAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[PublicAPIAttribute]
public static void CatchAndDrop(ILog log, Action action);
    [ExtensionAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[PublicAPIAttribute]
public static T CatchAndDrop(ILog log, Func`1<T> action);
    [ExtensionAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[PublicAPIAttribute]
public static void CatchWarn(ILog log, Action action);
    [ExtensionAttribute]
[HandleProcessCorruptedStateExceptionsAttribute]
[PublicAPIAttribute]
public static T CatchWarn(ILog log, Func`1<T> action);
    private static void DropException(Exception e);
    [ExtensionAttribute]
[StringFormatMethodAttribute("s")]
private static string FormatEx(string s, Object[] p);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static Nullable`1<LogWithLevel> WhenTrace(ILog logger);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static Nullable`1<LogWithLevel> WhenVerbose(ILog logger);
    [ExtensionAttribute]
[ObsoleteAttribute("Renamed to WhenTrace")]
public static Nullable`1<LogWithLevel> Trace(ILog logger);
    [ExtensionAttribute]
[ObsoleteAttribute("Renamed to WhenVerbose")]
public static Nullable`1<LogWithLevel> Verbose(ILog logger);
}
public enum JetBrains.Diagnostics.LoggingLevel : Enum {
    public int value__;
    public static LoggingLevel OFF;
    public static LoggingLevel FATAL;
    public static LoggingLevel ERROR;
    public static LoggingLevel WARN;
    public static LoggingLevel INFO;
    public static LoggingLevel VERBOSE;
    public static LoggingLevel TRACE;
}
[ExtensionAttribute]
public static class JetBrains.Diagnostics.LoggingLevelEx : object {
    [ExtensionAttribute]
public static bool IsSeriousError(LoggingLevel level);
    [ExtensionAttribute]
public static LoggingLevel AtLeast(Nullable`1<LoggingLevel> level, LoggingLevel least);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.Diagnostics.LogLog : object {
    private static LoggingLevel modreq(System.Runtime.CompilerServices.IsVolatile) ourSeverityFilter;
    private static object ourLock;
    private static List`1<Action`1<LogLogRecord>> ourEventListeners;
    [ThreadStaticAttribute]
private static bool ourReentrancyGuard;
    private static int MaxRecordsToStore;
    private static LinkedList`1<LogLogRecord> ourRecords;
    public static LoggingLevel SeverityFilter { get; public set; }
    public static List`1<LogLogRecord> StoredRecords { get; }
    private static LogLog();
    public static LoggingLevel get_SeverityFilter();
    public static void set_SeverityFilter(LoggingLevel value);
    public static void add_RecordsChanged(Action`1<LogLogRecord> value);
    public static void remove_RecordsChanged(Action`1<LogLogRecord> value);
    private static void Fire(string category, string msg, LoggingLevel severity);
    private static void RecordsStoreListener(LogLogRecord record);
    public static List`1<LogLogRecord> get_StoredRecords();
    internal static void ClearStoredRecords();
    public static void Error(Exception ex, string comment);
    public static void Error(string error);
    public static void Warn(string message);
    [StringFormatMethodAttribute("format")]
public static void Warn(string format, Object[] args);
    public static void Info(string message);
    [StringFormatMethodAttribute("format")]
public static void Info(string format, Object[] args);
    public static void Verbose(string category, string message);
    [StringFormatMethodAttribute("format")]
public static void Verbose(string category, string format, Object[] args);
    public static void Trace(string category, string message);
    [StringFormatMethodAttribute("format")]
public static void Trace(string category, string format, Object[] args);
    [StringFormatMethodAttribute("format")]
public static void Trace(string category, string format, T1 arg);
    [StringFormatMethodAttribute("format")]
public static void Trace(string category, string format, T1 arg1, T2 arg2);
    [HandleProcessCorruptedStateExceptionsAttribute]
public static void Catch(string comment, Action action);
    [HandleProcessCorruptedStateExceptionsAttribute]
public static void Catch(Action action);
    [NullableContextAttribute("2")]
[HandleProcessCorruptedStateExceptionsAttribute]
public static T Catch(Func`1<T> action);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Diagnostics.LogLogRecord : object {
    [CompilerGeneratedAttribute]
private DateTime <Time>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggingLevel <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public DateTime Time { get; }
    [NullableAttribute("2")]
public string Category { get; }
    public LoggingLevel Severity { get; }
    public string Message { get; }
    public LogLogRecord(string category, LoggingLevel severity, string message);
    [CompilerGeneratedAttribute]
public DateTime get_Time();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public LoggingLevel get_Severity();
    [CompilerGeneratedAttribute]
public string get_Message();
    public string Format(bool includeDate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Diagnostics.LogWithLevel : ValueType {
    [CompilerGeneratedAttribute]
private ILog <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggingLevel <Level>k__BackingField;
    [PublicAPIAttribute]
public ILog Logger { get; }
    [PublicAPIAttribute]
public LoggingLevel Level { get; }
    [PublicAPIAttribute]
public LogWithLevel(ILog logger, LoggingLevel level);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ILog get_Logger();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public LoggingLevel get_Level();
    [PublicAPIAttribute]
public void Log(string message);
    [PublicAPIAttribute]
public static Nullable`1<LogWithLevel> CreateIfEnabled(ILog logger, LoggingLevel level);
}
public static class JetBrains.Diagnostics.Mode : object {
    public static bool IsAssertion;
    public static bool IsAssertionUndefined;
    private static Mode();
}
public static class JetBrains.Diagnostics.ModeInitializer : object {
    [NullableAttribute("1")]
public static string AssertionEnabledVariableName;
    public static bool Init(bool isAssertionEnabled);
    public static bool GetIsAssertion();
    public static bool GetIsAssertionUndefined();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public static class JetBrains.Diagnostics.ProcessWatchdog : object {
    private static ILog ourLogger;
    internal static int DELAY_BEFORE_RETRY;
    private static int ERROR_INVALID_PARAMETER;
    private static ProcessWatchdog();
    public static void StartWatchdogForPidEnvironmentVariable(string envVarName, Action beforeProcessKill);
    public static void StartWatchdogForPidEnvironmentVariable(string envVarName, Lifetime lifetime, Nullable`1<TimeSpan> gracefulShutdownPeriod, Action beforeProcessKill);
    [NullableContextAttribute("2")]
public static void StartWatchdogForPid(int pid, Action beforeProcessKill);
    [NullableContextAttribute("2")]
public static void StartWatchdogForPid(int pid, Lifetime lifetime, Nullable`1<TimeSpan> gracefulShutdownPeriod, Action beforeProcessKill);
    public static void StartWatchdogForPid(Options options);
    private static int kill(int pid, int sig);
    public static bool ProcessExists(int pid, Boolean& useWinApi);
    private static bool ProcessExists_Windows(int pid);
    private static bool ProcessExists_SystemDiagnostics(int pid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Diagnostics.RName : object {
    [PublicAPIAttribute]
public static RName Empty;
    [NullableAttribute("2")]
[PublicAPIAttribute]
public RName Parent;
    [PublicAPIAttribute]
public string Separator;
    [PublicAPIAttribute]
public string LocalName;
    public RName(RName parent, string localName, string separator);
    public RName(string localName);
    private static RName();
    public RName Sub(string localName, string separator);
    public RName GetNonEmptyRoot();
    public RName DropNonEmptyRoot();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
public class JetBrains.Diagnostics.StringInterpolation.JetConditionalInterpolatedStringHandler : ValueType {
    private JetDefaultInterpolatedStringHandler myHandler;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    public bool IsEnabled { get; }
    public JetConditionalInterpolatedStringHandler(int literalLength, int formattedCount, bool condition, Boolean& isEnabled);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsEnabled();
    public virtual string ToString();
    public string ToStringAndClear();
    public void AppendLiteral(string value);
    public void AppendFormatted(T value);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, string format);
    public void AppendFormatted(T value, int alignment);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, int alignment, string format);
    [NullableContextAttribute("2")]
public void AppendFormatted(string value);
    [NullableContextAttribute("2")]
public void AppendFormatted(string value, int alignment, string format);
    [NullableContextAttribute("2")]
public void AppendFormatted(object value, int alignment, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class JetBrains.Diagnostics.StringInterpolation.JetDefaultInterpolatedStringHandler : ValueType {
    private StringBuilder myBuffer;
    public JetDefaultInterpolatedStringHandler(int literalLength, int formattedCount);
    public string ToStringAndClear();
    [NullableContextAttribute("2")]
public void AppendLiteral(string value);
    [NullableContextAttribute("2")]
private string ToStringFormatted(T value, string format);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, string format);
    public void AppendFormatted(T value, int alignment);
    public void AppendFormatted(T value);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, int alignment, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
public class JetBrains.Diagnostics.StringInterpolation.JetLogErrorInterpolatedStringHandler : ValueType {
    private JetLogLevelInterpolatedStringHandler myHandler;
    public bool IsEnabled { get; }
    public JetLogErrorInterpolatedStringHandler(int literalLength, int formattedCount, ILog logger, Boolean& isEnabled);
    public bool get_IsEnabled();
    public virtual string ToString();
    public string ToStringAndClear();
    public void AppendLiteral(string value);
    public void AppendFormatted(T value);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, string format);
    public void AppendFormatted(T value, int alignment);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, int alignment, string format);
    [NullableContextAttribute("2")]
public void AppendFormatted(string value);
    [NullableContextAttribute("2")]
public void AppendFormatted(string value, int alignment, string format);
    [NullableContextAttribute("2")]
public void AppendFormatted(object value, int alignment, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
public class JetBrains.Diagnostics.StringInterpolation.JetLogInfoInterpolatedStringHandler : ValueType {
    private JetLogLevelInterpolatedStringHandler myHandler;
    public bool IsEnabled { get; }
    public JetLogInfoInterpolatedStringHandler(int literalLength, int formattedCount, ILog logger, Boolean& isEnabled);
    public bool get_IsEnabled();
    public virtual string ToString();
    public string ToStringAndClear();
    public void AppendLiteral(string value);
    public void AppendFormatted(T value);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, string format);
    public void AppendFormatted(T value, int alignment);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, int alignment, string format);
    [NullableContextAttribute("2")]
public void AppendFormatted(string value);
    [NullableContextAttribute("2")]
public void AppendFormatted(string value, int alignment, string format);
    [NullableContextAttribute("2")]
public void AppendFormatted(object value, int alignment, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
public class JetBrains.Diagnostics.StringInterpolation.JetLogLevelInterpolatedStringHandler : ValueType {
    private JetConditionalInterpolatedStringHandler myHandler;
    public bool IsEnabled { get; }
    public JetLogLevelInterpolatedStringHandler(int literalLength, int formattedCount, ILog logger, LoggingLevel logLevel, Boolean& isEnabled);
    public bool get_IsEnabled();
    public virtual string ToString();
    public string ToStringAndClear();
    public void AppendLiteral(string value);
    public void AppendFormatted(T value);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, string format);
    public void AppendFormatted(T value, int alignment);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, int alignment, string format);
    [NullableContextAttribute("2")]
public void AppendFormatted(string value);
    [NullableContextAttribute("2")]
public void AppendFormatted(string value, int alignment, string format);
    [NullableContextAttribute("2")]
public void AppendFormatted(object value, int alignment, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
public class JetBrains.Diagnostics.StringInterpolation.JetLogTraceInterpolatedStringHandler : ValueType {
    private JetLogLevelInterpolatedStringHandler myHandler;
    public bool IsEnabled { get; }
    public JetLogTraceInterpolatedStringHandler(int literalLength, int formattedCount, ILog logger, Boolean& isEnabled);
    public bool get_IsEnabled();
    public virtual string ToString();
    public string ToStringAndClear();
    public void AppendLiteral(string value);
    public void AppendFormatted(T value);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, string format);
    public void AppendFormatted(T value, int alignment);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, int alignment, string format);
    [NullableContextAttribute("2")]
public void AppendFormatted(string value);
    [NullableContextAttribute("2")]
public void AppendFormatted(string value, int alignment, string format);
    [NullableContextAttribute("2")]
public void AppendFormatted(object value, int alignment, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
public class JetBrains.Diagnostics.StringInterpolation.JetLogVerboseInterpolatedStringHandler : ValueType {
    private JetLogLevelInterpolatedStringHandler myHandler;
    public bool IsEnabled { get; }
    public JetLogVerboseInterpolatedStringHandler(int literalLength, int formattedCount, ILog logger, Boolean& isEnabled);
    public bool get_IsEnabled();
    public virtual string ToString();
    public string ToStringAndClear();
    public void AppendLiteral(string value);
    public void AppendFormatted(T value);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, string format);
    public void AppendFormatted(T value, int alignment);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, int alignment, string format);
    [NullableContextAttribute("2")]
public void AppendFormatted(string value);
    [NullableContextAttribute("2")]
public void AppendFormatted(string value, int alignment, string format);
    [NullableContextAttribute("2")]
public void AppendFormatted(object value, int alignment, string format);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
public class JetBrains.Diagnostics.StringInterpolation.JetLogWarnInterpolatedStringHandler : ValueType {
    private JetLogLevelInterpolatedStringHandler myHandler;
    public bool IsEnabled { get; }
    public JetLogWarnInterpolatedStringHandler(int literalLength, int formattedCount, ILog logger, Boolean& isEnabled);
    public bool get_IsEnabled();
    public virtual string ToString();
    public string ToStringAndClear();
    public void AppendLiteral(string value);
    public void AppendFormatted(T value);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, string format);
    public void AppendFormatted(T value, int alignment);
    [NullableContextAttribute("2")]
public void AppendFormatted(T value, int alignment, string format);
    [NullableContextAttribute("2")]
public void AppendFormatted(string value);
    [NullableContextAttribute("2")]
public void AppendFormatted(string value, int alignment, string format);
    [NullableContextAttribute("2")]
public void AppendFormatted(object value, int alignment, string format);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[InterpolatedStringHandlerAttribute]
public class JetBrains.Diagnostics.StringInterpolation.JetNotNullConditionalInterpolatedStringHandler : ValueType {
    private JetConditionalInterpolatedStringHandler myHandler;
    public bool IsEnabled { get; }
    public JetNotNullConditionalInterpolatedStringHandler(int literalLength, int formattedCount, object obj, Boolean& isEnabled);
    public bool get_IsEnabled();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToStringAndClear();
    [NullableContextAttribute("1")]
public void AppendLiteral(string value);
    [NullableContextAttribute("1")]
public void AppendFormatted(T value);
    public void AppendFormatted(T value, string format);
    [NullableContextAttribute("1")]
public void AppendFormatted(T value, int alignment);
    public void AppendFormatted(T value, int alignment, string format);
    public void AppendFormatted(string value);
    public void AppendFormatted(string value, int alignment, string format);
    public void AppendFormatted(object value, int alignment, string format);
}
internal static class JetBrains.Interop.Kernel32 : object {
    [NullableAttribute("1")]
private static string DllName;
    public static IntPtr OpenProcess(ProcessAccessRights dwDesiredAccess, bool bInheritHandle, int dwProcessId);
    public static UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);
    public static bool CloseHandle(IntPtr handle);
}
[FlagsAttribute]
internal enum JetBrains.Interop.ProcessAccessRights : Enum {
    public int value__;
    public static ProcessAccessRights DELETE;
    public static ProcessAccessRights READ_CONTROL;
    public static ProcessAccessRights SYNCHRONIZE;
    public static ProcessAccessRights WRITE_DAC;
    public static ProcessAccessRights WRITE_OWNER;
    public static ProcessAccessRights PROCESS_CREATE_PROCESS;
    public static ProcessAccessRights PROCESS_CREATE_THREAD;
    public static ProcessAccessRights PROCESS_DUP_HANDLE;
    public static ProcessAccessRights PROCESS_QUERY_INFORMATION;
    public static ProcessAccessRights PROCESS_QUERY_LIMITED_INFORMATION;
    public static ProcessAccessRights PROCESS_SET_INFORMATION;
    public static ProcessAccessRights PROCESS_SET_QUOTA;
    public static ProcessAccessRights PROCESS_SUSPEND_RESUME;
    public static ProcessAccessRights PROCESS_TERMINATE;
    public static ProcessAccessRights PROCESS_VM_OPERATION;
    public static ProcessAccessRights PROCESS_VM_READ;
    public static ProcessAccessRights PROCESS_VM_WRITE;
}
internal enum JetBrains.Interop.ProcessExitCode : Enum {
    public int value__;
    public static ProcessExitCode STILL_ALIVE;
}
public interface JetBrains.Lifetimes.ITerminationHandler {
    public abstract virtual void OnTermination(Lifetime lifetime);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class JetBrains.Lifetimes.Lifetime : ValueType {
    [NullableAttribute("2")]
private LifetimeDefinition myDefinition;
    public static AsyncLocal`1<Lifetime> AsyncLocal;
    internal LifetimeDefinition Definition { get; }
    [PublicAPIAttribute]
public static Lifetime Eternal { get; }
    [PublicAPIAttribute]
public static Lifetime Terminated { get; }
    [PublicAPIAttribute]
public LifetimeStatus Status { get; }
    [PublicAPIAttribute]
public bool IsEternal { get; }
    [PublicAPIAttribute]
public bool IsAlive { get; }
    [PublicAPIAttribute]
public bool IsNotAlive { get; }
    [PublicAPIAttribute]
public LifetimeTerminationTimeoutKind TerminationTimeoutKind { get; }
    [PublicAPIAttribute]
public bool AllowTerminationUnderExecution { get; }
    [PublicAPIAttribute]
public int ExecutingCount { get; }
    [ObsoleteAttribute("For most cases you need `IsNotAlive` which means lifetime is terminated or soon will be terminated (somebody called Terminate() on this lifetime or its parent). If your operation makes sense in Canceling status (but must be stopped when resources termination already began) use Status < Terminating ")]
public bool IsTerminated { get; }
    [NullableAttribute("2")]
[PublicAPIAttribute]
public object Id { get; public set; }
    internal Lifetime(LifetimeDefinition definition);
    private static Lifetime();
    internal LifetimeDefinition get_Definition();
    public static Lifetime get_Eternal();
    public static Lifetime get_Terminated();
    public LifetimeStatus get_Status();
    public bool get_IsEternal();
    public bool get_IsAlive();
    public bool get_IsNotAlive();
    public LifetimeTerminationTimeoutKind get_TerminationTimeoutKind();
    public bool get_AllowTerminationUnderExecution();
    [PublicAPIAttribute]
public Lifetime OnTermination(Action action);
    [PublicAPIAttribute]
public Lifetime OnTermination(IDisposable disposable);
    [PublicAPIAttribute]
public Lifetime OnTermination(ITerminationHandler terminationHandler);
    [PublicAPIAttribute]
public bool TryOnTermination(Action action);
    [PublicAPIAttribute]
public bool TryOnTermination(IDisposable disposable);
    [PublicAPIAttribute]
public bool TryOnTermination(ITerminationHandler disposable);
    [PublicAPIAttribute]
public void Attach(LifetimeDefinition child, bool inheritTimeoutKind);
    public int get_ExecutingCount();
    [PublicAPIAttribute]
public AllowTerminationUnderExecutionCookie UsingAllowTerminationUnderExecution();
    [PublicAPIAttribute]
public ExecuteIfAliveCookie UsingExecuteIfAlive(bool allowTerminationUnderExecution);
    [PublicAPIAttribute]
public Result`1<T> TryExecute(Func`1<T> action, bool wrapExceptions);
    [PublicAPIAttribute]
public Result`1<Unit> TryExecute(Action action, bool wrapExceptions);
    [PublicAPIAttribute]
public T Execute(Func`1<T> action);
    [PublicAPIAttribute]
public void Execute(Action action);
    [PublicAPIAttribute]
public Result`1<Unit> TryBracket(Action opening, Action closing, bool wrapExceptions);
    [PublicAPIAttribute]
public Result`1<T> TryBracket(Func`1<T> opening, Action closing, bool wrapExceptions);
    [PublicAPIAttribute]
public Result`1<T> TryBracket(Func`1<T> opening, Action`1<T> closing, bool wrapExceptions);
    [PublicAPIAttribute]
public void Bracket(Action opening, Action closing);
    [PublicAPIAttribute]
public T Bracket(Func`1<T> opening, Action closing);
    [PublicAPIAttribute]
public T Bracket(Func`1<T> opening, Action`1<T> closing);
    [PublicAPIAttribute]
public CancellationToken ToCancellationToken();
    [PublicAPIAttribute]
public static CancellationToken op_Implicit(Lifetime lifetime);
    [PublicAPIAttribute]
public void ThrowIfNotAlive();
    [PublicAPIAttribute]
public static void Using(Action`1<Lifetime> action);
    [PublicAPIAttribute]
public static T Using(Func`2<Lifetime, T> action);
    [PublicAPIAttribute]
public void UsingNested(Action`1<Lifetime> action);
    [PublicAPIAttribute]
public T UsingNested(Func`2<Lifetime, T> action);
    [AsyncStateMachineAttribute("JetBrains.Lifetimes.Lifetime/<UsingAsync>d__49")]
[PublicAPIAttribute]
public static Task UsingAsync(Func`2<Lifetime, Task> action);
    [AsyncStateMachineAttribute("JetBrains.Lifetimes.Lifetime/<UsingAsync>d__50`1")]
[PublicAPIAttribute]
public static Task`1<T> UsingAsync(Func`2<Lifetime, Task`1<T>> action);
    [AsyncStateMachineAttribute("JetBrains.Lifetimes.Lifetime/<UsingAsync>d__51")]
[PublicAPIAttribute]
public static Task UsingAsync(OuterLifetime parent, Func`2<Lifetime, Task> action);
    [AsyncStateMachineAttribute("JetBrains.Lifetimes.Lifetime/<UsingAsync>d__52`1")]
[PublicAPIAttribute]
public static Task`1<T> UsingAsync(OuterLifetime parent, Func`2<Lifetime, Task`1<T>> action);
    [AsyncStateMachineAttribute("JetBrains.Lifetimes.Lifetime/<UsingNestedAsync>d__53`1")]
[PublicAPIAttribute]
public Task`1<TRetVal> UsingNestedAsync(Func`2<Lifetime, Task`1<TRetVal>> action);
    [AsyncStateMachineAttribute("JetBrains.Lifetimes.Lifetime/<UsingNestedAsync>d__54")]
public Task UsingNestedAsync(Func`2<Lifetime, Task> action);
    [PublicAPIAttribute]
public LifetimeDefinition CreateNested();
    [PublicAPIAttribute]
public LifetimeDefinition CreateNested(Action`1<LifetimeDefinition> atomicAction);
    [PublicAPIAttribute]
public Lifetime KeepAlive(object object);
    [PublicAPIAttribute]
public Lifetime AddDispose(IDisposable disposable);
    [ObsoleteAttribute("Use `Bracket` method instead")]
public Lifetime AddBracket(Action FOpening, Action FClosing);
    [ObsoleteAttribute("Use `OnTermination()` instead")]
public Lifetime AddAction(Action action);
    public bool get_IsTerminated();
    [ObsoleteAttribute("Use `KeepAlive() instead`")]
public Lifetime AddRef(object object);
    [ObsoleteAttribute("Reconsider your architecture and use Intersect")]
public static void Synchronize(LifetimeDefinition[] definitions);
    [PublicAPIAttribute]
public Lifetime Intersect(Lifetime other);
    [PublicAPIAttribute]
public static Lifetime Intersect(Lifetime lifetime1, Lifetime lifetime2);
    [PublicAPIAttribute]
public static Lifetime Intersect(Lifetime[] lifetimes);
    public static LifetimeDefinition DefineIntersection(Lifetime lifetime1, Lifetime lifetime2);
    [PublicAPIAttribute]
public static LifetimeDefinition DefineIntersection(Lifetime[] lifetimes);
    [NullableContextAttribute("2")]
public object get_Id();
    [NullableContextAttribute("2")]
public void set_Id(object value);
    [PublicAPIAttribute]
public void EnableTerminationLogging();
    public virtual string ToString();
    public static LifetimeDefinition Define(Lifetime lifetime, string id, Action`1<LifetimeDefinition> atomicAction);
    public static LifetimeDefinition Define(Lifetime lifetime, Action`1<Lifetime> atomicAction);
    [NullableContextAttribute("2")]
public static LifetimeDefinition Define(Lifetime lifetime, string id, Action`1<Lifetime> atomicAction);
    [PureAttribute]
public static LifetimeDefinition Define(string id);
    [NullableContextAttribute("0")]
private ScopedAsyncLocal`1<Lifetime> UsingAsyncLocal();
    [PublicAPIAttribute]
public Task ExecuteAsync(Func`1<Task> closure);
    [PublicAPIAttribute]
public Task`1<T> ExecuteAsync(Func`1<Task`1<T>> closure);
    [PublicAPIAttribute]
public Task TryExecuteAsync(Func`1<Task> closure, bool wrapExceptions);
    [PublicAPIAttribute]
public Task`1<T> TryExecuteAsync(Func`1<Task`1<T>> closure, bool wrapExceptions);
    [PublicAPIAttribute]
public Task Start(TaskScheduler scheduler, Action action, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task Start(TaskScheduler scheduler, Action`1<object> action, object state, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task`1<T> Start(TaskScheduler scheduler, Func`1<T> action, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task`1<T> Start(TaskScheduler scheduler, Func`2<object, T> action, object state, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task StartAsync(TaskScheduler scheduler, Func`1<Task> action, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task StartAsync(TaskScheduler scheduler, Func`2<object, Task> action, object state, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task`1<T> StartAsync(TaskScheduler scheduler, Func`1<Task`1<T>> action, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task`1<T> StartAsync(TaskScheduler scheduler, Func`2<object, Task`1<T>> action, object state, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task StartAttached(TaskScheduler scheduler, Action action, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task StartAttached(TaskScheduler scheduler, Action`1<object> action, object state, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task`1<T> StartAttached(TaskScheduler scheduler, Func`1<T> action, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task`1<T> StartAttached(TaskScheduler scheduler, Func`2<object, T> action, object state, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task StartAttachedAsync(TaskScheduler scheduler, Func`1<Task> action, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task StartAttachedAsync(TaskScheduler scheduler, Func`2<object, Task> action, object state, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task`1<T> StartAttachedAsync(TaskScheduler scheduler, Func`1<Task`1<T>> action, TaskCreationOptions options);
    [PublicAPIAttribute]
public Task`1<T> StartAttachedAsync(TaskScheduler scheduler, Func`2<object, Task`1<T>> action, object state, TaskCreationOptions options);
    [PublicAPIAttribute]
public TaskCompletionSource`1<T> CreateTaskCompletionSource(TaskCreationOptions options);
    [NullableContextAttribute("2")]
[PublicAPIAttribute]
public Lifetime CreateTerminatedAfter(TimeSpan timeSpan, TaskScheduler terminationScheduler);
    public static bool op_Equality(Lifetime left, Lifetime right);
    public static bool op_Inequality(Lifetime left, Lifetime right);
    public sealed virtual bool Equals(Lifetime other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [PublicAPIAttribute]
public static object WrapAsObject(Lifetime lifetime);
    [PublicAPIAttribute]
public static bool TryUnwrapAsObject(object obj, Lifetime& lifetime);
    [NullableContextAttribute("2")]
public Lifetime AssertEverTerminated(string comment);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("JetBrains.Lifetimes.Lifetime/<AssertTerminatesIn>d__110")]
public void AssertTerminatesIn(TimeSpan timeout, string comment);
    [AsyncStateMachineAttribute("JetBrains.Lifetimes.Lifetime/<RetryWhileOperationCancellingAsync>d__111")]
[PublicAPIAttribute]
public Task RetryWhileOperationCancellingAsync(Func`1<Task> task);
    [AsyncStateMachineAttribute("JetBrains.Lifetimes.Lifetime/<RetryWhileOperationCancellingAsync>d__112`1")]
[PublicAPIAttribute]
public Task`1<T> RetryWhileOperationCancellingAsync(Func`1<Task`1<T>> task);
}
public class JetBrains.Lifetimes.LifetimeCanceledException : OperationCanceledException {
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    [PublicAPIAttribute]
public Lifetime Lifetime { get; }
    public LifetimeCanceledException(Lifetime lifetime);
    [CompilerGeneratedAttribute]
public Lifetime get_Lifetime();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class JetBrains.Lifetimes.Lifetimed`1 : object {
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public Lifetime Lifetime { get; }
    public T Value { get; private set; }
    [NullableContextAttribute("1")]
public Lifetimed`1(Lifetime lifetime, T value);
    [PublicAPIAttribute]
public void Deconstruct(Lifetime& lifetime, T& value);
    [CompilerGeneratedAttribute]
public Lifetime get_Lifetime();
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(T value);
    private sealed virtual override void JetBrains.Lifetimes.ITerminationHandler.OnTermination(Lifetime lifetime);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Lifetimes.LifetimeDefinition : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private static AdditionalDiagnosticsInfo <AdditionalDiagnostics>k__BackingField;
    private static AdditionalDiagnosticsInfoStorage ourAdditionalDiagnosticsStorage;
    internal static ILog Log;
    [PublicAPIAttribute]
internal static LifetimeDefinition Eternal;
    [PublicAPIAttribute]
internal static LifetimeDefinition Terminated;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ThreadStaticAttribute]
private static Dictionary`2<LifetimeDefinition, int> ourThreadLocalExecuting;
    [ThreadStaticAttribute]
private static int ourAllowTerminationUnderExecutionThreadStatic;
    private static int WaitForExecutingInTerminationTimeoutMsDefault;
    [PublicAPIAttribute]
public static int WaitForExecutingInTerminationTimeoutMs;
    private static IntBitSlice ourExecutingSlice;
    private static Enum32BitSlice`1<LifetimeStatus> ourStatusSlice;
    private static BoolBitSlice ourMutexSlice;
    private static BoolBitSlice ourVerboseDiagnosticsSlice;
    private static BoolBitSlice ourAllowTerminationUnderExecutionSlice;
    private static BoolBitSlice ourLogErrorAfterExecution;
    private static Enum32BitSlice`1<LifetimeTerminationTimeoutKind> ourTerminationTimeoutKindSlice;
    private static Int32[] ourTerminationTimeoutMs;
    private static int ResourcesInitialCapacity;
    private int myResCount;
    [NullableAttribute("2")]
private Object[] myResources;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) myState;
    [PublicAPIAttribute]
public static string AnonymousLifetimeId;
    [NullableAttribute("2")]
private CancellationTokenSource myCts;
    [NullableAttribute("2")]
private object myId;
    [NullableAttribute("2")]
public static AdditionalDiagnosticsInfo AdditionalDiagnostics { get; public set; }
    public Lifetime Lifetime { get; }
    [PublicAPIAttribute]
public LifetimeStatus Status { get; }
    [PublicAPIAttribute]
public bool IsEternal { get; }
    public bool AllowTerminationUnderExecution { get; public set; }
    public LifetimeTerminationTimeoutKind TerminationTimeoutKind { get; public set; }
    [NullableAttribute("2")]
[PublicAPIAttribute]
public object Id { get; public set; }
    private bool IsVerboseLoggingEnabled { get; }
    [ObsoleteAttribute("Use `Lifetime.IsAlive` or `Status` field instead")]
public bool IsTerminated { get; }
    public int ExecutingCount { get; }
    private static LifetimeDefinition();
    public LifetimeDefinition(Lifetime parent);
    public LifetimeDefinition(Lifetime parent, Action`1<LifetimeDefinition> atomicAction);
    [NullableContextAttribute("2")]
public LifetimeDefinition(Lifetime parent, Action`1<Lifetime> atomicAction);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static AdditionalDiagnosticsInfo get_AdditionalDiagnostics();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void set_AdditionalDiagnostics(AdditionalDiagnosticsInfo value);
    private int ThreadLocalExecuting(int increment);
    [PublicAPIAttribute]
public static int GetTerminationTimeoutMs(LifetimeTerminationTimeoutKind timeoutKind);
    [PublicAPIAttribute]
public static void SetTerminationTimeoutMs(LifetimeTerminationTimeoutKind timeoutKind, int milliseconds);
    public Lifetime get_Lifetime();
    public LifetimeStatus get_Status();
    public bool get_IsEternal();
    [PublicAPIAttribute]
public bool get_AllowTerminationUnderExecution();
    [PublicAPIAttribute]
public void set_AllowTerminationUnderExecution(bool value);
    [PublicAPIAttribute]
public LifetimeTerminationTimeoutKind get_TerminationTimeoutKind();
    [PublicAPIAttribute]
public void set_TerminationTimeoutKind(LifetimeTerminationTimeoutKind value);
    [HandleProcessCorruptedStateExceptionsAttribute]
internal void ExecuteOrTerminateOnFail(Action`1<LifetimeDefinition> atomicAction);
    [NullableContextAttribute("2")]
[HandleProcessCorruptedStateExceptionsAttribute]
internal void ExecuteOrTerminateOnFail(Action`1<Lifetime> atomicAction);
    [NullableContextAttribute("2")]
public object get_Id();
    [NullableContextAttribute("2")]
public void set_Id(object value);
    private bool get_IsVerboseLoggingEnabled();
    public void EnableTerminationLogging();
    public virtual string ToString();
    private bool IncrementStatusIfEqualsTo(LifetimeStatus status);
    public sealed virtual void Dispose();
    public bool get_IsTerminated();
    private void Diagnostics(string msg);
    [PublicAPIAttribute]
public void Terminate();
    private void MarkCancelingRecursively();
    [HandleProcessCorruptedStateExceptionsAttribute]
private void Destruct();
    internal bool TryAdd(object action);
    internal Task Attached(Task task);
    internal Task`1<T> Attached(Task`1<T> task);
    internal void Attach(LifetimeDefinition child, bool inheritTimeoutKind);
    internal void OnTermination(object action);
    public int get_ExecutingCount();
    private void CheckNotNull(object action);
    private static Result`1<Unit> WrapOrThrow(Action action, bool wrap);
    private static Result`1<T> WrapOrThrow(Func`1<T> action, bool wrap);
    internal ExecuteIfAliveCookie UsingExecuteIfAlive(bool allowTerminationUnderExecution, bool disableIncrementThreadLocalExecuting);
    internal Result`1<T> TryExecute(Func`1<T> action, bool wrapExceptions);
    internal Result`1<Unit> TryExecute(Action action, bool wrapExceptions);
    internal Task TryExecuteAsync(Func`1<Task> closure, bool wrapExceptions);
    internal Task`1<T> TryExecuteAsync(Func`1<Task`1<T>> closure, bool wrapExceptions);
    internal T Execute(Func`1<T> action);
    internal void Execute(Action action);
    internal Task ExecuteAsync(Func`1<Task> closure);
    internal Task`1<T> ExecuteAsync(Func`1<Task`1<T>> closure);
    private void CheckNotNull(object opening, object closing);
    internal Result`1<Unit> TryBracket(Action opening, Action closing, bool wrapExceptions);
    internal Result`1<T> TryBracket(Func`1<T> opening, Action closing, bool wrapExceptions);
    internal Result`1<T> TryBracket(Func`1<T> opening, Action`1<T> closing, bool wrapExceptions);
    internal void Bracket(Action opening, Action closing);
    internal T Bracket(Func`1<T> opening, Action closing);
    internal T Bracket(Func`1<T> opening, Action`1<T> closing);
    private LifetimeCanceledException CanceledException();
    private Result`1<Nothing> CanceledResult();
    private CancellationTokenSource CreateCtsLazily();
    public void ThrowIfNotAlive();
    internal CancellationToken ToCancellationToken(bool doNotCreateCts);
    [NullableContextAttribute("2")]
[PublicAPIAttribute]
public void AssertEverTerminated(string comment);
    [PublicAPIAttribute]
public void SynchronizeWith(TaskCompletionSource`1<T> taskCompletionSource);
    [CompilerGeneratedAttribute]
private bool <Terminate>b__61_0();
    [CompilerGeneratedAttribute]
private bool <Terminate>b__61_1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Lifetimes.LifetimedList`1 : ValueType {
    private int myState;
    private int mySize;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueLifetimed`1[] myItems;
    public void Add(Lifetime lifetime, T value);
    public void AddPriorityItem(Lifetime lifetime, T value);
    public void Add(ValueLifetimed`1<T> item);
    public void AddPriorityItem(ValueLifetimed`1<T> item);
    private bool EnsureCapacityNoLock(bool priority, ValueLifetimed`1[]& items, Int32& marker, Int32& size);
    public void ClearValuesIfNotAlive();
    private void EnterGlobalLock();
    private void ReleaseGlobalLock();
    private void EnterLocalLock();
    private void ReleaseLocalLock();
    private void EnterLock(BoolBitSlice slice);
    private void ReleaseLock(BoolBitSlice slice);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Lifetimes.LifetimedListEx : object {
    internal static BoolBitSlice GlobalMutexSlice;
    internal static BoolBitSlice LocalMutexSlice;
    internal static IntBitSlice MarkerMutexSlice;
    private static LifetimedListEx();
    [NullableContextAttribute("2")]
[IteratorStateMachineAttribute("JetBrains.Lifetimes.LifetimedListEx/<Select>d__3`2")]
[ExtensionAttribute]
public static IEnumerable`1<TOut> Select(LifetimedList`1<TIn> source, Func`2<ValueLifetimed`1<TIn>, TOut> selector);
    [NullableContextAttribute("2")]
[IteratorStateMachineAttribute("JetBrains.Lifetimes.LifetimedListEx/<Where>d__4`1")]
[ExtensionAttribute]
public static IEnumerable`1<ValueLifetimed`1<T>> Where(LifetimedList`1<T> source, Func`2<ValueLifetimed`1<T>, bool> predicate);
}
public enum JetBrains.Lifetimes.LifetimeStatus : Enum {
    public int value__;
    public static LifetimeStatus Alive;
    public static LifetimeStatus Canceling;
    public static LifetimeStatus Terminating;
    public static LifetimeStatus Terminated;
}
public enum JetBrains.Lifetimes.LifetimeTerminationTimeoutKind : Enum {
    public int value__;
    public static LifetimeTerminationTimeoutKind Default;
    public static LifetimeTerminationTimeoutKind Short;
    public static LifetimeTerminationTimeoutKind Long;
    public static LifetimeTerminationTimeoutKind ExtraLong;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Lifetimes.OuterLifetime : ValueType {
    private Lifetime myLifetime;
    public bool IsTerminated { get; }
    internal LifetimeDefinition Def { get; }
    private OuterLifetime(Lifetime lifetime);
    public bool get_IsTerminated();
    public static OuterLifetime op_Implicit(Lifetime lifetime);
    public static OuterLifetime op_Implicit(LifetimeDefinition lifetime);
    public void AssertNotNull();
    public Task`1<TRetVal> UsingNestedAsync(Func`2<Lifetime, Task`1<TRetVal>> action);
    public Task UsingNestedAsync(Func`2<Lifetime, Task> action);
    internal LifetimeDefinition get_Def();
    public static LifetimeDefinition Define(OuterLifetime lifetime, string id, Action`2<LifetimeDefinition, Lifetime> atomicAction);
    [PublicAPIAttribute]
public static LifetimeDefinition DefineIntersection(OuterLifetime[] lifetimes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Lifetimes.SequentialLifetimes : object {
    private Lifetime myParentLifetime;
    private LifetimeDefinition myCurrentDef;
    public bool IsCurrentTerminated { get; }
    public SequentialLifetimes(Lifetime lifetime);
    public Lifetime Next();
    public void Next(Action`1<Lifetime> atomicAction);
    public void DefineNext(Action`1<LifetimeDefinition> atomicAction);
    public void TerminateCurrent();
    public bool get_IsCurrentTerminated();
    private LifetimeDefinition TrySetNewAndTerminateOld(LifetimeDefinition newLifetimeDefinition, Action`1<LifetimeDefinition> actionWithNewLifetime);
    [CompilerGeneratedAttribute]
internal static void <TrySetNewAndTerminateOld>g__TerminateLifetimeDefinition|9_0(LifetimeDefinition lifetimeDefinition);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class JetBrains.Lifetimes.ValueLifetimed`1 : ValueType {
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public Lifetime Lifetime { get; }
    public T Value { get; private set; }
    [NullableContextAttribute("1")]
public ValueLifetimed`1(Lifetime lifetime, T value);
    public void Deconstruct(Lifetime& lifetime, T& value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Lifetime get_Lifetime();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(T value);
    public void ClearValueIfNotAlive();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class JetBrains.Rd.Util.DictionaryEx : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
internal static TValue GetOrDefault(Dictionary`2<TKey, TValue> dictionary, TKey key, TValue default);
    [ExtensionAttribute]
[MustUseReturnValueAttribute]
internal static TValue GetOrCreate(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`1<TValue> factory);
    [ExtensionAttribute]
public static void BlockingAddUnique(IDictionary`2<TKey, TValue> dictionary, Lifetime lifetime, object lock, TKey key, TValue value);
}
public static class JetBrains.Serialization.NativeMemoryPool : object {
    public static int AllocSize;
    public static int MaxAllocSize;
    [NullableAttribute("1")]
private static string LogCategory;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static ThreadMemoryHolder ourThreadMemory;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadMemoryHolder[] ourBlocks;
    [NullableAttribute("1")]
private static object ourLock;
    private static NativeMemoryPool();
    public static int SampleUsed();
    public static int SampleCount();
    public static Cookie Reserve();
    public static bool TryFreeMemory();
    internal static Cookie ReserveMiss();
    private static IntPtr AllocateMemory(int allocSize);
    private static void ErrorOomOldMono();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <ReserveMiss>g__SearchAndReserve|10_0(ThreadMemoryHolder& holder);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <ReserveMiss>g__AllocateNew|10_1(ThreadMemoryHolder& holder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class JetBrains.Serialization.UnsafeReader : object {
    [NullableAttribute("0")]
private Byte* myPtr;
    [NullableAttribute("0")]
private Byte* myInitialPtr;
    private int myMaxlen;
    public static ReadDelegate`1<bool> BoolDelegate;
    public static ReadDelegate`1<bool> BooleanDelegate;
    public static ReadDelegate`1<byte> ByteDelegate;
    public static ReadDelegate`1<Guid> GuidDelegate;
    public static ReadDelegate`1<char> CharDelegate;
    public static ReadDelegate`1<decimal> DecimalDelegate;
    public static ReadDelegate`1<double> DoubleDelegate;
    public static ReadDelegate`1<float> FloatDelegate;
    public static ReadDelegate`1<short> Int16Delegate;
    public static ReadDelegate`1<short> ShortDelegate;
    public static ReadDelegate`1<int> Int32Delegate;
    public static ReadDelegate`1<int> IntDelegate;
    public static ReadDelegate`1<long> Int64Delegate;
    public static ReadDelegate`1<long> LongDelegate;
    public static ReadDelegate`1<ushort> UInt16Delegate;
    public static ReadDelegate`1<UInt32> UInt32Delegate;
    public static ReadDelegate`1<ulong> UInt64Delegate;
    public static ReadDelegate`1<DateTime> DateTimeDelegate;
    public static ReadDelegate`1<Uri> UriDelegate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReadDelegate`1<string> StringDelegate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReadDelegate`1<Byte[]> ByteArrayDelegate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReadDelegate`1<Boolean[]> BoolArrayDelegate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReadDelegate`1<Int32[]> IntArrayDelegate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReadDelegate`1<String[]> StringArrayDelegate;
    public int Position { get; }
    private static UnsafeReader();
    [NullableContextAttribute("0")]
public static UnsafeReader CreateReader(Byte* ptr, int len);
    public static void With(Byte[] data, Action`1<UnsafeReader> action);
    [NullableContextAttribute("0")]
public UnsafeReader Reset(Byte* ptr, int len);
    public int get_Position();
    public void Skip(int bytes);
    private void AssertLength(int size);
    private void ThrowOutOfRange(int size, int alreadyRead);
    [NullableContextAttribute("0")]
public Byte* ReadRaw(int count);
    public bool ReadBoolean();
    public byte ReadByte();
    public sbyte ReadSByte();
    public Guid ReadGuid();
    public char ReadChar();
    public decimal ReadDecimal();
    public double ReadDouble();
    public float ReadFloat();
    public short ReadInt16();
    public int ReadInt32();
    public int Read7BitEncodedInt32();
    public int ReadOftenSmallPositiveInt32();
    public long ReadInt64();
    public ushort ReadUInt16();
    public UInt32 ReadUInt32();
    public ulong ReadUInt64();
    public DateTime ReadDateTime();
    public TimeSpan ReadTimeSpan();
    public Uri ReadUri();
    [NullableContextAttribute("2")]
public string ReadString();
    public string ReadStringInterned(IRawStringIntern intern);
    [NullableContextAttribute("2")]
public T[] ReadArray(ReadDelegate`1<T> readDelegate);
    [NullableContextAttribute("2")]
public Int32[] ReadIntArray();
    [NullableContextAttribute("2")]
public Byte[] ReadByteArray();
    public TCollection ReadCollection(ReadDelegate`1<T> readDelegate, Func`2<int, TCollection> constructor);
    public TDictionary ReadDictionary(ReadDelegate`1<TKey> readKeyDelegate, ReadDelegate`1<TValue> readValueDelegate, Func`2<int, TDictionary> constructor);
    public bool ReadNullness();
    public bool ReadBool();
    public short ReadShort();
    public int ReadInt();
    public long ReadLong();
    public byte ReadUByte();
    public ushort ReadUShort();
    public UInt32 ReadUInt();
    public ulong ReadULong();
    public static ushort ReadUInt16FromBytes(Byte[] bytes);
    public static int ReadInt32FromBytes(Byte[] bytes, int offset);
    public static long ReadInt64FromBytes(Byte[] bytes, int offset);
    public static ulong ReadUInt64FromBytes(Byte[] bytes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[PublicAPIAttribute]
public class JetBrains.Serialization.UnsafeWriter : object {
    private int myInitialAllocSize;
    private static string LogCategory;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static UnsafeWriter ourWriter;
    [NullableAttribute("0")]
private Byte* myStartPtr;
    private int myCurrentAllocSize;
    [NullableAttribute("0")]
private Byte* myPtr;
    private int myCount;
    internal int ReleaseResources;
    [NullableAttribute("2")]
private ThreadMemoryHolder myMemory;
    private int myRecursionLevel;
    private static bool ourOldMonoFlag;
    public static WriteDelegate`1<bool> BooleanDelegate;
    public static WriteDelegate`1<byte> ByteDelegate;
    public static WriteDelegate`1<Guid> GuidDelegate;
    public static WriteDelegate`1<char> CharDelegate;
    public static WriteDelegate`1<decimal> DecimalDelegate;
    public static WriteDelegate`1<double> DoubleDelegate;
    public static WriteDelegate`1<float> FloatDelegate;
    public static WriteDelegate`1<short> Int16Delegate;
    public static WriteDelegate`1<int> Int32Delegate;
    public static WriteDelegate`1<long> Int64Delegate;
    public static WriteDelegate`1<ushort> UInt16Delegate;
    public static WriteDelegate`1<UInt32> UInt32Delegate;
    public static WriteDelegate`1<ulong> UInt64Delegate;
    public static WriteDelegate`1<DateTime> DateTimeDelegate;
    public static WriteDelegate`1<Uri> UriDelegate;
    public static WriteDelegate`1<string> StringDelegate;
    public static WriteDelegate`1<Byte[]> ByteArrayDelegate;
    public static WriteDelegate`1<Int32[]> IntArrayDelegate;
    public static WriteDelegate`1<String[]> StringArrayDelegate;
    [ObsoleteAttribute("Don't use")]
public static bool AllowUnsafeWriterCaching { get; public set; }
    private int Count { get; }
    [NullableAttribute("0")]
private Byte* Data { get; }
    [NullableAttribute("0")]
public Byte* Ptr { get; }
    private static UnsafeWriter();
    public static bool get_AllowUnsafeWriterCaching();
    public static void set_AllowUnsafeWriterCaching(bool value);
    public static Cookie NewThreadLocalWriter();
    [ObsoleteAttribute("Use NewThreadLocalWriter()")]
public static Cookie NewThreadLocalWriterNoCaching();
    [ObsoleteAttribute("Use NewThreadLocalWriter()")]
private static Cookie NewThreadLocalWriterImpl(bool allowCaching);
    private void Initialize();
    private void Deinitialize(int start);
    protected virtual override void Finalize();
    private void Reset(int start);
    private int get_Count();
    [NullableContextAttribute("0")]
private Byte* get_Data();
    [NullableContextAttribute("0")]
public Byte* get_Ptr();
    private void Prepare(int nbytes);
    private void Realloc(int newCount);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(bool value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(byte value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(Guid value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(char value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(decimal value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(double value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(float value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(short value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(int value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(long value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(ushort value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(UInt32 value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(ulong value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(DateTime value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(TimeSpan value);
    [CodeTemplateAttribute("$member$($arg$)")]
public void Write(Uri value);
    [NullableContextAttribute("2")]
[CodeTemplateAttribute("$member$($arg$)")]
public void Write(string value);
    public void WriteBoolean(bool value);
    public void WriteByte(byte value);
    public void WriteSByte(sbyte value);
    public void WriteGuid(Guid value);
    public void WriteChar(char value);
    public void WriteDecimal(decimal value);
    public void WriteDouble(double value);
    public void WriteFloat(float value);
    public void WriteInt16(short value);
    public void WriteInt32(int value);
    public void Write7BitEncodedInt32(int value);
    public void WriteOftenSmallPositiveInt32(int value);
    public static void WriteInt32ToBytes(int value, Byte[] data, int offset);
    public void WriteInt64(long value);
    public void WriteUint16(ushort value);
    public void WriteUInt32(UInt32 value);
    public void WriteUint64(ulong value);
    public void WriteDateTime(DateTime value);
    public void WriteTimeSpan(TimeSpan value);
    public void WriteUri(Uri value);
    [NullableContextAttribute("2")]
public void WriteString(string value);
    [NullableContextAttribute("2")]
public void WriteStringContent(string value);
    [NullableContextAttribute("2")]
public void WriteStringContent(string value, int offset, int count);
    private static void WriteStringContentInternal(UnsafeWriter wrt, string value, int offset, int count);
    private static void WriteStringContentInternalAfterMono5(UnsafeWriter wrt, string value, int offset, int count);
    private static void WriteStringContentInternalBeforeMono5(UnsafeWriter wrt, string value, int offset, int count);
    [NullableContextAttribute("0")]
public void Write(Byte* ptr, int size);
    [NullableContextAttribute("2")]
[CodeTemplateAttribute("$member$($arg$)")]
public void Write(Int32[] value);
    [NullableContextAttribute("2")]
[CodeTemplateAttribute("$member$($arg$)")]
public void Write(Byte[] value);
    [NullableContextAttribute("2")]
public void WriteArray(Int32[] value);
    [NullableContextAttribute("2")]
public void WriteByteArray(Byte[] value);
    public void WriteRaw(Byte[] value);
    public void WriteRaw(Byte[] value, int start, int length);
    [MustUseReturnValueAttribute]
public Bookmark MakeBookmark();
    public Bookmark Alloc(int length);
    [CodeTemplateAttribute("$member$($args$)")]
public void Write(WriteDelegate`1<T> writeDelegate, TCollection value);
    public void WriteCollection(WriteDelegate`1<T> writeDelegate, TCollection value);
    public void Write(WriteDelegate`1<TK> writeKeyDelegate, WriteDelegate`1<TV> writeValueDelegate, TDictionary value);
    [NullableContextAttribute("0")]
[ContractAnnotationAttribute("null=>false")]
public bool WriteNullness(Nullable`1<T> value);
    [ContractAnnotationAttribute("null=>false")]
public bool WriteNullness(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Threading.Actor`1 : object {
    [PublicAPIAttribute]
public string Id;
    private Func`2<T, Task> myProcessor;
    private AsyncChannel`1<T> myChannel;
    private ILog myLog;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AsyncLocal`1<Unit> myInsideProcessingFlow;
    private long myTotalMessagesProcessed;
    [PublicAPIAttribute]
public ISendChannel`1<T> Channel { get; }
    [PublicAPIAttribute]
public bool IsEmpty { get; }
    [PublicAPIAttribute]
public bool IsNotEmpty { get; }
    public bool IsInsideProcessing { get; }
    public Actor`1(string id, Lifetime lifetime, Action`1<T> processor, TaskScheduler scheduler, int maxQueueSize);
    public Actor`1(string id, Lifetime lifetime, Func`2<T, Task> processor, TaskScheduler scheduler, int maxQueueSize);
    public ISendChannel`1<T> get_Channel();
    public bool get_IsEmpty();
    public bool get_IsNotEmpty();
    public bool get_IsInsideProcessing();
    [AsyncStateMachineAttribute("JetBrains.Threading.Actor`1/<Process>d__16")]
[HandleProcessCorruptedStateExceptionsAttribute]
private Task Process();
    public sealed virtual void SendBlocking(T msg);
    public sealed virtual Task SendAsync(T msg);
    [AsyncStateMachineAttribute("JetBrains.Threading.Actor`1/<SendOrExecuteInline>d__19")]
public Task SendOrExecuteInline(T msg);
    public void WaitForEmpty();
    [CompilerGeneratedAttribute]
private bool <WaitForEmpty>b__20_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Threading.AsyncChannel`1 : object {
    private Lifetime myLifetime;
    private object myLock;
    private Queue`1<TaskCompletionSource`1<Unit>> mySenders;
    private Queue`1<T> myMessages;
    private Queue`1<TaskCompletionSource`1<T>> myReceivers;
    private int myTotalMessagesSent;
    [PublicAPIAttribute]
public int SendBufferSize;
    [PublicAPIAttribute]
public long TotalMessagesSent { get; }
    [PublicAPIAttribute]
public bool IsEmpty { get; }
    public AsyncChannel`1(Lifetime lifetime, int sendBufferSize);
    public long get_TotalMessagesSent();
    public bool get_IsEmpty();
    private void SetCanceledIsolated(TaskCompletionSource`1<TResult> tcs);
    [PublicAPIAttribute]
public sealed virtual void SendBlocking(T msg);
    [PublicAPIAttribute]
public sealed virtual T ReceiveBlocking();
    private void AssertState();
    public virtual string ToString();
    [PublicAPIAttribute]
public sealed virtual Task SendAsync(T msg);
    [PublicAPIAttribute]
public sealed virtual Task`1<T> ReceiveAsync();
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_0();
}
public class JetBrains.Threading.ByteBufferAsyncProcessor : object {
    private static string LogCategory;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    private Processor myProcessor;
    private object myLock;
    [CompilerGeneratedAttribute]
private long <AcknowledgedSeqN>k__BackingField;
    private static int DefaultChunkSize;
    private ILog myLog;
    [PublicAPIAttribute]
public int ChunkSize;
    private static int DefaultShrinkIntervalMs;
    private int myLastShrinkOrGrowTimeMs;
    [PublicAPIAttribute]
public int ShrinkIntervalMs;
    private bool myAllDataProcessed;
    private HashSet`1<string> myPauseReasons;
    [CompilerGeneratedAttribute]
private StateKind <State>k__BackingField;
    private Chunk myChunkToFill;
    private bool myProcessing;
    private Chunk modreq(System.Runtime.CompilerServices.IsVolatile) myChunkToProcess;
    private Thread myAsyncProcessingThread;
    [PublicAPIAttribute]
public string Id { get; }
    public long AcknowledgedSeqN { get; private set; }
    public bool AllDataProcessed { get; }
    public StateKind State { get; private set; }
    public int ChunkCount { get; }
    public ByteBufferAsyncProcessor(string id, Processor processor);
    public ByteBufferAsyncProcessor(string id, int chunkSize, Processor processor);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public long get_AcknowledgedSeqN();
    [CompilerGeneratedAttribute]
private void set_AcknowledgedSeqN(long value);
    public bool get_AllDataProcessed();
    [CompilerGeneratedAttribute]
public StateKind get_State();
    [CompilerGeneratedAttribute]
private void set_State(StateKind value);
    public int get_ChunkCount();
    private void CleanupInternal();
    private bool TerminateInternal(int timeoutMs, StateKind state, string action);
    private void ThreadProcCatchAbort();
    public void Acknowledge(long seqNumber);
    public void ReprocessUnacknowledged();
    private void ThreadProc();
    public void Start();
    private void Reset(int chunkSize);
    public void Clear();
    public bool Pause(string reason);
    private void WaitProcessingFinished();
    public bool Resume(string reason);
    public bool Stop(int timeoutMs);
    public bool Terminate(int timeoutMs);
    [PublicAPIAttribute]
public void Put(Byte[] data);
    [PublicAPIAttribute]
public void Put(Cookie data);
    [HandleProcessCorruptedStateExceptionsAttribute]
[PublicAPIAttribute]
public void Put(Byte* start, int count);
    private void GrowConditionally();
    private void ShrinkConditionally(Chunk upTo);
    [CompilerGeneratedAttribute]
private void <TerminateInternal>b__36_0();
}
[ExtensionAttribute]
public static class JetBrains.Threading.ExceptionEx : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PublicAPIAttribute]
public static bool IsOperationCanceled(Exception exception);
}
[NullableContextAttribute("1")]
public interface JetBrains.Threading.IReceiveChannel`1 {
    public abstract virtual T ReceiveBlocking();
    public abstract virtual Task`1<T> ReceiveAsync();
}
[NullableContextAttribute("1")]
public interface JetBrains.Threading.ISendChannel`1 {
    public abstract virtual void SendBlocking(T msg);
    public abstract virtual Task SendAsync(T msg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Threading.ProactiveLazy`1 : object {
    private Task`1<T> myTask;
    public ProactiveLazy`1(Lifetime lifetime, Func`1<T> factory, TaskScheduler taskScheduler);
    [PublicAPIAttribute]
public T GetOrWait();
    [PublicAPIAttribute]
public T GetOrWait(Lifetime lifetime);
    [PublicAPIAttribute]
public TaskAwaiter`1<T> GetAwaiter();
    [PublicAPIAttribute]
public Task`1<T> AsTask();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Threading.ScopedAsyncLocal`1 : ValueType {
    private AsyncLocal`1<T> myAsyncLocal;
    private T myOldValue;
    public ScopedAsyncLocal`1(AsyncLocal`1<T> asyncLocal, T value);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.Threading.SpinWaitEx : object {
    [PublicAPIAttribute]
public static void SpinUntil(Func`1<bool> condition);
    [PublicAPIAttribute]
public static bool SpinUntil(Lifetime lifetime, Func`1<bool> condition);
    [PublicAPIAttribute]
public static bool SpinUntil(TimeSpan timeout, Func`1<bool> condition);
    [PublicAPIAttribute]
public static bool SpinUntil(Lifetime lifetime, TimeSpan timeout, Func`1<bool> condition);
    [PublicAPIAttribute]
public static bool SpinUntil(Lifetime lifetime, long timeoutMs, Func`1<bool> condition);
    [AsyncStateMachineAttribute("JetBrains.Threading.SpinWaitEx/<SpinUntilAsync>d__5")]
[PublicAPIAttribute]
public static Task`1<bool> SpinUntilAsync(Lifetime lifetime, long timeoutMs, int delayBetweenChecksMs, Func`1<bool> condition);
}
public class JetBrains.Threading.SpinWaitLock : ValueType {
    private int _ownerThreadId;
    private int _lockCount;
    private static int _processorCount;
    private static int _sleepCount;
    public static int ApprovedProcessorCount { get; }
    private static SpinWaitLock();
    public static int get_ApprovedProcessorCount();
    public bool TryEnter();
    public void Enter();
    public void Exit();
    private bool TryEnter(int currentThreadId);
    private static void CalcApprovedProcessorCount();
    private static void Sleep();
}
[ExtensionAttribute]
[UsedImplicitlyAttribute]
public static class JetBrains.Threading.SpinWaitLockExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("It is not possible to use the using() pattern with the non-allocating SpinWaitLock because its lock status is cloned on copying. Either call paired methods, or use SpinWaitLockRef and allocate a heap object.")]
[UsedImplicitlyAttribute]
public static SpinWaitLockCookie Acquire(SpinWaitLock spinWaitLock);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Threading.TaskEx : object {
    private static Action`1<Task> ourNoAwaitContinuation;
    private static TaskEx();
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PublicAPIAttribute]
public static void NoAwait(Task task);
    [ExtensionAttribute]
[PublicAPIAttribute]
public static IReadonlyProperty`1<Result`1<T>> ToResultProperty(Task`1<T> task);
    [ExtensionAttribute]
public static T GetOrWait(Task`1<T> task, Lifetime lifetime);
    [ExtensionAttribute]
public static bool IsOperationCanceled(Task task);
    [AsyncStateMachineAttribute("JetBrains.Threading.TaskEx/<Select>d__5`2")]
[ExtensionAttribute]
[PublicAPIAttribute]
public static Task`1<TDst> Select(Task`1<TSrc> task, Func`2<TSrc, TDst> selector);
}
[ExtensionAttribute]
public static class JetBrains.Threading.ThreadEx : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToThreadString(Thread thread);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.Util.BitHacks : object {
    private static UInt32 DeBruijnSequence32;
    private static ulong DeBruijnSequence64;
    private static Byte[] ourDeBruijnBitTable32;
    private static Byte[] ourDeBruijnBitTable64;
    private static BitHacks();
    public static int Log2Floor(int x);
    public static int Log2Floor(long x);
    public static int Log2Ceil(int x);
    public static int Log2Ceil(long x);
    public static int NumberOfBitSet(int x);
    private static int ReverseBitScan(UInt32 value);
    private static int ReverseBitScan(ulong value);
}
public static class JetBrains.Util.EmptyAction : object {
    [NullableAttribute("1")]
public static Action Instance;
    private static EmptyAction();
}
public static class JetBrains.Util.EmptyAction`1 : object {
    [NullableAttribute("1")]
public static Action`1<T> Instance;
    private static EmptyAction`1();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.Util.EmptyAction`2 : object {
    [NullableAttribute("1")]
public static Action`2<T1, T2> Instance;
    private static EmptyAction`2();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class JetBrains.Util.EmptyAction`3 : object {
    [NullableAttribute("1")]
public static Action`3<T1, T2, T3> Instance;
    private static EmptyAction`3();
}
public static class JetBrains.Util.EmptyArray : object {
    [NullableContextAttribute("1")]
[PureAttribute]
public static T[] GetInstance();
}
[DebuggerDisplayAttribute("Length = 0")]
public static class JetBrains.Util.EmptyArray`1 : object {
    [NullableAttribute("1")]
public static T[] Instance;
    private static EmptyArray`1();
}
public static class JetBrains.Util.GenericUtil`1 : object {
    public static bool IsValueWriteAtomic;
    private static GenericUtil`1();
    private static bool IsValueWriteAtomicCalculate();
}
public class JetBrains.Util.Internal.Memory : object {
    public static void CopyMemory(Byte* src, Byte* dest, int len);
    public static void Barrier();
    public static T VolatileRead(T& location);
    public static void VolatileWrite(T& location, T value);
    public static int VolatileRead(Int32& location);
    public static void VolatileWrite(Int32& location, int value);
    public static bool VolatileRead(Boolean& location);
    public static void VolatileWrite(Boolean& location, bool value);
}
[IsReadOnlyAttribute]
public class JetBrains.Util.LocalStopwatch : ValueType {
    private static long TicksPerMillisecond;
    private static long TicksPerSecond;
    private static long ourFrequency;
    private static double ourTickFrequency;
    private long myStartTimeStamp;
    public TimeSpan Elapsed { get; }
    public long ElapsedMilliseconds { get; }
    public long ElapsedTicks { get; }
    private static LocalStopwatch();
    private LocalStopwatch(long startTimeStamp);
    public static LocalStopwatch StartNew();
    public TimeSpan get_Elapsed();
    public long get_ElapsedMilliseconds();
    public long get_ElapsedTicks();
    private long GetElapsedDateTimeTicks();
    private void AssertTimeStamp();
}
public static class JetBrains.Util.MethodImplAdvancedOptions : object {
    public static MethodImplOptions AggressiveInlining;
}
[ExtensionAttribute]
public static class JetBrains.Util.NullableEx : object {
    [ExtensionAttribute]
public static Nullable`1<T> ToNullable(T t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Util.ReflectionUtil : object {
    public static SetValueDelegate GetSetter(MemberInfo mi);
    public static SetValueDelegate TryGetSetter(MemberInfo mi);
    public static Func`2<object, object> GetGetter(MemberInfo mi);
    public static Type GetReturnType(MemberInfo mi);
    [NullableContextAttribute("2")]
public static T Call(MethodInfo method, object thisArg, Object[] parameters);
    public static object InvokeGenericThis(object self, string methodName, Type argument, Object[] parameters);
    public static object InvokeStaticGeneric(Type type, string methodName, Type argument, Object[] parameters);
    public static object InvokeStaticGeneric2(Type type, string methodName, Type argument1, Type argument2, Object[] parameters);
    public static object TryGetNonStaticField(object ownerObject, string memberName);
    public static object TryGetNonStaticProperty(object ownerObject, string memberName);
    [IteratorStateMachineAttribute("JetBrains.Util.ReflectionUtil/<EnumerateEnumValues>d__11`1")]
public static IEnumerable`1<T> EnumerateEnumValues();
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T GetPropertyValueSafe(object o, string propertyName, T defaultValue);
    public static T SetStaticInstanceProperty(Lifetime lifetime, Type type);
    [CompilerGeneratedAttribute]
internal static SetValueDelegate <TryGetSetter>g__GetFieldSetter|2_0(FieldInfo backingField);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[IsReadOnlyAttribute]
public class JetBrains.Util.RentedValueCookie`1 : ValueType {
    private SingleThreadObjectPool`1<T> myPool;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; }
    public RentedValueCookie`1(SingleThreadObjectPool`1<T> pool, T value);
    [CompilerGeneratedAttribute]
public T get_Value();
    public void Dispose();
}
public static class JetBrains.Util.RuntimeInfo : object {
    [NullableAttribute("2")]
public static Version CurrentMonoVersion;
    public static bool IsRunningOnMono;
    public static bool IsRunningUnderWindows;
    public static bool IsRunningOnCore;
    public static bool IsUnalignedAccessAllowed;
    private static RuntimeInfo();
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class JetBrains.Util.SingleThreadListPool`1 : SingleThreadObjectPool`1<List`1<T>> {
    public SingleThreadListPool`1(int maxCapacity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Util.SingleThreadObjectPool`1 : object {
    private int myMaxCapacity;
    private Func`1<T> myFactory;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<T> myClear;
    private Stack`1<T> myPool;
    private Thread myThread;
    public SingleThreadObjectPool`1(Func`1<T> factory, Action`1<T> clear);
    public SingleThreadObjectPool`1(int maxCapacity, Func`1<T> factory, Action`1<T> clear);
    public T Rent();
    public RentedValueCookie`1<T> RentCookie();
    public void Return(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Util.Util.BitSlice : object {
    [PublicAPIAttribute]
public int LoBit;
    [PublicAPIAttribute]
public int BitCount;
    [PublicAPIAttribute]
public int Mask;
    [PublicAPIAttribute]
public int HiBit { get; }
    public BitSlice(int loBit, int bitCount);
    public int get_HiBit();
    [NullableContextAttribute("2")]
[AssertionMethodAttribute]
protected void AssertSliceFitsHostType();
    [AssertionMethodAttribute]
private void AssertValueFitsSlice(int value);
    protected int GetRaw(int host);
    protected int UpdatedRaw(int host, int value);
    [NullableContextAttribute("2")]
private static int NextSliceLoBit(BitSlice slice);
    public static IntBitSlice Int(int bitCount, BitSlice previousSlice);
    public static BoolBitSlice Bool(BitSlice previousSlice);
    [NullableContextAttribute("0")]
public static Enum32BitSlice`1<T> Enum(BitSlice previousSlice);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public abstract class JetBrains.Util.Util.BitSlice`1 : BitSlice {
    public T Item { get; }
    protected BitSlice`1(int loBit, int bitCount);
    public abstract virtual T get_Item(int host);
    public abstract virtual int Updated(int host, T value);
    public void InterlockedUpdate(Int32& host, T value);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Util.BoolBitSlice : BitSlice`1<bool> {
    public bool Item { get; }
    public BoolBitSlice(int loBit, int bitCount);
    public virtual bool get_Item(int host);
    public virtual int Updated(int host, bool value);
}
public static class JetBrains.Util.Util.Cast32BitEnum`1 : object {
    private static Cast32BitEnum`1();
    [PublicAPIAttribute]
public static T FromInt(int source);
    [PublicAPIAttribute]
public static int ToInt(T source);
    [PublicAPIAttribute]
public static T FromUInt(UInt32 source);
    [PublicAPIAttribute]
public static UInt32 ToUInt(T source);
}
public static class JetBrains.Util.Util.Cast64BitEnum`1 : object {
    private static Cast64BitEnum`1();
    [PublicAPIAttribute]
public static T FromLong(long source);
    [PublicAPIAttribute]
public static long ToLong(T source);
    [PublicAPIAttribute]
public static T FromULong(ulong source);
    [PublicAPIAttribute]
public static ulong ToULong(T source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.Util.Util.CastTo`1 : object {
    [PublicAPIAttribute]
public static TTo From(TFrom s);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Util.Enum32BitSlice`1 : BitSlice`1<T> {
    public T Item { get; }
    public Enum32BitSlice`1(int loBit);
    private static int CalculateBitCount();
    public virtual T get_Item(int host);
    public virtual int Updated(int host, T value);
}
[DefaultMemberAttribute("Item")]
public class JetBrains.Util.Util.IntBitSlice : BitSlice`1<int> {
    public int Item { get; }
    public IntBitSlice(int loBit, int bitCount);
    public virtual int get_Item(int host);
    public virtual int Updated(int host, int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class JetBrains.Util.Util.Statics : object {
    private static Dictionary`2<Type, object> ourPerTypeStatics;
    private static Statics();
    public static StaticsForType`1<T> For();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class JetBrains.Util.Util.StaticsForType`1 : object {
    private List`1<T> myList;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Action Changed;
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void add_Changed(Action value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void remove_Changed(Action value);
    private void FireChanged();
    public void ForEachValue(Action action);
    public void AddLast(T value);
    public void AddFirst(T value);
    [NullableContextAttribute("2")]
public T PeekFirst();
    [NullableContextAttribute("2")]
public T PeekLast();
    public void ReplaceFirst(T value);
    public bool RemoveLastReferenceEqual(T value, bool failIfNotLast);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class JetBrains.Util.Util.Types : object {
    private static Dictionary`2<Type, string> ourPrimitives;
    private static Types();
    [ExtensionAttribute]
[ContractAnnotationAttribute("thisType:null=>null;=>notnull")]
public static string ToString(Type thisType, bool withNamespaces, bool withGenericArguments);
    [ExtensionAttribute]
public static TypeInfo OptionalTypeInfo(Type thisType);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("448")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public CallerArgumentExpressionAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    public String[] Arguments { get; }
    public InterpolatedStringHandlerArgumentAttribute(string argument);
    public InterpolatedStringHandlerArgumentAttribute(String[] arguments);
    [CompilerGeneratedAttribute]
public String[] get_Arguments();
}
[AttributeUsageAttribute("12")]
internal class System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
