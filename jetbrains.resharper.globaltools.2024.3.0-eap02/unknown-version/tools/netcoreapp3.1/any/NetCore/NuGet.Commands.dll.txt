[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Microsoft.Extensions.Internal.HashCodeCombiner : ValueType {
    private long _combinedHash64;
    public int CombinedHash { get; }
    private HashCodeCombiner(long seed);
    public int get_CombinedHash();
    public void Add(IEnumerable e);
    public static int op_Implicit(HashCodeCombiner self);
    public void Add(int i);
    public void Add(string s);
    public void Add(object o);
    public void Add(TValue value, IEqualityComparer`1<TValue> comparer);
    public static HashCodeCombiner Start();
}
public class NuGet.Commands.AddClientCertArgs : object {
    [CompilerGeneratedAttribute]
private string <PackageSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StorePasswordInClearText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StoreLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StoreName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FindBy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FindValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Force>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configfile>k__BackingField;
    public string PackageSource { get; public set; }
    public string Path { get; public set; }
    public string Password { get; public set; }
    public bool StorePasswordInClearText { get; public set; }
    public string StoreLocation { get; public set; }
    public string StoreName { get; public set; }
    public string FindBy { get; public set; }
    public string FindValue { get; public set; }
    public bool Force { get; public set; }
    public string Configfile { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_PackageSource();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackageSource(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Path(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Password();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Password(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_StorePasswordInClearText();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StorePasswordInClearText(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_StoreLocation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StoreLocation(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_StoreName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StoreName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FindBy();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FindBy(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FindValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FindValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Force();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Force(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Configfile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Configfile(string value);
}
public static class NuGet.Commands.AddClientCertRunner : object {
    public static void Run(AddClientCertArgs args, Func`1<ILogger> getLogger);
}
public class NuGet.Commands.AddSourceArgs : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StorePasswordInClearText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ValidAuthenticationTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configfile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowInsecureConnections>k__BackingField;
    public string Source { get; public set; }
    public string Name { get; public set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public bool StorePasswordInClearText { get; public set; }
    public string ValidAuthenticationTypes { get; public set; }
    public string ProtocolVersion { get; public set; }
    public string Configfile { get; public set; }
    public bool AllowInsecureConnections { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public bool get_StorePasswordInClearText();
    [CompilerGeneratedAttribute]
public void set_StorePasswordInClearText(bool value);
    [CompilerGeneratedAttribute]
public string get_ValidAuthenticationTypes();
    [CompilerGeneratedAttribute]
public void set_ValidAuthenticationTypes(string value);
    [CompilerGeneratedAttribute]
public string get_ProtocolVersion();
    [CompilerGeneratedAttribute]
public void set_ProtocolVersion(string value);
    [CompilerGeneratedAttribute]
public string get_Configfile();
    [CompilerGeneratedAttribute]
public void set_Configfile(string value);
    [CompilerGeneratedAttribute]
public bool get_AllowInsecureConnections();
    [CompilerGeneratedAttribute]
public void set_AllowInsecureConnections(bool value);
}
public static class NuGet.Commands.AddSourceRunner : object {
    public static void Run(AddSourceArgs args, Func`1<ILogger> getLogger);
}
public static class NuGet.Commands.AssetTargetFallbackUtility : object {
    public static string AssetTargetFallback;
    private static AssetTargetFallbackUtility();
    public static void EnsureValidFallback(IEnumerable`1<NuGetFramework> packageTargetFallback, IEnumerable`1<NuGetFramework> assetTargetFallback, string filePath);
    public static RestoreLogMessage GetInvalidFallbackCombinationMessage(string path);
    public static NuGetFramework GetFallbackFramework(NuGetFramework projectFramework, IEnumerable`1<NuGetFramework> packageTargetFallback, IEnumerable`1<NuGetFramework> assetTargetFallback);
    public static void ApplyFramework(TargetFrameworkInformation targetFrameworkInfo, IEnumerable`1<NuGetFramework> packageTargetFallback, IEnumerable`1<NuGetFramework> assetTargetFallback);
}
[ExtensionAttribute]
public static class NuGet.Commands.BuildAssetsUtils : object {
    private static XNamespace Namespace;
    internal static string CrossTargetingCondition;
    internal static string TargetFrameworkCondition;
    internal static string LanguageCondition;
    internal static string NegativeLanguageCondition;
    internal static string ExcludeAllCondition;
    public static string TargetsExtension;
    public static string PropsExtension;
    public static String[] MacroCandidates;
    private static BuildAssetsUtils();
    public static void WriteFiles(IEnumerable`1<MSBuildOutputFile> files, ILogger log);
    public static List`1<MSBuildOutputFile> GenerateMultiTargetFailureFiles(string targetsPath, string propsPath, ProjectStyle restoreType);
    private static string ReplacePathsWithMacros(string path);
    public static XDocument GenerateMultiTargetFrameworkWarning();
    public static void AddNuGetPropertiesToFirstImport(IEnumerable`1<MSBuildOutputFile> files, IEnumerable`1<string> packageFolders, string repositoryRoot, ProjectStyle projectStyle, string assetsFilePath, bool success);
    public static void AddNuGetProperties(XDocument doc, IEnumerable`1<string> packageFolders, string repositoryRoot, ProjectStyle projectStyle, string assetsFilePath, bool success);
    public static XDocument GenerateEmptyImportsFile();
    public static XElement GenerateProperty(string propertyName, string content);
    internal static XElement GenerateItem(string itemName, string path);
    public static XElement GenerateImport(string path);
    public static XElement GenerateContentFilesItem(string path, LockFileContentFile item, string packageId, string packageVersion);
    public static XDocument GenerateMSBuildFile(List`1<MSBuildRestoreItemGroup> groups, ProjectStyle outputType);
    public static void WriteXML(string path, XDocument doc);
    public static string GetPathWithMacros(string absolutePath, string repositoryRoot);
    public static bool HasChanges(XDocument newFile, string path, ILogger log);
    public static XDocument ReadExisting(string path, ILogger log);
    public static string GetMSBuildFilePath(PackageSpec project, string extension);
    public static string GetMSBuildFilePathForPackageReferenceStyleProject(PackageSpec project, string extension);
    public static List`1<MSBuildOutputFile> GetMSBuildOutputFiles(PackageSpec project, LockFile assetsFile, IEnumerable`1<RestoreTargetGraph> targetGraphs, IReadOnlyList`1<NuGetv3LocalRepository> repositories, RestoreRequest request, string assetsFilePath, bool restoreSuccess, ILogger log);
    [IteratorStateMachineAttribute("NuGet.Commands.BuildAssetsUtils/<GetLanguageConditions>d__28")]
private static IEnumerable`1<string> GetLanguageConditions(string language, SortedSet`1<string> allLanguages);
    public static string GetLanguage(string nugetLanguage);
    private static IEnumerable`1<MSBuildRestoreItemGroup> GetLanguageGroups(List`1<ValueTuple`3<LockFileTargetLibrary, LockFileContentFile, string>> currentItems);
    [IteratorStateMachineAttribute("NuGet.Commands.BuildAssetsUtils/<GenerateGroupsWithConditions>d__31")]
private static IEnumerable`1<MSBuildRestoreItemGroup> GenerateGroupsWithConditions(MSBuildRestoreItemGroup original, bool isCrossTargeting, String[] conditions);
    [ExtensionAttribute]
private static string GetAbsolutePath(Lazy`1<LocalPackageSourceInfo> package, LockFileItem item);
    [ExtensionAttribute]
private static bool Exists(Lazy`1<LocalPackageSourceInfo> package);
    [ExtensionAttribute]
private static IEnumerable`1<LockFileItem> WithExtension(IList`1<LockFileItem> items, string extension);
    private static string GetMatchingFrameworkStrings(PackageSpec spec, NuGetFramework framework);
    private static HashSet`1<PackageDependencyInfo> ConvertToPackageDependencyInfo(ISet`1<GraphItem`1<RemoteResolveResult>> items);
    private static XElement GeneratePackagePathProperty(LocalPackageInfo localPackageInfo);
    [CompilerGeneratedAttribute]
internal static MSBuildRestoreItemGroup <GetMSBuildOutputFiles>g__GenerateBuildGroup|27_1(string repositoryRoot, List`1<KeyValuePair`2<LockFileTargetLibrary, Lazy`1<LocalPackageSourceInfo>>> sortedPackages, string extension);
    [CompilerGeneratedAttribute]
internal static MSBuildRestoreItemGroup <GetMSBuildOutputFiles>g__GenerateMultiTargetingGroup|27_2(string repositoryRoot, List`1<KeyValuePair`2<LockFileTargetLibrary, Lazy`1<LocalPackageSourceInfo>>> sortedPackages, HashSet`1<string> multiTargetingImportsAdded, string extension);
    [IteratorStateMachineAttribute("NuGet.Commands.BuildAssetsUtils/<<WithExtension>g__FilterExtensions|34_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<LockFileItem> <WithExtension>g__FilterExtensions|34_0(IList`1<LockFileItem> items, string extension);
}
internal static class NuGet.Commands.CertificateProvider : object {
    private static int ERROR_FILE_NOT_FOUND_HRESULT;
    private static int OPENSSL_BIO_R_NO_SUCH_FILE;
    private static int ERROR_INVALID_PASSWORD_HRESULT;
    private static int OPENSSL_PKCS12_R_MAC_VERIFY_FAILURE;
    private static int MACOS_PKCS12_MAC_VERIFY_FAILURE;
    private static int CRYPT_E_NO_MATCH_HRESULT;
    private static int MACOS_INVALID_CERT;
    private static int OPENSSL_ERR_R_NESTED_ASN1_ERROR;
    [AsyncStateMachineAttribute("NuGet.Commands.CertificateProvider/<GetCertificatesAsync>d__8")]
public static Task`1<X509Certificate2Collection> GetCertificatesAsync(CertificateSourceOptions options);
    [AsyncStateMachineAttribute("NuGet.Commands.CertificateProvider/<LoadCertificateFromFileAsync>d__9")]
private static Task`1<X509Certificate2> LoadCertificateFromFileAsync(CertificateSourceOptions options);
    private static X509Certificate2Collection LoadCertificateFromStore(CertificateSourceOptions options);
    private static void OpenStore(X509Store store);
    private static X509Certificate2Collection GetValidCertificates(X509Certificate2Collection certificates);
    private static bool IsValid(X509Certificate2 certificate, X509Certificate2Collection extraStore);
}
internal class NuGet.Commands.CertificateSourceOptions : object {
    [CompilerGeneratedAttribute]
private string <CertificatePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificatePassword>k__BackingField;
    [CompilerGeneratedAttribute]
private StoreName <StoreName>k__BackingField;
    [CompilerGeneratedAttribute]
private StoreLocation <StoreLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Fingerprint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NonInteractive>k__BackingField;
    [CompilerGeneratedAttribute]
private IPasswordProvider <PasswordProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <Token>k__BackingField;
    public string CertificatePath { get; public set; }
    public string CertificatePassword { get; public set; }
    public StoreName StoreName { get; public set; }
    public StoreLocation StoreLocation { get; public set; }
    public string SubjectName { get; public set; }
    public string Fingerprint { get; public set; }
    public bool NonInteractive { get; public set; }
    public IPasswordProvider PasswordProvider { get; public set; }
    public CancellationToken Token { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CertificatePath();
    [CompilerGeneratedAttribute]
public void set_CertificatePath(string value);
    [CompilerGeneratedAttribute]
public string get_CertificatePassword();
    [CompilerGeneratedAttribute]
public void set_CertificatePassword(string value);
    [CompilerGeneratedAttribute]
public StoreName get_StoreName();
    [CompilerGeneratedAttribute]
public void set_StoreName(StoreName value);
    [CompilerGeneratedAttribute]
public StoreLocation get_StoreLocation();
    [CompilerGeneratedAttribute]
public void set_StoreLocation(StoreLocation value);
    [CompilerGeneratedAttribute]
public string get_SubjectName();
    [CompilerGeneratedAttribute]
public void set_SubjectName(string value);
    [CompilerGeneratedAttribute]
public string get_Fingerprint();
    [CompilerGeneratedAttribute]
public void set_Fingerprint(string value);
    [CompilerGeneratedAttribute]
public bool get_NonInteractive();
    [CompilerGeneratedAttribute]
public void set_NonInteractive(bool value);
    [CompilerGeneratedAttribute]
public IPasswordProvider get_PasswordProvider();
    [CompilerGeneratedAttribute]
public void set_PasswordProvider(IPasswordProvider value);
    [CompilerGeneratedAttribute]
public CancellationToken get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(CancellationToken value);
}
[ExtensionAttribute]
public static class NuGet.Commands.ClientCertArgsExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<X509FindType> GetFindBy(IClientCertArgsWithStoreData args);
    [ExtensionAttribute]
public static Nullable`1<StoreLocation> GetStoreLocation(IClientCertArgsWithStoreData args);
    [ExtensionAttribute]
public static Nullable`1<StoreName> GetStoreName(IClientCertArgsWithStoreData args);
    [ExtensionAttribute]
public static bool IsFileCertSettingsProvided(IClientCertArgsWithFileData args);
    [ExtensionAttribute]
public static bool IsPackageSourceSettingProvided(IClientCertArgsWithPackageSource args);
    [ExtensionAttribute]
public static bool IsStoreCertSettingsProvided(IClientCertArgsWithStoreData args);
    [ExtensionAttribute]
public static void Validate(RemoveClientCertArgs args);
    [ExtensionAttribute]
public static void Validate(AddClientCertArgs args);
    [ExtensionAttribute]
public static void Validate(UpdateClientCertArgs args);
}
public class NuGet.Commands.CommandException : Exception {
    public CommandException(string message);
    public CommandException(string format, Object[] args);
    public CommandException(string message, Exception exception);
    protected CommandException(SerializationInfo info, StreamingContext context);
}
internal static class NuGet.Commands.CommandRunnerUtility : object {
    public static string ResolveSource(IPackageSourceProvider sourceProvider, string source);
    public static string ResolveSymbolSource(IPackageSourceProvider sourceProvider, string symbolSource);
    public static string GetApiKey(ISettings settings, string endpoint, string source);
    [AsyncStateMachineAttribute("NuGet.Commands.CommandRunnerUtility/<GetPackageUpdateResource>d__3")]
public static Task`1<PackageUpdateResource> GetPackageUpdateResource(IPackageSourceProvider sourceProvider, PackageSource packageSource, CancellationToken cancellationToken);
    public static PackageSource GetOrCreatePackageSource(IPackageSourceProvider sourceProvider, string source);
    [AsyncStateMachineAttribute("NuGet.Commands.CommandRunnerUtility/<GetSymbolPackageUpdateResource>d__5")]
public static Task`1<SymbolPackageUpdateResourceV3> GetSymbolPackageUpdateResource(IPackageSourceProvider sourceProvider, string source, CancellationToken cancellationToken);
}
internal class NuGet.Commands.CompatibilityChecker : object {
    private IReadOnlyList`1<NuGetv3LocalRepository> _localRepositories;
    private LockFile _lockFile;
    private ILogger _log;
    private bool _validateRuntimeAssets;
    public CompatibilityChecker(IReadOnlyList`1<NuGetv3LocalRepository> localRepositories, LockFile lockFile, bool validateRuntimeAssets, ILogger log);
    [AsyncStateMachineAttribute("NuGet.Commands.CompatibilityChecker/<CheckAsync>d__5")]
internal Task`1<CompatibilityCheckResult> CheckAsync(RestoreTargetGraph graph, Dictionary`2<string, LibraryIncludeFlags> includeFlags, PackageSpec packageSpec);
    private static RestoreLogMessage GetErrorMessage(NuGetLogCode logCode, CompatibilityIssue issue, RestoreTargetGraph graph);
    private static IEnumerable`1<NuGetFramework> GetPackageFrameworks(CompatibilityData compatibilityData, RestoreTargetGraph graph);
    private static List`1<NuGetFramework> GetProjectFrameworks(Library localLibrary);
    private static bool IsProjectFrameworkCompatible(Library library);
    private bool IsPackageCompatible(CompatibilityData compatibilityData);
    private bool IsPackageTypeCompatible(CompatibilityData compatibilityData);
    private static HashSet`1<FrameworkRuntimePair> GetAvailableFrameworkRuntimePairs(CompatibilityData compatibilityData, RestoreTargetGraph graph);
    [AsyncStateMachineAttribute("NuGet.Commands.CompatibilityChecker/<VerifyDotnetToolCompatibilityChecks>d__13")]
private Task VerifyDotnetToolCompatibilityChecks(CompatibilityData compatibilityData, GraphItem`1<RemoteResolveResult> node, RestoreTargetGraph graph, List`1<CompatibilityIssue> issues);
    internal static bool HasCompatibleAssets(LockFileTargetLibrary targetLibrary);
    internal static bool HasCompatibleToolsAssets(LockFileTargetLibrary targetLibrary);
    private CompatibilityData GetCompatibilityData(RestoreTargetGraph graph, LibraryIdentity libraryId, PackageSpec packageSpec);
}
public class NuGet.Commands.CompatibilityCheckResult : object {
    [CompilerGeneratedAttribute]
private RestoreTargetGraph <Graph>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CompatibilityIssue> <Issues>k__BackingField;
    public RestoreTargetGraph Graph { get; }
    public IReadOnlyList`1<CompatibilityIssue> Issues { get; }
    public bool Success { get; }
    public CompatibilityCheckResult(RestoreTargetGraph graph, IEnumerable`1<CompatibilityIssue> issues);
    [CompilerGeneratedAttribute]
public RestoreTargetGraph get_Graph();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<CompatibilityIssue> get_Issues();
    public bool get_Success();
}
public class NuGet.Commands.CompatibilityIssue : object {
    [CompilerGeneratedAttribute]
private CompatibilityIssueType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageIdentity <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<NuGetFramework> <AvailableFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<FrameworkRuntimePair> <AvailableFrameworkRuntimePairs>k__BackingField;
    public CompatibilityIssueType Type { get; }
    public NuGetFramework Framework { get; }
    public string RuntimeIdentifier { get; }
    public string AssemblyName { get; }
    public PackageIdentity Package { get; }
    public List`1<NuGetFramework> AvailableFrameworks { get; }
    public List`1<FrameworkRuntimePair> AvailableFrameworkRuntimePairs { get; }
    private CompatibilityIssue(CompatibilityIssueType type, PackageIdentity package, string assemblyName, NuGetFramework framework, string runtimeIdentifier, IEnumerable`1<NuGetFramework> availableFrameworks, IEnumerable`1<FrameworkRuntimePair> availableFrameworkRuntimePairs);
    [CompilerGeneratedAttribute]
public CompatibilityIssueType get_Type();
    [CompilerGeneratedAttribute]
public NuGetFramework get_Framework();
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public PackageIdentity get_Package();
    [CompilerGeneratedAttribute]
public List`1<NuGetFramework> get_AvailableFrameworks();
    [CompilerGeneratedAttribute]
public List`1<FrameworkRuntimePair> get_AvailableFrameworkRuntimePairs();
    public static CompatibilityIssue ReferenceAssemblyNotImplemented(string assemblyName, PackageIdentity referenceAssemblyPackage, NuGetFramework framework, string runtimeIdentifier);
    public static CompatibilityIssue IncompatiblePackage(PackageIdentity referenceAssemblyPackage, NuGetFramework framework, string runtimeIdentifier, IEnumerable`1<NuGetFramework> packageFrameworks);
    public static CompatibilityIssue IncompatiblePackageWithDotnetTool(PackageIdentity referenceAssemblyPackage);
    public static CompatibilityIssue ToolsPackageWithExtraPackageTypes(PackageIdentity referenceAssemblyPackage);
    public static CompatibilityIssue IncompatibleToolsPackage(PackageIdentity packageIdentity, NuGetFramework framework, string runtimeIdentifier, HashSet`1<FrameworkRuntimePair> available);
    public static CompatibilityIssue IncompatibleProject(PackageIdentity project, NuGetFramework framework, string runtimeIdentifier, IEnumerable`1<NuGetFramework> projectFrameworks);
    public static CompatibilityIssue IncompatibleProjectType(PackageIdentity project);
    internal static CompatibilityIssue IncompatiblePackageType(PackageIdentity packageIdentity, NuGetFramework framework, string runtimeIdentifier);
    public virtual string ToString();
    public string Format();
    private string FormatMessage(string message, string supports, string noSupports);
    private static string FormatFramework(NuGetFramework framework);
    private static string FormatFramework(NuGetFramework framework, string runtimeId);
    public sealed virtual bool Equals(CompatibilityIssue other);
}
public enum NuGet.Commands.CompatibilityIssueType : Enum {
    public int value__;
    public static CompatibilityIssueType ReferenceAssemblyNotImplemented;
    public static CompatibilityIssueType PackageIncompatible;
    public static CompatibilityIssueType ProjectIncompatible;
    public static CompatibilityIssueType PackageToolsAssetsIncompatible;
    public static CompatibilityIssueType ProjectWithIncorrectDependencyCount;
    public static CompatibilityIssueType IncompatiblePackageWithDotnetTool;
    public static CompatibilityIssueType ToolsPackageWithExtraPackageTypes;
    public static CompatibilityIssueType PackageTypeIncompatible;
}
internal static class NuGet.Commands.ContentFileUtils : object {
    private static string ContentFilesFolderName;
    internal static List`1<ContentItemGroup> GetContentGroupsForFramework(NuGetFramework framework, IEnumerable`1<ContentItemGroup> contentGroups);
    internal static List`1<LockFileContentFile> GetContentFileGroup(NuspecReader nuspec, List`1<ContentItemGroup> contentFileGroups);
    internal static LockFileContentFile CreateEmptyItem();
    internal static string GetContentFileFolderRelativeToFramework(ReadOnlySpan`1<char> itemPath);
}
public class NuGet.Commands.ContentMetadata : ValueType {
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildAction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CopyToOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Flatten>k__BackingField;
    public string Target { get; public set; }
    public string Source { get; public set; }
    public string BuildAction { get; public set; }
    public string CopyToOutput { get; public set; }
    public string Flatten { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_BuildAction();
    [CompilerGeneratedAttribute]
public void set_BuildAction(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_CopyToOutput();
    [CompilerGeneratedAttribute]
public void set_CopyToOutput(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Flatten();
    [CompilerGeneratedAttribute]
public void set_Flatten(string value);
}
public static class NuGet.Commands.DeleteRunner : object {
    [AsyncStateMachineAttribute("NuGet.Commands.DeleteRunner/<Run>d__0")]
public static Task Run(ISettings settings, IPackageSourceProvider sourceProvider, string packageId, string packageVersion, string source, string apiKey, bool nonInteractive, bool noServiceEndpoint, Func`2<string, bool> confirmFunc, ILogger logger);
}
public class NuGet.Commands.DependencyGraphFileRequestProvider : object {
    private RestoreCommandProvidersCache _providerCache;
    public DependencyGraphFileRequestProvider(RestoreCommandProvidersCache providerCache);
    public virtual Task`1<IReadOnlyList`1<RestoreSummaryRequest>> CreateRequests(string inputPath, RestoreArgs restoreContext);
    public virtual Task`1<bool> Supports(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.Commands.DependencyGraphResolver : object {
    private static int DependencyGraphItemQueueSize;
    private static int EvictionsDictionarySize;
    private static int FindLibraryEntryResultCacheSize;
    private static int OverridesDictionarySize;
    private static int ResolvedDependencyGraphItemQueueSize;
    private RestoreCollectorLogger _logger;
    private Guid _operationId;
    private RestoreRequest _request;
    private TelemetryActivity _telemetryActivity;
    public DependencyGraphResolver(RestoreCollectorLogger logger, RestoreRequest restoreRequest, TelemetryActivity telemetryActivity, Guid operationId);
    [AsyncStateMachineAttribute("NuGet.Commands.DependencyGraphResolver/<ResolveAsync>d__10")]
public Task`1<ValueTuple`3<bool, List`1<RestoreTargetGraph>, RuntimeGraph>> ResolveAsync(NuGetv3LocalRepository userPackageFolder, IReadOnlyList`1<NuGetv3LocalRepository> fallbackPackageFolders, RemoteWalkContext context, ProjectRestoreCommand projectRestoreCommand, List`1<NuGetv3LocalRepository> localRepositories, CancellationToken token);
    private static bool EvictOnTypeConstraint(LibraryDependencyTarget current, LibraryDependencyTarget previous);
    private static bool VersionRangePreciseEquals(VersionRange a, VersionRange b);
}
public class NuGet.Commands.DependencyGraphSpecRequestProvider : object {
    private static bool DefaultRestoreLegacyPackagesDirectory;
    private DependencyGraphSpec _dgFile;
    private RestoreCommandProvidersCache _providerCache;
    private LockFileBuilderCache _lockFileBuilderCache;
    private ISettings _settings;
    public DependencyGraphSpecRequestProvider(RestoreCommandProvidersCache providerCache, DependencyGraphSpec dgFile);
    public DependencyGraphSpecRequestProvider(RestoreCommandProvidersCache providerCache, DependencyGraphSpec dgFile, ISettings settings);
    public sealed virtual Task`1<IReadOnlyList`1<RestoreSummaryRequest>> CreateRequests(RestoreArgs restoreContext);
    private IReadOnlyList`1<RestoreSummaryRequest> GetRequestsFromItems(RestoreArgs restoreContext, DependencyGraphSpec dgFile);
    public static IEnumerable`1<ExternalProjectReference> GetExternalClosure(DependencyGraphSpec dgFile, string projectNameToRestore);
    private static ExternalProjectReference GetExternalProject(PackageSpec rootProject);
    private RestoreSummaryRequest Create(string projectNameToRestore, ExternalProjectReference project, HashSet`1<ExternalProjectReference> projectReferenceClosure, RestoreArgs restoreArgs, DependencyGraphSpec projectDgSpec, SettingsLoadingContext settingsLoadingContext);
    private static IReadOnlyList`1<SourceRepository> GetAuditSources(CachingSourceProvider cachingSourceProvider);
    private string GetPackagesPath(RestoreArgs restoreArgs, PackageSpec project);
    private static void CollectReferences(ExternalProjectReference root, Dictionary`2<string, ExternalProjectReference> allProjects, HashSet`1<ExternalProjectReference> references);
    internal static IReadOnlyList`1<IAssetsLogMessage> GetMessagesForProject(IReadOnlyList`1<IAssetsLogMessage> allMessages, string projectPath);
}
public static class NuGet.Commands.DiagnosticUtility : object {
    public static string FormatIdentity(LibraryIdentity identity);
    public static string FormatDependency(string id, VersionRange range);
    public static string FormatExpectedIdentity(string id, VersionRange range);
    public static string FormatGraphName(RestoreTargetGraph graph);
    public static string GetMultiLineMessage(IEnumerable`1<string> lines);
    public static IEnumerable`1<RestoreLogMessage> MergeOnTargetGraph(IEnumerable`1<RestoreLogMessage> messages);
}
public class NuGet.Commands.DisableSourceArgs : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configfile>k__BackingField;
    public string Name { get; public set; }
    public string Configfile { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Configfile();
    [CompilerGeneratedAttribute]
public void set_Configfile(string value);
}
public static class NuGet.Commands.DisableSourceRunner : object {
    public static void Run(DisableSourceArgs args, Func`1<ILogger> getLogger);
}
public class NuGet.Commands.DownloadDependencyResolutionResult : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Tuple`2<LibraryRange, RemoteMatch>> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<RemoteMatch> <Install>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<LibraryRange> <Unresolved>k__BackingField;
    public NuGetFramework Framework { get; }
    public IList`1<Tuple`2<LibraryRange, RemoteMatch>> Dependencies { get; }
    public ISet`1<RemoteMatch> Install { get; }
    public ISet`1<LibraryRange> Unresolved { get; }
    private DownloadDependencyResolutionResult(NuGetFramework framework, IList`1<Tuple`2<LibraryRange, RemoteMatch>> dependencies, ISet`1<RemoteMatch> install, ISet`1<LibraryRange> unresolved);
    [CompilerGeneratedAttribute]
public NuGetFramework get_Framework();
    [CompilerGeneratedAttribute]
public IList`1<Tuple`2<LibraryRange, RemoteMatch>> get_Dependencies();
    [CompilerGeneratedAttribute]
public ISet`1<RemoteMatch> get_Install();
    [CompilerGeneratedAttribute]
public ISet`1<LibraryRange> get_Unresolved();
    public static DownloadDependencyResolutionResult Create(NuGetFramework framework, IList`1<Tuple`2<LibraryRange, RemoteMatch>> dependencies, IList`1<IRemoteDependencyProvider> remoteDependencyProviders);
}
public class NuGet.Commands.EnableSourceArgs : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configfile>k__BackingField;
    public string Name { get; public set; }
    public string Configfile { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Configfile();
    [CompilerGeneratedAttribute]
public void set_Configfile(string value);
}
public static class NuGet.Commands.EnableSourceRunner : object {
    public static void Run(EnableSourceArgs args, Func`1<ILogger> getLogger);
}
[ExtensionAttribute]
internal static class NuGet.Commands.Extensions : object {
    [ExtensionAttribute]
public static ISet`1<LibraryDependency> GetAllPackageDependencies(PackageSpec project);
    [ExtensionAttribute]
public static ISet`1<LibraryDependency> GetPackageDependenciesForFramework(PackageSpec project, NuGetFramework framework);
    [ExtensionAttribute]
public static void LogMessages(ILogger logger, IEnumerable`1<ILogMessage> messages);
    [ExtensionAttribute]
public static Task LogMessagesAsync(ILogger logger, ILogMessage[] messages);
    [AsyncStateMachineAttribute("NuGet.Commands.Extensions/<LogMessagesAsync>d__4")]
[ExtensionAttribute]
public static Task LogMessagesAsync(ILogger logger, IEnumerable`1<ILogMessage> messages);
    [ExtensionAttribute]
public static RestoreLogMessage AsRestoreLogMessage(IAssetsLogMessage logMessage);
    [ExtensionAttribute]
public static RestoreLogMessage AsRestoreLogMessage(LogMessage logMessage);
}
internal class NuGet.Commands.FileProviderGlobbingDirectory : DirectoryInfoBase {
    private static char DirectorySeparatorChar;
    private IFileProvider _fileProvider;
    private IFileInfo _fileInfo;
    private FileProviderGlobbingDirectory _parent;
    private bool _isRoot;
    [CompilerGeneratedAttribute]
private string <RelativePath>k__BackingField;
    public string RelativePath { get; }
    public string FullName { get; }
    public string Name { get; }
    public DirectoryInfoBase ParentDirectory { get; }
    public FileProviderGlobbingDirectory(IFileProvider fileProvider, IFileInfo fileInfo, FileProviderGlobbingDirectory parent);
    [CompilerGeneratedAttribute]
public string get_RelativePath();
    public virtual string get_FullName();
    public virtual string get_Name();
    public virtual DirectoryInfoBase get_ParentDirectory();
    [IteratorStateMachineAttribute("NuGet.Commands.FileProviderGlobbingDirectory/<EnumerateFileSystemInfos>d__15")]
public virtual IEnumerable`1<FileSystemInfoBase> EnumerateFileSystemInfos();
    public virtual DirectoryInfoBase GetDirectory(string path);
    public virtual FileInfoBase GetFile(string path);
    private FileSystemInfoBase BuildFileResult(IFileInfo fileInfo);
}
internal class NuGet.Commands.FileProviderGlobbingFile : FileInfoBase {
    private static char DirectorySeparatorChar;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryInfoBase <ParentDirectory>k__BackingField;
    public string FullName { get; }
    public string Name { get; }
    public DirectoryInfoBase ParentDirectory { get; }
    public FileProviderGlobbingFile(IFileInfo fileInfo, DirectoryInfoBase parent);
    [CompilerGeneratedAttribute]
public virtual string get_FullName();
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual DirectoryInfoBase get_ParentDirectory();
}
public interface NuGet.Commands.IClientCertArgsWithConfigFile {
    public string Configfile { get; public set; }
    public abstract virtual string get_Configfile();
    public abstract virtual void set_Configfile(string value);
}
public interface NuGet.Commands.IClientCertArgsWithFileData {
    public string Password { get; public set; }
    public string Path { get; public set; }
    public bool StorePasswordInClearText { get; public set; }
    public abstract virtual string get_Password();
    public abstract virtual void set_Password(string value);
    public abstract virtual string get_Path();
    public abstract virtual void set_Path(string value);
    public abstract virtual bool get_StorePasswordInClearText();
    public abstract virtual void set_StorePasswordInClearText(bool value);
}
public interface NuGet.Commands.IClientCertArgsWithForce {
    public bool Force { get; public set; }
    public abstract virtual bool get_Force();
    public abstract virtual void set_Force(bool value);
}
public interface NuGet.Commands.IClientCertArgsWithPackageSource {
    public string PackageSource { get; public set; }
    public abstract virtual string get_PackageSource();
    public abstract virtual void set_PackageSource(string value);
}
public interface NuGet.Commands.IClientCertArgsWithStoreData {
    public string FindBy { get; public set; }
    public string FindValue { get; public set; }
    public string StoreLocation { get; public set; }
    public string StoreName { get; public set; }
    public abstract virtual string get_FindBy();
    public abstract virtual void set_FindBy(string value);
    public abstract virtual string get_FindValue();
    public abstract virtual void set_FindValue(string value);
    public abstract virtual string get_StoreLocation();
    public abstract virtual void set_StoreLocation(string value);
    public abstract virtual string get_StoreName();
    public abstract virtual void set_StoreName(string value);
}
public interface NuGet.Commands.IListCommandRunner {
    public abstract virtual Task ExecuteCommand(ListArgs listArgs);
}
public interface NuGet.Commands.ILocalsCommandRunner {
    public abstract virtual void ExecuteCommand(LocalsArgs localsArgs);
}
public interface NuGet.Commands.IMSBuildItem {
    public string Identity { get; }
    public IReadOnlyList`1<string> Properties { get; }
    public abstract virtual string get_Identity();
    public abstract virtual string GetProperty(string property);
    public abstract virtual string GetProperty(string property, bool trim);
    public abstract virtual IReadOnlyList`1<string> get_Properties();
}
internal static class NuGet.Commands.IncludeFlagUtils : object {
    internal static Dictionary`2<string, LibraryIncludeFlags> FlattenDependencyTypes(Dictionary`2<RestoreTargetGraph, Dictionary`2<string, LibraryIncludeFlags>> includeFlagGraphs, PackageSpec project, RestoreTargetGraph graph);
    internal static Dictionary`2<string, LibraryIncludeFlags> FlattenDependencyTypes(RestoreTargetGraph targetGraph, PackageSpec spec);
    private static void FlattenDependencyTypesUnified(RestoreTargetGraph targetGraph, Dictionary`2<string, LibraryIncludeFlags> result);
    private static LibraryIncludeFlags GetDependencyType(GraphNode`1<RemoteResolveResult> parent, GraphNode`1<RemoteResolveResult> child);
    private static bool IsPackageOrProject(GraphItem`1<RemoteResolveResult> item);
    private static int OrderType(GraphItem`1<RemoteResolveResult> item);
}
public class NuGet.Commands.IndexedRestoreTargetGraph : object {
    private Dictionary`2<string, GraphItem`1<RemoteResolveResult>> _lookup;
    private HashSet`1<string> _idsWithErrors;
    [CompilerGeneratedAttribute]
private IRestoreTargetGraph <Graph>k__BackingField;
    public IRestoreTargetGraph Graph { get; }
    private IndexedRestoreTargetGraph(IRestoreTargetGraph graph);
    [CompilerGeneratedAttribute]
public IRestoreTargetGraph get_Graph();
    public static IndexedRestoreTargetGraph Create(IRestoreTargetGraph graph);
    public GraphItem`1<RemoteResolveResult> GetItemById(string id);
    public GraphItem`1<RemoteResolveResult> GetItemById(string id, LibraryType libraryType);
    public bool HasErrors(string id);
}
public interface NuGet.Commands.IPreLoadedRestoreRequestProvider {
    public abstract virtual Task`1<IReadOnlyList`1<RestoreSummaryRequest>> CreateRequests(RestoreArgs restoreContext);
}
public interface NuGet.Commands.IProjectFactory {
    public ILogger Logger { get; public set; }
    public abstract virtual WarningProperties GetWarningPropertiesForProject();
    public abstract virtual Dictionary`2<string, string> GetProjectProperties();
    public abstract virtual void SetIncludeSymbols(bool includeSymbols);
    public abstract virtual ILogger get_Logger();
    public abstract virtual void set_Logger(ILogger value);
    public abstract virtual PackageBuilder CreateBuilder(string basePath, NuGetVersion version, string suffix, bool buildIfNeeded, PackageBuilder builder);
}
[NullableContextAttribute("1")]
public interface NuGet.Commands.IRestoreProgressReporter {
    public abstract virtual void StartProjectUpdate(string projectPath, IReadOnlyList`1<string> updatedFiles);
    public abstract virtual void EndProjectUpdate(string projectPath, IReadOnlyList`1<string> updatedFiles);
}
public interface NuGet.Commands.IRestoreRequestProvider {
    public abstract virtual Task`1<bool> Supports(string path);
    public abstract virtual Task`1<IReadOnlyList`1<RestoreSummaryRequest>> CreateRequests(string inputPath, RestoreArgs restoreContext);
}
public interface NuGet.Commands.IRestoreResult {
    public bool Success { get; }
    public string LockFilePath { get; }
    public LockFile LockFile { get; }
    public LockFile PreviousLockFile { get; }
    public IEnumerable`1<MSBuildOutputFile> MSBuildOutputFiles { get; }
    public abstract virtual bool get_Success();
    public abstract virtual string get_LockFilePath();
    public abstract virtual LockFile get_LockFile();
    public abstract virtual LockFile get_PreviousLockFile();
    public abstract virtual IEnumerable`1<MSBuildOutputFile> get_MSBuildOutputFiles();
}
public interface NuGet.Commands.IRestoreTargetGraph {
    public string Name { get; }
    public string TargetGraphName { get; }
    public string RuntimeIdentifier { get; }
    public NuGetFramework Framework { get; }
    public ManagedCodeConventions Conventions { get; }
    public RuntimeGraph RuntimeGraph { get; }
    public IEnumerable`1<GraphNode`1<RemoteResolveResult>> Graphs { get; }
    public ISet`1<RemoteMatch> Install { get; }
    public ISet`1<GraphItem`1<RemoteResolveResult>> Flattened { get; }
    public ISet`1<LibraryRange> Unresolved { get; }
    public bool InConflict { get; }
    public IEnumerable`1<ResolverConflict> Conflicts { get; }
    public AnalyzeResult`1<RemoteResolveResult> AnalyzeResult { get; }
    public ISet`1<ResolvedDependencyKey> ResolvedDependencies { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_TargetGraphName();
    public abstract virtual string get_RuntimeIdentifier();
    public abstract virtual NuGetFramework get_Framework();
    public abstract virtual ManagedCodeConventions get_Conventions();
    public abstract virtual RuntimeGraph get_RuntimeGraph();
    public abstract virtual IEnumerable`1<GraphNode`1<RemoteResolveResult>> get_Graphs();
    public abstract virtual ISet`1<RemoteMatch> get_Install();
    public abstract virtual ISet`1<GraphItem`1<RemoteResolveResult>> get_Flattened();
    public abstract virtual ISet`1<LibraryRange> get_Unresolved();
    public abstract virtual bool get_InConflict();
    public abstract virtual IEnumerable`1<ResolverConflict> get_Conflicts();
    public abstract virtual AnalyzeResult`1<RemoteResolveResult> get_AnalyzeResult();
    public abstract virtual ISet`1<ResolvedDependencyKey> get_ResolvedDependencies();
}
public interface NuGet.Commands.ISignCommandRunner {
    public abstract virtual Task`1<int> ExecuteCommandAsync(SignArgs signArgs);
}
public interface NuGet.Commands.ITrustedSignersCommandRunner {
    public abstract virtual Task`1<int> ExecuteCommandAsync(TrustedSignersArgs trustedSignersArgs);
}
public interface NuGet.Commands.IVerifyCommandRunner {
    public abstract virtual Task`1<int> ExecuteCommandAsync(VerifyArgs verifyArgs);
}
[NullableContextAttribute("1")]
internal interface NuGet.Commands.IVulnerabilityInformationProvider {
    public bool IsAuditSource { get; }
    public string SourceName { get; }
    public abstract virtual Task`1<GetVulnerabilityInfoResult> GetVulnerabilityInformationAsync(CancellationToken cancellationToken);
    public abstract virtual bool get_IsAuditSource();
    public abstract virtual string get_SourceName();
}
public class NuGet.Commands.ListArgs : object {
    [CompilerGeneratedAttribute]
private bool <AllVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeDelisted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Prerelease>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private Log <PrintJustified>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDetailed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ListCommandNoPackages>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ListCommandLicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ListCommandListNotSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackageSource> <ListEndpoints>k__BackingField;
    public bool AllVersions { get; }
    public bool IncludeDelisted { get; }
    public bool Prerelease { get; }
    public IList`1<string> Arguments { get; }
    public ISettings Settings { get; }
    public ILogger Logger { get; }
    public Log PrintJustified { get; }
    public bool IsDetailed { get; }
    public string ListCommandNoPackages { get; }
    public string ListCommandLicenseUrl { get; }
    public string ListCommandListNotSupported { get; }
    public CancellationToken CancellationToken { get; }
    public IList`1<PackageSource> ListEndpoints { get; }
    public ListArgs(IList`1<string> arguments, IList`1<PackageSource> listEndpoints, ISettings settings, ILogger logger, Log printJustified, bool isDetailedl, string listCommandNoPackages, string listCommandLicenseUrl, string listCommandListNotSupported, bool allVersions, bool includeDelisted, bool prerelease, CancellationToken token);
    [CompilerGeneratedAttribute]
public bool get_AllVersions();
    [CompilerGeneratedAttribute]
public bool get_IncludeDelisted();
    [CompilerGeneratedAttribute]
public bool get_Prerelease();
    [CompilerGeneratedAttribute]
public IList`1<string> get_Arguments();
    [CompilerGeneratedAttribute]
public ISettings get_Settings();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public Log get_PrintJustified();
    [CompilerGeneratedAttribute]
public bool get_IsDetailed();
    [CompilerGeneratedAttribute]
public string get_ListCommandNoPackages();
    [CompilerGeneratedAttribute]
public string get_ListCommandLicenseUrl();
    [CompilerGeneratedAttribute]
public string get_ListCommandListNotSupported();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public IList`1<PackageSource> get_ListEndpoints();
}
public class NuGet.Commands.ListClientCertArgs : object {
    [CompilerGeneratedAttribute]
private string <Configfile>k__BackingField;
    public string Configfile { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Configfile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Configfile(string value);
}
public static class NuGet.Commands.ListClientCertRunner : object {
    private static int PaddingWidth;
    public static void Run(ListClientCertArgs args, Func`1<ILogger> getLogger);
}
public class NuGet.Commands.ListCommandRunner : object {
    [AsyncStateMachineAttribute("NuGet.Commands.ListCommandRunner/<ExecuteCommand>d__0")]
public sealed virtual Task ExecuteCommand(ListArgs listArgs);
    private static void AvoidHttpSources(ListArgs listArgs);
    [AsyncStateMachineAttribute("NuGet.Commands.ListCommandRunner/<PrintPackages>d__3")]
private Task PrintPackages(ListArgs listArgs, IEnumeratorAsync`1<IPackageSearchMetadata> asyncEnumerator);
}
public class NuGet.Commands.ListSourceArgs : object {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configfile>k__BackingField;
    public string Format { get; public set; }
    public string Configfile { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public string get_Configfile();
    [CompilerGeneratedAttribute]
public void set_Configfile(string value);
}
public static class NuGet.Commands.ListSourceRunner : object {
    public static void Run(ListSourceArgs args, Func`1<ILogger> getLogger);
    private static void WarnForHttpSources(IEnumerable`1<PackageSource> sources, Func`1<ILogger> getLogger);
}
public class NuGet.Commands.LocalsArgs : object {
    [CompilerGeneratedAttribute]
private bool <Clear>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <List>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private Log <LogError>k__BackingField;
    [CompilerGeneratedAttribute]
private Log <LogInformation>k__BackingField;
    public bool Clear { get; }
    public bool List { get; }
    public IList`1<string> Arguments { get; }
    public ISettings Settings { get; }
    public Log LogError { get; }
    public Log LogInformation { get; }
    public LocalsArgs(IList`1<string> arguments, ISettings settings, Log logInformation, Log logError, bool clear, bool list);
    [CompilerGeneratedAttribute]
public bool get_Clear();
    [CompilerGeneratedAttribute]
public bool get_List();
    [CompilerGeneratedAttribute]
public IList`1<string> get_Arguments();
    [CompilerGeneratedAttribute]
public ISettings get_Settings();
    [CompilerGeneratedAttribute]
public Log get_LogError();
    [CompilerGeneratedAttribute]
public Log get_LogInformation();
}
public class NuGet.Commands.LocalsCommandRunner : object {
    private static string HttpCacheResourceName;
    private static string GlobalPackagesResourceName;
    private static string PluginsCacheResourceName;
    private static string AllResourceName;
    private static string TempResourceName;
    public sealed virtual void ExecuteCommand(LocalsArgs localsArgs);
    private void ListLocalResource(LocalResourceName localResourceName, LocalsArgs localsArgs);
    private void PrintLocalResourcePath(string resourceName, string path, LocalsArgs localsArgs);
    private void ClearLocalResource(LocalResourceName localResourceName, LocalsArgs localsArgs);
    private bool ClearNuGetPluginsCache(LocalsArgs localsArgs);
    private bool ClearNuGetGlobalPackagesFolder(LocalsArgs localsArgs);
    private bool ClearNuGetHttpCache(LocalsArgs localsArgs);
    private bool ClearNuGetTempFolder(LocalsArgs localsArgs);
    private static LocalResourceName GetLocalResourceName(string localResourceName);
    private bool ClearCacheDirectory(string folderPath, LocalsArgs localsArgs);
}
public class NuGet.Commands.LockFileBuilder : object {
    private int _lockFileVersion;
    private ILogger _logger;
    private Dictionary`2<RestoreTargetGraph, Dictionary`2<string, LibraryIncludeFlags>> _includeFlagGraphs;
    public LockFileBuilder(int lockFileVersion, ILogger logger, Dictionary`2<RestoreTargetGraph, Dictionary`2<string, LibraryIncludeFlags>> includeFlagGraphs);
    [ObsoleteAttribute("Use method with LockFileBuilderCache parameter")]
public LockFile CreateLockFile(LockFile previousLockFile, PackageSpec project, IEnumerable`1<RestoreTargetGraph> targetGraphs, IReadOnlyList`1<NuGetv3LocalRepository> localRepositories, RemoteWalkContext context);
    public LockFile CreateLockFile(LockFile previousLockFile, PackageSpec project, IEnumerable`1<RestoreTargetGraph> targetGraphs, IReadOnlyList`1<NuGetv3LocalRepository> localRepositories, RemoteWalkContext context, LockFileBuilderCache lockFileBuilderCache);
    private Dictionary`2<ValueTuple`2<string, NuGetVersion>, LockFileLibrary> EnsureUniqueLockFileLibraries(LockFile lockFile);
    private static void EnsureUniqueLockFileTargetLibraries(LockFileTarget lockFileTarget);
    private static int RankReferences(string referenceType);
    private static string GetFallbackFrameworkString(NuGetFramework framework);
    private static void AddProjectFileDependenciesForSpec(PackageSpec project, LockFile lockFile);
    private static void AddProjectFileDependenciesForPackageReference(PackageSpec project, LockFile lockFile, IEnumerable`1<RestoreTargetGraph> targetGraphs);
    private void AddCentralTransitiveDependencyGroupsForPackageReference(PackageSpec project, LockFile lockFile, IEnumerable`1<RestoreTargetGraph> targetGraphs);
    [IteratorStateMachineAttribute("NuGet.Commands.LockFileBuilder/<GetLibraryDependenciesForCentralTransitiveDependencies>d__13")]
private IEnumerable`1<LibraryDependency> GetLibraryDependenciesForCentralTransitiveDependencies(RestoreTargetGraph targetGraph, TargetFrameworkInformation targetFrameworkInformation);
    [IteratorStateMachineAttribute("NuGet.Commands.LockFileBuilder/<EnumerateNodesForDependencyChecks>d__14`1")]
private static IEnumerable`1<GraphNode`1<T>> EnumerateNodesForDependencyChecks(HashSet`1<GraphNode`1<T>> visitedNodes, Queue`1<GraphNode`1<T>> queue, GraphNode`1<T> rootNode, GraphNode`1<T> graphNode);
    private static void PopulatePackageFolders(IEnumerable`1<string> packageFolders, LockFile lockFile);
    internal static LockFileLibrary CreateLockFileLibrary(LocalPackageInfo package, string sha512, string path);
    private static bool HasTools(string file);
}
public class NuGet.Commands.LockFileBuilderCache : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<ValueTuple`3<string, NuGetVersion, string>, ContentItemCollection> _contentItems;
    private ConcurrentDictionary`2<CriteriaKey, List`1<ValueTuple`2<List`1<SelectionCriteria>, bool>>> _criteriaSets;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<ValueTuple`4<CriteriaKey, string, string, LibraryIncludeFlags>, Lazy`1<ValueTuple`2<LockFileTargetLibrary, bool>>> _lockFileTargetLibraryCache;
    public List`1<List`1<SelectionCriteria>> GetSelectionCriteria(RestoreTargetGraph graph, NuGetFramework framework);
    internal List`1<ValueTuple`2<List`1<SelectionCriteria>, bool>> GetLabeledSelectionCriteria(RestoreTargetGraph graph, NuGetFramework framework);
    public ContentItemCollection GetContentItems(LockFileLibrary library, LocalPackageInfo package);
    internal ValueTuple`2<LockFileTargetLibrary, bool> GetLockFileTargetLibrary(RestoreTargetGraph graph, NuGetFramework framework, LocalPackageInfo localPackageInfo, string aliases, LibraryIncludeFlags libraryIncludeFlags, Func`1<ValueTuple`2<LockFileTargetLibrary, bool>> valueFactory);
}
public static class NuGet.Commands.LockFileUtils : object {
    public static string LIBANY;
    private static LockFileUtils();
    public static LockFileTargetLibrary CreateLockFileTargetLibrary(LockFileLibrary library, LocalPackageInfo package, RestoreTargetGraph targetGraph, LibraryIncludeFlags dependencyType);
    internal static ValueTuple`2<LockFileTargetLibrary, bool> CreateLockFileTargetLibrary(string aliases, LockFileLibrary library, LocalPackageInfo package, RestoreTargetGraph targetGraph, LibraryIncludeFlags dependencyType, NuGetFramework targetFrameworkOverride, List`1<LibraryDependency> dependencies, LockFileBuilderCache cache);
    internal static List`1<ValueTuple`2<List`1<SelectionCriteria>, bool>> CreateOrderedCriteriaSets(ManagedCodeConventions codeConventions, NuGetFramework framework, string runtimeIdentifier);
    private static void ApplyAliases(string aliases, LockFileItem item);
    internal static LockFileTargetLibrary CreateLockFileTargetLibrary(string aliases, LockFileLibrary library, LocalPackageInfo package, ManagedCodeConventions managedCodeConventions, LibraryIncludeFlags dependencyType, NuGetFramework framework, string runtimeIdentifier, ContentItemCollection contentItems, NuspecReader nuspec, IList`1<PackageType> packageTypes, List`1<SelectionCriteria> orderedCriteria);
    private static void AddMSBuildAssets(string libraryName, ManagedCodeConventions managedCodeConventions, LockFileTargetLibrary lockFileLib, List`1<SelectionCriteria> orderedCriteria, ContentItemCollection contentItems);
    private static LockFileTargetLibrary CreateLockFileTargetLibrary(string packageId, NuGetVersion packageVersion, List`1<PackageType> packageTypes, ManagedCodeConventions managedCodeConventions, ContentItemCollection contentItems, List`1<SelectionCriteria> orderedCriteria);
    private static void AddContentFiles(ManagedCodeConventions managedCodeConventions, LockFileTargetLibrary lockFileLib, NuGetFramework framework, ContentItemCollection contentItems, NuspecReader nuspec);
    private static void AddRuntimeTargets(ManagedCodeConventions managedCodeConventions, LibraryIncludeFlags dependencyType, LockFileTargetLibrary lockFileLib, NuGetFramework framework, string runtimeIdentifier, ContentItemCollection contentItems);
    private static void AddFrameworkReferences(LockFileTargetLibrary lockFileLib, NuGetFramework framework, NuspecReader nuspec);
    private static void ApplyReferenceFilter(LockFileTargetLibrary lockFileLib, NuGetFramework framework, NuspecReader nuspec);
    private static void ApplyLibContract(LocalPackageInfo package, LockFileTargetLibrary lockFileLib, NuGetFramework framework, ContentItemCollection contentItems);
    private static void AddDependencies(IEnumerable`1<LibraryDependency> dependencies, LockFileTargetLibrary lockFileLib, NuGetFramework framework, NuspecReader nuspec);
    public static LockFileTargetLibrary CreateLockFileTargetProject(GraphItem`1<RemoteResolveResult> graphItem, LibraryIdentity library, LibraryIncludeFlags dependencyType, RestoreTargetGraph targetGraph, ProjectStyle rootProjectStyle);
    private static List`1<LockFileItem> ConvertToProjectPaths(Dictionary`2<string, ProjectRestoreMetadataFile> fileLookup, string projectDir, IList`1<LockFileItem> items);
    private static IList`1<LockFileItem> GetLockFileItems(List`1<SelectionCriteria> criteria, ContentItemCollection items, Action`1<LockFileItem> additionalAction, PatternSet[] patterns);
    private static IList`1<LockFileItem> GetLockFileItems(List`1<SelectionCriteria> criteria, ContentItemCollection items, PatternSet[] patterns);
    [IteratorStateMachineAttribute("NuGet.Commands.LockFileUtils/<GetBuildItemsForPackageId>d__18")]
private static IEnumerable`1<LockFileItem> GetBuildItemsForPackageId(IList`1<LockFileItem> items, string packageId);
    private static List`1<SelectionCriteria> CreateCriteria(ManagedCodeConventions conventions, NuGetFramework framework, string runtimeIdentifier);
    private static void ClearIfExists(IList`1<T> group);
    private static bool GroupHasNonEmptyItems(IEnumerable`1<LockFileItem> group);
    private static List`1<ContentItemGroup> GetContentGroupsForFramework(NuGetFramework framework, List`1<ContentItemGroup> contentGroups, string primaryKey);
    private static List`1<LockFileRuntimeTarget> GetRuntimeTargetLockFileItems(ContentItemCollection contentItems, NuGetFramework framework, LibraryIncludeFlags dependencyType, LibraryIncludeFlags groupType, PatternSet patternSet, string assetType);
    private static List`1<LockFileRuntimeTarget> GetRuntimeTargetItems(List`1<ContentItemGroup> groups, string assetType);
    public static string ToDirectorySeparator(string path);
    private static PackageDependency GetDependencyVersionRange(LibraryDependency dependency);
    public static void ExcludeItems(LockFileTargetLibrary lockFileLib, LibraryIncludeFlags dependencyType);
}
public class NuGet.Commands.MSBuildItem : object {
    private IDictionary`2<string, string> _metadata;
    [CompilerGeneratedAttribute]
private string <Identity>k__BackingField;
    public string Identity { get; }
    public IReadOnlyList`1<string> Properties { get; }
    public MSBuildItem(string identity, IDictionary`2<string, string> metadata);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Identity();
    public sealed virtual IReadOnlyList`1<string> get_Properties();
    public sealed virtual string GetProperty(string property);
    public sealed virtual string GetProperty(string property, bool trim);
    public virtual string ToString();
}
internal class NuGet.Commands.MSBuildItemIdentityComparer : object {
    [CompilerGeneratedAttribute]
private static MSBuildItemIdentityComparer <Default>k__BackingField;
    public static MSBuildItemIdentityComparer Default { get; }
    private static MSBuildItemIdentityComparer();
    [CompilerGeneratedAttribute]
public static MSBuildItemIdentityComparer get_Default();
    public sealed virtual bool Equals(IMSBuildItem x, IMSBuildItem y);
    public sealed virtual int GetHashCode(IMSBuildItem obj);
}
public class NuGet.Commands.MSBuildOutputFile : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private XDocument <Content>k__BackingField;
    public string Path { get; }
    public XDocument Content { get; }
    public MSBuildOutputFile(string path, XDocument content);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public XDocument get_Content();
}
public class NuGet.Commands.MSBuildPackTargetArgs : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<OutputLibFile> <TargetPathsToSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<OutputLibFile> <TargetPathsToAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <AllowedOutputExtensionsInPackageBuildOutputFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NuspecOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, IEnumerable`1<ContentMetadata>> <ContentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<NuGetFramework> <TargetFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <SourceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeBuildOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <BuildOutputFolder>k__BackingField;
    public IEnumerable`1<OutputLibFile> TargetPathsToSymbols { get; public set; }
    public IEnumerable`1<OutputLibFile> TargetPathsToAssemblies { get; public set; }
    public HashSet`1<string> AllowedOutputExtensionsInPackageBuildOutputFolder { get; public set; }
    public HashSet`1<string> AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder { get; public set; }
    public string AssemblyName { get; public set; }
    public string NuspecOutputPath { get; public set; }
    public Dictionary`2<string, IEnumerable`1<ContentMetadata>> ContentFiles { get; public set; }
    public ISet`1<NuGetFramework> TargetFrameworks { get; public set; }
    public IDictionary`2<string, string> SourceFiles { get; public set; }
    public bool IncludeBuildOutput { get; public set; }
    public String[] BuildOutputFolder { get; public set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<OutputLibFile> get_TargetPathsToSymbols();
    [CompilerGeneratedAttribute]
public void set_TargetPathsToSymbols(IEnumerable`1<OutputLibFile> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<OutputLibFile> get_TargetPathsToAssemblies();
    [CompilerGeneratedAttribute]
public void set_TargetPathsToAssemblies(IEnumerable`1<OutputLibFile> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_AllowedOutputExtensionsInPackageBuildOutputFolder();
    [CompilerGeneratedAttribute]
public void set_AllowedOutputExtensionsInPackageBuildOutputFolder(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder();
    [CompilerGeneratedAttribute]
public void set_AllowedOutputExtensionsInSymbolsPackageBuildOutputFolder(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public string get_NuspecOutputPath();
    [CompilerGeneratedAttribute]
public void set_NuspecOutputPath(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, IEnumerable`1<ContentMetadata>> get_ContentFiles();
    [CompilerGeneratedAttribute]
public void set_ContentFiles(Dictionary`2<string, IEnumerable`1<ContentMetadata>> value);
    [CompilerGeneratedAttribute]
public ISet`1<NuGetFramework> get_TargetFrameworks();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworks(ISet`1<NuGetFramework> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_SourceFiles();
    [CompilerGeneratedAttribute]
public void set_SourceFiles(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public bool get_IncludeBuildOutput();
    [CompilerGeneratedAttribute]
public void set_IncludeBuildOutput(bool value);
    [CompilerGeneratedAttribute]
public String[] get_BuildOutputFolder();
    [CompilerGeneratedAttribute]
public void set_BuildOutputFolder(String[] value);
}
public class NuGet.Commands.MSBuildProjectFactory : object {
    private ILogger _logger;
    private static string SourcesFolder;
    [CompilerGeneratedAttribute]
private MSBuildPackTargetArgs <PackTargetArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private PackArgs <PackArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Build>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <ProjectProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTool>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ManifestFile> <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private IMachineWideSettings <MachineWideSettings>k__BackingField;
    private MSBuildPackTargetArgs PackTargetArgs { get; private set; }
    private PackArgs PackArgs { get; private set; }
    public bool IncludeSymbols { get; public set; }
    public bool Build { get; public set; }
    public Dictionary`2<string, string> ProjectProperties { get; private set; }
    public bool IsTool { get; public set; }
    public ICollection`1<ManifestFile> Files { get; public set; }
    public ILogger Logger { get; public set; }
    public IMachineWideSettings MachineWideSettings { get; public set; }
    private static MSBuildProjectFactory();
    [CompilerGeneratedAttribute]
private MSBuildPackTargetArgs get_PackTargetArgs();
    [CompilerGeneratedAttribute]
private void set_PackTargetArgs(MSBuildPackTargetArgs value);
    [CompilerGeneratedAttribute]
private PackArgs get_PackArgs();
    [CompilerGeneratedAttribute]
private void set_PackArgs(PackArgs value);
    public sealed virtual void SetIncludeSymbols(bool includeSymbols);
    [CompilerGeneratedAttribute]
public bool get_IncludeSymbols();
    [CompilerGeneratedAttribute]
public void set_IncludeSymbols(bool value);
    [CompilerGeneratedAttribute]
public bool get_Build();
    [CompilerGeneratedAttribute]
public void set_Build(bool value);
    public sealed virtual Dictionary`2<string, string> GetProjectProperties();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_ProjectProperties();
    [CompilerGeneratedAttribute]
private void set_ProjectProperties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public bool get_IsTool();
    [CompilerGeneratedAttribute]
public void set_IsTool(bool value);
    [CompilerGeneratedAttribute]
public ICollection`1<ManifestFile> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(ICollection`1<ManifestFile> value);
    public sealed virtual ILogger get_Logger();
    public sealed virtual void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public IMachineWideSettings get_MachineWideSettings();
    [CompilerGeneratedAttribute]
public void set_MachineWideSettings(IMachineWideSettings value);
    public static IProjectFactory ProjectCreator(PackArgs packArgs, string path);
    public sealed virtual PackageBuilder CreateBuilder(string basePath, NuGetVersion version, string suffix, bool buildIfNeeded, PackageBuilder builder);
    private void AddOutputFiles();
    private void AddOutputLibFiles(IEnumerable`1<OutputLibFile> libFiles, HashSet`1<string> allowedExtensions);
    private bool AddFileToBuilder(ManifestFile packageFile);
    private void AddContentFiles(PackageBuilder builder);
    private void AddSourceFiles();
    public static string GetTargetPathForSourceFile(string sourcePath, string projectDirectory);
    private static bool IsContentFile(string contentFileTargetPath);
    public sealed virtual WarningProperties GetWarningPropertiesForProject();
}
public static class NuGet.Commands.MSBuildProjectFrameworkUtility : object {
    public static IEnumerable`1<string> GetProjectFrameworkStrings(string projectFilePath, string targetFrameworks, string targetFramework, string targetFrameworkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string targetPlatformMinVersion);
    public static NuGetFramework GetProjectFramework(string projectFilePath, string targetFrameworkMoniker, string targetPlatformMoniker, string targetPlatformMinVersion);
    public static NuGetFramework GetProjectFramework(string projectFilePath, string targetFrameworkMoniker, string targetPlatformMoniker, string targetPlatformMinVersion, string clrSupport, string windowsTargetPlatformMinVersion);
    [ObsoleteAttribute("If you need ClrSupport support parameter to be accounted for in the calculation, the method with the windowsTargetPlatformMinVersion is the only correct one.")]
public static NuGetFramework GetProjectFramework(string projectFilePath, string targetFrameworkMoniker, string targetPlatformMoniker, string targetPlatformMinVersion, string clrSupport);
    public static IEnumerable`1<string> GetProjectFrameworkStrings(string projectFilePath, string targetFrameworks, string targetFramework, string targetFrameworkMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string targetPlatformMinVersion, bool isXnaWindowsPhoneProject, bool isManagementPackProject);
    internal static IEnumerable`1<string> GetProjectFrameworks(string projectFilePath, string targetFrameworks, string targetFramework, string targetFrameworkMoniker, string targetPlatformMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string targetPlatformMinVersion, string clrSupport, string windowsTargetPlatformMinVersion, bool isXnaWindowsPhoneProject, bool isManagementPackProject);
    internal static NuGetFramework GetProjectFramework(string projectFilePath, string targetFrameworkMoniker, string targetPlatformMoniker, string targetPlatformIdentifier, string targetPlatformVersion, string targetPlatformMinVersion, string clrSupport, string windowsTargetPlatformMinVersion, bool isXnaWindowsPhoneProject, bool isManagementPackProject);
    private static NuGetFramework GetFrameworkFromMoniker(string platformIdentifier, string platformMoniker, string platformMinVersion);
    private static String[] GetParts(string targetPlatformMoniker);
    public static IEnumerable`1<NuGetFramework> GetProjectFrameworks(IEnumerable`1<string> frameworkStrings);
    public static NuGetFramework GetProjectFrameworkReplacement(NuGetFramework framework);
}
public class NuGet.Commands.MSBuildRestoreItemGroup : object {
    public static string ItemGroup;
    public static string ImportGroup;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<XElement> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootName>k__BackingField;
    public int Position { get; public set; }
    public List`1<string> Conditions { get; public set; }
    public List`1<XElement> Items { get; public set; }
    public string RootName { get; public set; }
    public string Condition { get; }
    private static MSBuildRestoreItemGroup();
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(int value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Conditions();
    [CompilerGeneratedAttribute]
public void set_Conditions(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<XElement> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(List`1<XElement> value);
    [CompilerGeneratedAttribute]
public string get_RootName();
    [CompilerGeneratedAttribute]
public void set_RootName(string value);
    public string get_Condition();
    internal static MSBuildRestoreItemGroup Create(string rootName, int position);
    public static MSBuildRestoreItemGroup Create(string rootName, IEnumerable`1<XElement> items, int position, IEnumerable`1<string> conditions);
}
[ExtensionAttribute]
public static class NuGet.Commands.MSBuildRestoreUtility : object {
    public static string Clear;
    private static String[] HttpPrefixes;
    private static string DoubleSlash;
    private static MSBuildRestoreUtility();
    public static DependencyGraphSpec GetDependencySpec(IEnumerable`1<IMSBuildItem> items);
    public static DependencyGraphSpec GetDependencySpec(IEnumerable`1<IMSBuildItem> items, bool readOnly);
    public static void ApplyIncludeFlags(LibraryDependency dependency, string includeAssets, string excludeAssets, string privateAssets);
    public static void ApplyIncludeFlags(ProjectRestoreReference dependency, string includeAssets, string excludeAssets, string privateAssets);
    public static PackageSpec GetPackageSpec(IEnumerable`1<IMSBuildItem> items);
    public static void RemoveMissingProjects(DependencyGraphSpec graphSpec);
    public static void NormalizePathCasings(Dictionary`2<string, string> paths, DependencyGraphSpec graphSpec);
    public static void NormalizePathCasings(IDictionary`2<string, string> paths, DependencyGraphSpec graphSpec);
    public static bool ContainsClearKeyword(IEnumerable`1<string> values);
    public static bool HasInvalidClear(IEnumerable`1<string> values);
    public static bool LogErrorForClearIfInvalid(IEnumerable`1<string> values, string projectPath, ILogger logger);
    public static RestoreLogMessage GetWarningForUnsupportedProject(string path);
    public static RestoreLogMessage GetMessageForUnsupportedProject(string path);
    [IteratorStateMachineAttribute("NuGet.Commands.MSBuildRestoreUtility/<GetTargetFrameworkInformation>d__16")]
private static IEnumerable`1<TargetFrameworkInformation> GetTargetFrameworkInformation(string filePath, ProjectStyle restoreType, IEnumerable`1<IMSBuildItem> items);
    public static IEnumerable`1<string> AggregateSources(IEnumerable`1<string> values, IEnumerable`1<string> excludeValues);
    private static RuntimeGraph GetRuntimeGraph(IMSBuildItem specItem);
    private static void AddProjectReferences(PackageSpec spec, IEnumerable`1<IMSBuildItem> items);
    private static Tuple`2<List`1<string>, ProjectRestoreReference> GetProjectRestoreReference(IMSBuildItem item);
    private static bool AddDownloadDependencyIfNotExist(PackageSpec spec, string targetAlias, DownloadDependency dependency);
    private static bool AddDependencyIfNotExist(PackageSpec spec, LibraryDependency dependency);
    private static bool AddDependencyIfNotExist(PackageSpec spec, string targetAlias, LibraryDependency dependency);
    private static void AddPackageReferences(PackageSpec spec, IEnumerable`1<IMSBuildItem> items, bool isCpvmEnabled);
    internal static void AddPackageDownloads(PackageSpec spec, IEnumerable`1<IMSBuildItem> items);
    private static void ApplyIncludeFlags(LibraryDependency dependency, IMSBuildItem item);
    private static LibraryIncludeFlags GetIncludeFlags(string value, LibraryIncludeFlags defaultValue);
    private static void AddFrameworkReferences(PackageSpec spec, IEnumerable`1<IMSBuildItem> items);
    private static bool AddFrameworkReferenceIfNotExists(PackageSpec spec, string targetAlias, string frameworkReference, string privateAssetsValue);
    private static VersionRange GetVersionRange(IMSBuildItem item, VersionRange defaultValue, string propertyName);
    private static VersionRange GetVersionRange(string rangeString, VersionRange defaultValue);
    private static PackageSpec GetProjectJsonSpec(IMSBuildItem specItem);
    private static PackageSpec GetBaseSpec(IMSBuildItem specItem, ProjectStyle projectStyle, IEnumerable`1<IMSBuildItem> items);
    private static HashSet`1<string> GetFrameworks(IMSBuildItem item);
    private static HashSet`1<string> GetTargetFrameworkStrings(IMSBuildItem item);
    private static IEnumerable`1<IMSBuildItem> GetItemByType(IEnumerable`1<IMSBuildItem> items, string type);
    [ExtensionAttribute]
private static bool IsType(IMSBuildItem item, string type);
    private static NuGetVersion GetVersion(IMSBuildItem item);
    public static void Dump(IEnumerable`1<IMSBuildItem> items, ILogger log);
    private static WarningProperties GetWarningProperties(IMSBuildItem specItem);
    private static RestoreLockProperties GetRestoreLockProperties(IMSBuildItem specItem);
    public static RestoreAuditProperties GetRestoreAuditProperties(IMSBuildItem specItem, HashSet`1<string> suppressionItems);
    public static NuGetVersion GetSdkAnalysisLevel(string sdkAnalysisLevel);
    public static bool GetUsingMicrosoftNETSdk(string usingMicrosoftNETSdk);
    private static HashSet`1<string> GetAuditSuppressions(IEnumerable`1<IMSBuildItem> items);
    public static string FixSourcePath(string s);
    private static string FixSourcePath(string s, string prefixWithoutSlashes, string slashes);
    internal static bool IsPropertyFalse(IMSBuildItem item, string propertyName, bool defaultValue);
    internal static bool IsPropertyTrue(IMSBuildItem item, string propertyName, bool defaultValue);
    public static Task ReplayWarningsAndErrorsAsync(IEnumerable`1<IAssetsLogMessage> messages, ILogger logger);
    private static Dictionary`2<string, Dictionary`2<string, CentralPackageVersion>> CreateCentralVersionDependencies(IEnumerable`1<IMSBuildItem> items, IList`1<TargetFrameworkInformation> specFrameworks);
    private static void AddCentralPackageVersion(Dictionary`2<string, Dictionary`2<string, CentralPackageVersion>> centralPackageVersions, CentralPackageVersion centralPackageVersion, IEnumerable`1<string> frameworks);
    private static ProjectStyle GetProjectStyle(IMSBuildItem projectSpecItem);
    public static ValueTuple`4<bool, bool, bool, bool> GetCentralPackageManagementSettings(IMSBuildItem projectSpecItem, ProjectStyle projectStyle);
    private static void AddCentralPackageVersions(PackageSpec spec, IEnumerable`1<IMSBuildItem> items);
}
public class NuGet.Commands.NoOpRestoreResult : RestoreResult {
    private Lazy`1<LockFile> _lockFileLazy;
    public LockFile LockFile { get; }
    public LockFile PreviousLockFile { get; }
    public NoOpRestoreResult(bool success, string lockFilePath, Lazy`1<LockFile> lockFileLazy, CacheFile cacheFile, string cacheFilePath, ProjectStyle projectStyle, TimeSpan elapsedTime);
    public virtual LockFile get_LockFile();
    public virtual LockFile get_PreviousLockFile();
    public virtual Task CommitAsync(ILogger log, CancellationToken token);
    public virtual ISet`1<LibraryIdentity> GetAllInstalled();
    internal virtual IReadOnlyList`1<string> GetDirtyFiles();
}
public static class NuGet.Commands.NoOpRestoreUtilities : object {
    internal static string NoOpCacheFileName;
    internal static bool IsNoOpSupported(RestoreRequest request);
    private static string GetBuildIntegratedProjectCacheFilePath(RestoreRequest request);
    public static string GetProjectCacheFilePath(string cacheRoot, string projectPath);
    public static string GetProjectCacheFilePath(string cacheRoot);
    internal static string GetToolCacheFilePath(RestoreRequest request, LockFile lockFile);
    internal static string GetToolCacheFilePath(string toolDirectory, string toolName);
    internal static string GetCacheFilePath(RestoreRequest request);
    internal static string GetCacheFilePath(RestoreRequest request, LockFile lockFile);
    internal static bool VerifyRestoreOutput(RestoreRequest request, CacheFile cacheFile);
    internal static DependencyGraphSpec GetNoOpDgSpec(RestoreRequest request);
    internal static string GetPersistedDGSpecFilePath(RestoreRequest request);
    internal static void UpdateRequestBestMatchingToolPathsIfAvailable(RestoreRequest request);
    internal static List`1<string> GetRestoreOutput(RestoreRequest request, LockFile lockFile);
    [IteratorStateMachineAttribute("NuGet.Commands.NoOpRestoreUtilities/<GetPackageFiles>d__14")]
private static IEnumerable`1<string> GetPackageFiles(LocalPackageFileCache packageFileCache, string packageId, NuGetVersion version, List`1<VersionFolderPathResolver> resolvers);
}
internal class NuGet.Commands.NuGetSpecValidationStrings : object {
    public static string MissingRequiredProperty;
    public static string MissingRequiredPropertyForProjectType;
    public static string InvalidRestoreInput;
    public static string ErrorXprojNotAllowed;
    public static string PropertyNotAllowedForProjectType;
    public static string SpecValidationInvalidFramework;
    public static string SpecValidationNoFrameworks;
    public static string SpecValidationDuplicateFrameworks;
    public static string SpecValidationUAPSingleFramework;
    public static string PropertyNotAllowed;
}
public class NuGet.Commands.OriginalCaseGlobalPackageFolder : object {
    private List`1<NuGetv3LocalRepository> _localRepositories;
    private RestoreRequest _request;
    private ToolPathResolver _toolPathResolver;
    private VersionFolderPathResolver _pathResolver;
    [CompilerGeneratedAttribute]
private Guid <ParentId>k__BackingField;
    public Guid ParentId { get; }
    public OriginalCaseGlobalPackageFolder(RestoreRequest request);
    public OriginalCaseGlobalPackageFolder(RestoreRequest request, Guid parentId);
    [CompilerGeneratedAttribute]
public Guid get_ParentId();
    [AsyncStateMachineAttribute("NuGet.Commands.OriginalCaseGlobalPackageFolder/<CopyPackagesToOriginalCaseAsync>d__9")]
public Task CopyPackagesToOriginalCaseAsync(IEnumerable`1<RestoreTargetGraph> graphs, CancellationToken token);
    public void ConvertLockFileToOriginalCase(LockFile lockFile);
    private PackageExtractionContext GetPathContext();
    private static PackageIdentity GetPackageIdentity(RemoteMatch remoteMatch);
    private LocalPackageSourceInfo GetLocalPackageSourceInfo(RemoteMatch remoteMatch);
}
public class NuGet.Commands.OutputLibFile : ValueType {
    [CompilerGeneratedAttribute]
private string <FinalOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    public string FinalOutputPath { get; public set; }
    public string TargetPath { get; public set; }
    public string TargetFramework { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_FinalOutputPath();
    [CompilerGeneratedAttribute]
public void set_FinalOutputPath(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TargetPath();
    [CompilerGeneratedAttribute]
public void set_TargetPath(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(string value);
}
public class NuGet.Commands.PackagesLockFileBuilder : object {
    public PackagesLockFile CreateNuGetLockFile(LockFile assetsFile);
    private int GetPackagesLockFileVersion(LockFile assetsFile);
}
[ExtensionAttribute]
public static class NuGet.Commands.PackageSourceProviderExtensions : object {
    public static PackageSource ResolveSource(IEnumerable`1<PackageSource> availableSources, string source);
    [ExtensionAttribute]
public static string ResolveAndValidateSource(IPackageSourceProvider sourceProvider, string source);
    private static void ValidateSource(string source);
}
public class NuGet.Commands.PackageSpecificWarningProperties : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<NuGetLogCode, IDictionary`2<string, ISet`1<NuGetFramework>>> <Properties>k__BackingField;
    public IDictionary`2<NuGetLogCode, IDictionary`2<string, ISet`1<NuGetFramework>>> Properties { get; private set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<NuGetLogCode, IDictionary`2<string, ISet`1<NuGetFramework>>> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(IDictionary`2<NuGetLogCode, IDictionary`2<string, ISet`1<NuGetFramework>>> value);
    public static PackageSpecificWarningProperties CreatePackageSpecificWarningProperties(PackageSpec packageSpec);
    public static PackageSpecificWarningProperties CreatePackageSpecificWarningProperties(PackageSpec packageSpec, NuGetFramework framework);
    public void Add(NuGetLogCode code, string libraryId, NuGetFramework framework);
    public void AddRangeOfCodes(IEnumerable`1<NuGetLogCode> codes, string libraryId, NuGetFramework framework);
    public void AddRangeOfFrameworks(NuGetLogCode code, string libraryId, IEnumerable`1<NuGetFramework> frameworks);
    public bool Contains(NuGetLogCode code, string libraryId, NuGetFramework framework);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PackageSpecificWarningProperties other);
}
public class NuGet.Commands.PackArgs : object {
    private string _currentDirectory;
    private Dictionary`2<string, string> _properties;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BasePath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Build>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeEmptyDirectories>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeReferencedProjects>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InstallPackageToOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IMachineWideSettings <MachineWideSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <MinClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolPackageFormat <SymbolPackageFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private Lazy`1<string> <MsBuildDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoDefaultExcludes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoPackageAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OutputFileNamesWithoutVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SolutionDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Suffix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Symbols>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Tool>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Deterministic>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningProperties <WarningProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private MSBuildPackTargetArgs <PackTargetArgs>k__BackingField;
    public IEnumerable`1<string> Arguments { get; public set; }
    public string BasePath { get; public set; }
    public bool Build { get; public set; }
    public IEnumerable`1<string> Exclude { get; public set; }
    public bool ExcludeEmptyDirectories { get; public set; }
    public ILogger Logger { get; public set; }
    public LogLevel LogLevel { get; public set; }
    public bool IncludeReferencedProjects { get; public set; }
    public bool InstallPackageToOutputPath { get; public set; }
    public IMachineWideSettings MachineWideSettings { get; public set; }
    public Version MinClientVersion { get; public set; }
    public SymbolPackageFormat SymbolPackageFormat { get; public set; }
    public Lazy`1<string> MsBuildDirectory { get; public set; }
    public bool NoDefaultExcludes { get; public set; }
    public bool NoPackageAnalysis { get; public set; }
    public string OutputDirectory { get; public set; }
    public bool OutputFileNamesWithoutVersion { get; public set; }
    public string PackagesDirectory { get; public set; }
    public string Path { get; public set; }
    public bool Serviceable { get; public set; }
    public string SolutionDirectory { get; public set; }
    public string Suffix { get; public set; }
    public bool Symbols { get; public set; }
    public bool Tool { get; public set; }
    public string Version { get; public set; }
    public bool Deterministic { get; public set; }
    public WarningProperties WarningProperties { get; public set; }
    public MSBuildPackTargetArgs PackTargetArgs { get; public set; }
    public Dictionary`2<string, string> Properties { get; }
    public string CurrentDirectory { get; public set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_BasePath();
    [CompilerGeneratedAttribute]
public void set_BasePath(string value);
    [CompilerGeneratedAttribute]
public bool get_Build();
    [CompilerGeneratedAttribute]
public void set_Build(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeEmptyDirectories();
    [CompilerGeneratedAttribute]
public void set_ExcludeEmptyDirectories(bool value);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public void set_LogLevel(LogLevel value);
    [CompilerGeneratedAttribute]
public bool get_IncludeReferencedProjects();
    [CompilerGeneratedAttribute]
public void set_IncludeReferencedProjects(bool value);
    [CompilerGeneratedAttribute]
public bool get_InstallPackageToOutputPath();
    [CompilerGeneratedAttribute]
public void set_InstallPackageToOutputPath(bool value);
    [CompilerGeneratedAttribute]
public IMachineWideSettings get_MachineWideSettings();
    [CompilerGeneratedAttribute]
public void set_MachineWideSettings(IMachineWideSettings value);
    [CompilerGeneratedAttribute]
public Version get_MinClientVersion();
    [CompilerGeneratedAttribute]
public void set_MinClientVersion(Version value);
    [CompilerGeneratedAttribute]
public SymbolPackageFormat get_SymbolPackageFormat();
    [CompilerGeneratedAttribute]
public void set_SymbolPackageFormat(SymbolPackageFormat value);
    [CompilerGeneratedAttribute]
public Lazy`1<string> get_MsBuildDirectory();
    [CompilerGeneratedAttribute]
public void set_MsBuildDirectory(Lazy`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_NoDefaultExcludes();
    [CompilerGeneratedAttribute]
public void set_NoDefaultExcludes(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoPackageAnalysis();
    [CompilerGeneratedAttribute]
public void set_NoPackageAnalysis(bool value);
    [CompilerGeneratedAttribute]
public string get_OutputDirectory();
    [CompilerGeneratedAttribute]
public void set_OutputDirectory(string value);
    [CompilerGeneratedAttribute]
public bool get_OutputFileNamesWithoutVersion();
    [CompilerGeneratedAttribute]
public void set_OutputFileNamesWithoutVersion(bool value);
    [CompilerGeneratedAttribute]
public string get_PackagesDirectory();
    [CompilerGeneratedAttribute]
public void set_PackagesDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public bool get_Serviceable();
    [CompilerGeneratedAttribute]
public void set_Serviceable(bool value);
    [CompilerGeneratedAttribute]
public string get_SolutionDirectory();
    [CompilerGeneratedAttribute]
public void set_SolutionDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_Suffix();
    [CompilerGeneratedAttribute]
public void set_Suffix(string value);
    [CompilerGeneratedAttribute]
public bool get_Symbols();
    [CompilerGeneratedAttribute]
public void set_Symbols(bool value);
    [CompilerGeneratedAttribute]
public bool get_Tool();
    [CompilerGeneratedAttribute]
public void set_Tool(bool value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public bool get_Deterministic();
    [CompilerGeneratedAttribute]
public void set_Deterministic(bool value);
    [CompilerGeneratedAttribute]
public WarningProperties get_WarningProperties();
    [CompilerGeneratedAttribute]
public void set_WarningProperties(WarningProperties value);
    [CompilerGeneratedAttribute]
public MSBuildPackTargetArgs get_PackTargetArgs();
    [CompilerGeneratedAttribute]
public void set_PackTargetArgs(MSBuildPackTargetArgs value);
    public Dictionary`2<string, string> get_Properties();
    public string get_CurrentDirectory();
    public void set_CurrentDirectory(string value);
    public string GetPropertyValue(string propertyName);
    public static SymbolPackageFormat GetSymbolPackageFormat(string symbolPackageFormat);
}
public class NuGet.Commands.PackCollectorLogger : LoggerBase {
    private ConcurrentQueue`1<ILogMessage> _errors;
    private ILogger _innerLogger;
    [CompilerGeneratedAttribute]
private WarningProperties <WarningProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSpecificWarningProperties <PackageSpecificWarningProperties>k__BackingField;
    public WarningProperties WarningProperties { get; public set; }
    private PackageSpecificWarningProperties PackageSpecificWarningProperties { get; private set; }
    public IEnumerable`1<ILogMessage> Errors { get; }
    public PackCollectorLogger(ILogger innerLogger, WarningProperties warningProperties);
    public PackCollectorLogger(ILogger innerLogger, WarningProperties warningProperties, PackageSpecificWarningProperties packageSpecificWarningProperties);
    [CompilerGeneratedAttribute]
public WarningProperties get_WarningProperties();
    [CompilerGeneratedAttribute]
public void set_WarningProperties(WarningProperties value);
    [CompilerGeneratedAttribute]
private PackageSpecificWarningProperties get_PackageSpecificWarningProperties();
    [CompilerGeneratedAttribute]
private void set_PackageSpecificWarningProperties(PackageSpecificWarningProperties value);
    public IEnumerable`1<ILogMessage> get_Errors();
    public virtual void Log(ILogMessage message);
    public virtual Task LogAsync(ILogMessage message);
    private bool IsWarningSuppressed(ILogMessage message);
    private void UpgradeWarningToErrorIfNeeded(ILogMessage message);
    private bool DisplayMessage(ILogMessage message);
}
public class NuGet.Commands.PackCommand.PackageSpecificWarningProperties : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<NuGetLogCode, IDictionary`2<string, ISet`1<NuGetFramework>>> <Properties>k__BackingField;
    internal IDictionary`2<NuGetLogCode, IDictionary`2<string, ISet`1<NuGetFramework>>> Properties { get; private set; }
    [CompilerGeneratedAttribute]
internal IDictionary`2<NuGetLogCode, IDictionary`2<string, ISet`1<NuGetFramework>>> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(IDictionary`2<NuGetLogCode, IDictionary`2<string, ISet`1<NuGetFramework>>> value);
    public static PackageSpecificWarningProperties CreatePackageSpecificWarningProperties(IDictionary`2<string, HashSet`1<ValueTuple`2<NuGetLogCode, NuGetFramework>>> noWarnProperties);
    internal void Add(NuGetLogCode code, string libraryId, NuGetFramework framework);
    internal bool Contains(NuGetLogCode code, string libraryId, NuGetFramework framework);
    internal bool ApplyNoWarnProperties(IPackLogMessage message);
    private bool ApplyPackageSpecificNoWarnProperties(IPackLogMessage message);
}
public class NuGet.Commands.PackCommandRunner : object {
    private PackArgs _packArgs;
    private PackageBuilder _packageBuilder;
    private CreateProjectFactory _createProjectFactory;
    private static HashSet`1<string> AllowedExtensions;
    private static String[] LibPackageExcludes;
    private static String[] SymbolPackageExcludes;
    private HashSet`1<string> _excludes;
    [CompilerGeneratedAttribute]
private bool <GenerateNugetPackage>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IPackageRule> <Rules>k__BackingField;
    public bool GenerateNugetPackage { get; public set; }
    public IEnumerable`1<IPackageRule> Rules { get; public set; }
    public PackCommandRunner(PackArgs packArgs, CreateProjectFactory createProjectFactory, PackageBuilder packageBuilder);
    public PackCommandRunner(PackArgs packArgs, CreateProjectFactory createProjectFactory);
    private static PackCommandRunner();
    [CompilerGeneratedAttribute]
public bool get_GenerateNugetPackage();
    [CompilerGeneratedAttribute]
public void set_GenerateNugetPackage(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IPackageRule> get_Rules();
    [CompilerGeneratedAttribute]
public void set_Rules(IEnumerable`1<IPackageRule> value);
    public bool RunPackageBuild();
    [ObsoleteAttribute("Do not use this. Use RunPackageBuild() instead as it accounts for the effects of package analysis to the complete operation status.")]
public void BuildPackage();
    private bool BuildPackage(string path);
    [ObsoleteAttribute("Do not use this. Use RunPackageBuild() instead as it accounts for the effects of package analysis to the complete operation status.")]
public PackageArchiveReader BuildPackage(PackageBuilder builder, string outputPath);
    private bool BuildPackage(PackageBuilder builder, string outputPath, bool symbolsPackage);
    private void WriteResolvedNuSpecToPackageOutputDirectory(PackageBuilder builder);
    private void WriteSHA512PackageHash(PackageBuilder builder);
    private void InitCommonPackageBuilderProperties(PackageBuilder builder);
    [ObsoleteAttribute]
public static bool ProcessProjectJsonFile(PackageBuilder builder, string basePath, string id, NuGetVersion version, string suffix, Func`2<string, string> propertyProvider);
    [ObsoleteAttribute]
private static void LoadProjectJsonFile(PackageBuilder builder, string path, string basePath, string id, Stream stream, NuGetVersion version, string suffix);
    private static void CalculateExcludes(IncludeExcludeFiles files, String& fullExclude, String& filesExclude);
    public static void AddDependencyGroups(IEnumerable`1<LibraryDependency> dependencies, NuGetFramework framework, PackageBuilder builder);
    private bool BuildFromNuspec(string path);
    private PackageBuilder CreatePackageBuilderFromNuspec(string path);
    private bool BuildFromProjectFile(string path);
    private void CheckForUnsupportedFrameworks(PackageBuilder builder);
    private void PrintVerbose(string outputPath, PackageBuilder builder);
    internal void ExcludeFiles(ICollection`1<IPackageFile> packageFiles);
    private IEnumerable`1<IPackageFile> RemoveDefaultExclusions(ICollection`1<IPackageFile> packageFiles);
    private string ResolvePath(IPackageFile packageFile);
    private static string ResolvePath(IPackageFile packageFile, string basePath);
    private bool BuildSymbolsPackage(string path);
    internal void AnalyzePackage(PackageArchiveReader package);
    private void PrintPackageLogMessage(PackagingLogMessage message);
    internal static void ExcludeFilesForLibPackage(ICollection`1<IPackageFile> files);
    internal static void ExcludeFilesForSymbolPackage(ICollection`1<IPackageFile> files, SymbolPackageFormat symbolPackageFormat);
    public static string GetOutputPath(PackageBuilder builder, PackArgs packArgs, bool symbols, NuGetVersion nugetVersion, string outputDirectory, bool isNupkg);
    public static string GetOutputFileName(string packageId, NuGetVersion version, bool isNupkg, bool symbols, SymbolPackageFormat symbolPackageFormat, bool excludeVersion);
    public static void SetupCurrentDirectory(PackArgs packArgs);
    public static string GetInputFile(PackArgs packArgs);
    internal static string GetInputFile(PackArgs packArgs, IEnumerable`1<string> files);
    private void WriteLine(string message, object arg);
    public static void AddLibraryDependency(LibraryDependency dependency, ISet`1<LibraryDependency> list);
    public static void AddPackageDependency(PackageDependency dependency, ISet`1<PackageDependency> set);
}
internal class NuGet.Commands.ProjectRestoreCommand : object {
    private RestoreCollectorLogger _logger;
    private ProjectRestoreRequest _request;
    internal static string WalkFrameworkDependencyDuration;
    private static string WalkRuntimeDependencyDuration;
    private static string EvaluateDownloadDependenciesDuration;
    [CompilerGeneratedAttribute]
private Guid <ParentId>k__BackingField;
    public Guid ParentId { get; }
    public ProjectRestoreCommand(ProjectRestoreRequest request);
    [CompilerGeneratedAttribute]
public Guid get_ParentId();
    [AsyncStateMachineAttribute("NuGet.Commands.ProjectRestoreCommand/<TryRestoreAsync>d__9")]
public Task`1<Tuple`3<bool, List`1<RestoreTargetGraph>, RuntimeGraph>> TryRestoreAsync(LibraryRange projectRange, IEnumerable`1<FrameworkRuntimePair> frameworkRuntimePairs, NuGetv3LocalRepository userPackageFolder, IReadOnlyList`1<NuGetv3LocalRepository> fallbackPackageFolders, RemoteDependencyWalker remoteWalker, RemoteWalkContext context, bool forceRuntimeGraphCreation, CancellationToken token, TelemetryActivity telemetryActivity, string telemetryPrefix);
    internal static RuntimeGraph GetRuntimeGraph(string runtimeGraphPath, RestoreCollectorLogger logger);
    [AsyncStateMachineAttribute("NuGet.Commands.ProjectRestoreCommand/<DownloadDependenciesAsync>d__11")]
internal static Task`1<DownloadDependencyResolutionResult[]> DownloadDependenciesAsync(PackageSpec packageSpec, RemoteWalkContext context, TelemetryActivity telemetryActivity, string telemetryPrefix, CancellationToken cancellationToken);
    private Task`1<RestoreTargetGraph> WalkDependenciesAsync(LibraryRange projectRange, NuGetFramework framework, RemoteDependencyWalker walker, RemoteWalkContext context, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.ProjectRestoreCommand/<WalkDependenciesAsync>d__13")]
private Task`1<RestoreTargetGraph> WalkDependenciesAsync(LibraryRange projectRange, NuGetFramework framework, string runtimeIdentifier, RuntimeGraph runtimeGraph, RemoteDependencyWalker walker, RemoteWalkContext context, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.ProjectRestoreCommand/<ResolutionSucceeded>d__14")]
internal Task`1<bool> ResolutionSucceeded(IEnumerable`1<RestoreTargetGraph> graphs, IList`1<DownloadDependencyResolutionResult> downloadDependencyResults, RemoteWalkContext context, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.ProjectRestoreCommand/<InstallPackagesAsync>d__15")]
public Task`1<bool> InstallPackagesAsync(HashSet`1<LibraryIdentity> uniquePackages, IEnumerable`1<RestoreTargetGraph> graphs, IList`1<DownloadDependencyResolutionResult> downloadDependencyInformations, NuGetv3LocalRepository userPackageFolder, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.ProjectRestoreCommand/<InstallPackageAsync>d__16")]
private Task`1<bool> InstallPackageAsync(RemoteMatch installItem, NuGetv3LocalRepository userPackageFolder, PackageExtractionContext packageExtractionContext, CancellationToken token);
    private Task`1<RestoreTargetGraph[]> WalkRuntimeDependenciesAsync(LibraryRange projectRange, RestoreTargetGraph graph, IEnumerable`1<string> runtimeIds, RemoteDependencyWalker walker, RemoteWalkContext context, RuntimeGraph runtimes, CancellationToken token);
    internal static RuntimeGraph GetRuntimeGraph(RestoreTargetGraph graph, IReadOnlyList`1<NuGetv3LocalRepository> localRepositories, RuntimeGraph projectRuntimeGraph, RestoreCollectorLogger logger);
    [AsyncStateMachineAttribute("NuGet.Commands.ProjectRestoreCommand/<<DownloadDependenciesAsync>g__ResolveDownloadDependenciesAsync|11_0>d")]
[CompilerGeneratedAttribute]
internal static Task`1<DownloadDependencyResolutionResult> <DownloadDependenciesAsync>g__ResolveDownloadDependenciesAsync|11_0(RemoteWalkContext context, TargetFrameworkInformation targetFrameworkInformation, CancellationToken token);
}
internal class NuGet.Commands.ProjectRestoreRequest : object {
    [CompilerGeneratedAttribute]
private SourceCacheContext <CacheContext>k__BackingField;
    [CompilerGeneratedAttribute]
private RestoreCollectorLogger <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDegreeOfConcurrency>k__BackingField;
    [CompilerGeneratedAttribute]
private LockFile <ExistingLockFile>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSpec <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageExtractionContext <PackageExtractionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ParentId>k__BackingField;
    public SourceCacheContext CacheContext { get; }
    public RestoreCollectorLogger Log { get; }
    public string PackagesDirectory { get; }
    public int MaxDegreeOfConcurrency { get; }
    public LockFile ExistingLockFile { get; }
    public PackageSpec Project { get; }
    public PackageExtractionContext PackageExtractionContext { get; }
    public Guid ParentId { get; public set; }
    public ProjectRestoreRequest(RestoreRequest request, PackageSpec packageSpec, LockFile existingLockFile, RestoreCollectorLogger log);
    [CompilerGeneratedAttribute]
public SourceCacheContext get_CacheContext();
    [CompilerGeneratedAttribute]
public RestoreCollectorLogger get_Log();
    [CompilerGeneratedAttribute]
public string get_PackagesDirectory();
    [CompilerGeneratedAttribute]
public int get_MaxDegreeOfConcurrency();
    [CompilerGeneratedAttribute]
public LockFile get_ExistingLockFile();
    [CompilerGeneratedAttribute]
public PackageSpec get_Project();
    [CompilerGeneratedAttribute]
public PackageExtractionContext get_PackageExtractionContext();
    [CompilerGeneratedAttribute]
public Guid get_ParentId();
    [CompilerGeneratedAttribute]
public void set_ParentId(Guid value);
}
public static class NuGet.Commands.PushRunner : object {
    [AsyncStateMachineAttribute("NuGet.Commands.PushRunner/<Run>d__0")]
public static Task Run(ISettings settings, IPackageSourceProvider sourceProvider, IList`1<string> packagePaths, string source, string apiKey, string symbolSource, string symbolApiKey, int timeoutSeconds, bool disableBuffering, bool noSymbols, bool noServiceEndpoint, bool skipDuplicate, ILogger logger);
    [ObsoleteAttribute("Use Run method which takes multiple package paths.")]
public static Task Run(ISettings settings, IPackageSourceProvider sourceProvider, string packagePath, string source, string apiKey, string symbolSource, string symbolApiKey, int timeoutSeconds, bool disableBuffering, bool noSymbols, bool noServiceEndpoint, bool skipDuplicate, ILogger logger);
}
public class NuGet.Commands.RemoveClientCertArgs : object {
    [CompilerGeneratedAttribute]
private string <PackageSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configfile>k__BackingField;
    public string PackageSource { get; public set; }
    public string Configfile { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_PackageSource();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackageSource(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Configfile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Configfile(string value);
}
public static class NuGet.Commands.RemoveClientCertRunner : object {
    public static void Run(RemoveClientCertArgs args, Func`1<ILogger> getLogger);
}
public class NuGet.Commands.RemoveSourceArgs : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configfile>k__BackingField;
    public string Name { get; public set; }
    public string Configfile { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Configfile();
    [CompilerGeneratedAttribute]
public void set_Configfile(string value);
}
public static class NuGet.Commands.RemoveSourceRunner : object {
    public static void Run(RemoveSourceArgs args, Func`1<ILogger> getLogger);
}
public static class NuGet.Commands.RequestRuntimeUtility : object {
    internal static ISet`1<string> GetRestoreRuntimes(RestoreRequest request);
    [IteratorStateMachineAttribute("NuGet.Commands.RequestRuntimeUtility/<GetDefaultRestoreRuntimes>d__1")]
public static IEnumerable`1<string> GetDefaultRestoreRuntimes(string os, string runtimeOsName);
}
[IsReadOnlyAttribute]
public class NuGet.Commands.ResolvedDependencyKey : ValueType {
    [CompilerGeneratedAttribute]
private LibraryIdentity <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIdentity <Child>k__BackingField;
    public LibraryIdentity Parent { get; }
    public VersionRange Range { get; }
    public LibraryIdentity Child { get; }
    public ResolvedDependencyKey(LibraryIdentity parent, VersionRange range, LibraryIdentity child);
    [CompilerGeneratedAttribute]
public LibraryIdentity get_Parent();
    [CompilerGeneratedAttribute]
public VersionRange get_Range();
    [CompilerGeneratedAttribute]
public LibraryIdentity get_Child();
    public sealed virtual bool Equals(ResolvedDependencyKey other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ResolvedDependencyKey left, ResolvedDependencyKey right);
    public static bool op_Inequality(ResolvedDependencyKey left, ResolvedDependencyKey right);
}
public class NuGet.Commands.ResolverConflict : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ResolverRequest> <Requests>k__BackingField;
    public string Name { get; }
    public IList`1<ResolverRequest> Requests { get; }
    public ResolverConflict(string name, IEnumerable`1<ResolverRequest> requests);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IList`1<ResolverRequest> get_Requests();
}
public class NuGet.Commands.ResolverRequest : object {
    [CompilerGeneratedAttribute]
private LibraryIdentity <Requestor>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryRange <Request>k__BackingField;
    public LibraryIdentity Requestor { get; }
    public LibraryRange Request { get; }
    public ResolverRequest(LibraryIdentity requestor, LibraryRange request);
    [CompilerGeneratedAttribute]
public LibraryIdentity get_Requestor();
    [CompilerGeneratedAttribute]
public LibraryRange get_Request();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.Commands.Restore.Utility.AuditUtility : object {
    [NullableAttribute("2")]
private RestoreAuditProperties _restoreAuditProperties;
    private string _projectFullPath;
    private IEnumerable`1<RestoreTargetGraph> _targetGraphs;
    private IReadOnlyList`1<IVulnerabilityInformationProvider> _vulnerabilityInfoProviders;
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private PackageVulnerabilitySeverity <MinSeverity>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetAuditMode <AuditMode>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, bool> <SuppressedAdvisories>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<string> <DirectPackagesWithAdvisory>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<string> <TransitivePackagesWithAdvisory>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sev0DirectMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sev1DirectMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sev2DirectMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sev3DirectMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InvalidSevDirectMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sev0TransitiveMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sev1TransitiveMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sev2TransitiveMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Sev3TransitiveMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InvalidSevTransitiveMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <DownloadDurationSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <CheckPackagesDurationSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <GenerateOutputDurationSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SourcesWithVulnerabilityData>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DistinctAdvisoriesSuppressedCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalWarningsSuppressedCount>k__BackingField;
    internal PackageVulnerabilitySeverity MinSeverity { get; }
    internal NuGetAuditMode AuditMode { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Dictionary`2<string, bool> SuppressedAdvisories { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<string> DirectPackagesWithAdvisory { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<string> TransitivePackagesWithAdvisory { get; private set; }
    internal int Sev0DirectMatches { get; private set; }
    internal int Sev1DirectMatches { get; private set; }
    internal int Sev2DirectMatches { get; private set; }
    internal int Sev3DirectMatches { get; private set; }
    internal int InvalidSevDirectMatches { get; private set; }
    internal int Sev0TransitiveMatches { get; private set; }
    internal int Sev1TransitiveMatches { get; private set; }
    internal int Sev2TransitiveMatches { get; private set; }
    internal int Sev3TransitiveMatches { get; private set; }
    internal int InvalidSevTransitiveMatches { get; private set; }
    internal Nullable`1<double> DownloadDurationSeconds { get; private set; }
    internal Nullable`1<double> CheckPackagesDurationSeconds { get; private set; }
    internal Nullable`1<double> GenerateOutputDurationSeconds { get; private set; }
    internal int SourcesWithVulnerabilityData { get; private set; }
    internal int DistinctAdvisoriesSuppressedCount { get; private set; }
    internal int TotalWarningsSuppressedCount { get; private set; }
    public AuditUtility(RestoreAuditProperties restoreAuditProperties, string projectFullPath, IEnumerable`1<RestoreTargetGraph> graphs, IReadOnlyList`1<IVulnerabilityInformationProvider> vulnerabilityInformationProviders, ILogger logger);
    [CompilerGeneratedAttribute]
internal PackageVulnerabilitySeverity get_MinSeverity();
    [CompilerGeneratedAttribute]
internal NuGetAuditMode get_AuditMode();
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, bool> get_SuppressedAdvisories();
    [CompilerGeneratedAttribute]
internal List`1<string> get_DirectPackagesWithAdvisory();
    [CompilerGeneratedAttribute]
private void set_DirectPackagesWithAdvisory(List`1<string> value);
    [CompilerGeneratedAttribute]
internal List`1<string> get_TransitivePackagesWithAdvisory();
    [CompilerGeneratedAttribute]
private void set_TransitivePackagesWithAdvisory(List`1<string> value);
    [CompilerGeneratedAttribute]
internal int get_Sev0DirectMatches();
    [CompilerGeneratedAttribute]
private void set_Sev0DirectMatches(int value);
    [CompilerGeneratedAttribute]
internal int get_Sev1DirectMatches();
    [CompilerGeneratedAttribute]
private void set_Sev1DirectMatches(int value);
    [CompilerGeneratedAttribute]
internal int get_Sev2DirectMatches();
    [CompilerGeneratedAttribute]
private void set_Sev2DirectMatches(int value);
    [CompilerGeneratedAttribute]
internal int get_Sev3DirectMatches();
    [CompilerGeneratedAttribute]
private void set_Sev3DirectMatches(int value);
    [CompilerGeneratedAttribute]
internal int get_InvalidSevDirectMatches();
    [CompilerGeneratedAttribute]
private void set_InvalidSevDirectMatches(int value);
    [CompilerGeneratedAttribute]
internal int get_Sev0TransitiveMatches();
    [CompilerGeneratedAttribute]
private void set_Sev0TransitiveMatches(int value);
    [CompilerGeneratedAttribute]
internal int get_Sev1TransitiveMatches();
    [CompilerGeneratedAttribute]
private void set_Sev1TransitiveMatches(int value);
    [CompilerGeneratedAttribute]
internal int get_Sev2TransitiveMatches();
    [CompilerGeneratedAttribute]
private void set_Sev2TransitiveMatches(int value);
    [CompilerGeneratedAttribute]
internal int get_Sev3TransitiveMatches();
    [CompilerGeneratedAttribute]
private void set_Sev3TransitiveMatches(int value);
    [CompilerGeneratedAttribute]
internal int get_InvalidSevTransitiveMatches();
    [CompilerGeneratedAttribute]
private void set_InvalidSevTransitiveMatches(int value);
    [CompilerGeneratedAttribute]
internal Nullable`1<double> get_DownloadDurationSeconds();
    [CompilerGeneratedAttribute]
private void set_DownloadDurationSeconds(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<double> get_CheckPackagesDurationSeconds();
    [CompilerGeneratedAttribute]
private void set_CheckPackagesDurationSeconds(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<double> get_GenerateOutputDurationSeconds();
    [CompilerGeneratedAttribute]
private void set_GenerateOutputDurationSeconds(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
internal int get_SourcesWithVulnerabilityData();
    [CompilerGeneratedAttribute]
private void set_SourcesWithVulnerabilityData(int value);
    [CompilerGeneratedAttribute]
internal int get_DistinctAdvisoriesSuppressedCount();
    [CompilerGeneratedAttribute]
private void set_DistinctAdvisoriesSuppressedCount(int value);
    [CompilerGeneratedAttribute]
internal int get_TotalWarningsSuppressedCount();
    [CompilerGeneratedAttribute]
private void set_TotalWarningsSuppressedCount(int value);
    [AsyncStateMachineAttribute("NuGet.Commands.Restore.Utility.AuditUtility/<CheckPackageVulnerabilitiesAsync>d__87")]
public Task CheckPackageVulnerabilitiesAsync(CancellationToken cancellationToken);
    private void ReplayErrors(AggregateException exceptions);
    private void CheckPackageVulnerabilities(IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> knownVulnerabilities);
    private static List`1<PackageVulnerabilityInfo> GetKnownVulnerabilities(string name, NuGetVersion version, IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> knownVulnerabilities);
    private static ValueTuple`2<string, NuGetLogCode> GetSeverityLabelAndCode(PackageVulnerabilitySeverity severity);
    private Dictionary`2<PackageIdentity, PackageAuditInfo> FindPackagesWithKnownVulnerabilities(IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> knownVulnerabilities);
    [AsyncStateMachineAttribute("NuGet.Commands.Restore.Utility.AuditUtility/<GetAllVulnerabilityDataAsync>d__93")]
private Task`1<List`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>>> GetAllVulnerabilityDataAsync(CancellationToken cancellationToken);
    private PackageVulnerabilitySeverity ParseAuditLevel();
    private NuGetAuditMode ParseAuditMode();
    public static bool ParseEnableValue(RestoreAuditProperties value, string projectFullPath, ILogger logger);
    internal static string GetString(NuGetAuditMode auditMode);
    [CompilerGeneratedAttribute]
private bool <CheckPackageVulnerabilitiesAsync>g__HasPackages|87_0();
    [CompilerGeneratedAttribute]
internal static bool <CheckPackageVulnerabilitiesAsync>g__AnyVulnerabilityDataFound|87_1(IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> knownVulnerabilities);
}
public class NuGet.Commands.RestoreArgs : object {
    [CompilerGeneratedAttribute]
private string <ConfigFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IMachineWideSettings <MachineWideSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GlobalPackagesFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsLowercaseGlobalPackagesFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableParallel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowNoOp>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Runtimes>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <FallbackRuntimes>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Inputs>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceCacheContext <CacheContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private CachingSourceProvider <CachingSourceProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IRestoreRequestProvider> <RequestProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IPreLoadedRestoreRequestProvider> <PreLoadedRequestProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSaveMode <PackageSaveMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LockFileVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ValidateRuntimeAssets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HideWarningsAndErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRestoreOriginalAction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RestoreForceEvaluate>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IAssetsLogMessage> <AdditionalMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private IRestoreProgressReporter <ProgressReporter>k__BackingField;
    private ConcurrentDictionary`2<string, ISettings> _settingsCache;
    private ConcurrentDictionary`2<string, List`1<SourceRepository>> _sourcesCache;
    public string ConfigFile { get; public set; }
    public IMachineWideSettings MachineWideSettings { get; public set; }
    public string GlobalPackagesFolder { get; public set; }
    public Nullable`1<bool> IsLowercaseGlobalPackagesFolder { get; public set; }
    public bool DisableParallel { get; public set; }
    public bool AllowNoOp { get; public set; }
    public HashSet`1<string> Runtimes { get; public set; }
    public HashSet`1<string> FallbackRuntimes { get; public set; }
    public List`1<string> Inputs { get; public set; }
    public SourceCacheContext CacheContext { get; public set; }
    public ILogger Log { get; public set; }
    public List`1<string> Sources { get; public set; }
    public CachingSourceProvider CachingSourceProvider { get; public set; }
    public List`1<IRestoreRequestProvider> RequestProviders { get; public set; }
    public List`1<IPreLoadedRestoreRequestProvider> PreLoadedRequestProviders { get; public set; }
    public PackageSaveMode PackageSaveMode { get; public set; }
    public Nullable`1<int> LockFileVersion { get; public set; }
    public Nullable`1<bool> ValidateRuntimeAssets { get; public set; }
    public bool HideWarningsAndErrors { get; public set; }
    public Guid ParentId { get; public set; }
    public bool IsRestoreOriginalAction { get; public set; }
    public bool RestoreForceEvaluate { get; public set; }
    public IReadOnlyList`1<IAssetsLogMessage> AdditionalMessages { get; public set; }
    public IRestoreProgressReporter ProgressReporter { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ConfigFile();
    [CompilerGeneratedAttribute]
public void set_ConfigFile(string value);
    [CompilerGeneratedAttribute]
public IMachineWideSettings get_MachineWideSettings();
    [CompilerGeneratedAttribute]
public void set_MachineWideSettings(IMachineWideSettings value);
    [CompilerGeneratedAttribute]
public string get_GlobalPackagesFolder();
    [CompilerGeneratedAttribute]
public void set_GlobalPackagesFolder(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsLowercaseGlobalPackagesFolder();
    [CompilerGeneratedAttribute]
public void set_IsLowercaseGlobalPackagesFolder(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_DisableParallel();
    [CompilerGeneratedAttribute]
public void set_DisableParallel(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowNoOp();
    [CompilerGeneratedAttribute]
public void set_AllowNoOp(bool value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_Runtimes();
    [CompilerGeneratedAttribute]
public void set_Runtimes(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_FallbackRuntimes();
    [CompilerGeneratedAttribute]
public void set_FallbackRuntimes(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Inputs();
    [CompilerGeneratedAttribute]
public void set_Inputs(List`1<string> value);
    [CompilerGeneratedAttribute]
public SourceCacheContext get_CacheContext();
    [CompilerGeneratedAttribute]
public void set_CacheContext(SourceCacheContext value);
    [CompilerGeneratedAttribute]
public ILogger get_Log();
    [CompilerGeneratedAttribute]
public void set_Log(ILogger value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Sources();
    [CompilerGeneratedAttribute]
public void set_Sources(List`1<string> value);
    [CompilerGeneratedAttribute]
public CachingSourceProvider get_CachingSourceProvider();
    [CompilerGeneratedAttribute]
public void set_CachingSourceProvider(CachingSourceProvider value);
    [CompilerGeneratedAttribute]
public List`1<IRestoreRequestProvider> get_RequestProviders();
    [CompilerGeneratedAttribute]
public void set_RequestProviders(List`1<IRestoreRequestProvider> value);
    [CompilerGeneratedAttribute]
public List`1<IPreLoadedRestoreRequestProvider> get_PreLoadedRequestProviders();
    [CompilerGeneratedAttribute]
public void set_PreLoadedRequestProviders(List`1<IPreLoadedRestoreRequestProvider> value);
    [CompilerGeneratedAttribute]
public PackageSaveMode get_PackageSaveMode();
    [CompilerGeneratedAttribute]
public void set_PackageSaveMode(PackageSaveMode value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_LockFileVersion();
    [CompilerGeneratedAttribute]
public void set_LockFileVersion(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ValidateRuntimeAssets();
    [CompilerGeneratedAttribute]
public void set_ValidateRuntimeAssets(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_HideWarningsAndErrors();
    [CompilerGeneratedAttribute]
public void set_HideWarningsAndErrors(bool value);
    [CompilerGeneratedAttribute]
public Guid get_ParentId();
    [CompilerGeneratedAttribute]
public void set_ParentId(Guid value);
    [CompilerGeneratedAttribute]
public bool get_IsRestoreOriginalAction();
    [CompilerGeneratedAttribute]
public void set_IsRestoreOriginalAction(bool value);
    [CompilerGeneratedAttribute]
public bool get_RestoreForceEvaluate();
    [CompilerGeneratedAttribute]
public void set_RestoreForceEvaluate(bool value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IAssetsLogMessage> get_AdditionalMessages();
    [CompilerGeneratedAttribute]
public void set_AdditionalMessages(IReadOnlyList`1<IAssetsLogMessage> value);
    [CompilerGeneratedAttribute]
public IRestoreProgressReporter get_ProgressReporter();
    [CompilerGeneratedAttribute]
public void set_ProgressReporter(IRestoreProgressReporter value);
    public ISettings GetSettings(string projectDirectory);
    public string GetEffectiveGlobalPackagesFolder(string rootDirectory, ISettings settings);
    public IReadOnlyList`1<string> GetEffectiveFallbackPackageFolders(ISettings settings);
    public List`1<SourceRepository> GetEffectiveSources(ISettings settings, IList`1<PackageSource> dgSpecSources);
    private List`1<SourceRepository> GetEffectiveSourcesCore(ISettings settings, IList`1<PackageSource> dgSpecSources);
    public void ApplyStandardProperties(RestoreRequest request);
    [CompilerGeneratedAttribute]
private ISettings <GetSettings>b__98_0(string dir);
    [CompilerGeneratedAttribute]
private SourceRepository <GetEffectiveSourcesCore>b__102_0(KeyValuePair`2<string, PackageSource> entry);
}
public class NuGet.Commands.RestoreCollectorLogger : LoggerBase {
    private ILogger _innerLogger;
    private ConcurrentQueue`1<IRestoreLogMessage> _errors;
    private bool _hideWarningsAndErrors;
    private IEnumerable`1<RestoreTargetGraph> _restoreTargetGraphs;
    private PackageSpec _projectSpec;
    private WarningPropertiesCollection _transitiveWarningPropertiesCollection;
    [CompilerGeneratedAttribute]
private WarningPropertiesCollection <ProjectWarningPropertiesCollection>k__BackingField;
    public string ProjectPath { get; }
    public IEnumerable`1<IRestoreLogMessage> Errors { get; }
    public WarningPropertiesCollection ProjectWarningPropertiesCollection { get; public set; }
    public WarningPropertiesCollection TransitiveWarningPropertiesCollection { get; public set; }
    public RestoreCollectorLogger(ILogger innerLogger, LogLevel verbosity, bool hideWarningsAndErrors);
    public RestoreCollectorLogger(ILogger innerLogger, bool hideWarningsAndErrors);
    public RestoreCollectorLogger(ILogger innerLogger, LogLevel verbosity);
    public RestoreCollectorLogger(ILogger innerLogger);
    public string get_ProjectPath();
    public sealed virtual IEnumerable`1<IRestoreLogMessage> get_Errors();
    [CompilerGeneratedAttribute]
public WarningPropertiesCollection get_ProjectWarningPropertiesCollection();
    [CompilerGeneratedAttribute]
public void set_ProjectWarningPropertiesCollection(WarningPropertiesCollection value);
    public WarningPropertiesCollection get_TransitiveWarningPropertiesCollection();
    public void set_TransitiveWarningPropertiesCollection(WarningPropertiesCollection value);
    public void ApplyRestoreInputs(PackageSpec projectSpec);
    public void ApplyRestoreOutput(IEnumerable`1<RestoreTargetGraph> restoreTargetGraphs);
    public void Log(IRestoreLogMessage message);
    public Task LogAsync(IRestoreLogMessage message);
    public virtual void Log(ILogMessage message);
    public virtual Task LogAsync(ILogMessage message);
    protected bool DisplayMessage(IRestoreLogMessage message);
    private bool IsWarningSuppressed(IRestoreLogMessage message);
    private void UpgradeWarningToErrorIfNeeded(IRestoreLogMessage message);
    private static IRestoreLogMessage ToRestoreLogMessage(ILogMessage message);
}
public class NuGet.Commands.RestoreCommand : object {
    private RestoreCollectorLogger _logger;
    private RestoreRequest _request;
    private LockFileBuilderCache _lockFileBuilderCache;
    private bool _success;
    private Guid _operationId;
    private Dictionary`2<RestoreTargetGraph, Dictionary`2<string, LibraryIncludeFlags>> _includeFlagGraphs;
    [CompilerGeneratedAttribute]
private Guid <ParentId>k__BackingField;
    private static string ProjectRestoreInformation;
    private static string ErrorCodes;
    private static string WarningCodes;
    private static string RestoreSuccess;
    private static string ProjectFilePath;
    private static string IsCentralVersionManagementEnabled;
    private static string TotalUniquePackagesCount;
    private static string NewPackagesInstalledCount;
    private static string SourcesCount;
    private static string HttpSourcesCount;
    private static string LocalSourcesCount;
    private static string FallbackFoldersCount;
    private static string NoOpDuration;
    private static string NoOpResult;
    private static string NoOpCacheFileEvaluateDuration;
    private static string NoOpCacheFileEvaluationResult;
    private static string NoOpRestoreOutputEvaluationDuration;
    private static string NoOpRestoreOutputEvaluationResult;
    private static string NoOpReplayLogsDuration;
    private static string NoOpCacheFileAgeDays;
    private static string EvaluateLockFileDuration;
    private static string ValidatePackagesShaDuration;
    private static string IsLockFileEnabled;
    private static string ReadLockFileDuration;
    private static string ValidateLockFileDuration;
    private static string IsLockFileValidForRestore;
    private static string LockFileEvaluationResult;
    private static string GenerateRestoreGraphDuration;
    private static string CreateRestoreTargetGraphDuration;
    private static string CreateAdditionalRestoreTargetGraphDuration;
    private static string GenerateAssetsFileDuration;
    private static string ValidateRestoreGraphsDuration;
    private static string CreateRestoreResultDuration;
    private static string IsCentralPackageTransitivePinningEnabled;
    private static string UseLegacyDependencyResolver;
    private static string UsedLegacyDependencyResolver;
    private static string PackageSourceMappingIsMappingEnabled;
    private static string AuditEnabled;
    private static string AuditLevel;
    private static string AuditMode;
    private static string AuditSuppressedAdvisoriesDefinedCount;
    private static string AuditSuppressedAdvisoriesTotalWarningsSuppressedCount;
    private static string AuditSuppressedAdvisoriesDistinctAdvisoriesSuppressedCount;
    private static string AuditDataSources;
    private static string AuditDirectVulnerabilitiesPackages;
    private static string AuditDirectVulnerabilitiesCount;
    private static string AuditDirectVulnerabilitySev0;
    private static string AuditDirectVulnerabilitySev1;
    private static string AuditDirectVulnerabilitySev2;
    private static string AuditDirectVulnerabilitySev3;
    private static string AuditDirectVulnerabilitySevInvalid;
    private static string AuditTransitiveVulnerabilitiesPackages;
    private static string AuditTransitiveVulnerabilitiesCount;
    private static string AuditTransitiveVulnerabilitySev0;
    private static string AuditTransitiveVulnerabilitySev1;
    private static string AuditTransitiveVulnerabilitySev2;
    private static string AuditTransitiveVulnerabilitySev3;
    private static string AuditTransitiveVulnerabilitySevInvalid;
    private static string AuditDurationDownload;
    private static string AuditDurationCheck;
    private static string AuditDurationOutput;
    private static string AuditDurationTotal;
    private bool _enableNewDependencyResolver;
    public Guid ParentId { get; }
    public RestoreCommand(RestoreRequest request);
    [CompilerGeneratedAttribute]
public Guid get_ParentId();
    public Task`1<RestoreResult> ExecuteAsync();
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<ExecuteAsync>d__74")]
public Task`1<RestoreResult> ExecuteAsync(CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<PerformAuditAsync>d__75")]
private Task PerformAuditAsync(IEnumerable`1<RestoreTargetGraph> graphs, TelemetryActivity telemetry, CancellationToken token);
    private bool HasValidPlatformVersions();
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<AreCentralVersionRequirementsSatisfiedAsync>d__77")]
private Task`1<bool> AreCentralVersionRequirementsSatisfiedAsync(RestoreRequest restoreRequest, int httpSourcesCount);
    private string ConcatAsString(IEnumerable`1<T> enumerable);
    private bool VerifyCacheFileMatchesProject(CacheFile cacheFile);
    private bool ValidatePackagesSha512(PackagesLockFile lockFile, LockFile assetsFile);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<EvaluatePackagesLockFileAsync>d__81")]
private Task`1<ValueTuple`3<bool, bool, PackagesLockFile>> EvaluatePackagesLockFileAsync(string packagesLockFilePath, RemoteWalkContext contextForProject, TelemetryActivity lockFileTelemetry);
    private ValueTuple`3<CacheFile, bool, Nullable`1<TimeSpan>> EvaluateCacheFile();
    private string GetAssetsFilePath(LockFile lockFile);
    private void DowngradeLockFileIfNeeded(LockFile lockFile);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<FixCaseForLegacyReaders>d__85")]
private Task FixCaseForLegacyReaders(IEnumerable`1<RestoreTargetGraph> graphs, LockFile lockFile, CancellationToken token);
    private LockFile BuildAssetsFile(LockFile existingLockFile, PackageSpec project, IEnumerable`1<RestoreTargetGraph> graphs, IReadOnlyList`1<NuGetv3LocalRepository> localRepositories, RemoteWalkContext contextForProject);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<ValidateRestoreGraphsAsync>d__87")]
private Task`1<bool> ValidateRestoreGraphsAsync(IEnumerable`1<RestoreTargetGraph> graphs, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<ValidateCyclesAsync>d__88")]
private static Task`1<bool> ValidateCyclesAsync(IEnumerable`1<RestoreTargetGraph> graphs, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<ValidateConflictsAsync>d__89")]
private Task`1<bool> ValidateConflictsAsync(IEnumerable`1<RestoreTargetGraph> graphs, ILogger logger);
    internal static Task LogDowngradeWarningsOrErrorsAsync(IEnumerable`1<RestoreTargetGraph> graphs, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<VerifyCompatibilityAsync>d__91")]
private static Task`1<IList`1<CompatibilityCheckResult>> VerifyCompatibilityAsync(PackageSpec project, Dictionary`2<RestoreTargetGraph, Dictionary`2<string, LibraryIncludeFlags>> includeFlagGraphs, IReadOnlyList`1<NuGetv3LocalRepository> localRepositories, LockFile lockFile, IEnumerable`1<RestoreTargetGraph> graphs, bool validateRuntimeAssets, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<ExecuteLegacyRestoreAsync>d__92")]
private Task`1<IEnumerable`1<RestoreTargetGraph>> ExecuteLegacyRestoreAsync(NuGetv3LocalRepository userPackageFolder, IReadOnlyList`1<NuGetv3LocalRepository> fallbackPackageFolders, RemoteWalkContext context, CancellationToken token, TelemetryActivity telemetryActivity);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreCommand/<ExecuteRestoreAsync>d__93")]
private Task`1<IEnumerable`1<RestoreTargetGraph>> ExecuteRestoreAsync(NuGetv3LocalRepository userPackageFolder, IReadOnlyList`1<NuGetv3LocalRepository> fallbackPackageFolders, RemoteWalkContext context, CancellationToken token, TelemetryActivity telemetryActivity);
    internal static List`1<ExternalProjectReference> GetProjectReferences(RestoreRequest request);
    internal static IEnumerable`1<FrameworkRuntimePair> CreateFrameworkRuntimePairs(PackageSpec packageSpec, ISet`1<string> runtimeIds);
    private static RemoteWalkContext CreateRemoteWalkContext(RestoreRequest request, RestoreCollectorLogger logger);
    private static void DowngradeLockFileToV1(LockFile lockFile);
    private static ExternalProjectReference ToExternalProjectReference(PackageSpec project);
    [CompilerGeneratedAttribute]
private LockFile <ExecuteAsync>b__74_2();
    [CompilerGeneratedAttribute]
internal static void <PerformAuditAsync>g__AddPackagesList|75_0(TelemetryActivity telemetry, string eventName, List`1<string> packages);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private CacheFile <EvaluateCacheFile>b__82_0(FileStream stream, string path);
    [CompilerGeneratedAttribute]
internal static bool <EvaluateCacheFile>g__CacheFileExists|82_1(string path, Nullable`1& cacheFileAge);
}
public class NuGet.Commands.RestoreCommandException : Exception {
    private IRestoreLogMessage _logMessage;
    public RestoreCommandException(IRestoreLogMessage logMessage);
    public sealed virtual ILogMessage AsLogMessage();
}
public class NuGet.Commands.RestoreCommandProviders : object {
    [CompilerGeneratedAttribute]
private NuGetv3LocalRepository <GlobalPackages>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<NuGetv3LocalRepository> <FallbackPackageFolders>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IRemoteDependencyProvider> <LocalProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IRemoteDependencyProvider> <RemoteProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalPackageFileCache <PackageFileCache>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IVulnerabilityInformationProvider> <VulnerabilityInfoProviders>k__BackingField;
    public NuGetv3LocalRepository GlobalPackages { get; }
    public IReadOnlyList`1<NuGetv3LocalRepository> FallbackPackageFolders { get; }
    public IReadOnlyList`1<IRemoteDependencyProvider> LocalProviders { get; }
    public IReadOnlyList`1<IRemoteDependencyProvider> RemoteProviders { get; }
    public LocalPackageFileCache PackageFileCache { get; }
    internal IReadOnlyList`1<IVulnerabilityInformationProvider> VulnerabilityInfoProviders { get; }
    [ObsoleteAttribute("Create via RestoreCommandProvidersCache")]
public RestoreCommandProviders(NuGetv3LocalRepository globalPackages, IReadOnlyList`1<NuGetv3LocalRepository> fallbackPackageFolders, IReadOnlyList`1<IRemoteDependencyProvider> localProviders, IReadOnlyList`1<IRemoteDependencyProvider> remoteProviders, LocalPackageFileCache packageFileCache);
    internal RestoreCommandProviders(NuGetv3LocalRepository globalPackages, IReadOnlyList`1<NuGetv3LocalRepository> fallbackPackageFolders, IReadOnlyList`1<IRemoteDependencyProvider> localProviders, IReadOnlyList`1<IRemoteDependencyProvider> remoteProviders, LocalPackageFileCache packageFileCache, IReadOnlyList`1<IVulnerabilityInformationProvider> vulnerabilityInformationProviders);
    private static IReadOnlyList`1<IVulnerabilityInformationProvider> CreateVulnerabilityInfoProviders(IReadOnlyList`1<IRemoteDependencyProvider> remoteProviders);
    [CompilerGeneratedAttribute]
public NuGetv3LocalRepository get_GlobalPackages();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<NuGetv3LocalRepository> get_FallbackPackageFolders();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IRemoteDependencyProvider> get_LocalProviders();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IRemoteDependencyProvider> get_RemoteProviders();
    [CompilerGeneratedAttribute]
public LocalPackageFileCache get_PackageFileCache();
    [CompilerGeneratedAttribute]
internal IReadOnlyList`1<IVulnerabilityInformationProvider> get_VulnerabilityInfoProviders();
    [ObsoleteAttribute("Create via RestoreCommandProvidersCache")]
public static RestoreCommandProviders Create(string globalFolderPath, IEnumerable`1<string> fallbackPackageFolderPaths, IEnumerable`1<SourceRepository> sources, SourceCacheContext cacheContext, LocalPackageFileCache packageFileCache, ILogger log);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.Commands.RestoreCommandProvidersCache : object {
    private ConcurrentDictionary`2<SourceRepository, IRemoteDependencyProvider> _remoteProviders;
    private ConcurrentDictionary`2<string, IRemoteDependencyProvider> _localProvider;
    private ConcurrentDictionary`2<string, NuGetv3LocalRepository> _globalCache;
    private ConcurrentDictionary`2<SourceRepository, IVulnerabilityInformationProvider> _vulnerabilityInformationProviders;
    private LocalPackageFileCache _fileCache;
    public RestoreCommandProviders GetOrCreate(string globalPackagesPath, IReadOnlyList`1<string> fallbackPackagesPaths, IReadOnlyList`1<SourceRepository> sources, SourceCacheContext cacheContext, ILogger log);
    public RestoreCommandProviders GetOrCreate(string globalPackagesPath, IReadOnlyList`1<string> fallbackPackagesPaths, IReadOnlyList`1<SourceRepository> sources, SourceCacheContext cacheContext, ILogger log, bool updateLastAccess);
    public RestoreCommandProviders GetOrCreate(string globalPackagesPath, IReadOnlyList`1<string> fallbackPackagesPaths, IReadOnlyList`1<SourceRepository> packageSources, IReadOnlyList`1<SourceRepository> auditSources, SourceCacheContext cacheContext, ILogger log, bool updateLastAccess);
    private NuGetv3LocalRepository CreateGlobalPackagedRepository(string globalPackagesPath, bool updateLastAccess);
    private List`1<NuGetv3LocalRepository> GetFallbackFolderRepositories(IReadOnlyList`1<string> fallbackPackagesPaths);
    private List`1<IRemoteDependencyProvider> CreateLocalProviders(string globalPackagesPath, IReadOnlyList`1<string> fallbackPackagesPaths, SourceCacheContext cacheContext, ILogger log);
    private List`1<IRemoteDependencyProvider> CreateRemoveProviders(IReadOnlyList`1<SourceRepository> sources, SourceCacheContext cacheContext, ILogger log);
    private IReadOnlyList`1<IVulnerabilityInformationProvider> CreateVulnerabilityProviders(IReadOnlyList`1<SourceRepository> packageSources, IReadOnlyList`1<SourceRepository> auditSources, ILogger log);
    [CompilerGeneratedAttribute]
private NuGetv3LocalRepository <GetFallbackFolderRepositories>b__9_0(string path);
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IVulnerabilityInformationProvider> <CreateVulnerabilityProviders>g__CreateVulnerabilityProviders|12_0(IReadOnlyList`1<SourceRepository> sources, ILogger log, bool isAuditSource);
}
public class NuGet.Commands.RestoreRequest : object {
    public static int DefaultDegreeOfConcurrency;
    private string _lockFilePath;
    private Lazy`1<LockFile> _lockFileLazy;
    [CompilerGeneratedAttribute]
private DependencyGraphSpec <DependencyGraphSpec>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowNoOp>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceCacheContext <CacheContext>k__BackingField;
    [CompilerGeneratedAttribute]
private LockFileBuilderCache <LockFileBuilderCache>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSpec <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLowercasePackagesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ExternalProjectReference> <ExternalProjects>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDegreeOfConcurrency>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<FrameworkRuntimePair> <CompatibilityProfiles>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LockFileVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <RequestedRuntimes>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <FallbackRuntimes>k__BackingField;
    [CompilerGeneratedAttribute]
private RestoreCommandProviders <DependencyProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectStyle <ProjectStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RestoreOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildProjectExtensionsPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateRuntimeAssets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HideWarningsAndErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSaveMode <PackageSaveMode>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDocFileSaveMode <XmlDocFileSaveMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientPolicyContext <ClientPolicyContext>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSourceMapping <PackageSourceMapping>k__BackingField;
    [CompilerGeneratedAttribute]
private IPackageSignatureVerifier <SignedPackageVerifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRestoreOriginalAction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RestoreForceEvaluate>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IAssetsLogMessage> <AdditionalMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UpdatePackageLastAccessTime>k__BackingField;
    public DependencyGraphSpec DependencyGraphSpec { get; public set; }
    public bool AllowNoOp { get; public set; }
    public SourceCacheContext CacheContext { get; public set; }
    internal LockFileBuilderCache LockFileBuilderCache { get; }
    public ILogger Log { get; public set; }
    public PackageSpec Project { get; }
    public string PackagesDirectory { get; }
    public bool IsLowercasePackagesDirectory { get; public set; }
    public IList`1<ExternalProjectReference> ExternalProjects { get; public set; }
    public string LockFilePath { get; public set; }
    public LockFile ExistingLockFile { get; public set; }
    public int MaxDegreeOfConcurrency { get; public set; }
    public ISet`1<FrameworkRuntimePair> CompatibilityProfiles { get; }
    public int LockFileVersion { get; public set; }
    public ISet`1<string> RequestedRuntimes { get; }
    public ISet`1<string> FallbackRuntimes { get; }
    public RestoreCommandProviders DependencyProviders { get; public set; }
    public ProjectStyle ProjectStyle { get; public set; }
    public string RestoreOutputPath { get; public set; }
    public string MSBuildProjectExtensionsPath { get; public set; }
    public bool ValidateRuntimeAssets { get; public set; }
    public bool HideWarningsAndErrors { get; public set; }
    public PackageSaveMode PackageSaveMode { get; public set; }
    public XmlDocFileSaveMode XmlDocFileSaveMode { get; public set; }
    public ClientPolicyContext ClientPolicyContext { get; }
    public PackageSourceMapping PackageSourceMapping { get; }
    internal IPackageSignatureVerifier SignedPackageVerifier { get; internal set; }
    public Guid ParentId { get; public set; }
    public bool IsRestoreOriginalAction { get; public set; }
    public bool RestoreForceEvaluate { get; public set; }
    public IReadOnlyList`1<IAssetsLogMessage> AdditionalMessages { get; public set; }
    public bool UpdatePackageLastAccessTime { get; public set; }
    [ObsoleteAttribute("Use constructor with LockFileBuilderCache parameter")]
public RestoreRequest(PackageSpec project, RestoreCommandProviders dependencyProviders, SourceCacheContext cacheContext, ClientPolicyContext clientPolicyContext, ILogger log);
    public RestoreRequest(PackageSpec project, RestoreCommandProviders dependencyProviders, SourceCacheContext cacheContext, ClientPolicyContext clientPolicyContext, PackageSourceMapping packageSourceMapping, ILogger log, LockFileBuilderCache lockFileBuilderCache);
    private static RestoreRequest();
    [CompilerGeneratedAttribute]
public DependencyGraphSpec get_DependencyGraphSpec();
    [CompilerGeneratedAttribute]
public void set_DependencyGraphSpec(DependencyGraphSpec value);
    [CompilerGeneratedAttribute]
public bool get_AllowNoOp();
    [CompilerGeneratedAttribute]
public void set_AllowNoOp(bool value);
    [CompilerGeneratedAttribute]
public SourceCacheContext get_CacheContext();
    [CompilerGeneratedAttribute]
public void set_CacheContext(SourceCacheContext value);
    [CompilerGeneratedAttribute]
internal LockFileBuilderCache get_LockFileBuilderCache();
    [CompilerGeneratedAttribute]
public ILogger get_Log();
    [CompilerGeneratedAttribute]
public void set_Log(ILogger value);
    [CompilerGeneratedAttribute]
public PackageSpec get_Project();
    [CompilerGeneratedAttribute]
public string get_PackagesDirectory();
    [CompilerGeneratedAttribute]
public bool get_IsLowercasePackagesDirectory();
    [CompilerGeneratedAttribute]
public void set_IsLowercasePackagesDirectory(bool value);
    [CompilerGeneratedAttribute]
public IList`1<ExternalProjectReference> get_ExternalProjects();
    [CompilerGeneratedAttribute]
public void set_ExternalProjects(IList`1<ExternalProjectReference> value);
    public string get_LockFilePath();
    public void set_LockFilePath(string value);
    public LockFile get_ExistingLockFile();
    public void set_ExistingLockFile(LockFile value);
    [CompilerGeneratedAttribute]
public int get_MaxDegreeOfConcurrency();
    [CompilerGeneratedAttribute]
public void set_MaxDegreeOfConcurrency(int value);
    [CompilerGeneratedAttribute]
public ISet`1<FrameworkRuntimePair> get_CompatibilityProfiles();
    [CompilerGeneratedAttribute]
public int get_LockFileVersion();
    [CompilerGeneratedAttribute]
public void set_LockFileVersion(int value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_RequestedRuntimes();
    [CompilerGeneratedAttribute]
public ISet`1<string> get_FallbackRuntimes();
    [CompilerGeneratedAttribute]
public RestoreCommandProviders get_DependencyProviders();
    [CompilerGeneratedAttribute]
public void set_DependencyProviders(RestoreCommandProviders value);
    [CompilerGeneratedAttribute]
public ProjectStyle get_ProjectStyle();
    [CompilerGeneratedAttribute]
public void set_ProjectStyle(ProjectStyle value);
    [CompilerGeneratedAttribute]
public string get_RestoreOutputPath();
    [CompilerGeneratedAttribute]
public void set_RestoreOutputPath(string value);
    [CompilerGeneratedAttribute]
public string get_MSBuildProjectExtensionsPath();
    [CompilerGeneratedAttribute]
public void set_MSBuildProjectExtensionsPath(string value);
    [CompilerGeneratedAttribute]
public bool get_ValidateRuntimeAssets();
    [CompilerGeneratedAttribute]
public void set_ValidateRuntimeAssets(bool value);
    [CompilerGeneratedAttribute]
public bool get_HideWarningsAndErrors();
    [CompilerGeneratedAttribute]
public void set_HideWarningsAndErrors(bool value);
    [CompilerGeneratedAttribute]
public PackageSaveMode get_PackageSaveMode();
    [CompilerGeneratedAttribute]
public void set_PackageSaveMode(PackageSaveMode value);
    [CompilerGeneratedAttribute]
public XmlDocFileSaveMode get_XmlDocFileSaveMode();
    [CompilerGeneratedAttribute]
public void set_XmlDocFileSaveMode(XmlDocFileSaveMode value);
    [CompilerGeneratedAttribute]
public ClientPolicyContext get_ClientPolicyContext();
    [CompilerGeneratedAttribute]
public PackageSourceMapping get_PackageSourceMapping();
    [CompilerGeneratedAttribute]
internal IPackageSignatureVerifier get_SignedPackageVerifier();
    [CompilerGeneratedAttribute]
internal void set_SignedPackageVerifier(IPackageSignatureVerifier value);
    [CompilerGeneratedAttribute]
public Guid get_ParentId();
    [CompilerGeneratedAttribute]
public void set_ParentId(Guid value);
    [CompilerGeneratedAttribute]
public bool get_IsRestoreOriginalAction();
    [CompilerGeneratedAttribute]
public void set_IsRestoreOriginalAction(bool value);
    [CompilerGeneratedAttribute]
public bool get_RestoreForceEvaluate();
    [CompilerGeneratedAttribute]
public void set_RestoreForceEvaluate(bool value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IAssetsLogMessage> get_AdditionalMessages();
    [CompilerGeneratedAttribute]
public void set_AdditionalMessages(IReadOnlyList`1<IAssetsLogMessage> value);
    [CompilerGeneratedAttribute]
public bool get_UpdatePackageLastAccessTime();
    [CompilerGeneratedAttribute]
public void set_UpdatePackageLastAccessTime(bool value);
    [CompilerGeneratedAttribute]
private LockFile <set_LockFilePath>b__40_0();
}
public class NuGet.Commands.RestoreResult : object {
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LockFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<RestoreTargetGraph> <RestoreGraphs>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<CompatibilityCheckResult> <CompatibilityCheckResults>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<MSBuildOutputFile> <MSBuildOutputFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectStyle <ProjectStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private LockFile <LockFile>k__BackingField;
    [CompilerGeneratedAttribute]
private LockFile <PreviousLockFile>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ElapsedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IAssetsLogMessage> <LogMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private CacheFile <CacheFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheFilePath>k__BackingField;
    private string _newPackagesLockFilePath;
    [CompilerGeneratedAttribute]
private PackagesLockFile <_newPackagesLockFile>k__BackingField;
    private string _dependencyGraphSpecFilePath;
    private DependencyGraphSpec _dependencyGraphSpec;
    private Lazy`1<bool> _isAssetsFileDirty;
    private Lazy`1<List`1<MSBuildOutputFile>> _dirtyMSBuildFiles;
    public bool Success { get; }
    public string LockFilePath { get; public set; }
    public IEnumerable`1<RestoreTargetGraph> RestoreGraphs { get; }
    public IEnumerable`1<CompatibilityCheckResult> CompatibilityCheckResults { get; }
    public IEnumerable`1<MSBuildOutputFile> MSBuildOutputFiles { get; }
    public ProjectStyle ProjectStyle { get; }
    public LockFile LockFile { get; }
    public LockFile PreviousLockFile { get; }
    public TimeSpan ElapsedTime { get; }
    public IList`1<IAssetsLogMessage> LogMessages { get; internal set; }
    private CacheFile CacheFile { get; }
    protected string CacheFilePath { get; }
    internal PackagesLockFile _newPackagesLockFile { get; }
    public RestoreResult(bool success, IEnumerable`1<RestoreTargetGraph> restoreGraphs, IEnumerable`1<CompatibilityCheckResult> compatibilityCheckResults, IEnumerable`1<MSBuildOutputFile> msbuildFiles, LockFile lockFile, LockFile previousLockFile, string lockFilePath, CacheFile cacheFile, string cacheFilePath, string packagesLockFilePath, PackagesLockFile packagesLockFile, string dependencyGraphSpecFilePath, DependencyGraphSpec dependencyGraphSpec, ProjectStyle projectStyle, TimeSpan elapsedTime);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Success();
    [CompilerGeneratedAttribute]
public sealed virtual string get_LockFilePath();
    [CompilerGeneratedAttribute]
public void set_LockFilePath(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<RestoreTargetGraph> get_RestoreGraphs();
    [CompilerGeneratedAttribute]
public IEnumerable`1<CompatibilityCheckResult> get_CompatibilityCheckResults();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<MSBuildOutputFile> get_MSBuildOutputFiles();
    [CompilerGeneratedAttribute]
public ProjectStyle get_ProjectStyle();
    [CompilerGeneratedAttribute]
public virtual LockFile get_LockFile();
    [CompilerGeneratedAttribute]
public virtual LockFile get_PreviousLockFile();
    [CompilerGeneratedAttribute]
public TimeSpan get_ElapsedTime();
    [CompilerGeneratedAttribute]
public virtual IList`1<IAssetsLogMessage> get_LogMessages();
    [CompilerGeneratedAttribute]
internal virtual void set_LogMessages(IList`1<IAssetsLogMessage> value);
    [CompilerGeneratedAttribute]
private CacheFile get_CacheFile();
    [CompilerGeneratedAttribute]
protected string get_CacheFilePath();
    [CompilerGeneratedAttribute]
internal PackagesLockFile get__newPackagesLockFile();
    public virtual ISet`1<LibraryIdentity> GetAllInstalled();
    public ISet`1<LibraryRange> GetAllUnresolved();
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreResult/<CommitAsync>d__49")]
public virtual Task CommitAsync(ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreResult/<CommitAssetsFileAsync>d__50")]
private Task CommitAssetsFileAsync(LockFileFormat lockFileFormat, ILogger log, bool toolCommit, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreResult/<CommitCacheFileAsync>d__51")]
private Task CommitCacheFileAsync(ILogger log, bool toolCommit);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreResult/<CommitLockFileAsync>d__52")]
private Task CommitLockFileAsync(ILogger log, bool toolCommit);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreResult/<CommitDgSpecFileAsync>d__53")]
private Task CommitDgSpecFileAsync(ILogger log, bool toolCommit);
    internal virtual IReadOnlyList`1<string> GetDirtyFiles();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__46_0();
    [CompilerGeneratedAttribute]
private List`1<MSBuildOutputFile> <.ctor>b__46_1();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <CommitCacheFileAsync>b__51_0(string outPath);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <CommitLockFileAsync>b__52_0(string outputPath);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <CommitDgSpecFileAsync>b__53_0(string outputPath);
}
public class NuGet.Commands.RestoreResultPair : object {
    [CompilerGeneratedAttribute]
private RestoreSummaryRequest <SummaryRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private RestoreResult <Result>k__BackingField;
    public RestoreSummaryRequest SummaryRequest { get; }
    public RestoreResult Result { get; }
    public RestoreResultPair(RestoreSummaryRequest request, RestoreResult result);
    [CompilerGeneratedAttribute]
public RestoreSummaryRequest get_SummaryRequest();
    [CompilerGeneratedAttribute]
public RestoreResult get_Result();
}
public static class NuGet.Commands.RestoreRunner : object {
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<RunAsync>d__0")]
public static Task`1<IReadOnlyList`1<RestoreSummary>> RunAsync(RestoreArgs restoreContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<RunAsync>d__1")]
public static Task`1<IReadOnlyList`1<RestoreSummary>> RunAsync(RestoreArgs restoreContext);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<RunAsync>d__2")]
private static Task`1<IReadOnlyList`1<RestoreSummary>> RunAsync(IEnumerable`1<RestoreSummaryRequest> restoreRequests, RestoreArgs restoreArgs, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<RunWithoutCommit>d__3")]
public static Task`1<IReadOnlyList`1<RestoreResultPair>> RunWithoutCommit(IEnumerable`1<RestoreSummaryRequest> restoreRequests, RestoreArgs restoreContext);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<GetRequests>d__4")]
public static Task`1<IReadOnlyList`1<RestoreSummaryRequest>> GetRequests(RestoreArgs restoreContext);
    private static int GetMaxTaskCount(RestoreArgs restoreContext);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<ExecuteAndCommitAsync>d__6")]
private static Task`1<RestoreSummary> ExecuteAndCommitAsync(RestoreSummaryRequest summaryRequest, IRestoreProgressReporter progressReporter, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<ExecuteAsync>d__7")]
private static Task`1<RestoreResultPair> ExecuteAsync(RestoreSummaryRequest summaryRequest, CancellationToken token);
    public static Task`1<RestoreSummary> CommitAsync(RestoreResultPair restoreResult, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<CommitAsync>d__9")]
private static Task`1<RestoreSummary> CommitAsync(RestoreResultPair restoreResult, IRestoreProgressReporter progressReporter, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<CompleteTaskAsync>d__10")]
private static Task`1<RestoreSummary> CompleteTaskAsync(List`1<Task`1<RestoreSummary>> restoreTasks);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<CompleteTaskAsync>d__11")]
private static Task`1<RestoreResultPair> CompleteTaskAsync(List`1<Task`1<RestoreResultPair>> restoreTasks);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<CreatePreLoadedRequests>d__12")]
private static Task`1<IReadOnlyList`1<RestoreSummaryRequest>> CreatePreLoadedRequests(RestoreArgs restoreContext);
    [AsyncStateMachineAttribute("NuGet.Commands.RestoreRunner/<CreateRequests>d__13")]
private static Task`1<IReadOnlyList`1<RestoreSummaryRequest>> CreateRequests(string input, RestoreArgs restoreContext);
    public static string GetInvalidInputErrorMessage(string input);
}
public class NuGet.Commands.RestoreSpecException : Exception {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Files>k__BackingField;
    public IEnumerable`1<string> Files { get; }
    private RestoreSpecException(string message, IEnumerable`1<string> files, Exception innerException);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Files();
    public static RestoreSpecException Create(string message, IEnumerable`1<string> files);
    public static RestoreSpecException Create(string message, IEnumerable`1<string> files, Exception innerException);
}
public class NuGet.Commands.RestoreSummary : object {
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoOpRestore>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <ConfigFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <FeedsUsed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <InstallCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IRestoreLogMessage> <Errors>k__BackingField;
    public bool Success { get; }
    public bool NoOpRestore { get; }
    public string InputPath { get; }
    public IReadOnlyList`1<string> ConfigFiles { get; }
    public IReadOnlyList`1<string> FeedsUsed { get; }
    public int InstallCount { get; }
    public IReadOnlyList`1<IRestoreLogMessage> Errors { get; }
    public RestoreSummary(bool success);
    public RestoreSummary(RestoreResult result, string inputPath, IEnumerable`1<string> configFiles, IEnumerable`1<SourceRepository> sourceRepositories, IEnumerable`1<RestoreLogMessage> errors);
    public RestoreSummary(bool success, string inputPath, IReadOnlyList`1<string> configFiles, IReadOnlyList`1<string> feedsUsed, int installCount, IReadOnlyList`1<IRestoreLogMessage> errors);
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public bool get_NoOpRestore();
    [CompilerGeneratedAttribute]
public string get_InputPath();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_ConfigFiles();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_FeedsUsed();
    [CompilerGeneratedAttribute]
public int get_InstallCount();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IRestoreLogMessage> get_Errors();
    public static void Log(ILogger logger, IReadOnlyList`1<RestoreSummary> restoreSummaries, bool logErrors);
    private static void LogErrorsToConsole(RestoreSummary restoreSummary, string logHeading, ILogger logger);
    [IteratorStateMachineAttribute("NuGet.Commands.RestoreSummary/<IndentLines>d__26")]
private static IEnumerable`1<string> IndentLines(string input);
}
public class NuGet.Commands.RestoreSummaryRequest : object {
    [CompilerGeneratedAttribute]
private RestoreRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ConfigFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<SourceRepository> <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InputPath>k__BackingField;
    public RestoreRequest Request { get; }
    public IEnumerable`1<string> ConfigFiles { get; }
    public IReadOnlyList`1<SourceRepository> Sources { get; }
    public string InputPath { get; }
    public RestoreSummaryRequest(RestoreRequest request, string inputPath, IEnumerable`1<string> configFiles, IReadOnlyList`1<SourceRepository> sources);
    [CompilerGeneratedAttribute]
public RestoreRequest get_Request();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ConfigFiles();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<SourceRepository> get_Sources();
    [CompilerGeneratedAttribute]
public string get_InputPath();
}
public class NuGet.Commands.RestoreTargetGraph : object {
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private ManagedCodeConventions <Conventions>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeGraph <RuntimeGraph>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<GraphNode`1<RemoteResolveResult>> <Graphs>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<RemoteMatch> <Install>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<GraphItem`1<RemoteResolveResult>> <Flattened>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<LibraryRange> <Unresolved>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InConflict>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetGraphName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ResolverConflict> <Conflicts>k__BackingField;
    [CompilerGeneratedAttribute]
private AnalyzeResult`1<RemoteResolveResult> <AnalyzeResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<ResolvedDependencyKey> <ResolvedDependencies>k__BackingField;
    public string RuntimeIdentifier { get; internal set; }
    public NuGetFramework Framework { get; internal set; }
    public ManagedCodeConventions Conventions { get; internal set; }
    public RuntimeGraph RuntimeGraph { get; internal set; }
    public IEnumerable`1<GraphNode`1<RemoteResolveResult>> Graphs { get; internal set; }
    public ISet`1<RemoteMatch> Install { get; internal set; }
    public ISet`1<GraphItem`1<RemoteResolveResult>> Flattened { get; internal set; }
    public ISet`1<LibraryRange> Unresolved { get; internal set; }
    public bool InConflict { get; internal set; }
    public string Name { get; internal set; }
    public string TargetGraphName { get; internal set; }
    public IEnumerable`1<ResolverConflict> Conflicts { get; internal set; }
    public AnalyzeResult`1<RemoteResolveResult> AnalyzeResult { get; internal set; }
    public ISet`1<ResolvedDependencyKey> ResolvedDependencies { get; internal set; }
    private RestoreTargetGraph(IEnumerable`1<ResolverConflict> conflicts, NuGetFramework framework, string runtimeIdentifier, RuntimeGraph runtimeGraph, IEnumerable`1<GraphNode`1<RemoteResolveResult>> graphs, ISet`1<RemoteMatch> install, ISet`1<GraphItem`1<RemoteResolveResult>> flattened, ISet`1<LibraryRange> unresolved, AnalyzeResult`1<RemoteResolveResult> analyzeResult, ISet`1<ResolvedDependencyKey> resolvedDependencies);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RuntimeIdentifier();
    [CompilerGeneratedAttribute]
internal void set_RuntimeIdentifier(string value);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetFramework get_Framework();
    [CompilerGeneratedAttribute]
internal void set_Framework(NuGetFramework value);
    [CompilerGeneratedAttribute]
public sealed virtual ManagedCodeConventions get_Conventions();
    [CompilerGeneratedAttribute]
internal void set_Conventions(ManagedCodeConventions value);
    [CompilerGeneratedAttribute]
public sealed virtual RuntimeGraph get_RuntimeGraph();
    [CompilerGeneratedAttribute]
internal void set_RuntimeGraph(RuntimeGraph value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<GraphNode`1<RemoteResolveResult>> get_Graphs();
    [CompilerGeneratedAttribute]
internal void set_Graphs(IEnumerable`1<GraphNode`1<RemoteResolveResult>> value);
    [CompilerGeneratedAttribute]
public sealed virtual ISet`1<RemoteMatch> get_Install();
    [CompilerGeneratedAttribute]
internal void set_Install(ISet`1<RemoteMatch> value);
    [CompilerGeneratedAttribute]
public sealed virtual ISet`1<GraphItem`1<RemoteResolveResult>> get_Flattened();
    [CompilerGeneratedAttribute]
internal void set_Flattened(ISet`1<GraphItem`1<RemoteResolveResult>> value);
    [CompilerGeneratedAttribute]
public sealed virtual ISet`1<LibraryRange> get_Unresolved();
    [CompilerGeneratedAttribute]
internal void set_Unresolved(ISet`1<LibraryRange> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_InConflict();
    [CompilerGeneratedAttribute]
internal void set_InConflict(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TargetGraphName();
    [CompilerGeneratedAttribute]
internal void set_TargetGraphName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<ResolverConflict> get_Conflicts();
    [CompilerGeneratedAttribute]
internal void set_Conflicts(IEnumerable`1<ResolverConflict> value);
    [CompilerGeneratedAttribute]
public sealed virtual AnalyzeResult`1<RemoteResolveResult> get_AnalyzeResult();
    [CompilerGeneratedAttribute]
internal void set_AnalyzeResult(AnalyzeResult`1<RemoteResolveResult> value);
    [CompilerGeneratedAttribute]
public sealed virtual ISet`1<ResolvedDependencyKey> get_ResolvedDependencies();
    [CompilerGeneratedAttribute]
internal void set_ResolvedDependencies(ISet`1<ResolvedDependencyKey> value);
    public static RestoreTargetGraph Create(IEnumerable`1<GraphNode`1<RemoteResolveResult>> graphs, RemoteWalkContext context, ILogger logger, NuGetFramework framework);
    public static RestoreTargetGraph Create(RuntimeGraph runtimeGraph, IEnumerable`1<GraphNode`1<RemoteResolveResult>> graphs, RemoteWalkContext context, ILogger log, NuGetFramework framework, string runtimeIdentifier);
}
internal static class NuGet.Commands.RunnerHelper : object {
    public static ISettings GetSettings(string configfile);
    public static PackageSourceProvider GetSourceProvider(ISettings settings);
    public static void EnableOrDisableSource(PackageSourceProvider sourceProvider, string name, bool enable, Func`1<ILogger> getLogger);
    public static void ValidateCredentials(string username, string password, string validAuthenticationTypes);
    public static int ParseProtocolVersion(string protocolVersionString);
}
internal static class NuGet.Commands.SdkAnalysisLevelMinimums : object {
    internal static NuGetVersion HttpErrorSdkAnalysisLevelMinimumValue;
    private static SdkAnalysisLevelMinimums();
    public static bool IsEnabled(NuGetVersion sdkAnalysisLevel, bool usingMicrosoftNetSdk, NuGetVersion minSdkVersion);
}
public class NuGet.Commands.SignArgs : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PackagePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificatePath>k__BackingField;
    [CompilerGeneratedAttribute]
private StoreName <CertificateStoreName>k__BackingField;
    [CompilerGeneratedAttribute]
private StoreLocation <CertificateStoreLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateSubjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateFingerprint>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <SignatureHashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Timestamper>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <TimestampHashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificatePassword>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Overwrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NonInteractive>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IPasswordProvider <PasswordProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <Token>k__BackingField;
    [ObsoleteAttribute("Use PackagePaths instead")]
public string PackagePath { get; public set; }
    public IReadOnlyList`1<string> PackagePaths { get; public set; }
    public string OutputDirectory { get; public set; }
    public string CertificatePath { get; public set; }
    public StoreName CertificateStoreName { get; public set; }
    public StoreLocation CertificateStoreLocation { get; public set; }
    public string CertificateSubjectName { get; public set; }
    public string CertificateFingerprint { get; public set; }
    public HashAlgorithmName SignatureHashAlgorithm { get; public set; }
    public string Timestamper { get; public set; }
    public HashAlgorithmName TimestampHashAlgorithm { get; public set; }
    public string CertificatePassword { get; public set; }
    public bool Overwrite { get; public set; }
    public bool NonInteractive { get; public set; }
    public ILogger Logger { get; public set; }
    public IPasswordProvider PasswordProvider { get; public set; }
    public CancellationToken Token { get; public set; }
    public string get_PackagePath();
    public void set_PackagePath(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_PackagePaths();
    [CompilerGeneratedAttribute]
public void set_PackagePaths(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_OutputDirectory();
    [CompilerGeneratedAttribute]
public void set_OutputDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_CertificatePath();
    [CompilerGeneratedAttribute]
public void set_CertificatePath(string value);
    [CompilerGeneratedAttribute]
public StoreName get_CertificateStoreName();
    [CompilerGeneratedAttribute]
public void set_CertificateStoreName(StoreName value);
    [CompilerGeneratedAttribute]
public StoreLocation get_CertificateStoreLocation();
    [CompilerGeneratedAttribute]
public void set_CertificateStoreLocation(StoreLocation value);
    [CompilerGeneratedAttribute]
public string get_CertificateSubjectName();
    [CompilerGeneratedAttribute]
public void set_CertificateSubjectName(string value);
    [CompilerGeneratedAttribute]
public string get_CertificateFingerprint();
    [CompilerGeneratedAttribute]
public void set_CertificateFingerprint(string value);
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_SignatureHashAlgorithm();
    [CompilerGeneratedAttribute]
public void set_SignatureHashAlgorithm(HashAlgorithmName value);
    [CompilerGeneratedAttribute]
public string get_Timestamper();
    [CompilerGeneratedAttribute]
public void set_Timestamper(string value);
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_TimestampHashAlgorithm();
    [CompilerGeneratedAttribute]
public void set_TimestampHashAlgorithm(HashAlgorithmName value);
    [CompilerGeneratedAttribute]
public string get_CertificatePassword();
    [CompilerGeneratedAttribute]
public void set_CertificatePassword(string value);
    [CompilerGeneratedAttribute]
public bool get_Overwrite();
    [CompilerGeneratedAttribute]
public void set_Overwrite(bool value);
    [CompilerGeneratedAttribute]
public bool get_NonInteractive();
    [CompilerGeneratedAttribute]
public void set_NonInteractive(bool value);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public IPasswordProvider get_PasswordProvider();
    [CompilerGeneratedAttribute]
public void set_PasswordProvider(IPasswordProvider value);
    [CompilerGeneratedAttribute]
public CancellationToken get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(CancellationToken value);
}
public interface NuGet.Commands.SignCommand.IPasswordProvider {
}
public class NuGet.Commands.SignCommandException : Exception {
    private ILogMessage _logMessage;
    public SignCommandException(ILogMessage logMessage);
    public sealed virtual ILogMessage AsLogMessage();
}
public class NuGet.Commands.SignCommandRunner : object {
    [AsyncStateMachineAttribute("NuGet.Commands.SignCommandRunner/<ExecuteCommandAsync>d__0")]
public sealed virtual Task`1<int> ExecuteCommandAsync(SignArgs signArgs);
    [AsyncStateMachineAttribute("NuGet.Commands.SignCommandRunner/<ExecuteCommandAsync>d__1")]
public Task`1<int> ExecuteCommandAsync(IEnumerable`1<string> packagesToSign, SignPackageRequest signPackageRequest, string timestamper, ILogger logger, string outputDirectory, bool overwrite, CancellationToken token);
    private static ISignatureProvider GetSignatureProvider(string timestamper);
    [AsyncStateMachineAttribute("NuGet.Commands.SignCommandRunner/<GetCertificateAsync>d__3")]
private static Task`1<X509Certificate2> GetCertificateAsync(SignArgs signArgs);
    private static X509Certificate2Collection FilterCodeSigningCertificates(X509Certificate2Collection matchingCollection);
}
internal class NuGet.Commands.SingleFileProvider : object {
    public static string RootDir;
    private string _path;
    public SingleFileProvider(string path);
    public sealed virtual IDirectoryContents GetDirectoryContents(string subpath);
    public sealed virtual IFileInfo GetFileInfo(string subpath);
    public sealed virtual IChangeToken Watch(string filter);
}
public class NuGet.Commands.SourceRepositoryDependencyProvider : object {
    private object _lock;
    private SourceRepository _sourceRepository;
    private ILogger _logger;
    private SourceCacheContext _cacheContext;
    private LocalPackageFileCache _packageFileCache;
    private FindPackageByIdResource _findPackagesByIdResource;
    private bool _ignoreFailedSources;
    private bool _ignoreWarning;
    private bool _isFallbackFolderSource;
    private bool _useLegacyAssetTargetFallbackBehavior;
    private TaskResultCache`2<LibraryRangeCacheKey, LibraryDependencyInfo> _dependencyInfoCache;
    private TaskResultCache`2<LibraryRange, LibraryIdentity> _libraryMatchCache;
    private static SemaphoreSlim _throttle;
    public bool IsHttp { get; }
    public PackageSource Source { get; }
    public SourceRepository SourceRepository { get; }
    public SourceRepositoryDependencyProvider(SourceRepository sourceRepository, ILogger logger, SourceCacheContext cacheContext, bool ignoreFailedSources, bool ignoreWarning);
    public SourceRepositoryDependencyProvider(SourceRepository sourceRepository, ILogger logger, SourceCacheContext cacheContext, bool ignoreFailedSources, bool ignoreWarning, LocalPackageFileCache fileCache, bool isFallbackFolderSource);
    internal SourceRepositoryDependencyProvider(SourceRepository sourceRepository, ILogger logger, SourceCacheContext cacheContext, bool ignoreFailedSources, bool ignoreWarning, LocalPackageFileCache fileCache, bool isFallbackFolderSource, IEnvironmentVariableReader environmentVariableReader);
    private static SourceRepositoryDependencyProvider();
    internal static SemaphoreSlim GetThrottleSemaphoreSlim(IEnvironmentVariableReader env);
    public sealed virtual bool get_IsHttp();
    public sealed virtual PackageSource get_Source();
    public sealed virtual SourceRepository get_SourceRepository();
    [AsyncStateMachineAttribute("NuGet.Commands.SourceRepositoryDependencyProvider/<FindLibraryAsync>d__23")]
public sealed virtual Task`1<LibraryIdentity> FindLibraryAsync(LibraryRange libraryRange, NuGetFramework targetFramework, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Commands.SourceRepositoryDependencyProvider/<FindLibraryCoreAsync>d__24")]
private Task`1<LibraryIdentity> FindLibraryCoreAsync(LibraryRange libraryRange, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    public sealed virtual Task`1<LibraryDependencyInfo> GetDependenciesAsync(LibraryIdentity libraryIdentity, NuGetFramework targetFramework, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Commands.SourceRepositoryDependencyProvider/<GetDependenciesCoreAsync>d__26")]
private Task`1<LibraryDependencyInfo> GetDependenciesCoreAsync(LibraryIdentity match, NuGetFramework targetFramework, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Commands.SourceRepositoryDependencyProvider/<GetPackageDownloaderAsync>d__27")]
public sealed virtual Task`1<IPackageDownloader> GetPackageDownloaderAsync(PackageIdentity packageIdentity, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    private IEnumerable`1<LibraryDependency> GetDependencies(FindPackageByIdDependencyInfo packageInfo, NuGetFramework targetFramework);
    private static NuGetFramework DeconstructFallbackFrameworks(NuGetFramework nuGetFramework);
    [AsyncStateMachineAttribute("NuGet.Commands.SourceRepositoryDependencyProvider/<EnsureResource>d__30")]
private Task EnsureResource(CancellationToken cancellationToken);
    private void AddLocalV3ResourceOptions(FindPackageByIdResource resource);
    [AsyncStateMachineAttribute("NuGet.Commands.SourceRepositoryDependencyProvider/<GetAllVersionsAsync>d__32")]
public sealed virtual Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsAsync(string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Commands.SourceRepositoryDependencyProvider/<GetAllVersionsInternalAsync>d__33")]
internal Task`1<IEnumerable`1<NuGetVersion>> GetAllVersionsInternalAsync(string id, SourceCacheContext cacheContext, ILogger logger, bool catchAndLogExceptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.Commands.SourceRepositoryDependencyProvider/<LogWarningAsync>d__34")]
private Task LogWarningAsync(ILogger logger, string id, FatalProtocolException e);
    [AsyncStateMachineAttribute("NuGet.Commands.SourceRepositoryDependencyProvider/<LogErrorAsync>d__35")]
private Task LogErrorAsync(ILogger logger, string id, FatalProtocolException e);
    [CompilerGeneratedAttribute]
internal static ILogMessage <LogErrorAsync>g__UnwrapToLogMessage|35_0(Exception e);
}
public enum NuGet.Commands.SourcesAction : Enum {
    public int value__;
    public static SourcesAction None;
    public static SourcesAction List;
    public static SourcesAction Add;
    public static SourcesAction Remove;
    public static SourcesAction Enable;
    public static SourcesAction Disable;
    public static SourcesAction Update;
}
public enum NuGet.Commands.SourcesListFormat : Enum {
    public int value__;
    public static SourcesListFormat None;
    public static SourcesListFormat Detailed;
    public static SourcesListFormat Short;
}
public static class NuGet.Commands.SpecValidationUtility : object {
    [CompilerGeneratedAttribute]
private static NuGetVersion <SdkVersion>k__BackingField;
    public static NuGetVersion SdkVersion { get; public set; }
    [CompilerGeneratedAttribute]
public static NuGetVersion get_SdkVersion();
    [CompilerGeneratedAttribute]
public static void set_SdkVersion(NuGetVersion value);
    public static void ValidateDependencySpec(DependencyGraphSpec spec);
    public static void ValidateDependencySpec(DependencyGraphSpec spec, HashSet`1<string> projectsToSkip);
    private static void ValidateProjectSpecV3(PackageSpec spec);
    private static void ValidateProjectSpecV5(PackageSpec spec);
    public static void ValidateProjectSpec(PackageSpec spec);
    private static void ValidateFrameworks(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateProjectSpecPackageReference(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateProjectSpecUAP(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateStandaloneSpec(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateToolSpec(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateProjectSpecOther(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateProjectMetadata(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateProjectMSBuildMetadata(PackageSpec spec, IEnumerable`1<string> files);
    private static IEnumerable`1<LibraryDependency> GetAllDependencies(PackageSpec spec);
}
public static class NuGet.Commands.SpecValidationUtilityV3 : object {
    public static void ValidateProjectSpec(PackageSpec spec);
    private static void ValidateProjectSpecOther(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateProjectSpecUAP(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateFrameworks(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateProjectSpecPackageReference(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateProjectMSBuildMetadata(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateToolSpec(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateStandaloneSpec(PackageSpec spec, IEnumerable`1<string> files);
    private static void ValidateProjectMetadata(PackageSpec spec, IEnumerable`1<string> files);
    private static IEnumerable`1<LibraryDependency> GetAllDependencies(PackageSpec spec);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.Commands.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArgumentCannotBeNullOrEmpty { get; }
    internal static string CannotBeUsedWithOtherValues { get; }
    internal static string ClientCertificatesFileCertFilePath { get; }
    internal static string ClientCertificatesFileCertNoPassword { get; }
    internal static string ClientCertificatesFileCertWithPassword { get; }
    internal static string ClientCertificatesItemCertificateError { get; }
    internal static string ClientCertificatesItemCertificateMessage { get; }
    internal static string ClientCertificatesLogTitle { get; }
    internal static string ClientCertificatesStoreCertFindBy { get; }
    internal static string ClientCertificatesStoreCertFindValue { get; }
    internal static string ClientCertificatesStoreCertStoreLocation { get; }
    internal static string ClientCertificatesStoreCertStoreName { get; }
    internal static string ClientCertificateSuccessfullyAdded { get; }
    internal static string ClientCertificateSuccessfullyRemoved { get; }
    internal static string ClientCertificateSuccessfullyUpdated { get; }
    internal static string Error_AuthorTrustExpectedAuthorSignature { get; }
    internal static string Error_CannotFindMsbuild { get; }
    internal static string Error_CannotTrustOwnersForAuthor { get; }
    internal static string Error_CentralPackageVersions_AutoreferencedReferencesNotAllowed { get; }
    internal static string Error_CentralPackageVersions_FloatingVersionsAreNotAllowed { get; }
    internal static string Error_CentralPackageVersions_MissingPackageVersion { get; }
    internal static string Error_CentralPackageVersions_VersionOverrideDisabled { get; }
    internal static string Error_CentralPackageVersions_VersionsNotAllowed { get; }
    internal static string Error_ClientCertificateAlreadyExist { get; }
    internal static string Error_ClientCertificateNotExist { get; }
    internal static string Error_ClientCertificatesNotFound { get; }
    internal static string Error_ClientCertificateTypeMismatch { get; }
    internal static string Error_CouldNotAdd { get; }
    internal static string Error_CouldNotList { get; }
    internal static string Error_CouldNotRemove { get; }
    internal static string Error_CouldNotSync { get; }
    internal static string Error_CouldNotUpdateClientCertificate { get; }
    internal static string Error_CouldNotUpdateMetadataLastAccessTime { get; }
    internal static string Error_EmptyCertificateListInRepository { get; }
    internal static string Error_EmptySourceFilePath { get; }
    internal static string Error_EmptySourceFileProjectDirectory { get; }
    internal static string Error_HttpSource_Single { get; }
    internal static string Error_HttpSource_Single_Short { get; }
    internal static string Error_HttpSources_Multiple { get; }
    internal static string Error_IncompatiblePackageType { get; }
    internal static string Error_InputFileNotSpecified { get; }
    internal static string Error_InvalidATF { get; }
    internal static string Error_InvalidCertificateInformationFromServer { get; }
    internal static string Error_InvalidCombinationOfArguments { get; }
    internal static string Error_InvalidCommandLineInput { get; }
    internal static string Error_InvalidCommandLineInputConfig { get; }
    internal static string Error_InvalidCommandLineInputJson { get; }
    internal static string Error_InvalidDependencyVersionConstraints { get; }
    internal static string Error_InvalidLockFileInput { get; }
    internal static string Error_InvalidNuGetAuditLevelValue { get; }
    internal static string Error_InvalidNuGetAuditModeValue { get; }
    internal static string Error_InvalidNuGetAuditValue { get; }
    internal static string Error_InvalidProjectPackageCombo { get; }
    internal static string Error_InvalidSymbolPackageFormat { get; }
    internal static string Error_InvalidTargetFramework { get; }
    internal static string Error_InvalidWindowsTargetPlatformMinVersion { get; }
    internal static string Error_MissingSourceParameter { get; }
    internal static string Error_MultiplePackagePaths { get; }
    internal static string Error_NoClientAllowList { get; }
    internal static string Error_NoMatchingCertificate { get; }
    internal static string Error_NoMatchingClientCertificate { get; }
    internal static string Error_NoPackageVersionsExist { get; }
    internal static string Error_NoPackageVersionsExistInRange { get; }
    internal static string Error_NoSignatureTrustedForPackage { get; }
    internal static string Error_NoSourcesInformation { get; }
    internal static string Error_NoStablePackageVersionsExist { get; }
    internal static string Error_NotSupportedHashAlgorithm { get; }
    internal static string Error_PackageCommandNoFilesForLibPackage { get; }
    internal static string Error_PackageCommandNoFilesForSymbolsPackage { get; }
    internal static string Error_PackageDownload_NoVersion { get; }
    internal static string Error_PackageDownload_OnlyExactVersionsAreAllowed { get; }
    internal static string Error_PackageNotSigned { get; }
    internal static string Error_PackageValidationFailed { get; }
    internal static string Error_PackFailed { get; }
    internal static string Error_PlatformVersionNotPresent { get; }
    internal static string Error_ProjectDoesNotExist { get; }
    internal static string Error_ProjectRuntimeJsonIsUnreadable { get; }
    internal static string Error_ProjectRuntimeJsonNotFound { get; }
    internal static string Error_ProjectWithIncorrectDependenciesCount { get; }
    internal static string Error_PropertyCannotBeNullOrEmpty { get; }
    internal static string Error_RepoTrustExpectedRepoSignature { get; }
    internal static string Error_RestoreInLockedMode { get; }
    internal static string Error_ServiceIndexShouldBeHttps { get; }
    internal static string Error_ToolsPackageWithExtraPackageTypes { get; }
    internal static string Error_TrustedAuthorNoOwners { get; }
    internal static string Error_TrustedRepoAlreadyExists { get; }
    internal static string Error_TrustedRepositoryDoesNotExist { get; }
    internal static string Error_TrustedSignerAlreadyExists { get; }
    internal static string Error_UnableToFindProjectInfo { get; }
    internal static string Error_UnableToLocateBuildOutput { get; }
    internal static string Error_UnableToLocateRestoreTarget { get; }
    internal static string Error_UnableToSignPackage { get; }
    internal static string Error_UnavailableSource { get; }
    internal static string Error_UnknownBuildAction { get; }
    internal static string Error_UnknownClientCertificatesFindBy { get; }
    internal static string Error_UnknownClientCertificatesStoreLocation { get; }
    internal static string Error_UnknownClientCertificatesStoreName { get; }
    internal static string Error_UnknownClientCertificateStoreType { get; }
    internal static string Error_UnsupportedTrustTarget { get; }
    internal static string Error_VulnerabilityDataFetch { get; }
    internal static string Error_WriteResolvedNuSpecOverwriteOriginal { get; }
    internal static string Error_XPROJNotAllowed { get; }
    internal static string FailedToBuildProject { get; }
    internal static string FileNotAddedToPackage { get; }
    internal static string FoundVersionsInSource { get; }
    internal static string FoundVersionsInSourceWithoutMatch { get; }
    internal static string Invalid_AttributeValue { get; }
    internal static string InvalidRestoreInput { get; }
    internal static string InvalidRestoreInputWithFiles { get; }
    internal static string InvalidSource { get; }
    internal static string LocalsCommand_ClearedSuccessful { get; }
    internal static string LocalsCommand_ClearFailed { get; }
    internal static string LocalsCommand_ClearingNuGetGlobalPackagesFolder { get; }
    internal static string LocalsCommand_ClearingNuGetHttpCache { get; }
    internal static string LocalsCommand_ClearingNuGetPluginsCache { get; }
    internal static string LocalsCommand_ClearingNuGetTempCache { get; }
    internal static string LocalsCommand_FailedToDeletePath { get; }
    internal static string LocalsCommand_Help { get; }
    internal static string LocalsCommand_InvalidLocalResourceName { get; }
    internal static string LocalsCommand_LocalResourcePathNotSet { get; }
    internal static string LocalsCommand_LocalsPartiallyCleared { get; }
    internal static string Log_AllProjectsUpToDate { get; }
    internal static string Log_AssetsFileNotOnDisk { get; }
    internal static string Log_Committing { get; }
    internal static string Log_ConfigFileSummary { get; }
    internal static string Log_ConvertedPackageToOriginalCase { get; }
    internal static string Log_CPVM_DowngradeError { get; }
    internal static string Log_CycleDetected { get; }
    internal static string Log_DependencyBumpedUp { get; }
    internal static string Log_DowngradeWarning { get; }
    internal static string Log_ErrorSummary { get; }
    internal static string Log_FeedsUsedSummary { get; }
    internal static string Log_FrameworkDisplay { get; }
    internal static string Log_FrameworkRIDDisplay { get; }
    internal static string Log_GeneratingMsBuildFile { get; }
    internal static string Log_ImportsFallbackWarning { get; }
    internal static string Log_InstalledSummary { get; }
    internal static string Log_InstalledSummaryCount { get; }
    internal static string Log_LockFileNotOnDisk { get; }
    internal static string Log_MergingRuntimes { get; }
    internal static string Log_MissingImplementationFx { get; }
    internal static string Log_MissingImplementationFxRuntime { get; }
    internal static string Log_MissingPackagesOnDisk { get; }
    internal static string Log_PackageCommandAddedFile { get; }
    internal static string Log_PackageCommandAttemptingToBuildSymbolsPackage { get; }
    internal static string Log_PackageCommandInstallPackageToOutputPath { get; }
    internal static string Log_PackageCommandSuccess { get; }
    internal static string Log_PackageContentHashValidationFailed { get; }
    internal static string Log_PackageNotCompatibleWithFx { get; }
    internal static string Log_PackageNotCompatibleWithFx_NoSupports { get; }
    internal static string Log_PackageNotCompatibleWithFx_Supports { get; }
    internal static string Log_PackagesAndProjectsAreCompatible { get; }
    internal static string Log_ProjectDoesNotSpecifyTargetFrameworks { get; }
    internal static string Log_ProjectNotCompatibleWithFx { get; }
    internal static string Log_ProjectNotCompatibleWithFx_NoSupports { get; }
    internal static string Log_ProjectNotCompatibleWithFx_Supports { get; }
    internal static string Log_ProjectUpToDateSummary { get; }
    internal static string Log_PropsFileNotOnDisk { get; }
    internal static string Log_ReadingProject { get; }
    internal static string Log_ResolverConflict { get; }
    internal static string Log_ResolvingConflicts { get; }
    internal static string Log_RestoreComplete { get; }
    internal static string Log_RestoreCompleteDotnetTool { get; }
    internal static string Log_RestoreFailed { get; }
    internal static string Log_RestoreFailedDotnetTool { get; }
    internal static string Log_RestoreNoOpDGChanged { get; }
    internal static string Log_RestoreNoOpFinish { get; }
    internal static string Log_RestoringPackages { get; }
    internal static string Log_RunningNonParallelRestore { get; }
    internal static string Log_RunningParallelRestore { get; }
    internal static string Log_ScanningForRuntimeJson { get; }
    internal static string Log_SkippingAssetsFile { get; }
    internal static string Log_SkippingCacheFile { get; }
    internal static string Log_SkippingCompatibiilityCheckOnRidlessGraphForDotnetToolReferenceProject { get; }
    internal static string Log_SkippingPackagesLockFileGeneration { get; }
    internal static string Log_SourceMappingEnabledNoMatchingPackageSources { get; }
    internal static string Log_TargetsFileNotOnDisk { get; }
    internal static string Log_ToolSkippingAssetsFile { get; }
    internal static string Log_ToolWritingAssetsFile { get; }
    internal static string Log_ToolWritingCacheFile { get; }
    internal static string Log_UnknownCompatibilityProfile { get; }
    internal static string Log_UnresolvedDependency { get; }
    internal static string Log_VersionConflict { get; }
    internal static string Log_WritingAssetsFile { get; }
    internal static string Log_WritingCacheFile { get; }
    internal static string Log_WritingPackagesLockFile { get; }
    internal static string MissingRequiredProperty { get; }
    internal static string MissingRequiredPropertyForProjectType { get; }
    internal static string MSBuildWarning_MultiTarget { get; }
    internal static string Multiple_Nupkgs_Detected { get; }
    internal static string NoClientCertificates { get; }
    internal static string NoClientCertificatesMatching { get; }
    internal static string NonMatchingProperties { get; }
    internal static string NoTrustedSigners { get; }
    internal static string NoTrustedSignersMatching { get; }
    internal static string NuGetDocs { get; }
    internal static string PropertyNotAllowed { get; }
    internal static string PropertyNotAllowedForProjectType { get; }
    internal static string RegsiteredClientCertificates { get; }
    internal static string RegsiteredTrustedSigners { get; }
    internal static string ReservedPackageNameAll { get; }
    internal static string ResolverRequest_ToStringFormat { get; }
    internal static string SignCommandCertificateFileNotFound { get; }
    internal static string SignCommandCertificateStoreNotFound { get; }
    internal static string SignCommandDialogMessage { get; }
    internal static string SignCommandDialogTitle { get; }
    internal static string SignCommandDisplayCertificate { get; }
    internal static string SignCommandDisplayTimestamper { get; }
    internal static string SignCommandInvalidCertException { get; }
    internal static string SignCommandInvalidPasswordException { get; }
    internal static string SignCommandMultipleCertException { get; }
    internal static string SignCommandNoCertException { get; }
    internal static string SignCommandOutputPath { get; }
    internal static string SignCommandSuccess { get; }
    internal static string Source_DefaultNamePrefix { get; }
    internal static string Source_InvalidFormatValue { get; }
    internal static string SourceNotConsidered { get; }
    internal static string SourcesCommandAllNameIsReserved { get; }
    internal static string SourcesCommandClearingExistingAuthTypes { get; }
    internal static string SourcesCommandCredentialsRequired { get; }
    internal static string SourcesCommandCredentialsRequiredWithAuthTypes { get; }
    internal static string SourcesCommandDisabled { get; }
    internal static string SourcesCommandEnabled { get; }
    internal static string SourcesCommandInvalidSource { get; }
    internal static string SourcesCommandNoMatchingSourcesFound { get; }
    internal static string SourcesCommandNoSources { get; }
    internal static string SourcesCommandRegisteredSources { get; }
    internal static string SourcesCommandSourceAddedSuccessfully { get; }
    internal static string SourcesCommandSourceDisabledSuccessfully { get; }
    internal static string SourcesCommandSourceEnabledSuccessfully { get; }
    internal static string SourcesCommandSourceRemovedSuccessfully { get; }
    internal static string SourcesCommandUniqueName { get; }
    internal static string SourcesCommandUniqueSource { get; }
    internal static string SourcesCommandUpdateSuccessful { get; }
    internal static string SourcesCommandValidProtocolVersion { get; }
    internal static string SpecValidation_OriginalTargetFrameworksMustMatchAliases { get; }
    internal static string SpecValidationDuplicateFrameworks { get; }
    internal static string SpecValidationInvalidFramework { get; }
    internal static string SpecValidationMissingProject { get; }
    internal static string SpecValidationNoFrameworks { get; }
    internal static string SpecValidationUAPSingleFramework { get; }
    internal static string SpecValidationZeroRestoreRequests { get; }
    internal static string SuccessfullUpdatedTrustedSigner { get; }
    internal static string SuccessfullyAddedTrustedAuthor { get; }
    internal static string SuccessfullyAddedTrustedRepository { get; }
    internal static string SuccessfullyRemovedTrustedSigner { get; }
    internal static string SuccessfullySynchronizedTrustedRepository { get; }
    internal static string TrustedSignerLogCertificates { get; }
    internal static string TrustedSignerLogCertificateSummaryAllowUntrustedRoot { get; }
    internal static string TrustedSignerLogCertificateSummaryUnallowUntrustedRoot { get; }
    internal static string TrustedSignerLogOwners { get; }
    internal static string TrustedSignerLogServiceIndex { get; }
    internal static string TrustedSignerLogTitle { get; }
    internal static string UnsupportedHashAlgorithm { get; }
    internal static string UnsupportedProject { get; }
    internal static string VerifyCommand_Failed { get; }
    internal static string VerifyCommand_FinishedWithErrors { get; }
    internal static string VerifyCommand_NotSupported { get; }
    internal static string VerifyCommand_PackageIsNotValid { get; }
    internal static string VerifyCommand_Success { get; }
    internal static string VerifyCommand_VerificationTypeNotSupported { get; }
    internal static string VerifyCommand_VerifyingPackage { get; }
    internal static string Vulnerability_Severity_Critical { get; }
    internal static string Vulnerability_Severity_High { get; }
    internal static string Vulnerability_Severity_Low { get; }
    internal static string Vulnerability_Severity_Moderate { get; }
    internal static string Vulnerability_Severity_unknown { get; }
    internal static string Warning_AuditSourceWithoutVulnerabilityData { get; }
    internal static string Warning_CentralPackageVersions_MultipleSourcesWithoutPackageSourceMapping { get; }
    internal static string Warning_DuplicatePropertyKey { get; }
    internal static string Warning_FileExcludedByDefault { get; }
    internal static string Warning_HttpServerUsage { get; }
    internal static string Warning_HttpServerUsage_MultipleSources { get; }
    internal static string Warning_List_HttpSource { get; }
    internal static string Warning_List_HttpSources { get; }
    internal static string Warning_MinVersionDoesNotExist { get; }
    internal static string Warning_MinVersionNonInclusive { get; }
    internal static string Warning_PackageWithKnownVulnerability { get; }
    internal static string Warning_ProjectDependencyMissingLowerBound { get; }
    internal static string Warning_ProjectDependencyMissingVersion { get; }
    internal static string Warning_VersionAboveUpperBound { get; }
    internal static string WarningAsError { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArgumentCannotBeNullOrEmpty();
    internal static string get_CannotBeUsedWithOtherValues();
    internal static string get_ClientCertificatesFileCertFilePath();
    internal static string get_ClientCertificatesFileCertNoPassword();
    internal static string get_ClientCertificatesFileCertWithPassword();
    internal static string get_ClientCertificatesItemCertificateError();
    internal static string get_ClientCertificatesItemCertificateMessage();
    internal static string get_ClientCertificatesLogTitle();
    internal static string get_ClientCertificatesStoreCertFindBy();
    internal static string get_ClientCertificatesStoreCertFindValue();
    internal static string get_ClientCertificatesStoreCertStoreLocation();
    internal static string get_ClientCertificatesStoreCertStoreName();
    internal static string get_ClientCertificateSuccessfullyAdded();
    internal static string get_ClientCertificateSuccessfullyRemoved();
    internal static string get_ClientCertificateSuccessfullyUpdated();
    internal static string get_Error_AuthorTrustExpectedAuthorSignature();
    internal static string get_Error_CannotFindMsbuild();
    internal static string get_Error_CannotTrustOwnersForAuthor();
    internal static string get_Error_CentralPackageVersions_AutoreferencedReferencesNotAllowed();
    internal static string get_Error_CentralPackageVersions_FloatingVersionsAreNotAllowed();
    internal static string get_Error_CentralPackageVersions_MissingPackageVersion();
    internal static string get_Error_CentralPackageVersions_VersionOverrideDisabled();
    internal static string get_Error_CentralPackageVersions_VersionsNotAllowed();
    internal static string get_Error_ClientCertificateAlreadyExist();
    internal static string get_Error_ClientCertificateNotExist();
    internal static string get_Error_ClientCertificatesNotFound();
    internal static string get_Error_ClientCertificateTypeMismatch();
    internal static string get_Error_CouldNotAdd();
    internal static string get_Error_CouldNotList();
    internal static string get_Error_CouldNotRemove();
    internal static string get_Error_CouldNotSync();
    internal static string get_Error_CouldNotUpdateClientCertificate();
    internal static string get_Error_CouldNotUpdateMetadataLastAccessTime();
    internal static string get_Error_EmptyCertificateListInRepository();
    internal static string get_Error_EmptySourceFilePath();
    internal static string get_Error_EmptySourceFileProjectDirectory();
    internal static string get_Error_HttpSource_Single();
    internal static string get_Error_HttpSource_Single_Short();
    internal static string get_Error_HttpSources_Multiple();
    internal static string get_Error_IncompatiblePackageType();
    internal static string get_Error_InputFileNotSpecified();
    internal static string get_Error_InvalidATF();
    internal static string get_Error_InvalidCertificateInformationFromServer();
    internal static string get_Error_InvalidCombinationOfArguments();
    internal static string get_Error_InvalidCommandLineInput();
    internal static string get_Error_InvalidCommandLineInputConfig();
    internal static string get_Error_InvalidCommandLineInputJson();
    internal static string get_Error_InvalidDependencyVersionConstraints();
    internal static string get_Error_InvalidLockFileInput();
    internal static string get_Error_InvalidNuGetAuditLevelValue();
    internal static string get_Error_InvalidNuGetAuditModeValue();
    internal static string get_Error_InvalidNuGetAuditValue();
    internal static string get_Error_InvalidProjectPackageCombo();
    internal static string get_Error_InvalidSymbolPackageFormat();
    internal static string get_Error_InvalidTargetFramework();
    internal static string get_Error_InvalidWindowsTargetPlatformMinVersion();
    internal static string get_Error_MissingSourceParameter();
    internal static string get_Error_MultiplePackagePaths();
    internal static string get_Error_NoClientAllowList();
    internal static string get_Error_NoMatchingCertificate();
    internal static string get_Error_NoMatchingClientCertificate();
    internal static string get_Error_NoPackageVersionsExist();
    internal static string get_Error_NoPackageVersionsExistInRange();
    internal static string get_Error_NoSignatureTrustedForPackage();
    internal static string get_Error_NoSourcesInformation();
    internal static string get_Error_NoStablePackageVersionsExist();
    internal static string get_Error_NotSupportedHashAlgorithm();
    internal static string get_Error_PackageCommandNoFilesForLibPackage();
    internal static string get_Error_PackageCommandNoFilesForSymbolsPackage();
    internal static string get_Error_PackageDownload_NoVersion();
    internal static string get_Error_PackageDownload_OnlyExactVersionsAreAllowed();
    internal static string get_Error_PackageNotSigned();
    internal static string get_Error_PackageValidationFailed();
    internal static string get_Error_PackFailed();
    internal static string get_Error_PlatformVersionNotPresent();
    internal static string get_Error_ProjectDoesNotExist();
    internal static string get_Error_ProjectRuntimeJsonIsUnreadable();
    internal static string get_Error_ProjectRuntimeJsonNotFound();
    internal static string get_Error_ProjectWithIncorrectDependenciesCount();
    internal static string get_Error_PropertyCannotBeNullOrEmpty();
    internal static string get_Error_RepoTrustExpectedRepoSignature();
    internal static string get_Error_RestoreInLockedMode();
    internal static string get_Error_ServiceIndexShouldBeHttps();
    internal static string get_Error_ToolsPackageWithExtraPackageTypes();
    internal static string get_Error_TrustedAuthorNoOwners();
    internal static string get_Error_TrustedRepoAlreadyExists();
    internal static string get_Error_TrustedRepositoryDoesNotExist();
    internal static string get_Error_TrustedSignerAlreadyExists();
    internal static string get_Error_UnableToFindProjectInfo();
    internal static string get_Error_UnableToLocateBuildOutput();
    internal static string get_Error_UnableToLocateRestoreTarget();
    internal static string get_Error_UnableToSignPackage();
    internal static string get_Error_UnavailableSource();
    internal static string get_Error_UnknownBuildAction();
    internal static string get_Error_UnknownClientCertificatesFindBy();
    internal static string get_Error_UnknownClientCertificatesStoreLocation();
    internal static string get_Error_UnknownClientCertificatesStoreName();
    internal static string get_Error_UnknownClientCertificateStoreType();
    internal static string get_Error_UnsupportedTrustTarget();
    internal static string get_Error_VulnerabilityDataFetch();
    internal static string get_Error_WriteResolvedNuSpecOverwriteOriginal();
    internal static string get_Error_XPROJNotAllowed();
    internal static string get_FailedToBuildProject();
    internal static string get_FileNotAddedToPackage();
    internal static string get_FoundVersionsInSource();
    internal static string get_FoundVersionsInSourceWithoutMatch();
    internal static string get_Invalid_AttributeValue();
    internal static string get_InvalidRestoreInput();
    internal static string get_InvalidRestoreInputWithFiles();
    internal static string get_InvalidSource();
    internal static string get_LocalsCommand_ClearedSuccessful();
    internal static string get_LocalsCommand_ClearFailed();
    internal static string get_LocalsCommand_ClearingNuGetGlobalPackagesFolder();
    internal static string get_LocalsCommand_ClearingNuGetHttpCache();
    internal static string get_LocalsCommand_ClearingNuGetPluginsCache();
    internal static string get_LocalsCommand_ClearingNuGetTempCache();
    internal static string get_LocalsCommand_FailedToDeletePath();
    internal static string get_LocalsCommand_Help();
    internal static string get_LocalsCommand_InvalidLocalResourceName();
    internal static string get_LocalsCommand_LocalResourcePathNotSet();
    internal static string get_LocalsCommand_LocalsPartiallyCleared();
    internal static string get_Log_AllProjectsUpToDate();
    internal static string get_Log_AssetsFileNotOnDisk();
    internal static string get_Log_Committing();
    internal static string get_Log_ConfigFileSummary();
    internal static string get_Log_ConvertedPackageToOriginalCase();
    internal static string get_Log_CPVM_DowngradeError();
    internal static string get_Log_CycleDetected();
    internal static string get_Log_DependencyBumpedUp();
    internal static string get_Log_DowngradeWarning();
    internal static string get_Log_ErrorSummary();
    internal static string get_Log_FeedsUsedSummary();
    internal static string get_Log_FrameworkDisplay();
    internal static string get_Log_FrameworkRIDDisplay();
    internal static string get_Log_GeneratingMsBuildFile();
    internal static string get_Log_ImportsFallbackWarning();
    internal static string get_Log_InstalledSummary();
    internal static string get_Log_InstalledSummaryCount();
    internal static string get_Log_LockFileNotOnDisk();
    internal static string get_Log_MergingRuntimes();
    internal static string get_Log_MissingImplementationFx();
    internal static string get_Log_MissingImplementationFxRuntime();
    internal static string get_Log_MissingPackagesOnDisk();
    internal static string get_Log_PackageCommandAddedFile();
    internal static string get_Log_PackageCommandAttemptingToBuildSymbolsPackage();
    internal static string get_Log_PackageCommandInstallPackageToOutputPath();
    internal static string get_Log_PackageCommandSuccess();
    internal static string get_Log_PackageContentHashValidationFailed();
    internal static string get_Log_PackageNotCompatibleWithFx();
    internal static string get_Log_PackageNotCompatibleWithFx_NoSupports();
    internal static string get_Log_PackageNotCompatibleWithFx_Supports();
    internal static string get_Log_PackagesAndProjectsAreCompatible();
    internal static string get_Log_ProjectDoesNotSpecifyTargetFrameworks();
    internal static string get_Log_ProjectNotCompatibleWithFx();
    internal static string get_Log_ProjectNotCompatibleWithFx_NoSupports();
    internal static string get_Log_ProjectNotCompatibleWithFx_Supports();
    internal static string get_Log_ProjectUpToDateSummary();
    internal static string get_Log_PropsFileNotOnDisk();
    internal static string get_Log_ReadingProject();
    internal static string get_Log_ResolverConflict();
    internal static string get_Log_ResolvingConflicts();
    internal static string get_Log_RestoreComplete();
    internal static string get_Log_RestoreCompleteDotnetTool();
    internal static string get_Log_RestoreFailed();
    internal static string get_Log_RestoreFailedDotnetTool();
    internal static string get_Log_RestoreNoOpDGChanged();
    internal static string get_Log_RestoreNoOpFinish();
    internal static string get_Log_RestoringPackages();
    internal static string get_Log_RunningNonParallelRestore();
    internal static string get_Log_RunningParallelRestore();
    internal static string get_Log_ScanningForRuntimeJson();
    internal static string get_Log_SkippingAssetsFile();
    internal static string get_Log_SkippingCacheFile();
    internal static string get_Log_SkippingCompatibiilityCheckOnRidlessGraphForDotnetToolReferenceProject();
    internal static string get_Log_SkippingPackagesLockFileGeneration();
    internal static string get_Log_SourceMappingEnabledNoMatchingPackageSources();
    internal static string get_Log_TargetsFileNotOnDisk();
    internal static string get_Log_ToolSkippingAssetsFile();
    internal static string get_Log_ToolWritingAssetsFile();
    internal static string get_Log_ToolWritingCacheFile();
    internal static string get_Log_UnknownCompatibilityProfile();
    internal static string get_Log_UnresolvedDependency();
    internal static string get_Log_VersionConflict();
    internal static string get_Log_WritingAssetsFile();
    internal static string get_Log_WritingCacheFile();
    internal static string get_Log_WritingPackagesLockFile();
    internal static string get_MissingRequiredProperty();
    internal static string get_MissingRequiredPropertyForProjectType();
    internal static string get_MSBuildWarning_MultiTarget();
    internal static string get_Multiple_Nupkgs_Detected();
    internal static string get_NoClientCertificates();
    internal static string get_NoClientCertificatesMatching();
    internal static string get_NonMatchingProperties();
    internal static string get_NoTrustedSigners();
    internal static string get_NoTrustedSignersMatching();
    internal static string get_NuGetDocs();
    internal static string get_PropertyNotAllowed();
    internal static string get_PropertyNotAllowedForProjectType();
    internal static string get_RegsiteredClientCertificates();
    internal static string get_RegsiteredTrustedSigners();
    internal static string get_ReservedPackageNameAll();
    internal static string get_ResolverRequest_ToStringFormat();
    internal static string get_SignCommandCertificateFileNotFound();
    internal static string get_SignCommandCertificateStoreNotFound();
    internal static string get_SignCommandDialogMessage();
    internal static string get_SignCommandDialogTitle();
    internal static string get_SignCommandDisplayCertificate();
    internal static string get_SignCommandDisplayTimestamper();
    internal static string get_SignCommandInvalidCertException();
    internal static string get_SignCommandInvalidPasswordException();
    internal static string get_SignCommandMultipleCertException();
    internal static string get_SignCommandNoCertException();
    internal static string get_SignCommandOutputPath();
    internal static string get_SignCommandSuccess();
    internal static string get_Source_DefaultNamePrefix();
    internal static string get_Source_InvalidFormatValue();
    internal static string get_SourceNotConsidered();
    internal static string get_SourcesCommandAllNameIsReserved();
    internal static string get_SourcesCommandClearingExistingAuthTypes();
    internal static string get_SourcesCommandCredentialsRequired();
    internal static string get_SourcesCommandCredentialsRequiredWithAuthTypes();
    internal static string get_SourcesCommandDisabled();
    internal static string get_SourcesCommandEnabled();
    internal static string get_SourcesCommandInvalidSource();
    internal static string get_SourcesCommandNoMatchingSourcesFound();
    internal static string get_SourcesCommandNoSources();
    internal static string get_SourcesCommandRegisteredSources();
    internal static string get_SourcesCommandSourceAddedSuccessfully();
    internal static string get_SourcesCommandSourceDisabledSuccessfully();
    internal static string get_SourcesCommandSourceEnabledSuccessfully();
    internal static string get_SourcesCommandSourceRemovedSuccessfully();
    internal static string get_SourcesCommandUniqueName();
    internal static string get_SourcesCommandUniqueSource();
    internal static string get_SourcesCommandUpdateSuccessful();
    internal static string get_SourcesCommandValidProtocolVersion();
    internal static string get_SpecValidation_OriginalTargetFrameworksMustMatchAliases();
    internal static string get_SpecValidationDuplicateFrameworks();
    internal static string get_SpecValidationInvalidFramework();
    internal static string get_SpecValidationMissingProject();
    internal static string get_SpecValidationNoFrameworks();
    internal static string get_SpecValidationUAPSingleFramework();
    internal static string get_SpecValidationZeroRestoreRequests();
    internal static string get_SuccessfullUpdatedTrustedSigner();
    internal static string get_SuccessfullyAddedTrustedAuthor();
    internal static string get_SuccessfullyAddedTrustedRepository();
    internal static string get_SuccessfullyRemovedTrustedSigner();
    internal static string get_SuccessfullySynchronizedTrustedRepository();
    internal static string get_TrustedSignerLogCertificates();
    internal static string get_TrustedSignerLogCertificateSummaryAllowUntrustedRoot();
    internal static string get_TrustedSignerLogCertificateSummaryUnallowUntrustedRoot();
    internal static string get_TrustedSignerLogOwners();
    internal static string get_TrustedSignerLogServiceIndex();
    internal static string get_TrustedSignerLogTitle();
    internal static string get_UnsupportedHashAlgorithm();
    internal static string get_UnsupportedProject();
    internal static string get_VerifyCommand_Failed();
    internal static string get_VerifyCommand_FinishedWithErrors();
    internal static string get_VerifyCommand_NotSupported();
    internal static string get_VerifyCommand_PackageIsNotValid();
    internal static string get_VerifyCommand_Success();
    internal static string get_VerifyCommand_VerificationTypeNotSupported();
    internal static string get_VerifyCommand_VerifyingPackage();
    internal static string get_Vulnerability_Severity_Critical();
    internal static string get_Vulnerability_Severity_High();
    internal static string get_Vulnerability_Severity_Low();
    internal static string get_Vulnerability_Severity_Moderate();
    internal static string get_Vulnerability_Severity_unknown();
    internal static string get_Warning_AuditSourceWithoutVulnerabilityData();
    internal static string get_Warning_CentralPackageVersions_MultipleSourcesWithoutPackageSourceMapping();
    internal static string get_Warning_DuplicatePropertyKey();
    internal static string get_Warning_FileExcludedByDefault();
    internal static string get_Warning_HttpServerUsage();
    internal static string get_Warning_HttpServerUsage_MultipleSources();
    internal static string get_Warning_List_HttpSource();
    internal static string get_Warning_List_HttpSources();
    internal static string get_Warning_MinVersionDoesNotExist();
    internal static string get_Warning_MinVersionNonInclusive();
    internal static string get_Warning_PackageWithKnownVulnerability();
    internal static string get_Warning_ProjectDependencyMissingLowerBound();
    internal static string get_Warning_ProjectDependencyMissingVersion();
    internal static string get_Warning_VersionAboveUpperBound();
    internal static string get_WarningAsError();
}
public enum NuGet.Commands.SymbolPackageFormat : Enum {
    public int value__;
    public static SymbolPackageFormat Snupkg;
    public static SymbolPackageFormat SymbolsNupkg;
}
public static class NuGet.Commands.ToolRestoreUtility : object {
    public static PackageSpec GetSpec(string projectFilePath, string id, VersionRange versionRange, NuGetFramework framework, string packagesPath, IList`1<string> fallbackFolders, IList`1<PackageSource> sources, WarningProperties projectWideWarningProperties);
    public static string GetUniqueName(string id, string framework, VersionRange versionRange);
    public static IReadOnlyList`1<RestoreSummaryRequest> GetSubSetRequests(IEnumerable`1<RestoreSummaryRequest> requestSummaries);
    public static IReadOnlyList`1<RestoreSummaryRequest> GetSubSetRequestsForSingleId(IEnumerable`1<RestoreSummaryRequest> requests);
    public static string GetToolIdOrNullFromSpec(PackageSpec spec);
    public static LibraryDependency GetToolDependencyOrNullFromSpec(PackageSpec spec);
    public static LockFileTargetLibrary GetToolTargetLibrary(LockFile toolLockFile, string toolId);
}
public static class NuGet.Commands.TransitiveNoWarnUtils : object {
    public static WarningPropertiesCollection CreateTransitiveWarningPropertiesCollection(IEnumerable`1<RestoreTargetGraph> targetGraphs, PackageSpec parentProjectSpec);
    private static PackageSpecificWarningProperties ExtractTransitiveNoWarnProperties(RestoreTargetGraph targetGraph, string parentProjectName, HashSet`1<NuGetLogCode> parentProjectWideNoWarn, Dictionary`2<string, HashSet`1<NuGetLogCode>> parentPackageSpecificNoWarn, Dictionary`2<string, Dictionary`2<NuGetFramework, WarningPropertiesCollection>> warningPropertiesCache);
    private static WarningPropertiesCollection GetNodeWarningProperties(PackageSpec nodeProjectSpec, NuGetFramework framework, Dictionary`2<string, Dictionary`2<NuGetFramework, WarningPropertiesCollection>> warningPropertiesCache);
    private static bool AddToSeen(Dictionary`2<string, NodeWarningProperties> seen, DependencyNode node);
    private static void AddDependenciesToQueue(IEnumerable`1<LibraryDependency> dependencies, Queue`1<DependencyNode> queue, NodeWarningProperties nodeWarningProperties);
    private static PackageSpec GetNodePackageSpec(LocalMatch localMatch);
    public static HashSet`1<NuGetLogCode> ExtractPathNoWarnProperties(NodeWarningProperties nodeWarningProperties, string libraryId);
    public static HashSet`1<NuGetLogCode> MergeCodes(HashSet`1<NuGetLogCode> first, HashSet`1<NuGetLogCode> second);
    public static Dictionary`2<string, HashSet`1<NuGetLogCode>> MergePackageSpecificNoWarn(Dictionary`2<string, HashSet`1<NuGetLogCode>> first, Dictionary`2<string, HashSet`1<NuGetLogCode>> second);
    public static PackageSpecificWarningProperties MergePackageSpecificWarningProperties(PackageSpecificWarningProperties first, PackageSpecificWarningProperties second);
    public static bool TryMergeNullObjects(T first, T second, T& merged);
    private static bool IsProject(LibraryDependencyTarget type);
    private static bool IsProject(LibraryType type);
    public static Dictionary`2<NuGetFramework, Dictionary`2<string, HashSet`1<NuGetLogCode>>> ExtractPackageSpecificNoWarnPerFramework(PackageSpecificWarningProperties packageSpecificWarningProperties);
    public static Dictionary`2<string, HashSet`1<NuGetLogCode>> ExtractPackageSpecificNoWarnForFramework(PackageSpecificWarningProperties packageSpecificWarningProperties, NuGetFramework framework);
}
public class NuGet.Commands.TrustedSignerActionsProvider : object {
    private ITrustedSignersProvider _trustedSignersProvider;
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private SourceRepository <ServiceIndexSourceRepository>k__BackingField;
    internal SourceRepository ServiceIndexSourceRepository { get; internal set; }
    public TrustedSignerActionsProvider(ITrustedSignersProvider trustedSignersProvider, ILogger logger);
    [CompilerGeneratedAttribute]
internal SourceRepository get_ServiceIndexSourceRepository();
    [CompilerGeneratedAttribute]
internal void set_ServiceIndexSourceRepository(SourceRepository value);
    [AsyncStateMachineAttribute("NuGet.Commands.TrustedSignerActionsProvider/<SyncTrustedRepositoryAsync>d__7")]
public Task SyncTrustedRepositoryAsync(string name, CancellationToken token);
    public void AddOrUpdateTrustedSigner(string name, string fingerprint, HashAlgorithmName hashAlgorithm, bool allowUntrustedRoot);
    [AsyncStateMachineAttribute("NuGet.Commands.TrustedSignerActionsProvider/<AddTrustedRepositoryAsync>d__9")]
public Task AddTrustedRepositoryAsync(string name, Uri serviceIndex, IEnumerable`1<string> owners, CancellationToken token);
    private void ValidateNoExistingSigner(string name, string serviceIndex, bool validateServiceIndex);
    [AsyncStateMachineAttribute("NuGet.Commands.TrustedSignerActionsProvider/<GetCertificateItemsFromServiceIndexAsync>d__11")]
private Task`1<CertificateItem[]> GetCertificateItemsFromServiceIndexAsync(string serviceIndex, CancellationToken token);
    private string CreateOwnersList(IEnumerable`1<string> owners);
}
public class NuGet.Commands.TrustedSignersArgs : object {
    [CompilerGeneratedAttribute]
private TrustedSignersAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServiceIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateFingerprint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FingerprintAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUntrustedRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Author>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagePath>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    public TrustedSignersAction Action { get; public set; }
    public string Name { get; public set; }
    public string ServiceIndex { get; public set; }
    public string CertificateFingerprint { get; public set; }
    public string FingerprintAlgorithm { get; public set; }
    public bool AllowUntrustedRoot { get; public set; }
    public bool Author { get; public set; }
    public bool Repository { get; public set; }
    public IEnumerable`1<string> Owners { get; public set; }
    public string PackagePath { get; public set; }
    public ILogger Logger { get; public set; }
    [CompilerGeneratedAttribute]
public TrustedSignersAction get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(TrustedSignersAction value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_ServiceIndex();
    [CompilerGeneratedAttribute]
public void set_ServiceIndex(string value);
    [CompilerGeneratedAttribute]
public string get_CertificateFingerprint();
    [CompilerGeneratedAttribute]
public void set_CertificateFingerprint(string value);
    [CompilerGeneratedAttribute]
public string get_FingerprintAlgorithm();
    [CompilerGeneratedAttribute]
public void set_FingerprintAlgorithm(string value);
    [CompilerGeneratedAttribute]
public bool get_AllowUntrustedRoot();
    [CompilerGeneratedAttribute]
public void set_AllowUntrustedRoot(bool value);
    [CompilerGeneratedAttribute]
public bool get_Author();
    [CompilerGeneratedAttribute]
public void set_Author(bool value);
    [CompilerGeneratedAttribute]
public bool get_Repository();
    [CompilerGeneratedAttribute]
public void set_Repository(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Owners();
    [CompilerGeneratedAttribute]
public void set_Owners(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_PackagePath();
    [CompilerGeneratedAttribute]
public void set_PackagePath(string value);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
}
public class NuGet.Commands.TrustedSignersCommandRunner : object {
    private static int SuccessCode;
    private ITrustedSignersProvider _trustedSignersProvider;
    private IPackageSourceProvider _packageSourceProvider;
    public TrustedSignersCommandRunner(ITrustedSignersProvider trustedSignersProvider, IPackageSourceProvider packageSourceProvider);
    [AsyncStateMachineAttribute("NuGet.Commands.TrustedSignersCommandRunner/<ExecuteCommandAsync>d__4")]
public sealed virtual Task`1<int> ExecuteCommandAsync(TrustedSignersArgs trustedSignersArgs);
    [AsyncStateMachineAttribute("NuGet.Commands.TrustedSignersCommandRunner/<ListAllTrustedSignersAsync>d__5")]
private Task ListAllTrustedSignersAsync(ILogger logger);
    [AsyncStateMachineAttribute("NuGet.Commands.TrustedSignersCommandRunner/<RemoveTrustedSignerAsync>d__6")]
private Task RemoveTrustedSignerAsync(string name, ILogger logger);
    private void ValidateListArguments(TrustedSignersArgs args);
    private void ValidateRemoveArguments(TrustedSignersArgs args);
    private void ValidateSyncArguments(TrustedSignersArgs args);
    private void ValidateNameExists(string name);
    private HashAlgorithmName ValidateAndParseFingerprintAlgorithm(string algorithm);
    private Uri ValidateAndParseV3ServiceIndexUrl(string serviceIndex);
}
[ExtensionAttribute]
internal static class NuGet.Commands.UnexpectedDependencyMessages : object {
    [AsyncStateMachineAttribute("NuGet.Commands.UnexpectedDependencyMessages/<LogAsync>d__0")]
public static Task LogAsync(IEnumerable`1<IRestoreTargetGraph> graphs, PackageSpec project, ILogger logger);
    public static IEnumerable`1<RestoreLogMessage> GetMissingLowerBounds(IEnumerable`1<IRestoreTargetGraph> graphs, ISet`1<string> ignoreIds);
    public static RestoreLogMessage GetMissingLowerBoundMessage(ResolvedDependencyKey dependency, String[] targetGraphs);
    public static IEnumerable`1<RestoreLogMessage> GetBumpedUpDependencies(List`1<IndexedRestoreTargetGraph> graphs, PackageSpec project, ISet`1<string> ignoreIds);
    internal static IEnumerable`1<RestoreLogMessage> GetProjectDependenciesMissingVersion(PackageSpec project);
    public static IEnumerable`1<RestoreLogMessage> GetProjectDependenciesMissingLowerBounds(PackageSpec project);
    public static bool DependencyRangeHasMissingExactMatch(ResolvedDependencyKey dependency);
    public static bool HasMissingLowerBound(VersionRange range);
    public static IEnumerable`1<RestoreLogMessage> GetDependenciesAboveUpperBounds(List`1<IndexedRestoreTargetGraph> graphs, ILogger logger);
    [ExtensionAttribute]
private static bool IsNonFloatingPackageDependency(LibraryDependency dependency);
    private static String[] GetDependencyTargetGraphs(PackageSpec spec, LibraryDependency dependency);
}
internal static class NuGet.Commands.UnresolvedMessages : object {
    [AsyncStateMachineAttribute("NuGet.Commands.UnresolvedMessages/<LogAsync>d__0")]
internal static Task LogAsync(IEnumerable`1<IRestoreTargetGraph> graphs, RemoteWalkContext context, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.UnresolvedMessages/<LogAsync>d__1")]
internal static Task LogAsync(IList`1<DownloadDependencyResolutionResult> downloadDependencyResults, RemoteWalkContext context, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.UnresolvedMessages/<GetMessageAsync>d__2")]
internal static Task`1<RestoreLogMessage> GetMessageAsync(string targetGraphName, LibraryRange unresolved, IList`1<IRemoteDependencyProvider> applicableRemoteLibraryProviders, bool isPackageSourceMappingEnabled, IList`1<IRemoteDependencyProvider> allRemoteLibraryProviders, SourceCacheContext sourceCacheContext, ILogger logger, CancellationToken token);
    private static IEnumerable`1<IRemoteDependencyProvider> GetUnusedLibraryProviders(IList`1<IRemoteDependencyProvider> applicableRemoteLibraryProviders, IList`1<IRemoteDependencyProvider> allRemoteLibraryProviders);
    private static string FormatProviderNames(IEnumerable`1<IRemoteDependencyProvider> allRemoteLibraryProviders);
    internal static bool HasPrereleaseVersionsOnly(VersionRange range, IEnumerable`1<NuGetVersion> versions);
    internal static bool IsPrereleaseAllowed(VersionRange range);
    internal static string FormatSourceInfo(KeyValuePair`2<PackageSource, SortedSet`1<NuGetVersion>> sourceInfo, VersionRange range);
    [AsyncStateMachineAttribute("NuGet.Commands.UnresolvedMessages/<GetSourceInfosForIdAsync>d__8")]
internal static Task`1<List`1<KeyValuePair`2<PackageSource, SortedSet`1<NuGetVersion>>>> GetSourceInfosForIdAsync(string id, IList`1<IRemoteDependencyProvider> remoteLibraryProviders, SourceCacheContext sourceCacheContext, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.Commands.UnresolvedMessages/<GetSourceInfoForIdAsync>d__9")]
internal static Task`1<KeyValuePair`2<PackageSource, SortedSet`1<NuGetVersion>>> GetSourceInfoForIdAsync(IRemoteDependencyProvider provider, string id, SourceCacheContext cacheContext, ILogger logger, CancellationToken token);
    internal static NuGetVersion GetBestMatch(SortedSet`1<NuGetVersion> versions, VersionRange range);
}
public class NuGet.Commands.UpdateClientCertArgs : object {
    [CompilerGeneratedAttribute]
private string <PackageSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StorePasswordInClearText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StoreLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StoreName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FindBy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FindValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Force>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configfile>k__BackingField;
    public string PackageSource { get; public set; }
    public string Path { get; public set; }
    public string Password { get; public set; }
    public bool StorePasswordInClearText { get; public set; }
    public string StoreLocation { get; public set; }
    public string StoreName { get; public set; }
    public string FindBy { get; public set; }
    public string FindValue { get; public set; }
    public bool Force { get; public set; }
    public string Configfile { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_PackageSource();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackageSource(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Path(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Password();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Password(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_StorePasswordInClearText();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StorePasswordInClearText(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_StoreLocation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StoreLocation(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_StoreName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StoreName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FindBy();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FindBy(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FindValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FindValue(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Force();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Force(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Configfile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Configfile(string value);
}
public static class NuGet.Commands.UpdateClientCertRunner : object {
    public static void Run(UpdateClientCertArgs args, Func`1<ILogger> getLogger);
}
public class NuGet.Commands.UpdateSourceArgs : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StorePasswordInClearText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ValidAuthenticationTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configfile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowInsecureConnections>k__BackingField;
    public string Name { get; public set; }
    public string Source { get; public set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public bool StorePasswordInClearText { get; public set; }
    public string ValidAuthenticationTypes { get; public set; }
    public string ProtocolVersion { get; public set; }
    public string Configfile { get; public set; }
    public bool AllowInsecureConnections { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public bool get_StorePasswordInClearText();
    [CompilerGeneratedAttribute]
public void set_StorePasswordInClearText(bool value);
    [CompilerGeneratedAttribute]
public string get_ValidAuthenticationTypes();
    [CompilerGeneratedAttribute]
public void set_ValidAuthenticationTypes(string value);
    [CompilerGeneratedAttribute]
public string get_ProtocolVersion();
    [CompilerGeneratedAttribute]
public void set_ProtocolVersion(string value);
    [CompilerGeneratedAttribute]
public string get_Configfile();
    [CompilerGeneratedAttribute]
public void set_Configfile(string value);
    [CompilerGeneratedAttribute]
public bool get_AllowInsecureConnections();
    [CompilerGeneratedAttribute]
public void set_AllowInsecureConnections(bool value);
}
public static class NuGet.Commands.UpdateSourceRunner : object {
    public static void Run(UpdateSourceArgs args, Func`1<ILogger> getLogger);
}
public class NuGet.Commands.VerifyArgs : object {
    [CompilerGeneratedAttribute]
private IList`1<Verification> <Verifications>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PackagePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <CertificateFingerprint>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettings <Settings>k__BackingField;
    public IList`1<Verification> Verifications { get; public set; }
    [ObsoleteAttribute("Use PackagePaths instead")]
public string PackagePath { get; public set; }
    public IReadOnlyList`1<string> PackagePaths { get; public set; }
    public ILogger Logger { get; public set; }
    public LogLevel LogLevel { get; public set; }
    public IEnumerable`1<string> CertificateFingerprint { get; public set; }
    public ISettings Settings { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<Verification> get_Verifications();
    [CompilerGeneratedAttribute]
public void set_Verifications(IList`1<Verification> value);
    public string get_PackagePath();
    public void set_PackagePath(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_PackagePaths();
    [CompilerGeneratedAttribute]
public void set_PackagePaths(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(ILogger value);
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public void set_LogLevel(LogLevel value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_CertificateFingerprint();
    [CompilerGeneratedAttribute]
public void set_CertificateFingerprint(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public ISettings get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(ISettings value);
}
public class NuGet.Commands.VerifyCommandRunner : object {
    private static int SuccessCode;
    private static int FailureCode;
    private static HashAlgorithmName _defaultFingerprintAlgorithm;
    [AsyncStateMachineAttribute("NuGet.Commands.VerifyCommandRunner/<ExecuteCommandAsync>d__3")]
public sealed virtual Task`1<int> ExecuteCommandAsync(VerifyArgs verifyArgs);
    [AsyncStateMachineAttribute("NuGet.Commands.VerifyCommandRunner/<VerifySignatureForPackageAsync>d__4")]
private Task`1<int> VerifySignatureForPackageAsync(string packagePath, ILogger logger, PackageSignatureVerifier verifier, SignedPackageVerifierSettings verifierSettings);
    private bool ShouldExecuteVerification(VerifyArgs args, Verification v);
    private bool IsSignatureVerifyCommandSupported();
}
internal class NuGet.Commands.VirtualFileInfo : object {
    private string _path;
    private bool _isDirectory;
    private string _name;
    public bool Exists { get; }
    public bool IsDirectory { get; }
    public DateTimeOffset LastModified { get; }
    public long Length { get; }
    public string Name { get; }
    public string PhysicalPath { get; }
    public VirtualFileInfo(string path);
    public VirtualFileInfo(string path, bool isDirectory);
    public sealed virtual bool get_Exists();
    public sealed virtual bool get_IsDirectory();
    public sealed virtual DateTimeOffset get_LastModified();
    public sealed virtual long get_Length();
    public sealed virtual string get_Name();
    public sealed virtual string get_PhysicalPath();
    public sealed virtual Stream CreateReadStream();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.Commands.VulnerabilityInformationProvider : object {
    private SourceRepository _source;
    private ILogger _logger;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AsyncLazy`1<GetVulnerabilityInfoResult> _vulnerabilityInfo;
    [CompilerGeneratedAttribute]
private bool <IsAuditSource>k__BackingField;
    public bool IsAuditSource { get; }
    public string SourceName { get; }
    public VulnerabilityInformationProvider(SourceRepository source, ILogger logger, bool isAuditSource);
    [AsyncStateMachineAttribute("NuGet.Commands.VulnerabilityInformationProvider/<GetVulnerabilityInformationAsync>d__4")]
public sealed virtual Task`1<GetVulnerabilityInfoResult> GetVulnerabilityInformationAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAuditSource();
    public sealed virtual string get_SourceName();
    [AsyncStateMachineAttribute("NuGet.Commands.VulnerabilityInformationProvider/<GetVulnerabilityInfoAsync>d__10")]
private Task`1<GetVulnerabilityInfoResult> GetVulnerabilityInfoAsync();
}
public class NuGet.Commands.WarningPropertiesCollection : object {
    private ConcurrentDictionary`2<string, NuGetFramework> _getFrameworkCache;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<NuGetFramework> <ProjectFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private WarningProperties <ProjectWideWarningProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSpecificWarningProperties <PackageSpecificWarningProperties>k__BackingField;
    public IReadOnlyList`1<NuGetFramework> ProjectFrameworks { get; }
    public WarningProperties ProjectWideWarningProperties { get; }
    public PackageSpecificWarningProperties PackageSpecificWarningProperties { get; }
    public WarningPropertiesCollection(WarningProperties projectWideWarningProperties, PackageSpecificWarningProperties packageSpecificWarningProperties, IReadOnlyList`1<NuGetFramework> projectFrameworks);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<NuGetFramework> get_ProjectFrameworks();
    [CompilerGeneratedAttribute]
public WarningProperties get_ProjectWideWarningProperties();
    [CompilerGeneratedAttribute]
public PackageSpecificWarningProperties get_PackageSpecificWarningProperties();
    public bool ApplyWarningProperties(IRestoreLogMessage message);
    public bool ApplyNoWarnProperties(IRestoreLogMessage message);
    public void ApplyWarningAsErrorProperties(IRestoreLogMessage message);
    private bool ApplyPackageSpecificNoWarnProperties(IRestoreLogMessage message);
    public static bool ApplyProjectWideNoWarnProperties(ILogMessage message, WarningProperties warningProperties);
    public static void ApplyProjectWideWarningsAsErrorProperties(ILogMessage message, WarningProperties warningProperties);
    private NuGetFramework GetNuGetFramework(string targetGraph);
    private static NuGetFramework GetNuGetFrameworkFromTargetGraph(string targetGraph);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(WarningPropertiesCollection other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
    [ExtensionAttribute]
public static void AppendInt(StringBuilder sb, int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class NuGet.Shared.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
internal static class NuGet.Shared.XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.TaskResultCache`2 : object {
    private ConcurrentDictionary`2<TKey, Task`1<TValue>> _cache;
    private ConcurrentDictionary`2<TKey, object> _perTaskLock;
    public TaskResultCache`2(IEqualityComparer`1<TKey> comparer);
    public Task`1<TValue> GetOrAddAsync(TKey key, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
    public Task`1<TValue> GetOrAddAsync(TKey key, bool refresh, Func`2<TState, Task`1<TValue>> valueFactory, TState state, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.DeconstructionExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
