[DebuggerDisplayAttribute("Count = {InnerExceptions.Count}")]
public class System.AggregateException : Exception {
    private ReadOnlyCollection`1<Exception> m_innerExceptions;
    public ReadOnlyCollection`1<Exception> InnerExceptions { get; }
    public AggregateException(string message);
    public AggregateException(string message, Exception innerException);
    public AggregateException(IEnumerable`1<Exception> innerExceptions);
    public AggregateException(Exception[] innerExceptions);
    public AggregateException(string message, IEnumerable`1<Exception> innerExceptions);
    public AggregateException(string message, Exception[] innerExceptions);
    private AggregateException(string message, IList`1<Exception> innerExceptions);
    [SecurityCriticalAttribute]
protected AggregateException(SerializationInfo info, StreamingContext context);
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Exception GetBaseException();
    public ReadOnlyCollection`1<Exception> get_InnerExceptions();
    public void Handle(Func`2<Exception, bool> predicate);
    public AggregateException Flatten();
    public virtual string ToString();
}
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.SystemThreadingCollections_BlockingCollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}, Type = {m_collection}")]
[ComVisibleAttribute("False")]
public class System.Collections.Concurrent.BlockingCollection`1 : object {
    private static int NON_BOUNDED;
    private static int COMPLETE_ADDING_ON_MASK;
    private IProducerConsumerCollection`1<T> m_collection;
    private int m_boundedCapacity;
    private SemaphoreSlim m_freeNodes;
    private SemaphoreSlim m_occupiedNodes;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_isDisposed;
    private CancellationTokenSource m_ConsumersCancellationTokenSource;
    private CancellationTokenSource m_ProducersCancellationTokenSource;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_currentAdders;
    public int BoundedCapacity { get; }
    public bool IsAddingCompleted { get; }
    public bool IsCompleted { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public BlockingCollection`1(int boundedCapacity);
    public BlockingCollection`1(IProducerConsumerCollection`1<T> collection, int boundedCapacity);
    public BlockingCollection`1(IProducerConsumerCollection`1<T> collection);
    public int get_BoundedCapacity();
    public bool get_IsAddingCompleted();
    public bool get_IsCompleted();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private void Initialize(IProducerConsumerCollection`1<T> collection, int boundedCapacity, int collectionCount);
    public void Add(T item);
    public void Add(T item, CancellationToken cancellationToken);
    public bool TryAdd(T item);
    public bool TryAdd(T item, TimeSpan timeout);
    public bool TryAdd(T item, int millisecondsTimeout);
    public bool TryAdd(T item, int millisecondsTimeout, CancellationToken cancellationToken);
    private bool TryAddWithNoTimeValidation(T item, int millisecondsTimeout, CancellationToken cancellationToken);
    public T Take();
    public T Take(CancellationToken cancellationToken);
    public bool TryTake(T& item);
    public bool TryTake(T& item, TimeSpan timeout);
    public bool TryTake(T& item, int millisecondsTimeout);
    public bool TryTake(T& item, int millisecondsTimeout, CancellationToken cancellationToken);
    private bool TryTakeWithNoTimeValidation(T& item, int millisecondsTimeout, CancellationToken cancellationToken, CancellationTokenSource combinedTokenSource);
    public static int AddToAny(BlockingCollection`1[] collections, T item);
    public static int AddToAny(BlockingCollection`1[] collections, T item, CancellationToken cancellationToken);
    public static int TryAddToAny(BlockingCollection`1[] collections, T item);
    public static int TryAddToAny(BlockingCollection`1[] collections, T item, TimeSpan timeout);
    public static int TryAddToAny(BlockingCollection`1[] collections, T item, int millisecondsTimeout);
    public static int TryAddToAny(BlockingCollection`1[] collections, T item, int millisecondsTimeout, CancellationToken cancellationToken);
    private static int TryAddTakeAny(BlockingCollection`1[] collections, T& item, int millisecondsTimeout, OperationMode<T> operationMode, CancellationToken externalCancellationToken);
    private static List`1<WaitHandle> GetHandles(BlockingCollection`1[] collections, OperationMode<T> operationMode, CancellationToken externalCancellationToken, bool excludeCompleted, CancellationToken[]& cancellationTokens);
    private static int WaitHandle_WaitAny(List`1<WaitHandle> handles, int millisecondsTimeout, CancellationToken combinedToken, CancellationToken externalToken);
    private static int UpdateTimeOut(long startTimeTicks, int originalWaitMillisecondsTimeout);
    public static int TakeFromAny(BlockingCollection`1[] collections, T& item);
    public static int TakeFromAny(BlockingCollection`1[] collections, T& item, CancellationToken cancellationToken);
    public static int TryTakeFromAny(BlockingCollection`1[] collections, T& item);
    public static int TryTakeFromAny(BlockingCollection`1[] collections, T& item, TimeSpan timeout);
    public static int TryTakeFromAny(BlockingCollection`1[] collections, T& item, int millisecondsTimeout);
    public static int TryTakeFromAny(BlockingCollection`1[] collections, T& item, int millisecondsTimeout, CancellationToken cancellationToken);
    public void CompleteAdding();
    private void CancelWaitingConsumers();
    private void CancelWaitingProducers();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public T[] ToArray();
    public void CopyTo(T[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public IEnumerable`1<T> GetConsumingEnumerable();
    public IEnumerable`1<T> GetConsumingEnumerable(CancellationToken cancellationToken);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static BlockingCollection`1[] ValidateCollectionsArray(BlockingCollection`1[] collections, OperationMode<T> operationMode);
    private static void ValidateTimeout(TimeSpan timeout);
    private static void ValidateMillisecondsTimeout(int millisecondsTimeout);
    private void CheckDisposed();
}
[DebuggerDisplayAttribute("Count = {Count}")]
[ComVisibleAttribute("False")]
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.SystemThreadingCollection_IProducerConsumerCollectionDebugView`1")]
public class System.Collections.Concurrent.ConcurrentBag`1 : object {
    private ThreadLocal`1<ThreadLocalList<T>> m_locals;
    private ThreadLocalList modreq(System.Runtime.CompilerServices.IsVolatile) m_headList;
    private ThreadLocalList modreq(System.Runtime.CompilerServices.IsVolatile) m_tailList;
    private object m_globalListsLock;
    private bool m_needSync;
    private T[] m_serializationArray;
    public int Count { get; }
    public bool IsEmpty { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public ConcurrentBag`1(IEnumerable`1<T> collection);
    private void Initialize(IEnumerable`1<T> collection);
    public void Add(T item);
    private void AddInternal(ThreadLocalList<T> list, T item);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
    public sealed virtual bool TryTake(T& result);
    public bool TryPeek(T& result);
    private bool TryTakeOrPeek(T& result, bool take);
    private ThreadLocalList<T> GetThreadList(bool forceCreate);
    private ThreadLocalList<T> GetUnownedList();
    private bool Steal(T& result, bool take);
    private bool TrySteal(ThreadLocalList<T> list, T& result, bool take);
    private bool CanSteal(ThreadLocalList<T> list);
    public sealed virtual void CopyTo(T[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual T[] ToArray();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext context);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private void FreezeBag(Boolean& lockTaken);
    private void UnfreezeBag(bool lockTaken);
    private void AcquireAllLocks();
    private void ReleaseAllLocks();
    private void WaitAllOperations();
    private int GetCountInternal();
    private List`1<T> ToList();
}
[ComVisibleAttribute("False")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.Mscorlib_DictionaryDebugView`2")]
public class System.Collections.Concurrent.ConcurrentDictionary`2 : object {
    private static int DEFAULT_CONCURRENCY_MULTIPLIER;
    private static int DEFAULT_CAPACITY;
    private Node[] modreq(System.Runtime.CompilerServices.IsVolatile) m_buckets;
    private Object[] m_locks;
    private Int32[] modreq(System.Runtime.CompilerServices.IsVolatile) m_countPerLock;
    private IEqualityComparer`1<TKey> m_comparer;
    private KeyValuePair`2[] m_serializationArray;
    private int m_serializationConcurrencyLevel;
    private int m_serializationCapacity;
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private static int DefaultConcurrencyLevel { get; }
    public ConcurrentDictionary`2(int concurrencyLevel, int capacity);
    public ConcurrentDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public ConcurrentDictionary`2(IEqualityComparer`1<TKey> comparer);
    public ConcurrentDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    public ConcurrentDictionary`2(int concurrencyLevel, IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    public ConcurrentDictionary`2(int concurrencyLevel, int capacity, IEqualityComparer`1<TKey> comparer);
    private void InitializeFromCollection(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public bool TryAdd(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public bool TryRemove(TKey key, TValue& value);
    private bool TryRemoveInternal(TKey key, TValue& value, bool matchValue, TValue oldValue);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public bool TryUpdate(TKey key, TValue newValue, TValue comparisonValue);
    public sealed virtual void Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index);
    public KeyValuePair`2[] ToArray();
    private void CopyToPairs(KeyValuePair`2[] array, int index);
    private void CopyToEntries(DictionaryEntry[] array, int index);
    private void CopyToObjects(Object[] array, int index);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private bool TryAddInternal(TKey key, TValue value, bool updateIfExists, bool acquireLock, TValue& resultingValue);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual int get_Count();
    public TValue GetOrAdd(TKey key, Func`2<TKey, TValue> valueFactory);
    public TValue GetOrAdd(TKey key, TValue value);
    public TValue AddOrUpdate(TKey key, Func`2<TKey, TValue> addValueFactory, Func`3<TKey, TValue, TValue> updateValueFactory);
    public TValue AddOrUpdate(TKey key, TValue addValue, Func`3<TKey, TValue, TValue> updateValueFactory);
    public bool get_IsEmpty();
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private void GrowTable(Node[] buckets);
    private void GetBucketAndLockNo(int hashcode, Int32& bucketNo, Int32& lockNo, int bucketCount);
    private static int get_DefaultConcurrencyLevel();
    private void AcquireAllLocks(Int32& locksAcquired);
    private void AcquireLocks(int fromInclusive, int toExclusive, Int32& locksAcquired);
    private void ReleaseLocks(int fromInclusive, int toExclusive);
    private ReadOnlyCollection`1<TKey> GetKeys();
    private ReadOnlyCollection`1<TValue> GetValues();
    [ConditionalAttribute("DEBUG")]
private void Assert(bool condition);
    private string GetResource(string key);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext context);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
}
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[ComVisibleAttribute("False")]
public class System.Collections.Concurrent.ConcurrentQueue`1 : object {
    private static int SEGMENT_SIZE;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) m_head;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) m_tail;
    private T[] m_serializationArray;
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public ConcurrentQueue`1(IEnumerable`1<T> collection);
    private void InitializeFromCollection(IEnumerable`1<T> collection);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext context);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(T& item);
    public bool get_IsEmpty();
    public sealed virtual T[] ToArray();
    private List`1<T> ToList();
    private void GetHeadTailPositions(Segment& head, Segment& tail, Int32& headLow, Int32& tailHigh);
    public sealed virtual int get_Count();
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public void Enqueue(T item);
    public bool TryDequeue(T& result);
    public bool TryPeek(T& result);
}
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public class System.Collections.Concurrent.ConcurrentStack`1 : object {
    private static int BACKOFF_MAX_YIELDS;
    private Node modreq(System.Runtime.CompilerServices.IsVolatile) m_head;
    private T[] m_serializationArray;
    public bool IsEmpty { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public ConcurrentStack`1(IEnumerable`1<T> collection);
    private void InitializeFromCollection(IEnumerable`1<T> collection);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext context);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext context);
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Clear();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual void CopyTo(T[] array, int index);
    public void Push(T item);
    public void PushRange(T[] items);
    public void PushRange(T[] items, int startIndex, int count);
    private void PushCore(Node<T> head, Node<T> tail);
    private void ValidatePushPopRangeInput(T[] items, int startIndex, int count);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
    public bool TryPeek(T& result);
    public bool TryPop(T& result);
    public int TryPopRange(T[] items);
    public int TryPopRange(T[] items, int startIndex, int count);
    private bool TryPopCore(T& result);
    private int TryPopCore(int count, Node& poppedHead);
    private void CopyRemovedItems(Node<T> head, T[] collection, int startIndex, int nodesCount);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(T& item);
    public sealed virtual T[] ToArray();
    private List`1<T> ToList();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private IEnumerator`1<T> GetEnumerator(Node<T> head);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public interface System.Collections.Concurrent.IProducerConsumerCollection`1 {
    public abstract virtual void CopyTo(T[] array, int index);
    public abstract virtual bool TryAdd(T item);
    public abstract virtual bool TryTake(T& item);
    public abstract virtual T[] ToArray();
}
public abstract class System.Collections.Concurrent.OrderablePartitioner`1 : Partitioner`1<TSource> {
    [CompilerGeneratedAttribute]
private bool <KeysOrderedInEachPartition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeysOrderedAcrossPartitions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeysNormalized>k__BackingField;
    public bool KeysOrderedInEachPartition { get; private set; }
    public bool KeysOrderedAcrossPartitions { get; private set; }
    public bool KeysNormalized { get; private set; }
    protected OrderablePartitioner`1(bool keysOrderedInEachPartition, bool keysOrderedAcrossPartitions, bool keysNormalized);
    public abstract virtual IList`1<IEnumerator`1<KeyValuePair`2<long, TSource>>> GetOrderablePartitions(int partitionCount);
    public virtual IEnumerable`1<KeyValuePair`2<long, TSource>> GetOrderableDynamicPartitions();
    [CompilerGeneratedAttribute]
public bool get_KeysOrderedInEachPartition();
    [CompilerGeneratedAttribute]
private void set_KeysOrderedInEachPartition(bool value);
    [CompilerGeneratedAttribute]
public bool get_KeysOrderedAcrossPartitions();
    [CompilerGeneratedAttribute]
private void set_KeysOrderedAcrossPartitions(bool value);
    [CompilerGeneratedAttribute]
public bool get_KeysNormalized();
    [CompilerGeneratedAttribute]
private void set_KeysNormalized(bool value);
    public virtual IList`1<IEnumerator`1<TSource>> GetPartitions(int partitionCount);
    public virtual IEnumerable`1<TSource> GetDynamicPartitions();
}
public static class System.Collections.Concurrent.Partitioner : object {
    private static int DEFAULT_BYTES_PER_CHUNK;
    public static OrderablePartitioner`1<TSource> Create(IList`1<TSource> list, bool loadBalance);
    public static OrderablePartitioner`1<TSource> Create(TSource[] array, bool loadBalance);
    public static OrderablePartitioner`1<TSource> Create(IEnumerable`1<TSource> source);
    internal static OrderablePartitioner`1<TSource> Create(IEnumerable`1<TSource> source, int maxChunkSize);
    private static int GetDefaultChunkSize();
}
public abstract class System.Collections.Concurrent.Partitioner`1 : object {
    public bool SupportsDynamicPartitions { get; }
    public abstract virtual IList`1<IEnumerator`1<TSource>> GetPartitions(int partitionCount);
    public virtual bool get_SupportsDynamicPartitions();
    public virtual IEnumerable`1<TSource> GetDynamicPartitions();
}
internal class System.Collections.Concurrent.SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1 : object {
    private IProducerConsumerCollection`1<T> m_collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public SystemCollectionsConcurrent_ProducerConsumerCollectionDebugView`1(IProducerConsumerCollection`1<T> collection);
    public T[] get_Items();
}
internal class System.Collections.Concurrent.SystemThreadingCollection_IProducerConsumerCollectionDebugView`1 : object {
    private IProducerConsumerCollection`1<T> m_collection;
    public T[] Items { get; }
    public SystemThreadingCollection_IProducerConsumerCollectionDebugView`1(IProducerConsumerCollection`1<T> collection);
    public T[] get_Items();
}
internal class System.Collections.Concurrent.SystemThreadingCollections_BlockingCollectionDebugView`1 : object {
    private BlockingCollection`1<T> m_blockingCollection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public SystemThreadingCollections_BlockingCollectionDebugView`1(BlockingCollection`1<T> collection);
    public T[] get_Items();
}
internal class System.Collections.Generic.Mscorlib_DictionaryDebugView`2 : object {
    private IDictionary`2<K, V> dict;
    [DebuggerBrowsableAttribute("3")]
internal KeyValuePair`2[] Items { get; }
    internal Mscorlib_DictionaryDebugView`2(IDictionary`2<K, V> dictionary);
    internal KeyValuePair`2[] get_Items();
}
internal static class System.Diagnostics.Contracts.Contract : object {
    [ConditionalAttribute("DEBUG")]
internal static void Assert(bool condition);
    [ConditionalAttribute("DEBUG")]
internal static void Assert(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
internal static void Ensures(bool condition);
    [ConditionalAttribute("DEBUG")]
internal static void EndContractBlock();
}
internal static class System.Environment2 : object {
    internal static string GetResourceString(string key);
}
public class System.Func_`6 : MulticastDelegate {
    public Func_`6(object object, IntPtr method);
    public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
[DebuggerDisplayAttribute("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")]
[DebuggerTypeProxyAttribute("System.System_LazyDebugView`1")]
[ComVisibleAttribute("False")]
public class System.Lazy`1 : object {
    private static Func`1<T> PUBLICATION_ONLY_OR_ALREADY_INITIALIZED;
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) m_boxed;
    private Func`1<T> m_valueFactory;
    private object m_threadSafeObj;
    [CompilerGeneratedAttribute]
private static Func`1<T> CS$<>9__CachedAnonymousMethodDelegate1;
    internal T ValueForDebugDisplay { get; }
    internal LazyThreadSafetyMode Mode { get; }
    internal bool IsValueFaulted { get; }
    public bool IsValueCreated { get; }
    [DebuggerBrowsableAttribute("0")]
public T Value { get; }
    public Lazy`1(Func`1<T> valueFactory);
    public Lazy`1(bool isThreadSafe);
    public Lazy`1(LazyThreadSafetyMode mode);
    public Lazy`1(Func`1<T> valueFactory, bool isThreadSafe);
    public Lazy`1(Func`1<T> valueFactory, LazyThreadSafetyMode mode);
    private static Lazy`1();
    private static object GetObjectFromMode(LazyThreadSafetyMode mode);
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext context);
    public virtual string ToString();
    internal T get_ValueForDebugDisplay();
    internal LazyThreadSafetyMode get_Mode();
    internal bool get_IsValueFaulted();
    public bool get_IsValueCreated();
    public T get_Value();
    private T LazyInitValue();
    private Boxed<T> CreateValue();
    [CompilerGeneratedAttribute]
private static T <.cctor>b__0();
}
internal static class System.Linq.AggregationMinMaxHelpers`1 : object {
    [CompilerGeneratedAttribute]
private static Func`2<Pair`2<bool, T>, T> CS$<>9__CachedAnonymousMethodDelegate7;
    private static T Reduce(IEnumerable`1<T> source, int sign);
    internal static T ReduceMin(IEnumerable`1<T> source);
    internal static T ReduceMax(IEnumerable`1<T> source);
    private static Func`3<Pair`2<bool, T>, T, Pair`2<bool, T>> MakeIntermediateReduceFunction(int sign);
    private static Func`3<Pair`2<bool, T>, Pair`2<bool, T>, Pair`2<bool, T>> MakeFinalReduceFunction(int sign);
    private static Func`2<Pair`2<bool, T>, T> MakeResultSelectorFunction();
    [CompilerGeneratedAttribute]
private static T <MakeResultSelectorFunction>b__6(Pair`2<bool, T> accumulator);
}
public class System.Linq.OrderedParallelQuery`1 : ParallelQuery`1<TSource> {
    private QueryOperator`1<TSource> m_sortOp;
    internal QueryOperator`1<TSource> SortOperator { get; }
    internal IOrderedEnumerable`1<TSource> OrderedEnumerable { get; }
    internal OrderedParallelQuery`1(QueryOperator`1<TSource> sortOp);
    internal QueryOperator`1<TSource> get_SortOperator();
    internal IOrderedEnumerable`1<TSource> get_OrderedEnumerable();
    public virtual IEnumerator`1<TSource> GetEnumerator();
}
internal class System.Linq.Parallel.AnyAllSearchOperator`1 : UnaryQueryOperator`2<TInput, bool> {
    private Func`2<TInput, bool> m_predicate;
    private bool m_qualification;
    internal bool LimitsParallelism { get; }
    internal AnyAllSearchOperator`1(IEnumerable`1<TInput> child, bool qualification, Func`2<TInput, bool> predicate);
    internal bool Aggregate();
    internal virtual QueryResults`1<bool> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<bool> recipient, bool preferStriping, QuerySettings settings);
    internal virtual IEnumerable`1<bool> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.ArrayMergeHelper`1 : object {
    private QueryResults`1<TInputOutput> m_queryResults;
    private TInputOutput[] m_outputArray;
    private QuerySettings m_settings;
    public ArrayMergeHelper`1(QuerySettings settings, QueryResults`1<TInputOutput> queryResults);
    private void ToArrayElement(int index);
    public sealed virtual void Execute();
    public sealed virtual IEnumerator`1<TInputOutput> GetEnumerator();
    public sealed virtual TInputOutput[] GetResultsAsArray();
}
internal class System.Linq.Parallel.AssociativeAggregationOperator`3 : UnaryQueryOperator`2<TInput, TIntermediate> {
    private TIntermediate m_seed;
    private bool m_seedIsSpecified;
    private bool m_throwIfEmpty;
    private Func`3<TIntermediate, TInput, TIntermediate> m_intermediateReduce;
    private Func`3<TIntermediate, TIntermediate, TIntermediate> m_finalReduce;
    private Func`2<TIntermediate, TOutput> m_resultSelector;
    private Func`1<TIntermediate> m_seedFactory;
    internal bool LimitsParallelism { get; }
    internal AssociativeAggregationOperator`3(IEnumerable`1<TInput> child, TIntermediate seed, Func`1<TIntermediate> seedFactory, bool seedIsSpecified, Func`3<TIntermediate, TInput, TIntermediate> intermediateReduce, Func`3<TIntermediate, TIntermediate, TIntermediate> finalReduce, Func`2<TIntermediate, TOutput> resultSelector, bool throwIfEmpty, QueryAggregationOptions options);
    internal TOutput Aggregate();
    internal virtual QueryResults`1<TIntermediate> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<TIntermediate> recipient, bool preferStriping, QuerySettings settings);
    internal virtual IEnumerable`1<TIntermediate> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.AsynchronousChannel`1 : object {
    private T[][] m_buffer;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_producerBufferIndex;
    private int m_consumerBufferIndex;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_done;
    private T[] m_producerChunk;
    private int m_producerChunkIndex;
    private T[] m_consumerChunk;
    private int m_consumerChunkIndex;
    private int m_chunkSize;
    private ManualResetEventSlim m_producerEvent;
    private ManualResetEventSlim m_consumerEvent;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_producerIsWaiting;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_consumerIsWaiting;
    private CancellationToken m_cancellationToken;
    internal bool IsFull { get; }
    internal bool IsChunkBufferEmpty { get; }
    internal bool IsDone { get; }
    internal AsynchronousChannel`1(int chunkSize, CancellationToken cancellationToken);
    internal AsynchronousChannel`1(int capacity, int chunkSize, CancellationToken cancellationToken);
    internal bool get_IsFull();
    internal bool get_IsChunkBufferEmpty();
    internal bool get_IsDone();
    internal void FlushBuffers();
    internal void SetDone();
    internal void Enqueue(T item);
    private void EnqueueChunk(T[] chunk);
    private void WaitUntilNonFull();
    private void FlushCachedChunk();
    internal bool TryDequeue(T& item);
    private bool TryDequeueChunk(T[]& chunk);
    internal bool TryDequeue(T& item, ManualResetEventSlim& waitEvent);
    private bool TryDequeueChunk(T[]& chunk, ManualResetEventSlim& waitEvent);
    private T[] InternalDequeueChunk();
    internal void DoneWithDequeueWait();
    public sealed virtual void Dispose();
}
internal class System.Linq.Parallel.AsynchronousChannelMergeEnumerator`1 : MergeEnumerator`1<T> {
    private AsynchronousChannel`1[] m_channels;
    private ManualResetEventSlim[] m_channelEvents;
    private Boolean[] m_done;
    private int m_channelIndex;
    private T m_currentElement;
    public T Current { get; }
    internal AsynchronousChannelMergeEnumerator`1(QueryTaskGroupState taskGroupState, AsynchronousChannel`1[] channels);
    public virtual T get_Current();
    public virtual bool MoveNext();
    private bool MoveNextSlowPath();
    private static int WaitAny(ManualResetEventSlim[] events);
}
internal abstract class System.Linq.Parallel.BinaryQueryOperator`3 : QueryOperator`1<TOutput> {
    private QueryOperator`1<TLeftInput> m_leftChild;
    private QueryOperator`1<TRightInput> m_rightChild;
    private OrdinalIndexState m_indexState;
    internal QueryOperator`1<TLeftInput> LeftChild { get; }
    internal QueryOperator`1<TRightInput> RightChild { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal BinaryQueryOperator`3(ParallelQuery`1<TLeftInput> leftChild, ParallelQuery`1<TRightInput> rightChild);
    internal BinaryQueryOperator`3(QueryOperator`1<TLeftInput> leftChild, QueryOperator`1<TRightInput> rightChild);
    internal QueryOperator`1<TLeftInput> get_LeftChild();
    internal QueryOperator`1<TRightInput> get_RightChild();
    internal sealed virtual OrdinalIndexState get_OrdinalIndexState();
    protected void SetOrdinalIndex(OrdinalIndexState indexState);
    public abstract virtual void WrapPartitionedStream(PartitionedStream`2<TLeftInput, TLeftKey> leftPartitionedStream, PartitionedStream`2<TRightInput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TOutput> outputRecipient, bool preferStriping, QuerySettings settings);
}
internal static class System.Linq.Parallel.CancellableEnumerable : object {
    internal static IEnumerable`1<TElement> Wrap(IEnumerable`1<TElement> source, CancellationToken token);
}
internal class System.Linq.Parallel.CancellationState : object {
    internal static int POLL_INTERVAL;
    internal CancellationTokenSource InternalCancellationTokenSource;
    internal CancellationToken ExternalCancellationToken;
    internal CancellationTokenSource MergedCancellationTokenSource;
    internal Shared`1<bool> TopLevelDisposedFlag;
    internal CancellationToken MergedCancellationToken { get; }
    internal CancellationState(CancellationToken externalCancellationToken);
    internal CancellationToken get_MergedCancellationToken();
    internal static void ThrowIfCanceled(CancellationToken token);
    internal static void ThrowWithStandardMessageIfCanceled(CancellationToken externalCancellationToken);
}
internal class System.Linq.Parallel.ConcatKey`2 : ValueType {
    private TLeftKey m_leftKey;
    private TRightKey m_rightKey;
    private bool m_isLeft;
    private ConcatKey`2(TLeftKey leftKey, TRightKey rightKey, bool isLeft);
    internal static ConcatKey`2<TLeftKey, TRightKey> MakeLeft(TLeftKey leftKey);
    internal static ConcatKey`2<TLeftKey, TRightKey> MakeRight(TRightKey rightKey);
    internal static IComparer`1<ConcatKey`2<TLeftKey, TRightKey>> MakeComparer(IComparer`1<TLeftKey> leftComparer, IComparer`1<TRightKey> rightComparer);
}
internal class System.Linq.Parallel.ConcatQueryOperator`1 : BinaryQueryOperator`3<TSource, TSource, TSource> {
    private bool m_prematureMergeLeft;
    private bool m_prematureMergeRight;
    internal bool LimitsParallelism { get; }
    internal ConcatQueryOperator`1(ParallelQuery`1<TSource> firstChild, ParallelQuery`1<TSource> secondChild);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    public virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TLeftKey> leftStream, PartitionedStream`2<TSource, TRightKey> rightStream, IPartitionedStreamRecipient`1<TSource> outputRecipient, bool preferStriping, QuerySettings settings);
    internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.ContainsSearchOperator`1 : UnaryQueryOperator`2<TInput, bool> {
    private TInput m_searchValue;
    private IEqualityComparer`1<TInput> m_comparer;
    internal bool LimitsParallelism { get; }
    internal ContainsSearchOperator`1(IEnumerable`1<TInput> child, TInput searchValue, IEqualityComparer`1<TInput> comparer);
    internal bool Aggregate();
    internal virtual QueryResults`1<bool> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<bool> recipient, bool preferStriping, QuerySettings settings);
    internal virtual IEnumerable`1<bool> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.CountAggregationOperator`1 : InlinedAggregationOperator`3<TSource, int, int> {
    internal CountAggregationOperator`1(IEnumerable`1<TSource> child);
    protected virtual int InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<int, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<TSource, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.DecimalAverageAggregationOperator : InlinedAggregationOperator`3<decimal, Pair`2<decimal, long>, decimal> {
    internal DecimalAverageAggregationOperator(IEnumerable`1<decimal> child);
    protected virtual decimal InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<decimal, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<decimal, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.DecimalMinMaxAggregationOperator : InlinedAggregationOperator`3<decimal, decimal, decimal> {
    private int m_sign;
    internal DecimalMinMaxAggregationOperator(IEnumerable`1<decimal> child, int sign);
    protected virtual decimal InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<decimal, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<decimal, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.DecimalSumAggregationOperator : InlinedAggregationOperator`3<decimal, decimal, decimal> {
    internal DecimalSumAggregationOperator(IEnumerable`1<decimal> child);
    protected virtual decimal InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<decimal, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<decimal, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.DefaultIfEmptyQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
    private TSource m_defaultValue;
    internal bool LimitsParallelism { get; }
    internal DefaultIfEmptyQueryOperator`1(IEnumerable`1<TSource> child, TSource defaultValue);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings);
    internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.DefaultMergeHelper`2 : object {
    private QueryTaskGroupState m_taskGroupState;
    private PartitionedStream`2<TInputOutput, TIgnoreKey> m_partitions;
    private AsynchronousChannel`1[] m_asyncChannels;
    private SynchronousChannel`1[] m_syncChannels;
    private IEnumerator`1<TInputOutput> m_channelEnumerator;
    private TaskScheduler m_taskScheduler;
    private bool m_ignoreOutput;
    internal DefaultMergeHelper`2(PartitionedStream`2<TInputOutput, TIgnoreKey> partitions, bool ignoreOutput, ParallelMergeOptions options, TaskScheduler taskScheduler, CancellationState cancellationState, int queryId);
    private sealed virtual override void System.Linq.Parallel.IMergeHelper<TInputOutput>.Execute();
    private sealed virtual override IEnumerator`1<TInputOutput> System.Linq.Parallel.IMergeHelper<TInputOutput>.GetEnumerator();
    public sealed virtual TInputOutput[] GetResultsAsArray();
}
internal class System.Linq.Parallel.DistinctQueryOperator`1 : UnaryQueryOperator`2<TInputOutput, TInputOutput> {
    private IEqualityComparer`1<TInputOutput> m_comparer;
    internal bool LimitsParallelism { get; }
    internal DistinctQueryOperator`1(IEnumerable`1<TInputOutput> source, IEqualityComparer`1<TInputOutput> comparer);
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TKey> inputStream, IPartitionedStreamRecipient`1<TInputOutput> recipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TKey> hashStream, IPartitionedStreamRecipient`1<TInputOutput> recipient, CancellationToken cancellationToken);
    internal virtual bool get_LimitsParallelism();
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
}
internal class System.Linq.Parallel.DoubleAverageAggregationOperator : InlinedAggregationOperator`3<double, Pair`2<double, long>, double> {
    internal DoubleAverageAggregationOperator(IEnumerable`1<double> child);
    protected virtual double InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<double, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<double, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.DoubleMinMaxAggregationOperator : InlinedAggregationOperator`3<double, double, double> {
    private int m_sign;
    internal DoubleMinMaxAggregationOperator(IEnumerable`1<double> child, int sign);
    protected virtual double InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<double, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<double, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.DoubleSumAggregationOperator : InlinedAggregationOperator`3<double, double, double> {
    internal DoubleSumAggregationOperator(IEnumerable`1<double> child);
    protected virtual double InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<double, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<double, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.ElementAtQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
    private int m_index;
    private bool m_prematureMerge;
    internal bool LimitsParallelism { get; }
    internal ElementAtQueryOperator`1(IEnumerable`1<TSource> child, int index);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings);
    internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
    internal bool Aggregate(TSource& result, bool withDefaultValue);
}
internal class System.Linq.Parallel.EmptyEnumerable`1 : ParallelQuery`1<T> {
    private static EmptyEnumerable`1<T> s_instance;
    private static EmptyEnumerator`1<T> s_enumeratorInstance;
    internal static EmptyEnumerable`1<T> Instance { get; }
    internal static EmptyEnumerable`1<T> get_Instance();
    public virtual IEnumerator`1<T> GetEnumerator();
}
internal class System.Linq.Parallel.EmptyEnumerator`1 : QueryOperatorEnumerator`2<T, int> {
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal virtual bool MoveNext(T& currentElement, Int32& currentKey);
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
internal class System.Linq.Parallel.EnumerableWrapperWeakToStrong : object {
    private IEnumerable m_wrappedEnumerable;
    internal EnumerableWrapperWeakToStrong(IEnumerable wrappedEnumerable);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<object> GetEnumerator();
}
internal static class System.Linq.Parallel.ExceptionAggregator : object {
    internal static IEnumerable`1<TElement> WrapEnumerable(IEnumerable`1<TElement> source, CancellationState cancellationState);
    internal static IEnumerable`1<TElement> WrapQueryEnumerator(QueryOperatorEnumerator`2<TElement, TIgnoreKey> source, CancellationState cancellationState);
    internal static void ThrowOCEorAggregateException(Exception ex, CancellationState cancellationState);
    internal static Func`2<T, U> WrapFunc(Func`2<T, U> f, CancellationState cancellationState);
    private static bool ThrowAnOCE(Exception ex, CancellationState cancellationState);
}
internal class System.Linq.Parallel.ExceptQueryOperator`1 : BinaryQueryOperator`3<TInputOutput, TInputOutput, TInputOutput> {
    private IEqualityComparer`1<TInputOutput> m_comparer;
    internal bool LimitsParallelism { get; }
    internal ExceptQueryOperator`1(ParallelQuery`1<TInputOutput> left, ParallelQuery`1<TInputOutput> right, IEqualityComparer`1<TInputOutput> comparer);
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    public virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TLeftKey> leftStream, PartitionedStream`2<TInputOutput, TRightKey> rightStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream, PartitionedStream`2<TInputOutput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, CancellationToken cancellationToken);
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
[ExtensionAttribute]
internal static class System.Linq.Parallel.ExchangeUtilities : object {
    internal static PartitionedStream`2<T, int> PartitionDataSource(IEnumerable`1<T> source, int partitionCount, bool useStriping);
    internal static PartitionedStream`2<Pair`2<TElement, THashKey>, int> HashRepartition(PartitionedStream`2<TElement, TIgnoreKey> source, Func`2<TElement, THashKey> keySelector, IEqualityComparer`1<THashKey> keyComparer, IEqualityComparer`1<TElement> elementComparer, CancellationToken cancellationToken);
    internal static PartitionedStream`2<Pair`2<TElement, THashKey>, TOrderKey> HashRepartitionOrdered(PartitionedStream`2<TElement, TOrderKey> source, Func`2<TElement, THashKey> keySelector, IEqualityComparer`1<THashKey> keyComparer, IEqualityComparer`1<TElement> elementComparer, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static OrdinalIndexState Worse(OrdinalIndexState state1, OrdinalIndexState state2);
    [ExtensionAttribute]
internal static bool IsWorseThan(OrdinalIndexState state1, OrdinalIndexState state2);
}
internal class System.Linq.Parallel.FirstQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
    private Func`2<TSource, bool> m_predicate;
    private bool m_prematureMergeNeeded;
    internal bool LimitsParallelism { get; }
    internal FirstQueryOperator`1(IEnumerable`1<TSource> child, Func`2<TSource, bool> predicate);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings);
    internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.FixedMaxHeap`1 : object {
    private TElement[] m_elements;
    private int m_count;
    private IComparer`1<TElement> m_comparer;
    internal int Count { get; }
    internal int Size { get; }
    internal TElement MaxValue { get; }
    internal FixedMaxHeap`1(int maximumSize);
    internal FixedMaxHeap`1(int maximumSize, IComparer`1<TElement> comparer);
    internal int get_Count();
    internal int get_Size();
    internal TElement get_MaxValue();
    internal void Clear();
    internal bool Insert(TElement e);
    internal void ReplaceMax(TElement newValue);
    internal void RemoveMax();
    private void Swap(int i, int j);
    private void HeapifyRoot();
    private void HeapifyLastLeaf();
}
internal class System.Linq.Parallel.FloatAverageAggregationOperator : InlinedAggregationOperator`3<float, Pair`2<double, long>, float> {
    internal FloatAverageAggregationOperator(IEnumerable`1<float> child);
    protected virtual float InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<double, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<float, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.FloatMinMaxAggregationOperator : InlinedAggregationOperator`3<float, float, float> {
    private int m_sign;
    internal FloatMinMaxAggregationOperator(IEnumerable`1<float> child, int sign);
    protected virtual float InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<float, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<float, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.FloatSumAggregationOperator : InlinedAggregationOperator`3<float, double, float> {
    internal FloatSumAggregationOperator(IEnumerable`1<float> child);
    protected virtual float InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<double, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<float, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.ForAllOperator`1 : UnaryQueryOperator`2<TInput, TInput> {
    private Action`1<TInput> m_elementAction;
    internal bool LimitsParallelism { get; }
    internal ForAllOperator`1(IEnumerable`1<TInput> child, Action`1<TInput> elementAction);
    internal void RunSynchronously();
    internal virtual QueryResults`1<TInput> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<TInput> recipient, bool preferStriping, QuerySettings settings);
    internal virtual IEnumerable`1<TInput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.ForAllSpoolingTask`2 : SpoolingTaskBase {
    private QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> m_source;
    internal ForAllSpoolingTask`2(int taskIndex, QueryTaskGroupState groupState, QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> source);
    protected virtual void SpoolingWork();
    protected virtual void SpoolingFinally();
}
internal class System.Linq.Parallel.GroupByElementSelectorQueryOperatorEnumerator`4 : GroupByQueryOperatorEnumerator`4<TSource, TGroupKey, TElement, TOrderKey> {
    private Func`2<TSource, TElement> m_elementSelector;
    internal GroupByElementSelectorQueryOperatorEnumerator`4(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, IEqualityComparer`1<TGroupKey> keyComparer, Func`2<TSource, TElement> elementSelector, CancellationToken cancellationToken);
    protected virtual HashLookup`2<Wrapper`1<TGroupKey>, ListChunk`1<TElement>> BuildHashLookup();
}
internal class System.Linq.Parallel.GroupByGrouping`2 : object {
    private KeyValuePair`2<Wrapper`1<TGroupKey>, ListChunk`1<TElement>> m_keyValues;
    private TGroupKey System.Linq.IGrouping<TGroupKey,TElement>.Key { get; }
    internal GroupByGrouping`2(TGroupKey key);
    internal GroupByGrouping`2(KeyValuePair`2<Wrapper`1<TGroupKey>, ListChunk`1<TElement>> keyValues);
    internal void Add(TElement element);
    private sealed virtual override TGroupKey System.Linq.IGrouping<TGroupKey,TElement>.get_Key();
    private sealed virtual override IEnumerator`1<TElement> System.Collections.Generic.IEnumerable<TElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Linq.Parallel.GroupByIdentityQueryOperatorEnumerator`3 : GroupByQueryOperatorEnumerator`4<TSource, TGroupKey, TSource, TOrderKey> {
    internal GroupByIdentityQueryOperatorEnumerator`3(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, IEqualityComparer`1<TGroupKey> keyComparer, CancellationToken cancellationToken);
    protected virtual HashLookup`2<Wrapper`1<TGroupKey>, ListChunk`1<TSource>> BuildHashLookup();
}
internal class System.Linq.Parallel.GroupByQueryOperator`3 : UnaryQueryOperator`2<TSource, IGrouping`2<TGroupKey, TElement>> {
    private Func`2<TSource, TGroupKey> m_keySelector;
    private Func`2<TSource, TElement> m_elementSelector;
    private IEqualityComparer`1<TGroupKey> m_keyComparer;
    internal bool LimitsParallelism { get; }
    internal GroupByQueryOperator`3(IEnumerable`1<TSource> child, Func`2<TSource, TGroupKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TGroupKey> keyComparer);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<IGrouping`2<TGroupKey, TElement>> recipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TSource, TGroupKey>, TKey> hashStream, IPartitionedStreamRecipient`1<IGrouping`2<TGroupKey, TElement>> recipient, CancellationToken cancellationToken);
    private void WrapPartitionedStreamHelperOrdered(PartitionedStream`2<Pair`2<TSource, TGroupKey>, TKey> hashStream, IPartitionedStreamRecipient`1<IGrouping`2<TGroupKey, TElement>> recipient, CancellationToken cancellationToken);
    internal virtual QueryResults`1<IGrouping`2<TGroupKey, TElement>> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<IGrouping`2<TGroupKey, TElement>> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal abstract class System.Linq.Parallel.GroupByQueryOperatorEnumerator`4 : QueryOperatorEnumerator`2<IGrouping`2<TGroupKey, TElement>, TOrderKey> {
    protected QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> m_source;
    protected IEqualityComparer`1<TGroupKey> m_keyComparer;
    protected CancellationToken m_cancellationToken;
    private Mutables<TSource, TGroupKey, TElement, TOrderKey> m_mutables;
    protected GroupByQueryOperatorEnumerator`4(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, IEqualityComparer`1<TGroupKey> keyComparer, CancellationToken cancellationToken);
    internal virtual bool MoveNext(IGrouping`2& currentElement, TOrderKey& currentKey);
    protected abstract virtual HashLookup`2<Wrapper`1<TGroupKey>, ListChunk`1<TElement>> BuildHashLookup();
    protected virtual void Dispose(bool disposing);
}
internal class System.Linq.Parallel.GroupJoinQueryOperator`4 : BinaryQueryOperator`3<TLeftInput, TRightInput, TOutput> {
    private Func`2<TLeftInput, TKey> m_leftKeySelector;
    private Func`2<TRightInput, TKey> m_rightKeySelector;
    private Func`3<TLeftInput, IEnumerable`1<TRightInput>, TOutput> m_resultSelector;
    private IEqualityComparer`1<TKey> m_keyComparer;
    internal bool LimitsParallelism { get; }
    internal GroupJoinQueryOperator`4(ParallelQuery`1<TLeftInput> left, ParallelQuery`1<TRightInput> right, Func`2<TLeftInput, TKey> leftKeySelector, Func`2<TRightInput, TKey> rightKeySelector, Func`3<TLeftInput, IEnumerable`1<TRightInput>, TOutput> resultSelector, IEqualityComparer`1<TKey> keyComparer);
    internal virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    public virtual void WrapPartitionedStream(PartitionedStream`2<TLeftInput, TLeftKey> leftStream, PartitionedStream`2<TRightInput, TRightKey> rightStream, IPartitionedStreamRecipient`1<TOutput> outputRecipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TLeftInput, TKey>, TLeftKey> leftHashStream, PartitionedStream`2<TRightInput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TOutput> outputRecipient, int partitionCount, CancellationToken cancellationToken);
    internal virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.GrowingArray`1 : object {
    private static int DEFAULT_ARRAY_SIZE;
    private T[] m_array;
    private int m_count;
    internal T[] InternalArray { get; }
    internal int Count { get; }
    internal T[] get_InternalArray();
    internal int get_Count();
    internal void Add(T element);
    private void GrowArray(int newSize);
    internal void CopyFrom(T[] otherArray, int otherCount);
}
internal class System.Linq.Parallel.HashJoinQueryOperatorEnumerator`5 : QueryOperatorEnumerator`2<TOutput, TLeftKey> {
    private QueryOperatorEnumerator`2<Pair`2<TLeftInput, THashKey>, TLeftKey> m_leftSource;
    private QueryOperatorEnumerator`2<Pair`2<TRightInput, THashKey>, int> m_rightSource;
    private Func`3<TLeftInput, TRightInput, TOutput> m_singleResultSelector;
    private Func`3<TLeftInput, IEnumerable`1<TRightInput>, TOutput> m_groupResultSelector;
    private IEqualityComparer`1<THashKey> m_keyComparer;
    private CancellationToken m_cancellationToken;
    private Mutables<TLeftInput, TLeftKey, TRightInput, THashKey, TOutput> m_mutables;
    internal HashJoinQueryOperatorEnumerator`5(QueryOperatorEnumerator`2<Pair`2<TLeftInput, THashKey>, TLeftKey> leftSource, QueryOperatorEnumerator`2<Pair`2<TRightInput, THashKey>, int> rightSource, Func`3<TLeftInput, TRightInput, TOutput> singleResultSelector, Func`3<TLeftInput, IEnumerable`1<TRightInput>, TOutput> groupResultSelector, IEqualityComparer`1<THashKey> keyComparer, CancellationToken cancellationToken);
    internal virtual bool MoveNext(TOutput& currentElement, TLeftKey& currentKey);
    protected virtual void Dispose(bool disposing);
}
[DefaultMemberAttribute("Item")]
internal class System.Linq.Parallel.HashLookup`2 : object {
    private Int32[] buckets;
    private Slot[] slots;
    private int count;
    private int freeList;
    private IEqualityComparer`1<TKey> comparer;
    unknown TValue Item {internal set; }
    internal int Count { get; }
    internal KeyValuePair`2<TKey, TValue> Item { get; }
    internal HashLookup`2(IEqualityComparer`1<TKey> comparer);
    internal bool Add(TKey key, TValue value);
    internal bool TryGetValue(TKey key, TValue& value);
    internal void set_Item(TKey key, TValue value);
    private int GetKeyHashCode(TKey key);
    private bool AreKeysEqual(TKey key1, TKey key2);
    internal bool Remove(TKey key);
    private bool Find(TKey key, bool add, bool set, TValue& value);
    private void Resize();
    internal int get_Count();
    internal KeyValuePair`2<TKey, TValue> get_Item(int index);
}
internal class System.Linq.Parallel.HashRepartitionEnumerator`3 : QueryOperatorEnumerator`2<Pair`2<TInputOutput, THashKey>, int> {
    private static int ENUMERATION_NOT_STARTED;
    private int m_partitionCount;
    private int m_partitionIndex;
    private Func`2<TInputOutput, THashKey> m_keySelector;
    private HashRepartitionStream`3<TInputOutput, THashKey, int> m_repartitionStream;
    private ListChunk`1[0...,0...] m_valueExchangeMatrix;
    private QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> m_source;
    private CountdownEvent m_barrier;
    private CancellationToken m_cancellationToken;
    private Mutables<TInputOutput, THashKey, TIgnoreKey> m_mutables;
    internal HashRepartitionEnumerator`3(QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> source, int partitionCount, int partitionIndex, Func`2<TInputOutput, THashKey> keySelector, HashRepartitionStream`3<TInputOutput, THashKey, int> repartitionStream, CountdownEvent barrier, ListChunk`1[0...,0...] valueExchangeMatrix, CancellationToken cancellationToken);
    internal virtual bool MoveNext(Pair`2& currentElement, Int32& currentKey);
    private void EnumerateAndRedistributeElements();
    protected virtual void Dispose(bool disposed);
}
internal abstract class System.Linq.Parallel.HashRepartitionStream`3 : PartitionedStream`2<Pair`2<TInputOutput, THashKey>, TOrderKey> {
    private static int NULL_ELEMENT_HASH_CODE;
    private IEqualityComparer`1<THashKey> m_keyComparer;
    private IEqualityComparer`1<TInputOutput> m_elementComparer;
    private int m_distributionMod;
    internal HashRepartitionStream`3(int partitionsCount, IComparer`1<TOrderKey> orderKeyComparer, IEqualityComparer`1<THashKey> hashKeyComparer, IEqualityComparer`1<TInputOutput> elementComparer);
    internal int GetHashCode(TInputOutput element);
    internal int GetHashCode(THashKey key);
}
internal interface System.Linq.Parallel.IMergeHelper`1 {
    public abstract virtual void Execute();
    public abstract virtual IEnumerator`1<TInputOutput> GetEnumerator();
    public abstract virtual TInputOutput[] GetResultsAsArray();
}
internal class System.Linq.Parallel.IndexedSelectQueryOperator`2 : UnaryQueryOperator`2<TInput, TOutput> {
    private Func`3<TInput, int, TOutput> m_selector;
    private bool m_prematureMerge;
    internal bool LimitsParallelism { get; }
    internal IndexedSelectQueryOperator`2(IEnumerable`1<TInput> child, Func`3<TInput, int, TOutput> selector);
    private void InitOrdinalIndexState();
    internal virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, bool preferStriping, QuerySettings settings);
    internal virtual bool get_LimitsParallelism();
    internal virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
}
internal class System.Linq.Parallel.IndexedWhereQueryOperator`1 : UnaryQueryOperator`2<TInputOutput, TInputOutput> {
    private Func`3<TInputOutput, int, bool> m_predicate;
    private bool m_prematureMerge;
    internal bool LimitsParallelism { get; }
    internal IndexedWhereQueryOperator`1(IEnumerable`1<TInputOutput> child, Func`3<TInputOutput, int, bool> predicate);
    private void InitOrdinalIndexState();
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TKey> inputStream, IPartitionedStreamRecipient`1<TInputOutput> recipient, bool preferStriping, QuerySettings settings);
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal abstract class System.Linq.Parallel.InlinedAggregationOperator`3 : UnaryQueryOperator`2<TSource, TIntermediate> {
    internal bool LimitsParallelism { get; }
    internal InlinedAggregationOperator`3(IEnumerable`1<TSource> child);
    internal TResult Aggregate();
    protected abstract virtual TResult InternalAggregate(Exception& singularExceptionToThrow);
    internal virtual QueryResults`1<TIntermediate> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TIntermediate> recipient, bool preferStriping, QuerySettings settings);
    protected abstract virtual QueryOperatorEnumerator`2<TIntermediate, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<TSource, TKey> source, object sharedData, CancellationToken cancellationToken);
    internal virtual IEnumerable`1<TIntermediate> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal abstract class System.Linq.Parallel.InlinedAggregationOperatorEnumerator`1 : QueryOperatorEnumerator`2<TIntermediate, int> {
    private int m_partitionIndex;
    protected CancellationToken m_cancellationToken;
    internal InlinedAggregationOperatorEnumerator`1(int partitionIndex, CancellationToken cancellationToken);
    internal sealed virtual bool MoveNext(TIntermediate& currentElement, Int32& currentKey);
    protected abstract virtual bool MoveNextCore(TIntermediate& currentElement);
}
internal class System.Linq.Parallel.IntAverageAggregationOperator : InlinedAggregationOperator`3<int, Pair`2<long, long>, double> {
    internal IntAverageAggregationOperator(IEnumerable`1<int> child);
    protected virtual double InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<long, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<int, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.IntersectQueryOperator`1 : BinaryQueryOperator`3<TInputOutput, TInputOutput, TInputOutput> {
    private IEqualityComparer`1<TInputOutput> m_comparer;
    internal bool LimitsParallelism { get; }
    internal IntersectQueryOperator`1(ParallelQuery`1<TInputOutput> left, ParallelQuery`1<TInputOutput> right, IEqualityComparer`1<TInputOutput> comparer);
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    public virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TLeftKey> leftPartitionedStream, PartitionedStream`2<TInputOutput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream, PartitionedStream`2<TInputOutput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, CancellationToken cancellationToken);
    internal virtual bool get_LimitsParallelism();
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
}
internal class System.Linq.Parallel.IntMinMaxAggregationOperator : InlinedAggregationOperator`3<int, int, int> {
    private int m_sign;
    internal IntMinMaxAggregationOperator(IEnumerable`1<int> child, int sign);
    protected virtual int InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<int, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<int, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.IntSumAggregationOperator : InlinedAggregationOperator`3<int, int, int> {
    internal IntSumAggregationOperator(IEnumerable`1<int> child);
    protected virtual int InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<int, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<int, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal interface System.Linq.Parallel.IParallelPartitionable`1 {
    public abstract virtual QueryOperatorEnumerator`2[] GetPartitions(int partitionCount);
}
internal interface System.Linq.Parallel.IPartitionedStreamRecipient`1 {
    public abstract virtual void Receive(PartitionedStream`2<TElement, TKey> partitionedStream);
}
internal class System.Linq.Parallel.JoinQueryOperator`4 : BinaryQueryOperator`3<TLeftInput, TRightInput, TOutput> {
    private Func`2<TLeftInput, TKey> m_leftKeySelector;
    private Func`2<TRightInput, TKey> m_rightKeySelector;
    private Func`3<TLeftInput, TRightInput, TOutput> m_resultSelector;
    private IEqualityComparer`1<TKey> m_keyComparer;
    internal bool LimitsParallelism { get; }
    internal JoinQueryOperator`4(ParallelQuery`1<TLeftInput> left, ParallelQuery`1<TRightInput> right, Func`2<TLeftInput, TKey> leftKeySelector, Func`2<TRightInput, TKey> rightKeySelector, Func`3<TLeftInput, TRightInput, TOutput> resultSelector, IEqualityComparer`1<TKey> keyComparer);
    public virtual void WrapPartitionedStream(PartitionedStream`2<TLeftInput, TLeftKey> leftStream, PartitionedStream`2<TRightInput, TRightKey> rightStream, IPartitionedStreamRecipient`1<TOutput> outputRecipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamHelper(PartitionedStream`2<Pair`2<TLeftInput, TKey>, TLeftKey> leftHashStream, PartitionedStream`2<TRightInput, TRightKey> rightPartitionedStream, IPartitionedStreamRecipient`1<TOutput> outputRecipient, CancellationToken cancellationToken);
    internal virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.LastQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
    private Func`2<TSource, bool> m_predicate;
    private bool m_prematureMergeNeeded;
    internal bool LimitsParallelism { get; }
    internal LastQueryOperator`1(IEnumerable`1<TSource> child, Func`2<TSource, bool> predicate);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings);
    internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.ListChunk`1 : object {
    internal TInputOutput[] m_chunk;
    private int m_chunkCount;
    private ListChunk`1<TInputOutput> m_nextChunk;
    private ListChunk`1<TInputOutput> m_tailChunk;
    internal ListChunk`1<TInputOutput> Next { get; }
    internal int Count { get; }
    internal ListChunk`1(int size);
    internal void Add(TInputOutput e);
    internal ListChunk`1<TInputOutput> get_Next();
    internal int get_Count();
    public sealed virtual IEnumerator`1<TInputOutput> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Linq.Parallel.ListQueryResults`1 : QueryResults`1<T> {
    private IList`1<T> m_source;
    private int m_partitionCount;
    private bool m_useStriping;
    internal bool IsIndexible { get; }
    internal int ElementsCount { get; }
    internal ListQueryResults`1(IList`1<T> source, int partitionCount, bool useStriping);
    internal virtual void GivePartitionedStream(IPartitionedStreamRecipient`1<T> recipient);
    internal virtual bool get_IsIndexible();
    internal virtual int get_ElementsCount();
    internal virtual T GetElement(int index);
    internal PartitionedStream`2<T, int> GetPartitionedStream();
}
internal class System.Linq.Parallel.LongAverageAggregationOperator : InlinedAggregationOperator`3<long, Pair`2<long, long>, double> {
    internal LongAverageAggregationOperator(IEnumerable`1<long> child);
    protected virtual double InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<long, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<long, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.LongCountAggregationOperator`1 : InlinedAggregationOperator`3<TSource, long, long> {
    internal LongCountAggregationOperator`1(IEnumerable`1<TSource> child);
    protected virtual long InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<long, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<TSource, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.LongMinMaxAggregationOperator : InlinedAggregationOperator`3<long, long, long> {
    private int m_sign;
    internal LongMinMaxAggregationOperator(IEnumerable`1<long> child, int sign);
    protected virtual long InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<long, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<long, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.LongSumAggregationOperator : InlinedAggregationOperator`3<long, long, long> {
    internal LongSumAggregationOperator(IEnumerable`1<long> child);
    protected virtual long InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<long, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<long, TKey> source, object sharedData, CancellationToken cancellationToken);
}
[DefaultMemberAttribute("Item")]
internal class System.Linq.Parallel.Lookup`2 : object {
    private IDictionary`2<TKey, IGrouping`2<TKey, TElement>> m_dict;
    private IEqualityComparer`1<TKey> m_comparer;
    private IGrouping`2<TKey, TElement> m_defaultKeyGrouping;
    public int Count { get; }
    public IEnumerable`1<TElement> Item { get; }
    internal Lookup`2(IEqualityComparer`1<TKey> comparer);
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TElement> get_Item(TKey key);
    public sealed virtual bool Contains(TKey key);
    internal void Add(IGrouping`2<TKey, TElement> grouping);
    public sealed virtual IEnumerator`1<IGrouping`2<TKey, TElement>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal abstract class System.Linq.Parallel.MergeEnumerator`1 : object {
    protected QueryTaskGroupState m_taskGroupState;
    public TInputOutput Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    protected MergeEnumerator`1(QueryTaskGroupState taskGroupState);
    public abstract virtual TInputOutput get_Current();
    public abstract virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public virtual void Reset();
    public virtual void Dispose();
}
internal class System.Linq.Parallel.MergeExecutor`1 : object {
    private IMergeHelper`1<TInputOutput> m_mergeHelper;
    internal static MergeExecutor`1<TInputOutput> Execute(PartitionedStream`2<TInputOutput, TKey> partitions, bool ignoreOutput, ParallelMergeOptions options, TaskScheduler taskScheduler, bool isOrdered, CancellationState cancellationState, int queryId);
    private void Execute();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<TInputOutput> GetEnumerator();
    internal TInputOutput[] GetResultsAsArray();
    internal static AsynchronousChannel`1[] MakeAsynchronousChannels(int partitionCount, ParallelMergeOptions options, CancellationToken cancellationToken);
    internal static SynchronousChannel`1[] MakeSynchronousChannels(int partitionCount);
}
internal class System.Linq.Parallel.NoKeyMemoizationRequired : ValueType {
}
internal class System.Linq.Parallel.NullableDecimalAverageAggregationOperator : InlinedAggregationOperator`3<Nullable`1<decimal>, Pair`2<decimal, long>, Nullable`1<decimal>> {
    internal NullableDecimalAverageAggregationOperator(IEnumerable`1<Nullable`1<decimal>> child);
    protected virtual Nullable`1<decimal> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<decimal, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<decimal>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableDecimalMinMaxAggregationOperator : InlinedAggregationOperator`3<Nullable`1<decimal>, Nullable`1<decimal>, Nullable`1<decimal>> {
    private int m_sign;
    internal NullableDecimalMinMaxAggregationOperator(IEnumerable`1<Nullable`1<decimal>> child, int sign);
    protected virtual Nullable`1<decimal> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<decimal>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<decimal>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableDecimalSumAggregationOperator : InlinedAggregationOperator`3<Nullable`1<decimal>, Nullable`1<decimal>, Nullable`1<decimal>> {
    internal NullableDecimalSumAggregationOperator(IEnumerable`1<Nullable`1<decimal>> child);
    protected virtual Nullable`1<decimal> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<decimal>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<decimal>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableDoubleAverageAggregationOperator : InlinedAggregationOperator`3<Nullable`1<double>, Pair`2<double, long>, Nullable`1<double>> {
    internal NullableDoubleAverageAggregationOperator(IEnumerable`1<Nullable`1<double>> child);
    protected virtual Nullable`1<double> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<double, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<double>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableDoubleMinMaxAggregationOperator : InlinedAggregationOperator`3<Nullable`1<double>, Nullable`1<double>, Nullable`1<double>> {
    private int m_sign;
    internal NullableDoubleMinMaxAggregationOperator(IEnumerable`1<Nullable`1<double>> child, int sign);
    protected virtual Nullable`1<double> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<double>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<double>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableDoubleSumAggregationOperator : InlinedAggregationOperator`3<Nullable`1<double>, Nullable`1<double>, Nullable`1<double>> {
    internal NullableDoubleSumAggregationOperator(IEnumerable`1<Nullable`1<double>> child);
    protected virtual Nullable`1<double> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<double>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<double>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableFloatAverageAggregationOperator : InlinedAggregationOperator`3<Nullable`1<float>, Pair`2<double, long>, Nullable`1<float>> {
    internal NullableFloatAverageAggregationOperator(IEnumerable`1<Nullable`1<float>> child);
    protected virtual Nullable`1<float> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<double, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<float>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableFloatMinMaxAggregationOperator : InlinedAggregationOperator`3<Nullable`1<float>, Nullable`1<float>, Nullable`1<float>> {
    private int m_sign;
    internal NullableFloatMinMaxAggregationOperator(IEnumerable`1<Nullable`1<float>> child, int sign);
    protected virtual Nullable`1<float> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<float>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<float>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableFloatSumAggregationOperator : InlinedAggregationOperator`3<Nullable`1<float>, Nullable`1<double>, Nullable`1<float>> {
    internal NullableFloatSumAggregationOperator(IEnumerable`1<Nullable`1<float>> child);
    protected virtual Nullable`1<float> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<double>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<float>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableIntAverageAggregationOperator : InlinedAggregationOperator`3<Nullable`1<int>, Pair`2<long, long>, Nullable`1<double>> {
    internal NullableIntAverageAggregationOperator(IEnumerable`1<Nullable`1<int>> child);
    protected virtual Nullable`1<double> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<long, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<int>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableIntMinMaxAggregationOperator : InlinedAggregationOperator`3<Nullable`1<int>, Nullable`1<int>, Nullable`1<int>> {
    private int m_sign;
    internal NullableIntMinMaxAggregationOperator(IEnumerable`1<Nullable`1<int>> child, int sign);
    protected virtual Nullable`1<int> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<int>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<int>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableIntSumAggregationOperator : InlinedAggregationOperator`3<Nullable`1<int>, Nullable`1<int>, Nullable`1<int>> {
    internal NullableIntSumAggregationOperator(IEnumerable`1<Nullable`1<int>> child);
    protected virtual Nullable`1<int> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<int>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<int>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableLongAverageAggregationOperator : InlinedAggregationOperator`3<Nullable`1<long>, Pair`2<long, long>, Nullable`1<double>> {
    internal NullableLongAverageAggregationOperator(IEnumerable`1<Nullable`1<long>> child);
    protected virtual Nullable`1<double> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Pair`2<long, long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<long>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableLongMinMaxAggregationOperator : InlinedAggregationOperator`3<Nullable`1<long>, Nullable`1<long>, Nullable`1<long>> {
    private int m_sign;
    internal NullableLongMinMaxAggregationOperator(IEnumerable`1<Nullable`1<long>> child, int sign);
    protected virtual Nullable`1<long> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<long>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.NullableLongSumAggregationOperator : InlinedAggregationOperator`3<Nullable`1<long>, Nullable`1<long>, Nullable`1<long>> {
    internal NullableLongSumAggregationOperator(IEnumerable`1<Nullable`1<long>> child);
    protected virtual Nullable`1<long> InternalAggregate(Exception& singularExceptionToThrow);
    protected virtual QueryOperatorEnumerator`2<Nullable`1<long>, int> CreateEnumerator(int index, int count, QueryOperatorEnumerator`2<Nullable`1<long>, TKey> source, object sharedData, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.OrderedGroupByElementSelectorQueryOperatorEnumerator`4 : OrderedGroupByQueryOperatorEnumerator`4<TSource, TGroupKey, TElement, TOrderKey> {
    private Func`2<TSource, TElement> m_elementSelector;
    internal OrderedGroupByElementSelectorQueryOperatorEnumerator`4(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, Func`2<TSource, TGroupKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TGroupKey> keyComparer, IComparer`1<TOrderKey> orderComparer, CancellationToken cancellationToken);
    protected virtual HashLookup`2<Wrapper`1<TGroupKey>, GroupKeyData<TSource, TGroupKey, TElement, TOrderKey>> BuildHashLookup();
}
internal class System.Linq.Parallel.OrderedGroupByGrouping`3 : object {
    private TGroupKey m_groupKey;
    private GrowingArray`1<TElement> m_values;
    private GrowingArray`1<TOrderKey> m_orderKeys;
    private IComparer`1<TOrderKey> m_orderComparer;
    private TGroupKey System.Linq.IGrouping<TGroupKey,TElement>.Key { get; }
    internal OrderedGroupByGrouping`3(TGroupKey groupKey, IComparer`1<TOrderKey> orderComparer);
    private sealed virtual override TGroupKey System.Linq.IGrouping<TGroupKey,TElement>.get_Key();
    private sealed virtual override IEnumerator`1<TElement> System.Collections.Generic.IEnumerable<TElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void Add(TElement value, TOrderKey orderKey);
    internal void DoneAdding();
}
internal class System.Linq.Parallel.OrderedGroupByIdentityQueryOperatorEnumerator`3 : OrderedGroupByQueryOperatorEnumerator`4<TSource, TGroupKey, TSource, TOrderKey> {
    internal OrderedGroupByIdentityQueryOperatorEnumerator`3(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, Func`2<TSource, TGroupKey> keySelector, IEqualityComparer`1<TGroupKey> keyComparer, IComparer`1<TOrderKey> orderComparer, CancellationToken cancellationToken);
    protected virtual HashLookup`2<Wrapper`1<TGroupKey>, GroupKeyData<TSource, TGroupKey, TSource, TOrderKey>> BuildHashLookup();
}
internal abstract class System.Linq.Parallel.OrderedGroupByQueryOperatorEnumerator`4 : QueryOperatorEnumerator`2<IGrouping`2<TGroupKey, TElement>, TOrderKey> {
    protected QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> m_source;
    private Func`2<TSource, TGroupKey> m_keySelector;
    protected IEqualityComparer`1<TGroupKey> m_keyComparer;
    protected IComparer`1<TOrderKey> m_orderComparer;
    protected CancellationToken m_cancellationToken;
    private Mutables<TSource, TGroupKey, TElement, TOrderKey> m_mutables;
    protected OrderedGroupByQueryOperatorEnumerator`4(QueryOperatorEnumerator`2<Pair`2<TSource, TGroupKey>, TOrderKey> source, Func`2<TSource, TGroupKey> keySelector, IEqualityComparer`1<TGroupKey> keyComparer, IComparer`1<TOrderKey> orderComparer, CancellationToken cancellationToken);
    internal virtual bool MoveNext(IGrouping`2& currentElement, TOrderKey& currentKey);
    protected abstract virtual HashLookup`2<Wrapper`1<TGroupKey>, GroupKeyData<TSource, TGroupKey, TElement, TOrderKey>> BuildHashLookup();
    protected virtual void Dispose(bool disposing);
}
internal class System.Linq.Parallel.OrderedHashRepartitionEnumerator`3 : QueryOperatorEnumerator`2<Pair`2<TInputOutput, THashKey>, TOrderKey> {
    private static int ENUMERATION_NOT_STARTED;
    private int m_partitionCount;
    private int m_partitionIndex;
    private Func`2<TInputOutput, THashKey> m_keySelector;
    private HashRepartitionStream`3<TInputOutput, THashKey, TOrderKey> m_repartitionStream;
    private ListChunk`1[0...,0...] m_valueExchangeMatrix;
    private ListChunk`1[0...,0...] m_keyExchangeMatrix;
    private QueryOperatorEnumerator`2<TInputOutput, TOrderKey> m_source;
    private CountdownEvent m_barrier;
    private CancellationToken m_cancellationToken;
    private Mutables<TInputOutput, THashKey, TOrderKey> m_mutables;
    internal OrderedHashRepartitionEnumerator`3(QueryOperatorEnumerator`2<TInputOutput, TOrderKey> source, int partitionCount, int partitionIndex, Func`2<TInputOutput, THashKey> keySelector, OrderedHashRepartitionStream`3<TInputOutput, THashKey, TOrderKey> repartitionStream, CountdownEvent barrier, ListChunk`1[0...,0...] valueExchangeMatrix, ListChunk`1[0...,0...] keyExchangeMatrix, CancellationToken cancellationToken);
    internal virtual bool MoveNext(Pair`2& currentElement, TOrderKey& currentKey);
    private void EnumerateAndRedistributeElements();
    protected virtual void Dispose(bool disposing);
}
internal class System.Linq.Parallel.OrderedHashRepartitionStream`3 : HashRepartitionStream`3<TInputOutput, THashKey, TOrderKey> {
    internal OrderedHashRepartitionStream`3(PartitionedStream`2<TInputOutput, TOrderKey> inputStream, Func`2<TInputOutput, THashKey> hashKeySelector, IEqualityComparer`1<THashKey> hashKeyComparer, IEqualityComparer`1<TInputOutput> elementComparer, CancellationToken cancellationToken);
}
internal class System.Linq.Parallel.OrderingQueryOperator`1 : QueryOperator`1<TSource> {
    private bool m_orderOn;
    private QueryOperator`1<TSource> m_child;
    private OrdinalIndexState m_ordinalIndexState;
    internal bool LimitsParallelism { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    public OrderingQueryOperator`1(QueryOperator`1<TSource> child, bool orderOn);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerator`1<TSource> GetEnumerator(Nullable`1<ParallelMergeOptions> mergeOptions, bool suppressOrderPreservation);
    internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
    internal virtual OrdinalIndexState get_OrdinalIndexState();
}
internal class System.Linq.Parallel.OrderPreservingMergeHelper`2 : object {
    private QueryTaskGroupState m_taskGroupState;
    private PartitionedStream`2<TInputOutput, TKey> m_partitions;
    private Shared`1<TInputOutput[]> m_results;
    private TaskScheduler m_taskScheduler;
    internal OrderPreservingMergeHelper`2(PartitionedStream`2<TInputOutput, TKey> partitions, TaskScheduler taskScheduler, CancellationState cancellationState, int queryId);
    private sealed virtual override void System.Linq.Parallel.IMergeHelper<TInputOutput>.Execute();
    private sealed virtual override IEnumerator`1<TInputOutput> System.Linq.Parallel.IMergeHelper<TInputOutput>.GetEnumerator();
    public sealed virtual TInputOutput[] GetResultsAsArray();
}
internal class System.Linq.Parallel.OrderPreservingPipeliningMergeHelper`1 : object {
    internal static int INITIAL_BUFFER_SIZE;
    internal static int STEAL_BUFFER_SIZE;
    internal static int MAX_BUFFER_SIZE;
    private QueryTaskGroupState m_taskGroupState;
    private PartitionedStream`2<TOutput, int> m_partitions;
    private TaskScheduler m_taskScheduler;
    private bool m_autoBuffered;
    private Queue`1[] m_buffers;
    private Boolean[] m_producerDone;
    private Boolean[] m_producerWaiting;
    private Boolean[] m_consumerWaiting;
    private Object[] m_bufferLocks;
    private static ProducerComparer<TOutput> s_producerComparer;
    internal OrderPreservingPipeliningMergeHelper`1(PartitionedStream`2<TOutput, int> partitions, TaskScheduler taskScheduler, CancellationState cancellationState, bool autoBuffered, int queryId);
    private static OrderPreservingPipeliningMergeHelper`1();
    private sealed virtual override void System.Linq.Parallel.IMergeHelper<TOutput>.Execute();
    private sealed virtual override IEnumerator`1<TOutput> System.Linq.Parallel.IMergeHelper<TOutput>.GetEnumerator();
    public sealed virtual TOutput[] GetResultsAsArray();
}
internal class System.Linq.Parallel.OrderPreservingPipeliningSpoolingTask`1 : SpoolingTaskBase {
    private static int PRODUCER_BUFFER_AUTO_SIZE;
    private QueryTaskGroupState m_taskGroupState;
    private TaskScheduler m_taskScheduler;
    private QueryOperatorEnumerator`2<TOutput, int> m_partition;
    private Boolean[] m_consumerWaiting;
    private Boolean[] m_producerWaiting;
    private Boolean[] m_producerDone;
    private int m_partitionIndex;
    private Queue`1[] m_buffers;
    private object m_bufferLock;
    private bool m_autoBuffered;
    internal OrderPreservingPipeliningSpoolingTask`1(QueryOperatorEnumerator`2<TOutput, int> partition, QueryTaskGroupState taskGroupState, Boolean[] consumerWaiting, Boolean[] producerWaiting, Boolean[] producerDone, int partitionIndex, Queue`1[] buffers, object bufferLock, TaskScheduler taskScheduler, bool autoBuffered);
    protected virtual void SpoolingWork();
    public static void Spool(QueryTaskGroupState groupState, PartitionedStream`2<TOutput, int> partitions, Boolean[] consumerWaiting, Boolean[] producerWaiting, Boolean[] producerDone, Queue`1[] buffers, Object[] bufferLocks, TaskScheduler taskScheduler, bool autoBuffered);
    protected virtual void SpoolingFinally();
}
internal class System.Linq.Parallel.OrderPreservingSpoolingTask`2 : SpoolingTaskBase {
    private Shared`1<TInputOutput[]> m_results;
    private SortHelper`1<TInputOutput> m_sortHelper;
    private OrderPreservingSpoolingTask`2(int taskIndex, QueryTaskGroupState groupState, Shared`1<TInputOutput[]> results, SortHelper`1<TInputOutput> sortHelper);
    internal static void Spool(QueryTaskGroupState groupState, PartitionedStream`2<TInputOutput, TKey> partitions, Shared`1<TInputOutput[]> results, TaskScheduler taskScheduler);
    protected virtual void SpoolingWork();
}
internal enum System.Linq.Parallel.OrdinalIndexState : Enum {
    public byte value__;
    public static OrdinalIndexState Indexible;
    public static OrdinalIndexState Correct;
    public static OrdinalIndexState Increasing;
    public static OrdinalIndexState Shuffled;
}
internal class System.Linq.Parallel.Pair`2 : ValueType {
    internal T m_first;
    internal U m_second;
    public T First { get; public set; }
    public U Second { get; public set; }
    public Pair`2(T first, U second);
    public T get_First();
    public void set_First(T value);
    public U get_Second();
    public void set_Second(U value);
}
internal class System.Linq.Parallel.PairComparer`2 : object {
    private IComparer`1<T> m_comparer1;
    private IComparer`1<U> m_comparer2;
    public PairComparer`2(IComparer`1<T> comparer1, IComparer`1<U> comparer2);
    public sealed virtual int Compare(Pair`2<T, U> x, Pair`2<T, U> y);
}
internal class System.Linq.Parallel.ParallelEnumerableWrapper : ParallelQuery`1<object> {
    private IEnumerable m_source;
    internal ParallelEnumerableWrapper(IEnumerable source);
    internal virtual IEnumerator GetEnumeratorUntyped();
    public virtual IEnumerator`1<object> GetEnumerator();
}
internal class System.Linq.Parallel.ParallelEnumerableWrapper`1 : ParallelQuery`1<T> {
    private IEnumerable`1<T> m_wrappedEnumerable;
    internal IEnumerable`1<T> WrappedEnumerable { get; }
    internal ParallelEnumerableWrapper`1(IEnumerable`1<T> wrappedEnumerable);
    internal IEnumerable`1<T> get_WrappedEnumerable();
    public virtual IEnumerator`1<T> GetEnumerator();
}
internal class System.Linq.Parallel.PartitionedDataSource`1 : PartitionedStream`2<T, int> {
    internal PartitionedDataSource`1(IEnumerable`1<T> source, int partitionCount, bool useStriping);
    private void InitializePartitions(IEnumerable`1<T> source, int partitionCount, bool useStriping);
    private static QueryOperatorEnumerator`2[] MakePartitions(IEnumerator`1<T> source, int partitionCount);
}
[DefaultMemberAttribute("Item")]
internal class System.Linq.Parallel.PartitionedStream`2 : object {
    protected QueryOperatorEnumerator`2[] m_partitions;
    private IComparer`1<TKey> m_keyComparer;
    private OrdinalIndexState m_indexState;
    internal QueryOperatorEnumerator`2<TElement, TKey> Item { get; internal set; }
    public int PartitionCount { get; }
    internal IComparer`1<TKey> KeyComparer { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal PartitionedStream`2(int partitionCount, IComparer`1<TKey> keyComparer, OrdinalIndexState indexState);
    internal QueryOperatorEnumerator`2<TElement, TKey> get_Item(int index);
    internal void set_Item(int index, QueryOperatorEnumerator`2<TElement, TKey> value);
    public int get_PartitionCount();
    internal IComparer`1<TKey> get_KeyComparer();
    internal OrdinalIndexState get_OrdinalIndexState();
}
internal class System.Linq.Parallel.PartitionedStreamMerger`1 : object {
    private bool m_forEffectMerge;
    private ParallelMergeOptions m_mergeOptions;
    private bool m_isOrdered;
    private MergeExecutor`1<TOutput> m_mergeExecutor;
    private TaskScheduler m_taskScheduler;
    private int m_queryId;
    private CancellationState m_cancellationState;
    internal MergeExecutor`1<TOutput> MergeExecutor { get; }
    internal PartitionedStreamMerger`1(bool forEffectMerge, ParallelMergeOptions mergeOptions, TaskScheduler taskScheduler, bool outputOrdered, CancellationState cancellationState, int queryId);
    internal MergeExecutor`1<TOutput> get_MergeExecutor();
    public sealed virtual void Receive(PartitionedStream`2<TOutput, TKey> partitionedStream);
}
internal class System.Linq.Parallel.PartitionerQueryOperator`1 : QueryOperator`1<TElement> {
    private Partitioner`1<TElement> m_partitioner;
    internal bool Orderable { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal bool LimitsParallelism { get; }
    internal PartitionerQueryOperator`1(Partitioner`1<TElement> partitioner);
    internal bool get_Orderable();
    internal virtual QueryResults`1<TElement> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TElement> AsSequentialQuery(CancellationToken token);
    internal virtual OrdinalIndexState get_OrdinalIndexState();
    internal static OrdinalIndexState GetOrdinalIndexState(Partitioner`1<TElement> partitioner);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.PipelineSpoolingTask`2 : SpoolingTaskBase {
    private QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> m_source;
    private AsynchronousChannel`1<TInputOutput> m_destination;
    internal PipelineSpoolingTask`2(int taskIndex, QueryTaskGroupState groupState, QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> source, AsynchronousChannel`1<TInputOutput> destination);
    protected virtual void SpoolingWork();
    protected virtual void SpoolingFinally();
}
[FlagsAttribute]
internal enum System.Linq.Parallel.QueryAggregationOptions : Enum {
    public int value__;
    public static QueryAggregationOptions None;
    public static QueryAggregationOptions Associative;
    public static QueryAggregationOptions Commutative;
    public static QueryAggregationOptions AssociativeCommutative;
}
internal class System.Linq.Parallel.QueryExecutionOption`1 : QueryOperator`1<TSource> {
    private QueryOperator`1<TSource> m_child;
    private OrdinalIndexState m_indexState;
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal bool LimitsParallelism { get; }
    internal QueryExecutionOption`1(QueryOperator`1<TSource> source, QuerySettings settings);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual OrdinalIndexState get_OrdinalIndexState();
    internal virtual bool get_LimitsParallelism();
}
internal static class System.Linq.Parallel.QueryLifecycle : object {
    internal static void LogicalQueryExecutionBegin(int queryID);
    internal static void LogicalQueryExecutionEnd(int queryID);
}
internal class System.Linq.Parallel.QueryOpeningEnumerator`1 : object {
    private QueryOperator`1<TOutput> m_queryOperator;
    private IEnumerator`1<TOutput> m_openedQueryEnumerator;
    private QuerySettings m_querySettings;
    private Nullable`1<ParallelMergeOptions> m_mergeOptions;
    private bool m_suppressOrderPreservation;
    private int m_moveNextIteration;
    private bool m_hasQueryOpeningFailed;
    private Shared`1<bool> m_topLevelDisposedFlag;
    private CancellationTokenSource m_topLevelCancellationTokenSource;
    public TOutput Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal QueryOpeningEnumerator`1(QueryOperator`1<TOutput> queryOperator, Nullable`1<ParallelMergeOptions> mergeOptions, bool suppressOrderPreservation);
    public sealed virtual TOutput get_Current();
    public sealed virtual void Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    private void OpenQuery();
    public sealed virtual void Reset();
}
internal abstract class System.Linq.Parallel.QueryOperator`1 : ParallelQuery`1<TOutput> {
    protected bool m_outputOrdered;
    internal bool OutputOrdered { get; }
    internal bool LimitsParallelism { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal QueryOperator`1(QuerySettings settings);
    internal QueryOperator`1(bool isOrdered, QuerySettings settings);
    internal abstract virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    public virtual IEnumerator`1<TOutput> GetEnumerator();
    public IEnumerator`1<TOutput> GetEnumerator(Nullable`1<ParallelMergeOptions> mergeOptions);
    internal bool get_OutputOrdered();
    internal virtual IEnumerator`1<TOutput> GetEnumerator(Nullable`1<ParallelMergeOptions> mergeOptions, bool suppressOrderPreservation);
    internal IEnumerator`1<TOutput> GetOpenedEnumerator(Nullable`1<ParallelMergeOptions> mergeOptions, bool suppressOrder, bool forEffect, QuerySettings querySettings);
    private QueryResults`1<TOutput> GetQueryResults(QuerySettings querySettings);
    internal TOutput[] ExecuteAndGetResultsAsArray();
    internal abstract virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
    internal abstract virtual bool get_LimitsParallelism();
    internal abstract virtual OrdinalIndexState get_OrdinalIndexState();
    internal static ListQueryResults`1<TOutput> ExecuteAndCollectResults(PartitionedStream`2<TOutput, TKey> openedChild, int partitionCount, bool outputOrdered, bool useStriping, QuerySettings settings);
    internal static QueryOperator`1<TOutput> AsQueryOperator(IEnumerable`1<TOutput> source);
}
internal abstract class System.Linq.Parallel.QueryOperatorEnumerator`2 : object {
    internal abstract virtual bool MoveNext(TElement& currentElement, TKey& currentKey);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal virtual void Reset();
    internal IEnumerator`1<TElement> AsClassicEnumerator();
}
[DefaultMemberAttribute("Item")]
internal abstract class System.Linq.Parallel.QueryResults`1 : object {
    internal bool IsIndexible { get; }
    internal int ElementsCount { get; }
    public T Item { get; public set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    internal abstract virtual void GivePartitionedStream(IPartitionedStreamRecipient`1<T> recipient);
    internal virtual bool get_IsIndexible();
    internal virtual T GetElement(int index);
    internal virtual int get_ElementsCount();
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Linq.Parallel.QuerySettings : ValueType {
    private TaskScheduler m_taskScheduler;
    private Nullable`1<int> m_degreeOfParallelism;
    private CancellationState m_cancellationState;
    private Nullable`1<ParallelExecutionMode> m_executionMode;
    private Nullable`1<ParallelMergeOptions> m_mergeOptions;
    private int m_queryId;
    internal CancellationState CancellationState { get; internal set; }
    internal TaskScheduler TaskScheduler { get; internal set; }
    internal Nullable`1<int> DegreeOfParallelism { get; internal set; }
    internal Nullable`1<ParallelExecutionMode> ExecutionMode { get; internal set; }
    internal Nullable`1<ParallelMergeOptions> MergeOptions { get; internal set; }
    internal int QueryId { get; }
    internal static QuerySettings Empty { get; }
    internal QuerySettings(TaskScheduler taskScheduler, Nullable`1<int> degreeOfParallelism, CancellationToken externalCancellationToken, Nullable`1<ParallelExecutionMode> executionMode, Nullable`1<ParallelMergeOptions> mergeOptions);
    internal CancellationState get_CancellationState();
    internal void set_CancellationState(CancellationState value);
    internal TaskScheduler get_TaskScheduler();
    internal void set_TaskScheduler(TaskScheduler value);
    internal Nullable`1<int> get_DegreeOfParallelism();
    internal void set_DegreeOfParallelism(Nullable`1<int> value);
    internal Nullable`1<ParallelExecutionMode> get_ExecutionMode();
    internal void set_ExecutionMode(Nullable`1<ParallelExecutionMode> value);
    internal Nullable`1<ParallelMergeOptions> get_MergeOptions();
    internal void set_MergeOptions(Nullable`1<ParallelMergeOptions> value);
    internal int get_QueryId();
    internal QuerySettings Merge(QuerySettings settings2);
    internal QuerySettings WithPerExecutionSettings();
    internal QuerySettings WithPerExecutionSettings(CancellationTokenSource topLevelCancellationTokenSource, Shared`1<bool> topLevelDisposedFlag);
    internal QuerySettings WithDefaults();
    internal static QuerySettings get_Empty();
    public void CleanStateAtQueryEnd();
}
internal abstract class System.Linq.Parallel.QueryTask : object {
    protected int m_taskIndex;
    protected QueryTaskGroupState m_groupState;
    private static Action`1<object> s_runTaskSynchronouslyDelegate;
    private static Action`1<object> s_baseWorkDelegate;
    [CompilerGeneratedAttribute]
private static Action`1<object> CS$<>9__CachedAnonymousMethodDelegate1;
    protected QueryTask(int taskIndex, QueryTaskGroupState groupState);
    private static QueryTask();
    private static void RunTaskSynchronously(object o);
    internal Task RunSynchronously(TaskScheduler taskScheduler);
    internal Task RunAsynchronously(TaskScheduler taskScheduler);
    private void BaseWork(object unused);
    protected abstract virtual void Work();
    [CompilerGeneratedAttribute]
private static void <.cctor>b__0(object o);
}
internal class System.Linq.Parallel.QueryTaskGroupState : object {
    private Task m_rootTask;
    private int m_alreadyEnded;
    private CancellationState m_cancellationState;
    private int m_queryId;
    internal bool IsAlreadyEnded { get; }
    internal CancellationState CancellationState { get; }
    internal int QueryId { get; }
    internal QueryTaskGroupState(CancellationState cancellationState, int queryId);
    internal bool get_IsAlreadyEnded();
    internal CancellationState get_CancellationState();
    internal int get_QueryId();
    internal void QueryBegin(Task rootTask);
    internal void QueryEnd(bool userInitiatedDispose);
}
internal class System.Linq.Parallel.RangeEnumerable : ParallelQuery`1<int> {
    private int m_from;
    private int m_count;
    internal RangeEnumerable(int from, int count);
    public sealed virtual QueryOperatorEnumerator`2[] GetPartitions(int partitionCount);
    public virtual IEnumerator`1<int> GetEnumerator();
}
internal class System.Linq.Parallel.RepeatEnumerable`1 : ParallelQuery`1<TResult> {
    private TResult m_element;
    private int m_count;
    internal RepeatEnumerable`1(TResult element, int count);
    public sealed virtual QueryOperatorEnumerator`2[] GetPartitions(int partitionCount);
    public virtual IEnumerator`1<TResult> GetEnumerator();
}
internal class System.Linq.Parallel.ReverseComparer`1 : object {
    private IComparer`1<T> m_comparer;
    internal ReverseComparer`1(IComparer`1<T> comparer);
    public sealed virtual int Compare(T x, T y);
}
internal class System.Linq.Parallel.ReverseQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
    internal bool LimitsParallelism { get; }
    internal ReverseQueryOperator`1(IEnumerable`1<TSource> child);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.ScanQueryOperator`1 : QueryOperator`1<TElement> {
    private IEnumerable`1<TElement> m_data;
    public IEnumerable`1<TElement> Data { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal bool LimitsParallelism { get; }
    internal ScanQueryOperator`1(IEnumerable`1<TElement> data);
    public IEnumerable`1<TElement> get_Data();
    internal virtual QueryResults`1<TElement> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerator`1<TElement> GetEnumerator(Nullable`1<ParallelMergeOptions> mergeOptions, bool suppressOrderPreservation);
    internal virtual IEnumerable`1<TElement> AsSequentialQuery(CancellationToken token);
    internal virtual OrdinalIndexState get_OrdinalIndexState();
    internal virtual bool get_LimitsParallelism();
}
internal static class System.Linq.Parallel.Scheduling : object {
    internal static bool DefaultPreserveOrder;
    internal static int DEFAULT_BOUNDED_BUFFER_CAPACITY;
    internal static int DEFAULT_BYTES_PER_CHUNK;
    internal static int ZOMBIED_PRODUCER_TIMEOUT;
    internal static int MAX_SUPPORTED_DOP;
    internal static int DefaultDegreeOfParallelism;
    private static Scheduling();
    internal static int GetDefaultDegreeOfParallelism();
    internal static int GetDefaultChunkSize();
}
internal class System.Linq.Parallel.SelectManyQueryOperator`3 : UnaryQueryOperator`2<TLeftInput, TOutput> {
    private Func`2<TLeftInput, IEnumerable`1<TRightInput>> m_rightChildSelector;
    private Func`3<TLeftInput, int, IEnumerable`1<TRightInput>> m_indexedRightChildSelector;
    private Func`3<TLeftInput, TRightInput, TOutput> m_resultSelector;
    private bool m_prematureMerge;
    internal bool LimitsParallelism { get; }
    internal SelectManyQueryOperator`3(IEnumerable`1<TLeftInput> leftChild, Func`2<TLeftInput, IEnumerable`1<TRightInput>> rightChildSelector, Func`3<TLeftInput, int, IEnumerable`1<TRightInput>> indexedRightChildSelector, Func`3<TLeftInput, TRightInput, TOutput> resultSelector);
    private void InitOrderIndex();
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TLeftInput, TLeftKey> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamNotIndexed(PartitionedStream`2<TLeftInput, TLeftKey> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, QuerySettings settings);
    private void WrapPartitionedStreamIndexed(PartitionedStream`2<TLeftInput, int> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, QuerySettings settings);
    internal virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.SelectQueryOperator`2 : UnaryQueryOperator`2<TInput, TOutput> {
    private Func`2<TInput, TOutput> m_selector;
    internal bool LimitsParallelism { get; }
    internal SelectQueryOperator`2(IEnumerable`1<TInput> child, Func`2<TInput, TOutput> selector);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, bool preferStriping, QuerySettings settings);
    internal virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.Set`1 : object {
    private Int32[] buckets;
    private Slot[] slots;
    private int count;
    private int freeList;
    private IEqualityComparer`1<TElement> comparer;
    internal Set`1(IEqualityComparer`1<TElement> comparer);
    internal bool Add(TElement value);
    internal bool Contains(TElement value);
    internal bool Remove(TElement value);
    internal bool Find(TElement value, bool add);
    private void Resize();
}
internal class System.Linq.Parallel.Shared`1 : object {
    internal T Value;
    internal Shared`1(T value);
}
internal class System.Linq.Parallel.SingleQueryOperator`1 : UnaryQueryOperator`2<TSource, TSource> {
    private Func`2<TSource, bool> m_predicate;
    internal bool LimitsParallelism { get; }
    internal SingleQueryOperator`1(IEnumerable`1<TSource> child, Func`2<TSource, bool> predicate);
    internal virtual QueryResults`1<TSource> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TSource, TKey> inputStream, IPartitionedStreamRecipient`1<TSource> recipient, bool preferStriping, QuerySettings settings);
    internal virtual IEnumerable`1<TSource> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal abstract class System.Linq.Parallel.SortHelper`1 : object {
    internal abstract virtual TInputOutput[] Sort();
}
internal class System.Linq.Parallel.SortHelper`2 : SortHelper`1<TInputOutput> {
    private QueryOperatorEnumerator`2<TInputOutput, TKey> m_source;
    private int m_partitionCount;
    private int m_partitionIndex;
    private QueryTaskGroupState m_groupState;
    private Int32[][] m_sharedIndices;
    private GrowingArray`1[] m_sharedKeys;
    private TInputOutput[][] m_sharedValues;
    private Barrier[0...,0...] m_sharedBarriers;
    private OrdinalIndexState m_indexState;
    private IComparer`1<TKey> m_keyComparer;
    private SortHelper`2(QueryOperatorEnumerator`2<TInputOutput, TKey> source, int partitionCount, int partitionIndex, QueryTaskGroupState groupState, Int32[][] sharedIndices, OrdinalIndexState indexState, IComparer`1<TKey> keyComparer, GrowingArray`1[] sharedkeys, TInputOutput[][] sharedValues, Barrier[0...,0...] sharedBarriers);
    internal static SortHelper`2[] GenerateSortHelpers(PartitionedStream`2<TInputOutput, TKey> partitions, QueryTaskGroupState groupState);
    public sealed virtual void Dispose();
    internal virtual TInputOutput[] Sort();
    private void BuildKeysFromSource(GrowingArray`1& keys, List`1& values);
    private void QuickSortIndicesInPlace(GrowingArray`1<TKey> keys, List`1<TInputOutput> values, OrdinalIndexState ordinalIndexState);
    private void MergeSortCooperatively();
    private int ComputePartnerIndex(int phase);
    private void QuickSort(int left, int right, TKey[] keys, Int32[] indices, CancellationToken cancelToken);
}
internal class System.Linq.Parallel.SortQueryOperator`2 : UnaryQueryOperator`2<TInputOutput, TInputOutput> {
    private Func`2<TInputOutput, TSortKey> m_keySelector;
    private IComparer`1<TSortKey> m_comparer;
    internal Func`2<TInputOutput, TSortKey> KeySelector { get; }
    internal IComparer`1<TSortKey> KeyComparer { get; }
    internal bool LimitsParallelism { get; }
    internal SortQueryOperator`2(IEnumerable`1<TInputOutput> source, Func`2<TInputOutput, TSortKey> keySelector, IComparer`1<TSortKey> comparer, bool descending);
    private sealed virtual override IOrderedEnumerable`1<TInputOutput> System.Linq.IOrderedEnumerable<TInputOutput>.CreateOrderedEnumerable(Func`2<TInputOutput, TKey2> key2Selector, IComparer`1<TKey2> key2Comparer, bool descending);
    internal Func`2<TInputOutput, TSortKey> get_KeySelector();
    internal IComparer`1<TSortKey> get_KeyComparer();
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TKey> inputStream, IPartitionedStreamRecipient`1<TInputOutput> recipient, bool preferStriping, QuerySettings settings);
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.SortQueryOperatorEnumerator`3 : QueryOperatorEnumerator`2<TInputOutput, TSortKey> {
    private QueryOperatorEnumerator`2<TInputOutput, TKey> m_source;
    private Func`2<TInputOutput, TSortKey> m_keySelector;
    private IComparer`1<TSortKey> m_keyComparer;
    public IComparer`1<TSortKey> KeyComparer { get; }
    internal SortQueryOperatorEnumerator`3(QueryOperatorEnumerator`2<TInputOutput, TKey> source, Func`2<TInputOutput, TSortKey> keySelector, IComparer`1<TSortKey> keyComparer);
    public IComparer`1<TSortKey> get_KeyComparer();
    internal virtual bool MoveNext(TInputOutput& currentElement, TSortKey& currentKey);
    protected virtual void Dispose(bool disposing);
}
internal class System.Linq.Parallel.SortQueryOperatorResults`2 : QueryResults`1<TInputOutput> {
    protected QueryResults`1<TInputOutput> m_childQueryResults;
    private SortQueryOperator`2<TInputOutput, TSortKey> m_op;
    private QuerySettings m_settings;
    private bool m_preferStriping;
    internal bool IsIndexible { get; }
    internal SortQueryOperatorResults`2(QueryResults`1<TInputOutput> childQueryResults, SortQueryOperator`2<TInputOutput, TSortKey> op, QuerySettings settings, bool preferStriping);
    internal virtual bool get_IsIndexible();
    internal virtual void GivePartitionedStream(IPartitionedStreamRecipient`1<TInputOutput> recipient);
}
internal static class System.Linq.Parallel.SpoolingTask : object {
    internal static void SpoolStopAndGo(QueryTaskGroupState groupState, PartitionedStream`2<TInputOutput, TIgnoreKey> partitions, SynchronousChannel`1[] channels, TaskScheduler taskScheduler);
    internal static void SpoolPipeline(QueryTaskGroupState groupState, PartitionedStream`2<TInputOutput, TIgnoreKey> partitions, AsynchronousChannel`1[] channels, TaskScheduler taskScheduler);
    internal static void SpoolForAll(QueryTaskGroupState groupState, PartitionedStream`2<TInputOutput, TIgnoreKey> partitions, TaskScheduler taskScheduler);
}
internal abstract class System.Linq.Parallel.SpoolingTaskBase : QueryTask {
    protected SpoolingTaskBase(int taskIndex, QueryTaskGroupState groupState);
    protected virtual void Work();
    protected abstract virtual void SpoolingWork();
    protected virtual void SpoolingFinally();
}
internal class System.Linq.Parallel.StopAndGoSpoolingTask`2 : SpoolingTaskBase {
    private QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> m_source;
    private SynchronousChannel`1<TInputOutput> m_destination;
    internal StopAndGoSpoolingTask`2(int taskIndex, QueryTaskGroupState groupState, QueryOperatorEnumerator`2<TInputOutput, TIgnoreKey> source, SynchronousChannel`1<TInputOutput> destination);
    protected virtual void SpoolingWork();
    protected virtual void SpoolingFinally();
}
internal class System.Linq.Parallel.SynchronousChannel`1 : object {
    private Queue`1<T> m_queue;
    internal int Count { get; }
    internal void Init();
    internal void Enqueue(T item);
    internal T Dequeue();
    internal void SetDone();
    internal void CopyTo(T[] array, int arrayIndex);
    internal int get_Count();
}
internal class System.Linq.Parallel.SynchronousChannelMergeEnumerator`1 : MergeEnumerator`1<T> {
    private SynchronousChannel`1[] m_channels;
    private int m_channelIndex;
    private T m_currentElement;
    public T Current { get; }
    internal SynchronousChannelMergeEnumerator`1(QueryTaskGroupState taskGroupState, SynchronousChannel`1[] channels);
    public virtual T get_Current();
    public virtual bool MoveNext();
}
internal class System.Linq.Parallel.TakeOrSkipQueryOperator`1 : UnaryQueryOperator`2<TResult, TResult> {
    private int m_count;
    private bool m_take;
    private bool m_prematureMerge;
    internal bool LimitsParallelism { get; }
    internal TakeOrSkipQueryOperator`1(IEnumerable`1<TResult> child, int count, bool take);
    private OrdinalIndexState OutputOrdinalIndexState();
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TResult, TKey> inputStream, IPartitionedStreamRecipient`1<TResult> recipient, bool preferStriping, QuerySettings settings);
    internal virtual QueryResults`1<TResult> Open(QuerySettings settings, bool preferStriping);
    internal virtual bool get_LimitsParallelism();
    internal virtual IEnumerable`1<TResult> AsSequentialQuery(CancellationToken token);
}
internal class System.Linq.Parallel.TakeOrSkipWhileQueryOperator`1 : UnaryQueryOperator`2<TResult, TResult> {
    private Func`2<TResult, bool> m_predicate;
    private Func`3<TResult, int, bool> m_indexedPredicate;
    private bool m_take;
    private bool m_prematureMerge;
    internal bool LimitsParallelism { get; }
    internal TakeOrSkipWhileQueryOperator`1(IEnumerable`1<TResult> child, Func`2<TResult, bool> predicate, Func`3<TResult, int, bool> indexedPredicate, bool take);
    private OrdinalIndexState OutputOrderIndexState();
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TResult, TKey> inputStream, IPartitionedStreamRecipient`1<TResult> recipient, bool preferStriping, QuerySettings settings);
    internal virtual QueryResults`1<TResult> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TResult> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal static class System.Linq.Parallel.TraceHelpers : object {
    [ConditionalAttribute("PFXTRACE")]
internal static void SetVerbose();
    [ConditionalAttribute("PFXTRACE")]
internal static void TraceInfo(string msg, Object[] args);
    [ConditionalAttribute("PFXTRACE")]
internal static void TraceWarning(string msg, Object[] args);
    [ConditionalAttribute("PFXTRACE")]
internal static void TraceError(string msg, Object[] args);
    internal static void NotYetImplemented();
    internal static void NotYetImplemented(string message);
    internal static void NotYetImplemented(bool assertCondition, string message);
}
internal abstract class System.Linq.Parallel.UnaryQueryOperator`2 : QueryOperator`1<TOutput> {
    private QueryOperator`1<TInput> m_child;
    private OrdinalIndexState m_indexState;
    internal QueryOperator`1<TInput> Child { get; }
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal UnaryQueryOperator`2(IEnumerable`1<TInput> child);
    internal UnaryQueryOperator`2(IEnumerable`1<TInput> child, bool outputOrdered);
    private UnaryQueryOperator`2(QueryOperator`1<TInput> child);
    internal UnaryQueryOperator`2(QueryOperator`1<TInput> child, bool outputOrdered);
    private UnaryQueryOperator`2(QueryOperator`1<TInput> child, bool outputOrdered, QuerySettings settings);
    internal QueryOperator`1<TInput> get_Child();
    internal sealed virtual OrdinalIndexState get_OrdinalIndexState();
    protected void SetOrdinalIndexState(OrdinalIndexState indexState);
    internal abstract virtual void WrapPartitionedStream(PartitionedStream`2<TInput, TKey> inputStream, IPartitionedStreamRecipient`1<TOutput> recipient, bool preferStriping, QuerySettings settings);
}
internal class System.Linq.Parallel.UnionQueryOperator`1 : BinaryQueryOperator`3<TInputOutput, TInputOutput, TInputOutput> {
    private IEqualityComparer`1<TInputOutput> m_comparer;
    internal bool LimitsParallelism { get; }
    internal UnionQueryOperator`1(ParallelQuery`1<TInputOutput> left, ParallelQuery`1<TInputOutput> right, IEqualityComparer`1<TInputOutput> comparer);
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    public virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TLeftKey> leftStream, PartitionedStream`2<TInputOutput, TRightKey> rightStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, bool preferStriping, QuerySettings settings);
    private void WrapPartitionedStreamFixedLeftType(PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream, PartitionedStream`2<TInputOutput, TRightKey> rightStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, int partitionCount, CancellationToken cancellationToken);
    private void WrapPartitionedStreamFixedBothTypes(PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TLeftKey> leftHashStream, PartitionedStream`2<Pair`2<TInputOutput, NoKeyMemoizationRequired>, TRightKey> rightHashStream, IPartitionedStreamRecipient`1<TInputOutput> outputRecipient, int partitionCount, CancellationToken cancellationToken);
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.UnorderedHashRepartitionStream`3 : HashRepartitionStream`3<TInputOutput, THashKey, int> {
    internal UnorderedHashRepartitionStream`3(PartitionedStream`2<TInputOutput, TIgnoreKey> inputStream, Func`2<TInputOutput, THashKey> keySelector, IEqualityComparer`1<THashKey> keyComparer, IEqualityComparer`1<TInputOutput> elementComparer, CancellationToken cancellationToken);
}
internal static class System.Linq.Parallel.Util : object {
    private static FastIntComparer s_fastIntComparer;
    private static FastLongComparer s_fastLongComparer;
    private static FastFloatComparer s_fastFloatComparer;
    private static FastDoubleComparer s_fastDoubleComparer;
    private static FastDateTimeComparer s_fastDateTimeComparer;
    private static Util();
    internal static int Sign(int x);
    internal static Comparer`1<TKey> GetDefaultComparer();
}
internal class System.Linq.Parallel.WhereQueryOperator`1 : UnaryQueryOperator`2<TInputOutput, TInputOutput> {
    private Func`2<TInputOutput, bool> m_predicate;
    internal bool LimitsParallelism { get; }
    internal WhereQueryOperator`1(IEnumerable`1<TInputOutput> child, Func`2<TInputOutput, bool> predicate);
    internal virtual void WrapPartitionedStream(PartitionedStream`2<TInputOutput, TKey> inputStream, IPartitionedStreamRecipient`1<TInputOutput> recipient, bool preferStriping, QuerySettings settings);
    internal virtual QueryResults`1<TInputOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TInputOutput> AsSequentialQuery(CancellationToken token);
    internal virtual bool get_LimitsParallelism();
}
internal class System.Linq.Parallel.Wrapper`1 : ValueType {
    internal T Value;
    internal Wrapper`1(T value);
}
internal class System.Linq.Parallel.WrapperEqualityComparer`1 : ValueType {
    private IEqualityComparer`1<T> m_comparer;
    internal WrapperEqualityComparer`1(IEqualityComparer`1<T> comparer);
    public sealed virtual bool Equals(Wrapper`1<T> x, Wrapper`1<T> y);
    public sealed virtual int GetHashCode(Wrapper`1<T> x);
}
internal class System.Linq.Parallel.ZipQueryOperator`3 : QueryOperator`1<TOutput> {
    private Func`3<TLeftInput, TRightInput, TOutput> m_resultSelector;
    private QueryOperator`1<TLeftInput> m_leftChild;
    private QueryOperator`1<TRightInput> m_rightChild;
    private bool m_prematureMergeLeft;
    private bool m_prematureMergeRight;
    internal OrdinalIndexState OrdinalIndexState { get; }
    internal bool LimitsParallelism { get; }
    internal ZipQueryOperator`3(ParallelQuery`1<TLeftInput> leftChildSource, IEnumerable`1<TRightInput> rightChildSource, Func`3<TLeftInput, TRightInput, TOutput> resultSelector);
    private ZipQueryOperator`3(QueryOperator`1<TLeftInput> left, QueryOperator`1<TRightInput> right, Func`3<TLeftInput, TRightInput, TOutput> resultSelector);
    internal virtual QueryResults`1<TOutput> Open(QuerySettings settings, bool preferStriping);
    internal virtual IEnumerable`1<TOutput> AsSequentialQuery(CancellationToken token);
    internal virtual OrdinalIndexState get_OrdinalIndexState();
    internal virtual bool get_LimitsParallelism();
}
[ExtensionAttribute]
public static class System.Linq.ParallelEnumerable : object {
    private static string RIGHT_SOURCE_NOT_PARALLEL_STR;
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> AsParallel(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> AsParallel(Partitioner`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> AsOrdered(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery AsOrdered(ParallelQuery source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> AsUnordered(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery AsParallel(IEnumerable source);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> AsSequential(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
internal static ParallelQuery`1<TSource> WithTaskScheduler(ParallelQuery`1<TSource> source, TaskScheduler taskScheduler);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> WithDegreeOfParallelism(ParallelQuery`1<TSource> source, int degreeOfParallelism);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> WithCancellation(ParallelQuery`1<TSource> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> WithExecutionMode(ParallelQuery`1<TSource> source, ParallelExecutionMode executionMode);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> WithMergeOptions(ParallelQuery`1<TSource> source, ParallelMergeOptions mergeOptions);
    public static ParallelQuery`1<int> Range(int start, int count);
    public static ParallelQuery`1<TResult> Repeat(TResult element, int count);
    public static ParallelQuery`1<TResult> Empty();
    [ExtensionAttribute]
public static void ForAll(ParallelQuery`1<TSource> source, Action`1<TSource> action);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Where(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Where(ParallelQuery`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Select(ParallelQuery`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Select(ParallelQuery`1<TSource> source, Func`3<TSource, int, TResult> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Zip(ParallelQuery`1<TFirst> first, ParallelQuery`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TResult> Zip(ParallelQuery`1<TFirst> first, IEnumerable`1<TSecond> second, Func`3<TFirst, TSecond, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TResult> Join(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, TInner, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, ParallelQuery`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TResult> GroupJoin(ParallelQuery`1<TOuter> outer, IEnumerable`1<TInner> inner, Func`2<TOuter, TKey> outerKeySelector, Func`2<TInner, TKey> innerKeySelector, Func`3<TOuter, IEnumerable`1<TInner>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`2<TSource, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TResult>> selector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> SelectMany(ParallelQuery`1<TSource> source, Func`3<TSource, int, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> OrderBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> OrderBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> OrderByDescending(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> OrderByDescending(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> ThenBy(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> ThenBy(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> ThenByDescending(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static OrderedParallelQuery`1<TSource> ThenByDescending(OrderedParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<IGrouping`2<TKey, TSource>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ParallelQuery`1<IGrouping`2<TKey, TSource>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<IGrouping`2<TKey, TElement>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<IGrouping`2<TKey, TElement>> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`3<TKey, IEnumerable`1<TSource>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> GroupBy(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, Func`3<TKey, IEnumerable`1<TElement>, TResult> resultSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
private static T PerformAggregation(ParallelQuery`1<T> source, Func`3<T, T, T> reduce, T seed, bool seedIsSpecified, bool throwIfEmpty, QueryAggregationOptions options);
    [ExtensionAttribute]
private static TAccumulate PerformSequentialAggregation(ParallelQuery`1<TSource> source, TAccumulate seed, bool seedIsSpecified, Func`3<TAccumulate, TSource, TAccumulate> func);
    [ExtensionAttribute]
public static TSource Aggregate(ParallelQuery`1<TSource> source, Func`3<TSource, TSource, TSource> func);
    [ExtensionAttribute]
internal static TSource Aggregate(ParallelQuery`1<TSource> source, Func`3<TSource, TSource, TSource> func, QueryAggregationOptions options);
    [ExtensionAttribute]
public static TAccumulate Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func);
    [ExtensionAttribute]
internal static TAccumulate Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func, QueryAggregationOptions options);
    [ExtensionAttribute]
public static TResult Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static TResult Aggregate(ParallelQuery`1<TSource> source, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> updateAccumulatorFunc, Func`3<TAccumulate, TAccumulate, TAccumulate> combineAccumulatorsFunc, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static TResult Aggregate(ParallelQuery`1<TSource> source, Func`1<TAccumulate> seedFactory, Func`3<TAccumulate, TSource, TAccumulate> updateAccumulatorFunc, Func`3<TAccumulate, TAccumulate, TAccumulate> combineAccumulatorsFunc, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static int Count(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static int Count(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static long LongCount(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static long LongCount(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static int Sum(ParallelQuery`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(ParallelQuery`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static long Sum(ParallelQuery`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(ParallelQuery`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Sum(ParallelQuery`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(ParallelQuery`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Sum(ParallelQuery`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(ParallelQuery`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Sum(ParallelQuery`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(ParallelQuery`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static int Sum(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static long Sum(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Sum(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Sum(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Sum(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Sum(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static int Min(ParallelQuery`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Min(ParallelQuery`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static long Min(ParallelQuery`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Min(ParallelQuery`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Min(ParallelQuery`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Min(ParallelQuery`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Min(ParallelQuery`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Min(ParallelQuery`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Min(ParallelQuery`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Min(ParallelQuery`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static TSource Min(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static int Min(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static long Min(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Min(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Min(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Min(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Min(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static TResult Min(ParallelQuery`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static int Max(ParallelQuery`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<int> Max(ParallelQuery`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static long Max(ParallelQuery`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<long> Max(ParallelQuery`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Max(ParallelQuery`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Max(ParallelQuery`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Max(ParallelQuery`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Max(ParallelQuery`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Max(ParallelQuery`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Max(ParallelQuery`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static TSource Max(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static int Max(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<int> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static long Max(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<long> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Max(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Max(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Max(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Max(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static TResult Max(ParallelQuery`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<int> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<Nullable`1<int>> source);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<long> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<Nullable`1<long>> source);
    [ExtensionAttribute]
public static float Average(ParallelQuery`1<float> source);
    [ExtensionAttribute]
public static Nullable`1<float> Average(ParallelQuery`1<Nullable`1<float>> source);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<double> source);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<Nullable`1<double>> source);
    [ExtensionAttribute]
public static decimal Average(ParallelQuery`1<decimal> source);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(ParallelQuery`1<Nullable`1<decimal>> source);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<TSource> source, Func`2<TSource, int> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<int>> selector);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<TSource> source, Func`2<TSource, long> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<long>> selector);
    [ExtensionAttribute]
public static float Average(ParallelQuery`1<TSource> source, Func`2<TSource, float> selector);
    [ExtensionAttribute]
public static Nullable`1<float> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<float>> selector);
    [ExtensionAttribute]
public static double Average(ParallelQuery`1<TSource> source, Func`2<TSource, double> selector);
    [ExtensionAttribute]
public static Nullable`1<double> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<double>> selector);
    [ExtensionAttribute]
public static decimal Average(ParallelQuery`1<TSource> source, Func`2<TSource, decimal> selector);
    [ExtensionAttribute]
public static Nullable`1<decimal> Average(ParallelQuery`1<TSource> source, Func`2<TSource, Nullable`1<decimal>> selector);
    [ExtensionAttribute]
public static bool Any(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static bool Any(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static bool All(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static bool Contains(ParallelQuery`1<TSource> source, TSource value);
    [ExtensionAttribute]
public static bool Contains(ParallelQuery`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Take(ParallelQuery`1<TSource> source, int count);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> TakeWhile(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> TakeWhile(ParallelQuery`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Skip(ParallelQuery`1<TSource> source, int count);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> SkipWhile(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> SkipWhile(ParallelQuery`1<TSource> source, Func`3<TSource, int, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Concat(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TSource> Concat(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static bool SequenceEqual(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static bool SequenceEqual(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static bool SequenceEqual(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    private static void DisposeEnumerator(IEnumerator`1<TSource> e, CancellationState cancelState);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static bool SequenceEqual(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Distinct(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Distinct(ParallelQuery`1<TSource> source, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TSource> Union(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ExtensionAttribute]
[ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
public static ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TSource> Intersect(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, ParallelQuery`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ObsoleteAttribute("The second data source of a binary operator must be of type System.Linq.ParallelQuery<T> rather than System.Collections.Generic.IEnumerable<T>. To fix this problem, use the AsParallel() extension method to convert the right data source to System.Linq.ParallelQuery<T>.")]
[ExtensionAttribute]
public static ParallelQuery`1<TSource> Except(ParallelQuery`1<TSource> first, IEnumerable`1<TSource> second, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> AsEnumerable(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource[] ToArray(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static List`1<TSource> ToList(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TSource> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ILookup`2<TKey, TSource> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ILookup`2<TKey, TSource> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ILookup`2<TKey, TElement> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector);
    [ExtensionAttribute]
public static ILookup`2<TKey, TElement> ToLookup(ParallelQuery`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> Reverse(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> OfType(ParallelQuery source);
    [ExtensionAttribute]
public static ParallelQuery`1<TResult> Cast(ParallelQuery source);
    private static TSource GetOneWithPossibleDefault(QueryOperator`1<TSource> queryOp, bool throwIfTwo, bool defaultIfEmpty);
    [ExtensionAttribute]
public static TSource First(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource First(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource FirstOrDefault(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource FirstOrDefault(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource Last(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource Last(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource LastOrDefault(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource LastOrDefault(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource Single(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource Single(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static TSource SingleOrDefault(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static TSource SingleOrDefault(ParallelQuery`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> DefaultIfEmpty(ParallelQuery`1<TSource> source);
    [ExtensionAttribute]
public static ParallelQuery`1<TSource> DefaultIfEmpty(ParallelQuery`1<TSource> source, TSource defaultValue);
    [ExtensionAttribute]
public static TSource ElementAt(ParallelQuery`1<TSource> source, int index);
    [ExtensionAttribute]
public static TSource ElementAtOrDefault(ParallelQuery`1<TSource> source, int index);
    [CompilerGeneratedAttribute]
private static void <WithCancellation>b__0();
    [CompilerGeneratedAttribute]
private static T <PerformAggregation>b__e(T obj);
}
public enum System.Linq.ParallelExecutionMode : Enum {
    public int value__;
    public static ParallelExecutionMode Default;
    public static ParallelExecutionMode ForceParallelism;
}
public enum System.Linq.ParallelMergeOptions : Enum {
    public int value__;
    public static ParallelMergeOptions Default;
    public static ParallelMergeOptions NotBuffered;
    public static ParallelMergeOptions AutoBuffered;
    public static ParallelMergeOptions FullyBuffered;
}
public class System.Linq.ParallelQuery : object {
    private QuerySettings m_specifiedSettings;
    internal QuerySettings SpecifiedQuerySettings { get; }
    internal ParallelQuery(QuerySettings specifiedSettings);
    internal QuerySettings get_SpecifiedQuerySettings();
    internal virtual ParallelQuery`1<TCastTo> Cast();
    internal virtual ParallelQuery`1<TCastTo> OfType();
    internal virtual IEnumerator GetEnumeratorUntyped();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Linq.ParallelQuery`1 : ParallelQuery {
    internal ParallelQuery`1(QuerySettings settings);
    internal sealed virtual ParallelQuery`1<TCastTo> Cast();
    internal sealed virtual ParallelQuery`1<TCastTo> OfType();
    internal virtual IEnumerator GetEnumeratorUntyped();
    public virtual IEnumerator`1<TSource> GetEnumerator();
    [CompilerGeneratedAttribute]
private static TCastTo <Cast>b__0(TSource elem);
    [CompilerGeneratedAttribute]
private static bool <OfType>b__1(TSource elem);
    [CompilerGeneratedAttribute]
private static TCastTo <OfType>b__2(TSource elem);
}
[ComVisibleAttribute("True")]
internal class System.OperationCanceledException2 : OperationCanceledException {
    private CancellationToken _cancellationToken;
    public CancellationToken CancellationToken { get; private set; }
    public OperationCanceledException2(string message);
    public OperationCanceledException2(string message, Exception innerException);
    public OperationCanceledException2(CancellationToken token);
    public OperationCanceledException2(string message, CancellationToken token);
    public OperationCanceledException2(string message, Exception innerException, CancellationToken token);
    protected OperationCanceledException2(SerializationInfo info, StreamingContext context);
    public CancellationToken get_CancellationToken();
    private void set_CancellationToken(CancellationToken value);
}
internal class System.SecuritySafeCriticalAttribute : Attribute {
}
internal class System.System_LazyDebugView`1 : object {
    private Lazy`1<T> m_lazy;
    public bool IsValueCreated { get; }
    public T Value { get; }
    public LazyThreadSafetyMode Mode { get; }
    public bool IsValueFaulted { get; }
    public System_LazyDebugView`1(Lazy`1<T> lazy);
    public bool get_IsValueCreated();
    public T get_Value();
    public LazyThreadSafetyMode get_Mode();
    public bool get_IsValueFaulted();
}
[DebuggerDisplayAttribute("Participant Count={ParticipantCount},Participants Remaining={ParticipantsRemaining}")]
[ComVisibleAttribute("False")]
public class System.Threading.Barrier : object {
    private static int CURRENT_MASK;
    private static int TOTAL_MASK;
    private static int SENSE_MASK;
    private static int MAX_PARTICIPANTS;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_currentTotalCount;
    private long m_currentPhase;
    private bool m_disposed;
    private ManualResetEventSlim m_oddEvent;
    private ManualResetEventSlim m_evenEvent;
    private ExecutionContext m_ownerThreadContext;
    private Action`1<Barrier> m_postPhaseAction;
    private Exception m_exception;
    private int m_actionCallerID;
    public int ParticipantsRemaining { get; }
    public int ParticipantCount { get; }
    public long CurrentPhaseNumber { get; }
    public Barrier(int participantCount);
    public Barrier(int participantCount, Action`1<Barrier> postPhaseAction);
    public int get_ParticipantsRemaining();
    public int get_ParticipantCount();
    public long get_CurrentPhaseNumber();
    private void GetCurrentTotal(int currentTotal, Int32& current, Int32& total, Boolean& sense);
    private bool SetCurrentTotal(int currentTotal, int current, int total, bool sense);
    public long AddParticipant();
    public long AddParticipants(int participantCount);
    public void RemoveParticipant();
    public void RemoveParticipants(int participantCount);
    public void SignalAndWait();
    public void SignalAndWait(CancellationToken cancellationToken);
    public bool SignalAndWait(TimeSpan timeout);
    public bool SignalAndWait(TimeSpan timeout, CancellationToken cancellationToken);
    public bool SignalAndWait(int millisecondsTimeout);
    public bool SignalAndWait(int millisecondsTimeout, CancellationToken cancellationToken);
    private void FinishPhase(bool observedSense);
    private void SetResetEvents(bool observedSense);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    [CompilerGeneratedAttribute]
private void <FinishPhase>b__0(object i);
}
public class System.Threading.BarrierPostPhaseException : Exception {
    public BarrierPostPhaseException(Exception innerException);
    public BarrierPostPhaseException(string message);
    public BarrierPostPhaseException(string message, Exception innerException);
    [SecurityCriticalAttribute]
protected BarrierPostPhaseException(SerializationInfo info, StreamingContext context);
}
internal class System.Threading.CancellationCallbackCoreWorkArguments : ValueType {
    internal SparselyPopulatedArrayFragment`1<CancellationCallbackInfo> m_currArrayFragment;
    internal int m_currArrayIndex;
    public CancellationCallbackCoreWorkArguments(SparselyPopulatedArrayFragment`1<CancellationCallbackInfo> currArrayFragment, int currArrayIndex);
}
internal class System.Threading.CancellationCallbackInfo : object {
    internal Action`1<object> Callback;
    internal object StateForCallback;
    internal SynchronizationContext TargetSyncContext;
    internal ExecutionContext TargetExecutionContext;
    internal CancellationTokenSource CancellationTokenSource;
    internal CancellationCallbackInfo(Action`1<object> callback, object stateForCallback, SynchronizationContext targetSyncContext, ExecutionContext targetExecutionContext, CancellationTokenSource cancellationTokenSource);
    [SecuritySafeCriticalAttribute]
internal void ExecuteCallback();
    private static void ExecutionContextCallback(object obj);
}
[DebuggerDisplayAttribute("IsCancellationRequested = {IsCancellationRequested}")]
[ComVisibleAttribute("False")]
public class System.Threading.CancellationToken : ValueType {
    private CancellationTokenSource m_source;
    private static Action`1<object> s_ActionToActionObjShunt;
    public static CancellationToken None { get; }
    public bool IsCancellationRequested { get; }
    public bool CanBeCanceled { get; }
    public WaitHandle WaitHandle { get; }
    internal CancellationToken(CancellationTokenSource source);
    public CancellationToken(bool canceled);
    private static CancellationToken();
    public static CancellationToken get_None();
    public bool get_IsCancellationRequested();
    public bool get_CanBeCanceled();
    public WaitHandle get_WaitHandle();
    private static void ActionToActionObjShunt(object obj);
    public CancellationTokenRegistration Register(Action callback);
    public CancellationTokenRegistration Register(Action callback, bool useSynchronizationContext);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state, bool useSynchronizationContext);
    internal CancellationTokenRegistration InternalRegisterWithoutEC(Action`1<object> callback, object state);
    private CancellationTokenRegistration Register(Action`1<object> callback, object state, bool useSynchronizationContext, bool useExecutionContext);
    public bool Equals(CancellationToken other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public static bool op_Equality(CancellationToken left, CancellationToken right);
    public static bool op_Inequality(CancellationToken left, CancellationToken right);
    public void ThrowIfCancellationRequested();
    internal void ThrowIfSourceDisposed();
    private void InitializeDefaultSource();
}
public class System.Threading.CancellationTokenRegistration : ValueType {
    private CancellationTokenSource m_tokenSource;
    private CancellationCallbackInfo m_callbackInfo;
    private SparselyPopulatedArrayAddInfo`1<CancellationCallbackInfo> m_registrationInfo;
    internal CancellationTokenRegistration(CancellationTokenSource tokenSource, CancellationCallbackInfo callbackInfo, SparselyPopulatedArrayAddInfo`1<CancellationCallbackInfo> registrationInfo);
    internal bool TryDeregister();
    public sealed virtual void Dispose();
    public static bool op_Equality(CancellationTokenRegistration left, CancellationTokenRegistration right);
    public static bool op_Inequality(CancellationTokenRegistration left, CancellationTokenRegistration right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CancellationTokenRegistration other);
    public virtual int GetHashCode();
}
[ComVisibleAttribute("False")]
public class System.Threading.CancellationTokenSource : object {
    private static int CANNOT_BE_CANCELED;
    private static int NOT_CANCELED;
    private static int NOTIFYING;
    private static int NOTIFYINGCOMPLETE;
    private static CancellationTokenSource _staticSource_Set;
    private static CancellationTokenSource _staticSource_NotCancelable;
    private static int s_nLists;
    private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) m_kernelEvent;
    private SparselyPopulatedArray`1[] modreq(System.Runtime.CompilerServices.IsVolatile) m_registeredCallbacksLists;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_state;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_threadIDExecutingCallbacks;
    private bool m_disposed;
    private List`1<CancellationTokenRegistration> m_linkingRegistrations;
    private static Action`1<object> s_LinkedTokenCancelDelegate;
    private CancellationCallbackInfo modreq(System.Runtime.CompilerServices.IsVolatile) m_executingCallback;
    public bool IsCancellationRequested { get; }
    internal bool IsCancellationCompleted { get; }
    internal bool IsDisposed { get; }
    internal int ThreadIDExecutingCallbacks { get; internal set; }
    public CancellationToken Token { get; }
    internal bool CanBeCanceled { get; }
    internal WaitHandle WaitHandle { get; }
    internal CancellationCallbackInfo ExecutingCallback { get; }
    private CancellationTokenSource(bool set);
    private static CancellationTokenSource();
    private static void LinkedTokenCancelDelegate(object source);
    public bool get_IsCancellationRequested();
    internal bool get_IsCancellationCompleted();
    internal bool get_IsDisposed();
    internal void set_ThreadIDExecutingCallbacks(int value);
    internal int get_ThreadIDExecutingCallbacks();
    public CancellationToken get_Token();
    internal bool get_CanBeCanceled();
    internal WaitHandle get_WaitHandle();
    internal CancellationCallbackInfo get_ExecutingCallback();
    public void Cancel();
    public void Cancel(bool throwOnFirstException);
    public sealed virtual void Dispose();
    internal void ThrowIfDisposed();
    internal static CancellationTokenSource InternalGetStaticSource(bool set);
    internal CancellationTokenRegistration InternalRegister(Action`1<object> callback, object stateForCallback, SynchronizationContext targetSyncContext, ExecutionContext executionContext);
    private void NotifyCancellation(bool throwOnFirstException);
    private void ExecuteCallbackHandlers(bool throwOnFirstException);
    private void CancellationCallbackCoreWork_OnSyncContext(object obj);
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token1, CancellationToken token2);
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken[] tokens);
    internal void WaitForCallbackToComplete(CancellationCallbackInfo callbackInfo);
}
[ComVisibleAttribute("False")]
[DebuggerDisplayAttribute("Initial Count={InitialCount}, Current Count={CurrentCount}")]
public class System.Threading.CountdownEvent : object {
    private int m_initialCount;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_currentCount;
    private ManualResetEventSlim m_event;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_disposed;
    public int CurrentCount { get; }
    public int InitialCount { get; }
    public bool IsSet { get; }
    public WaitHandle WaitHandle { get; }
    public CountdownEvent(int initialCount);
    public int get_CurrentCount();
    public int get_InitialCount();
    public bool get_IsSet();
    public WaitHandle get_WaitHandle();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public bool Signal();
    public bool Signal(int signalCount);
    public void AddCount();
    public bool TryAddCount();
    public void AddCount(int signalCount);
    public bool TryAddCount(int signalCount);
    public void Reset();
    public void Reset(int count);
    public void Wait();
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    private void ThrowIfDisposed();
}
public static class System.Threading.LazyInitializer : object {
    private static Object modreq(System.Runtime.CompilerServices.IsVolatile) s_barrier;
    private static LazyInitializer();
    public static T EnsureInitialized(T& target);
    public static T EnsureInitialized(T& target, Func`1<T> valueFactory);
    private static T EnsureInitializedCore(T& target, Func`1<T> valueFactory);
    public static T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock);
    public static T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock, Func`1<T> valueFactory);
    private static T EnsureInitializedCore(T& target, Boolean& initialized, Object& syncLock, Func`1<T> valueFactory);
}
public enum System.Threading.LazyThreadSafetyMode : Enum {
    public int value__;
    public static LazyThreadSafetyMode None;
    public static LazyThreadSafetyMode PublicationOnly;
    public static LazyThreadSafetyMode ExecutionAndPublication;
}
[ComVisibleAttribute("False")]
[DebuggerDisplayAttribute("Set = {IsSet}")]
public class System.Threading.ManualResetEventSlim : object {
    private static int DEFAULT_SPIN_SP;
    private static int DEFAULT_SPIN_MP;
    private static int SignalledState_BitMask;
    private static int SignalledState_ShiftCount;
    private static int Dispose_BitMask;
    private static int SpinCountState_BitMask;
    private static int SpinCountState_ShiftCount;
    private static int SpinCountState_MaxValue;
    private static int NumWaitersState_BitMask;
    private static int NumWaitersState_ShiftCount;
    private static int NumWaitersState_MaxValue;
    private object m_lock;
    private ManualResetEvent m_eventObj;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_combinedState;
    private static Action`1<object> s_cancellationTokenCallback;
    public WaitHandle WaitHandle { get; }
    public bool IsSet { get; private set; }
    public int SpinCount { get; private set; }
    private int Waiters { get; private set; }
    public ManualResetEventSlim(bool initialState);
    public ManualResetEventSlim(bool initialState, int spinCount);
    private static ManualResetEventSlim();
    public WaitHandle get_WaitHandle();
    public bool get_IsSet();
    private void set_IsSet(bool value);
    public int get_SpinCount();
    private void set_SpinCount(int value);
    private int get_Waiters();
    private void set_Waiters(int value);
    private void Initialize(bool initialState, int spinCount);
    private void EnsureLockObjectCreated();
    private bool LazyInitializeEvent();
    public void Set();
    private void Set(bool duringCancellation);
    public void Reset();
    public void Wait();
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    private static void CancellationTokenCallback(object obj);
    private void UpdateStateAtomically(int newBits, int updateBitsMask);
    private static int ExtractStatePortionAndShiftRight(int state, int mask, int rightBitShiftCount);
    private static int ExtractStatePortion(int state, int mask);
    private static int UpdateTimeOut(long startTimeTicks, int originalWaitMillisecondsTimeout);
}
internal class System.Threading.Monitor2 : object {
    internal static void Enter(object obj, Boolean& taken);
    internal static bool TryEnter(object obj);
    internal static void TryEnter(object obj, Boolean& taken);
    internal static bool TryEnter(object obj, int millisecondsTimeout);
    internal static bool TryEnter(object obj, TimeSpan timeout);
    internal static void TryEnter(object obj, int millisecondsTimeout, Boolean& taken);
}
internal static class System.Threading.Platform : object {
    internal static int ProcessorCount { get; }
    internal static bool IsSingleProcessor { get; }
    internal static int get_ProcessorCount();
    internal static bool get_IsSingleProcessor();
    internal static void Yield();
}
internal static class System.Threading.PlatformHelper : object {
    private static int PROCESSOR_COUNT_REFRESH_INTERVAL_MS;
    private static int s_processorCount;
    private static DateTime s_nextProcessorCountRefreshTime;
    internal static int ProcessorCount { get; }
    internal static bool IsSingleProcessor { get; }
    private static PlatformHelper();
    internal static int get_ProcessorCount();
    internal static bool get_IsSingleProcessor();
}
[DebuggerDisplayAttribute("Current Count = {m_currentCount}")]
[ComVisibleAttribute("False")]
public class System.Threading.SemaphoreSlim : object {
    private static int NO_MAXIMUM;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_currentCount;
    private int m_maxCount;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_waitCount;
    private object m_lockObj;
    private ManualResetEvent m_waitHandle;
    private static Action`1<object> s_cancellationTokenCanceledEventHandler;
    public int CurrentCount { get; }
    public WaitHandle AvailableWaitHandle { get; }
    public SemaphoreSlim(int initialCount);
    public SemaphoreSlim(int initialCount, int maxCount);
    private static SemaphoreSlim();
    public int get_CurrentCount();
    public WaitHandle get_AvailableWaitHandle();
    public void Wait();
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool WaitUntilCountOrTimeout(int millisecondsTimeout, long startTimeTicks, CancellationToken cancellationToken);
    public int Release();
    public int Release(int releaseCount);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private static int UpdateTimeOut(long startTimeTicks, int originalWaitMillisecondsTimeout);
    private static void CancellationTokenCanceledEventHandler(object obj);
    private void CheckDispose();
    private static string GetResourceString(string str);
}
internal class System.Threading.SparselyPopulatedArray`1 : object {
    private SparselyPopulatedArrayFragment`1<T> m_head;
    private SparselyPopulatedArrayFragment`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_tail;
    internal SparselyPopulatedArrayFragment`1<T> Head { get; }
    internal SparselyPopulatedArrayFragment`1<T> Tail { get; }
    internal SparselyPopulatedArray`1(int initialSize);
    internal SparselyPopulatedArrayFragment`1<T> get_Head();
    internal SparselyPopulatedArrayFragment`1<T> get_Tail();
    internal SparselyPopulatedArrayAddInfo`1<T> Add(T element);
}
internal class System.Threading.SparselyPopulatedArrayAddInfo`1 : ValueType {
    private SparselyPopulatedArrayFragment`1<T> m_source;
    private int m_index;
    internal SparselyPopulatedArrayFragment`1<T> Source { get; }
    internal int Index { get; }
    internal SparselyPopulatedArrayAddInfo`1(SparselyPopulatedArrayFragment`1<T> source, int index);
    internal SparselyPopulatedArrayFragment`1<T> get_Source();
    internal int get_Index();
}
[DefaultMemberAttribute("Item")]
internal class System.Threading.SparselyPopulatedArrayFragment`1 : object {
    internal T[] m_elements;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_freeCount;
    internal SparselyPopulatedArrayFragment`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_next;
    internal SparselyPopulatedArrayFragment`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_prev;
    internal T Item { get; }
    internal int Length { get; }
    internal SparselyPopulatedArrayFragment`1<T> Next { get; }
    internal SparselyPopulatedArrayFragment`1<T> Prev { get; }
    internal SparselyPopulatedArrayFragment`1(int size);
    internal SparselyPopulatedArrayFragment`1(int size, SparselyPopulatedArrayFragment`1<T> prev);
    internal T get_Item(int index);
    internal int get_Length();
    internal SparselyPopulatedArrayFragment`1<T> get_Next();
    internal SparselyPopulatedArrayFragment`1<T> get_Prev();
    internal T SafeAtomicRemove(int index, T expectedElement);
}
[DebuggerDisplayAttribute("IsHeld = {IsHeld}")]
[ComVisibleAttribute("False")]
[DebuggerTypeProxyAttribute("System.Threading.SpinLock/SystemThreading_SpinLockDebugView")]
public class System.Threading.SpinLock : ValueType {
    private static int SPINNING_FACTOR;
    private static int SLEEP_ONE_FREQUENCY;
    private static int SLEEP_ZERO_FREQUENCY;
    private static int TIMEOUT_CHECK_FREQUENCY;
    private static int LOCK_ID_DISABLE_MASK;
    private static int LOCK_ANONYMOUS_OWNED;
    private static int WAITERS_MASK;
    private static int LOCK_UNOWNED;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_owner;
    private static int MAXIMUM_WAITERS;
    public bool IsHeld { get; }
    public bool IsHeldByCurrentThread { get; }
    public bool IsThreadOwnerTrackingEnabled { get; }
    public SpinLock(bool enableThreadOwnerTracking);
    private static SpinLock();
    public void Enter(Boolean& lockTaken);
    public void TryEnter(Boolean& lockTaken);
    public void TryEnter(TimeSpan timeout, Boolean& lockTaken);
    public void TryEnter(int millisecondsTimeout, Boolean& lockTaken);
    private void ContinueTryEnter(int millisecondsTimeout, Boolean& lockTaken);
    private void DecrementWaiters();
    private void ContinueTryEnterWithThreadTracking(int millisecondsTimeout, long startTicks, Boolean& lockTaken);
    private static bool TimeoutExpired(long startTicks, int originalWaitTime);
    [ReliabilityContractAttribute("3", "2")]
public void Exit();
    [ReliabilityContractAttribute("3", "2")]
public void Exit(bool useMemoryBarrier);
    [ReliabilityContractAttribute("3", "2")]
public bool get_IsHeld();
    [ReliabilityContractAttribute("3", "2")]
public bool get_IsHeldByCurrentThread();
    [ReliabilityContractAttribute("3", "2")]
public bool get_IsThreadOwnerTrackingEnabled();
}
public class System.Threading.SpinWait : ValueType {
    internal static int YIELD_THRESHOLD;
    internal static int SLEEP_0_EVERY_HOW_MANY_TIMES;
    internal static int SLEEP_1_EVERY_HOW_MANY_TIMES;
    private int m_count;
    public int Count { get; }
    public bool NextSpinWillYield { get; }
    public int get_Count();
    public bool get_NextSpinWillYield();
    public void SpinOnce();
    public void Reset();
    public static void SpinUntil(Func`1<bool> condition);
    public static bool SpinUntil(Func`1<bool> condition, TimeSpan timeout);
    public static bool SpinUntil(Func`1<bool> condition, int millisecondsTimeout);
}
internal class System.Threading.StackCrawlMark2 : ValueType {
    internal static StackCrawlMark2 LookForMyCaller { get; }
    internal static StackCrawlMark2 get_LookForMyCaller();
}
internal class System.Threading.SystemThreading_ThreadLocalDebugView`1 : object {
    private ThreadLocal`1<T> m_tlocal;
    public bool IsValueCreated { get; }
    public T Value { get; }
    public SystemThreading_ThreadLocalDebugView`1(ThreadLocal`1<T> tlocal);
    public bool get_IsValueCreated();
    public T get_Value();
}
internal class System.Threading.Tasks.IndexRange : ValueType {
    internal long m_nFromInclusive;
    internal long m_nToExclusive;
    internal Shared`1<long> m_nSharedCurrentIndexOffset;
    internal int m_bRangeFinished;
}
[FlagsAttribute]
internal enum System.Threading.Tasks.InternalTaskOptions : Enum {
    public int value__;
    public static InternalTaskOptions None;
    public static InternalTaskOptions InternalOptionsMask;
    public static InternalTaskOptions ChildReplica;
    public static InternalTaskOptions ContinuationTask;
    public static InternalTaskOptions PromiseTask;
    public static InternalTaskOptions SelfReplicating;
    public static InternalTaskOptions QueuedByRuntime;
}
internal interface System.Threading.Tasks.IThreadPoolWorkItem {
    public abstract virtual void ExecuteWorkItem();
    public abstract virtual void MarkAborted(ThreadAbortException tae);
}
public static class System.Threading.Tasks.Parallel : object {
    internal static int DEFAULT_LOOP_STRIDE;
    internal static ParallelOptions s_defaultParallelOptions;
    [CompilerGeneratedAttribute]
private static Func`1<ConcurrentQueue`1<Exception>> CS$<>9__CachedAnonymousMethodDelegate3;
    private static Parallel();
    public static void Invoke(Action[] actions);
    public static void Invoke(ParallelOptions parallelOptions, Action[] actions);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, Action`1<int> body);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, Action`1<long> body);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Action`1<int> body);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Action`1<long> body);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, Action`2<int, ParallelLoopState> body);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, Action`2<long, ParallelLoopState> body);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Action`2<int, ParallelLoopState> body);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Action`2<long, ParallelLoopState> body);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, Func`1<TLocal> localInit, Func`4<int, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, Func`1<TLocal> localInit, Func`4<long, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult For(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`4<int, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult For(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`4<long, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    private static ParallelLoopResult ForWorker(int fromInclusive, int toExclusive, ParallelOptions parallelOptions, Action`1<int> body, Action`2<int, ParallelLoopState> bodyWithState, Func`4<int, ParallelLoopState, TLocal, TLocal> bodyWithLocal, Func`1<TLocal> localInit, Action`1<TLocal> localFinally);
    private static ParallelLoopResult ForWorker64(long fromInclusive, long toExclusive, ParallelOptions parallelOptions, Action`1<long> body, Action`2<long, ParallelLoopState> bodyWithState, Func`4<long, ParallelLoopState, TLocal, TLocal> bodyWithLocal, Func`1<TLocal> localInit, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Action`1<TSource> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Action`1<TSource> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Action`2<TSource, ParallelLoopState> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Action`2<TSource, ParallelLoopState> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Action`3<TSource, ParallelLoopState, long> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Action`3<TSource, ParallelLoopState, long> body);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Func`1<TLocal> localInit, Func`4<TSource, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`4<TSource, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, Func`1<TLocal> localInit, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    private static ParallelLoopResult ForEachWorker(IEnumerable`1<TSource> source, ParallelOptions parallelOptions, Action`1<TSource> body, Action`2<TSource, ParallelLoopState> bodyWithState, Action`3<TSource, ParallelLoopState, long> bodyWithStateAndIndex, Func`4<TSource, ParallelLoopState, TLocal, TLocal> bodyWithStateAndLocal, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> bodyWithEverything, Func`1<TLocal> localInit, Action`1<TLocal> localFinally);
    private static ParallelLoopResult ForEachWorker(TSource[] array, ParallelOptions parallelOptions, Action`1<TSource> body, Action`2<TSource, ParallelLoopState> bodyWithState, Action`3<TSource, ParallelLoopState, long> bodyWithStateAndIndex, Func`4<TSource, ParallelLoopState, TLocal, TLocal> bodyWithStateAndLocal, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> bodyWithEverything, Func`1<TLocal> localInit, Action`1<TLocal> localFinally);
    private static ParallelLoopResult ForEachWorker(IList`1<TSource> list, ParallelOptions parallelOptions, Action`1<TSource> body, Action`2<TSource, ParallelLoopState> bodyWithState, Action`3<TSource, ParallelLoopState, long> bodyWithStateAndIndex, Func`4<TSource, ParallelLoopState, TLocal, TLocal> bodyWithStateAndLocal, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> bodyWithEverything, Func`1<TLocal> localInit, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, Action`1<TSource> body);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, Action`2<TSource, ParallelLoopState> body);
    public static ParallelLoopResult ForEach(OrderablePartitioner`1<TSource> source, Action`3<TSource, ParallelLoopState, long> body);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, Func`1<TLocal> localInit, Func`4<TSource, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(OrderablePartitioner`1<TSource> source, Func`1<TLocal> localInit, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, ParallelOptions parallelOptions, Action`1<TSource> body);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, ParallelOptions parallelOptions, Action`2<TSource, ParallelLoopState> body);
    public static ParallelLoopResult ForEach(OrderablePartitioner`1<TSource> source, ParallelOptions parallelOptions, Action`3<TSource, ParallelLoopState, long> body);
    public static ParallelLoopResult ForEach(Partitioner`1<TSource> source, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`4<TSource, ParallelLoopState, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    public static ParallelLoopResult ForEach(OrderablePartitioner`1<TSource> source, ParallelOptions parallelOptions, Func`1<TLocal> localInit, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> body, Action`1<TLocal> localFinally);
    private static ParallelLoopResult PartitionerForEachWorker(Partitioner`1<TSource> source, ParallelOptions parallelOptions, Action`1<TSource> simpleBody, Action`2<TSource, ParallelLoopState> bodyWithState, Action`3<TSource, ParallelLoopState, long> bodyWithStateAndIndex, Func`4<TSource, ParallelLoopState, TLocal, TLocal> bodyWithStateAndLocal, Func`5<TSource, ParallelLoopState, long, TLocal, TLocal> bodyWithEverything, Func`1<TLocal> localInit, Action`1<TLocal> localFinally);
    internal static void ThrowIfReducableToSingleOCE(IEnumerable`1<Exception> excCollection, CancellationToken ct);
    [CompilerGeneratedAttribute]
private static ConcurrentQueue`1<Exception> <Invoke>b__2();
}
internal class System.Threading.Tasks.ParallelForReplicaTask : Task {
    internal object m_stateForNextReplica;
    internal object m_stateFromPreviousReplica;
    internal Task m_handedOverChildReplica;
    internal object SavedStateForNextReplica { get; internal set; }
    internal object SavedStateFromPreviousReplica { get; internal set; }
    internal Task HandedOverChildReplica { get; internal set; }
    internal ParallelForReplicaTask(Action`1<object> taskReplicaDelegate, object stateObject, Task parentTask, TaskScheduler taskScheduler, TaskCreationOptions creationOptionsForReplica, InternalTaskOptions internalOptionsForReplica);
    internal void SaveStateForNextReplica(object stateForNextReplica);
    internal virtual object get_SavedStateForNextReplica();
    internal virtual void set_SavedStateForNextReplica(object value);
    internal virtual object get_SavedStateFromPreviousReplica();
    internal virtual void set_SavedStateFromPreviousReplica(object value);
    internal virtual Task get_HandedOverChildReplica();
    internal virtual void set_HandedOverChildReplica(Task value);
}
internal class System.Threading.Tasks.ParallelForReplicatingTask : Task {
    private int m_replicationDownCount;
    internal ParallelForReplicatingTask(ParallelOptions parallelOptions, Action action, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual bool ShouldReplicate();
    internal virtual Task CreateReplicaTask(Action`1<object> taskReplicaDelegate, object stateObject, Task parentTask, TaskScheduler taskScheduler, TaskCreationOptions creationOptionsForReplica, InternalTaskOptions internalOptionsForReplica);
}
public class System.Threading.Tasks.ParallelLoopResult : ValueType {
    internal bool m_completed;
    internal Nullable`1<long> m_lowestBreakIteration;
    public bool IsCompleted { get; }
    public Nullable`1<long> LowestBreakIteration { get; }
    public bool get_IsCompleted();
    public Nullable`1<long> get_LowestBreakIteration();
}
[DebuggerDisplayAttribute("ShouldExitCurrentIteration = {ShouldExitCurrentIteration}")]
public class System.Threading.Tasks.ParallelLoopState : object {
    private ParallelLoopStateFlags m_flagsBase;
    internal bool InternalShouldExitCurrentIteration { get; }
    public bool ShouldExitCurrentIteration { get; }
    public bool IsStopped { get; }
    public bool IsExceptional { get; }
    internal Nullable`1<long> InternalLowestBreakIteration { get; }
    public Nullable`1<long> LowestBreakIteration { get; }
    internal ParallelLoopState(ParallelLoopStateFlags fbase);
    internal virtual bool get_InternalShouldExitCurrentIteration();
    public bool get_ShouldExitCurrentIteration();
    public bool get_IsStopped();
    public bool get_IsExceptional();
    internal virtual Nullable`1<long> get_InternalLowestBreakIteration();
    public Nullable`1<long> get_LowestBreakIteration();
    public void Stop();
    internal virtual void InternalBreak();
    public void Break();
    internal static void Break(int iteration, ParallelLoopStateFlags32 pflags);
    internal static void Break(long iteration, ParallelLoopStateFlags64 pflags);
}
internal class System.Threading.Tasks.ParallelLoopState32 : ParallelLoopState {
    private ParallelLoopStateFlags32 m_sharedParallelStateFlags;
    private int m_currentIteration;
    internal int CurrentIteration { get; internal set; }
    internal bool InternalShouldExitCurrentIteration { get; }
    internal Nullable`1<long> InternalLowestBreakIteration { get; }
    internal ParallelLoopState32(ParallelLoopStateFlags32 sharedParallelStateFlags);
    internal int get_CurrentIteration();
    internal void set_CurrentIteration(int value);
    internal virtual bool get_InternalShouldExitCurrentIteration();
    internal virtual Nullable`1<long> get_InternalLowestBreakIteration();
    internal virtual void InternalBreak();
}
internal class System.Threading.Tasks.ParallelLoopState64 : ParallelLoopState {
    private ParallelLoopStateFlags64 m_sharedParallelStateFlags;
    private long m_currentIteration;
    internal long CurrentIteration { get; internal set; }
    internal bool InternalShouldExitCurrentIteration { get; }
    internal Nullable`1<long> InternalLowestBreakIteration { get; }
    internal ParallelLoopState64(ParallelLoopStateFlags64 sharedParallelStateFlags);
    internal long get_CurrentIteration();
    internal void set_CurrentIteration(long value);
    internal virtual bool get_InternalShouldExitCurrentIteration();
    internal virtual Nullable`1<long> get_InternalLowestBreakIteration();
    internal virtual void InternalBreak();
}
internal class System.Threading.Tasks.ParallelLoopStateFlags : object {
    internal static int PLS_NONE;
    internal static int PLS_EXCEPTIONAL;
    internal static int PLS_BROKEN;
    internal static int PLS_STOPPED;
    internal static int PLS_CANCELED;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_LoopStateFlags;
    internal int LoopStateFlags { get; }
    private static ParallelLoopStateFlags();
    internal int get_LoopStateFlags();
    internal bool AtomicLoopStateUpdate(int newState, int illegalStates);
    internal bool AtomicLoopStateUpdate(int newState, int illegalStates, Int32& oldState);
    internal void SetExceptional();
    internal void Stop();
    internal bool Cancel();
}
internal class System.Threading.Tasks.ParallelLoopStateFlags32 : ParallelLoopStateFlags {
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_lowestBreakIteration;
    internal int LowestBreakIteration { get; }
    internal Nullable`1<long> NullableLowestBreakIteration { get; }
    internal int get_LowestBreakIteration();
    internal Nullable`1<long> get_NullableLowestBreakIteration();
    internal bool ShouldExitLoop(int CallerIteration);
    internal bool ShouldExitLoop();
}
internal class System.Threading.Tasks.ParallelLoopStateFlags64 : ParallelLoopStateFlags {
    internal long m_lowestBreakIteration;
    internal long LowestBreakIteration { get; }
    internal Nullable`1<long> NullableLowestBreakIteration { get; }
    internal long get_LowestBreakIteration();
    internal Nullable`1<long> get_NullableLowestBreakIteration();
    internal bool ShouldExitLoop(long CallerIteration);
    internal bool ShouldExitLoop();
}
public class System.Threading.Tasks.ParallelOptions : object {
    private TaskScheduler m_scheduler;
    private int m_maxDegreeOfParallelism;
    private CancellationToken m_cancellationToken;
    public TaskScheduler TaskScheduler { get; public set; }
    internal TaskScheduler EffectiveTaskScheduler { get; }
    public int MaxDegreeOfParallelism { get; public set; }
    public CancellationToken CancellationToken { get; public set; }
    internal int EffectiveMaxConcurrencyLevel { get; }
    public TaskScheduler get_TaskScheduler();
    public void set_TaskScheduler(TaskScheduler value);
    internal TaskScheduler get_EffectiveTaskScheduler();
    public int get_MaxDegreeOfParallelism();
    public void set_MaxDegreeOfParallelism(int value);
    public CancellationToken get_CancellationToken();
    public void set_CancellationToken(CancellationToken value);
    internal int get_EffectiveMaxConcurrencyLevel();
}
internal class System.Threading.Tasks.RangeManager : object {
    internal IndexRange[] m_indexRanges;
    internal int m_nCurrentIndexRangeToAssign;
    internal long m_nStep;
    internal RangeManager(long nFromInclusive, long nToExclusive, long nStep, int nNumExpectedWorkers);
    internal RangeWorker RegisterNewWorker();
}
internal class System.Threading.Tasks.RangeWorker : ValueType {
    internal IndexRange[] m_indexRanges;
    internal int m_nCurrentIndexRange;
    internal long m_nStep;
    internal long m_nIncrementValue;
    internal long m_nMaxIncrementValue;
    internal RangeWorker(IndexRange[] ranges, int nInitialRange, long nStep);
    internal bool FindNewWork(Int64& nFromInclusiveLocal, Int64& nToExclusiveLocal);
    internal bool FindNewWork32(Int32& nFromInclusiveLocal32, Int32& nToExclusiveLocal32);
}
internal class System.Threading.Tasks.Shared`1 : object {
    internal T Value;
    internal Shared`1(T value);
}
internal class System.Threading.Tasks.StackGuard : object {
    private static int s_maxUncheckedInliningDepth;
    private int m_inliningDepth;
    [SecuritySafeCriticalAttribute]
internal bool TryBeginInliningScope();
    [SecuritySafeCriticalAttribute]
internal void EndInliningScope();
    [SecurityCriticalAttribute]
private bool CheckForSufficientStack();
}
internal class System.Threading.Tasks.SynchronizationContextTaskScheduler : TaskScheduler {
    private SynchronizationContext m_synchronizationContext;
    private static SendOrPostCallback s_postCallback;
    public int MaximumConcurrencyLevel { get; }
    private static SynchronizationContextTaskScheduler();
    [SecurityCriticalAttribute]
protected internal virtual void QueueTask(Task task);
    [SecurityCriticalAttribute]
protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    [SecurityCriticalAttribute]
protected virtual IEnumerable`1<Task> GetScheduledTasks();
    public virtual int get_MaximumConcurrencyLevel();
    private static void PostCallback(object obj);
}
internal class System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1 : object {
    private Task`1<TResult> m_task;
    public TResult Result { get; }
    public object AsyncState { get; }
    public TaskCreationOptions CreationOptions { get; }
    public Exception Exception { get; }
    public int Id { get; }
    public bool CancellationPending { get; }
    public TaskStatus Status { get; }
    public SystemThreadingTasks_FutureDebugView`1(Task`1<TResult> task);
    public TResult get_Result();
    public object get_AsyncState();
    public TaskCreationOptions get_CreationOptions();
    public Exception get_Exception();
    public int get_Id();
    public bool get_CancellationPending();
    public TaskStatus get_Status();
}
internal class System.Threading.Tasks.SystemThreadingTasks_TaskDebugView : object {
    private Task m_task;
    public object AsyncState { get; }
    public TaskCreationOptions CreationOptions { get; }
    public Exception Exception { get; }
    public int Id { get; }
    public bool CancellationPending { get; }
    public TaskStatus Status { get; }
    public SystemThreadingTasks_TaskDebugView(Task task);
    public object get_AsyncState();
    public TaskCreationOptions get_CreationOptions();
    public Exception get_Exception();
    public int get_Id();
    public bool get_CancellationPending();
    public TaskStatus get_Status();
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SystemThreadingTasks_TaskDebugView")]
[DebuggerDisplayAttribute("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")]
public class System.Threading.Tasks.Task : object {
    private static int OptionsMask;
    internal static int TASK_STATE_STARTED;
    internal static int TASK_STATE_DELEGATE_INVOKED;
    internal static int TASK_STATE_DISPOSED;
    internal static int TASK_STATE_EXCEPTIONOBSERVEDBYPARENT;
    internal static int TASK_STATE_CANCELLATIONACKNOWLEDGED;
    internal static int TASK_STATE_FAULTED;
    internal static int TASK_STATE_CANCELED;
    internal static int TASK_STATE_WAITING_ON_CHILDREN;
    internal static int TASK_STATE_RAN_TO_COMPLETION;
    internal static int TASK_STATE_WAITINGFORACTIVATION;
    internal static int TASK_STATE_COMPLETION_RESERVED;
    internal static int TASK_STATE_THREAD_WAS_ABORTED;
    internal static int s_taskIdCounter;
    private static TaskFactory s_factory;
    private int m_taskId;
    internal object m_action;
    internal object m_stateObject;
    internal TaskScheduler m_taskScheduler;
    internal Task m_parent;
    internal ExecutionContext m_capturedContext;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_stateFlags;
    internal static int CANCELLATION_REQUESTED;
    private ManualResetEventSlim modreq(System.Runtime.CompilerServices.IsVolatile) m_completionEvent;
    internal ContingentProperties modreq(System.Runtime.CompilerServices.IsVolatile) m_contingentProperties;
    internal static Action`1<object> s_taskCancelCallback;
    internal static Func`1<ContingentProperties> s_contingentPropertyCreator;
    private static Predicate`1<Task> s_IsExceptionObservedByParentPredicate;
    [SecurityCriticalAttribute]
private static ContextCallback s_ecCallback;
    [CompilerGeneratedAttribute]
private static Predicate`1<Task> CS$<>9__CachedAnonymousMethodDelegate1;
    private string DebuggerDisplayMethodDescription { get; }
    internal TaskCreationOptions Options { get; }
    public int Id { get; }
    public static Nullable`1<int> CurrentId { get; }
    internal static Task InternalCurrent { get; }
    internal static StackGuard CurrentStackGuard { get; }
    public AggregateException Exception { get; }
    public TaskStatus Status { get; }
    public bool IsCanceled { get; }
    internal bool IsCancellationRequested { get; }
    internal CancellationToken CancellationToken { get; }
    internal bool IsCancellationAcknowledged { get; }
    public bool IsCompleted { get; }
    internal bool CompletedSuccessfully { get; }
    internal bool IsDisposed { get; }
    public TaskCreationOptions CreationOptions { get; }
    private WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }
    internal object InternalAsyncState { get; }
    public object AsyncState { get; }
    private bool System.IAsyncResult.CompletedSynchronously { get; }
    internal TaskScheduler ExecutingTaskScheduler { get; }
    public static TaskFactory Factory { get; }
    internal ManualResetEventSlim CompletedEvent { get; }
    internal bool IsSelfReplicatingRoot { get; }
    internal bool IsChildReplica { get; }
    internal int ActiveChildCount { get; }
    internal bool ExceptionRecorded { get; }
    public bool IsFaulted { get; }
    internal bool IsExceptionObservedByParent { get; }
    internal bool IsDelegateInvoked { get; }
    internal object SavedStateForNextReplica { get; internal set; }
    internal object SavedStateFromPreviousReplica { get; internal set; }
    internal Task HandedOverChildReplica { get; internal set; }
    [SecuritySafeCriticalAttribute]
private static Task();
    internal Task(bool canceled, TaskCreationOptions creationOptions);
    internal Task(object state, CancellationToken cancelationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, bool promiseStyle);
    public Task(Action action);
    public Task(Action action, CancellationToken cancellationToken);
    public Task(Action action, TaskCreationOptions creationOptions);
    public Task(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task(Action`1<object> action, object state);
    public Task(Action`1<object> action, object state, CancellationToken cancellationToken);
    public Task(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    public Task(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    internal Task(Action`1<object> action, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler, StackCrawlMark2& stackMark);
    internal Task(object action, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    internal void TaskConstructorCore(object action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    internal void DeregisterCancellationCallback();
    private static void TaskCancelCallback(object o);
    private string get_DebuggerDisplayMethodDescription();
    [SecuritySafeCriticalAttribute]
internal void PossiblyCaptureContext(StackCrawlMark2& stackMark);
    internal TaskCreationOptions get_Options();
    internal bool AtomicStateUpdate(int newBits, int illegalBits);
    internal bool AtomicStateUpdate(int newBits, int illegalBits, Int32& oldFlags);
    internal bool MarkStarted();
    internal void AddNewChild();
    internal void DisregardChild();
    public void Start();
    public void Start(TaskScheduler scheduler);
    public void RunSynchronously();
    public void RunSynchronously(TaskScheduler scheduler);
    [SecuritySafeCriticalAttribute]
internal void InternalRunSynchronously(TaskScheduler scheduler);
    internal static Task InternalStartNew(Task creatingTask, object action, object state, CancellationToken cancellationToken, TaskScheduler scheduler, TaskCreationOptions options, InternalTaskOptions internalOptions, StackCrawlMark2& stackMark);
    internal static Task InternalStartNew(Task creatingTask, object action, object state, TaskScheduler scheduler, TaskCreationOptions options, InternalTaskOptions internalOptions, ExecutionContext context);
    public int get_Id();
    public static Nullable`1<int> get_CurrentId();
    internal static Task get_InternalCurrent();
    internal static StackGuard get_CurrentStackGuard();
    public AggregateException get_Exception();
    public TaskStatus get_Status();
    public bool get_IsCanceled();
    internal bool get_IsCancellationRequested();
    private static ContingentProperties ContingentPropertyCreator();
    internal CancellationToken get_CancellationToken();
    internal bool get_IsCancellationAcknowledged();
    public sealed virtual bool get_IsCompleted();
    internal bool get_CompletedSuccessfully();
    internal bool get_IsDisposed();
    internal void ThrowIfDisposed();
    public TaskCreationOptions get_CreationOptions();
    private sealed virtual override WaitHandle System.IAsyncResult.get_AsyncWaitHandle();
    internal virtual object get_InternalAsyncState();
    public sealed virtual object get_AsyncState();
    private sealed virtual override bool System.IAsyncResult.get_CompletedSynchronously();
    internal TaskScheduler get_ExecutingTaskScheduler();
    public static TaskFactory get_Factory();
    internal ManualResetEventSlim get_CompletedEvent();
    private void SetCompleted();
    internal bool get_IsSelfReplicatingRoot();
    internal bool get_IsChildReplica();
    internal int get_ActiveChildCount();
    internal bool get_ExceptionRecorded();
    public bool get_IsFaulted();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [SecuritySafeCriticalAttribute]
internal void ScheduleAndStart(bool needsProtection);
    internal void AddException(object exceptionObject);
    private AggregateException GetExceptions(bool includeTaskCanceledExceptions);
    internal void ThrowIfExceptional(bool includeTaskCanceledExceptions);
    internal void UpdateExceptionObservedStatus();
    internal bool get_IsExceptionObservedByParent();
    internal bool get_IsDelegateInvoked();
    internal void Finish(bool bUserDelegateExecuted);
    internal void FinishStageTwo();
    private void FinishStageThree();
    internal void ProcessChildCompletion(Task childTask);
    internal void AddExceptionsFromChildren();
    internal void FinishThreadAbortedTask(bool bTAEAddedToExceptionHolder, bool delegateRan);
    private void Execute();
    internal virtual bool ShouldReplicate();
    internal virtual Task CreateReplicaTask(Action`1<object> taskReplicaDelegate, object stateObject, Task parentTask, TaskScheduler taskScheduler, TaskCreationOptions creationOptionsForReplica, InternalTaskOptions internalOptionsForReplica);
    internal virtual object get_SavedStateForNextReplica();
    internal virtual void set_SavedStateForNextReplica(object value);
    internal virtual object get_SavedStateFromPreviousReplica();
    internal virtual void set_SavedStateFromPreviousReplica(object value);
    internal virtual Task get_HandedOverChildReplica();
    internal virtual void set_HandedOverChildReplica(Task value);
    private static void ExecuteSelfReplicating(Task root);
    [SecurityCriticalAttribute]
private sealed virtual override void System.Threading.Tasks.IThreadPoolWorkItem.ExecuteWorkItem();
    [SecurityCriticalAttribute]
private sealed virtual override void System.Threading.Tasks.IThreadPoolWorkItem.MarkAborted(ThreadAbortException tae);
    [SecuritySafeCriticalAttribute]
internal bool ExecuteEntry(bool bPreventDoubleExecution);
    [SecurityCriticalAttribute]
private void ExecuteWithThreadLocal(Task& currentTaskSlot);
    [SecurityCriticalAttribute]
private static void ExecutionContextCallback(object obj);
    internal void InnerInvoke();
    internal void InnerInvokeWithArg(Task childTask);
    private void HandleException(Exception unhandledException);
    public void Wait();
    public bool Wait(TimeSpan timeout);
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool WrappedTryRunInline();
    private bool WrappedTryRunInline(TaskScheduler currentScheduler, object currentSchedulerStatics);
    internal bool InternalWait(int millisecondsTimeout, CancellationToken cancellationToken);
    [SecuritySafeCriticalAttribute]
internal bool InternalCancel(bool bCancelNonExecutingOnly);
    internal void RecordInternalCancellationRequest();
    internal void CancellationCleanupLogic();
    private void SetCancellationAcknowledged();
    private void FinishContinuations();
    internal bool ContinueWithIsRightKind(TaskContinuationOptions options);
    public Task ContinueWith(Action`1<Task> continuationAction);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task ContinueWith(Action`1<Task> continuationAction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, StackCrawlMark2& stackMark);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, StackCrawlMark2& stackMark);
    internal static void CreationOptionsFromContinuationOptions(TaskContinuationOptions continuationOptions, TaskCreationOptions& creationOptions, InternalTaskOptions& internalOptions);
    internal void ContinueWithCore(Task continuationTask, TaskScheduler scheduler, TaskContinuationOptions options);
    internal void AddCompletionAction(Action`1<Task> action);
    public static void WaitAll(Task[] tasks);
    public static bool WaitAll(Task[] tasks, TimeSpan timeout);
    public static bool WaitAll(Task[] tasks, int millisecondsTimeout);
    public static void WaitAll(Task[] tasks, CancellationToken cancellationToken);
    public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    private static bool WaitAllSTAAnd64Aware(WaitHandle[] waitHandles, int millisecondsTimeout, CancellationToken cancellationToken);
    internal static void FastWaitAll(Task[] tasks);
    internal static void AddExceptionsForCompletedTask(List`1& exceptions, Task t);
    public static int WaitAny(Task[] tasks);
    public static int WaitAny(Task[] tasks, TimeSpan timeout);
    public static int WaitAny(Task[] tasks, CancellationToken cancellationToken);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private static bool <.cctor>b__0(Task t);
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1")]
[DebuggerDisplayAttribute("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}, Result = {DebuggerDisplayResultDescription}")]
public class System.Threading.Tasks.Task`1 : Task {
    private object m_valueSelector;
    private TResult m_result;
    internal bool m_resultWasSet;
    private object m_futureState;
    private static TaskFactory`1<TResult> s_Factory;
    private string DebuggerDisplayResultDescription { get; }
    private string DebuggerDisplayMethodDescription { get; }
    [DebuggerBrowsableAttribute("0")]
public TResult Result { get; internal set; }
    public static TaskFactory`1<TResult> Factory { get; }
    internal object InternalAsyncState { get; }
    internal Task`1(object state, CancellationToken cancellationToken, TaskCreationOptions options, InternalTaskOptions internalOptions);
    internal Task`1(bool canceled, TResult result, TaskCreationOptions creationOptions);
    public Task`1(Func`1<TResult> function);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task`1(Func`2<object, TResult> function, object state);
    public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    internal Task`1(Func`1<TResult> valueSelector, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler, StackCrawlMark2& stackMark);
    internal Task`1(Func`1<TResult> valueSelector, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    internal Task`1(Func`2<object, TResult> valueSelector, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler, StackCrawlMark2& stackMark);
    internal Task`1(Func`2<object, TResult> valueSelector, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private static Task`1();
    internal static Task`1<TResult> StartNew(Task parent, Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler, StackCrawlMark2& stackMark);
    internal static Task`1<TResult> StartNew(Task parent, Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler, StackCrawlMark2& stackMark);
    private string get_DebuggerDisplayResultDescription();
    private string get_DebuggerDisplayMethodDescription();
    internal bool TrySetResult(TResult result);
    public TResult get_Result();
    internal void set_Result(TResult value);
    internal bool TrySetException(object exceptionObject);
    public static TaskFactory`1<TResult> get_Factory();
    internal virtual object get_InternalAsyncState();
    private static void InvokeFuture(object futureAsObj);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, StackCrawlMark2& stackMark);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, StackCrawlMark2& stackMark);
}
public class System.Threading.Tasks.TaskCanceledException : OperationCanceledException {
    private Task m_canceledTask;
    public Task Task { get; }
    public TaskCanceledException(string message);
    public TaskCanceledException(string message, Exception innerException);
    public TaskCanceledException(Task task);
    protected TaskCanceledException(SerializationInfo info, StreamingContext context);
    public Task get_Task();
}
public class System.Threading.Tasks.TaskCompletionSource`1 : object {
    private Task`1<TResult> m_task;
    public Task`1<TResult> Task { get; }
    public TaskCompletionSource`1(TaskCreationOptions creationOptions);
    public TaskCompletionSource`1(object state);
    public TaskCompletionSource`1(object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> get_Task();
    public bool TrySetException(Exception exception);
    public bool TrySetException(IEnumerable`1<Exception> exceptions);
    public void SetException(Exception exception);
    public void SetException(IEnumerable`1<Exception> exceptions);
    public bool TrySetResult(TResult result);
    public void SetResult(TResult result);
    public void SetCanceled();
    public bool TrySetCanceled();
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskContinuationOptions : Enum {
    public int value__;
    public static TaskContinuationOptions None;
    public static TaskContinuationOptions PreferFairness;
    public static TaskContinuationOptions LongRunning;
    public static TaskContinuationOptions AttachedToParent;
    public static TaskContinuationOptions NotOnRanToCompletion;
    public static TaskContinuationOptions NotOnFaulted;
    public static TaskContinuationOptions NotOnCanceled;
    public static TaskContinuationOptions OnlyOnRanToCompletion;
    public static TaskContinuationOptions OnlyOnFaulted;
    public static TaskContinuationOptions OnlyOnCanceled;
    public static TaskContinuationOptions ExecuteSynchronously;
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskCreationOptions : Enum {
    public int value__;
    public static TaskCreationOptions None;
    public static TaskCreationOptions PreferFairness;
    public static TaskCreationOptions LongRunning;
    public static TaskCreationOptions AttachedToParent;
}
internal class System.Threading.Tasks.TaskExceptionHolder : object {
    private List`1<Exception> m_exceptions;
    private bool m_isHandled;
    private Task m_task;
    internal TaskExceptionHolder(Task task);
    protected virtual void Finalize();
    internal void Add(object exceptionObject);
    private void MarkAsUnhandled();
    internal void MarkAsHandled(bool calledFromFinalizer);
    internal AggregateException CreateExceptionObject(bool calledFromFinalizer, Exception includeThisException);
}
[ExtensionAttribute]
public static class System.Threading.Tasks.TaskExtensions : object {
    [ExtensionAttribute]
public static Task Unwrap(Task`1<Task> task);
    [ExtensionAttribute]
public static Task`1<TResult> Unwrap(Task`1<Task`1<TResult>> task);
    [ExtensionAttribute]
private static bool TrySetFromTask(TaskCompletionSource`1<TResult> me, Task source);
}
public class System.Threading.Tasks.TaskFactory : object {
    private CancellationToken m_defaultCancellationToken;
    private TaskScheduler m_defaultScheduler;
    private TaskCreationOptions m_defaultCreationOptions;
    private TaskContinuationOptions m_defaultContinuationOptions;
    private TaskScheduler DefaultScheduler { get; }
    public CancellationToken CancellationToken { get; }
    public TaskScheduler Scheduler { get; }
    public TaskCreationOptions CreationOptions { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskFactory(CancellationToken cancellationToken);
    public TaskFactory(TaskScheduler scheduler);
    public TaskFactory(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    public TaskFactory(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private TaskScheduler get_DefaultScheduler();
    private TaskScheduler GetDefaultScheduler(Task currTask);
    internal static void CheckCreationOptions(TaskCreationOptions creationOptions);
    public CancellationToken get_CancellationToken();
    public TaskScheduler get_Scheduler();
    public TaskCreationOptions get_CreationOptions();
    public TaskContinuationOptions get_ContinuationOptions();
    public Task StartNew(Action action);
    public Task StartNew(Action action, CancellationToken cancellationToken);
    public Task StartNew(Action action, TaskCreationOptions creationOptions);
    public Task StartNew(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    internal Task StartNew(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    public Task StartNew(Action`1<object> action, object state);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken);
    public Task StartNew(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    private static void FromAsyncCoreLogic(IAsyncResult iar, Action`1<IAsyncResult> endMethod, TaskCompletionSource`1<object> tcs);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    private Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler, StackCrawlMark2& stackMark);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func_`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task FromAsync(Func_`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func_`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func_`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static void CheckFromAsyncOptions(TaskCreationOptions creationOptions, bool hasBeginMethod);
    internal static Task`1<bool> CommonCWAllLogic(Task[] tasksCopy);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private static Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark2& stackMark);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private static Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark2& stackMark);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark2& stackMark);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark2& stackMark);
    private static Task CreateCanceledTask(TaskContinuationOptions continuationOptions);
    internal static Task`1<Task> CommonCWAnyLogic(Task[] tasksCopy);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark2& stackMark);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark2& stackMark);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark2& stackMark);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark2& stackMark);
    internal static Task[] CheckMultiContinuationTasksAndCopy(Task[] tasks);
    internal static Task`1[] CheckMultiContinuationTasksAndCopy(Task`1[] tasks);
    internal static void CheckMultiTaskContinuationOptions(TaskContinuationOptions continuationOptions);
}
public class System.Threading.Tasks.TaskFactory`1 : object {
    private CancellationToken m_defaultCancellationToken;
    private TaskScheduler m_defaultScheduler;
    private TaskCreationOptions m_defaultCreationOptions;
    private TaskContinuationOptions m_defaultContinuationOptions;
    private TaskScheduler DefaultScheduler { get; }
    public CancellationToken CancellationToken { get; }
    public TaskScheduler Scheduler { get; }
    public TaskCreationOptions CreationOptions { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskFactory`1(CancellationToken cancellationToken);
    public TaskFactory`1(TaskScheduler scheduler);
    public TaskFactory`1(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    public TaskFactory`1(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private TaskScheduler get_DefaultScheduler();
    private TaskScheduler GetDefaultScheduler(Task currTask);
    public CancellationToken get_CancellationToken();
    public TaskScheduler get_Scheduler();
    public TaskCreationOptions get_CreationOptions();
    public TaskContinuationOptions get_ContinuationOptions();
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    private static void FromAsyncCoreLogic(IAsyncResult iar, Func`2<IAsyncResult, TResult> endMethod, TaskCompletionSource`1<TResult> tcs);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> FromAsyncImpl(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler, StackCrawlMark2& stackMark);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func_`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func_`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func_`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    private static Task`1<TResult> CreateCanceledTask(TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark2& stackMark);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark2& stackMark);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark2& stackMark);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler, StackCrawlMark2& stackMark);
}
[DebuggerTypeProxyAttribute("System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView")]
[DebuggerDisplayAttribute("Id={Id}")]
public abstract class System.Threading.Tasks.TaskScheduler : object {
    private static TaskScheduler s_defaultTaskScheduler;
    internal static int s_taskSchedulerIdCounter;
    private int m_taskSchedulerId;
    internal WeakReference m_weakReferenceToSelf;
    private static ConcurrentDictionary`2<WeakReference, object> s_activeTaskSchedulers;
    private static EventHandler`1<UnobservedTaskExceptionEventArgs> _unobservedTaskException;
    private static object _unobservedTaskExceptionLockObject;
    public int MaximumConcurrencyLevel { get; }
    internal bool RequiresAtomicStartTransition { get; }
    public static TaskScheduler Default { get; }
    public static TaskScheduler Current { get; }
    public int Id { get; }
    private static TaskScheduler();
    [SecurityCriticalAttribute]
protected internal abstract virtual void QueueTask(Task task);
    [SecurityCriticalAttribute]
protected abstract virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    [SecurityCriticalAttribute]
protected abstract virtual IEnumerable`1<Task> GetScheduledTasks();
    public virtual int get_MaximumConcurrencyLevel();
    [SecuritySafeCriticalAttribute]
internal virtual object GetThreadStatics();
    [SecuritySafeCriticalAttribute]
internal bool TryRunInline(Task task, bool taskWasPreviouslyQueued, object threadStatics);
    [SecuritySafeCriticalAttribute]
internal bool TryRunInline(Task task, bool taskWasPreviouslyQueued);
    [SecurityCriticalAttribute]
protected internal virtual bool TryDequeue(Task task);
    internal virtual void NotifyWorkItemProgress();
    internal virtual bool get_RequiresAtomicStartTransition();
    protected virtual void Finalize();
    public static TaskScheduler get_Default();
    public static TaskScheduler get_Current();
    public static TaskScheduler FromCurrentSynchronizationContext();
    public int get_Id();
    [SecurityCriticalAttribute]
protected bool TryExecuteTask(Task task);
    private static void add__unobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    private static void remove__unobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    [SecurityCriticalAttribute]
public static void add_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    [SecurityCriticalAttribute]
public static void remove_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    internal static void PublishUnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs ueea);
    [SecurityCriticalAttribute]
internal Task[] GetScheduledTasksForDebugger();
    [SecurityCriticalAttribute]
internal static TaskScheduler[] GetTaskSchedulersForDebugger();
    internal static void RegisterTaskScheduler(TaskScheduler ts);
    internal static void UnregisterTaskScheduler(TaskScheduler ts);
}
public class System.Threading.Tasks.TaskSchedulerException : Exception {
    public TaskSchedulerException(string message);
    public TaskSchedulerException(Exception innerException);
    public TaskSchedulerException(string message, Exception innerException);
    protected TaskSchedulerException(SerializationInfo info, StreamingContext context);
}
public enum System.Threading.Tasks.TaskStatus : Enum {
    public int value__;
    public static TaskStatus Created;
    public static TaskStatus WaitingForActivation;
    public static TaskStatus WaitingToRun;
    public static TaskStatus Running;
    public static TaskStatus WaitingForChildrenToComplete;
    public static TaskStatus RanToCompletion;
    public static TaskStatus Canceled;
    public static TaskStatus Faulted;
}
internal class System.Threading.Tasks.ThreadPoolTaskScheduler : TaskScheduler {
    private static ParameterizedThreadStart s_longRunningThreadWork;
    private static WaitCallback s_taskExecuteWaitCallback;
    internal bool RequiresAtomicStartTransition { get; }
    private static ThreadPoolTaskScheduler();
    private static void LongRunningThreadWork(object obj);
    [SecurityCriticalAttribute]
protected internal virtual void QueueTask(Task task);
    private static void TaskExecuteWaitCallback(object obj);
    [SecurityCriticalAttribute]
protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    [SecurityCriticalAttribute]
protected internal virtual bool TryDequeue(Task task);
    [SecurityCriticalAttribute]
protected virtual IEnumerable`1<Task> GetScheduledTasks();
    private IEnumerable`1<Task> FilterTasksFromWorkItems(IEnumerable`1<IThreadPoolWorkItem> tpwItems);
    internal virtual void NotifyWorkItemProgress();
    internal virtual bool get_RequiresAtomicStartTransition();
}
public class System.Threading.Tasks.UnobservedTaskExceptionEventArgs : EventArgs {
    private AggregateException m_exception;
    internal bool m_observed;
    public bool Observed { get; }
    public AggregateException Exception { get; }
    public UnobservedTaskExceptionEventArgs(AggregateException exception);
    public void SetObserved();
    public bool get_Observed();
    public AggregateException get_Exception();
}
[DebuggerDisplayAttribute("IsValueCreated={IsValueCreated}, Value={ValueForDebugDisplay}")]
[DebuggerTypeProxyAttribute("System.Threading.SystemThreading_ThreadLocalDebugView`1")]
public class System.Threading.ThreadLocal`1 : object {
    private static Type[] s_dummyTypes;
    private static int s_currentTypeId;
    private static ConcurrentStack`1<int> s_availableIndices;
    private static int TYPE_DIMENSIONS;
    internal static int MAXIMUM_TYPES_LENGTH;
    private HolderBase<T> m_holder;
    private Func`1<T> m_valueFactory;
    private int m_currentInstanceIndex;
    [DebuggerBrowsableAttribute("0")]
public T Value { get; public set; }
    public bool IsValueCreated { get; }
    internal T ValueForDebugDisplay { get; }
    public ThreadLocal`1(Func`1<T> valueFactory);
    private static ThreadLocal`1();
    protected virtual void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private bool FindNextTypeIndex();
    private Type[] GetTypesFromIndex();
    public virtual string ToString();
    public T get_Value();
    public void set_Value(T value);
    private Boxed<T> CreateValue();
    public bool get_IsValueCreated();
    internal T get_ValueForDebugDisplay();
}
internal static class System.Threading.ThreadLocalGlobalCounter : object {
    internal static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_fastPathCount;
    internal static int MAXIMUM_GLOBAL_COUNT;
    private static ThreadLocalGlobalCounter();
}
