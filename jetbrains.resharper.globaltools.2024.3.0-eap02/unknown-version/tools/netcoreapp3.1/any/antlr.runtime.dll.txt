public class antlr.ANTLRException : Exception {
    public ANTLRException(string s);
    public ANTLRException(string s, Exception inner);
}
public class antlr.ANTLRPanicException : ANTLRException {
    public ANTLRPanicException(string s);
    public ANTLRPanicException(string s, Exception inner);
}
public class antlr.ASTFactory : object {
    protected Type defaultASTNodeTypeObject_;
    protected ASTNodeCreator defaultCreator_;
    protected FactoryEntry[] heteroList_;
    protected Hashtable typename2creator_;
    public ASTFactory(string nodeTypeName);
    public ASTFactory(Type nodeType);
    public void setTokenTypeASTNodeType(int tokenType, string NodeTypeName);
    [ObsoleteAttribute("Replaced by setTokenTypeASTNodeType(int, string) since version 2.7.2.6", "True")]
public void registerFactory(int NodeType, string NodeTypeName);
    public void setTokenTypeASTNodeCreator(int NodeType, ASTNodeCreator creator);
    public void setASTNodeCreator(ASTNodeCreator creator);
    public void setMaxNodeType(int NodeType);
    public virtual void addASTChild(ASTPair& currentAST, AST child);
    public virtual AST create();
    public virtual AST create(int type);
    public virtual AST create(int type, string txt);
    public virtual AST create(int type, string txt, string ASTNodeTypeName);
    public virtual AST create(IToken tok, string ASTNodeTypeName);
    public virtual AST create(AST aNode);
    public virtual AST create(IToken tok);
    public virtual AST dup(AST t);
    public virtual AST dupList(AST t);
    public virtual AST dupTree(AST t);
    public virtual AST make(AST[] nodes);
    public virtual AST make(ASTArray nodes);
    public virtual void makeASTRoot(ASTPair& currentAST, AST root);
    public virtual void setASTNodeType(string t);
    public virtual void error(string e);
    private static Type loadNodeTypeObject(string nodeTypeName);
    private AST createFromAST(AST node);
    private AST createFromNodeName(string nodeTypeName);
    private AST createFromNodeType(int nodeTypeIndex);
    private AST createFromNodeTypeObject(Type nodeTypeObject);
}
public abstract class antlr.ASTNodeCreator : object {
    public string ASTNodeTypeName { get; }
    public abstract virtual string get_ASTNodeTypeName();
    public abstract virtual AST Create();
}
public class antlr.ASTNULLType : object {
    public int Type { get; public set; }
    public virtual void addChild(AST c);
    public virtual bool Equals(AST t);
    public virtual bool EqualsList(AST t);
    public virtual bool EqualsListPartial(AST t);
    public virtual bool EqualsTree(AST t);
    public virtual bool EqualsTreePartial(AST t);
    public virtual IEnumerator findAll(AST tree);
    public virtual IEnumerator findAllPartial(AST subtree);
    public virtual AST getFirstChild();
    public virtual AST getNextSibling();
    public virtual string getText();
    public virtual int get_Type();
    public virtual void set_Type(int value);
    public sealed virtual int getNumberOfChildren();
    public virtual void initialize(int t, string txt);
    public virtual void initialize(AST t);
    public virtual void initialize(IToken t);
    public virtual void setFirstChild(AST c);
    public virtual void setNextSibling(AST n);
    public virtual void setText(string text);
    public virtual void setType(int ttype);
    public virtual string ToString();
    public virtual string ToStringList();
    public virtual string ToStringTree();
    public sealed virtual object Clone();
}
public class antlr.ASTPair : ValueType {
    public AST root;
    public AST child;
    public void advanceChildToEnd();
    public ASTPair copy();
    private void reset();
    public virtual string ToString();
}
public interface antlr.ASTVisitor {
    public abstract virtual void visit(AST node);
}
public abstract class antlr.BaseAST : object {
    protected internal BaseAST down;
    protected internal BaseAST right;
    private static bool verboseStringConversion;
    private static String[] tokenNames;
    public int Type { get; public set; }
    private static BaseAST();
    public virtual void addChild(AST node);
    private void doWorkForFindAll(ArrayList v, AST target, bool partialMatch);
    public virtual bool Equals(object obj);
    public virtual bool Equals(AST t);
    public virtual bool EqualsList(AST t);
    public virtual bool EqualsListPartial(AST sub);
    public virtual bool EqualsTree(AST t);
    public virtual bool EqualsTreePartial(AST sub);
    public virtual IEnumerator findAll(AST target);
    public virtual IEnumerator findAllPartial(AST sub);
    public virtual AST getFirstChild();
    public virtual AST getNextSibling();
    public virtual string getText();
    public virtual int get_Type();
    public virtual void set_Type(int value);
    public sealed virtual int getNumberOfChildren();
    public abstract virtual void initialize(int t, string txt);
    public abstract virtual void initialize(AST t);
    public abstract virtual void initialize(IToken t);
    public virtual void removeChildren();
    public virtual void setFirstChild(AST c);
    public virtual void setNextSibling(AST n);
    public virtual void setText(string text);
    public virtual void setType(int ttype);
    public static void setVerboseStringConversion(bool verbose, String[] names);
    public virtual string ToString();
    public virtual string ToStringList();
    public virtual string ToStringTree();
    public virtual string ToTree();
    public virtual string ToTree(string prefix);
    public static string decode(string text);
    public static string encode(string text);
    public virtual void xmlSerializeNode(TextWriter outWriter);
    public virtual void xmlSerializeRootOpen(TextWriter outWriter);
    public virtual void xmlSerializeRootClose(TextWriter outWriter);
    public virtual void xmlSerialize(TextWriter outWriter);
    [ObsoleteAttribute("Deprecated since version 2.7.2. Use ASTFactory.dup() instead.", "False")]
public virtual object Clone();
    public virtual int GetHashCode();
}
public class antlr.ByteBuffer : InputBuffer {
    private static int BUF_SIZE;
    internal Stream input;
    private Byte[] buf;
    public ByteBuffer(Stream input_);
    public virtual void fill(int amount);
}
public class antlr.CharBuffer : InputBuffer {
    private static int BUF_SIZE;
    internal TextReader input;
    private Char[] buf;
    public CharBuffer(TextReader input_);
    public virtual void fill(int amount);
}
public class antlr.CharQueue : object {
    protected internal Char[] buffer;
    private int sizeLessOne;
    private int offset;
    protected internal int nbrEntries;
    public CharQueue(int minSize);
    public void append(char tok);
    public char elementAt(int idx);
    private void expand();
    public virtual void init(int size);
    public void reset();
    public void removeFirst();
}
public abstract class antlr.CharScanner : object {
    internal static char NO_CHAR;
    public static char EOF_CHAR;
    private EventHandlerList events_;
    internal static object EnterRuleEventKey;
    internal static object ExitRuleEventKey;
    internal static object DoneEventKey;
    internal static object ReportErrorEventKey;
    internal static object ReportWarningEventKey;
    internal static object NewLineEventKey;
    internal static object MatchEventKey;
    internal static object MatchNotEventKey;
    internal static object MisMatchEventKey;
    internal static object MisMatchNotEventKey;
    internal static object ConsumeEventKey;
    internal static object LAEventKey;
    internal static object SemPredEvaluatedEventKey;
    internal static object SynPredStartedEventKey;
    internal static object SynPredFailedEventKey;
    internal static object SynPredSucceededEventKey;
    protected internal StringBuilder text;
    protected bool saveConsumedInput;
    protected TokenCreator tokenCreator;
    protected char cached_LA1;
    protected char cached_LA2;
    protected bool caseSensitive;
    protected bool caseSensitiveLiterals;
    protected Hashtable literals;
    protected internal int tabsize;
    protected internal IToken returnToken_;
    protected internal LexerSharedInputState inputState;
    protected internal bool commitToPath;
    protected internal int traceDepth;
    protected internal EventHandlerList Events { get; }
    public CharScanner(InputBuffer cb);
    public CharScanner(LexerSharedInputState sharedState);
    private static CharScanner();
    protected internal EventHandlerList get_Events();
    public sealed virtual void add_EnterRule(TraceEventHandler value);
    public sealed virtual void remove_EnterRule(TraceEventHandler value);
    public sealed virtual void add_ExitRule(TraceEventHandler value);
    public sealed virtual void remove_ExitRule(TraceEventHandler value);
    public sealed virtual void add_Done(TraceEventHandler value);
    public sealed virtual void remove_Done(TraceEventHandler value);
    public sealed virtual void add_ErrorReported(MessageEventHandler value);
    public sealed virtual void remove_ErrorReported(MessageEventHandler value);
    public sealed virtual void add_WarningReported(MessageEventHandler value);
    public sealed virtual void remove_WarningReported(MessageEventHandler value);
    public sealed virtual void add_HitNewLine(NewLineEventHandler value);
    public sealed virtual void remove_HitNewLine(NewLineEventHandler value);
    public sealed virtual void add_MatchedChar(MatchEventHandler value);
    public sealed virtual void remove_MatchedChar(MatchEventHandler value);
    public sealed virtual void add_MatchedNotChar(MatchEventHandler value);
    public sealed virtual void remove_MatchedNotChar(MatchEventHandler value);
    public sealed virtual void add_MisMatchedChar(MatchEventHandler value);
    public sealed virtual void remove_MisMatchedChar(MatchEventHandler value);
    public sealed virtual void add_MisMatchedNotChar(MatchEventHandler value);
    public sealed virtual void remove_MisMatchedNotChar(MatchEventHandler value);
    public sealed virtual void add_ConsumedChar(TokenEventHandler value);
    public sealed virtual void remove_ConsumedChar(TokenEventHandler value);
    public sealed virtual void add_CharLA(TokenEventHandler value);
    public sealed virtual void remove_CharLA(TokenEventHandler value);
    public sealed virtual void add_SemPredEvaluated(SemanticPredicateEventHandler value);
    public sealed virtual void remove_SemPredEvaluated(SemanticPredicateEventHandler value);
    public sealed virtual void add_SynPredStarted(SyntacticPredicateEventHandler value);
    public sealed virtual void remove_SynPredStarted(SyntacticPredicateEventHandler value);
    public sealed virtual void add_SynPredFailed(SyntacticPredicateEventHandler value);
    public sealed virtual void remove_SynPredFailed(SyntacticPredicateEventHandler value);
    public sealed virtual void add_SynPredSucceeded(SyntacticPredicateEventHandler value);
    public sealed virtual void remove_SynPredSucceeded(SyntacticPredicateEventHandler value);
    public virtual IToken nextToken();
    public virtual void append(char c);
    public virtual void append(string s);
    public virtual void commit();
    public virtual void recover(RecognitionException ex, BitSet tokenSet);
    public virtual void consume();
    public virtual void consumeUntil(int c);
    public virtual void consumeUntil(BitSet bset);
    public virtual bool getCaseSensitive();
    public bool getCaseSensitiveLiterals();
    public virtual int getColumn();
    public virtual void setColumn(int c);
    public virtual bool getCommitToPath();
    public virtual string getFilename();
    public virtual InputBuffer getInputBuffer();
    public virtual LexerSharedInputState getInputState();
    public virtual void setInputState(LexerSharedInputState state);
    public virtual int getLine();
    public virtual string getText();
    public virtual IToken getTokenObject();
    public virtual char LA(int i);
    protected internal virtual IToken makeToken(int t);
    public virtual int mark();
    public virtual void match(char c);
    public virtual void match(int c);
    public virtual void match(BitSet b);
    public virtual void match(string s);
    public virtual void matchNot(char c);
    public virtual void matchNot(int c);
    public virtual void matchRange(int c1, int c2);
    public virtual void matchRange(char c1, char c2);
    public virtual void newline();
    public virtual void tab();
    public virtual void setTabSize(int size);
    public virtual int getTabSize();
    public virtual void panic();
    public virtual void panic(string s);
    public virtual void reportError(RecognitionException ex);
    public virtual void reportError(string s);
    public virtual void reportWarning(string s);
    public virtual void refresh();
    public virtual void resetState(InputBuffer ib);
    public void resetState(Stream s);
    public void resetState(TextReader tr);
    public virtual void resetText();
    public virtual void rewind(int pos);
    public virtual void setCaseSensitive(bool t);
    public virtual void setCommitToPath(bool commit);
    public virtual void setFilename(string f);
    public virtual void setLine(int line);
    public virtual void setText(string s);
    public virtual void setTokenObjectClass(string cl);
    public virtual void setTokenCreator(TokenCreator tokenCreator);
    public virtual int testLiteralsTable(int ttype);
    public virtual int testLiteralsTable(string someText, int ttype);
    public virtual char toLower(int c);
    public virtual void traceIndent();
    public virtual void traceIn(string rname);
    public virtual void traceOut(string rname);
    public virtual void uponEOF();
}
public class antlr.CharStreamException : ANTLRException {
    public CharStreamException(string s);
}
public class antlr.CharStreamIOException : CharStreamException {
    public IOException io;
    public CharStreamIOException(IOException io);
}
public interface antlr.collections.AST {
    public int Type { get; public set; }
    public abstract virtual void addChild(AST c);
    public abstract virtual bool Equals(AST t);
    public abstract virtual bool EqualsList(AST t);
    public abstract virtual bool EqualsListPartial(AST t);
    public abstract virtual bool EqualsTree(AST t);
    public abstract virtual bool EqualsTreePartial(AST t);
    public abstract virtual IEnumerator findAll(AST tree);
    public abstract virtual IEnumerator findAllPartial(AST subtree);
    public abstract virtual AST getFirstChild();
    public abstract virtual AST getNextSibling();
    public abstract virtual string getText();
    public abstract virtual int get_Type();
    public abstract virtual void set_Type(int value);
    public abstract virtual int getNumberOfChildren();
    public abstract virtual void initialize(int t, string txt);
    public abstract virtual void initialize(AST t);
    public abstract virtual void initialize(IToken t);
    public abstract virtual void setFirstChild(AST c);
    public abstract virtual void setNextSibling(AST n);
    public abstract virtual void setText(string text);
    public abstract virtual void setType(int ttype);
    public abstract virtual string ToString();
    public abstract virtual string ToStringList();
    public abstract virtual string ToStringTree();
}
public class antlr.collections.impl.ASTArray : object {
    public int size;
    public AST[] array;
    public ASTArray(int capacity);
    public virtual ASTArray add(AST node);
}
public class antlr.collections.impl.BitSet : object {
    protected internal static int BITS;
    protected internal static int NIBBLE;
    protected internal static int LOG_BITS;
    protected internal static int MOD_MASK;
    protected internal Int64[] dataBits;
    public BitSet(Int64[] bits_);
    public BitSet(int nbits);
    private static BitSet();
    public virtual void add(int el);
    public virtual BitSet and(BitSet a);
    public virtual void andInPlace(BitSet a);
    private static long bitMask(int bitNumber);
    public virtual void clear();
    public virtual void clear(int el);
    public virtual object Clone();
    public virtual int degree();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual void growToInclude(int bit);
    public virtual bool member(int el);
    public virtual bool nil();
    public virtual BitSet not();
    public virtual void notInPlace();
    public virtual void notInPlace(int maxBit);
    public virtual void notInPlace(int minBit, int maxBit);
    private int numWordsToHold(int el);
    public static BitSet of(int el);
    public virtual BitSet or(BitSet a);
    public virtual void orInPlace(BitSet a);
    public virtual void remove(int el);
    private void setSize(int nwords);
    public virtual int size();
    public virtual int lengthInLongWords();
    public virtual bool subset(BitSet a);
    public virtual void subtractInPlace(BitSet a);
    public virtual Int32[] toArray();
    public virtual Int64[] toPackedArray();
    public virtual string ToString();
    public virtual string ToString(string separator);
    public virtual string ToString(string separator, ArrayList vocabulary);
    public virtual string toStringOfHalfWords();
    public virtual string toStringOfWords();
    private static int wordNumber(int bit);
}
public class antlr.CommonAST : BaseAST {
    public static CommonASTCreator Creator;
    internal int ttype;
    internal string text;
    public int Type { get; public set; }
    [ObsoleteAttribute("Deprecated since version 2.7.2. Use ASTFactory.dup() instead.", "False")]
protected CommonAST(CommonAST another);
    public CommonAST(IToken tok);
    private static CommonAST();
    public virtual string getText();
    public virtual int get_Type();
    public virtual void set_Type(int value);
    public virtual void initialize(int t, string txt);
    public virtual void initialize(AST t);
    public virtual void initialize(IToken tok);
    public virtual void setText(string text_);
    public virtual void setType(int ttype_);
    [ObsoleteAttribute("Deprecated since version 2.7.2. Use ASTFactory.dup() instead.", "False")]
public virtual object Clone();
}
public class antlr.CommonASTWithHiddenTokens : CommonAST {
    public static CommonASTWithHiddenTokensCreator Creator;
    protected internal IHiddenStreamToken hiddenBefore;
    protected internal IHiddenStreamToken hiddenAfter;
    public CommonASTWithHiddenTokens(IToken tok);
    [ObsoleteAttribute("Deprecated since version 2.7.2. Use ASTFactory.dup() instead.", "False")]
protected CommonASTWithHiddenTokens(CommonASTWithHiddenTokens another);
    private static CommonASTWithHiddenTokens();
    public virtual IHiddenStreamToken getHiddenAfter();
    public virtual IHiddenStreamToken getHiddenBefore();
    public virtual void initialize(AST t);
    public virtual void initialize(IToken tok);
    [ObsoleteAttribute("Deprecated since version 2.7.2. Use ASTFactory.dup() instead.", "False")]
public virtual object Clone();
}
public class antlr.CommonHiddenStreamToken : CommonToken {
    public static CommonHiddenStreamTokenCreator Creator;
    protected internal IHiddenStreamToken hiddenBefore;
    protected internal IHiddenStreamToken hiddenAfter;
    public CommonHiddenStreamToken(int t, string txt);
    public CommonHiddenStreamToken(string s);
    private static CommonHiddenStreamToken();
    public virtual IHiddenStreamToken getHiddenAfter();
    public virtual IHiddenStreamToken getHiddenBefore();
    public virtual void setHiddenAfter(IHiddenStreamToken t);
    public virtual void setHiddenBefore(IHiddenStreamToken t);
}
public class antlr.CommonToken : Token {
    public static CommonTokenCreator Creator;
    protected internal int line;
    protected internal string text;
    protected internal int col;
    public CommonToken(int t, string txt);
    public CommonToken(string s);
    private static CommonToken();
    public virtual int getLine();
    public virtual string getText();
    public virtual void setLine(int l);
    public virtual void setText(string s);
    public virtual string ToString();
    public virtual int getColumn();
    public virtual void setColumn(int c);
}
public abstract class antlr.debug.ANTLREventArgs : EventArgs {
    private int type_;
    public int Type { get; public set; }
    public ANTLREventArgs(int type);
    public virtual int get_Type();
    public virtual void set_Type(int value);
    internal void setValues(int type);
}
public abstract class antlr.debug.DebuggingCharScanner : CharScanner {
    private ScannerEventSupport eventSupport;
    private bool _notDebugMode;
    protected internal String[] ruleNames;
    protected internal String[] semPredNames;
    public DebuggingCharScanner(InputBuffer cb);
    public DebuggingCharScanner(LexerSharedInputState state);
    private void InitBlock();
    public virtual void setDebugMode(bool mode);
    public virtual void addMessageListener(MessageListener l);
    public virtual void addNewLineListener(NewLineListener l);
    public virtual void addParserListener(ParserListener l);
    public virtual void addParserMatchListener(ParserMatchListener l);
    public virtual void addParserTokenListener(ParserTokenListener l);
    public virtual void addSemanticPredicateListener(SemanticPredicateListener l);
    public virtual void addSyntacticPredicateListener(SyntacticPredicateListener l);
    public virtual void addTraceListener(TraceListener l);
    public virtual void consume();
    protected internal virtual void fireEnterRule(int num, int data);
    protected internal virtual void fireExitRule(int num, int ttype);
    protected internal virtual bool fireSemanticPredicateEvaluated(int type, int num, bool condition);
    protected internal virtual void fireSyntacticPredicateFailed();
    protected internal virtual void fireSyntacticPredicateStarted();
    protected internal virtual void fireSyntacticPredicateSucceeded();
    public virtual string getRuleName(int num);
    public virtual string getSemPredName(int num);
    public virtual void goToSleep();
    public virtual bool isDebugMode();
    public virtual char LA(int i);
    protected internal virtual IToken makeToken(int t);
    public virtual void match(int c);
    public virtual void match(BitSet b);
    public virtual void match(string s);
    public virtual void matchNot(int c);
    public virtual void matchRange(int c1, int c2);
    public virtual void newline();
    public virtual void removeMessageListener(MessageListener l);
    public virtual void removeNewLineListener(NewLineListener l);
    public virtual void removeParserListener(ParserListener l);
    public virtual void removeParserMatchListener(ParserMatchListener l);
    public virtual void removeParserTokenListener(ParserTokenListener l);
    public virtual void removeSemanticPredicateListener(SemanticPredicateListener l);
    public virtual void removeSyntacticPredicateListener(SyntacticPredicateListener l);
    public virtual void removeTraceListener(TraceListener l);
    public virtual void reportError(MismatchedCharException e);
    public virtual void reportError(string s);
    public virtual void reportWarning(string s);
    public virtual void setupDebugging();
    public virtual void wakeUp();
}
public class antlr.debug.DebuggingInputBuffer : InputBuffer {
    private InputBuffer buffer;
    private InputBufferEventSupport inputBufferEventSupport;
    private bool debugMode;
    public ArrayList InputBufferListeners { get; }
    unknown bool DebugMode {public set; }
    public DebuggingInputBuffer(InputBuffer buffer);
    public virtual ArrayList get_InputBufferListeners();
    public virtual void set_DebugMode(bool value);
    public virtual void addInputBufferListener(InputBufferListener l);
    public virtual char consume();
    public virtual void fill(int a);
    public virtual bool isDebugMode();
    public virtual bool isMarked();
    public virtual char LA(int i);
    public virtual int mark();
    public virtual void removeInputBufferListener(InputBufferListener l);
    public virtual void rewind(int mark);
}
public interface antlr.debug.DebuggingParser {
    public abstract virtual string getRuleName(int n);
    public abstract virtual string getSemPredName(int n);
}
public abstract class antlr.debug.GuessingEventArgs : ANTLREventArgs {
    private int guessing_;
    public int Guessing { get; public set; }
    public GuessingEventArgs(int type);
    public virtual int get_Guessing();
    public virtual void set_Guessing(int value);
    public virtual void setValues(int type, int guessing);
}
public interface antlr.debug.ICharScannerDebugSubject {
    public abstract virtual void add_HitNewLine(NewLineEventHandler value);
    public abstract virtual void remove_HitNewLine(NewLineEventHandler value);
    public abstract virtual void add_MatchedChar(MatchEventHandler value);
    public abstract virtual void remove_MatchedChar(MatchEventHandler value);
    public abstract virtual void add_MatchedNotChar(MatchEventHandler value);
    public abstract virtual void remove_MatchedNotChar(MatchEventHandler value);
    public abstract virtual void add_MisMatchedChar(MatchEventHandler value);
    public abstract virtual void remove_MisMatchedChar(MatchEventHandler value);
    public abstract virtual void add_MisMatchedNotChar(MatchEventHandler value);
    public abstract virtual void remove_MisMatchedNotChar(MatchEventHandler value);
    public abstract virtual void add_ConsumedChar(TokenEventHandler value);
    public abstract virtual void remove_ConsumedChar(TokenEventHandler value);
    public abstract virtual void add_CharLA(TokenEventHandler value);
    public abstract virtual void remove_CharLA(TokenEventHandler value);
}
public interface antlr.debug.IDebugSubject {
    public abstract virtual void add_EnterRule(TraceEventHandler value);
    public abstract virtual void remove_EnterRule(TraceEventHandler value);
    public abstract virtual void add_ExitRule(TraceEventHandler value);
    public abstract virtual void remove_ExitRule(TraceEventHandler value);
    public abstract virtual void add_Done(TraceEventHandler value);
    public abstract virtual void remove_Done(TraceEventHandler value);
    public abstract virtual void add_ErrorReported(MessageEventHandler value);
    public abstract virtual void remove_ErrorReported(MessageEventHandler value);
    public abstract virtual void add_WarningReported(MessageEventHandler value);
    public abstract virtual void remove_WarningReported(MessageEventHandler value);
    public abstract virtual void add_SemPredEvaluated(SemanticPredicateEventHandler value);
    public abstract virtual void remove_SemPredEvaluated(SemanticPredicateEventHandler value);
    public abstract virtual void add_SynPredStarted(SyntacticPredicateEventHandler value);
    public abstract virtual void remove_SynPredStarted(SyntacticPredicateEventHandler value);
    public abstract virtual void add_SynPredFailed(SyntacticPredicateEventHandler value);
    public abstract virtual void remove_SynPredFailed(SyntacticPredicateEventHandler value);
    public abstract virtual void add_SynPredSucceeded(SyntacticPredicateEventHandler value);
    public abstract virtual void remove_SynPredSucceeded(SyntacticPredicateEventHandler value);
}
public class antlr.debug.InputBufferEventArgs : ANTLREventArgs {
    public static int CONSUME;
    public static int LA;
    public static int MARK;
    public static int REWIND;
    internal char c_;
    internal int lookaheadAmount_;
    public char Char { get; public set; }
    public int LookaheadAmount { get; public set; }
    public InputBufferEventArgs(int type, char c, int lookaheadAmount);
    public virtual char get_Char();
    public virtual void set_Char(char value);
    public virtual int get_LookaheadAmount();
    public virtual void set_LookaheadAmount(int value);
    internal void setValues(int type, char c, int la);
    public virtual string ToString();
}
public class antlr.debug.InputBufferEventSupport : object {
    protected internal static int CONSUME;
    protected internal static int LA;
    protected internal static int MARK;
    protected internal static int REWIND;
    private object source;
    private ArrayList inputBufferListeners;
    private InputBufferEventArgs inputBufferEvent;
    public ArrayList InputBufferListeners { get; }
    public InputBufferEventSupport(object source);
    public virtual ArrayList get_InputBufferListeners();
    public virtual void addInputBufferListener(InputBufferListener l);
    public virtual void fireConsume(char c);
    public virtual void fireEvent(int type, Listener l);
    public virtual void fireEvents(int type, ArrayList listeners);
    public virtual void fireLA(char c, int la);
    public virtual void fireMark(int pos);
    public virtual void fireRewind(int pos);
    protected internal virtual void refresh(ArrayList listeners);
    public virtual void refreshListeners();
    public virtual void removeInputBufferListener(InputBufferListener l);
}
public interface antlr.debug.InputBufferListener {
    public abstract virtual void inputBufferConsume(object source, InputBufferEventArgs e);
    public abstract virtual void inputBufferLA(object source, InputBufferEventArgs e);
    public abstract virtual void inputBufferMark(object source, InputBufferEventArgs e);
    public abstract virtual void inputBufferRewind(object source, InputBufferEventArgs e);
}
public abstract class antlr.debug.InputBufferListenerBase : object {
    public virtual void doneParsing(object source, TraceEventArgs e);
    public virtual void inputBufferConsume(object source, InputBufferEventArgs e);
    public virtual void inputBufferLA(object source, InputBufferEventArgs e);
    public virtual void inputBufferMark(object source, InputBufferEventArgs e);
    public virtual void inputBufferRewind(object source, InputBufferEventArgs e);
    public virtual void refresh();
}
public class antlr.debug.InputBufferReporter : InputBufferListenerBase {
    public virtual void inputBufferChanged(object source, InputBufferEventArgs e);
    public virtual void inputBufferConsume(object source, InputBufferEventArgs e);
    public virtual void inputBufferLA(object source, InputBufferEventArgs e);
    public virtual void inputBufferMark(object source, InputBufferEventArgs e);
    public virtual void inputBufferRewind(object source, InputBufferEventArgs e);
}
public interface antlr.debug.IParserDebugSubject {
    public abstract virtual void add_MatchedToken(MatchEventHandler value);
    public abstract virtual void remove_MatchedToken(MatchEventHandler value);
    public abstract virtual void add_MatchedNotToken(MatchEventHandler value);
    public abstract virtual void remove_MatchedNotToken(MatchEventHandler value);
    public abstract virtual void add_MisMatchedToken(MatchEventHandler value);
    public abstract virtual void remove_MisMatchedToken(MatchEventHandler value);
    public abstract virtual void add_MisMatchedNotToken(MatchEventHandler value);
    public abstract virtual void remove_MisMatchedNotToken(MatchEventHandler value);
    public abstract virtual void add_ConsumedToken(TokenEventHandler value);
    public abstract virtual void remove_ConsumedToken(TokenEventHandler value);
    public abstract virtual void add_TokenLA(TokenEventHandler value);
    public abstract virtual void remove_TokenLA(TokenEventHandler value);
}
public interface antlr.debug.Listener {
    public abstract virtual void doneParsing(object source, TraceEventArgs e);
    public abstract virtual void refresh();
}
public class antlr.debug.LLkDebuggingParser : LLkParser {
    protected internal ParserEventSupport parserEventSupport;
    private bool _notDebugMode;
    protected internal String[] ruleNames;
    protected internal String[] semPredNames;
    public LLkDebuggingParser(int k_);
    public LLkDebuggingParser(ParserSharedInputState state, int k_);
    public LLkDebuggingParser(TokenBuffer tokenBuf, int k_);
    public LLkDebuggingParser(TokenStream lexer, int k_);
    private void InitBlock();
    public virtual void setDebugMode(bool mode);
    public virtual void addMessageListener(MessageListener l);
    public virtual void addParserListener(ParserListener l);
    public virtual void addParserMatchListener(ParserMatchListener l);
    public virtual void addParserTokenListener(ParserTokenListener l);
    public virtual void addSemanticPredicateListener(SemanticPredicateListener l);
    public virtual void addSyntacticPredicateListener(SyntacticPredicateListener l);
    public virtual void addTraceListener(TraceListener l);
    public virtual void consume();
    protected internal virtual void fireEnterRule(int num, int data);
    protected internal virtual void fireExitRule(int num, int data);
    protected internal virtual bool fireSemanticPredicateEvaluated(int type, int num, bool condition);
    protected internal virtual void fireSyntacticPredicateFailed();
    protected internal virtual void fireSyntacticPredicateStarted();
    protected internal virtual void fireSyntacticPredicateSucceeded();
    public virtual string getRuleName(int num);
    public virtual string getSemPredName(int num);
    public virtual void goToSleep();
    public virtual bool isDebugMode();
    public virtual bool isGuessing();
    public virtual int LA(int i);
    public virtual void match(int t);
    public virtual void match(BitSet b);
    public virtual void matchNot(int t);
    public virtual void removeMessageListener(MessageListener l);
    public virtual void removeParserListener(ParserListener l);
    public virtual void removeParserMatchListener(ParserMatchListener l);
    public virtual void removeParserTokenListener(ParserTokenListener l);
    public virtual void removeSemanticPredicateListener(SemanticPredicateListener l);
    public virtual void removeSyntacticPredicateListener(SyntacticPredicateListener l);
    public virtual void removeTraceListener(TraceListener l);
    public virtual void reportError(RecognitionException ex);
    public virtual void reportError(string s);
    public virtual void reportWarning(string s);
    public virtual void setupDebugging(TokenBuffer tokenBuf);
    public virtual void setupDebugging(TokenStream lexer);
    protected internal virtual void setupDebugging(TokenStream lexer, TokenBuffer tokenBuf);
    public virtual void wakeUp();
}
public class antlr.debug.MatchEventArgs : GuessingEventArgs {
    public static int TOKEN;
    public static int BITSET;
    public static int CHAR;
    public static int CHAR_BITSET;
    public static int STRING;
    public static int CHAR_RANGE;
    private bool inverse_;
    private bool matched_;
    private object target_;
    private int val_;
    private string text_;
    public object Target { get; public set; }
    public string Text { get; public set; }
    public int Value { get; public set; }
    unknown bool Inverse {internal set; }
    unknown bool Matched {internal set; }
    public MatchEventArgs(int type, int val, object target, string text, int guessing, bool inverse, bool matched);
    private static MatchEventArgs();
    public virtual object get_Target();
    public virtual void set_Target(object value);
    public virtual string get_Text();
    public virtual void set_Text(string value);
    public virtual int get_Value();
    public virtual void set_Value(int value);
    internal void set_Inverse(bool value);
    internal void set_Matched(bool value);
    public virtual bool isInverse();
    public virtual bool isMatched();
    internal void setValues(int type, int val, object target, string text, int guessing, bool inverse, bool matched);
    public virtual string ToString();
}
public class antlr.debug.MatchEventHandler : MulticastDelegate {
    public MatchEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, MatchEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, MatchEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class antlr.debug.MessageEventArgs : ANTLREventArgs {
    private string text_;
    public static int WARNING;
    public static int ERROR;
    public string Text { get; public set; }
    public MessageEventArgs(int type, string text);
    private static MessageEventArgs();
    public virtual string get_Text();
    public virtual void set_Text(string value);
    internal void setValues(int type, string text);
    public virtual string ToString();
}
public class antlr.debug.MessageEventHandler : MulticastDelegate {
    public MessageEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, MessageEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, MessageEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface antlr.debug.MessageListener {
    public abstract virtual void reportError(object source, MessageEventArgs e);
    public abstract virtual void reportWarning(object source, MessageEventArgs e);
}
public class antlr.debug.MessageListenerBase : object {
    public virtual void doneParsing(object source, TraceEventArgs e);
    public virtual void refresh();
    public virtual void reportError(object source, MessageEventArgs e);
    public virtual void reportWarning(object source, MessageEventArgs e);
}
public class antlr.debug.NewLineEventArgs : ANTLREventArgs {
    private int line_;
    public int Line { get; public set; }
    public NewLineEventArgs(int line);
    public virtual int get_Line();
    public virtual void set_Line(int value);
    public virtual string ToString();
}
public class antlr.debug.NewLineEventHandler : MulticastDelegate {
    public NewLineEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NewLineEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NewLineEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface antlr.debug.NewLineListener {
    public abstract virtual void hitNewLine(object source, NewLineEventArgs e);
}
public interface antlr.debug.ParserController {
    unknown ParserEventSupport ParserEventSupport {public set; }
    public abstract virtual void set_ParserEventSupport(ParserEventSupport value);
    public abstract virtual void checkBreak();
}
public class antlr.debug.ParserEventSupport : object {
    private object source;
    private Hashtable listeners;
    private MatchEventArgs matchEvent;
    private MessageEventArgs messageEvent;
    private TokenEventArgs tokenEvent;
    private SemanticPredicateEventArgs semPredEvent;
    private SyntacticPredicateEventArgs synPredEvent;
    private TraceEventArgs traceEvent;
    private NewLineEventArgs newLineEvent;
    private ParserController controller;
    private int ruleDepth;
    public ParserEventSupport(object source);
    public virtual void checkController();
    public virtual void addDoneListener(Listener l);
    public virtual void addMessageListener(MessageListener l);
    public virtual void addParserListener(ParserListener l);
    public virtual void addParserMatchListener(ParserMatchListener l);
    public virtual void addParserTokenListener(ParserTokenListener l);
    public virtual void addSemanticPredicateListener(SemanticPredicateListener l);
    public virtual void addSyntacticPredicateListener(SyntacticPredicateListener l);
    public virtual void addTraceListener(TraceListener l);
    public virtual void fireConsume(int c);
    public virtual void fireDoneParsing();
    public virtual void fireEnterRule(int ruleNum, int guessing, int data);
    public virtual void fireExitRule(int ruleNum, int guessing, int data);
    public virtual void fireLA(int k, int la);
    public virtual void fireMatch(char c, int guessing);
    public virtual void fireMatch(char c, BitSet b, int guessing);
    public virtual void fireMatch(char c, string target, int guessing);
    public virtual void fireMatch(int c, BitSet b, string text, int guessing);
    public virtual void fireMatch(int n, string text, int guessing);
    public virtual void fireMatch(string s, int guessing);
    public virtual void fireMatchNot(char c, char n, int guessing);
    public virtual void fireMatchNot(int c, int n, string text, int guessing);
    public virtual void fireMismatch(char c, char n, int guessing);
    public virtual void fireMismatch(char c, BitSet b, int guessing);
    public virtual void fireMismatch(char c, string target, int guessing);
    public virtual void fireMismatch(int i, int n, string text, int guessing);
    public virtual void fireMismatch(int i, BitSet b, string text, int guessing);
    public virtual void fireMismatch(string s, string text, int guessing);
    public virtual void fireMismatchNot(char v, char c, int guessing);
    public virtual void fireMismatchNot(int i, int n, string text, int guessing);
    public virtual void fireReportError(Exception e);
    public virtual void fireReportError(string s);
    public virtual void fireReportWarning(string s);
    public virtual bool fireSemanticPredicateEvaluated(int type, int condition, bool result, int guessing);
    public virtual void fireSyntacticPredicateFailed(int guessing);
    public virtual void fireSyntacticPredicateStarted(int guessing);
    public virtual void fireSyntacticPredicateSucceeded(int guessing);
    public virtual void refreshListeners();
    public virtual void removeDoneListener(Listener l);
    public virtual void removeMessageListener(MessageListener l);
    public virtual void removeParserListener(ParserListener l);
    public virtual void removeParserMatchListener(ParserMatchListener l);
    public virtual void removeParserTokenListener(ParserTokenListener l);
    public virtual void removeSemanticPredicateListener(SemanticPredicateListener l);
    public virtual void removeSyntacticPredicateListener(SyntacticPredicateListener l);
    public virtual void removeTraceListener(TraceListener l);
}
public interface antlr.debug.ParserListener {
}
public class antlr.debug.ParserListenerBase : object {
    public virtual void doneParsing(object source, TraceEventArgs e);
    public virtual void enterRule(object source, TraceEventArgs e);
    public virtual void exitRule(object source, TraceEventArgs e);
    public virtual void parserConsume(object source, TokenEventArgs e);
    public virtual void parserLA(object source, TokenEventArgs e);
    public virtual void parserMatch(object source, MatchEventArgs e);
    public virtual void parserMatchNot(object source, MatchEventArgs e);
    public virtual void parserMismatch(object source, MatchEventArgs e);
    public virtual void parserMismatchNot(object source, MatchEventArgs e);
    public virtual void reportError(object source, MessageEventArgs e);
    public virtual void reportWarning(object source, MessageEventArgs e);
    public virtual void semanticPredicateEvaluated(object source, SemanticPredicateEventArgs e);
    public virtual void syntacticPredicateFailed(object source, SyntacticPredicateEventArgs e);
    public virtual void syntacticPredicateStarted(object source, SyntacticPredicateEventArgs e);
    public virtual void syntacticPredicateSucceeded(object source, SyntacticPredicateEventArgs e);
    public virtual void refresh();
}
public interface antlr.debug.ParserMatchListener {
    public abstract virtual void parserMatch(object source, MatchEventArgs e);
    public abstract virtual void parserMatchNot(object source, MatchEventArgs e);
    public abstract virtual void parserMismatch(object source, MatchEventArgs e);
    public abstract virtual void parserMismatchNot(object source, MatchEventArgs e);
}
public abstract class antlr.debug.ParserMatchListenerBase : object {
    public virtual void doneParsing(object source, TraceEventArgs e);
    public virtual void parserMatch(object source, MatchEventArgs e);
    public virtual void parserMatchNot(object source, MatchEventArgs e);
    public virtual void parserMismatch(object source, MatchEventArgs e);
    public virtual void parserMismatchNot(object source, MatchEventArgs e);
    public virtual void refresh();
}
public class antlr.debug.ParserReporter : Tracer {
    public virtual void parserConsume(object source, TokenEventArgs e);
    public virtual void parserLA(object source, TokenEventArgs e);
    public virtual void parserMatch(object source, MatchEventArgs e);
    public virtual void parserMatchNot(object source, MatchEventArgs e);
    public virtual void parserMismatch(object source, MatchEventArgs e);
    public virtual void parserMismatchNot(object source, MatchEventArgs e);
    public virtual void reportError(object source, MessageEventArgs e);
    public virtual void reportWarning(object source, MessageEventArgs e);
    public virtual void semanticPredicateEvaluated(object source, SemanticPredicateEventArgs e);
    public virtual void syntacticPredicateFailed(object source, SyntacticPredicateEventArgs e);
    public virtual void syntacticPredicateStarted(object source, SyntacticPredicateEventArgs e);
    public virtual void syntacticPredicateSucceeded(object source, SyntacticPredicateEventArgs e);
}
public interface antlr.debug.ParserTokenListener {
    public abstract virtual void parserConsume(object source, TokenEventArgs e);
    public abstract virtual void parserLA(object source, TokenEventArgs e);
}
public abstract class antlr.debug.ParserTokenListenerBase : object {
    public virtual void doneParsing(object source, TraceEventArgs e);
    public virtual void refresh();
    public virtual void parserConsume(object source, TokenEventArgs e);
    public virtual void parserLA(object source, TokenEventArgs e);
}
public class antlr.debug.ParseTreeDebugParser : LLkParser {
    protected Stack currentParseTreeRoot;
    protected ParseTreeRule mostRecentParseTreeRoot;
    protected int numberOfDerivationSteps;
    public ParseTreeDebugParser(int k_);
    public ParseTreeDebugParser(ParserSharedInputState state, int k_);
    public ParseTreeDebugParser(TokenBuffer tokenBuf, int k_);
    public ParseTreeDebugParser(TokenStream lexer, int k_);
    public ParseTree getParseTree();
    public int getNumberOfDerivationSteps();
    public virtual void match(int i);
    public virtual void match(BitSet bitSet);
    public virtual void matchNot(int i);
    protected void addCurrentTokenToParseTree();
    public virtual void traceIn(string s);
    public virtual void traceOut(string s);
}
public class antlr.debug.ScannerEventSupport : object {
    private object source;
    private Hashtable listeners;
    private MatchEventArgs matchEvent;
    private MessageEventArgs messageEvent;
    private TokenEventArgs tokenEvent;
    private SemanticPredicateEventArgs semPredEvent;
    private SyntacticPredicateEventArgs synPredEvent;
    private TraceEventArgs traceEvent;
    private NewLineEventArgs newLineEvent;
    private int ruleDepth;
    public ScannerEventSupport(object source);
    public virtual void checkController();
    public virtual void addDoneListener(Listener l);
    public virtual void addMessageListener(MessageListener l);
    public virtual void addNewLineListener(NewLineListener l);
    public virtual void addParserListener(ParserListener l);
    public virtual void addParserMatchListener(ParserMatchListener l);
    public virtual void addParserTokenListener(ParserTokenListener l);
    public virtual void addSemanticPredicateListener(SemanticPredicateListener l);
    public virtual void addSyntacticPredicateListener(SyntacticPredicateListener l);
    public virtual void addTraceListener(TraceListener l);
    public virtual void fireConsume(int c);
    public virtual void fireDoneParsing();
    public virtual void fireEnterRule(int ruleNum, int guessing, int data);
    public virtual void fireExitRule(int ruleNum, int guessing, int data);
    public virtual void fireLA(int k, int la);
    public virtual void fireMatch(char c, int guessing);
    public virtual void fireMatch(char c, BitSet b, int guessing);
    public virtual void fireMatch(char c, string target, int guessing);
    public virtual void fireMatch(int c, BitSet b, string text, int guessing);
    public virtual void fireMatch(int n, string text, int guessing);
    public virtual void fireMatch(string s, int guessing);
    public virtual void fireMatchNot(char c, char n, int guessing);
    public virtual void fireMatchNot(int c, int n, string text, int guessing);
    public virtual void fireMismatch(char c, char n, int guessing);
    public virtual void fireMismatch(char c, BitSet b, int guessing);
    public virtual void fireMismatch(char c, string target, int guessing);
    public virtual void fireMismatch(int i, int n, string text, int guessing);
    public virtual void fireMismatch(int i, BitSet b, string text, int guessing);
    public virtual void fireMismatch(string s, string text, int guessing);
    public virtual void fireMismatchNot(char v, char c, int guessing);
    public virtual void fireMismatchNot(int i, int n, string text, int guessing);
    public virtual void fireNewLine(int line);
    public virtual void fireReportError(Exception e);
    public virtual void fireReportError(string s);
    public virtual void fireReportWarning(string s);
    public virtual bool fireSemanticPredicateEvaluated(int type, int condition, bool result, int guessing);
    public virtual void fireSyntacticPredicateFailed(int guessing);
    public virtual void fireSyntacticPredicateStarted(int guessing);
    public virtual void fireSyntacticPredicateSucceeded(int guessing);
    public virtual void refreshListeners();
    public virtual void removeDoneListener(Listener l);
    public virtual void removeMessageListener(MessageListener l);
    public virtual void removeNewLineListener(NewLineListener l);
    public virtual void removeParserListener(ParserListener l);
    public virtual void removeParserMatchListener(ParserMatchListener l);
    public virtual void removeParserTokenListener(ParserTokenListener l);
    public virtual void removeSemanticPredicateListener(SemanticPredicateListener l);
    public virtual void removeSyntacticPredicateListener(SyntacticPredicateListener l);
    public virtual void removeTraceListener(TraceListener l);
}
public class antlr.debug.SemanticPredicateEventArgs : GuessingEventArgs {
    public static int VALIDATING;
    public static int PREDICTING;
    private int condition_;
    private bool result_;
    public int Condition { get; public set; }
    public bool Result { get; public set; }
    public SemanticPredicateEventArgs(int type);
    public virtual int get_Condition();
    public virtual void set_Condition(int value);
    public virtual bool get_Result();
    public virtual void set_Result(bool value);
    internal void setValues(int type, int condition, bool result, int guessing);
    public virtual string ToString();
}
public class antlr.debug.SemanticPredicateEventHandler : MulticastDelegate {
    public SemanticPredicateEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SemanticPredicateEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SemanticPredicateEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface antlr.debug.SemanticPredicateListener {
    public abstract virtual void semanticPredicateEvaluated(object source, SemanticPredicateEventArgs e);
}
public class antlr.debug.SemanticPredicateListenerBase : object {
    public virtual void doneParsing(object source, TraceEventArgs e);
    public virtual void refresh();
    public virtual void semanticPredicateEvaluated(object source, SemanticPredicateEventArgs e);
}
public class antlr.debug.SyntacticPredicateEventArgs : GuessingEventArgs {
    public SyntacticPredicateEventArgs(int type);
    public virtual string ToString();
}
public class antlr.debug.SyntacticPredicateEventHandler : MulticastDelegate {
    public SyntacticPredicateEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SyntacticPredicateEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SyntacticPredicateEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface antlr.debug.SyntacticPredicateListener {
    public abstract virtual void syntacticPredicateFailed(object source, SyntacticPredicateEventArgs e);
    public abstract virtual void syntacticPredicateStarted(object source, SyntacticPredicateEventArgs e);
    public abstract virtual void syntacticPredicateSucceeded(object source, SyntacticPredicateEventArgs e);
}
public abstract class antlr.debug.SyntacticPredicateListenerBase : object {
    public virtual void doneParsing(object source, TraceEventArgs e);
    public virtual void refresh();
    public virtual void syntacticPredicateFailed(object source, SyntacticPredicateEventArgs e);
    public virtual void syntacticPredicateStarted(object source, SyntacticPredicateEventArgs e);
    public virtual void syntacticPredicateSucceeded(object source, SyntacticPredicateEventArgs e);
}
public class antlr.debug.TokenEventArgs : ANTLREventArgs {
    private int value_;
    private int amount;
    public static int LA;
    public static int CONSUME;
    public int Amount { get; public set; }
    public int Value { get; public set; }
    public TokenEventArgs(int type, int amount, int val);
    private static TokenEventArgs();
    public virtual int get_Amount();
    public virtual void set_Amount(int value);
    public virtual int get_Value();
    public virtual void set_Value(int value);
    internal void setValues(int type, int amount, int val);
    public virtual string ToString();
}
public class antlr.debug.TokenEventHandler : MulticastDelegate {
    public TokenEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TokenEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TokenEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class antlr.debug.TraceEventArgs : GuessingEventArgs {
    private int ruleNum_;
    private int data_;
    public static int ENTER;
    public static int EXIT;
    public static int DONE_PARSING;
    public int Data { get; public set; }
    public int RuleNum { get; public set; }
    public TraceEventArgs(int type, int ruleNum, int guessing, int data);
    private static TraceEventArgs();
    public virtual int get_Data();
    public virtual void set_Data(int value);
    public virtual int get_RuleNum();
    public virtual void set_RuleNum(int value);
    internal void setValues(int type, int ruleNum, int guessing, int data);
    public virtual string ToString();
}
public class antlr.debug.TraceEventHandler : MulticastDelegate {
    public TraceEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TraceEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TraceEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface antlr.debug.TraceListener {
    public abstract virtual void enterRule(object source, TraceEventArgs e);
    public abstract virtual void exitRule(object source, TraceEventArgs e);
}
public abstract class antlr.debug.TraceListenerBase : object {
    public virtual void doneParsing(object source, TraceEventArgs e);
    public virtual void enterRule(object source, TraceEventArgs e);
    public virtual void exitRule(object source, TraceEventArgs e);
    public virtual void refresh();
}
public class antlr.debug.Tracer : TraceListenerBase {
    protected string indentString;
    protected internal virtual void dedent();
    public virtual void enterRule(object source, TraceEventArgs e);
    public virtual void exitRule(object source, TraceEventArgs e);
    protected internal virtual void indent();
}
public class antlr.DefaultFileLineFormatter : FileLineFormatter {
    public virtual string getFormatString(string fileName, int line, int column);
}
public class antlr.DumpASTVisitor : object {
    protected int level;
    private void tabs();
    public sealed virtual void visit(AST node);
}
public abstract class antlr.FileLineFormatter : object {
    private static FileLineFormatter formatter;
    private static FileLineFormatter();
    public static FileLineFormatter getFormatter();
    public static void setFormatter(FileLineFormatter f);
    public abstract virtual string getFormatString(string fileName, int line, int column);
}
public interface antlr.IHiddenStreamToken {
    public abstract virtual IHiddenStreamToken getHiddenAfter();
    public abstract virtual void setHiddenAfter(IHiddenStreamToken t);
    public abstract virtual IHiddenStreamToken getHiddenBefore();
    public abstract virtual void setHiddenBefore(IHiddenStreamToken t);
}
public abstract class antlr.InputBuffer : object {
    protected internal int nMarkers;
    protected internal int markerOffset;
    protected internal int numToConsume;
    protected ArrayList queue;
    public virtual void commit();
    public virtual char consume();
    public abstract virtual void fill(int amount);
    public virtual string getLAChars();
    public virtual string getMarkedChars();
    public virtual bool isMarked();
    public virtual char LA(int i);
    public virtual int mark();
    public virtual void rewind(int mark);
    public virtual void reset();
    protected internal virtual void syncConsume();
}
public interface antlr.IToken {
    public int Type { get; public set; }
    public abstract virtual int getColumn();
    public abstract virtual void setColumn(int c);
    public abstract virtual int getLine();
    public abstract virtual void setLine(int l);
    public abstract virtual string getFilename();
    public abstract virtual void setFilename(string name);
    public abstract virtual string getText();
    public abstract virtual void setText(string t);
    public abstract virtual int get_Type();
    public abstract virtual void set_Type(int value);
}
public class antlr.LexerSharedInputState : object {
    protected internal int column;
    protected internal int line;
    protected internal int tokenStartColumn;
    protected internal int tokenStartLine;
    protected internal InputBuffer input;
    protected internal string filename;
    public int guessing;
    public LexerSharedInputState(InputBuffer inbuf);
    public LexerSharedInputState(Stream inStream);
    public LexerSharedInputState(TextReader inReader);
    private void initialize();
    public virtual void reset();
    public virtual void resetInput(InputBuffer ib);
    public virtual void resetInput(Stream s);
    public virtual void resetInput(TextReader tr);
}
public class antlr.LLkParser : Parser {
    internal int k;
    public LLkParser(int k_);
    public LLkParser(ParserSharedInputState state, int k_);
    public LLkParser(TokenBuffer tokenBuf, int k_);
    public LLkParser(TokenStream lexer, int k_);
    public virtual void consume();
    public virtual int LA(int i);
    public virtual IToken LT(int i);
    private void trace(string ee, string rname);
    public virtual void traceIn(string rname);
    public virtual void traceOut(string rname);
}
public class antlr.MismatchedCharException : RecognitionException {
    public CharTypeEnum mismatchType;
    public int foundChar;
    public int expecting;
    public int upper;
    public BitSet bset;
    public CharScanner scanner;
    public string Message { get; }
    public MismatchedCharException(char c, char lower, char upper_, bool matchNot, CharScanner scanner_);
    public MismatchedCharException(char c, char expecting_, bool matchNot, CharScanner scanner_);
    public MismatchedCharException(char c, BitSet set_, bool matchNot, CharScanner scanner_);
    public virtual string get_Message();
    private void appendCharName(StringBuilder sb, int c);
}
public class antlr.MismatchedTokenException : RecognitionException {
    internal String[] tokenNames;
    public IToken token;
    public AST node;
    internal string tokenText;
    public TokenTypeEnum mismatchType;
    public int expecting;
    public int upper;
    public BitSet bset;
    public string Message { get; }
    public MismatchedTokenException(String[] tokenNames_, AST node_, int lower, int upper_, bool matchNot);
    public MismatchedTokenException(String[] tokenNames_, AST node_, int expecting_, bool matchNot);
    public MismatchedTokenException(String[] tokenNames_, AST node_, BitSet set_, bool matchNot);
    public MismatchedTokenException(String[] tokenNames_, IToken token_, int lower, int upper_, bool matchNot, string fileName_);
    public MismatchedTokenException(String[] tokenNames_, IToken token_, int expecting_, bool matchNot, string fileName_);
    public MismatchedTokenException(String[] tokenNames_, IToken token_, BitSet set_, bool matchNot, string fileName_);
    public virtual string get_Message();
    private string tokenName(int tokenType);
}
public class antlr.NoViableAltException : RecognitionException {
    public IToken token;
    public AST node;
    public string Message { get; }
    public NoViableAltException(AST t);
    public NoViableAltException(IToken t, string fileName_);
    public virtual string get_Message();
}
public class antlr.NoViableAltForCharException : RecognitionException {
    public char foundChar;
    public string Message { get; }
    public NoViableAltForCharException(char c, CharScanner scanner);
    public NoViableAltForCharException(char c, string fileName, int line, int column);
    public virtual string get_Message();
}
public abstract class antlr.Parser : object {
    private EventHandlerList events_;
    internal static object EnterRuleEventKey;
    internal static object ExitRuleEventKey;
    internal static object DoneEventKey;
    internal static object ReportErrorEventKey;
    internal static object ReportWarningEventKey;
    internal static object NewLineEventKey;
    internal static object MatchEventKey;
    internal static object MatchNotEventKey;
    internal static object MisMatchEventKey;
    internal static object MisMatchNotEventKey;
    internal static object ConsumeEventKey;
    internal static object LAEventKey;
    internal static object SemPredEvaluatedEventKey;
    internal static object SynPredStartedEventKey;
    internal static object SynPredFailedEventKey;
    internal static object SynPredSucceededEventKey;
    protected internal ParserSharedInputState inputState;
    protected internal String[] tokenNames;
    protected internal AST returnAST;
    protected internal ASTFactory astFactory;
    private bool ignoreInvalidDebugCalls;
    protected internal int traceDepth;
    protected internal EventHandlerList Events { get; }
    public Parser(ParserSharedInputState state);
    private static Parser();
    protected internal EventHandlerList get_Events();
    public sealed virtual void add_EnterRule(TraceEventHandler value);
    public sealed virtual void remove_EnterRule(TraceEventHandler value);
    public sealed virtual void add_ExitRule(TraceEventHandler value);
    public sealed virtual void remove_ExitRule(TraceEventHandler value);
    public sealed virtual void add_Done(TraceEventHandler value);
    public sealed virtual void remove_Done(TraceEventHandler value);
    public sealed virtual void add_ErrorReported(MessageEventHandler value);
    public sealed virtual void remove_ErrorReported(MessageEventHandler value);
    public sealed virtual void add_WarningReported(MessageEventHandler value);
    public sealed virtual void remove_WarningReported(MessageEventHandler value);
    public sealed virtual void add_MatchedToken(MatchEventHandler value);
    public sealed virtual void remove_MatchedToken(MatchEventHandler value);
    public sealed virtual void add_MatchedNotToken(MatchEventHandler value);
    public sealed virtual void remove_MatchedNotToken(MatchEventHandler value);
    public sealed virtual void add_MisMatchedToken(MatchEventHandler value);
    public sealed virtual void remove_MisMatchedToken(MatchEventHandler value);
    public sealed virtual void add_MisMatchedNotToken(MatchEventHandler value);
    public sealed virtual void remove_MisMatchedNotToken(MatchEventHandler value);
    public sealed virtual void add_ConsumedToken(TokenEventHandler value);
    public sealed virtual void remove_ConsumedToken(TokenEventHandler value);
    public sealed virtual void add_TokenLA(TokenEventHandler value);
    public sealed virtual void remove_TokenLA(TokenEventHandler value);
    public sealed virtual void add_SemPredEvaluated(SemanticPredicateEventHandler value);
    public sealed virtual void remove_SemPredEvaluated(SemanticPredicateEventHandler value);
    public sealed virtual void add_SynPredStarted(SyntacticPredicateEventHandler value);
    public sealed virtual void remove_SynPredStarted(SyntacticPredicateEventHandler value);
    public sealed virtual void add_SynPredFailed(SyntacticPredicateEventHandler value);
    public sealed virtual void remove_SynPredFailed(SyntacticPredicateEventHandler value);
    public sealed virtual void add_SynPredSucceeded(SyntacticPredicateEventHandler value);
    public sealed virtual void remove_SynPredSucceeded(SyntacticPredicateEventHandler value);
    public virtual void addMessageListener(MessageListener l);
    public virtual void addParserListener(ParserListener l);
    public virtual void addParserMatchListener(ParserMatchListener l);
    public virtual void addParserTokenListener(ParserTokenListener l);
    public virtual void addSemanticPredicateListener(SemanticPredicateListener l);
    public virtual void addSyntacticPredicateListener(SyntacticPredicateListener l);
    public virtual void addTraceListener(TraceListener l);
    public abstract virtual void consume();
    public virtual void consumeUntil(int tokenType);
    public virtual void consumeUntil(BitSet bset);
    protected internal virtual void defaultDebuggingSetup(TokenStream lexer, TokenBuffer tokBuf);
    public virtual AST getAST();
    public virtual ASTFactory getASTFactory();
    public virtual string getFilename();
    public virtual ParserSharedInputState getInputState();
    public virtual void setInputState(ParserSharedInputState state);
    public virtual void resetState();
    public virtual string getTokenName(int num);
    public virtual String[] getTokenNames();
    public virtual bool isDebugMode();
    public abstract virtual int LA(int i);
    public abstract virtual IToken LT(int i);
    public virtual int mark();
    public virtual void match(int t);
    public virtual void match(BitSet b);
    public virtual void matchNot(int t);
    [ObsoleteAttribute("De-activated since version 2.7.2.6 as it cannot be overidden.", "True")]
public static void panic();
    public virtual void removeMessageListener(MessageListener l);
    public virtual void removeParserListener(ParserListener l);
    public virtual void removeParserMatchListener(ParserMatchListener l);
    public virtual void removeParserTokenListener(ParserTokenListener l);
    public virtual void removeSemanticPredicateListener(SemanticPredicateListener l);
    public virtual void removeSyntacticPredicateListener(SyntacticPredicateListener l);
    public virtual void removeTraceListener(TraceListener l);
    public virtual void reportError(RecognitionException ex);
    public virtual void reportError(string s);
    public virtual void reportWarning(string s);
    public virtual void recover(RecognitionException ex, BitSet tokenSet);
    public virtual void rewind(int pos);
    public virtual void setASTFactory(ASTFactory f);
    public virtual void setASTNodeClass(string cl);
    [ObsoleteAttribute("Replaced by setASTNodeClass(string) since version 2.7.1", "True")]
public virtual void setASTNodeType(string nodeType);
    public virtual void setDebugMode(bool debugMode);
    public virtual void setFilename(string f);
    public virtual void setIgnoreInvalidDebugCalls(bool Value);
    public virtual void setTokenBuffer(TokenBuffer t);
    public virtual void traceIndent();
    public virtual void traceIn(string rname);
    public virtual void traceOut(string rname);
}
public class antlr.ParserSharedInputState : object {
    protected internal TokenBuffer input;
    public int guessing;
    protected internal string filename;
    public virtual void reset();
}
public abstract class antlr.ParseTree : BaseAST {
    public string getLeftmostDerivationStep(int step);
    public string getLeftmostDerivation(int maxSteps);
    protected internal abstract virtual int getLeftmostDerivation(StringBuilder buf, int step);
    public virtual void initialize(int i, string s);
    public virtual void initialize(AST ast);
    public virtual void initialize(IToken token);
}
public class antlr.ParseTreeRule : ParseTree {
    public static int INVALID_ALT;
    protected string ruleName;
    protected int altNumber;
    public ParseTreeRule(string ruleName);
    public ParseTreeRule(string ruleName, int altNumber);
    public string getRuleName();
    protected internal virtual int getLeftmostDerivation(StringBuilder buf, int step);
    public virtual string ToString();
}
public class antlr.ParseTreeToken : ParseTree {
    protected IToken token;
    public ParseTreeToken(IToken token);
    protected internal virtual int getLeftmostDerivation(StringBuilder buf, int step);
    public virtual string ToString();
}
public class antlr.RecognitionException : ANTLRException {
    public string fileName;
    public int line;
    public int column;
    public RecognitionException(string s);
    public RecognitionException(string s, string fileName_, int line_, int column_);
    public virtual string getFilename();
    public virtual int getLine();
    public virtual int getColumn();
    [ObsoleteAttribute("Replaced by Message property since version 2.7.0", "True")]
public virtual string getErrorMessage();
    public virtual string ToString();
}
public class antlr.SemanticException : RecognitionException {
    public SemanticException(string s);
    [ObsoleteAttribute("Replaced by SemanticException(string, string, int, int) since version 2.7.2.6", "False")]
public SemanticException(string s, string fileName, int line);
    public SemanticException(string s, string fileName, int line, int column);
}
public class antlr.StringUtils : object {
    public static string stripBack(string s, char c);
    public static string stripBack(string s, string remove);
    public static string stripFront(string s, char c);
    public static string stripFront(string s, string remove);
    public static string stripFrontBack(string src, string head, string tail);
}
public class antlr.Token : object {
    public static int MIN_USER_TYPE;
    public static int NULL_TREE_LOOKAHEAD;
    public static int INVALID_TYPE;
    public static int EOF_TYPE;
    public static int SKIP;
    protected int type_;
    public static Token badToken;
    public int Type { get; public set; }
    public Token(int t);
    public Token(int t, string txt);
    private static Token();
    public virtual int getColumn();
    public virtual int getLine();
    public virtual string getFilename();
    public virtual void setFilename(string name);
    public virtual string getText();
    public sealed virtual int get_Type();
    public sealed virtual void set_Type(int value);
    public virtual void setType(int newType);
    public virtual void setColumn(int c);
    public virtual void setLine(int l);
    public virtual void setText(string t);
    public virtual string ToString();
}
public class antlr.TokenBuffer : object {
    protected internal TokenStream input;
    protected internal int nMarkers;
    protected internal int markerOffset;
    protected internal int numToConsume;
    internal TokenQueue queue;
    public TokenBuffer(TokenStream input_);
    public virtual void reset();
    public virtual void consume();
    protected virtual void fill(int amount);
    public virtual TokenStream getInput();
    public virtual int LA(int i);
    public virtual IToken LT(int i);
    public virtual int mark();
    public virtual void rewind(int mark);
    protected virtual void syncConsume();
}
public abstract class antlr.TokenCreator : object {
    public string TokenTypeName { get; }
    public abstract virtual string get_TokenTypeName();
    public abstract virtual IToken Create();
}
internal class antlr.TokenQueue : object {
    private IToken[] buffer;
    private int sizeLessOne;
    private int offset;
    protected internal int nbrEntries;
    public TokenQueue(int minSize);
    public void append(IToken tok);
    public IToken elementAt(int idx);
    private void expand();
    private void init(int size);
    public void reset();
    public void removeFirst();
}
public interface antlr.TokenStream {
    public abstract virtual IToken nextToken();
}
public class antlr.TokenStreamBasicFilter : object {
    protected internal BitSet discardMask;
    protected internal TokenStream input;
    public TokenStreamBasicFilter(TokenStream input);
    public virtual void discard(int ttype);
    public virtual void discard(BitSet mask);
    public virtual IToken nextToken();
}
public class antlr.TokenStreamException : ANTLRException {
    public TokenStreamException(string s);
}
public class antlr.TokenStreamHiddenTokenFilter : TokenStreamBasicFilter {
    protected internal BitSet hideMask;
    private IHiddenStreamToken nextMonitoredToken;
    protected internal IHiddenStreamToken lastHiddenToken;
    protected internal IHiddenStreamToken firstHidden;
    public TokenStreamHiddenTokenFilter(TokenStream input);
    protected internal virtual void consume();
    private void consumeFirst();
    public virtual BitSet getDiscardMask();
    public virtual IHiddenStreamToken getHiddenAfter(IHiddenStreamToken t);
    public virtual IHiddenStreamToken getHiddenBefore(IHiddenStreamToken t);
    public virtual BitSet getHideMask();
    public virtual IHiddenStreamToken getInitialHiddenToken();
    public virtual void hide(int m);
    public virtual void hide(BitSet mask);
    protected internal virtual IHiddenStreamToken LA(int i);
    public virtual IToken nextToken();
    public virtual void resetState();
}
public class antlr.TokenStreamIOException : TokenStreamException {
    public IOException io;
    public TokenStreamIOException(IOException io);
}
public class antlr.TokenStreamRecognitionException : TokenStreamException {
    public RecognitionException recog;
    public TokenStreamRecognitionException(RecognitionException re);
    public virtual string ToString();
}
public class antlr.TokenStreamRetryException : TokenStreamException {
}
public class antlr.TokenStreamRewriteEngine : object {
    public static int MIN_TOKEN_INDEX;
    public static string DEFAULT_PROGRAM_NAME;
    public static int PROGRAM_INIT_SIZE;
    protected IList tokens;
    protected IDictionary programs;
    protected IDictionary lastRewriteTokenIndexes;
    protected int index;
    protected TokenStream stream;
    protected BitSet discardMask;
    public TokenStreamRewriteEngine(TokenStream upstream);
    public TokenStreamRewriteEngine(TokenStream upstream, int initialSize);
    public sealed virtual IToken nextToken();
    public void rollback(int instructionIndex);
    public void rollback(string programName, int instructionIndex);
    public void deleteProgram();
    public void deleteProgram(string programName);
    protected void addToSortedRewriteList(RewriteOperation op);
    protected void addToSortedRewriteList(string programName, RewriteOperation op);
    public void insertAfter(IToken t, string text);
    public void insertAfter(int index, string text);
    public void insertAfter(string programName, IToken t, string text);
    public void insertAfter(string programName, int index, string text);
    public void insertBefore(IToken t, string text);
    public void insertBefore(int index, string text);
    public void insertBefore(string programName, IToken t, string text);
    public void insertBefore(string programName, int index, string text);
    public void replace(int index, string text);
    public void replace(int from, int to, string text);
    public void replace(IToken indexT, string text);
    public void replace(IToken from, IToken to, string text);
    public void replace(string programName, int from, int to, string text);
    public void replace(string programName, IToken from, IToken to, string text);
    public void delete(int index);
    public void delete(int from, int to);
    public void delete(IToken indexT);
    public void delete(IToken from, IToken to);
    public void delete(string programName, int from, int to);
    public void delete(string programName, IToken from, IToken to);
    public void discard(int ttype);
    public TokenWithIndex getToken(int i);
    public int getTokenStreamSize();
    public string ToOriginalString();
    public string ToOriginalString(int start, int end);
    public virtual string ToString();
    public string ToString(string programName);
    public string ToString(int start, int end);
    public string ToString(string programName, int start, int end);
    public string ToDebugString();
    public string ToDebugString(int start, int end);
    public int getLastRewriteTokenIndex();
    protected int getLastRewriteTokenIndex(string programName);
    protected void setLastRewriteTokenIndex(string programName, int i);
    protected IList getProgram(string name);
    private IList initializeProgram(string name);
}
public class antlr.TokenStreamSelector : object {
    protected internal Hashtable inputStreamNames;
    protected internal TokenStream input;
    protected internal Stack streamStack;
    public virtual void addInputStream(TokenStream stream, string key);
    public virtual TokenStream getCurrentStream();
    public virtual TokenStream getStream(string sname);
    public virtual IToken nextToken();
    public virtual TokenStream pop();
    public virtual void push(TokenStream stream);
    public virtual void push(string sname);
    public virtual void retry();
    public virtual void select(TokenStream stream);
    public virtual void select(string sname);
}
public class antlr.TokenWithIndex : CommonToken {
    private int index;
    public TokenWithIndex(int i, string t);
    public void setIndex(int i);
    public int getIndex();
    public virtual string ToString();
}
public class antlr.TreeParser : object {
    public static ASTNULLType ASTNULL;
    protected internal AST retTree_;
    protected internal TreeParserSharedInputState inputState;
    protected internal String[] tokenNames;
    protected internal AST returnAST;
    protected internal ASTFactory astFactory;
    protected internal int traceDepth;
    private static TreeParser();
    public virtual AST getAST();
    public virtual ASTFactory getASTFactory();
    public virtual void resetState();
    public virtual string getTokenName(int num);
    public virtual String[] getTokenNames();
    protected internal virtual void match(AST t, int ttype);
    public virtual void match(AST t, BitSet b);
    protected internal virtual void matchNot(AST t, int ttype);
    [ObsoleteAttribute("De-activated since version 2.7.2.6 as it cannot be overidden.", "True")]
public static void panic();
    public virtual void reportError(RecognitionException ex);
    public virtual void reportError(string s);
    public virtual void reportWarning(string s);
    public virtual void setASTFactory(ASTFactory f);
    public virtual void setASTNodeType(string nodeType);
    public virtual void setASTNodeClass(string nodeType);
    public virtual void traceIndent();
    public virtual void traceIn(string rname, AST t);
    public virtual void traceOut(string rname, AST t);
}
public class antlr.TreeParserSharedInputState : object {
    public int guessing;
    public virtual void reset();
}
internal class SupportClass : object {
    public static int URShift(int number, int bits);
    public static int URShift(int number, long bits);
    public static long URShift(long number, int bits);
    public static long URShift(long number, long bits);
}
