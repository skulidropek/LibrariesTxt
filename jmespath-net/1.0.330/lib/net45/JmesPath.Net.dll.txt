public class DevLab.JmesPath.Expressions.JmesParenExpression : JmesPathSimpleExpression {
    public JmesParenExpression(JmesPathExpression expression);
    public virtual string ToString();
}
public class DevLab.JmesPath.Expressions.JmesPathAdditionExpression : JmesPathArithmeticExpression {
    public JmesPathAdditionExpression(JmesPathExpression left, JmesPathExpression right);
    protected virtual double Compute(double left, double right);
    public virtual string ToString();
}
public class DevLab.JmesPath.Expressions.JmesPathAndExpression : JmesPathCompoundExpression {
    public JmesPathAndExpression(JmesPathExpression left, JmesPathExpression right);
    protected virtual JmesPathArgument Transform(JToken json);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Expressions.JmesPathAndExpression/<TransformAsync>d__2")]
protected virtual Task`1<JmesPathArgument> TransformAsync(JToken json);
    public virtual string ToString();
}
public class DevLab.JmesPath.Expressions.JmesPathArgument : ValueType {
    public static JmesPathArgument Null;
    public static JmesPathArgument True;
    public static JmesPathArgument False;
    [CompilerGeneratedAttribute]
private JToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private JmesPathArgument[] <Projection>k__BackingField;
    public bool IsProjection { get; }
    public JToken Token { get; }
    public JmesPathArgument[] Projection { get; }
    public JmesPathArgument(JToken token);
    public JmesPathArgument(IEnumerable`1<JmesPathArgument> projection);
    private static JmesPathArgument();
    public bool get_IsProjection();
    public static JmesPathArgument op_Implicit(JToken token);
    [CompilerGeneratedAttribute]
public JToken get_Token();
    [CompilerGeneratedAttribute]
public JmesPathArgument[] get_Projection();
    public JToken AsJToken();
    public static bool IsFalse(JmesPathArgument argument);
    public bool IsNull();
}
public abstract class DevLab.JmesPath.Expressions.JmesPathArithmeticExpression : JmesPathCompoundExpression {
    public JmesPathArithmeticExpression(JmesPathExpression left, JmesPathExpression right);
    protected virtual JmesPathArgument Transform(JToken json);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Expressions.JmesPathArithmeticExpression/<TransformAsync>d__2")]
protected virtual Task`1<JmesPathArgument> TransformAsync(JToken json);
    private JmesPathArgument Compute(JToken rightToken, JToken leftToken);
    protected abstract virtual double Compute(double left, double right);
}
public class DevLab.JmesPath.Expressions.JmesPathBinding : object {
    private string name_;
    private JmesPathExpression expression_;
    public string Name { get; }
    public JmesPathExpression Expression { get; }
    public JmesPathBinding(string name, JmesPathExpression expression);
    public string get_Name();
    public JmesPathExpression get_Expression();
    public virtual string ToString();
}
public abstract class DevLab.JmesPath.Expressions.JmesPathComparison : JmesPathCompoundExpression {
    private string operator_;
    protected JmesPathComparison(JmesPathExpression left, JmesPathExpression right, string op);
    protected abstract virtual Nullable`1<bool> Compare(JToken left, JToken right);
    protected virtual JmesPathArgument Transform(JToken json);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Expressions.JmesPathComparison/<TransformAsync>d__4")]
protected virtual Task`1<JmesPathArgument> TransformAsync(JToken json);
    public virtual string ToString();
}
public class DevLab.JmesPath.Expressions.JmesPathCompoundExpression : JmesPathExpression {
    private JmesPathExpression left_;
    private JmesPathExpression right_;
    protected JmesPathExpression Left { get; }
    protected JmesPathExpression Right { get; }
    protected JmesPathCompoundExpression(JmesPathExpression left, JmesPathExpression right);
    protected JmesPathExpression get_Left();
    protected JmesPathExpression get_Right();
    protected virtual JmesPathArgument Transform(JToken json);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Expressions.JmesPathCompoundExpression/<TransformAsync>d__8")]
protected virtual Task`1<JmesPathArgument> TransformAsync(JToken json);
    public virtual void Accept(IVisitor visitor);
    protected virtual string Format();
}
public class DevLab.JmesPath.Expressions.JmesPathCurrentNodeExpression : JmesPathExpression {
    protected virtual JmesPathArgument Transform(JToken json);
    protected virtual string Format();
}
public class DevLab.JmesPath.Expressions.JmesPathDivisionExpression : JmesPathArithmeticExpression {
    public JmesPathDivisionExpression(JmesPathExpression left, JmesPathExpression right);
    protected virtual double Compute(double left, double right);
    public virtual string ToString();
}
public class DevLab.JmesPath.Expressions.JmesPathEqualOperator : JmesPathComparison {
    public JmesPathEqualOperator(JmesPathExpression left, JmesPathExpression right);
    protected virtual Nullable`1<bool> Compare(JToken left, JToken right);
}
public abstract class DevLab.JmesPath.Expressions.JmesPathExpression : object {
    [CompilerGeneratedAttribute]
private bool <IsExpressionType>k__BackingField;
    public bool IsExpressionType { get; private set; }
    public virtual JmesPathArgument Transform(JmesPathArgument argument);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Expressions.JmesPathExpression/<TransformAsync>d__1")]
public virtual Task`1<JmesPathArgument> TransformAsync(JmesPathArgument argument);
    protected virtual JmesPathArgument Project(IEnumerable`1<JmesPathArgument> arguments);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Expressions.JmesPathExpression/<ProjectAsync>d__3")]
protected virtual Task`1<JmesPathArgument> ProjectAsync(IEnumerable`1<JmesPathArgument> arguments);
    protected abstract virtual JmesPathArgument Transform(JToken json);
    protected virtual Task`1<JmesPathArgument> TransformAsync(JToken json);
    [CompilerGeneratedAttribute]
public bool get_IsExpressionType();
    [CompilerGeneratedAttribute]
private void set_IsExpressionType(bool value);
    public static void MakeExpressionType(JmesPathExpression expression);
    public virtual void Accept(IVisitor visitor);
    public virtual string ToString();
    protected abstract virtual string Format();
}
public class DevLab.JmesPath.Expressions.JmesPathFilterProjection : JmesPathProjection {
    private JmesPathExpression expression_;
    public JmesPathExpression Expression { get; }
    public JmesPathFilterProjection(JmesPathExpression expression);
    public JmesPathExpression get_Expression();
    protected virtual JmesPathArgument Project(JmesPathArgument argument);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Expressions.JmesPathFilterProjection/<ProjectAsync>d__5")]
protected virtual Task`1<JmesPathArgument> ProjectAsync(JmesPathArgument argument);
    public virtual void Accept(IVisitor visitor);
    protected virtual string Format();
}
public class DevLab.JmesPath.Expressions.JmesPathFlattenProjection : JmesPathProjection {
    protected virtual JmesPathArgument Project(IEnumerable`1<JmesPathArgument> arguments);
    protected virtual Task`1<JmesPathArgument> ProjectAsync(IEnumerable`1<JmesPathArgument> arguments);
    protected virtual JmesPathArgument Project(JmesPathArgument argument);
    protected virtual string Format();
}
public class DevLab.JmesPath.Expressions.JmesPathFunctionExpression : JmesPathExpression {
    private string name_;
    private JmesPathExpression[] expressions_;
    private JmesPathFunction function_;
    public string Name { get; }
    public JmesPathExpression[] Arguments { get; }
    public JmesPathFunctionExpression(IFunctionRepository repository, string name, IList`1<JmesPathExpression> expressions);
    public JmesPathFunctionExpression(IFunctionRepository repository, string name, JmesPathExpression[] expressions);
    public string get_Name();
    public JmesPathExpression[] get_Arguments();
    protected virtual JmesPathArgument Transform(JToken json);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Expressions.JmesPathFunctionExpression/<TransformAsync>d__10")]
protected virtual Task`1<JmesPathArgument> TransformAsync(JToken json);
    public virtual void Accept(IVisitor visitor);
    protected virtual string Format();
}
public class DevLab.JmesPath.Expressions.JmesPathGreaterThanOperator : JmesPathOrderingComparison {
    public JmesPathGreaterThanOperator(JmesPathExpression left, JmesPathExpression right);
    protected virtual bool Compare(double left, double right);
    protected virtual bool Compare(string left, string right);
}
public class DevLab.JmesPath.Expressions.JmesPathGreaterThanOrEqualOperator : JmesPathOrderingComparison {
    public JmesPathGreaterThanOrEqualOperator(JmesPathExpression left, JmesPathExpression right);
    protected virtual bool Compare(double left, double right);
    protected virtual bool Compare(string left, string right);
}
public class DevLab.JmesPath.Expressions.JmesPathHashWildcardProjection : JmesPathProjection {
    protected virtual JmesPathArgument Project(JmesPathArgument argument);
    protected virtual string Format();
}
public class DevLab.JmesPath.Expressions.JmesPathIdentifier : JmesPathExpression {
    private string name_;
    public string Name { get; }
    public JmesPathIdentifier(string name);
    public string get_Name();
    protected virtual JmesPathArgument Transform(JToken json);
    protected virtual string Format();
}
public class DevLab.JmesPath.Expressions.JmesPathIndex : JmesPathExpression {
    private int index_;
    public int Index { get; }
    public JmesPathIndex(int index);
    public int get_Index();
    protected virtual JmesPathArgument Transform(JToken json);
    protected virtual string Format();
}
public class DevLab.JmesPath.Expressions.JmesPathIndexExpression : JmesPathCompoundExpression {
    public JmesPathIndexExpression(JmesPathExpression expression, JmesPathExpression specifier);
}
public class DevLab.JmesPath.Expressions.JmesPathIntegerDivisionExpression : JmesPathArithmeticExpression {
    public JmesPathIntegerDivisionExpression(JmesPathExpression left, JmesPathExpression right);
    protected virtual double Compute(double left, double right);
    public virtual string ToString();
}
public class DevLab.JmesPath.Expressions.JmesPathLessThanOperator : JmesPathOrderingComparison {
    public JmesPathLessThanOperator(JmesPathExpression left, JmesPathExpression right);
    protected virtual bool Compare(double left, double right);
    protected virtual bool Compare(string left, string right);
}
public class DevLab.JmesPath.Expressions.JmesPathLessThanOrEqualOperator : JmesPathOrderingComparison {
    public JmesPathLessThanOrEqualOperator(JmesPathExpression left, JmesPathExpression right);
    protected virtual bool Compare(double left, double right);
    protected virtual bool Compare(string left, string right);
}
public class DevLab.JmesPath.Expressions.JmesPathLetExpression : JmesPathExpression {
    private IList`1<JmesPathBinding> bindings_;
    private JmesPathExpression expression_;
    [CompilerGeneratedAttribute]
private IScopeParticipant <Scopes>k__BackingField;
    public IScopeParticipant Scopes { get; public set; }
    public JmesPathLetExpression(IList`1<JmesPathBinding> bindings, JmesPathExpression expression);
    [CompilerGeneratedAttribute]
public sealed virtual IScopeParticipant get_Scopes();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Scopes(IScopeParticipant value);
    protected virtual JmesPathArgument Transform(JToken json);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Expressions.JmesPathLetExpression/<TransformAsync>d__8")]
protected virtual Task`1<JmesPathArgument> TransformAsync(JToken json);
    public virtual void Accept(IVisitor visitor);
    private JToken BindScope(JToken json);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Expressions.JmesPathLetExpression/<BindScopeAsync>d__11")]
private Task`1<JToken> BindScopeAsync(JToken json);
    protected virtual string Format();
}
public class DevLab.JmesPath.Expressions.JmesPathListWildcardProjection : JmesPathProjection {
    protected virtual JmesPathArgument Project(JmesPathArgument argument);
    protected virtual string Format();
}
public class DevLab.JmesPath.Expressions.JmesPathLiteral : JmesPathExpression {
    private JToken value_;
    public JToken Value { get; }
    public JmesPathLiteral(JToken value);
    public JToken get_Value();
    protected virtual JmesPathArgument Transform(JToken json);
    protected virtual string Format();
}
public class DevLab.JmesPath.Expressions.JmesPathModuloExpression : JmesPathArithmeticExpression {
    public JmesPathModuloExpression(JmesPathExpression left, JmesPathExpression right);
    protected virtual double Compute(double left, double right);
    public virtual string ToString();
}
public class DevLab.JmesPath.Expressions.JmesPathMultiplicationExpression : JmesPathArithmeticExpression {
    public JmesPathMultiplicationExpression(JmesPathExpression left, JmesPathExpression right);
    protected virtual double Compute(double left, double right);
    public virtual string ToString();
}
public class DevLab.JmesPath.Expressions.JmesPathMultiSelectHash : JmesPathExpression {
    private IDictionary`2<string, JmesPathExpression> dictionary_;
    public IReadOnlyDictionary`2<string, JmesPathExpression> Dictionary { get; }
    public JmesPathMultiSelectHash(IDictionary`2<string, JmesPathExpression> dictionary);
    public IReadOnlyDictionary`2<string, JmesPathExpression> get_Dictionary();
    protected virtual JmesPathArgument Transform(JToken json);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Expressions.JmesPathMultiSelectHash/<TransformAsync>d__5")]
protected virtual Task`1<JmesPathArgument> TransformAsync(JToken json);
    public virtual void Accept(IVisitor visitor);
    protected virtual string Format();
}
public class DevLab.JmesPath.Expressions.JmesPathMultiSelectList : JmesPathExpression {
    private IList`1<JmesPathExpression> expressions_;
    public JmesPathExpression[] Expressions { get; }
    public JmesPathMultiSelectList(JmesPathExpression[] expressions);
    public JmesPathMultiSelectList(IEnumerable`1<JmesPathExpression> expressions);
    public JmesPathExpression[] get_Expressions();
    protected virtual JmesPathArgument Transform(JToken json);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Expressions.JmesPathMultiSelectList/<TransformAsync>d__6")]
protected virtual Task`1<JmesPathArgument> TransformAsync(JToken json);
    public virtual void Accept(IVisitor visitor);
    protected virtual string Format();
}
public class DevLab.JmesPath.Expressions.JmesPathNotEqualOperator : JmesPathComparison {
    public JmesPathNotEqualOperator(JmesPathExpression left, JmesPathExpression right);
    protected virtual Nullable`1<bool> Compare(JToken left, JToken right);
}
public class DevLab.JmesPath.Expressions.JmesPathNotExpression : JmesPathSimpleExpression {
    public JmesPathNotExpression(JmesPathExpression expression);
    protected virtual JmesPathArgument Transform(JToken json);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Expressions.JmesPathNotExpression/<TransformAsync>d__2")]
protected virtual Task`1<JmesPathArgument> TransformAsync(JToken json);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<JmesPathArgument> <>n__0(JToken json);
}
public abstract class DevLab.JmesPath.Expressions.JmesPathOrderingComparison : JmesPathComparison {
    protected JmesPathOrderingComparison(JmesPathExpression left, JmesPathExpression right, string op);
    protected static bool FromDouble(JToken token, Nullable`1& value);
    protected static bool FromString(JToken token, String& value);
    protected virtual Nullable`1<bool> Compare(JToken left, JToken right);
    protected abstract virtual bool Compare(double left, double right);
    protected abstract virtual bool Compare(string left, string right);
}
public class DevLab.JmesPath.Expressions.JmesPathOrExpression : JmesPathCompoundExpression {
    public JmesPathOrExpression(JmesPathExpression left, JmesPathExpression right);
    protected virtual JmesPathArgument Transform(JToken json);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Expressions.JmesPathOrExpression/<TransformAsync>d__2")]
protected virtual Task`1<JmesPathArgument> TransformAsync(JToken json);
    public virtual string ToString();
}
public class DevLab.JmesPath.Expressions.JmesPathPipeExpression : JmesPathCompoundExpression {
    public JmesPathPipeExpression(JmesPathExpression left, JmesPathExpression right);
    protected virtual JmesPathArgument Transform(JToken json);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Expressions.JmesPathPipeExpression/<TransformAsync>d__2")]
protected virtual Task`1<JmesPathArgument> TransformAsync(JToken json);
    public virtual string ToString();
}
public abstract class DevLab.JmesPath.Expressions.JmesPathProjection : JmesPathExpression {
    protected abstract virtual JmesPathArgument Project(JmesPathArgument argument);
    protected virtual Task`1<JmesPathArgument> ProjectAsync(JmesPathArgument argument);
    protected virtual JmesPathArgument Transform(JToken json);
    protected virtual Task`1<JmesPathArgument> TransformAsync(JToken json);
}
public class DevLab.JmesPath.Expressions.JmesPathRawString : JmesPathExpression {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public JmesPathRawString(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    protected virtual JmesPathArgument Transform(JToken json);
    protected virtual string Format();
}
internal class DevLab.JmesPath.Expressions.JmesPathRootExpression : JmesPathSimpleExpression {
    [CompilerGeneratedAttribute]
private IScopeParticipant <Scopes>k__BackingField;
    public IScopeParticipant Scopes { get; public set; }
    public JmesPathRootExpression(JmesPathExpression expression);
    [CompilerGeneratedAttribute]
public sealed virtual IScopeParticipant get_Scopes();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Scopes(IScopeParticipant value);
    protected virtual JmesPathArgument Transform(JToken json);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Expressions.JmesPathRootExpression/<TransformAsync>d__6")]
protected virtual Task`1<JmesPathArgument> TransformAsync(JToken json);
}
public class DevLab.JmesPath.Expressions.JmesPathRootNodeExpression : JmesPathExpression {
    [CompilerGeneratedAttribute]
private IContextEvaluator <DevLab.JmesPath.Interop.IContextHolder.Evaluator>k__BackingField;
    private IContextEvaluator DevLab.JmesPath.Interop.IContextHolder.Evaluator { get; private set; }
    [CompilerGeneratedAttribute]
private sealed virtual override IContextEvaluator DevLab.JmesPath.Interop.IContextHolder.get_Evaluator();
    [CompilerGeneratedAttribute]
private sealed virtual override void DevLab.JmesPath.Interop.IContextHolder.set_Evaluator(IContextEvaluator value);
    protected virtual JmesPathArgument Transform(JToken json);
    protected virtual string Format();
}
public class DevLab.JmesPath.Expressions.JmesPathSimpleExpression : JmesPathExpression {
    private JmesPathExpression expression_;
    public JmesPathExpression Expression { get; }
    protected JmesPathSimpleExpression(JmesPathExpression expression);
    public JmesPathExpression get_Expression();
    protected virtual JmesPathArgument Transform(JToken json);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Expressions.JmesPathSimpleExpression/<TransformAsync>d__5")]
protected virtual Task`1<JmesPathArgument> TransformAsync(JToken json);
    public virtual void Accept(IVisitor visitor);
    protected virtual string Format();
}
public class DevLab.JmesPath.Expressions.JmesPathSliceProjection : JmesPathProjection {
    private Nullable`1<int> start_;
    private Nullable`1<int> stop_;
    private Nullable`1<int> step_;
    public Nullable`1<int> Start { get; }
    public Nullable`1<int> Stop { get; }
    public Nullable`1<int> Step { get; }
    public JmesPathSliceProjection(Nullable`1<int> start, Nullable`1<int> stop, Nullable`1<int> step);
    public Nullable`1<int> get_Start();
    public Nullable`1<int> get_Stop();
    public Nullable`1<int> get_Step();
    protected virtual JmesPathArgument Project(JmesPathArgument argument);
    private JToken Slice(Text text);
    private ValueTuple`3<int, int, int> GetSliceParameters(int length);
    protected virtual string Format();
}
public class DevLab.JmesPath.Expressions.JmesPathSubExpression : JmesPathCompoundExpression {
    public JmesPathSubExpression(JmesPathExpression expression, JmesPathExpression subExpression);
    public virtual string ToString();
}
public class DevLab.JmesPath.Expressions.JmesPathSubtractionExpression : JmesPathArithmeticExpression {
    public JmesPathSubtractionExpression(JmesPathExpression left, JmesPathExpression right);
    protected virtual double Compute(double left, double right);
    public virtual string ToString();
}
public class DevLab.JmesPath.Expressions.JmesPathUnaryMinusExpression : JmesPathSubtractionExpression {
    public JmesPathUnaryMinusExpression(JmesPathExpression expression);
    public virtual string ToString();
}
public class DevLab.JmesPath.Expressions.JmesPathUnaryPlusExpression : JmesPathAdditionExpression {
    public JmesPathUnaryPlusExpression(JmesPathExpression expression);
    public virtual string ToString();
}
public class DevLab.JmesPath.Expressions.JmesPathVariableReference : JmesPathExpression {
    private string name_;
    private IContextEvaluator evaluator;
    [CompilerGeneratedAttribute]
private IContextEvaluator <Evaluator>k__BackingField;
    public string Name { get; }
    public IContextEvaluator Evaluator { get; public set; }
    public JmesPathVariableReference(string name);
    public string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual IContextEvaluator get_Evaluator();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Evaluator(IContextEvaluator value);
    public virtual void Accept(IVisitor visitor);
    protected virtual JmesPathArgument Transform(JToken json);
    protected virtual string Format();
}
public class DevLab.JmesPath.Functions.AbsFunction : JmesPathFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.AvgFunction : JmesPathFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public abstract class DevLab.JmesPath.Functions.ByFunction : JmesPathFunction {
    protected ByFunction(string name);
    public virtual void Validate(JmesPathFunctionArgument[] args);
    protected JToken Evaluate(JmesPathExpression expression, JToken token);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Functions.ByFunction/<EvaluateAsync>d__3")]
protected Task`1<JToken> EvaluateAsync(JmesPathExpression expression, JToken token);
}
public class DevLab.JmesPath.Functions.CeilFunction : JmesPathFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.ContainsFunction : JmesPathFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.EndsWithFunction : StartsEndsWithFunction {
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.FindFirstFunction : JmesPathFunction {
    protected FindFirstFunction(string name);
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.FindLastFunction : FindFirstFunction {
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.FloorFunction : JmesPathFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.FromItemsFunction : JmesPathFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.GroupByFunction : ByFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Functions.GroupByFunction/<ExecuteAsync>d__3")]
public virtual Task`1<JToken> ExecuteAsync(JmesPathFunctionArgument[] args);
    private static void AddElement(IDictionary`2<string, IList`1<JToken>> dictionary, string key, JToken element);
}
public class DevLab.JmesPath.Functions.ItemsFunction : JmesPathFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public abstract class DevLab.JmesPath.Functions.JmesPathFunction : object {
    protected IScopeParticipant scopes_;
    private JToken context_;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinArgumentCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxArgumentCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Variadic>k__BackingField;
    public string Name { get; private set; }
    public int MinArgumentCount { get; }
    public Nullable`1<int> MaxArgumentCount { get; }
    public bool Variadic { get; }
    public IScopeParticipant Scopes { get; }
    protected JToken Context { get; }
    protected JmesPathFunction(string name, int count);
    protected JmesPathFunction(string name, int count, IScopeParticipant scopes);
    protected JmesPathFunction(string name, int minCount, bool variadic);
    protected JmesPathFunction(string name, int minCount, int maxCount);
    protected JmesPathFunction(string name, int minCount, Nullable`1<int> maxCount, bool variadic, IScopeParticipant scopes);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_MinArgumentCount();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxArgumentCount();
    [CompilerGeneratedAttribute]
public bool get_Variadic();
    public IScopeParticipant get_Scopes();
    protected JToken get_Context();
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public abstract virtual JToken Execute(JmesPathFunctionArgument[] args);
    public virtual Task`1<JToken> ExecuteAsync(JmesPathFunctionArgument[] args);
    protected static bool IsInteger(double sum);
    protected string EnsureString(JmesPathFunctionArgument argument);
    protected JObject EnsureObject(JmesPathFunctionArgument argument);
    protected JArray EnsureArray(JmesPathFunctionArgument argument);
    protected JArray EnsureArrayOf(JmesPathFunctionArgument argument, string type);
    protected JArray EnsureArrayOfAny(JmesPathFunctionArgument argument, String[] types);
    protected JArray EnsureArrayOfSame(JmesPathFunctionArgument argument, String[] types);
    protected void EnsureArrayOrString(JmesPathFunctionArgument argument);
    protected void EnsureExpressionType(JmesPathFunctionArgument argument);
    protected void EnsureNumbers(JmesPathFunctionArgument[] args);
    private JToken EnsureOf(JmesPathFunctionArgument argument, string type);
    private static string FormatAllowedDataTypes(String[] types);
    public void SetContext(JToken token);
}
public class DevLab.JmesPath.Functions.JmesPathFunctionArgument : ValueType {
    private JToken token_;
    private JmesPathExpression expression_;
    public bool IsExpressionType { get; }
    public bool IsToken { get; }
    public JmesPathExpression Expression { get; }
    public JToken Token { get; }
    public JmesPathFunctionArgument(JToken token);
    public JmesPathFunctionArgument(JmesPathExpression expression);
    public bool get_IsExpressionType();
    public bool get_IsToken();
    public JmesPathExpression get_Expression();
    public JToken get_Token();
}
[DefaultMemberAttribute("Item")]
public class DevLab.JmesPath.Functions.JmesPathFunctionFactory : object {
    private Dictionary`2<string, JmesPathFunction> functions_;
    public IEnumerable`1<string> Names { get; }
    public JmesPathFunction Item { get; }
    public static JmesPathFunctionFactory Create();
    public sealed virtual IRegisterFunctions Register(string name, JmesPathFunction function);
    public sealed virtual IRegisterFunctions Register();
    public sealed virtual IEnumerable`1<string> get_Names();
    public sealed virtual JmesPathFunction get_Item(string name);
    public sealed virtual bool Contains(string name);
}
public class DevLab.JmesPath.Functions.JoinFunction : JmesPathFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.KeysFunction : JmesPathFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.LengthFunction : JmesPathFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.LowerFunction : JmesPathFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.MapFunction : JmesPathFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Functions.MapFunction/<ExecuteAsync>d__3")]
public virtual Task`1<JToken> ExecuteAsync(JmesPathFunctionArgument[] args);
}
public abstract class DevLab.JmesPath.Functions.MathArrayFunction : JmesPathFunction {
    protected MathArrayFunction(string name, int count);
    protected MathArrayFunction(string name, int minCount, bool variadic);
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
    protected abstract virtual JToken Execute(JArray array, IEnumerable`1<string> dataTypes);
}
public class DevLab.JmesPath.Functions.MaxByFunction : ByFunction {
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Functions.MaxByFunction/<ExecuteAsync>d__2")]
public virtual Task`1<JToken> ExecuteAsync(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.MaxFunction : MinOrMaxFunction {
    protected virtual JToken GetMinOrMax(JArray array);
}
public class DevLab.JmesPath.Functions.MergeFunction : JmesPathFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.MinByFunction : ByFunction {
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Functions.MinByFunction/<ExecuteAsync>d__2")]
public virtual Task`1<JToken> ExecuteAsync(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.MinFunction : MinOrMaxFunction {
    protected virtual JToken GetMinOrMax(JArray array);
}
public abstract class DevLab.JmesPath.Functions.MinOrMaxFunction : MathArrayFunction {
    public MinOrMaxFunction(string name);
    protected virtual JToken Execute(JArray array, IEnumerable`1<string> dataTypes);
    protected abstract virtual JToken GetMinOrMax(JArray array);
}
public class DevLab.JmesPath.Functions.NotNullFunction : JmesPathFunction {
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.PadLeftFunction : JmesPathFunction {
    protected string text_;
    protected int width_;
    protected char character_;
    protected PadLeftFunction(string name);
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.PadRightFunction : PadLeftFunction {
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.ReplaceFunction : JmesPathFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.ReverseFunction : JmesPathFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.SortByFunction : ByFunction {
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Functions.SortByFunction/<ExecuteAsync>d__2")]
public virtual Task`1<JToken> ExecuteAsync(JmesPathFunctionArgument[] args);
    private JToken[] SortByNumbers(JToken[] array, JmesPathExpression expression);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Functions.SortByFunction/<SortByNumbersAsync>d__4`1")]
private Task`1<JToken[]> SortByNumbersAsync(JToken[] array, JmesPathExpression expression);
    private JToken[] SortByText(JToken[] array, JmesPathExpression expression);
    [AsyncStateMachineAttribute("DevLab.JmesPath.Functions.SortByFunction/<SortByTextAsync>d__6")]
private Task`1<JToken[]> SortByTextAsync(JToken[] array, JmesPathExpression expression);
}
public class DevLab.JmesPath.Functions.SortFunction : JmesPathFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
    internal static T[] SortNumber(JArray array);
    internal static String[] SortText(JArray array);
}
public class DevLab.JmesPath.Functions.SplitFunction : JmesPathFunction {
    private string text_;
    private string separator_;
    private Nullable`1<int> count_;
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public abstract class DevLab.JmesPath.Functions.StartsEndsWithFunction : JmesPathFunction {
    protected StartsEndsWithFunction(string name);
    public virtual void Validate(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.StartsWithFunction : StartsEndsWithFunction {
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.SumFunction : JmesPathFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.ToArrayFunction : JmesPathFunction {
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.ToNumberFunction : JmesPathFunction {
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.ToStringFunction : JmesPathFunction {
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.TrimFunction : JmesPathFunction {
    protected TrimFunction(string name);
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
    protected ValueTuple`2<string, Char[]> GetFunctionArguments(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.TrimLeftFunction : TrimFunction {
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.TrimRightFunction : TrimFunction {
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.TypeFunction : JmesPathFunction {
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.UpperFunction : JmesPathFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.ValuesFunction : JmesPathFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public class DevLab.JmesPath.Functions.ZipFunction : JmesPathFunction {
    public virtual void Validate(JmesPathFunctionArgument[] args);
    public virtual JToken Execute(JmesPathFunctionArgument[] args);
}
public interface DevLab.JmesPath.Interop.IContextEvaluator {
    public JToken Root { get; }
    public abstract virtual JToken get_Root();
    public abstract virtual JToken Evaluate(string identifier);
}
public interface DevLab.JmesPath.Interop.IContextHolder {
    public IContextEvaluator Evaluator { get; public set; }
    public abstract virtual IContextEvaluator get_Evaluator();
    public abstract virtual void set_Evaluator(IContextEvaluator value);
}
[DefaultMemberAttribute("Item")]
public interface DevLab.JmesPath.Interop.IFunctionRepository {
    public IEnumerable`1<string> Names { get; }
    public JmesPathFunction Item { get; }
    public abstract virtual IEnumerable`1<string> get_Names();
    public abstract virtual JmesPathFunction get_Item(string name);
    public abstract virtual bool Contains(string name);
}
public interface DevLab.JmesPath.Interop.IRegisterFunctions {
    public abstract virtual IRegisterFunctions Register(string name, JmesPathFunction function);
    public abstract virtual IRegisterFunctions Register();
}
public interface DevLab.JmesPath.Interop.IScopeHolder {
    public IScopeParticipant Scopes { get; public set; }
    public abstract virtual IScopeParticipant get_Scopes();
    public abstract virtual void set_Scopes(IScopeParticipant value);
}
public interface DevLab.JmesPath.Interop.IScopeParticipant {
    public abstract virtual void SetRoot(JToken root);
    public abstract virtual void PushScope(JToken scope);
    public abstract virtual void PopScope();
}
public interface DevLab.JmesPath.Interop.IVisitor {
    public abstract virtual void Visit(JmesPathExpression expression);
}
public class DevLab.JmesPath.JmesPath : object {
    private Encoding _encoding;
    private JmesPathFunctionFactory repository_;
    public IRegisterFunctions FunctionRepository { get; }
    public JmesPath(Encoding encoding);
    public IRegisterFunctions get_FunctionRepository();
    [ObsoleteAttribute("Please, use the Transform(string, string) overload instead.")]
public JToken Transform(JToken token, string expression);
    [AsyncStateMachineAttribute("DevLab.JmesPath.JmesPath/<TransformAsync>d__7")]
public Task`1<JToken> TransformAsync(JToken token, string expression);
    public string Transform(string json, string expression);
    [AsyncStateMachineAttribute("DevLab.JmesPath.JmesPath/<TransformAsync>d__9")]
public Task`1<string> TransformAsync(string json, string expression);
    public JmesPathExpression Parse(string expression);
    public JmesPathExpression Parse(Stream stream);
    public static JToken ParseJson(string input);
}
internal class DevLab.JmesPath.JmesPathGenerator : object {
    private IFunctionRepository repository_;
    private Stack`1<IDictionary`2<string, JmesPathExpression>> selectHashes_;
    private Stack`1<IList`1<JmesPathExpression>> selectLists_;
    private Stack`1<IList`1<JmesPathExpression>> functions_;
    private Stack`1<IList`1<JmesPathBinding>> bindings_;
    private Stack`1<JmesPathExpression> expressions_;
    private IList`1<JmesPathBinding> currentBindings_;
    private static JmesPathFlattenProjection JmesPathFlattenProjection;
    private static JmesPathListWildcardProjection JmesPathListWildcardProjection;
    private static JmesPathHashWildcardProjection JmesPathHashWildcardProjection;
    public JmesPathExpression Expression { get; }
    public JmesPathGenerator(IFunctionRepository repository);
    private static JmesPathGenerator();
    public JmesPathExpression get_Expression();
    public sealed virtual void OnExpression();
    public sealed virtual bool IsProjection();
    public sealed virtual void OnSubExpression();
    public sealed virtual void OnIndex(int index);
    public sealed virtual void OnFilterProjection();
    public sealed virtual void OnFlattenProjection();
    public sealed virtual void OnListWildcardProjection();
    public sealed virtual void OnIndexExpression();
    public sealed virtual void OnSliceExpression(Nullable`1<int> start, Nullable`1<int> stop, Nullable`1<int> step);
    public sealed virtual void OnComparisonEqual();
    public sealed virtual void OnComparisonNotEqual();
    public sealed virtual void OnComparisonGreaterOrEqual();
    public sealed virtual void OnComparisonGreater();
    public sealed virtual void OnComparisonLesserOrEqual();
    public sealed virtual void OnComparisonLesser();
    public sealed virtual void OnArithmeticUnaryPlus();
    public sealed virtual void OnArithmeticUnaryMinus();
    public sealed virtual void OnArithmeticAddition();
    public sealed virtual void OnArithmeticSubtraction();
    public sealed virtual void OnArithmeticMultiplication();
    public sealed virtual void OnArithmeticDivision();
    public sealed virtual void OnArithmeticModulo();
    public sealed virtual void OnArithmeticIntegerDivision();
    public sealed virtual void OnOrExpression();
    public sealed virtual void OnAndExpression();
    public sealed virtual void OnNotExpression();
    public sealed virtual void OnLetExpression();
    public sealed virtual void OnLetBindings();
    public sealed virtual void OnLetBinding(string name);
    public sealed virtual void OnVariableReference(string name);
    public sealed virtual void OnIdentifier(string name);
    public sealed virtual void OnHashWildcardProjection();
    public sealed virtual void PushMultiSelectHash();
    public sealed virtual void AddMultiSelectHashExpression();
    public sealed virtual void PopMultiSelectHash();
    public sealed virtual void PushMultiSelectList();
    public sealed virtual void AddMultiSelectListExpression();
    public sealed virtual void PopMultiSelectList();
    public sealed virtual void OnLiteralString(string literal);
    public sealed virtual void OnPipeExpression();
    public sealed virtual void PushFunction();
    public sealed virtual void PopFunction(string name);
    public sealed virtual void AddFunctionArg();
    public sealed virtual void OnExpressionType();
    public sealed virtual void OnRawString(string value);
    public sealed virtual void OnCurrentNode();
    public sealed virtual void OnRootNode();
    private void Push();
    private void Push(Func`1<T> factory);
    private void Push(JmesPathExpression expression);
    private void PopPush(Func`2<JmesPathExpression, T> factory);
    private void PopPush(Func`3<JmesPathExpression, JmesPathExpression, T> factory);
    [CompilerGeneratedAttribute]
private JmesPathLetExpression <OnLetExpression>b__38_0();
    [CompilerGeneratedAttribute]
private JmesPathMultiSelectHash <PopMultiSelectHash>b__47_0();
    [CompilerGeneratedAttribute]
private JmesPathMultiSelectList <PopMultiSelectList>b__50_0();
}
public class DevLab.JmesPath.ScopeParticipant : object {
    private Stack`1<JToken> scopes_;
    private JToken root_;
    private JToken DevLab.JmesPath.Interop.IContextEvaluator.Root { get; }
    private sealed virtual override JToken DevLab.JmesPath.Interop.IContextEvaluator.get_Root();
    public sealed virtual JToken Evaluate(string identifier);
    public sealed virtual void SetRoot(JToken root);
    public sealed virtual void PushScope(JToken token);
    public sealed virtual void PopScope();
}
internal class DevLab.JmesPath.Utils.CodePointEnumerator : object {
    private string text_;
    private Int32[] codePoints_;
    private int index_;
    public int Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public CodePointEnumerator(Text text);
    [IteratorStateMachineAttribute("DevLab.JmesPath.Utils.CodePointEnumerator/<AsEnumerable>d__4")]
public IEnumerable`1<int> AsEnumerable();
    public sealed virtual int get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
    internal static Int32[] GetCodePoints(Text text);
}
[ExtensionAttribute]
public static class DevLab.JmesPath.Utils.JArrayExtensions : object {
    [ExtensionAttribute]
public static JArray AddRange(JArray array, JToken[] tokens);
    [ExtensionAttribute]
public static JArray AddRange(JArray array, IEnumerable`1<JToken> tokens);
}
[ExtensionAttribute]
public static class DevLab.JmesPath.Utils.JTokenExtensions : object {
    [ExtensionAttribute]
public static string AsString(JToken token);
    [ExtensionAttribute]
public static string GetTokenType(JToken token);
}
public static class DevLab.JmesPath.Utils.JTokens : object {
    public static JToken Null;
    public static JToken True;
    public static JToken False;
    private static JTokens();
    public static bool IsNull(JToken token);
    public static bool IsFalse(JToken token);
}
internal class DevLab.JmesPath.Utils.Text : object {
    private string text_;
    private StringInfo info_;
    private static IComparer`1<Text> defaultComparer_;
    public static IComparer`1<Text> CodePointComparer { get; }
    public int Length { get; }
    public Int32[] CodePoints { get; }
    public Text(string text);
    public Text(Int32[] codePoints);
    private static Text();
    public static IComparer`1<Text> get_CodePointComparer();
    public int get_Length();
    public IEnumerator`1<int> GetCodePointsEnumerator();
    public Int32[] get_CodePoints();
    public static string op_Implicit(Text text);
    public static Text op_Explicit(string text);
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    public sealed virtual bool Equals(Text other);
    public sealed virtual int CompareTo(Text other);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
}
internal class DevLab.JmesPath.Utils.TextEnumerator : object {
    private TextElementEnumerator enum_;
    public string Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public TextEnumerator(string text);
    public sealed virtual string get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class jmespath.net.Functions.Impl.StringExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<int> Find(string text, string search, Nullable`1<int> start, Nullable`1<int> end);
    [ExtensionAttribute]
public static Nullable`1<int> FindLast(string text, string search, Nullable`1<int> start, Nullable`1<int> end);
    [ExtensionAttribute]
public static string Replace(string text, string replace, string with, Nullable`1<int> count);
    [ExtensionAttribute]
public static String[] Split(string text, string separator, Nullable`1<int> count);
}
