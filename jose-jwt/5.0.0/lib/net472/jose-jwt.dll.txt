public class Jose.AesCbcHmacEncryption : object {
    private IJwsAlgorithm hashAlgorithm;
    private int keyLength;
    public int KeySize { get; }
    public AesCbcHmacEncryption(IJwsAlgorithm hashAlgorithm, int keyLength);
    public sealed virtual Byte[][] Encrypt(Byte[] aad, Byte[] plainText, Byte[] cek);
    public sealed virtual Byte[] Decrypt(Byte[] aad, Byte[] cek, Byte[] iv, Byte[] cipherText, Byte[] authTag);
    public sealed virtual int get_KeySize();
    private Byte[] ComputeAuthTag(Byte[] aad, Byte[] iv, Byte[] cipherText, Byte[] hmacKey);
}
public static class Jose.AesGcm : object {
    public static Byte[][] Encrypt(Byte[] key, Byte[] iv, Byte[] aad, Byte[] plainText);
    public static Byte[] Decrypt(Byte[] key, Byte[] iv, Byte[] aad, Byte[] cipherText, Byte[] authTag);
    private static int MaxAuthTagSize(IntPtr hAlg);
    private static IntPtr OpenAlgorithmProvider(string alg, string provider, string chainingMode);
    private static IntPtr ImportKey(IntPtr hAlg, Byte[] key, IntPtr& hKey);
    private static Byte[] GetProperty(IntPtr hAlg, string name);
}
public class Jose.AesGcmEncryption : object {
    private int keyLength;
    public int KeySize { get; }
    public AesGcmEncryption(int keyLength);
    public sealed virtual Byte[][] Encrypt(Byte[] aad, Byte[] plainText, Byte[] cek);
    public sealed virtual Byte[] Decrypt(Byte[] aad, Byte[] cek, Byte[] iv, Byte[] cipherText, Byte[] authTag);
    public sealed virtual int get_KeySize();
}
public class Jose.AesGcmKeyWrapManagement : object {
    private int keyLengthBits;
    public AesGcmKeyWrapManagement(int keyLengthBits);
    public sealed virtual Byte[][] WrapNewKey(int cekSizeBits, object key, IDictionary`2<string, object> header);
    public sealed virtual Byte[] WrapKey(Byte[] cek, object key, IDictionary`2<string, object> header);
    public sealed virtual Byte[] Unwrap(Byte[] encryptedCek, object key, int cekSizeBits, IDictionary`2<string, object> header);
    private Byte[] byteKey(object key);
}
public static class Jose.AesKeyWrap : object {
    private static Byte[] DefaultIV;
    private static AesKeyWrap();
    public static Byte[] Wrap(Byte[] cek, Byte[] kek);
    public static Byte[] Unwrap(Byte[] encryptedCek, Byte[] kek);
    private static Byte[] AesDec(Byte[] sharedKey, Byte[] cipherText);
    private static Byte[] AesEnc(Byte[] sharedKey, Byte[] plainText);
}
public class Jose.AesKeyWrapManagement : object {
    private int kekLengthBits;
    public AesKeyWrapManagement(int kekLengthBits);
    public sealed virtual Byte[][] WrapNewKey(int cekSizeBits, object key, IDictionary`2<string, object> header);
    public sealed virtual Byte[] WrapKey(Byte[] cek, object key, IDictionary`2<string, object> header);
    public sealed virtual Byte[] Unwrap(Byte[] encryptedCek, object key, int cekSizeBits, IDictionary`2<string, object> header);
    private Byte[] byteKey(object key);
}
public static class Jose.Arrays : object {
    public static Byte[] Empty;
    public static Byte[] Zero;
    private static RandomNumberGenerator rng;
    private static Arrays();
    public static Byte[] FirstHalf(Byte[] arr);
    public static Byte[] SecondHalf(Byte[] arr);
    public static Byte[] Concat(Byte[][] arrays);
    public static Byte[][] Slice(Byte[] array, int count);
    public static Byte[] Xor(Byte[] left, long right);
    public static Byte[] Xor(Byte[] left, Byte[] right);
    public static bool ConstantTimeEquals(Byte[] expected, Byte[] actual);
    public static string Dump(Byte[] arr, string label);
    public static Byte[] Random(int sizeBits);
    public static Byte[] IntToBytes(int value);
    public static Byte[] LongToBytes(long value);
    public static long BytesToLong(Byte[] array);
    public static Byte[] LeftmostBits(Byte[] data, int lengthBits);
    public static Byte[] RightmostBits(Byte[] data, int lengthBits);
    public static Byte[] Truncate(Byte[] data, long size);
}
public static class Jose.Base64Url : object {
    public static string Encode(Byte[] input);
    public static Byte[] Decode(string input);
}
public static class Jose.Collections : object {
    public static String[] Union(String[] src, object other);
}
public static class Jose.Compact : object {
    public static string Serialize(Byte[][] parts);
    public static string Serialize(Byte[] header, string payload, Byte[][] other);
    public static Byte[][] Parse(string token);
    public static Iterator Iterate(string token);
}
public static class Jose.ConcatKDF : object {
    public static Byte[] DeriveKey(CngKey externalPubKey, CngKey privateKey, int keyBitLength, Byte[] algorithmId, Byte[] partyVInfo, Byte[] partyUInfo, Byte[] suppPubInfo);
    public static Byte[] DeriveEcdhKey(ECDiffieHellman externalPubKey, ECDiffieHellman privateKey, int keyBitLength, Byte[] algorithmId, Byte[] partyVInfo, Byte[] partyUInfo, Byte[] suppPubInfo);
}
public class Jose.DeflateCompression : object {
    private long maxBufferSizeBytes;
    public DeflateCompression(long maxBufferSizeBytes);
    public sealed virtual Byte[] Compress(Byte[] plainText);
    public sealed virtual Byte[] Decompress(Byte[] compressedText);
}
public static class Jose.Dictionaries : object {
    public static void Append(IDictionary`2<K, V> src, IDictionary`2<K, V> other);
    public static V Get(IDictionary`2<string, object> src, string key);
    public static List`1<V> GetList(IDictionary`2<string, object> src, string key);
    public static IDictionary`2<string, object> Except(IDictionary`2<string, object> src, HashSet`1<string> keys);
    public static IDictionary`2<string, object> MergeHeaders(IDictionary`2[] dicts);
}
public class Jose.DirectKeyManagement : object {
    public sealed virtual Byte[][] WrapNewKey(int cekSizeBits, object key, IDictionary`2<string, object> header);
    public sealed virtual Byte[] WrapKey(Byte[] cek, object key, IDictionary`2<string, object> header);
    public sealed virtual Byte[] Unwrap(Byte[] encryptedCek, object key, int cekSizeBits, IDictionary`2<string, object> header);
    private Byte[] byteKey(object key);
}
public class Jose.EcdhKeyManagementUnix : object {
    private string algIdHeader;
    public EcdhKeyManagementUnix(bool isDirectAgreement);
    public virtual Byte[][] WrapNewKey(int cekSizeBits, object key, IDictionary`2<string, object> header);
    public virtual Byte[] WrapKey(Byte[] cek, object key, IDictionary`2<string, object> header);
    private Byte[] NewKey(int keyLength, object key, IDictionary`2<string, object> header);
    public virtual Byte[] Wrap(Byte[] cek, object key);
    public virtual Byte[] Unwrap(Byte[] encryptedCek, object key, int cekSizeBits, IDictionary`2<string, object> header);
    public static ECDiffieHellman CreateEcDiffieHellman(ECCurve curve, Byte[] x, Byte[] y, Byte[] d);
    private Byte[] DeriveKey(IDictionary`2<string, object> header, int cekSizeBits, ECDiffieHellman externalPublicKey, ECDiffieHellman privateKey);
}
public class Jose.EcdhKeyManagementUnixWithAesKeyWrap : EcdhKeyManagementUnix {
    private AesKeyWrapManagement aesKW;
    private int keyLengthBits;
    public EcdhKeyManagementUnixWithAesKeyWrap(int keyLengthBits, AesKeyWrapManagement aesKw);
    public virtual Byte[][] WrapNewKey(int cekSizeBits, object key, IDictionary`2<string, object> header);
    public virtual Byte[] WrapKey(Byte[] cek, object key, IDictionary`2<string, object> header);
    public virtual Byte[] Unwrap(Byte[] encryptedCek, object key, int cekSizeBits, IDictionary`2<string, object> header);
}
public class Jose.EcdhKeyManagementWin : object {
    private IKeyManagement ecdhKeyManagementUnix;
    private string algIdHeader;
    public EcdhKeyManagementWin(bool isDirectAgreement, IKeyManagement ecdhKeyManagementUnix);
    public virtual Byte[][] WrapNewKey(int cekSizeBits, object key, IDictionary`2<string, object> header);
    public virtual Byte[] WrapKey(Byte[] cek, object key, IDictionary`2<string, object> header);
    private Byte[] NewKey(int keyLength, object key, IDictionary`2<string, object> header);
    public virtual Byte[] Wrap(Byte[] cek, object key);
    public virtual Byte[] Unwrap(Byte[] encryptedCek, object key, int cekSizeBits, IDictionary`2<string, object> header);
    private Byte[] DeriveKey(IDictionary`2<string, object> header, int cekSizeBits, CngKey externalPublicKey, CngKey privateKey);
}
public class Jose.EcdhKeyManagementWinWithAesKeyWrap : EcdhKeyManagementWin {
    private AesKeyWrapManagement aesKW;
    private int keyLengthBits;
    private EcdhKeyManagementUnixWithAesKeyWrap ecdhKeyManagementUnixWithAesKeyWrap;
    public EcdhKeyManagementWinWithAesKeyWrap(int keyLengthBits, AesKeyWrapManagement aesKw, EcdhKeyManagementUnixWithAesKeyWrap ecdhKeyManagementUnixWithAesKeyWrap);
    public virtual Byte[][] WrapNewKey(int cekSizeBits, object key, IDictionary`2<string, object> header);
    public virtual Byte[] WrapKey(Byte[] cek, object key, IDictionary`2<string, object> header);
    public virtual Byte[] Unwrap(Byte[] encryptedCek, object key, int cekSizeBits, IDictionary`2<string, object> header);
}
public class Jose.EncryptionException : JoseException {
    public EncryptionException(string message);
    public EncryptionException(string message, Exception innerException);
}
public static class Jose.Ensure : object {
    public static void IsEmpty(Byte[] arr, string msg, Object[] args);
    public static T Type(object obj, string msg, Object[] args);
    public static void IsNull(object key, string msg, Object[] args);
    public static void BitSize(Byte[] array, long expectedSize, string msg, Object[] args);
    public static void BitSize(int actualSize, int expectedSize, string msg);
    public static void IsNotEmpty(string arg, string msg, Object[] args);
    public static void Divisible(int arg, int divisor, string msg, Object[] args);
    public static void MinValue(long arg, long min, string msg, Object[] args);
    public static void MaxValue(long arg, long max, string msg, Object[] args);
    public static void MinBitSize(Byte[] arr, long minBitSize, string msg, Object[] args);
    public static void Contains(IDictionary`2<string, object> dict, String[] keys, string msg, Object[] args);
    public static void SameSize(Byte[] left, Byte[] right, string msg, Object[] args);
}
public class Jose.HmacUsingSha : object {
    private string hashMethod;
    public HmacUsingSha(string hashMethod);
    public sealed virtual Byte[] Sign(Byte[] securedInput, object key);
    public sealed virtual bool Verify(Byte[] signature, Byte[] securedInput, object key);
    private KeyedHashAlgorithm KeyedHash(Byte[] key);
}
public interface Jose.ICompression {
    public abstract virtual Byte[] Compress(Byte[] plainText);
    public abstract virtual Byte[] Decompress(Byte[] compressedText);
}
public interface Jose.IJsonMapper {
    public abstract virtual string Serialize(object obj);
    public abstract virtual T Parse(string json);
}
public interface Jose.IJweAlgorithm {
    public int KeySize { get; }
    public abstract virtual Byte[][] Encrypt(Byte[] aad, Byte[] plainText, Byte[] cek);
    public abstract virtual Byte[] Decrypt(Byte[] aad, Byte[] cek, Byte[] iv, Byte[] cipherText, Byte[] authTag);
    public abstract virtual int get_KeySize();
}
public interface Jose.IJwsAlgorithm {
    public abstract virtual Byte[] Sign(Byte[] securedInput, object key);
    public abstract virtual bool Verify(Byte[] signature, Byte[] securedInput, object key);
}
public interface Jose.IKeyManagement {
    public abstract virtual Byte[][] WrapNewKey(int cekSizeBits, object key, IDictionary`2<string, object> header);
    public abstract virtual Byte[] WrapKey(Byte[] cek, object key, IDictionary`2<string, object> header);
    public abstract virtual Byte[] Unwrap(Byte[] encryptedCek, object key, int cekSizeBits, IDictionary`2<string, object> header);
}
public class Jose.IntegrityException : JoseException {
    public IntegrityException(string message);
    public IntegrityException(string message, Exception innerException);
}
public class Jose.InvalidAlgorithmException : JoseException {
    public InvalidAlgorithmException(string message);
    public InvalidAlgorithmException(string message, Exception innerException);
}
public class Jose.JoseException : Exception {
    public JoseException(string message);
    public JoseException(string message, Exception innerException);
}
public class Jose.JSSerializerMapper : object {
    private static JavaScriptSerializer js;
    private static JSSerializerMapper();
    public sealed virtual string Serialize(object obj);
    public sealed virtual T Parse(string json);
}
public static class Jose.JWE : object {
    public static string Encrypt(string plaintext, IEnumerable`1<JweRecipient> recipients, JweEncryption enc, Byte[] aad, SerializationMode mode, Nullable`1<JweCompression> compression, IDictionary`2<string, object> extraProtectedHeaders, IDictionary`2<string, object> unprotectedHeaders, JwtSettings settings);
    public static string EncryptBytes(Byte[] plaintext, IEnumerable`1<JweRecipient> recipients, JweEncryption enc, Byte[] aad, SerializationMode mode, Nullable`1<JweCompression> compression, IDictionary`2<string, object> extraProtectedHeaders, IDictionary`2<string, object> unprotectedHeaders, JwtSettings settings);
    public static JweToken Decrypt(string jwe, object key, Nullable`1<JweAlgorithm> expectedJweAlg, Nullable`1<JweEncryption> expectedJweEnc, JwtSettings settings);
    public static JweToken Headers(string jwe, JwtSettings settings);
    private static JwtSettings GetSettings(JwtSettings settings);
    private static Byte[] Aad(Byte[] protectedHeader, Byte[] aad);
}
public enum Jose.JweAlgorithm : Enum {
    public int value__;
    public static JweAlgorithm RSA1_5;
    public static JweAlgorithm RSA_OAEP;
    public static JweAlgorithm RSA_OAEP_256;
    public static JweAlgorithm DIR;
    public static JweAlgorithm A128KW;
    public static JweAlgorithm A192KW;
    public static JweAlgorithm A256KW;
    public static JweAlgorithm ECDH_ES;
    public static JweAlgorithm ECDH_ES_A128KW;
    public static JweAlgorithm ECDH_ES_A192KW;
    public static JweAlgorithm ECDH_ES_A256KW;
    public static JweAlgorithm PBES2_HS256_A128KW;
    public static JweAlgorithm PBES2_HS384_A192KW;
    public static JweAlgorithm PBES2_HS512_A256KW;
    public static JweAlgorithm A128GCMKW;
    public static JweAlgorithm A192GCMKW;
    public static JweAlgorithm A256GCMKW;
}
public enum Jose.JweCompression : Enum {
    public int value__;
    public static JweCompression DEF;
}
public enum Jose.JweEncryption : Enum {
    public int value__;
    public static JweEncryption A128CBC_HS256;
    public static JweEncryption A192CBC_HS384;
    public static JweEncryption A256CBC_HS512;
    public static JweEncryption A128GCM;
    public static JweEncryption A192GCM;
    public static JweEncryption A256GCM;
}
public class Jose.JweRecipient : object {
    [CompilerGeneratedAttribute]
private JweAlgorithm <Alg>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <EncryptedCek>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <JoseHeader>k__BackingField;
    public JweAlgorithm Alg { get; }
    public object Key { get; }
    public Byte[] EncryptedCek { get; }
    public IDictionary`2<string, object> Header { get; }
    public IDictionary`2<string, object> JoseHeader { get; internal set; }
    public JweRecipient(Byte[] encryptedCek, IDictionary`2<string, object> header);
    public JweRecipient(JweAlgorithm alg, object key, IDictionary`2<string, object> header);
    [CompilerGeneratedAttribute]
public JweAlgorithm get_Alg();
    [CompilerGeneratedAttribute]
public object get_Key();
    [CompilerGeneratedAttribute]
public Byte[] get_EncryptedCek();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Header();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_JoseHeader();
    [CompilerGeneratedAttribute]
internal void set_JoseHeader(IDictionary`2<string, object> value);
}
public class Jose.JweToken : object {
    [CompilerGeneratedAttribute]
private Byte[] <ProtectedHeaderBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <UnprotectedHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<JweRecipient> <Recipients>k__BackingField;
    [CompilerGeneratedAttribute]
private JweRecipient <Recipient>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Aad>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Iv>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Ciphertext>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <PlaintextBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <AuthTag>k__BackingField;
    [CompilerGeneratedAttribute]
private SerializationMode <Encoding>k__BackingField;
    public Byte[] ProtectedHeaderBytes { get; }
    public IDictionary`2<string, object> UnprotectedHeader { get; }
    public List`1<JweRecipient> Recipients { get; }
    public JweRecipient Recipient { get; internal set; }
    public Byte[] Aad { get; }
    public Byte[] Iv { get; }
    public Byte[] Ciphertext { get; }
    public Byte[] PlaintextBytes { get; internal set; }
    public string Plaintext { get; }
    public Byte[] AuthTag { get; }
    public SerializationMode Encoding { get; }
    public JweToken(Byte[] protectedHeaderBytes, IDictionary`2<string, object> unprotectedHeader, List`1<JweRecipient> recipients, Byte[] aad, Byte[] iv, Byte[] ciphertext, Byte[] authTag, SerializationMode encoding);
    public string AsString(IJsonMapper mapper);
    public static JweToken FromString(string token, IJsonMapper jsonMapper);
    [CompilerGeneratedAttribute]
public Byte[] get_ProtectedHeaderBytes();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_UnprotectedHeader();
    [CompilerGeneratedAttribute]
public List`1<JweRecipient> get_Recipients();
    [CompilerGeneratedAttribute]
public JweRecipient get_Recipient();
    [CompilerGeneratedAttribute]
internal void set_Recipient(JweRecipient value);
    [CompilerGeneratedAttribute]
public Byte[] get_Aad();
    [CompilerGeneratedAttribute]
public Byte[] get_Iv();
    [CompilerGeneratedAttribute]
public Byte[] get_Ciphertext();
    [CompilerGeneratedAttribute]
public Byte[] get_PlaintextBytes();
    [CompilerGeneratedAttribute]
internal void set_PlaintextBytes(Byte[] value);
    public string get_Plaintext();
    [CompilerGeneratedAttribute]
public Byte[] get_AuthTag();
    [CompilerGeneratedAttribute]
public SerializationMode get_Encoding();
    private static JweToken ParseCompact(string jwe);
    private static JweToken ParseJson(IDictionary`2<string, object> json);
}
public class Jose.Jwk : object {
    private Byte[] octKey;
    private RSA rsaKey;
    private CngKey eccCngKey;
    private ECDiffieHellman ecdhKey;
    private List`1<X509Certificate2> x509Chain;
    private ECDsa ecdsaKey;
    [CompilerGeneratedAttribute]
private string <Kty>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Use>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alg>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <KeyOps>k__BackingField;
    [CompilerGeneratedAttribute]
private string <K>k__BackingField;
    [CompilerGeneratedAttribute]
private string <N>k__BackingField;
    [CompilerGeneratedAttribute]
private string <E>k__BackingField;
    [CompilerGeneratedAttribute]
private string <D>k__BackingField;
    [CompilerGeneratedAttribute]
private string <P>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DP>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Q>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DQ>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QI>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Crv>k__BackingField;
    [CompilerGeneratedAttribute]
private string <X>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Y>k__BackingField;
    [CompilerGeneratedAttribute]
private string <X5U>k__BackingField;
    [CompilerGeneratedAttribute]
private string <X5T>k__BackingField;
    [CompilerGeneratedAttribute]
private string <X5TSha256>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <X5C>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <OtherParams>k__BackingField;
    public string Kty { get; public set; }
    public string Use { get; public set; }
    public string Alg { get; public set; }
    public string KeyId { get; public set; }
    public List`1<string> KeyOps { get; public set; }
    public string K { get; public set; }
    public string N { get; public set; }
    public string E { get; public set; }
    public string D { get; public set; }
    public string P { get; public set; }
    public string DP { get; public set; }
    public string Q { get; public set; }
    public string DQ { get; public set; }
    public string QI { get; public set; }
    public string Crv { get; public set; }
    public string X { get; public set; }
    public string Y { get; public set; }
    public string X5U { get; public set; }
    public string X5T { get; public set; }
    public string X5TSha256 { get; public set; }
    public List`1<string> X5C { get; public set; }
    public IDictionary`2<string, object> OtherParams { get; public set; }
    public Jwk(string crv, string x, string y, string d);
    public Jwk(string e, string n, string p, string q, string d, string dp, string dq, string qi);
    public Jwk(Byte[] key);
    public Jwk(ECDsa key, bool isPrivate);
    public Jwk(RSA key, bool isPrivate);
    public Jwk(ECDiffieHellman key, bool isPrivate);
    public Jwk(CngKey key, bool isPrivate);
    [CompilerGeneratedAttribute]
public string get_Kty();
    [CompilerGeneratedAttribute]
public void set_Kty(string value);
    [CompilerGeneratedAttribute]
public string get_Use();
    [CompilerGeneratedAttribute]
public void set_Use(string value);
    [CompilerGeneratedAttribute]
public string get_Alg();
    [CompilerGeneratedAttribute]
public void set_Alg(string value);
    [CompilerGeneratedAttribute]
public string get_KeyId();
    [CompilerGeneratedAttribute]
public void set_KeyId(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_KeyOps();
    [CompilerGeneratedAttribute]
public void set_KeyOps(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_K();
    [CompilerGeneratedAttribute]
public void set_K(string value);
    [CompilerGeneratedAttribute]
public string get_N();
    [CompilerGeneratedAttribute]
public void set_N(string value);
    [CompilerGeneratedAttribute]
public string get_E();
    [CompilerGeneratedAttribute]
public void set_E(string value);
    [CompilerGeneratedAttribute]
public string get_D();
    [CompilerGeneratedAttribute]
public void set_D(string value);
    [CompilerGeneratedAttribute]
public string get_P();
    [CompilerGeneratedAttribute]
public void set_P(string value);
    [CompilerGeneratedAttribute]
public string get_DP();
    [CompilerGeneratedAttribute]
public void set_DP(string value);
    [CompilerGeneratedAttribute]
public string get_Q();
    [CompilerGeneratedAttribute]
public void set_Q(string value);
    [CompilerGeneratedAttribute]
public string get_DQ();
    [CompilerGeneratedAttribute]
public void set_DQ(string value);
    [CompilerGeneratedAttribute]
public string get_QI();
    [CompilerGeneratedAttribute]
public void set_QI(string value);
    [CompilerGeneratedAttribute]
public string get_Crv();
    [CompilerGeneratedAttribute]
public void set_Crv(string value);
    [CompilerGeneratedAttribute]
public string get_X();
    [CompilerGeneratedAttribute]
public void set_X(string value);
    [CompilerGeneratedAttribute]
public string get_Y();
    [CompilerGeneratedAttribute]
public void set_Y(string value);
    [CompilerGeneratedAttribute]
public string get_X5U();
    [CompilerGeneratedAttribute]
public void set_X5U(string value);
    [CompilerGeneratedAttribute]
public string get_X5T();
    [CompilerGeneratedAttribute]
public void set_X5T(string value);
    [CompilerGeneratedAttribute]
public string get_X5TSha256();
    [CompilerGeneratedAttribute]
public void set_X5TSha256(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_X5C();
    [CompilerGeneratedAttribute]
public void set_X5C(List`1<string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_OtherParams();
    [CompilerGeneratedAttribute]
public void set_OtherParams(IDictionary`2<string, object> value);
    public RSA RsaKey();
    public Byte[] OctKey();
    public ECDsa ECDsaKey();
    public CngKey CngKey(CngKeyUsages usage);
    public ECDiffieHellman EcDiffieHellmanKey();
    public void Add(X509Certificate2 cert);
    public void SetX509Chain(IEnumerable`1<X509Certificate2> chain);
    public List`1<X509Certificate2> GetX509Chain();
    public void SetX5T(X509Certificate2 cert);
    public void SetX5TSha256(X509Certificate2 cert);
    public IDictionary`2<string, object> ToDictionary();
    public static Jwk FromDictionary(IDictionary`2<string, object> data);
    public string ToJson(IJsonMapper mapper);
    public static Jwk FromJson(string json, IJsonMapper mapper);
    public static string CurveToName(ECCurve curve);
    public static ECCurve NameToCurve(string name);
}
public class Jose.JwkSet : object {
    private List`1<Jwk> keys;
    public List`1<Jwk> Keys { get; }
    public JwkSet(IEnumerable`1<Jwk> keys);
    public JwkSet(Jwk[] keys);
    public List`1<Jwk> get_Keys();
    public void Add(Jwk key);
    public static JwkSet FromDictionary(IDictionary`2<string, object> data);
    public IDictionary`2<string, object> ToDictionary();
    public string ToJson(IJsonMapper mapper);
    public static JwkSet FromJson(string json, IJsonMapper mapper);
    public sealed virtual IEnumerator`1<Jwk> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public enum Jose.JwsAlgorithm : Enum {
    public int value__;
    public static JwsAlgorithm none;
    public static JwsAlgorithm HS256;
    public static JwsAlgorithm HS384;
    public static JwsAlgorithm HS512;
    public static JwsAlgorithm RS256;
    public static JwsAlgorithm RS384;
    public static JwsAlgorithm RS512;
    public static JwsAlgorithm PS256;
    public static JwsAlgorithm PS384;
    public static JwsAlgorithm PS512;
    public static JwsAlgorithm ES256;
    public static JwsAlgorithm ES384;
    public static JwsAlgorithm ES512;
}
public static class Jose.JWT : object {
    private static JwtSettings defaultSettings;
    public static JwtSettings DefaultSettings { get; }
    [ObsoleteAttribute("Custom JsonMappers should be set in DefaultSettings")]
unknown static IJsonMapper JsonMapper {public set; }
    private static JWT();
    public static JwtSettings get_DefaultSettings();
    public static void set_JsonMapper(IJsonMapper value);
    public static IDictionary`2<string, object> Headers(string token, JwtSettings settings);
    public static T Headers(string token, JwtSettings settings);
    public static string Payload(string token, bool b64);
    public static Byte[] PayloadBytes(string token, bool b64);
    public static T Payload(string token, JwtSettings settings);
    public static string Encode(object payload, object key, JweAlgorithm alg, JweEncryption enc, Nullable`1<JweCompression> compression, IDictionary`2<string, object> extraHeaders, JwtSettings settings);
    public static string Encode(string payload, object key, JweAlgorithm alg, JweEncryption enc, Nullable`1<JweCompression> compression, IDictionary`2<string, object> extraHeaders, JwtSettings settings);
    public static string EncodeBytes(Byte[] payload, object key, JweAlgorithm alg, JweEncryption enc, Nullable`1<JweCompression> compression, IDictionary`2<string, object> extraHeaders, JwtSettings settings);
    public static string Encode(object payload, object key, JwsAlgorithm algorithm, IDictionary`2<string, object> extraHeaders, JwtSettings settings, JwtOptions options);
    public static string Encode(string payload, object key, JwsAlgorithm algorithm, IDictionary`2<string, object> extraHeaders, JwtSettings settings, JwtOptions options);
    public static string EncodeBytes(Byte[] payload, object key, JwsAlgorithm algorithm, IDictionary`2<string, object> extraHeaders, JwtSettings settings, JwtOptions options);
    public static string Decode(string token, object key, JweAlgorithm alg, JweEncryption enc, JwtSettings settings);
    public static Byte[] DecodeBytes(string token, object key, JweAlgorithm alg, JweEncryption enc, JwtSettings settings);
    public static string Decode(string token, object key, JwsAlgorithm alg, JwtSettings settings, string payload);
    public static Byte[] DecodeBytes(string token, object key, JwsAlgorithm alg, JwtSettings settings, Byte[] payload);
    public static string Decode(string token, object key, JwtSettings settings, string payload);
    public static Byte[] DecodeBytes(string token, object key, JwtSettings settings, Byte[] payload);
    public static T Decode(string token, object key, JweAlgorithm alg, JweEncryption enc, JwtSettings settings);
    public static T Decode(string token, object key, JwsAlgorithm alg, JwtSettings settings);
    public static T Decode(string token, object key, JwtSettings settings);
    public static string Verify(string token, object key, Nullable`1<JwsAlgorithm> alg, JwtSettings settings, string payload);
    public static Byte[] VerifyBytes(string token, object key, Nullable`1<JwsAlgorithm> alg, JwtSettings settings, Byte[] payload);
    public static string Decrypt(string token, object key, Nullable`1<JweAlgorithm> alg, Nullable`1<JweEncryption> enc, JwtSettings settings);
    public static Byte[] DecryptBytes(string token, object key, Nullable`1<JweAlgorithm> alg, Nullable`1<JweEncryption> enc, JwtSettings settings);
    private static Byte[] DecodeBytes(Iterator parts, object key, Nullable`1<JwsAlgorithm> expectedJwsAlg, Nullable`1<JweAlgorithm> expectedJweAlg, Nullable`1<JweEncryption> expectedJweEnc, JwtSettings settings, Byte[] payload);
    private static string Decode(string token, object key, Nullable`1<JwsAlgorithm> jwsAlg, Nullable`1<JweAlgorithm> jweAlg, Nullable`1<JweEncryption> jweEnc, JwtSettings settings, string payload);
    private static JwtSettings GetSettings(JwtSettings settings);
    private static Byte[] securedInput(Byte[] header, Byte[] payload, bool b64);
}
public class Jose.JwtOptions : object {
    public static JwtOptions Default;
    [CompilerGeneratedAttribute]
private bool <EncodePayload>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DetachPayload>k__BackingField;
    public bool EncodePayload { get; public set; }
    public bool DetachPayload { get; public set; }
    private static JwtOptions();
    [CompilerGeneratedAttribute]
public bool get_EncodePayload();
    [CompilerGeneratedAttribute]
public void set_EncodePayload(bool value);
    [CompilerGeneratedAttribute]
public bool get_DetachPayload();
    [CompilerGeneratedAttribute]
public void set_DetachPayload(bool value);
}
public class Jose.JwtSettings : object {
    private Dictionary`2<JwsAlgorithm, IJwsAlgorithm> jwsAlgorithms;
    private Dictionary`2<JwsAlgorithm, string> jwsAlgorithmsHeaderValue;
    private Dictionary`2<string, JwsAlgorithm> jwsAlgorithmsAliases;
    private Dictionary`2<JweEncryption, IJweAlgorithm> encAlgorithms;
    private Dictionary`2<JweEncryption, string> encAlgorithmsHeaderValue;
    private Dictionary`2<string, JweEncryption> encAlgorithmsAliases;
    private Dictionary`2<JweAlgorithm, IKeyManagement> keyAlgorithms;
    private Dictionary`2<JweAlgorithm, string> keyAlgorithmsHeaderValue;
    private Dictionary`2<string, JweAlgorithm> keyAlgorithmsAliases;
    private Dictionary`2<JweCompression, ICompression> compressionAlgorithms;
    private Dictionary`2<JweCompression, string> jweCompressionHeaderValue;
    private Dictionary`2<string, JweCompression> compressionAlgorithmsAliases;
    private IJsonMapper jsMapper;
    public IJsonMapper JsonMapper { get; public set; }
    public JwtSettings RegisterJwa(JweAlgorithm alg, IKeyManagement impl);
    public JwtSettings RegisterJwaAlias(string alias, JweAlgorithm alg);
    public JwtSettings RegisterJwe(JweEncryption alg, IJweAlgorithm impl);
    public JwtSettings RegisterJweAlias(string alias, JweEncryption alg);
    public JwtSettings RegisterCompression(JweCompression alg, ICompression impl);
    public JwtSettings RegisterCompressionAlias(string alias, JweCompression alg);
    public JwtSettings RegisterJws(JwsAlgorithm alg, IJwsAlgorithm impl);
    public JwtSettings RegisterJwsAlias(string alias, JwsAlgorithm alg);
    public JwtSettings DeregisterJws(JwsAlgorithm alg);
    public JwtSettings DeregisterJwa(JweAlgorithm alg);
    public JwtSettings DeregisterJwe(JweEncryption alg);
    public JwtSettings DeregisterCompression(JweCompression alg);
    public JwtSettings RegisterMapper(IJsonMapper mapper);
    public IJsonMapper get_JsonMapper();
    public void set_JsonMapper(IJsonMapper value);
    public IJwsAlgorithm Jws(JwsAlgorithm alg);
    public string JwsHeaderValue(JwsAlgorithm algorithm);
    public JwsAlgorithm JwsAlgorithmFromHeader(string headerValue);
    public IJweAlgorithm Jwe(JweEncryption alg);
    public string JweHeaderValue(JweEncryption algorithm);
    public JweEncryption JweAlgorithmFromHeader(string headerValue);
    public IKeyManagement Jwa(JweAlgorithm alg);
    public string JwaHeaderValue(JweAlgorithm alg);
    public JweAlgorithm JwaAlgorithmFromHeader(string headerValue);
    public ICompression Compression(JweCompression alg);
    public ICompression Compression(string alg);
    public string CompressionHeader(JweCompression value);
    public JweCompression CompressionAlgFromHeader(string header);
}
public class Jose.keys.EccKey : object {
    public static Byte[] BCRYPT_ECDSA_PUBLIC_P256_MAGIC;
    public static Byte[] BCRYPT_ECDSA_PRIVATE_P256_MAGIC;
    public static Byte[] BCRYPT_ECDSA_PUBLIC_P384_MAGIC;
    public static Byte[] BCRYPT_ECDSA_PRIVATE_P384_MAGIC;
    public static Byte[] BCRYPT_ECDSA_PUBLIC_P521_MAGIC;
    public static Byte[] BCRYPT_ECDSA_PRIVATE_P521_MAGIC;
    public static Byte[] BCRYPT_ECDH_PUBLIC_P256_MAGIC;
    public static Byte[] BCRYPT_ECDH_PRIVATE_P256_MAGIC;
    public static Byte[] BCRYPT_ECDH_PUBLIC_P384_MAGIC;
    public static Byte[] BCRYPT_ECDH_PRIVATE_P384_MAGIC;
    public static Byte[] BCRYPT_ECDH_PUBLIC_P521_MAGIC;
    public static Byte[] BCRYPT_ECDH_PRIVATE_P521_MAGIC;
    private CngKey key;
    private bool isPrivate;
    private Byte[] x;
    private Byte[] y;
    private Byte[] d;
    public Byte[] X { get; }
    public Byte[] Y { get; }
    public Byte[] D { get; }
    public CngKey Key { get; }
    private static EccKey();
    public Byte[] get_X();
    public Byte[] get_Y();
    public Byte[] get_D();
    public CngKey get_Key();
    public static CngKey New(Byte[] x, Byte[] y, Byte[] d, CngKeyUsages usage);
    public static EccKey Generate(CngKey receiverPubKey);
    public static EccKey Export(CngKey _key, bool isPrivate);
    public string Curve();
    private void ExportKey();
}
public class Jose.keys.EcdhKey : object {
    private ECDiffieHellman key;
    private bool isPrivate;
    private Byte[] x;
    private Byte[] y;
    private Byte[] d;
    public Byte[] X { get; }
    public Byte[] Y { get; }
    public Byte[] D { get; }
    public ECDiffieHellman Key { get; }
    public Byte[] get_X();
    public Byte[] get_Y();
    public Byte[] get_D();
    public ECDiffieHellman get_Key();
    public static ECDiffieHellman New(Byte[] x, Byte[] y, Byte[] d, CngKeyUsages usage);
    public static ECDiffieHellman FromPublic(ECDsa key);
    public static ECDiffieHellman FromPrivate(ECDsa key);
    public static EcdhKey Generate(ECDiffieHellman receiverPubKey);
    public static EcdhKey Export(ECDiffieHellman _key, bool isPrivate);
    public string Curve();
    private void ExportKey();
}
public static class Jose.keys.RsaKey : object {
    public static Byte[] BCRYPT_RSAPUBLIC_MAGIC;
    public static Byte[] BCRYPT_RSAPRIVATE_MAGIC;
    private static RsaKey();
    public static CngKey New(RSAParameters parameters);
    public static CngKey New(Byte[] exponent, Byte[] modulus, Byte[] p, Byte[] q);
}
public static class Jose.native.BCrypt : object {
    public static UInt32 ERROR_SUCCESS;
    public static UInt32 BCRYPT_PAD_PSS;
    public static UInt32 BCRYPT_PAD_OAEP;
    public static Byte[] BCRYPT_KEY_DATA_BLOB_MAGIC;
    public static string BCRYPT_OBJECT_LENGTH;
    public static string BCRYPT_CHAIN_MODE_GCM;
    public static string BCRYPT_AUTH_TAG_LENGTH;
    public static string BCRYPT_CHAINING_MODE;
    public static string BCRYPT_KEY_DATA_BLOB;
    public static string BCRYPT_AES_ALGORITHM;
    public static string MS_PRIMITIVE_PROVIDER;
    public static int BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG;
    public static int BCRYPT_INIT_AUTH_MODE_INFO_VERSION;
    public static UInt32 STATUS_AUTH_TAG_MISMATCH;
    private static BCrypt();
    public static UInt32 BCryptOpenAlgorithmProvider(IntPtr& phAlgorithm, string pszAlgId, string pszImplementation, UInt32 dwFlags);
    public static UInt32 BCryptCloseAlgorithmProvider(IntPtr hAlgorithm, UInt32 flags);
    public static UInt32 BCryptGetProperty(IntPtr hObject, string pszProperty, Byte[] pbOutput, int cbOutput, Int32& pcbResult, UInt32 flags);
    internal static UInt32 BCryptSetAlgorithmProperty(IntPtr hObject, string pszProperty, Byte[] pbInput, int cbInput, int dwFlags);
    public static UInt32 BCryptImportKey(IntPtr hAlgorithm, IntPtr hImportKey, string pszBlobType, IntPtr& phKey, IntPtr pbKeyObject, int cbKeyObject, Byte[] pbInput, int cbInput, UInt32 dwFlags);
    public static UInt32 BCryptDestroyKey(IntPtr hKey);
    public static UInt32 BCryptEncrypt(IntPtr hKey, Byte[] pbInput, int cbInput, BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO& pPaddingInfo, Byte[] pbIV, int cbIV, Byte[] pbOutput, int cbOutput, Int32& pcbResult, UInt32 dwFlags);
    internal static UInt32 BCryptDecrypt(IntPtr hKey, Byte[] pbInput, int cbInput, BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO& pPaddingInfo, Byte[] pbIV, int cbIV, Byte[] pbOutput, int cbOutput, Int32& pcbResult, int dwFlags);
}
public static class Jose.native.NCrypt : object {
    public static UInt32 NTE_BAD_SIGNATURE;
    public static UInt32 KDF_ALGORITHMID;
    public static UInt32 KDF_PARTYUINFO;
    public static UInt32 KDF_PARTYVINFO;
    public static UInt32 KDF_SUPPPUBINFO;
    public static UInt32 KDF_SUPPPRIVINFO;
    public static UInt32 NCryptSecretAgreement(SafeNCryptKeyHandle hPrivKey, SafeNCryptKeyHandle hPublicKey, SafeNCryptSecretHandle& phSecret, UInt32 flags);
    public static UInt32 NCryptDeriveKey(SafeNCryptSecretHandle hSharedSecret, string kdf, NCryptBufferDesc parameterList, Byte[] derivedKey, UInt32 derivedKeyByteSize, UInt32& result, UInt32 flags);
    internal static UInt32 NCryptSignHash(SafeNCryptKeyHandle hKey, BCRYPT_PSS_PADDING_INFO& pPaddingInfo, Byte[] pbHashValue, int cbHashValue, Byte[] pbSignature, int cbSignature, UInt32& pcbResult, UInt32 dwFlags);
    internal static UInt32 NCryptVerifySignature(SafeNCryptKeyHandle hKey, BCRYPT_PSS_PADDING_INFO& pPaddingInfo, Byte[] pbHashValue, int cbHashValue, Byte[] pbSignature, int cbSignature, UInt32 dwFlags);
    internal static UInt32 NCryptDecrypt(SafeNCryptKeyHandle hKey, Byte[] pbInput, int cbInput, BCRYPT_OAEP_PADDING_INFO& pvPadding, Byte[] pbOutput, UInt32 cbOutput, UInt32& pcbResult, UInt32 dwFlags);
    internal static UInt32 NCryptEncrypt(SafeNCryptKeyHandle hKey, Byte[] pbInput, int cbInput, BCRYPT_OAEP_PADDING_INFO& pvPadding, Byte[] pbOutput, UInt32 cbOutput, UInt32& pcbResult, UInt32 dwFlags);
}
public class Jose.netstandard1_4.EcdsaUsingSha : object {
    private int keySize;
    protected HashAlgorithmName Hash { get; }
    public EcdsaUsingSha(int keySize);
    public sealed virtual Byte[] Sign(Byte[] securedInput, object key);
    public sealed virtual bool Verify(Byte[] signature, Byte[] securedInput, object key);
    protected HashAlgorithmName get_Hash();
    private Byte[] Sign(CngKey privateKey, Byte[] securedInput);
    private Byte[] Sign(ECDsa privateKey, Byte[] securedInput);
    private bool Verify(CngKey publicKey, Byte[] signature, Byte[] securedInput);
    private bool Verify(ECDsa publicKey, Byte[] signature, Byte[] securedInput);
}
public static class Jose.PBKDF2 : object {
    public static Byte[] DeriveKey(Byte[] password, Byte[] salt, int iterationCount, int keyBitLength, HMAC prf);
    private static Byte[] F(Byte[] salt, int iterationCount, int blockIndex, HMAC prf);
}
public class Jose.Pbse2HmacShaKeyManagementWithAesKeyWrap : object {
    private AesKeyWrapManagement aesKW;
    private int keyLengthBits;
    private long maxIterations;
    private long minIterations;
    private HMAC PRF { get; }
    public Pbse2HmacShaKeyManagementWithAesKeyWrap(int keyLengthBits, AesKeyWrapManagement aesKw, long maxIterations, int minIterations);
    public sealed virtual Byte[][] WrapNewKey(int cekSizeBits, object key, IDictionary`2<string, object> header);
    public sealed virtual Byte[] WrapKey(Byte[] cek, object key, IDictionary`2<string, object> header);
    public sealed virtual Byte[] Unwrap(Byte[] encryptedCek, object key, int cekSizeBits, IDictionary`2<string, object> header);
    private HMAC get_PRF();
}
public class Jose.Plaintext : object {
    public sealed virtual Byte[] Sign(Byte[] securedInput, object key);
    public sealed virtual bool Verify(Byte[] signature, Byte[] securedInput, object key);
}
public class Jose.RsaKeyManagement : object {
    private bool useRsaOaepPadding;
    public RsaKeyManagement(bool useRsaOaepPadding);
    public sealed virtual Byte[][] WrapNewKey(int cekSizeBits, object key, IDictionary`2<string, object> header);
    public sealed virtual Byte[] WrapKey(Byte[] cek, object key, IDictionary`2<string, object> header);
    public sealed virtual Byte[] Unwrap(Byte[] encryptedCek, object key, int cekSizeBits, IDictionary`2<string, object> header);
    private Byte[] decrypt(Byte[] content, RSA privateKey);
    private Byte[] encrypt(Byte[] content, RSA publicKey);
}
public static class Jose.RsaOaep : object {
    public static Byte[] Decrypt(Byte[] cipherText, CngKey key, CngAlgorithm hash);
    public static Byte[] Encrypt(Byte[] plainText, CngKey key, CngAlgorithm hash);
}
public class Jose.RsaOaep256KeyManagement : object {
    public sealed virtual Byte[][] WrapNewKey(int cekSizeBits, object key, IDictionary`2<string, object> header);
    public sealed virtual Byte[] WrapKey(Byte[] cek, object key, IDictionary`2<string, object> header);
    public sealed virtual Byte[] Unwrap(Byte[] encryptedCek, object key, int cekSizeBits, IDictionary`2<string, object> header);
}
public static class Jose.RsaPss : object {
    public static Byte[] Sign(Byte[] input, CngKey key, CngAlgorithm hash, int saltSize);
    public static bool Verify(Byte[] securedInput, Byte[] signature, CngKey key, CngAlgorithm hash, int saltSize);
    private static bool VerifyHash(Byte[] hash, Byte[] signature, CngKey key, string algorithm, int saltSize);
    private static Byte[] SignHash(Byte[] hash, CngKey key, string algorithm, int saltSize);
    private static HashAlgorithm HashAlgorithm(CngAlgorithm hash);
}
public class Jose.RsaPssUsingSha : object {
    private int saltSize;
    private HashAlgorithmName HashAlgorithm { get; }
    private CngAlgorithm Hash { get; }
    public RsaPssUsingSha(int saltSize);
    public sealed virtual Byte[] Sign(Byte[] securedInput, object key);
    public sealed virtual bool Verify(Byte[] signature, Byte[] securedInput, object key);
    private HashAlgorithmName get_HashAlgorithm();
    private CngAlgorithm get_Hash();
}
public class Jose.RsaUsingSha : object {
    private string hashMethod;
    private HashAlgorithmName HashAlgorithm { get; }
    public RsaUsingSha(string hashMethod);
    public sealed virtual Byte[] Sign(Byte[] securedInput, object key);
    public sealed virtual bool Verify(Byte[] signature, Byte[] securedInput, object key);
    private HashAlgorithmName get_HashAlgorithm();
}
public enum Jose.SerializationMode : Enum {
    public int value__;
    public static SerializationMode Compact;
    public static SerializationMode Json;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
