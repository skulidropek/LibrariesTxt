[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("additionalItems")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[DependsOnAnnotationsFromAttribute("Json.Schema.ItemsKeyword")]
[JsonConverterAttribute("Json.Schema.AdditionalItemsKeywordJsonConverter")]
public class Json.Schema.AdditionalItemsKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public AdditionalItemsKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    [IteratorStateMachineAttribute("Json.Schema.AdditionalItemsKeyword/<LocateInstances>d__6")]
private static IEnumerable`1<JsonPointer> LocateInstances(KeywordEvaluation evaluation);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.AdditionalItemsKeywordJsonConverter : WeaklyTypedJsonConverter`1<AdditionalItemsKeyword> {
    public virtual AdditionalItemsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, AdditionalItemsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("additionalProperties")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[DependsOnAnnotationsFromAttribute("Json.Schema.PropertiesKeyword")]
[DependsOnAnnotationsFromAttribute("Json.Schema.PatternPropertiesKeyword")]
[JsonConverterAttribute("Json.Schema.AdditionalPropertiesKeywordJsonConverter")]
public class Json.Schema.AdditionalPropertiesKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public AdditionalPropertiesKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    [IteratorStateMachineAttribute("Json.Schema.AdditionalPropertiesKeyword/<LocateInstances>d__6")]
private static IEnumerable`1<JsonPointer> LocateInstances(KeywordEvaluation evaluation);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.AdditionalPropertiesKeywordJsonConverter : WeaklyTypedJsonConverter`1<AdditionalPropertiesKeyword> {
    public virtual AdditionalPropertiesKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, AdditionalPropertiesKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("allOf")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.AllOfKeywordJsonConverter")]
public class Json.Schema.AllOfKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<JsonSchema> <Schemas>k__BackingField;
    public IReadOnlyList`1<JsonSchema> Schemas { get; }
    public AllOfKeyword(JsonSchema[] values);
    public AllOfKeyword(IEnumerable`1<JsonSchema> values);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<JsonSchema> get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.AllOfKeywordJsonConverter : WeaklyTypedJsonConverter`1<AllOfKeyword> {
    public virtual AllOfKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, AllOfKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("$anchor")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/core")]
[JsonConverterAttribute("Json.Schema.AnchorKeywordJsonConverter")]
public class Json.Schema.AnchorKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private string <Anchor>k__BackingField;
    internal static Regex AnchorPattern201909 { get; }
    internal static Regex AnchorPattern202012 { get; }
    public string Anchor { get; }
    public AnchorKeyword(string anchor);
    [GeneratedRegexAttribute("^[A-Za-z][-A-Za-z0-9.:_]*$", "8")]
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
private static Regex GetAnchorPattern201909Regex();
    internal static Regex get_AnchorPattern201909();
    [GeneratedRegexAttribute("^[A-Za-z_][-A-Za-z0-9._]*$", "8")]
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
private static Regex GetAnchorPattern202012Regex();
    internal static Regex get_AnchorPattern202012();
    [CompilerGeneratedAttribute]
public string get_Anchor();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.AnchorKeywordJsonConverter : WeaklyTypedJsonConverter`1<AnchorKeyword> {
    public virtual AnchorKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, AnchorKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("anyOf")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.AnyOfKeywordJsonConverter")]
public class Json.Schema.AnyOfKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<JsonSchema> <Schemas>k__BackingField;
    public IReadOnlyList`1<JsonSchema> Schemas { get; }
    public AnyOfKeyword(JsonSchema[] values);
    public AnyOfKeyword(IEnumerable`1<JsonSchema> values);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<JsonSchema> get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.AnyOfKeywordJsonConverter : WeaklyTypedJsonConverter`1<AnyOfKeyword> {
    public virtual AnyOfKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, AnyOfKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("$comment")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/core")]
[JsonConverterAttribute("Json.Schema.CommentKeywordJsonConverter")]
public class Json.Schema.CommentKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public CommentKeyword(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.CommentKeywordJsonConverter : WeaklyTypedJsonConverter`1<CommentKeyword> {
    public virtual CommentKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, CommentKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Json.Schema.CommonJsonPointers : object {
    public static JsonPointer[] SingleEmptyPointerArray;
    private static ConcurrentDictionary`2<int, JsonPointer> _numberSegments;
    private static CommonJsonPointers();
    public static JsonPointer GetNumberSegment(int i);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("const")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.ConstKeywordJsonConverter")]
public class Json.Schema.ConstKeyword : object {
    [NullableAttribute("1")]
public static string Name;
    [CompilerGeneratedAttribute]
private JsonNode <Value>k__BackingField;
    public JsonNode Value { get; }
    public ConstKeyword(JsonNode value);
    [CompilerGeneratedAttribute]
public JsonNode get_Value();
    [NullableContextAttribute("1")]
public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    [NullableContextAttribute("1")]
private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.ConstKeywordJsonConverter : WeaklyTypedJsonConverter`1<ConstKeyword> {
    public virtual ConstKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ConstKeyword value, JsonSerializerOptions options);
}
[ExtensionAttribute]
public static class Json.Schema.ConstraintExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static KeywordEvaluation GetKeywordEvaluation(KeywordEvaluation evaluation);
    [ExtensionAttribute]
public static KeywordConstraint GetKeywordConstraint(ReadOnlySpan`1<KeywordConstraint> constraints);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("contains")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[DependsOnAnnotationsFromAttribute("Json.Schema.MinContainsKeyword")]
[DependsOnAnnotationsFromAttribute("Json.Schema.MaxContainsKeyword")]
[JsonConverterAttribute("Json.Schema.ContainsKeywordJsonConverter")]
public class Json.Schema.ContainsKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public ContainsKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    [IteratorStateMachineAttribute("Json.Schema.ContainsKeyword/<SubschemaConstraintInstanceLocator>d__6")]
private static IEnumerable`1<JsonPointer> SubschemaConstraintInstanceLocator(KeywordEvaluation evaluation);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.ContainsKeywordJsonConverter : WeaklyTypedJsonConverter`1<ContainsKeyword> {
    public virtual ContainsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ContainsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("contentEncoding")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/content")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/content")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/content")]
[JsonConverterAttribute("Json.Schema.ContentEncodingKeywordJsonConverter")]
public class Json.Schema.ContentEncodingKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public ContentEncodingKeyword(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.ContentEncodingKeywordJsonConverter : WeaklyTypedJsonConverter`1<ContentEncodingKeyword> {
    public virtual ContentEncodingKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ContentEncodingKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("contentMediaType")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/content")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/content")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/content")]
[JsonConverterAttribute("Json.Schema.ContentMediaTypeKeywordJsonConverter")]
public class Json.Schema.ContentMediaTypeKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public ContentMediaTypeKeyword(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.ContentMediaTypeKeywordJsonConverter : WeaklyTypedJsonConverter`1<ContentMediaTypeKeyword> {
    public virtual ContentMediaTypeKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ContentMediaTypeKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("contentSchema")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/content")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/content")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/content")]
[JsonConverterAttribute("Json.Schema.ContentSchemaKeywordJsonConverter")]
public class Json.Schema.ContentSchemaKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public ContentSchemaKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.ContentSchemaKeywordJsonConverter : WeaklyTypedJsonConverter`1<ContentSchemaKeyword> {
    public virtual ContentSchemaKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ContentSchemaKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("default")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/meta-data")]
[JsonConverterAttribute("Json.Schema.DefaultKeywordJsonConverter")]
public class Json.Schema.DefaultKeyword : object {
    [NullableAttribute("1")]
public static string Name;
    [CompilerGeneratedAttribute]
private JsonNode <Value>k__BackingField;
    public JsonNode Value { get; }
    public DefaultKeyword(JsonNode value);
    [CompilerGeneratedAttribute]
public JsonNode get_Value();
    [NullableContextAttribute("1")]
public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.DefaultKeywordJsonConverter : WeaklyTypedJsonConverter`1<DefaultKeyword> {
    public virtual DefaultKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DefaultKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("definitions")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[JsonConverterAttribute("Json.Schema.DefinitionsKeywordJsonConverter")]
public class Json.Schema.DefinitionsKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, JsonSchema> <Definitions>k__BackingField;
    public IReadOnlyDictionary`2<string, JsonSchema> Definitions { get; }
    private IReadOnlyDictionary`2<string, JsonSchema> Json.Schema.IKeyedSchemaCollector.Schemas { get; }
    public DefinitionsKeyword(IReadOnlyDictionary`2<string, JsonSchema> values);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, JsonSchema> get_Definitions();
    private sealed virtual override IReadOnlyDictionary`2<string, JsonSchema> Json.Schema.IKeyedSchemaCollector.get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.DefinitionsKeywordJsonConverter : WeaklyTypedJsonConverter`1<DefinitionsKeyword> {
    public virtual DefinitionsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DefinitionsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("$defs")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/core")]
[JsonConverterAttribute("Json.Schema.DefsKeywordJsonConverter")]
public class Json.Schema.DefsKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, JsonSchema> <Definitions>k__BackingField;
    public IReadOnlyDictionary`2<string, JsonSchema> Definitions { get; }
    private IReadOnlyDictionary`2<string, JsonSchema> Json.Schema.IKeyedSchemaCollector.Schemas { get; }
    public DefsKeyword(IReadOnlyDictionary`2<string, JsonSchema> values);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, JsonSchema> get_Definitions();
    private sealed virtual override IReadOnlyDictionary`2<string, JsonSchema> Json.Schema.IKeyedSchemaCollector.get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.DefsKeywordJsonConverter : WeaklyTypedJsonConverter`1<DefsKeyword> {
    public virtual DefsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DefsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("dependencies")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[JsonConverterAttribute("Json.Schema.DependenciesKeywordJsonConverter")]
public class Json.Schema.DependenciesKeyword : object {
    private IReadOnlyDictionary`2<string, JsonSchema> _schemas;
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, SchemaOrPropertyList> <Requirements>k__BackingField;
    public IReadOnlyDictionary`2<string, SchemaOrPropertyList> Requirements { get; }
    private IReadOnlyDictionary`2<string, JsonSchema> Json.Schema.IKeyedSchemaCollector.Schemas { get; }
    public DependenciesKeyword(IReadOnlyDictionary`2<string, SchemaOrPropertyList> values);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, SchemaOrPropertyList> get_Requirements();
    private sealed virtual override IReadOnlyDictionary`2<string, JsonSchema> Json.Schema.IKeyedSchemaCollector.get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.DependenciesKeywordJsonConverter : WeaklyTypedJsonConverter`1<DependenciesKeyword> {
    public virtual DependenciesKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DependenciesKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("dependentRequired")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.DependentRequiredKeywordJsonConverter")]
public class Json.Schema.DependentRequiredKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> <Requirements>k__BackingField;
    public IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> Requirements { get; }
    public DependentRequiredKeyword(IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> values);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> get_Requirements();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.DependentRequiredKeywordJsonConverter : WeaklyTypedJsonConverter`1<DependentRequiredKeyword> {
    public virtual DependentRequiredKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DependentRequiredKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("dependentSchemas")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.DependentSchemasKeywordJsonConverter")]
public class Json.Schema.DependentSchemasKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, JsonSchema> <Schemas>k__BackingField;
    public IReadOnlyDictionary`2<string, JsonSchema> Schemas { get; }
    public DependentSchemasKeyword(IReadOnlyDictionary`2<string, JsonSchema> values);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, JsonSchema> get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.DependentSchemasKeywordJsonConverter : WeaklyTypedJsonConverter`1<DependentSchemasKeyword> {
    public virtual DependentSchemasKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DependentSchemasKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("12")]
public class Json.Schema.DependsOnAnnotationsFromAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <DependentType>k__BackingField;
    public Type DependentType { get; }
    public DependsOnAnnotationsFromAttribute(Type type);
    [CompilerGeneratedAttribute]
public Type get_DependentType();
}
[AttributeUsageAttribute("12")]
public class Json.Schema.DependsOnAnnotationsFromAttribute`1 : DependsOnAnnotationsFromAttribute {
}
[SchemaKeywordAttribute("deprecated")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/meta-data")]
[JsonConverterAttribute("Json.Schema.DeprecatedKeywordJsonConverter")]
public class Json.Schema.DeprecatedKeyword : object {
    [NullableAttribute("1")]
public static string Name;
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; }
    public DeprecatedKeyword(bool value);
    [CompilerGeneratedAttribute]
public bool get_Value();
    [NullableContextAttribute("1")]
public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.DeprecatedKeywordJsonConverter : WeaklyTypedJsonConverter`1<DeprecatedKeyword> {
    public virtual DeprecatedKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DeprecatedKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("description")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/meta-data")]
[JsonConverterAttribute("Json.Schema.DescriptionKeywordJsonConverter")]
public class Json.Schema.DescriptionKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public DescriptionKeyword(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.DescriptionKeywordJsonConverter : WeaklyTypedJsonConverter`1<DescriptionKeyword> {
    public virtual DescriptionKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DescriptionKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Json.Schema.Duration : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <Years>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Months>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Weeks>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Days>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Hours>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Minutes>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Seconds>k__BackingField;
    public UInt32 Years { get; }
    public UInt32 Months { get; }
    public UInt32 Weeks { get; }
    public UInt32 Days { get; }
    public UInt32 Hours { get; }
    public UInt32 Minutes { get; }
    public UInt32 Seconds { get; }
    private Duration(UInt32 years, UInt32 months, UInt32 weeks, UInt32 days, UInt32 hours, UInt32 minutes, UInt32 seconds);
    [CompilerGeneratedAttribute]
public UInt32 get_Years();
    [CompilerGeneratedAttribute]
public UInt32 get_Months();
    [CompilerGeneratedAttribute]
public UInt32 get_Weeks();
    [CompilerGeneratedAttribute]
public UInt32 get_Days();
    [CompilerGeneratedAttribute]
public UInt32 get_Hours();
    [CompilerGeneratedAttribute]
public UInt32 get_Minutes();
    [CompilerGeneratedAttribute]
public UInt32 get_Seconds();
    public static Duration Parse(string source);
    public static bool TryParse(string source, Duration& duration);
    private static bool Require(string source, Int32& index, char ch);
    private static bool TryGetComponent(string source, Int32& index, UInt32& number, char ch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("$dynamicAnchor")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/core")]
[JsonConverterAttribute("Json.Schema.DynamicAnchorKeywordJsonConverter")]
public class Json.Schema.DynamicAnchorKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public DynamicAnchorKeyword(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.DynamicAnchorKeywordJsonConverter : WeaklyTypedJsonConverter`1<DynamicAnchorKeyword> {
    public virtual DynamicAnchorKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DynamicAnchorKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("$dynamicRef")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/core")]
[JsonConverterAttribute("Json.Schema.DynamicRefKeywordJsonConverter")]
public class Json.Schema.DynamicRefKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private Uri <Reference>k__BackingField;
    public Uri Reference { get; }
    public DynamicRefKeyword(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_Reference();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context, JsonSchema target);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.DynamicRefKeywordJsonConverter : WeaklyTypedJsonConverter`1<DynamicRefKeyword> {
    public virtual DynamicRefKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DynamicRefKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.DynamicScope : object {
    private Stack`1<Uri> _scope;
    public Uri LocalScope { get; }
    internal DynamicScope(Uri initialScope);
    internal DynamicScope(DynamicScope other);
    public Uri get_LocalScope();
    internal void Push(Uri newLocal);
    internal void Pop();
    public sealed virtual IEnumerator`1<Uri> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(DynamicScope other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("else")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[DependsOnAnnotationsFromAttribute("Json.Schema.IfKeyword")]
[JsonConverterAttribute("Json.Schema.ElseKeywordJsonConverter")]
public class Json.Schema.ElseKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public ElseKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.ElseKeywordJsonConverter : WeaklyTypedJsonConverter`1<ElseKeyword> {
    public virtual ElseKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ElseKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Json.Schema.EnumerableExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool ContentsEqual(IReadOnlyList`1<T> collection, IReadOnlyList`1<T> other);
    [ExtensionAttribute]
public static bool ContentsEqual(IReadOnlyList`1<T> collection, IReadOnlyList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int GetStringDictionaryHashCode(IDictionary`2<string, T> collection);
    [ExtensionAttribute]
public static int GetStringDictionaryHashCode(IReadOnlyDictionary`2<string, T> collection);
    [ExtensionAttribute]
public static int GetUnorderedCollectionHashCode(IEnumerable`1<T> collection);
    [ExtensionAttribute]
internal static int GetUnorderedCollectionHashCode(IEnumerable`1<T> collection, Func`2<T, int> getHashCode);
    [ExtensionAttribute]
internal static IReadOnlyList`1<T> ToReadOnlyList(IEnumerable`1<T> values);
    [CompilerGeneratedAttribute]
internal static int <GetStringDictionaryHashCode>g__GetHashCode|2_0(KeyValuePair`2<string, T> kvp);
    [CompilerGeneratedAttribute]
internal static int <GetStringDictionaryHashCode>g__GetHashCode|3_0(KeyValuePair`2<string, T> kvp);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("enum")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.EnumKeywordJsonConverter")]
public class Json.Schema.EnumKeyword : object {
    public static string Name;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonNode[] _values;
    [CompilerGeneratedAttribute]
private static bool <RequireUniqueValues>k__BackingField;
    public static bool RequireUniqueValues { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<JsonNode> Values { get; }
    public EnumKeyword(JsonNode[] values);
    public EnumKeyword(IEnumerable`1<JsonNode> values);
    [CompilerGeneratedAttribute]
public static bool get_RequireUniqueValues();
    [CompilerGeneratedAttribute]
public static void set_RequireUniqueValues(bool value);
    public IReadOnlyList`1<JsonNode> get_Values();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.EnumKeywordJsonConverter : WeaklyTypedJsonConverter`1<EnumKeyword> {
    public virtual EnumKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, EnumKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Json.Schema.ErrorMessages : object {
    [CompilerGeneratedAttribute]
private static string <Const>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ContainsTooFew>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ContainsTooMany>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <DependentRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <DependentSchemas>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <Enum>k__BackingField;
    [NullableAttribute("1")]
private static ResourceManager _resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ExclusiveMaximum>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ExclusiveMinimum>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <UnknownFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <FormatWithDetail>k__BackingField;
    private static string _falseSchema;
    [CompilerGeneratedAttribute]
private static string <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MaxItems>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MaxLength>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MaxProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MinItems>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MinLength>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MinProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MultipleOf>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <OneOf>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MetaSchemaValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <UniqueItems>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <UnknownVocabularies>k__BackingField;
    public static string Const { get; public set; }
    public static string ContainsTooFew { get; public set; }
    public static string ContainsTooMany { get; public set; }
    public static string DependentRequired { get; public set; }
    public static string DependentSchemas { get; public set; }
    public static string Enum { get; public set; }
    public static CultureInfo Culture { get; public set; }
    public static string ExclusiveMaximum { get; public set; }
    public static string ExclusiveMinimum { get; public set; }
    public static string UnknownFormat { get; public set; }
    public static string Format { get; public set; }
    public static string FormatWithDetail { get; public set; }
    [NullableAttribute("1")]
public static string FalseSchema { get; public set; }
    public static string Maximum { get; public set; }
    public static string MaxItems { get; public set; }
    public static string MaxLength { get; public set; }
    public static string MaxProperties { get; public set; }
    public static string Minimum { get; public set; }
    public static string MinItems { get; public set; }
    public static string MinLength { get; public set; }
    public static string MinProperties { get; public set; }
    public static string MultipleOf { get; public set; }
    public static string OneOf { get; public set; }
    public static string Pattern { get; public set; }
    public static string Required { get; public set; }
    public static string MetaSchemaValidation { get; public set; }
    public static string Type { get; public set; }
    public static string UniqueItems { get; public set; }
    public static string UnknownVocabularies { get; public set; }
    private static ErrorMessages();
    [CompilerGeneratedAttribute]
public static string get_Const();
    [CompilerGeneratedAttribute]
public static void set_Const(string value);
    [NullableContextAttribute("1")]
public static string GetConst(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_ContainsTooFew();
    [CompilerGeneratedAttribute]
public static void set_ContainsTooFew(string value);
    [NullableContextAttribute("1")]
public static string GetContainsTooFew(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_ContainsTooMany();
    [CompilerGeneratedAttribute]
public static void set_ContainsTooMany(string value);
    [NullableContextAttribute("1")]
public static string GetContainsTooMany(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_DependentRequired();
    [CompilerGeneratedAttribute]
public static void set_DependentRequired(string value);
    [NullableContextAttribute("1")]
public static string GetDependentRequired(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_DependentSchemas();
    [CompilerGeneratedAttribute]
public static void set_DependentSchemas(string value);
    [NullableContextAttribute("1")]
public static string GetDependentSchemas(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_Enum();
    [CompilerGeneratedAttribute]
public static void set_Enum(string value);
    [NullableContextAttribute("1")]
public static string GetEnum(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public static void set_Culture(CultureInfo value);
    private static string Get(CultureInfo culture, string key);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[RequiresDynamicCodeAttribute("Calls JsonSerializer.Serialize and might require reflection for token values serialization. Prefer ReplaceToken that takes TypeInfo parameters for AOT scenarios.")]
[RequiresUnreferencedCodeAttribute("Calls JsonSerializer.Serialize and might require reflection for token values serialization. Prefer ReplaceToken that takes TypeInfo parameters for AOT scenarios.")]
public static string ReplaceToken(string message, string name, object value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ReplaceToken(string message, string name, T value, JsonTypeInfo`1<T> typeInfo);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ReplaceToken(string message, string name, int value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ReplaceToken(string message, string name, UInt32 value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ReplaceToken(string message, string name, decimal value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ReplaceToken(string message, string name, string value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ReplaceToken(string message, string name, String[] value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ReplaceToken(string message, string name, Dictionary`2<string, String[]> value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ReplaceToken(string message, string name, JsonNode value);
    [CompilerGeneratedAttribute]
public static string get_ExclusiveMaximum();
    [CompilerGeneratedAttribute]
public static void set_ExclusiveMaximum(string value);
    [NullableContextAttribute("1")]
public static string GetExclusiveMaximum(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_ExclusiveMinimum();
    [CompilerGeneratedAttribute]
public static void set_ExclusiveMinimum(string value);
    [NullableContextAttribute("1")]
public static string GetExclusiveMinimum(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_UnknownFormat();
    [CompilerGeneratedAttribute]
public static void set_UnknownFormat(string value);
    [NullableContextAttribute("1")]
public static string GetUnknownFormat(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_Format();
    [CompilerGeneratedAttribute]
public static void set_Format(string value);
    [NullableContextAttribute("1")]
public static string GetFormat(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_FormatWithDetail();
    [CompilerGeneratedAttribute]
public static void set_FormatWithDetail(string value);
    [NullableContextAttribute("1")]
public static string GetFormatWithDetail(CultureInfo culture);
    [NullableContextAttribute("1")]
public static string get_FalseSchema();
    [NullableContextAttribute("1")]
public static void set_FalseSchema(string value);
    [CompilerGeneratedAttribute]
public static string get_Maximum();
    [CompilerGeneratedAttribute]
public static void set_Maximum(string value);
    [NullableContextAttribute("1")]
public static string GetMaximum(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_MaxItems();
    [CompilerGeneratedAttribute]
public static void set_MaxItems(string value);
    [NullableContextAttribute("1")]
public static string GetMaxItems(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_MaxLength();
    [CompilerGeneratedAttribute]
public static void set_MaxLength(string value);
    [NullableContextAttribute("1")]
public static string GetMaxLength(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_MaxProperties();
    [CompilerGeneratedAttribute]
public static void set_MaxProperties(string value);
    [NullableContextAttribute("1")]
public static string GetMaxProperties(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_Minimum();
    [CompilerGeneratedAttribute]
public static void set_Minimum(string value);
    [NullableContextAttribute("1")]
public static string GetMinimum(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_MinItems();
    [CompilerGeneratedAttribute]
public static void set_MinItems(string value);
    [NullableContextAttribute("1")]
public static string GetMinItems(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_MinLength();
    [CompilerGeneratedAttribute]
public static void set_MinLength(string value);
    [NullableContextAttribute("1")]
public static string GetMinLength(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_MinProperties();
    [CompilerGeneratedAttribute]
public static void set_MinProperties(string value);
    [NullableContextAttribute("1")]
public static string GetMinProperties(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_MultipleOf();
    [CompilerGeneratedAttribute]
public static void set_MultipleOf(string value);
    [NullableContextAttribute("1")]
public static string GetMultipleOf(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_OneOf();
    [CompilerGeneratedAttribute]
public static void set_OneOf(string value);
    [NullableContextAttribute("1")]
public static string GetOneOf(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_Pattern();
    [CompilerGeneratedAttribute]
public static void set_Pattern(string value);
    [NullableContextAttribute("1")]
public static string GetPattern(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_Required();
    [CompilerGeneratedAttribute]
public static void set_Required(string value);
    [NullableContextAttribute("1")]
public static string GetRequired(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_MetaSchemaValidation();
    [CompilerGeneratedAttribute]
public static void set_MetaSchemaValidation(string value);
    [NullableContextAttribute("1")]
public static string GetMetaSchemaValidation(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_Type();
    [CompilerGeneratedAttribute]
public static void set_Type(string value);
    [NullableContextAttribute("1")]
public static string GetType(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_UniqueItems();
    [CompilerGeneratedAttribute]
public static void set_UniqueItems(string value);
    [NullableContextAttribute("1")]
public static string GetUniqueItems(CultureInfo culture);
    [CompilerGeneratedAttribute]
public static string get_UnknownVocabularies();
    [CompilerGeneratedAttribute]
public static void set_UnknownVocabularies(string value);
    [NullableContextAttribute("1")]
public static string GetUnknownVocabularies(CultureInfo culture);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.EvaluationContext : object {
    private Stack`1<SpecVersion> _evaluatingAs;
    [CompilerGeneratedAttribute]
private EvaluationOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicScope <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private SpecVersion <EvaluatingAs>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Stack`1<ValueTuple`2<string, JsonPointer>> <NavigatedReferences>k__BackingField;
    public EvaluationOptions Options { get; }
    public DynamicScope Scope { get; }
    public SpecVersion EvaluatingAs { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Stack`1<ValueTuple`2<string, JsonPointer>> NavigatedReferences { get; }
    internal EvaluationContext(EvaluationOptions options, SpecVersion evaluatingAs, Uri initialScope);
    [CompilerGeneratedAttribute]
public EvaluationOptions get_Options();
    [CompilerGeneratedAttribute]
public DynamicScope get_Scope();
    [CompilerGeneratedAttribute]
public SpecVersion get_EvaluatingAs();
    [CompilerGeneratedAttribute]
private void set_EvaluatingAs(SpecVersion value);
    [CompilerGeneratedAttribute]
internal Stack`1<ValueTuple`2<string, JsonPointer>> get_NavigatedReferences();
    internal void PushEvaluatingAs(SpecVersion version);
    internal void PopEvaluatingAs();
    internal void PushEvaluationPath(PointerSegment segment);
    internal void PopEvaluationPath();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.EvaluationOptions : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<Type> _ignoredAnnotationTypes;
    private bool _requireFormatValidation;
    private bool _onlyKnownFormats;
    private bool _processCustomKeywords;
    [CompilerGeneratedAttribute]
private static EvaluationOptions <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private SpecVersion <EvaluateAs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateAgainstMetaSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private OutputFormat <OutputFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private SchemaRegistry <SchemaRegistry>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveDroppedAnnotations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddAnnotationForUnknownKeywords>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowReferencesIntoUnknownKeywords>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Changed>k__BackingField;
    public static EvaluationOptions Default { get; }
    public SpecVersion EvaluateAs { get; public set; }
    public bool ValidateAgainstMetaSchema { get; public set; }
    public OutputFormat OutputFormat { get; public set; }
    public SchemaRegistry SchemaRegistry { get; }
    public bool RequireFormatValidation { get; public set; }
    public bool OnlyKnownFormats { get; public set; }
    public bool ProcessCustomKeywords { get; public set; }
    public bool PreserveDroppedAnnotations { get; public set; }
    public bool AddAnnotationForUnknownKeywords { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<Type> IgnoredAnnotations { get; }
    [NullableAttribute("2")]
public CultureInfo Culture { get; public set; }
    public bool AllowReferencesIntoUnknownKeywords { get; public set; }
    internal bool Changed { get; internal set; }
    private static EvaluationOptions();
    [CompilerGeneratedAttribute]
public static EvaluationOptions get_Default();
    [CompilerGeneratedAttribute]
public SpecVersion get_EvaluateAs();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EvaluateAs(SpecVersion value);
    [CompilerGeneratedAttribute]
public bool get_ValidateAgainstMetaSchema();
    [CompilerGeneratedAttribute]
public void set_ValidateAgainstMetaSchema(bool value);
    [CompilerGeneratedAttribute]
public OutputFormat get_OutputFormat();
    [CompilerGeneratedAttribute]
public void set_OutputFormat(OutputFormat value);
    [CompilerGeneratedAttribute]
public SchemaRegistry get_SchemaRegistry();
    public bool get_RequireFormatValidation();
    public void set_RequireFormatValidation(bool value);
    public bool get_OnlyKnownFormats();
    public void set_OnlyKnownFormats(bool value);
    public bool get_ProcessCustomKeywords();
    public void set_ProcessCustomKeywords(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreserveDroppedAnnotations();
    [CompilerGeneratedAttribute]
public void set_PreserveDroppedAnnotations(bool value);
    [CompilerGeneratedAttribute]
public bool get_AddAnnotationForUnknownKeywords();
    [CompilerGeneratedAttribute]
public void set_AddAnnotationForUnknownKeywords(bool value);
    public IEnumerable`1<Type> get_IgnoredAnnotations();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    [CompilerGeneratedAttribute]
public bool get_AllowReferencesIntoUnknownKeywords();
    [CompilerGeneratedAttribute]
public void set_AllowReferencesIntoUnknownKeywords(bool value);
    [CompilerGeneratedAttribute]
internal bool get_Changed();
    [CompilerGeneratedAttribute]
internal void set_Changed(bool value);
    public static EvaluationOptions From(EvaluationOptions other);
    [NullableContextAttribute("0")]
public void IgnoreAnnotationsFrom();
    public void IgnoreAllAnnotations();
    public void ClearIgnoredAnnotations();
    [NullableContextAttribute("2")]
public void CollectAnnotationsFrom();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[JsonConverterAttribute("Json.Schema.EvaluationResultsJsonConverter")]
public class Json.Schema.EvaluationResults : object {
    private Uri _currentUri;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<string> _backgroundAnnotations;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<string> _ignoredAnnotations;
    [NullableAttribute("2")]
private JsonPointer _reference;
    [NullableAttribute("2")]
private Uri _schemaLocation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<EvaluationResults> _details;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, JsonNode> _annotations;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, string> _errors;
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPointer <EvaluationPath>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPointer <InstanceLocation>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EvaluationResults <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private OutputFormat <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeDroppedAnnotations>k__BackingField;
    public bool IsValid { get; private set; }
    public JsonPointer EvaluationPath { get; }
    public JsonPointer InstanceLocation { get; }
    public Uri SchemaLocation { get; }
    public IReadOnlyList`1<EvaluationResults> Details { get; }
    public bool HasDetails { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, JsonNode> Annotations { get; }
    public bool HasAnnotations { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyDictionary`2<string, string> Errors { get; }
    public bool HasErrors { get; }
    [NullableAttribute("2")]
public EvaluationResults Parent { get; private set; }
    internal bool Exclude { get; private set; }
    internal OutputFormat Format { get; private set; }
    internal bool IncludeDroppedAnnotations { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IReadOnlyDictionary`2<string, JsonNode> AnnotationsToSerialize { get; }
    internal EvaluationResults(JsonPointer evaluationPath, Uri schemaLocation, JsonPointer instanceLocation, EvaluationOptions options);
    private EvaluationResults(EvaluationResults other);
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
private void set_IsValid(bool value);
    [CompilerGeneratedAttribute]
public JsonPointer get_EvaluationPath();
    [CompilerGeneratedAttribute]
public JsonPointer get_InstanceLocation();
    public Uri get_SchemaLocation();
    public IReadOnlyList`1<EvaluationResults> get_Details();
    public bool get_HasDetails();
    public IReadOnlyDictionary`2<string, JsonNode> get_Annotations();
    public bool get_HasAnnotations();
    public IReadOnlyDictionary`2<string, string> get_Errors();
    public bool get_HasErrors();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public EvaluationResults get_Parent();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Parent(EvaluationResults value);
    [CompilerGeneratedAttribute]
internal bool get_Exclude();
    [CompilerGeneratedAttribute]
private void set_Exclude(bool value);
    [CompilerGeneratedAttribute]
internal OutputFormat get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(OutputFormat value);
    [CompilerGeneratedAttribute]
internal bool get_IncludeDroppedAnnotations();
    internal IReadOnlyDictionary`2<string, JsonNode> get_AnnotationsToSerialize();
    internal void SetSchemaReference(JsonPointer pointer);
    private Uri BuildSchemaLocation();
    public void ToList();
    private List`1<EvaluationResults> GetAllChildren();
    public void ToFlag();
    public void SetAnnotation(string keyword, JsonNode value);
    public bool TryGetAnnotation(string keyword, JsonNode& annotation);
    [IteratorStateMachineAttribute("Json.Schema.EvaluationResults/<GetAllAnnotations>d__58")]
public IEnumerable`1<JsonNode> GetAllAnnotations(string keyword);
    public void Fail();
    public void Fail(string keyword, string message);
    internal void AddNestedResult(EvaluationResults results);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <get_AnnotationsToSerialize>b__48_0(KeyValuePair`2<string, JsonNode> x);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.EvaluationResultsJsonConverter : WeaklyTypedJsonConverter`1<EvaluationResults> {
    public virtual EvaluationResults Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, EvaluationResults value, JsonSerializerOptions options);
}
[SchemaKeywordAttribute("examples")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/meta-data")]
[JsonConverterAttribute("Json.Schema.ExamplesKeywordJsonConverter")]
public class Json.Schema.ExamplesKeyword : object {
    [NullableAttribute("1")]
public static string Name;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<JsonNode> <Values>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<JsonNode> Values { get; }
    public ExamplesKeyword(JsonNode[] values);
    public ExamplesKeyword(IEnumerable`1<JsonNode> values);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<JsonNode> get_Values();
    [NullableContextAttribute("1")]
public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.ExamplesKeywordJsonConverter : WeaklyTypedJsonConverter`1<ExamplesKeyword> {
    public virtual ExamplesKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ExamplesKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("exclusiveMaximum")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.ExclusiveMaximumKeywordJsonConverter")]
public class Json.Schema.ExclusiveMaximumKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private decimal <Value>k__BackingField;
    public decimal Value { get; }
    public ExclusiveMaximumKeyword(decimal value);
    [CompilerGeneratedAttribute]
public decimal get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.ExclusiveMaximumKeywordJsonConverter : WeaklyTypedJsonConverter`1<ExclusiveMaximumKeyword> {
    public virtual ExclusiveMaximumKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ExclusiveMaximumKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("exclusiveMinimum")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.ExclusiveMinimumKeywordJsonConverter")]
public class Json.Schema.ExclusiveMinimumKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private decimal <Value>k__BackingField;
    public decimal Value { get; }
    public ExclusiveMinimumKeyword(decimal value);
    [CompilerGeneratedAttribute]
public decimal get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.ExclusiveMinimumKeywordJsonConverter : WeaklyTypedJsonConverter`1<ExclusiveMinimumKeyword> {
    public virtual ExclusiveMinimumKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ExclusiveMinimumKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.Format : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public string Key { get; }
    public Format(string key);
    [CompilerGeneratedAttribute]
public string get_Key();
    [NullableContextAttribute("2")]
public virtual bool Validate(JsonNode node, String& errorMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("format")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/format")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/format-annotation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/format-assertion")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/format-annotation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/format-assertion")]
[JsonConverterAttribute("Json.Schema.FormatKeywordJsonConverter")]
public class Json.Schema.FormatKeyword : object {
    public static string Name;
    private static Uri[] _formatAssertionIds;
    [CompilerGeneratedAttribute]
private Format <Value>k__BackingField;
    public Format Value { get; }
    public FormatKeyword(Format value);
    private static FormatKeyword();
    [CompilerGeneratedAttribute]
public Format get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void AssertionEvaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.FormatKeywordJsonConverter : WeaklyTypedJsonConverter`1<FormatKeyword> {
    public virtual FormatKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, FormatKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Json.Schema.Formats : object {
    private static ConcurrentDictionary`2<string, Format> _registry;
    private static String[] _timeFormats;
    public static Format Date;
    public static Format DateTime;
    public static Format Duration;
    public static Format Email;
    public static Format Hostname;
    public static Format IdnEmail;
    public static Format IdnHostname;
    public static Format Ipv4;
    public static Format Ipv6;
    public static Format Iri;
    public static Format IriReference;
    public static Format JsonPointer;
    public static Format Regex;
    public static Format RelativeJsonPointer;
    public static Format Time;
    public static Format Uri;
    public static Format UriReference;
    public static Format UriTemplate;
    public static Format Uuid;
    private static Formats();
    [GeneratedRegexAttribute("^((?:(\d{4}-\d{2}-\d{2})([Tt_]| )(\d{2}:\d{2}:\d{2}(?:\.\d+)?))([Zz]|[\+-]\d{2}:\d{2}))$", "8", "250")]
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
private static Regex DateTimeRegex();
    [GeneratedRegexAttribute("^[a-zA-Z][-.a-zA-Z0-9]{0,22}[a-zA-Z0-9]$", "8", "250")]
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
private static Regex HostnameRegex();
    public static Format Get(string key);
    public static void Register(Format format);
    public static Format CreateUnknown(string name);
    [NullableContextAttribute("2")]
private static bool CheckAbsoluteUri(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckUri(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckUriTemplate(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckJsonPointer(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckRelativeJsonPointer(JsonNode node);
    [GeneratedRegexAttribute("(@)(.+)$", "8", "250")]
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
private static Regex NormalizeDomainRegex();
    [GeneratedRegexAttribute("^(?(")(".+?(?<!\\)"@)|(([0-9a-z]((\.(?!\.))|[-!#\$%&'\*\+/=\?\^`\{\}\|~\w])*)(?<=[0-9a-z])@))(?(\[)(\[(\d{1,3}\.){3}\d{1,3}\])|(([0-9a-z][-0-9a-z]*[0-9a-z]*\.)+[a-z0-9][\-a-z0-9]{0,22}[a-z0-9]))$", "9", "250")]
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
private static Regex EmailFormatRegex();
    [NullableContextAttribute("2")]
private static bool CheckEmail(JsonNode node);
    private static string DomainMapper(Match match);
    [NullableContextAttribute("2")]
private static bool CheckUuid(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckDate(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckTime(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckDateTime(JsonNode node);
    private static bool CheckDateFormat(JsonNode node, String[] formats);
    [NullableContextAttribute("2")]
private static bool CheckHostName(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckIpv4(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckIpv6(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckHostName(JsonNode node, UriHostNameType type);
    [NullableContextAttribute("2")]
private static bool CheckDuration(JsonNode node);
    [NullableContextAttribute("2")]
private static bool CheckRegex(JsonNode node);
}
[NullableContextAttribute("1")]
public interface Json.Schema.IBaseDocument {
    public Uri BaseUri { get; }
    public abstract virtual Uri get_BaseUri();
    public abstract virtual JsonSchema FindSubschema(JsonPointer pointer, EvaluationOptions options);
}
[NullableContextAttribute("1")]
public interface Json.Schema.ICustomSchemaCollector {
    public IEnumerable`1<JsonSchema> Schemas { get; }
    public abstract virtual IEnumerable`1<JsonSchema> get_Schemas();
    public abstract virtual ValueTuple`2<JsonSchema, int> FindSubschema(JsonPointer pointer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("$id")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/core")]
[JsonConverterAttribute("Json.Schema.IdKeywordJsonConverter")]
public class Json.Schema.IdKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private Uri <Id>k__BackingField;
    public Uri Id { get; }
    public IdKeyword(Uri id);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_Id();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.IdKeywordJsonConverter : WeaklyTypedJsonConverter`1<IdKeyword> {
    public virtual IdKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, IdKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("if")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.IfKeywordJsonConverter")]
public class Json.Schema.IfKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public IfKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.IfKeywordJsonConverter : WeaklyTypedJsonConverter`1<IfKeyword> {
    public virtual IfKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, IfKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
public interface Json.Schema.IIdKeyword {
    public Uri Id { get; }
    public abstract virtual Uri get_Id();
}
[NullableContextAttribute("1")]
public interface Json.Schema.IJsonSchemaKeyword {
    public abstract virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
public interface Json.Schema.IKeyedSchemaCollector {
    public IReadOnlyDictionary`2<string, JsonSchema> Schemas { get; }
    public abstract virtual IReadOnlyDictionary`2<string, JsonSchema> get_Schemas();
}
[NullableContextAttribute("1")]
public interface Json.Schema.ISchemaCollector {
    public IReadOnlyList`1<JsonSchema> Schemas { get; }
    public abstract virtual IReadOnlyList`1<JsonSchema> get_Schemas();
}
[NullableContextAttribute("1")]
public interface Json.Schema.ISchemaContainer {
    public JsonSchema Schema { get; }
    public abstract virtual JsonSchema get_Schema();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("items")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[DependsOnAnnotationsFromAttribute("Json.Schema.PrefixItemsKeyword")]
[JsonConverterAttribute("Json.Schema.ItemsKeywordJsonConverter")]
public class Json.Schema.ItemsKeyword : object {
    public static string Name;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonSchema <SingleSchema>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<JsonSchema> <ArraySchemas>k__BackingField;
    [NullableAttribute("2")]
public JsonSchema SingleSchema { get; }
    private JsonSchema Json.Schema.ISchemaContainer.Schema { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyList`1<JsonSchema> ArraySchemas { get; }
    private IReadOnlyList`1<JsonSchema> Json.Schema.ISchemaCollector.Schemas { get; }
    public ItemsKeyword(JsonSchema value);
    public ItemsKeyword(JsonSchema[] values);
    public ItemsKeyword(IEnumerable`1<JsonSchema> values);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonSchema get_SingleSchema();
    private sealed virtual override JsonSchema Json.Schema.ISchemaContainer.get_Schema();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<JsonSchema> get_ArraySchemas();
    private sealed virtual override IReadOnlyList`1<JsonSchema> Json.Schema.ISchemaCollector.get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    [IteratorStateMachineAttribute("Json.Schema.ItemsKeyword/<LocateInstances>d__15")]
private static IEnumerable`1<JsonPointer> LocateInstances(KeywordEvaluation evaluation);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.ItemsKeywordJsonConverter : WeaklyTypedJsonConverter`1<ItemsKeyword> {
    public virtual ItemsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ItemsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.JsonNodeBaseDocument : object {
    private JsonNode _node;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<JsonPointer, JsonSchema> _foundSubschemas;
    [CompilerGeneratedAttribute]
private Uri <BaseUri>k__BackingField;
    public Uri BaseUri { get; }
    public JsonNodeBaseDocument(JsonNode node, Uri baseUri);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_BaseUri();
    public sealed virtual JsonSchema FindSubschema(JsonPointer pointer, EvaluationOptions options);
}
[ExtensionAttribute]
public static class Json.Schema.JsonNodeExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SchemaValueType GetSchemaValueType(JsonNode node);
    private static SchemaValueType GetSchemaValueType(JsonElement element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[JsonConverterAttribute("Json.Schema.SchemaJsonConverter")]
[DebuggerDisplayAttribute("{ToDebugString()}")]
public class Json.Schema.JsonSchema : object {
    private static string _unknownKeywordsAnnotationKey;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, IJsonSchemaKeyword> _keywords;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentStack`1<ValueTuple`2<DynamicScope, SchemaConstraint>> _constraints;
    [NullableAttribute("2")]
private EvaluationOptions _lastCalledOptions;
    private Nullable`1<bool> _isDynamic;
    public static JsonSchema Empty;
    public static JsonSchema True;
    public static JsonSchema False;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <BoolValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <BaseUri>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsResourceRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private SpecVersion <DeclaredVersion>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Vocabulary[] <Dialect>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonSchema[] _subschemas;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyCollection`1<IJsonSchemaKeyword> Keywords { get; }
    [NullableAttribute("2")]
public IJsonSchemaKeyword Item { get; }
    public Nullable`1<bool> BoolValue { get; }
    public Uri BaseUri { get; public set; }
    public bool IsResourceRoot { get; private set; }
    public SpecVersion DeclaredVersion { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Vocabulary[] Dialect { get; internal set; }
    private JsonSchema(bool value);
    internal JsonSchema(IEnumerable`1<IJsonSchemaKeyword> keywords);
    private static JsonSchema();
    public IReadOnlyCollection`1<IJsonSchemaKeyword> get_Keywords();
    public IJsonSchemaKeyword get_Item(string keyword);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_BoolValue();
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_BaseUri();
    [CompilerGeneratedAttribute]
public void set_BaseUri(Uri value);
    [CompilerGeneratedAttribute]
public bool get_IsResourceRoot();
    [CompilerGeneratedAttribute]
private void set_IsResourceRoot(bool value);
    [CompilerGeneratedAttribute]
public SpecVersion get_DeclaredVersion();
    [CompilerGeneratedAttribute]
internal void set_DeclaredVersion(SpecVersion value);
    [CompilerGeneratedAttribute]
internal Vocabulary[] get_Dialect();
    [CompilerGeneratedAttribute]
internal void set_Dialect(Vocabulary[] value);
    [RequiresUnreferencedCodeAttribute("Calls JsonSerializer.Deserialize with JsonSerializerOptions. Make sure the options object contains all relevant JsonTypeInfos before suppressing this warning.")]
[RequiresDynamicCodeAttribute("Calls JsonSerializer.Deserialize with JsonSerializerOptions. Make sure the options object contains all relevant JsonTypeInfos before suppressing this warning.")]
public static JsonSchema FromFile(string fileName, JsonSerializerOptions options);
    public static JsonSchema FromFile(string fileName);
    [RequiresUnreferencedCodeAttribute("Calls JsonSerializer.Deserialize with JsonSerializerOptions. Make sure the options object contains all relevant JsonTypeInfos before suppressing this warning.")]
[RequiresDynamicCodeAttribute("Calls JsonSerializer.Deserialize with JsonSerializerOptions. Make sure the options object contains all relevant JsonTypeInfos before suppressing this warning.")]
public static JsonSchema FromText(string jsonText, JsonSerializerOptions options);
    public static JsonSchema FromText(string jsonText);
    [RequiresUnreferencedCodeAttribute("Calls JsonSerializer.Deserialize with JsonSerializerOptions. Make sure the options object contains all relevant JsonTypeInfos before suppressing this warning.")]
[RequiresDynamicCodeAttribute("Calls JsonSerializer.Deserialize with JsonSerializerOptions. Make sure the options object contains all relevant JsonTypeInfos before suppressing this warning.")]
public static ValueTask`1<JsonSchema> FromStream(Stream source, JsonSerializerOptions options);
    public static ValueTask`1<JsonSchema> FromStream(Stream source);
    [NullableContextAttribute("2")]
internal static EvaluationResults AutoEvaluate(JsonNode root, EvaluationOptions options);
    private static Uri GenerateBaseUri();
    [NullableContextAttribute("0")]
public T GetKeyword();
    [NullableContextAttribute("0")]
public bool TryGetKeyword(T& keyword);
    public bool TryGetKeyword(string keywordName, T& keyword);
    [NullableContextAttribute("2")]
public EvaluationResults Evaluate(JsonNode root, EvaluationOptions options);
    private void ClearConstraints();
    private bool IsDynamic();
    public SchemaConstraint GetConstraint(JsonPointer relativeEvaluationPath, JsonPointer baseInstanceLocation, JsonPointer relativeInstanceLocation, EvaluationContext context);
    private SchemaConstraint BuildConstraint(JsonPointer evaluationPath, JsonPointer baseInstanceLocation, JsonPointer relativeInstanceLocation, DynamicScope scope);
    private SchemaConstraint CheckScopedConstraints(DynamicScope scope);
    private void PopulateConstraint(SchemaConstraint constraint, EvaluationContext context);
    private bool ShouldProcessKeyword(IJsonSchemaKeyword keyword, bool processCustomKeywords, SpecVersion preferredVersion, ReadOnlySpan`1<Type> declaredKeywordTypes);
    internal int CountSubschemas();
    private static int CountSubschemas(IJsonSchemaKeyword keyword);
    internal ReadOnlySpan`1<JsonSchema> GetSubschemas(IMemoryOwner`1<JsonSchema> owner);
    private static ReadOnlySpan`1<JsonSchema> GetSubschemas(IJsonSchemaKeyword keyword, IMemoryOwner`1<JsonSchema> owner);
    private sealed virtual override JsonSchema Json.Schema.IBaseDocument.FindSubschema(JsonPointer pointer, EvaluationOptions options);
    public static JsonSchema op_Implicit(bool value);
    private string ToDebugString();
    [CompilerGeneratedAttribute]
private object <Json.Schema.IBaseDocument.FindSubschema>g__ExtractSchemaFromData|57_0(JsonPointer localPointer, JsonNode data, JsonSchema hostSchema, <>c__DisplayClass57_0& );
    [CompilerGeneratedAttribute]
private object <Json.Schema.IBaseDocument.FindSubschema>g__CheckResolvable|57_1(object localResolvable, Int32& i, string pointerSegment, JsonSchema& hostSchema, <>c__DisplayClass57_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.JsonSchemaBuilder : object {
    private Dictionary`2<string, IJsonSchemaKeyword> _keywords;
    [NullableAttribute("2")]
private Uri _baseUri;
    internal void TrySetBaseUri(Uri uri);
    public void Add(IJsonSchemaKeyword keyword);
    [NullableContextAttribute("0")]
public T Get();
    public static JsonSchema RefRoot();
    public static JsonSchema RecursiveRefRoot();
    public JsonSchema Build();
    public static JsonSchema op_Implicit(JsonSchemaBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Json.Schema.JsonSchemaBuilderExtensions : object {
    [ExtensionAttribute]
public static JsonSchemaBuilder AdditionalItems(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder AdditionalProperties(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder AllOf(JsonSchemaBuilder builder, JsonSchema[] schemas);
    [ExtensionAttribute]
public static JsonSchemaBuilder AllOf(JsonSchemaBuilder builder, IEnumerable`1<JsonSchema> schemas);
    [ExtensionAttribute]
public static JsonSchemaBuilder Anchor(JsonSchemaBuilder builder, string reference);
    [ExtensionAttribute]
public static JsonSchemaBuilder AnyOf(JsonSchemaBuilder builder, JsonSchema[] schemas);
    [ExtensionAttribute]
public static JsonSchemaBuilder AnyOf(JsonSchemaBuilder builder, IEnumerable`1<JsonSchema> schemas);
    [ExtensionAttribute]
public static JsonSchemaBuilder Comment(JsonSchemaBuilder builder, string comment);
    [ExtensionAttribute]
public static JsonSchemaBuilder Const(JsonSchemaBuilder builder, JsonNode node);
    [ExtensionAttribute]
public static JsonSchemaBuilder Contains(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder Default(JsonSchemaBuilder builder, JsonNode node);
    [ExtensionAttribute]
public static JsonSchemaBuilder Definitions(JsonSchemaBuilder builder, IReadOnlyDictionary`2<string, JsonSchema> defs);
    [ExtensionAttribute]
public static JsonSchemaBuilder Definitions(JsonSchemaBuilder builder, ValueTuple`2[] defs);
    [ExtensionAttribute]
public static JsonSchemaBuilder Defs(JsonSchemaBuilder builder, IReadOnlyDictionary`2<string, JsonSchema> defs);
    [ExtensionAttribute]
public static JsonSchemaBuilder Defs(JsonSchemaBuilder builder, ValueTuple`2[] defs);
    [ExtensionAttribute]
public static JsonSchemaBuilder Dependencies(JsonSchemaBuilder builder, IReadOnlyDictionary`2<string, SchemaOrPropertyList> deps);
    [ExtensionAttribute]
public static JsonSchemaBuilder Dependencies(JsonSchemaBuilder builder, ValueTuple`2[] deps);
    [ExtensionAttribute]
public static JsonSchemaBuilder DependentRequired(JsonSchemaBuilder builder, IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> deps);
    [ExtensionAttribute]
public static JsonSchemaBuilder DependentRequired(JsonSchemaBuilder builder, ValueTuple`2[] deps);
    [ExtensionAttribute]
public static JsonSchemaBuilder DependentSchemas(JsonSchemaBuilder builder, IReadOnlyDictionary`2<string, JsonSchema> deps);
    [ExtensionAttribute]
public static JsonSchemaBuilder DependentSchemas(JsonSchemaBuilder builder, ValueTuple`2[] deps);
    [ExtensionAttribute]
public static JsonSchemaBuilder Deprecated(JsonSchemaBuilder builder, bool deprecated);
    [ExtensionAttribute]
public static JsonSchemaBuilder Description(JsonSchemaBuilder builder, string description);
    [ExtensionAttribute]
public static JsonSchemaBuilder DynamicAnchor(JsonSchemaBuilder builder, string reference);
    [ExtensionAttribute]
public static JsonSchemaBuilder DynamicRef(JsonSchemaBuilder builder, Uri reference);
    [ExtensionAttribute]
public static JsonSchemaBuilder DynamicRef(JsonSchemaBuilder builder, string reference);
    [ExtensionAttribute]
public static JsonSchemaBuilder Else(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder Enum(JsonSchemaBuilder builder, IEnumerable`1<JsonNode> elements);
    [ExtensionAttribute]
public static JsonSchemaBuilder Enum(JsonSchemaBuilder builder, JsonNode[] elements);
    [ExtensionAttribute]
public static JsonSchemaBuilder Enum(JsonSchemaBuilder builder, IEnumerable`1<string> elements);
    [ExtensionAttribute]
public static JsonSchemaBuilder Examples(JsonSchemaBuilder builder, IEnumerable`1<JsonNode> elements);
    [ExtensionAttribute]
public static JsonSchemaBuilder Examples(JsonSchemaBuilder builder, JsonNode[] elements);
    [ExtensionAttribute]
public static JsonSchemaBuilder ExclusiveMaximum(JsonSchemaBuilder builder, decimal max);
    [ExtensionAttribute]
public static JsonSchemaBuilder ExclusiveMinimum(JsonSchemaBuilder builder, decimal min);
    [ExtensionAttribute]
public static JsonSchemaBuilder Format(JsonSchemaBuilder builder, string format);
    [ExtensionAttribute]
public static JsonSchemaBuilder Format(JsonSchemaBuilder builder, Format format);
    [ExtensionAttribute]
public static JsonSchemaBuilder Id(JsonSchemaBuilder builder, Uri id);
    [ExtensionAttribute]
public static JsonSchemaBuilder Id(JsonSchemaBuilder builder, string id);
    [ExtensionAttribute]
public static JsonSchemaBuilder If(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder Items(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder Items(JsonSchemaBuilder builder, IEnumerable`1<JsonSchema> schemas);
    [ExtensionAttribute]
public static JsonSchemaBuilder MaxContains(JsonSchemaBuilder builder, UInt32 value);
    [ExtensionAttribute]
public static JsonSchemaBuilder Maximum(JsonSchemaBuilder builder, decimal value);
    [ExtensionAttribute]
public static JsonSchemaBuilder MaxItems(JsonSchemaBuilder builder, UInt32 value);
    [ExtensionAttribute]
public static JsonSchemaBuilder MaxLength(JsonSchemaBuilder builder, UInt32 value);
    [ExtensionAttribute]
public static JsonSchemaBuilder MaxProperties(JsonSchemaBuilder builder, UInt32 value);
    [ExtensionAttribute]
public static JsonSchemaBuilder MinContains(JsonSchemaBuilder builder, UInt32 value);
    [ExtensionAttribute]
public static JsonSchemaBuilder Minimum(JsonSchemaBuilder builder, decimal value);
    [ExtensionAttribute]
public static JsonSchemaBuilder MinItems(JsonSchemaBuilder builder, UInt32 value);
    [ExtensionAttribute]
public static JsonSchemaBuilder MinLength(JsonSchemaBuilder builder, UInt32 value);
    [ExtensionAttribute]
public static JsonSchemaBuilder MinProperties(JsonSchemaBuilder builder, UInt32 value);
    [ExtensionAttribute]
public static JsonSchemaBuilder MultipleOf(JsonSchemaBuilder builder, decimal value);
    [ExtensionAttribute]
public static JsonSchemaBuilder Not(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder OneOf(JsonSchemaBuilder builder, JsonSchema[] schemas);
    [ExtensionAttribute]
public static JsonSchemaBuilder OneOf(JsonSchemaBuilder builder, IEnumerable`1<JsonSchema> schemas);
    [ExtensionAttribute]
public static JsonSchemaBuilder Pattern(JsonSchemaBuilder builder, Regex pattern);
    [ExtensionAttribute]
public static JsonSchemaBuilder Pattern(JsonSchemaBuilder builder, string pattern);
    [ExtensionAttribute]
public static JsonSchemaBuilder PatternProperties(JsonSchemaBuilder builder, IReadOnlyDictionary`2<Regex, JsonSchema> props);
    [ExtensionAttribute]
public static JsonSchemaBuilder PatternProperties(JsonSchemaBuilder builder, ValueTuple`2[] props);
    [ExtensionAttribute]
public static JsonSchemaBuilder PatternProperties(JsonSchemaBuilder builder, IReadOnlyDictionary`2<string, JsonSchema> props);
    [ExtensionAttribute]
public static JsonSchemaBuilder PatternProperties(JsonSchemaBuilder builder, ValueTuple`2[] props);
    [ExtensionAttribute]
public static JsonSchemaBuilder PrefixItems(JsonSchemaBuilder builder, JsonSchema[] schemas);
    [ExtensionAttribute]
public static JsonSchemaBuilder PrefixItems(JsonSchemaBuilder builder, IEnumerable`1<JsonSchema> schemas);
    [ExtensionAttribute]
public static JsonSchemaBuilder Properties(JsonSchemaBuilder builder, IReadOnlyDictionary`2<string, JsonSchema> props);
    [ExtensionAttribute]
public static JsonSchemaBuilder Properties(JsonSchemaBuilder builder, ValueTuple`2[] props);
    [ExtensionAttribute]
public static JsonSchemaBuilder PropertyDependencies(JsonSchemaBuilder builder, IReadOnlyDictionary`2<string, PropertyDependency> dependencies);
    [ExtensionAttribute]
public static JsonSchemaBuilder PropertyDependencies(JsonSchemaBuilder builder, ValueTuple`2[] dependencies);
    [ExtensionAttribute]
public static JsonSchemaBuilder PropertyNames(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder ReadOnly(JsonSchemaBuilder builder, bool value);
    [ExtensionAttribute]
public static JsonSchemaBuilder RecursiveAnchor(JsonSchemaBuilder builder, bool value);
    [ExtensionAttribute]
public static JsonSchemaBuilder RecursiveRef(JsonSchemaBuilder builder, Uri reference);
    [ExtensionAttribute]
public static JsonSchemaBuilder RecursiveRef(JsonSchemaBuilder builder, string reference);
    [ExtensionAttribute]
public static JsonSchemaBuilder Ref(JsonSchemaBuilder builder, Uri reference);
    [ExtensionAttribute]
public static JsonSchemaBuilder Ref(JsonSchemaBuilder builder, string reference);
    [ExtensionAttribute]
public static JsonSchemaBuilder Required(JsonSchemaBuilder builder, IEnumerable`1<string> properties);
    [ExtensionAttribute]
public static JsonSchemaBuilder Required(JsonSchemaBuilder builder, String[] properties);
    [ExtensionAttribute]
public static JsonSchemaBuilder Schema(JsonSchemaBuilder builder, Uri uri);
    [ExtensionAttribute]
public static JsonSchemaBuilder Schema(JsonSchemaBuilder builder, string uri);
    [ExtensionAttribute]
public static JsonSchemaBuilder Then(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder Title(JsonSchemaBuilder builder, string title);
    [ExtensionAttribute]
public static JsonSchemaBuilder Type(JsonSchemaBuilder builder, SchemaValueType type);
    [ExtensionAttribute]
public static JsonSchemaBuilder Type(JsonSchemaBuilder builder, SchemaValueType[] types);
    [ExtensionAttribute]
public static JsonSchemaBuilder Type(JsonSchemaBuilder builder, IEnumerable`1<SchemaValueType> types);
    [ExtensionAttribute]
public static JsonSchemaBuilder UnevaluatedItems(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder UnevaluatedProperties(JsonSchemaBuilder builder, JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchemaBuilder UniqueItems(JsonSchemaBuilder builder, bool value);
    [ExtensionAttribute]
public static JsonSchemaBuilder Unrecognized(JsonSchemaBuilder builder, string name, JsonNode value);
    [ExtensionAttribute]
public static JsonSchemaBuilder Vocabulary(JsonSchemaBuilder builder, ValueTuple`2[] vocabs);
    [ExtensionAttribute]
public static JsonSchemaBuilder Vocabulary(JsonSchemaBuilder builder, ValueTuple`2[] vocabs);
    [ExtensionAttribute]
public static JsonSchemaBuilder Vocabulary(JsonSchemaBuilder builder, IReadOnlyDictionary`2<Uri, bool> vocabs);
    [ExtensionAttribute]
public static JsonSchemaBuilder Vocabulary(JsonSchemaBuilder builder, IReadOnlyDictionary`2<string, bool> vocabs);
    [ExtensionAttribute]
public static JsonSchemaBuilder WriteOnly(JsonSchemaBuilder builder, bool value);
    [ExtensionAttribute]
public static EvaluationResults Evaluate(JsonSchemaBuilder builder, JsonNode root, EvaluationOptions options);
}
public class Json.Schema.JsonSchemaException : Exception {
    [NullableContextAttribute("1")]
public JsonSchemaException(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Json.Schema.JsonSchemaExtensions : object {
    [ExtensionAttribute]
public static EvaluationResults Evaluate(JsonSchema jsonSchema, JsonDocument jsonDocument, EvaluationOptions options);
    [ExtensionAttribute]
public static EvaluationResults Evaluate(JsonSchema jsonSchema, JsonElement jsonElement, EvaluationOptions options);
    [ExtensionAttribute]
public static JsonSchema Bundle(JsonSchema jsonSchema, EvaluationOptions options);
    [ExtensionAttribute]
public static JsonSchema GetAdditionalItems(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetAdditionalProperties(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyList`1<JsonSchema> GetAllOf(JsonSchema schema);
    [ExtensionAttribute]
public static string GetAnchor(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyList`1<JsonSchema> GetAnyOf(JsonSchema schema);
    [ExtensionAttribute]
public static string GetComment(JsonSchema schema);
    [ExtensionAttribute]
public static JsonNode GetConst(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetContains(JsonSchema schema);
    [ExtensionAttribute]
public static string GetContentEncoding(JsonSchema schema);
    [ExtensionAttribute]
public static string GetContentMediaType(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetContentSchema(JsonSchema schema);
    [ExtensionAttribute]
public static JsonNode GetDefault(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, JsonSchema> GetDefinitions(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, JsonSchema> GetDefs(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, SchemaOrPropertyList> GetDependencies(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, IReadOnlyList`1<string>> GetDependentRequired(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, JsonSchema> GetDependentSchemas(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<bool> GetDeprecated(JsonSchema schema);
    [ExtensionAttribute]
public static string GetDescription(JsonSchema schema);
    [ExtensionAttribute]
public static string GetDynamicAnchor(JsonSchema schema);
    [ExtensionAttribute]
public static Uri GetDynamicRef(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetElse(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyList`1<JsonNode> GetEnum(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyList`1<JsonNode> GetExamples(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<decimal> GetExclusiveMaximum(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<decimal> GetExclusiveMinimum(JsonSchema schema);
    [ExtensionAttribute]
public static Format GetFormat(JsonSchema schema);
    [ExtensionAttribute]
public static Uri GetId(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetIf(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetItems(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyList`1<JsonSchema> GetItemsArrayForm(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<UInt32> GetMaxContains(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<decimal> GetMaximum(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<UInt32> GetMaxItems(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<UInt32> GetMaxLength(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<UInt32> GetMaxProperties(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<UInt32> GetMinContains(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<decimal> GetMinimum(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<UInt32> GetMinItems(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<UInt32> GetMinLength(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<UInt32> GetMinProperties(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<decimal> GetMultipleOf(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetNot(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyList`1<JsonSchema> GetOneOf(JsonSchema schema);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use 'GetPatternValue' instead.")]
public static Regex GetPattern(JsonSchema schema);
    [ExtensionAttribute]
public static string GetPatternValue(JsonSchema schema);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use 'GetPatternPropertiesValues' instead.")]
public static IReadOnlyDictionary`2<Regex, JsonSchema> GetPatternProperties(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, JsonSchema> GetPatternPropertiesValues(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyList`1<JsonSchema> GetPrefixItems(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, JsonSchema> GetProperties(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, PropertyDependency> GetPropertyDependencies(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetPropertyNames(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<bool> GetReadOnly(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<bool> GetRecursiveAnchor(JsonSchema schema);
    [ExtensionAttribute]
public static Uri GetRecursiveRef(JsonSchema schema);
    [ExtensionAttribute]
public static Uri GetRef(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyList`1<string> GetRequired(JsonSchema schema);
    [ExtensionAttribute]
public static Uri GetSchema(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetThen(JsonSchema schema);
    [ExtensionAttribute]
public static string GetTitle(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<SchemaValueType> GetJsonType(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetUnevaluatedItems(JsonSchema schema);
    [ExtensionAttribute]
public static JsonSchema GetUnevaluatedProperties(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<bool> GetUniqueItems(JsonSchema schema);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<Uri, bool> GetVocabulary(JsonSchema schema);
    [ExtensionAttribute]
public static Nullable`1<bool> GetWriteOnly(JsonSchema schema);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[JsonSerializableAttribute("Json.Schema.JsonSchema")]
[JsonSerializableAttribute("Json.Schema.AdditionalItemsKeyword")]
[JsonSerializableAttribute("Json.Schema.AdditionalPropertiesKeyword")]
[JsonSerializableAttribute("Json.Schema.AllOfKeyword")]
[JsonSerializableAttribute("Json.Schema.AnchorKeyword")]
[JsonSerializableAttribute("Json.Schema.AnyOfKeyword")]
[JsonSerializableAttribute("Json.Schema.CommentKeyword")]
[JsonSerializableAttribute("Json.Schema.ConstKeyword")]
[JsonSerializableAttribute("Json.Schema.ContainsKeyword")]
[JsonSerializableAttribute("Json.Schema.ContentEncodingKeyword")]
[JsonSerializableAttribute("Json.Schema.ContentMediaTypeKeyword")]
[JsonSerializableAttribute("Json.Schema.ContentSchemaKeyword")]
[JsonSerializableAttribute("Json.Schema.DefaultKeyword")]
[JsonSerializableAttribute("Json.Schema.DefinitionsKeyword")]
[JsonSerializableAttribute("Json.Schema.DefsKeyword")]
[JsonSerializableAttribute("Json.Schema.DependenciesKeyword")]
[JsonSerializableAttribute("Json.Schema.DependentRequiredKeyword")]
[JsonSerializableAttribute("Json.Schema.DependentSchemasKeyword")]
[JsonSerializableAttribute("Json.Schema.DeprecatedKeyword")]
[JsonSerializableAttribute("Json.Schema.DescriptionKeyword")]
[JsonSerializableAttribute("Json.Schema.DynamicAnchorKeyword")]
[JsonSerializableAttribute("Json.Schema.DynamicRefKeyword")]
[JsonSerializableAttribute("Json.Schema.ElseKeyword")]
[JsonSerializableAttribute("Json.Schema.EnumKeyword")]
[JsonSerializableAttribute("Json.Schema.ExamplesKeyword")]
[JsonSerializableAttribute("Json.Schema.ExclusiveMaximumKeyword")]
[JsonSerializableAttribute("Json.Schema.ExclusiveMinimumKeyword")]
[JsonSerializableAttribute("Json.Schema.FormatKeyword")]
[JsonSerializableAttribute("Json.Schema.IdKeyword")]
[JsonSerializableAttribute("Json.Schema.IfKeyword")]
[JsonSerializableAttribute("Json.Schema.ItemsKeyword")]
[JsonSerializableAttribute("Json.Schema.MaxContainsKeyword")]
[JsonSerializableAttribute("Json.Schema.MaximumKeyword")]
[JsonSerializableAttribute("Json.Schema.MaxItemsKeyword")]
[JsonSerializableAttribute("Json.Schema.MaxLengthKeyword")]
[JsonSerializableAttribute("Json.Schema.MaxPropertiesKeyword")]
[JsonSerializableAttribute("Json.Schema.MinContainsKeyword")]
[JsonSerializableAttribute("Json.Schema.MinimumKeyword")]
[JsonSerializableAttribute("Json.Schema.MinItemsKeyword")]
[JsonSerializableAttribute("Json.Schema.MinLengthKeyword")]
[JsonSerializableAttribute("Json.Schema.MinPropertiesKeyword")]
[JsonSerializableAttribute("Json.Schema.MultipleOfKeyword")]
[JsonSerializableAttribute("Json.Schema.NotKeyword")]
[JsonSerializableAttribute("Json.Schema.OneOfKeyword")]
[JsonSerializableAttribute("Json.Schema.PatternKeyword")]
[JsonSerializableAttribute("Json.Schema.PatternPropertiesKeyword")]
[JsonSerializableAttribute("Json.Schema.PrefixItemsKeyword")]
[JsonSerializableAttribute("Json.Schema.PropertiesKeyword")]
[JsonSerializableAttribute("Json.Schema.PropertyDependenciesKeyword")]
[JsonSerializableAttribute("Json.Schema.PropertyNamesKeyword")]
[JsonSerializableAttribute("Json.Schema.ReadOnlyKeyword")]
[JsonSerializableAttribute("Json.Schema.RecursiveAnchorKeyword")]
[JsonSerializableAttribute("Json.Schema.RecursiveRefKeyword")]
[JsonSerializableAttribute("Json.Schema.RefKeyword")]
[JsonSerializableAttribute("Json.Schema.RequiredKeyword")]
[JsonSerializableAttribute("Json.Schema.SchemaKeyword")]
[JsonSerializableAttribute("Json.Schema.ThenKeyword")]
[JsonSerializableAttribute("Json.Schema.TitleKeyword")]
[JsonSerializableAttribute("Json.Schema.TypeKeyword")]
[JsonSerializableAttribute("Json.Schema.UnevaluatedItemsKeyword")]
[JsonSerializableAttribute("Json.Schema.UnevaluatedPropertiesKeyword")]
[JsonSerializableAttribute("Json.Schema.UniqueItemsKeyword")]
[JsonSerializableAttribute("Json.Schema.UnrecognizedKeyword")]
[JsonSerializableAttribute("Json.Schema.VocabularyKeyword")]
[JsonSerializableAttribute("Json.Schema.WriteOnlyKeyword")]
[JsonSerializableAttribute("Json.Schema.SchemaOrPropertyList")]
[JsonSerializableAttribute("Json.Schema.PropertyDependency")]
[JsonSerializableAttribute("Json.Schema.SchemaValueType")]
[JsonSerializableAttribute("Json.Schema.EvaluationResults")]
[JsonSerializableAttribute("Json.Pointer.JsonPointer")]
[JsonSerializableAttribute("System.Text.Json.Nodes.JsonNode")]
[JsonSerializableAttribute("System.Collections.Generic.IReadOnlyCollection`1<System.Text.Json.Nodes.JsonNode>")]
[JsonSerializableAttribute("System.UInt32")]
[JsonSerializableAttribute("System.Decimal")]
[JsonSerializableAttribute("System.String")]
[JsonSerializableAttribute("System.String[]")]
[JsonSerializableAttribute("System.Collections.Generic.Dictionary`2<System.String,System.String[]>")]
[JsonSerializableAttribute("System.Boolean")]
[JsonSerializableAttribute("System.Int32[]")]
[JsonSerializableAttribute("System.Uri")]
[GeneratedCodeAttribute("System.Text.Json.SourceGeneration", "8.0.10.36612")]
internal class Json.Schema.JsonSchemaSerializerContext : JsonSerializerContext {
    [NullableAttribute("2")]
private JsonTypeInfo`1<bool> _Boolean;
    [NullableAttribute("2")]
private JsonTypeInfo`1<decimal> _Decimal;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<JsonPointer> _JsonPointer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<AdditionalItemsKeyword> _AdditionalItemsKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<AdditionalPropertiesKeyword> _AdditionalPropertiesKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<AllOfKeyword> _AllOfKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<AnchorKeyword> _AnchorKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<AnyOfKeyword> _AnyOfKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<CommentKeyword> _CommentKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<ConstKeyword> _ConstKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<ContainsKeyword> _ContainsKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<ContentEncodingKeyword> _ContentEncodingKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<ContentMediaTypeKeyword> _ContentMediaTypeKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<ContentSchemaKeyword> _ContentSchemaKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<DefaultKeyword> _DefaultKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<DefinitionsKeyword> _DefinitionsKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<DefsKeyword> _DefsKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<DependenciesKeyword> _DependenciesKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<DependentRequiredKeyword> _DependentRequiredKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<DependentSchemasKeyword> _DependentSchemasKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<DeprecatedKeyword> _DeprecatedKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<DescriptionKeyword> _DescriptionKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<DynamicAnchorKeyword> _DynamicAnchorKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<DynamicRefKeyword> _DynamicRefKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<ElseKeyword> _ElseKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<EnumKeyword> _EnumKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<EvaluationResults> _EvaluationResults;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<ExamplesKeyword> _ExamplesKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<ExclusiveMaximumKeyword> _ExclusiveMaximumKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<ExclusiveMinimumKeyword> _ExclusiveMinimumKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<FormatKeyword> _FormatKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<IdKeyword> _IdKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<IfKeyword> _IfKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<ItemsKeyword> _ItemsKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<JsonSchema> _JsonSchema;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<MaxContainsKeyword> _MaxContainsKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<MaximumKeyword> _MaximumKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<MaxItemsKeyword> _MaxItemsKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<MaxLengthKeyword> _MaxLengthKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<MaxPropertiesKeyword> _MaxPropertiesKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<MinContainsKeyword> _MinContainsKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<MinimumKeyword> _MinimumKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<MinItemsKeyword> _MinItemsKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<MinLengthKeyword> _MinLengthKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<MinPropertiesKeyword> _MinPropertiesKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<MultipleOfKeyword> _MultipleOfKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<NotKeyword> _NotKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<OneOfKeyword> _OneOfKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<PatternKeyword> _PatternKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<PatternPropertiesKeyword> _PatternPropertiesKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<PrefixItemsKeyword> _PrefixItemsKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<PropertiesKeyword> _PropertiesKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<PropertyDependenciesKeyword> _PropertyDependenciesKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<PropertyDependency> _PropertyDependency;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<PropertyNamesKeyword> _PropertyNamesKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<ReadOnlyKeyword> _ReadOnlyKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<RecursiveAnchorKeyword> _RecursiveAnchorKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<RecursiveRefKeyword> _RecursiveRefKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<RefKeyword> _RefKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<RequiredKeyword> _RequiredKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<SchemaKeyword> _SchemaKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<SchemaOrPropertyList> _SchemaOrPropertyList;
    [NullableAttribute("2")]
private JsonTypeInfo`1<SchemaValueType> _SchemaValueType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<ThenKeyword> _ThenKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<TitleKeyword> _TitleKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<TypeKeyword> _TypeKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<UnevaluatedItemsKeyword> _UnevaluatedItemsKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<UnevaluatedPropertiesKeyword> _UnevaluatedPropertiesKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<UniqueItemsKeyword> _UniqueItemsKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<UnrecognizedKeyword> _UnrecognizedKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<VocabularyKeyword> _VocabularyKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<WriteOnlyKeyword> _WriteOnlyKeyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<Dictionary`2<string, String[]>> _DictionaryStringStringArray;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<IReadOnlyCollection`1<JsonNode>> _IReadOnlyCollectionJsonNode;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<JsonNode> _JsonNode;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<Uri> _Uri;
    [NullableAttribute("2")]
private JsonTypeInfo`1<int> _Int32;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<Int32[]> _Int32Array;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<string> _String;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<String[]> _StringArray;
    [NullableAttribute("2")]
private JsonTypeInfo`1<UInt32> _UInt32;
    private static JsonSerializerOptions s_defaultOptions;
    [CompilerGeneratedAttribute]
private static JsonSchemaSerializerContext <Default>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonSerializerOptions <GeneratedSerializerOptions>k__BackingField;
    public JsonTypeInfo`1<bool> Boolean { get; }
    public JsonTypeInfo`1<decimal> Decimal { get; }
    public JsonTypeInfo`1<JsonPointer> JsonPointer { get; }
    public JsonTypeInfo`1<AdditionalItemsKeyword> AdditionalItemsKeyword { get; }
    public JsonTypeInfo`1<AdditionalPropertiesKeyword> AdditionalPropertiesKeyword { get; }
    public JsonTypeInfo`1<AllOfKeyword> AllOfKeyword { get; }
    public JsonTypeInfo`1<AnchorKeyword> AnchorKeyword { get; }
    public JsonTypeInfo`1<AnyOfKeyword> AnyOfKeyword { get; }
    public JsonTypeInfo`1<CommentKeyword> CommentKeyword { get; }
    public JsonTypeInfo`1<ConstKeyword> ConstKeyword { get; }
    public JsonTypeInfo`1<ContainsKeyword> ContainsKeyword { get; }
    public JsonTypeInfo`1<ContentEncodingKeyword> ContentEncodingKeyword { get; }
    public JsonTypeInfo`1<ContentMediaTypeKeyword> ContentMediaTypeKeyword { get; }
    public JsonTypeInfo`1<ContentSchemaKeyword> ContentSchemaKeyword { get; }
    public JsonTypeInfo`1<DefaultKeyword> DefaultKeyword { get; }
    public JsonTypeInfo`1<DefinitionsKeyword> DefinitionsKeyword { get; }
    public JsonTypeInfo`1<DefsKeyword> DefsKeyword { get; }
    public JsonTypeInfo`1<DependenciesKeyword> DependenciesKeyword { get; }
    public JsonTypeInfo`1<DependentRequiredKeyword> DependentRequiredKeyword { get; }
    public JsonTypeInfo`1<DependentSchemasKeyword> DependentSchemasKeyword { get; }
    public JsonTypeInfo`1<DeprecatedKeyword> DeprecatedKeyword { get; }
    public JsonTypeInfo`1<DescriptionKeyword> DescriptionKeyword { get; }
    public JsonTypeInfo`1<DynamicAnchorKeyword> DynamicAnchorKeyword { get; }
    public JsonTypeInfo`1<DynamicRefKeyword> DynamicRefKeyword { get; }
    public JsonTypeInfo`1<ElseKeyword> ElseKeyword { get; }
    public JsonTypeInfo`1<EnumKeyword> EnumKeyword { get; }
    public JsonTypeInfo`1<EvaluationResults> EvaluationResults { get; }
    public JsonTypeInfo`1<ExamplesKeyword> ExamplesKeyword { get; }
    public JsonTypeInfo`1<ExclusiveMaximumKeyword> ExclusiveMaximumKeyword { get; }
    public JsonTypeInfo`1<ExclusiveMinimumKeyword> ExclusiveMinimumKeyword { get; }
    public JsonTypeInfo`1<FormatKeyword> FormatKeyword { get; }
    public JsonTypeInfo`1<IdKeyword> IdKeyword { get; }
    public JsonTypeInfo`1<IfKeyword> IfKeyword { get; }
    public JsonTypeInfo`1<ItemsKeyword> ItemsKeyword { get; }
    public JsonTypeInfo`1<JsonSchema> JsonSchema { get; }
    public JsonTypeInfo`1<MaxContainsKeyword> MaxContainsKeyword { get; }
    public JsonTypeInfo`1<MaximumKeyword> MaximumKeyword { get; }
    public JsonTypeInfo`1<MaxItemsKeyword> MaxItemsKeyword { get; }
    public JsonTypeInfo`1<MaxLengthKeyword> MaxLengthKeyword { get; }
    public JsonTypeInfo`1<MaxPropertiesKeyword> MaxPropertiesKeyword { get; }
    public JsonTypeInfo`1<MinContainsKeyword> MinContainsKeyword { get; }
    public JsonTypeInfo`1<MinimumKeyword> MinimumKeyword { get; }
    public JsonTypeInfo`1<MinItemsKeyword> MinItemsKeyword { get; }
    public JsonTypeInfo`1<MinLengthKeyword> MinLengthKeyword { get; }
    public JsonTypeInfo`1<MinPropertiesKeyword> MinPropertiesKeyword { get; }
    public JsonTypeInfo`1<MultipleOfKeyword> MultipleOfKeyword { get; }
    public JsonTypeInfo`1<NotKeyword> NotKeyword { get; }
    public JsonTypeInfo`1<OneOfKeyword> OneOfKeyword { get; }
    public JsonTypeInfo`1<PatternKeyword> PatternKeyword { get; }
    public JsonTypeInfo`1<PatternPropertiesKeyword> PatternPropertiesKeyword { get; }
    public JsonTypeInfo`1<PrefixItemsKeyword> PrefixItemsKeyword { get; }
    public JsonTypeInfo`1<PropertiesKeyword> PropertiesKeyword { get; }
    public JsonTypeInfo`1<PropertyDependenciesKeyword> PropertyDependenciesKeyword { get; }
    public JsonTypeInfo`1<PropertyDependency> PropertyDependency { get; }
    public JsonTypeInfo`1<PropertyNamesKeyword> PropertyNamesKeyword { get; }
    public JsonTypeInfo`1<ReadOnlyKeyword> ReadOnlyKeyword { get; }
    public JsonTypeInfo`1<RecursiveAnchorKeyword> RecursiveAnchorKeyword { get; }
    public JsonTypeInfo`1<RecursiveRefKeyword> RecursiveRefKeyword { get; }
    public JsonTypeInfo`1<RefKeyword> RefKeyword { get; }
    public JsonTypeInfo`1<RequiredKeyword> RequiredKeyword { get; }
    public JsonTypeInfo`1<SchemaKeyword> SchemaKeyword { get; }
    public JsonTypeInfo`1<SchemaOrPropertyList> SchemaOrPropertyList { get; }
    public JsonTypeInfo`1<SchemaValueType> SchemaValueType { get; }
    public JsonTypeInfo`1<ThenKeyword> ThenKeyword { get; }
    public JsonTypeInfo`1<TitleKeyword> TitleKeyword { get; }
    public JsonTypeInfo`1<TypeKeyword> TypeKeyword { get; }
    public JsonTypeInfo`1<UnevaluatedItemsKeyword> UnevaluatedItemsKeyword { get; }
    public JsonTypeInfo`1<UnevaluatedPropertiesKeyword> UnevaluatedPropertiesKeyword { get; }
    public JsonTypeInfo`1<UniqueItemsKeyword> UniqueItemsKeyword { get; }
    public JsonTypeInfo`1<UnrecognizedKeyword> UnrecognizedKeyword { get; }
    public JsonTypeInfo`1<VocabularyKeyword> VocabularyKeyword { get; }
    public JsonTypeInfo`1<WriteOnlyKeyword> WriteOnlyKeyword { get; }
    public JsonTypeInfo`1<Dictionary`2<string, String[]>> DictionaryStringStringArray { get; }
    public JsonTypeInfo`1<IReadOnlyCollection`1<JsonNode>> IReadOnlyCollectionJsonNode { get; }
    public JsonTypeInfo`1<JsonNode> JsonNode { get; }
    public JsonTypeInfo`1<Uri> Uri { get; }
    public JsonTypeInfo`1<int> Int32 { get; }
    public JsonTypeInfo`1<Int32[]> Int32Array { get; }
    public JsonTypeInfo`1<string> String { get; }
    public JsonTypeInfo`1<String[]> StringArray { get; }
    public JsonTypeInfo`1<UInt32> UInt32 { get; }
    public static JsonSchemaSerializerContext Default { get; }
    [NullableAttribute("2")]
protected JsonSerializerOptions GeneratedSerializerOptions { get; }
    public JsonSchemaSerializerContext(JsonSerializerOptions options);
    private static JsonSchemaSerializerContext();
    public JsonTypeInfo`1<bool> get_Boolean();
    private JsonTypeInfo`1<bool> Create_Boolean(JsonSerializerOptions options);
    public JsonTypeInfo`1<decimal> get_Decimal();
    private JsonTypeInfo`1<decimal> Create_Decimal(JsonSerializerOptions options);
    public JsonTypeInfo`1<JsonPointer> get_JsonPointer();
    private JsonTypeInfo`1<JsonPointer> Create_JsonPointer(JsonSerializerOptions options);
    public JsonTypeInfo`1<AdditionalItemsKeyword> get_AdditionalItemsKeyword();
    private JsonTypeInfo`1<AdditionalItemsKeyword> Create_AdditionalItemsKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<AdditionalPropertiesKeyword> get_AdditionalPropertiesKeyword();
    private JsonTypeInfo`1<AdditionalPropertiesKeyword> Create_AdditionalPropertiesKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<AllOfKeyword> get_AllOfKeyword();
    private JsonTypeInfo`1<AllOfKeyword> Create_AllOfKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<AnchorKeyword> get_AnchorKeyword();
    private JsonTypeInfo`1<AnchorKeyword> Create_AnchorKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<AnyOfKeyword> get_AnyOfKeyword();
    private JsonTypeInfo`1<AnyOfKeyword> Create_AnyOfKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<CommentKeyword> get_CommentKeyword();
    private JsonTypeInfo`1<CommentKeyword> Create_CommentKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<ConstKeyword> get_ConstKeyword();
    private JsonTypeInfo`1<ConstKeyword> Create_ConstKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<ContainsKeyword> get_ContainsKeyword();
    private JsonTypeInfo`1<ContainsKeyword> Create_ContainsKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<ContentEncodingKeyword> get_ContentEncodingKeyword();
    private JsonTypeInfo`1<ContentEncodingKeyword> Create_ContentEncodingKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<ContentMediaTypeKeyword> get_ContentMediaTypeKeyword();
    private JsonTypeInfo`1<ContentMediaTypeKeyword> Create_ContentMediaTypeKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<ContentSchemaKeyword> get_ContentSchemaKeyword();
    private JsonTypeInfo`1<ContentSchemaKeyword> Create_ContentSchemaKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<DefaultKeyword> get_DefaultKeyword();
    private JsonTypeInfo`1<DefaultKeyword> Create_DefaultKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<DefinitionsKeyword> get_DefinitionsKeyword();
    private JsonTypeInfo`1<DefinitionsKeyword> Create_DefinitionsKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<DefsKeyword> get_DefsKeyword();
    private JsonTypeInfo`1<DefsKeyword> Create_DefsKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<DependenciesKeyword> get_DependenciesKeyword();
    private JsonTypeInfo`1<DependenciesKeyword> Create_DependenciesKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<DependentRequiredKeyword> get_DependentRequiredKeyword();
    private JsonTypeInfo`1<DependentRequiredKeyword> Create_DependentRequiredKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<DependentSchemasKeyword> get_DependentSchemasKeyword();
    private JsonTypeInfo`1<DependentSchemasKeyword> Create_DependentSchemasKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<DeprecatedKeyword> get_DeprecatedKeyword();
    private JsonTypeInfo`1<DeprecatedKeyword> Create_DeprecatedKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<DescriptionKeyword> get_DescriptionKeyword();
    private JsonTypeInfo`1<DescriptionKeyword> Create_DescriptionKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<DynamicAnchorKeyword> get_DynamicAnchorKeyword();
    private JsonTypeInfo`1<DynamicAnchorKeyword> Create_DynamicAnchorKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<DynamicRefKeyword> get_DynamicRefKeyword();
    private JsonTypeInfo`1<DynamicRefKeyword> Create_DynamicRefKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<ElseKeyword> get_ElseKeyword();
    private JsonTypeInfo`1<ElseKeyword> Create_ElseKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<EnumKeyword> get_EnumKeyword();
    private JsonTypeInfo`1<EnumKeyword> Create_EnumKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<EvaluationResults> get_EvaluationResults();
    private JsonTypeInfo`1<EvaluationResults> Create_EvaluationResults(JsonSerializerOptions options);
    public JsonTypeInfo`1<ExamplesKeyword> get_ExamplesKeyword();
    private JsonTypeInfo`1<ExamplesKeyword> Create_ExamplesKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<ExclusiveMaximumKeyword> get_ExclusiveMaximumKeyword();
    private JsonTypeInfo`1<ExclusiveMaximumKeyword> Create_ExclusiveMaximumKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<ExclusiveMinimumKeyword> get_ExclusiveMinimumKeyword();
    private JsonTypeInfo`1<ExclusiveMinimumKeyword> Create_ExclusiveMinimumKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<FormatKeyword> get_FormatKeyword();
    private JsonTypeInfo`1<FormatKeyword> Create_FormatKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<IdKeyword> get_IdKeyword();
    private JsonTypeInfo`1<IdKeyword> Create_IdKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<IfKeyword> get_IfKeyword();
    private JsonTypeInfo`1<IfKeyword> Create_IfKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<ItemsKeyword> get_ItemsKeyword();
    private JsonTypeInfo`1<ItemsKeyword> Create_ItemsKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<JsonSchema> get_JsonSchema();
    private JsonTypeInfo`1<JsonSchema> Create_JsonSchema(JsonSerializerOptions options);
    public JsonTypeInfo`1<MaxContainsKeyword> get_MaxContainsKeyword();
    private JsonTypeInfo`1<MaxContainsKeyword> Create_MaxContainsKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<MaximumKeyword> get_MaximumKeyword();
    private JsonTypeInfo`1<MaximumKeyword> Create_MaximumKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<MaxItemsKeyword> get_MaxItemsKeyword();
    private JsonTypeInfo`1<MaxItemsKeyword> Create_MaxItemsKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<MaxLengthKeyword> get_MaxLengthKeyword();
    private JsonTypeInfo`1<MaxLengthKeyword> Create_MaxLengthKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<MaxPropertiesKeyword> get_MaxPropertiesKeyword();
    private JsonTypeInfo`1<MaxPropertiesKeyword> Create_MaxPropertiesKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<MinContainsKeyword> get_MinContainsKeyword();
    private JsonTypeInfo`1<MinContainsKeyword> Create_MinContainsKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<MinimumKeyword> get_MinimumKeyword();
    private JsonTypeInfo`1<MinimumKeyword> Create_MinimumKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<MinItemsKeyword> get_MinItemsKeyword();
    private JsonTypeInfo`1<MinItemsKeyword> Create_MinItemsKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<MinLengthKeyword> get_MinLengthKeyword();
    private JsonTypeInfo`1<MinLengthKeyword> Create_MinLengthKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<MinPropertiesKeyword> get_MinPropertiesKeyword();
    private JsonTypeInfo`1<MinPropertiesKeyword> Create_MinPropertiesKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<MultipleOfKeyword> get_MultipleOfKeyword();
    private JsonTypeInfo`1<MultipleOfKeyword> Create_MultipleOfKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<NotKeyword> get_NotKeyword();
    private JsonTypeInfo`1<NotKeyword> Create_NotKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<OneOfKeyword> get_OneOfKeyword();
    private JsonTypeInfo`1<OneOfKeyword> Create_OneOfKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<PatternKeyword> get_PatternKeyword();
    private JsonTypeInfo`1<PatternKeyword> Create_PatternKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<PatternPropertiesKeyword> get_PatternPropertiesKeyword();
    private JsonTypeInfo`1<PatternPropertiesKeyword> Create_PatternPropertiesKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<PrefixItemsKeyword> get_PrefixItemsKeyword();
    private JsonTypeInfo`1<PrefixItemsKeyword> Create_PrefixItemsKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<PropertiesKeyword> get_PropertiesKeyword();
    private JsonTypeInfo`1<PropertiesKeyword> Create_PropertiesKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<PropertyDependenciesKeyword> get_PropertyDependenciesKeyword();
    private JsonTypeInfo`1<PropertyDependenciesKeyword> Create_PropertyDependenciesKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<PropertyDependency> get_PropertyDependency();
    private JsonTypeInfo`1<PropertyDependency> Create_PropertyDependency(JsonSerializerOptions options);
    public JsonTypeInfo`1<PropertyNamesKeyword> get_PropertyNamesKeyword();
    private JsonTypeInfo`1<PropertyNamesKeyword> Create_PropertyNamesKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<ReadOnlyKeyword> get_ReadOnlyKeyword();
    private JsonTypeInfo`1<ReadOnlyKeyword> Create_ReadOnlyKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<RecursiveAnchorKeyword> get_RecursiveAnchorKeyword();
    private JsonTypeInfo`1<RecursiveAnchorKeyword> Create_RecursiveAnchorKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<RecursiveRefKeyword> get_RecursiveRefKeyword();
    private JsonTypeInfo`1<RecursiveRefKeyword> Create_RecursiveRefKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<RefKeyword> get_RefKeyword();
    private JsonTypeInfo`1<RefKeyword> Create_RefKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<RequiredKeyword> get_RequiredKeyword();
    private JsonTypeInfo`1<RequiredKeyword> Create_RequiredKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<SchemaKeyword> get_SchemaKeyword();
    private JsonTypeInfo`1<SchemaKeyword> Create_SchemaKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<SchemaOrPropertyList> get_SchemaOrPropertyList();
    private JsonTypeInfo`1<SchemaOrPropertyList> Create_SchemaOrPropertyList(JsonSerializerOptions options);
    public JsonTypeInfo`1<SchemaValueType> get_SchemaValueType();
    private JsonTypeInfo`1<SchemaValueType> Create_SchemaValueType(JsonSerializerOptions options);
    public JsonTypeInfo`1<ThenKeyword> get_ThenKeyword();
    private JsonTypeInfo`1<ThenKeyword> Create_ThenKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<TitleKeyword> get_TitleKeyword();
    private JsonTypeInfo`1<TitleKeyword> Create_TitleKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<TypeKeyword> get_TypeKeyword();
    private JsonTypeInfo`1<TypeKeyword> Create_TypeKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<UnevaluatedItemsKeyword> get_UnevaluatedItemsKeyword();
    private JsonTypeInfo`1<UnevaluatedItemsKeyword> Create_UnevaluatedItemsKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<UnevaluatedPropertiesKeyword> get_UnevaluatedPropertiesKeyword();
    private JsonTypeInfo`1<UnevaluatedPropertiesKeyword> Create_UnevaluatedPropertiesKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<UniqueItemsKeyword> get_UniqueItemsKeyword();
    private JsonTypeInfo`1<UniqueItemsKeyword> Create_UniqueItemsKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<UnrecognizedKeyword> get_UnrecognizedKeyword();
    private JsonTypeInfo`1<UnrecognizedKeyword> Create_UnrecognizedKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<VocabularyKeyword> get_VocabularyKeyword();
    private JsonTypeInfo`1<VocabularyKeyword> Create_VocabularyKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<WriteOnlyKeyword> get_WriteOnlyKeyword();
    private JsonTypeInfo`1<WriteOnlyKeyword> Create_WriteOnlyKeyword(JsonSerializerOptions options);
    public JsonTypeInfo`1<Dictionary`2<string, String[]>> get_DictionaryStringStringArray();
    private JsonTypeInfo`1<Dictionary`2<string, String[]>> Create_DictionaryStringStringArray(JsonSerializerOptions options);
    private void DictionaryStringStringArraySerializeHandler(Utf8JsonWriter writer, Dictionary`2<string, String[]> value);
    public JsonTypeInfo`1<IReadOnlyCollection`1<JsonNode>> get_IReadOnlyCollectionJsonNode();
    private JsonTypeInfo`1<IReadOnlyCollection`1<JsonNode>> Create_IReadOnlyCollectionJsonNode(JsonSerializerOptions options);
    private void IReadOnlyCollectionJsonNodeSerializeHandler(Utf8JsonWriter writer, IReadOnlyCollection`1<JsonNode> value);
    public JsonTypeInfo`1<JsonNode> get_JsonNode();
    private JsonTypeInfo`1<JsonNode> Create_JsonNode(JsonSerializerOptions options);
    public JsonTypeInfo`1<Uri> get_Uri();
    private JsonTypeInfo`1<Uri> Create_Uri(JsonSerializerOptions options);
    public JsonTypeInfo`1<int> get_Int32();
    private JsonTypeInfo`1<int> Create_Int32(JsonSerializerOptions options);
    public JsonTypeInfo`1<Int32[]> get_Int32Array();
    private JsonTypeInfo`1<Int32[]> Create_Int32Array(JsonSerializerOptions options);
    private void Int32ArraySerializeHandler(Utf8JsonWriter writer, Int32[] value);
    public JsonTypeInfo`1<string> get_String();
    private JsonTypeInfo`1<string> Create_String(JsonSerializerOptions options);
    public JsonTypeInfo`1<String[]> get_StringArray();
    private JsonTypeInfo`1<String[]> Create_StringArray(JsonSerializerOptions options);
    private void StringArraySerializeHandler(Utf8JsonWriter writer, String[] value);
    public JsonTypeInfo`1<UInt32> get_UInt32();
    private JsonTypeInfo`1<UInt32> Create_UInt32(JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
public static JsonSchemaSerializerContext get_Default();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected virtual JsonSerializerOptions get_GeneratedSerializerOptions();
    private static bool TryGetTypeInfoForRuntimeCustomConverter(JsonSerializerOptions options, JsonTypeInfo`1& jsonTypeInfo);
    private static JsonConverter GetRuntimeConverterForType(Type type, JsonSerializerOptions options);
    private static JsonConverter ExpandConverter(Type type, JsonConverter converter, JsonSerializerOptions options, bool validateCanConvert);
    public virtual JsonTypeInfo GetTypeInfo(Type type);
    private sealed virtual override JsonTypeInfo global::System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver.GetTypeInfo(Type type, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Json.Schema.JsonSerializerOptionsExtensions : object {
    [ExtensionAttribute]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026:Members annotated with 'RequiresUnreferencedCodeAttribute' require dynamic access otherwise can break functionality when trimming application code")]
[UnconditionalSuppressMessageAttribute("AOT", "IL3050:Members annotated with 'RequiresUnreferencedCodeAttribute' require dynamic access otherwise can break functionality when trimming application code")]
internal static object Read(JsonSerializerOptions options, Utf8JsonReader& reader, Type arbitraryType, JsonTypeInfo typeInfo);
    [ExtensionAttribute]
[UnconditionalSuppressMessageAttribute("Trimming", "IL2026:Members annotated with 'RequiresUnreferencedCodeAttribute' require dynamic access otherwise can break functionality when trimming application code")]
[UnconditionalSuppressMessageAttribute("AOT", "IL3050:Members annotated with 'RequiresUnreferencedCodeAttribute' require dynamic access otherwise can break functionality when trimming application code")]
internal static void Write(JsonSerializerOptions options, Utf8JsonWriter writer, object value, Type arbitraryType, JsonTypeInfo typeInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.KeywordConstraint : object {
    private Guid _id;
    [CompilerGeneratedAttribute]
private static KeywordConstraint <Skip>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Keyword>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<KeywordEvaluation, EvaluationContext> <Evaluator>k__BackingField;
    [CompilerGeneratedAttribute]
private KeywordConstraint[] <SiblingDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private SchemaConstraint[] <ChildDependencies>k__BackingField;
    public static KeywordConstraint Skip { get; }
    [NullableAttribute("2")]
public string Keyword { get; }
    public Action`2<KeywordEvaluation, EvaluationContext> Evaluator { get; }
    public KeywordConstraint[] SiblingDependencies { get; public set; }
    public SchemaConstraint[] ChildDependencies { get; public set; }
    public KeywordConstraint(string keyword, Action`2<KeywordEvaluation, EvaluationContext> evaluator);
    private static KeywordConstraint();
    [CompilerGeneratedAttribute]
public static KeywordConstraint get_Skip();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Keyword();
    [CompilerGeneratedAttribute]
public Action`2<KeywordEvaluation, EvaluationContext> get_Evaluator();
    [CompilerGeneratedAttribute]
public KeywordConstraint[] get_SiblingDependencies();
    [CompilerGeneratedAttribute]
public void set_SiblingDependencies(KeywordConstraint[] value);
    [CompilerGeneratedAttribute]
public SchemaConstraint[] get_ChildDependencies();
    [CompilerGeneratedAttribute]
public void set_ChildDependencies(SchemaConstraint[] value);
    public static KeywordConstraint SimpleAnnotation(string keyword, JsonNode value);
    internal KeywordEvaluation BuildEvaluation(SchemaEvaluation schemaEvaluation, JsonPointer instanceLocation, JsonPointer evaluationPath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.KeywordEvaluation : object {
    private bool _evaluated;
    private bool _skipped;
    [CompilerGeneratedAttribute]
private static KeywordEvaluation <Skip>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonNode <LocalInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private EvaluationResults <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private KeywordEvaluation[] <SiblingEvaluations>k__BackingField;
    [CompilerGeneratedAttribute]
private SchemaEvaluation[] <ChildEvaluations>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private KeywordConstraint <Constraint>k__BackingField;
    internal static KeywordEvaluation Skip { get; }
    [NullableAttribute("2")]
public JsonNode LocalInstance { get; }
    public EvaluationResults Results { get; }
    public KeywordEvaluation[] SiblingEvaluations { get; internal set; }
    public SchemaEvaluation[] ChildEvaluations { get; public set; }
    internal Guid Id { get; internal set; }
    internal KeywordConstraint Constraint { get; }
    internal KeywordEvaluation(KeywordConstraint constraint, JsonNode localInstance, EvaluationResults results);
    private static KeywordEvaluation();
    [CompilerGeneratedAttribute]
internal static KeywordEvaluation get_Skip();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonNode get_LocalInstance();
    [CompilerGeneratedAttribute]
public EvaluationResults get_Results();
    [CompilerGeneratedAttribute]
public KeywordEvaluation[] get_SiblingEvaluations();
    [CompilerGeneratedAttribute]
internal void set_SiblingEvaluations(KeywordEvaluation[] value);
    [CompilerGeneratedAttribute]
public SchemaEvaluation[] get_ChildEvaluations();
    [CompilerGeneratedAttribute]
public void set_ChildEvaluations(SchemaEvaluation[] value);
    [CompilerGeneratedAttribute]
internal Guid get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(Guid value);
    [CompilerGeneratedAttribute]
internal KeywordConstraint get_Constraint();
    public void MarkAsSkipped();
    internal void Evaluate(EvaluationContext context);
}
[SchemaKeywordAttribute("maxContains")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MaxContainsKeywordJsonConverter")]
public class Json.Schema.MaxContainsKeyword : object {
    [NullableAttribute("1")]
public static string Name;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public UInt32 Value { get; }
    public MaxContainsKeyword(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
    [NullableContextAttribute("1")]
public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.MaxContainsKeywordJsonConverter : WeaklyTypedJsonConverter`1<MaxContainsKeyword> {
    public virtual MaxContainsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MaxContainsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("maximum")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MaximumKeywordJsonConverter")]
public class Json.Schema.MaximumKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private decimal <Value>k__BackingField;
    public decimal Value { get; }
    public MaximumKeyword(decimal value);
    [CompilerGeneratedAttribute]
public decimal get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.MaximumKeywordJsonConverter : WeaklyTypedJsonConverter`1<MaximumKeyword> {
    public virtual MaximumKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MaximumKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("maxItems")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MaxItemsKeywordJsonConverter")]
public class Json.Schema.MaxItemsKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public UInt32 Value { get; }
    public MaxItemsKeyword(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.MaxItemsKeywordJsonConverter : WeaklyTypedJsonConverter`1<MaxItemsKeyword> {
    public virtual MaxItemsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MaxItemsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("maxLength")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MaxLengthKeywordJsonConverter")]
public class Json.Schema.MaxLengthKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public UInt32 Value { get; }
    public MaxLengthKeyword(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.MaxLengthKeywordJsonConverter : WeaklyTypedJsonConverter`1<MaxLengthKeyword> {
    public virtual MaxLengthKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MaxLengthKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("maxProperties")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MaxPropertiesKeywordJsonConverter")]
public class Json.Schema.MaxPropertiesKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public UInt32 Value { get; }
    public MaxPropertiesKeyword(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.MaxPropertiesKeywordJsonConverter : WeaklyTypedJsonConverter`1<MaxPropertiesKeyword> {
    public virtual MaxPropertiesKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MaxPropertiesKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Json.Schema.MetaSchemas : object {
    internal static string Draft201909IdValue;
    public static Uri Draft201909Id;
    public static Uri Core201909Id;
    public static Uri Applicator201909Id;
    public static Uri Validation201909Id;
    public static Uri Metadata201909Id;
    public static Uri Format201909Id;
    public static Uri Content201909Id;
    public static JsonSchema Draft201909;
    public static JsonSchema Core201909;
    public static JsonSchema Applicator201909;
    public static JsonSchema Validation201909;
    public static JsonSchema Metadata201909;
    public static JsonSchema Format201909;
    public static JsonSchema Content201909;
    internal static string Draft202012IdValue;
    public static Uri Draft202012Id;
    public static Uri Core202012Id;
    public static Uri Unevaluated202012Id;
    public static Uri Applicator202012Id;
    public static Uri Validation202012Id;
    public static Uri Metadata202012Id;
    public static Uri FormatAnnotation202012Id;
    public static Uri FormatAssertion202012Id;
    public static Uri Content202012Id;
    public static JsonSchema Draft202012;
    public static JsonSchema Core202012;
    public static JsonSchema Unevaluated202012;
    public static JsonSchema Applicator202012;
    public static JsonSchema Validation202012;
    public static JsonSchema Metadata202012;
    public static JsonSchema FormatAnnotation202012;
    public static JsonSchema FormatAssertion202012;
    public static JsonSchema Content202012;
    internal static string Draft6IdValue;
    public static Uri Draft6Id;
    public static JsonSchema Draft6;
    internal static string Draft7IdValue;
    public static Uri Draft7Id;
    public static JsonSchema Draft7;
    internal static string DraftNextIdValue;
    public static Uri DraftNextId;
    public static Uri CoreNextId;
    public static Uri UnevaluatedNextId;
    public static Uri ApplicatorNextId;
    public static Uri ValidationNextId;
    public static Uri MetadataNextId;
    public static Uri FormatAnnotationNextId;
    public static Uri FormatAssertionNextId;
    public static Uri ContentNextId;
    public static JsonSchema DraftNext;
    public static JsonSchema CoreNext;
    public static JsonSchema UnevaluatedNext;
    public static JsonSchema ApplicatorNext;
    public static JsonSchema ValidationNext;
    public static JsonSchema MetadataNext;
    public static JsonSchema FormatAnnotationNext;
    public static JsonSchema FormatAssertionNext;
    public static JsonSchema ContentNext;
    private static MetaSchemas();
}
[SchemaKeywordAttribute("minContains")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MinContainsKeywordJsonConverter")]
public class Json.Schema.MinContainsKeyword : object {
    [NullableAttribute("1")]
public static string Name;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public UInt32 Value { get; }
    public MinContainsKeyword(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
    [NullableContextAttribute("1")]
public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.MinContainsKeywordJsonConverter : WeaklyTypedJsonConverter`1<MinContainsKeyword> {
    public virtual MinContainsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MinContainsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("minimum")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MinimumKeywordJsonConverter")]
public class Json.Schema.MinimumKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private decimal <Value>k__BackingField;
    public decimal Value { get; }
    public MinimumKeyword(decimal value);
    [CompilerGeneratedAttribute]
public decimal get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.MinimumKeywordJsonConverter : WeaklyTypedJsonConverter`1<MinimumKeyword> {
    public virtual MinimumKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MinimumKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("minItems")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MinItemsKeywordJsonConverter")]
public class Json.Schema.MinItemsKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public UInt32 Value { get; }
    public MinItemsKeyword(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.MinItemsKeywordJsonConverter : WeaklyTypedJsonConverter`1<MinItemsKeyword> {
    public virtual MinItemsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MinItemsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("minLength")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MinLengthKeywordJsonConverter")]
public class Json.Schema.MinLengthKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public UInt32 Value { get; }
    public MinLengthKeyword(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.MinLengthKeywordJsonConverter : WeaklyTypedJsonConverter`1<MinLengthKeyword> {
    public virtual MinLengthKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MinLengthKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("minProperties")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MinPropertiesKeywordJsonConverter")]
public class Json.Schema.MinPropertiesKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private UInt32 <Value>k__BackingField;
    public UInt32 Value { get; }
    public MinPropertiesKeyword(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.MinPropertiesKeywordJsonConverter : WeaklyTypedJsonConverter`1<MinPropertiesKeyword> {
    public virtual MinPropertiesKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MinPropertiesKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Json.Schema.MultiLookupConcurrentDictionary`1 : object {
    private ConcurrentDictionary`2<object, TValue> _lookup;
    private List`1<Func`2<TValue, object>> _keyFunctions;
    public TValue Item { get; public set; }
    public TValue get_Item(object key);
    public void set_Item(object key, TValue value);
    public void AddLookup(Func`2<TValue, object> lookup);
    public void Add(TValue value);
    public void Remove(TValue value);
    public bool TryGetValue(object key, TValue& value);
    public TValue GetValueOrDefault(object key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<object, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("multipleOf")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.MultipleOfKeywordJsonConverter")]
public class Json.Schema.MultipleOfKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private decimal <Value>k__BackingField;
    public decimal Value { get; }
    public MultipleOfKeyword(decimal value);
    [CompilerGeneratedAttribute]
public decimal get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.MultipleOfKeywordJsonConverter : WeaklyTypedJsonConverter`1<MultipleOfKeyword> {
    public virtual MultipleOfKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, MultipleOfKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("not")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.NotKeywordJsonConverter")]
public class Json.Schema.NotKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public NotKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.NotKeywordJsonConverter : WeaklyTypedJsonConverter`1<NotKeyword> {
    public virtual NotKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, NotKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("oneOf")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.OneOfKeywordJsonConverter")]
public class Json.Schema.OneOfKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<JsonSchema> <Schemas>k__BackingField;
    public IReadOnlyList`1<JsonSchema> Schemas { get; }
    public OneOfKeyword(JsonSchema[] values);
    public OneOfKeyword(IEnumerable`1<JsonSchema> values);
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<JsonSchema> get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.OneOfKeywordJsonConverter : WeaklyTypedJsonConverter`1<OneOfKeyword> {
    public virtual OneOfKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, OneOfKeyword value, JsonSerializerOptions options);
}
public enum Json.Schema.OutputFormat : Enum {
    public int value__;
    public static OutputFormat Flag;
    public static OutputFormat List;
    public static OutputFormat Hierarchical;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("pattern")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.PatternKeywordJsonConverter")]
public class Json.Schema.PatternKeyword : object {
    private RegexOrPattern _regexOrPattern;
    public static string Name;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <InvalidPattern>k__BackingField;
    public string Pattern { get; }
    [ObsoleteAttribute("Please use the 'Pattern' property instead.")]
public Regex Value { get; }
    [NullableAttribute("2")]
[ObsoleteAttribute("This property is not used and will be removed with the next major version.")]
public string InvalidPattern { get; }
    public PatternKeyword(Regex value);
    public PatternKeyword(string pattern);
    public string get_Pattern();
    public Regex get_Value();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_InvalidPattern();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.PatternKeywordJsonConverter : WeaklyTypedJsonConverter`1<PatternKeyword> {
    public virtual PatternKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, PatternKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("patternProperties")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.PatternPropertiesKeywordJsonConverter")]
public class Json.Schema.PatternPropertiesKeyword : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<string, ValueTuple`3<RegexOrPattern, JsonPointer, JsonSchema>> _patternsLookup;
    public static string Name;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, JsonSchema> _patternValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Regex, JsonSchema> _patterns;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <InvalidPatterns>k__BackingField;
    public IReadOnlyDictionary`2<string, JsonSchema> PatternValues { get; }
    [ObsoleteAttribute("Please use the 'PatternValues' instead.")]
public IReadOnlyDictionary`2<Regex, JsonSchema> Patterns { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ObsoleteAttribute("This property is not used and will be removed with the next major version.")]
public IReadOnlyList`1<string> InvalidPatterns { get; }
    private IReadOnlyDictionary`2<string, JsonSchema> Json.Schema.IKeyedSchemaCollector.Schemas { get; }
    public PatternPropertiesKeyword(IEnumerable`1<KeyValuePair`2<string, JsonSchema>> values);
    public PatternPropertiesKeyword(IEnumerable`1<KeyValuePair`2<Regex, JsonSchema>> values);
    internal PatternPropertiesKeyword(IEnumerable`1<ValueTuple`2<string, JsonSchema>> values);
    internal PatternPropertiesKeyword(IEnumerable`1<ValueTuple`2<Regex, JsonSchema>> values);
    public IReadOnlyDictionary`2<string, JsonSchema> get_PatternValues();
    public IReadOnlyDictionary`2<Regex, JsonSchema> get_Patterns();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_InvalidPatterns();
    private sealed virtual override IReadOnlyDictionary`2<string, JsonSchema> Json.Schema.IKeyedSchemaCollector.get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
    internal IEnumerable`1<ValueTuple`2<string, JsonSchema>> EnumeratePropertyPatterns();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.PatternPropertiesKeywordJsonConverter : WeaklyTypedJsonConverter`1<PatternPropertiesKeyword> {
    public virtual PatternPropertiesKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, PatternPropertiesKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ObsoleteAttribute("This doesn't work right, and the architecture of EvaluationResults makes it difficult to fix.  Recommendation is to use the draft-next structure via EvaluationResultsJsonConverter (which is the default).")]
public class Json.Schema.Pre202012EvaluationResultsJsonConverter : WeaklyTypedJsonConverter`1<EvaluationResults> {
    public virtual EvaluationResults Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, EvaluationResults value, JsonSerializerOptions options);
    private static void WriteError(Utf8JsonWriter writer, EvaluationResults value, string keyword, string error, JsonSerializerOptions options);
    private static void WriteAnnotation(Utf8JsonWriter writer, EvaluationResults value, Annotation annotation, JsonSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Json.Schema.PredicateFormat : Format {
    private Func`2<JsonNode, bool> _predicate;
    private PredicateWithErrorMessage _predicateWithErrorMessage;
    [NullableContextAttribute("1")]
public PredicateFormat(string key, Func`2<JsonNode, bool> predicate);
    [NullableContextAttribute("1")]
public PredicateFormat(string key, PredicateWithErrorMessage predicate);
    public virtual bool Validate(JsonNode element, String& errorMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("prefixItems")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.PrefixItemsKeywordJsonConverter")]
public class Json.Schema.PrefixItemsKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<JsonSchema> <ArraySchemas>k__BackingField;
    public IReadOnlyList`1<JsonSchema> ArraySchemas { get; }
    private IReadOnlyList`1<JsonSchema> Json.Schema.ISchemaCollector.Schemas { get; }
    public PrefixItemsKeyword(JsonSchema[] values);
    public PrefixItemsKeyword(IEnumerable`1<JsonSchema> values);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<JsonSchema> get_ArraySchemas();
    private sealed virtual override IReadOnlyList`1<JsonSchema> Json.Schema.ISchemaCollector.get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.PrefixItemsKeywordJsonConverter : WeaklyTypedJsonConverter`1<PrefixItemsKeyword> {
    public virtual PrefixItemsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, PrefixItemsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("properties")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.PropertiesKeywordJsonConverter")]
public class Json.Schema.PropertiesKeyword : object {
    private Dictionary`2<string, JsonPointer> _evaluationPointers;
    private Dictionary`2<string, JsonPointer> _instancePointers;
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, JsonSchema> <Properties>k__BackingField;
    public IReadOnlyDictionary`2<string, JsonSchema> Properties { get; }
    private IReadOnlyDictionary`2<string, JsonSchema> Json.Schema.IKeyedSchemaCollector.Schemas { get; }
    public PropertiesKeyword(IReadOnlyDictionary`2<string, JsonSchema> values);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, JsonSchema> get_Properties();
    private sealed virtual override IReadOnlyDictionary`2<string, JsonSchema> Json.Schema.IKeyedSchemaCollector.get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.PropertiesKeywordJsonConverter : WeaklyTypedJsonConverter`1<PropertiesKeyword> {
    public virtual PropertiesKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, PropertiesKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("propertyDependencies")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.PropertyDependenciesKeywordJsonConverter")]
public class Json.Schema.PropertyDependenciesKeyword : object {
    private JsonSchema[] _schemas;
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, PropertyDependency> <Dependencies>k__BackingField;
    public IReadOnlyDictionary`2<string, PropertyDependency> Dependencies { get; }
    private IEnumerable`1<JsonSchema> Json.Schema.ICustomSchemaCollector.Schemas { get; }
    public PropertyDependenciesKeyword(IReadOnlyDictionary`2<string, PropertyDependency> dependencies);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, PropertyDependency> get_Dependencies();
    private sealed virtual override IEnumerable`1<JsonSchema> Json.Schema.ICustomSchemaCollector.get_Schemas();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
    private sealed virtual override ValueTuple`2<JsonSchema, int> Json.Schema.ICustomSchemaCollector.FindSubschema(JsonPointer pointer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.PropertyDependenciesKeywordJsonConverter : WeaklyTypedJsonConverter`1<PropertyDependenciesKeyword> {
    public virtual PropertyDependenciesKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, PropertyDependenciesKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[JsonConverterAttribute("Json.Schema.PropertyDependencyJsonConverter")]
public class Json.Schema.PropertyDependency : object {
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, JsonSchema> <Schemas>k__BackingField;
    public IReadOnlyDictionary`2<string, JsonSchema> Schemas { get; }
    public PropertyDependency(IReadOnlyDictionary`2<string, JsonSchema> schemas);
    public PropertyDependency(ValueTuple`2[] schemas);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, JsonSchema> get_Schemas();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(PropertyDependency other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static PropertyDependency op_Implicit(Dictionary`2<string, JsonSchema> dependency);
    public static PropertyDependency op_Implicit(ValueTuple`2[] dependency);
    public static PropertyDependency op_Implicit(ValueTuple`2[] dependency);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.PropertyDependencyJsonConverter : WeaklyTypedJsonConverter`1<PropertyDependency> {
    public virtual PropertyDependency Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, PropertyDependency value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("propertyNames")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[JsonConverterAttribute("Json.Schema.PropertyNamesKeywordJsonConverter")]
public class Json.Schema.PropertyNamesKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public PropertyNamesKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.PropertyNamesKeywordJsonConverter : WeaklyTypedJsonConverter`1<PropertyNamesKeyword> {
    public virtual PropertyNamesKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, PropertyNamesKeyword value, JsonSerializerOptions options);
}
[SchemaKeywordAttribute("readOnly")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/meta-data")]
[JsonConverterAttribute("Json.Schema.ReadOnlyKeywordJsonConverter")]
public class Json.Schema.ReadOnlyKeyword : object {
    [NullableAttribute("1")]
public static string Name;
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; }
    public ReadOnlyKeyword(bool value);
    [CompilerGeneratedAttribute]
public bool get_Value();
    [NullableContextAttribute("1")]
public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.ReadOnlyKeywordJsonConverter : WeaklyTypedJsonConverter`1<ReadOnlyKeyword> {
    public virtual ReadOnlyKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ReadOnlyKeyword value, JsonSerializerOptions options);
}
[SchemaKeywordAttribute("$recursiveAnchor")]
[SchemaSpecVersionAttribute("4")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/core")]
[JsonConverterAttribute("Json.Schema.RecursiveAnchorKeywordJsonConverter")]
public class Json.Schema.RecursiveAnchorKeyword : object {
    [NullableAttribute("1")]
public static string Name;
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; }
    public RecursiveAnchorKeyword(bool value);
    [CompilerGeneratedAttribute]
public bool get_Value();
    [NullableContextAttribute("1")]
public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.RecursiveAnchorKeywordJsonConverter : WeaklyTypedJsonConverter`1<RecursiveAnchorKeyword> {
    public virtual RecursiveAnchorKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, RecursiveAnchorKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("$recursiveRef")]
[SchemaSpecVersionAttribute("4")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/core")]
[JsonConverterAttribute("Json.Schema.RecursiveRefKeywordJsonConverter")]
public class Json.Schema.RecursiveRefKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private Uri <Reference>k__BackingField;
    public Uri Reference { get; }
    public RecursiveRefKeyword(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_Reference();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context, JsonSchema target);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.RecursiveRefKeywordJsonConverter : WeaklyTypedJsonConverter`1<RecursiveRefKeyword> {
    public virtual RecursiveRefKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, RecursiveRefKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("$ref")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/core")]
[JsonConverterAttribute("Json.Schema.RefKeywordJsonConverter")]
public class Json.Schema.RefKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private Uri <Reference>k__BackingField;
    public Uri Reference { get; }
    public RefKeyword(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_Reference();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.RefKeywordJsonConverter : WeaklyTypedJsonConverter`1<RefKeyword> {
    public virtual RefKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, RefKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.RefResolutionException : JsonSchemaException {
    [CompilerGeneratedAttribute]
private Uri <BaseUri>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Anchor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDynamic>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonPointer <Location>k__BackingField;
    public Uri BaseUri { get; }
    [NullableAttribute("2")]
public string Anchor { get; }
    public bool IsDynamic { get; }
    [NullableAttribute("2")]
public JsonPointer Location { get; }
    public RefResolutionException(Uri baseUri, string anchor, bool isDynamic);
    public RefResolutionException(Uri baseUri, JsonPointer location);
    [CompilerGeneratedAttribute]
public Uri get_BaseUri();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Anchor();
    [CompilerGeneratedAttribute]
public bool get_IsDynamic();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonPointer get_Location();
    private static string Format(Uri baseUri, string anchor, bool isDynamic);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.RegexFormat : Format {
    private RegexOrPattern _regex;
    public RegexFormat(string key, string regex);
    public RegexFormat(string key, Regex regex);
    [NullableContextAttribute("2")]
public virtual bool Validate(JsonNode node, String& errorMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Json.Schema.RegexOrPattern : ValueType {
    private string _pattern;
    [NullableAttribute("2")]
private Regex _regex;
    public RegexOrPattern(string pattern);
    public RegexOrPattern(Regex regex);
    public bool IsMatch(string str);
    public Regex ToRegex();
    public static string op_Implicit(RegexOrPattern regexOrPattern);
    public static RegexOrPattern op_Implicit(string pattern);
    public static RegexOrPattern op_Implicit(Regex regex);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RegexOrPattern other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("required")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.RequiredKeywordJsonConverter")]
public class Json.Schema.RequiredKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Properties>k__BackingField;
    public IReadOnlyList`1<string> Properties { get; }
    public RequiredKeyword(String[] values);
    public RequiredKeyword(IEnumerable`1<string> values);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Properties();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.RequiredKeywordJsonConverter : WeaklyTypedJsonConverter`1<RequiredKeyword> {
    public virtual RequiredKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, RequiredKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.SchemaConstraint : object {
    private Guid _id;
    private JsonPointer _relativeEvaluationPath;
    [CompilerGeneratedAttribute]
private Uri <SchemaBaseUri>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPointer <BaseInstanceLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPointer <RelativeInstanceLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private KeywordConstraint[] <Constraints>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<KeywordEvaluation, IEnumerable`1<JsonPointer>> <InstanceLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchema <LocalSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPointer <BaseSchemaOffset>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SchemaConstraint <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseLocatorAsInstance>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonArray <UnknownKeywords>k__BackingField;
    public Uri SchemaBaseUri { get; }
    public JsonPointer BaseInstanceLocation { get; }
    public JsonPointer RelativeInstanceLocation { get; }
    public KeywordConstraint[] Constraints { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<KeywordEvaluation, IEnumerable`1<JsonPointer>> InstanceLocator { get; public set; }
    public JsonSchema LocalSchema { get; }
    internal JsonPointer BaseSchemaOffset { get; internal set; }
    [NullableAttribute("2")]
internal SchemaConstraint Source { get; internal set; }
    internal bool UseLocatorAsInstance { get; internal set; }
    [NullableAttribute("2")]
internal JsonArray UnknownKeywords { get; internal set; }
    internal SchemaConstraint(JsonPointer relativeEvaluationPath, JsonPointer baseInstanceLocation, JsonPointer relativeInstanceLocation, Uri schemaBaseUri, JsonSchema localSchema);
    [CompilerGeneratedAttribute]
public Uri get_SchemaBaseUri();
    [CompilerGeneratedAttribute]
public JsonPointer get_BaseInstanceLocation();
    [CompilerGeneratedAttribute]
public JsonPointer get_RelativeInstanceLocation();
    [CompilerGeneratedAttribute]
public KeywordConstraint[] get_Constraints();
    [CompilerGeneratedAttribute]
internal void set_Constraints(KeywordConstraint[] value);
    [CompilerGeneratedAttribute]
public Func`2<KeywordEvaluation, IEnumerable`1<JsonPointer>> get_InstanceLocator();
    [CompilerGeneratedAttribute]
public void set_InstanceLocator(Func`2<KeywordEvaluation, IEnumerable`1<JsonPointer>> value);
    [CompilerGeneratedAttribute]
public JsonSchema get_LocalSchema();
    [CompilerGeneratedAttribute]
internal JsonPointer get_BaseSchemaOffset();
    [CompilerGeneratedAttribute]
internal void set_BaseSchemaOffset(JsonPointer value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal SchemaConstraint get_Source();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Source(SchemaConstraint value);
    [CompilerGeneratedAttribute]
internal bool get_UseLocatorAsInstance();
    [CompilerGeneratedAttribute]
internal void set_UseLocatorAsInstance(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal JsonArray get_UnknownKeywords();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_UnknownKeywords(JsonArray value);
    public SchemaEvaluation BuildEvaluation(JsonNode localInstance, JsonPointer instanceLocation, JsonPointer evaluationPath, EvaluationOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.SchemaEvaluation : object {
    private bool _hasBeenEvaluated;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonNode <LocalInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPointer <RelativeInstanceLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private EvaluationResults <Results>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private KeywordEvaluation[] <KeywordEvaluations>k__BackingField;
    [CompilerGeneratedAttribute]
private EvaluationOptions <Options>k__BackingField;
    [NullableAttribute("2")]
public JsonNode LocalInstance { get; }
    public JsonPointer RelativeInstanceLocation { get; internal set; }
    public EvaluationResults Results { get; }
    internal Guid Id { get; internal set; }
    internal KeywordEvaluation[] KeywordEvaluations { get; }
    internal EvaluationOptions Options { get; }
    internal SchemaEvaluation(JsonNode localInstance, JsonPointer relativeInstanceLocation, EvaluationResults results, KeywordEvaluation[] evaluations, EvaluationOptions options);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonNode get_LocalInstance();
    [CompilerGeneratedAttribute]
public JsonPointer get_RelativeInstanceLocation();
    [CompilerGeneratedAttribute]
internal void set_RelativeInstanceLocation(JsonPointer value);
    [CompilerGeneratedAttribute]
public EvaluationResults get_Results();
    [CompilerGeneratedAttribute]
internal Guid get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(Guid value);
    [CompilerGeneratedAttribute]
internal KeywordEvaluation[] get_KeywordEvaluations();
    [CompilerGeneratedAttribute]
internal EvaluationOptions get_Options();
    public void Evaluate(EvaluationContext context);
    [NullableContextAttribute("2")]
internal KeywordEvaluation FindEvaluation(Guid id);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.SchemaJsonConverter : WeaklyTypedJsonConverter`1<JsonSchema> {
    public virtual JsonSchema Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, JsonSchema value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("$schema")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/core")]
[JsonConverterAttribute("Json.Schema.SchemaKeywordJsonConverter")]
public class Json.Schema.SchemaKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private Uri <Schema>k__BackingField;
    public Uri Schema { get; }
    public SchemaKeyword(Uri schema);
    [CompilerGeneratedAttribute]
public Uri get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("12")]
public class Json.Schema.SchemaKeywordAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public SchemaKeywordAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.SchemaKeywordJsonConverter : WeaklyTypedJsonConverter`1<SchemaKeyword> {
    public virtual SchemaKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, SchemaKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Json.Schema.SchemaKeywordRegistry : object {
    private static MultiLookupConcurrentDictionary`1<KeywordMetaData> _keywordData;
    internal static IEnumerable`1<Type> KeywordTypes { get; }
    private static SchemaKeywordRegistry();
    internal static IEnumerable`1<Type> get_KeywordTypes();
    private static void EvaluateDependencies();
    [NullableContextAttribute("0")]
[RequiresDynamicCodeAttribute("For AOT support, use Register<T> that takes a JsonTypeInfo. Using this method requires reflection later.")]
public static void Register();
    public static void Register(JsonSerializerContext typeContext);
    [NullableContextAttribute("0")]
public static void Unregister();
    public static Type GetImplementationType(string keyword);
    internal static JsonTypeInfo GetTypeInfo(Type keywordType);
    public static void RegisterNullValue(T nullKeyword);
    internal static IJsonSchemaKeyword GetNullValuedKeyword(Type keywordType);
    [ExtensionAttribute]
public static string Keyword(Type keywordType);
    [ExtensionAttribute]
public static string Keyword(IJsonSchemaKeyword keyword);
    [ExtensionAttribute]
public static long Priority(IJsonSchemaKeyword keyword);
    [ExtensionAttribute]
public static bool SupportsVersion(IJsonSchemaKeyword keyword, SpecVersion version);
    [ExtensionAttribute]
public static SpecVersion VersionsSupported(IJsonSchemaKeyword keyword);
    [ExtensionAttribute]
internal static bool ProducesDependentAnnotations(Type keywordType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[JsonConverterAttribute("Json.Schema.SchemaOrPropertyListJsonConverter")]
public class Json.Schema.SchemaOrPropertyList : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<string> <Requirements>k__BackingField;
    [NullableAttribute("2")]
public JsonSchema Schema { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<string> Requirements { get; }
    public SchemaOrPropertyList(JsonSchema schema);
    public SchemaOrPropertyList(IEnumerable`1<string> requirements);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonSchema get_Schema();
    [CompilerGeneratedAttribute]
public List`1<string> get_Requirements();
    public static SchemaOrPropertyList op_Implicit(JsonSchema schema);
    public static SchemaOrPropertyList op_Implicit(List`1<string> requirements);
    public static SchemaOrPropertyList op_Implicit(String[] requirements);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.SchemaOrPropertyListJsonConverter : WeaklyTypedJsonConverter`1<SchemaOrPropertyList> {
    public virtual SchemaOrPropertyList Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, SchemaOrPropertyList value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.SchemaRegistry : object {
    private static Uri _empty;
    private static Dictionary`2<Uri, SpecVersion> _versionLookup;
    private Dictionary`2<Uri, Registration> _registered;
    private EvaluationOptions _options;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<Uri, IBaseDocument> _fetch;
    public static SchemaRegistry Global { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<Uri, IBaseDocument> Fetch { get; public set; }
    internal SchemaRegistry(EvaluationOptions options);
    private static SchemaRegistry();
    public static SchemaRegistry get_Global();
    public Func`2<Uri, IBaseDocument> get_Fetch();
    public void set_Fetch(Func`2<Uri, IBaseDocument> value);
    internal void InitializeMetaSchemas();
    public void Register(IBaseDocument document);
    public void Register(Uri uri, IBaseDocument document);
    public static void RegisterNewSpecVersion(Uri metaSchemaUri, SpecVersion specVersion);
    private void RegisterSchema(Uri uri, IBaseDocument document);
    public IBaseDocument Get(Uri uri);
    internal IBaseDocument Get(Uri baseUri, string anchor, bool allowLegacy);
    internal JsonSchema Get(DynamicScope scope, Uri baseUri, string anchor, bool requireLocalAnchor);
    internal JsonSchema GetRecursive(DynamicScope scope);
    [NullableContextAttribute("2")]
private IBaseDocument Get(Uri baseUri, string anchor, bool isDynamic, bool allowLegacy);
    private static IBaseDocument GetFromRegistry(Dictionary`2<Uri, Registration> registry, Uri baseUri, string anchor, bool isDynamic, bool allowLegacy);
    private static Uri MakeAbsolute(Uri uri);
    internal void CopyFrom(SchemaRegistry other);
    public void Initialize(Uri baseUri, JsonSchema schema);
    private Dictionary`2<Uri, Registration> Scan(Uri baseUri, JsonSchema document);
    private static void DetermineSpecVersion(JsonSchema schema, SchemaRegistry registry);
    private void SetDialect(JsonSchema schema, Vocabulary[] parentDialect);
}
[AttributeUsageAttribute("12")]
public class Json.Schema.SchemaSpecVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private SpecVersion <Version>k__BackingField;
    public SpecVersion Version { get; }
    public SchemaSpecVersionAttribute(SpecVersion version);
    [CompilerGeneratedAttribute]
public SpecVersion get_Version();
}
[FlagsAttribute]
[JsonConverterAttribute("Json.More.EnumStringConverter`1<Json.Schema.SchemaValueType>")]
public enum Json.Schema.SchemaValueType : Enum {
    public int value__;
    [DescriptionAttribute("object")]
public static SchemaValueType Object;
    [DescriptionAttribute("array")]
public static SchemaValueType Array;
    [DescriptionAttribute("boolean")]
public static SchemaValueType Boolean;
    [DescriptionAttribute("string")]
public static SchemaValueType String;
    [DescriptionAttribute("number")]
public static SchemaValueType Number;
    [DescriptionAttribute("integer")]
public static SchemaValueType Integer;
    [DescriptionAttribute("null")]
public static SchemaValueType Null;
}
internal interface Json.Schema.Serialization.IValidatingJsonConverter {
    public OutputFormat OutputFormat { get; public set; }
    public bool RequireFormatValidation { get; public set; }
    public abstract virtual OutputFormat get_OutputFormat();
    public abstract virtual void set_OutputFormat(OutputFormat value);
    public abstract virtual bool get_RequireFormatValidation();
    public abstract virtual void set_RequireFormatValidation(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1036")]
public class Json.Schema.Serialization.JsonSchemaAttribute : Attribute {
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    internal JsonSchema Schema { get; }
    [RequiresUnreferencedCodeAttribute("Uses reflection")]
public JsonSchemaAttribute(Type declaringType, string memberName);
    [CompilerGeneratedAttribute]
internal JsonSchema get_Schema();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public class Json.Schema.Serialization.ValidatingJsonConverter : JsonConverterFactory {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<Type, JsonConverter> _cache;
    private static ValidatingJsonConverter _instance;
    [CompilerGeneratedAttribute]
private Nullable`1<OutputFormat> <OutputFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <RequireFormatValidation>k__BackingField;
    public Nullable`1<OutputFormat> OutputFormat { get; public set; }
    public Nullable`1<bool> RequireFormatValidation { get; public set; }
    private static ValidatingJsonConverter();
    [CompilerGeneratedAttribute]
public Nullable`1<OutputFormat> get_OutputFormat();
    [CompilerGeneratedAttribute]
public void set_OutputFormat(Nullable`1<OutputFormat> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_RequireFormatValidation();
    [CompilerGeneratedAttribute]
public void set_RequireFormatValidation(Nullable`1<bool> value);
    public static void MapType(JsonSchema schema);
    public virtual bool CanConvert(Type typeToConvert);
    public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
    private JsonConverter CreateConverter(Type typeToConvert, JsonSchema schema);
    private void SetOptions(JsonConverter converter);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Json.Schema.Serialization.ValidatingJsonConverter`1 : WeaklyTypedJsonConverter`1<T> {
    private JsonSchema _schema;
    private Func`2<JsonSerializerOptions, JsonSerializerOptions> _optionsFactory;
    [CompilerGeneratedAttribute]
private OutputFormat <OutputFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireFormatValidation>k__BackingField;
    public OutputFormat OutputFormat { get; public set; }
    public bool RequireFormatValidation { get; public set; }
    public ValidatingJsonConverter`1(JsonSchema schema, Func`2<JsonSerializerOptions, JsonSerializerOptions> optionsFactory);
    [CompilerGeneratedAttribute]
public sealed virtual OutputFormat get_OutputFormat();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OutputFormat(OutputFormat value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequireFormatValidation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RequireFormatValidation(bool value);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2026:Members annotated with 'RequiresUnreferencedCodeAttribute' require dynamic access otherwise can break functionality when trimming application code")]
[UnconditionalSuppressMessageAttribute("AOT", "IL3050:Calling members annotated with 'RequiresDynamicCodeAttribute' may break functionality when AOT compiling.")]
public virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    [UnconditionalSuppressMessageAttribute("Trimming", "IL2026:Members annotated with 'RequiresUnreferencedCodeAttribute' require dynamic access otherwise can break functionality when trimming application code")]
[UnconditionalSuppressMessageAttribute("AOT", "IL3050:Calling members annotated with 'RequiresDynamicCodeAttribute' may break functionality when AOT compiling.")]
public virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
}
[FlagsAttribute]
public enum Json.Schema.SpecVersion : Enum {
    public int value__;
    public static SpecVersion Unspecified;
    public static SpecVersion Draft6;
    public static SpecVersion Draft7;
    public static SpecVersion Draft201909;
    public static SpecVersion Draft202012;
    public static SpecVersion DraftNext;
    public static SpecVersion All;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("then")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[DependsOnAnnotationsFromAttribute("Json.Schema.IfKeyword")]
[JsonConverterAttribute("Json.Schema.ThenKeywordJsonConverter")]
public class Json.Schema.ThenKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public ThenKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private static void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.ThenKeywordJsonConverter : WeaklyTypedJsonConverter`1<ThenKeyword> {
    public virtual ThenKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ThenKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("title")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/meta-data")]
[JsonConverterAttribute("Json.Schema.TitleKeywordJsonConverter")]
public class Json.Schema.TitleKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public TitleKeyword(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.TitleKeywordJsonConverter : WeaklyTypedJsonConverter`1<TitleKeyword> {
    public virtual TitleKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, TitleKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("type")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.TypeKeywordJsonConverter")]
public class Json.Schema.TypeKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private SchemaValueType <Type>k__BackingField;
    public SchemaValueType Type { get; }
    public TypeKeyword(SchemaValueType type);
    public TypeKeyword(SchemaValueType[] types);
    public TypeKeyword(IEnumerable`1<SchemaValueType> types);
    [CompilerGeneratedAttribute]
public SchemaValueType get_Type();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context, SchemaValueType expectedType);
    [CompilerGeneratedAttribute]
private void <GetConstraint>b__7_0(KeywordEvaluation e, EvaluationContext c);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.TypeKeywordJsonConverter : WeaklyTypedJsonConverter`1<TypeKeyword> {
    public virtual TypeKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, TypeKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("unevaluatedItems")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[DependsOnAnnotationsFromAttribute("Json.Schema.PrefixItemsKeyword")]
[DependsOnAnnotationsFromAttribute("Json.Schema.ItemsKeyword")]
[DependsOnAnnotationsFromAttribute("Json.Schema.AdditionalItemsKeyword")]
[DependsOnAnnotationsFromAttribute("Json.Schema.ContainsKeyword")]
[DependsOnAnnotationsFromAttribute("Json.Schema.UnevaluatedItemsKeyword")]
[JsonConverterAttribute("Json.Schema.UnevaluatedItemsKeywordJsonConverter")]
public class Json.Schema.UnevaluatedItemsKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public UnevaluatedItemsKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
    [CompilerGeneratedAttribute]
internal static bool <Evaluator>g__CheckAnnotation|6_0(EvaluationResults results);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.UnevaluatedItemsKeywordJsonConverter : WeaklyTypedJsonConverter`1<UnevaluatedItemsKeyword> {
    public virtual UnevaluatedItemsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, UnevaluatedItemsKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("unevaluatedProperties")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/applicator")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/applicator")]
[DependsOnAnnotationsFromAttribute("Json.Schema.PropertiesKeyword")]
[DependsOnAnnotationsFromAttribute("Json.Schema.PatternPropertiesKeyword")]
[DependsOnAnnotationsFromAttribute("Json.Schema.AdditionalPropertiesKeyword")]
[DependsOnAnnotationsFromAttribute("Json.Schema.ContainsKeyword")]
[DependsOnAnnotationsFromAttribute("Json.Schema.UnevaluatedPropertiesKeyword")]
[JsonConverterAttribute("Json.Schema.UnevaluatedPropertiesKeywordJsonConverter")]
public class Json.Schema.UnevaluatedPropertiesKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public JsonSchema Schema { get; }
    public UnevaluatedPropertiesKeyword(JsonSchema value);
    [CompilerGeneratedAttribute]
public sealed virtual JsonSchema get_Schema();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <Evaluator>g__GetAnnotation|6_0(EvaluationResults results);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.UnevaluatedPropertiesKeywordJsonConverter : WeaklyTypedJsonConverter`1<UnevaluatedPropertiesKeyword> {
    public virtual UnevaluatedPropertiesKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, UnevaluatedPropertiesKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("uniqueItems")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/validation")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/validation")]
[JsonConverterAttribute("Json.Schema.UniqueItemsKeywordJsonConverter")]
public class Json.Schema.UniqueItemsKeyword : object {
    public static string Name;
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; }
    public UniqueItemsKeyword(bool value);
    [CompilerGeneratedAttribute]
public bool get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.UniqueItemsKeywordJsonConverter : WeaklyTypedJsonConverter`1<UniqueItemsKeyword> {
    public virtual UniqueItemsKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, UniqueItemsKeyword value, JsonSerializerOptions options);
}
public class Json.Schema.UnknownFormat : Format {
    [NullableContextAttribute("1")]
public UnknownFormat(string key);
    [NullableContextAttribute("2")]
public virtual bool Validate(JsonNode node, String& errorMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaSpecVersionAttribute("1")]
[SchemaSpecVersionAttribute("2")]
[SchemaSpecVersionAttribute("4")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/core")]
[SchemaSpecVersionAttribute("8")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/core")]
[SchemaSpecVersionAttribute("16")]
[JsonConverterAttribute("Json.Schema.UnrecognizedKeywordJsonConverter")]
public class Json.Schema.UnrecognizedKeyword : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonNode <Value>k__BackingField;
    public string Name { get; }
    [NullableAttribute("2")]
public JsonNode Value { get; }
    public UnrecognizedKeyword(string name, JsonNode value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonNode get_Value();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.UnrecognizedKeywordJsonConverter : WeaklyTypedJsonConverter`1<UnrecognizedKeyword> {
    public virtual UnrecognizedKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, UnrecognizedKeyword value, JsonSerializerOptions options);
}
[ExtensionAttribute]
public static class Json.Schema.UriExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Uri GetParentUri(Uri uri);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Json.Schema.Vocabularies : object {
    public static string Core201909Id;
    public static string Applicator201909Id;
    public static string Validation201909Id;
    public static string Metadata201909Id;
    public static string Format201909Id;
    public static string Content201909Id;
    public static Vocabulary Core201909;
    public static Vocabulary Applicator201909;
    public static Vocabulary Validation201909;
    public static Vocabulary Metadata201909;
    public static Vocabulary Format201909;
    public static Vocabulary Content201909;
    public static string Core202012Id;
    public static string Unevaluated202012Id;
    public static string Applicator202012Id;
    public static string Validation202012Id;
    public static string Metadata202012Id;
    public static string FormatAnnotation202012Id;
    public static string FormatAssertion202012Id;
    public static string Content202012Id;
    public static Vocabulary Core202012;
    public static Vocabulary Unevaluated202012;
    public static Vocabulary Applicator202012;
    public static Vocabulary Validation202012;
    public static Vocabulary Metadata202012;
    public static Vocabulary FormatAnnotation202012;
    public static Vocabulary FormatAssertion202012;
    public static Vocabulary Content202012;
    public static string CoreNextId;
    public static string UnevaluatedNextId;
    public static string ApplicatorNextId;
    public static string ValidationNextId;
    public static string MetadataNextId;
    public static string FormatAnnotationNextId;
    public static string FormatAssertionNextId;
    public static string ContentNextId;
    public static Vocabulary CoreNext;
    public static Vocabulary UnevaluatedNext;
    public static Vocabulary ApplicatorNext;
    public static Vocabulary ValidationNext;
    public static Vocabulary MetadataNext;
    public static Vocabulary FormatAnnotationNext;
    public static Vocabulary FormatAssertionNext;
    public static Vocabulary ContentNext;
    private static Vocabularies();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Json.Schema.Vocabulary : object {
    [CompilerGeneratedAttribute]
private Uri <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<Type> <Keywords>k__BackingField;
    public Uri Id { get; }
    public IReadOnlyCollection`1<Type> Keywords { get; }
    public Vocabulary(string id, Type[] keywords);
    public Vocabulary(string id, IEnumerable`1<Type> keywords);
    [CompilerGeneratedAttribute]
public Uri get_Id();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<Type> get_Keywords();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("12")]
public class Json.Schema.VocabularyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Uri <Id>k__BackingField;
    public Uri Id { get; }
    public VocabularyAttribute(string id);
    [CompilerGeneratedAttribute]
public Uri get_Id();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SchemaKeywordAttribute("$vocabulary")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/core")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/core")]
[JsonConverterAttribute("Json.Schema.VocabularyKeywordJsonConverter")]
public class Json.Schema.VocabularyKeyword : object {
    public static string Name;
    private Dictionary`2<Uri, bool> _allVocabularies;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<Uri, bool> <Vocabulary>k__BackingField;
    public IReadOnlyDictionary`2<Uri, bool> Vocabulary { get; }
    public VocabularyKeyword(IReadOnlyDictionary`2<Uri, bool> values);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<Uri, bool> get_Vocabulary();
    public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
    private void Evaluator(KeywordEvaluation evaluation, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.VocabularyKeywordJsonConverter : WeaklyTypedJsonConverter`1<VocabularyKeyword> {
    public virtual VocabularyKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, VocabularyKeyword value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Json.Schema.VocabularyRegistry : object {
    private static ConcurrentDictionary`2<Uri, Vocabulary> _vocabularies;
    private static VocabularyRegistry();
    public static void Register(Vocabulary vocabulary);
    public static void Unregister(Vocabulary vocabulary);
    public static bool IsKnown(Uri vocabularyId);
    public static Vocabulary Get(Uri vocabularyId);
}
[SchemaKeywordAttribute("writeOnly")]
[SchemaSpecVersionAttribute("4")]
[SchemaSpecVersionAttribute("8")]
[SchemaSpecVersionAttribute("16")]
[VocabularyAttribute("https://json-schema.org/draft/2019-09/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/2020-12/vocab/meta-data")]
[VocabularyAttribute("https://json-schema.org/draft/next/vocab/meta-data")]
[JsonConverterAttribute("Json.Schema.WriteOnlyKeywordJsonConverter")]
public class Json.Schema.WriteOnlyKeyword : object {
    [NullableAttribute("1")]
public static string Name;
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; }
    public WriteOnlyKeyword(bool value);
    [CompilerGeneratedAttribute]
public bool get_Value();
    [NullableContextAttribute("1")]
public sealed virtual KeywordConstraint GetConstraint(SchemaConstraint schemaConstraint, ReadOnlySpan`1<KeywordConstraint> localConstraints, EvaluationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Json.Schema.WriteOnlyKeywordJsonConverter : WeaklyTypedJsonConverter`1<WriteOnlyKeyword> {
    public virtual WriteOnlyKeyword Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, WriteOnlyKeyword value, JsonSerializerOptions options);
}
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
internal class System.Text.RegularExpressions.Generated.<RegexGenerator_g>FD6BFD1C503AE438894F777539DC62D98C9DA8511AD79E31596177CDE9998F5C6__DateTimeRegex_2 : Regex {
    [NullableAttribute("1")]
internal static <RegexGenerator_g>FD6BFD1C503AE438894F777539DC62D98C9DA8511AD79E31596177CDE9998F5C6__DateTimeRegex_2 Instance;
    private static <RegexGenerator_g>FD6BFD1C503AE438894F777539DC62D98C9DA8511AD79E31596177CDE9998F5C6__DateTimeRegex_2();
}
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
internal class System.Text.RegularExpressions.Generated.<RegexGenerator_g>FD6BFD1C503AE438894F777539DC62D98C9DA8511AD79E31596177CDE9998F5C6__EmailFormatRegex_5 : Regex {
    [NullableAttribute("1")]
internal static <RegexGenerator_g>FD6BFD1C503AE438894F777539DC62D98C9DA8511AD79E31596177CDE9998F5C6__EmailFormatRegex_5 Instance;
    private static <RegexGenerator_g>FD6BFD1C503AE438894F777539DC62D98C9DA8511AD79E31596177CDE9998F5C6__EmailFormatRegex_5();
}
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
internal class System.Text.RegularExpressions.Generated.<RegexGenerator_g>FD6BFD1C503AE438894F777539DC62D98C9DA8511AD79E31596177CDE9998F5C6__GetAnchorPattern201909Regex_0 : Regex {
    [NullableAttribute("1")]
internal static <RegexGenerator_g>FD6BFD1C503AE438894F777539DC62D98C9DA8511AD79E31596177CDE9998F5C6__GetAnchorPattern201909Regex_0 Instance;
    private static <RegexGenerator_g>FD6BFD1C503AE438894F777539DC62D98C9DA8511AD79E31596177CDE9998F5C6__GetAnchorPattern201909Regex_0();
}
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
internal class System.Text.RegularExpressions.Generated.<RegexGenerator_g>FD6BFD1C503AE438894F777539DC62D98C9DA8511AD79E31596177CDE9998F5C6__GetAnchorPattern202012Regex_1 : Regex {
    [NullableAttribute("1")]
internal static <RegexGenerator_g>FD6BFD1C503AE438894F777539DC62D98C9DA8511AD79E31596177CDE9998F5C6__GetAnchorPattern202012Regex_1 Instance;
    private static <RegexGenerator_g>FD6BFD1C503AE438894F777539DC62D98C9DA8511AD79E31596177CDE9998F5C6__GetAnchorPattern202012Regex_1();
}
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
internal class System.Text.RegularExpressions.Generated.<RegexGenerator_g>FD6BFD1C503AE438894F777539DC62D98C9DA8511AD79E31596177CDE9998F5C6__HostnameRegex_3 : Regex {
    [NullableAttribute("1")]
internal static <RegexGenerator_g>FD6BFD1C503AE438894F777539DC62D98C9DA8511AD79E31596177CDE9998F5C6__HostnameRegex_3 Instance;
    private static <RegexGenerator_g>FD6BFD1C503AE438894F777539DC62D98C9DA8511AD79E31596177CDE9998F5C6__HostnameRegex_3();
}
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
internal class System.Text.RegularExpressions.Generated.<RegexGenerator_g>FD6BFD1C503AE438894F777539DC62D98C9DA8511AD79E31596177CDE9998F5C6__NormalizeDomainRegex_4 : Regex {
    [NullableAttribute("1")]
internal static <RegexGenerator_g>FD6BFD1C503AE438894F777539DC62D98C9DA8511AD79E31596177CDE9998F5C6__NormalizeDomainRegex_4 Instance;
    private static <RegexGenerator_g>FD6BFD1C503AE438894F777539DC62D98C9DA8511AD79E31596177CDE9998F5C6__NormalizeDomainRegex_4();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
internal static class System.Text.RegularExpressions.Generated.<RegexGenerator_g>FD6BFD1C503AE438894F777539DC62D98C9DA8511AD79E31596177CDE9998F5C6__Utilities : object {
    internal static TimeSpan s_defaultTimeout;
    internal static bool s_hasTimeout;
    internal static SearchValues`1<char> s_asciiLettersAndDigits;
    internal static SearchValues`1<char> s_ascii_60FF03FEFFFF87FEFFFF07;
    internal static SearchValues`1<char> s_ascii_60FF07FEFFFF87FEFFFF07;
    private static <RegexGenerator_g>FD6BFD1C503AE438894F777539DC62D98C9DA8511AD79E31596177CDE9998F5C6__Utilities();
    internal static void StackPop(Int32[] stack, Int32& pos, Int32& arg0, Int32& arg1);
    internal static void StackPush(Int32[]& stack, Int32& pos, int arg0);
    internal static void StackPush(Int32[]& stack, Int32& pos, int arg0, int arg1);
    internal static void StackPush(Int32[]& stack, Int32& pos, int arg0, int arg1, int arg2);
    [CompilerGeneratedAttribute]
internal static void <StackPush>g__WithResize|3_0(Int32[]& stack, Int32& pos, int arg0);
    [CompilerGeneratedAttribute]
internal static void <StackPush>g__WithResize|4_0(Int32[]& stack, Int32& pos, int arg0, int arg1);
    [CompilerGeneratedAttribute]
internal static void <StackPush>g__WithResize|5_0(Int32[]& stack, Int32& pos, int arg0, int arg1, int arg2);
}
