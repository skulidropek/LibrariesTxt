public interface K4os.Compression.LZ4.Streams.Abstractions.ILZ4FrameReader {
    public abstract virtual bool OpenFrame();
    [NullableContextAttribute("1")]
public abstract virtual Task`1<bool> OpenFrameAsync(CancellationToken token);
    public abstract virtual Nullable`1<long> GetFrameLength();
    [NullableContextAttribute("1")]
public abstract virtual Task`1<Nullable`1<long>> GetFrameLengthAsync(CancellationToken token);
    public abstract virtual int ReadOneByte();
    [NullableContextAttribute("1")]
public abstract virtual Task`1<int> ReadOneByteAsync(CancellationToken token);
    public abstract virtual int ReadManyBytes(Span`1<byte> buffer, bool interactive);
    public abstract virtual Task`1<int> ReadManyBytesAsync(CancellationToken token, Memory`1<byte> buffer, bool interactive);
    public abstract virtual long GetBytesRead();
    public abstract virtual void CloseFrame();
}
public interface K4os.Compression.LZ4.Streams.Abstractions.ILZ4FrameWriter {
    public abstract virtual bool OpenFrame();
    [NullableContextAttribute("1")]
public abstract virtual Task`1<bool> OpenFrameAsync(CancellationToken token);
    public abstract virtual void WriteOneByte(byte value);
    [NullableContextAttribute("1")]
public abstract virtual Task WriteOneByteAsync(CancellationToken token, byte value);
    public abstract virtual void WriteManyBytes(ReadOnlySpan`1<byte> buffer);
    public abstract virtual Task WriteManyBytesAsync(CancellationToken token, ReadOnlyMemory`1<byte> buffer);
    public abstract virtual long GetBytesWritten();
    public abstract virtual void CloseFrame();
    [NullableContextAttribute("1")]
public abstract virtual Task CloseFrameAsync(CancellationToken token);
}
[NullableContextAttribute("1")]
public interface K4os.Compression.LZ4.Streams.Abstractions.IStreamReader`1 {
    public abstract virtual int Read(TStreamState& state, Byte[] buffer, int offset, int length);
    public abstract virtual Task`1<ReadResult`1<TStreamState>> ReadAsync(TStreamState state, Byte[] buffer, int offset, int length, CancellationToken token);
}
[NullableContextAttribute("1")]
public interface K4os.Compression.LZ4.Streams.Abstractions.IStreamWriter`1 {
    public bool CanFlush { get; }
    public abstract virtual bool get_CanFlush();
    public abstract virtual void Write(TStreamState& state, Byte[] buffer, int offset, int length);
    public abstract virtual Task`1<TStreamState> WriteAsync(TStreamState state, Byte[] buffer, int offset, int length, CancellationToken token);
    public abstract virtual void Flush(TStreamState& state);
    public abstract virtual Task`1<TStreamState> FlushAsync(TStreamState state, CancellationToken token);
}
public static class K4os.Compression.LZ4.Streams.Abstractions.ReadResult : object {
    [NullableContextAttribute("1")]
public static ReadResult`1<TStreamState> Create(TStreamState stream, int bytes);
}
public class K4os.Compression.LZ4.Streams.Abstractions.ReadResult`1 : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private TStreamState <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Bytes>k__BackingField;
    [NullableAttribute("1")]
public TStreamState Stream { get; public set; }
    public int Bytes { get; public set; }
    [NullableContextAttribute("1")]
public ReadResult`1(TStreamState Stream, int Bytes);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public TStreamState get_Stream();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Stream(TStreamState value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Bytes();
    [CompilerGeneratedAttribute]
public void set_Bytes(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ReadResult`1<TStreamState> left, ReadResult`1<TStreamState> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ReadResult`1<TStreamState> left, ReadResult`1<TStreamState> right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ReadResult`1<TStreamState> other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void Deconstruct(TStreamState& Stream, Int32& Bytes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class K4os.Compression.LZ4.Streams.Adapters.ByteBufferAdapter`1 : ValueType {
    public bool CanFlush { get; }
    public sealed virtual void Write(TBufferWriter& state, Byte[] buffer, int offset, int length);
    public sealed virtual Task`1<TBufferWriter> WriteAsync(TBufferWriter state, Byte[] buffer, int offset, int length, CancellationToken token);
    public sealed virtual bool get_CanFlush();
    public sealed virtual void Flush(TBufferWriter& state);
    public sealed virtual Task`1<TBufferWriter> FlushAsync(TBufferWriter state, CancellationToken token);
}
[IsReadOnlyAttribute]
public class K4os.Compression.LZ4.Streams.Adapters.ByteMemoryReadAdapter : ValueType {
    private ReadOnlyMemory`1<byte> _memory;
    public ByteMemoryReadAdapter(ReadOnlyMemory`1<byte> memory);
    [NullableContextAttribute("1")]
internal int CopyToBuffer(int head, Byte[] buffer, int offset, int length);
    private static int Advance(Int32& state, int length);
    [NullableContextAttribute("1")]
public sealed virtual int Read(Int32& state, Byte[] buffer, int offset, int length);
    [NullableContextAttribute("1")]
public sealed virtual Task`1<ReadResult`1<int>> ReadAsync(int state, Byte[] buffer, int offset, int length, CancellationToken token);
}
[IsReadOnlyAttribute]
public class K4os.Compression.LZ4.Streams.Adapters.ByteMemoryWriteAdapter : ValueType {
    private Memory`1<byte> _memory;
    public bool CanFlush { get; }
    public ByteMemoryWriteAdapter(Memory`1<byte> memory);
    private static void Advance(Int32& memory, int length);
    [NullableContextAttribute("1")]
public sealed virtual void Write(Int32& state, Byte[] buffer, int offset, int length);
    [NullableContextAttribute("1")]
public sealed virtual Task`1<int> WriteAsync(int state, Byte[] buffer, int offset, int length, CancellationToken token);
    public sealed virtual bool get_CanFlush();
    public sealed virtual void Flush(Int32& state);
    [NullableContextAttribute("1")]
public sealed virtual Task`1<int> FlushAsync(int state, CancellationToken token);
}
public class K4os.Compression.LZ4.Streams.Adapters.ByteSequenceAdapter : ValueType {
    public sealed virtual int Read(ReadOnlySequence`1& state, Byte[] buffer, int offset, int length);
    public sealed virtual Task`1<ReadResult`1<ReadOnlySequence`1<byte>>> ReadAsync(ReadOnlySequence`1<byte> state, Byte[] buffer, int offset, int length, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class K4os.Compression.LZ4.Streams.Adapters.ByteSpanAdapter : object {
    private UnsafeByteSpan _span;
    public bool CanFlush { get; }
    public ByteSpanAdapter(UnsafeByteSpan span);
    public sealed virtual int Read(Int32& state, Byte[] buffer, int offset, int length);
    public sealed virtual Task`1<ReadResult`1<int>> ReadAsync(int state, Byte[] buffer, int offset, int length, CancellationToken token);
    public sealed virtual void Write(Int32& state, Byte[] buffer, int offset, int length);
    public sealed virtual Task`1<int> WriteAsync(int state, Byte[] buffer, int offset, int length, CancellationToken token);
    public sealed virtual bool get_CanFlush();
    public sealed virtual void Flush(Int32& state);
    public sealed virtual Task`1<int> FlushAsync(int state, CancellationToken token);
}
[IsReadOnlyAttribute]
public class K4os.Compression.LZ4.Streams.Adapters.EmptyState : ValueType {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class K4os.Compression.LZ4.Streams.Adapters.PipeReaderAdapter : ValueType {
    private PipeReader _reader;
    public PipeReaderAdapter(PipeReader reader);
    private static void CheckSyncOverAsync();
    public sealed virtual int Read(EmptyState& state, Byte[] buffer, int offset, int length);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Adapters.PipeReaderAdapter/<ReadAsync>d__4")]
public sealed virtual Task`1<ReadResult`1<EmptyState>> ReadAsync(EmptyState state, Byte[] buffer, int offset, int length, CancellationToken token);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Adapters.PipeReaderAdapter/<ReadFromPipe>d__5")]
private static Task`1<ReadOnlySequence`1<byte>> ReadFromPipe(PipeReader reader, int length, CancellationToken token);
    [NullableContextAttribute("0")]
private static ReadResult`1<EmptyState> ReadFromSequence(PipeReader reader, ReadOnlySequence`1<byte> sequence, Span`1<byte> buffer);
    [DoesNotReturnAttribute]
private static void ThrowPendingReadsCancelled();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class K4os.Compression.LZ4.Streams.Adapters.PipeWriterAdapter : ValueType {
    private PipeWriter _writer;
    public bool CanFlush { get; }
    public PipeWriterAdapter(PipeWriter writer);
    public sealed virtual void Write(EmptyState& state, Byte[] buffer, int offset, int length);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Adapters.PipeWriterAdapter/<WriteAsync>d__3")]
public sealed virtual Task`1<EmptyState> WriteAsync(EmptyState state, Byte[] buffer, int offset, int length, CancellationToken token);
    public sealed virtual bool get_CanFlush();
    public sealed virtual void Flush(EmptyState& state);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Adapters.PipeWriterAdapter/<FlushAsync>d__7")]
public sealed virtual Task`1<EmptyState> FlushAsync(EmptyState state, CancellationToken token);
    private static void CheckSyncOverAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class K4os.Compression.LZ4.Streams.Adapters.StreamAdapter : ValueType {
    private Stream _stream;
    public bool CanFlush { get; }
    public StreamAdapter(Stream stream);
    public sealed virtual int Read(EmptyState& state, Byte[] buffer, int offset, int length);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Adapters.StreamAdapter/<ReadAsync>d__3")]
public sealed virtual Task`1<ReadResult`1<EmptyState>> ReadAsync(EmptyState state, Byte[] buffer, int offset, int length, CancellationToken token);
    public sealed virtual void Write(EmptyState& state, Byte[] buffer, int offset, int length);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Adapters.StreamAdapter/<WriteAsync>d__5")]
public sealed virtual Task`1<EmptyState> WriteAsync(EmptyState state, Byte[] buffer, int offset, int length, CancellationToken token);
    public sealed virtual bool get_CanFlush();
    public sealed virtual void Flush(EmptyState& state);
    public sealed virtual Task`1<EmptyState> FlushAsync(EmptyState state, CancellationToken token);
}
[IsReadOnlyAttribute]
public class K4os.Compression.LZ4.Streams.Adapters.UnsafeByteSpan : ValueType {
    [CompilerGeneratedAttribute]
private Byte* <Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public Byte* Bytes { get; }
    public int Length { get; }
    public Span`1<byte> Span { get; }
    public UnsafeByteSpan(Void* bytes, int length);
    [CompilerGeneratedAttribute]
public Byte* get_Bytes();
    [CompilerGeneratedAttribute]
public int get_Length();
    public static UnsafeByteSpan Create(Void* bytes, int length);
    public Span`1<byte> get_Span();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class K4os.Compression.LZ4.Streams.Extensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static ReadOnlySpan`1<T> AsReadOnly(Span`1<T> span);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static ReadOnlyMemory`1<T> AsReadOnly(Memory`1<T> memory);
    private static int ExtraBlocks(int blockSize, int extraMemory);
    [ExtensionAttribute]
public static ILZ4Encoder CreateEncoder(ILZ4Descriptor descriptor, LZ4Level level, int extraMemory);
    [ExtensionAttribute]
public static ILZ4Encoder CreateEncoder(ILZ4Descriptor descriptor, LZ4EncoderSettings settings);
    [ExtensionAttribute]
public static ILZ4Decoder CreateDecoder(ILZ4Descriptor descriptor, int extraMemory);
    [ExtensionAttribute]
public static ILZ4Decoder CreateDecoder(ILZ4Descriptor descriptor, LZ4DecoderSettings settings);
    [ExtensionAttribute]
public static ILZ4Descriptor CreateDescriptor(LZ4EncoderSettings settings);
    [ExtensionAttribute]
public static Task`1<bool> OpenFrameAsync(ILZ4FrameReader reader);
    [ExtensionAttribute]
public static Task`1<Nullable`1<long>> GetFrameLengthAsync(ILZ4FrameReader reader);
    [ExtensionAttribute]
public static Task`1<int> ReadOneByteAsync(ILZ4FrameReader reader);
    [ExtensionAttribute]
public static Task`1<int> ReadManyBytesAsync(ILZ4FrameReader reader, Memory`1<byte> buffer, bool interactive);
    [ExtensionAttribute]
public static Task`1<bool> OpenFrameAsync(ILZ4FrameWriter writer);
    [ExtensionAttribute]
public static Task WriteOneByteAsync(ILZ4FrameWriter writer, byte value);
    [ExtensionAttribute]
public static Task WriteManyBytesAsync(ILZ4FrameWriter writer, ReadOnlyMemory`1<byte> buffer);
    [ExtensionAttribute]
public static Task CloseFrameAsync(ILZ4FrameWriter writer);
    [ExtensionAttribute]
public static void CopyTo(ILZ4FrameReader source, TBufferWriter target, int blockSize);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Extensions/<CopyToAsync>d__17`1")]
[ExtensionAttribute]
public static Task CopyToAsync(ILZ4FrameReader source, TBufferWriter target, int blockSize);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static int CopyFrom(ILZ4FrameWriter target, ReadOnlySequence`1<byte> source);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Extensions/<CopyFromAsync>d__19")]
[ExtensionAttribute]
public static Task`1<int> CopyFromAsync(ILZ4FrameWriter target, ReadOnlySequence`1<byte> source);
    [ExtensionAttribute]
public static LZ4FrameReaderAsStream AsStream(ILZ4FrameReader reader, bool leaveOpen, bool interactive);
    [ExtensionAttribute]
public static LZ4FrameWriterAsStream AsStream(ILZ4FrameWriter writer, bool leaveOpen);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class K4os.Compression.LZ4.Streams.Frames.ByteBufferLZ4FrameWriter : ByteBufferLZ4FrameWriter`1<IBufferWriter`1<byte>> {
    public ByteBufferLZ4FrameWriter(IBufferWriter`1<byte> stream, Func`2<ILZ4Descriptor, ILZ4Encoder> encoderFactory, ILZ4Descriptor descriptor);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class K4os.Compression.LZ4.Streams.Frames.ByteBufferLZ4FrameWriter`1 : LZ4FrameWriter`2<ByteBufferAdapter`1<TBufferWriter>, TBufferWriter> {
    public TBufferWriter BufferWriter { get; }
    public ByteBufferLZ4FrameWriter`1(TBufferWriter stream, Func`2<ILZ4Descriptor, ILZ4Encoder> encoderFactory, ILZ4Descriptor descriptor);
    public TBufferWriter get_BufferWriter();
}
public class K4os.Compression.LZ4.Streams.Frames.ByteMemoryLZ4FrameReader : LZ4FrameReader`2<ByteMemoryReadAdapter, int> {
    public ByteMemoryLZ4FrameReader(ReadOnlyMemory`1<byte> memory, Func`2<ILZ4Descriptor, ILZ4Decoder> decoderFactory);
}
public class K4os.Compression.LZ4.Streams.Frames.ByteMemoryLZ4FrameWriter : LZ4FrameWriter`2<ByteMemoryWriteAdapter, int> {
    public int CompressedLength { get; }
    [NullableContextAttribute("1")]
public ByteMemoryLZ4FrameWriter(Memory`1<byte> memory, Func`2<ILZ4Descriptor, ILZ4Encoder> encoderFactory, ILZ4Descriptor descriptor);
    public int get_CompressedLength();
}
public class K4os.Compression.LZ4.Streams.Frames.ByteSequenceLZ4FrameReader : LZ4FrameReader`2<ByteSequenceAdapter, ReadOnlySequence`1<byte>> {
    public ByteSequenceLZ4FrameReader(ReadOnlySequence`1<byte> sequence, Func`2<ILZ4Descriptor, ILZ4Decoder> decoderFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class K4os.Compression.LZ4.Streams.Frames.ByteSpanLZ4FrameReader : LZ4FrameReader`2<ByteSpanAdapter, int> {
    public ByteSpanLZ4FrameReader(UnsafeByteSpan span, Func`2<ILZ4Descriptor, ILZ4Decoder> decoderFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class K4os.Compression.LZ4.Streams.Frames.ByteSpanLZ4FrameWriter : LZ4FrameWriter`2<ByteSpanAdapter, int> {
    public int CompressedLength { get; }
    public ByteSpanLZ4FrameWriter(UnsafeByteSpan span, Func`2<ILZ4Descriptor, ILZ4Encoder> encoderFactory, ILZ4Descriptor descriptor);
    public int get_CompressedLength();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class K4os.Compression.LZ4.Streams.Frames.LZ4FrameReader`2 : object {
    private TStreamReader _reader;
    private TStreamState _stream;
    private Stash _stash;
    private Func`2<ILZ4Descriptor, ILZ4Decoder> _decoderFactory;
    [NullableAttribute("2")]
private ILZ4Descriptor _descriptor;
    [NullableAttribute("2")]
private ILZ4Decoder _decoder;
    private State _contentChecksum;
    [NullableAttribute("2")]
private Byte[] _buffer;
    private int _decoded;
    private long _bytesRead;
    public TStreamState StreamState { get; }
    public LZ4FrameReader`2(TStreamReader reader, TStreamState stream, Func`2<ILZ4Descriptor, ILZ4Decoder> decoderFactory);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameReader`2/<Peek8>d__0")]
private Task`1<ulong> Peek8(CancellationToken token);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameReader`2/<TryPeek4>d__1")]
private Task`1<Nullable`1<UInt32>> TryPeek4(CancellationToken token);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameReader`2/<Peek4>d__2")]
private Task`1<UInt32> Peek4(CancellationToken token);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameReader`2/<Peek2>d__3")]
private Task`1<ushort> Peek2(CancellationToken token);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameReader`2/<Peek1>d__4")]
private Task`1<byte> Peek1(CancellationToken token);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameReader`2/<EnsureHeader>d__5")]
private Task`1<bool> EnsureHeader(CancellationToken token);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameReader`2/<ReadHeader>d__6")]
private Task`1<bool> ReadHeader(CancellationToken token);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameReader`2/<ReadBlock>d__7")]
private Task`1<int> ReadBlock(CancellationToken token);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameReader`2/<GetFrameLength>d__8")]
private Task`1<Nullable`1<long>> GetFrameLength(CancellationToken token);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameReader`2/<ReadOneByte>d__9")]
private Task`1<int> ReadOneByte(CancellationToken token);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameReader`2/<ReadManyBytes>d__10")]
private Task`1<int> ReadManyBytes(CancellationToken token, Memory`1<byte> buffer, bool interactive);
    private ulong Peek8(EmptyToken token);
    private Nullable`1<UInt32> TryPeek4(EmptyToken token);
    private UInt32 Peek4(EmptyToken token);
    private ushort Peek2(EmptyToken token);
    private byte Peek1(EmptyToken token);
    private bool EnsureHeader(EmptyToken token);
    private bool ReadHeader(EmptyToken token);
    private int ReadBlock(EmptyToken token);
    private Nullable`1<long> GetFrameLength(EmptyToken token);
    private int ReadOneByte(EmptyToken token);
    [NullableContextAttribute("0")]
private int ReadManyBytes(EmptyToken token, Span`1<byte> buffer, bool interactive);
    public TStreamState get_StreamState();
    private static int MaxBlockSize(int blockSizeCode);
    private ILZ4Decoder CreateDecoder(ILZ4Descriptor descriptor);
    public sealed virtual void CloseFrame();
    protected virtual Byte[] AllocBuffer(int size);
    protected virtual void ReleaseBuffer(Byte[] buffer);
    private int InjectOrDecode(int blockLength, bool uncompressed);
    [NullableContextAttribute("0")]
private bool Drain(Span`1<byte> buffer, Int32& offset, Int32& count, Int32& read);
    private void VerifyBlockChecksum(UInt32 expected, int blockLength);
    private void InitializeContentChecksum();
    private void UpdateContentChecksum(int read);
    private void VerifyContentChecksum(UInt32 expected);
    public sealed virtual bool OpenFrame();
    public sealed virtual Task`1<bool> OpenFrameAsync(CancellationToken token);
    public sealed virtual long GetBytesRead();
    public sealed virtual Nullable`1<long> GetFrameLength();
    public sealed virtual Task`1<Nullable`1<long>> GetFrameLengthAsync(CancellationToken token);
    public sealed virtual int ReadOneByte();
    public sealed virtual Task`1<int> ReadOneByteAsync(CancellationToken token);
    [NullableContextAttribute("0")]
public sealed virtual int ReadManyBytes(Span`1<byte> buffer, bool interactive);
    [NullableContextAttribute("0")]
public sealed virtual Task`1<int> ReadManyBytesAsync(CancellationToken token, Memory`1<byte> buffer, bool interactive);
    private static NotImplementedException NotImplemented(string feature);
    private static InvalidDataException InvalidHeaderChecksum();
    private static InvalidDataException MagicNumberExpected();
    private static InvalidDataException UnknownFrameVersion(int version);
    private static InvalidDataException InvalidChecksum(string type);
    protected virtual void Dispose(bool disposing);
    protected virtual void ReleaseResources();
    protected virtual Task ReleaseResourcesAsync();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameReader`2/<DisposeAsync>d__64")]
public virtual ValueTask DisposeAsync();
    private int ReadMeta(EmptyToken _, int length, bool optional);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameReader`2/<ReadMeta>d__66")]
private Task`1<int> ReadMeta(CancellationToken token, int length, bool optional);
    private void ReadData(EmptyToken _, int length);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameReader`2/<ReadData>d__68")]
private Task ReadData(CancellationToken token, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class K4os.Compression.LZ4.Streams.Frames.LZ4FrameReaderAsStream : LZ4StreamEssentials`1<ILZ4FrameReader> {
    private bool _interactive;
    public bool CanRead { get; }
    public long Length { get; }
    public long Position { get; }
    public LZ4FrameReaderAsStream(ILZ4FrameReader reader, bool doNotDispose, bool interactive);
    public virtual bool get_CanRead();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken token);
    public virtual long get_Length();
    public virtual long get_Position();
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class K4os.Compression.LZ4.Streams.Frames.LZ4FrameWriter`2 : object {
    private TStreamWriter _writer;
    private TStreamState _stream;
    private Stash _stash;
    private Func`2<ILZ4Descriptor, ILZ4Encoder> _encoderFactory;
    [NullableAttribute("2")]
private ILZ4Descriptor _descriptor;
    [NullableAttribute("2")]
private ILZ4Encoder _encoder;
    [NullableAttribute("2")]
private Byte[] _buffer;
    private long _bytesWritten;
    private State _contentChecksum;
    protected TStreamState StreamState { get; }
    public LZ4FrameWriter`2(TStreamWriter writer, TStreamState stream, Func`2<ILZ4Descriptor, ILZ4Encoder> encoderFactory, ILZ4Descriptor descriptor);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameWriter`2/<WriteBlock>d__0")]
private Task WriteBlock(CancellationToken token, BlockInfo block);
    private Task WriteOneByte(CancellationToken token, byte value);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameWriter`2/<WriteManyBytes>d__2")]
private Task WriteManyBytes(CancellationToken token, ReadOnlyMemory`1<byte> buffer);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameWriter`2/<OpenFrame>d__3")]
private Task`1<bool> OpenFrame(CancellationToken token);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameWriter`2/<CloseFrame>d__4")]
private Task CloseFrame(CancellationToken token);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameWriter`2/<WriteFrameTail>d__5")]
private Task WriteFrameTail(CancellationToken token);
    private void WriteBlock(EmptyToken token, BlockInfo block);
    private void WriteOneByte(EmptyToken token, byte value);
    [NullableContextAttribute("0")]
private void WriteManyBytes(EmptyToken token, ReadOnlySpan`1<byte> buffer);
    private bool OpenFrame(EmptyToken token);
    private void CloseFrame(EmptyToken token);
    private void WriteFrameTail(EmptyToken token);
    protected TStreamState get_StreamState();
    private bool TryStashFrame();
    protected virtual Byte[] AllocateBuffer(int size);
    protected virtual void ReleaseBuffer(Byte[] buffer);
    private ILZ4Encoder CreateEncoder();
    [NullableContextAttribute("0")]
private BlockInfo TopupAndEncode(ReadOnlySpan`1<byte> buffer, Int32& offset, Int32& count);
    private BlockInfo FlushAndEncode();
    private static UInt32 BlockLengthCode(BlockInfo& block);
    private void InitializeContentChecksum();
    [NullableContextAttribute("0")]
private void UpdateContentChecksum(ReadOnlySpan`1<byte> buffer);
    private Nullable`1<UInt32> BlockChecksum(BlockInfo block);
    private Nullable`1<UInt32> ContentChecksum();
    private int MaxBlockSizeCode(int blockSize);
    public sealed virtual long GetBytesWritten();
    public sealed virtual void WriteOneByte(byte value);
    public sealed virtual Task WriteOneByteAsync(CancellationToken token, byte value);
    [NullableContextAttribute("0")]
public sealed virtual void WriteManyBytes(ReadOnlySpan`1<byte> buffer);
    [NullableContextAttribute("0")]
public sealed virtual Task WriteManyBytesAsync(CancellationToken token, ReadOnlyMemory`1<byte> buffer);
    public sealed virtual bool OpenFrame();
    public sealed virtual Task`1<bool> OpenFrameAsync(CancellationToken token);
    public sealed virtual void CloseFrame();
    public sealed virtual Task CloseFrameAsync(CancellationToken token);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected virtual void ReleaseResources();
    protected virtual Task ReleaseResourcesAsync();
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameWriter`2/<DisposeAsync>d__49")]
public virtual ValueTask DisposeAsync();
    private void FlushMeta(EmptyToken _, bool eof);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameWriter`2/<FlushMeta>d__51")]
private Task FlushMeta(CancellationToken token, bool eof);
    private void WriteData(EmptyToken _, BlockInfo block);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.LZ4FrameWriter`2/<WriteData>d__53")]
private Task WriteData(CancellationToken token, BlockInfo block);
    [NullableContextAttribute("0")]
private Span`1<byte> OneByteBuffer(EmptyToken& _, byte value);
    [NullableContextAttribute("0")]
private Memory`1<byte> OneByteBuffer(CancellationToken& _, byte value);
    private NotImplementedException NotImplemented(string operation);
    private static ArgumentException InvalidValue(string description);
    private protected ArgumentException InvalidBlockSize(int blockSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class K4os.Compression.LZ4.Streams.Frames.LZ4FrameWriterAsStream : LZ4StreamEssentials`1<ILZ4FrameWriter> {
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; }
    public LZ4FrameWriterAsStream(ILZ4FrameWriter writer, bool doNotDispose);
    public virtual bool get_CanWrite();
    public virtual void WriteByte(byte value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken token);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken token);
    public virtual long get_Length();
    public virtual long get_Position();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class K4os.Compression.LZ4.Streams.Frames.PipeLZ4FrameReader : LZ4FrameReader`2<PipeReaderAdapter, EmptyState> {
    private PipeReader _pipe;
    private bool _leaveOpen;
    public PipeLZ4FrameReader(PipeReader pipe, bool leaveOpen, Func`2<ILZ4Descriptor, ILZ4Decoder> decoderFactory);
    protected virtual void ReleaseResources();
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.PipeLZ4FrameReader/<ReleaseResourcesAsync>d__4")]
protected virtual Task ReleaseResourcesAsync();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class K4os.Compression.LZ4.Streams.Frames.PipeLZ4FrameWriter : LZ4FrameWriter`2<PipeWriterAdapter, EmptyState> {
    private PipeWriter _pipe;
    private bool _leaveOpen;
    public PipeLZ4FrameWriter(PipeWriter pipe, bool leaveOpen, Func`2<ILZ4Descriptor, ILZ4Encoder> encoderFactory, ILZ4Descriptor descriptor);
    protected virtual void ReleaseResources();
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.PipeLZ4FrameWriter/<ReleaseResourcesAsync>d__4")]
protected virtual Task ReleaseResourcesAsync();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class K4os.Compression.LZ4.Streams.Frames.StreamLZ4FrameReader : LZ4FrameReader`2<StreamAdapter, EmptyState> {
    private Stream _stream;
    private bool _leaveOpen;
    public StreamLZ4FrameReader(Stream stream, bool leaveOpen, Func`2<ILZ4Descriptor, ILZ4Decoder> decoderFactory);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.StreamLZ4FrameReader/<DisposeAsync>d__4")]
public virtual ValueTask DisposeAsync();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class K4os.Compression.LZ4.Streams.Frames.StreamLZ4FrameWriter : LZ4FrameWriter`2<StreamAdapter, EmptyState> {
    private Stream _stream;
    private bool _leaveOpen;
    public StreamLZ4FrameWriter(Stream stream, bool leaveOpen, Func`2<ILZ4Descriptor, ILZ4Encoder> encoderFactory, ILZ4Descriptor descriptor);
    protected virtual void ReleaseResources();
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Frames.StreamLZ4FrameWriter/<ReleaseResourcesAsync>d__4")]
protected virtual Task ReleaseResourcesAsync();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0();
}
public interface K4os.Compression.LZ4.Streams.ILZ4Descriptor {
    public Nullable`1<long> ContentLength { get; }
    public bool ContentChecksum { get; }
    public bool Chaining { get; }
    public bool BlockChecksum { get; }
    public Nullable`1<UInt32> Dictionary { get; }
    public int BlockSize { get; }
    public abstract virtual Nullable`1<long> get_ContentLength();
    public abstract virtual bool get_ContentChecksum();
    public abstract virtual bool get_Chaining();
    public abstract virtual bool get_BlockChecksum();
    public abstract virtual Nullable`1<UInt32> get_Dictionary();
    public abstract virtual int get_BlockSize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class K4os.Compression.LZ4.Streams.Internal.BlockInfo : ValueType {
    private Byte[] _buffer;
    private int _length;
    public Byte[] Buffer { get; }
    public int Offset { get; }
    public int Length { get; }
    public bool Compressed { get; }
    public bool Ready { get; }
    public BlockInfo(Byte[] buffer, EncoderAction action, int length);
    public Byte[] get_Buffer();
    public int get_Offset();
    public int get_Length();
    public bool get_Compressed();
    public bool get_Ready();
}
[IsReadOnlyAttribute]
internal class K4os.Compression.LZ4.Streams.Internal.EmptyToken : ValueType {
    public static EmptyToken Value;
    private static EmptyToken();
}
[ExtensionAttribute]
internal static class K4os.Compression.LZ4.Streams.Internal.Extensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ConfiguredTaskAwaitable`1<T> Weave(Task`1<T> task);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ConfiguredTaskAwaitable Weave(Task task);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ConfiguredValueTaskAwaitable`1<T> Weave(ValueTask`1<T> task);
    [ExtensionAttribute]
public static ConfiguredValueTaskAwaitable Weave(ValueTask task);
    [ExtensionAttribute]
public static ReadOnlySpan`1<byte> ToSpan(ReadOnlySpan`1<byte> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<byte> ToSpan(ReadOnlyMemory`1<byte> span);
    [ExtensionAttribute]
public static Span`1<byte> ToSpan(Span`1<byte> span);
    [ExtensionAttribute]
public static Span`1<byte> ToSpan(Memory`1<byte> span);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void AssertIsNotNull(T value, string name);
    [NullableContextAttribute("2")]
[DoesNotReturnAttribute]
private static void ThrowArgumentNullException(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class K4os.Compression.LZ4.Streams.Internal.LZ4StreamEssentials`1 : Stream {
    private T _innerResource;
    private bool _doNotDispose;
    private bool _alreadyDisposed;
    protected T InnerResource { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public bool CanSeek { get; }
    public long Position { get; public set; }
    public long Length { get; }
    protected LZ4StreamEssentials`1(T innerResource, bool doNotDispose);
    protected T get_InnerResource();
    private protected NotImplementedException NotImplemented(string operation);
    private protected InvalidOperationException InvalidOperation(string operation);
    private protected static ArgumentException InvalidValue(string description);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual bool get_CanSeek();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken token);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken token);
    protected virtual void Dispose(bool disposing);
    public virtual void WriteByte(byte value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken token);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken token);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken token);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Internal.LZ4StreamEssentials`1/<DisposeAsync>d__43")]
public virtual ValueTask DisposeAsync();
    private bool ShouldDisposeInner(bool disposing);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class K4os.Compression.LZ4.Streams.Internal.LZ4StreamOnStreamEssentials : LZ4StreamEssentials`1<Stream> {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    private protected LZ4StreamOnStreamEssentials(Stream innerStream, bool leaveOpen);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class K4os.Compression.LZ4.Streams.Internal.ReaderExtensions : object {
    private static EndOfStreamException EndOfStream();
    [ExtensionAttribute]
public static int TryReadBlock(TStreamReader stream, TStreamState& state, Byte[] buffer, int offset, int count, bool optional);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.Internal.ReaderExtensions/<TryReadBlockAsync>d__2`2")]
[ExtensionAttribute]
public static Task`1<ReadResult`1<TStreamState>> TryReadBlockAsync(TStreamReader stream, TStreamState state, Byte[] buffer, int offset, int count, bool optional, CancellationToken token);
}
internal class K4os.Compression.LZ4.Streams.Internal.Stash : ValueType {
    [NullableAttribute("1")]
private Byte[] _buffer;
    private int _size;
    private int _head;
    [NullableAttribute("1")]
public Byte[] Data { get; }
    public int Head { get; }
    public Stash(int size);
    public void Dispose();
    [NullableContextAttribute("1")]
public Byte[] get_Data();
    public int get_Head();
    public int Flush();
    public int Advance(int loaded);
    public Span`1<byte> AsSpan(int offset);
    public byte OneByteValue();
    public Span`1<byte> OneByteSpan();
    public Span`1<byte> OneByteSpan(byte value);
    public Memory`1<byte> OneByteMemory();
    public Memory`1<byte> OneByteMemory(byte value);
    public Span`1<byte> OneByteBuffer(EmptyToken& _);
    public Memory`1<byte> OneByteBuffer(CancellationToken& _);
    public ulong Last8(int loaded);
    public UInt32 Last4(int loaded);
    public ushort Last2(int loaded);
    public byte Last1(int loaded);
    public void Poke1(byte value);
    public void Poke2(ushort value);
    public void Poke4(UInt32 value);
    public void Poke8(ulong value);
    public void TryPoke4(Nullable`1<UInt32> value);
    private void ValidateBuffer();
    private void PokeN(T value);
    public UInt32 Digest(int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class K4os.Compression.LZ4.Streams.LZ4DecoderSettings : object {
    [CompilerGeneratedAttribute]
private static LZ4DecoderSettings <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExtraMemory>k__BackingField;
    internal static LZ4DecoderSettings Default { get; }
    public int ExtraMemory { get; public set; }
    private static LZ4DecoderSettings();
    [CompilerGeneratedAttribute]
internal static LZ4DecoderSettings get_Default();
    [CompilerGeneratedAttribute]
public int get_ExtraMemory();
    [CompilerGeneratedAttribute]
public void set_ExtraMemory(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class K4os.Compression.LZ4.Streams.LZ4DecoderStream : LZ4StreamOnStreamEssentials {
    private StreamLZ4FrameReader _reader;
    private bool _interactive;
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; }
    public LZ4DecoderStream(Stream inner, Func`2<ILZ4Descriptor, ILZ4Decoder> decoderFactory, bool leaveOpen, bool interactive);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken token);
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken token);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.LZ4DecoderStream/<DisposeAsync>d__15")]
public virtual ValueTask DisposeAsync();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
}
public class K4os.Compression.LZ4.Streams.LZ4Descriptor : object {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContentChecksum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Chaining>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BlockChecksum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <Dictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BlockSize>k__BackingField;
    public Nullable`1<long> ContentLength { get; }
    public bool ContentChecksum { get; }
    public bool Chaining { get; }
    public bool BlockChecksum { get; }
    public Nullable`1<UInt32> Dictionary { get; }
    public int BlockSize { get; }
    public LZ4Descriptor(Nullable`1<long> contentLength, bool contentChecksum, bool chaining, bool blockChecksum, Nullable`1<UInt32> dictionary, int blockSize);
    [NullableContextAttribute("1")]
public LZ4Descriptor(ILZ4Descriptor descriptor);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<long> get_ContentLength();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ContentChecksum();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Chaining();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_BlockChecksum();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<UInt32> get_Dictionary();
    [CompilerGeneratedAttribute]
public sealed virtual int get_BlockSize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class K4os.Compression.LZ4.Streams.LZ4EncoderSettings : object {
    [CompilerGeneratedAttribute]
private static LZ4EncoderSettings <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ChainBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BlockSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContentChecksum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BlockChecksum>k__BackingField;
    [CompilerGeneratedAttribute]
private LZ4Level <CompressionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExtraMemory>k__BackingField;
    internal static LZ4EncoderSettings Default { get; }
    public Nullable`1<long> ContentLength { get; public set; }
    public bool ChainBlocks { get; public set; }
    public int BlockSize { get; public set; }
    public bool ContentChecksum { get; public set; }
    public bool BlockChecksum { get; public set; }
    public Nullable`1<UInt32> Dictionary { get; }
    public LZ4Level CompressionLevel { get; public set; }
    public int ExtraMemory { get; public set; }
    private static LZ4EncoderSettings();
    [CompilerGeneratedAttribute]
internal static LZ4EncoderSettings get_Default();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ContentLength();
    [CompilerGeneratedAttribute]
public void set_ContentLength(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public bool get_ChainBlocks();
    [CompilerGeneratedAttribute]
public void set_ChainBlocks(bool value);
    [CompilerGeneratedAttribute]
public int get_BlockSize();
    [CompilerGeneratedAttribute]
public void set_BlockSize(int value);
    [CompilerGeneratedAttribute]
public bool get_ContentChecksum();
    [CompilerGeneratedAttribute]
public void set_ContentChecksum(bool value);
    [CompilerGeneratedAttribute]
public bool get_BlockChecksum();
    [CompilerGeneratedAttribute]
public void set_BlockChecksum(bool value);
    public Nullable`1<UInt32> get_Dictionary();
    [CompilerGeneratedAttribute]
public LZ4Level get_CompressionLevel();
    [CompilerGeneratedAttribute]
public void set_CompressionLevel(LZ4Level value);
    [CompilerGeneratedAttribute]
public int get_ExtraMemory();
    [CompilerGeneratedAttribute]
public void set_ExtraMemory(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class K4os.Compression.LZ4.Streams.LZ4EncoderStream : LZ4StreamOnStreamEssentials {
    private StreamLZ4FrameWriter _writer;
    public bool CanRead { get; }
    public long Length { get; }
    public long Position { get; }
    public LZ4EncoderStream(Stream inner, ILZ4Descriptor descriptor, Func`2<ILZ4Descriptor, ILZ4Encoder> encoderFactory, bool leaveOpen);
    protected virtual void Dispose(bool disposing);
    public virtual void WriteByte(byte value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken token);
    [AsyncStateMachineAttribute("K4os.Compression.LZ4.Streams.LZ4EncoderStream/<DisposeAsync>d__6")]
public virtual ValueTask DisposeAsync();
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken token);
    public virtual bool get_CanRead();
    public virtual long get_Length();
    public virtual long get_Position();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class K4os.Compression.LZ4.Streams.LZ4Frame : object {
    public static TBufferWriter Decode(ReadOnlySpan`1<byte> source, TBufferWriter target, int extraMemory);
    [NullableContextAttribute("0")]
public static ByteMemoryLZ4FrameReader Decode(ReadOnlyMemory`1<byte> memory, int extraMemory);
    [NullableContextAttribute("0")]
public static ByteSequenceLZ4FrameReader Decode(ReadOnlySequence`1<byte> sequence, int extraMemory);
    public static StreamLZ4FrameReader Decode(Stream stream, int extraMemory, bool leaveOpen);
    public static PipeLZ4FrameReader Decode(PipeReader reader, int extraMemory, bool leaveOpen);
    private static LZ4EncoderSettings ToEncoderSettings(LZ4Level level, int extraMemory);
    public static TBufferWriter Encode(ReadOnlySequence`1<byte> source, TBufferWriter target, LZ4EncoderSettings settings);
    public static TBufferWriter Encode(ReadOnlySpan`1<byte> source, TBufferWriter target, LZ4EncoderSettings settings);
    public static TBufferWriter Encode(ReadOnlySequence`1<byte> source, TBufferWriter target, LZ4Level level, int extraMemory);
    public static TBufferWriter Encode(ReadOnlySpan`1<byte> source, TBufferWriter target, LZ4Level level, int extraMemory);
    [NullableContextAttribute("0")]
public static int Encode(ReadOnlySequence`1<byte> source, Span`1<byte> target, LZ4EncoderSettings settings);
    [NullableContextAttribute("0")]
public static int Encode(Span`1<byte> source, Span`1<byte> target, LZ4EncoderSettings settings);
    [NullableContextAttribute("0")]
public static int Encode(Action`1<ILZ4FrameWriter> source, Span`1<byte> target, LZ4EncoderSettings settings);
    [NullableContextAttribute("0")]
public static int Encode(ReadOnlySequence`1<byte> source, Span`1<byte> target, LZ4Level level, int extraMemory);
    [NullableContextAttribute("0")]
public static int Encode(Span`1<byte> source, Span`1<byte> target, LZ4Level level, int extraMemory);
    [NullableContextAttribute("0")]
public static int Encode(Action`1<ILZ4FrameWriter> source, Span`1<byte> target, LZ4Level level, int extraMemory);
    [NullableContextAttribute("0")]
public static ByteSpanLZ4FrameWriter Encode(Byte* target, int length, LZ4EncoderSettings settings);
    [NullableContextAttribute("0")]
public static ByteSpanLZ4FrameWriter Encode(Byte* target, int length, LZ4Level level, int extraMemory);
    [NullableContextAttribute("0")]
public static ByteMemoryLZ4FrameWriter Encode(Memory`1<byte> target, LZ4EncoderSettings settings);
    [NullableContextAttribute("0")]
public static ByteMemoryLZ4FrameWriter Encode(Memory`1<byte> target, LZ4Level level, int extraMemory);
    public static ByteBufferLZ4FrameWriter`1<TBufferWriter> Encode(TBufferWriter target, LZ4EncoderSettings settings);
    public static ByteBufferLZ4FrameWriter`1<TBufferWriter> Encode(TBufferWriter target, LZ4Level level, int extraMemory);
    public static ByteBufferLZ4FrameWriter Encode(IBufferWriter`1<byte> target, LZ4EncoderSettings settings);
    public static ByteBufferLZ4FrameWriter Encode(IBufferWriter`1<byte> target, LZ4Level level, int extraMemory);
    public static StreamLZ4FrameWriter Encode(Stream target, LZ4EncoderSettings settings, bool leaveOpen);
    public static StreamLZ4FrameWriter Encode(Stream target, LZ4Level level, int extraMemory, bool leaveOpen);
    public static PipeLZ4FrameWriter Encode(PipeWriter target, LZ4EncoderSettings settings, bool leaveOpen);
    public static PipeLZ4FrameWriter Encode(PipeWriter target, LZ4Level level, int extraMemory, bool leaveOpen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class K4os.Compression.LZ4.Streams.LZ4Stream : object {
    public static LZ4EncoderStream Encode(Stream stream, LZ4EncoderSettings settings, bool leaveOpen);
    public static LZ4EncoderStream Encode(Stream stream, LZ4Level level, int extraMemory, bool leaveOpen);
    public static LZ4DecoderStream Decode(Stream stream, LZ4DecoderSettings settings, bool leaveOpen, bool interactive);
    public static LZ4DecoderStream Decode(Stream stream, int extraMemory, bool leaveOpen, bool interactive);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[AttributeUsageAttribute("32")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.StringSyntaxAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Syntax>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    public static string CompositeFormat;
    public static string DateOnlyFormat;
    public static string DateTimeFormat;
    public static string EnumFormat;
    public static string GuidFormat;
    public static string Json;
    public static string NumericFormat;
    public static string Regex;
    public static string TimeOnlyFormat;
    public static string TimeSpanFormat;
    public static string Uri;
    public static string Xml;
    public string Syntax { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] Arguments { get; }
    public StringSyntaxAttribute(string syntax);
    public StringSyntaxAttribute(string syntax, Object[] arguments);
    [CompilerGeneratedAttribute]
public string get_Syntax();
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
}
[AttributeUsageAttribute("2240")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Diagnostics.CodeAnalysis.UnscopedRefAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public void set_IsOptional(bool value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[AttributeUsageAttribute("396")]
[ExcludeFromCodeCoverageAttribute]
internal class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
