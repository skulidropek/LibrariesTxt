public enum Lamar.AppendState : Enum {
    public int value__;
    public static AppendState NewDefault;
    public static AppendState SameDefault;
}
public enum Lamar.AssertMode : Enum {
    public int value__;
    public static AssertMode ConfigOnly;
    public static AssertMode Full;
}
internal class Lamar.CloseGenericFamilyPolicy : object {
    public sealed virtual ServiceFamily Build(Type type, ServiceGraph graph);
    private ServiceFamily tryToConnect(Type type, ServiceGraph graph);
}
internal class Lamar.ConcreteFamilyPolicy : object {
    public sealed virtual ServiceFamily Build(Type type, ServiceGraph serviceGraph);
    public static bool IsReallyPublic(Type type);
}
public abstract class Lamar.ConfiguredInstancePolicy : object {
    public sealed virtual void Apply(Instance instance);
    protected abstract virtual void apply(IConfiguredInstance instance);
}
public class Lamar.Container : Scope {
    private bool _isDisposing;
    public Container(IServiceCollection services);
    public Container(Action`1<ServiceRegistry> configuration);
    private Container(ServiceGraph serviceGraph, Container container);
    public sealed virtual INestedContainer GetNestedContainer();
    public virtual void Dispose();
    [AsyncStateMachineAttribute("Lamar.Container/<DisposeAsync>d__7")]
public virtual ValueTask DisposeAsync();
    public sealed virtual void AssertConfigurationIsValid(AssertMode mode);
    public sealed virtual void Configure(IServiceCollection services);
    public sealed virtual void Configure(Action`1<IServiceCollection> configure);
    private sealed virtual override IServiceScope Microsoft.Extensions.DependencyInjection.IServiceScopeFactory.CreateScope();
    private sealed virtual override object Microsoft.Extensions.DependencyInjection.ISupportRequiredService.GetRequiredService(Type serviceType);
    public static Container Empty();
    public static Container For();
    public static Container For(Action`1<ServiceRegistry> configuration);
    public static Task`1<Container> BuildAsync(Action`1<ServiceRegistry> configure);
    [AsyncStateMachineAttribute("Lamar.Container/<BuildAsync>d__17")]
public static Task`1<Container> BuildAsync(IServiceCollection services);
    private bool buildAndValidateAll(StringWriter writer);
    private bool validateConfiguration(StringWriter writer);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0();
}
[LamarIgnoreAttribute]
public class Lamar.DecoratorPolicy : object {
    private Type _decoratorType;
    private Type _serviceType;
    public DecoratorPolicy(Type serviceType, Type decoratorType);
    public sealed virtual bool TryWrap(Instance instance, Instance& wrapped);
}
[LamarIgnoreAttribute]
public class Lamar.DecoratorPolicy`2 : DecoratorPolicy {
}
[AttributeUsageAttribute("32")]
public class Lamar.DefaultConstructorAttribute : Attribute {
    public static ConstructorInfo GetConstructor(Type exportedType);
}
public interface Lamar.Diagnostics.IModel {
    public IEnumerable`1<IServiceFamilyConfiguration> ServiceTypes { get; }
    public IEnumerable`1<InstanceRef> AllInstances { get; }
    public IEnumerable`1<AssemblyScanner> Scanners { get; }
    public abstract virtual IEnumerable`1<IServiceFamilyConfiguration> get_ServiceTypes();
    public abstract virtual IEnumerable`1<InstanceRef> get_AllInstances();
    public abstract virtual IEnumerable`1<AssemblyScanner> get_Scanners();
    public abstract virtual IServiceFamilyConfiguration For();
    public abstract virtual IServiceFamilyConfiguration For(Type type);
    public abstract virtual IEnumerable`1<InstanceRef> InstancesOf(Type serviceType);
    public abstract virtual IEnumerable`1<InstanceRef> InstancesOf();
    public abstract virtual Type DefaultTypeFor();
    public abstract virtual Type DefaultTypeFor(Type serviceType);
    public abstract virtual T[] GetAllPossible();
    public abstract virtual bool HasRegistrationFor(Type serviceType);
    public abstract virtual bool HasRegistrationFor();
}
public class Lamar.Diagnostics.InstanceRef : object {
    private Scope _rootScope;
    private Scope _scope;
    [CompilerGeneratedAttribute]
private Instance <Instance>k__BackingField;
    public Instance Instance { get; }
    public ServiceLifetime Lifetime { get; }
    public string Name { get; }
    public Type ImplementationType { get; }
    public Type ServiceType { get; }
    public InstanceRef(Instance instance, Scope scope);
    [CompilerGeneratedAttribute]
public Instance get_Instance();
    public ServiceLifetime get_Lifetime();
    public string get_Name();
    public Type get_ImplementationType();
    public Type get_ServiceType();
    public T Get();
    public bool ObjectHasBeenCreated();
    public string DescribeBuildPlan();
    public object Resolve();
    public virtual string ToString();
}
internal class Lamar.Diagnostics.QueryModel : object {
    private Scope _scope;
    public IEnumerable`1<IServiceFamilyConfiguration> ServiceTypes { get; }
    public IEnumerable`1<InstanceRef> AllInstances { get; }
    public IEnumerable`1<AssemblyScanner> Scanners { get; }
    public QueryModel(Scope scope);
    public sealed virtual IServiceFamilyConfiguration For();
    public sealed virtual IServiceFamilyConfiguration For(Type type);
    public sealed virtual IEnumerable`1<IServiceFamilyConfiguration> get_ServiceTypes();
    public sealed virtual IEnumerable`1<InstanceRef> InstancesOf(Type serviceType);
    public sealed virtual IEnumerable`1<InstanceRef> InstancesOf();
    public sealed virtual Type DefaultTypeFor();
    public sealed virtual Type DefaultTypeFor(Type serviceType);
    public sealed virtual IEnumerable`1<InstanceRef> get_AllInstances();
    public sealed virtual T[] GetAllPossible();
    public sealed virtual bool HasRegistrationFor(Type serviceType);
    public sealed virtual bool HasRegistrationFor();
    public sealed virtual IEnumerable`1<AssemblyScanner> get_Scanners();
    [CompilerGeneratedAttribute]
private ServiceFamilyConfiguration <get_ServiceTypes>b__5_0(ServiceFamily x);
    [CompilerGeneratedAttribute]
private InstanceRef <get_AllInstances>b__11_0(Instance x);
}
public enum Lamar.DisposalLock : Enum {
    public int value__;
    public static DisposalLock Ignore;
    public static DisposalLock Unlocked;
    public static DisposalLock ThrowOnDispose;
}
public enum Lamar.DynamicAssemblySharing : Enum {
    public int value__;
    public static DynamicAssemblySharing Shared;
    public static DynamicAssemblySharing Individual;
}
internal class Lamar.EmptyFamilyPolicy : object {
    public sealed virtual ServiceFamily Build(Type type, ServiceGraph serviceGraph);
}
public interface Lamar.IActivationInterceptor`1 {
    public abstract virtual T Intercept(Type serviceType, T instance, IServiceContext scope);
}
public interface Lamar.IContainer {
    public abstract virtual INestedContainer GetNestedContainer();
    public abstract virtual void AssertConfigurationIsValid(AssertMode mode);
    public abstract virtual void Configure(IServiceCollection services);
    public abstract virtual void Configure(Action`1<IServiceCollection> configure);
}
public interface Lamar.IDecoratorPolicy {
    public abstract virtual bool TryWrap(Instance inner, Instance& wrapped);
}
[LamarIgnoreAttribute]
public interface Lamar.IFamilyPolicy {
    public abstract virtual ServiceFamily Build(Type type, ServiceGraph serviceGraph);
}
[AttributeUsageAttribute("1")]
public class Lamar.IgnoreAssemblyAttribute : Attribute {
}
public interface Lamar.IInstancePolicy {
    public abstract virtual void Apply(Instance instance);
}
public interface Lamar.ILamarPolicy {
}
internal interface Lamar.IMaybeIntercepted {
    public abstract virtual bool TryWrap(Instance& wrapped);
}
public interface Lamar.INestedContainer {
    public abstract virtual void Inject(Type serviceType, object object, bool replace);
    public abstract virtual void Inject(T object, bool replace);
    public abstract virtual void Inject(T object);
}
[ExtensionAttribute]
public static class Lamar.InstanceExtensions : object {
    [ExtensionAttribute]
public static T Named(T instance, string name);
    [ExtensionAttribute]
public static T Scoped(T instance);
    private static void AssertNotObjectInstance(T instance);
    [ExtensionAttribute]
public static T Singleton(T instance);
    [ExtensionAttribute]
public static T Transient(T instance);
}
public class Lamar.InstanceNameAttribute : LamarAttribute {
    private string _name;
    public InstanceNameAttribute(string name);
    public virtual void Alter(Instance instance);
}
internal class Lamar.IoC.Activation.ActivatingInstance`2 : LambdaInstance`2<Scope, TService> {
    private Instance _inner;
    public ActivatingInstance`2(Action`2<IServiceContext, TActual> action, Instance inner);
    protected virtual IEnumerable`1<Instance> createPlan(ServiceGraph services);
    internal virtual string GetBuildPlan(Scope rootScope);
    private static Func`2<Scope, TService> buildCreator(Action`2<IServiceContext, TActual> interceptor, Instance inner);
}
internal class Lamar.IoC.Activation.ActivationPolicy`1 : object {
    private Action`2<IServiceContext, T> _action;
    public ActivationPolicy`1(Action`2<IServiceContext, T> action);
    public sealed virtual bool TryWrap(Instance inner, Instance& wrapped);
    public virtual bool TestInstance(Instance inner);
}
internal class Lamar.IoC.Activation.InterceptingInstance`2 : LambdaInstance`2<Scope, TService> {
    private Instance _inner;
    public InterceptingInstance`2(Func`3<IServiceContext, TImplementation, TService> interceptor, Instance inner);
    protected virtual IEnumerable`1<Instance> createPlan(ServiceGraph services);
    internal virtual string GetBuildPlan(Scope rootScope);
    private static Func`2<Scope, TService> buildCreator(Func`3<IServiceContext, TImplementation, TService> interceptor, Instance inner);
}
internal class Lamar.IoC.Activation.InterceptorPolicy`1 : object {
    private Func`3<IServiceContext, T, T> _interceptor;
    public InterceptorPolicy`1(Func`3<IServiceContext, T, T> interceptor);
    public sealed virtual bool TryWrap(Instance inner, Instance& wrapped);
    public virtual bool TestInstance(Instance inner);
}
internal class Lamar.IoC.AsyncDisposableWrapper : object {
    private IAsyncDisposable _inner;
    public AsyncDisposableWrapper(IAsyncDisposable inner);
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual void Dispose();
}
public enum Lamar.IoC.BuildMode : Enum {
    public int value__;
    public static BuildMode Inline;
    public static BuildMode Dependency;
    public static BuildMode Build;
}
public class Lamar.IoC.ContainerValidationException : Exception {
    [CompilerGeneratedAttribute]
private string <WhatDoIHave>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WhatDidIScan>k__BackingField;
    public string WhatDoIHave { get; }
    public string WhatDidIScan { get; }
    public ContainerValidationException(string message, string whatDoIHave, string whatDidIScan);
    [CompilerGeneratedAttribute]
public string get_WhatDoIHave();
    [CompilerGeneratedAttribute]
public string get_WhatDidIScan();
}
internal class Lamar.IoC.Diagnostics.CharacterWidth : object {
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    internal int Width { get; private set; }
    [CompilerGeneratedAttribute]
internal int get_Width();
    [CompilerGeneratedAttribute]
private void set_Width(int value);
    internal static CharacterWidth[] For(int count);
    internal void SetWidth(int width);
    internal void Add(int add);
}
internal class Lamar.IoC.Diagnostics.DividerLine : object {
    private char _character;
    internal DividerLine(char character);
    public sealed virtual void OverwriteCounts(CharacterWidth[] widths);
    public sealed virtual void Write(TextWriter writer, CharacterWidth[] widths);
}
internal interface Lamar.IoC.Diagnostics.Line {
    public abstract virtual void OverwriteCounts(CharacterWidth[] widths);
    public abstract virtual void Write(TextWriter writer, CharacterWidth[] widths);
}
public class Lamar.IoC.Diagnostics.ModelQuery : object {
    public Assembly Assembly;
    public string Namespace;
    public Type ServiceType;
    public string TypeName;
    public IEnumerable`1<IServiceFamilyConfiguration> Query(IModel model);
    [CompilerGeneratedAttribute]
private bool <Query>b__4_0(IServiceFamilyConfiguration x);
    [CompilerGeneratedAttribute]
private bool <Query>b__4_1(IServiceFamilyConfiguration x);
    [CompilerGeneratedAttribute]
private bool <Query>b__4_2(IServiceFamilyConfiguration x);
    [CompilerGeneratedAttribute]
private bool <Query>b__4_3(IServiceFamilyConfiguration x);
}
internal class Lamar.IoC.Diagnostics.PlainLine : object {
    [CompilerGeneratedAttribute]
private string <Contents>k__BackingField;
    public string Contents { get; public set; }
    public PlainLine(string contents);
    [CompilerGeneratedAttribute]
public string get_Contents();
    [CompilerGeneratedAttribute]
public void set_Contents(string value);
    public sealed virtual void OverwriteCounts(CharacterWidth[] widths);
    public sealed virtual void Write(TextWriter writer, CharacterWidth[] widths);
}
internal class Lamar.IoC.Diagnostics.TextLine : object {
    private String[] _contents;
    internal TextLine(String[] contents);
    public sealed virtual void OverwriteCounts(CharacterWidth[] widths);
    public sealed virtual void Write(TextWriter writer, CharacterWidth[] widths);
}
public class Lamar.IoC.Diagnostics.TextReportWriter : object {
    private int _columnCount;
    private List`1<Line> _lines;
    public TextReportWriter(int columnCount);
    public void AddDivider(char character);
    public void AddText(String[] contents);
    public void AddContent(string contents);
    public void Write(StringWriter writer);
    public string Write();
    public void DumpToDebug();
}
public enum Lamar.IoC.Diagnostics.WhatDoIHaveDisplay : Enum {
    public int value__;
    public static WhatDoIHaveDisplay Summary;
    public static WhatDoIHaveDisplay BuildPlan;
}
public class Lamar.IoC.Diagnostics.WhatDoIHaveWriter : object {
    private IModel _graph;
    public WhatDoIHaveWriter(IModel graph);
    public string GetText(ModelQuery query, string title, WhatDoIHaveDisplay display);
    private void writeContentsOfServiceTypes(IEnumerable`1<IServiceFamilyConfiguration> serviceTypes, StringWriter writer, WhatDoIHaveDisplay display);
    private static void writeBuildPlan(IEnumerable`1<IServiceFamilyConfiguration> serviceTypes, StringWriter writer);
    private void writeSummary(IEnumerable`1<IServiceFamilyConfiguration> serviceTypes, StringWriter writer);
    private void writeServiceType(IServiceFamilyConfiguration serviceType, TextReportWriter reportWriter);
    private void writeInstance(InstanceRef instance, IServiceFamilyConfiguration serviceType, TextReportWriter reportWriter, List`1<InstanceRef> instanceRegistry);
    private void setContents(String[] contents, InstanceRef instance, List`1<InstanceRef> instanceRegistry);
}
[ExtensionAttribute]
public static class Lamar.IoC.Diagnostics.WriterExtensions : object {
    [ExtensionAttribute]
public static void WriteLine(TextWriter writer, int spaces, string text);
    [ExtensionAttribute]
public static string Line(int length, char character);
}
public class Lamar.IoC.Enumerables.ArrayInstance`1 : GeneratedInstance {
    [CompilerGeneratedAttribute]
private IList`1<Instance> <InlineDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private Instance[] <Elements>k__BackingField;
    public IList`1<Instance> InlineDependencies { get; }
    public Instance[] Elements { get; private set; }
    public ArrayInstance`1(Type serviceType);
    [CompilerGeneratedAttribute]
public IList`1<Instance> get_InlineDependencies();
    [CompilerGeneratedAttribute]
public sealed virtual Instance[] get_Elements();
    [CompilerGeneratedAttribute]
private void set_Elements(Instance[] value);
    public virtual Frame CreateBuildFrame();
    protected virtual Variable generateVariableForBuilding(ResolverVariables variables, BuildMode mode, bool isRoot);
    protected virtual IEnumerable`1<Instance> createPlan(ServiceGraph services);
    public virtual object QuickResolve(Scope scope);
    public void AddInline(Instance instance);
}
internal class Lamar.IoC.Enumerables.EnumerablePolicy : object {
    public sealed virtual ServiceFamily Build(Type type, ServiceGraph serviceGraph);
}
internal interface Lamar.IoC.Enumerables.IEnumerableInstance {
    public Instance[] Elements { get; }
    public Type ServiceType { get; }
    public abstract virtual Instance[] get_Elements();
    public abstract virtual Type get_ServiceType();
}
public class Lamar.IoC.Enumerables.ListInstance`1 : GeneratedInstance {
    [CompilerGeneratedAttribute]
private IList`1<Instance> <InlineDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private Instance[] <Elements>k__BackingField;
    public IList`1<Instance> InlineDependencies { get; }
    public Instance[] Elements { get; private set; }
    public ListInstance`1(Type serviceType);
    [CompilerGeneratedAttribute]
public IList`1<Instance> get_InlineDependencies();
    [CompilerGeneratedAttribute]
public sealed virtual Instance[] get_Elements();
    [CompilerGeneratedAttribute]
private void set_Elements(Instance[] value);
    public virtual Frame CreateBuildFrame();
    protected virtual Variable generateVariableForBuilding(ResolverVariables variables, BuildMode mode, bool isRoot);
    protected virtual IEnumerable`1<Instance> createPlan(ServiceGraph services);
    public virtual object QuickResolve(Scope scope);
    public void AddInline(Instance instance);
    public virtual string ToString();
}
public class Lamar.IoC.Frames.ArrayAssignmentFrame`1 : SyncFrame {
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private Variable[] <Elements>k__BackingField;
    [CompilerGeneratedAttribute]
private Variable <Variable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnCreated>k__BackingField;
    public Type ElementType { get; }
    public Variable[] Elements { get; }
    public Variable Variable { get; }
    public bool ReturnCreated { get; public set; }
    public ArrayAssignmentFrame`1(ArrayInstance`1<T> instance, Variable[] elements);
    [CompilerGeneratedAttribute]
public Type get_ElementType();
    [CompilerGeneratedAttribute]
public Variable[] get_Elements();
    [CompilerGeneratedAttribute]
public Variable get_Variable();
    [CompilerGeneratedAttribute]
public bool get_ReturnCreated();
    [CompilerGeneratedAttribute]
public void set_ReturnCreated(bool value);
    public sealed virtual void WriteExpressions(LambdaDefinition definition);
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
    public virtual IEnumerable`1<Variable> FindVariables(IMethodVariables chain);
}
public class Lamar.IoC.Frames.GetInstanceFrame : SyncFrame {
    private static MethodInfo _resolveMethod;
    private string _name;
    private Variable _scope;
    [CompilerGeneratedAttribute]
private ServiceVariable <Variable>k__BackingField;
    public ServiceVariable Variable { get; }
    public GetInstanceFrame(Instance instance);
    private static GetInstanceFrame();
    [CompilerGeneratedAttribute]
public ServiceVariable get_Variable();
    public sealed virtual void WriteExpressions(LambdaDefinition definition);
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
    [IteratorStateMachineAttribute("Lamar.IoC.Frames.GetInstanceFrame/<FindVariables>d__9")]
public virtual IEnumerable`1<Variable> FindVariables(IMethodVariables chain);
}
public class Lamar.IoC.Frames.GetInstanceFromNestedContainerFrame : SyncFrame {
    private Variable _nested;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ICodeFragment <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private Variable <Variable>k__BackingField;
    [NullableAttribute("2")]
public ICodeFragment Header { get; public set; }
    public Variable Variable { get; }
    public GetInstanceFromNestedContainerFrame(Variable nested, Type serviceType);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ICodeFragment get_Header();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Header(ICodeFragment value);
    [CompilerGeneratedAttribute]
public Variable get_Variable();
    public void Comment(string text);
    public void MultiLineComment(string text);
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
}
public class Lamar.IoC.Frames.GetServiceFrame : SyncFrame {
    private Variable _provider;
    [CompilerGeneratedAttribute]
private Variable <Variable>k__BackingField;
    public Variable Variable { get; }
    public GetServiceFrame(Variable provider, Type serviceType);
    [CompilerGeneratedAttribute]
public Variable get_Variable();
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
}
public class Lamar.IoC.Frames.InjectedServiceField : InjectedField {
    private bool _isOnlyOne;
    [CompilerGeneratedAttribute]
private Instance <Instance>k__BackingField;
    private bool IsOnlyOne { get; public set; }
    public string CtorArgDeclaration { get; }
    public Instance Instance { get; }
    public InjectedServiceField(Instance instance);
    private bool get_IsOnlyOne();
    public void set_IsOnlyOne(bool value);
    public virtual string get_CtorArgDeclaration();
    [CompilerGeneratedAttribute]
public sealed virtual Instance get_Instance();
    public virtual Expression ToVariableExpression(LambdaDefinition definition);
}
public interface Lamar.IoC.Frames.IServiceVariable {
    public Instance Instance { get; }
    public abstract virtual Instance get_Instance();
}
public class Lamar.IoC.Frames.ListAssignmentFrame`1 : Frame {
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private Variable[] <Elements>k__BackingField;
    [CompilerGeneratedAttribute]
private Variable <Variable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnCreated>k__BackingField;
    public Type ElementType { get; }
    public Variable[] Elements { get; }
    public Variable Variable { get; }
    public bool ReturnCreated { get; public set; }
    public ListAssignmentFrame`1(ListInstance`1<T> instance, Variable[] elements);
    [CompilerGeneratedAttribute]
public Type get_ElementType();
    [CompilerGeneratedAttribute]
public Variable[] get_Elements();
    [CompilerGeneratedAttribute]
public Variable get_Variable();
    [CompilerGeneratedAttribute]
public bool get_ReturnCreated();
    [CompilerGeneratedAttribute]
public void set_ReturnCreated(bool value);
    public sealed virtual void WriteExpressions(LambdaDefinition definition);
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
    public virtual IEnumerable`1<Variable> FindVariables(IMethodVariables chain);
}
public class Lamar.IoC.Frames.NestedContainerCreation : AsyncFrame {
    [CompilerGeneratedAttribute]
private Variable <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private Variable <Nested>k__BackingField;
    public Variable Root { get; }
    public Variable Nested { get; }
    [CompilerGeneratedAttribute]
public Variable get_Root();
    [CompilerGeneratedAttribute]
public Variable get_Nested();
    [IteratorStateMachineAttribute("Lamar.IoC.Frames.NestedContainerCreation/<FindVariables>d__7")]
public virtual IEnumerable`1<Variable> FindVariables(IMethodVariables chain);
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
}
public class Lamar.IoC.Frames.ResolverVariables : object {
    private List`1<Variable> _all;
    private Dictionary`2<Instance, Variable> _tracking;
    [CompilerGeneratedAttribute]
private int <VariableSequence>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodVariables <Method>k__BackingField;
    public int VariableSequence { get; public set; }
    public IMethodVariables Method { get; }
    public ResolverVariables(IMethodVariables method, IList`1<InjectedServiceField> fields);
    [CompilerGeneratedAttribute]
public int get_VariableSequence();
    [CompilerGeneratedAttribute]
public void set_VariableSequence(int value);
    [CompilerGeneratedAttribute]
public IMethodVariables get_Method();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<Variable> GetEnumerator();
    private sealed virtual override Variable JasperFx.CodeGeneration.Model.IMethodVariables.FindVariable(Type type);
    private sealed virtual override Variable JasperFx.CodeGeneration.Model.IMethodVariables.FindVariableByName(Type dependency, string name);
    private sealed virtual override bool JasperFx.CodeGeneration.Model.IMethodVariables.TryFindVariableByName(Type dependency, string name, Variable& variable);
    private sealed virtual override Variable JasperFx.CodeGeneration.Model.IMethodVariables.TryFindVariable(Type type, VariableSource source);
    public Variable Resolve(Instance instance, BuildMode mode);
    public void MakeNamesUnique();
}
public enum Lamar.IoC.Frames.ServiceDeclaration : Enum {
    public int value__;
    public static ServiceDeclaration ImplementationType;
    public static ServiceDeclaration ServiceType;
}
public class Lamar.IoC.Frames.ServiceScopeFactoryCreation : SyncFrame {
    private Variable _factory;
    private Variable _scope;
    [CompilerGeneratedAttribute]
private Variable <Provider>k__BackingField;
    public Variable Provider { get; }
    public ServiceScopeFactoryCreation(Variable factory);
    [CompilerGeneratedAttribute]
public Variable get_Provider();
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
}
public class Lamar.IoC.Frames.ServiceStandinVariable : Variable {
    private Variable _inner;
    [CompilerGeneratedAttribute]
private Instance <Instance>k__BackingField;
    public Instance Instance { get; }
    public string Usage { get; protected set; }
    public ServiceStandinVariable(Instance instance);
    [CompilerGeneratedAttribute]
public Instance get_Instance();
    public virtual string get_Usage();
    protected virtual void set_Usage(string value);
    public void UseInner(Variable variable);
    public virtual void OverrideName(string variableName);
    public virtual int GetHashCode();
}
public class Lamar.IoC.Frames.ServiceVariable : Variable {
    [CompilerGeneratedAttribute]
private Instance <Instance>k__BackingField;
    public Instance Instance { get; }
    public ServiceVariable(Instance instance, Frame creator, ServiceDeclaration declaration);
    [CompilerGeneratedAttribute]
public sealed virtual Instance get_Instance();
}
public class Lamar.IoC.Frames.ServiceVariableSource : object {
    public static string UsingNestedContainerDirectly;
    private IList`1<InjectedServiceField> _fields;
    private ServiceGraph _services;
    private IList`1<ServiceStandinVariable> _standins;
    private Variable _nested;
    private bool _usesNestedContainerDirectly;
    public ServiceVariableSource(ServiceGraph services);
    public sealed virtual bool Matches(Type type);
    public sealed virtual Variable Create(Type type);
    public sealed virtual void ReplaceVariables(IMethodVariables method);
    public sealed virtual void StartNewType();
    public sealed virtual void StartNewMethod();
    private void useInlineConstruction(IMethodVariables method);
    private void useServiceProvider(IMethodVariables method);
    [CompilerGeneratedAttribute]
private void <useInlineConstruction>b__12_0(InjectedServiceField field);
}
[ExtensionAttribute]
public static class Lamar.IoC.Frames.VariableExtensions : object {
    [ExtensionAttribute]
public static bool RefersTo(Variable variable, Instance instance);
}
public class Lamar.IoC.Instances.ConstructorInstance : GeneratedInstance {
    public static string NoPublicConstructors;
    public static string NoPublicConstructorCanBeFilled;
    private object _locker;
    private List`1<InjectedSetter> _setters;
    [CompilerGeneratedAttribute]
private CtorArg[] <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Instance> <InlineDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo <Constructor>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Instance> <Lamar.IoC.Instances.IConfiguredInstance.InlineDependencies>k__BackingField;
    public CtorArg[] Arguments { get; private set; }
    public IList`1<Instance> InlineDependencies { get; }
    internal IReadOnlyList`1<InjectedSetter> Setters { get; }
    public ConstructorInfo Constructor { get; public set; }
    private IReadOnlyList`1<Instance> Lamar.IoC.Instances.IConfiguredInstance.InlineDependencies { get; }
    public ConstructorInstance(Type serviceType, Type implementationType, ServiceLifetime lifetime);
    private static ConstructorInstance();
    [CompilerGeneratedAttribute]
public CtorArg[] get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(CtorArg[] value);
    [CompilerGeneratedAttribute]
public IList`1<Instance> get_InlineDependencies();
    internal IReadOnlyList`1<InjectedSetter> get_Setters();
    [CompilerGeneratedAttribute]
public sealed virtual ConstructorInfo get_Constructor();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Constructor(ConstructorInfo value);
    public sealed virtual void AddInline(Instance instance);
    public sealed virtual DependencyExpression`1<T> Ctor(string constructorArg);
    [CompilerGeneratedAttribute]
private sealed virtual override IReadOnlyList`1<Instance> Lamar.IoC.Instances.IConfiguredInstance.get_InlineDependencies();
    public static ConstructorInstance For(ServiceLifetime lifetime);
    public static ConstructorInstance`2<TConcrete, T> For(ServiceLifetime lifetime);
    public virtual Func`2<Scope, object> ToResolver(Scope topScope);
    public virtual object QuickResolve(Scope scope);
    private object quickResolve(Scope scope);
    public virtual Instance CloseType(Type serviceType, Type[] templateTypes);
    protected virtual Variable generateVariableForBuilding(ResolverVariables variables, BuildMode mode, bool isRoot);
    public virtual Frame CreateBuildFrame();
    private DisposeTracking determineDisposalTracking(BuildMode mode);
    protected virtual IEnumerable`1<Instance> createPlan(ServiceGraph services);
    internal InjectedSetter[] FindSetters(ServiceGraph services);
    private void findSetters(ServiceGraph services);
    private void buildOutConstructorArguments(ServiceGraph services);
    private CtorArg determineArgument(ServiceGraph services, ParameterInfo parameter);
    private Instance findInstanceForConstructorParameter(ServiceGraph services, ParameterInfo parameter, Type dependencyType);
    private Instance findInlineDependency(string name, Type dependencyType);
    public virtual string ToString();
    private static ConstructorInfo[] findConstructors(Type implementationType);
    private bool couldBuild(ConstructorInfo ctor, ServiceGraph services);
    public ConstructorInfo DetermineConstructor(ServiceGraph services, String& message);
    private static string explainWhyConstructorCannotBeUsed(Type implementationType, ConstructorInfo constructor, ServiceGraph services);
    public DependencyExpression`1<T> Setter(string propName);
    protected virtual IEnumerable`1<Assembly> relatedAssemblies();
}
public class Lamar.IoC.Instances.ConstructorInstance`2 : ConstructorInstance {
    private Func`3<IServiceContext, TImplementation, TService> _interceptor;
    public ConstructorInstance`2(Type serviceType, ServiceLifetime lifetime);
    private sealed virtual override bool Lamar.IMaybeIntercepted.TryWrap(Instance& wrapped);
    public ConstructorInstance`2<TImplementation, TService> SelectConstructor(Expression`1<Func`1<TImplementation>> constructor);
    public ConstructorInstance`2<TImplementation, TService> OnCreation(Func`2<TImplementation, TService> interceptor);
    public ConstructorInstance`2<TImplementation, TService> OnCreation(Func`3<IServiceContext, TImplementation, TService> interceptor);
    public ConstructorInstance`2<TImplementation, TService> OnCreation(Action`2<IServiceContext, TImplementation> activator);
    public ConstructorInstance`2<TImplementation, TService> OnCreation(Action`1<TImplementation> activator);
}
public class Lamar.IoC.Instances.CtorArg : object {
    [CompilerGeneratedAttribute]
private ParameterInfo <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Instance <Instance>k__BackingField;
    public ParameterInfo Parameter { get; }
    public Instance Instance { get; }
    public CtorArg(ParameterInfo parameter, Instance instance);
    [CompilerGeneratedAttribute]
public ParameterInfo get_Parameter();
    [CompilerGeneratedAttribute]
public Instance get_Instance();
    public Variable Resolve(ResolverVariables variables, BuildMode mode);
}
public class Lamar.IoC.Instances.DefaultVariable : Variable {
    public DefaultVariable(Type variableType);
    public virtual Expression ToVariableExpression(LambdaDefinition definition);
}
public class Lamar.IoC.Instances.DependencyExpression`1 : object {
    private ConstructorInstance _instance;
    private string _propertyName;
    internal DependencyExpression`1(ConstructorInstance instance, string propertyName);
    public ConstructorInstance Is(Func`2<IServiceContext, TChild> func);
    public ConstructorInstance Is(string description, Func`2<IServiceContext, TChild> func);
    public ConstructorInstance Is(Instance instance);
    public ConstructorInstance Is(TChild value);
    public ConstructorInstance IsNamedInstance(string instanceKey);
    public ConstructorInstance Is();
    public ConstructorInstance IsNull();
    public ConstructorInstance Is(Action`1<ConstructorInstance`2<TConcreteType, TChild>> configure);
    public ConstructorInstance Named(string name);
}
public enum Lamar.IoC.Instances.DisposeTracking : Enum {
    public int value__;
    public static DisposeTracking WithUsing;
    public static DisposeTracking RegisterWithScope;
    public static DisposeTracking None;
}
public class Lamar.IoC.Instances.ErrorMessageResolver : object {
    private string _message;
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Hash>k__BackingField;
    public Type ServiceType { get; }
    public string Name { get; public set; }
    public int Hash { get; public set; }
    public ErrorMessageResolver(Instance instance);
    public sealed virtual object Resolve(Scope scope);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ServiceType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Hash();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Hash(int value);
}
public class Lamar.IoC.Instances.FuncResolverDefinition : object {
    private FramesCollection _frames;
    private GenerationRules _rules;
    private Scope _scope;
    private Argument _scopeArgument;
    [CompilerGeneratedAttribute]
private IList`1<Variable> <JasperFx.CodeGeneration.IGeneratedMethod.DerivedVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IVariableSource> <JasperFx.CodeGeneration.IGeneratedMethod.Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Setter> <JasperFx.CodeGeneration.IGeneratedType.Setters>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<InjectedField> <JasperFx.CodeGeneration.IGeneratedType.AllInjectedFields>k__BackingField;
    private FramesCollection JasperFx.CodeGeneration.IGeneratedMethod.Frames { get; }
    public Argument[] Arguments { get; }
    private IList`1<Variable> JasperFx.CodeGeneration.IGeneratedMethod.DerivedVariables { get; }
    private IList`1<IVariableSource> JasperFx.CodeGeneration.IGeneratedMethod.Sources { get; }
    public string MethodName { get; }
    private IList`1<Setter> JasperFx.CodeGeneration.IGeneratedType.Setters { get; }
    private IList`1<InjectedField> JasperFx.CodeGeneration.IGeneratedType.AllInjectedFields { get; }
    private GenerationRules JasperFx.CodeGeneration.IGeneratedType.Rules { get; }
    public string TypeName { get; }
    public FuncResolverDefinition(GeneratedInstance instance, Scope scope, GenerationRules rules);
    private sealed virtual override FramesCollection JasperFx.CodeGeneration.IGeneratedMethod.get_Frames();
    public sealed virtual Argument[] get_Arguments();
    [CompilerGeneratedAttribute]
private sealed virtual override IList`1<Variable> JasperFx.CodeGeneration.IGeneratedMethod.get_DerivedVariables();
    [CompilerGeneratedAttribute]
private sealed virtual override IList`1<IVariableSource> JasperFx.CodeGeneration.IGeneratedMethod.get_Sources();
    public sealed virtual string get_MethodName();
    [CompilerGeneratedAttribute]
private sealed virtual override IList`1<Setter> JasperFx.CodeGeneration.IGeneratedType.get_Setters();
    [CompilerGeneratedAttribute]
private sealed virtual override IList`1<InjectedField> JasperFx.CodeGeneration.IGeneratedType.get_AllInjectedFields();
    private sealed virtual override GenerationRules JasperFx.CodeGeneration.IGeneratedType.get_Rules();
    public sealed virtual string get_TypeName();
    public Func`2<Scope, object> BuildResolver();
}
public abstract class Lamar.IoC.Instances.GeneratedInstance : Instance {
    private object _locker;
    protected Func`2<Scope, object> _resolver;
    public Type ResolverBaseType { get; }
    protected GeneratedInstance(Type serviceType, Type implementationType, ServiceLifetime lifetime);
    public Type get_ResolverBaseType();
    internal ValueTuple`2<string, string> GenerateResolverClassCode(GeneratedAssembly generatedAssembly);
    public string GetResolverTypeName();
    [IteratorStateMachineAttribute("Lamar.IoC.Instances.GeneratedInstance/<relatedAssemblies>d__7")]
protected virtual IEnumerable`1<Assembly> relatedAssemblies();
    public sealed virtual Variable CreateVariable(BuildMode mode, ResolverVariables variables, bool isRoot);
    public Func`2<Scope, object> BuildFuncResolver(Scope scope);
    public abstract virtual Frame CreateBuildFrame();
    protected abstract virtual Variable generateVariableForBuilding(ResolverVariables variables, BuildMode mode, bool isRoot);
    public virtual Func`2<Scope, object> ToResolver(Scope topScope);
    public virtual object Resolve(Scope scope);
    private void buildResolver(Scope scope);
    internal virtual string GetBuildPlan(Scope rootScope);
}
public static class Lamar.IoC.Instances.GenericsPluginGraph : object {
    public static bool CanBeCast(Type serviceType, Type implementationType);
    private static bool checkGenericType(Type pluggedType, Type pluginType);
}
public interface Lamar.IoC.Instances.IConfiguredInstance {
    public ConstructorInfo Constructor { get; public set; }
    public Type ServiceType { get; }
    public Type ImplementationType { get; }
    public ServiceLifetime Lifetime { get; public set; }
    public string Name { get; public set; }
    public IReadOnlyList`1<Instance> InlineDependencies { get; }
    public abstract virtual ConstructorInfo get_Constructor();
    public abstract virtual void set_Constructor(ConstructorInfo value);
    public abstract virtual Type get_ServiceType();
    public abstract virtual Type get_ImplementationType();
    public abstract virtual ServiceLifetime get_Lifetime();
    public abstract virtual void set_Lifetime(ServiceLifetime value);
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual IReadOnlyList`1<Instance> get_InlineDependencies();
    public abstract virtual DependencyExpression`1<T> Ctor(string constructorArg);
    public abstract virtual void AddInline(Instance instance);
}
public class Lamar.IoC.Instances.InjectedInstance`1 : Instance {
    public virtual Func`2<Scope, object> ToResolver(Scope topScope);
    public virtual object Resolve(Scope scope);
    public virtual Variable CreateVariable(BuildMode mode, ResolverVariables variables, bool isRoot);
}
public class Lamar.IoC.Instances.InlineLambdaCreationFrame`1 : SyncFrame {
    private Setter _setter;
    private Variable _scope;
    [CompilerGeneratedAttribute]
private ServiceVariable <Variable>k__BackingField;
    public ServiceVariable Variable { get; }
    public InlineLambdaCreationFrame`1(Setter setter, Instance instance);
    [CompilerGeneratedAttribute]
public ServiceVariable get_Variable();
    public sealed virtual void WriteExpressions(LambdaDefinition definition);
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
    [IteratorStateMachineAttribute("Lamar.IoC.Instances.InlineLambdaCreationFrame`1/<FindVariables>d__8")]
public virtual IEnumerable`1<Variable> FindVariables(IMethodVariables chain);
}
public abstract class Lamar.IoC.Instances.Instance : object {
    public IList`1<string> ErrorMessages;
    private string _name;
    [CompilerGeneratedAttribute]
private bool <IsOnlyOneOfServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExplicitlyNamed>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ImplementationType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceLifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InlineIsLimitedToExactNameMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasPlanned>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PlanningSucceeded>k__BackingField;
    [CompilerGeneratedAttribute]
private Instance[] <ImmediateDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private Instance[] <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private Instance <Parent>k__BackingField;
    public bool IsOnlyOneOfServiceType { get; public set; }
    public bool IsExplicitlyNamed { get; public set; }
    public Type ServiceType { get; }
    public Type ImplementationType { get; }
    public int Hash { get; public set; }
    public ServiceLifetime Lifetime { get; public set; }
    public string Name { get; public set; }
    internal bool InlineIsLimitedToExactNameMatch { get; internal set; }
    public bool HasPlanned { get; protected internal set; }
    public bool PlanningSucceeded { get; protected internal set; }
    public Instance[] ImmediateDependencies { get; private set; }
    public Instance[] Dependencies { get; protected set; }
    public bool IsDefault { get; public set; }
    internal Instance Parent { get; internal set; }
    protected Instance(Type serviceType, Type implementationType, ServiceLifetime lifetime);
    [CompilerGeneratedAttribute]
public bool get_IsOnlyOneOfServiceType();
    [CompilerGeneratedAttribute]
public void set_IsOnlyOneOfServiceType(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsExplicitlyNamed();
    [CompilerGeneratedAttribute]
public void set_IsExplicitlyNamed(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ServiceType();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ImplementationType();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Hash();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Hash(int value);
    [CompilerGeneratedAttribute]
public sealed virtual ServiceLifetime get_Lifetime();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Lifetime(ServiceLifetime value);
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
internal bool get_InlineIsLimitedToExactNameMatch();
    [CompilerGeneratedAttribute]
internal void set_InlineIsLimitedToExactNameMatch(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasPlanned();
    [CompilerGeneratedAttribute]
protected internal void set_HasPlanned(bool value);
    [CompilerGeneratedAttribute]
public bool get_PlanningSucceeded();
    [CompilerGeneratedAttribute]
protected internal void set_PlanningSucceeded(bool value);
    [CompilerGeneratedAttribute]
public Instance[] get_ImmediateDependencies();
    [CompilerGeneratedAttribute]
private void set_ImmediateDependencies(Instance[] value);
    [CompilerGeneratedAttribute]
public Instance[] get_Dependencies();
    [CompilerGeneratedAttribute]
protected void set_Dependencies(Instance[] value);
    [CompilerGeneratedAttribute]
public bool get_IsDefault();
    [CompilerGeneratedAttribute]
public void set_IsDefault(bool value);
    [CompilerGeneratedAttribute]
internal Instance get_Parent();
    [CompilerGeneratedAttribute]
internal void set_Parent(Instance value);
    public abstract virtual Func`2<Scope, object> ToResolver(Scope topScope);
    public ServiceDescriptor ToDescriptor();
    public string DefaultArgName();
    [IteratorStateMachineAttribute("Lamar.IoC.Instances.Instance/<ReferencedAssemblies>d__59")]
internal IEnumerable`1<Assembly> ReferencedAssemblies();
    public static Instance For(ServiceDescriptor service);
    public static bool CanBeCastTo(Type implementationType, Type serviceType);
    public abstract virtual object Resolve(Scope scope);
    public virtual object QuickResolve(Scope scope);
    public virtual string WhyRequireServiceProvider(IMethodVariables method);
    public virtual bool RequiresServiceProvider(IMethodVariables method);
    public void CreatePlan(ServiceGraph services);
    public virtual void Reset();
    public abstract virtual Variable CreateVariable(BuildMode mode, ResolverVariables variables, bool isRoot);
    public virtual Variable CreateInlineVariable(ResolverVariables variables);
    protected virtual IEnumerable`1<Instance> createPlan(ServiceGraph services);
    public bool DependsOn(Type dependencyType);
    protected bool tryGetService(Scope scope, Object& service);
    protected void store(Scope scope, object service);
    internal virtual string GetBuildPlan(Scope rootScope);
    public sealed virtual int GetHashCode();
    public static int HashCode(Type serviceType, string name);
    public virtual Instance CloseType(Type serviceType, Type[] templateTypes);
    public bool IsInlineDependency();
    protected string inlineSetterName();
    [CompilerGeneratedAttribute]
private bool <CreatePlan>b__66_0(Instance x);
}
public class Lamar.IoC.Instances.InstanceConstructorFrame : ConstructorFrame {
    [CompilerGeneratedAttribute]
private DisposeTracking <Disposal>k__BackingField;
    public DisposeTracking Disposal { get; public set; }
    public InstanceConstructorFrame(ConstructorInstance instance, DisposeTracking disposal, Variable[] arguments, SetterArg[] setterParameters);
    [CompilerGeneratedAttribute]
public DisposeTracking get_Disposal();
    [CompilerGeneratedAttribute]
public void set_Disposal(DisposeTracking value);
    public sealed virtual void WriteExpressions(LambdaDefinition definition);
}
[ExtensionAttribute]
public static class Lamar.IoC.Instances.LambdaDefinitionExtensions : object {
    private static MethodInfo _tryRegisterDisposable;
    private static LambdaDefinitionExtensions();
    [ExtensionAttribute]
public static void RegisterDisposable(LambdaDefinition definition, Expression parameter, Type variableType);
    [ExtensionAttribute]
public static void TryRegisterDisposable(LambdaDefinition definition, Expression parameter);
    [ExtensionAttribute]
public static Expression Scope(LambdaDefinition definition);
}
public class Lamar.IoC.Instances.LambdaInstance : LambdaInstance`2<IServiceProvider, object> {
    public LambdaInstance(Type serviceType, Func`2<IServiceProvider, object> factory, ServiceLifetime lifetime);
    public static LambdaInstance`2<TContainer, TReturn> For(Func`2<TContainer, TReturn> func);
    public static LambdaInstance For(Func`2<IServiceProvider, T> factory, ServiceLifetime lifetime);
}
public class Lamar.IoC.Instances.LambdaInstance`2 : Instance {
    private object _locker;
    private IResolver _resolver;
    [CompilerGeneratedAttribute]
private Func`2<TContainer, TReturn> <Factory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public Func`2<TContainer, TReturn> Factory { get; }
    public string Description { get; public set; }
    public LambdaInstance`2(Type serviceType, Func`2<TContainer, TReturn> factory, ServiceLifetime lifetime);
    [CompilerGeneratedAttribute]
public Func`2<TContainer, TReturn> get_Factory();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    public virtual bool RequiresServiceProvider(IMethodVariables method);
    public virtual string WhyRequireServiceProvider(IMethodVariables method);
    public virtual Variable CreateVariable(BuildMode mode, ResolverVariables variables, bool isRoot);
    public virtual Variable CreateInlineVariable(ResolverVariables variables);
    public virtual Func`2<Scope, object> ToResolver(Scope topScope);
    public virtual object Resolve(Scope scope);
    protected IResolver buildResolver(Scope rootScope);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private object <ToResolver>b__14_0(Scope scope);
}
public class Lamar.IoC.Instances.NullInstance : Instance {
    public NullInstance(Type serviceType);
    public virtual Func`2<Scope, object> ToResolver(Scope topScope);
    public virtual object Resolve(Scope scope);
    public virtual Variable CreateVariable(BuildMode mode, ResolverVariables variables, bool isRoot);
}
public class Lamar.IoC.Instances.NullVariable : Variable {
    public NullVariable(Type variableType);
    public virtual void OverrideName(string variableName);
}
public class Lamar.IoC.Instances.ObjectInstance : Instance {
    [CompilerGeneratedAttribute]
private object <Service>k__BackingField;
    public object Service { get; }
    public ObjectInstance(Type serviceType, object service);
    [CompilerGeneratedAttribute]
public object get_Service();
    public sealed virtual void Dispose();
    public static ObjectInstance For(T object);
    public virtual Variable CreateVariable(BuildMode mode, ResolverVariables variables, bool isRoot);
    public virtual Func`2<Scope, object> ToResolver(Scope topScope);
    public virtual object Resolve(Scope scope);
    public virtual object QuickResolve(Scope scope);
    public virtual Variable CreateInlineVariable(ResolverVariables variables);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private object <ToResolver>b__7_0(Scope s);
}
public class Lamar.IoC.Instances.ReferencedInstance : Instance {
    private string _instanceKey;
    private Instance _inner;
    public ReferencedInstance(Type serviceType, string instanceKey);
    public virtual Func`2<Scope, object> ToResolver(Scope topScope);
    public virtual object Resolve(Scope scope);
    public virtual Variable CreateVariable(BuildMode mode, ResolverVariables variables, bool isRoot);
    public virtual object QuickResolve(Scope scope);
    public virtual bool RequiresServiceProvider(IMethodVariables method);
    public virtual string WhyRequireServiceProvider(IMethodVariables method);
    public virtual Variable CreateInlineVariable(ResolverVariables variables);
    [IteratorStateMachineAttribute("Lamar.IoC.Instances.ReferencedInstance/<createPlan>d__10")]
protected virtual IEnumerable`1<Instance> createPlan(ServiceGraph services);
    internal virtual string GetBuildPlan(Scope rootScope);
    public virtual Instance CloseType(Type serviceType, Type[] templateTypes);
}
public class Lamar.IoC.Instances.SetterWrappedServiceVariable : ServiceVariable {
    private Setter _setter;
    public SetterWrappedServiceVariable(Setter setter, Instance instance, Frame creator, ServiceDeclaration declaration);
    public virtual void OverrideName(string variableName);
}
public class Lamar.IoC.LamarException : Exception {
    public LamarException(string message);
    public LamarException(string message, Exception innerException);
}
public class Lamar.IoC.LamarInstanceHashCollisionException : LamarException {
    [CompilerGeneratedAttribute]
private int <InstanceHash>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <ServiceTypes>k__BackingField;
    public int InstanceHash { get; }
    public IEnumerable`1<Type> ServiceTypes { get; }
    public LamarInstanceHashCollisionException(int instanceHash, IEnumerable`1<Type> serviceTypes);
    [CompilerGeneratedAttribute]
public int get_InstanceHash();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_ServiceTypes();
}
public class Lamar.IoC.LamarMissingRegistrationException : LamarException {
    public LamarMissingRegistrationException(Type serviceType, string name);
    public LamarMissingRegistrationException(Type serviceType);
    public LamarMissingRegistrationException(ServiceFamily family);
}
internal class Lamar.IoC.Lazy.FuncByNameInstance`1 : Instance {
    public virtual Variable CreateVariable(BuildMode mode, ResolverVariables variables, bool isRoot);
    public virtual bool RequiresServiceProvider(IMethodVariables method);
    public virtual string WhyRequireServiceProvider(IMethodVariables method);
    public virtual Func`2<Scope, object> ToResolver(Scope topScope);
    public virtual object Resolve(Scope scope);
}
internal class Lamar.IoC.Lazy.FuncInstance`1 : Instance {
    public virtual Variable CreateVariable(BuildMode mode, ResolverVariables variables, bool isRoot);
    public virtual string WhyRequireServiceProvider(IMethodVariables method);
    public virtual bool RequiresServiceProvider(IMethodVariables method);
    public virtual Func`2<Scope, object> ToResolver(Scope topScope);
    public virtual object Resolve(Scope scope);
}
internal class Lamar.IoC.Lazy.FuncOrLazyPolicy : object {
    public sealed virtual ServiceFamily Build(Type type, ServiceGraph serviceGraph);
}
internal class Lamar.IoC.Lazy.GetFuncByNameFrame : TemplateFrame {
    private static MethodInfo _openMethod;
    private Type _serviceType;
    private object _scope;
    [CompilerGeneratedAttribute]
private Variable <Variable>k__BackingField;
    public Variable Variable { get; }
    public GetFuncByNameFrame(Instance instance, Type innerType);
    private static GetFuncByNameFrame();
    [CompilerGeneratedAttribute]
public Variable get_Variable();
    public sealed virtual void WriteExpressions(LambdaDefinition definition);
    protected virtual string Template();
}
internal class Lamar.IoC.Lazy.GetFuncFrame : TemplateFrame {
    private static MethodInfo _openMethod;
    private Type _serviceType;
    private object _scope;
    [CompilerGeneratedAttribute]
private Variable <Variable>k__BackingField;
    public Variable Variable { get; }
    public GetFuncFrame(Instance instance, Type innerType);
    private static GetFuncFrame();
    [CompilerGeneratedAttribute]
public Variable get_Variable();
    public sealed virtual void WriteExpressions(LambdaDefinition definition);
    protected virtual string Template();
}
internal class Lamar.IoC.Lazy.GetLazyFrame : TemplateFrame {
    private static MethodInfo _openMethod;
    private Type _serviceType;
    private object _scope;
    [CompilerGeneratedAttribute]
private Variable <Variable>k__BackingField;
    public Variable Variable { get; }
    public GetLazyFrame(Instance instance, Type innerType);
    private static GetLazyFrame();
    [CompilerGeneratedAttribute]
public Variable get_Variable();
    public sealed virtual void WriteExpressions(LambdaDefinition definition);
    protected virtual string Template();
}
internal class Lamar.IoC.Lazy.LazyInstance`1 : Instance {
    public virtual object Resolve(Scope scope);
    public virtual Variable CreateVariable(BuildMode mode, ResolverVariables variables, bool isRoot);
    public virtual bool RequiresServiceProvider(IMethodVariables method);
    public virtual string WhyRequireServiceProvider(IMethodVariables method);
    public virtual Func`2<Scope, object> ToResolver(Scope topScope);
}
public class Lamar.IoC.Resolvers.CastRootScopeFrame : SyncFrame {
    private Variable _scope;
    [CompilerGeneratedAttribute]
private Variable <Variable>k__BackingField;
    public Variable Variable { get; }
    public CastRootScopeFrame(Type interfaceType);
    [CompilerGeneratedAttribute]
public Variable get_Variable();
    public sealed virtual void WriteExpressions(LambdaDefinition definition);
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
    [IteratorStateMachineAttribute("Lamar.IoC.Resolvers.CastRootScopeFrame/<FindVariables>d__7")]
public virtual IEnumerable`1<Variable> FindVariables(IMethodVariables chain);
}
internal class Lamar.IoC.Resolvers.CastScopeFrame : SyncFrame {
    private Variable _scope;
    [CompilerGeneratedAttribute]
private Variable <Variable>k__BackingField;
    public Variable Variable { get; }
    public CastScopeFrame(Type interfaceType);
    [CompilerGeneratedAttribute]
public Variable get_Variable();
    public sealed virtual void WriteExpressions(LambdaDefinition definition);
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
    [IteratorStateMachineAttribute("Lamar.IoC.Resolvers.CastScopeFrame/<FindVariables>d__7")]
public virtual IEnumerable`1<Variable> FindVariables(IMethodVariables chain);
}
public interface Lamar.IoC.Resolvers.IResolver {
    public Type ServiceType { get; }
    public string Name { get; public set; }
    public int Hash { get; public set; }
    public abstract virtual Type get_ServiceType();
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual int get_Hash();
    public abstract virtual void set_Hash(int value);
    public abstract virtual object Resolve(Scope scope);
}
public class Lamar.IoC.Resolvers.RootScopeInstance`1 : Instance {
    public virtual object Resolve(Scope scope);
    public virtual Variable CreateVariable(BuildMode mode, ResolverVariables variables, bool isRoot);
    public virtual Func`2<Scope, object> ToResolver(Scope topScope);
    public virtual string ToString();
}
public class Lamar.IoC.Resolvers.ScopedLambdaResolver`2 : ScopedResolver`1<T> {
    private Func`2<TContainer, T> _builder;
    public ScopedLambdaResolver`2(Func`2<TContainer, T> builder);
    public virtual T Build(Scope scope);
}
public abstract class Lamar.IoC.Resolvers.ScopedResolver`1 : object {
    private object _locker;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Hash>k__BackingField;
    public Type ServiceType { get; }
    public string Name { get; public set; }
    public int Hash { get; public set; }
    public sealed virtual Type get_ServiceType();
    public sealed virtual object Resolve(Scope scope);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Hash();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Hash(int value);
    public abstract virtual T Build(Scope scope);
}
public class Lamar.IoC.Resolvers.ScopeInstance`1 : Instance {
    public virtual object Resolve(Scope scope);
    public virtual Variable CreateVariable(BuildMode mode, ResolverVariables variables, bool isRoot);
    public virtual Func`2<Scope, object> ToResolver(Scope topScope);
    public virtual string ToString();
}
public class Lamar.IoC.Resolvers.ScopeResolver : object {
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Hash>k__BackingField;
    public Type ServiceType { get; }
    public string Name { get; public set; }
    public int Hash { get; public set; }
    public sealed virtual object Resolve(Scope scope);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ServiceType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Hash();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Hash(int value);
}
public class Lamar.IoC.Resolvers.SingletonLambdaResolver`2 : SingletonResolver`1<T> {
    private Func`2<TContainer, T> _builder;
    public SingletonLambdaResolver`2(Func`2<TContainer, T> builder, Scope topLevelScope);
    public virtual T Build(Scope scope);
}
public abstract class Lamar.IoC.Resolvers.SingletonResolver`1 : object {
    private object _locker;
    private Scope _topLevelScope;
    private T _service;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Hash>k__BackingField;
    public Type ServiceType { get; }
    public string Name { get; public set; }
    public int Hash { get; public set; }
    public SingletonResolver`1(Scope topLevelScope);
    public sealed virtual Type get_ServiceType();
    public sealed virtual object Resolve(Scope scope);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Hash();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Hash(int value);
    public abstract virtual T Build(Scope scope);
}
public class Lamar.IoC.Resolvers.TransientLambdaResolver`2 : TransientResolver`1<T> {
    private Func`2<TContainer, T> _builder;
    public TransientLambdaResolver`2(Func`2<TContainer, T> builder);
    public virtual T Build(Scope scope);
}
public abstract class Lamar.IoC.Resolvers.TransientResolver`1 : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Hash>k__BackingField;
    public Type ServiceType { get; }
    public string Name { get; public set; }
    public int Hash { get; public set; }
    public sealed virtual object Resolve(Scope scope);
    public sealed virtual Type get_ServiceType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Hash();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Hash(int value);
    public abstract virtual T Build(Scope scope);
}
public class Lamar.IoC.Scope : object {
    protected bool _hasDisposed;
    private Dictionary`2<Type, object> _injected;
    internal ImHashMap`2<int, object> Services;
    [CompilerGeneratedAttribute]
private Scope <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private DisposalLock <DisposalLock>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceGraph <ServiceGraph>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentBag`1<IDisposable> <Disposables>k__BackingField;
    public Scope Root { get; protected set; }
    public DisposalLock DisposalLock { get; public set; }
    internal ServiceGraph ServiceGraph { get; internal set; }
    public ConcurrentBag`1<IDisposable> Disposables { get; }
    internal IEnumerable`1<IDisposable> AllDisposables { get; }
    public IServiceProvider ServiceProvider { get; }
    public IModel Model { get; }
    public Scope(IServiceCollection services);
    public Scope(ServiceGraph serviceGraph, Scope root);
    [CompilerGeneratedAttribute]
public Scope get_Root();
    [CompilerGeneratedAttribute]
protected void set_Root(Scope value);
    [CompilerGeneratedAttribute]
public DisposalLock get_DisposalLock();
    [CompilerGeneratedAttribute]
public void set_DisposalLock(DisposalLock value);
    [CompilerGeneratedAttribute]
internal ServiceGraph get_ServiceGraph();
    [CompilerGeneratedAttribute]
internal void set_ServiceGraph(ServiceGraph value);
    [CompilerGeneratedAttribute]
public ConcurrentBag`1<IDisposable> get_Disposables();
    internal IEnumerable`1<IDisposable> get_AllDisposables();
    public sealed virtual IServiceProvider get_ServiceProvider();
    public sealed virtual IModel get_Model();
    public virtual void Dispose();
    [AsyncStateMachineAttribute("Lamar.IoC.Scope/<DisposeAsync>d__28")]
public virtual ValueTask DisposeAsync();
    public sealed virtual object GetService(Type serviceType);
    public sealed virtual T GetInstance();
    public sealed virtual T GetInstance(string name);
    public sealed virtual object GetInstance(Type serviceType);
    public sealed virtual object GetInstance(Type serviceType, string name);
    public sealed virtual T TryGetInstance();
    public sealed virtual T TryGetInstance(string name);
    public sealed virtual object TryGetInstance(Type serviceType);
    public sealed virtual object TryGetInstance(Type serviceType, string name);
    public sealed virtual T QuickBuild();
    public sealed virtual object QuickBuild(Type objectType);
    public sealed virtual IReadOnlyList`1<T> QuickBuildAll();
    public sealed virtual IReadOnlyList`1<T> GetAllInstances();
    public sealed virtual IEnumerable GetAllInstances(Type serviceType);
    public sealed virtual string WhatDoIHave(Type serviceType, Assembly assembly, string namespace, string typeName);
    public sealed virtual string HowDoIBuild(Type serviceType, Assembly assembly, string namespace, string typeName);
    public sealed virtual string WhatDidIScan();
    public sealed virtual IServiceVariableSource CreateServiceVariableSource();
    public sealed virtual bool IsService(Type serviceType);
    public static Scope Empty();
    protected void assertNotDisposed();
    public void BuildUp(object target);
    public string GenerateCodeWithInlineServices(GeneratedAssembly assembly);
    public virtual void Inject(Type serviceType, object object, bool replace);
    public sealed virtual void Inject(T object);
    public sealed virtual void Inject(T object, bool replace);
    public T GetInjected();
    public void TryAddDisposable(object object);
    public Func`2<string, T> FactoryByNameFor();
    public Func`1<T> FactoryFor();
    public Lazy`1<T> LazyFor();
    public sealed virtual object GetKeyedService(Type serviceType, object serviceKey);
    public sealed virtual object GetRequiredKeyedService(Type serviceType, object serviceKey);
    [CompilerGeneratedAttribute]
private object <QuickBuildAll>b__40_0(Instance x);
    [CompilerGeneratedAttribute]
private object <GetAllInstances>b__41_0(Instance x);
    [CompilerGeneratedAttribute]
private object <GetAllInstances>b__42_0(Instance x);
}
internal class Lamar.IoC.Setters.InjectedSetter : object {
    [CompilerGeneratedAttribute]
private PropertyInfo <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private Instance <Instance>k__BackingField;
    public PropertyInfo Property { get; }
    public Instance Instance { get; }
    public InjectedSetter(PropertyInfo property, Instance instance);
    [CompilerGeneratedAttribute]
public PropertyInfo get_Property();
    [CompilerGeneratedAttribute]
public Instance get_Instance();
    public void ApplyQuickBuildProperties(object service, Scope scope);
    public SetterArg Resolve(ResolverVariables variables, BuildMode mode);
}
public interface Lamar.IoC.Setters.ISetterPolicy {
    public abstract virtual bool Matches(PropertyInfo prop);
}
public class Lamar.IoC.Setters.LambdaSetterPolicy : object {
    private Func`2<PropertyInfo, bool> _match;
    public LambdaSetterPolicy(Func`2<PropertyInfo, bool> match);
    public sealed virtual bool Matches(PropertyInfo prop);
}
public class Lamar.IoC.Setters.SetterConvention : object {
    private PoliciesExpression _parent;
    public SetterConvention(PoliciesExpression parent);
    public void OfType();
    public void TypeMatches(Predicate`1<Type> predicate);
    public void Matching(Func`2<PropertyInfo, bool> rule);
    public void WithAnyTypeFromNamespace(string nameSpace);
    public void WithAnyTypeFromNamespaceContainingType();
    public void NameMatches(Predicate`1<string> rule);
}
[ExtensionAttribute]
internal static class Lamar.IoC.StringExtensions : object {
    [ExtensionAttribute]
public static string Sanitize(string value);
}
public interface Lamar.IRegistrationPolicy {
    public abstract virtual void Apply(ServiceRegistry services);
}
public interface Lamar.IServiceContext {
    public IModel Model { get; }
    public abstract virtual IModel get_Model();
    public abstract virtual T GetInstance();
    public abstract virtual T GetInstance(string name);
    public abstract virtual object GetInstance(Type serviceType);
    public abstract virtual object GetInstance(Type serviceType, string name);
    public abstract virtual T TryGetInstance();
    public abstract virtual T TryGetInstance(string name);
    public abstract virtual object TryGetInstance(Type serviceType);
    public abstract virtual object TryGetInstance(Type serviceType, string name);
    public abstract virtual T QuickBuild();
    public abstract virtual object QuickBuild(Type objectType);
    public abstract virtual IReadOnlyList`1<T> QuickBuildAll();
    public abstract virtual IReadOnlyList`1<T> GetAllInstances();
    public abstract virtual IEnumerable GetAllInstances(Type serviceType);
    public abstract virtual string WhatDoIHave(Type serviceType, Assembly assembly, string namespace, string typeName);
    public abstract virtual string WhatDidIScan();
    public abstract virtual IServiceVariableSource CreateServiceVariableSource();
    public abstract virtual string HowDoIBuild(Type serviceType, Assembly assembly, string namespace, string typeName);
}
public interface Lamar.IServiceFamilyConfiguration {
    public Type ServiceType { get; }
    public InstanceRef Default { get; }
    public IEnumerable`1<InstanceRef> Instances { get; }
    public abstract virtual Type get_ServiceType();
    public abstract virtual InstanceRef get_Default();
    public abstract virtual IEnumerable`1<InstanceRef> get_Instances();
    public abstract virtual bool HasImplementations();
}
public interface Lamar.IStub {
}
public abstract class Lamar.LamarAttribute : Attribute {
    public virtual void Alter(IConfiguredInstance instance);
    public virtual void Alter(Instance instance);
}
[AttributeUsageAttribute("1028")]
public class Lamar.LamarIgnoreAttribute : Attribute {
}
internal class Lamar.LamarOverrides : object {
    [CompilerGeneratedAttribute]
private ServiceRegistry <Overrides>k__BackingField;
    public ServiceRegistry Overrides { get; }
    [CompilerGeneratedAttribute]
public ServiceRegistry get_Overrides();
    public sealed virtual void Apply(ServiceRegistry services);
}
internal class Lamar.MaybeIntercepted : object {
    internal static MaybeIntercepted Instance;
    private static MaybeIntercepted();
    public sealed virtual bool TryWrap(Instance inner, Instance& wrapped);
}
[AttributeUsageAttribute("2052")]
public class Lamar.NamedAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    public string Name { get; }
    public string TypeName { get; public set; }
    public NamedAttribute(string name);
    public NamedAttribute(string name, string typeName);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
}
[ExtensionAttribute]
public static class Lamar.RegistrationExtensions : object {
    [ExtensionAttribute]
public static void OverrideServices(IServiceCollection services, Action`1<ServiceRegistry> overrides);
}
public static class Lamar.Scanning.Conventions.AssemblyLoader : object {
    public static Assembly ByName(string assemblyName);
}
[LamarIgnoreAttribute]
public class Lamar.Scanning.Conventions.AssemblyScanner : object {
    private List`1<Assembly> _assemblies;
    private CompositeFilter`1<Type> _filter;
    private ServiceRegistry _parent;
    private bool _hasScanned;
    [CompilerGeneratedAttribute]
private List`1<IRegistrationConvention> <Conventions>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeSet <TypeFinder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public List`1<IRegistrationConvention> Conventions { get; }
    public TypeSet TypeFinder { get; private set; }
    public string Description { get; public set; }
    public AssemblyScanner(ServiceRegistry parent);
    [CompilerGeneratedAttribute]
public List`1<IRegistrationConvention> get_Conventions();
    [CompilerGeneratedAttribute]
public TypeSet get_TypeFinder();
    [CompilerGeneratedAttribute]
private void set_TypeFinder(TypeSet value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Description(string value);
    public sealed virtual void Assembly(Assembly assembly);
    public sealed virtual void Assembly(string assemblyName);
    public sealed virtual void Convention();
    public sealed virtual void AssemblyContainingType();
    public sealed virtual void AssemblyContainingType(Type type);
    public sealed virtual FindAllTypesFilter AddAllTypesOf();
    public sealed virtual FindAllTypesFilter AddAllTypesOf(ServiceLifetime lifetime);
    public sealed virtual FindAllTypesFilter AddAllTypesOf(Type pluginType);
    public sealed virtual FindAllTypesFilter AddAllTypesOf(Type pluginType, ServiceLifetime lifetime);
    public sealed virtual void Exclude(Func`2<Type, bool> exclude);
    public sealed virtual void ExcludeNamespace(string nameSpace);
    public sealed virtual void ExcludeNamespaceContainingType();
    public sealed virtual void Include(Func`2<Type, bool> predicate);
    public sealed virtual void IncludeNamespace(string nameSpace);
    public sealed virtual void IncludeNamespaceContainingType();
    public sealed virtual void ExcludeType();
    public sealed virtual void With(IRegistrationConvention convention);
    public sealed virtual void WithDefaultConventions();
    public sealed virtual void WithDefaultConventions(ServiceLifetime lifetime);
    public sealed virtual void WithDefaultConventions(OverwriteBehavior behavior);
    public sealed virtual void WithDefaultConventions(OverwriteBehavior behavior, ServiceLifetime lifetime);
    public sealed virtual void ConnectImplementationsToTypesClosing(Type openGenericType);
    public sealed virtual void ConnectImplementationsToTypesClosing(Type openGenericType, ServiceLifetime lifetime);
    public sealed virtual void RegisterConcreteTypesAgainstTheFirstInterface();
    public sealed virtual void RegisterConcreteTypesAgainstTheFirstInterface(ServiceLifetime lifetime);
    public sealed virtual void SingleImplementationsOfInterface();
    public sealed virtual void SingleImplementationsOfInterface(ServiceLifetime lifetime);
    public sealed virtual void LookForRegistries();
    public sealed virtual void TheCallingAssembly();
    public sealed virtual void AssembliesFromApplicationBaseDirectory();
    public sealed virtual void AssembliesFromApplicationBaseDirectory(Func`2<Assembly, bool> assemblyFilter);
    public sealed virtual void AssembliesAndExecutablesFromApplicationBaseDirectory(Func`2<Assembly, bool> assemblyFilter);
    [ObsoleteAttribute("It is very strongly recommended to use the overload with an Assembly filter to improve performance")]
public sealed virtual void AssembliesAndExecutablesFromPath(string path);
    [ObsoleteAttribute("It is very strongly recommended to use the overload with an Assembly filter to improve performance")]
public sealed virtual void AssembliesFromPath(string path);
    public sealed virtual void AssembliesAndExecutablesFromPath(string path, Func`2<Assembly, bool> assemblyFilter);
    public sealed virtual void AssembliesFromPath(string path, Func`2<Assembly, bool> assemblyFilter);
    public void Describe(StringWriter writer);
    public void Start();
    public void ApplyRegistrations(ServiceRegistry services);
    public bool Contains(string assemblyName);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool <Start>b__53_0(Type type);
}
[LamarIgnoreAttribute]
internal class Lamar.Scanning.Conventions.ConnectedConcretions : List`1<Type> {
}
internal class Lamar.Scanning.Conventions.DefaultConventionScanner : object {
    private ServiceLifetime _lifetime;
    [CompilerGeneratedAttribute]
private OverwriteBehavior <Overwrites>k__BackingField;
    public OverwriteBehavior Overwrites { get; public set; }
    public DefaultConventionScanner(ServiceLifetime lifetime);
    [CompilerGeneratedAttribute]
public OverwriteBehavior get_Overwrites();
    [CompilerGeneratedAttribute]
public void set_Overwrites(OverwriteBehavior value);
    public sealed virtual void ScanTypes(TypeSet types, ServiceRegistry services);
    public bool ShouldAdd(IServiceCollection services, Type serviceType, Type implementationType);
    public virtual Type FindServiceType(Type concreteType);
    public virtual string ToString();
}
public class Lamar.Scanning.Conventions.FindAllTypesFilter : object {
    private ServiceLifetime _lifetime;
    private Type _serviceType;
    private Func`2<Type, string> _namePolicy;
    public FindAllTypesFilter(Type serviceType, ServiceLifetime lifetime);
    private sealed virtual override void Lamar.Scanning.Conventions.IRegistrationConvention.ScanTypes(TypeSet types, ServiceRegistry services);
    private bool Matches(Type type);
    private static Type determineLeastSpecificButValidType(Type pluginType, Type type);
    public virtual string ToString();
    public FindAllTypesFilter NameBy(Func`2<Type, string> namePolicy);
}
internal class Lamar.Scanning.Conventions.FindRegistriesScanner : object {
    public sealed virtual void ScanTypes(TypeSet types, ServiceRegistry registry);
    internal static bool IsPublicRegistry(Type type);
}
internal class Lamar.Scanning.Conventions.FirstInterfaceConvention : object {
    private ServiceLifetime _lifetime;
    public FirstInterfaceConvention(ServiceLifetime lifetime);
    public sealed virtual void ScanTypes(TypeSet types, ServiceRegistry services);
    public virtual string ToString();
}
internal class Lamar.Scanning.Conventions.GenericConnectionScanner : object {
    private IList`1<Type> _concretions;
    private IList`1<Type> _interfaces;
    private ServiceLifetime _lifetime;
    private Type _openType;
    public GenericConnectionScanner(Type openType, ServiceLifetime lifetime);
    public sealed virtual void ScanTypes(TypeSet types, ServiceRegistry services);
    public virtual string ToString();
    private void addConcretionsThatCouldBeClosed(Type interface, IServiceCollection services);
}
public interface Lamar.Scanning.Conventions.IAssemblyScanner {
    public string Description { get; public set; }
    public abstract virtual string get_Description();
    public abstract virtual void set_Description(string value);
    public abstract virtual void Assembly(Assembly assembly);
    public abstract virtual void Assembly(string assemblyName);
    public abstract virtual void AssemblyContainingType();
    public abstract virtual void AssemblyContainingType(Type type);
    public abstract virtual FindAllTypesFilter AddAllTypesOf();
    public abstract virtual FindAllTypesFilter AddAllTypesOf(ServiceLifetime lifetime);
    public abstract virtual FindAllTypesFilter AddAllTypesOf(Type pluginType);
    public abstract virtual FindAllTypesFilter AddAllTypesOf(Type pluginType, ServiceLifetime lifetime);
    public abstract virtual void Exclude(Func`2<Type, bool> exclude);
    public abstract virtual void ExcludeNamespace(string nameSpace);
    public abstract virtual void ExcludeNamespaceContainingType();
    public abstract virtual void Include(Func`2<Type, bool> predicate);
    public abstract virtual void IncludeNamespace(string nameSpace);
    public abstract virtual void IncludeNamespaceContainingType();
    public abstract virtual void ExcludeType();
    public abstract virtual void Convention();
    public abstract virtual void With(IRegistrationConvention convention);
    public abstract virtual void WithDefaultConventions();
    public abstract virtual void WithDefaultConventions(ServiceLifetime lifetime);
    public abstract virtual void WithDefaultConventions(OverwriteBehavior behavior);
    public abstract virtual void WithDefaultConventions(OverwriteBehavior behavior, ServiceLifetime lifetime);
    public abstract virtual void RegisterConcreteTypesAgainstTheFirstInterface();
    public abstract virtual void RegisterConcreteTypesAgainstTheFirstInterface(ServiceLifetime lifetime);
    public abstract virtual void SingleImplementationsOfInterface();
    public abstract virtual void SingleImplementationsOfInterface(ServiceLifetime lifetime);
    public abstract virtual void TheCallingAssembly();
    public abstract virtual void AssembliesFromApplicationBaseDirectory();
    public abstract virtual void AssembliesFromApplicationBaseDirectory(Func`2<Assembly, bool> assemblyFilter);
    public abstract virtual void ConnectImplementationsToTypesClosing(Type openGenericType);
    public abstract virtual void ConnectImplementationsToTypesClosing(Type openGenericType, ServiceLifetime lifetime);
    public abstract virtual void AssembliesAndExecutablesFromApplicationBaseDirectory(Func`2<Assembly, bool> assemblyFilter);
    [ObsoleteAttribute("It is very strongly recommended to use the overload with an Assembly filter to improve performance")]
public abstract virtual void AssembliesAndExecutablesFromPath(string path);
    [ObsoleteAttribute("It is very strongly recommended to use the overload with an Assembly filter to improve performance")]
public abstract virtual void AssembliesFromPath(string path);
    public abstract virtual void AssembliesAndExecutablesFromPath(string path, Func`2<Assembly, bool> assemblyFilter);
    public abstract virtual void AssembliesFromPath(string path, Func`2<Assembly, bool> assemblyFilter);
    public abstract virtual void LookForRegistries();
}
internal class Lamar.Scanning.Conventions.ImplementationMap : object {
    private ServiceLifetime _lifetime;
    public ImplementationMap(ServiceLifetime lifetime);
    public sealed virtual void ScanTypes(TypeSet types, ServiceRegistry services);
    public virtual string ToString();
}
public interface Lamar.Scanning.Conventions.IRegistrationConvention {
    public abstract virtual void ScanTypes(TypeSet types, ServiceRegistry services);
}
public enum Lamar.Scanning.Conventions.OverwriteBehavior : Enum {
    public int value__;
    public static OverwriteBehavior Always;
    public static OverwriteBehavior NewType;
    public static OverwriteBehavior Never;
}
internal static class Lamar.Scanning.Conventions.ScanningExploder : object {
    internal static ValueTuple`2<ServiceRegistry, AssemblyScanner[]> ExplodeSynchronously(IServiceCollection services);
    [AsyncStateMachineAttribute("Lamar.Scanning.Conventions.ScanningExploder/<Explode>d__1")]
internal static Task`1<ValueTuple`2<ServiceRegistry, AssemblyScanner[]>> Explode(IServiceCollection services);
    private static ValueTuple`2<ServiceRegistry, List`1<object>> ParseToOperations(IServiceCollection services, List`1<Type> registriesEncountered);
}
[ExtensionAttribute]
internal static class Lamar.Scanning.Conventions.ServiceCollectionExtensions : object {
    [ExtensionAttribute]
public static bool HasScanners(IEnumerable`1<ServiceDescriptor> services);
    [ExtensionAttribute]
public static ConnectedConcretions ConnectedConcretions(IServiceCollection services);
    [ExtensionAttribute]
public static void Add(IServiceCollection services, Instance instance);
    [ExtensionAttribute]
public static bool Matches(ServiceDescriptor descriptor, Type serviceType, Type implementationType);
    [ExtensionAttribute]
public static Instance AddType(IServiceCollection services, Type serviceType, Type implementationType, ServiceLifetime lifetime);
    [ExtensionAttribute]
public static ServiceDescriptor FindDefault(IServiceCollection services);
    [ExtensionAttribute]
public static ServiceDescriptor FindDefault(IServiceCollection services, Type serviceType);
}
[ExtensionAttribute]
internal static class Lamar.Scanning.Conventions.TypeExtensions : object {
    [ExtensionAttribute]
public static bool CanBeCreated(Type type);
    [ExtensionAttribute]
public static Type FindFirstInterfaceThatCloses(Type implementationType, Type templateType);
    [ExtensionAttribute]
public static IEnumerable`1<Type> FindInterfacesThatClose(Type pluggedType, Type templateType);
    [IteratorStateMachineAttribute("Lamar.Scanning.Conventions.TypeExtensions/<rawFindInterfacesThatCloses>d__3")]
private static IEnumerable`1<Type> rawFindInterfacesThatCloses(Type TPluggedType, Type templateType);
    [ExtensionAttribute]
public static bool CouldCloseTo(Type openConcretion, Type closedInterface);
}
[AttributeUsageAttribute("1028")]
public class Lamar.ScopedAttribute : LamarAttribute {
    public virtual void Alter(IConfiguredInstance instance);
}
public class Lamar.ServiceFamily : object {
    private Dictionary`2<string, Instance> _instances;
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullNameInCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Instance[] <All>k__BackingField;
    [CompilerGeneratedAttribute]
private Instance <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CannotBeResolvedMessage>k__BackingField;
    public Type ServiceType { get; }
    public string FullNameInCode { get; }
    public Instance[] All { get; private set; }
    public Instance Default { get; private set; }
    public IReadOnlyDictionary`2<string, Instance> Instances { get; }
    public string CannotBeResolvedMessage { get; public set; }
    public ServiceFamily(Type serviceType, IDecoratorPolicy[] decoratorPolicies, Instance[] instances);
    [CompilerGeneratedAttribute]
public Type get_ServiceType();
    [CompilerGeneratedAttribute]
public string get_FullNameInCode();
    [CompilerGeneratedAttribute]
public Instance[] get_All();
    [CompilerGeneratedAttribute]
private void set_All(Instance[] value);
    [CompilerGeneratedAttribute]
public Instance get_Default();
    [CompilerGeneratedAttribute]
private void set_Default(Instance value);
    public IReadOnlyDictionary`2<string, Instance> get_Instances();
    [CompilerGeneratedAttribute]
public string get_CannotBeResolvedMessage();
    [CompilerGeneratedAttribute]
public void set_CannotBeResolvedMessage(string value);
    [IteratorStateMachineAttribute("Lamar.ServiceFamily/<allDecoratorPolicies>d__22")]
private IEnumerable`1<IDecoratorPolicy> allDecoratorPolicies(IDecoratorPolicy[] decoratorPolicies);
    [IteratorStateMachineAttribute("Lamar.ServiceFamily/<applyDecorators>d__23")]
private IEnumerable`1<Instance> applyDecorators(IDecoratorPolicy[] decoratorPolicies, Instance[] instances);
    public AppendState Append(ObjectInstance instance, IDecoratorPolicy[] decoration);
    public AppendState Append(IEnumerable`1<ServiceDescriptor> services, IDecoratorPolicy[] decoration);
    public AppendState Append(Instance[] instances, IDecoratorPolicy[] decoration);
    public virtual string ToString();
    public Instance InstanceFor(string name);
    private void makeNamesUnique(IEnumerable`1<Instance> instances);
    public ServiceFamily CreateTemplatedClone(Type serviceType, IDecoratorPolicy[] decoration, Type[] templateTypes);
}
internal class Lamar.ServiceFamilyConfiguration : object {
    private ServiceFamily _family;
    private Scope _scope;
    public Type ServiceType { get; }
    public InstanceRef Default { get; }
    public IEnumerable`1<InstanceRef> Instances { get; }
    public ServiceFamilyConfiguration(ServiceFamily family, Scope scope);
    public sealed virtual Type get_ServiceType();
    public sealed virtual InstanceRef get_Default();
    public sealed virtual IEnumerable`1<InstanceRef> get_Instances();
    public sealed virtual bool HasImplementations();
    [CompilerGeneratedAttribute]
private InstanceRef <get_Instances>b__8_0(Instance x);
}
public class Lamar.ServiceGraph : object {
    private Stack`1<Instance> _chain;
    private object _familyLock;
    private IList`1<Type> _lookingFor;
    private ServiceRegistry _services;
    private Assembly[] _allAssemblies;
    private ImHashMap`2<Type, Func`2<Scope, object>> _byType;
    private ImHashMap`2<Type, ServiceFamily> _families;
    private bool _inPlanning;
    [CompilerGeneratedAttribute]
private Scope <RootScope>k__BackingField;
    [CompilerGeneratedAttribute]
private ISetterPolicy[] <setterPolicies>k__BackingField;
    [CompilerGeneratedAttribute]
private IDecoratorPolicy[] <DecoratorPolicies>k__BackingField;
    [CompilerGeneratedAttribute]
private IInstancePolicy[] <InstancePolicies>k__BackingField;
    [CompilerGeneratedAttribute]
private IFamilyPolicy[] <FamilyPolicies>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyScanner[] <Scanners>k__BackingField;
    public Scope RootScope { get; }
    private ISetterPolicy[] setterPolicies { get; private set; }
    public IDecoratorPolicy[] DecoratorPolicies { get; private set; }
    public IInstancePolicy[] InstancePolicies { get; public set; }
    public IFamilyPolicy[] FamilyPolicies { get; private set; }
    public IServiceCollection Services { get; }
    public IReadOnlyDictionary`2<Type, ServiceFamily> Families { get; }
    internal AssemblyScanner[] Scanners { get; private set; }
    private ServiceGraph(IServiceCollection services, Scope rootScope, AssemblyScanner[] scanners);
    public ServiceGraph(IServiceCollection services, Scope rootScope);
    [CompilerGeneratedAttribute]
public Scope get_RootScope();
    [CompilerGeneratedAttribute]
private ISetterPolicy[] get_setterPolicies();
    [CompilerGeneratedAttribute]
private void set_setterPolicies(ISetterPolicy[] value);
    [CompilerGeneratedAttribute]
public IDecoratorPolicy[] get_DecoratorPolicies();
    [CompilerGeneratedAttribute]
private void set_DecoratorPolicies(IDecoratorPolicy[] value);
    [CompilerGeneratedAttribute]
public IInstancePolicy[] get_InstancePolicies();
    [CompilerGeneratedAttribute]
public void set_InstancePolicies(IInstancePolicy[] value);
    [CompilerGeneratedAttribute]
public IFamilyPolicy[] get_FamilyPolicies();
    [CompilerGeneratedAttribute]
private void set_FamilyPolicies(IFamilyPolicy[] value);
    public IServiceCollection get_Services();
    public IReadOnlyDictionary`2<Type, ServiceFamily> get_Families();
    [CompilerGeneratedAttribute]
internal AssemblyScanner[] get_Scanners();
    [CompilerGeneratedAttribute]
private void set_Scanners(AssemblyScanner[] value);
    [AsyncStateMachineAttribute("Lamar.ServiceGraph/<DisposeAsync>d__37")]
public sealed virtual ValueTask DisposeAsync();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Lamar.ServiceGraph/<BuildAsync>d__39")]
public static Task`1<ServiceGraph> BuildAsync(IServiceCollection services, Scope rootScope);
    private void organize(ServiceRegistry services);
    internal bool ShouldBeSet(PropertyInfo property);
    internal void Inject(Type serviceType, object object);
    public void Initialize();
    private void rebuildReferencedAssemblyArray();
    private void buildOutMissingResolvers();
    internal GeneratedAssembly ToGeneratedAssembly(string namespace);
    private void resetInstancePlanning();
    private void planResolutionStrategies();
    internal Instance FindInstance(ParameterInfo parameter);
    private void organizeIntoFamilies(IServiceCollection services);
    private ServiceFamily buildFamilyForInstanceGroup(IServiceCollection services, IGrouping`2<Type, ServiceDescriptor> group);
    private ServiceFamily buildClosedGenericType(Type serviceType, IServiceCollection services);
    public IEnumerable`1<Instance> AllInstances();
    public bool HasFamily(Type serviceType);
    public Instance FindInstance(Type serviceType, string name);
    public ServiceFamily ResolveFamily(Type serviceType);
    private ServiceFamily addMissingFamily(Type serviceType);
    public Func`2<Scope, object> FindResolver(Type serviceType);
    public Instance FindDefault(Type serviceType);
    public Instance[] FindAll(Type serviceType);
    public bool CouldBuild(Type concreteType, String& message);
    internal void StartingToPlan(Instance instance);
    internal void FinishedPlanning();
    public static ServiceGraph Empty();
    public static ServiceGraph For(Action`1<ServiceRegistry> configure);
    public ServiceFamily TryToCreateMissingFamily(Type serviceType);
    internal ServiceFamily TryToCreateMissingFamilyWithNetCoreRules(Type serviceType);
    private Type getServiceTypeThatTakesCollectionsIntoAccount(Type serviceType);
    internal void ClearPlanning();
    public bool CouldResolve(Type type);
    public void AppendServices(IServiceCollection services);
    public bool CanBeServiceByNetCoreRules(Type serviceType);
}
public class Lamar.ServiceRegistry : List`1<ServiceDescriptor> {
    [CompilerGeneratedAttribute]
private IList`1<Type> <RegistryTypes>k__BackingField;
    internal static Func`2<string, string> DefaultInstanceRenamePolicy;
    internal IList`1<Type> RegistryTypes { get; internal set; }
    public PoliciesExpression Policies { get; }
    public ServiceRegistry(IEnumerable`1<ServiceDescriptor> descriptors);
    private static ServiceRegistry();
    [CompilerGeneratedAttribute]
internal IList`1<Type> get_RegistryTypes();
    [CompilerGeneratedAttribute]
internal void set_RegistryTypes(IList`1<Type> value);
    public PoliciesExpression get_Policies();
    public static ServiceRegistry For(Action`1<ServiceRegistry> configuration);
    public BuildWithExpression`1<T> ForConcreteType();
    public InstanceExpression`1<T> For();
    public DescriptorExpression For(Type serviceType);
    public InstanceExpression`1<T> ForSingletonOf();
    public void Scan(Action`1<IAssemblyScanner> scan);
    public void IncludeRegistry();
    public void IncludeRegistry(T serviceRegistry);
    public void Include(ServiceRegistry registry);
    public void Injectable();
    internal T[] FindAndRemovePolicies();
    public InverseInstanceExpression`1<T> Use();
    public ProvidedInstanceInverseInstanceExpression`1<T> Use(T instance);
    public void MitigateInstanceHashCollisions(int retryLimit, Func`2<string, string> instanceRenamePolicy);
    internal bool TryRemoveInstanceHashCollisions();
    internal bool TryRemoveInstanceHashCollisions(Func`2<string, string> instanceRenamePolicy);
    internal void HandleInstanceHashCollisions(IGrouping`2<int, Instance> collision);
    internal void HandleInstanceHashCollisions(IGrouping`2<int, Instance> collision, Func`2<string, string> instanceRenamePolicy);
    internal IEnumerable`1<IGrouping`2<int, Instance>> GetInstanceHashCollisions();
}
[AttributeUsageAttribute("128")]
public class Lamar.SetterPropertyAttribute : Attribute {
}
[AttributeUsageAttribute("1028")]
public class Lamar.SingletonAttribute : LamarAttribute {
    public virtual void Alter(IConfiguredInstance instance);
}
[ExtensionAttribute]
internal static class Lamar.Util.TypeExtensions : object {
    private static Type[] _ignoredTypes;
    private static TypeExtensions();
    [ExtensionAttribute]
internal static bool ShouldIgnore(Type type);
}
[AttributeUsageAttribute("64")]
public class Lamar.ValidationMethodAttribute : Attribute {
    public static MethodInfo[] GetValidationMethods(Type objectType);
}
