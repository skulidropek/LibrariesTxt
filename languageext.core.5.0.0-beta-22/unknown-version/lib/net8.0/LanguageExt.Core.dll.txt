[ExtensionAttribute]
public static class CompositionsExt : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Compositions`1<A> Cons(A a, Compositions`1<A> ma);
}
[IsReadOnlyAttribute]
public class LanguageExt.Accel : ValueType {
    private double Value;
    public double MetresPerSecond2 { get; }
    internal Accel(double value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public sealed virtual bool Equals(Accel other);
    public bool Equals(Accel other, double epsilon);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Accel other);
    public Accel Add(Accel rhs);
    public Accel Subtract(Accel rhs);
    public Accel Multiply(double rhs);
    public Accel Divide(double rhs);
    public static Accel op_Multiply(Accel lhs, double rhs);
    public static Accel op_Multiply(double lhs, Accel rhs);
    public static Velocity op_Multiply(Accel lhs, Time rhs);
    public static Velocity op_Multiply(Time lhs, Accel rhs);
    public static VelocitySq op_Multiply(Accel lhs, Length rhs);
    public static VelocitySq op_Multiply(Length lhs, Accel rhs);
    public static Length op_Multiply(Accel lhs, TimeSq rhs);
    public static Length op_Multiply(TimeSq lhs, Accel rhs);
    public static Accel op_Addition(Accel lhs, Accel rhs);
    public static Accel op_Subtraction(Accel lhs, Accel rhs);
    public static Accel op_Division(Accel lhs, double rhs);
    public static double op_Division(Accel lhs, Accel rhs);
    public static bool op_Equality(Accel lhs, Accel rhs);
    public static bool op_Inequality(Accel lhs, Accel rhs);
    public static bool op_GreaterThan(Accel lhs, Accel rhs);
    public static bool op_LessThan(Accel lhs, Accel rhs);
    public static bool op_GreaterThanOrEqual(Accel lhs, Accel rhs);
    public static bool op_LessThanOrEqual(Accel lhs, Accel rhs);
    public Accel Pow(double power);
    public Accel Round();
    public Accel Sqrt();
    public Accel Abs();
    public Accel Min(Accel rhs);
    public Accel Max(Accel rhs);
    public double get_MetresPerSecond2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ActionObservable`1 : object {
    [CompilerGeneratedAttribute]
private Action <PostSubscribeAction>P;
    [CompilerGeneratedAttribute]
private IObservable`1<T> <SwitchTo>P;
    public ActionObservable`1(Action PostSubscribeAction, IObservable`1<T> SwitchTo);
    public sealed virtual IDisposable Subscribe(IObserver`1<T> observer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.AlternativeExtensions : object {
    [ExtensionAttribute]
public static K`2<M, A> Filter(K`2<M, A> ma, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, A> Where(K`2<M, A> ma, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, B> Choose(K`2<M, A> ma, Func`2<A, Option`1<B>> selector);
    [ExtensionAttribute]
public static K`2<F, A> OneOf(Seq`1<K`2<F, A>> ms);
    [ExtensionAttribute]
public static K`2<F, Seq`1<A>> Some(K`2<F, A> v);
    [ExtensionAttribute]
public static K`2<F, Seq`1<A>> Many(K`2<F, A> v);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.ApplicativeExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, B> Apply(K`2<F, Func`2<A, B>> mf, K`2<F, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, B> ApplyM(K`2<F, Func`2<A, K`2<F, B>>> mf, K`2<F, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, Func`2<B, C>> Apply(K`2<F, Func`3<A, B, C>> mf, K`2<F, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, Func`2<B, K`2<F, C>>> ApplyM(K`2<F, Func`3<A, B, K`2<F, C>>> mf, K`2<F, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, C> Apply(K`2<F, Func`3<A, B, C>> mf, K`2<F, A> ma, K`2<F, B> mb);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, C> ApplyM(K`2<F, Func`3<A, B, K`2<F, C>>> mf, K`2<F, A> ma, K`2<F, B> mb);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, D> Apply(K`2<F, Func`4<A, B, C, D>> mf, K`2<F, A> ma, K`2<F, B> mb, K`2<F, C> mc);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, D> ApplyM(K`2<F, Func`4<A, B, C, K`2<F, D>>> mf, K`2<F, A> ma, K`2<F, B> mb, K`2<F, C> mc);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, Func`2<C, D>> Apply(K`2<F, Func`4<A, B, C, D>> mf, K`2<F, A> ma, K`2<F, B> mb);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, Func`2<C, K`2<F, D>>> ApplyM(K`2<F, Func`4<A, B, C, K`2<F, D>>> mf, K`2<F, A> ma, K`2<F, B> mb);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, Func`2<B, Func`2<C, D>>> Apply(K`2<F, Func`4<A, B, C, D>> mf, K`2<F, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, Func`2<B, Func`2<C, K`2<F, D>>>> ApplyM(K`2<F, Func`4<A, B, C, K`2<F, D>>> mf, K`2<F, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, B> Action(K`2<F, A> ma, K`2<F, B> mb);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, A> Actions(IEnumerable`1<K`2<F, A>> ma);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, A> Actions(IAsyncEnumerable`1<K`2<F, A>> ma);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, B> Lift(Func`2<A, B> f, K`2<F, A> fa);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, C> Lift(Func`3<A, B, C> f, K`2<F, A> fa, K`2<F, B> fb);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, C> Lift(Func`2<A, Func`2<B, C>> f, K`2<F, A> fa, K`2<F, B> fb);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, D> Lift(Func`4<A, B, C, D> f, K`2<F, A> fa, K`2<F, B> fb, K`2<F, C> fc);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, D> Lift(Func`2<A, Func`2<B, Func`2<C, D>>> f, K`2<F, A> fa, K`2<F, B> fb, K`2<F, C> fc);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<Fnctr, R> Apply(ValueTuple`2<K`2<Fnctr, A>, K`2<Fnctr, B>> items, Func`3<A, B, R> f);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<M, R> ApplyM(ValueTuple`2<K`2<M, A>, K`2<M, B>> items, Func`3<A, B, K`2<M, R>> f);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<Fnctr, R> Apply(ValueTuple`3<K`2<Fnctr, A>, K`2<Fnctr, B>, K`2<Fnctr, C>> items, Func`4<A, B, C, R> f);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<M, R> ApplyM(ValueTuple`3<K`2<M, A>, K`2<M, B>, K`2<M, C>> items, Func`4<A, B, C, K`2<M, R>> f);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<Fnctr, R> Apply(ValueTuple`4<K`2<Fnctr, A>, K`2<Fnctr, B>, K`2<Fnctr, C>, K`2<Fnctr, D>> items, Func`5<A, B, C, D, R> f);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<M, R> ApplyM(ValueTuple`4<K`2<M, A>, K`2<M, B>, K`2<M, C>, K`2<M, D>> items, Func`5<A, B, C, D, K`2<M, R>> f);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<Fnctr, R> Apply(ValueTuple`5<K`2<Fnctr, A>, K`2<Fnctr, B>, K`2<Fnctr, C>, K`2<Fnctr, D>, K`2<Fnctr, E>> items, Func`6<A, B, C, D, E, R> f);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<M, R> ApplyM(ValueTuple`5<K`2<M, A>, K`2<M, B>, K`2<M, C>, K`2<M, D>, K`2<M, E>> items, Func`6<A, B, C, D, E, K`2<M, R>> f);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<Fnctr, R> Apply(ValueTuple`6<K`2<Fnctr, A>, K`2<Fnctr, B>, K`2<Fnctr, C>, K`2<Fnctr, D>, K`2<Fnctr, E>, K`2<Fnctr, F>> items, Func`7<A, B, C, D, E, F, R> f);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<M, R> ApplyM(ValueTuple`6<K`2<M, A>, K`2<M, B>, K`2<M, C>, K`2<M, D>, K`2<M, E>, K`2<M, F>> items, Func`7<A, B, C, D, E, F, K`2<M, R>> f);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<Fnctr, R> Apply(ValueTuple`7<K`2<Fnctr, A>, K`2<Fnctr, B>, K`2<Fnctr, C>, K`2<Fnctr, D>, K`2<Fnctr, E>, K`2<Fnctr, F>, K`2<Fnctr, G>> items, Func`8<A, B, C, D, E, F, G, R> f);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<M, R> ApplyM(ValueTuple`7<K`2<M, A>, K`2<M, B>, K`2<M, C>, K`2<M, D>, K`2<M, E>, K`2<M, F>, K`2<M, G>> items, Func`8<A, B, C, D, E, F, G, K`2<M, R>> f);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<Fnctr, R> Apply(ValueTuple`8<K`2<Fnctr, A>, K`2<Fnctr, B>, K`2<Fnctr, C>, K`2<Fnctr, D>, K`2<Fnctr, E>, K`2<Fnctr, F>, K`2<Fnctr, G>, ValueTuple`1<K`2<Fnctr, H>>> items, Func`9<A, B, C, D, E, F, G, H, R> f);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<M, R> ApplyM(ValueTuple`8<K`2<M, A>, K`2<M, B>, K`2<M, C>, K`2<M, D>, K`2<M, E>, K`2<M, F>, K`2<M, G>, ValueTuple`1<K`2<M, H>>> items, Func`9<A, B, C, D, E, F, G, H, K`2<M, R>> f);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<Fnctr, R> Apply(ValueTuple`8<K`2<Fnctr, A>, K`2<Fnctr, B>, K`2<Fnctr, C>, K`2<Fnctr, D>, K`2<Fnctr, E>, K`2<Fnctr, F>, K`2<Fnctr, G>, ValueTuple`2<K`2<Fnctr, H>, K`2<Fnctr, I>>> items, Func`10<A, B, C, D, E, F, G, H, I, R> f);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<M, R> ApplyM(ValueTuple`8<K`2<M, A>, K`2<M, B>, K`2<M, C>, K`2<M, D>, K`2<M, E>, K`2<M, F>, K`2<M, G>, ValueTuple`2<K`2<M, H>, K`2<M, I>>> items, Func`10<A, B, C, D, E, F, G, H, I, K`2<M, R>> f);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<Fnctr, R> Apply(ValueTuple`8<K`2<Fnctr, A>, K`2<Fnctr, B>, K`2<Fnctr, C>, K`2<Fnctr, D>, K`2<Fnctr, E>, K`2<Fnctr, F>, K`2<Fnctr, G>, ValueTuple`3<K`2<Fnctr, H>, K`2<Fnctr, I>, K`2<Fnctr, J>>> items, Func`11<A, B, C, D, E, F, G, H, I, J, R> f);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<M, R> ApplyM(ValueTuple`8<K`2<M, A>, K`2<M, B>, K`2<M, C>, K`2<M, D>, K`2<M, E>, K`2<M, F>, K`2<M, G>, ValueTuple`3<K`2<M, H>, K`2<M, I>, K`2<M, J>>> items, Func`11<A, B, C, D, E, F, G, H, I, J, K`2<M, R>> f);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, A> Add(K`2<F, A> fa, K`2<F, A> fb);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, A> Add(K`2<F, A> fa, K`2<F, A> fb);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, A> Subtract(K`2<F, A> fa, K`2<F, A> fb);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, A> Subtract(K`2<F, A> fa, K`2<F, A> fb);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, A> Multiply(K`2<F, A> fa, K`2<F, A> fb);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, A> Multiply(K`2<F, A> fa, K`2<F, A> fb);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, A> Divide(K`2<F, A> fa, K`2<F, A> fb);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<F, A> Divide(K`2<F, A> fa, K`2<F, A> fb);
}
[IsReadOnlyAttribute]
public class LanguageExt.Area : ValueType {
    private double Value;
    public double SqKilometres { get; }
    public double SqMetres { get; }
    public double SqCentimetres { get; }
    public double SqMillimetres { get; }
    internal Area(double value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public sealed virtual bool Equals(Area other);
    public bool Equals(Area other, double epsilon);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Area other);
    public Area Add(Area rhs);
    public Area Subtract(Area rhs);
    public Area Multiply(double rhs);
    public Area Divide(double rhs);
    public static Area op_Multiply(Area lhs, double rhs);
    public static Area op_Multiply(double lhs, Area rhs);
    public static Area op_Division(Area lhs, double rhs);
    public static Area op_Addition(Area lhs, Area rhs);
    public static Area op_Subtraction(Area lhs, Area rhs);
    public static Length op_Division(Area lhs, Length rhs);
    public static double op_Division(Area lhs, Area rhs);
    public static bool op_Equality(Area lhs, Area rhs);
    public static bool op_Inequality(Area lhs, Area rhs);
    public static bool op_GreaterThan(Area lhs, Area rhs);
    public static bool op_LessThan(Area lhs, Area rhs);
    public static bool op_GreaterThanOrEqual(Area lhs, Area rhs);
    public static bool op_LessThanOrEqual(Area lhs, Area rhs);
    public Area Pow(double power);
    public Area Round();
    public Area Sqrt();
    public Length Abs();
    public Area Min(Area rhs);
    public Area Max(Area rhs);
    public double get_SqKilometres();
    public double get_SqMetres();
    public double get_SqCentimetres();
    public double get_SqMillimetres();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Arr : object {
    [NullableContextAttribute("2")]
[PureAttribute]
public static Arr`1<T> empty();
    [NullableContextAttribute("2")]
[PureAttribute]
public static Arr`1<T> create();
    [PureAttribute]
public static Arr`1<A> singleton(A value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Arr`1<T> create(ReadOnlySpan`1<T> items);
    [PureAttribute]
public static Arr`1<T> create(T[] items);
    [PureAttribute]
public static Arr`1<T> createRange(IEnumerable`1<T> items);
    [PureAttribute]
public static Arr`1<T> add(Arr`1<T> array, T value);
    [PureAttribute]
public static Arr`1<T> addRange(Arr`1<T> array, IEnumerable`1<T> value);
    [PureAttribute]
public static Arr`1<T> remove(Arr`1<T> array, T value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Arr`1<T> removeAt(Arr`1<T> array, int index);
    [PureAttribute]
public static T[] rev(T[] array);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Arr`1<T> rev(Arr`1<T> array);
    [PureAttribute]
public static A[] flatten(A[][] ma);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Arr`1<A> flatten(Arr`1<Arr`1<A>> ma);
    private static override K`2<Arr, B> LanguageExt.Traits.Monad<LanguageExt.Arr>.Bind(K`2<Arr, A> ma, Func`2<A, K`2<Arr, B>> f);
    private static override K`2<Arr, B> LanguageExt.Traits.Functor<LanguageExt.Arr>.Map(Func`2<A, B> f, K`2<Arr, A> ma);
    private static override K`2<Arr, A> LanguageExt.Traits.Applicative<LanguageExt.Arr>.Pure(A value);
    private static override K`2<Arr, B> LanguageExt.Traits.Applicative<LanguageExt.Arr>.Apply(K`2<Arr, Func`2<A, B>> mf, K`2<Arr, A> ma);
    private static override K`2<Arr, B> LanguageExt.Traits.Applicative<LanguageExt.Arr>.Action(K`2<Arr, A> ma, K`2<Arr, B> mb);
    private static override K`2<Arr, A> LanguageExt.Traits.MonoidK<LanguageExt.Arr>.Empty();
    private static override K`2<Arr, A> LanguageExt.Traits.SemigroupK<LanguageExt.Arr>.Combine(K`2<Arr, A> ma, K`2<Arr, A> mb);
    private static override int LanguageExt.Traits.Foldable<LanguageExt.Arr>.Count(K`2<Arr, A> ta);
    private static override bool LanguageExt.Traits.Foldable<LanguageExt.Arr>.IsEmpty(K`2<Arr, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Arr>.FoldWhile(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<Arr, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Arr>.FoldBackWhile(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<Arr, A> ta);
    private static override Option`1<A> LanguageExt.Traits.Foldable<LanguageExt.Arr>.At(K`2<Arr, A> ta, Index index);
    private static override Arr`1<A> LanguageExt.Traits.Foldable<LanguageExt.Arr>.ToArr(K`2<Arr, A> ta);
    private static override Lst`1<A> LanguageExt.Traits.Foldable<LanguageExt.Arr>.ToLst(K`2<Arr, A> ta);
    private static override Iterable`1<A> LanguageExt.Traits.Foldable<LanguageExt.Arr>.ToIterable(K`2<Arr, A> ta);
    private static override Seq`1<A> LanguageExt.Traits.Foldable<LanguageExt.Arr>.ToSeq(K`2<Arr, A> ta);
    private static override K`2<F, K`2<Arr, B>> LanguageExt.Traits.Traversable<LanguageExt.Arr>.Traverse(Func`2<A, K`2<F, B>> f, K`2<Arr, A> ta);
    private static override K`2<F, K`2<Arr, B>> LanguageExt.Traits.Traversable<LanguageExt.Arr>.TraverseM(Func`2<A, K`2<F, B>> f, K`2<Arr, A> ta);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[CollectionBuilderAttribute("LanguageExt.Arr", "create")]
public class LanguageExt.Arr`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Arr`1<A> <Empty>k__BackingField;
    private A[] value;
    private int hashCode;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Arr`1<A> Empty { get; }
    internal A[] Value { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public static Lens`2<Arr`1<A>, A> head { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public static Lens`2<Arr`1<A>, Option`1<A>> headOrNone { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public static Lens`2<Arr`1<A>, A> last { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public static Lens`2<Arr`1<A>, Option`1<A>> lastOrNone { get; }
    [PureAttribute]
public A Item { get; }
    [NullableAttribute("2")]
[PureAttribute]
public object Case { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public int Length { get; }
    [PureAttribute]
private int System.Collections.Generic.IReadOnlyCollection<A>.Count { get; }
    [PureAttribute]
private A System.Collections.Generic.IReadOnlyList<A>.Item { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Arr`1<A> AdditiveIdentity { get; }
    public Arr`1(IEnumerable`1<A> initial);
    public Arr`1(ReadOnlySpan`1<A> initial);
    internal Arr`1(A[] value);
    private static Arr`1();
    [CompilerGeneratedAttribute]
public static override Arr`1<A> get_Empty();
    internal A[] get_Value();
    [PureAttribute]
public StreamT`2<M, A> AsStream();
    [PureAttribute]
public ReadOnlySpan`1<A> AsSpan();
    [PureAttribute]
public ReadOnlySpan`1<A> AsSpan(int start, int length);
    public static Arr`1<A> op_Implicit(A[] xs);
    public static Lens`2<Arr`1<A>, A> get_head();
    public static Lens`2<Arr`1<A>, Option`1<A>> get_headOrNone();
    public static Lens`2<Arr`1<A>, A> get_last();
    public static Lens`2<Arr`1<A>, Option`1<A>> get_lastOrNone();
    [PureAttribute]
public static Lens`2<Arr`1<A>, A> item(int index);
    [PureAttribute]
public static Lens`2<Arr`1<A>, Option`1<A>> itemOrNone(int index);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Lens`2<Arr`1<A>, Arr`1<B>> map(Lens`2<A, B> lens);
    public A get_Item(Index index);
    [NullableContextAttribute("2")]
public object get_Case();
    public bool get_IsEmpty();
    public int get_Count();
    public int get_Length();
    private sealed virtual override int System.Collections.Generic.IReadOnlyCollection<A>.get_Count();
    private sealed virtual override A System.Collections.Generic.IReadOnlyList<A>.get_Item(int index);
    [PureAttribute]
public Arr`1<A> Add(A valueToAdd);
    [PureAttribute]
public Arr`1<A> AddRange(IEnumerable`1<A> items);
    [PureAttribute]
public Arr`1<A> Clear();
    [NullableContextAttribute("0")]
[PureAttribute]
public Enumerator<A> GetEnumerator();
    [PureAttribute]
public int IndexOf(A item, int index, int count, IEqualityComparer`1<A> equalityComparer);
    [PureAttribute]
public int LastIndexOf(A item, int index, int count, IEqualityComparer`1<A> equalityComparer);
    [PureAttribute]
public int IndexOf(A item, int index, int count);
    [PureAttribute]
public int LastIndexOf(A item, int index, int count);
    [PureAttribute]
public Arr`1<A> Insert(int index, A valueToInsert);
    [PureAttribute]
public Arr`1<A> InsertRange(int index, IEnumerable`1<A> items);
    [PureAttribute]
public Arr`1<A> Remove(A valueToRemove);
    [PureAttribute]
public Arr`1<A> Remove(A valueToRemove, IEqualityComparer`1<A> equalityComparer);
    [PureAttribute]
public Arr`1<A> Remove(A valueToRemove);
    [PureAttribute]
public Arr`1<A> RemoveAll(Predicate`1<A> pred);
    [PureAttribute]
private Arr`1<A> RemoveAtRange(List`1<int> remove);
    [PureAttribute]
public Arr`1<A> RemoveAt(int index);
    [PureAttribute]
public Arr`1<A> RemoveRange(int index, int count);
    [PureAttribute]
public Arr`1<A> SetItem(int index, A valueToSet);
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator`1<A> System.Collections.Generic.IEnumerable<A>.GetEnumerator();
    [PureAttribute]
public Iterable`1<A> AsIterable();
    [PureAttribute]
public Seq`1<A> ToSeq();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToFullString(string separator);
    [PureAttribute]
public string ToFullArrayString(string separator);
    [PureAttribute]
public Iterable`1<A> Skip(int amount);
    [PureAttribute]
public Arr`1<A> Reverse();
    public Arr`1<A> Do(Action`1<A> f);
    [PureAttribute]
public Arr`1<B> Map(Func`2<A, B> map);
    [PureAttribute]
public K`2<F, Arr`1<B>> Traverse(Func`2<A, K`2<F, B>> f);
    [PureAttribute]
public K`2<M, Arr`1<B>> TraverseM(Func`2<A, K`2<M, B>> f);
    [PureAttribute]
public Arr`1<A> Filter(Func`2<A, bool> pred);
    [PureAttribute]
public static Arr`1<A> op_Addition(Arr`1<A> lhs, A rhs);
    [PureAttribute]
public static Arr`1<A> op_Addition(A lhs, Arr`1<A> rhs);
    [PureAttribute]
public static override Arr`1<A> op_Addition(Arr`1<A> lhs, Arr`1<A> rhs);
    [PureAttribute]
public sealed virtual Arr`1<A> Combine(Arr`1<A> rhs);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[PureAttribute]
public sealed virtual int CompareTo(object obj);
    [PureAttribute]
public sealed virtual bool Equals(Arr`1<A> other);
    [PureAttribute]
public sealed virtual int CompareTo(Arr`1<A> other);
    [PureAttribute]
public static override bool op_Equality(Arr`1<A> lhs, Arr`1<A> rhs);
    [PureAttribute]
public static override bool op_Inequality(Arr`1<A> lhs, Arr`1<A> rhs);
    [NullableContextAttribute("2")]
[PureAttribute]
public Arr`1<B> Bind(Func`2<A, Arr`1<B>> f);
    public static Arr`1<A> op_Implicit(SeqEmpty _);
    public static override bool op_GreaterThan(Arr`1<A> left, Arr`1<A> right);
    public static override bool op_GreaterThanOrEqual(Arr`1<A> left, Arr`1<A> right);
    public static override bool op_LessThan(Arr`1<A> left, Arr`1<A> right);
    public static override bool op_LessThanOrEqual(Arr`1<A> left, Arr`1<A> right);
    public static override Arr`1<A> get_AdditiveIdentity();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.ArrExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Arr`1<A> As(K`2<Arr, A> xs);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static A[] Flatten(A[][] ma);
    [ExtensionAttribute]
[PureAttribute]
public static Arr`1<A> Flatten(Arr`1<Arr`1<A>> ma);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static Arr`1<A> Filter(Arr`1<A> ma, Func`2<A, bool> f);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static Arr`1<A> Where(Arr`1<A> ma, Func`2<A, bool> f);
    [ExtensionAttribute]
[PureAttribute]
public static Arr`1<B> Map(Arr`1<A> ma, Func`2<A, B> f);
    [ExtensionAttribute]
[PureAttribute]
public static Arr`1<B> Select(Arr`1<A> ma, Func`2<A, B> f);
    [ExtensionAttribute]
[PureAttribute]
public static Arr`1<B> Bind(Arr`1<A> ma, Func`2<A, Arr`1<B>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Arr`1<B> SelectMany(Arr`1<A> ma, Func`2<A, Arr`1<B>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Arr`1<C> SelectMany(Arr`1<A> ma, Func`2<A, Arr`1<B>> bind, Func`3<A, B, C> project);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static IQueryable`1<A> AsQueryable(Arr`1<A> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class LanguageExt.Ask`2 : ValueType {
    [CompilerGeneratedAttribute]
private Func`2<Env, A> <F>k__BackingField;
    public Func`2<Env, A> F { get; public set; }
    public Ask`2(Func`2<Env, A> F);
    [CompilerGeneratedAttribute]
public Func`2<Env, A> get_F();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_F(Func`2<Env, A> value);
    public Reader`2<Env, A> ToReader();
    public ReaderT`3<Env, M, A> ToReaderT();
    public K`2<M, C> SelectMany(Func`2<A, K`2<M, B>> bind, Func`3<A, B, C> project);
    public ReaderT`3<Env, M, C> SelectMany(Func`2<A, ReaderT`3<Env, M, B>> bind, Func`3<A, B, C> project);
    public Reader`2<Env, C> SelectMany(Func`2<A, Reader`2<Env, B>> bind, Func`3<A, B, C> project);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(Ask`2<Env, A> left, Ask`2<Env, A> right);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public static bool op_Equality(Ask`2<Env, A> left, Ask`2<Env, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Ask`2<Env, A> other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`2& F);
}
[ExtensionAttribute]
public static class LanguageExt.AskExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static K`2<M, C> SelectMany(K`2<M, A> ma, Func`2<A, Ask`2<Env, B>> bind, Func`3<A, B, C> project);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Async.Async : object {
    public static A await(Task`1<A> operation);
    public static ForkIO`1<A> fork(Func`1<A> operation, TimeSpan timeout);
    public static ForkIO`1<A> fork(Func`1<Task`1<A>> operation, TimeSpan timeout);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.Async.Linq.AsyncEnumerableExtensions : object {
    [AsyncIteratorStateMachineAttribute("LanguageExt.Async.Linq.AsyncEnumerableExtensions/<Select>d__0`2")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<B> Select(IAsyncEnumerable`1<A> ma, Func`2<A, B> f);
    [AsyncIteratorStateMachineAttribute("LanguageExt.Async.Linq.AsyncEnumerableExtensions/<SelectMany>d__1`2")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<B> SelectMany(IAsyncEnumerable`1<A> ma, Func`2<A, IAsyncEnumerable`1<B>> f);
    [AsyncIteratorStateMachineAttribute("LanguageExt.Async.Linq.AsyncEnumerableExtensions/<SelectMany>d__2`3")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<C> SelectMany(IAsyncEnumerable`1<A> ma, Func`2<A, IAsyncEnumerable`1<B>> bind, Func`3<A, B, C> project);
    [AsyncIteratorStateMachineAttribute("LanguageExt.Async.Linq.AsyncEnumerableExtensions/<Where>d__3`1")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<A> Where(IAsyncEnumerable`1<A> ma, Func`2<A, bool> f);
    [AsyncIteratorStateMachineAttribute("LanguageExt.Async.Linq.AsyncEnumerableExtensions/<Skip>d__4`1")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<A> Skip(IAsyncEnumerable`1<A> ma, int amount);
    [AsyncIteratorStateMachineAttribute("LanguageExt.Async.Linq.AsyncEnumerableExtensions/<Take>d__5`1")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<A> Take(IAsyncEnumerable`1<A> ma, int amount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.AsyncEnumerableExtensions : object {
    [ExtensionAttribute]
public static StreamT`2<M, A> AsStream(IAsyncEnumerable`1<A> ma);
    [AsyncIteratorStateMachineAttribute("LanguageExt.AsyncEnumerableExtensions/<Map>d__1`2")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<B> Map(IAsyncEnumerable`1<A> ma, Func`2<A, B> f);
    [AsyncIteratorStateMachineAttribute("LanguageExt.AsyncEnumerableExtensions/<Bind>d__2`2")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<B> Bind(IAsyncEnumerable`1<A> ma, Func`2<A, IAsyncEnumerable`1<B>> f);
    [AsyncIteratorStateMachineAttribute("LanguageExt.AsyncEnumerableExtensions/<Filter>d__3`1")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<A> Filter(IAsyncEnumerable`1<A> ma, Func`2<A, bool> f);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Atom`1 : object {
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) value;
    private Func`2<A, bool> validator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private AtomChangedEvent`1<A> Change;
    public IO`1<A> ValueIO { get; public set; }
    public A Value { get; }
    private Atom`1(A value, Func`2<A, bool> validator);
    [CompilerGeneratedAttribute]
public void add_Change(AtomChangedEvent`1<A> value);
    [CompilerGeneratedAttribute]
public void remove_Change(AtomChangedEvent`1<A> value);
    internal static Option`1<Atom`1<A>> New(A value, Func`2<A, bool> validator);
    internal static Atom`1<A> New(A value);
    public A Swap(Func`2<A, A> f);
    public A Swap(Func`2<A, Option`1<A>> f);
    public IO`1<A> SwapIO(Func`2<A, A> f);
    public IO`1<A> SwapIO(Func`2<A, Option`1<A>> f);
    public IO`1<A> get_ValueIO();
    public void set_ValueIO(IO`1<A> value);
    public A get_Value();
    public static A op_Implicit(Atom`1<A> atom);
    private static bool True(A _);
    public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private A <get_ValueIO>b__13_0(EnvIO _);
    [CompilerGeneratedAttribute]
private IO`1<A> <set_ValueIO>b__14_0(A v);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Atom`2 : object {
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) value;
    private Func`2<A, bool> validator;
    private M metadata;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private AtomChangedEvent`1<A> Change;
    public IO`1<A> ValueIO { get; public set; }
    public A Value { get; }
    private Atom`2(M metadata, A value, Func`2<A, bool> validator);
    [CompilerGeneratedAttribute]
public void add_Change(AtomChangedEvent`1<A> value);
    [CompilerGeneratedAttribute]
public void remove_Change(AtomChangedEvent`1<A> value);
    internal static Option`1<Atom`2<M, A>> New(M metadata, A value, Func`2<A, bool> validator);
    internal static Atom`2<M, A> New(M metadata, A value);
    public A Swap(Func`3<M, A, A> f);
    public A Swap(Func`3<M, A, Option`1<A>> f);
    public IO`1<A> SwapIO(Func`3<M, A, A> f);
    public IO`1<A> SwapIO(Func`3<M, A, Option`1<A>> f);
    public IO`1<A> get_ValueIO();
    public void set_ValueIO(IO`1<A> value);
    public A get_Value();
    public virtual string ToString();
    public static A op_Implicit(Atom`2<M, A> atom);
    private static bool True(A _);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private A <get_ValueIO>b__14_0(EnvIO _);
    [CompilerGeneratedAttribute]
private IO`1<A> <set_ValueIO>b__15_0(A v);
}
public class LanguageExt.AtomChangedEvent`1 : MulticastDelegate {
    public AtomChangedEvent`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(A value);
    public virtual IAsyncResult BeginInvoke(A value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class LanguageExt.AtomDequeuedEvent`1 : MulticastDelegate {
    public AtomDequeuedEvent`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(A value);
    public virtual IAsyncResult BeginInvoke(A value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class LanguageExt.AtomEnqueuedEvent`1 : MulticastDelegate {
    public AtomEnqueuedEvent`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(A value);
    public virtual IAsyncResult BeginInvoke(A value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class LanguageExt.AtomHashMap : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static AtomHashMap`2<K, V> ToAtom(HashMap`2<K, V> self);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static AtomHashMap`3<EqK, K, V> ToAtom(HashMap`3<EqK, K, V> self);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class LanguageExt.AtomHashMap`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private TrieMap`3 modreq(System.Runtime.CompilerServices.IsVolatile) Items;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private AtomHashMapChangeEvent`2<K, V> Change;
    public static AtomHashMap`2<K, V> Empty { get; }
    [PureAttribute]
public V Item { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public int Length { get; }
    [PureAttribute]
public Iterable`1<K> Keys { get; }
    [PureAttribute]
public Iterable`1<V> Values { get; }
    [PureAttribute]
private IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.Keys { get; }
    [PureAttribute]
private IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.Values { get; }
    private AtomHashMap`2(TrieMap`3<EqDefault`1<K>, K, V> items);
    internal AtomHashMap`2(HashMap`2<K, V> items);
    [CompilerGeneratedAttribute]
public void add_Change(AtomHashMapChangeEvent`2<K, V> value);
    [CompilerGeneratedAttribute]
public void remove_Change(AtomHashMapChangeEvent`2<K, V> value);
    public static AtomHashMap`2<K, V> get_Empty();
    public sealed virtual V get_Item(K key);
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public int get_Length();
    public Unit Swap(Func`2<TrackingHashMap`2<K, V>, TrackingHashMap`2<K, V>> swap);
    public Unit SwapKey(K key, Func`2<V, V> swap);
    public Unit SwapKey(K key, Func`2<Option`1<V>, Option`1<V>> swap);
    [PureAttribute]
public AtomHashMap`2<K, V> Filter(Func`2<V, bool> pred);
    public Unit FilterInPlace(Func`2<V, bool> pred);
    [PureAttribute]
public AtomHashMap`2<K, V> Filter(Func`3<K, V, bool> pred);
    public Unit FilterInPlace(Func`3<K, V, bool> pred);
    public Unit MapInPlace(Func`2<V, V> f);
    public AtomHashMap`2<K, U> Map(Func`3<K, V, U> f);
    public Unit Add(K key, V value);
    public Unit TryAdd(K key, V value);
    public Unit AddOrUpdate(K key, V value);
    public Unit AddOrUpdate(K key, Func`2<V, V> Some, Func`1<V> None);
    public Unit AddOrUpdate(K key, Func`2<V, V> Some, V None);
    public Unit AddRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    public Unit TryAddRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    public Unit TryAddRange(IEnumerable`1<KeyValuePair`2<K, V>> range);
    public Unit AddOrUpdateRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    public Unit AddOrUpdateRange(IEnumerable`1<KeyValuePair`2<K, V>> range);
    public Unit Remove(K key);
    [PureAttribute]
public Option`1<V> Find(K value);
    [PureAttribute]
public Seq`1<V> FindSeq(K key);
    [PureAttribute]
public R Find(K key, Func`2<V, R> Some, Func`1<R> None);
    public V FindOrAdd(K key, Func`1<V> None);
    public V FindOrAdd(K key, V value);
    public Option`1<V> FindOrMaybeAdd(K key, Func`1<Option`1<V>> None);
    public Option`1<V> FindOrMaybeAdd(K key, Option`1<V> None);
    public Unit SetItem(K key, V value);
    public Unit SetItem(K key, Func`2<V, V> Some);
    public Unit TrySetItem(K key, V value);
    public Unit TrySetItem(K key, Func`2<V, V> Some);
    [PureAttribute]
public sealed virtual bool ContainsKey(K key);
    [PureAttribute]
public bool Contains(K key, V value);
    [PureAttribute]
public bool Contains(V value);
    [PureAttribute]
public bool Contains(V value);
    [PureAttribute]
public bool Contains(K key, V value);
    public Unit Clear();
    public Unit AddRange(IEnumerable`1<KeyValuePair`2<K, V>> pairs);
    public Unit SetItems(IEnumerable`1<KeyValuePair`2<K, V>> items);
    public Unit SetItems(IEnumerable`1<ValueTuple`2<K, V>> items);
    public Unit TrySetItems(IEnumerable`1<KeyValuePair`2<K, V>> items);
    public Unit TrySetItems(IEnumerable`1<ValueTuple`2<K, V>> items);
    public Unit TrySetItems(IEnumerable`1<K> keys, Func`2<V, V> Some);
    public Unit RemoveRange(IEnumerable`1<K> keys);
    [PureAttribute]
public bool Contains(KeyValuePair`2<K, V> pair);
    public Iterable`1<K> get_Keys();
    public Iterable`1<V> get_Values();
    [PureAttribute]
public IReadOnlyDictionary`2<K, V> ToDictionary();
    [PureAttribute]
public HashMap`2<K, V> ToHashMap();
    public sealed virtual IEnumerator`1<ValueTuple`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public Seq`1<ValueTuple`2<K, V>> ToSeq();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToFullString(string separator);
    [PureAttribute]
public string ToFullArrayString(string separator);
    [PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> AsIterable();
    [PureAttribute]
public static AtomHashMap`2<K, V> op_Implicit(SeqEmpty _);
    [PureAttribute]
public static bool op_Equality(AtomHashMap`2<K, V> lhs, AtomHashMap`2<K, V> rhs);
    [PureAttribute]
public static bool op_Equality(AtomHashMap`2<K, V> lhs, HashMap`2<K, V> rhs);
    [PureAttribute]
public static bool op_Equality(HashMap`2<K, V> lhs, AtomHashMap`2<K, V> rhs);
    [PureAttribute]
public static bool op_Inequality(AtomHashMap`2<K, V> lhs, AtomHashMap`2<K, V> rhs);
    [PureAttribute]
public static bool op_Inequality(AtomHashMap`2<K, V> lhs, HashMap`2<K, V> rhs);
    [PureAttribute]
public static bool op_Inequality(HashMap`2<K, V> lhs, AtomHashMap`2<K, V> rhs);
    public Unit Append(AtomHashMap`2<K, V> rhs);
    public Unit Append(HashMap`2<K, V> rhs);
    public Unit Subtract(AtomHashMap`2<K, V> rhs);
    public Unit Subtract(HashMap`2<K, V> rhs);
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsSubsetOf(HashMap`2<K, V> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<K> rhs);
    public Unit Intersect(IEnumerable`1<K> rhs);
    public Unit Intersect(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    public Unit Intersect(IEnumerable`1<ValueTuple`2<K, V>> rhs, WhenMatched`4<K, V, V, V> Merge);
    public Unit Intersect(HashMap`2<K, V> rhs, WhenMatched`4<K, V, V, V> Merge);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<K> other);
    public Unit Except(IEnumerable`1<K> rhs);
    public Unit Except(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    public Unit SymmetricExcept(HashMap`2<K, V> rhs);
    public Unit SymmetricExcept(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    public Unit Union(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    public Unit Union(IEnumerable`1<ValueTuple`2<K, V>> rhs, WhenMatched`4<K, V, V, V> Merge);
    public Unit Union(IEnumerable`1<ValueTuple`2<K, W>> rhs, WhenMissing`3<K, W, V> MapRight, WhenMatched`4<K, V, W, V> Merge);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public sealed virtual bool Equals(AtomHashMap`2<K, V> other);
    [PureAttribute]
public sealed virtual bool Equals(HashMap`2<K, V> other);
    [PureAttribute]
public bool EqualsKeys(AtomHashMap`2<K, V> other);
    [PureAttribute]
public bool EqualsKeys(HashMap`2<K, V> other);
    [PureAttribute]
public virtual int GetHashCode();
    [PureAttribute]
public AtomHashMap`2<K, U> Select(Func`2<V, U> f);
    [PureAttribute]
public AtomHashMap`2<K, U> Select(Func`3<K, V, U> f);
    [PureAttribute]
[EditorBrowsableAttribute("1")]
public AtomHashMap`2<K, V> Where(Func`2<V, bool> pred);
    [PureAttribute]
[EditorBrowsableAttribute("1")]
public AtomHashMap`2<K, V> Where(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool ForAll(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<V, bool> pred);
    public bool Exists(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<KeyValuePair`2<K, V>, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<V, bool> pred);
    public Unit Iter(Action`2<K, V> action);
    public Unit Iter(Action`1<V> action);
    public Unit Iter(Action`1<ValueTuple`2<K, V>> action);
    public Unit Iter(Action`1<KeyValuePair`2<K, V>> action);
    [PureAttribute]
public S Fold(S state, Func`4<S, K, V, S> folder);
    [PureAttribute]
public S Fold(S state, Func`3<S, V, S> folder);
    private void AnnounceChange(TrieMap`3<EqDefault`1<K>, K, V> prev, TrieMap`3<EqDefault`1<K>, K, V> current, K key, Change`1<V> change);
    private void AnnounceChanges(TrieMap`3<EqDefault`1<K>, K, V> prev, TrieMap`3<EqDefault`1<K>, K, V> current, TrieMap`3<EqDefault`1<K>, K, Change`1<V>> changes);
    [PureAttribute]
public IDictionary`2<KR, VR> ToDictionary(Func`2<ValueTuple`2<K, V>, KR> keySelector, Func`2<ValueTuple`2<K, V>, VR> valueSelector);
    [PureAttribute]
public sealed virtual bool TryGetValue(K key, V& value);
    [PureAttribute]
private sealed virtual override IEnumerator`1<KeyValuePair`2<K, V>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,V>>.GetEnumerator();
    private sealed virtual override IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Keys();
    private sealed virtual override IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Values();
    [PureAttribute]
public IReadOnlyDictionary`2<K, V> ToReadOnlyDictionary();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class LanguageExt.AtomHashMap`3 : object {
    internal TrieMap`3 modreq(System.Runtime.CompilerServices.IsVolatile) Items;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private AtomHashMapChangeEvent`3<EqK, K, V> Change;
    public static AtomHashMap`3<EqK, K, V> Empty { get; }
    [PureAttribute]
public V Item { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public int Length { get; }
    [PureAttribute]
public Iterable`1<K> Keys { get; }
    [PureAttribute]
public Iterable`1<V> Values { get; }
    [PureAttribute]
private IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.Keys { get; }
    [PureAttribute]
private IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.Values { get; }
    private AtomHashMap`3(TrieMap`3<EqK, K, V> items);
    internal AtomHashMap`3(HashMap`3<EqK, K, V> items);
    [CompilerGeneratedAttribute]
public void add_Change(AtomHashMapChangeEvent`3<EqK, K, V> value);
    [CompilerGeneratedAttribute]
public void remove_Change(AtomHashMapChangeEvent`3<EqK, K, V> value);
    public static AtomHashMap`3<EqK, K, V> get_Empty();
    public sealed virtual V get_Item(K key);
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public int get_Length();
    public Unit Swap(Func`2<TrackingHashMap`3<EqK, K, V>, TrackingHashMap`3<EqK, K, V>> swap);
    internal Unit SwapInternal(Func`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, V>> swap);
    public Unit SwapKey(K key, Func`2<V, V> swap);
    public Unit SwapKey(K key, Func`2<Option`1<V>, Option`1<V>> swap);
    [PureAttribute]
public AtomHashMap`3<EqK, K, V> Filter(Func`2<V, bool> pred);
    public Unit FilterInPlace(Func`2<V, bool> pred);
    [PureAttribute]
public AtomHashMap`3<EqK, K, V> Filter(Func`3<K, V, bool> pred);
    public Unit FilterInPlace(Func`3<K, V, bool> pred);
    public Unit MapInPlace(Func`2<V, V> f);
    public AtomHashMap`3<EqK, K, U> Map(Func`3<K, V, U> f);
    public Unit Add(K key, V value);
    public Unit TryAdd(K key, V value);
    public Unit AddOrUpdate(K key, V value);
    public Unit AddOrUpdate(K key, Func`2<V, V> Some, Func`1<V> None);
    public Unit AddOrUpdate(K key, Func`2<V, V> Some, V None);
    public Unit AddRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    public Unit TryAddRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    public Unit TryAddRange(IEnumerable`1<KeyValuePair`2<K, V>> range);
    public Unit AddOrUpdateRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    public Unit AddOrUpdateRange(IEnumerable`1<KeyValuePair`2<K, V>> range);
    public Unit Remove(K key);
    [PureAttribute]
public Option`1<V> Find(K value);
    [PureAttribute]
public Seq`1<V> FindSeq(K key);
    [PureAttribute]
public R Find(K key, Func`2<V, R> Some, Func`1<R> None);
    public V FindOrAdd(K key, Func`1<V> None);
    public V FindOrAdd(K key, V value);
    public Option`1<V> FindOrMaybeAdd(K key, Func`1<Option`1<V>> None);
    public Option`1<V> FindOrMaybeAdd(K key, Option`1<V> None);
    public Unit SetItem(K key, V value);
    public Unit SetItem(K key, Func`2<V, V> Some);
    public Unit TrySetItem(K key, V value);
    public Unit TrySetItem(K key, Func`2<V, V> Some);
    [PureAttribute]
public sealed virtual bool ContainsKey(K key);
    [PureAttribute]
public bool Contains(K key, V value);
    [PureAttribute]
public bool Contains(V value);
    [PureAttribute]
public bool Contains(V value);
    [PureAttribute]
public bool Contains(K key, V value);
    public Unit Clear();
    public Unit AddRange(IEnumerable`1<KeyValuePair`2<K, V>> pairs);
    public Unit SetItems(IEnumerable`1<KeyValuePair`2<K, V>> items);
    public Unit SetItems(IEnumerable`1<ValueTuple`2<K, V>> items);
    public Unit TrySetItems(IEnumerable`1<KeyValuePair`2<K, V>> items);
    public Unit TrySetItems(IEnumerable`1<ValueTuple`2<K, V>> items);
    public Unit TrySetItems(IEnumerable`1<K> keys, Func`2<V, V> Some);
    public Unit RemoveRange(IEnumerable`1<K> keys);
    [PureAttribute]
public bool Contains(KeyValuePair`2<K, V> pair);
    public Iterable`1<K> get_Keys();
    public Iterable`1<V> get_Values();
    [PureAttribute]
public HashMap`3<EqK, K, V> ToHashMap();
    public sealed virtual IEnumerator`1<ValueTuple`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public Seq`1<ValueTuple`2<K, V>> ToSeq();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToFullString(string separator);
    [PureAttribute]
public string ToFullArrayString(string separator);
    [PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> AsIterable();
    [PureAttribute]
public static AtomHashMap`3<EqK, K, V> op_Implicit(SeqEmpty _);
    [PureAttribute]
public static bool op_Equality(AtomHashMap`3<EqK, K, V> lhs, AtomHashMap`3<EqK, K, V> rhs);
    [PureAttribute]
public static bool op_Equality(AtomHashMap`3<EqK, K, V> lhs, HashMap`3<EqK, K, V> rhs);
    [PureAttribute]
public static bool op_Equality(HashMap`3<EqK, K, V> lhs, AtomHashMap`3<EqK, K, V> rhs);
    [PureAttribute]
public static bool op_Inequality(AtomHashMap`3<EqK, K, V> lhs, AtomHashMap`3<EqK, K, V> rhs);
    [PureAttribute]
public static bool op_Inequality(AtomHashMap`3<EqK, K, V> lhs, HashMap`3<EqK, K, V> rhs);
    [PureAttribute]
public static bool op_Inequality(HashMap`3<EqK, K, V> lhs, AtomHashMap`3<EqK, K, V> rhs);
    public Unit Append(AtomHashMap`3<EqK, K, V> rhs);
    public Unit Append(HashMap`3<EqK, K, V> rhs);
    public Unit Subtract(AtomHashMap`3<EqK, K, V> rhs);
    public Unit Subtract(HashMap`3<EqK, K, V> rhs);
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsSubsetOf(HashMap`3<EqK, K, V> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<K> rhs);
    public Unit Intersect(IEnumerable`1<K> rhs);
    public Unit Intersect(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    public Unit Intersect(IEnumerable`1<ValueTuple`2<K, V>> rhs, WhenMatched`4<K, V, V, V> Merge);
    public Unit Intersect(HashMap`3<EqK, K, V> rhs, WhenMatched`4<K, V, V, V> Merge);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<K> other);
    public Unit Except(IEnumerable`1<K> rhs);
    public Unit Except(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    public Unit SymmetricExcept(HashMap`3<EqK, K, V> rhs);
    public Unit SymmetricExcept(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    public Unit Union(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    public Unit Union(IEnumerable`1<ValueTuple`2<K, V>> rhs, WhenMatched`4<K, V, V, V> Merge);
    public Unit Union(IEnumerable`1<ValueTuple`2<K, W>> rhs, WhenMissing`3<K, W, V> MapRight, WhenMatched`4<K, V, W, V> Merge);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public sealed virtual bool Equals(AtomHashMap`3<EqK, K, V> other);
    [PureAttribute]
public sealed virtual bool Equals(HashMap`3<EqK, K, V> other);
    [PureAttribute]
public bool EqualsKeys(AtomHashMap`3<EqK, K, V> other);
    [PureAttribute]
public bool EqualsKeys(HashMap`3<EqK, K, V> other);
    [PureAttribute]
public virtual int GetHashCode();
    [PureAttribute]
public AtomHashMap`3<EqK, K, U> Select(Func`2<V, U> f);
    [PureAttribute]
public AtomHashMap`3<EqK, K, U> Select(Func`3<K, V, U> f);
    [PureAttribute]
[EditorBrowsableAttribute("1")]
public AtomHashMap`3<EqK, K, V> Where(Func`2<V, bool> pred);
    [PureAttribute]
[EditorBrowsableAttribute("1")]
public AtomHashMap`3<EqK, K, V> Where(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool ForAll(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<V, bool> pred);
    public bool Exists(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<V, bool> pred);
    public Unit Iter(Action`2<K, V> action);
    public Unit Iter(Action`1<V> action);
    public Unit Iter(Action`1<ValueTuple`2<K, V>> action);
    public Unit Iter(Action`1<KeyValuePair`2<K, V>> action);
    [PureAttribute]
public S Fold(S state, Func`4<S, K, V, S> folder);
    [PureAttribute]
public S Fold(S state, Func`3<S, V, S> folder);
    private void AnnounceChange(TrieMap`3<EqK, K, V> prev, TrieMap`3<EqK, K, V> current, K key, Change`1<V> change);
    private void AnnounceChanges(TrieMap`3<EqK, K, V> prev, TrieMap`3<EqK, K, V> current, TrieMap`3<EqK, K, Change`1<V>> changes);
    [PureAttribute]
public IDictionary`2<KR, VR> ToDictionary(Func`2<ValueTuple`2<K, V>, KR> keySelector, Func`2<ValueTuple`2<K, V>, VR> valueSelector);
    [PureAttribute]
public sealed virtual bool TryGetValue(K key, V& value);
    [PureAttribute]
private sealed virtual override IEnumerator`1<KeyValuePair`2<K, V>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,V>>.GetEnumerator();
    private sealed virtual override IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Keys();
    private sealed virtual override IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Values();
    [PureAttribute]
public IReadOnlyDictionary`2<K, V> ToReadOnlyDictionary();
}
public class LanguageExt.AtomHashMapChangeEvent`2 : MulticastDelegate {
    public AtomHashMapChangeEvent`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(HashMapPatch`2<K, V> Patch);
    public virtual IAsyncResult BeginInvoke(HashMapPatch`2<K, V> Patch, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class LanguageExt.AtomHashMapChangeEvent`3 : MulticastDelegate {
    public AtomHashMapChangeEvent`3(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(HashMapPatch`3<EqK, K, V> Patch);
    public virtual IAsyncResult BeginInvoke(HashMapPatch`3<EqK, K, V> Patch, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.AtomQue : object {
    private static override S LanguageExt.Traits.Foldable<LanguageExt.AtomQue>.FoldWhile(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<AtomQue, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.AtomQue>.FoldBackWhile(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<AtomQue, A> ta);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.AtomQue`1 : object {
    private QueInternal`1<A> items;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private AtomDequeuedEvent`1<A> Dequeued;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private AtomEnqueuedEvent`1<A> Enqueued;
    [NullableAttribute("2")]
[PureAttribute]
public object Case { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public int Length { get; }
    internal AtomQue`1(IEnumerable`1<A> items);
    internal AtomQue`1(Que`1<A> items);
    [CompilerGeneratedAttribute]
public void add_Dequeued(AtomDequeuedEvent`1<A> value);
    [CompilerGeneratedAttribute]
public void remove_Dequeued(AtomDequeuedEvent`1<A> value);
    [CompilerGeneratedAttribute]
public void add_Enqueued(AtomEnqueuedEvent`1<A> value);
    [CompilerGeneratedAttribute]
public void remove_Enqueued(AtomEnqueuedEvent`1<A> value);
    public Unit Do(Action`1<A> f);
    [NullableContextAttribute("2")]
public object get_Case();
    public bool get_IsEmpty();
    public int get_Count();
    public int get_Length();
    public Unit Clear();
    [PureAttribute]
public Option`1<A> Peek();
    public Option`1<A> Dequeue();
    public A DequeueUnsafe();
    public Unit Enqueue(A value);
    [PureAttribute]
public Seq`1<A> ToSeq();
    [PureAttribute]
public Iterable`1<A> AsIterable();
    [PureAttribute]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public Unit Append(Que`1<A> rhs);
    [PureAttribute]
public Unit Append(AtomQue`1<A> rhs);
    [PureAttribute]
public static bool op_Equality(AtomQue`1<A> lhs, AtomQue`1<A> rhs);
    [PureAttribute]
public static bool op_Equality(AtomQue`1<A> lhs, Que`1<A> rhs);
    [PureAttribute]
public static bool op_Equality(Que`1<A> lhs, AtomQue`1<A> rhs);
    [PureAttribute]
public static bool op_Inequality(AtomQue`1<A> lhs, AtomQue`1<A> rhs);
    [PureAttribute]
public static bool op_Inequality(Que`1<A> lhs, AtomQue`1<A> rhs);
    [PureAttribute]
public static bool op_Inequality(AtomQue`1<A> lhs, Que`1<A> rhs);
    [PureAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public sealed virtual bool Equals(AtomQue`1<A> other);
    [PureAttribute]
public sealed virtual bool Equals(Que`1<A> other);
}
[ExtensionAttribute]
public static class LanguageExt.AtomQueExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static AtomQue`1<A> As(K`2<AtomQue, A> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class LanguageExt.AtomSeq`1 : object {
    private ISeqInternal`1 modreq(System.Runtime.CompilerServices.IsVolatile) items;
    public static AtomSeq`1<A> Empty { get; }
    [NullableAttribute("2")]
[PureAttribute]
public object Case { get; }
    public A Item { get; }
    public A Head { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Seq`1<A> Tail { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Seq`1<A> Init { get; }
    public A Last { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public int Length { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Seq`1<Seq`1<A>> Inits { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Seq`1<Seq`1<A>> NonEmptyInits { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Seq`1<Seq`1<A>> Tails { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Seq`1<Seq`1<A>> NonEmptyTails { get; }
    public AtomSeq`1(IEnumerable`1<A> ma);
    internal AtomSeq`1(ISeqInternal`1<A> items);
    public static AtomSeq`1<A> get_Empty();
    [PureAttribute]
public Seq`1<A> ToSeq();
    [NullableContextAttribute("2")]
public object get_Case();
    public void Deconstruct(A& head, Seq`1& tail);
    public A get_Item(int index);
    public Unit Swap(Func`2<Seq`1<A>, Seq`1<A>> swap);
    internal Unit SwapInternal(Func`2<ISeqInternal`1<A>, ISeqInternal`1<A>> swap);
    public Unit Add(A value);
    [PureAttribute]
public Unit Concat(IEnumerable`1<A> items);
    [PureAttribute]
public Unit Concat(Lst`1<A> items);
    [PureAttribute]
public Unit Concat(Set`1<A> items);
    [PureAttribute]
public Unit Concat(HashSet`1<A> items);
    public Unit Concat(Arr`1<A> items);
    public Unit Concat(Stck`1<A> items);
    public Unit Concat(IReadOnlyCollection`1<A> items);
    public Unit Concat(Seq`1<A> rhs);
    internal Unit Cons(A value);
    public A get_Head();
    public Seq`1<A> get_Tail();
    public Seq`1<A> get_Init();
    [PureAttribute]
public Option`1<A> HeadOrNone();
    public A get_Last();
    [PureAttribute]
public Option`1<A> LastOrNone();
    [PureAttribute]
public Either`2<L, A> LastOrLeft(L Left);
    [PureAttribute]
public Either`2<L, A> LastOrLeft(Func`1<L> Left);
    [PureAttribute]
public Either`2<L, A> HeadOrLeft(L left);
    [PureAttribute]
public Either`2<L, A> HeadOrLeft(Func`1<L> Left);
    public bool get_IsEmpty();
    public int get_Count();
    public int get_Length();
    [PureAttribute]
public Iterable`1<A> AsIterable();
    [PureAttribute]
public B Match(Func`1<B> Empty, Func`3<A, Seq`1<A>, B> Tail);
    [PureAttribute]
public B Match(Func`1<B> Empty, Func`2<A, B> Head, Func`3<A, Seq`1<A>, B> Tail);
    [PureAttribute]
public B Match(Func`1<B> Empty, Func`2<Seq`1<A>, B> Seq);
    [PureAttribute]
public B Match(Func`1<B> Empty, Func`2<A, B> Head, Func`2<Seq`1<A>, B> Tail);
    public Unit Iter(Action`1<A> f);
    [PureAttribute]
public Seq`1<B> Map(Func`2<A, B> f);
    [PureAttribute]
public Unit MapInPlace(Func`2<A, A> f);
    [PureAttribute]
public Seq`1<B> Select(Func`2<A, B> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public Seq`1<B> Bind(Func`2<A, Seq`1<B>> f);
    [NullableContextAttribute("2")]
public Unit BindInPlace(Func`2<A, Seq`1<A>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public Seq`1<C> SelectMany(Func`2<A, Seq`1<B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Seq`1<A> Filter(Func`2<A, bool> f);
    public Unit FilterInPlace(Func`2<A, bool> f);
    [PureAttribute]
public Seq`1<A> Where(Func`2<A, bool> f);
    [PureAttribute]
public S Fold(S state, Func`3<S, A, S> f);
    [PureAttribute]
public S FoldBack(S state, Func`3<S, A, S> f);
    [PureAttribute]
public bool Exists(Func`2<A, bool> f);
    [PureAttribute]
public bool ForAll(Func`2<A, bool> f);
    [PureAttribute]
public bool Any();
    [PureAttribute]
public Unit Intersperse(A value);
    [PureAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[PureAttribute]
public sealed virtual int CompareTo(object obj);
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToFullString(string separator);
    [PureAttribute]
public string ToFullArrayString(string separator);
    public static bool op_GreaterThan(AtomSeq`1<A> x, AtomSeq`1<A> y);
    public static bool op_GreaterThanOrEqual(AtomSeq`1<A> x, AtomSeq`1<A> y);
    public static bool op_LessThan(AtomSeq`1<A> x, AtomSeq`1<A> y);
    public static bool op_LessThanOrEqual(AtomSeq`1<A> x, AtomSeq`1<A> y);
    public static bool op_Equality(AtomSeq`1<A> x, AtomSeq`1<A> y);
    public static bool op_Inequality(AtomSeq`1<A> x, AtomSeq`1<A> y);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [PureAttribute]
public sealed virtual bool Equals(Seq`1<A> rhs);
    [PureAttribute]
public sealed virtual bool Equals(AtomSeq`1<A> rhs);
    [NullableContextAttribute("0")]
[PureAttribute]
public bool Equals(Seq`1<A> rhs);
    [PureAttribute]
public bool Equals(AtomSeq`1<A> rhs);
    public Unit Skip(int amount);
    public Unit Take(int amount);
    public Unit TakeWhile(Func`2<A, bool> pred);
    public Unit TakeWhile(Func`3<A, int, bool> pred);
    public Seq`1<Seq`1<A>> get_Inits();
    public Seq`1<Seq`1<A>> get_NonEmptyInits();
    public Seq`1<Seq`1<A>> get_Tails();
    public Seq`1<Seq`1<A>> get_NonEmptyTails();
    [PureAttribute]
public sealed virtual int CompareTo(Seq`1<A> rhs);
    [PureAttribute]
public sealed virtual int CompareTo(AtomSeq`1<A> rhs);
    [NullableContextAttribute("0")]
[PureAttribute]
public int CompareTo(Seq`1<A> rhs);
    [PureAttribute]
public int CompareTo(AtomSeq`1<A> rhs);
    public Unit Strict();
    [PureAttribute]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("2")]
[PureAttribute]
public Seq`1<B> Cast();
    [IteratorStateMachineAttribute("LanguageExt.AtomSeq`1/<<Bind>g__Yield|52_0>d`1")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<B> <Bind>g__Yield|52_0(ISeqInternal`1<A> ma, Func`2<A, Seq`1<B>> bnd);
    [IteratorStateMachineAttribute("LanguageExt.AtomSeq`1/<<SelectMany>g__Yield|54_0>d`2")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<C> <SelectMany>g__Yield|54_0(ISeqInternal`1<A> ma, Func`2<A, Seq`1<B>> bnd, Func`3<A, B, C> prj);
    [IteratorStateMachineAttribute("LanguageExt.AtomSeq`1/<<Filter>g__Yield|55_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<A> <Filter>g__Yield|55_0(ISeqInternal`1<A> items, Func`2<A, bool> f);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.AtomSeqExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static Validation`2<F, A> LastOrInvalid(AtomSeq`1<A> ma, F Fail);
    [ExtensionAttribute]
[PureAttribute]
public static Validation`2<F, A> HeadOrInvalid(AtomSeq`1<A> ma, F Fail);
    [ExtensionAttribute]
[PureAttribute]
public static Validation`2<F, A> LastOrInvalid(AtomSeq`1<A> ma, Func`1<F> Fail);
    [ExtensionAttribute]
[PureAttribute]
public static Validation`2<F, A> HeadOrInvalid(AtomSeq`1<A> ma, Func`1<F> Fail);
    [ExtensionAttribute]
[PureAttribute]
public static Validation`2<F, A> LastOrInvalid(AtomSeq`1<A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Validation`2<F, A> HeadOrInvalid(AtomSeq`1<A> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1024")]
public class LanguageExt.Attributes.TraitAttribute : Attribute {
    public string NameFormat;
    public TraitAttribute(string nameFormat);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class LanguageExt.bigint : ValueType {
    public BigInteger Value;
    public static bigint One;
    public static bigint MinusOne;
    public static bigint Zero;
    public bool IsEven { get; }
    public bool IsZero { get; }
    public bool IsPowerOfTwo { get; }
    public bool IsOne { get; }
    public int Sign { get; }
    private static bigint LanguageExt.Traits.Monoid<LanguageExt.bigint>.Empty { get; }
    public bigint(BigInteger value);
    public bigint(Byte[] value);
    public bigint(decimal value);
    public bigint(double value);
    public bigint(int value);
    public bigint(long value);
    public bigint(float value);
    public bigint(UInt32 value);
    public bigint(ulong value);
    private static bigint();
    public bool get_IsEven();
    public bool get_IsZero();
    public bool get_IsPowerOfTwo();
    public bool get_IsOne();
    public int get_Sign();
    public static bigint Abs(bigint value);
    public static bigint Add(bigint left, bigint right);
    public static int Compare(bigint left, bigint right);
    public static bigint Divide(bigint dividend, bigint divisor);
    [NullableContextAttribute("0")]
public static ValueTuple`2<bigint, bigint> DivRem(bigint dividend, bigint divisor);
    public static bigint GreatestCommonDivisor(bigint left, bigint right);
    public static double Log(bigint value);
    public static double Log(bigint value, double baseValue);
    public static double Log10(bigint value);
    public static bigint Max(bigint left, bigint right);
    public static bigint Min(bigint left, bigint right);
    public static bigint ModPow(bigint value, bigint exponent, bigint modulus);
    public static bigint Multiply(bigint left, bigint right);
    public static bigint Negate(bigint value);
    public static bigint Parse(string value, NumberStyles style);
    public static bigint Parse(string value, IFormatProvider provider);
    public static bigint Parse(string value);
    public static bigint Parse(string value, NumberStyles style, IFormatProvider provider);
    public static bigint Pow(bigint value, int exponent);
    public static bigint Remainder(bigint dividend, bigint divisor);
    public static bigint Subtract(bigint left, bigint right);
    public static Option`1<bigint> TryParse(string value, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("0")]
public static Option`1<bigint> TryParse(string value);
    public int CompareTo(long other);
    public int CompareTo(ulong other);
    public int CompareTo(BigInteger other);
    public sealed virtual int CompareTo(bigint other);
    public bool Equals(long other);
    public bool Equals(BigInteger other);
    public sealed virtual bool Equals(bigint other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(ulong other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public Byte[] ToByteArray();
    public virtual string ToString();
    public string ToString(string format);
    public string ToString(IFormatProvider provider);
    public string ToString(string format, IFormatProvider provider);
    public static bigint op_UnaryPlus(bigint value);
    public static override bigint op_Addition(bigint left, bigint right);
    public static bigint op_UnaryNegation(bigint value);
    public static bigint op_Subtraction(bigint left, bigint right);
    public static bigint op_OnesComplement(bigint value);
    public static bigint op_Increment(bigint value);
    public static bigint op_Decrement(bigint value);
    public static bigint op_Multiply(bigint left, bigint right);
    public static bigint op_Division(bigint dividend, bigint divisor);
    public static bigint op_Modulus(bigint dividend, bigint divisor);
    public static bigint op_BitwiseAnd(bigint left, bigint right);
    public static bigint op_BitwiseOr(bigint left, bigint right);
    public static bigint op_ExclusiveOr(bigint left, bigint right);
    public static bigint op_LeftShift(bigint value, int shift);
    public static bigint op_RightShift(bigint value, int shift);
    public static bool op_Equality(bigint left, ulong right);
    public static bool op_Equality(BigInteger left, bigint right);
    public static bool op_Equality(bigint left, BigInteger right);
    public static bool op_Equality(long left, bigint right);
    public static bool op_Equality(bigint left, long right);
    public static bool op_Equality(bigint left, bigint right);
    public static bool op_Equality(ulong left, bigint right);
    public static bool op_Inequality(ulong left, bigint right);
    public static bool op_Inequality(bigint left, ulong right);
    public static bool op_Inequality(long left, bigint right);
    public static bool op_Inequality(bigint left, long right);
    public static bool op_Inequality(bigint left, bigint right);
    public static bool op_Inequality(BigInteger left, bigint right);
    public static bool op_Inequality(bigint left, BigInteger right);
    public static bool op_LessThan(long left, bigint right);
    public static bool op_LessThan(bigint left, ulong right);
    public static bool op_LessThan(ulong left, bigint right);
    public static bool op_LessThan(bigint left, bigint right);
    public static bool op_LessThan(BigInteger left, bigint right);
    public static bool op_LessThan(bigint left, BigInteger right);
    public static bool op_LessThan(bigint left, long right);
    public static bool op_GreaterThan(ulong left, bigint right);
    public static bool op_GreaterThan(bigint left, bigint right);
    public static bool op_GreaterThan(BigInteger left, bigint right);
    public static bool op_GreaterThan(bigint left, BigInteger right);
    public static bool op_GreaterThan(long left, bigint right);
    public static bool op_GreaterThan(bigint left, long right);
    public static bool op_GreaterThan(bigint left, ulong right);
    public static bool op_LessThanOrEqual(long left, bigint right);
    public static bool op_LessThanOrEqual(bigint left, long right);
    public static bool op_LessThanOrEqual(bigint left, bigint right);
    public static bool op_LessThanOrEqual(BigInteger left, bigint right);
    public static bool op_LessThanOrEqual(bigint left, BigInteger right);
    public static bool op_LessThanOrEqual(bigint left, ulong right);
    public static bool op_LessThanOrEqual(ulong left, bigint right);
    public static bool op_GreaterThanOrEqual(long left, bigint right);
    public static bool op_GreaterThanOrEqual(bigint left, long right);
    public static bool op_GreaterThanOrEqual(bigint left, bigint right);
    public static bool op_GreaterThanOrEqual(BigInteger left, bigint right);
    public static bool op_GreaterThanOrEqual(bigint left, BigInteger right);
    public static bool op_GreaterThanOrEqual(ulong left, bigint right);
    public static bool op_GreaterThanOrEqual(bigint left, ulong right);
    public static bigint op_Implicit(BigInteger value);
    public static bigint op_Implicit(byte value);
    public static bigint op_Implicit(ushort value);
    public static bigint op_Implicit(sbyte value);
    public static bigint op_Implicit(UInt32 value);
    public static bigint op_Implicit(long value);
    public static bigint op_Implicit(int value);
    public static bigint op_Implicit(short value);
    public static bigint op_Implicit(ulong value);
    public static bigint op_Explicit(decimal value);
    public static bigint op_Explicit(double value);
    public static byte op_Explicit(bigint value);
    public static BigInteger op_Implicit(bigint value);
    public static decimal op_Explicit(bigint value);
    public static double op_Explicit(bigint value);
    public static short op_Explicit(bigint value);
    public static long op_Explicit(bigint value);
    public static sbyte op_Explicit(bigint value);
    public static ushort op_Explicit(bigint value);
    public static UInt32 op_Explicit(bigint value);
    public static ulong op_Explicit(bigint value);
    public static bigint op_Explicit(float value);
    public static int op_Explicit(bigint value);
    public static float op_Explicit(bigint value);
    private sealed virtual override bigint LanguageExt.Traits.Semigroup<LanguageExt.bigint>.Combine(bigint y);
    private static override bigint LanguageExt.Traits.Monoid<LanguageExt.bigint>.get_Empty();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class LanguageExt.BiMap`2 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Map`2<A, B> Left;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Map`2<B, A> Right;
    [PureAttribute]
public A Item { get; }
    [PureAttribute]
public B Item { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public int Length { get; }
    [PureAttribute]
public Iterable`1<A> LeftKeys { get; }
    [PureAttribute]
public Iterable`1<B> RightKeys { get; }
    [PureAttribute]
public Iterable`1<B> LeftValues { get; }
    [PureAttribute]
public Iterable`1<A> RightValues { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
[ObsoleteAttribute("Use Pairs instead")]
public Iterable`1<ValueTuple`2<A, B>> Tuples { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Iterable`1<ValueTuple`2<A, B>> Pairs { get; }
    private BiMap`2(Map`2<A, B> left, Map`2<B, A> right);
    public BiMap`2(IEnumerable`1<ValueTuple`2<A, B>> items);
    public BiMap`2(IEnumerable`1<ValueTuple`2<A, B>> items, bool tryAdd);
    [PureAttribute]
public BiMap`2<A, B> Add(A left, B right);
    [PureAttribute]
public BiMap`2<A, B> TryAdd(A left, B right);
    [PureAttribute]
public BiMap`2<A, B> AddRange(IEnumerable`1<ValueTuple`2<A, B>> range);
    [PureAttribute]
public BiMap`2<A, B> AddRange(IEnumerable`1<Tuple`2<A, B>> range);
    [PureAttribute]
public BiMap`2<A, B> AddRange(IEnumerable`1<KeyValuePair`2<A, B>> range);
    [PureAttribute]
public BiMap`2<A, B> TryAddRange(IEnumerable`1<ValueTuple`2<A, B>> range);
    [PureAttribute]
public BiMap`2<A, B> TryAddRange(IEnumerable`1<Tuple`2<A, B>> range);
    [PureAttribute]
public BiMap`2<A, B> TryAddRange(IEnumerable`1<KeyValuePair`2<A, B>> range);
    [PureAttribute]
public BiMap`2<A, B> AddOrUpdateRange(IEnumerable`1<Tuple`2<A, B>> range);
    [PureAttribute]
public BiMap`2<A, B> AddOrUpdateRange(IEnumerable`1<ValueTuple`2<A, B>> range);
    [PureAttribute]
public BiMap`2<A, B> AddOrUpdateRange(IEnumerable`1<KeyValuePair`2<A, B>> range);
    [PureAttribute]
public BiMap`2<A, B> Remove(A left);
    [PureAttribute]
public BiMap`2<A, B> Remove(B right);
    public A get_Item(B value);
    public B get_Item(A value);
    public bool get_IsEmpty();
    public int get_Count();
    public int get_Length();
    [PureAttribute]
public BiMap`2<A, B> SetItem(A left, B right);
    [PureAttribute]
public BiMap`2<A, B> TrySetItem(A left, B right);
    [PureAttribute]
public BiMap`2<A, B> AddOrUpdate(A left, B right);
    [PureAttribute]
public bool ContainsKey(A value);
    [PureAttribute]
public bool ContainsKey(B value);
    [PureAttribute]
public BiMap`2<A, B> Clear();
    public Iterable`1<A> get_LeftKeys();
    public Iterable`1<B> get_RightKeys();
    public Iterable`1<B> get_LeftValues();
    public Iterable`1<A> get_RightValues();
    [PureAttribute]
public IReadOnlyDictionary`2<A, B> ToDictionaryLeft();
    [PureAttribute]
public IReadOnlyDictionary`2<B, A> ToDictionaryRight();
    public Iterable`1<ValueTuple`2<A, B>> get_Tuples();
    public Iterable`1<ValueTuple`2<A, B>> get_Pairs();
    [PureAttribute]
public Seq`1<ValueTuple`2<A, B>> ToSeq();
    [PureAttribute]
public sealed virtual bool Equals(BiMap`2<A, B> y);
    [PureAttribute]
public Option`1<B> Find(A value);
    [PureAttribute]
public Option`1<A> Find(B value);
    [PureAttribute]
public MapEnumerator`2<A, B> GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator`1<ValueTuple`2<A, B>> System.Collections.Generic.IEnumerable<(ALeft,BRight)>.GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public sealed virtual int CompareTo(BiMap`2<A, B> rhs);
    [NullableContextAttribute("2")]
[PureAttribute]
public sealed virtual int CompareTo(object obj);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public static bool op_Equality(BiMap`2<A, B> lhs, BiMap`2<A, B> rhs);
    [PureAttribute]
public static bool op_Inequality(BiMap`2<A, B> lhs, BiMap`2<A, B> rhs);
    [PureAttribute]
public static bool op_LessThan(BiMap`2<A, B> lhs, BiMap`2<A, B> rhs);
    [PureAttribute]
public static bool op_LessThanOrEqual(BiMap`2<A, B> lhs, BiMap`2<A, B> rhs);
    [PureAttribute]
public static bool op_GreaterThan(BiMap`2<A, B> lhs, BiMap`2<A, B> rhs);
    [PureAttribute]
public static bool op_GreaterThanOrEqual(BiMap`2<A, B> lhs, BiMap`2<A, B> rhs);
    [PureAttribute]
public static BiMap`2<A, B> op_Addition(BiMap`2<A, B> lhs, BiMap`2<A, B> rhs);
    [PureAttribute]
public static BiMap`2<A, B> op_Subtraction(BiMap`2<A, B> lhs, BiMap`2<A, B> rhs);
    [PureAttribute]
public virtual int GetHashCode();
    public static BiMap`2<A, B> op_Implicit(SeqEmpty _);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Bind`2 : Free`2<F, A> {
    [CompilerGeneratedAttribute]
private K`2<F, Free`2<F, A>> <Value>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public K`2<F, Free`2<F, A>> Value { get; public set; }
    public Bind`2(K`2<F, Free`2<F, A>> Value);
    [CompilerGeneratedAttribute]
private Bind`2(Bind`2<F, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public K`2<F, Free`2<F, A>> get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(K`2<F, Free`2<F, A>> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Bind`2<F, A> left, Bind`2<F, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Bind`2<F, A> left, Bind`2<F, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Free`2<F, A> other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Bind`2<F, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override Bind`2<F, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(K`2& Value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class LanguageExt.BindIO`1 : IOResponse`1<A> {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected BindIO`1(BindIO`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public abstract virtual IO`1<A> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(BindIO`1<A> left, BindIO`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(BindIO`1<A> left, BindIO`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(IOResponse`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(BindIO`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public abstract virtual override BindIO`1<A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.BindIO`2 : BindIO`1<A> {
    [CompilerGeneratedAttribute]
private X <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<X, IO`1<A>> <Computation>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public X Value { get; public set; }
    public Func`2<X, IO`1<A>> Computation { get; public set; }
    public BindIO`2(X Value, Func`2<X, IO`1<A>> Computation);
    [CompilerGeneratedAttribute]
protected BindIO`2(BindIO`2<X, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public X get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(X value);
    [CompilerGeneratedAttribute]
public Func`2<X, IO`1<A>> get_Computation();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Computation(Func`2<X, IO`1<A>> value);
    public virtual IO`1<A> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(BindIO`2<X, A> left, BindIO`2<X, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(BindIO`2<X, A> left, BindIO`2<X, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(BindIO`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(BindIO`2<X, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override BindIO`2<X, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(X& Value, Func`2& Computation);
}
internal static class LanguageExt.Bit : object {
    public static UInt32 Set(UInt32 value, int bit, bool flag);
    public static UInt32 Set(UInt32 value, UInt32 bit, bool flag);
    public static bool Get(UInt32 value, int bit);
    public static bool Get(UInt32 value, UInt32 bit);
    public static int Get(UInt32 data, Sec section);
    public static UInt32 Set(UInt32 data, Sec section, int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.Box`1 : object {
    public A Value;
    public static Func`2<A, object> New;
    public static Func`2<object, A> GetValue;
    public Box`1(A value);
    private static Box`1();
    private static Func`2<object, A> GetValueClass();
    private static Func`2<object, A> GetValueStruct();
    private static Func`2<A, object> MakeNewClass();
    private static Func`2<A, object> MakeNewStruct();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class LanguageExt.CatchM`3 : ValueType {
    [CompilerGeneratedAttribute]
private Func`2<E, bool> <Match>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<E, K`2<M, A>> <Action>k__BackingField;
    public Func`2<E, bool> Match { get; public set; }
    public Func`2<E, K`2<M, A>> Action { get; public set; }
    public CatchM`3(Func`2<E, bool> Match, Func`2<E, K`2<M, A>> Action);
    [CompilerGeneratedAttribute]
public Func`2<E, bool> get_Match();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Match(Func`2<E, bool> value);
    [CompilerGeneratedAttribute]
public Func`2<E, K`2<M, A>> get_Action();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Action(Func`2<E, K`2<M, A>> value);
    public K`2<M, A> Run(E error, K`2<M, A> otherwise);
    public static K`2<M, A> op_BitwiseOr(K`2<M, A> lhs, CatchM`3<E, M, A> rhs);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(CatchM`3<E, M, A> left, CatchM`3<E, M, A> right);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public static bool op_Equality(CatchM`3<E, M, A> left, CatchM`3<E, M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CatchM`3<E, M, A> other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`2& Match, Func`2& Action);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.Change : object {
    public static string UseEffMonadInstead;
    public static string UseIOMonadInstead;
    public static string UseEffMonadInsteadOfAff;
    public static string UseTransducersInstead;
    public static string UseCollectionIntialiser;
    public static string UseCollectionIntialiserSeq;
    public static string UseToArrayInstead;
    public static string UseToListInstead;
    public static string UseToSeqInstead;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.Change`1 : object {
    public bool HasNoChange { get; }
    public bool HasChanged { get; }
    public bool HasRemoved { get; }
    public bool HasMapped { get; }
    public bool HasAdded { get; }
    public static Change`1<A> None { get; }
    private static Change`1<A> LanguageExt.Traits.Monoid<LanguageExt.Change<A>>.Empty { get; }
    public bool get_HasNoChange();
    public bool get_HasChanged();
    public bool get_HasRemoved();
    public bool get_HasMapped();
    [NullableContextAttribute("2")]
public bool HasMappedFrom();
    public bool get_HasAdded();
    public Option`1<A> ToOption();
    public static Change`1<A> get_None();
    public static Change`1<A> Removed(A oldValue);
    public static Change`1<A> Added(A value);
    public static Change`1<A> Mapped(FROM oldValue, A value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public abstract virtual bool Equals(Change`1<A> obj);
    public virtual int GetHashCode();
    public sealed virtual Change`1<A> Combine(Change`1<A> y);
    private static override Change`1<A> LanguageExt.Traits.Monoid<LanguageExt.Change<A>>.get_Empty();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.Channel`1 : object {
    private ConcurrentQueue`1<Ev`1<A>> queue;
    private AutoResetEvent wait;
    public int Count { get; }
    protected virtual override void Finalize();
    public int get_Count();
    internal Unit Post(Ev`1<A> event);
    public Unit Post(A value);
    public Unit Stop();
    [AsyncIteratorStateMachineAttribute("LanguageExt.Channel`1/<GetAsyncEnumerator>d__9")]
public sealed virtual IAsyncEnumerator`1<A> GetAsyncEnumerator(CancellationToken cancellationToken);
}
internal static class LanguageExt.Check : object {
    [NullableContextAttribute("1")]
internal static T NullReturn(T value);
}
internal static class LanguageExt.Check`1 : object {
    private static bool IsReferenceType;
    private static bool IsNullable;
    private static Check`1();
    internal static bool IsDefault(A value);
    internal static bool IsNull(A value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class LanguageExt.Choice : object {
    [PureAttribute]
public static R matchUntyped(CH ma, Func`2<object, R> Left, Func`2<object, R> Right, Func`1<R> Bottom);
    [PureAttribute]
public static Arr`1<B> toArray(CH ma);
    [PureAttribute]
public static Lst`1<B> toList(CH ma);
    [NullableContextAttribute("1")]
[PureAttribute]
public static IEnumerable`1<B> toSeq(CH ma);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Either`2<A, B> toEither(CH ma);
    [PureAttribute]
public static Option`1<B> toOption(CH ma);
    [NullableContextAttribute("1")]
[PureAttribute]
public static B ifLeft(CH ma, Func`1<B> Left);
    [NullableContextAttribute("1")]
[PureAttribute]
public static B ifLeft(CH ma, Func`2<A, B> leftMap);
    [NullableContextAttribute("1")]
[PureAttribute]
public static B ifLeft(CH ma, B rightValue);
    [NullableContextAttribute("1")]
public static Unit ifLeft(CH ma, Action`1<A> Left);
    [NullableContextAttribute("1")]
public static Unit ifRight(CH ma, Action`1<B> Right);
    [NullableContextAttribute("1")]
[PureAttribute]
public static A ifRight(CH ma, A leftValue);
    [NullableContextAttribute("1")]
[PureAttribute]
public static A ifRight(CH ma, Func`1<A> Right);
    [NullableContextAttribute("1")]
[PureAttribute]
public static A ifRight(CH ma, Func`2<B, A> rightMap);
    [PureAttribute]
public static Lst`1<B> rightToList(CH ma);
    [PureAttribute]
public static Arr`1<B> rightToArray(CH ma);
    [PureAttribute]
public static Lst`1<A> leftToList(CH ma);
    [PureAttribute]
public static Arr`1<A> leftToArray(CH ma);
    [PureAttribute]
public static Seq`1<B> rightAsEnumerable(CH ma);
    [PureAttribute]
public static Seq`1<A> leftAsEnumerable(CH ma);
    [PureAttribute]
public static int hashCode(CH ma);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("LanguageExt.Choice/<lefts>d__21`4")]
[PureAttribute]
public static IEnumerable`1<A> lefts(IEnumerable`1<CH> ma);
    [PureAttribute]
public static Seq`1<A> lefts(Seq`1<CH> ma);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("LanguageExt.Choice/<rights>d__23`4")]
[PureAttribute]
public static IEnumerable`1<B> rights(IEnumerable`1<CH> ma);
    [PureAttribute]
public static Seq`1<B> rights(Seq`1<CH> ma);
    [PureAttribute]
public static ValueTuple`2<IEnumerable`1<A>, IEnumerable`1<B>> partition(IEnumerable`1<CH> ma);
    [PureAttribute]
public static ValueTuple`2<Seq`1<A>, Seq`1<B>> partition(Seq`1<CH> ma);
}
public class LanguageExt.ClassInstances.EqArr`1 : ValueType {
    [PureAttribute]
public static override bool Equals(Arr`1<A> x, Arr`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Arr`1<A> x);
}
public class LanguageExt.ClassInstances.EqArr`2 : ValueType {
    [PureAttribute]
public static override bool Equals(Arr`1<A> x, Arr`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Arr`1<A> x);
}
public class LanguageExt.ClassInstances.EqArray`1 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(A[] x, A[] y);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(A[] x);
}
public class LanguageExt.ClassInstances.EqArray`2 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(A[] x, A[] y);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(A[] x);
}
public class LanguageExt.ClassInstances.EqBigInt : ValueType {
    [PureAttribute]
public static override bool Equals(bigint a, bigint b);
    [PureAttribute]
public static override int GetHashCode(bigint x);
}
public class LanguageExt.ClassInstances.EqBool : ValueType {
    [PureAttribute]
public static override bool Equals(bool a, bool b);
    [PureAttribute]
public static override int GetHashCode(bool x);
}
public class LanguageExt.ClassInstances.EqChar : ValueType {
    [PureAttribute]
public static override bool Equals(char a, char b);
    [PureAttribute]
public static override int GetHashCode(char x);
}
public class LanguageExt.ClassInstances.EqCharOrdinalIgnoreCase : ValueType {
    [PureAttribute]
public static override bool Equals(char a, char b);
    [PureAttribute]
public static override int GetHashCode(char x);
}
public class LanguageExt.ClassInstances.EqChoice`4 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(CH x, CH y);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(CH x);
}
public class LanguageExt.ClassInstances.EqChoice`5 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(CH x, CH y);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(CH x);
}
public class LanguageExt.ClassInstances.EqChoice`6 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(CH x, CH y);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(CH x);
}
public class LanguageExt.ClassInstances.EqCompositions`1 : ValueType {
    [PureAttribute]
public static override bool Equals(Compositions`1<A> x, Compositions`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Compositions`1<A> x);
}
public class LanguageExt.ClassInstances.EqDateTime : ValueType {
    [PureAttribute]
public static override bool Equals(DateTime a, DateTime b);
    [PureAttribute]
public static override int GetHashCode(DateTime x);
}
public class LanguageExt.ClassInstances.EqDecimal : ValueType {
    [PureAttribute]
public static override bool Equals(decimal a, decimal b);
    [PureAttribute]
public static override int GetHashCode(decimal x);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Task`1<bool> EqualsAsync(decimal x, decimal y);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Task`1<int> GetHashCodeAsync(decimal x);
}
[IsReadOnlyAttribute]
public class LanguageExt.ClassInstances.EqDefault`1 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(A a, A b);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(A x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.ClassInstances.EqDefault`2 : object {
    private static Func`3<A, B, bool> Eq;
    private static EqDefault`2();
    [PureAttribute]
public static bool Equals(A a, B b);
}
public class LanguageExt.ClassInstances.EqDouble : ValueType {
    [PureAttribute]
public static override bool Equals(double a, double b);
    [PureAttribute]
public static override int GetHashCode(double x);
}
public class LanguageExt.ClassInstances.EqEdit`2 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(Edit`2<EqA, A> x, Edit`2<EqA, A> y);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(Edit`2<EqA, A> x);
}
public class LanguageExt.ClassInstances.EqEither`2 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(Either`2<L, R> x, Either`2<L, R> y);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(Either`2<L, R> x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.EqEither`4 : ValueType {
    [PureAttribute]
public static override bool Equals(Either`2<L, R> x, Either`2<L, R> y);
    [PureAttribute]
public static override int GetHashCode(Either`2<L, R> x);
    [PureAttribute]
public static Task`1<int> GetHashCodeAsync(Either`2<L, R> x);
    [PureAttribute]
public static Task`1<bool> EqualsAsync(Either`2<L, R> x, Either`2<L, R> y);
}
public class LanguageExt.ClassInstances.EqEnumerable`1 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(IEnumerable`1<A> x, IEnumerable`1<A> y);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(IEnumerable`1<A> x);
}
public class LanguageExt.ClassInstances.EqEnumerable`2 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(IEnumerable`1<A> x, IEnumerable`1<A> y);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(IEnumerable`1<A> x);
}
public class LanguageExt.ClassInstances.EqException : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(Exception x);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(Exception x, Exception y);
}
public class LanguageExt.ClassInstances.EqFloat : ValueType {
    [PureAttribute]
public static override bool Equals(float a, float b);
    [PureAttribute]
public static override int GetHashCode(float x);
}
public class LanguageExt.ClassInstances.EqGuid : ValueType {
    [PureAttribute]
public static override bool Equals(Guid a, Guid b);
    [PureAttribute]
public static override int GetHashCode(Guid x);
}
public class LanguageExt.ClassInstances.EqHashSet`1 : ValueType {
    [PureAttribute]
public static override bool Equals(HashSet`1<A> x, HashSet`1<A> y);
    [PureAttribute]
public static override int GetHashCode(HashSet`1<A> x);
}
public class LanguageExt.ClassInstances.EqHashSet`2 : ValueType {
    [PureAttribute]
public static override bool Equals(HashSet`1<A> x, HashSet`1<A> y);
    [PureAttribute]
public static override int GetHashCode(HashSet`1<A> x);
}
public class LanguageExt.ClassInstances.EqIdentity`1 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(Identity`1<A> a, Identity`1<A> b);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(Identity`1<A> x);
}
public class LanguageExt.ClassInstances.EqInt : ValueType {
    [PureAttribute]
public static override bool Equals(int a, int b);
    [PureAttribute]
public static override int GetHashCode(int x);
}
public class LanguageExt.ClassInstances.EqIterable`1 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(Iterable`1<A> x, Iterable`1<A> y);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(Iterable`1<A> x);
}
public class LanguageExt.ClassInstances.EqIterable`2 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(Iterable`1<A> x, Iterable`1<A> y);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(Iterable`1<A> x);
}
public class LanguageExt.ClassInstances.EqLong : ValueType {
    [PureAttribute]
public static override bool Equals(long a, long b);
    [PureAttribute]
public static override int GetHashCode(long x);
}
public class LanguageExt.ClassInstances.EqLst`1 : ValueType {
    [PureAttribute]
public static override bool Equals(Lst`1<A> x, Lst`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Lst`1<A> x);
}
public class LanguageExt.ClassInstances.EqLst`2 : ValueType {
    [PureAttribute]
public static override bool Equals(Lst`1<A> x, Lst`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Lst`1<A> x);
}
public class LanguageExt.ClassInstances.EqMap`2 : ValueType {
    [PureAttribute]
public static override bool Equals(Map`2<K, V> x, Map`2<K, V> y);
    [PureAttribute]
public static override int GetHashCode(Map`2<K, V> x);
}
public class LanguageExt.ClassInstances.EqMap`3 : ValueType {
    [PureAttribute]
public static override bool Equals(Map`3<OrdK, K, V> x, Map`3<OrdK, K, V> y);
    [PureAttribute]
public static override int GetHashCode(Map`3<OrdK, K, V> x);
}
public class LanguageExt.ClassInstances.EqOption`1 : ValueType {
    [PureAttribute]
public static override bool Equals(Option`1<A> x, Option`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Option`1<A> x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.EqOptional`3 : ValueType {
    [PureAttribute]
public static override bool Equals(OA x, OA y);
    [PureAttribute]
public static override int GetHashCode(OA x);
    [PureAttribute]
public static Task`1<bool> EqualsAsync(OA x, OA y);
    [PureAttribute]
public static Task`1<int> GetHashCodeAsync(OA x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.EqOptional`4 : ValueType {
    [PureAttribute]
public static override bool Equals(OA x, OA y);
    [PureAttribute]
public static override int GetHashCode(OA x);
    [PureAttribute]
public static Task`1<bool> EqualsAsync(OA x, OA y);
    [PureAttribute]
public static Task`1<int> GetHashCodeAsync(OA x);
}
public class LanguageExt.ClassInstances.EqPatch`2 : ValueType {
    [PureAttribute]
public static override bool Equals(Patch`2<EqA, A> x, Patch`2<EqA, A> y);
    [PureAttribute]
public static override int GetHashCode(Patch`2<EqA, A> x);
}
public class LanguageExt.ClassInstances.EqQue`1 : ValueType {
    [PureAttribute]
public static override bool Equals(Que`1<A> x, Que`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Que`1<A> x);
}
public class LanguageExt.ClassInstances.EqQue`2 : ValueType {
    [PureAttribute]
public static override bool Equals(Que`1<A> x, Que`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Que`1<A> x);
}
public class LanguageExt.ClassInstances.EqRecord`1 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(A x, A y);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(A x);
}
public class LanguageExt.ClassInstances.EqSeq`1 : ValueType {
    [PureAttribute]
public static override bool Equals(Seq`1<A> x, Seq`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Seq`1<A> x);
}
public class LanguageExt.ClassInstances.EqSeq`2 : ValueType {
    [PureAttribute]
public static override bool Equals(Seq`1<A> x, Seq`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Seq`1<A> x);
}
public class LanguageExt.ClassInstances.EqSet`1 : ValueType {
    [PureAttribute]
public static override bool Equals(Set`1<A> x, Set`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Set`1<A> x);
}
public class LanguageExt.ClassInstances.EqSet`2 : ValueType {
    [PureAttribute]
public static override bool Equals(Set`1<A> x, Set`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Set`1<A> x);
}
public class LanguageExt.ClassInstances.EqShort : ValueType {
    [PureAttribute]
public static override bool Equals(short a, short b);
    [PureAttribute]
public static override int GetHashCode(short x);
}
public class LanguageExt.ClassInstances.EqStck`1 : ValueType {
    [PureAttribute]
public static override bool Equals(Stck`1<A> x, Stck`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Stck`1<A> x);
}
public class LanguageExt.ClassInstances.EqStck`2 : ValueType {
    [PureAttribute]
public static override bool Equals(Stck`1<A> x, Stck`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Stck`1<A> x);
}
public class LanguageExt.ClassInstances.EqString : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(string a, string b);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(string x);
}
public class LanguageExt.ClassInstances.EqStringCurrentCulture : ValueType {
    public static EqStringCurrentCulture Inst;
    private static EqStringCurrentCulture();
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(string a, string b);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(string x);
}
public class LanguageExt.ClassInstances.EqStringCurrentCultureIgnoreCase : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(string a, string b);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(string x);
}
public class LanguageExt.ClassInstances.EqStringInvariantCulture : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(string a, string b);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(string x);
}
public class LanguageExt.ClassInstances.EqStringInvariantCultureIgnoreCase : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(string a, string b);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(string x);
}
public class LanguageExt.ClassInstances.EqStringOrdinal : ValueType {
    public static EqStringOrdinal Inst;
    private static EqStringOrdinal();
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(string a, string b);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(string x);
}
public class LanguageExt.ClassInstances.EqStringOrdinalIgnoreCase : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(string a, string b);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(string x);
}
public class LanguageExt.ClassInstances.EqTask`1 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(Task`1<A> x, Task`1<A> y);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(Task`1<A> x);
}
public class LanguageExt.ClassInstances.EqTrue`1 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(A x, A y);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(A x);
}
public class LanguageExt.ClassInstances.EqTuple2`4 : ValueType {
    public static override int GetHashCode(ValueTuple`2<A, B> pair);
    public static override bool Equals(ValueTuple`2<A, B> x, ValueTuple`2<A, B> y);
}
public class LanguageExt.ClassInstances.EqTypeInfo : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override bool Equals(TypeInfo x, TypeInfo y);
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(TypeInfo x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.FoldCompositions`1 : ValueType {
    private static S FoldNode(S state, Func`3<S, A, S> f, Node<A> node);
    private static S FoldNodes(S state, Func`3<S, A, S> f, Seq`1<Node<A>> nodes);
    private static S FoldNodeBack(S state, Func`3<S, A, S> f, Node<A> node);
    private static S FoldNodesBack(S state, Func`3<S, A, S> f, Seq`1<Node<A>> nodes);
    internal static Seq`1<B> FoldMap(Func`2<A, B> f, Seq`1<Node<A>> nodes);
    internal static Seq`1<B> FoldMapBack(Func`2<A, B> f, Seq`1<Node<A>> nodes);
    public static Func`2<Unit, int> Count(Compositions`1<A> fa);
    public static Func`2<Unit, S> Fold(Compositions`1<A> fa, S state, Func`3<S, A, S> f);
    public static Func`2<Unit, S> FoldBack(Compositions`1<A> fa, S state, Func`3<S, A, S> f);
}
public class LanguageExt.ClassInstances.HashableArr`1 : ValueType {
    [PureAttribute]
public static override int GetHashCode(Arr`1<A> x);
}
public class LanguageExt.ClassInstances.HashableArr`2 : ValueType {
    [PureAttribute]
public static override int GetHashCode(Arr`1<A> x);
}
public class LanguageExt.ClassInstances.HashableArray`1 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(A[] x);
}
public class LanguageExt.ClassInstances.HashableArray`2 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(A[] x);
}
public class LanguageExt.ClassInstances.HashableBigInt : ValueType {
    [PureAttribute]
public static override int GetHashCode(bigint x);
}
public class LanguageExt.ClassInstances.HashableBool : ValueType {
    [PureAttribute]
public static override int GetHashCode(bool x);
}
public class LanguageExt.ClassInstances.HashableChar : ValueType {
    [PureAttribute]
public static override int GetHashCode(char x);
}
public class LanguageExt.ClassInstances.HashableCharOrdinalIgnoreCase : ValueType {
    [PureAttribute]
public static override int GetHashCode(char x);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.HashableChoice`4 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(CH x);
}
public class LanguageExt.ClassInstances.HashableChoice`5 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(CH x);
}
public class LanguageExt.ClassInstances.HashableChoice`6 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(CH x);
}
public class LanguageExt.ClassInstances.HashableCompositions`1 : ValueType {
    [PureAttribute]
public static override int GetHashCode(Compositions`1<A> x);
}
public class LanguageExt.ClassInstances.HashableDateTime : ValueType {
    [PureAttribute]
public static override int GetHashCode(DateTime x);
}
public class LanguageExt.ClassInstances.HashableDecimal : ValueType {
    [PureAttribute]
public static override int GetHashCode(decimal x);
}
public class LanguageExt.ClassInstances.HashableDefault`1 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(A x);
}
public class LanguageExt.ClassInstances.HashableDouble : ValueType {
    [PureAttribute]
public static override int GetHashCode(double x);
}
public class LanguageExt.ClassInstances.HashableEdit`2 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(Edit`2<EqA, A> x);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class LanguageExt.ClassInstances.HashableEither`2 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(Either`2<L, R> x);
}
[IsReadOnlyAttribute]
public class LanguageExt.ClassInstances.HashableEither`4 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(Either`2<L, R> x);
}
public class LanguageExt.ClassInstances.HashableEnumerable`1 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(IEnumerable`1<A> x);
}
public class LanguageExt.ClassInstances.HashableEnumerable`2 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(IEnumerable`1<A> x);
}
public class LanguageExt.ClassInstances.HashableException : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(Exception x);
}
public class LanguageExt.ClassInstances.HashableFloat : ValueType {
    [PureAttribute]
public static override int GetHashCode(float x);
}
public class LanguageExt.ClassInstances.HashableGuid : ValueType {
    [PureAttribute]
public static override int GetHashCode(Guid x);
}
public class LanguageExt.ClassInstances.HashableHashSet`1 : ValueType {
    [PureAttribute]
public static override int GetHashCode(HashSet`1<A> x);
}
public class LanguageExt.ClassInstances.HashableHashSet`2 : ValueType {
    [PureAttribute]
public static override int GetHashCode(HashSet`1<A> x);
}
public class LanguageExt.ClassInstances.HashableIdentity`1 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(Identity`1<A> x);
}
public class LanguageExt.ClassInstances.HashableInt : ValueType {
    [PureAttribute]
public static override int GetHashCode(int x);
}
public class LanguageExt.ClassInstances.HashableIterable`1 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(Iterable`1<A> x);
}
public class LanguageExt.ClassInstances.HashableIterable`2 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(Iterable`1<A> x);
}
public class LanguageExt.ClassInstances.HashableLong : ValueType {
    [PureAttribute]
public static override int GetHashCode(long x);
}
public class LanguageExt.ClassInstances.HashableLst`1 : ValueType {
    [PureAttribute]
public static override int GetHashCode(Lst`1<A> x);
}
public class LanguageExt.ClassInstances.HashableLst`2 : ValueType {
    [PureAttribute]
public static override int GetHashCode(Lst`1<A> x);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.HashableMap`2 : ValueType {
    [PureAttribute]
public static override int GetHashCode(Map`2<K, V> x);
}
public class LanguageExt.ClassInstances.HashableMap`3 : ValueType {
    [PureAttribute]
public static override int GetHashCode(Map`3<OrdK, K, V> x);
}
public class LanguageExt.ClassInstances.HashableOption`1 : ValueType {
    public static override int GetHashCode(Option`1<A> x);
}
public class LanguageExt.ClassInstances.HashableOptional`3 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(OA x);
}
public class LanguageExt.ClassInstances.HashableOptional`4 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(OA x);
}
public class LanguageExt.ClassInstances.HashablePatch`2 : ValueType {
    [PureAttribute]
public static override int GetHashCode(Patch`2<EqA, A> x);
}
public class LanguageExt.ClassInstances.HashableQue`1 : ValueType {
    [PureAttribute]
public static override int GetHashCode(Que`1<A> x);
}
public class LanguageExt.ClassInstances.HashableQue`2 : ValueType {
    [PureAttribute]
public static override int GetHashCode(Que`1<A> x);
}
public class LanguageExt.ClassInstances.HashableRecord`1 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(A x);
}
public class LanguageExt.ClassInstances.HashableSeq`1 : ValueType {
    [PureAttribute]
public static override int GetHashCode(Seq`1<A> x);
}
public class LanguageExt.ClassInstances.HashableSeq`2 : ValueType {
    [PureAttribute]
public static override int GetHashCode(Seq`1<A> x);
}
public class LanguageExt.ClassInstances.HashableSet`1 : ValueType {
    [PureAttribute]
public static override int GetHashCode(Set`1<A> x);
}
public class LanguageExt.ClassInstances.HashableSet`2 : ValueType {
    [PureAttribute]
public static override int GetHashCode(Set`1<A> x);
}
public class LanguageExt.ClassInstances.HashableShort : ValueType {
    [PureAttribute]
public static override int GetHashCode(short x);
}
public class LanguageExt.ClassInstances.HashableStck`1 : ValueType {
    [PureAttribute]
public static override int GetHashCode(Stck`1<A> x);
}
public class LanguageExt.ClassInstances.HashableStck`2 : ValueType {
    [PureAttribute]
public static override int GetHashCode(Stck`1<A> x);
}
public class LanguageExt.ClassInstances.HashableString : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(string x);
}
public class LanguageExt.ClassInstances.HashableStringCurrentCulture : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(string x);
}
public class LanguageExt.ClassInstances.HashableStringCurrentCultureIgnoreCase : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(string x);
}
public class LanguageExt.ClassInstances.HashableStringInvariantCulture : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(string x);
}
public class LanguageExt.ClassInstances.HashableStringInvariantCultureIgnoreCase : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(string x);
}
public class LanguageExt.ClassInstances.HashableStringOrdinal : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(string x);
}
public class LanguageExt.ClassInstances.HashableStringOrdinalIgnoreCase : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(string x);
}
public class LanguageExt.ClassInstances.HashableTask`1 : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(Task`1<A> x);
}
public class LanguageExt.ClassInstances.HashableTuple`4 : ValueType {
    public static override int GetHashCode(ValueTuple`2<A, B> pair);
}
public class LanguageExt.ClassInstances.HashableTypeInfo : ValueType {
    [NullableContextAttribute("1")]
[PureAttribute]
public static override int GetHashCode(TypeInfo x);
}
public class LanguageExt.ClassInstances.OrdArr`1 : ValueType {
    [PureAttribute]
public static override bool Equals(Arr`1<A> x, Arr`1<A> y);
    [PureAttribute]
public static override int Compare(Arr`1<A> mx, Arr`1<A> my);
    [PureAttribute]
public static override int GetHashCode(Arr`1<A> x);
}
public class LanguageExt.ClassInstances.OrdArr`2 : ValueType {
    [PureAttribute]
public static override bool Equals(Arr`1<A> x, Arr`1<A> y);
    [PureAttribute]
public static override int Compare(Arr`1<A> mx, Arr`1<A> my);
    [PureAttribute]
public static override int GetHashCode(Arr`1<A> x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdArray`1 : ValueType {
    [PureAttribute]
public static override bool Equals(A[] x, A[] y);
    [PureAttribute]
public static override int Compare(A[] mx, A[] my);
    [PureAttribute]
public static override int GetHashCode(A[] x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdArray`2 : ValueType {
    [PureAttribute]
public static override bool Equals(A[] x, A[] y);
    [PureAttribute]
public static override int Compare(A[] mx, A[] my);
    [PureAttribute]
public static override int GetHashCode(A[] x);
}
public class LanguageExt.ClassInstances.OrdBigInt : ValueType {
    [PureAttribute]
public static override bool Equals(bigint x, bigint y);
    [PureAttribute]
public static override int Compare(bigint x, bigint y);
    [PureAttribute]
public static override int GetHashCode(bigint x);
}
public class LanguageExt.ClassInstances.OrdBool : ValueType {
    [PureAttribute]
public static override bool Equals(bool x, bool y);
    [PureAttribute]
public static override int Compare(bool x, bool y);
    [PureAttribute]
public static override int GetHashCode(bool x);
}
public class LanguageExt.ClassInstances.OrdChar : ValueType {
    public static OrdChar Inst;
    [PureAttribute]
public static override bool Equals(char x, char y);
    [PureAttribute]
public static override int Compare(char x, char y);
    [PureAttribute]
public static override int GetHashCode(char x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdChoice`4 : ValueType {
    [PureAttribute]
public static override int Compare(CH x, CH y);
    [PureAttribute]
public static override bool Equals(CH x, CH y);
    [PureAttribute]
public static override int GetHashCode(CH x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdChoice`5 : ValueType {
    [PureAttribute]
public static override int Compare(CH x, CH y);
    [PureAttribute]
public static override bool Equals(CH x, CH y);
    [PureAttribute]
public static override int GetHashCode(CH x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdChoice`6 : ValueType {
    [PureAttribute]
public static override int Compare(CH x, CH y);
    [PureAttribute]
public static override bool Equals(CH x, CH y);
    [PureAttribute]
public static override int GetHashCode(CH x);
}
public class LanguageExt.ClassInstances.OrdDateTime : ValueType {
    [PureAttribute]
public static override bool Equals(DateTime x, DateTime y);
    [PureAttribute]
public static override int Compare(DateTime x, DateTime y);
    [PureAttribute]
public static override int GetHashCode(DateTime x);
}
public class LanguageExt.ClassInstances.OrdDecimal : ValueType {
    [PureAttribute]
public static override bool Equals(decimal x, decimal y);
    [PureAttribute]
public static override int Compare(decimal x, decimal y);
    [PureAttribute]
public static override int GetHashCode(decimal x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdDefault`1 : ValueType {
    [PureAttribute]
public static override int Compare(A x, A y);
    [PureAttribute]
public static override bool Equals(A x, A y);
    [PureAttribute]
public static override int GetHashCode(A x);
}
public class LanguageExt.ClassInstances.OrdDouble : ValueType {
    [PureAttribute]
public static override bool Equals(double x, double y);
    [PureAttribute]
public static override int Compare(double x, double y);
    [PureAttribute]
public static override int GetHashCode(double x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdEither`2 : ValueType {
    [PureAttribute]
public static override int Compare(Either`2<L, R> x, Either`2<L, R> y);
    [PureAttribute]
public static override bool Equals(Either`2<L, R> x, Either`2<L, R> y);
    [PureAttribute]
public static override int GetHashCode(Either`2<L, R> x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdEither`4 : ValueType {
    [PureAttribute]
public static override int Compare(Either`2<L, R> x, Either`2<L, R> y);
    [PureAttribute]
public static override bool Equals(Either`2<L, R> x, Either`2<L, R> y);
    [PureAttribute]
public static override int GetHashCode(Either`2<L, R> x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdEnumerable`1 : ValueType {
    [PureAttribute]
public static override bool Equals(IEnumerable`1<A> x, IEnumerable`1<A> y);
    [PureAttribute]
public static override int Compare(IEnumerable`1<A> x, IEnumerable`1<A> y);
    [PureAttribute]
public static override int GetHashCode(IEnumerable`1<A> x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdEnumerable`2 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static OrdEnumerable`2<OrdA, A> Inst;
    [PureAttribute]
public static override bool Equals(IEnumerable`1<A> x, IEnumerable`1<A> y);
    [PureAttribute]
public static override int Compare(IEnumerable`1<A> x, IEnumerable`1<A> y);
    [PureAttribute]
public static override int GetHashCode(IEnumerable`1<A> x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdException : ValueType {
    [PureAttribute]
public static override int GetHashCode(Exception x);
    [PureAttribute]
public static override bool Equals(Exception x, Exception y);
    [PureAttribute]
public static override int Compare(Exception x, Exception y);
}
public class LanguageExt.ClassInstances.OrdFloat : ValueType {
    [PureAttribute]
public static override bool Equals(float x, float y);
    [PureAttribute]
public static override int Compare(float x, float y);
    [PureAttribute]
public static override int GetHashCode(float x);
}
public class LanguageExt.ClassInstances.OrdGuid : ValueType {
    [PureAttribute]
public static override bool Equals(Guid x, Guid y);
    [PureAttribute]
public static override int Compare(Guid x, Guid y);
    [PureAttribute]
public static override int GetHashCode(Guid x);
}
public class LanguageExt.ClassInstances.OrdHashSet`1 : ValueType {
    [PureAttribute]
public static override bool Equals(HashSet`1<A> x, HashSet`1<A> y);
    [PureAttribute]
public static override int Compare(HashSet`1<A> x, HashSet`1<A> y);
    [PureAttribute]
public static override int GetHashCode(HashSet`1<A> x);
}
public class LanguageExt.ClassInstances.OrdHashSet`2 : ValueType {
    [PureAttribute]
public static override bool Equals(HashSet`1<A> x, HashSet`1<A> y);
    [PureAttribute]
public static override int Compare(HashSet`1<A> x, HashSet`1<A> y);
    [PureAttribute]
public static override int GetHashCode(HashSet`1<A> x);
}
public class LanguageExt.ClassInstances.OrdInt : ValueType {
    [PureAttribute]
public static override bool Equals(int x, int y);
    [PureAttribute]
public static override int Compare(int x, int y);
    [PureAttribute]
public static override int GetHashCode(int x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdIterable`1 : ValueType {
    [PureAttribute]
public static override bool Equals(Iterable`1<A> x, Iterable`1<A> y);
    [PureAttribute]
public static override int Compare(Iterable`1<A> x, Iterable`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Iterable`1<A> x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdIterable`2 : ValueType {
    [PureAttribute]
public static override bool Equals(Iterable`1<A> x, Iterable`1<A> y);
    [PureAttribute]
public static override int Compare(Iterable`1<A> x, Iterable`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Iterable`1<A> x);
}
public class LanguageExt.ClassInstances.OrdLong : ValueType {
    [PureAttribute]
public static override bool Equals(long x, long y);
    [PureAttribute]
public static override int Compare(long x, long y);
    [PureAttribute]
public static override int GetHashCode(long x);
}
public class LanguageExt.ClassInstances.OrdLst`1 : ValueType {
    [PureAttribute]
public static override bool Equals(Lst`1<A> x, Lst`1<A> y);
    [PureAttribute]
public static override int Compare(Lst`1<A> x, Lst`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Lst`1<A> x);
}
public class LanguageExt.ClassInstances.OrdLst`2 : ValueType {
    [PureAttribute]
public static override bool Equals(Lst`1<A> x, Lst`1<A> y);
    [PureAttribute]
public static override int Compare(Lst`1<A> mx, Lst`1<A> my);
    [PureAttribute]
public static override int GetHashCode(Lst`1<A> x);
}
public class LanguageExt.ClassInstances.OrdMap`2 : ValueType {
    [PureAttribute]
public static override int Compare(Map`2<K, V> x, Map`2<K, V> y);
    [PureAttribute]
public static override bool Equals(Map`2<K, V> x, Map`2<K, V> y);
    [PureAttribute]
public static override int GetHashCode(Map`2<K, V> x);
}
public class LanguageExt.ClassInstances.OrdMap`3 : ValueType {
    [PureAttribute]
public static override int Compare(Map`3<OrdK, K, V> x, Map`3<OrdK, K, V> y);
    [PureAttribute]
public static override bool Equals(Map`3<OrdK, K, V> x, Map`3<OrdK, K, V> y);
    [PureAttribute]
public static override int GetHashCode(Map`3<OrdK, K, V> x);
}
public class LanguageExt.ClassInstances.OrdOption`2 : ValueType {
    [PureAttribute]
public static override int Compare(Option`1<A> x, Option`1<A> y);
    [PureAttribute]
public static override bool Equals(Option`1<A> x, Option`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Option`1<A> x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdOptional`3 : ValueType {
    [PureAttribute]
public static override bool Equals(OA x, OA y);
    [PureAttribute]
public static override int Compare(OA mx, OA my);
    [PureAttribute]
public static override int GetHashCode(OA x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdOptional`4 : ValueType {
    [PureAttribute]
public static override bool Equals(OA x, OA y);
    [PureAttribute]
public static override int Compare(OA mx, OA my);
    [PureAttribute]
public static override int GetHashCode(OA x);
}
public class LanguageExt.ClassInstances.OrdQue`1 : ValueType {
    [PureAttribute]
public static override bool Equals(Que`1<A> x, Que`1<A> y);
    [PureAttribute]
public static override int Compare(Que`1<A> x, Que`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Que`1<A> x);
}
public class LanguageExt.ClassInstances.OrdQue`2 : ValueType {
    [PureAttribute]
public static override bool Equals(Que`1<A> x, Que`1<A> y);
    [PureAttribute]
public static override int Compare(Que`1<A> x, Que`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Que`1<A> x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdRecord`1 : ValueType {
    [PureAttribute]
public static override int Compare(A x, A y);
    [PureAttribute]
public static override bool Equals(A x, A y);
    [PureAttribute]
public static override int GetHashCode(A x);
}
public class LanguageExt.ClassInstances.OrdSeq`1 : ValueType {
    [PureAttribute]
public static override bool Equals(Seq`1<A> x, Seq`1<A> y);
    [PureAttribute]
public static override int Compare(Seq`1<A> x, Seq`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Seq`1<A> x);
}
public class LanguageExt.ClassInstances.OrdSeq`2 : ValueType {
    [PureAttribute]
public static override bool Equals(Seq`1<A> x, Seq`1<A> y);
    [PureAttribute]
public static override int Compare(Seq`1<A> x, Seq`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Seq`1<A> x);
}
public class LanguageExt.ClassInstances.OrdSet`1 : ValueType {
    [PureAttribute]
public static override bool Equals(Set`1<A> x, Set`1<A> y);
    [PureAttribute]
public static override int Compare(Set`1<A> x, Set`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Set`1<A> x);
}
public class LanguageExt.ClassInstances.OrdSet`2 : ValueType {
    [PureAttribute]
public static override bool Equals(Set`1<A> x, Set`1<A> y);
    [PureAttribute]
public static override int Compare(Set`1<A> x, Set`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Set`1<A> x);
}
public class LanguageExt.ClassInstances.OrdShort : ValueType {
    [PureAttribute]
public static override bool Equals(short x, short y);
    [PureAttribute]
public static override int Compare(short x, short y);
    [PureAttribute]
public static override int GetHashCode(short x);
}
public class LanguageExt.ClassInstances.OrdStck`1 : ValueType {
    [PureAttribute]
public static override bool Equals(Stck`1<A> x, Stck`1<A> y);
    [PureAttribute]
public static override int Compare(Stck`1<A> x, Stck`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Stck`1<A> x);
}
public class LanguageExt.ClassInstances.OrdStck`2 : ValueType {
    [PureAttribute]
public static override bool Equals(Stck`1<A> x, Stck`1<A> y);
    [PureAttribute]
public static override int Compare(Stck`1<A> x, Stck`1<A> y);
    [PureAttribute]
public static override int GetHashCode(Stck`1<A> x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdString : ValueType {
    public static override int Compare(string a, string b);
    public static override bool Equals(string a, string b);
    public static override int GetHashCode(string x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdStringCurrentCulture : ValueType {
    public static override int Compare(string a, string b);
    public static override bool Equals(string a, string b);
    public static override int GetHashCode(string x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdStringCurrentCultureIgnoreCase : ValueType {
    public static override int Compare(string a, string b);
    public static override bool Equals(string a, string b);
    public static override int GetHashCode(string x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdStringOrdinal : ValueType {
    public static override int Compare(string a, string b);
    public static override bool Equals(string a, string b);
    public static override int GetHashCode(string x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdStringOrdinalIgnoreCase : ValueType {
    public static override int Compare(string a, string b);
    public static override bool Equals(string a, string b);
    public static override int GetHashCode(string x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdTask`1 : ValueType {
    public static override int Compare(Task`1<A> x, Task`1<A> y);
    public static override bool Equals(Task`1<A> x, Task`1<A> y);
    public static override int GetHashCode(Task`1<A> x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdTrue`1 : ValueType {
    public static override int Compare(A x, A y);
    public static override bool Equals(A x, A y);
    public static override int GetHashCode(A x);
}
public class LanguageExt.ClassInstances.OrdTupleFirst`3 : ValueType {
    public static override int Compare(ValueTuple`2<A, B> x, ValueTuple`2<A, B> y);
    public static override bool Equals(ValueTuple`2<A, B> x, ValueTuple`2<A, B> y);
    public static override int GetHashCode(ValueTuple`2<A, B> x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.OrdTypeInfo : ValueType {
    public static override int Compare(TypeInfo x, TypeInfo y);
    public static override bool Equals(TypeInfo x, TypeInfo y);
    public static override int GetHashCode(TypeInfo x);
}
public class LanguageExt.ClassInstances.TBigInt : ValueType {
    [PureAttribute]
public static bigint Empty { get; }
    [PureAttribute]
public static override bool Equals(bigint x, bigint y);
    [PureAttribute]
public static override int Compare(bigint x, bigint y);
    [PureAttribute]
public static override bigint Add(bigint x, bigint y);
    [PureAttribute]
public static override bigint Subtract(bigint x, bigint y);
    [PureAttribute]
public static override bigint Multiply(bigint x, bigint y);
    [PureAttribute]
public static override bigint Divide(bigint x, bigint y);
    [PureAttribute]
public static override bigint Abs(bigint x);
    [PureAttribute]
public static override bigint Signum(bigint x);
    [PureAttribute]
public static override bigint FromInteger(int x);
    [PureAttribute]
public static override bigint FromDecimal(decimal x);
    [PureAttribute]
public static override bigint FromFloat(float x);
    [PureAttribute]
public static override bigint FromDouble(double x);
    public static bigint get_Empty();
    [PureAttribute]
public static override bigint Negate(bigint x);
    [PureAttribute]
public static bigint Append(bigint x, bigint y);
    [PureAttribute]
public static override int GetHashCode(bigint x);
    [PureAttribute]
public static override bigint True();
    [PureAttribute]
public static override bigint False();
    [PureAttribute]
public static override bigint And(bigint a, bigint b);
    [PureAttribute]
public static override bigint Or(bigint a, bigint b);
    [PureAttribute]
public static override bigint Not(bigint a);
    [PureAttribute]
public static override bigint XOr(bigint a, bigint b);
    [PureAttribute]
public static override bigint Implies(bigint a, bigint b);
    [PureAttribute]
public static override bigint BiCondition(bigint a, bigint b);
}
public class LanguageExt.ClassInstances.TBool : ValueType {
    [PureAttribute]
public static override bool And(bool a, bool b);
    public static override int Compare(bool x, bool y);
    [PureAttribute]
public static override bool Equals(bool x, bool y);
    [PureAttribute]
public static override bool False();
    [PureAttribute]
public static override int GetHashCode(bool x);
    [PureAttribute]
public static override bool Not(bool a);
    [PureAttribute]
public static override bool Or(bool a, bool b);
    [PureAttribute]
public static override bool True();
    [PureAttribute]
public static override bool XOr(bool a, bool b);
    [PureAttribute]
public static override bool Implies(bool a, bool b);
    [PureAttribute]
public static override bool BiCondition(bool a, bool b);
}
public class LanguageExt.ClassInstances.TBoolBool : ValueType {
    [PureAttribute]
public static override ValueTuple`2<bool, bool> And(ValueTuple`2<bool, bool> a, ValueTuple`2<bool, bool> b);
    public static override int Compare(ValueTuple`2<bool, bool> x, ValueTuple`2<bool, bool> y);
    [PureAttribute]
public static override bool Equals(ValueTuple`2<bool, bool> x, ValueTuple`2<bool, bool> y);
    [PureAttribute]
public static override ValueTuple`2<bool, bool> False();
    [PureAttribute]
public static override int GetHashCode(ValueTuple`2<bool, bool> x);
    [PureAttribute]
public static override ValueTuple`2<bool, bool> Not(ValueTuple`2<bool, bool> a);
    [PureAttribute]
public static override ValueTuple`2<bool, bool> Or(ValueTuple`2<bool, bool> a, ValueTuple`2<bool, bool> b);
    [PureAttribute]
public static override ValueTuple`2<bool, bool> True();
    [PureAttribute]
public static override ValueTuple`2<bool, bool> XOr(ValueTuple`2<bool, bool> a, ValueTuple`2<bool, bool> b);
    [PureAttribute]
public static override ValueTuple`2<bool, bool> Implies(ValueTuple`2<bool, bool> a, ValueTuple`2<bool, bool> b);
    [PureAttribute]
public static override ValueTuple`2<bool, bool> BiCondition(ValueTuple`2<bool, bool> a, ValueTuple`2<bool, bool> b);
}
public class LanguageExt.ClassInstances.TChar : ValueType {
    [PureAttribute]
public static override bool Equals(char x, char y);
    [PureAttribute]
public static override int Compare(char x, char y);
    [PureAttribute]
public static override int GetHashCode(char x);
    [PureAttribute]
public static override char Add(char x, char y);
    [PureAttribute]
public static override char Subtract(char x, char y);
    [PureAttribute]
public static override char Multiply(char x, char y);
    [PureAttribute]
public static override char Negate(char x);
}
public class LanguageExt.ClassInstances.TDecimal : ValueType {
    [PureAttribute]
public static override bool Equals(decimal x, decimal y);
    [PureAttribute]
public static override int Compare(decimal x, decimal y);
    [PureAttribute]
public static override decimal Add(decimal x, decimal y);
    [PureAttribute]
public static override decimal Subtract(decimal x, decimal y);
    [PureAttribute]
public static override decimal Multiply(decimal x, decimal y);
    [PureAttribute]
public static override decimal Divide(decimal x, decimal y);
    [PureAttribute]
public static override decimal Abs(decimal x);
    [PureAttribute]
public static override decimal Signum(decimal x);
    [PureAttribute]
public static override decimal FromInteger(int x);
    [PureAttribute]
public static override decimal FromDecimal(decimal x);
    [PureAttribute]
public static override decimal FromFloat(float x);
    [PureAttribute]
public static override decimal FromDouble(double x);
    [PureAttribute]
public static override decimal FromRational(Ratio`1<int> x);
    [PureAttribute]
public static override decimal Pi();
    [PureAttribute]
public static override decimal Exp(decimal x);
    [PureAttribute]
public static override decimal Sqrt(decimal x);
    [PureAttribute]
public static override decimal Log(decimal x);
    [PureAttribute]
public static override decimal Pow(decimal x, decimal y);
    [PureAttribute]
public static override decimal LogBase(decimal b, decimal x);
    [PureAttribute]
public static override decimal Sin(decimal x);
    [PureAttribute]
public static override decimal Cos(decimal x);
    [PureAttribute]
public static override decimal Tan(decimal x);
    [PureAttribute]
public static override decimal Asin(decimal x);
    [PureAttribute]
public static override decimal Acos(decimal x);
    [PureAttribute]
public static override decimal Atan(decimal x);
    [PureAttribute]
public static override decimal Sinh(decimal x);
    [PureAttribute]
public static override decimal Cosh(decimal x);
    [PureAttribute]
public static override decimal Tanh(decimal x);
    [PureAttribute]
public static override decimal Asinh(decimal x);
    [PureAttribute]
public static override decimal Acosh(decimal x);
    [PureAttribute]
public static override decimal Atanh(decimal x);
    [PureAttribute]
public static override decimal Negate(decimal x);
    [PureAttribute]
public static override int GetHashCode(decimal x);
}
public class LanguageExt.ClassInstances.TDouble : ValueType {
    [PureAttribute]
public static override bool Equals(double x, double y);
    [PureAttribute]
public static override int Compare(double x, double y);
    [PureAttribute]
public static override double Add(double x, double y);
    [PureAttribute]
public static override double Subtract(double x, double y);
    [PureAttribute]
public static override double Multiply(double x, double y);
    [PureAttribute]
public static override double Divide(double x, double y);
    [PureAttribute]
public static override double Abs(double x);
    [PureAttribute]
public static override double Signum(double x);
    [PureAttribute]
public static override double FromInteger(int x);
    [PureAttribute]
public static override double FromDecimal(decimal x);
    [PureAttribute]
public static override double FromFloat(float x);
    [PureAttribute]
public static override double FromDouble(double x);
    [PureAttribute]
public static override double FromRational(Ratio`1<int> x);
    [PureAttribute]
public static override double Pi();
    [PureAttribute]
public static override double Exp(double x);
    [PureAttribute]
public static override double Sqrt(double x);
    [PureAttribute]
public static override double Log(double x);
    [PureAttribute]
public static override double Pow(double x, double y);
    [PureAttribute]
public static override double LogBase(double b, double x);
    [PureAttribute]
public static override double Sin(double x);
    [PureAttribute]
public static override double Cos(double x);
    [PureAttribute]
public static override double Tan(double x);
    [PureAttribute]
public static override double Asin(double x);
    [PureAttribute]
public static override double Acos(double x);
    [PureAttribute]
public static override double Atan(double x);
    [PureAttribute]
public static override double Sinh(double x);
    [PureAttribute]
public static override double Cosh(double x);
    [PureAttribute]
public static override double Tanh(double x);
    [PureAttribute]
public static override double Asinh(double x);
    [PureAttribute]
public static override double Acosh(double x);
    [PureAttribute]
public static override double Atanh(double x);
    [PureAttribute]
public static override double Negate(double x);
    [PureAttribute]
public static override int GetHashCode(double x);
}
public class LanguageExt.ClassInstances.TFloat : ValueType {
    [PureAttribute]
public static override bool Equals(float x, float y);
    [PureAttribute]
public static override int Compare(float x, float y);
    [PureAttribute]
public static override float Add(float x, float y);
    [PureAttribute]
public static override float Subtract(float x, float y);
    [PureAttribute]
public static override float Multiply(float x, float y);
    [PureAttribute]
public static override float Divide(float x, float y);
    [PureAttribute]
public static override float Abs(float x);
    [PureAttribute]
public static override float Signum(float x);
    [PureAttribute]
public static override float FromInteger(int x);
    [PureAttribute]
public static override float FromDecimal(decimal x);
    [PureAttribute]
public static override float FromFloat(float x);
    [PureAttribute]
public static override float FromDouble(double x);
    [PureAttribute]
public static override float FromRational(Ratio`1<int> x);
    [PureAttribute]
public static override float Pi();
    [PureAttribute]
public static override float Exp(float x);
    [PureAttribute]
public static override float Sqrt(float x);
    [PureAttribute]
public static override float Log(float x);
    [PureAttribute]
public static override float Pow(float x, float y);
    [PureAttribute]
public static override float LogBase(float b, float x);
    [PureAttribute]
public static override float Sin(float x);
    [PureAttribute]
public static override float Cos(float x);
    [PureAttribute]
public static override float Tan(float x);
    [PureAttribute]
public static override float Asin(float x);
    [PureAttribute]
public static override float Acos(float x);
    [PureAttribute]
public static override float Atan(float x);
    [PureAttribute]
public static override float Sinh(float x);
    [PureAttribute]
public static override float Cosh(float x);
    [PureAttribute]
public static override float Tanh(float x);
    [PureAttribute]
public static override float Asinh(float x);
    [PureAttribute]
public static override float Acosh(float x);
    [PureAttribute]
public static override float Atanh(float x);
    [PureAttribute]
public static override float Negate(float x);
    [PureAttribute]
public static override int GetHashCode(float x);
}
public class LanguageExt.ClassInstances.TInt : ValueType {
    [PureAttribute]
public static override bool Equals(int x, int y);
    [PureAttribute]
public static override int Compare(int x, int y);
    [PureAttribute]
public static override int Add(int x, int y);
    [PureAttribute]
public static override int Subtract(int x, int y);
    [PureAttribute]
public static override int Multiply(int x, int y);
    [PureAttribute]
public static override int Divide(int x, int y);
    [PureAttribute]
public static override int Abs(int x);
    [PureAttribute]
public static override int Signum(int x);
    [PureAttribute]
public static override int FromInteger(int x);
    [PureAttribute]
public static override int FromDecimal(decimal x);
    [PureAttribute]
public static override int FromFloat(float x);
    [PureAttribute]
public static override int FromDouble(double x);
    [PureAttribute]
public static override int Negate(int x);
    [PureAttribute]
public static override int GetHashCode(int x);
    [PureAttribute]
public static override int True();
    [PureAttribute]
public static override int False();
    [PureAttribute]
public static override int And(int a, int b);
    [PureAttribute]
public static override int Or(int a, int b);
    [PureAttribute]
public static override int Not(int a);
    [PureAttribute]
public static override int XOr(int a, int b);
    [PureAttribute]
public static override int Implies(int a, int b);
    [PureAttribute]
public static override int BiCondition(int a, int b);
}
public class LanguageExt.ClassInstances.TLong : ValueType {
    [PureAttribute]
public static override bool Equals(long x, long y);
    [PureAttribute]
public static override int Compare(long x, long y);
    [PureAttribute]
public static override long Add(long x, long y);
    [PureAttribute]
public static override long Subtract(long x, long y);
    [PureAttribute]
public static override long Multiply(long x, long y);
    [PureAttribute]
public static override long Divide(long x, long y);
    [PureAttribute]
public static override long Abs(long x);
    [PureAttribute]
public static override long Signum(long x);
    [PureAttribute]
public static override long FromInteger(int x);
    [PureAttribute]
public static override long FromDecimal(decimal x);
    [PureAttribute]
public static override long FromFloat(float x);
    [PureAttribute]
public static override long FromDouble(double x);
    [PureAttribute]
public static override long Negate(long x);
    [PureAttribute]
public static override int GetHashCode(long x);
    [PureAttribute]
public static override long True();
    [PureAttribute]
public static override long False();
    [PureAttribute]
public static override long And(long a, long b);
    [PureAttribute]
public static override long Or(long a, long b);
    [PureAttribute]
public static override long Not(long a);
    [PureAttribute]
public static override long XOr(long a, long b);
    [PureAttribute]
public static override long Implies(long a, long b);
    [PureAttribute]
public static override long BiCondition(long a, long b);
}
public class LanguageExt.ClassInstances.TNumericChar : ValueType {
    [PureAttribute]
public static override bool Equals(char x, char y);
    [PureAttribute]
public static override int Compare(char x, char y);
    [PureAttribute]
public static override int GetHashCode(char x);
    [PureAttribute]
public static override char Add(char x, char y);
    [PureAttribute]
public static override char Subtract(char x, char y);
    [PureAttribute]
public static override char Multiply(char x, char y);
    [PureAttribute]
public static override char Negate(char x);
    private static int CharToInt(int x);
    public static override char Abs(char x);
    public static override char Signum(char x);
    public static override char FromInteger(int x);
    public static override char FromDecimal(decimal x);
    public static override char FromFloat(float x);
    public static override char FromDouble(double x);
    public static override char Divide(char x, char y);
}
public class LanguageExt.ClassInstances.TShort : ValueType {
    [PureAttribute]
public static override bool Equals(short x, short y);
    [PureAttribute]
public static override int Compare(short x, short y);
    [PureAttribute]
public static override short Add(short x, short y);
    [PureAttribute]
public static override short Subtract(short x, short y);
    [PureAttribute]
public static override short Multiply(short x, short y);
    [PureAttribute]
public static override short Divide(short x, short y);
    [PureAttribute]
public static override short Abs(short x);
    [PureAttribute]
public static override short Signum(short x);
    [PureAttribute]
public static override short FromInteger(int x);
    [PureAttribute]
public static override short FromDecimal(decimal x);
    [PureAttribute]
public static override short FromFloat(float x);
    [PureAttribute]
public static override short FromDouble(double x);
    [PureAttribute]
public static override short Negate(short x);
    [PureAttribute]
public static override int GetHashCode(short x);
    [PureAttribute]
public static override short True();
    [PureAttribute]
public static override short False();
    [PureAttribute]
public static override short And(short a, short b);
    [PureAttribute]
public static override short Or(short a, short b);
    [PureAttribute]
public static override short Not(short a);
    [PureAttribute]
public static override short XOr(short a, short b);
    [PureAttribute]
public static override short Implies(short a, short b);
    [PureAttribute]
public static override short BiCondition(short a, short b);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.TString : ValueType {
    [PureAttribute]
public static override bool Equals(string x, string y);
    [PureAttribute]
public static override int Compare(string x, string y);
    [PureAttribute]
public static override int GetHashCode(string x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.TStringCurrentCulture : ValueType {
    [PureAttribute]
public static override bool Equals(string x, string y);
    [PureAttribute]
public static override int Compare(string x, string y);
    [PureAttribute]
public static override int GetHashCode(string x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.TStringCurrentCultureIgnoreCase : ValueType {
    [PureAttribute]
public static override bool Equals(string x, string y);
    [PureAttribute]
public static override int Compare(string x, string y);
    [PureAttribute]
public static override int GetHashCode(string x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.TStringOrdinal : ValueType {
    [PureAttribute]
public static override bool Equals(string x, string y);
    [PureAttribute]
public static override int Compare(string x, string y);
    [PureAttribute]
public static override int GetHashCode(string x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ClassInstances.TStringOrdinalIgnoreCase : ValueType {
    [PureAttribute]
public static override bool Equals(string x, string y);
    [PureAttribute]
public static override int Compare(string x, string y);
    [PureAttribute]
public static override int GetHashCode(string x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.CollectionFormat : object {
    public static int MaxShortItems;
    private static CollectionFormat();
    internal static string ToShortString(IEnumerable`1<A> ma, string separator);
    internal static string ToShortString(IEnumerable`1<A> ma, int count, string separator);
    internal static string ToShortArrayString(IEnumerable`1<A> ma, string separator);
    internal static string ToShortArrayString(IEnumerable`1<A> ma, int count, string separator);
    internal static string ToFullString(IEnumerable`1<A> ma, string separator);
    internal static string ToFullArrayString(IEnumerable`1<A> ma, string separator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Combinators : object {
    public static A I(A x);
    public static Func`2<B, A> K(A x);
    public static Func`2<A, A> M(Func`2<A, A> x);
    public static Func`2<Func`2<A, B>, B> T(A x);
    [NullableContextAttribute("2")]
public static Func`2<Func`2<B, C>, Func`2<A, C>> Q(Func`2<A, B> x);
    [NullableContextAttribute("2")]
public static Func`2<Func`2<A, B>, Func`2<A, C>> S(Func`3<A, B, C> x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Combinators`1 : object {
    public static Func`2<A, A> I;
    public static Func`2<Func`2<A, A>, Func`2<A, A>> M;
    private static Combinators`1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Combinators`2 : object {
    public static Func`2<A, Func`2<B, A>> K;
    public static Func`2<A, Func`2<Func`2<A, B>, B>> T;
    private static Combinators`2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Combinators`3 : object {
    public static Func`2<Func`2<A, B>, Func`2<Func`2<B, C>, Func`2<A, C>>> Q;
    public static Func`2<Func`2<A, Func`2<B, C>>, Func`2<Func`2<A, B>, Func`2<A, C>>> S;
    public static Func`2<Func`3<Func`2<A, B>, A, B>, Func`2<A, B>> Y;
    private static Combinators`3();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.CombinatorsDynamic : object {
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Func`2<object, object> I;
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Func`2<object, Func`2<object, object>> M;
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Func`2<object, Func`2<object, object>> K;
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Func`2<object, Func`2<object, object>> T;
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Func`2<object, Func`2<object, Func`2<object, object>>> Q;
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Func`2<object, Func`2<object, Func`2<object, object>>> S;
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Func`2<object, Func`2<object, object>> Y;
    private static CombinatorsDynamic();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
public class LanguageExt.Common.BottomError : Exceptional {
    public static Error Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [DataMemberAttribute]
public int Code { get; }
    [DataMemberAttribute]
public string Message { get; }
    [PureAttribute]
[IgnoreDataMemberAttribute]
public bool IsExceptional { get; }
    [PureAttribute]
[IgnoreDataMemberAttribute]
public bool IsExpected { get; }
    [CompilerGeneratedAttribute]
private BottomError(BottomError original);
    private static BottomError();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual int get_Code();
    public virtual string get_Message();
    public virtual string ToString();
    public virtual Exception ToException();
    public virtual ErrorException ToErrorException();
    [NullableContextAttribute("0")]
[PureAttribute]
public virtual bool HasException();
    [PureAttribute]
public virtual bool Is(Error error);
    public virtual bool get_IsExceptional();
    public virtual bool get_IsExpected();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(BottomError left, BottomError right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(BottomError left, BottomError right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Exceptional other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(BottomError other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override BottomError <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Common.BottomException : ExceptionalException {
    public static BottomException Default;
    public string Message { get; }
    public int Code { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Option`1<ErrorException> Inner { get; }
    private static BottomException();
    public virtual string get_Message();
    public virtual int get_Code();
    public virtual Option`1<ErrorException> get_Inner();
    public virtual Error ToError();
    public virtual ErrorException Combine(ErrorException error);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
public abstract class LanguageExt.Common.Error : object {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [PureAttribute]
[DataMemberAttribute]
public int Code { get; }
    [PureAttribute]
[DataMemberAttribute]
public string Message { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
[IgnoreDataMemberAttribute]
public Option`1<Error> Inner { get; }
    [PureAttribute]
[IgnoreDataMemberAttribute]
public bool IsExceptional { get; }
    [PureAttribute]
[IgnoreDataMemberAttribute]
public bool IsExpected { get; }
    [PureAttribute]
[IgnoreDataMemberAttribute]
public Error Head { get; }
    [PureAttribute]
[IgnoreDataMemberAttribute]
public Error Tail { get; }
    [PureAttribute]
[IgnoreDataMemberAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
[IgnoreDataMemberAttribute]
public int Count { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Option`1<Exception> Exception { get; }
    [PureAttribute]
public static Error Empty { get; }
    [CompilerGeneratedAttribute]
protected Error(Error original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual int get_Code();
    public abstract virtual string get_Message();
    public virtual Option`1<Error> get_Inner();
    [NullableContextAttribute("0")]
[PureAttribute]
public virtual bool HasException();
    [PureAttribute]
public virtual bool HasCode(int code);
    [NullableContextAttribute("0")]
[PureAttribute]
public virtual bool IsType();
    [PureAttribute]
public virtual bool Is(Error error);
    [PureAttribute]
public virtual Error Filter();
    [PureAttribute]
public virtual K`2<M, A> ForAllM(Func`2<Error, K`2<M, A>> f);
    [PureAttribute]
public virtual K`2<M, A> FoldM(Func`2<Error, K`2<M, A>> f);
    public abstract virtual bool get_IsExceptional();
    public abstract virtual bool get_IsExpected();
    public virtual Error get_Head();
    public virtual Error get_Tail();
    public virtual bool get_IsEmpty();
    public virtual int get_Count();
    [PureAttribute]
public virtual Exception ToException();
    public Option`1<Exception> get_Exception();
    [PureAttribute]
public abstract virtual ErrorException ToErrorException();
    [PureAttribute]
public sealed virtual Error Combine(Error error);
    public static override Error get_Empty();
    [PureAttribute]
public static override Error op_Addition(Error lhs, Error rhs);
    [PureAttribute]
public virtual Iterable`1<Error> AsIterable();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public static Error New(Exception thisException);
    [PureAttribute]
public static Error New(string message, Exception thisException);
    [PureAttribute]
public static Error New(string message);
    [PureAttribute]
public static Error New(int code, string message);
    [PureAttribute]
public static Error New(int code, string message, Error inner);
    [PureAttribute]
public static Error New(string message, Error inner);
    [PureAttribute]
public static Error Many(Error[] errors);
    [PureAttribute]
public static Error Many(Seq`1<Error> errors);
    [PureAttribute]
public static Error op_Explicit(string e);
    [PureAttribute]
public static Error op_Implicit(ValueTuple`2<int, string> e);
    [PureAttribute]
public static Error op_Implicit(Exception e);
    [PureAttribute]
public static Exception op_Implicit(Error e);
    [PureAttribute]
public static Error FromObject(object value);
    [NullableContextAttribute("2")]
[PureAttribute]
internal static Option`1<FAIL> Convert(object err);
    public Unit Throw();
    public R Throw();
    protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(Error left, Error right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(Error left, Error right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(Error other);
    [CompilerGeneratedAttribute]
public abstract virtual Error <Clone>$();
    [IteratorStateMachineAttribute("LanguageExt.Common.Error/<<AsIterable>g__go|35_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<Error> <AsIterable>g__go|35_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.Common.ErrorException : Exception {
    [PureAttribute]
public int Code { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Option`1<ErrorException> Inner { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public bool IsExceptional { get; }
    [PureAttribute]
public bool IsExpected { get; }
    [PureAttribute]
public static ErrorException Empty { get; }
    protected ErrorException(int code);
    public abstract virtual int get_Code();
    public abstract virtual Option`1<ErrorException> get_Inner();
    [PureAttribute]
public abstract virtual Error ToError();
    public virtual bool get_IsEmpty();
    public abstract virtual bool get_IsExceptional();
    public abstract virtual bool get_IsExpected();
    [PureAttribute]
public abstract virtual ErrorException Combine(ErrorException error);
    public static override ErrorException get_Empty();
    [PureAttribute]
public static override ErrorException op_Addition(ErrorException lhs, ErrorException rhs);
    [IteratorStateMachineAttribute("LanguageExt.Common.ErrorException/<GetEnumerator>d__16")]
[PureAttribute]
public virtual IEnumerator`1<ErrorException> GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public static ErrorException New(Exception thisException);
    [PureAttribute]
public static ErrorException New(string message, Exception thisException);
    [PureAttribute]
public static ErrorException New(string message);
    [PureAttribute]
public static ErrorException New(int code, string message);
    [PureAttribute]
public static ErrorException New(int code, string message, ErrorException inner);
    [PureAttribute]
public static ErrorException New(string message, ErrorException inner);
    [PureAttribute]
public static ErrorException Many(ErrorException[] errors);
    [PureAttribute]
public static ErrorException Many(Seq`1<ErrorException> errors);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Common.Errors : object {
    public static Error None;
    public static string BottomText;
    public static int BottomCode;
    public static Error Bottom;
    public static string CancelledText;
    public static int CancelledCode;
    public static Error Cancelled;
    public static string TimedOutText;
    public static int TimedOutCode;
    public static Error TimedOut;
    public static string SequenceEmptyText;
    public static int SequenceEmptyCode;
    public static Error SequenceEmpty;
    public static string ClosedText;
    public static int ClosedCode;
    public static Error Closed;
    public static int ParseErrorCode;
    public static int ManyErrorsCode;
    public static string LiftIONotSupportedText;
    public static int LiftIONotSupportedCode;
    public static Error LiftIONotSupported;
    public static string UnliftIONotSupportedText;
    public static int UnliftIONotSupportedCode;
    public static Error UnliftIONotSupported;
    public static string EndOfStreamText;
    public static int EndOfStreamCode;
    public static Error EndOfStream;
    public static string ValidationFailedText;
    public static int ValidationFailedCode;
    public static Error ValidationFailed;
    private static Errors();
    public static Error ParseError(string msg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
public class LanguageExt.Common.Exceptional : Error {
    [NullableAttribute("2")]
[IgnoreDataMemberAttribute]
private Exception Value;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Code>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [DataMemberAttribute]
public string Message { get; }
    [DataMemberAttribute]
public int Code { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Option`1<Error> Inner { get; }
    [PureAttribute]
[IgnoreDataMemberAttribute]
public bool IsExceptional { get; }
    [PureAttribute]
[IgnoreDataMemberAttribute]
public bool IsExpected { get; }
    public Exceptional(string Message, int Code);
    internal Exceptional(Exception value);
    internal Exceptional(string message, Exception value);
    [CompilerGeneratedAttribute]
protected Exceptional(Exceptional original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string get_Message();
    [CompilerGeneratedAttribute]
public virtual int get_Code();
    public virtual string ToString();
    public virtual Option`1<Error> get_Inner();
    [PureAttribute]
public virtual Exception ToException();
    [PureAttribute]
public virtual ErrorException ToErrorException();
    [NullableContextAttribute("0")]
[PureAttribute]
public virtual bool HasException();
    [PureAttribute]
public virtual bool Is(Error error);
    public virtual bool get_IsExceptional();
    public virtual bool get_IsExpected();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(Exceptional left, Exceptional right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(Exceptional left, Exceptional right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Error other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(Exceptional other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override Exceptional <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Message, Int32& Code);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Common.ExceptionalException : ErrorException {
    [NullableAttribute("2")]
public Exception Exception;
    [CompilerGeneratedAttribute]
private int <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public int Code { get; }
    public string Message { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Option`1<ErrorException> Inner { get; }
    [PureAttribute]
public bool IsExceptional { get; }
    [PureAttribute]
public bool IsExpected { get; }
    public ExceptionalException(Exception Exception);
    public ExceptionalException(string Message, int Code);
    public ExceptionalException(string Message, Exception Exception);
    [CompilerGeneratedAttribute]
public virtual int get_Code();
    [CompilerGeneratedAttribute]
public virtual string get_Message();
    [PureAttribute]
public virtual string ToString();
    public virtual Option`1<ErrorException> get_Inner();
    public virtual Error ToError();
    public virtual bool get_IsExceptional();
    public virtual bool get_IsExpected();
    [PureAttribute]
public virtual ErrorException Combine(ErrorException error);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.Common.ExceptionExtensions : object {
    [ExtensionAttribute]
public static Unit Rethrow(Exception e);
    [ExtensionAttribute]
public static R Rethrow(Exception e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Common.Exceptions : object {
    public static ErrorException None;
    public static ExceptionalException Bottom;
    public static ExpectedException Cancelled;
    public static ExpectedException TimedOut;
    public static ExpectedException SequenceEmpty;
    public static ExpectedException Closed;
    public static int ParseErrorCode;
    public static ExceptionalException LiftIONotSupported;
    public static ExceptionalException UnliftIONotSupported;
    public static ExpectedException EndOfStream;
    public static ExpectedException ValidationFailed;
    private static Exceptions();
    public static ExpectedException ParseError(string msg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
public class LanguageExt.Common.Expected : Error {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Code>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Option`1<Error> <Inner>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [PureAttribute]
[DataMemberAttribute]
public string Message { get; }
    [PureAttribute]
[DataMemberAttribute]
public int Code { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
[IgnoreDataMemberAttribute]
public Option`1<Error> Inner { get; }
    [PureAttribute]
[IgnoreDataMemberAttribute]
public bool IsExceptional { get; }
    [PureAttribute]
[IgnoreDataMemberAttribute]
public bool IsExpected { get; }
    public Expected(string Message, int Code, Option`1<Error> Inner);
    [CompilerGeneratedAttribute]
protected Expected(Expected original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string get_Message();
    [CompilerGeneratedAttribute]
public virtual int get_Code();
    [CompilerGeneratedAttribute]
public virtual Option`1<Error> get_Inner();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public virtual ErrorException ToErrorException();
    [NullableContextAttribute("0")]
[PureAttribute]
public virtual bool HasException();
    public virtual bool get_IsExceptional();
    public virtual bool get_IsExpected();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(Expected left, Expected right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(Expected left, Expected right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Error other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(Expected other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override Expected <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Message, Int32& Code, Option`1& Inner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Common.ExpectedException : ErrorException {
    [CompilerGeneratedAttribute]
private int <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Option`1<ErrorException> <Inner>k__BackingField;
    [PureAttribute]
public int Code { get; }
    [PureAttribute]
public string Message { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Option`1<ErrorException> Inner { get; }
    [PureAttribute]
public bool IsExceptional { get; }
    [PureAttribute]
public bool IsExpected { get; }
    public ExpectedException(string message, int code, Option`1<ErrorException> inner);
    [CompilerGeneratedAttribute]
public virtual int get_Code();
    [CompilerGeneratedAttribute]
public virtual string get_Message();
    [PureAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public virtual Option`1<ErrorException> get_Inner();
    [PureAttribute]
public virtual Error ToError();
    public virtual bool get_IsExceptional();
    public virtual bool get_IsExpected();
    [PureAttribute]
public virtual ErrorException Combine(ErrorException error);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
public class LanguageExt.Common.ManyErrors : Error {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Seq`1<Error> <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private static Error <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public Seq`1<Error> Errors { get; public set; }
    public static Error Empty { get; }
    public int Code { get; }
    public string Message { get; }
    [PureAttribute]
[IgnoreDataMemberAttribute]
public bool IsExceptional { get; }
    [PureAttribute]
[IgnoreDataMemberAttribute]
public bool IsExpected { get; }
    [PureAttribute]
[IgnoreDataMemberAttribute]
public Error Head { get; }
    [PureAttribute]
[IgnoreDataMemberAttribute]
public Error Tail { get; }
    [PureAttribute]
[IgnoreDataMemberAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
[IgnoreDataMemberAttribute]
public int Count { get; }
    public ManyErrors(Seq`1<Error> Errors);
    [CompilerGeneratedAttribute]
private ManyErrors(ManyErrors original);
    private static ManyErrors();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Seq`1<Error> get_Errors();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Errors(Seq`1<Error> value);
    [CompilerGeneratedAttribute]
public static Error get_Empty();
    public virtual int get_Code();
    [CompilerGeneratedAttribute]
public virtual string get_Message();
    public virtual string ToString();
    public virtual Exception ToException();
    public virtual ErrorException ToErrorException();
    [NullableContextAttribute("0")]
[PureAttribute]
public virtual bool HasException();
    [PureAttribute]
public virtual bool HasCode(int code);
    [NullableContextAttribute("0")]
[PureAttribute]
public virtual bool IsType();
    [PureAttribute]
public virtual bool Is(Error error);
    [PureAttribute]
public virtual Error Filter();
    [PureAttribute]
public virtual K`2<M, A> ForAllM(Func`2<Error, K`2<M, A>> f);
    [PureAttribute]
public virtual K`2<M, A> FoldM(Func`2<Error, K`2<M, A>> f);
    public virtual bool get_IsExceptional();
    public virtual bool get_IsExpected();
    public virtual Error get_Head();
    public virtual Error get_Tail();
    public virtual bool get_IsEmpty();
    public virtual int get_Count();
    [PureAttribute]
public virtual Iterable`1<Error> AsIterable();
    [PureAttribute]
internal static Error FromAggregate(AggregateException e);
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ManyErrors left, ManyErrors right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ManyErrors left, ManyErrors right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Error other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ManyErrors other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override ManyErrors <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Seq`1& Errors);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Common.ManyExceptions : ErrorException {
    [CompilerGeneratedAttribute]
private static ErrorException <Empty>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Seq`1<ErrorException> Errors;
    public static ErrorException Empty { get; }
    public int Code { get; }
    public string Message { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Option`1<ErrorException> Inner { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public bool IsExceptional { get; }
    [PureAttribute]
public bool IsExpected { get; }
    public ManyExceptions(Seq`1<ErrorException> errors);
    private static ManyExceptions();
    [CompilerGeneratedAttribute]
public static ErrorException get_Empty();
    public virtual int get_Code();
    public virtual string get_Message();
    public virtual Option`1<ErrorException> get_Inner();
    public virtual Error ToError();
    [PureAttribute]
public virtual string ToString();
    public virtual bool get_IsEmpty();
    public virtual bool get_IsExceptional();
    public virtual bool get_IsExpected();
    [PureAttribute]
public virtual ErrorException Combine(ErrorException error);
    [PureAttribute]
public virtual IEnumerator`1<ErrorException> GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Common.WrappedErrorExceptionalException : ExceptionalException {
    [CompilerGeneratedAttribute]
private Error <Error>P;
    public WrappedErrorExceptionalException(Error Error);
    public virtual Error ToError();
    [PureAttribute]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Common.WrappedErrorExpectedException : ExpectedException {
    [CompilerGeneratedAttribute]
private Error <Error>P;
    public WrappedErrorExpectedException(Error Error);
    public virtual Error ToError();
    [PureAttribute]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class LanguageExt.CommuteRef`1 : ValueType {
    internal Ref`1<A> Ref;
    public A Value { get; public set; }
    internal CommuteRef`1(Ref`1<A> r);
    public A get_Value();
    public void set_Value(A value);
    public static A op_Implicit(CommuteRef`1<A> r);
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(A other);
    public A Swap(Func`2<A, A> f);
    public IO`1<A> SwapIO(Func`2<A, A> f);
    public CommuteRef`1<A> Commute(Func`2<A, A> f);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.CompleteIO`1 : IOResponse`1<A> {
    [CompilerGeneratedAttribute]
private A <Value>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public A Value { get; public set; }
    public CompleteIO`1(A Value);
    [CompilerGeneratedAttribute]
protected CompleteIO`1(CompleteIO`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public A get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(A value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CompleteIO`1<A> left, CompleteIO`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CompleteIO`1<A> left, CompleteIO`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(IOResponse`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(CompleteIO`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override CompleteIO`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(A& Value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.ComposeExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static Func`2<A, C> BackCompose(Func`2<B, C> g, Func`2<A, B> f);
    [ExtensionAttribute]
[PureAttribute]
public static Func`1<B> BackCompose(Func`2<A, B> g, Func`1<A> f);
    [ExtensionAttribute]
[PureAttribute]
public static Action`1<A> BackCompose(Action`1<B> g, Func`2<A, B> f);
    [ExtensionAttribute]
[PureAttribute]
public static Action BackCompose(Action`1<A> g, Func`1<A> f);
    [ExtensionAttribute]
[PureAttribute]
public static Func`2<A, C> Compose(Func`2<A, B> f, Func`2<B, C> g);
    [ExtensionAttribute]
[PureAttribute]
public static Func`1<B> Compose(Func`1<A> f, Func`2<A, B> g);
    [ExtensionAttribute]
[PureAttribute]
public static Action`1<A> Compose(Func`2<A, B> f, Action`1<B> g);
    [ExtensionAttribute]
[PureAttribute]
public static Action Compose(Func`1<A> f, Action`1<A> g);
}
public static class LanguageExt.Compositions : object {
    public static bool wellFormed(Compositions`1<A> ca);
    public static Compositions`1<A> skip(int amount, Compositions`1<A> compositions);
    public static Compositions`1<A> take(int amount, Compositions`1<A> compositions);
    [NullableContextAttribute("1")]
public static A takeComposed(int amount, Compositions`1<A> compositions);
    public static ValueTuple`2<Compositions`1<A>, Compositions`1<A>> splitAt(int i, Compositions`1<A> c);
    [NullableContextAttribute("1")]
public static A composed(Compositions`1<A> compositions);
    [NullableContextAttribute("1")]
public static Compositions`1<A> singleton(A value);
    public static int count(Compositions`1<A> compositions);
    [NullableContextAttribute("1")]
public static Compositions`1<A> cons(A x, Compositions`1<A> xs);
    [NullableContextAttribute("1")]
public static Compositions`1<A> fromList(IEnumerable`1<A> ma);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static bool <wellFormed>g__wellFormedNode|0_0(int n, Node<A> node);
    [CompilerGeneratedAttribute]
internal static bool <wellFormed>g__go|0_1(int m, Seq`1<Node<A>> ma);
    [CompilerGeneratedAttribute]
internal static Seq`1<Node<A>> <skip>g__go|1_0(int n, Seq`1<Node<A>> nodes);
    [CompilerGeneratedAttribute]
internal static Seq`1<Node<A>> <take>g__go|2_0(int n, Seq`1<Node<A>> nodes);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static A <takeComposed>g__go|3_0(int n, Seq`1<Node<A>> nodes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Compositions`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Compositions`1<A> <Empty>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Seq`1<Node<A>> Tree;
    private Nullable`1<int> hashCode;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Compositions`1<A> Empty { get; }
    internal Compositions`1(Seq`1<Node<A>> tree);
    private static Compositions`1();
    [CompilerGeneratedAttribute]
public static override Compositions`1<A> get_Empty();
    public sealed virtual Compositions`1<A> Combine(Compositions`1<A> compy);
    [NullableContextAttribute("0")]
public bool WellFormed();
    public Compositions`1<A> Skip(int amount);
    public Compositions`1<A> Take(int amount);
    public A TakeComposed(int amount);
    public ValueTuple`2<Compositions`1<A>, Compositions`1<A>> SplitAt(int i);
    public A Composed();
    public static Compositions`1<A> Singleton(A value);
    public int Count();
    public static Compositions`1<A> FromList(IEnumerable`1<A> ma);
    public sealed virtual bool Equals(Compositions`1<A> b);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool op_Equality(Compositions`1<A> a, Compositions`1<A> b);
    public static bool op_Inequality(Compositions`1<A> a, Compositions`1<A> b);
    public virtual int GetHashCode();
    public Seq`1<A> ToSeq();
    public Iterable`1<A> AsIterable();
    public sealed virtual IEnumerator`1<A> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
internal static Seq`1<Node<A>> <Combine>g__go|6_0(Seq`1<Node<A>> mx, Seq`1<Node<A>> my);
}
[NullableContextAttribute("2")]
public interface LanguageExt.Conflict`1 {
    public static abstract virtual ValueTuple`2<long, Option`1<V>> Resolve(ValueTuple`2<long, Option`1<V>> Current, ValueTuple`2<long, Option`1<V>> Proposed);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ContT.ContT`3 : object {
    [CompilerGeneratedAttribute]
private Func`2<Func`2<A, K`2<M, R>>, K`2<M, R>> <runCont>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Func`2<Func`2<A, K`2<M, R>>, K`2<M, R>> runCont { get; public set; }
    public ContT`3(Func`2<Func`2<A, K`2<M, R>>, K`2<M, R>> runCont);
    [CompilerGeneratedAttribute]
protected ContT`3(ContT`3<R, M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Func`2<Func`2<A, K`2<M, R>>, K`2<M, R>> get_runCont();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_runCont(Func`2<Func`2<A, K`2<M, R>>, K`2<M, R>> value);
    public static ContT`3<R, M, A> Pure(A value);
    public ContT`3<R, M, B> Map(Func`2<A, B> f);
    public ContT`3<R, M, B> Bind(Func`2<A, ContT`3<R, M, B>> f);
    public K`2<M, R> Run(Func`2<A, R> f);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ContT`3<R, M, A> left, ContT`3<R, M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ContT`3<R, M, A> left, ContT`3<R, M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(ContT`3<R, M, A> other);
    [CompilerGeneratedAttribute]
public virtual ContT`3<R, M, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`2& runCont);
}
public interface LanguageExt.Culture`1 {
    private static StringComparison LanguageExt.HashableString<STRING>.Comparison { get; }
    private static override StringComparison LanguageExt.HashableString<STRING>.get_Comparison();
}
public interface LanguageExt.CultureIgnoreCase`1 {
    private static StringComparison LanguageExt.HashableString<STRING>.Comparison { get; }
    private static override StringComparison LanguageExt.HashableString<STRING>.get_Comparison();
}
public class LanguageExt.DeadlockException : Exception {
}
internal static class LanguageExt.Disposable`1 : object {
    public static bool IsDisposable;
    private static Disposable`1();
}
[IsReadOnlyAttribute]
public class LanguageExt.Duration : ValueType {
    public double Milliseconds;
    public static Duration Zero;
    public Duration(double milliseconds);
    private static Duration();
    [PureAttribute]
public static Duration random(Duration min, Duration max, Option`1<int> seed);
    [PureAttribute]
public static Duration op_Implicit(double milliseconds);
    [PureAttribute]
public static Duration op_Implicit(TimeSpan timeSpan);
    [PureAttribute]
public static Duration op_Implicit(Time time);
    [PureAttribute]
public static double op_Implicit(Duration duration);
    [PureAttribute]
public static TimeSpan op_Explicit(Duration duration);
    [PureAttribute]
public static Time op_Explicit(Duration duration);
    [PureAttribute]
public static bool op_Equality(Duration a, Duration b);
    [PureAttribute]
public static bool op_Inequality(Duration a, Duration b);
    [PureAttribute]
public sealed virtual bool Equals(Duration other);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public virtual int GetHashCode();
    [PureAttribute]
public sealed virtual int CompareTo(Duration other);
    [PureAttribute]
public static bool op_GreaterThan(Duration a, Duration b);
    [PureAttribute]
public static bool op_GreaterThanOrEqual(Duration a, Duration b);
    [PureAttribute]
public static bool op_LessThan(Duration a, Duration b);
    [PureAttribute]
public static bool op_LessThanOrEqual(Duration a, Duration b);
    [NullableContextAttribute("1")]
[PureAttribute]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.Edit`2 : object {
    public int Position;
    public A Element;
    private Edit`2(int position, A element);
    internal abstract virtual Edit`2<EqA, A> Index(Func`2<int, int> f);
    public abstract virtual Edit`2<EqA, A> MapOld(Func`2<A, A> f);
    public abstract virtual Edit`2<EqA, A> MapNew(Func`2<A, A> f);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool op_Equality(Edit`2<EqA, A> a, Edit`2<EqA, A> b);
    public static bool op_Inequality(Edit`2<EqA, A> a, Edit`2<EqA, A> b);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(Edit`2<EqA, A> other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Eff : object {
    private static override K`2<Eff, B> LanguageExt.Traits.Monad<LanguageExt.Eff>.Bind(K`2<Eff, A> ma, Func`2<A, K`2<Eff, B>> f);
    private static override K`2<Eff, B> LanguageExt.Traits.Functor<LanguageExt.Eff>.Map(Func`2<A, B> f, K`2<Eff, A> ma);
    private static override K`2<Eff, A> LanguageExt.Traits.Applicative<LanguageExt.Eff>.Pure(A value);
    private static override K`2<Eff, B> LanguageExt.Traits.Applicative<LanguageExt.Eff>.Apply(K`2<Eff, Func`2<A, B>> mf, K`2<Eff, A> ma);
    private static override K`2<Eff, B> LanguageExt.Traits.Applicative<LanguageExt.Eff>.Action(K`2<Eff, A> ma, K`2<Eff, B> mb);
    private static override K`2<Eff, A> LanguageExt.Traits.Applicative<LanguageExt.Eff>.Actions(IEnumerable`1<K`2<Eff, A>> fas);
    private static override K`2<Eff, A> LanguageExt.Traits.MonoidK<LanguageExt.Eff>.Empty();
    private static override K`2<Eff, A> LanguageExt.Traits.SemigroupK<LanguageExt.Eff>.Combine(K`2<Eff, A> ma, K`2<Eff, A> mb);
    private static override K`2<Eff, A> LanguageExt.Traits.Readable<LanguageExt.Eff,LanguageExt.Effects.MinRT>.Asks(Func`2<MinRT, A> f);
    private static override K`2<Eff, A> LanguageExt.Traits.Readable<LanguageExt.Eff,LanguageExt.Effects.MinRT>.Local(Func`2<MinRT, MinRT> f, K`2<Eff, A> ma);
    private static override K`2<Eff, A> LanguageExt.Traits.MonadIO<LanguageExt.Eff>.LiftIO(IO`1<A> ma);
    private static override K`2<Eff, IO`1<A>> LanguageExt.Traits.MonadIO<LanguageExt.Eff>.ToIO(K`2<Eff, A> ma);
    private static override K`2<Eff, B> LanguageExt.Traits.MonadIO<LanguageExt.Eff>.MapIO(K`2<Eff, A> ma, Func`2<IO`1<A>, IO`1<B>> f);
    private static override K`2<Eff, A> LanguageExt.Traits.Fallible<LanguageExt.Common.Error,LanguageExt.Eff>.Fail(Error error);
    private static override K`2<Eff, A> LanguageExt.Traits.Fallible<LanguageExt.Common.Error,LanguageExt.Eff>.Catch(K`2<Eff, A> fa, Func`2<Error, bool> Predicate, Func`2<Error, K`2<Eff, A>> Fail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Eff`1 : object {
    [CompilerGeneratedAttribute]
private Eff`2<MinRT, A> <effect>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ReaderT`3<A, IO, ValueTuple`2<A, EnvIO>> getState;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Eff`2<MinRT, A> effect { get; public set; }
    public Eff`1(Eff`2<MinRT, A> effect);
    [CompilerGeneratedAttribute]
protected Eff`1(Eff`1<A> original);
    private static Eff`1();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Eff`2<MinRT, A> get_effect();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_effect(Eff`2<MinRT, A> value);
    [PureAttribute]
public static Eff`1<A> Pure(A value);
    [PureAttribute]
public static Eff`1<A> Fail(Error error);
    public Eff`2<RT, A> WithRuntime();
    [PureAttribute]
public static Eff`1<A> Lift(Func`2<MinRT, Either`2<Error, A>> f);
    [PureAttribute]
public static Eff`1<A> Lift(Func`2<MinRT, Fin`1<A>> f);
    [PureAttribute]
public static Eff`1<A> Lift(Func`2<MinRT, A> f);
    [PureAttribute]
public static Eff`1<A> LiftIO(Func`2<MinRT, Task`1<A>> f);
    [PureAttribute]
public static Eff`1<A> LiftIO(Func`2<MinRT, Task`1<Fin`1<A>>> f);
    [PureAttribute]
public static Eff`1<A> LiftIO(Func`2<MinRT, IO`1<A>> f);
    [PureAttribute]
public static Eff`1<A> LiftIO(IO`1<A> ma);
    [PureAttribute]
public static Eff`1<A> Lift(Func`1<Either`2<Error, A>> f);
    [PureAttribute]
public static Eff`1<A> Lift(Func`1<Fin`1<A>> f);
    [PureAttribute]
public static Eff`1<A> Lift(Func`1<A> f);
    [PureAttribute]
public static Eff`1<A> LiftIO(Func`1<Task`1<A>> f);
    [PureAttribute]
public static Eff`1<A> LiftIO(Func`1<Task`1<Fin`1<A>>> f);
    [PureAttribute]
public Eff`1<B> Map(Func`2<A, B> f);
    [PureAttribute]
public Eff`1<B> Select(Func`2<A, B> f);
    [PureAttribute]
public Eff`1<A> MapFail(Func`2<Error, Error> f);
    [PureAttribute]
public Eff`1<B> MapIO(Func`2<IO`1<A>, IO`1<B>> f);
    [PureAttribute]
public Eff`1<B> BiMap(Func`2<A, B> Succ, Func`2<Error, Error> Fail);
    [PureAttribute]
public Eff`1<B> Match(Func`2<A, B> Succ, Func`2<Error, B> Fail);
    [PureAttribute]
public Eff`1<A> IfFail(Func`2<Error, A> Fail);
    [PureAttribute]
public Eff`1<A> IfFailEff(Func`2<Error, Eff`1<A>> Fail);
    [PureAttribute]
public Eff`1<A> Filter(Func`2<A, bool> predicate);
    [PureAttribute]
public Eff`1<A> Where(Func`2<A, bool> predicate);
    [PureAttribute]
public Eff`1<B> Bind(Func`2<A, Eff`1<B>> f);
    [PureAttribute]
public Eff`1<B> Bind(Func`2<A, IO`1<B>> f);
    [PureAttribute]
public Eff`1<B> Bind(Func`2<A, Ask`2<MinRT, B>> f);
    [PureAttribute]
public Eff`2<RT, B> Bind(Func`2<A, Eff`2<RT, B>> f);
    [PureAttribute]
public Eff`2<RT, B> Bind(Func`2<A, K`2<Eff`1<RT>, B>> f);
    [PureAttribute]
public Eff`1<B> Bind(Func`2<A, K`2<Eff, B>> f);
    [PureAttribute]
public Eff`1<B> Bind(Func`2<A, Pure`1<B>> f);
    [PureAttribute]
public Eff`1<A> Bind(Func`2<A, Fail`1<Error>> f);
    [PureAttribute]
public Eff`1<C> SelectMany(Func`2<A, Eff`1<B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Eff`2<RT, C> SelectMany(Func`2<A, Eff`2<RT, B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Eff`2<RT, C> SelectMany(Func`2<A, K`2<Eff`1<RT>, B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Eff`1<C> SelectMany(Func`2<A, K`2<Eff, B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Eff`1<C> SelectMany(Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Eff`1<C> SelectMany(Func`2<A, IO`1<B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Eff`1<C> SelectMany(Func`2<A, Ask`2<MinRT, B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Eff`1<C> SelectMany(Func`2<A, Fail`1<Error>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Eff`1<C> SelectMany(Func`2<A, Guard`2<Error, Unit>> bind, Func`3<A, Unit, C> project);
    [PureAttribute]
public Eff`1<C> SelectMany(Func`2<A, Guard`2<Fail`1<Error>, Unit>> bind, Func`3<A, Unit, C> project);
    public static Eff`1<A> op_RightShift(Eff`1<A> lhs, Eff`1<A> rhs);
    public static Eff`1<A> op_RightShift(Eff`1<A> lhs, Eff`1<Unit> rhs);
    public static Eff`1<A> op_RightShift(Eff`1<A> lhs, K`2<Eff, A> rhs);
    public static Eff`1<A> op_RightShift(Eff`1<A> lhs, K`2<Eff, Unit> rhs);
    [PureAttribute]
public static override Eff`1<A> op_Implicit(Pure`1<A> ma);
    [PureAttribute]
public static override Eff`1<A> op_Implicit(Fail`1<Error> ma);
    [PureAttribute]
public static Eff`1<A> op_Implicit(Lift`1& ma);
    [PureAttribute]
public static Eff`1<A> op_Implicit(Lift`1& ma);
    [PureAttribute]
public static Eff`1<A> op_Implicit(Lift`2& ma);
    [PureAttribute]
public static Eff`1<A> op_Implicit(Lift`2& ma);
    [PureAttribute]
public static Eff`1<A> op_Implicit(Either`2& ma);
    [PureAttribute]
public static Eff`1<A> op_Implicit(Fin`1& ma);
    [PureAttribute]
public static Eff`1<A> op_Implicit(IO`1& ma);
    [PureAttribute]
public static Eff`1<A> op_Implicit(Error& fail);
    [PureAttribute]
public static override Eff`1<A> op_BitwiseOr(Eff`1<A> ma, Eff`1<A> mb);
    [PureAttribute]
public static override Eff`1<A> op_BitwiseOr(K`2<Eff, A> ma, Eff`1<A> mb);
    [PureAttribute]
public static override Eff`1<A> op_BitwiseOr(Eff`1<A> ma, K`2<Eff, A> mb);
    [PureAttribute]
public static override Eff`1<A> op_BitwiseOr(Eff`1<A> ma, Pure`1<A> mb);
    [PureAttribute]
public static override Eff`1<A> op_BitwiseOr(Eff`1<A> ma, Fail`1<Error> error);
    [PureAttribute]
public static Eff`1<A> op_BitwiseOr(Eff`1<A> ma, Error error);
    [PureAttribute]
public static Eff`1<A> op_BitwiseOr(Eff`1<A> ma, A value);
    [PureAttribute]
public static override Eff`1<A> op_BitwiseOr(Eff`1<A> ma, CatchM`3<Error, Eff, A> mb);
    [PureAttribute]
public static Eff`1<A> op_Implicit(Effect`2& ma);
    public virtual string ToString();
    private static override K`2<Eff`1<A>, T> LanguageExt.Traits.Fallible<LanguageExt.Common.Error,LanguageExt.Eff<A>>.Fail(Error error);
    private static override K`2<Eff`1<A>, T> LanguageExt.Traits.Fallible<LanguageExt.Common.Error,LanguageExt.Eff<A>>.Catch(K`2<Eff`1<A>, T> ma, Func`2<Error, bool> pred, Func`2<Error, K`2<Eff`1<A>, T>> f);
    private static override K`2<Eff`1<A>, U> LanguageExt.Traits.Monad<LanguageExt.Eff<A>>.Bind(K`2<Eff`1<A>, T> ma, Func`2<T, K`2<Eff`1<A>, U>> f);
    private static override K`2<Eff`1<A>, U> LanguageExt.Traits.Functor<LanguageExt.Eff<A>>.Map(Func`2<T, U> f, K`2<Eff`1<A>, T> ma);
    private static override K`2<Eff`1<A>, T> LanguageExt.Traits.Applicative<LanguageExt.Eff<A>>.Pure(T value);
    private static override K`2<Eff`1<A>, U> LanguageExt.Traits.Applicative<LanguageExt.Eff<A>>.Apply(K`2<Eff`1<A>, Func`2<T, U>> mf, K`2<Eff`1<A>, T> ma);
    private static override K`2<Eff`1<A>, U> LanguageExt.Traits.Applicative<LanguageExt.Eff<A>>.Action(K`2<Eff`1<A>, T> ma, K`2<Eff`1<A>, U> mb);
    private static override K`2<Eff`1<A>, T> LanguageExt.Traits.Applicative<LanguageExt.Eff<A>>.Actions(IEnumerable`1<K`2<Eff`1<A>, T>> fas);
    private static override K`2<Eff`1<A>, T> LanguageExt.Traits.MonoidK<LanguageExt.Eff<A>>.Empty();
    private static override K`2<Eff`1<A>, T> LanguageExt.Traits.SemigroupK<LanguageExt.Eff<A>>.Combine(K`2<Eff`1<A>, T> ma, K`2<Eff`1<A>, T> mb);
    private static override K`2<Eff`1<A>, T> LanguageExt.Traits.Readable<LanguageExt.Eff<A>,A>.Asks(Func`2<A, T> f);
    private static override K`2<Eff`1<A>, T> LanguageExt.Traits.Readable<LanguageExt.Eff<A>,A>.Local(Func`2<A, A> f, K`2<Eff`1<A>, T> ma);
    private static override K`2<Eff`1<A>, T> LanguageExt.Traits.MonadIO<LanguageExt.Eff<A>>.LiftIO(IO`1<T> ma);
    private static override K`2<Eff`1<A>, IO`1<T>> LanguageExt.Traits.MonadIO<LanguageExt.Eff<A>>.ToIO(K`2<Eff`1<A>, T> ma);
    private static override K`2<Eff`1<A>, U> LanguageExt.Traits.MonadIO<LanguageExt.Eff<A>>.MapIO(K`2<Eff`1<A>, T> ma, Func`2<IO`1<T>, IO`1<U>> f);
    internal static ReaderT`3<A, IO, X> getsM(Func`2<A, IO`1<X>> f);
    internal static ReaderT`3<A, IO, X> getsIO(Func`2<A, Task`1<X>> f);
    internal static ReaderT`3<A, IO, X> gets(Func`2<A, X> f);
    internal static ReaderT`3<A, IO, X> gets(Func`2<A, Fin`1<X>> f);
    internal static ReaderT`3<A, IO, X> gets(Func`2<A, Either`2<Error, X>> f);
    internal static ReaderT`3<A, IO, X> fail(Error value);
    internal static ReaderT`3<A, IO, X> pure(X value);
    [ObsoleteAttribute("Use either: `Prelude.Pure` or `Eff<A>.Pure`")]
[PureAttribute]
public static Eff`1<A> Success(A value);
    [ObsoleteAttribute("Use either: `Prelude.lift` or `Eff<A>.Lift`")]
[PureAttribute]
public static Eff`1<A> Effect(Func`1<A> f);
    [ObsoleteAttribute("Use either: `Prelude.lift` or `Eff<A>.Lift`")]
[PureAttribute]
public static Eff`1<A> EffectMaybe(Func`1<Fin`1<A>> f);
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Eff`1<A> left, Eff`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Eff`1<A> left, Eff`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Eff`1<A> other);
    [CompilerGeneratedAttribute]
public virtual Eff`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Eff`2& effect);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Eff`2 : object {
    [CompilerGeneratedAttribute]
private ReaderT`3<RT, IO, A> <effect>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public ReaderT`3<RT, IO, A> effect { get; public set; }
    public Eff`2(ReaderT`3<RT, IO, A> effect);
    internal Eff`2(Func`2<RT, Task`1<A>> effect);
    private Eff`2(A value);
    private Eff`2(Error value);
    private Eff`2(Func`2<RT, A> effect);
    private Eff`2(Func`2<RT, Fin`1<A>> effect);
    private Eff`2(Func`2<RT, Either`2<Error, A>> effect);
    private Eff`2(IO`1<A> effect);
    [CompilerGeneratedAttribute]
protected Eff`2(Eff`2<RT, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public ReaderT`3<RT, IO, A> get_effect();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_effect(ReaderT`3<RT, IO, A> value);
    [PureAttribute]
public static Eff`2<RT, A> Pure(A value);
    [PureAttribute]
public static Eff`2<RT, A> Fail(Error error);
    [PureAttribute]
public static Eff`2<RT, A> Lift(Func`2<RT, Either`2<Error, A>> f);
    [PureAttribute]
public static Eff`2<RT, A> Lift(Func`2<RT, Fin`1<A>> f);
    [PureAttribute]
public static Eff`2<RT, A> Lift(Func`2<RT, A> f);
    [PureAttribute]
public static Eff`2<RT, A> LiftIO(Func`2<RT, Task`1<A>> f);
    [PureAttribute]
public static Eff`2<RT, A> LiftIO(Func`2<RT, Task`1<Fin`1<A>>> f);
    [PureAttribute]
public static Eff`2<RT, A> LiftIO(Func`2<RT, IO`1<A>> f);
    [PureAttribute]
public static Eff`2<RT, A> Lift(Func`1<Either`2<Error, A>> f);
    [PureAttribute]
public static Eff`2<RT, A> Lift(Func`1<Fin`1<A>> f);
    [PureAttribute]
public static Eff`2<RT, A> Lift(Func`1<A> f);
    [PureAttribute]
public static Eff`2<RT, A> LiftIO(Func`1<Task`1<A>> f);
    [PureAttribute]
public static Eff`2<RT, A> LiftIO(Func`1<Task`1<Fin`1<A>>> f);
    [PureAttribute]
public static Eff`2<RT, A> LiftIO(IO`1<A> ma);
    [PureAttribute]
public Eff`2<RT, B> Map(Func`2<A, B> f);
    [PureAttribute]
public Eff`2<RT, B> Select(Func`2<A, B> f);
    [PureAttribute]
public Eff`2<RT, A> MapFail(Func`2<Error, Error> f);
    [PureAttribute]
public Eff`2<RT, B> MapIO(Func`2<IO`1<A>, IO`1<B>> f);
    [PureAttribute]
public Eff`2<RT, B> BiMap(Func`2<A, B> Succ, Func`2<Error, Error> Fail);
    [PureAttribute]
public Eff`2<RT, B> Match(Func`2<A, B> Succ, Func`2<Error, B> Fail);
    [PureAttribute]
public Eff`2<RT, A> IfFail(Func`2<Error, A> Fail);
    [PureAttribute]
public Eff`2<RT, A> IfFailEff(Func`2<Error, K`2<Eff`1<RT>, A>> Fail);
    [PureAttribute]
public Eff`2<RT, A> IfFailEff(Func`2<Error, K`2<Eff, A>> Fail);
    [PureAttribute]
public Eff`2<RT, A> Filter(Func`2<A, bool> predicate);
    [PureAttribute]
public Eff`2<RT, A> Where(Func`2<A, bool> predicate);
    [PureAttribute]
public Eff`2<RT, B> Bind(Func`2<A, Eff`2<RT, B>> f);
    [PureAttribute]
public Eff`2<RT, B> Bind(Func`2<A, IO`1<B>> f);
    [PureAttribute]
public Eff`2<RT, B> Bind(Func`2<A, Ask`2<RT, B>> f);
    [PureAttribute]
public Eff`2<RT, B> Bind(Func`2<A, K`2<Eff`1<RT>, B>> f);
    [PureAttribute]
public Eff`2<RT, B> Bind(Func`2<A, Pure`1<B>> f);
    [PureAttribute]
public Eff`2<RT, A> Bind(Func`2<A, Fail`1<Error>> f);
    [PureAttribute]
public Eff`2<RT, B> Bind(Func`2<A, Eff`1<B>> f);
    [PureAttribute]
public Eff`2<RT, B> Bind(Func`2<A, K`2<Eff, B>> f);
    [PureAttribute]
public Eff`2<RT, C> SelectMany(Func`2<A, Eff`2<RT, B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Eff`2<RT, C> SelectMany(Func`2<A, K`2<Eff`1<RT>, B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Eff`2<RT, C> SelectMany(Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Eff`2<RT, C> SelectMany(Func`2<A, IO`1<B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Eff`2<RT, C> SelectMany(Func`2<A, Ask`2<RT, B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Eff`2<RT, C> SelectMany(Func`2<A, Fail`1<Error>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Eff`2<RT, C> SelectMany(Func`2<A, Guard`2<Error, Unit>> bind, Func`3<A, Unit, C> project);
    [PureAttribute]
public Eff`2<RT, C> SelectMany(Func`2<A, Guard`2<Fail`1<Error>, Unit>> bind, Func`3<A, Unit, C> project);
    [PureAttribute]
public Eff`2<RT, C> SelectMany(Func`2<A, Eff`1<B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Eff`2<RT, C> SelectMany(Func`2<A, K`2<Eff, B>> bind, Func`3<A, B, C> project);
    public static Eff`2<RT, A> op_RightShift(Eff`2<RT, A> lhs, Eff`2<RT, A> rhs);
    public static Eff`2<RT, A> op_RightShift(Eff`2<RT, A> lhs, Eff`1<A> rhs);
    public static Eff`2<RT, A> op_RightShift(Eff`2<RT, A> lhs, K`2<Eff`1<RT>, A> rhs);
    public static Eff`2<RT, A> op_RightShift(Eff`2<RT, A> lhs, K`2<Eff, A> rhs);
    public static Eff`2<RT, A> op_RightShift(Eff`2<RT, A> lhs, Eff`2<RT, Unit> rhs);
    public static Eff`2<RT, A> op_RightShift(Eff`2<RT, A> lhs, Eff`1<Unit> rhs);
    public static Eff`2<RT, A> op_RightShift(Eff`2<RT, A> lhs, K`2<Eff`1<RT>, Unit> rhs);
    public static Eff`2<RT, A> op_RightShift(Eff`2<RT, A> lhs, K`2<Eff, Unit> rhs);
    [PureAttribute]
public static override Eff`2<RT, A> op_Implicit(Pure`1<A> ma);
    [PureAttribute]
public static override Eff`2<RT, A> op_Implicit(Fail`1<Error> ma);
    [PureAttribute]
public static Eff`2<RT, A> op_Implicit(Lift`1& ma);
    [PureAttribute]
public static Eff`2<RT, A> op_Implicit(Lift`1& ma);
    [PureAttribute]
public static Eff`2<RT, A> op_Implicit(Lift`2& ma);
    [PureAttribute]
public static Eff`2<RT, A> op_Implicit(Lift`2& ma);
    [PureAttribute]
public static Eff`2<RT, A> op_Implicit(Either`2& ma);
    [PureAttribute]
public static Eff`2<RT, A> op_Implicit(Fin`1& ma);
    [PureAttribute]
public static Eff`2<RT, A> op_Implicit(Eff`1& ma);
    [PureAttribute]
public static Eff`2<RT, A> op_Implicit(Effect`2& ma);
    [PureAttribute]
public static Eff`2<RT, A> op_Implicit(IO`1& ma);
    [PureAttribute]
public static Eff`2<RT, A> op_Implicit(Error fail);
    [PureAttribute]
public static override Eff`2<RT, A> op_BitwiseOr(Eff`2<RT, A> ma, Eff`2<RT, A> mb);
    [PureAttribute]
public static override Eff`2<RT, A> op_BitwiseOr(Eff`2<RT, A> ma, K`2<Eff`1<RT>, A> mb);
    [PureAttribute]
public static override Eff`2<RT, A> op_BitwiseOr(K`2<Eff`1<RT>, A> ma, Eff`2<RT, A> mb);
    [PureAttribute]
public static override Eff`2<RT, A> op_BitwiseOr(Eff`2<RT, A> ma, Pure`1<A> mb);
    [PureAttribute]
public static override Eff`2<RT, A> op_BitwiseOr(Eff`2<RT, A> ma, Fail`1<Error> error);
    [PureAttribute]
public static Eff`2<RT, A> op_BitwiseOr(Eff`2<RT, A> ma, Error error);
    [PureAttribute]
public static Eff`2<RT, A> op_BitwiseOr(Eff`2<RT, A> ma, A value);
    [PureAttribute]
public static override Eff`2<RT, A> op_BitwiseOr(Eff`2<RT, A> ma, CatchM`3<Error, Eff`1<RT>, A> mb);
    [PureAttribute]
public static Eff`2<RT, A> op_BitwiseOr(Eff`2<RT, A> ma, CatchM`3<Error, Eff, A> mb);
    [ObsoleteAttribute("Use either: `Eff<RT, A>.Lift`, `Prelude.liftEff`, or `lift`")]
[PureAttribute]
public static Eff`2<RT, A> Success(A value);
    [ObsoleteAttribute("Use either: `Eff<RT, A>.Lift`, `Prelude.liftEff`, or `lift`")]
[PureAttribute]
public static Eff`2<RT, A> Effect(Func`2<RT, A> f);
    [ObsoleteAttribute("Use either: `Eff<RT, A>.Lift`, `Prelude.liftEff`, or `lift`")]
[PureAttribute]
public static Eff`2<RT, A> EffectMaybe(Func`2<RT, Fin`1<A>> f);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Eff`2<RT, A> left, Eff`2<RT, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Eff`2<RT, A> left, Eff`2<RT, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Eff`2<RT, A> other);
    [CompilerGeneratedAttribute]
public virtual Eff`2<RT, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(ReaderT`3& effect);
}
[IsReadOnlyAttribute]
public class LanguageExt.Effects.MinRT : ValueType {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.EffExtensions : object {
    [ExtensionAttribute]
public static Eff`1<B> Apply(Eff`1<Func`2<A, B>> mf, Eff`1<A> ma);
    [ExtensionAttribute]
public static Eff`1<C> Apply(Eff`1<Func`3<A, B, C>> mf, Eff`1<A> ma, Eff`1<B> mb);
    [ExtensionAttribute]
public static Eff`1<Func`2<B, C>> Apply(Eff`1<Func`3<A, B, C>> mf, Eff`1<A> ma);
    [ExtensionAttribute]
public static Eff`1<D> Apply(Eff`1<Func`4<A, B, C, D>> mf, Eff`1<A> ma, Eff`1<B> mb, Eff`1<C> mc);
    [ExtensionAttribute]
public static Eff`1<Func`2<C, D>> Apply(Eff`1<Func`4<A, B, C, D>> mf, Eff`1<A> ma, Eff`1<B> mb);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`1<Func`2<B, Func`2<C, D>>> Apply(Eff`1<Func`4<A, B, C, D>> mf, Eff`1<A> ma);
    [ExtensionAttribute]
public static Eff`1<E> Apply(Eff`1<Func`5<A, B, C, D, E>> mf, Eff`1<A> ma, Eff`1<B> mb, Eff`1<C> mc, Eff`1<D> md);
    [ExtensionAttribute]
public static Eff`1<Func`2<D, E>> Apply(Eff`1<Func`5<A, B, C, D, E>> mf, Eff`1<A> ma, Eff`1<B> mb, Eff`1<C> mc);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`1<Func`2<C, Func`2<D, E>>> Apply(Eff`1<Func`5<A, B, C, D, E>> mf, Eff`1<A> ma, Eff`1<B> mb);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`1<Func`2<B, Func`2<C, Func`2<D, E>>>> Apply(Eff`1<Func`5<A, B, C, D, E>> mf, Eff`1<A> ma);
    [ExtensionAttribute]
public static Eff`1<B> Apply(Func`2<A, B> f, Eff`1<A> ma);
    [ExtensionAttribute]
public static Eff`1<C> Apply(Func`3<A, B, C> f, Eff`1<A> ma, Eff`1<B> mb);
    [ExtensionAttribute]
public static Eff`1<Func`2<B, C>> Apply(Func`3<A, B, C> f, Eff`1<A> ma);
    [ExtensionAttribute]
public static Eff`1<D> Apply(Func`4<A, B, C, D> f, Eff`1<A> ma, Eff`1<B> mb, Eff`1<C> mc);
    [ExtensionAttribute]
public static Eff`1<Func`2<C, D>> Apply(Func`4<A, B, C, D> f, Eff`1<A> ma, Eff`1<B> mb);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`1<Func`2<B, Func`2<C, D>>> Apply(Func`4<A, B, C, D> f, Eff`1<A> ma);
    [ExtensionAttribute]
public static Eff`1<E> Apply(Func`5<A, B, C, D, E> f, Eff`1<A> ma, Eff`1<B> mb, Eff`1<C> mc, Eff`1<D> md);
    [ExtensionAttribute]
public static Eff`1<Func`2<D, E>> Apply(Func`5<A, B, C, D, E> f, Eff`1<A> ma, Eff`1<B> mb, Eff`1<C> mc);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`1<Func`2<C, Func`2<D, E>>> Apply(Func`5<A, B, C, D, E> f, Eff`1<A> ma, Eff`1<B> mb);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`1<Func`2<B, Func`2<C, Func`2<D, E>>>> Apply(Func`5<A, B, C, D, E> f, Eff`1<A> ma);
    [ExtensionAttribute]
public static Eff`1<B> Action(Eff`1<A> ma, Eff`1<B> mb);
    [ExtensionAttribute]
public static Eff`1<A> As(K`2<Eff, A> ma);
    [ExtensionAttribute]
public static Eff`1<A> As(Eff`2<MinRT, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Fin`1<A> Run(K`2<Eff, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Fin`1<A> Run(K`2<Eff, A> ma, EnvIO envIO);
    [ExtensionAttribute]
[PureAttribute]
public static A RunUnsafe(K`2<Eff, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static A RunUnsafe(K`2<Eff, A> ma, EnvIO envIO);
    [ExtensionAttribute]
[PureAttribute]
public static IO`1<A> RunIO(K`2<Eff, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Task`1<Fin`1<A>> RunAsync(K`2<Eff, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Task`1<Fin`1<A>> RunAsync(K`2<Eff, A> ma, EnvIO envIO);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<A> RunUnsafeAsync(K`2<Eff, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<A> RunUnsafeAsync(K`2<Eff, A> ma, EnvIO envIO);
    [ExtensionAttribute]
public static Eff`1<A> Flatten(K`2<Eff, K`2<Eff, A>> mma);
    [ExtensionAttribute]
public static Eff`1<A> Flatten(K`2<Eff, Eff`1<A>> mma);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`1<D> SelectMany(ValueTuple`2<K`2<Eff, A>, K`2<Eff, B>> self, Func`2<ValueTuple`2<A, B>, K`2<Eff, C>> bind, Func`3<ValueTuple`2<A, B>, C, D> project);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`1<D> SelectMany(K`2<Eff, A> self, Func`2<A, ValueTuple`2<K`2<Eff, B>, K`2<Eff, C>>> bind, Func`3<A, ValueTuple`2<B, C>, D> project);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`1<E> SelectMany(ValueTuple`3<K`2<Eff, A>, K`2<Eff, B>, K`2<Eff, C>> self, Func`2<ValueTuple`3<A, B, C>, K`2<Eff, D>> bind, Func`3<ValueTuple`3<A, B, C>, D, E> project);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`1<E> SelectMany(K`2<Eff, A> self, Func`2<A, ValueTuple`3<K`2<Eff, B>, K`2<Eff, C>, K`2<Eff, D>>> bind, Func`3<A, ValueTuple`3<B, C, D>, E> project);
    [ExtensionAttribute]
public static Eff`2<RT, B> Apply(K`2<Eff`1<RT>, Func`2<A, B>> mf, K`2<Eff`1<RT>, A> ma);
    [ExtensionAttribute]
public static Eff`2<RT, C> Apply(K`2<Eff`1<RT>, Func`3<A, B, C>> mf, K`2<Eff`1<RT>, A> ma, K`2<Eff`1<RT>, B> mb);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`2<RT, Func`2<B, C>> Apply(K`2<Eff`1<RT>, Func`3<A, B, C>> mf, K`2<Eff`1<RT>, A> ma);
    [ExtensionAttribute]
public static Eff`2<RT, D> Apply(K`2<Eff`1<RT>, Func`4<A, B, C, D>> mf, K`2<Eff`1<RT>, A> ma, K`2<Eff`1<RT>, B> mb, K`2<Eff`1<RT>, C> mc);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`2<RT, Func`2<C, D>> Apply(K`2<Eff`1<RT>, Func`4<A, B, C, D>> mf, K`2<Eff`1<RT>, A> ma, K`2<Eff`1<RT>, B> mb);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`2<RT, Func`2<B, Func`2<C, D>>> Apply(K`2<Eff`1<RT>, Func`4<A, B, C, D>> mf, K`2<Eff`1<RT>, A> ma);
    [ExtensionAttribute]
public static Eff`2<RT, E> Apply(K`2<Eff`1<RT>, Func`5<A, B, C, D, E>> mf, K`2<Eff`1<RT>, A> ma, K`2<Eff`1<RT>, B> mb, K`2<Eff`1<RT>, C> mc, K`2<Eff`1<RT>, D> md);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`2<RT, Func`2<D, E>> Apply(K`2<Eff`1<RT>, Func`5<A, B, C, D, E>> mf, K`2<Eff`1<RT>, A> ma, K`2<Eff`1<RT>, B> mb, K`2<Eff`1<RT>, C> mc);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`2<RT, Func`2<C, Func`2<D, E>>> Apply(K`2<Eff`1<RT>, Func`5<A, B, C, D, E>> mf, K`2<Eff`1<RT>, A> ma, K`2<Eff`1<RT>, B> mb);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`2<RT, Func`2<B, Func`2<C, Func`2<D, E>>>> Apply(K`2<Eff`1<RT>, Func`5<A, B, C, D, E>> mf, K`2<Eff`1<RT>, A> ma);
    [ExtensionAttribute]
public static Eff`2<RT, B> Action(K`2<Eff`1<RT>, A> ma, K`2<Eff`1<RT>, B> mb);
    [ExtensionAttribute]
public static Eff`2<RT, A> As(K`2<Eff`1<RT>, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Fin`1<A> Run(K`2<Eff`1<RT>, A> ma, RT env);
    [ExtensionAttribute]
[PureAttribute]
public static Fin`1<A> Run(K`2<Eff`1<RT>, A> ma, RT env, EnvIO envIO);
    [ExtensionAttribute]
[PureAttribute]
public static A RunUnsafe(K`2<Eff`1<RT>, A> ma, RT env);
    [ExtensionAttribute]
[PureAttribute]
public static A RunUnsafe(K`2<Eff`1<RT>, A> ma, RT env, EnvIO envIO);
    [ExtensionAttribute]
[PureAttribute]
public static IO`1<A> RunIO(K`2<Eff`1<RT>, A> ma, RT env);
    [AsyncStateMachineAttribute("LanguageExt.EffExtensions/<RunAsync>d__55`2")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<Fin`1<A>> RunAsync(K`2<Eff`1<RT>, A> ma, RT env);
    [AsyncStateMachineAttribute("LanguageExt.EffExtensions/<RunAsync>d__56`2")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<Fin`1<A>> RunAsync(K`2<Eff`1<RT>, A> ma, RT env, EnvIO envIO);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<A> RunUnsafeAsync(K`2<Eff`1<RT>, A> ma, RT env);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<A> RunUnsafeAsync(K`2<Eff`1<RT>, A> ma, RT env, EnvIO envIO);
    [ExtensionAttribute]
public static Eff`2<RT, A> Flatten(K`2<Eff`1<RT>, Eff`2<RT, A>> mma);
    [ExtensionAttribute]
public static Eff`2<RT, A> Flatten(K`2<Eff`1<RT>, K`2<Eff`1<RT>, A>> mma);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`2<RT, D> SelectMany(ValueTuple`2<K`2<Eff`1<RT>, A>, K`2<Eff`1<RT>, B>> self, Func`2<ValueTuple`2<A, B>, K`2<Eff`1<RT>, C>> bind, Func`3<ValueTuple`2<A, B>, C, D> project);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`2<RT, D> SelectMany(K`2<Eff`1<RT>, A> self, Func`2<A, ValueTuple`2<K`2<Eff`1<RT>, B>, K`2<Eff`1<RT>, C>>> bind, Func`3<A, ValueTuple`2<B, C>, D> project);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`2<RT, E> SelectMany(ValueTuple`3<K`2<Eff`1<RT>, A>, K`2<Eff`1<RT>, B>, K`2<Eff`1<RT>, C>> self, Func`2<ValueTuple`3<A, B, C>, K`2<Eff`1<RT>, D>> bind, Func`3<ValueTuple`3<A, B, C>, D, E> project);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`2<RT, E> SelectMany(K`2<Eff`1<RT>, A> self, Func`2<A, ValueTuple`3<K`2<Eff`1<RT>, B>, K`2<Eff`1<RT>, C>, K`2<Eff`1<RT>, D>>> bind, Func`3<A, ValueTuple`3<B, C, D>, E> project);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Either : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Either`1 : object {
    private static override K`2<Either`1<L>, B> LanguageExt.Traits.Applicative<LanguageExt.Either<L>>.Apply(K`2<Either`1<L>, Func`2<A, B>> mf, K`2<Either`1<L>, A> ma);
    private static override K`2<Either`1<L>, B> LanguageExt.Traits.Applicative<LanguageExt.Either<L>>.Action(K`2<Either`1<L>, A> ma, K`2<Either`1<L>, B> mb);
    private static override K`2<Either`1<L>, B> LanguageExt.Traits.Monad<LanguageExt.Either<L>>.Bind(K`2<Either`1<L>, A> ma, Func`2<A, K`2<Either`1<L>, B>> f);
    private static override K`2<Either`1<L>, A> LanguageExt.Traits.Applicative<LanguageExt.Either<L>>.Pure(A value);
    private static override K`2<F, K`2<Either`1<L>, B>> LanguageExt.Traits.Traversable<LanguageExt.Either<L>>.Traverse(Func`2<A, K`2<F, B>> f, K`2<Either`1<L>, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Either<L>>.FoldWhile(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<Either`1<L>, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Either<L>>.FoldBackWhile(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<Either`1<L>, A> ta);
    private static override K`2<Either`1<L>, B> LanguageExt.Traits.Functor<LanguageExt.Either<L>>.Map(Func`2<A, B> f, K`2<Either`1<L>, A> ma);
    private static K`2<Either`1<L>, A> Right(A value);
    private static K`2<Either`1<L>, A> Left(L value);
    public static override K`2<Either`1<L>, A> Combine(K`2<Either`1<L>, A> ma, K`2<Either`1<L>, A> mb);
    private static override K`2<Either`1<L>, A> LanguageExt.Traits.Fallible<L,LanguageExt.Either<L>>.Fail(L error);
    private static override K`2<Either`1<L>, A> LanguageExt.Traits.Fallible<L,LanguageExt.Either<L>>.Catch(K`2<Either`1<L>, A> fa, Func`2<L, bool> Predicate, Func`2<L, K`2<Either`1<L>, A>> Fail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.Either`2 : object {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public bool IsRight { get; }
    public bool IsLeft { get; }
    internal R RightValue { get; }
    internal L LeftValue { get; }
    [CompilerGeneratedAttribute]
protected Either`2(Either`2<L, R> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public abstract virtual bool get_IsRight();
    public abstract virtual bool get_IsLeft();
    [PureAttribute]
public static R op_Explicit(Either`2<L, R> ma);
    [PureAttribute]
public static L op_Explicit(Either`2<L, R> ma);
    [PureAttribute]
public static Either`2<L, R> op_Implicit(R value);
    [PureAttribute]
public static Either`2<L, R> op_Implicit(L value);
    [PureAttribute]
public abstract virtual B Match(Func`2<L, B> Left, Func`2<R, B> Right);
    public Unit Match(Action`1<L> Left, Action`1<R> Right);
    [PureAttribute]
public R IfLeft(Func`1<R> Left);
    [PureAttribute]
public R IfLeft(Func`2<L, R> leftMap);
    [PureAttribute]
public R IfLeft(R rightValue);
    public Unit IfLeft(Action`1<L> Left);
    public Unit IfRight(Action`1<R> Right);
    [PureAttribute]
public L IfRight(L leftValue);
    [PureAttribute]
public L IfRight(Func`1<L> Right);
    [PureAttribute]
public L IfRight(Func`2<R, L> rightMap);
    [PureAttribute]
public EitherUnitContext`2<L, R> Right(Action`1<R> right);
    [PureAttribute]
public EitherContext`3<L, R, Ret> Right(Func`2<R, Ret> right);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("2")]
[PureAttribute]
public sealed virtual int CompareTo(object obj);
    [IteratorStateMachineAttribute("LanguageExt.Either`2/<GetEnumerator>d__24")]
[PureAttribute]
public sealed virtual IEnumerator`1<R> GetEnumerator();
    [PureAttribute]
public abstract virtual ReadOnlySpan`1<L> LeftSpan();
    [PureAttribute]
public abstract virtual ReadOnlySpan`1<R> RightSpan();
    [PureAttribute]
public Lst`1<L> LeftToList();
    [PureAttribute]
public Arr`1<L> LeftToArray();
    public Lst`1<R> ToList();
    public Arr`1<R> ToArray();
    [PureAttribute]
public Seq`1<R> ToSeq();
    [PureAttribute]
public Seq`1<L> LeftToSeq();
    [PureAttribute]
public Option`1<R> ToOption();
    [PureAttribute]
public StreamT`2<M, R> ToStream();
    [PureAttribute]
public StreamT`2<M, L> LeftToStream();
    [PureAttribute]
public Eff`1<R> ToEff(Func`2<L, Error> Left);
    [PureAttribute]
public EitherT`3<L, IO, R> ToIO();
    [PureAttribute]
public static bool op_LessThan(Either`2<L, R> lhs, Fail`1<L> rhs);
    [PureAttribute]
public static bool op_LessThanOrEqual(Either`2<L, R> lhs, Fail`1<L> rhs);
    [PureAttribute]
public static bool op_GreaterThan(Either`2<L, R> lhs, Fail`1<L> rhs);
    [PureAttribute]
public static bool op_GreaterThanOrEqual(Either`2<L, R> lhs, Fail`1<L> rhs);
    [PureAttribute]
public static bool op_LessThan(Either`2<L, R> lhs, Pure`1<R> rhs);
    [PureAttribute]
public static bool op_LessThanOrEqual(Either`2<L, R> lhs, Pure`1<R> rhs);
    [PureAttribute]
public static bool op_GreaterThan(Either`2<L, R> lhs, Pure`1<R> rhs);
    [PureAttribute]
public static bool op_GreaterThanOrEqual(Either`2<L, R> lhs, Pure`1<R> rhs);
    [PureAttribute]
public static bool op_LessThan(Fail`1<L> lhs, Either`2<L, R> rhs);
    [PureAttribute]
public static bool op_LessThanOrEqual(Fail`1<L> lhs, Either`2<L, R> rhs);
    [PureAttribute]
public static bool op_GreaterThan(Fail`1<L> lhs, Either`2<L, R> rhs);
    [PureAttribute]
public static bool op_GreaterThanOrEqual(Fail`1<L> lhs, Either`2<L, R> rhs);
    [PureAttribute]
public static bool op_LessThan(Pure`1<R> lhs, Either`2<L, R> rhs);
    [PureAttribute]
public static bool op_LessThanOrEqual(Pure`1<R> lhs, Either`2<L, R> rhs);
    [PureAttribute]
public static bool op_GreaterThan(Pure`1<R> lhs, Either`2<L, R> rhs);
    [PureAttribute]
public static bool op_GreaterThanOrEqual(Pure`1<R> lhs, Either`2<L, R> rhs);
    [PureAttribute]
public static bool op_LessThan(Either`2<L, R> lhs, Either`2<L, R> rhs);
    [PureAttribute]
public static bool op_LessThanOrEqual(Either`2<L, R> lhs, Either`2<L, R> rhs);
    [PureAttribute]
public static bool op_GreaterThan(Either`2<L, R> lhs, Either`2<L, R> rhs);
    [PureAttribute]
public static bool op_GreaterThanOrEqual(Either`2<L, R> lhs, Either`2<L, R> rhs);
    [PureAttribute]
public static bool op_Equality(Either`2<L, R> lhs, Fail`1<L> rhs);
    [PureAttribute]
public static bool op_Equality(Either`2<L, R> lhs, Pure`1<R> rhs);
    [PureAttribute]
public static bool op_Equality(Fail`1<L> lhs, Either`2<L, R> rhs);
    [PureAttribute]
public static bool op_Equality(Pure`1<R> lhs, Either`2<L, R> rhs);
    [PureAttribute]
public static bool op_Inequality(Either`2<L, R> lhs, Fail`1<L> rhs);
    [PureAttribute]
public static bool op_Inequality(Either`2<L, R> lhs, Pure`1<R> rhs);
    [PureAttribute]
public static bool op_Inequality(Fail`1<L> lhs, Either`2<L, R> rhs);
    [PureAttribute]
public static bool op_Inequality(Pure`1<R> lhs, Either`2<L, R> rhs);
    [PureAttribute]
public static override Either`2<L, R> op_BitwiseOr(Either`2<L, R> lhs, Either`2<L, R> rhs);
    [PureAttribute]
public static override Either`2<L, R> op_BitwiseOr(K`2<Either`1<L>, R> lhs, Either`2<L, R> rhs);
    [PureAttribute]
public static override Either`2<L, R> op_BitwiseOr(Either`2<L, R> lhs, K`2<Either`1<L>, R> rhs);
    [PureAttribute]
public static override Either`2<L, R> op_BitwiseOr(Either`2<L, R> ma, Pure`1<R> mb);
    [PureAttribute]
public static override Either`2<L, R> op_BitwiseOr(Either`2<L, R> ma, Fail`1<L> mb);
    [PureAttribute]
public static override Either`2<L, R> op_BitwiseOr(Either`2<L, R> ma, CatchM`3<L, Either`1<L>, R> mb);
    [PureAttribute]
public static bool op_True(Either`2<L, R> value);
    [PureAttribute]
public static bool op_False(Either`2<L, R> value);
    [PureAttribute]
public int CompareTo(Either`2<L, R> other);
    [PureAttribute]
public int CompareTo(Either`2<L, R> other);
    [PureAttribute]
public abstract virtual int CompareTo(Either`2<L, R> other);
    [PureAttribute]
public int CompareTo(Fail`1<L> other);
    [PureAttribute]
public sealed virtual int CompareTo(Pure`1<R> other);
    [NullableContextAttribute("2")]
[PureAttribute]
public sealed virtual int CompareTo(R other);
    [NullableContextAttribute("2")]
[PureAttribute]
public int CompareTo(L other);
    [NullableContextAttribute("2")]
[PureAttribute]
public sealed virtual bool Equals(R other);
    [NullableContextAttribute("2")]
[PureAttribute]
public bool Equals(L other);
    [PureAttribute]
public virtual bool Equals(Either`2<L, R> other);
    [PureAttribute]
public virtual bool Equals(Either`2<L, R> other);
    [PureAttribute]
public abstract virtual bool Equals(Either`2<L, R> other);
    [PureAttribute]
public bool Equals(Fail`1<L> other);
    [PureAttribute]
public sealed virtual bool Equals(Pure`1<R> other);
    [PureAttribute]
public sealed virtual Res MatchUntyped(Func`2<object, Res> Left, Func`2<object, Res> Right);
    [PureAttribute]
public sealed virtual Type GetUnderlyingRightType();
    [PureAttribute]
public sealed virtual Type GetUnderlyingLeftType();
    [PureAttribute]
public static Either`2<L, R> Right(R value);
    [PureAttribute]
public static Either`2<L, R> Left(L value);
    internal abstract virtual R get_RightValue();
    internal abstract virtual L get_LeftValue();
    [PureAttribute]
public Type GetUnderlyingType();
    [PureAttribute]
public Either`2<R, L> Swap();
    [PureAttribute]
public bool ForAll(Func`2<R, bool> Right);
    [PureAttribute]
public bool BiForAll(Func`2<L, bool> Left, Func`2<R, bool> Right);
    [PureAttribute]
public S Fold(S state, Func`3<S, R, S> Right);
    [PureAttribute]
public S BiFold(S state, Func`3<S, L, S> Left, Func`3<S, R, S> Right);
    [PureAttribute]
public bool Exists(Func`2<R, bool> pred);
    public Either`2<L, R> Do(Action`1<R> f);
    [PureAttribute]
public K`2<F, Either`2<L, B>> Traverse(Func`2<R, K`2<F, B>> f);
    [PureAttribute]
public abstract virtual Either`2<L, B> Map(Func`2<R, B> f);
    [PureAttribute]
public Either`2<B, R> MapLeft(Func`2<L, B> f);
    [PureAttribute]
public abstract virtual Either`2<L2, R2> BiMap(Func`2<L, L2> Left, Func`2<R, R2> Right);
    [PureAttribute]
public abstract virtual Either`2<L, B> Bind(Func`2<R, Either`2<L, B>> f);
    [PureAttribute]
public Either`2<L, B> Bind(Func`2<R, K`2<Either`1<L>, B>> f);
    [PureAttribute]
public abstract virtual Either`2<L2, R2> BiBind(Func`2<L, Either`2<L2, R2>> Left, Func`2<R, Either`2<L2, R2>> Right);
    [PureAttribute]
public Either`2<B, R> BindLeft(Func`2<L, Either`2<B, R>> f);
    [PureAttribute]
public Either`2<L, U> Select(Func`2<R, U> f);
    [PureAttribute]
public Either`2<L, T> SelectMany(Func`2<R, Either`2<L, S>> bind, Func`3<R, S, T> project);
    [PureAttribute]
public Either`2<L, B> Bind(Func`2<R, Pure`1<B>> f);
    [PureAttribute]
public Either`2<L, R> Bind(Func`2<R, Fail`1<L>> f);
    [PureAttribute]
public Either`2<L, C> SelectMany(Func`2<R, Pure`1<B>> bind, Func`3<R, B, C> project);
    [PureAttribute]
public Either`2<L, C> SelectMany(Func`2<R, Fail`1<L>> bind, Func`3<R, B, C> _);
    [PureAttribute]
public static override Either`2<L, R> op_Implicit(Pure`1<R> mr);
    [PureAttribute]
public static override Either`2<L, R> op_Implicit(Fail`1<L> mr);
    [PureAttribute]
[ObsoleteAttribute("Use ToList() instead")]
public Lst`1<R> RightToList();
    [PureAttribute]
[ObsoleteAttribute("Use ToArray() instead")]
public Arr`1<R> RightToArray();
    [PureAttribute]
[ObsoleteAttribute("Use ToList() instead")]
public Seq`1<R> RightToSeq();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Either`2<L, R> left, Either`2<L, R> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Either`2<L, R> left, Either`2<L, R> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public abstract virtual Either`2<L, R> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class LanguageExt.EitherContext`3 : ValueType {
    private Either`2<L, R> either;
    private Func`2<R, Ret> rightHandler;
    internal EitherContext`3(Either`2<L, R> either, Func`2<R, Ret> rightHandler);
    [PureAttribute]
public Ret Left(Func`2<L, Ret> left);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.EitherExtensions : object {
    [ExtensionAttribute]
public static Either`2<L, R> As(K`2<Either`1<L>, R> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Either`2<L, R> Flatten(Either`2<L, Either`2<L, R>> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Either`2<L, B> Apply(Either`2<L, Func`2<A, B>> fab, Either`2<L, A> fa);
    [ExtensionAttribute]
[PureAttribute]
public static Either`2<L, C> Apply(Either`2<L, Func`3<A, B, C>> fabc, Either`2<L, A> fa, Either`2<L, B> fb);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Either`2<L, Func`2<B, C>> Apply(Either`2<L, Func`3<A, B, C>> fabc, Either`2<L, A> fa);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Either`2<L, Func`2<B, C>> Apply(Either`2<L, Func`2<A, Func`2<B, C>>> fabc, Either`2<L, A> fa);
    [ExtensionAttribute]
[PureAttribute]
public static Either`2<L, B> Action(Either`2<L, A> fa, Either`2<L, B> fb);
    [IteratorStateMachineAttribute("LanguageExt.EitherExtensions/<Lefts>d__7`2")]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<L> Lefts(IEnumerable`1<Either`2<L, R>> self);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Seq`1<L> Lefts(Seq`1<Either`2<L, R>> self);
    [IteratorStateMachineAttribute("LanguageExt.EitherExtensions/<Rights>d__9`2")]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<R> Rights(IEnumerable`1<Either`2<L, R>> self);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Seq`1<R> Rights(Seq`1<Either`2<L, R>> self);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTuple`2<IEnumerable`1<L>, IEnumerable`1<R>> Partition(IEnumerable`1<Either`2<L, R>> self);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTuple`2<Seq`1<L>, Seq`1<R>> Partition(Seq`1<Either`2<L, R>> self);
    [AsyncStateMachineAttribute("LanguageExt.EitherExtensions/<MatchAsync>d__13`3")]
[ExtensionAttribute]
public static Task`1<R2> MatchAsync(Either`2<L, Task`1<R>> self, Func`2<R, R2> Right, Func`2<L, R2> Left);
    [AsyncStateMachineAttribute("LanguageExt.EitherExtensions/<MapAsync>d__14`3")]
[ExtensionAttribute]
public static Task`1<Either`2<L, R2>> MapAsync(Either`2<L, R> self, Func`2<R, Task`1<R2>> map);
    [AsyncStateMachineAttribute("LanguageExt.EitherExtensions/<MapAsync>d__15`3")]
[ExtensionAttribute]
public static Task`1<Either`2<L, R2>> MapAsync(Task`1<Either`2<L, R>> self, Func`2<R, Task`1<R2>> map);
    [AsyncStateMachineAttribute("LanguageExt.EitherExtensions/<MapAsync>d__16`3")]
[ExtensionAttribute]
public static Task`1<Either`2<L, R2>> MapAsync(Task`1<Either`2<L, R>> self, Func`2<R, R2> map);
    [AsyncStateMachineAttribute("LanguageExt.EitherExtensions/<MapAsync>d__17`3")]
[ExtensionAttribute]
public static Task`1<Either`2<L, R2>> MapAsync(Either`2<L, Task`1<R>> self, Func`2<R, R2> map);
    [AsyncStateMachineAttribute("LanguageExt.EitherExtensions/<MapAsync>d__18`3")]
[ExtensionAttribute]
public static Task`1<Either`2<L, R2>> MapAsync(Either`2<L, Task`1<R>> self, Func`2<R, Task`1<R2>> map);
    [AsyncStateMachineAttribute("LanguageExt.EitherExtensions/<BindAsync>d__19`3")]
[ExtensionAttribute]
public static Task`1<Either`2<L, R2>> BindAsync(Either`2<L, R> self, Func`2<R, Task`1<Either`2<L, R2>>> bind);
    [AsyncStateMachineAttribute("LanguageExt.EitherExtensions/<BindAsync>d__20`3")]
[ExtensionAttribute]
public static Task`1<Either`2<L, R2>> BindAsync(Task`1<Either`2<L, R>> self, Func`2<R, Task`1<Either`2<L, R2>>> bind);
    [AsyncStateMachineAttribute("LanguageExt.EitherExtensions/<BindAsync>d__21`3")]
[ExtensionAttribute]
public static Task`1<Either`2<L, R2>> BindAsync(Task`1<Either`2<L, R>> self, Func`2<R, Either`2<L, R2>> bind);
    [AsyncStateMachineAttribute("LanguageExt.EitherExtensions/<BindAsync>d__22`3")]
[ExtensionAttribute]
public static Task`1<Either`2<L, R2>> BindAsync(Either`2<L, Task`1<R>> self, Func`2<R, Either`2<L, R2>> bind);
    [AsyncStateMachineAttribute("LanguageExt.EitherExtensions/<BindAsync>d__23`3")]
[ExtensionAttribute]
public static Task`1<Either`2<L, R2>> BindAsync(Either`2<L, Task`1<R>> self, Func`2<R, Task`1<Either`2<L, R2>>> bind);
    [AsyncStateMachineAttribute("LanguageExt.EitherExtensions/<IterAsync>d__24`2")]
[ExtensionAttribute]
public static Task`1<Unit> IterAsync(Task`1<Either`2<L, R>> self, Action`1<R> action);
    [AsyncStateMachineAttribute("LanguageExt.EitherExtensions/<IterAsync>d__25`2")]
[ExtensionAttribute]
public static Task`1<Unit> IterAsync(Either`2<L, Task`1<R>> self, Action`1<R> action);
    [ExtensionAttribute]
[PureAttribute]
public static Validation`2<L, R> ToValidation(Either`2<L, R> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Eff`1<R> ToEff(Either`2<Error, R> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Eff`1<R> ToEff(Either`2<Exception, R> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Eff`1<R> ToEff(Either`2<string, R> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.EitherGuardExtensions : object {
    [ExtensionAttribute]
public static Either`2<L, Unit> SelectMany(Either`2<L, A> ma, Func`2<A, Guard`2<L, Unit>> f);
    [ExtensionAttribute]
public static Either`2<L, C> SelectMany(Either`2<L, A> ma, Func`2<A, Guard`2<L, Unit>> bind, Func`3<A, Unit, C> project);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.EitherIsNotLeftException : Exception {
    public EitherIsNotLeftException(string message);
    public EitherIsNotLeftException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.EitherIsNotRightException : Exception {
    public EitherIsNotRightException(string message);
    public EitherIsNotRightException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.EitherT : object {
    public static EitherT`3<L, M, B> bind(EitherT`3<L, M, A> ma, Func`2<A, EitherT`3<L, M, B>> f);
    public static EitherT`3<L, M, B> map(Func`2<A, B> f, EitherT`3<L, M, A> ma);
    public static EitherT`3<L, M, A> Right(A value);
    public static EitherT`3<L, M, A> Left(L value);
    public static EitherT`3<L, M, B> apply(EitherT`3<L, M, Func`2<A, B>> mf, EitherT`3<L, M, A> ma);
    public static EitherT`3<L, M, B> action(EitherT`3<L, M, A> ma, EitherT`3<L, M, B> mb);
    public static EitherT`3<L, M, A> lift(Either`2<L, A> ma);
    public static EitherT`3<L, M, A> lift(K`2<M, A> ma);
    public static EitherT`3<L, M, A> lift(Pure`1<A> ma);
    public static EitherT`3<L, M, A> lift(Fail`1<L> ma);
    public static EitherT`3<L, M, A> liftIO(IO`1<A> ma);
    public static K`2<M, B> match(EitherT`3<L, M, A> ma, Func`2<L, B> Left, Func`2<A, B> Right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.EitherT`2 : object {
    public static EitherT`3<L, M, A> Right(A value);
    public static EitherT`3<L, M, A> Left(L value);
    public static EitherT`3<L, M, A> lift(Either`2<L, A> ma);
    public static EitherT`3<L, M, A> lift(Pure`1<A> ma);
    public static EitherT`3<L, M, A> lift(Fail`1<L> ma);
    public static EitherT`3<L, M, A> liftIO(IO`1<A> ma);
    private static override K`2<EitherT`2<L, M>, B> LanguageExt.Traits.Monad<LanguageExt.EitherT<L,M>>.Bind(K`2<EitherT`2<L, M>, A> ma, Func`2<A, K`2<EitherT`2<L, M>, B>> f);
    private static override K`2<EitherT`2<L, M>, B> LanguageExt.Traits.Functor<LanguageExt.EitherT<L,M>>.Map(Func`2<A, B> f, K`2<EitherT`2<L, M>, A> ma);
    private static override K`2<EitherT`2<L, M>, A> LanguageExt.Traits.Applicative<LanguageExt.EitherT<L,M>>.Pure(A value);
    private static override K`2<EitherT`2<L, M>, B> LanguageExt.Traits.Applicative<LanguageExt.EitherT<L,M>>.Apply(K`2<EitherT`2<L, M>, Func`2<A, B>> mf, K`2<EitherT`2<L, M>, A> ma);
    private static override K`2<EitherT`2<L, M>, B> LanguageExt.Traits.Applicative<LanguageExt.EitherT<L,M>>.Action(K`2<EitherT`2<L, M>, A> ma, K`2<EitherT`2<L, M>, B> mb);
    private static override K`2<EitherT`2<L, M>, A> LanguageExt.Traits.MonadT<LanguageExt.EitherT<L,M>,M>.Lift(K`2<M, A> ma);
    private static override K`2<EitherT`2<L, M>, A> LanguageExt.Traits.MonadIO<LanguageExt.EitherT<L,M>>.LiftIO(IO`1<A> ma);
    private static override K`2<EitherT`2<L, M>, A> LanguageExt.Traits.SemigroupK<LanguageExt.EitherT<L,M>>.Combine(K`2<EitherT`2<L, M>, A> ma, K`2<EitherT`2<L, M>, A> mb);
    private static override K`2<EitherT`2<L, M>, A> LanguageExt.Traits.Fallible<L,LanguageExt.EitherT<L,M>>.Fail(L error);
    private static override K`2<EitherT`2<L, M>, A> LanguageExt.Traits.Fallible<L,LanguageExt.EitherT<L,M>>.Catch(K`2<EitherT`2<L, M>, A> fa, Func`2<L, bool> Predicate, Func`2<L, K`2<EitherT`2<L, M>, A>> Fail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.EitherT`3 : object {
    [CompilerGeneratedAttribute]
private K`2<M, Either`2<L, R>> <runEither>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public K`2<M, Either`2<L, R>> runEither { get; public set; }
    public K`2<M, bool> IsRight { get; }
    public K`2<M, bool> IsLeft { get; }
    public EitherT`3(K`2<M, Either`2<L, R>> runEither);
    [CompilerGeneratedAttribute]
protected EitherT`3(EitherT`3<L, M, R> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public K`2<M, Either`2<L, R>> get_runEither();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_runEither(K`2<M, Either`2<L, R>> value);
    public static EitherT`3<L, M, R> Right(R value);
    public static EitherT`3<L, M, R> Left(L value);
    public K`2<M, bool> get_IsRight();
    public K`2<M, bool> get_IsLeft();
    public static EitherT`3<L, M, R> Lift(Pure`1<R> pure);
    public static EitherT`3<L, M, R> Lift(Either`2<L, R> either);
    public static EitherT`3<L, M, R> Lift(Fail`1<L> fail);
    public static EitherT`3<L, M, R> Lift(K`2<M, R> monad);
    public static EitherT`3<L, M, R> Lift(K`2<M, Either`2<L, R>> monad);
    public static EitherT`3<L, M, R> LiftIO(IO`1<R> monad);
    public static EitherT`3<L, M, R> LiftIO(IO`1<Either`2<L, R>> monad);
    [PureAttribute]
public K`2<M, B> Match(Func`2<L, B> Left, Func`2<R, B> Right);
    [PureAttribute]
public K`2<M, Unit> Match(Action`1<L> Left, Action`1<R> Right);
    [PureAttribute]
public K`2<M, R> IfLeft(Func`1<R> Left);
    [PureAttribute]
public K`2<M, R> IfLeft(Func`2<L, R> leftMap);
    [PureAttribute]
public K`2<M, R> IfLeft(R rightValue);
    public K`2<M, Unit> IfLeft(Action`1<L> Left);
    public K`2<M, Unit> IfRight(Action`1<R> Right);
    [PureAttribute]
public K`2<M, L> IfRight(L leftValue);
    [PureAttribute]
public K`2<M, L> IfRight(Func`1<L> Right);
    [PureAttribute]
public K`2<M, L> IfRight(Func`2<R, L> rightMap);
    public EitherT`3<L, M1, B> MapT(Func`2<K`2<M, Either`2<L, R>>, K`2<M1, Either`2<L, B>>> f);
    public EitherT`3<L, M, B> MapM(Func`2<K`2<M, R>, K`2<M, B>> f);
    public EitherT`3<L, M, B> Map(Func`2<R, B> f);
    public EitherT`3<L, M, B> Select(Func`2<R, B> f);
    public EitherT`3<L, M, B> Bind(Func`2<R, K`2<EitherT`2<L, M>, B>> f);
    public EitherT`3<L, M, B> Bind(Func`2<R, Either`2<L, B>> f);
    public EitherT`3<L, M, B> Bind(Func`2<R, EitherT`3<L, M, B>> f);
    public EitherT`3<L, M, B> Bind(Func`2<R, IO`1<B>> f);
    public EitherT`3<L, M, B> Bind(Func`2<R, Pure`1<B>> f);
    public EitherT`3<L, M, B> Bind(Func`2<R, Fail`1<L>> f);
    public EitherT`3<L, M, B> BiBind(Func`2<L, EitherT`3<L, M, B>> Left, Func`2<R, EitherT`3<L, M, B>> Right);
    public EitherT`3<L, M, R> BindLeft(Func`2<L, EitherT`3<L, M, R>> Left);
    public EitherT`3<L, M, C> SelectMany(Func`2<R, K`2<EitherT`2<L, M>, B>> bind, Func`3<R, B, C> project);
    public EitherT`3<L, M, C> SelectMany(Func`2<R, EitherT`3<L, M, B>> bind, Func`3<R, B, C> project);
    public EitherT`3<L, M, C> SelectMany(Func`2<R, K`2<M, B>> bind, Func`3<R, B, C> project);
    public EitherT`3<L, M, C> SelectMany(Func`2<R, Either`2<L, B>> bind, Func`3<R, B, C> project);
    public EitherT`3<L, M, C> SelectMany(Func`2<R, Pure`1<B>> bind, Func`3<R, B, C> project);
    public EitherT`3<L, M, C> SelectMany(Func`2<R, IO`1<B>> bind, Func`3<R, B, C> project);
    public static EitherT`3<L, M, R> op_RightShift(EitherT`3<L, M, R> lhs, EitherT`3<L, M, R> rhs);
    public static EitherT`3<L, M, R> op_RightShift(EitherT`3<L, M, R> lhs, K`2<EitherT`2<L, M>, R> rhs);
    public static EitherT`3<L, M, R> op_RightShift(EitherT`3<L, M, R> lhs, EitherT`3<L, M, Unit> rhs);
    public static EitherT`3<L, M, R> op_RightShift(EitherT`3<L, M, R> lhs, K`2<EitherT`2<L, M>, Unit> rhs);
    public static EitherT`3<L, M, R> op_Implicit(Either`2<L, R> ma);
    public static override EitherT`3<L, M, R> op_Implicit(Pure`1<R> ma);
    public static override EitherT`3<L, M, R> op_Implicit(Fail`1<L> ma);
    public static EitherT`3<L, M, R> op_Implicit(L fail);
    public static EitherT`3<L, M, R> op_Implicit(IO`1<R> ma);
    public static EitherT`3<L, M, R> op_Implicit(Lift`1<R> ma);
    public static EitherT`3<L, M, R> op_Implicit(Lift`2<EnvIO, R> ma);
    public static EitherT`3<L, M, R> op_Implicit(IO`1<Either`2<L, R>> ma);
    [PureAttribute]
public static override EitherT`3<L, M, R> op_BitwiseOr(EitherT`3<L, M, R> lhs, EitherT`3<L, M, R> rhs);
    [PureAttribute]
public static override EitherT`3<L, M, R> op_BitwiseOr(K`2<EitherT`2<L, M>, R> lhs, EitherT`3<L, M, R> rhs);
    [PureAttribute]
public static override EitherT`3<L, M, R> op_BitwiseOr(EitherT`3<L, M, R> lhs, K`2<EitherT`2<L, M>, R> rhs);
    public static EitherT`3<L, M, R> op_BitwiseOr(EitherT`3<L, M, R> ma, R b);
    [PureAttribute]
public static override EitherT`3<L, M, R> op_BitwiseOr(EitherT`3<L, M, R> ma, Pure`1<R> mb);
    [PureAttribute]
public static override EitherT`3<L, M, R> op_BitwiseOr(EitherT`3<L, M, R> ma, Fail`1<L> mb);
    [PureAttribute]
public static EitherT`3<L, M, R> op_BitwiseOr(EitherT`3<L, M, R> ma, L mb);
    [PureAttribute]
public static override EitherT`3<L, M, R> op_BitwiseOr(EitherT`3<L, M, R> ma, CatchM`3<L, EitherT`2<L, M>, R> mb);
    public OptionT`2<M, R> ToOption();
    public StreamT`2<M, R> ToStream();
    public StreamT`2<M, L> LeftToStream();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(EitherT`3<L, M, R> left, EitherT`3<L, M, R> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(EitherT`3<L, M, R> left, EitherT`3<L, M, R> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(EitherT`3<L, M, R> other);
    [CompilerGeneratedAttribute]
public virtual EitherT`3<L, M, R> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(K`2& runEither);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.EitherTExt : object {
    [ExtensionAttribute]
public static EitherT`3<L, M, A> As(K`2<EitherT`2<L, M>, A> ma);
    [ExtensionAttribute]
public static FinT`2<M, A> ToFin(K`2<EitherT`2<Error, M>, A> ma);
    [ExtensionAttribute]
public static K`2<M, Either`2<L, A>> Run(K`2<EitherT`2<L, M>, A> ma);
    [ExtensionAttribute]
public static EitherT`3<L, IO, A> Flatten(Task`1<EitherT`3<L, IO, A>> tma);
    [ExtensionAttribute]
public static EitherT`3<L, IO, A> ToIO(Task`1<Either`2<L, A>> ma);
    [ExtensionAttribute]
[PureAttribute]
public static EitherT`3<L, M, A> Flatten(EitherT`3<L, M, EitherT`3<L, M, A>> mma);
    [ExtensionAttribute]
[PureAttribute]
public static EitherT`3<L, M, C> SelectMany(K`2<M, A> ma, Func`2<A, K`2<EitherT`2<L, M>, B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
[PureAttribute]
public static EitherT`3<L, M, C> SelectMany(K`2<M, A> ma, Func`2<A, EitherT`3<L, M, B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
[PureAttribute]
public static EitherT`3<L, M, B> Apply(EitherT`3<L, M, Func`2<A, B>> mf, EitherT`3<L, M, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static EitherT`3<L, M, B> Action(EitherT`3<L, M, A> ma, EitherT`3<L, M, B> mb);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<M, Seq`1<L>> Lefts(IEnumerable`1<EitherT`3<L, M, R>> self);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<M, Seq`1<L>> Lefts(Seq`1<EitherT`3<L, M, R>> self);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<M, Seq`1<R>> Rights(IEnumerable`1<EitherT`3<L, M, R>> self);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<M, Seq`1<R>> Rights(Seq`1<EitherT`3<L, M, R>> self);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<M, ValueTuple`2<Seq`1<L>, Seq`1<R>>> Partition(Seq`1<EitherT`3<L, M, R>> self);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<M, ValueTuple`2<Seq`1<L>, Seq`1<R>>> Partition(IEnumerable`1<EitherT`3<L, M, R>> self);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class LanguageExt.EitherUnitContext`2 : ValueType {
    private Either`2<L, R> either;
    private Action`1<R> rightHandler;
    internal EitherUnitContext`2(Either`2<L, R> either, Action`1<R> rightHandler);
    public Unit Left(Action`1<L> leftHandler);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.EntryAdded`1 : Change`1<A> {
    public A Value;
    internal EntryAdded`1(A value);
    public virtual bool Equals(Change`1<A> obj);
    public sealed virtual bool Equals(EntryAdded`1<A> rhs);
    public virtual int GetHashCode();
    public void Deconstruct(A& value);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.EntryMapped`2 : Change`1<B> {
    [CompilerGeneratedAttribute]
private A <From>k__BackingField;
    [CompilerGeneratedAttribute]
private B <To>k__BackingField;
    public A From { get; }
    public B To { get; }
    internal EntryMapped`2(A from, B to);
    [CompilerGeneratedAttribute]
public sealed virtual A get_From();
    [CompilerGeneratedAttribute]
public sealed virtual B get_To();
    public virtual bool Equals(Change`1<B> obj);
    public sealed virtual bool Equals(EntryMapped`2<A, B> rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual void Deconstruct(B& to);
    public sealed virtual void Deconstruct(A& from);
    public void Deconstruct(A& from, B& to);
}
[NullableContextAttribute("1")]
public interface LanguageExt.EntryMappedFrom`1 {
    public A From { get; }
    public abstract virtual A get_From();
    public abstract virtual void Deconstruct(A& from);
}
[NullableContextAttribute("1")]
public interface LanguageExt.EntryMappedTo`1 {
    public B To { get; }
    public abstract virtual B get_To();
    public abstract virtual void Deconstruct(B& to);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.EntryRemoved`1 : Change`1<A> {
    public A OldValue;
    internal EntryRemoved`1(A oldValue);
    public virtual bool Equals(Change`1<A> obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(EntryRemoved`1<A> rhs);
    public void Deconstruct(A& oldValue);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.Enum`1 : object {
    private static int DefaultCapacity;
    private A[] data;
    private int count;
    private int ncount;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerator`1<A> iter;
    public int Count { get; }
    public A[] Data { get; }
    public Enum`1(IEnumerable`1<A> ma);
    public int get_Count();
    public A[] get_Data();
    public ValueTuple`2<bool, A> Get(int index);
    public virtual int GetHashCode();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.EnumerableOptimal : object {
    [ExtensionAttribute]
public static IEnumerable`1<A> ConcatFast(IEnumerable`1<A> ma, IEnumerable`1<A> mb);
    [ExtensionAttribute]
public static Iterable`1<A> ConcatFast(Iterable`1<A> ma, IEnumerable`1<A> mb);
    [ExtensionAttribute]
internal static IEnumerable`1<B> BindFast(IEnumerable`1<A> ma, Func`2<A, IEnumerable`1<B>> f);
    [ExtensionAttribute]
internal static IEnumerable`1<B> BindFast(IEnumerable`1<A> ma, Func`2<A, Lst`1<B>> f);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.EnvIO : object {
    public Resources Resources;
    public CancellationToken Token;
    public CancellationTokenSource Source;
    [NullableAttribute("2")]
public SynchronizationContext SyncContext;
    private int Own;
    public EnvIO LocalResources { get; }
    public EnvIO LocalCancel { get; }
    public EnvIO LocalSyncContext { get; }
    private EnvIO(Resources resources, CancellationToken token, CancellationTokenSource source, SynchronizationContext syncContext, int own);
    [NullableContextAttribute("2")]
public static EnvIO New(Resources resources, CancellationToken token, CancellationTokenSource source, SynchronizationContext syncContext);
    public EnvIO get_LocalResources();
    public EnvIO get_LocalCancel();
    public EnvIO get_LocalSyncContext();
    public sealed virtual void Dispose();
    public virtual string ToString();
}
public static class LanguageExt.Eq : object {
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool equals(A x, A y);
}
public class LanguageExt.EqAttribute : Attribute {
    [NullableContextAttribute("1")]
public EqAttribute(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.EqCompare`1 : object {
    private Func`3<T, T, bool> compare;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Option`1<Func`2<T, int>> hashCode;
    public EqCompare`1(Func`3<T, T, bool> compare);
    public EqCompare`1(Func`3<T, T, bool> compare, Func`2<T, int> hashCode);
    [NullableContextAttribute("2")]
[PureAttribute]
public sealed virtual bool Equals(T x, T y);
    [PureAttribute]
public sealed virtual int GetHashCode(T obj);
}
[ExtensionAttribute]
public static class LanguageExt.EqExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static bool Equals(A[] x, A[] y);
    [ExtensionAttribute]
[PureAttribute]
public static bool Equals(Nullable`1<A> mx, Nullable`1<A> my);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static bool Equals(IEnumerable`1<A> x, IEnumerable`1<A> y);
}
[NullableContextAttribute("1")]
public interface LanguageExt.EqString`1 {
    private static override bool LanguageExt.Traits.Eq<STRING>.Equals(STRING lhs, STRING rhs);
}
internal static class LanguageExt.Ev : object {
    [NullableContextAttribute("1")]
public static Ev`1<A> Item(A value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class LanguageExt.Ev`1 : object {
    public static Ev`1<A> Stop;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected Ev`1(Ev`1<A> original);
    private static Ev`1();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Ev`1<A> left, Ev`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Ev`1<A> left, Ev`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Ev`1<A> other);
    [CompilerGeneratedAttribute]
public abstract virtual Ev`1<A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.Extensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Proxy`6<UOut, UIn, DIn, DOut, M, A> As(K`2<Proxy`5<UOut, UIn, DIn, DOut, M>, A> ma);
    [ExtensionAttribute]
public static Effect`2<M, A> As(K`2<Proxy`5<Void, Unit, Unit, Void, M>, A> ma);
    [ExtensionAttribute]
public static Producer`3<OUT, M, A> As(K`2<Proxy`5<Void, Unit, Unit, OUT, M>, A> ma);
    [ExtensionAttribute]
public static Consumer`3<IN, M, A> As(K`2<Proxy`5<Unit, IN, Unit, Void, M>, A> ma);
    [ExtensionAttribute]
public static Pipe`4<IN, OUT, M, A> As(K`2<Proxy`5<Unit, IN, Unit, OUT, M>, A> ma);
    [ExtensionAttribute]
public static Client`4<REQ, RES, M, A> As(K`2<Proxy`5<REQ, RES, Unit, Void, M>, A> ma);
    [ExtensionAttribute]
public static Server`4<REQ, RES, M, A> As(K`2<Proxy`5<Void, Unit, REQ, RES, M>, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Effect`2<M, R> ToEffect(Proxy`6<Void, Unit, Unit, Void, M, R> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Producer`3<A, M, R> ToProducer(Proxy`6<Void, Unit, Unit, A, M, R> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Consumer`3<A, M, R> ToConsumer(Proxy`6<Unit, A, Unit, Void, M, R> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Pipe`4<A, B, M, R> ToPipe(Proxy`6<Unit, A, Unit, B, M, R> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Client`4<A, B, M, R> ToClient(Proxy`6<A, B, Unit, Void, M, R> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Server`4<A, B, M, R> ToServer(Proxy`6<Void, Unit, A, B, M, R> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class LanguageExt.Fail`1 : ValueType {
    [CompilerGeneratedAttribute]
private E <Value>k__BackingField;
    public E Value { get; public set; }
    public Fail`1(E Value);
    [CompilerGeneratedAttribute]
public E get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(E value);
    public Fail`1<F> MapFail(Func`2<E, F> f);
    public Either`2<E, A> ToEither();
    public virtual string ToString();
    public Either`2<E, C> SelectMany(Func`2<Unit, Pure`1<B>> bind, Func`3<Unit, B, C> project);
    public Either`2<E, C> SelectMany(Func`2<Unit, Option`1<B>> bind, Func`3<Unit, B, C> project);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(Fail`1<E> left, Fail`1<E> right);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public static bool op_Equality(Fail`1<E> left, Fail`1<E> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Fail`1<E> other);
    [CompilerGeneratedAttribute]
public void Deconstruct(E& Value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.FailExtensions : object {
    [ExtensionAttribute]
public static Fin`1<A> ToFin(Fail`1<Error> fail);
    [ExtensionAttribute]
public static Validation`2<F, A> ToValidation(Fail`1<F> fail);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Eff`2<RT, A> ToEff(Fail`1<Error> fail);
    [ExtensionAttribute]
public static Eff`1<A> ToEff(Fail`1<Error> fail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Fin : object {
    private static override K`2<Fin, B> LanguageExt.Traits.Monad<LanguageExt.Fin>.Bind(K`2<Fin, A> ma, Func`2<A, K`2<Fin, B>> f);
    private static override K`2<Fin, B> LanguageExt.Traits.Functor<LanguageExt.Fin>.Map(Func`2<A, B> f, K`2<Fin, A> ma);
    private static override K`2<Fin, A> LanguageExt.Traits.Applicative<LanguageExt.Fin>.Pure(A value);
    private static override K`2<Fin, B> LanguageExt.Traits.Applicative<LanguageExt.Fin>.Apply(K`2<Fin, Func`2<A, B>> mf, K`2<Fin, A> ma);
    private static override K`2<Fin, B> LanguageExt.Traits.Applicative<LanguageExt.Fin>.Action(K`2<Fin, A> ma, K`2<Fin, B> mb);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Fin>.FoldWhile(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<Fin, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Fin>.FoldBackWhile(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<Fin, A> ta);
    private static override K`2<F, K`2<Fin, B>> LanguageExt.Traits.Traversable<LanguageExt.Fin>.Traverse(Func`2<A, K`2<F, B>> f, K`2<Fin, A> ta);
    private static override K`2<Fin, A> LanguageExt.Traits.MonoidK<LanguageExt.Fin>.Empty();
    private static override K`2<Fin, A> LanguageExt.Traits.SemigroupK<LanguageExt.Fin>.Combine(K`2<Fin, A> ma, K`2<Fin, A> mb);
    private static K`2<Fin, A> ConsSucc(A value);
    private static K`2<Fin, A> ConsFail(Error value);
    private static override K`2<Fin, A> LanguageExt.Traits.Fallible<LanguageExt.Common.Error,LanguageExt.Fin>.Fail(Error error);
    private static override K`2<Fin, A> LanguageExt.Traits.Fallible<LanguageExt.Common.Error,LanguageExt.Fin>.Catch(K`2<Fin, A> fa, Func`2<Error, bool> Predicate, Func`2<Error, K`2<Fin, A>> Fail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.Fin`1 : object {
    [CompilerGeneratedAttribute]
private static Fin`1<A> <Empty>k__BackingField;
    [PureAttribute]
public bool IsSucc { get; }
    [PureAttribute]
public bool IsFail { get; }
    internal A SuccValue { get; }
    internal Error FailValue { get; }
    [PureAttribute]
public static Fin`1<A> Empty { get; }
    private static Fin`1();
    [PureAttribute]
public static Fin`1<A> Succ(A value);
    [PureAttribute]
public static Fin`1<A> Fail(Error error);
    [PureAttribute]
public static Fin`1<A> Fail(string error);
    public abstract virtual bool get_IsSucc();
    public abstract virtual bool get_IsFail();
    [PureAttribute]
public abstract virtual B Match(Func`2<A, B> Succ, Func`2<Error, B> Fail);
    [PureAttribute]
public abstract virtual ReadOnlySpan`1<Error> FailSpan();
    [PureAttribute]
public abstract virtual ReadOnlySpan`1<A> SuccSpan();
    [PureAttribute]
public abstract virtual int CompareTo(Fin`1<A> other);
    [PureAttribute]
public abstract virtual bool Equals(Fin`1<A> other);
    [PureAttribute]
public sealed virtual bool Equals(Fin`1<A> other);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object other);
    [NullableContextAttribute("0")]
[PureAttribute]
public abstract virtual int GetHashCode();
    [PureAttribute]
public virtual int GetHashCode();
    internal abstract virtual A get_SuccValue();
    internal abstract virtual Error get_FailValue();
    [PureAttribute]
public abstract virtual Fin`1<B> Map(Func`2<A, B> Succ);
    [PureAttribute]
public abstract virtual Fin`1<B> BiMap(Func`2<A, B> Succ, Func`2<Error, Error> Fail);
    [PureAttribute]
public abstract virtual Fin`1<B> Bind(Func`2<A, Fin`1<B>> f);
    [PureAttribute]
public abstract virtual Fin`1<B> BiBind(Func`2<A, Fin`1<B>> Succ, Func`2<Error, Fin`1<B>> Fail);
    [PureAttribute]
public Fin`1<A> BindFail(Func`2<Error, Fin`1<A>> Fail);
    [CompilerGeneratedAttribute]
public static Fin`1<A> get_Empty();
    [PureAttribute]
public static Fin`1<A> op_Implicit(A value);
    [PureAttribute]
public static Fin`1<A> op_Implicit(Error error);
    [PureAttribute]
public static Fin`1<A> op_Implicit(Either`2<Error, A> either);
    [PureAttribute]
public static override Fin`1<A> op_Implicit(Pure`1<A> value);
    [PureAttribute]
public static override Fin`1<A> op_Implicit(Fail`1<Error> value);
    [PureAttribute]
public static A op_Explicit(Fin`1<A> ma);
    [PureAttribute]
public static Error op_Explicit(Fin`1<A> ma);
    [PureAttribute]
public static override Fin`1<A> op_BitwiseOr(Fin`1<A> lhs, Fin`1<A> rhs);
    [PureAttribute]
public static override Fin`1<A> op_BitwiseOr(K`2<Fin, A> lhs, Fin`1<A> rhs);
    [PureAttribute]
public static override Fin`1<A> op_BitwiseOr(Fin`1<A> lhs, K`2<Fin, A> rhs);
    [PureAttribute]
public static override Fin`1<A> op_BitwiseOr(Fin`1<A> ma, Pure`1<A> mb);
    [PureAttribute]
public static override Fin`1<A> op_BitwiseOr(Fin`1<A> ma, Fail`1<Error> mb);
    [PureAttribute]
public static Fin`1<A> op_BitwiseOr(Fin`1<A> ma, Fail`1<Exception> mb);
    [PureAttribute]
public static override Fin`1<A> op_BitwiseOr(Fin`1<A> ma, CatchM`3<Error, Fin, A> mb);
    [PureAttribute]
public static bool op_True(Fin`1<A> ma);
    [PureAttribute]
public static bool op_False(Fin`1<A> ma);
    [PureAttribute]
public static bool op_Equality(Fin`1<A> ma, Fin`1<A> mb);
    [PureAttribute]
public static bool op_Inequality(Fin`1<A> ma, Fin`1<A> mb);
    [PureAttribute]
public static bool op_LessThan(Fin`1<A> lhs, A rhs);
    [PureAttribute]
public static bool op_LessThanOrEqual(Fin`1<A> lhs, A rhs);
    [PureAttribute]
public static bool op_GreaterThan(Fin`1<A> lhs, A rhs);
    [PureAttribute]
public static bool op_GreaterThanOrEqual(Fin`1<A> lhs, A rhs);
    [PureAttribute]
public static bool op_LessThan(A lhs, Fin`1<A> rhs);
    [PureAttribute]
public static bool op_LessThanOrEqual(A lhs, Fin`1<A> rhs);
    [PureAttribute]
public static bool op_GreaterThan(A lhs, Fin`1<A> rhs);
    [PureAttribute]
public static bool op_GreaterThanOrEqual(A lhs, Fin`1<A> rhs);
    [PureAttribute]
public static bool op_LessThan(Fin`1<A> lhs, Fin`1<A> rhs);
    [PureAttribute]
public static bool op_LessThanOrEqual(Fin`1<A> lhs, Fin`1<A> rhs);
    [PureAttribute]
public static bool op_GreaterThan(Fin`1<A> lhs, Fin`1<A> rhs);
    [PureAttribute]
public static bool op_GreaterThanOrEqual(Fin`1<A> lhs, Fin`1<A> rhs);
    [PureAttribute]
public static bool op_Equality(Fin`1<A> lhs, Error rhs);
    [PureAttribute]
public static bool op_Equality(Fin`1<A> lhs, A rhs);
    [PureAttribute]
public static bool op_Equality(A lhs, Fin`1<A> rhs);
    [PureAttribute]
public static bool op_Equality(Error lhs, Fin`1<A> rhs);
    [PureAttribute]
public static bool op_Inequality(Fin`1<A> lhs, Error rhs);
    [PureAttribute]
public static bool op_Inequality(Error lhs, Fin`1<A> rhs);
    [PureAttribute]
public static bool op_Inequality(Fin`1<A> lhs, A rhs);
    [PureAttribute]
public static bool op_Inequality(A lhs, Fin`1<A> rhs);
    [NullableContextAttribute("2")]
[PureAttribute]
private static Option`1<T> convert(Object& value);
    [PureAttribute]
internal Fin`1<B> Cast();
    [PureAttribute]
public sealed virtual int CompareTo(Fin`1<A> other);
    [IteratorStateMachineAttribute("LanguageExt.Fin`1/<GetEnumerator>d__69")]
[PureAttribute]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("2")]
[PureAttribute]
public sealed virtual int CompareTo(object obj);
    public Unit Match(Action`1<A> Succ, Action`1<Error> Fail);
    [PureAttribute]
public A IfFail(Func`2<Error, A> Fail);
    [PureAttribute]
public A IfFail(A alternative);
    public Unit IfFail(Action`1<Error> Fail);
    public Unit IfSucc(Action`1<A> Succ);
    public Unit Iter(Action`1<A> Succ);
    [PureAttribute]
public S Fold(S state, Func`3<S, A, S> f);
    [PureAttribute]
public S BiFold(S& state, Func`3<S, A, S> Succ, Func`3<S, Error, S> Fail);
    [PureAttribute]
public bool Exists(Func`2<A, bool> f);
    [PureAttribute]
public bool ForAll(Func`2<A, bool> f);
    [PureAttribute]
public K`2<F, Fin`1<B>> Traverse(Func`2<A, K`2<F, B>> f);
    [PureAttribute]
public K`2<M, Fin`1<B>> TraverseM(Func`2<A, K`2<M, B>> f);
    [PureAttribute]
public Fin`1<B> Select(Func`2<A, B> f);
    [PureAttribute]
public Fin`1<B> Bind(Func`2<A, K`2<Fin, B>> f);
    [PureAttribute]
public Fin`1<B> Bind(Func`2<A, Pure`1<B>> f);
    [PureAttribute]
public Fin`1<A> Bind(Func`2<A, Fail`1<Error>> f);
    [PureAttribute]
public Fin`1<C> SelectMany(Func`2<A, Fin`1<B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Fin`1<C> SelectMany(Func`2<A, K`2<Fin, B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Fin`1<C> SelectMany(Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Fin`1<Unit> SelectMany(Func`2<A, Fail`1<Error>> bind, Func`3<A, Error, Unit> project);
    [PureAttribute]
public Lst`1<A> ToList();
    [PureAttribute]
public Seq`1<A> ToSeq();
    [PureAttribute]
public Arr`1<A> ToArray();
    [PureAttribute]
public Option`1<A> ToOption();
    [PureAttribute]
public StreamT`2<M, A> ToStream();
    [PureAttribute]
public StreamT`2<M, Error> FailToStream();
    [PureAttribute]
public Either`2<Error, A> ToEither();
    [PureAttribute]
public Validation`2<Error, A> ToValidation();
    [PureAttribute]
public Eff`1<A> ToEff();
    public A ThrowIfFail();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.FinExtensions : object {
    [ExtensionAttribute]
public static Fin`1<A> As(K`2<Fin, A> ma);
    [ExtensionAttribute]
public static Fin`1<A> ToFin(Either`2<Error, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Fin`1<R> Flatten(Fin`1<Fin`1<R>> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Fin`1<R> Plus(Fin`1<R> x, Fin`1<R> y);
    [ExtensionAttribute]
[PureAttribute]
public static Fin`1<R> Subtract(Fin`1<R> x, Fin`1<R> y);
    [ExtensionAttribute]
[PureAttribute]
public static Fin`1<R> Product(Fin`1<R> x, Fin`1<R> y);
    [ExtensionAttribute]
[PureAttribute]
public static Fin`1<R> Divide(Fin`1<R> x, Fin`1<R> y);
    [ExtensionAttribute]
[PureAttribute]
public static Fin`1<B> Apply(Fin`1<Func`2<A, B>> fab, Fin`1<A> fa);
    [ExtensionAttribute]
[PureAttribute]
public static Fin`1<B> Map(Func`2<A, B> fab, Fin`1<A> fa);
    [ExtensionAttribute]
[PureAttribute]
public static Fin`1<C> Apply(Fin`1<Func`3<A, B, C>> fabc, Fin`1<A> fa, Fin`1<B> fb);
    [ExtensionAttribute]
[PureAttribute]
public static Fin`1<C> Map(Func`3<A, B, C> fabc, Fin`1<A> fa, Fin`1<B> fb);
    [ExtensionAttribute]
[PureAttribute]
public static Fin`1<Func`2<B, C>> Apply(Fin`1<Func`3<A, B, C>> fabc, Fin`1<A> fa);
    [ExtensionAttribute]
[PureAttribute]
public static Fin`1<Func`2<B, C>> Map(Func`3<A, B, C> fabc, Fin`1<A> fa);
    [ExtensionAttribute]
[PureAttribute]
public static Fin`1<Func`2<B, C>> Apply(Fin`1<Func`2<A, Func`2<B, C>>> fabc, Fin`1<A> fa);
    [ExtensionAttribute]
[PureAttribute]
public static Fin`1<Func`2<B, C>> Map(Func`2<A, Func`2<B, C>> fabc, Fin`1<A> fa);
    [ExtensionAttribute]
[PureAttribute]
public static Fin`1<B> Action(Fin`1<A> fa, Fin`1<B> fb);
    [ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<A> Succs(IEnumerable`1<Fin`1<A>> xs);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Seq`1<A> Succs(Seq`1<Fin`1<A>> xs);
    [ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<Error> Fails(IEnumerable`1<Fin`1<A>> xs);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Seq`1<Error> Fails(Seq`1<Fin`1<A>> xs);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`2<IEnumerable`1<Error>, IEnumerable`1<A>> Partition(IEnumerable`1<Fin`1<A>> xs);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTuple`2<Seq`1<Error>, Seq`1<A>> Partition(Seq`1<Fin`1<A>> xs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.FinGuardExtensions : object {
    [ExtensionAttribute]
public static Fin`1<Unit> ToFin(Guard`2<Error, Unit> ma);
    [ExtensionAttribute]
public static Fin`1<B> SelectMany(Guard`2<Error, Unit> ma, Func`2<Unit, Fin`1<B>> f);
    [ExtensionAttribute]
public static Fin`1<C> SelectMany(Guard`2<Error, Unit> ma, Func`2<Unit, Fin`1<B>> bind, Func`3<Unit, B, C> project);
    [ExtensionAttribute]
public static Fin`1<Unit> SelectMany(Fin`1<A> ma, Func`2<A, Guard`2<Error, Unit>> f);
    [ExtensionAttribute]
public static Fin`1<C> SelectMany(Fin`1<A> ma, Func`2<A, Guard`2<Error, Unit>> bind, Func`3<A, Unit, C> project);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.FinT : object {
    public static FinT`2<M, B> bind(FinT`2<M, A> ma, Func`2<A, FinT`2<M, B>> f);
    public static FinT`2<M, B> map(Func`2<A, B> f, FinT`2<M, A> ma);
    public static FinT`2<M, A> Succ(A value);
    public static FinT`2<M, A> Fail(Error value);
    public static FinT`2<M, B> apply(FinT`2<M, Func`2<A, B>> mf, FinT`2<M, A> ma);
    public static FinT`2<M, B> action(FinT`2<M, A> ma, FinT`2<M, B> mb);
    public static FinT`2<M, A> lift(Fin`1<A> ma);
    public static FinT`2<M, A> lift(Either`2<Error, A> ma);
    public static FinT`2<M, A> lift(K`2<M, A> ma);
    public static FinT`2<M, A> lift(Pure`1<A> ma);
    public static FinT`2<M, A> lift(Fail`1<Error> ma);
    public static FinT`2<M, A> liftIO(IO`1<A> ma);
    public static K`2<M, B> match(FinT`2<M, A> ma, Func`2<A, B> Succ, Func`2<Error, B> Fail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.FinT`1 : object {
    public static FinT`2<M, A> Succ(A value);
    public static FinT`2<M, A> Fail(Error value);
    public static FinT`2<M, A> lift(Fin`1<A> ma);
    public static FinT`2<M, A> lift(Pure`1<A> ma);
    public static FinT`2<M, A> lift(Fail`1<Error> ma);
    public static FinT`2<M, A> liftIO(IO`1<A> ma);
    private static override K`2<FinT`1<M>, B> LanguageExt.Traits.Monad<LanguageExt.FinT<M>>.Bind(K`2<FinT`1<M>, A> ma, Func`2<A, K`2<FinT`1<M>, B>> f);
    private static override K`2<FinT`1<M>, B> LanguageExt.Traits.Functor<LanguageExt.FinT<M>>.Map(Func`2<A, B> f, K`2<FinT`1<M>, A> ma);
    private static override K`2<FinT`1<M>, A> LanguageExt.Traits.Applicative<LanguageExt.FinT<M>>.Pure(A value);
    private static override K`2<FinT`1<M>, B> LanguageExt.Traits.Applicative<LanguageExt.FinT<M>>.Apply(K`2<FinT`1<M>, Func`2<A, B>> mf, K`2<FinT`1<M>, A> ma);
    private static override K`2<FinT`1<M>, B> LanguageExt.Traits.Applicative<LanguageExt.FinT<M>>.Action(K`2<FinT`1<M>, A> ma, K`2<FinT`1<M>, B> mb);
    private static override K`2<FinT`1<M>, A> LanguageExt.Traits.MonadT<LanguageExt.FinT<M>,M>.Lift(K`2<M, A> ma);
    private static override K`2<FinT`1<M>, A> LanguageExt.Traits.MonadIO<LanguageExt.FinT<M>>.LiftIO(IO`1<A> ma);
    private static override K`2<FinT`1<M>, A> LanguageExt.Traits.SemigroupK<LanguageExt.FinT<M>>.Combine(K`2<FinT`1<M>, A> ma, K`2<FinT`1<M>, A> mb);
    private static override K`2<FinT`1<M>, A> LanguageExt.Traits.Fallible<LanguageExt.Common.Error,LanguageExt.FinT<M>>.Fail(Error error);
    private static override K`2<FinT`1<M>, A> LanguageExt.Traits.Fallible<LanguageExt.Common.Error,LanguageExt.FinT<M>>.Catch(K`2<FinT`1<M>, A> fa, Func`2<Error, bool> Predicate, Func`2<Error, K`2<FinT`1<M>, A>> Fail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.FinT`2 : object {
    [CompilerGeneratedAttribute]
private K`2<M, Fin`1<A>> <runFin>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public K`2<M, Fin`1<A>> runFin { get; public set; }
    public K`2<M, bool> IsSucc { get; }
    public K`2<M, bool> IsFail { get; }
    public FinT`2(K`2<M, Fin`1<A>> runFin);
    [CompilerGeneratedAttribute]
protected FinT`2(FinT`2<M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public K`2<M, Fin`1<A>> get_runFin();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_runFin(K`2<M, Fin`1<A>> value);
    public static FinT`2<M, A> Succ(A value);
    public static FinT`2<M, A> Fail(Error value);
    public K`2<M, bool> get_IsSucc();
    public K`2<M, bool> get_IsFail();
    public static FinT`2<M, A> Lift(Pure`1<A> pure);
    public static FinT`2<M, A> Lift(Fin`1<A> ma);
    public static FinT`2<M, A> Lift(Fail`1<Error> fail);
    public static FinT`2<M, A> Lift(Error fail);
    public static FinT`2<M, A> Lift(K`2<M, A> monad);
    public static FinT`2<M, A> Lift(K`2<M, Fin`1<A>> monad);
    public static FinT`2<M, A> LiftIO(IO`1<A> monad);
    public static FinT`2<M, A> LiftIO(IO`1<Fin`1<A>> monad);
    [PureAttribute]
public K`2<M, B> Match(Func`2<A, B> Succ, Func`2<Error, B> Fail);
    [PureAttribute]
public K`2<M, Unit> Match(Action`1<A> Succ, Action`1<Error> Fail);
    [PureAttribute]
public K`2<M, A> IfFail(Func`1<A> Fail);
    [PureAttribute]
public K`2<M, A> IfFail(Func`2<Error, A> f);
    [PureAttribute]
public K`2<M, A> IfFail(A value);
    public K`2<M, Unit> IfFail(Action`1<Error> Fail);
    public K`2<M, Unit> IfSucc(Action`1<A> Succ);
    [PureAttribute]
public K`2<M, Error> IfSucc(Error fail);
    [PureAttribute]
public K`2<M, Error> IfSucc(Func`1<Error> Succ);
    [PureAttribute]
public K`2<M, Error> IfSucc(Func`2<A, Error> f);
    public FinT`2<M1, B> MapT(Func`2<K`2<M, Fin`1<A>>, K`2<M1, Fin`1<B>>> f);
    public FinT`2<M, B> MapM(Func`2<K`2<M, A>, K`2<M, B>> f);
    public FinT`2<M, B> Map(Func`2<A, B> f);
    public FinT`2<M, B> Select(Func`2<A, B> f);
    public FinT`2<M, B> Bind(Func`2<A, K`2<FinT`1<M>, B>> f);
    public FinT`2<M, B> Bind(Func`2<A, Fin`1<B>> f);
    public FinT`2<M, B> Bind(Func`2<A, FinT`2<M, B>> f);
    public FinT`2<M, B> Bind(Func`2<A, IO`1<B>> f);
    public FinT`2<M, B> Bind(Func`2<A, Pure`1<B>> f);
    public FinT`2<M, B> Bind(Func`2<A, Fail`1<Error>> f);
    public FinT`2<M, B> BiBind(Func`2<Error, FinT`2<M, B>> Fail, Func`2<A, FinT`2<M, B>> Succ);
    public FinT`2<M, A> BindFail(Func`2<Error, FinT`2<M, A>> Fail);
    public FinT`2<M, C> SelectMany(Func`2<A, K`2<FinT`1<M>, B>> bind, Func`3<A, B, C> project);
    public FinT`2<M, C> SelectMany(Func`2<A, FinT`2<M, B>> bind, Func`3<A, B, C> project);
    public FinT`2<M, C> SelectMany(Func`2<A, K`2<M, B>> bind, Func`3<A, B, C> project);
    public FinT`2<M, C> SelectMany(Func`2<A, Fin`1<B>> bind, Func`3<A, B, C> project);
    public FinT`2<M, C> SelectMany(Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    public FinT`2<M, C> SelectMany(Func`2<A, IO`1<B>> bind, Func`3<A, B, C> project);
    public static FinT`2<M, A> op_RightShift(FinT`2<M, A> lhs, FinT`2<M, A> rhs);
    public static FinT`2<M, A> op_RightShift(FinT`2<M, A> lhs, K`2<FinT`1<M>, A> rhs);
    public static FinT`2<M, A> op_RightShift(FinT`2<M, A> lhs, FinT`2<M, Unit> rhs);
    public static FinT`2<M, A> op_RightShift(FinT`2<M, A> lhs, K`2<FinT`1<M>, Unit> rhs);
    public static FinT`2<M, A> op_Implicit(Fin`1<A> ma);
    public static override FinT`2<M, A> op_Implicit(Pure`1<A> ma);
    public static override FinT`2<M, A> op_Implicit(Fail`1<Error> ma);
    public static FinT`2<M, A> op_Implicit(Error ma);
    public static FinT`2<M, A> op_Implicit(IO`1<A> ma);
    public static FinT`2<M, A> op_Implicit(Lift`1<A> ma);
    public static FinT`2<M, A> op_Implicit(Lift`2<EnvIO, A> ma);
    public static FinT`2<M, A> op_Implicit(IO`1<Fin`1<A>> ma);
    public static override FinT`2<M, A> op_BitwiseOr(FinT`2<M, A> lhs, FinT`2<M, A> rhs);
    public static override FinT`2<M, A> op_BitwiseOr(K`2<FinT`1<M>, A> lhs, FinT`2<M, A> rhs);
    public static override FinT`2<M, A> op_BitwiseOr(FinT`2<M, A> lhs, K`2<FinT`1<M>, A> rhs);
    public static FinT`2<M, A> op_BitwiseOr(FinT`2<M, A> lhs, A rhs);
    public static override FinT`2<M, A> op_BitwiseOr(FinT`2<M, A> ma, Pure`1<A> mb);
    public static override FinT`2<M, A> op_BitwiseOr(FinT`2<M, A> ma, Fail`1<Error> mb);
    public static FinT`2<M, A> op_BitwiseOr(FinT`2<M, A> ma, Fail`1<Exception> mb);
    public static FinT`2<M, A> op_BitwiseOr(FinT`2<M, A> ma, Error mb);
    public static override FinT`2<M, A> op_BitwiseOr(FinT`2<M, A> ma, CatchM`3<Error, FinT`1<M>, A> mb);
    public OptionT`2<M, A> ToOption();
    public EitherT`3<Error, M, A> ToEither();
    public ValidationT`3<Error, M, A> ToValidation();
    public StreamT`2<M, A> ToStream();
    public StreamT`2<M, Error> FailToStream();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(FinT`2<M, A> left, FinT`2<M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(FinT`2<M, A> left, FinT`2<M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(FinT`2<M, A> other);
    [CompilerGeneratedAttribute]
public virtual FinT`2<M, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(K`2& runFin);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.FinTExt : object {
    [ExtensionAttribute]
public static FinT`2<M, A> As(K`2<FinT`1<M>, A> ma);
    [ExtensionAttribute]
public static K`2<M, Fin`1<A>> Run(K`2<FinT`1<M>, A> ma);
    [ExtensionAttribute]
public static FinT`2<IO, A> Flatten(Task`1<FinT`2<IO, A>> tma);
    [ExtensionAttribute]
public static FinT`2<IO, A> ToIO(Task`1<Fin`1<A>> ma);
    [ExtensionAttribute]
[PureAttribute]
public static FinT`2<M, A> Flatten(FinT`2<M, FinT`2<M, A>> mma);
    [ExtensionAttribute]
[PureAttribute]
public static FinT`2<M, C> SelectMany(K`2<M, A> ma, Func`2<A, K`2<FinT`1<M>, B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
[PureAttribute]
public static FinT`2<M, C> SelectMany(K`2<M, A> ma, Func`2<A, FinT`2<M, B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
[PureAttribute]
public static FinT`2<M, B> Apply(FinT`2<M, Func`2<A, B>> mf, FinT`2<M, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static FinT`2<M, B> Action(FinT`2<M, A> ma, FinT`2<M, B> mb);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<M, Seq`1<Error>> Fails(IEnumerable`1<FinT`2<M, A>> self);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<M, Seq`1<Error>> Fails(Seq`1<FinT`2<M, R>> self);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<M, Seq`1<A>> Succs(IEnumerable`1<FinT`2<M, A>> self);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<M, Seq`1<A>> Succs(Seq`1<FinT`2<M, A>> self);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<M, ValueTuple`2<Seq`1<Error>, Seq`1<A>>> Partition(Seq`1<FinT`2<M, A>> self);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<M, ValueTuple`2<Seq`1<Error>, Seq`1<A>>> Partition(IEnumerable`1<FinT`2<M, A>> self);
}
public class LanguageExt.FirstWriteWins`1 : ValueType {
    public static override ValueTuple`2<long, Option`1<V>> Resolve(ValueTuple`2<long, Option`1<V>> Current, ValueTuple`2<long, Option`1<V>> Proposed);
}
internal static class LanguageExt.FNV32 : object {
    public static int OffsetBasis;
    public static int Prime;
    public static int Next(int hashA, int hashB);
    public static int Hash(A[] items, int offsetBasis);
    public static int Hash(A[] items, int start, int length, int offsetBasis);
    public static int Hash(IEnumerable`1<A> items, int offsetBasis);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.FoldableExtensions : object {
    public static S FoldOption(Func`2<S, Func`2<A, Option`1<S>>> f, S initialState, K`2<T, A> ta);
    public static S FoldOption(Func`3<S, A, Option`1<S>> f, S initialState, K`2<T, A> ta);
    public static S FoldBackOption(Func`2<A, Func`2<S, Option`1<S>>> f, S initialState, K`2<T, A> ta);
    public static S FoldBackOption(Func`3<A, S, Option`1<S>> f, S initialState, K`2<T, A> ta);
    [ExtensionAttribute]
public static S FoldWhile(K`2<T, A> ta, S initialState, Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate);
    [ExtensionAttribute]
public static S FoldWhile(K`2<T, A> ta, S initialState, Func`3<S, A, S> f, Func`2<ValueTuple`2<S, A>, bool> predicate);
    [ExtensionAttribute]
public static S FoldBackWhile(K`2<T, A> ta, S initialState, Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate);
    [ExtensionAttribute]
public static S FoldBackWhile(K`2<T, A> ta, S initialState, Func`3<S, A, S> f, Func`2<ValueTuple`2<S, A>, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, S> FoldWhileM(K`2<T, A> ta, S initialState, Func`2<A, Func`2<S, K`2<M, S>>> f, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, S> FoldWhileM(K`2<T, A> ta, S initialState, Func`3<S, A, K`2<M, S>> f, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, S> FoldBackWhileM(K`2<T, A> ta, S initialState, Func`2<S, Func`2<A, K`2<M, S>>> f, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, S> FoldBackWhileM(K`2<T, A> ta, S initialState, Func`3<S, A, K`2<M, S>> f, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static S FoldUntil(K`2<T, A> ta, S initialState, Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate);
    [ExtensionAttribute]
public static S FoldUntil(K`2<T, A> ta, S initialState, Func`3<S, A, S> f, Func`2<ValueTuple`2<S, A>, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, S> FoldUntilM(K`2<T, A> ta, S initialState, Func`2<A, Func`2<S, K`2<M, S>>> f, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, S> FoldUntilM(K`2<T, A> ta, S initialState, Func`3<S, A, K`2<M, S>> f, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static S FoldBackUntil(K`2<T, A> ta, S initialState, Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate);
    [ExtensionAttribute]
public static S FoldBackUntil(K`2<T, A> ta, S initialState, Func`3<S, A, S> f, Func`2<ValueTuple`2<S, A>, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, S> FoldBackUntilM(K`2<T, A> ta, S initialState, Func`2<S, Func`2<A, K`2<M, S>>> f, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, S> FoldBackUntilM(K`2<T, A> ta, S initialState, Func`3<S, A, K`2<M, S>> f, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static S Fold(K`2<T, A> ta, S initialState, Func`2<A, Func`2<S, S>> f);
    [ExtensionAttribute]
public static S Fold(K`2<T, A> ta, S initialState, Func`3<S, A, S> f);
    [ExtensionAttribute]
public static K`2<M, S> FoldM(K`2<T, A> ta, S initialState, Func`2<A, Func`2<S, K`2<M, S>>> f);
    [ExtensionAttribute]
public static K`2<M, S> FoldM(K`2<T, A> ta, S initialState, Func`3<S, A, K`2<M, S>> f);
    [ExtensionAttribute]
public static S FoldBack(K`2<T, A> ta, S initialState, Func`2<S, Func`2<A, S>> f);
    [ExtensionAttribute]
public static S FoldBack(K`2<T, A> ta, S initialState, Func`3<S, A, S> f);
    [ExtensionAttribute]
public static K`2<M, S> FoldBackM(K`2<T, A> ta, S initialState, Func`2<S, Func`2<A, K`2<M, S>>> f);
    [ExtensionAttribute]
public static K`2<M, S> FoldBackM(K`2<T, A> ta, S initialState, Func`3<S, A, K`2<M, S>> f);
    [ExtensionAttribute]
public static A Fold(K`2<T, A> tm);
    [ExtensionAttribute]
public static A FoldWhile(K`2<T, A> tm, Func`2<ValueTuple`2<A, A>, bool> predicate);
    [ExtensionAttribute]
public static A FoldUntil(K`2<T, A> tm, Func`2<ValueTuple`2<A, A>, bool> predicate);
    [ExtensionAttribute]
public static B FoldMap(K`2<T, A> ta, Func`2<A, B> f);
    [ExtensionAttribute]
public static B FoldMapWhile(K`2<T, A> ta, Func`2<A, B> f, Func`2<ValueTuple`2<B, A>, bool> predicate);
    [ExtensionAttribute]
public static B FoldMapUntil(K`2<T, A> ta, Func`2<A, B> f, Func`2<ValueTuple`2<B, A>, bool> predicate);
    [ExtensionAttribute]
public static B FoldMapBack(K`2<T, A> ta, Func`2<A, B> f);
    [ExtensionAttribute]
public static B FoldMapBackWhile(K`2<T, A> ta, Func`2<A, B> f, Func`2<ValueTuple`2<B, A>, bool> predicate);
    [ExtensionAttribute]
public static B FoldMapBackUntil(K`2<T, A> ta, Func`2<A, B> f, Func`2<ValueTuple`2<B, A>, bool> predicate);
    [ExtensionAttribute]
public static Seq`1<A> ToSeq(K`2<T, A> ta);
    [ExtensionAttribute]
public static Lst`1<A> ToLst(K`2<T, A> ta);
    [ExtensionAttribute]
public static Arr`1<A> ToArr(K`2<T, A> ta);
    [ExtensionAttribute]
public static Iterable`1<A> ToEnumerable(K`2<T, A> ta);
    [ExtensionAttribute]
public static bool IsEmpty(K`2<T, A> ta);
    [ExtensionAttribute]
public static int Count(K`2<T, A> ta);
    [ExtensionAttribute]
public static bool Exists(K`2<T, A> ta, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static bool ForAll(K`2<T, A> ta, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static bool Contains(K`2<T, A> ta, A value);
    [ExtensionAttribute]
public static bool Contains(K`2<T, A> ta, A value);
    [ExtensionAttribute]
public static Option`1<A> Find(K`2<T, A> ta, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static Option`1<A> FindBack(K`2<T, A> ta, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static Seq`1<A> FindAll(K`2<T, A> ta, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static Seq`1<A> FindAllBack(K`2<T, A> ta, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static A Sum(K`2<T, A> ta);
    [ExtensionAttribute]
public static A Product(K`2<T, A> ta);
    [ExtensionAttribute]
public static Option`1<A> Head(K`2<T, A> ta);
    [ExtensionAttribute]
public static Option`1<A> Last(K`2<T, A> ta);
    [ExtensionAttribute]
public static K`2<F, Unit> Iter(K`2<T, A> ta, Func`2<A, K`2<F, B>> f);
    [ExtensionAttribute]
public static Unit Iter(K`2<T, A> ta, Action`1<A> f);
    [ExtensionAttribute]
public static Unit Iter(K`2<T, A> ta, Action`2<int, A> f);
    [ExtensionAttribute]
public static Option`1<A> Min(K`2<T, A> ta);
    [ExtensionAttribute]
public static Option`1<A> Min(K`2<T, A> ta);
    [ExtensionAttribute]
public static Option`1<A> Max(K`2<T, A> ta);
    [ExtensionAttribute]
public static Option`1<A> Max(K`2<T, A> ta);
    [ExtensionAttribute]
public static A Min(K`2<T, A> ta, A initialMin);
    [ExtensionAttribute]
public static A Min(K`2<T, A> ta, A initialMin);
    [ExtensionAttribute]
public static A Max(K`2<T, A> ta, A initialMax);
    [ExtensionAttribute]
public static A Max(K`2<T, A> ta, A initialMax);
    [ExtensionAttribute]
public static A Average(K`2<T, A> ta);
    [ExtensionAttribute]
public static B Average(K`2<T, A> ta, Func`2<A, B> f);
    [ExtensionAttribute]
public static Option`1<A> At(K`2<T, A> ta, Index index);
    [ExtensionAttribute]
public static S FoldWhileT(K`2<T, K`2<U, A>> tua, S initialState, Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate);
    [ExtensionAttribute]
public static S FoldWhileT(K`2<T, K`2<U, A>> tua, S initialState, Func`3<S, A, S> f, Func`2<ValueTuple`2<S, A>, bool> predicate);
    [ExtensionAttribute]
public static S FoldBackWhileT(K`2<T, K`2<U, A>> tua, S initialState, Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate);
    [ExtensionAttribute]
public static S FoldBackWhileT(K`2<T, K`2<U, A>> tua, S initialState, Func`3<S, A, S> f, Func`2<ValueTuple`2<S, A>, bool> predicate);
    [ExtensionAttribute]
public static S FoldUntilT(K`2<T, K`2<U, A>> tua, S initialState, Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate);
    [ExtensionAttribute]
public static S FoldUntilT(K`2<T, K`2<U, A>> tua, S initialState, Func`3<S, A, S> f, Func`2<ValueTuple`2<S, A>, bool> predicate);
    [ExtensionAttribute]
public static S FoldBackUntilT(K`2<T, K`2<U, A>> tua, S initialState, Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate);
    [ExtensionAttribute]
public static S FoldBackUntilT(K`2<T, K`2<U, A>> tua, S initialState, Func`3<S, A, S> f, Func`2<ValueTuple`2<S, A>, bool> predicate);
    [ExtensionAttribute]
public static S FoldT(K`2<T, K`2<U, A>> tua, S initialState, Func`2<A, Func`2<S, S>> f);
    [ExtensionAttribute]
public static S FoldT(K`2<T, K`2<U, A>> tua, S initialState, Func`3<S, A, S> f);
    [ExtensionAttribute]
public static S FoldBackT(K`2<T, K`2<U, A>> tua, S initialState, Func`2<S, Func`2<A, S>> f);
    [ExtensionAttribute]
public static S FoldBackT(K`2<T, K`2<U, A>> tua, S initialState, Func`3<S, A, S> f);
    [ExtensionAttribute]
public static A FoldT(K`2<T, K`2<U, A>> tua);
    [ExtensionAttribute]
public static A FoldWhileT(K`2<T, K`2<U, A>> tua, Func`2<ValueTuple`2<A, A>, bool> predicate);
    [ExtensionAttribute]
public static A FoldUntilT(K`2<T, K`2<U, A>> tua, Func`2<ValueTuple`2<A, A>, bool> predicate);
    [ExtensionAttribute]
public static B FoldMapT(K`2<T, K`2<U, A>> tua, Func`2<A, B> f);
    [ExtensionAttribute]
public static B FoldMapWhileT(K`2<T, K`2<U, A>> tua, Func`2<A, B> f, Func`2<ValueTuple`2<B, A>, bool> predicate);
    [ExtensionAttribute]
public static B FoldMapUntilT(K`2<T, K`2<U, A>> tua, Func`2<A, B> f, Func`2<ValueTuple`2<B, A>, bool> predicate);
    [ExtensionAttribute]
public static B FoldMapBackT(K`2<T, K`2<U, A>> tua, Func`2<A, B> f);
    [ExtensionAttribute]
public static B FoldMapBackWhileT(K`2<T, K`2<U, A>> tua, Func`2<A, B> f, Func`2<ValueTuple`2<B, A>, bool> predicate);
    [ExtensionAttribute]
public static B FoldMapBackUntilT(K`2<T, K`2<U, A>> tua, Func`2<A, B> f, Func`2<ValueTuple`2<B, A>, bool> predicate);
    [ExtensionAttribute]
public static Seq`1<A> ToSeqT(K`2<T, K`2<U, A>> tua);
    [ExtensionAttribute]
public static Lst`1<A> ToLstT(K`2<T, K`2<U, A>> tua);
    [ExtensionAttribute]
public static Arr`1<A> ToArrT(K`2<T, K`2<U, A>> tua);
    [ExtensionAttribute]
public static Iterable`1<A> ToEnumerableT(K`2<T, K`2<U, A>> tua);
    [ExtensionAttribute]
public static bool IsEmptyT(K`2<T, K`2<U, A>> tua);
    [ExtensionAttribute]
public static int CountT(K`2<T, K`2<U, A>> tua);
    [ExtensionAttribute]
public static bool ExistsT(K`2<T, K`2<U, A>> tua, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static bool ForAllT(K`2<T, K`2<U, A>> tua, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static bool ContainsT(K`2<T, K`2<U, A>> tua, A value);
    [ExtensionAttribute]
public static bool ContainsT(K`2<T, K`2<U, A>> tua, A value);
    [ExtensionAttribute]
public static Option`1<A> FindT(K`2<T, K`2<U, A>> tua, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static Option`1<A> FindBackT(K`2<T, K`2<U, A>> tua, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static Seq`1<A> FindAllT(K`2<T, K`2<U, A>> tua, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static Seq`1<A> FindAllBackT(K`2<T, K`2<U, A>> tua, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static A SumT(K`2<T, K`2<U, A>> tua);
    [ExtensionAttribute]
public static A ProductT(K`2<T, K`2<U, A>> tua);
    [ExtensionAttribute]
public static Option`1<A> HeadT(K`2<T, K`2<U, A>> tua);
    [ExtensionAttribute]
public static Option`1<A> LastT(K`2<T, K`2<U, A>> tua);
    [ExtensionAttribute]
public static K`2<F, Unit> IterT(K`2<T, K`2<U, A>> tua, Func`2<A, K`2<F, B>> f);
    [ExtensionAttribute]
public static Unit IterT(K`2<T, K`2<U, A>> tua, Action`2<int, A> f);
    [ExtensionAttribute]
public static Unit IterT(K`2<T, K`2<U, A>> tua, Action`1<A> f);
    [ExtensionAttribute]
public static Option`1<A> MinT(K`2<T, K`2<U, A>> tua);
    [ExtensionAttribute]
public static Option`1<A> MinT(K`2<T, K`2<U, A>> tua);
    [ExtensionAttribute]
public static Option`1<A> MaxT(K`2<T, K`2<U, A>> tua);
    [ExtensionAttribute]
public static Option`1<A> MaxT(K`2<T, K`2<U, A>> tua);
    [ExtensionAttribute]
public static A MinT(K`2<T, K`2<U, A>> tua, A initialMin);
    [ExtensionAttribute]
public static A MinT(K`2<T, K`2<U, A>> tua, A initialMin);
    [ExtensionAttribute]
public static A MaxT(K`2<T, K`2<U, A>> tua, A initialMax);
    [ExtensionAttribute]
public static A MaxT(K`2<T, K`2<U, A>> tua, A initialMax);
    [ExtensionAttribute]
public static A AverageT(K`2<T, A> ta);
    [ExtensionAttribute]
public static B AverageT(K`2<T, A> ta, Func`2<A, B> f);
    [ExtensionAttribute]
public static Option`1<A> AtT(K`2<T, A> ta, Index index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class LanguageExt.ForkIO`1 : ValueType {
    [CompilerGeneratedAttribute]
private IO`1<Unit> <Cancel>k__BackingField;
    [CompilerGeneratedAttribute]
private IO`1<A> <Await>k__BackingField;
    public IO`1<Unit> Cancel { get; public set; }
    public IO`1<A> Await { get; public set; }
    public ForkIO`1(IO`1<Unit> Cancel, IO`1<A> Await);
    [CompilerGeneratedAttribute]
public IO`1<Unit> get_Cancel();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Cancel(IO`1<Unit> value);
    [CompilerGeneratedAttribute]
public IO`1<A> get_Await();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Await(IO`1<A> value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ForkIO`1<A> left, ForkIO`1<A> right);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ForkIO`1<A> left, ForkIO`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ForkIO`1<A> other);
    [CompilerGeneratedAttribute]
public void Deconstruct(IO`1& Cancel, IO`1& Await);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Free : object {
    public static Free`2<F, A> pure(A value);
    public static Free`2<F, A> lift(K`2<F, A> value);
    public static Free`2<F, A> bind(K`2<F, Free`2<F, A>> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Free`1 : object {
    private static override K`2<Free`1<F>, B> LanguageExt.Traits.Functor<LanguageExt.Free<F>>.Map(Func`2<A, B> f, K`2<Free`1<F>, A> ma);
    private static override K`2<Free`1<F>, B> LanguageExt.Traits.Monad<LanguageExt.Free<F>>.Bind(K`2<Free`1<F>, A> ma, Func`2<A, K`2<Free`1<F>, B>> f);
    private static override K`2<Free`1<F>, A> LanguageExt.Traits.Applicative<LanguageExt.Free<F>>.Pure(A value);
    private static override K`2<Free`1<F>, B> LanguageExt.Traits.Applicative<LanguageExt.Free<F>>.Apply(K`2<Free`1<F>, Func`2<A, B>> mf, K`2<Free`1<F>, A> ma);
    private static override K`2<Free`1<F>, A> LanguageExt.Traits.SemigroupK<LanguageExt.Free<F>>.Combine(K`2<Free`1<F>, A> lhs, K`2<Free`1<F>, A> rhs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.Free`2 : object {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected Free`2(Free`2<F, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Free`2<F, A> left, Free`2<F, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Free`2<F, A> left, Free`2<F, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Free`2<F, A> other);
    [CompilerGeneratedAttribute]
public abstract virtual Free`2<F, A> <Clone>$();
}
[ExtensionAttribute]
public static class LanguageExt.FreeExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Free`2<F, A> As(K`2<Free`1<F>, A> ma);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.FuncExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static Func`3<B, A, C> Flip(Func`3<A, B, C> f);
    [ExtensionAttribute]
[PureAttribute]
public static Func`2<B, Func`2<A, C>> Flip(Func`2<A, Func`2<B, C>> f);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.FunctorExtensions : object {
    [ExtensionAttribute]
public static K`2<F, Unit> IgnoreF(K`2<F, A> fa);
    [ExtensionAttribute]
public static K`2<F, C> SelectMany(K`2<F, A> ma, Func`2<A, Guard`2<Error, Unit>> bind, Func`3<A, Unit, C> project);
    [ExtensionAttribute]
public static K`2<F, C> SelectMany(K`2<F, A> ma, Func`2<A, Guard`2<Fail`1<Error>, Unit>> bind, Func`3<A, Unit, C> project);
    [ExtensionAttribute]
public static K`2<F, C> SelectMany(Guard`2<Error, Unit> ma, Func`2<Unit, K`2<F, B>> bind, Func`3<Unit, B, C> project);
    [ExtensionAttribute]
public static K`2<F, C> SelectMany(Guard`2<Fail`1<Error>, Unit> ma, Func`2<Unit, K`2<F, B>> bind, Func`3<Unit, B, C> project);
    [ExtensionAttribute]
public static K`2<Fnctr, B> Map(K`2<Fnctr, A> ma, Func`2<A, B> f);
    [ExtensionAttribute]
public static K`2<Fnctr, B> Map(K`2<Fnctr, A> ma, B value);
    [ExtensionAttribute]
public static K`2<Fnctr, B> Select(K`2<Fnctr, A> ma, Func`2<A, B> f);
    [ExtensionAttribute]
public static K`2<Fnctr, B> Map(Func`2<A, B> f, K`2<Fnctr, A> ma);
    [ExtensionAttribute]
public static K`2<Fnctr, Func`2<B, C>> Map(Func`3<A, B, C> f, K`2<Fnctr, A> ma);
    [ExtensionAttribute]
public static K`2<Fnctr, Func`2<B, Func`2<C, D>>> Map(Func`4<A, B, C, D> f, K`2<Fnctr, A> ma);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static K`2<Fnctr, Func`2<B, Func`2<C, Func`2<D, E>>>> Map(Func`5<A, B, C, D, E> f, K`2<Fnctr, A> ma);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static K`2<Fnctr, Func`2<B, Func`2<C, Func`2<D, Func`2<E, F>>>>> Map(Func`6<A, B, C, D, E, F> f, K`2<Fnctr, A> ma);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static K`2<Fnctr, Func`2<B, Func`2<C, Func`2<D, Func`2<E, Func`2<F, G>>>>>> Map(Func`7<A, B, C, D, E, F, G> f, K`2<Fnctr, A> ma);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static K`2<Fnctr, Func`2<B, Func`2<C, Func`2<D, Func`2<E, Func`2<F, Func`2<G, H>>>>>>> Map(Func`8<A, B, C, D, E, F, G, H> f, K`2<Fnctr, A> ma);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static K`2<Fnctr, Func`2<B, Func`2<C, Func`2<D, Func`2<E, Func`2<F, Func`2<G, Func`2<H, I>>>>>>>> Map(Func`9<A, B, C, D, E, F, G, H, I> f, K`2<Fnctr, A> ma);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static K`2<Fnctr, Func`2<B, Func`2<C, Func`2<D, Func`2<E, Func`2<F, Func`2<G, Func`2<H, Func`2<I, J>>>>>>>>> Map(Func`10<A, B, C, D, E, F, G, H, I, J> f, K`2<Fnctr, A> ma);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static K`2<Fnctr, Func`2<B, Func`2<C, Func`2<D, Func`2<E, Func`2<F, Func`2<G, Func`2<H, Func`2<I, Func`2<J, K>>>>>>>>>> Map(Func`11<A, B, C, D, E, F, G, H, I, J, K> f, K`2<Fnctr, A> ma);
    [ExtensionAttribute]
public static K`2<M, K`2<N, B>> MapT(K`2<M, K`2<N, A>> mna, Func`2<A, B> f);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class LanguageExt.Gets`2 : ValueType {
    [CompilerGeneratedAttribute]
private Func`2<S, A> <f>k__BackingField;
    public Func`2<S, A> f { get; public set; }
    public Gets`2(Func`2<S, A> f);
    [CompilerGeneratedAttribute]
public Func`2<S, A> get_f();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_f(Func`2<S, A> value);
    public StateT`3<S, M, A> ToStateT();
    public State`2<S, A> ToState();
    public StateT`3<S, M, C> SelectMany(Func`2<A, StateT`3<S, M, B>> bind, Func`3<A, B, C> project);
    public State`2<S, C> SelectMany(Func`2<A, State`2<S, B>> bind, Func`3<A, B, C> project);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(Gets`2<S, A> left, Gets`2<S, A> right);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public static bool op_Equality(Gets`2<S, A> left, Gets`2<S, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Gets`2<S, A> other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`2& f);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class LanguageExt.Guard`2 : ValueType {
    public bool Flag;
    private Func`1<E> onFalse;
    public Func`1<E> OnFalse { get; }
    internal Guard`2(bool flag, Func`1<E> onFalse);
    internal Guard`2(bool flag, E onFalse);
    [NullableContextAttribute("2")]
public Guard`2<E, B> Cast();
    public Func`1<E> get_OnFalse();
    public Guard`2<E, C> SelectMany(Func`2<E, Guard`2<E, Unit>> bind, Func`3<Unit, Unit, C> project);
    public Guard`2<E, B> Select(Func`2<B, B> _);
    public Either`2<E, Unit> ToEither();
    public Either`2<E, B> Bind(Func`2<Unit, Either`2<E, B>> f);
    public Either`2<E, C> SelectMany(Func`2<Unit, Either`2<E, B>> bind, Func`3<Unit, B, C> project);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.GuardExtensions : object {
    [ExtensionAttribute]
public static IO`1<B> Bind(Guard`2<Error, Unit> guard, Func`2<Unit, IO`1<B>> f);
    [ExtensionAttribute]
public static IO`1<C> SelectMany(Guard`2<Error, Unit> guard, Func`2<Unit, IO`1<B>> bind, Func`3<Unit, B, C> project);
    [ExtensionAttribute]
public static IO`1<Unit> ToIO(Guard`2<Error, Unit> guard);
    [ExtensionAttribute]
public static Eff`1<Unit> ToEff(Guard`2<Error, Unit> guard);
    [ExtensionAttribute]
public static Eff`1<B> Bind(Guard`2<Error, Unit> guard, Func`2<Unit, Eff`1<B>> f);
    [ExtensionAttribute]
public static Eff`1<C> SelectMany(Guard`2<Error, Unit> guard, Func`2<Unit, Eff`1<B>> bind, Func`3<Unit, B, C> project);
    [ExtensionAttribute]
public static Eff`2<RT, Unit> ToEff(Guard`2<Error, Unit> guard);
    [ExtensionAttribute]
public static Eff`2<RT, B> Bind(Guard`2<Error, Unit> guard, Func`2<Unit, Eff`2<RT, B>> f);
    [ExtensionAttribute]
public static Eff`2<RT, C> SelectMany(Guard`2<Error, Unit> guard, Func`2<Unit, Eff`2<RT, B>> bind, Func`3<Unit, B, C> project);
    [ExtensionAttribute]
public static Validation`2<F, Unit> ToValidation(Guard`2<F, Unit> guard);
    [ExtensionAttribute]
public static Validation`2<F, B> Bind(Guard`2<F, Unit> guard, Func`2<Unit, Validation`2<F, B>> f);
    [ExtensionAttribute]
public static Validation`2<F, C> SelectMany(Guard`2<F, Unit> guard, Func`2<Unit, Validation`2<F, B>> bind, Func`3<Unit, B, C> project);
}
[NullableContextAttribute("1")]
[TraitAttribute("Hashable*")]
public interface LanguageExt.Hashable`1 {
    [PureAttribute]
public static abstract virtual int GetHashCode(A x);
}
public class LanguageExt.HashableAttribute : Attribute {
    [NullableContextAttribute("1")]
public HashableAttribute(Type type);
}
public class LanguageExt.HashablePair`4 : ValueType {
    [PureAttribute]
public static override int GetHashCode(ValueTuple`2<A, B> pair);
}
[NullableContextAttribute("1")]
public interface LanguageExt.HashableString`1 {
    public static StringComparison Comparison { get; }
    public static abstract virtual StringComparison get_Comparison();
    private static override int LanguageExt.Hashable<STRING>.GetHashCode(STRING x);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class LanguageExt.HashMap : object {
    [PureAttribute]
public static HashMap`2<K, V> clear(HashMap`2<K, V> map);
    [PureAttribute]
public static HashMap`2<K, V> empty();
    [PureAttribute]
public static HashMap`2<K, V> singleton(ValueTuple`2<K, V> value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`2<K, V> singleton(K key, V value);
    [PureAttribute]
public static HashMap`2<K, V> create();
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`2<K, V> create(Tuple`2<K, V> head, Tuple`2[] tail);
    [PureAttribute]
public static HashMap`2<K, V> create(ValueTuple`2<K, V> head, ValueTuple`2[] tail);
    [PureAttribute]
public static HashMap`2<K, V> create(KeyValuePair`2<K, V> head, KeyValuePair`2[] tail);
    [PureAttribute]
public static HashMap`2<K, V> createRange(IEnumerable`1<Tuple`2<K, V>> keyValues);
    [PureAttribute]
public static HashMap`2<K, V> createRange(IEnumerable`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static HashMap`2<K, V> createRange(ReadOnlySpan`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static HashMap`2<K, V> createRange(IEnumerable`1<KeyValuePair`2<K, V>> keyValues);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`2<K, V> add(HashMap`2<K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`2<K, V> tryAdd(HashMap`2<K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`2<K, V> addOrUpdate(HashMap`2<K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`2<K, V> addOrUpdate(HashMap`2<K, V> map, K key, Func`2<V, V> Some, Func`1<V> None);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`2<K, V> addOrUpdate(HashMap`2<K, V> map, K key, Func`2<V, V> Some, V None);
    [PureAttribute]
public static HashMap`2<K, V> addRange(HashMap`2<K, V> map, IEnumerable`1<Tuple`2<K, V>> keyValues);
    [PureAttribute]
public static HashMap`2<K, V> addRange(HashMap`2<K, V> map, IEnumerable`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static HashMap`2<K, V> addRange(HashMap`2<K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> keyValues);
    [PureAttribute]
public static HashMap`2<K, V> tryAddRange(HashMap`2<K, V> map, IEnumerable`1<Tuple`2<K, V>> keyValues);
    [PureAttribute]
public static HashMap`2<K, V> tryAddRange(HashMap`2<K, V> map, IEnumerable`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static HashMap`2<K, V> tryAddRange(HashMap`2<K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> keyValues);
    [PureAttribute]
public static HashMap`2<K, V> addOrUpdateRange(HashMap`2<K, V> map, IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public static HashMap`2<K, V> addOrUpdateRange(HashMap`2<K, V> map, IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public static HashMap`2<K, V> addOrUpdateRange(HashMap`2<K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> range);
    [PureAttribute]
public static HashMap`2<K, V> remove(HashMap`2<K, V> map, K key);
    [PureAttribute]
public static bool containsKey(HashMap`2<K, V> map, K key);
    [PureAttribute]
public static bool contains(HashMap`2<K, V> map, KeyValuePair`2<K, V> kv);
    [PureAttribute]
public static bool contains(HashMap`2<K, V> map, Tuple`2<K, V> kv);
    [PureAttribute]
public static bool contains(HashMap`2<K, V> map, ValueTuple`2<K, V> kv);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`2<K, V> setItem(HashMap`2<K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`2<K, V> trySetItem(HashMap`2<K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`2<K, V> trySetItem(HashMap`2<K, V> map, K key, Func`2<V, V> Some);
    [PureAttribute]
public static HashMap`2<K, V> setItems(HashMap`2<K, V> map, IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public static HashMap`2<K, V> setItems(HashMap`2<K, V> map, IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public static HashMap`2<K, V> setItems(HashMap`2<K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> items);
    [PureAttribute]
public static HashMap`2<K, V> trySetItems(HashMap`2<K, V> map, IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public static HashMap`2<K, V> trySetItems(HashMap`2<K, V> map, IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public static HashMap`2<K, V> trySetItems(HashMap`2<K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> items);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`2<K, V> trySetItems(HashMap`2<K, V> map, IEnumerable`1<K> keys, Func`2<V, V> Some);
    [PureAttribute]
public static Option`1<V> find(HashMap`2<K, V> map, K key);
    [NullableContextAttribute("1")]
[PureAttribute]
public static R find(HashMap`2<K, V> map, K key, Func`2<V, R> Some, Func`1<R> None);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`2<K, V> setItem(HashMap`2<K, V> map, K key, Func`2<V, V> mapper);
    public static Unit iter(HashMap`2<K, V> map, Action`1<V> action);
    public static Unit iter(HashMap`2<K, V> map, Action`2<K, V> action);
    [PureAttribute]
public static bool forall(HashMap`2<K, V> map, Func`2<V, bool> pred);
    [PureAttribute]
public static bool forall(HashMap`2<K, V> map, Func`3<K, V, bool> pred);
    [PureAttribute]
public static bool forall(HashMap`2<K, V> map, Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public static HashMap`2<K, U> map(HashMap`2<K, T> map, Func`2<T, U> f);
    [PureAttribute]
public static HashMap`2<K, U> map(HashMap`2<K, T> map, Func`3<K, T, U> f);
    [PureAttribute]
public static HashMap`2<K, V> filter(HashMap`2<K, V> map, Func`2<V, bool> predicate);
    [PureAttribute]
public static HashMap`2<K, V> filter(HashMap`2<K, V> map, Func`3<K, V, bool> predicate);
    [PureAttribute]
public static HashMap`3<EqK, K, V> clear(HashMap`3<EqK, K, V> map);
    [PureAttribute]
public static HashMap`3<EqK, K, V> empty();
    [PureAttribute]
public static HashMap`3<EqK, K, V> create();
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> singleton(K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> create(Tuple`2<K, V> head, Tuple`2[] tail);
    [PureAttribute]
public static HashMap`3<EqK, K, V> create(ValueTuple`2<K, V> head, ValueTuple`2[] tail);
    [PureAttribute]
public static HashMap`3<EqK, K, V> create(KeyValuePair`2<K, V> head, KeyValuePair`2[] tail);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> createRange(IEnumerable`1<Tuple`2<K, V>> keyValues);
    [PureAttribute]
public static HashMap`3<EqK, K, V> createRange(IEnumerable`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static HashMap`3<EqK, K, V> createRange(ReadOnlySpan`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static HashMap`3<EqK, K, V> createRange(IEnumerable`1<KeyValuePair`2<K, V>> keyValues);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> add(HashMap`3<EqK, K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> tryAdd(HashMap`3<EqK, K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> addOrUpdate(HashMap`3<EqK, K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> addOrUpdate(HashMap`3<EqK, K, V> map, K key, Func`2<V, V> Some, Func`1<V> None);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> addOrUpdate(HashMap`3<EqK, K, V> map, K key, Func`2<V, V> Some, V None);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> addRange(HashMap`3<EqK, K, V> map, IEnumerable`1<Tuple`2<K, V>> keyValues);
    [PureAttribute]
public static HashMap`3<EqK, K, V> addRange(HashMap`3<EqK, K, V> map, IEnumerable`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static HashMap`3<EqK, K, V> addRange(HashMap`3<EqK, K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> keyValues);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> tryAddRange(HashMap`3<EqK, K, V> map, IEnumerable`1<Tuple`2<K, V>> keyValues);
    [PureAttribute]
public static HashMap`3<EqK, K, V> tryAddRange(HashMap`3<EqK, K, V> map, IEnumerable`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static HashMap`3<EqK, K, V> tryAddRange(HashMap`3<EqK, K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> keyValues);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> addOrUpdateRange(HashMap`3<EqK, K, V> map, IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public static HashMap`3<EqK, K, V> addOrUpdateRange(HashMap`3<EqK, K, V> map, IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public static HashMap`3<EqK, K, V> addOrUpdateRange(HashMap`3<EqK, K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> range);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> remove(HashMap`3<EqK, K, V> map, K key);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool containsKey(HashMap`3<EqK, K, V> map, K key);
    [PureAttribute]
public static bool contains(HashMap`3<EqK, K, V> map, KeyValuePair`2<K, V> kv);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool contains(HashMap`3<EqK, K, V> map, Tuple`2<K, V> kv);
    [PureAttribute]
public static bool contains(HashMap`3<EqK, K, V> map, ValueTuple`2<K, V> kv);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> setItem(HashMap`3<EqK, K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> trySetItem(HashMap`3<EqK, K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> trySetItem(HashMap`3<EqK, K, V> map, K key, Func`2<V, V> Some);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> setItems(HashMap`3<EqK, K, V> map, IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public static HashMap`3<EqK, K, V> setItems(HashMap`3<EqK, K, V> map, IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public static HashMap`3<EqK, K, V> setItems(HashMap`3<EqK, K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> items);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> trySetItems(HashMap`3<EqK, K, V> map, IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public static HashMap`3<EqK, K, V> trySetItems(HashMap`3<EqK, K, V> map, IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public static HashMap`3<EqK, K, V> trySetItems(HashMap`3<EqK, K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> items);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> trySetItems(HashMap`3<EqK, K, V> map, IEnumerable`1<K> keys, Func`2<V, V> Some);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Option`1<V> find(HashMap`3<EqK, K, V> map, K key);
    [NullableContextAttribute("1")]
[PureAttribute]
public static IEnumerable`1<V> findSeq(HashMap`3<EqK, K, V> map, K key);
    [NullableContextAttribute("1")]
[PureAttribute]
public static R find(HashMap`3<EqK, K, V> map, K key, Func`2<V, R> Some, Func`1<R> None);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> setItem(HashMap`3<EqK, K, V> map, K key, Func`2<V, V> mapper);
    [NullableContextAttribute("1")]
public static Unit iter(HashMap`3<EqK, K, V> map, Action`1<V> action);
    [NullableContextAttribute("1")]
public static Unit iter(HashMap`3<EqK, K, V> map, Action`2<K, V> action);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool forall(HashMap`3<EqK, K, V> map, Func`2<V, bool> pred);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool forall(HashMap`3<EqK, K, V> map, Func`3<K, V, bool> pred);
    [PureAttribute]
public static bool forall(HashMap`3<EqK, K, V> map, Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public static HashMap`3<EqK, K, U> map(HashMap`3<EqK, K, T> map, Func`2<T, U> f);
    [PureAttribute]
public static HashMap`3<EqK, K, U> map(HashMap`3<EqK, K, T> map, Func`3<K, T, U> f);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> filter(HashMap`3<EqK, K, V> map, Func`2<V, bool> predicate);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<EqK, K, V> filter(HashMap`3<EqK, K, V> map, Func`3<K, V, bool> predicate);
    [PureAttribute]
public static int length(HashMap`3<EqK, K, T> map);
    [NullableContextAttribute("1")]
[PureAttribute]
public static S fold(HashMap`3<EqK, K, V> map, S state, Func`4<S, K, V, S> folder);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool exists(HashMap`3<EqK, K, V> map, Func`3<K, V, bool> pred);
    [PureAttribute]
public static bool exists(HashMap`3<EqK, K, V> map, Func`2<ValueTuple`2<K, V>, bool> pred);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool exists(HashMap`3<EqK, K, V> map, Func`2<V, bool> pred);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.HashMap`1 : object {
    private static override K`2<HashMap`1<Key>, B> LanguageExt.Traits.Functor<LanguageExt.HashMap<Key>>.Map(Func`2<A, B> f, K`2<HashMap`1<Key>, A> ma);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.HashMap<Key>>.FoldWhile(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<HashMap`1<Key>, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.HashMap<Key>>.FoldBackWhile(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<HashMap`1<Key>, A> ta);
    private static override int LanguageExt.Traits.Foldable<LanguageExt.HashMap<Key>>.Count(K`2<HashMap`1<Key>, A> ta);
    private static override bool LanguageExt.Traits.Foldable<LanguageExt.HashMap<Key>>.IsEmpty(K`2<HashMap`1<Key>, A> ta);
    private static override K`2<HashMap`1<Key>, A> LanguageExt.Traits.SemigroupK<LanguageExt.HashMap<Key>>.Combine(K`2<HashMap`1<Key>, A> lhs, K`2<HashMap`1<Key>, A> rhs);
    private static override K`2<HashMap`1<Key>, A> LanguageExt.Traits.MonoidK<LanguageExt.HashMap<Key>>.Empty();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[CollectionBuilderAttribute("LanguageExt.HashMap", "createRange")]
public class LanguageExt.HashMap`2 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static HashMap`2<K, V> <Empty>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private TrieMap`3<EqDefault`1<K>, K, V> value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public static HashMap`2<K, V> Empty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal TrieMap`3<EqDefault`1<K>, K, V> Value { get; }
    [PureAttribute]
public V Item { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public Iterable`1<K> Keys { get; }
    [PureAttribute]
public Iterable`1<V> Values { get; }
    [PureAttribute]
private IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.Keys { get; }
    [PureAttribute]
private IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.Values { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static HashMap`2<K, V> AdditiveIdentity { get; }
    internal HashMap`2(TrieMap`3<EqDefault`1<K>, K, V> value);
    public HashMap`2(IEnumerable`1<ValueTuple`2<K, V>> items);
    public HashMap`2(IEnumerable`1<ValueTuple`2<K, V>> items, bool tryAdd);
    private static HashMap`2();
    [CompilerGeneratedAttribute]
public static override HashMap`2<K, V> get_Empty();
    internal TrieMap`3<EqDefault`1<K>, K, V> get_Value();
    [PureAttribute]
public static Lens`2<HashMap`2<K, V>, V> item(K key);
    [PureAttribute]
public static Lens`2<HashMap`2<K, V>, Option`1<V>> itemOrNone(K key);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Lens`2<HashMap`2<K, V>, HashMap`2<K, B>> map(Lens`2<V, B> lens);
    private static HashMap`2<K, V> Wrap(TrieMap`3<EqDefault`1<K>, K, V> value);
    [NullableContextAttribute("2")]
private static HashMap`2<K, U> Wrap(TrieMap`3<EqDefault`1<K>, K, U> value);
    public sealed virtual V get_Item(K key);
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    [PureAttribute]
public HashMap`2<K, V> Filter(Func`2<V, bool> pred);
    [PureAttribute]
public HashMap`2<K, V> Filter(Func`3<K, V, bool> pred);
    [PureAttribute]
public HashMap`2<K, U> Map(Func`2<V, U> mapper);
    [PureAttribute]
public HashMap`2<K, U> Map(Func`3<K, V, U> mapper);
    [PureAttribute]
public HashMap`2<K, V> Add(K key, V valueToAdd);
    [PureAttribute]
public HashMap`2<K, V> TryAdd(K key, V valueToAdd);
    [PureAttribute]
public HashMap`2<K, V> AddOrUpdate(K key, V value);
    [PureAttribute]
public HashMap`2<K, V> AddOrUpdate(K key, Func`2<V, V> Some, Func`1<V> None);
    [PureAttribute]
public HashMap`2<K, V> AddOrUpdate(K key, Func`2<V, V> Some, V None);
    [PureAttribute]
public HashMap`2<K, V> AddRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public HashMap`2<K, V> AddRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public HashMap`2<K, V> TryAddRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public HashMap`2<K, V> TryAddRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public HashMap`2<K, V> TryAddRange(IEnumerable`1<KeyValuePair`2<K, V>> range);
    [PureAttribute]
public HashMap`2<K, V> AddOrUpdateRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public HashMap`2<K, V> AddOrUpdateRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public HashMap`2<K, V> AddOrUpdateRange(IEnumerable`1<KeyValuePair`2<K, V>> range);
    [PureAttribute]
public HashMap`2<K, V> Remove(K key);
    [PureAttribute]
public Option`1<V> Find(K key);
    [PureAttribute]
public R Find(K key, Func`2<V, R> Some, Func`1<R> None);
    [PureAttribute]
public ValueTuple`2<HashMap`2<K, V>, V> FindOrAdd(K key, Func`1<V> None);
    [PureAttribute]
public ValueTuple`2<HashMap`2<K, V>, V> FindOrAdd(K key, V valueToFindOrAdd);
    [PureAttribute]
public ValueTuple`2<HashMap`2<K, V>, Option`1<V>> FindOrMaybeAdd(K key, Func`1<Option`1<V>> None);
    [PureAttribute]
public ValueTuple`2<HashMap`2<K, V>, Option`1<V>> FindOrMaybeAdd(K key, Option`1<V> None);
    [PureAttribute]
public HashMap`2<K, V> SetItem(K key, V valueToSet);
    [PureAttribute]
public HashMap`2<K, V> SetItem(K key, Func`2<V, V> Some);
    [PureAttribute]
public HashMap`2<K, V> TrySetItem(K key, V valueToSet);
    [PureAttribute]
public HashMap`2<K, V> TrySetItem(K key, Func`2<V, V> Some);
    [PureAttribute]
public sealed virtual bool ContainsKey(K key);
    [PureAttribute]
public bool Contains(K key, V value);
    [PureAttribute]
public bool Contains(V value);
    [PureAttribute]
public bool Contains(K key, V value);
    [PureAttribute]
public HashMap`2<K, V> AddRange(IEnumerable`1<KeyValuePair`2<K, V>> pairs);
    [PureAttribute]
public HashMap`2<K, V> SetItems(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [PureAttribute]
public HashMap`2<K, V> SetItems(IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public HashMap`2<K, V> SetItems(IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public HashMap`2<K, V> TrySetItems(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [PureAttribute]
public HashMap`2<K, V> TrySetItems(IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public HashMap`2<K, V> TrySetItems(IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public HashMap`2<K, V> TrySetItems(IEnumerable`1<K> keys, Func`2<V, V> Some);
    [PureAttribute]
public HashMap`2<K, V> RemoveRange(IEnumerable`1<K> keys);
    [PureAttribute]
public bool Contains(ValueTuple`2<K, V> pair);
    public Iterable`1<K> get_Keys();
    public Iterable`1<V> get_Values();
    [PureAttribute]
public IDictionary`2<KR, VR> ToDictionary(Func`2<ValueTuple`2<K, V>, KR> keySelector, Func`2<ValueTuple`2<K, V>, VR> valueSelector);
    public sealed virtual IEnumerator`1<ValueTuple`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public HashMap`2<K, V> ToTrackingHashMap();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToFullString(string separator);
    [PureAttribute]
public string ToFullArrayString(string separator);
    [PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> AsIterable();
    [PureAttribute]
public static HashMap`2<K, V> op_Implicit(SeqEmpty _);
    [PureAttribute]
public static override bool op_Equality(HashMap`2<K, V> lhs, HashMap`2<K, V> rhs);
    [PureAttribute]
public static override bool op_Inequality(HashMap`2<K, V> lhs, HashMap`2<K, V> rhs);
    [PureAttribute]
public static override HashMap`2<K, V> op_Addition(HashMap`2<K, V> lhs, HashMap`2<K, V> rhs);
    [PureAttribute]
public sealed virtual HashMap`2<K, V> Combine(HashMap`2<K, V> rhs);
    [PureAttribute]
public static override HashMap`2<K, V> op_Subtraction(HashMap`2<K, V> lhs, HashMap`2<K, V> rhs);
    [PureAttribute]
public HashMap`2<K, V> Subtract(HashMap`2<K, V> rhs);
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsSubsetOf(HashMap`2<K, V> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<K> rhs);
    [PureAttribute]
public HashMap`2<K, V> Intersect(IEnumerable`1<K> rhs);
    [PureAttribute]
public HashMap`2<K, V> Intersect(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    [PureAttribute]
public HashMap`2<K, V> Intersect(IEnumerable`1<ValueTuple`2<K, V>> rhs, WhenMatched`4<K, V, V, V> Merge);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<K> other);
    [PureAttribute]
public HashMap`2<K, V> Except(IEnumerable`1<K> rhs);
    [PureAttribute]
public HashMap`2<K, V> Except(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    [PureAttribute]
public HashMap`2<K, V> SymmetricExcept(HashMap`2<K, V> rhs);
    [PureAttribute]
public HashMap`2<K, V> SymmetricExcept(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    [PureAttribute]
public HashMap`2<K, V> Union(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    [PureAttribute]
public HashMap`2<K, V> Union(IEnumerable`1<ValueTuple`2<K, V>> other, WhenMatched`4<K, V, V, V> Merge);
    [PureAttribute]
public HashMap`2<K, V> Union(IEnumerable`1<ValueTuple`2<K, W>> other, WhenMissing`3<K, W, V> MapRight, WhenMatched`4<K, V, W, V> Merge);
    [PureAttribute]
public HashMap`2<K, W> Union(IEnumerable`1<ValueTuple`2<K, W>> other, WhenMissing`3<K, V, W> MapLeft, WhenMatched`4<K, V, W, W> Merge);
    [PureAttribute]
public HashMap`2<K, R> Union(IEnumerable`1<ValueTuple`2<K, W>> other, WhenMissing`3<K, V, R> MapLeft, WhenMissing`3<K, W, R> MapRight, WhenMatched`4<K, V, W, R> Merge);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public sealed virtual bool Equals(HashMap`2<K, V> other);
    [NullableContextAttribute("0")]
[PureAttribute]
public bool Equals(HashMap`2<K, V> other);
    [PureAttribute]
public bool EqualsKeys(HashMap`2<K, V> other);
    [PureAttribute]
public virtual int GetHashCode();
    public HashMap`2<K, V> Do(Action`1<V> f);
    [PureAttribute]
public HashMap`2<K, U> Select(Func`2<V, U> mapper);
    [PureAttribute]
public HashMap`2<K, U> Select(Func`3<K, V, U> mapper);
    [PureAttribute]
[EditorBrowsableAttribute("1")]
public HashMap`2<K, V> Where(Func`2<V, bool> pred);
    [PureAttribute]
[EditorBrowsableAttribute("1")]
public HashMap`2<K, V> Where(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool ForAll(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool Exists(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<ValueTuple`2<K, V>, bool> pred);
    public Unit Iter(Action`2<K, V> action);
    public Unit Iter(Action`1<ValueTuple`2<K, V>> action);
    [PureAttribute]
private sealed virtual override IEnumerator`1<KeyValuePair`2<K, V>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,V>>.GetEnumerator();
    private sealed virtual override IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Keys();
    private sealed virtual override IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Values();
    [PureAttribute]
public sealed virtual bool TryGetValue(K key, V& value);
    [PureAttribute]
public IReadOnlyDictionary`2<K, V> ToReadOnlyDictionary();
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`2<K, V> op_Implicit(ValueTuple`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`2<K, V> op_Implicit(ValueTuple`2<ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`2<K, V> op_Implicit(ValueTuple`3<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`2<K, V> op_Implicit(ValueTuple`4<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`2<K, V> op_Implicit(ValueTuple`5<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`2<K, V> op_Implicit(ValueTuple`6<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`2<K, V> op_Implicit(ValueTuple`7<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`1<ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`3<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`4<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`5<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`6<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`7<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`1<ValueTuple`2<K, V>>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<ValueTuple`2<K, V>, ValueTuple`2<K, V>>>> items);
    public static override HashMap`2<K, V> get_AdditiveIdentity();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[CollectionBuilderAttribute("LanguageExt.HashMap", "createRange")]
public class LanguageExt.HashMap`3 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static HashMap`3<EqK, K, V> <Empty>k__BackingField;
    private TrieMap`3<EqK, K, V> value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public static HashMap`3<EqK, K, V> Empty { get; }
    internal TrieMap`3<EqK, K, V> Value { get; }
    [PureAttribute]
public V Item { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public int Length { get; }
    [PureAttribute]
public Iterable`1<K> Keys { get; }
    [PureAttribute]
public Iterable`1<V> Values { get; }
    [PureAttribute]
private IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.Keys { get; }
    [PureAttribute]
private IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.Values { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static HashMap`3<EqK, K, V> AdditiveIdentity { get; }
    internal HashMap`3(TrieMap`3<EqK, K, V> value);
    public HashMap`3(IEnumerable`1<ValueTuple`2<K, V>> items);
    public HashMap`3(IEnumerable`1<ValueTuple`2<K, V>> items, bool tryAdd);
    private static HashMap`3();
    [CompilerGeneratedAttribute]
public static override HashMap`3<EqK, K, V> get_Empty();
    internal TrieMap`3<EqK, K, V> get_Value();
    private static HashMap`3<EqK, K, V> Wrap(TrieMap`3<EqK, K, V> value);
    private static HashMap`3<EqK, K, U> Wrap(TrieMap`3<EqK, K, U> value);
    public sealed virtual V get_Item(K key);
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public int get_Length();
    [PureAttribute]
public HashMap`3<EqK, K, V> Filter(Func`2<V, bool> pred);
    [PureAttribute]
public HashMap`3<EqK, K, V> Filter(Func`3<K, V, bool> pred);
    [PureAttribute]
public HashMap`3<EqK, K, U> Map(Func`2<V, U> mapper);
    [PureAttribute]
public HashMap`3<EqK, K, U> Map(Func`3<K, V, U> mapper);
    [PureAttribute]
public HashMap`3<EqK, K, V> Add(K key, V value);
    [PureAttribute]
public HashMap`3<EqK, K, V> TryAdd(K key, V value);
    [PureAttribute]
public HashMap`3<EqK, K, V> AddOrUpdate(K key, V value);
    [PureAttribute]
public HashMap`3<EqK, K, V> AddOrUpdate(K key, Func`2<V, V> Some, Func`1<V> None);
    [PureAttribute]
public HashMap`3<EqK, K, V> AddOrUpdate(K key, Func`2<V, V> Some, V None);
    [PureAttribute]
public HashMap`3<EqK, K, V> AddRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public HashMap`3<EqK, K, V> AddRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public HashMap`3<EqK, K, V> TryAddRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public HashMap`3<EqK, K, V> TryAddRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public HashMap`3<EqK, K, V> TryAddRange(IEnumerable`1<KeyValuePair`2<K, V>> range);
    [PureAttribute]
public HashMap`3<EqK, K, V> AddOrUpdateRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public HashMap`3<EqK, K, V> AddOrUpdateRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public HashMap`3<EqK, K, V> AddOrUpdateRange(IEnumerable`1<KeyValuePair`2<K, V>> range);
    [PureAttribute]
public HashMap`3<EqK, K, V> Remove(K key);
    [PureAttribute]
public Option`1<V> Find(K key);
    [PureAttribute]
public Seq`1<V> FindSeq(K key);
    [PureAttribute]
public R Find(K key, Func`2<V, R> Some, Func`1<R> None);
    [PureAttribute]
public ValueTuple`2<HashMap`3<EqK, K, V>, V> FindOrAdd(K key, Func`1<V> None);
    [PureAttribute]
public ValueTuple`2<HashMap`3<EqK, K, V>, V> FindOrAdd(K key, V value);
    [PureAttribute]
public ValueTuple`2<HashMap`3<EqK, K, V>, Option`1<V>> FindOrMaybeAdd(K key, Func`1<Option`1<V>> None);
    [PureAttribute]
public ValueTuple`2<HashMap`3<EqK, K, V>, Option`1<V>> FindOrMaybeAdd(K key, Option`1<V> None);
    [PureAttribute]
public HashMap`3<EqK, K, V> SetItem(K key, V value);
    [PureAttribute]
public HashMap`3<EqK, K, V> SetItem(K key, Func`2<V, V> Some);
    [PureAttribute]
public HashMap`3<EqK, K, V> TrySetItem(K key, V value);
    [PureAttribute]
public HashMap`3<EqK, K, V> TrySetItem(K key, Func`2<V, V> Some);
    [PureAttribute]
public sealed virtual bool ContainsKey(K key);
    [PureAttribute]
public bool Contains(K key, V value);
    [PureAttribute]
public bool Contains(K key, V value);
    [PureAttribute]
public HashMap`3<EqK, K, V> Clear();
    [PureAttribute]
public HashMap`3<EqK, K, V> AddRange(IEnumerable`1<KeyValuePair`2<K, V>> pairs);
    [PureAttribute]
public HashMap`3<EqK, K, V> SetItems(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [PureAttribute]
public HashMap`3<EqK, K, V> SetItems(IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public HashMap`3<EqK, K, V> SetItems(IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public HashMap`3<EqK, K, V> TrySetItems(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [PureAttribute]
public HashMap`3<EqK, K, V> TrySetItems(IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public HashMap`3<EqK, K, V> TrySetItems(IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public HashMap`3<EqK, K, V> TrySetItems(IEnumerable`1<K> keys, Func`2<V, V> Some);
    [PureAttribute]
public HashMap`3<EqK, K, V> RemoveRange(IEnumerable`1<K> keys);
    [PureAttribute]
public bool Contains(KeyValuePair`2<K, V> pair);
    [NullableContextAttribute("0")]
[PureAttribute]
public bool Contains(KeyValuePair`2<K, V> pair);
    public Iterable`1<K> get_Keys();
    public Iterable`1<V> get_Values();
    [PureAttribute]
public IDictionary`2<KR, VR> ToDictionary(Func`2<ValueTuple`2<K, V>, KR> keySelector, Func`2<ValueTuple`2<K, V>, VR> valueSelector);
    public sealed virtual IEnumerator`1<ValueTuple`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public Seq`1<ValueTuple`2<K, V>> ToSeq();
    [PureAttribute]
public HashMap`3<EqK, K, V> ToTrackingHashMap();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToFullString(string separator);
    [PureAttribute]
public string ToFullArrayString(string separator);
    [PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> AsEnumerable();
    [PureAttribute]
public static HashMap`3<EqK, K, V> op_Implicit(SeqEmpty _);
    [PureAttribute]
public static override bool op_Equality(HashMap`3<EqK, K, V> lhs, HashMap`3<EqK, K, V> rhs);
    [PureAttribute]
public static override bool op_Inequality(HashMap`3<EqK, K, V> lhs, HashMap`3<EqK, K, V> rhs);
    [PureAttribute]
public static override HashMap`3<EqK, K, V> op_Addition(HashMap`3<EqK, K, V> lhs, HashMap`3<EqK, K, V> rhs);
    [PureAttribute]
public sealed virtual HashMap`3<EqK, K, V> Combine(HashMap`3<EqK, K, V> rhs);
    [PureAttribute]
public static override HashMap`3<EqK, K, V> op_Subtraction(HashMap`3<EqK, K, V> lhs, HashMap`3<EqK, K, V> rhs);
    [PureAttribute]
public HashMap`3<EqK, K, V> Subtract(HashMap`3<EqK, K, V> rhs);
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsSubsetOf(HashMap`3<EqK, K, V> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<K> rhs);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<K> other);
    [PureAttribute]
public HashMap`3<EqK, K, V> Intersect(IEnumerable`1<K> rhs);
    [PureAttribute]
public HashMap`3<EqK, K, V> Intersect(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    [PureAttribute]
public HashMap`3<EqK, K, V> Intersect(IEnumerable`1<ValueTuple`2<K, V>> rhs, WhenMatched`4<K, V, V, V> Merge);
    [PureAttribute]
public HashMap`3<EqK, K, V> Except(IEnumerable`1<K> rhs);
    [PureAttribute]
public HashMap`3<EqK, K, V> Except(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    [PureAttribute]
public HashMap`3<EqK, K, V> SymmetricExcept(HashMap`3<EqK, K, V> rhs);
    [PureAttribute]
public HashMap`3<EqK, K, V> SymmetricExcept(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    [PureAttribute]
public HashMap`3<EqK, K, V> Union(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    [PureAttribute]
public HashMap`3<EqK, K, V> Union(IEnumerable`1<ValueTuple`2<K, V>> other, WhenMatched`4<K, V, V, V> Merge);
    [PureAttribute]
public HashMap`3<EqK, K, V> Union(IEnumerable`1<ValueTuple`2<K, W>> other, WhenMissing`3<K, W, V> MapRight, WhenMatched`4<K, V, W, V> Merge);
    [PureAttribute]
public HashMap`3<EqK, K, W> Union(IEnumerable`1<ValueTuple`2<K, W>> other, WhenMissing`3<K, V, W> MapLeft, WhenMatched`4<K, V, W, W> Merge);
    [PureAttribute]
public HashMap`3<EqK, K, R> Union(IEnumerable`1<ValueTuple`2<K, W>> other, WhenMissing`3<K, V, R> MapLeft, WhenMissing`3<K, W, R> MapRight, WhenMatched`4<K, V, W, R> Merge);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public sealed virtual bool Equals(HashMap`3<EqK, K, V> other);
    [NullableContextAttribute("0")]
[PureAttribute]
public bool Equals(HashMap`3<EqK, K, V> other);
    [PureAttribute]
public bool EqualKeys(HashMap`3<EqK, K, V> other);
    [PureAttribute]
public virtual int GetHashCode();
    public HashMap`3<EqK, K, V> Do(Action`1<V> f);
    [PureAttribute]
public HashMap`3<EqK, K, U> Select(Func`2<V, U> mapper);
    [PureAttribute]
public HashMap`3<EqK, K, U> Select(Func`3<K, V, U> mapper);
    [PureAttribute]
[EditorBrowsableAttribute("1")]
public HashMap`3<EqK, K, V> Where(Func`2<V, bool> pred);
    [PureAttribute]
[EditorBrowsableAttribute("1")]
public HashMap`3<EqK, K, V> Where(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool ForAll(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<V, bool> pred);
    public bool Exists(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<V, bool> pred);
    public Unit Iter(Action`2<K, V> action);
    public Unit Iter(Action`1<V> action);
    public Unit Iter(Action`1<Tuple`2<K, V>> action);
    public Unit Iter(Action`1<ValueTuple`2<K, V>> action);
    public Unit Iter(Action`1<KeyValuePair`2<K, V>> action);
    [PureAttribute]
public S Fold(S state, Func`4<S, K, V, S> folder);
    [PureAttribute]
private sealed virtual override IEnumerator`1<KeyValuePair`2<K, V>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,V>>.GetEnumerator();
    private sealed virtual override IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Keys();
    private sealed virtual override IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Values();
    [PureAttribute]
public IReadOnlyDictionary`2<K, V> ToReadOnlyDictionary();
    [PureAttribute]
public sealed virtual bool TryGetValue(K key, V& value);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`3<EqK, K, V> op_Implicit(ValueTuple`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`3<EqK, K, V> op_Implicit(ValueTuple`2<ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`3<EqK, K, V> op_Implicit(ValueTuple`3<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`3<EqK, K, V> op_Implicit(ValueTuple`4<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`3<EqK, K, V> op_Implicit(ValueTuple`5<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`3<EqK, K, V> op_Implicit(ValueTuple`6<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`3<EqK, K, V> op_Implicit(ValueTuple`7<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`3<EqK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`1<ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`3<EqK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`3<EqK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`3<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`3<EqK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`4<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`3<EqK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`5<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`3<EqK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`6<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`3<EqK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`7<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`3<EqK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`1<ValueTuple`2<K, V>>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static HashMap`3<EqK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<ValueTuple`2<K, V>, ValueTuple`2<K, V>>>> items);
    public static override HashMap`3<EqK, K, V> get_AdditiveIdentity();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.HashMapEq`2 : object {
    private static override S LanguageExt.Traits.Foldable<LanguageExt.HashMapEq<EqKey,Key>>.FoldWhile(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<HashMapEq`2<EqKey, Key>, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.HashMapEq<EqKey,Key>>.FoldBackWhile(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<HashMapEq`2<EqKey, Key>, A> ta);
    private static override int LanguageExt.Traits.Foldable<LanguageExt.HashMapEq<EqKey,Key>>.Count(K`2<HashMapEq`2<EqKey, Key>, A> ta);
    private static override bool LanguageExt.Traits.Foldable<LanguageExt.HashMapEq<EqKey,Key>>.IsEmpty(K`2<HashMapEq`2<EqKey, Key>, A> ta);
    private static override K`2<HashMapEq`2<EqKey, Key>, A> LanguageExt.Traits.SemigroupK<LanguageExt.HashMapEq<EqKey,Key>>.Combine(K`2<HashMapEq`2<EqKey, Key>, A> lhs, K`2<HashMapEq`2<EqKey, Key>, A> rhs);
    private static override K`2<HashMapEq`2<EqKey, Key>, A> LanguageExt.Traits.MonoidK<LanguageExt.HashMapEq<EqKey,Key>>.Empty();
    public static override K`2<HashMapEq`2<EqKey, Key>, B> Map(Func`2<A, B> f, K`2<HashMapEq`2<EqKey, Key>, A> ma);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.HashMapExtensions : object {
    [ExtensionAttribute]
public static HashMap`2<Key, V> As(K`2<HashMap`1<Key>, V> ma);
    [ExtensionAttribute]
[PureAttribute]
public static HashMap`2<K, V> ToHashMap(IEnumerable`1<ValueTuple`2<K, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static HashMap`2<ValueTuple`2<K1, K2>, V> ToHashMap(IEnumerable`1<ValueTuple`3<K1, K2, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static HashMap`2<ValueTuple`3<K1, K2, K3>, V> ToHashMap(IEnumerable`1<ValueTuple`4<K1, K2, K3, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static HashMap`2<ValueTuple`4<K1, K2, K3, K4>, V> ToHashMap(IEnumerable`1<ValueTuple`5<K1, K2, K3, K4, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static IQueryable`1<ValueTuple`2<K, V>> AsQueryable(HashMap`2<K, V> source);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static HashMap`3<EqKey, Key, V> As(K`2<HashMapEq`2<EqKey, Key>, V> ma);
    [ExtensionAttribute]
[PureAttribute]
public static HashMap`3<EqK, K, V> ToHashMap(IEnumerable`1<ValueTuple`2<K, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static HashMap`3<EqK, ValueTuple`2<K1, K2>, V> ToHashMap(IEnumerable`1<ValueTuple`3<K1, K2, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static HashMap`3<EqK, ValueTuple`3<K1, K2, K3>, V> ToHashMap(IEnumerable`1<ValueTuple`4<K1, K2, K3, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static HashMap`3<EqK, ValueTuple`4<K1, K2, K3, K4>, V> ToHashMap(IEnumerable`1<ValueTuple`5<K1, K2, K3, K4, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static IQueryable`1<ValueTuple`2<K, V>> AsQueryable(HashMap`3<EqK, K, V> source);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class LanguageExt.HashMapPatch`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private TrieMap`3<EqDefault`1<K>, K, V> prev;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private TrieMap`3<EqDefault`1<K>, K, V> curr;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private TrieMap`3<EqDefault`1<K>, K, Change`1<V>> changes;
    private K key;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Change`1<V> change;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public HashMap`2<K, V> From { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public HashMap`2<K, V> To { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public HashMap`2<K, Change`1<V>> Changes { get; }
    internal HashMapPatch`2(TrieMap`3<EqDefault`1<K>, K, V> prev, TrieMap`3<EqDefault`1<K>, K, V> curr, TrieMap`3<EqDefault`1<K>, K, Change`1<V>> changes);
    [NullableContextAttribute("1")]
internal HashMapPatch`2(TrieMap`3<EqDefault`1<K>, K, V> prev, TrieMap`3<EqDefault`1<K>, K, V> curr, K key, Change`1<V> change);
    public HashMap`2<K, V> get_From();
    public HashMap`2<K, V> get_To();
    public HashMap`2<K, Change`1<V>> get_Changes();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.HashMapPatch`3 : object {
    private TrieMap`3<EqK, K, V> prev;
    private TrieMap`3<EqK, K, V> curr;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private TrieMap`3<EqK, K, Change`1<V>> changes;
    [NullableAttribute("2")]
private K key;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Change`1<V> change;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public HashMap`3<EqK, K, V> From { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public HashMap`3<EqK, K, V> To { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public HashMap`3<EqK, K, Change`1<V>> Changes { get; }
    internal HashMapPatch`3(TrieMap`3<EqK, K, V> prev, TrieMap`3<EqK, K, V> curr, TrieMap`3<EqK, K, Change`1<V>> changes);
    internal HashMapPatch`3(TrieMap`3<EqK, K, V> prev, TrieMap`3<EqK, K, V> curr, K key, Change`1<V> change);
    public HashMap`3<EqK, K, V> get_From();
    public HashMap`3<EqK, K, V> get_To();
    public HashMap`3<EqK, K, Change`1<V>> get_Changes();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.HashSet : object {
    [NullableContextAttribute("2")]
[PureAttribute]
public static bool isEmpty(HashSet`1<T> set);
    [NullableContextAttribute("2")]
[PureAttribute]
public static HashSet`1<T> create();
    [PureAttribute]
public static HashSet`1<A> singleton(A value);
    [PureAttribute]
public static HashSet`1<T> createRange(IEnumerable`1<T> range);
    [NullableContextAttribute("2")]
[PureAttribute]
public static HashSet`1<T> createRange(ReadOnlySpan`1<T> range);
    [NullableContextAttribute("2")]
[PureAttribute]
public static HashSet`1<T> empty();
    [PureAttribute]
public static HashSet`1<T> add(HashSet`1<T> set, T value);
    [PureAttribute]
public static HashSet`1<T> tryAdd(HashSet`1<T> set, T value);
    [PureAttribute]
public static HashSet`1<T> addOrUpdate(HashSet`1<T> set, T value);
    [PureAttribute]
public static Option`1<T> find(HashSet`1<T> set, T value);
    [PureAttribute]
public static bool exists(HashSet`1<T> set, Func`2<T, bool> pred);
    [NullableContextAttribute("2")]
[PureAttribute]
public static bool equals(HashSet`1<T> setA, HashSet`1<T> setB);
    [NullableContextAttribute("2")]
[PureAttribute]
public static int length(HashSet`1<T> set);
    [NullableContextAttribute("2")]
[PureAttribute]
public static HashSet`1<T> subtract(HashSet`1<T> setA, HashSet`1<T> setB);
    [NullableContextAttribute("2")]
[PureAttribute]
public static HashSet`1<T> union(HashSet`1<T> setA, HashSet`1<T> setB);
    [PureAttribute]
public static HashSet`1<T> filter(HashSet`1<T> set, Func`2<T, bool> pred);
    [PureAttribute]
public static S fold(HashSet`1<T> set, S state, Func`3<S, T, S> folder);
    [PureAttribute]
public static S foldBack(HashSet`1<T> set, S state, Func`3<S, T, S> folder);
    [PureAttribute]
public static HashSet`1<T> intersect(HashSet`1<T> setA, IEnumerable`1<T> setB);
    [PureAttribute]
public static HashSet`1<T> except(HashSet`1<T> setA, IEnumerable`1<T> setB);
    [PureAttribute]
public static HashSet`1<T> symmetricExcept(HashSet`1<T> setA, IEnumerable`1<T> setB);
    [NullableContextAttribute("2")]
[PureAttribute]
public static HashSet`1<R> map(HashSet`1<T> set, Func`2<T, R> mapper);
    [PureAttribute]
public static bool contains(HashSet`1<T> set, T value);
    [PureAttribute]
public static HashSet`1<T> remove(HashSet`1<T> set, T value);
    [PureAttribute]
public static bool isSubHSet(HashSet`1<T> setA, IEnumerable`1<T> setB);
    [PureAttribute]
public static bool isSuperHSet(HashSet`1<T> setA, IEnumerable`1<T> setB);
    [PureAttribute]
public static bool isProperSubHSet(HashSet`1<T> setA, IEnumerable`1<T> setB);
    [PureAttribute]
public static bool isProperSuperHSet(HashSet`1<T> setA, IEnumerable`1<T> setB);
    [PureAttribute]
public static bool overlaps(HashSet`1<T> setA, IEnumerable`1<T> setB);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool isEmpty(HashSet`2<EqT, T> set);
    [NullableContextAttribute("0")]
[PureAttribute]
public static HashSet`2<EqT, T> create();
    [PureAttribute]
public static HashSet`2<EqA, A> singleton(A value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static HashSet`2<EqA, A> createRange(ReadOnlySpan`1<A> range);
    [PureAttribute]
public static HashSet`2<EqT, T> createRange(IEnumerable`1<T> range);
    [NullableContextAttribute("0")]
[PureAttribute]
public static HashSet`2<EqT, T> empty();
    [PureAttribute]
public static HashSet`2<EqT, T> add(HashSet`2<EqT, T> set, T value);
    [PureAttribute]
public static HashSet`2<EqT, T> tryAdd(HashSet`2<EqT, T> set, T value);
    [PureAttribute]
public static HashSet`2<EqT, T> addOrUpdate(HashSet`2<EqT, T> set, T value);
    [PureAttribute]
public static Option`1<T> find(HashSet`2<EqT, T> set, T value);
    [PureAttribute]
public static bool exists(HashSet`2<EqT, T> set, Func`2<T, bool> pred);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool equals(HashSet`2<EqT, T> setA, HashSet`2<EqT, T> setB);
    [NullableContextAttribute("0")]
[PureAttribute]
public static int length(HashSet`2<EqT, T> set);
    [NullableContextAttribute("0")]
[PureAttribute]
public static HashSet`2<EqT, T> subtract(HashSet`2<EqT, T> setA, HashSet`2<EqT, T> setB);
    [NullableContextAttribute("0")]
[PureAttribute]
public static HashSet`2<EqT, T> union(HashSet`2<EqT, T> setA, HashSet`2<EqT, T> setB);
    [PureAttribute]
public static HashSet`2<EqT, T> filter(HashSet`2<EqT, T> set, Func`2<T, bool> pred);
    [PureAttribute]
public static S fold(HashSet`2<EqT, T> set, S state, Func`3<S, T, S> folder);
    [PureAttribute]
public static S foldBack(HashSet`2<EqT, T> set, S state, Func`3<S, T, S> folder);
    [NullableContextAttribute("0")]
[PureAttribute]
public static HashSet`2<EqT, T> intersect(HashSet`2<EqT, T> setA, HashSet`2<EqT, T> setB);
    [NullableContextAttribute("0")]
[PureAttribute]
public static HashSet`2<EqT, T> except(HashSet`2<EqT, T> setA, HashSet`2<EqT, T> setB);
    [NullableContextAttribute("0")]
[PureAttribute]
public static HashSet`2<EqT, T> symmetricExcept(HashSet`2<EqT, T> setA, HashSet`2<EqT, T> setB);
    [PureAttribute]
public static HashSet`2<EqR, R> map(HashSet`2<EqT, T> set, Func`2<T, R> mapper);
    [PureAttribute]
public static HashSet`2<EqT, T> map(HashSet`2<EqT, T> set, Func`2<T, T> mapper);
    [PureAttribute]
public static bool contains(HashSet`2<EqT, T> set, T value);
    [PureAttribute]
public static HashSet`2<EqT, T> remove(HashSet`2<EqT, T> set, T value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool isSubHSet(HashSet`2<EqT, T> setA, HashSet`2<EqT, T> setB);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool isSuperHSet(HashSet`2<EqT, T> setA, HashSet`2<EqT, T> setB);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool isProperSubHSet(HashSet`2<EqT, T> setA, HashSet`2<EqT, T> setB);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool isProperSuperHSet(HashSet`2<EqT, T> setA, HashSet`2<EqT, T> setB);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool overlaps(HashSet`2<EqT, T> setA, HashSet`2<EqT, T> setB);
    private static override K`2<HashSet, B> LanguageExt.Traits.Monad<LanguageExt.HashSet>.Bind(K`2<HashSet, A> ma, Func`2<A, K`2<HashSet, B>> f);
    private static override K`2<HashSet, B> LanguageExt.Traits.Functor<LanguageExt.HashSet>.Map(Func`2<A, B> f, K`2<HashSet, A> ma);
    private static override K`2<HashSet, A> LanguageExt.Traits.Applicative<LanguageExt.HashSet>.Pure(A value);
    private static override K`2<HashSet, B> LanguageExt.Traits.Applicative<LanguageExt.HashSet>.Apply(K`2<HashSet, Func`2<A, B>> mf, K`2<HashSet, A> ma);
    private static override K`2<HashSet, B> LanguageExt.Traits.Applicative<LanguageExt.HashSet>.Action(K`2<HashSet, A> ma, K`2<HashSet, B> mb);
    private static override K`2<HashSet, A> LanguageExt.Traits.MonoidK<LanguageExt.HashSet>.Empty();
    private static override K`2<HashSet, A> LanguageExt.Traits.SemigroupK<LanguageExt.HashSet>.Combine(K`2<HashSet, A> ma, K`2<HashSet, A> mb);
    private static override bool LanguageExt.Traits.Foldable<LanguageExt.HashSet>.Contains(A value, K`2<HashSet, A> ta);
    private static override int LanguageExt.Traits.Foldable<LanguageExt.HashSet>.Count(K`2<HashSet, A> ta);
    private static override bool LanguageExt.Traits.Foldable<LanguageExt.HashSet>.IsEmpty(K`2<HashSet, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.HashSet>.FoldWhile(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<HashSet, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.HashSet>.FoldBackWhile(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<HashSet, A> ta);
    private static override K`2<F, K`2<HashSet, B>> LanguageExt.Traits.Traversable<LanguageExt.HashSet>.Traverse(Func`2<A, K`2<F, B>> f, K`2<HashSet, A> ta);
    private static override K`2<F, K`2<HashSet, B>> LanguageExt.Traits.Traversable<LanguageExt.HashSet>.TraverseM(Func`2<A, K`2<F, B>> f, K`2<HashSet, A> ta);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[CollectionBuilderAttribute("LanguageExt.HashSet", "createRange")]
public class LanguageExt.HashSet`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static HashSet`1<A> <Empty>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private TrieSet`2<EqDefault`1<A>, A> value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static HashSet`1<A> Empty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal TrieSet`2<EqDefault`1<A>, A> Value { get; }
    [PureAttribute]
public A Item { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public int Length { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static HashSet`1<A> AdditiveIdentity { get; }
    internal HashSet`1(TrieSet`2<EqDefault`1<A>, A> value);
    public HashSet`1(ReadOnlySpan`1<A> items);
    public HashSet`1(ReadOnlySpan`1<A> items, bool tryAdd);
    public HashSet`1(IEnumerable`1<A> items);
    public HashSet`1(IEnumerable`1<A> items, bool tryAdd);
    private static HashSet`1();
    [CompilerGeneratedAttribute]
public static override HashSet`1<A> get_Empty();
    internal TrieSet`2<EqDefault`1<A>, A> get_Value();
    private HashSet`1<A> Wrap(TrieSet`2<EqDefault`1<A>, A> value);
    [NullableContextAttribute("2")]
private static HashSet`1<B> Wrap(TrieSet`2<EqDefault`1<B>, B> value);
    [PureAttribute]
public static Lens`2<HashSet`1<A>, bool> item(A key);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Lens`2<HashSet`1<A>, HashSet`1<A>> map(Lens`2<A, A> lens);
    public A get_Item(A key);
    public bool get_IsEmpty();
    public int get_Count();
    public int get_Length();
    public HashSet`1<A> Do(Action`1<A> f);
    [PureAttribute]
public HashSet`1<R> Map(Func`2<A, R> mapper);
    [PureAttribute]
public K`2<F, HashSet`1<B>> Traverse(Func`2<A, K`2<F, B>> f);
    [PureAttribute]
public K`2<M, HashSet`1<B>> TraverseM(Func`2<A, K`2<M, B>> f);
    [PureAttribute]
public HashSet`1<A> Filter(Func`2<A, bool> pred);
    [PureAttribute]
public HashSet`1<R> Select(Func`2<A, R> mapper);
    [PureAttribute]
public HashSet`1<A> Where(Func`2<A, bool> pred);
    [PureAttribute]
public HashSet`1<A> Add(A key);
    [PureAttribute]
public HashSet`1<A> TryAdd(A key);
    [PureAttribute]
public HashSet`1<A> AddOrUpdate(A key);
    [PureAttribute]
public HashSet`1<A> AddRange(IEnumerable`1<A> range);
    [PureAttribute]
public HashSet`1<A> TryAddRange(IEnumerable`1<A> range);
    [PureAttribute]
public HashSet`1<A> AddOrUpdateRange(IEnumerable`1<A> range);
    [PureAttribute]
public HashSet`1<A> Remove(A key);
    [PureAttribute]
public Option`1<A> Find(A key);
    [PureAttribute]
public Seq`1<A> FindSeq(A key);
    [PureAttribute]
public R Find(A key, Func`2<A, R> Some, Func`1<R> None);
    [PureAttribute]
public HashSet`1<A> SetItem(A key);
    [PureAttribute]
public HashSet`1<A> TrySetItem(A key);
    [PureAttribute]
public bool Contains(A key);
    [PureAttribute]
public HashSet`1<A> Clear();
    [PureAttribute]
public HashSet`1<A> SetItems(IEnumerable`1<A> items);
    [PureAttribute]
public HashSet`1<A> TrySetItems(IEnumerable`1<A> items);
    [PureAttribute]
public HashSet`1<A> RemoveRange(IEnumerable`1<A> keys);
    [PureAttribute]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public Seq`1<A> ToSeq();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToFullString(string separator);
    [PureAttribute]
public string ToFullArrayString(string separator);
    [PureAttribute]
public Iterable`1<A> AsIterable();
    [PureAttribute]
public static HashSet`1<A> op_Implicit(SeqEmpty _);
    [PureAttribute]
public static override HashSet`1<A> op_Addition(HashSet`1<A> lhs, HashSet`1<A> rhs);
    [PureAttribute]
public sealed virtual HashSet`1<A> Combine(HashSet`1<A> rhs);
    [PureAttribute]
public static override HashSet`1<A> op_Subtraction(HashSet`1<A> lhs, HashSet`1<A> rhs);
    [PureAttribute]
public HashSet`1<A> Subtract(HashSet`1<A> rhs);
    [PureAttribute]
public static override bool op_Equality(HashSet`1<A> lhs, HashSet`1<A> rhs);
    [PureAttribute]
public static override bool op_Inequality(HashSet`1<A> lhs, HashSet`1<A> rhs);
    [PureAttribute]
public sealed virtual bool Equals(HashSet`1<A> other);
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<A> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<A> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<A> other);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<A> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<A> rhs);
    [PureAttribute]
public HashSet`1<A> Intersect(IEnumerable`1<A> rhs);
    [PureAttribute]
public HashSet`1<A> Except(IEnumerable`1<A> rhs);
    [PureAttribute]
public HashSet`1<A> SymmetricExcept(HashSet`1<A> rhs);
    [PureAttribute]
public HashSet`1<A> SymmetricExcept(IEnumerable`1<A> rhs);
    [PureAttribute]
public HashSet`1<A> Union(IEnumerable`1<A> rhs);
    public Unit CopyTo(A[] array, int index);
    public Unit CopyTo(Array array, int index);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[PureAttribute]
public HashSet`1<B> Bind(Func`2<A, HashSet`1<B>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public HashSet`1<C> SelectMany(Func`2<A, HashSet`1<B>> bind, Func`3<A, B, C> project);
    public static override HashSet`1<A> get_AdditiveIdentity();
    [IteratorStateMachineAttribute("LanguageExt.HashSet`1/<<Map>g__Yield|24_0>d`1")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<R> <Map>g__Yield|24_0(TrieSet`2<EqDefault`1<A>, A> map, Func`2<A, R> f);
    [IteratorStateMachineAttribute("LanguageExt.HashSet`1/<<Filter>g__Yield|27_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<A> <Filter>g__Yield|27_0(TrieSet`2<EqDefault`1<A>, A> map, Func`2<A, bool> f);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[CollectionBuilderAttribute("LanguageExt.HashSet", "createRange")]
public class LanguageExt.HashSet`2 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static HashSet`2<EqA, A> <Empty>k__BackingField;
    private TrieSet`2<EqA, A> value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static HashSet`2<EqA, A> Empty { get; }
    private TrieSet`2<EqA, A> Value { get; }
    [PureAttribute]
public A Item { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public int Length { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static HashSet`2<EqA, A> AdditiveIdentity { get; }
    internal HashSet`2(TrieSet`2<EqA, A> value);
    public HashSet`2(IEnumerable`1<A> items);
    public HashSet`2(IEnumerable`1<A> items, bool tryAdd);
    public HashSet`2(ReadOnlySpan`1<A> items);
    public HashSet`2(ReadOnlySpan`1<A> items, bool tryAdd);
    private static HashSet`2();
    [CompilerGeneratedAttribute]
public static override HashSet`2<EqA, A> get_Empty();
    private TrieSet`2<EqA, A> get_Value();
    private HashSet`2<EqA, A> Wrap(TrieSet`2<EqA, A> value);
    [PureAttribute]
public static Lens`2<HashSet`2<EqA, A>, bool> item(A key);
    [PureAttribute]
public static Lens`2<HashSet`2<EqA, A>, HashSet`2<EqA, A>> map(Lens`2<A, A> lens);
    public A get_Item(A key);
    public bool get_IsEmpty();
    public int get_Count();
    public int get_Length();
    public HashSet`2<EqA, A> Do(Action`1<A> f);
    [PureAttribute]
public HashSet`2<EqR, R> Map(Func`2<A, R> mapper);
    [PureAttribute]
public HashSet`2<EqA, A> Map(Func`2<A, A> mapper);
    [PureAttribute]
public HashSet`2<EqA, A> Filter(Func`2<A, bool> pred);
    [PureAttribute]
public HashSet`2<EqR, R> Select(Func`2<A, R> mapper);
    [PureAttribute]
public HashSet`2<EqA, A> Where(Func`2<A, bool> pred);
    [PureAttribute]
public HashSet`2<EqA, A> Add(A key);
    [PureAttribute]
public HashSet`2<EqA, A> TryAdd(A key);
    [PureAttribute]
public HashSet`2<EqA, A> AddOrUpdate(A key);
    [PureAttribute]
public HashSet`2<EqA, A> AddRange(IEnumerable`1<A> range);
    [PureAttribute]
public HashSet`2<EqA, A> TryAddRange(IEnumerable`1<A> range);
    [PureAttribute]
public HashSet`2<EqA, A> AddOrUpdateRange(IEnumerable`1<A> range);
    [PureAttribute]
public HashSet`2<EqA, A> Remove(A key);
    [PureAttribute]
public Option`1<A> Find(A key);
    [PureAttribute]
public Seq`1<A> FindSeq(A key);
    [PureAttribute]
public R Find(A key, Func`2<A, R> Some, Func`1<R> None);
    [PureAttribute]
public HashSet`2<EqA, A> SetItem(A key);
    [PureAttribute]
public HashSet`2<EqA, A> TrySetItem(A key);
    [PureAttribute]
public bool Contains(A key);
    [PureAttribute]
public HashSet`2<EqA, A> Clear();
    [PureAttribute]
public HashSet`2<EqA, A> SetItems(IEnumerable`1<A> items);
    [PureAttribute]
public HashSet`2<EqA, A> TrySetItems(IEnumerable`1<A> items);
    [PureAttribute]
public HashSet`2<EqA, A> RemoveRange(IEnumerable`1<A> keys);
    [PureAttribute]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public Seq`1<A> ToSeq();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToFullString(string separator);
    [PureAttribute]
public string ToFullArrayString(string separator);
    [PureAttribute]
public Iterable`1<A> AsIterable();
    [PureAttribute]
public static HashSet`2<EqA, A> op_Implicit(SeqEmpty _);
    [PureAttribute]
public static override HashSet`2<EqA, A> op_Addition(HashSet`2<EqA, A> lhs, HashSet`2<EqA, A> rhs);
    [PureAttribute]
public sealed virtual HashSet`2<EqA, A> Combine(HashSet`2<EqA, A> rhs);
    [PureAttribute]
public static override HashSet`2<EqA, A> op_Subtraction(HashSet`2<EqA, A> lhs, HashSet`2<EqA, A> rhs);
    [PureAttribute]
public HashSet`2<EqA, A> Subtract(HashSet`2<EqA, A> rhs);
    [PureAttribute]
public static override bool op_Equality(HashSet`2<EqA, A> lhs, HashSet`2<EqA, A> rhs);
    [PureAttribute]
public static override bool op_Inequality(HashSet`2<EqA, A> lhs, HashSet`2<EqA, A> rhs);
    [PureAttribute]
public sealed virtual bool Equals(HashSet`2<EqA, A> other);
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<A> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<A> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<A> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<A> rhs);
    [PureAttribute]
public HashSet`2<EqA, A> Intersect(IEnumerable`1<A> rhs);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<A> other);
    [PureAttribute]
public HashSet`2<EqA, A> Except(IEnumerable`1<A> rhs);
    [PureAttribute]
public HashSet`2<EqA, A> SymmetricExcept(HashSet`2<EqA, A> rhs);
    [PureAttribute]
public HashSet`2<EqA, A> SymmetricExcept(IEnumerable`1<A> rhs);
    [PureAttribute]
public HashSet`2<EqA, A> Union(IEnumerable`1<A> rhs);
    public Unit CopyTo(A[] array, int index);
    public Unit CopyTo(Array array, int index);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[PureAttribute]
public HashSet`1<B> Bind(Func`2<A, HashSet`1<B>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public HashSet`1<C> SelectMany(Func`2<A, HashSet`1<B>> bind, Func`3<A, B, C> project);
    public static override HashSet`2<EqA, A> get_AdditiveIdentity();
    [IteratorStateMachineAttribute("LanguageExt.HashSet`2/<<Map>g__Yield|23_0>d`2")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<R> <Map>g__Yield|23_0(TrieSet`2<EqA, A> map, Func`2<A, R> f);
    [IteratorStateMachineAttribute("LanguageExt.HashSet`2/<<Filter>g__Yield|25_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<A> <Filter>g__Yield|25_0(TrieSet`2<EqA, A> map, Func`2<A, bool> f);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.HashSetExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static HashSet`1<A> As(K`2<HashSet, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static IQueryable`1<A> AsQueryable(HashSet`1<A> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Identity : object {
    public static override K`2<Identity, A> Pure(A value);
    public static Identity`1<B> bind(Identity`1<A> ma, Func`2<A, Identity`1<B>> f);
    public static Identity`1<B> map(Func`2<A, B> f, Identity`1<A> ma);
    public static Identity`1<B> apply(Identity`1<Func`2<A, B>> mf, Identity`1<A> ma);
    public static Identity`1<B> action(Identity`1<A> ma, Identity`1<B> mb);
    public static S fold(Func`2<A, Func`2<S, S>> f, S initialState, K`2<Identity, A> ta);
    public static S foldBack(Func`2<S, Func`2<A, S>> f, S initialState, K`2<Identity, A> ta);
    public static K`2<F, K`2<Identity, B>> traverse(Func`2<A, K`2<F, B>> f, K`2<Identity, A> ta);
    private static override K`2<Identity, B> LanguageExt.Traits.Monad<LanguageExt.Identity>.Bind(K`2<Identity, A> ma, Func`2<A, K`2<Identity, B>> f);
    private static override K`2<Identity, B> LanguageExt.Traits.Functor<LanguageExt.Identity>.Map(Func`2<A, B> f, K`2<Identity, A> ma);
    private static override K`2<Identity, B> LanguageExt.Traits.Applicative<LanguageExt.Identity>.Apply(K`2<Identity, Func`2<A, B>> mf, K`2<Identity, A> ma);
    private static override K`2<Identity, B> LanguageExt.Traits.Applicative<LanguageExt.Identity>.Action(K`2<Identity, A> ma, K`2<Identity, B> mb);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Identity>.FoldWhile(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S initialState, K`2<Identity, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Identity>.FoldBackWhile(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S initialState, K`2<Identity, A> ta);
    private static override K`2<F, K`2<Identity, B>> LanguageExt.Traits.Traversable<LanguageExt.Identity>.Traverse(Func`2<A, K`2<F, B>> f, K`2<Identity, A> ta);
    private static override K`2<Identity, A> LanguageExt.Traits.MonoidK<LanguageExt.Identity>.Empty();
    private static override K`2<Identity, A> LanguageExt.Traits.SemigroupK<LanguageExt.Identity>.Combine(K`2<Identity, A> ma, K`2<Identity, A> mb);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Identity`1 : object {
    [CompilerGeneratedAttribute]
private A <Value>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public A Value { get; public set; }
    public Identity`1(A Value);
    [CompilerGeneratedAttribute]
protected Identity`1(Identity`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public A get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(A value);
    public static Identity`1<A> Pure(A value);
    [PureAttribute]
public K`2<F, Identity`1<B>> Traverse(Func`2<A, K`2<F, B>> f);
    [PureAttribute]
public K`2<M, Identity`1<B>> TraverseM(Func`2<A, K`2<M, B>> f);
    [PureAttribute]
public virtual bool Equals(Identity`1<A> other);
    [PureAttribute]
public virtual int GetHashCode();
    [PureAttribute]
public Identity`1<B> Map(Func`2<A, B> f);
    [PureAttribute]
public Identity`1<B> Select(Func`2<A, B> f);
    [PureAttribute]
public Identity`1<B> Bind(Func`2<A, Identity`1<B>> f);
    [PureAttribute]
public Identity`1<B> Bind(Func`2<A, K`2<Identity, B>> f);
    [PureAttribute]
public Identity`1<C> SelectMany(Func`2<A, Identity`1<B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Identity`1<C> SelectMany(Func`2<A, K`2<Identity, B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public sealed virtual int CompareTo(Identity`1<A> other);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Identity`1<A> left, Identity`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Identity`1<A> left, Identity`1<A> right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual Identity`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(A& Value);
}
[ExtensionAttribute]
public static class LanguageExt.IdentityExt : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Identity`1<A> As(K`2<Identity, A> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.IdentityT`1 : object {
    public static override K`2<IdentityT`1<M>, A> Pure(A value);
    public static IdentityT`2<M, B> bind(IdentityT`2<M, A> ma, Func`2<A, IdentityT`2<M, B>> f);
    public static IdentityT`2<M, B> map(Func`2<A, B> f, IdentityT`2<M, A> ma);
    public static IdentityT`2<M, B> apply(IdentityT`2<M, Func`2<A, B>> mf, IdentityT`2<M, A> ma);
    public static IdentityT`2<M, B> action(IdentityT`2<M, A> ma, IdentityT`2<M, B> mb);
    private static override K`2<IdentityT`1<M>, B> LanguageExt.Traits.Monad<LanguageExt.IdentityT<M>>.Bind(K`2<IdentityT`1<M>, A> ma, Func`2<A, K`2<IdentityT`1<M>, B>> f);
    private static override K`2<IdentityT`1<M>, B> LanguageExt.Traits.Functor<LanguageExt.IdentityT<M>>.Map(Func`2<A, B> f, K`2<IdentityT`1<M>, A> ma);
    private static override K`2<IdentityT`1<M>, B> LanguageExt.Traits.Applicative<LanguageExt.IdentityT<M>>.Apply(K`2<IdentityT`1<M>, Func`2<A, B>> mf, K`2<IdentityT`1<M>, A> ma);
    private static override K`2<IdentityT`1<M>, B> LanguageExt.Traits.Applicative<LanguageExt.IdentityT<M>>.Action(K`2<IdentityT`1<M>, A> ma, K`2<IdentityT`1<M>, B> mb);
    private static override K`2<IdentityT`1<M>, A> LanguageExt.Traits.MonadT<LanguageExt.IdentityT<M>,M>.Lift(K`2<M, A> ma);
    private static override K`2<IdentityT`1<M>, A> LanguageExt.Traits.MonadIO<LanguageExt.IdentityT<M>>.LiftIO(IO`1<A> ma);
    private static override K`2<IdentityT`1<M>, IO`1<A>> LanguageExt.Traits.MonadIO<LanguageExt.IdentityT<M>>.ToIO(K`2<IdentityT`1<M>, A> ma);
    private static override K`2<IdentityT`1<M>, A> LanguageExt.Traits.SemigroupK<LanguageExt.IdentityT<M>>.Combine(K`2<IdentityT`1<M>, A> ma, K`2<IdentityT`1<M>, A> mb);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.IdentityT`2 : object {
    [CompilerGeneratedAttribute]
private K`2<M, A> <Value>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public K`2<M, A> Value { get; public set; }
    public IdentityT`2(K`2<M, A> Value);
    [CompilerGeneratedAttribute]
protected IdentityT`2(IdentityT`2<M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public K`2<M, A> get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(K`2<M, A> value);
    public static IdentityT`2<M, A> Pure(A value);
    public static IdentityT`2<M, A> Lift(K`2<M, A> value);
    [PureAttribute]
public IdentityT`2<M, B> Map(Func`2<A, B> f);
    public IdentityT`2<M, B> MapM(Func`2<K`2<M, A>, K`2<M, B>> f);
    [PureAttribute]
public IdentityT`2<M, B> Select(Func`2<A, B> f);
    [PureAttribute]
public IdentityT`2<M, B> Bind(Func`2<A, IdentityT`2<M, B>> f);
    [PureAttribute]
public IdentityT`2<M, B> Bind(Func`2<A, K`2<IdentityT`1<M>, B>> f);
    [PureAttribute]
public IdentityT`2<M, B> Bind(Func`2<A, Pure`1<B>> f);
    [PureAttribute]
public IdentityT`2<M, B> Bind(Func`2<A, IO`1<B>> f);
    [PureAttribute]
public IdentityT`2<M, C> SelectMany(Func`2<A, IdentityT`2<M, B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public IdentityT`2<M, C> SelectMany(Func`2<A, K`2<IdentityT`1<M>, B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public IdentityT`2<M, C> SelectMany(Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public IdentityT`2<M, C> SelectMany(Func`2<A, IO`1<B>> bind, Func`3<A, B, C> project);
    public static IdentityT`2<M, A> op_RightShift(IdentityT`2<M, A> lhs, IdentityT`2<M, A> rhs);
    public static IdentityT`2<M, A> op_RightShift(IdentityT`2<M, A> lhs, K`2<IdentityT`1<M>, A> rhs);
    public static IdentityT`2<M, A> op_RightShift(IdentityT`2<M, A> lhs, IdentityT`2<M, Unit> rhs);
    public static IdentityT`2<M, A> op_RightShift(IdentityT`2<M, A> lhs, K`2<IdentityT`1<M>, Unit> rhs);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(IdentityT`2<M, A> left, IdentityT`2<M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(IdentityT`2<M, A> left, IdentityT`2<M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(IdentityT`2<M, A> other);
    [CompilerGeneratedAttribute]
public virtual IdentityT`2<M, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(K`2& Value);
}
[ExtensionAttribute]
public static class LanguageExt.IdentityTExt : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IdentityT`2<M, A> As(K`2<IdentityT`1<M>, A> ma);
}
[NullableContextAttribute("1")]
public interface LanguageExt.IEither {
    public bool IsRight { get; }
    public bool IsLeft { get; }
    public abstract virtual bool get_IsRight();
    public abstract virtual bool get_IsLeft();
    public abstract virtual R MatchUntyped(Func`2<object, R> Right, Func`2<object, R> Left);
    public abstract virtual Type GetUnderlyingRightType();
    public abstract virtual Type GetUnderlyingLeftType();
}
public class LanguageExt.IgnoreBaseAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.IL : object {
    public static Func`1<R> Ctor();
    [NullableContextAttribute("2")]
public static Func`2<A, R> Ctor();
    [NullableContextAttribute("2")]
public static Func`3<A, B, R> Ctor();
    [NullableContextAttribute("2")]
public static Func`4<A, B, C, R> Ctor();
    [NullableContextAttribute("2")]
public static Func`5<A, B, C, D, R> Ctor();
    [NullableContextAttribute("2")]
public static Option`1<Func`2<object, R>> Func1(Type arg1, Func`2<MethodInfo, bool> methodPred);
    [NullableContextAttribute("2")]
public static Option`1<Func`2<A, R>> Func1(Func`2<MethodInfo, bool> methodPred);
    [NullableContextAttribute("2")]
public static Option`1<Func`3<A, B, R>> Func2(Func`2<MethodInfo, bool> methodPred);
    [NullableContextAttribute("2")]
public static Option`1<Func`4<A, B, C, R>> Func3(Func`2<MethodInfo, bool> methodPred);
    [NullableContextAttribute("2")]
public static Option`1<Func`5<A, B, C, D, R>> Func4(Func`2<MethodInfo, bool> methodPred);
    public static Func`2<A, int> GetHashCode(bool includeBase);
    public static Func`3<A, object, bool> Equals(bool includeBase);
    public static Func`3<A, A, bool> EqualsTyped(bool includeBase);
    public static Func`3<A, A, int> Compare(bool includeBase);
    private static Func`2<A, string> ToStringExpr(bool includeBase);
    public static Func`2<A, string> ToString(bool includeBase);
    private static Action`2<A, SerializationInfo> GetObjectDataExpr(bool includeBase);
    public static Action`2<A, SerializationInfo> GetObjectData(bool includeBase);
    private static Action`2<A, SerializationInfo> SetObjectDataExpr(bool includeBase);
    public static Action`2<A, SerializationInfo> SetObjectData(bool includeBase);
    [NullableContextAttribute("2")]
public static Func`2<A, B> GetPropertyOrField(string name);
    [NullableContextAttribute("2")]
public static Func`2<A, B> GetProperty(string name);
    [NullableContextAttribute("2")]
public static Func`2<A, B> GetField(string name);
    private static string PrettyFieldName(FieldInfo field);
}
public static class LanguageExt.ILCapability : object {
    public static bool Available;
    private static ILCapability();
    private static bool GetAvailability();
    [NullableContextAttribute("1")]
private static Func`1<SystemException> TestSystemExceptionCtor();
}
[NullableContextAttribute("2")]
internal interface LanguageExt.IMapItem`2 {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<K, V> KeyValue { get; }
    public abstract virtual ValueTuple`2<K, V> get_KeyValue();
}
internal static class LanguageExt.Inter : object {
    public static int And(Int32& loc, int value);
}
public interface LanguageExt.InvariantCulture`1 {
    private static StringComparison LanguageExt.HashableString<STRING>.Comparison { get; }
    private static override StringComparison LanguageExt.HashableString<STRING>.get_Comparison();
}
public interface LanguageExt.InvariantIgnoreCase`1 {
    private static StringComparison LanguageExt.HashableString<STRING>.Comparison { get; }
    private static override StringComparison LanguageExt.HashableString<STRING>.get_Comparison();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.IO : object {
    public static IO`1<EnvIO> env;
    public static IO`1<CancellationToken> token;
    public static IO`1<CancellationTokenSource> source;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IO`1<Option`1<SynchronizationContext>> syncContext;
    private static IO();
    public static IO`1<A> fail(Error value);
    public static IO`1<A> fail(string value);
    public static IO`1<Unit> lift(Action f);
    public static K`2<M, A> local(K`2<M, A> ma);
    public static IO`1<A> lift(Either`2<Error, A> ma);
    public static IO`1<A> lift(Fin`1<A> ma);
    public static IO`1<A> lift(Func`1<A> f);
    public static IO`1<A> lift(Func`2<EnvIO, A> f);
    public static IO`1<A> lift(Func`1<Fin`1<A>> f);
    public static IO`1<A> lift(Func`2<EnvIO, Fin`1<A>> f);
    public static IO`1<A> lift(Func`1<Either`2<Error, A>> f);
    public static IO`1<A> lift(Func`2<EnvIO, Either`2<Error, A>> f);
    public static IO`1<A> liftAsync(Func`1<Task`1<A>> f);
    public static IO`1<A> liftAsync(Func`2<EnvIO, Task`1<A>> f);
    public static IO`1<B> bind(K`2<IO, A> ma, Func`2<A, K`2<IO, B>> f);
    public static IO`1<B> map(Func`2<A, B> f, K`2<IO, A> ma);
    public static IO`1<B> map(Func`2<A, B> f, IO`1<A> ma);
    public static IO`1<B> apply(K`2<IO, Func`2<A, B>> mf, K`2<IO, A> ma);
    public static IO`1<B> action(K`2<IO, A> ma, K`2<IO, B> mb);
    public static IO`1<A> empty();
    public static IO`1<A> or(K`2<IO, A> ma, K`2<IO, A> mb);
    [PureAttribute]
public static K`2<M, B> mapIO(K`2<M, A> ma, Func`2<IO`1<A>, IO`1<B>> f);
    [NullableContextAttribute("0")]
[PureAttribute]
public static IO`1<ForkIO`1<A>> fork(K`2<IO, A> ma, Option`1<TimeSpan> timeout);
    [NullableContextAttribute("0")]
[PureAttribute]
public static K`2<M, ForkIO`1<A>> fork(K`2<M, A> ma, Option`1<TimeSpan> timeout);
    [PureAttribute]
public static IO`1<Unit> yield(double milliseconds);
    [AsyncStateMachineAttribute("LanguageExt.IO/<yieldFor>d__29")]
internal static Task`1<Unit> yieldFor(Duration d, CancellationToken token);
    public static IO`1<A> pure(A value);
    private static override K`2<IO, B> LanguageExt.Traits.Monad<LanguageExt.IO>.Bind(K`2<IO, A> ma, Func`2<A, K`2<IO, B>> f);
    private static override K`2<IO, B> LanguageExt.Traits.Functor<LanguageExt.IO>.Map(Func`2<A, B> f, K`2<IO, A> ma);
    private static override K`2<IO, A> LanguageExt.Traits.Applicative<LanguageExt.IO>.Pure(A value);
    private static override K`2<IO, B> LanguageExt.Traits.Applicative<LanguageExt.IO>.Apply(K`2<IO, Func`2<A, B>> mf, K`2<IO, A> ma);
    private static IO`1<B> ApplyAsyncAsync(IOAsync`1<Func`2<A, B>> mf, IOAsync`1<A> ma);
    private static IO`1<B> ApplyAsyncSync(IOAsync`1<Func`2<A, B>> mf, IO`1<A> ma);
    private static IO`1<B> ApplySyncAsync(IO`1<Func`2<A, B>> mf, IOAsync`1<A> ma);
    private static IO`1<B> ApplySyncSync(IO`1<Func`2<A, B>> mf, IO`1<A> ma);
    private static override K`2<IO, B> LanguageExt.Traits.Applicative<LanguageExt.IO>.Action(K`2<IO, A> ma, K`2<IO, B> mb);
    private static override K`2<IO, A> LanguageExt.Traits.Applicative<LanguageExt.IO>.Actions(IEnumerable`1<K`2<IO, A>> fas);
    private static override K`2<IO, A> LanguageExt.Traits.MonoidK<LanguageExt.IO>.Empty();
    private static override K`2<IO, A> LanguageExt.Traits.SemigroupK<LanguageExt.IO>.Combine(K`2<IO, A> ma, K`2<IO, A> mb);
    private static override K`2<IO, A> LanguageExt.Traits.MonadIO<LanguageExt.IO>.LiftIO(IO`1<A> ma);
    private static override K`2<IO, IO`1<A>> LanguageExt.Traits.MonadIO<LanguageExt.IO>.ToIO(K`2<IO, A> ma);
    private static override K`2<IO, B> LanguageExt.Traits.MonadIO<LanguageExt.IO>.MapIO(K`2<IO, A> ma, Func`2<IO`1<A>, IO`1<B>> f);
    private static override K`2<IO, A> LanguageExt.Traits.Fallible<LanguageExt.Common.Error,LanguageExt.IO>.Fail(Error error);
    private static override K`2<IO, A> LanguageExt.Traits.Fallible<LanguageExt.Common.Error,LanguageExt.IO>.Catch(K`2<IO, A> fa, Func`2<Error, bool> Predicate, Func`2<Error, K`2<IO, A>> Fail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.IO`1 : object {
    public static IO`1<A> Empty;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected IO`1(IO`1<A> original);
    private static IO`1();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public static IO`1<A> Pure(A value);
    public static IO`1<A> Fail(Error value);
    public static IO`1<A> Lift(Func`1<A> f);
    public static IO`1<A> Lift(Func`1<IOResponse`1<A>> f);
    public static IO`1<A> Lift(Func`2<EnvIO, A> f);
    public static IO`1<A> Lift(Func`2<EnvIO, IOResponse`1<A>> f);
    public static IO`1<A> LiftAsync(Func`1<Task`1<IOResponse`1<A>>> f);
    public static IO`1<A> LiftAsync(Func`2<EnvIO, Task`1<IOResponse`1<A>>> f);
    public static IO`1<A> LiftAsync(Func`1<Task`1<A>> f);
    public static IO`1<A> LiftAsync(Func`2<EnvIO, Task`1<A>> f);
    public abstract virtual IO`1<B> Map(Func`2<A, B> f);
    public IO`1<B> Map(B value);
    public IO`1<A> MapFail(Func`2<Error, Error> f);
    public IO`1<B> BiMap(Func`2<A, B> Succ, Func`2<Error, Error> Fail);
    public IO`1<B> Match(Func`2<A, B> Succ, Func`2<Error, B> Fail);
    public IO`1<A> IfFail(Func`2<Error, A> Fail);
    public IO`1<A> IfFail(A Fail);
    public IO`1<A> IfFail(Func`2<Error, IO`1<A>> Fail);
    public IO`1<A> IfFail(IO`1<A> Fail);
    public IO`1<S> Fold(Schedule schedule, S initialState, Func`3<S, A, S> folder);
    public IO`1<S> Fold(S initialState, Func`3<S, A, S> folder);
    public IO`1<S> FoldWhile(Schedule schedule, S initialState, Func`3<S, A, S> folder, Func`2<S, bool> stateIs);
    public IO`1<S> FoldWhile(S initialState, Func`3<S, A, S> folder, Func`2<S, bool> stateIs);
    public IO`1<S> FoldWhile(Schedule schedule, S initialState, Func`3<S, A, S> folder, Func`2<A, bool> valueIs);
    public IO`1<S> FoldWhile(S initialState, Func`3<S, A, S> folder, Func`2<A, bool> valueIs);
    public IO`1<S> FoldWhile(Schedule schedule, S initialState, Func`3<S, A, S> folder, Func`2<ValueTuple`2<S, A>, bool> predicate);
    public IO`1<S> FoldWhile(S initialState, Func`3<S, A, S> folder, Func`2<ValueTuple`2<S, A>, bool> predicate);
    public IO`1<S> FoldUntil(Schedule schedule, S initialState, Func`3<S, A, S> folder, Func`2<S, bool> stateIs);
    public IO`1<S> FoldUntil(S initialState, Func`3<S, A, S> folder, Func`2<S, bool> stateIs);
    public IO`1<S> FoldUntil(Schedule schedule, S initialState, Func`3<S, A, S> folder, Func`2<A, bool> valueIs);
    public IO`1<S> FoldUntil(S initialState, Func`3<S, A, S> folder, Func`2<A, bool> valueIs);
    public IO`1<S> FoldUntil(S initialState, Func`3<S, A, S> folder, Func`2<ValueTuple`2<S, A>, bool> predicate);
    public abstract virtual IO`1<S> FoldUntil(Schedule schedule, S initialState, Func`3<S, A, S> folder, Func`2<ValueTuple`2<S, A>, bool> predicate);
    public abstract virtual IO`1<A> Post();
    public abstract virtual IO`1<B> Bind(Func`2<A, IO`1<B>> f);
    public IO`1<B> Bind(Func`2<A, K`2<IO, B>> f);
    public IO`1<B> Bind(Func`2<A, Pure`1<B>> f);
    public IO`1<B> Select(Func`2<A, B> f);
    public IO`1<C> SelectMany(Func`2<A, IO`1<B>> bind, Func`3<A, B, C> project);
    public IO`1<C> SelectMany(Func`2<A, K`2<IO, B>> bind, Func`3<A, B, C> project);
    public IO`1<C> SelectMany(Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    public OptionT`2<M, C> SelectMany(Func`2<A, OptionT`2<M, B>> bind, Func`3<A, B, C> project);
    public TryT`2<M, C> SelectMany(Func`2<A, TryT`2<M, B>> bind, Func`3<A, B, C> project);
    public EitherT`3<L, M, C> SelectMany(Func`2<A, EitherT`3<L, M, B>> bind, Func`3<A, B, C> project);
    public FinT`2<M, C> SelectMany(Func`2<A, FinT`2<M, B>> bind, Func`3<A, B, C> project);
    public ValidationT`3<F, M, C> SelectMany(Func`2<A, ValidationT`3<F, M, B>> bind, Func`3<A, B, C> project);
    public ReaderT`3<Env, M, C> SelectMany(Func`2<A, ReaderT`3<Env, M, B>> bind, Func`3<A, B, C> project);
    public StateT`3<S, M, C> SelectMany(Func`2<A, StateT`3<S, M, B>> bind, Func`3<A, B, C> project);
    public Eff`1<C> SelectMany(Func`2<A, Eff`1<B>> bind, Func`3<A, B, C> project);
    public Eff`2<RT, C> SelectMany(Func`2<A, Eff`2<RT, B>> bind, Func`3<A, B, C> project);
    public IO`1<C> SelectMany(Func`2<A, Guard`2<Error, Unit>> bind, Func`3<A, Unit, C> project);
    public static override IO`1<A> op_BitwiseOr(IO`1<A> lhs, IO`1<A> rhs);
    public static override IO`1<A> op_BitwiseOr(IO`1<A> lhs, K`2<IO, A> rhs);
    public static override IO`1<A> op_BitwiseOr(K`2<IO, A> lhs, IO`1<A> rhs);
    public static override IO`1<A> op_BitwiseOr(IO`1<A> lhs, Pure`1<A> rhs);
    public static override IO`1<A> op_BitwiseOr(IO`1<A> lhs, Fail`1<Error> rhs);
    public static override IO`1<A> op_BitwiseOr(IO`1<A> lhs, CatchM`3<Error, IO, A> rhs);
    public static IO`1<A> op_BitwiseOr(IO`1<A> lhs, A rhs);
    public static IO`1<A> op_RightShift(IO`1<A> lhs, IO`1<A> rhs);
    public static IO`1<A> op_RightShift(IO`1<A> lhs, K`2<IO, A> rhs);
    public static IO`1<A> op_RightShift(IO`1<A> lhs, IO`1<Unit> rhs);
    public static IO`1<A> op_RightShift(IO`1<A> lhs, K`2<IO, Unit> rhs);
    [PureAttribute]
public abstract virtual IO`1<A> Bracket();
    public IO`1<C> Bracket(Func`2<A, IO`1<C>> Use, Func`2<A, IO`1<B>> Finally);
    public abstract virtual IO`1<C> Bracket(Func`2<A, IO`1<C>> Use, Func`2<Error, IO`1<C>> Catch, Func`2<A, IO`1<B>> Finally);
    public static override IO`1<A> op_Implicit(Pure`1<A> ma);
    public static IO`1<A> op_Implicit(Error error);
    public static override IO`1<A> op_Implicit(Fail`1<Error> ma);
    public static IO`1<A> op_Implicit(Fail`1<Exception> ma);
    public static IO`1<A> op_Implicit(Lift`2<EnvIO, A> ma);
    public static IO`1<A> op_Implicit(Lift`1<A> ma);
    public IO`1<A> Timeout(TimeSpan timeout);
    public abstract virtual IO`1<A> Local();
    [NullableContextAttribute("0")]
public abstract virtual IO`1<ForkIO`1<A>> Fork(Option`1<TimeSpan> timeout);
    [NullableContextAttribute("2")]
public abstract virtual ValueTask`1<A> RunAsync(EnvIO envIO);
    public abstract virtual A Run(EnvIO envIO);
    public FinT`2<IO, A> Try();
    public IO`1<A> Repeat();
    public IO`1<A> Repeat(Schedule schedule);
    public IO`1<A> RepeatWhile(Func`2<A, bool> predicate);
    public IO`1<A> RepeatWhile(Schedule schedule, Func`2<A, bool> predicate);
    public abstract virtual IO`1<A> RepeatUntil(Func`2<A, bool> predicate);
    public abstract virtual IO`1<A> RepeatUntil(Schedule schedule, Func`2<A, bool> predicate);
    public IO`1<A> Retry();
    public IO`1<A> Retry(Schedule schedule);
    public IO`1<A> RetryWhile(Func`2<Error, bool> predicate);
    public IO`1<A> RetryWhile(Schedule schedule, Func`2<Error, bool> predicate);
    public abstract virtual IO`1<A> RetryUntil(Func`2<Error, bool> predicate);
    public abstract virtual IO`1<A> RetryUntil(Schedule schedule, Func`2<Error, bool> predicate);
    public abstract virtual IO`1<A> Catch(Func`2<Error, bool> Predicate, Func`2<Error, K`2<IO, A>> Fail);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(IO`1<A> left, IO`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(IO`1<A> left, IO`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(IO`1<A> other);
    [CompilerGeneratedAttribute]
public abstract virtual IO`1<A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class LanguageExt.IOAsync`1 : IO`1<A> {
    [CompilerGeneratedAttribute]
private Func`2<EnvIO, Task`1<IOResponse`1<A>>> <runIO>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Func`2<EnvIO, Task`1<IOResponse`1<A>>> runIO { get; public set; }
    public IOAsync`1(Func`2<EnvIO, Task`1<IOResponse`1<A>>> runIO);
    [CompilerGeneratedAttribute]
protected IOAsync`1(IOAsync`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Func`2<EnvIO, Task`1<IOResponse`1<A>>> get_runIO();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_runIO(Func`2<EnvIO, Task`1<IOResponse`1<A>>> value);
    public virtual IO`1<B> Map(Func`2<A, B> f);
    public virtual IO`1<S> FoldUntil(Schedule schedule, S initialState, Func`3<S, A, S> folder, Func`2<ValueTuple`2<S, A>, bool> predicate);
    public virtual IO`1<A> Post();
    public virtual IO`1<B> Bind(Func`2<A, IO`1<B>> f);
    [PureAttribute]
public virtual IO`1<A> Bracket();
    public virtual IO`1<C> Bracket(Func`2<A, IO`1<C>> Use, Func`2<Error, IO`1<C>> Catch, Func`2<A, IO`1<B>> Finally);
    public virtual IO`1<A> Local();
    [NullableContextAttribute("0")]
public virtual IO`1<ForkIO`1<A>> Fork(Option`1<TimeSpan> timeout);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("LanguageExt.IOAsync`1/<RunAsync>d__15")]
public virtual ValueTask`1<A> RunAsync(EnvIO env);
    public virtual A Run(EnvIO env);
    public virtual IO`1<A> RepeatUntil(Schedule schedule, Func`2<A, bool> predicate);
    public virtual IO`1<A> RepeatUntil(Func`2<A, bool> predicate);
    public virtual IO`1<A> RetryUntil(Schedule schedule, Func`2<Error, bool> predicate);
    public virtual IO`1<A> RetryUntil(Func`2<Error, bool> predicate);
    [AsyncStateMachineAttribute("LanguageExt.IOAsync`1/<AwaitAsync>d__21")]
private Task`1<IOResponse`1<A>> AwaitAsync(Task`1<IOResponse`1<A>> t, EnvIO envIO, CancellationToken token, CancellationTokenSource source);
    public virtual IO`1<A> Catch(Func`2<Error, bool> Predicate, Func`2<Error, K`2<IO, A>> Fail);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(IOAsync`1<A> left, IOAsync`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(IOAsync`1<A> left, IOAsync`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(IO`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(IOAsync`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override IOAsync`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`2& runIO);
    [AsyncStateMachineAttribute("LanguageExt.IOAsync`1/<<Post>b__9_0>d")]
[CompilerGeneratedAttribute]
private Task`1<IOResponse`1<A>> <Post>b__9_0(EnvIO env);
    [AsyncStateMachineAttribute("LanguageExt.IOAsync`1/<<Bracket>b__11_0>d")]
[CompilerGeneratedAttribute]
private Task`1<IOResponse`1<A>> <Bracket>b__11_0(EnvIO env);
    [AsyncStateMachineAttribute("LanguageExt.IOAsync`1/<<Local>b__13_0>d")]
[CompilerGeneratedAttribute]
private Task`1<IOResponse`1<A>> <Local>b__13_0(EnvIO env);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.IOExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static IO`1<A> As(K`2<IO, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static A Run(K`2<IO, A> ma, EnvIO envIO);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<A> RunAsync(K`2<IO, A> ma, EnvIO envIO);
    [ExtensionAttribute]
public static IO`1<A> Flatten(Task`1<IO`1<A>> tma);
    [ExtensionAttribute]
[PureAttribute]
public static IO`1<A> Flatten(IO`1<IO`1<A>> mma);
    [ExtensionAttribute]
[PureAttribute]
public static IO`1<C> SelectMany(K`2<IO, A> ma, Func`2<A, K`2<IO, B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
public static K`2<M, A> LocalIO(K`2<M, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static IO`1<B> Apply(IO`1<Func`2<A, B>> ff, IO`1<A> fa);
    [ExtensionAttribute]
[PureAttribute]
public static IO`1<B> Action(IO`1<A> fa, IO`1<B> fb);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<M, A> PostIO(K`2<M, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<M, A> Await(K`2<M, ForkIO`1<A>> ma);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[PureAttribute]
public static K`2<M, ForkIO`1<A>> ForkIO(K`2<M, A> ma, Option`1<TimeSpan> timeout);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<M, A> TimeoutIO(K`2<M, A> ma, TimeSpan timeout);
    [ExtensionAttribute]
[PureAttribute]
public static K`2<M, A> BracketIO(K`2<M, A> ma);
    [ExtensionAttribute]
public static K`2<M, C> BracketIO(K`2<M, A> acq, Func`2<A, IO`1<C>> Use, Func`2<A, IO`1<B>> Finally);
    [ExtensionAttribute]
public static K`2<M, C> BracketIO(K`2<M, A> acq, Func`2<A, IO`1<C>> Use, Func`2<Error, IO`1<C>> Catch, Func`2<A, IO`1<B>> Finally);
    [ExtensionAttribute]
public static K`2<M, A> RepeatIO(K`2<M, A> ma);
    [ExtensionAttribute]
public static K`2<M, A> RepeatIO(K`2<M, A> ma, Schedule schedule);
    [ExtensionAttribute]
public static K`2<M, A> RepeatWhileIO(K`2<M, A> ma, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, A> RepeatWhileIO(K`2<M, A> ma, Schedule schedule, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, A> RepeatUntilIO(K`2<M, A> ma, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, A> RepeatUntilIO(K`2<M, A> ma, Schedule schedule, Func`2<A, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, A> RetryIO(K`2<M, A> ma);
    [ExtensionAttribute]
public static K`2<M, A> RetryIO(K`2<M, A> ma, Schedule schedule);
    [ExtensionAttribute]
public static K`2<M, A> RetryWhileIO(K`2<M, A> ma, Func`2<Error, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, A> RetryWhileIO(K`2<M, A> ma, Schedule schedule, Func`2<Error, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, A> RetryUntilIO(K`2<M, A> ma, Func`2<Error, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, A> RetryUntilIO(K`2<M, A> ma, Schedule schedule, Func`2<Error, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, S> FoldIO(K`2<M, A> ma, Schedule schedule, S initialState, Func`3<S, A, S> folder);
    [ExtensionAttribute]
public static K`2<M, S> FoldIO(K`2<M, A> ma, S initialState, Func`3<S, A, S> folder);
    [ExtensionAttribute]
public static K`2<M, S> FoldWhileIO(K`2<M, A> ma, Schedule schedule, S initialState, Func`3<S, A, S> folder, Func`2<S, bool> stateIs);
    [ExtensionAttribute]
public static K`2<M, S> FoldWhileIO(K`2<M, A> ma, S initialState, Func`3<S, A, S> folder, Func`2<S, bool> stateIs);
    [ExtensionAttribute]
public static K`2<M, S> FoldWhileIO(K`2<M, A> ma, Schedule schedule, S initialState, Func`3<S, A, S> folder, Func`2<A, bool> valueIs);
    [ExtensionAttribute]
public static K`2<M, S> FoldWhileIO(K`2<M, A> ma, S initialState, Func`3<S, A, S> folder, Func`2<A, bool> valueIs);
    [ExtensionAttribute]
public static K`2<M, S> FoldWhileIO(K`2<M, A> ma, Schedule schedule, S initialState, Func`3<S, A, S> folder, Func`2<ValueTuple`2<S, A>, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, S> FoldWhileIO(K`2<M, A> ma, S initialState, Func`3<S, A, S> folder, Func`2<ValueTuple`2<S, A>, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, S> FoldUntilIO(K`2<M, A> ma, Schedule schedule, S initialState, Func`3<S, A, S> folder, Func`2<S, bool> stateIs);
    [ExtensionAttribute]
public static K`2<M, S> FoldUntilIO(K`2<M, A> ma, S initialState, Func`3<S, A, S> folder, Func`2<S, bool> stateIs);
    [ExtensionAttribute]
public static K`2<M, S> FoldUntilIO(K`2<M, A> ma, Schedule schedule, S initialState, Func`3<S, A, S> folder, Func`2<A, bool> valueIs);
    [ExtensionAttribute]
public static K`2<M, S> FoldUntilIO(K`2<M, A> ma, S initialState, Func`3<S, A, S> folder, Func`2<A, bool> valueIs);
    [ExtensionAttribute]
public static K`2<M, S> FoldUntilIO(K`2<M, A> ma, S initialState, Func`3<S, A, S> folder, Func`2<ValueTuple`2<S, A>, bool> predicate);
    [ExtensionAttribute]
public static K`2<M, S> FoldUntilIO(K`2<M, A> ma, Schedule schedule, S initialState, Func`3<S, A, S> folder, Func`2<ValueTuple`2<S, A>, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static K`2<M, ValueTuple`2<A, B>> ZipIO(ValueTuple`2<K`2<M, A>, K`2<M, B>> tuple);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static K`2<M, ValueTuple`3<A, B, C>> ZipIO(ValueTuple`3<K`2<M, A>, K`2<M, B>, K`2<M, C>> tuple);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static K`2<M, ValueTuple`4<A, B, C, D>> ZipIO(ValueTuple`4<K`2<M, A>, K`2<M, B>, K`2<M, C>, K`2<M, D>> tuple);
    [ExtensionAttribute]
public static K`2<M, ValueTuple`2<A, B>> ZipIO(K`2<M, A> First, K`2<M, B> Second);
    [ExtensionAttribute]
public static K`2<M, ValueTuple`3<A, B, C>> ZipIO(K`2<M, A> First, K`2<M, B> Second, K`2<M, C> Third);
    [ExtensionAttribute]
public static K`2<M, ValueTuple`4<A, B, C, D>> ZipIO(K`2<M, A> First, K`2<M, B> Second, K`2<M, C> Third, K`2<M, D> Fourth);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class LanguageExt.IOFail`1 : IO`1<A> {
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Error Error { get; public set; }
    public IOFail`1(Error Error);
    [CompilerGeneratedAttribute]
protected IOFail`1(IOFail`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Error(Error value);
    public IO`1<A> ToSync();
    public IO`1<A> ToAsync();
    public virtual IO`1<B> Map(Func`2<A, B> f);
    public virtual IO`1<S> FoldUntil(Schedule schedule, S initialState, Func`3<S, A, S> folder, Func`2<ValueTuple`2<S, A>, bool> predicate);
    public virtual IO`1<A> Post();
    public virtual IO`1<B> Bind(Func`2<A, IO`1<B>> f);
    public virtual IO`1<A> Bracket();
    public virtual IO`1<C> Bracket(Func`2<A, IO`1<C>> Use, Func`2<Error, IO`1<C>> Catch, Func`2<A, IO`1<B>> Finally);
    public virtual IO`1<A> Local();
    [NullableContextAttribute("0")]
public virtual IO`1<ForkIO`1<A>> Fork(Option`1<TimeSpan> timeout);
    [NullableContextAttribute("2")]
public virtual ValueTask`1<A> RunAsync(EnvIO envIO);
    public virtual A Run(EnvIO envIO);
    public virtual IO`1<A> RepeatUntil(Func`2<A, bool> predicate);
    public virtual IO`1<A> RepeatUntil(Schedule schedule, Func`2<A, bool> predicate);
    public virtual IO`1<A> RetryUntil(Func`2<Error, bool> predicate);
    public virtual IO`1<A> RetryUntil(Schedule schedule, Func`2<Error, bool> predicate);
    public virtual IO`1<A> Catch(Func`2<Error, bool> Predicate, Func`2<Error, K`2<IO, A>> Fail);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(IOFail`1<A> left, IOFail`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(IOFail`1<A> left, IOFail`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(IO`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(IOFail`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override IOFail`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Error& Error);
    [CompilerGeneratedAttribute]
private IOResponse`1<A> <ToSync>b__7_0(EnvIO _);
    [CompilerGeneratedAttribute]
private Task`1<IOResponse`1<A>> <ToAsync>b__8_0(EnvIO _);
}
[NullableContextAttribute("1")]
public interface LanguageExt.IOptional {
    public bool IsSome { get; }
    public bool IsNone { get; }
    public abstract virtual bool get_IsSome();
    public abstract virtual bool get_IsNone();
    public abstract virtual R MatchUntyped(Func`2<object, R> Some, Func`1<R> None);
    public abstract virtual Type GetUnderlyingType();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class LanguageExt.IOPure`1 : IO`1<A> {
    [CompilerGeneratedAttribute]
private A <Value>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public A Value { get; public set; }
    public IOPure`1(A Value);
    [CompilerGeneratedAttribute]
protected IOPure`1(IOPure`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public A get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(A value);
    public IO`1<A> ToSync();
    public IO`1<A> ToAsync();
    public virtual IO`1<B> Map(Func`2<A, B> f);
    public virtual IO`1<S> FoldUntil(Schedule schedule, S initialState, Func`3<S, A, S> folder, Func`2<ValueTuple`2<S, A>, bool> predicate);
    public virtual IO`1<A> Post();
    public virtual IO`1<B> Bind(Func`2<A, IO`1<B>> f);
    public virtual IO`1<A> Bracket();
    public virtual IO`1<C> Bracket(Func`2<A, IO`1<C>> Use, Func`2<Error, IO`1<C>> Catch, Func`2<A, IO`1<B>> Finally);
    public virtual IO`1<A> Local();
    [NullableContextAttribute("0")]
public virtual IO`1<ForkIO`1<A>> Fork(Option`1<TimeSpan> timeout);
    [NullableContextAttribute("2")]
public virtual ValueTask`1<A> RunAsync(EnvIO envIO);
    public virtual A Run(EnvIO envIO);
    public virtual IO`1<A> RepeatUntil(Func`2<A, bool> predicate);
    public virtual IO`1<A> RepeatUntil(Schedule schedule, Func`2<A, bool> predicate);
    public virtual IO`1<A> RetryUntil(Func`2<Error, bool> predicate);
    public virtual IO`1<A> RetryUntil(Schedule schedule, Func`2<Error, bool> predicate);
    public virtual IO`1<A> Catch(Func`2<Error, bool> Predicate, Func`2<Error, K`2<IO, A>> Fail);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(IOPure`1<A> left, IOPure`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(IOPure`1<A> left, IOPure`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(IO`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(IOPure`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override IOPure`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(A& Value);
    [CompilerGeneratedAttribute]
private IOResponse`1<A> <ToSync>b__7_0(EnvIO _);
    [CompilerGeneratedAttribute]
private Task`1<IOResponse`1<A>> <ToAsync>b__8_0(EnvIO _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.IOResponse : object {
    public static IOResponse`1<A> Complete(A value);
    public static IOResponse`1<A> Recurse(IO`1<A> computation);
    public static IOResponse`1<A> Bind(X value, Func`2<X, IO`1<A>> computation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.IOResponse`1 : object {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected IOResponse`1(IOResponse`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(IOResponse`1<A> left, IOResponse`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(IOResponse`1<A> left, IOResponse`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(IOResponse`1<A> other);
    [CompilerGeneratedAttribute]
public abstract virtual IOResponse`1<A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class LanguageExt.IOSync`1 : IO`1<A> {
    [CompilerGeneratedAttribute]
private Func`2<EnvIO, IOResponse`1<A>> <runIO>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Func`2<EnvIO, IOResponse`1<A>> runIO { get; public set; }
    public IOSync`1(Func`2<EnvIO, IOResponse`1<A>> runIO);
    [CompilerGeneratedAttribute]
protected IOSync`1(IOSync`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Func`2<EnvIO, IOResponse`1<A>> get_runIO();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_runIO(Func`2<EnvIO, IOResponse`1<A>> value);
    public IO`1<A> ToAsync();
    public virtual IO`1<B> Map(Func`2<A, B> f);
    public virtual IO`1<S> FoldUntil(Schedule schedule, S initialState, Func`3<S, A, S> folder, Func`2<ValueTuple`2<S, A>, bool> predicate);
    public virtual IO`1<A> Post();
    public virtual IO`1<B> Bind(Func`2<A, IO`1<B>> f);
    [PureAttribute]
public virtual IO`1<A> Bracket();
    public virtual IO`1<C> Bracket(Func`2<A, IO`1<C>> Use, Func`2<Error, IO`1<C>> Catch, Func`2<A, IO`1<B>> Finally);
    public virtual IO`1<A> Local();
    [NullableContextAttribute("0")]
public virtual IO`1<ForkIO`1<A>> Fork(Option`1<TimeSpan> timeout);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("LanguageExt.IOSync`1/<RunAsync>d__16")]
public virtual ValueTask`1<A> RunAsync(EnvIO envIO);
    public virtual A Run(EnvIO envIO);
    public virtual IO`1<A> RepeatUntil(Schedule schedule, Func`2<A, bool> predicate);
    public virtual IO`1<A> RepeatUntil(Func`2<A, bool> predicate);
    public virtual IO`1<A> RetryUntil(Schedule schedule, Func`2<Error, bool> predicate);
    public virtual IO`1<A> RetryUntil(Func`2<Error, bool> predicate);
    public virtual IO`1<A> Catch(Func`2<Error, bool> Predicate, Func`2<Error, K`2<IO, A>> Fail);
    public virtual string ToString();
    [AsyncStateMachineAttribute("LanguageExt.IOSync`1/<AwaitAsync>d__24")]
private Task`1<IOResponse`1<A>> AwaitAsync(Task`1<IOResponse`1<A>> t, EnvIO envIO, CancellationToken token, CancellationTokenSource source);
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(IOSync`1<A> left, IOSync`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(IOSync`1<A> left, IOSync`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(IO`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(IOSync`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override IOSync`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`2& runIO);
    [CompilerGeneratedAttribute]
private Task`1<IOResponse`1<A>> <ToAsync>b__7_0(EnvIO e);
    [CompilerGeneratedAttribute]
private IOResponse`1<A> <Bracket>b__12_0(EnvIO env);
    [CompilerGeneratedAttribute]
private IOResponse`1<A> <Local>b__14_0(EnvIO env);
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
internal interface LanguageExt.ISeqInternal`1 {
    public SeqType Type { get; }
    public A Item { get; }
    public A Head { get; }
    public ISeqInternal`1<A> Tail { get; }
    public bool IsEmpty { get; }
    public ISeqInternal`1<A> Init { get; }
    public A Last { get; }
    public int Count { get; }
    public abstract virtual SeqType get_Type();
    public abstract virtual A get_Item(int index);
    public abstract virtual Option`1<A> At(int index);
    public abstract virtual ISeqInternal`1<A> Add(A value);
    public abstract virtual ISeqInternal`1<A> Cons(A value);
    public abstract virtual A get_Head();
    public abstract virtual ISeqInternal`1<A> get_Tail();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual ISeqInternal`1<A> get_Init();
    public abstract virtual A get_Last();
    public abstract virtual int get_Count();
    public abstract virtual S Fold(S state, Func`3<S, A, S> f);
    public abstract virtual S FoldBack(S state, Func`3<S, A, S> f);
    public abstract virtual ISeqInternal`1<A> Skip(int amount);
    public abstract virtual ISeqInternal`1<A> Take(int amount);
    public abstract virtual ISeqInternal`1<A> Strict();
    public abstract virtual Unit Iter(Action`1<A> f);
    public abstract virtual bool Exists(Func`2<A, bool> f);
    public abstract virtual bool ForAll(Func`2<A, bool> f);
    public abstract virtual int GetHashCode(int offsetBasis);
}
public enum LanguageExt.Isolation : Enum {
    public int value__;
    public static Isolation Snapshot;
    public static Isolation Serialisable;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class LanguageExt.ItemEv`1 : Ev`1<A> {
    [CompilerGeneratedAttribute]
private A <Value>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public A Value { get; public set; }
    public ItemEv`1(A Value);
    [CompilerGeneratedAttribute]
private ItemEv`1(ItemEv`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public A get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(A value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ItemEv`1<A> left, ItemEv`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ItemEv`1<A> left, ItemEv`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Ev`1<A> other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ItemEv`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override ItemEv`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(A& Value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Iterable : object {
    [PureAttribute]
public static Iterable`1<A> flatten(Iterable`1<Iterable`1<A>> ma);
    [PureAttribute]
public static Iterable`1<A> empty();
    [PureAttribute]
public static Iterable`1<A> singleton(A value);
    [PureAttribute]
public static Iterable`1<A> create();
    [PureAttribute]
public static Iterable`1<A> create(A[] items);
    [PureAttribute]
public static Iterable`1<A> createRange(ReadOnlySpan`1<A> items);
    [PureAttribute]
public static Iterable`1<A> createRange(IEnumerable`1<A> items);
    [PureAttribute]
public static Iterable`1<A> generate(int count, Func`2<int, A> generator);
    [PureAttribute]
public static Iterable`1<A> repeat(A item, int count);
    [PureAttribute]
public static Option`1<A> head(Iterable`1<A> list);
    [PureAttribute]
public static Iterable`1<B> choose(Iterable`1<A> list, Func`2<A, Option`1<B>> selector);
    [PureAttribute]
public static Iterable`1<A> rev(Iterable`1<A> list);
    [PureAttribute]
public static Iterable`1<S> scan(Iterable`1<A> list, S state, Func`3<S, A, S> folder);
    [PureAttribute]
public static Iterable`1<S> scanBack(Iterable`1<A> list, S state, Func`3<S, A, S> folder);
    [PureAttribute]
public static Iterable`1<C> zip(Iterable`1<A> list, Iterable`1<B> other, Func`3<A, B, C> zipper);
    [PureAttribute]
public static Iterable`1<ValueTuple`2<A, B>> zip(Iterable`1<A> list, Iterable`1<B> other);
    [PureAttribute]
public static Iterable`1<A> distinct(Iterable`1<A> list);
    [PureAttribute]
public static Iterable`1<A> distinct(Iterable`1<A> list);
    [PureAttribute]
public static Iterable`1<A> take(Iterable`1<A> list, int count);
    [PureAttribute]
public static Iterable`1<A> takeWhile(Iterable`1<A> list, Func`2<A, bool> pred);
    [PureAttribute]
public static Iterable`1<A> takeWhile(Iterable`1<A> list, Func`3<A, int, bool> pred);
    private static override K`2<Iterable, B> LanguageExt.Traits.Monad<LanguageExt.Iterable>.Bind(K`2<Iterable, A> ma, Func`2<A, K`2<Iterable, B>> f);
    private static override K`2<Iterable, B> LanguageExt.Traits.Functor<LanguageExt.Iterable>.Map(Func`2<A, B> f, K`2<Iterable, A> ma);
    private static override K`2<Iterable, A> LanguageExt.Traits.Applicative<LanguageExt.Iterable>.Pure(A value);
    private static override K`2<Iterable, B> LanguageExt.Traits.Applicative<LanguageExt.Iterable>.Apply(K`2<Iterable, Func`2<A, B>> mf, K`2<Iterable, A> ma);
    private static override K`2<Iterable, B> LanguageExt.Traits.Applicative<LanguageExt.Iterable>.Action(K`2<Iterable, A> ma, K`2<Iterable, B> mb);
    private static override K`2<Iterable, A> LanguageExt.Traits.MonoidK<LanguageExt.Iterable>.Empty();
    private static override K`2<Iterable, A> LanguageExt.Traits.SemigroupK<LanguageExt.Iterable>.Combine(K`2<Iterable, A> ma, K`2<Iterable, A> mb);
    private static override K`2<F, K`2<Iterable, B>> LanguageExt.Traits.Traversable<LanguageExt.Iterable>.Traverse(Func`2<A, K`2<F, B>> f, K`2<Iterable, A> ta);
    private static override K`2<F, K`2<Iterable, B>> LanguageExt.Traits.Traversable<LanguageExt.Iterable>.TraverseM(Func`2<A, K`2<F, B>> f, K`2<Iterable, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Iterable>.FoldWhile(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<Iterable, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Iterable>.FoldBackWhile(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<Iterable, A> ta);
    private static override Arr`1<A> LanguageExt.Traits.Foldable<LanguageExt.Iterable>.ToArr(K`2<Iterable, A> ta);
    private static override Lst`1<A> LanguageExt.Traits.Foldable<LanguageExt.Iterable>.ToLst(K`2<Iterable, A> ta);
    private static override Iterable`1<A> LanguageExt.Traits.Foldable<LanguageExt.Iterable>.ToIterable(K`2<Iterable, A> ta);
    private static override Seq`1<A> LanguageExt.Traits.Foldable<LanguageExt.Iterable>.ToSeq(K`2<Iterable, A> ta);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CollectionBuilderAttribute("LanguageExt.Iterable", "createRange")]
public class LanguageExt.Iterable`1 : object {
    private Nullable`1<int> hashCode;
    [PureAttribute]
public static Iterable`1<A> Empty { get; }
    public static Iterable`1<A> AdditiveIdentity { get; }
    public static Iterable`1<A> FromSpan(ReadOnlySpan`1<A> ma);
    [PureAttribute]
public virtual int Count();
    [PureAttribute]
public virtual IEnumerable`1<A> AsEnumerable();
    [PureAttribute]
public StreamT`2<M, A> AsStream();
    [PureAttribute]
public virtual Iterable`1<A> Reverse();
    [PureAttribute]
public virtual Iterable`1<A> Add(A item);
    [PureAttribute]
public virtual Iterable`1<A> Cons(A item);
    public virtual Unit Iter(Action`1<A> f);
    public virtual Unit Iter(Action`2<A, int> f);
    [PureAttribute]
public virtual Iterable`1<B> Map(Func`2<A, B> f);
    [PureAttribute]
public virtual Iterable`1<B> Map(Func`3<A, int, B> f);
    [PureAttribute]
public virtual Iterable`1<B> Bind(Func`2<A, Iterable`1<B>> f);
    [PureAttribute]
public virtual Iterable`1<A> Filter(Func`2<A, bool> f);
    [PureAttribute]
public virtual bool Equals(Iterable`1<A> other);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public static override bool op_Equality(Iterable`1<A> lhs, Iterable`1<A> rhs);
    [PureAttribute]
public static override bool op_Inequality(Iterable`1<A> lhs, Iterable`1<A> rhs);
    [PureAttribute]
public S FoldWhile(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state);
    [PureAttribute]
public S FoldWhile(Func`3<S, A, S> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state);
    [PureAttribute]
public S FoldBackWhile(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state);
    [PureAttribute]
public S FoldBackWhile(Func`3<S, A, S> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state);
    [PureAttribute]
public sealed virtual Iterable`1<A> Combine(Iterable`1<A> y);
    [PureAttribute]
public Iterable`1<A> Concat(IEnumerable`1<A> items);
    [PureAttribute]
public Iterable`1<A> Concat(Iterable`1<A> items);
    [PureAttribute]
public Iterable`1<S> Scan(S state, Func`3<S, A, S> folder);
    [PureAttribute]
public Iterable`1<S> ScanBack(S state, Func`3<S, A, S> folder);
    [PureAttribute]
public Iterable`1<A> Distinct();
    [PureAttribute]
public Iterable`1<A> Distinct();
    [PureAttribute]
public K`2<F, Iterable`1<B>> Traverse(Func`2<A, K`2<F, B>> f);
    [PureAttribute]
public K`2<M, Iterable`1<B>> TraverseM(Func`2<A, K`2<M, B>> f);
    [PureAttribute]
public Iterable`1<B> Bind(Func`2<A, K`2<Iterable, B>> f);
    [PureAttribute]
public Iterable`1<B> Bind(Func`2<A, IEnumerable`1<B>> f);
    [PureAttribute]
public bool Any();
    [PureAttribute]
public Iterable`1<A> Intersperse(A value);
    [NullableContextAttribute("2")]
[PureAttribute]
public int CompareTo(object obj);
    [PureAttribute]
public sealed virtual int CompareTo(Iterable`1<A> other);
    [NullableContextAttribute("0")]
[PureAttribute]
public virtual int CompareTo(Iterable`1<A> rhs);
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public virtual string ToFullString(string separator);
    [PureAttribute]
public virtual string ToFullArrayString(string separator);
    [PureAttribute]
public virtual bool Equals(Iterable`1<A> rhs);
    [PureAttribute]
public Iterable`1<A> Skip(int amount);
    [PureAttribute]
public Iterable`1<A> Take(int amount);
    [PureAttribute]
public Iterable`1<A> TakeWhile(Func`2<A, bool> pred);
    [PureAttribute]
public Iterable`1<A> TakeWhile(Func`3<A, int, bool> pred);
    [PureAttribute]
public ValueTuple`2<Iterable`1<A>, Iterable`1<A>> Partition(Func`2<A, bool> predicate);
    [PureAttribute]
public Iterable`1<B> Cast();
    [PureAttribute]
public Iterable`1<ValueTuple`2<A, B>> Zip(Iterable`1<B> rhs);
    [PureAttribute]
public Iterable`1<C> Zip(Iterable`1<B> rhs, Func`3<A, B, C> zipper);
    public static override Iterable`1<A> get_Empty();
    [PureAttribute]
public static override Iterable`1<A> op_Addition(Iterable`1<A> x, Iterable`1<A> y);
    [PureAttribute]
public static override bool op_GreaterThan(Iterable`1<A> x, Iterable`1<A> y);
    [PureAttribute]
public static override bool op_GreaterThanOrEqual(Iterable`1<A> x, Iterable`1<A> y);
    [PureAttribute]
public static override bool op_LessThan(Iterable`1<A> x, Iterable`1<A> y);
    [PureAttribute]
public static override bool op_LessThanOrEqual(Iterable`1<A> x, Iterable`1<A> y);
    [PureAttribute]
public static Iterable`1<A> op_Implicit(SeqEmpty _);
    [PureAttribute]
public Iterable`1<B> Select(Func`2<A, B> f);
    [PureAttribute]
public Iterable`1<B> Select(Func`3<A, int, B> f);
    [PureAttribute]
public Iterable`1<A> Where(Func`2<A, bool> f);
    [PureAttribute]
public Iterable`1<B> SelectMany(Func`2<A, Iterable`1<B>> bind);
    [PureAttribute]
public Iterable`1<C> SelectMany(Func`2<A, Iterable`1<B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Iterable`1<B> SelectMany(Func`2<A, IEnumerable`1<B>> bind);
    [PureAttribute]
public Iterable`1<C> SelectMany(Func`2<A, IEnumerable`1<B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    [PureAttribute]
public virtual int GetHashCode();
    public static override Iterable`1<A> get_AdditiveIdentity();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("LanguageExt.Iterable`1/<<Distinct>g__Yield|27_0>d`1")]
[CompilerGeneratedAttribute]
private IEnumerable`1<A> <Distinct>g__Yield|27_0();
    [IteratorStateMachineAttribute("LanguageExt.Iterable`1/<<TakeWhile>g__Yield|44_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<A> <TakeWhile>g__Yield|44_0(IEnumerable`1<A> xs, Func`2<A, bool> f);
    [IteratorStateMachineAttribute("LanguageExt.Iterable`1/<<TakeWhile>g__Yield|45_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<A> <TakeWhile>g__Yield|45_0(IEnumerable`1<A> xs, Func`3<A, int, bool> f);
    [IteratorStateMachineAttribute("LanguageExt.Iterable`1/<<Cast>g__Yield|47_0>d`1")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<B> <Cast>g__Yield|47_0(IEnumerable`1<A> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class LanguageExt.IterableAdd`1 : Iterable`1<A> {
    [CompilerGeneratedAttribute]
private SeqStrict`1<A> <Prefix>P;
    [CompilerGeneratedAttribute]
private Iterable`1<A> <Source>P;
    [CompilerGeneratedAttribute]
private SeqStrict`1<A> <Postfix>P;
    public IterableAdd`1(SeqStrict`1<A> Prefix, Iterable`1<A> Source, SeqStrict`1<A> Postfix);
    [PureAttribute]
public virtual int Count();
    [PureAttribute]
public virtual Iterable`1<A> Add(A item);
    [PureAttribute]
public virtual Iterable`1<A> Cons(A item);
    [IteratorStateMachineAttribute("LanguageExt.IterableAdd`1/<AsEnumerable>d__7")]
[PureAttribute]
public virtual IEnumerable`1<A> AsEnumerable();
    public virtual Iterable`1<A> Reverse();
    public virtual Unit Iter(Action`1<A> f);
    public virtual Unit Iter(Action`2<A, int> f);
    [PureAttribute]
public virtual Iterable`1<B> Map(Func`2<A, B> f);
    [PureAttribute]
public virtual Iterable`1<B> Map(Func`3<A, int, B> f);
    [PureAttribute]
public virtual Iterable`1<B> Bind(Func`2<A, Iterable`1<B>> f);
    [PureAttribute]
public virtual Iterable`1<A> Filter(Func`2<A, bool> f);
    [PureAttribute]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class LanguageExt.IterableConcat`1 : Iterable`1<A> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Seq`1<Iterable`1<A>> <Items>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Seq`1<Iterable`1<A>> Items { get; }
    public IterableConcat`1(Seq`1<Iterable`1<A>> Items);
    [CompilerGeneratedAttribute]
public Seq`1<Iterable`1<A>> get_Items();
    [PureAttribute]
public virtual int Count();
    [IteratorStateMachineAttribute("LanguageExt.IterableConcat`1/<AsEnumerable>d__5")]
[PureAttribute]
public virtual IEnumerable`1<A> AsEnumerable();
    public virtual Iterable`1<A> Reverse();
    public virtual Unit Iter(Action`1<A> f);
    public virtual Unit Iter(Action`2<A, int> f);
    [PureAttribute]
public virtual Iterable`1<B> Map(Func`2<A, B> f);
    [PureAttribute]
public virtual Iterable`1<B> Map(Func`3<A, int, B> f);
    [PureAttribute]
public virtual Iterable`1<B> Bind(Func`2<A, Iterable`1<B>> f);
    [PureAttribute]
public virtual Iterable`1<A> Filter(Func`2<A, bool> f);
    [PureAttribute]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class LanguageExt.IterableEnumerable`1 : Iterable`1<A> {
    [CompilerGeneratedAttribute]
private IEnumerable`1<A> <runEnumerable>P;
    public IterableEnumerable`1(IEnumerable`1<A> runEnumerable);
    public virtual int Count();
    [PureAttribute]
public virtual IEnumerable`1<A> AsEnumerable();
    [PureAttribute]
public virtual Iterable`1<A> Reverse();
    public virtual Unit Iter(Action`1<A> f);
    public virtual Unit Iter(Action`2<A, int> f);
    [PureAttribute]
public virtual Iterable`1<B> Map(Func`2<A, B> f);
    [PureAttribute]
public virtual Iterable`1<B> Map(Func`3<A, int, B> f);
    [PureAttribute]
public virtual Iterable`1<B> Bind(Func`2<A, Iterable`1<B>> f);
    [PureAttribute]
public virtual Iterable`1<A> Filter(Func`2<A, bool> f);
    [PureAttribute]
public virtual string ToString();
    [IteratorStateMachineAttribute("LanguageExt.IterableEnumerable`1/<<Bind>g__go|9_0>d`1")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<B> <Bind>g__go|9_0(Iterable`1<A> ma, Func`2<A, Iterable`1<B>> bnd);
    [IteratorStateMachineAttribute("LanguageExt.IterableEnumerable`1/<<Filter>g__Yield|10_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<A> <Filter>g__Yield|10_0(Iterable`1<A> items, Func`2<A, bool> f);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.IterableExtensions : object {
    [ExtensionAttribute]
public static Iterable`1<A> As(K`2<Iterable, A> xs);
    [ExtensionAttribute]
public static Iterable`1<A> AsIterable(IEnumerable`1<A> xs);
    [ExtensionAttribute]
[PureAttribute]
public static Iterable`1<A> Flatten(Iterable`1<Iterable`1<A>> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Iterable`1<B> Choose(Iterable`1<A> list, Func`2<A, Option`1<B>> selector);
    [ExtensionAttribute]
[PureAttribute]
public static Iterable`1<T> Rev(Iterable`1<T> list);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.IterableTExtensions : object {
    [ExtensionAttribute]
public static StreamT`2<M, A> As(K`2<StreamT`1<M>, A> ma);
    [ExtensionAttribute]
public static MList`1<A> As(K`2<MList, A> ma);
    [ExtensionAttribute]
public static K`2<M, Option`1<ValueTuple`2<A, StreamT`2<M, A>>>> Run(K`2<StreamT`1<M>, A> mma);
    [ExtensionAttribute]
public static K`2<M, A> Combine(K`2<StreamT`1<M>, A> mma);
    [ExtensionAttribute]
private static K`2<M, A> Combine(K`2<M, MList`1<A>> mma);
    [ExtensionAttribute]
public static StreamT`2<M, A> Flatten(K`2<StreamT`1<M>, StreamT`2<M, A>> mma);
    [ExtensionAttribute]
public static StreamT`2<M, A> Flatten(K`2<StreamT`1<M>, K`2<StreamT`1<M>, A>> mma);
    [ExtensionAttribute]
public static K`2<M, MList`1<A>> Flatten(K`2<M, MList`1<K`2<M, MList`1<A>>>> mma);
    [ExtensionAttribute]
public static K`2<M, MList`1<A>> Flatten(MList`1<K`2<M, MList`1<A>>> mma);
    [ExtensionAttribute]
public static K`2<M, MList`1<A>> Append(K`2<M, MList`1<A>> xs, K`2<M, MList`1<A>> ys);
    [ExtensionAttribute]
public static StreamT`2<M, B> Bind(Pure`1<A> ma, Func`2<A, StreamT`2<M, B>> f);
    [ExtensionAttribute]
public static StreamT`2<M, B> Bind(Pure`1<A> ma, Func`2<A, K`2<StreamT`1<M>, B>> f);
    [ExtensionAttribute]
public static StreamT`2<M, B> Bind(IO`1<A> ma, Func`2<A, StreamT`2<M, B>> f);
    [ExtensionAttribute]
public static StreamT`2<M, B> Bind(IO`1<A> ma, Func`2<A, K`2<StreamT`1<M>, B>> f);
    [ExtensionAttribute]
public static StreamT`2<M, C> SelectMany(Pure`1<A> ma, Func`2<A, StreamT`2<M, B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
public static StreamT`2<M, C> SelectMany(Pure`1<A> ma, Func`2<A, K`2<StreamT`1<M>, B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
public static StreamT`2<M, C> SelectMany(IO`1<A> ma, Func`2<A, StreamT`2<M, B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
public static StreamT`2<M, C> SelectMany(IO`1<A> ma, Func`2<A, K`2<StreamT`1<M>, B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
public static K`2<M, Unit> Iter(K`2<StreamT`1<M>, A> ma);
    [ExtensionAttribute]
public static K`2<M, Option`1<A>> Head(K`2<StreamT`1<M>, A> ma);
    [ExtensionAttribute]
public static K`2<M, A> HeadUnsafe(K`2<StreamT`1<M>, A> ma);
    [ExtensionAttribute]
public static StreamT`2<M, A> Tail(K`2<StreamT`1<M>, A> ma);
    [ExtensionAttribute]
public static StreamT`2<M, S> Fold(K`2<StreamT`1<M>, A> ma, S state, Func`3<S, A, Option`1<S>> f);
    [ExtensionAttribute]
public static StreamT`2<M, S> FoldUntil(K`2<StreamT`1<M>, A> ma, S state, Func`3<S, A, S> f, Func`3<S, A, bool> until);
    [ExtensionAttribute]
public static StreamT`2<M, S> FoldWhile(K`2<StreamT`1<M>, A> ma, S state, Func`3<S, A, S> f, Func`3<S, A, bool> while);
    [ExtensionAttribute]
public static K`2<M, S> FoldM(K`2<StreamT`1<M>, A> ma, S state, Func`3<S, A, K`2<M, S>> f);
    [ExtensionAttribute]
public static StreamT`2<M, A> Combine(K`2<StreamT`1<M>, A> first, StreamT`2<M, A> second);
    [ExtensionAttribute]
public static StreamT`2<M, A> Combine(K`2<StreamT`1<M>, A> first, K`2<StreamT`1<M>, A> second);
    [ExtensionAttribute]
public static StreamT`2<M, A> Merge(K`2<StreamT`1<M>, A> first, K`2<StreamT`1<M>, A> second);
    [ExtensionAttribute]
public static StreamT`2<M, A> Merge(K`2<StreamT`1<M>, A> first, K`2<StreamT`1<M>, A> second, K`2[] rest);
    [ExtensionAttribute]
public static StreamT`2<M, ValueTuple`2<A, B>> Zip(K`2<StreamT`1<M>, A> first, K`2<StreamT`1<M>, B> second);
    [ExtensionAttribute]
public static StreamT`2<M, ValueTuple`3<A, B, C>> Zip(K`2<StreamT`1<M>, A> first, K`2<StreamT`1<M>, B> second, K`2<StreamT`1<M>, C> third);
    [ExtensionAttribute]
public static StreamT`2<M, ValueTuple`4<A, B, C, D>> Zip(K`2<StreamT`1<M>, A> first, K`2<StreamT`1<M>, B> second, K`2<StreamT`1<M>, C> third, K`2<StreamT`1<M>, D> fourth);
    [ExtensionAttribute]
public static StreamT`2<M, A> Somes(IAsyncEnumerable`1<OptionT`2<M, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, A> SomesStream(IAsyncEnumerable`1<Option`1<A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, A> Somes(IEnumerable`1<OptionT`2<M, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, A> SomesStream(IEnumerable`1<Option`1<A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, A> Rights(IAsyncEnumerable`1<EitherT`3<L, M, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, A> RightsStream(IAsyncEnumerable`1<Either`2<L, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, A> Rights(IEnumerable`1<EitherT`3<L, M, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, A> RightsStream(IEnumerable`1<Either`2<L, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, L> Lefts(IAsyncEnumerable`1<EitherT`3<L, M, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, L> LeftsStream(IAsyncEnumerable`1<Either`2<L, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, L> Lefts(IEnumerable`1<EitherT`3<L, M, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, L> LeftsStream(IEnumerable`1<Either`2<L, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, A> Succs(IAsyncEnumerable`1<FinT`2<M, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, A> SuccsStream(IAsyncEnumerable`1<Fin`1<A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, A> Succs(IEnumerable`1<FinT`2<M, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, A> SuccsStream(IEnumerable`1<Fin`1<A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, Error> Fails(IAsyncEnumerable`1<FinT`2<M, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, Error> FailsStream(IAsyncEnumerable`1<Fin`1<A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, Error> Fails(IEnumerable`1<FinT`2<M, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, Error> FailsStream(IEnumerable`1<Fin`1<A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, A> Succs(IAsyncEnumerable`1<ValidationT`3<L, M, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, A> SuccsStream(IAsyncEnumerable`1<Validation`2<L, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, A> Succs(IEnumerable`1<ValidationT`3<L, M, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, A> SuccsStream(IEnumerable`1<Validation`2<L, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, L> Fails(IAsyncEnumerable`1<ValidationT`3<L, M, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, L> FailsStream(IAsyncEnumerable`1<Validation`2<L, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, L> Fails(IEnumerable`1<ValidationT`3<L, M, A>> stream);
    [ExtensionAttribute]
public static StreamT`2<M, L> FailsStream(IEnumerable`1<Validation`2<L, A>> stream);
}
public class LanguageExt.LastWriteWins`1 : ValueType {
    public static override ValueTuple`2<long, Option`1<V>> Resolve(ValueTuple`2<long, Option`1<V>> Current, ValueTuple`2<long, Option`1<V>> Proposed);
}
[IsReadOnlyAttribute]
public class LanguageExt.Length : ValueType {
    private double Value;
    public double Miles { get; }
    public double NauticalMiles { get; }
    public double Yards { get; }
    public double Feet { get; }
    public double Inches { get; }
    public double Kilometres { get; }
    public double Hectometres { get; }
    public double Decametres { get; }
    public double Metres { get; }
    public double Centimetres { get; }
    public double Millimetres { get; }
    public double Micrometres { get; }
    public double Nanometres { get; }
    public double Angstroms { get; }
    internal Length(double value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public sealed virtual bool Equals(Length other);
    public bool Equals(Length other, double epsilon);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Length other);
    public Length Add(Length rhs);
    public Length Subtract(Length rhs);
    public Length Multiply(double rhs);
    public Length Divide(double rhs);
    public static Area op_Multiply(Length lhs, Length rhs);
    public static override Length op_Multiply(Length lhs, double rhs);
    public static Length op_Multiply(double lhs, Length rhs);
    public static override Length op_UnaryNegation(Length self);
    public static override Length op_Addition(Length lhs, Length rhs);
    public static override Length op_Subtraction(Length lhs, Length rhs);
    public static override Length op_Division(Length lhs, double rhs);
    public static double op_Division(Length lhs, Length rhs);
    public static Accel op_Division(Length lhs, TimeSq rhs);
    public static Time op_Division(Length lhs, Velocity rhs);
    public static Velocity op_Division(Length lhs, Time rhs);
    public static override bool op_Equality(Length lhs, Length rhs);
    public static override bool op_Inequality(Length lhs, Length rhs);
    public static override bool op_GreaterThan(Length lhs, Length rhs);
    public static override bool op_LessThan(Length lhs, Length rhs);
    public static override bool op_GreaterThanOrEqual(Length lhs, Length rhs);
    public static override bool op_LessThanOrEqual(Length lhs, Length rhs);
    public Length Pow(double power);
    public Length Round();
    public Length Sqrt();
    public Length Abs();
    public Length Min(Length rhs);
    public Length Max(Length rhs);
    public double get_Miles();
    public double get_NauticalMiles();
    public double get_Yards();
    public double get_Feet();
    public double get_Inches();
    public double get_Kilometres();
    public double get_Hectometres();
    public double get_Decametres();
    public double get_Metres();
    public double get_Centimetres();
    public double get_Millimetres();
    public double get_Micrometres();
    public double get_Nanometres();
    public double get_Angstroms();
    [NullableContextAttribute("1")]
private static override Fin`1<Length> LanguageExt.Traits.Domain.DomainType<LanguageExt.Length,System.Double>.From(double repr);
    public static Length From(double repr);
    public sealed virtual double To();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.Lens : object {
    public static Lens`2<ValueTuple`2<A, B>, ValueTuple`2<C, D>> tuple(Lens`2<A, C> First, Lens`2<B, D> Second);
    public static Lens`2<ValueTuple`3<A, B, C>, ValueTuple`3<D, E, F>> tuple(Lens`2<A, D> First, Lens`2<B, E> Second, Lens`2<C, F> Third);
    public static Lens`2<A, B> cond(Func`2<A, bool> pred, Lens`2<A, B> Then, Lens`2<A, B> Else);
    public static Lens`2<ValueTuple`2<A, B>, A> fst();
    public static Lens`2<ValueTuple`3<A, B, C>, A> fst();
    public static Lens`2<ValueTuple`4<A, B, C, D>, A> fst();
    public static Lens`2<ValueTuple`2<A, B>, B> snd();
    public static Lens`2<ValueTuple`3<A, B, C>, B> snd();
    public static Lens`2<ValueTuple`4<A, B, C, D>, B> snd();
    public static Lens`2<ValueTuple`3<A, B, C>, C> thrd();
    public static Lens`2<ValueTuple`4<A, B, C, D>, C> thrd();
    public static Lens`2<A, A> identity();
    public static Lens`2<IEnumerable`1<A>, IEnumerable`1<B>> enumMap(Lens`2<A, B> la);
    [ExtensionAttribute]
public static Prism`2<A, B> ToPrism(Lens`2<A, B> la);
    [ExtensionAttribute]
public static Prism`2<A, B> ToPrism(Lens`2<A, Option`1<B>> la);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class LanguageExt.Lens`2 : ValueType {
    public Func`2<A, B> Get;
    public Func`2<B, Func`2<A, A>> SetF;
    private Lens`2(Func`2<A, B> get, Func`2<B, Func`2<A, A>> set);
    public A Set(B value, A cont);
    public static Lens`2<A, B> New(Func`2<A, B> Get, Func`2<B, Func`2<A, A>> Set);
    public Func`2<A, A> Update(Func`2<B, B> f);
    public A Update(Func`2<B, B> f, A value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Lift`1 : object {
    [CompilerGeneratedAttribute]
private Func`1<A> <Function>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Func`1<A> Function { get; public set; }
    public Lift`1(Func`1<A> Function);
    [CompilerGeneratedAttribute]
protected Lift`1(Lift`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Func`1<A> get_Function();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Function(Func`1<A> value);
    public K`2<F, A> ToApplicative();
    public IO`1<A> ToIO();
    public Eff`1<A> ToEff();
    public Eff`2<RT, A> ToEff();
    public Lift`1<B> Map(Func`2<A, B> f);
    public Lift`1<B> Bind(Func`2<A, Lift`1<B>> f);
    public Lift`1<B> Bind(Func`2<A, Pure`1<B>> f);
    public K`2<M, B> Bind(Func`2<A, K`2<M, B>> f);
    public IO`1<B> Bind(Func`2<A, IO`1<B>> f);
    public Lift`1<B> Select(Func`2<A, B> f);
    public IO`1<C> SelectMany(Func`2<A, IO`1<B>> bind, Func`3<A, B, C> project);
    public K`2<M, C> SelectMany(Func`2<A, K`2<M, B>> bind, Func`3<A, B, C> project);
    public Lift`1<C> SelectMany(Func`2<A, Lift`1<B>> bind, Func`3<A, B, C> project);
    public Lift`1<C> SelectMany(Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Lift`1<A> left, Lift`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Lift`1<A> left, Lift`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Lift`1<A> other);
    [CompilerGeneratedAttribute]
public virtual Lift`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`1& Function);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private A <ToApplicative>b__7_0(Unit _);
    [CompilerGeneratedAttribute]
private A <ToIO>b__8_0(EnvIO _);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private A <Bind>b__14_0(Unit _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Lift`2 : object {
    [CompilerGeneratedAttribute]
private Func`2<A, B> <Function>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Func`2<A, B> Function { get; public set; }
    public Lift`2(Func`2<A, B> Function);
    [CompilerGeneratedAttribute]
protected Lift`2(Lift`2<A, B> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Func`2<A, B> get_Function();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Function(Func`2<A, B> value);
    public Lift`2<A, C> Map(Func`2<B, C> f);
    public Lift`2<A, C> Bind(Func`2<B, Lift`2<A, C>> f);
    public Lift`2<A, C> Bind(Func`2<B, Pure`1<C>> f);
    public Lift`2<A, C> Select(Func`2<B, C> f);
    public Lift`2<A, D> SelectMany(Func`2<B, Pure`1<C>> bind, Func`3<B, C, D> project);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Lift`2<A, B> left, Lift`2<A, B> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Lift`2<A, B> left, Lift`2<A, B> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Lift`2<A, B> other);
    [CompilerGeneratedAttribute]
public virtual Lift`2<A, B> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`2& Function);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.List : object {
    [NullableContextAttribute("2")]
[PureAttribute]
public static Lst`1<A> flatten(Lst`1<Lst`1<A>> ma);
    [PureAttribute]
public static Iterable`1<A> flatten(IEnumerable`1<IEnumerable`1<A>> ma);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Lst`1<T> empty();
    [PureAttribute]
public static Lst`1<A> singleton(A value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Lst`1<T> create();
    [PureAttribute]
public static Lst`1<T> create(T[] items);
    [PureAttribute]
public static Lst`1<T> createRange(IEnumerable`1<T> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Lst`1<A> createRange(ReadOnlySpan`1<A> items);
    [PureAttribute]
public static Iterable`1<T> generate(int count, Func`2<int, T> generator);
    [PureAttribute]
public static Iterable`1<T> generate(Func`2<int, T> generator);
    [PureAttribute]
public static Iterable`1<T> repeat(T item, int count);
    [PureAttribute]
public static Lst`1<T> add(Lst`1<T> list, T value);
    [PureAttribute]
public static Lst`1<T> addRange(Lst`1<T> list, IEnumerable`1<T> value);
    [PureAttribute]
public static Lst`1<T> remove(Lst`1<T> list, T value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Lst`1<T> removeAt(Lst`1<T> list, int index);
    [PureAttribute]
public static T head(IEnumerable`1<T> list);
    [PureAttribute]
public static Option`1<A> headOrNone(IEnumerable`1<A> list);
    [PureAttribute]
public static Either`2<L, R> headOrLeft(IEnumerable`1<R> list, L left);
    [PureAttribute]
public static Validation`2<Fail, Success> headOrInvalid(IEnumerable`1<Success> list, Fail fail);
    [PureAttribute]
public static Validation`2<Fail, Success> headOrInvalid(IEnumerable`1<Success> list);
    [PureAttribute]
public static A last(IEnumerable`1<A> list);
    [PureAttribute]
public static Option`1<A> lastOrNone(IEnumerable`1<A> list);
    [PureAttribute]
public static Either`2<L, R> lastOrLeft(IEnumerable`1<R> list, L left);
    [PureAttribute]
public static Validation`2<Fail, Success> lastOrInvalid(IEnumerable`1<Success> list, Fail fail);
    [PureAttribute]
public static Validation`2<Fail, Success> lastOrInvalid(IEnumerable`1<Success> list);
    [PureAttribute]
public static Seq`1<A> init(IEnumerable`1<A> list);
    [PureAttribute]
public static Iterable`1<T> tail(IEnumerable`1<T> list);
    [PureAttribute]
public static Iterable`1<R> map(IEnumerable`1<T> list, Func`2<T, R> map);
    [PureAttribute]
public static Iterable`1<R> map(IEnumerable`1<T> list, Func`3<int, T, R> map);
    [PureAttribute]
public static Iterable`1<T> filter(IEnumerable`1<T> list, Func`2<T, bool> predicate);
    [PureAttribute]
public static Iterable`1<R> choose(IEnumerable`1<T> list, Func`2<T, Option`1<R>> selector);
    [PureAttribute]
public static Iterable`1<R> choose(IEnumerable`1<T> list, Func`3<int, T, Option`1<R>> selector);
    [PureAttribute]
public static Iterable`1<R> collect(IEnumerable`1<T> list, Func`2<T, IEnumerable`1<R>> map);
    [PureAttribute]
public static int sum(IEnumerable`1<int> list);
    [PureAttribute]
public static float sum(IEnumerable`1<float> list);
    [PureAttribute]
public static double sum(IEnumerable`1<double> list);
    [PureAttribute]
public static decimal sum(IEnumerable`1<decimal> list);
    [PureAttribute]
public static Iterable`1<T> rev(IEnumerable`1<T> list);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Lst`1<T> rev(Lst`1<T> list);
    [PureAttribute]
public static Iterable`1<T> append(IEnumerable`1<T> lhs, IEnumerable`1<T> rhs);
    [PureAttribute]
public static Iterable`1<T> append(IEnumerable`1<T> x, IEnumerable`1<IEnumerable`1<T>> xs);
    [PureAttribute]
public static Iterable`1<T> append(IEnumerable`1[] lists);
    [PureAttribute]
public static S fold(IEnumerable`1<T> list, S state, Func`3<S, T, S> folder);
    [PureAttribute]
public static S foldBack(IEnumerable`1<T> list, S state, Func`3<S, T, S> folder);
    [PureAttribute]
public static S foldWhile(IEnumerable`1<T> list, S state, Func`3<S, T, S> folder, Func`2<T, bool> preditem);
    [PureAttribute]
public static S foldWhile(IEnumerable`1<T> list, S state, Func`3<S, T, S> folder, Func`2<S, bool> predstate);
    [PureAttribute]
public static S foldBackWhile(IEnumerable`1<T> list, S state, Func`3<S, T, S> folder, Func`2<T, bool> preditem);
    [PureAttribute]
public static S foldBackWhile(IEnumerable`1<T> list, S state, Func`3<S, T, S> folder, Func`2<S, bool> predstate);
    [PureAttribute]
public static S foldUntil(IEnumerable`1<T> list, S state, Func`3<S, T, S> folder, Func`2<T, bool> preditem);
    [PureAttribute]
public static S foldUntil(IEnumerable`1<T> list, S state, Func`3<S, T, S> folder, Func`2<S, bool> predstate);
    [PureAttribute]
public static S foldBackUntil(IEnumerable`1<T> list, S state, Func`3<S, T, S> folder, Func`2<T, bool> preditem);
    [PureAttribute]
public static S foldBackUntil(IEnumerable`1<T> list, S state, Func`3<S, T, S> folder, Func`2<S, bool> predstate);
    [PureAttribute]
public static A reduce(IEnumerable`1<A> list, Func`3<A, A, A> reducer);
    [PureAttribute]
public static Option`1<A> reduceOrNone(IEnumerable`1<A> list, Func`3<A, A, A> reducer);
    [PureAttribute]
public static A reduceBack(IEnumerable`1<A> list, Func`3<A, A, A> reducer);
    [PureAttribute]
public static Option`1<A> reduceBackOrNone(IEnumerable`1<A> list, Func`3<A, A, A> reducer);
    [IteratorStateMachineAttribute("LanguageExt.List/<scan>d__56`2")]
[PureAttribute]
public static IEnumerable`1<S> scan(IEnumerable`1<T> list, S state, Func`3<S, T, S> folder);
    [PureAttribute]
public static IEnumerable`1<S> scanBack(IEnumerable`1<T> list, S state, Func`3<S, T, S> folder);
    [PureAttribute]
public static Option`1<T> find(IEnumerable`1<T> list, Func`2<T, bool> pred);
    [IteratorStateMachineAttribute("LanguageExt.List/<findSeq>d__59`1")]
[PureAttribute]
public static IEnumerable`1<T> findSeq(IEnumerable`1<T> list, Func`2<T, bool> pred);
    [PureAttribute]
public static Lst`1<T> freeze(IEnumerable`1<T> list);
    [PureAttribute]
public static IEnumerable`1<V> zip(IEnumerable`1<T> list, IEnumerable`1<U> other, Func`3<T, U, V> zipper);
    [PureAttribute]
public static IEnumerable`1<ValueTuple`2<T, U>> zip(IEnumerable`1<T> list, IEnumerable`1<U> other);
    [PureAttribute]
public static int length(IEnumerable`1<T> list);
    public static Unit iter(IEnumerable`1<T> list, Action`1<T> action);
    public static Unit iter(IEnumerable`1<T> list, Action`2<int, T> action);
    public static Unit consume(IEnumerable`1<T> list);
    [PureAttribute]
public static bool forall(IEnumerable`1<T> list, Func`2<T, bool> pred);
    [PureAttribute]
public static IEnumerable`1<T> distinct(IEnumerable`1<T> list);
    [PureAttribute]
public static IEnumerable`1<T> distinct(IEnumerable`1<T> list);
    [PureAttribute]
public static IEnumerable`1<T> distinct(IEnumerable`1<T> list, Func`2<T, K> keySelector, Option`1<Func`3<K, K, bool>> compare);
    [PureAttribute]
public static IEnumerable`1<T> take(IEnumerable`1<T> list, int count);
    [PureAttribute]
public static IEnumerable`1<T> takeWhile(IEnumerable`1<T> list, Func`2<T, bool> pred);
    [PureAttribute]
public static IEnumerable`1<T> takeWhile(IEnumerable`1<T> list, Func`3<T, int, bool> pred);
    [IteratorStateMachineAttribute("LanguageExt.List/<unfold>d__74`1")]
[PureAttribute]
public static IEnumerable`1<S> unfold(S state, Func`2<S, Option`1<S>> unfolder);
    [IteratorStateMachineAttribute("LanguageExt.List/<unfold>d__75`2")]
[PureAttribute]
public static IEnumerable`1<A> unfold(S state, Func`2<S, Option`1<ValueTuple`2<A, S>>> unfolder);
    [NullableContextAttribute("2")]
[IteratorStateMachineAttribute("LanguageExt.List/<unfold>d__76`3")]
[PureAttribute]
public static IEnumerable`1<A> unfold(ValueTuple`2<S1, S2> state, Func`3<S1, S2, Option`1<ValueTuple`3<A, S1, S2>>> unfolder);
    [NullableContextAttribute("2")]
[IteratorStateMachineAttribute("LanguageExt.List/<unfold>d__77`4")]
[PureAttribute]
public static IEnumerable`1<A> unfold(ValueTuple`3<S1, S2, S3> state, Func`4<S1, S2, S3, Option`1<ValueTuple`4<A, S1, S2, S3>>> unfolder);
    [NullableContextAttribute("2")]
[IteratorStateMachineAttribute("LanguageExt.List/<unfold>d__78`5")]
[PureAttribute]
public static IEnumerable`1<A> unfold(ValueTuple`4<S1, S2, S3, S4> state, Func`5<S1, S2, S3, S4, Option`1<ValueTuple`5<A, S1, S2, S3, S4>>> unfolder);
    [PureAttribute]
public static bool exists(IEnumerable`1<T> list, Func`2<T, bool> pred);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("headSafe has been deprecated, please use headOrNone")]
public static Option`1<T> headSafe(IEnumerable`1<T> list);
    [PureAttribute]
public static Iterable`1<B> apply(IEnumerable`1<Func`2<A, B>> fabc, IEnumerable`1<A> fa);
    [PureAttribute]
public static Iterable`1<Func`2<B, C>> apply(IEnumerable`1<Func`3<A, B, C>> fabc, IEnumerable`1<A> fa);
    [PureAttribute]
public static Iterable`1<C> apply(IEnumerable`1<Func`3<A, B, C>> fabc, IEnumerable`1<A> fa, IEnumerable`1<B> fb);
    [PureAttribute]
public static Iterable`1<Func`2<B, C>> apply(IEnumerable`1<Func`2<A, Func`2<B, C>>> fabc, IEnumerable`1<A> fa);
    [PureAttribute]
public static Iterable`1<C> apply(IEnumerable`1<Func`2<A, Func`2<B, C>>> fabc, IEnumerable`1<A> fa, IEnumerable`1<B> fb);
    [PureAttribute]
public static Iterable`1<B> action(IEnumerable`1<A> fa, IEnumerable`1<B> fb);
    [IteratorStateMachineAttribute("LanguageExt.List/<tails>d__87`1")]
[PureAttribute]
public static IEnumerable`1<IEnumerable`1<T>> tails(IEnumerable`1<T> self);
    [PureAttribute]
public static ValueTuple`2<IEnumerable`1<T>, IEnumerable`1<T>> span(IEnumerable`1<T> self, Func`2<T, bool> pred);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ListEnumerator`1 : ValueType {
    private ListItem`1[] stack;
    private int stackDepth;
    private ListItem`1<T> map;
    private int left;
    private bool rev;
    private int start;
    private int count;
    [CompilerGeneratedAttribute]
private ListItem`1<T> <NodeCurrent>k__BackingField;
    private ListItem`1<T> NodeCurrent { get; private set; }
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal ListEnumerator`1(ListItem`1<T> root, bool rev, int start, int count);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private ListItem`1<T> get_NodeCurrent();
    [CompilerGeneratedAttribute]
private void set_NodeCurrent(ListItem`1<T> value);
    [IsReadOnlyAttribute]
public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    private ListItem`1<T> Next(ListItem`1<T> node);
    private ListItem`1<T> Prev(ListItem`1<T> node);
    private void Push(ListItem`1<T> node);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.ListExtensions : object {
    [ExtensionAttribute]
public static Lst`1<A> As(K`2<Lst, A> xs);
    [ExtensionAttribute]
public static ValueTuple`2<A, IEnumerable`1<A>> HeadAndTail(IEnumerable`1<A> ma);
    [ExtensionAttribute]
public static Option`1<ValueTuple`2<A, IEnumerable`1<A>>> HeadAndTailSafe(IEnumerable`1<A> ma);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Lst`1<A> Flatten(Lst`1<Lst`1<A>> ma);
    [ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<A> Flatten(IEnumerable`1<IEnumerable`1<A>> ma);
    [ExtensionAttribute]
public static B Match(IEnumerable`1<A> list, Func`1<B> Empty, Func`2<Seq`1<A>, B> More);
    [ExtensionAttribute]
[PureAttribute]
public static B Match(IEnumerable`1<A> list, Func`1<B> Empty, Func`3<A, Seq`1<A>, B> More);
    [ExtensionAttribute]
[PureAttribute]
public static R Match(IEnumerable`1<T> list, Func`1<R> Empty, Func`2<T, R> One, Func`3<T, Seq`1<T>, R> More);
    [ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<A> Init(IEnumerable`1<A> list);
    [ExtensionAttribute]
[PureAttribute]
public static Iterable`1<T> Tail(IEnumerable`1<T> list);
    [IteratorStateMachineAttribute("LanguageExt.ListExtensions/<Intersperse>d__10`1")]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<A> Intersperse(IEnumerable`1<A> ma, A value);
    [ExtensionAttribute]
[PureAttribute]
public static string Concat(IEnumerable`1<string> xs);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Lst`1<A> Rev(Lst`1<A> list);
    [ExtensionAttribute]
[PureAttribute]
public static T Reduce(IEnumerable`1<T> list, Func`3<T, T, T> reducer);
    [ExtensionAttribute]
[PureAttribute]
public static T ReduceBack(IEnumerable`1<T> list, Func`3<T, T, T> reducer);
    [ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<S> Scan(IEnumerable`1<T> list, S state, Func`3<S, T, S> folder);
    [ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<S> ScanBack(IEnumerable`1<T> list, S state, Func`3<S, T, S> folder);
    [ExtensionAttribute]
public static Unit Consume(IEnumerable`1<T> list);
    [ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<T> Distinct(IEnumerable`1<T> list);
    [ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<IEnumerable`1<T>> Tails(IEnumerable`1<T> self);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`2<IEnumerable`1<T>, IEnumerable`1<T>> Span(IEnumerable`1<T> self, Func`2<T, bool> pred);
    [ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<R> Bind(IEnumerable`1<T> self, Func`2<T, IEnumerable`1<R>> binder);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Lst`1<B> Select(Lst`1<A> self, Func`2<A, B> map);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<B> BindEnumerable(Lst`1<A> self, Func`2<A, Lst`1<B>> binder);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Lst`1<B> Bind(Lst`1<A> self, Func`2<A, Lst`1<B>> binder);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Lst`1<B> Bind(Lst`1<A> self, Func`2<A, K`2<Lst, B>> binder);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static int Count(Lst`1<A> self);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Lst`1<C> SelectMany(Lst`1<A> self, Func`2<A, Lst`1<B>> bind, Func`3<A, B, C> project);
    [IteratorStateMachineAttribute("LanguageExt.ListExtensions/<SkipLast>d__28`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> SkipLast(IEnumerable`1<T> self);
    [IteratorStateMachineAttribute("LanguageExt.ListExtensions/<SkipLast>d__29`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> SkipLast(IEnumerable`1<T> self, int n);
    [ExtensionAttribute]
public static Option`1<A> ToOption(IEnumerable`1<A> self);
    [ExtensionAttribute]
[PureAttribute]
public static IQueryable`1<A> AsQueryable(Lst`1<A> source);
    [IteratorStateMachineAttribute("LanguageExt.ListExtensions/<<HeadAndTailSafe>g__tail|2_0>d`1")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<A> <HeadAndTailSafe>g__tail|2_0(IEnumerator`1<A> rest);
}
public interface LanguageExt.ListInfo {
    public int Count { get; }
    public abstract virtual int get_Count();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.ListItem`1 : object {
    public static ListItem`1<T> Empty;
    public int Count;
    public byte Height;
    public ListItem`1<T> Left;
    public ListItem`1<T> Right;
    [CompilerGeneratedAttribute]
private T <Key>k__BackingField;
    public static ListItem`1<T> EmptyM { get; }
    public bool IsEmpty { get; }
    internal int BalanceFactor { get; }
    public T Key { get; internal set; }
    public bool IsBalanced { get; }
    internal ListItem`1(byte height, int count, ListItem`1<T> left, T key, ListItem`1<T> right);
    private static ListItem`1();
    public static ListItem`1<T> get_EmptyM();
    public bool get_IsEmpty();
    internal int get_BalanceFactor();
    [CompilerGeneratedAttribute]
public T get_Key();
    [CompilerGeneratedAttribute]
internal void set_Key(T value);
    public bool get_IsBalanced();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class LanguageExt.ListModule : object {
    public static S Fold(ListItem`1<T> node, S state, Func`3<S, T, S> folder);
    public static bool ForAll(ListItem`1<A> node, Func`2<A, bool> pred);
    public static bool Exists(ListItem`1<T> node, Func`2<T, bool> pred);
    public static ListItem`1<U> Map(ListItem`1<T> node, Func`2<T, U> f);
    public static ListItem`1<A> AddRange(ListItem`1<A> node, IEnumerable`1<A> items);
    private static ListItem`1<A> AddRange(ListItem`1<A> node, ListItem`1<A> insertNode);
    public static ListItem`1<A> InsertMany(ListItem`1<A> node, IEnumerable`1<A> items, int index);
    public static ListItem`1<A> Insert(ListItem`1<A> node, A key, int index);
    public static ListItem`1<A> Add(ListItem`1<A> node, A key);
    public static ListItem`1<A> SetItem(ListItem`1<A> node, A key, int index);
    public static T GetItem(ListItem`1<T> node, int index);
    public static ListItem`1<T> Remove(ListItem`1<T> node, Func`2<T, bool> pred);
    public static ListItem`1<T> Remove(ListItem`1<T> node, T value, IEqualityComparer`1<T> compare);
    public static ListItem`1<T> Remove(ListItem`1<T> node, int index);
    public static int Find(ListItem`1<T> node, T key, int index, int count, IComparer`1<T> comparer);
    public static ListItem`1<T> Skip(ListItem`1<T> node, int amount);
    public static ListItem`1<T> Make(T k, ListItem`1<T> l, ListItem`1<T> r);
    public static ListItem`1<T> Balance(ListItem`1<T> node);
    public static ListItem`1<T> RotRight(ListItem`1<T> node);
    public static ListItem`1<T> RotLeft(ListItem`1<T> node);
    public static ListItem`1<T> DblRotRight(ListItem`1<T> node);
    public static ListItem`1<T> DblRotLeft(ListItem`1<T> node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class LanguageExt.ListModuleM : object {
    public static ListItem`1<A> InsertMany(ListItem`1<A> node, IEnumerable`1<A> items, int index);
    public static ListItem`1<A> InsertMany(ListItem`1<A> node, ReadOnlySpan`1<A> items, int index);
    public static ListItem`1<A> BuildSubTree(IEnumerable`1<A> items);
    public static ListItem`1<A> BuildSubTree(ReadOnlySpan`1<A> items);
    public static ListItem`1<A> Insert(ListItem`1<A> node, ListItem`1<A> insertNode, int index);
    public static ListItem`1<T> Balance(ListItem`1<T> node);
    public static ListItem`1<T> DblRotRight(ListItem`1<T> node);
    public static ListItem`1<T> DblRotLeft(ListItem`1<T> node);
    public static ListItem`1<A> RotRight(ListItem`1<A> node);
    public static ListItem`1<A> RotLeft(ListItem`1<A> node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Lst : object {
    private static override K`2<Lst, B> LanguageExt.Traits.Monad<LanguageExt.Lst>.Bind(K`2<Lst, A> ma, Func`2<A, K`2<Lst, B>> f);
    private static override K`2<Lst, B> LanguageExt.Traits.Functor<LanguageExt.Lst>.Map(Func`2<A, B> f, K`2<Lst, A> ma);
    private static override K`2<Lst, A> LanguageExt.Traits.Applicative<LanguageExt.Lst>.Pure(A value);
    private static override K`2<Lst, B> LanguageExt.Traits.Applicative<LanguageExt.Lst>.Apply(K`2<Lst, Func`2<A, B>> mf, K`2<Lst, A> ma);
    private static override K`2<Lst, B> LanguageExt.Traits.Applicative<LanguageExt.Lst>.Action(K`2<Lst, A> ma, K`2<Lst, B> mb);
    private static override K`2<Lst, A> LanguageExt.Traits.MonoidK<LanguageExt.Lst>.Empty();
    private static override K`2<Lst, A> LanguageExt.Traits.SemigroupK<LanguageExt.Lst>.Combine(K`2<Lst, A> ma, K`2<Lst, A> mb);
    private static override K`2<F, K`2<Lst, B>> LanguageExt.Traits.Traversable<LanguageExt.Lst>.Traverse(Func`2<A, K`2<F, B>> f, K`2<Lst, A> ta);
    private static override K`2<F, K`2<Lst, B>> LanguageExt.Traits.Traversable<LanguageExt.Lst>.TraverseM(Func`2<A, K`2<F, B>> f, K`2<Lst, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Lst>.FoldWhile(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<Lst, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Lst>.FoldBackWhile(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<Lst, A> ta);
    private static override int LanguageExt.Traits.Foldable<LanguageExt.Lst>.Count(K`2<Lst, A> ta);
    private static override bool LanguageExt.Traits.Foldable<LanguageExt.Lst>.IsEmpty(K`2<Lst, A> ta);
    private static override Option`1<A> LanguageExt.Traits.Foldable<LanguageExt.Lst>.At(K`2<Lst, A> ta, Index index);
    private static override Arr`1<A> LanguageExt.Traits.Foldable<LanguageExt.Lst>.ToArr(K`2<Lst, A> ta);
    private static override Lst`1<A> LanguageExt.Traits.Foldable<LanguageExt.Lst>.ToLst(K`2<Lst, A> ta);
    private static override Iterable`1<A> LanguageExt.Traits.Foldable<LanguageExt.Lst>.ToIterable(K`2<Lst, A> ta);
    private static override Seq`1<A> LanguageExt.Traits.Foldable<LanguageExt.Lst>.ToSeq(K`2<Lst, A> ta);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[CollectionBuilderAttribute("LanguageExt.List", "createRange")]
public class LanguageExt.Lst`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Lst`1<A> <Empty>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private LstInternal`1<A> value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Lst`1<A> Empty { get; }
    internal LstInternal`1<A> Value { get; }
    private ListItem`1<A> Root { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [NullableAttribute("2")]
[PureAttribute]
public object Case { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public static Lens`2<Lst`1<A>, A> head { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public static Lens`2<Lst`1<A>, Option`1<A>> headOrNone { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public static Lens`2<Lst`1<A>, A> tail { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public static Lens`2<Lst`1<A>, Option`1<A>> tailOrNone { get; }
    [PureAttribute]
public A Item { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
private int System.Collections.Generic.IReadOnlyCollection<A>.Count { get; }
    [PureAttribute]
private A System.Collections.Generic.IReadOnlyList<A>.Item { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Lst`1<A> AdditiveIdentity { get; }
    public Lst`1(IEnumerable`1<A> initial);
    public Lst`1(ReadOnlySpan`1<A> initial);
    private Lst`1(LstInternal`1<A> initial);
    internal Lst`1(ListItem`1<A> root);
    private static Lst`1();
    [CompilerGeneratedAttribute]
public static override Lst`1<A> get_Empty();
    internal LstInternal`1<A> get_Value();
    private ListItem`1<A> get_Root();
    public bool get_IsEmpty();
    [NullableContextAttribute("2")]
public object get_Case();
    public static Lens`2<Lst`1<A>, A> get_head();
    public static Lens`2<Lst`1<A>, Option`1<A>> get_headOrNone();
    public static Lens`2<Lst`1<A>, A> get_tail();
    public static Lens`2<Lst`1<A>, Option`1<A>> get_tailOrNone();
    [PureAttribute]
public static Lens`2<Lst`1<A>, A> item(int index);
    [PureAttribute]
public static Lens`2<Lst`1<A>, Option`1<A>> itemOrNone(int index);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Lens`2<Lst`1<A>, Lst`1<B>> map(Lens`2<A, B> lens);
    public A get_Item(Index index);
    [PureAttribute]
public Option`1<A> At(int index);
    public int get_Count();
    private sealed virtual override int System.Collections.Generic.IReadOnlyCollection<A>.get_Count();
    [PureAttribute]
public StreamT`2<M, A> AsStream();
    private sealed virtual override A System.Collections.Generic.IReadOnlyList<A>.get_Item(int index);
    private Lst`1<A> Wrap(LstInternal`1<A> list);
    private static Lst`1<X> Wrap(LstInternal`1<X> list);
    [PureAttribute]
public bool Contains(A value);
    [PureAttribute]
public bool Contains(A value);
    [PureAttribute]
public Lst`1<A> Add(A value);
    [PureAttribute]
public Lst`1<A> AddRange(IEnumerable`1<A> items);
    [PureAttribute]
public Lst`1<A> Clear();
    [PureAttribute]
public ListEnumerator`1<A> GetEnumerator();
    [PureAttribute]
public int IndexOf(A item, int index, int count, IEqualityComparer`1<A> equalityComparer);
    [PureAttribute]
public Lst`1<A> Insert(int index, A value);
    [PureAttribute]
public Lst`1<A> InsertRange(int index, IEnumerable`1<A> items);
    [PureAttribute]
public int LastIndexOf(A item, int index, int count, IEqualityComparer`1<A> equalityComparer);
    [PureAttribute]
public Lst`1<A> Remove(A value);
    [PureAttribute]
public Lst`1<A> Remove(A value, IEqualityComparer`1<A> equalityComparer);
    [PureAttribute]
public Lst`1<A> RemoveAll(Func`2<A, bool> pred);
    [PureAttribute]
public Lst`1<A> RemoveAt(int index);
    [PureAttribute]
public Lst`1<A> RemoveRange(int index, int count);
    [PureAttribute]
public Lst`1<A> SetItem(int index, A value);
    [PureAttribute]
public Iterable`1<A> FindRange(int index, int count);
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator`1<A> System.Collections.Generic.IEnumerable<A>.GetEnumerator();
    [PureAttribute]
public Seq`1<A> ToSeq();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToFullString(string separator);
    [PureAttribute]
public string ToFullArrayString(string separator);
    [PureAttribute]
public Iterable`1<A> AsIterable();
    [PureAttribute]
public Iterable`1<A> Skip(int amount);
    [PureAttribute]
public Lst`1<A> Reverse();
    public Lst`1<A> Do(Action`1<A> f);
    [PureAttribute]
public Lst`1<U> Map(Func`2<A, U> map);
    [PureAttribute]
public K`2<F, Lst`1<B>> Traverse(Func`2<A, K`2<F, B>> f);
    [PureAttribute]
public K`2<M, Lst`1<B>> TraverseM(Func`2<A, K`2<M, B>> f);
    [PureAttribute]
public Lst`1<A> Filter(Func`2<A, bool> pred);
    [PureAttribute]
public static Lst`1<A> op_Addition(Lst`1<A> lhs, A rhs);
    [PureAttribute]
public static Lst`1<A> op_Addition(A lhs, Lst`1<A> rhs);
    [PureAttribute]
public static override Lst`1<A> op_Addition(Lst`1<A> lhs, Lst`1<A> rhs);
    [PureAttribute]
public sealed virtual Lst`1<A> Combine(Lst`1<A> rhs);
    [PureAttribute]
public static override Lst`1<A> op_Subtraction(Lst`1<A> lhs, Lst`1<A> rhs);
    [PureAttribute]
public Lst`1<A> Subtract(Lst`1<A> rhs);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[PureAttribute]
public sealed virtual int CompareTo(object obj);
    [PureAttribute]
public sealed virtual bool Equals(Lst`1<A> other);
    [PureAttribute]
public static override bool op_Equality(Lst`1<A> lhs, Lst`1<A> rhs);
    [PureAttribute]
public static override bool op_Inequality(Lst`1<A> lhs, Lst`1<A> rhs);
    [PureAttribute]
public static override bool op_LessThan(Lst`1<A> lhs, Lst`1<A> rhs);
    [PureAttribute]
public static override bool op_LessThanOrEqual(Lst`1<A> lhs, Lst`1<A> rhs);
    [PureAttribute]
public static override bool op_GreaterThan(Lst`1<A> lhs, Lst`1<A> rhs);
    [PureAttribute]
public static override bool op_GreaterThanOrEqual(Lst`1<A> lhs, Lst`1<A> rhs);
    [PureAttribute]
public Arr`1<A> ToArr();
    [PureAttribute]
internal A[] ToArray();
    [PureAttribute]
public sealed virtual int CompareTo(Lst`1<A> other);
    public static Lst`1<A> op_Implicit(SeqEmpty _);
    public static override Lst`1<A> get_AdditiveIdentity();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class LanguageExt.LstInternal`1 : object {
    public static LstInternal`1<A> Empty;
    internal ListItem`1<A> root;
    internal int hashCode;
    internal ListItem`1<A> Root { get; }
    [PureAttribute]
public A Item { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
private int System.Collections.Generic.IReadOnlyCollection<A>.Count { get; }
    [PureAttribute]
private A System.Collections.Generic.IReadOnlyList<A>.Item { get; }
    internal LstInternal`1(IEnumerable`1<A> items);
    internal LstInternal`1(ReadOnlySpan`1<A> items);
    internal LstInternal`1(ListItem`1<A> root);
    private static LstInternal`1();
    internal static LstInternal`1<A> Wrap(ListItem`1<A> list);
    internal ListItem`1<A> get_Root();
    public A get_Item(int index);
    public sealed virtual int get_Count();
    private sealed virtual override int System.Collections.Generic.IReadOnlyCollection<A>.get_Count();
    private sealed virtual override A System.Collections.Generic.IReadOnlyList<A>.get_Item(int index);
    [PureAttribute]
public LstInternal`1<A> Add(A value);
    [PureAttribute]
public LstInternal`1<A> AddRange(IEnumerable`1<A> items);
    [PureAttribute]
public LstInternal`1<A> Clear();
    [PureAttribute]
public ListEnumerator`1<A> GetEnumerator();
    [PureAttribute]
public int IndexOf(A item, int index, int count, IEqualityComparer`1<A> equalityComparer);
    [PureAttribute]
public LstInternal`1<A> Insert(int index, A value);
    [PureAttribute]
public LstInternal`1<A> InsertRange(int index, IEnumerable`1<A> items);
    [PureAttribute]
public int LastIndexOf(A item, int index, int count, IEqualityComparer`1<A> equalityComparer);
    [PureAttribute]
public LstInternal`1<A> Remove(A value);
    [PureAttribute]
public LstInternal`1<A> Remove(A value, IEqualityComparer`1<A> equalityComparer);
    [PureAttribute]
public LstInternal`1<A> RemoveAll(Func`2<A, bool> pred);
    [PureAttribute]
public LstInternal`1<A> RemoveAt(int index);
    [PureAttribute]
public LstInternal`1<A> RemoveRange(int index, int count);
    [PureAttribute]
public LstInternal`1<A> SetItem(int index, A value);
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator`1<A> System.Collections.Generic.IEnumerable<A>.GetEnumerator();
    [PureAttribute]
public Iterable`1<A> Skip(int amount);
    [PureAttribute]
public LstInternal`1<A> Reverse();
    [PureAttribute]
public S Fold(S state, Func`3<S, A, S> folder);
    [PureAttribute]
public LstInternal`1<U> Map(Func`2<A, U> map);
    [PureAttribute]
public Iterable`1<A> FindRange(int index, int count);
    [PureAttribute]
public LstInternal`1<A> Filter(Func`2<A, bool> pred);
    [PureAttribute]
public static LstInternal`1<A> op_Addition(LstInternal`1<A> lhs, A rhs);
    [PureAttribute]
public static LstInternal`1<A> op_Addition(A rhs, LstInternal`1<A> lhs);
    [PureAttribute]
public static LstInternal`1<A> op_Addition(LstInternal`1<A> lhs, LstInternal`1<A> rhs);
    [PureAttribute]
public LstInternal`1<A> Combine(LstInternal`1<A> rhs);
    [PureAttribute]
public static LstInternal`1<A> op_Subtraction(LstInternal`1<A> lhs, LstInternal`1<A> rhs);
    [PureAttribute]
public LstInternal`1<A> Subtract(LstInternal`1<A> rhs);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public virtual int GetHashCode();
    [PureAttribute]
public sealed virtual bool Equals(LstInternal`1<A> other);
    [PureAttribute]
public static bool op_Equality(LstInternal`1<A> lhs, LstInternal`1<A> rhs);
    [PureAttribute]
public static bool op_Inequality(LstInternal`1<A> lhs, LstInternal`1<A> rhs);
    [PureAttribute]
public int CompareTo(LstInternal`1<A> other);
    [PureAttribute]
public int CompareTo(LstInternal`1<A> other);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.Map : object {
    [PureAttribute]
public static Map`2<K, V> empty();
    [PureAttribute]
public static Map`2<K, V> singleton(ValueTuple`2<K, V> value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`2<K, V> singleton(K key, V value);
    [PureAttribute]
public static Map`2<K, V> create();
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`2<K, V> create(Tuple`2<K, V> head, Tuple`2[] tail);
    [PureAttribute]
public static Map`2<K, V> create(KeyValuePair`2<K, V> head, KeyValuePair`2[] tail);
    [PureAttribute]
public static Map`2<K, V> create(ValueTuple`2<K, V> head, ValueTuple`2[] tail);
    [PureAttribute]
public static Map`2<K, V> createRange(IEnumerable`1<Tuple`2<K, V>> keyValues);
    [PureAttribute]
public static Map`2<K, V> createRange(IEnumerable`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static Map`2<K, V> createRange(ReadOnlySpan`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static Map`2<K, V> createRange(IEnumerable`1<KeyValuePair`2<K, V>> keyValues);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`2<K, V> add(Map`2<K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`2<K, V> tryAdd(Map`2<K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`2<K, V> tryAdd(Map`2<K, V> map, K key, V value, Func`3<Map`2<K, V>, V, Map`2<K, V>> Fail);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`2<K, V> addOrUpdate(Map`2<K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`2<K, V> addOrUpdate(Map`2<K, V> map, K key, Func`2<V, V> Some, Func`1<V> None);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`2<K, V> addOrUpdate(Map`2<K, V> map, K key, Func`2<V, V> Some, V None);
    [PureAttribute]
public static Map`2<K, V> addRange(Map`2<K, V> map, IEnumerable`1<Tuple`2<K, V>> keyValues);
    [PureAttribute]
public static Map`2<K, V> addRange(Map`2<K, V> map, IEnumerable`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static Map`2<K, V> addRange(Map`2<K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> keyValues);
    [PureAttribute]
public static Map`2<K, V> tryAddRange(Map`2<K, V> map, IEnumerable`1<Tuple`2<K, V>> keyValues);
    [PureAttribute]
public static Map`2<K, V> tryAddRange(Map`2<K, V> map, IEnumerable`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static Map`2<K, V> tryAddRange(Map`2<K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> keyValues);
    [PureAttribute]
public static Map`2<K, V> addOrUpdateRange(Map`2<K, V> map, IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public static Map`2<K, V> addOrUpdateRange(Map`2<K, V> map, IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public static Map`2<K, V> addOrUpdateRange(Map`2<K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> range);
    [PureAttribute]
public static Map`2<K, V> remove(Map`2<K, V> map, K key);
    [PureAttribute]
public static bool containsKey(Map`2<K, V> map, K key);
    [PureAttribute]
public static bool contains(Map`2<K, V> map, KeyValuePair`2<K, V> kv);
    [PureAttribute]
public static bool contains(Map`2<K, V> map, Tuple`2<K, V> kv);
    [PureAttribute]
public static bool contains(Map`2<K, V> map, ValueTuple`2<K, V> kv);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`2<K, V> setItem(Map`2<K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`2<K, V> trySetItem(Map`2<K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`2<K, V> trySetItem(Map`2<K, V> map, K key, Func`2<V, V> Some);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`2<K, V> trySetItem(Map`2<K, V> map, K key, Func`2<V, V> Some, Func`2<Map`2<K, V>, Map`2<K, V>> None);
    [PureAttribute]
public static Map`2<K, V> setItems(Map`2<K, V> map, IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public static Map`2<K, V> setItems(Map`2<K, V> map, IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public static Map`2<K, V> setItems(Map`2<K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> items);
    [PureAttribute]
public static Map`2<K, V> trySetItems(Map`2<K, V> map, IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public static Map`2<K, V> trySetItems(Map`2<K, V> map, IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public static Map`2<K, V> trySetItems(Map`2<K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> items);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`2<K, V> trySetItems(Map`2<K, V> map, IEnumerable`1<K> keys, Func`2<V, V> Some);
    [PureAttribute]
public static Option`1<V> find(Map`2<K, V> map, K key);
    [NullableContextAttribute("1")]
[PureAttribute]
public static IEnumerable`1<V> findSeq(Map`2<K, V> map, K key);
    [NullableContextAttribute("1")]
[PureAttribute]
public static R find(Map`2<K, V> map, K key, Func`2<V, R> Some, Func`1<R> None);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`2<K, V> setItem(Map`2<K, V> map, K key, Func`2<V, V> mapper);
    [NullableContextAttribute("1")]
[PureAttribute]
public static IEnumerable`1<V> findRange(Map`2<K, V> map, K keyFrom, K keyTo);
    [PureAttribute]
public static IEnumerable`1<ValueTuple`2<K, V>> skip(Map`2<K, V> map, int amount);
    public static Unit iter(Map`2<K, V> map, Action`1<V> action);
    public static Unit iter(Map`2<K, V> map, Action`2<K, V> action);
    [PureAttribute]
public static bool forall(Map`2<K, V> map, Func`2<V, bool> pred);
    [PureAttribute]
public static bool forall(Map`2<K, V> map, Func`3<K, V, bool> pred);
    [PureAttribute]
public static bool forall(Map`2<K, V> map, Func`2<Tuple`2<K, V>, bool> pred);
    [PureAttribute]
public static bool forall(Map`2<K, V> map, Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public static bool forall(Map`2<K, V> map, Func`2<KeyValuePair`2<K, V>, bool> pred);
    [PureAttribute]
public static Map`2<K, U> map(Map`2<K, T> map, Func`2<T, U> f);
    [PureAttribute]
public static Map`2<K, U> map(Map`2<K, T> map, Func`3<K, T, U> f);
    [PureAttribute]
public static Map`2<K, V> filter(Map`2<K, V> map, Func`2<V, bool> predicate);
    [PureAttribute]
public static Map`2<K, V> filter(Map`2<K, V> map, Func`3<K, V, bool> predicate);
    [PureAttribute]
public static Map`2<K, R> choose(Map`2<K, T> map, Func`2<T, Option`1<R>> selector);
    [PureAttribute]
public static Map`2<K, R> choose(Map`2<K, T> map, Func`3<K, T, Option`1<R>> selector);
    [PureAttribute]
public static int length(Map`2<K, T> map);
    [NullableContextAttribute("1")]
[PureAttribute]
public static S fold(Map`2<K, V> map, S state, Func`4<S, K, V, S> folder);
    [NullableContextAttribute("1")]
[PureAttribute]
public static S fold(Map`2<K, V> map, S state, Func`3<S, V, S> folder);
    [PureAttribute]
public static bool exists(Map`2<K, V> map, Func`3<K, V, bool> pred);
    [PureAttribute]
public static bool exists(Map`2<K, V> map, Func`2<Tuple`2<K, V>, bool> pred);
    [PureAttribute]
public static bool exists(Map`2<K, V> map, Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public static bool exists(Map`2<K, V> map, Func`2<KeyValuePair`2<K, V>, bool> pred);
    [PureAttribute]
public static bool exists(Map`2<K, V> map, Func`2<V, bool> pred);
    [PureAttribute]
public static Map`2<K, V> toMap(IDictionary`2<K, V> dict);
    [ExtensionAttribute]
[PureAttribute]
public static Map`2<K, V> ToMap(IDictionary`2<K, V> dict);
    [PureAttribute]
public static HashMap`2<K, V> toHashMap(IDictionary`2<K, V> dict);
    [ExtensionAttribute]
[PureAttribute]
public static HashMap`2<K, V> ToHashMap(IDictionary`2<K, V> dict);
    [PureAttribute]
public static Map`2<K, V> union(Map`2<K, V> left, Map`2<K, V> right, WhenMatched`4<K, V, V, V> Merge);
    [PureAttribute]
public static Map`2<K, A> union(Map`2<K, A> left, Map`2<K, B> right, WhenMissing`3<K, B, A> MapRight, WhenMatched`4<K, A, B, A> Merge);
    [PureAttribute]
public static Map`2<K, B> union(Map`2<K, A> left, Map`2<K, B> right, WhenMissing`3<K, A, B> MapLeft, WhenMatched`4<K, A, B, B> Merge);
    [PureAttribute]
public static Map`2<K, C> union(Map`2<K, A> left, Map`2<K, B> right, WhenMissing`3<K, A, C> MapLeft, WhenMissing`3<K, B, C> MapRight, WhenMatched`4<K, A, B, C> Merge);
    [PureAttribute]
public static Map`2<K, R> intersect(Map`2<K, A> left, Map`2<K, B> right, WhenMatched`4<K, A, B, R> merge);
    [PureAttribute]
public static Map`2<K, V> except(Map`2<K, V> left, Map`2<K, V> right);
    [PureAttribute]
public static Map`2<K, V> symmetricExcept(Map`2<K, V> left, Map`2<K, V> right);
    [PureAttribute]
public static Map`3<OrdK, K, V> empty();
    [PureAttribute]
public static Map`3<OrdK, K, V> singleton(ValueTuple`2<K, V> value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> singleton(K key, V value);
    [PureAttribute]
public static Map`3<OrdK, K, V> create();
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> create(Tuple`2<K, V> head, Tuple`2[] tail);
    [PureAttribute]
public static Map`3<OrdK, K, V> create(ValueTuple`2<K, V> head, ValueTuple`2[] tail);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> createRange(IEnumerable`1<Tuple`2<K, V>> keyValues);
    [PureAttribute]
public static Map`3<OrdK, K, V> createRange(IEnumerable`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static Map`3<OrdK, K, V> createRange(ReadOnlySpan`1<ValueTuple`2<K, V>> keyValues);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> add(Map`3<OrdK, K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> tryAdd(Map`3<OrdK, K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> tryAdd(Map`3<OrdK, K, V> map, K key, V value, Func`3<Map`3<OrdK, K, V>, V, Map`3<OrdK, K, V>> Fail);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> addOrUpdate(Map`3<OrdK, K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> addOrUpdate(Map`3<OrdK, K, V> map, K key, Func`2<V, V> Some, Func`1<V> None);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> addOrUpdate(Map`3<OrdK, K, V> map, K key, Func`2<V, V> Some, V None);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> addRange(Map`3<OrdK, K, V> map, IEnumerable`1<Tuple`2<K, V>> keyValues);
    [PureAttribute]
public static Map`3<OrdK, K, V> addRange(Map`3<OrdK, K, V> map, IEnumerable`1<ValueTuple`2<K, V>> keyValues);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> tryAddRange(Map`3<OrdK, K, V> map, IEnumerable`1<Tuple`2<K, V>> keyValues);
    [PureAttribute]
public static Map`3<OrdK, K, V> tryAddRange(Map`3<OrdK, K, V> map, IEnumerable`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static Map`3<OrdK, K, V> tryAddRange(Map`3<OrdK, K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> keyValues);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> addOrUpdateRange(Map`3<OrdK, K, V> map, IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public static Map`3<OrdK, K, V> addOrUpdateRange(Map`3<OrdK, K, V> map, IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public static Map`3<OrdK, K, V> addOrUpdateRange(Map`3<OrdK, K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> range);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> remove(Map`3<OrdK, K, V> map, K key);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool containsKey(Map`3<OrdK, K, V> map, K key);
    [PureAttribute]
public static bool contains(Map`3<OrdK, K, V> map, KeyValuePair`2<K, V> kv);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool contains(Map`3<OrdK, K, V> map, Tuple`2<K, V> kv);
    [PureAttribute]
public static bool contains(Map`3<OrdK, K, V> map, ValueTuple`2<K, V> kv);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> setItem(Map`3<OrdK, K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> trySetItem(Map`3<OrdK, K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> trySetItem(Map`3<OrdK, K, V> map, K key, Func`2<V, V> Some);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> trySetItem(Map`3<OrdK, K, V> map, K key, Func`2<V, V> Some, Func`2<Map`2<K, V>, Map`2<K, V>> None);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> setItems(Map`3<OrdK, K, V> map, IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public static Map`3<OrdK, K, V> setItems(Map`3<OrdK, K, V> map, IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public static Map`3<OrdK, K, V> setItems(Map`3<OrdK, K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> items);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> trySetItems(Map`3<OrdK, K, V> map, IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public static Map`3<OrdK, K, V> trySetItems(Map`3<OrdK, K, V> map, IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public static Map`3<OrdK, K, V> trySetItems(Map`3<OrdK, K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> items);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> trySetItems(Map`3<OrdK, K, V> map, IEnumerable`1<K> keys, Func`2<V, V> Some);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Option`1<V> find(Map`3<OrdK, K, V> map, K key);
    [NullableContextAttribute("1")]
[PureAttribute]
public static IEnumerable`1<V> findSeq(Map`3<OrdK, K, V> map, K key);
    [NullableContextAttribute("1")]
[PureAttribute]
public static R find(Map`3<OrdK, K, V> map, K key, Func`2<V, R> Some, Func`1<R> None);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> setItem(Map`3<OrdK, K, V> map, K key, Func`2<V, V> mapper);
    [NullableContextAttribute("1")]
[PureAttribute]
public static IEnumerable`1<V> findRange(Map`3<OrdK, K, V> map, K keyFrom, K keyTo);
    [PureAttribute]
public static IEnumerable`1<ValueTuple`2<K, V>> skip(Map`3<OrdK, K, V> map, int amount);
    [NullableContextAttribute("1")]
public static Unit iter(Map`3<OrdK, K, V> map, Action`1<V> action);
    [NullableContextAttribute("1")]
public static Unit iter(Map`3<OrdK, K, V> map, Action`2<K, V> action);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool forall(Map`3<OrdK, K, V> map, Func`2<V, bool> pred);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool forall(Map`3<OrdK, K, V> map, Func`3<K, V, bool> pred);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool forall(Map`3<OrdK, K, V> map, Func`2<Tuple`2<K, V>, bool> pred);
    [PureAttribute]
public static bool forall(Map`3<OrdK, K, V> map, Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public static bool forall(Map`3<OrdK, K, V> map, Func`2<KeyValuePair`2<K, V>, bool> pred);
    [PureAttribute]
public static Map`3<OrdK, K, U> map(Map`3<OrdK, K, T> map, Func`2<T, U> f);
    [PureAttribute]
public static Map`3<OrdK, K, U> map(Map`3<OrdK, K, T> map, Func`3<K, T, U> f);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> filter(Map`3<OrdK, K, V> map, Func`2<V, bool> predicate);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> filter(Map`3<OrdK, K, V> map, Func`3<K, V, bool> predicate);
    [PureAttribute]
public static Map`3<OrdK, K, R> choose(Map`3<OrdK, K, T> map, Func`2<T, Option`1<R>> selector);
    [PureAttribute]
public static Map`3<OrdK, K, R> choose(Map`3<OrdK, K, T> map, Func`3<K, T, Option`1<R>> selector);
    [PureAttribute]
public static int length(Map`3<OrdK, K, T> map);
    [NullableContextAttribute("1")]
[PureAttribute]
public static S fold(Map`3<OrdK, K, V> map, S state, Func`4<S, K, V, S> folder);
    [NullableContextAttribute("1")]
[PureAttribute]
public static S fold(Map`3<OrdK, K, V> map, S state, Func`3<S, V, S> folder);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool exists(Map`3<OrdK, K, V> map, Func`3<K, V, bool> pred);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool exists(Map`3<OrdK, K, V> map, Func`2<Tuple`2<K, V>, bool> pred);
    [PureAttribute]
public static bool exists(Map`3<OrdK, K, V> map, Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public static bool exists(Map`3<OrdK, K, V> map, Func`2<KeyValuePair`2<K, V>, bool> pred);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool exists(Map`3<OrdK, K, V> map, Func`2<V, bool> pred);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> toMap(IDictionary`2<K, V> dict);
    [NullableContextAttribute("1")]
[PureAttribute]
public static HashMap`3<OrdK, K, V> toHashMap(IDictionary`2<K, V> dict);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static HashMap`3<OrdK, K, V> ToHashMap(IDictionary`2<K, V> dict);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, V> union(Map`3<OrdK, K, V> left, Map`3<OrdK, K, V> right, WhenMatched`4<K, V, V, V> Merge);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, A> union(Map`3<OrdK, K, A> left, Map`3<OrdK, K, B> right, WhenMissing`3<K, B, A> MapRight, WhenMatched`4<K, A, B, A> Merge);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, B> union(Map`3<OrdK, K, A> left, Map`3<OrdK, K, B> right, WhenMissing`3<K, A, B> MapLeft, WhenMatched`4<K, A, B, B> Merge);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Map`3<OrdK, K, C> union(Map`3<OrdK, K, A> left, Map`3<OrdK, K, B> right, WhenMissing`3<K, A, C> MapLeft, WhenMissing`3<K, B, C> MapRight, WhenMatched`4<K, A, B, C> Merge);
    [PureAttribute]
public static Map`3<OrdK, K, R> intersect(Map`3<OrdK, K, A> left, Map`3<OrdK, K, B> right, WhenMatched`4<K, A, B, R> merge);
    [PureAttribute]
public static Map`3<OrdK, K, V> except(Map`3<OrdK, K, V> left, Map`3<OrdK, K, V> right);
    [PureAttribute]
public static Map`3<OrdK, K, V> symmetricExcept(Map`3<OrdK, K, V> left, Map`3<OrdK, K, V> right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Map`1 : object {
    private static override K`2<Map`1<Key>, B> LanguageExt.Traits.Functor<LanguageExt.Map<Key>>.Map(Func`2<A, B> f, K`2<Map`1<Key>, A> ma);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Map<Key>>.FoldWhile(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<Map`1<Key>, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Map<Key>>.FoldBackWhile(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<Map`1<Key>, A> ta);
    private static override int LanguageExt.Traits.Foldable<LanguageExt.Map<Key>>.Count(K`2<Map`1<Key>, A> ta);
    private static override bool LanguageExt.Traits.Foldable<LanguageExt.Map<Key>>.IsEmpty(K`2<Map`1<Key>, A> ta);
    private static override Option`1<A> LanguageExt.Traits.Foldable<LanguageExt.Map<Key>>.Head(K`2<Map`1<Key>, A> ta);
    private static override Option`1<A> LanguageExt.Traits.Foldable<LanguageExt.Map<Key>>.Last(K`2<Map`1<Key>, A> ta);
    private static override Option`1<A> LanguageExt.Traits.Foldable<LanguageExt.Map<Key>>.Min(K`2<Map`1<Key>, A> ta);
    private static override Option`1<A> LanguageExt.Traits.Foldable<LanguageExt.Map<Key>>.Max(K`2<Map`1<Key>, A> ta);
    private static override K`2<Map`1<Key>, A> LanguageExt.Traits.SemigroupK<LanguageExt.Map<Key>>.Combine(K`2<Map`1<Key>, A> lhs, K`2<Map`1<Key>, A> rhs);
    private static override K`2<Map`1<Key>, A> LanguageExt.Traits.MonoidK<LanguageExt.Map<Key>>.Empty();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[CollectionBuilderAttribute("LanguageExt.Map", "createRange")]
public class LanguageExt.Map`2 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Map`2<K, V> <Empty>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private MapInternal`3<OrdDefault`1<K>, K, V> value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Map`2<K, V> Empty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal MapInternal`3<OrdDefault`1<K>, K, V> Value { get; }
    [NullableAttribute("2")]
[PureAttribute]
public object Case { get; }
    [PureAttribute]
public V Item { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public int Length { get; }
    [PureAttribute]
public Iterable`1<K> Keys { get; }
    [PureAttribute]
public Iterable`1<V> Values { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> Pairs { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
[ObsoleteAttribute("Use Pairs instead")]
public Iterable`1<ValueTuple`2<K, V>> ValueTuples { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Option`1<ValueTuple`2<K, V>> Min { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Option`1<ValueTuple`2<K, V>> Max { get; }
    [PureAttribute]
private IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.Keys { get; }
    [PureAttribute]
private IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.Values { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Map`2<K, V> AdditiveIdentity { get; }
    public Map`2(IEnumerable`1<ValueTuple`2<K, V>> items);
    public Map`2(IEnumerable`1<ValueTuple`2<K, V>> items, bool tryAdd);
    public Map`2(ReadOnlySpan`1<ValueTuple`2<K, V>> items);
    public Map`2(ReadOnlySpan`1<ValueTuple`2<K, V>> items, bool tryAdd);
    internal Map`2(MapInternal`3<OrdDefault`1<K>, K, V> value);
    internal Map`2(MapItem`2<K, V> root, bool rev);
    private static Map`2();
    [CompilerGeneratedAttribute]
public static override Map`2<K, V> get_Empty();
    internal static Map`2<K, V> Wrap(MapInternal`3<OrdDefault`1<K>, K, V> map);
    internal MapInternal`3<OrdDefault`1<K>, K, V> get_Value();
    [NullableContextAttribute("2")]
public object get_Case();
    [PureAttribute]
public static Lens`2<Map`2<K, V>, V> item(K key);
    [PureAttribute]
public static Lens`2<Map`2<K, V>, Option`1<V>> itemOrNone(K key);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Lens`2<Map`2<K, V>, Map`2<K, B>> map(Lens`2<V, B> lens);
    public sealed virtual V get_Item(K key);
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public int get_Length();
    [PureAttribute]
public Map`2<K, V> Add(K key, V value);
    [PureAttribute]
public Map`2<K, V> TryAdd(K key, V value);
    [PureAttribute]
public Map`2<K, V> TryAdd(K key, V value, Func`3<Map`2<K, V>, V, Map`2<K, V>> Fail);
    [PureAttribute]
public Map`2<K, V> AddRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public Map`2<K, V> AddRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public Map`2<K, V> TryAddRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public Map`2<K, V> TryAddRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public Map`2<K, V> TryAddRange(IEnumerable`1<KeyValuePair`2<K, V>> range);
    [PureAttribute]
public Map`2<K, V> AddOrUpdateRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public Map`2<K, V> AddOrUpdateRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public Map`2<K, V> AddOrUpdateRange(IEnumerable`1<KeyValuePair`2<K, V>> range);
    [PureAttribute]
public Map`2<K, V> Remove(K key);
    [PureAttribute]
public Option`1<V> Find(K key);
    [PureAttribute]
public Seq`1<V> FindSeq(K key);
    [PureAttribute]
public R Find(K key, Func`2<V, R> Some, Func`1<R> None);
    [PureAttribute]
public Option`1<ValueTuple`2<K, V>> FindPredecessor(K key);
    [PureAttribute]
public Option`1<ValueTuple`2<K, V>> FindExactOrPredecessor(K key);
    [PureAttribute]
public Option`1<ValueTuple`2<K, V>> FindSuccessor(K key);
    [PureAttribute]
public Option`1<ValueTuple`2<K, V>> FindExactOrSuccessor(K key);
    [PureAttribute]
public ValueTuple`2<Map`2<K, V>, V> FindOrAdd(K key, Func`1<V> None);
    [PureAttribute]
public ValueTuple`2<Map`2<K, V>, V> FindOrAdd(K key, V value);
    [PureAttribute]
public ValueTuple`2<Map`2<K, V>, Option`1<V>> FindOrMaybeAdd(K key, Func`1<Option`1<V>> None);
    [PureAttribute]
public ValueTuple`2<Map`2<K, V>, Option`1<V>> FindOrMaybeAdd(K key, Option`1<V> None);
    [PureAttribute]
public Map`2<K, V> SetItem(K key, V value);
    [PureAttribute]
public Map`2<K, V> SetItem(K key, Func`2<V, V> Some);
    [PureAttribute]
public Map`2<K, V> TrySetItem(K key, V value);
    [PureAttribute]
public Map`2<K, V> TrySetItem(K key, Func`2<V, V> Some);
    [PureAttribute]
public Map`2<K, V> TrySetItem(K key, Func`2<V, V> Some, Func`2<Map`2<K, V>, Map`2<K, V>> None);
    [PureAttribute]
public Map`2<K, V> AddOrUpdate(K key, V value);
    [PureAttribute]
public Map`2<K, V> AddOrUpdate(K key, Func`2<V, V> Some, Func`1<V> None);
    [PureAttribute]
public Map`2<K, V> AddOrUpdate(K key, Func`2<V, V> Some, V None);
    [PureAttribute]
public Iterable`1<V> FindRange(K keyFrom, K keyTo);
    [PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> FindRangePairs(K keyFrom, K keyTo);
    [PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> Skip(int amount);
    [PureAttribute]
public sealed virtual bool ContainsKey(K key);
    [PureAttribute]
public bool Contains(K key, V value);
    [PureAttribute]
public Map`2<K, V> Clear();
    [PureAttribute]
public Map`2<K, V> AddRange(IEnumerable`1<KeyValuePair`2<K, V>> pairs);
    [PureAttribute]
public Map`2<K, V> SetItems(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [PureAttribute]
public Map`2<K, V> SetItems(IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public Map`2<K, V> SetItems(IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public Map`2<K, V> TrySetItems(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [PureAttribute]
public Map`2<K, V> TrySetItems(IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public Map`2<K, V> TrySetItems(IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public Map`2<K, V> TrySetItems(IEnumerable`1<K> keys, Func`2<V, V> Some);
    [PureAttribute]
public Map`2<K, V> RemoveRange(IEnumerable`1<K> keys);
    [PureAttribute]
public bool Contains(KeyValuePair`2<K, V> pair);
    public Iterable`1<K> get_Keys();
    public Iterable`1<V> get_Values();
    [PureAttribute]
public IDictionary`2<KR, VR> ToDictionary(Func`2<ValueTuple`2<K, V>, KR> keySelector, Func`2<ValueTuple`2<K, V>, VR> valueSelector);
    public Iterable`1<ValueTuple`2<K, V>> get_Pairs();
    public Iterable`1<ValueTuple`2<K, V>> get_ValueTuples();
    [PureAttribute]
public MapEnumerator`2<K, V> GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator`1<ValueTuple`2<K, V>> System.Collections.Generic.IEnumerable<(KKey,VValue)>.GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public Seq`1<ValueTuple`2<K, V>> ToSeq();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToFullString(string separator);
    [PureAttribute]
public string ToFullArrayString(string separator);
    [PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> AsEnumerable();
    internal Map`2<K, V> SetRoot(MapItem`2<K, V> root);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`2<K, V> op_Implicit(ValueTuple`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`2<K, V> op_Implicit(ValueTuple`2<ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`2<K, V> op_Implicit(ValueTuple`3<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`2<K, V> op_Implicit(ValueTuple`4<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`2<K, V> op_Implicit(ValueTuple`5<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`2<K, V> op_Implicit(ValueTuple`6<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`2<K, V> op_Implicit(ValueTuple`7<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`1<ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`3<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`4<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`5<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`6<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`7<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`1<ValueTuple`2<K, V>>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<ValueTuple`2<K, V>, ValueTuple`2<K, V>>>> items);
    [PureAttribute]
public static override bool op_Equality(Map`2<K, V> lhs, Map`2<K, V> rhs);
    [PureAttribute]
public static override bool op_Inequality(Map`2<K, V> lhs, Map`2<K, V> rhs);
    [PureAttribute]
public static override bool op_LessThan(Map`2<K, V> lhs, Map`2<K, V> rhs);
    [PureAttribute]
public static override bool op_LessThanOrEqual(Map`2<K, V> lhs, Map`2<K, V> rhs);
    [PureAttribute]
public static override bool op_GreaterThan(Map`2<K, V> lhs, Map`2<K, V> rhs);
    [PureAttribute]
public static override bool op_GreaterThanOrEqual(Map`2<K, V> lhs, Map`2<K, V> rhs);
    [PureAttribute]
public sealed virtual Map`2<K, V> Combine(Map`2<K, V> y);
    [PureAttribute]
public static override Map`2<K, V> op_Addition(Map`2<K, V> lhs, Map`2<K, V> rhs);
    [PureAttribute]
public static override Map`2<K, V> op_Subtraction(Map`2<K, V> lhs, Map`2<K, V> rhs);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public sealed virtual bool Equals(Map`2<K, V> y);
    [NullableContextAttribute("0")]
[PureAttribute]
public bool Equals(Map`2<K, V> y);
    [PureAttribute]
public bool EqualsKeys(Map`2<K, V> y);
    [PureAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[PureAttribute]
public sealed virtual int CompareTo(object obj);
    public Map`2<K, V> Do(Action`1<V> f);
    [PureAttribute]
public Map`2<K, U> Select(Func`2<V, U> mapper);
    [PureAttribute]
public Map`2<K, U> Select(Func`3<K, V, U> mapper);
    [PureAttribute]
public Map`2<K, V> Where(Func`2<V, bool> valuePred);
    [PureAttribute]
public Map`2<K, V> Where(Func`3<K, V, bool> keyValuePred);
    [PureAttribute]
public Map`2<K, V> Filter(Func`2<V, bool> valuePred);
    [PureAttribute]
public Map`2<K, V> Filter(Func`3<K, V, bool> keyValuePred);
    [PureAttribute]
public bool ForAll(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<Tuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<KeyValuePair`2<K, V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<V, bool> pred);
    [PureAttribute]
public bool Exists(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<Tuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<KeyValuePair`2<K, V>, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<V, bool> pred);
    public Unit Iter(Action`2<K, V> action);
    public Unit Iter(Action`1<V> action);
    public Unit Iter(Action`1<Tuple`2<K, V>> action);
    public Unit Iter(Action`1<ValueTuple`2<K, V>> action);
    public Unit Iter(Action`1<KeyValuePair`2<K, V>> action);
    [NullableContextAttribute("2")]
[PureAttribute]
public Map`2<K, U> Choose(Func`3<K, V, Option`1<U>> selector);
    [NullableContextAttribute("2")]
[PureAttribute]
public Map`2<K, U> Choose(Func`2<V, Option`1<U>> selector);
    [PureAttribute]
public S Fold(S state, Func`4<S, K, V, S> folder);
    [PureAttribute]
public S Fold(S state, Func`3<S, V, S> folder);
    [PureAttribute]
public Map`2<K, V> Union(Map`2<K, V> other, WhenMatched`4<K, V, V, V> Merge);
    [PureAttribute]
public Map`2<K, V> Union(Map`2<K, V2> other, WhenMissing`3<K, V2, V> MapRight, WhenMatched`4<K, V, V2, V> Merge);
    [PureAttribute]
public Map`2<K, V2> Union(Map`2<K, V2> other, WhenMissing`3<K, V, V2> MapLeft, WhenMatched`4<K, V, V2, V2> Merge);
    [PureAttribute]
public Map`2<K, R> Union(Map`2<K, V2> other, WhenMissing`3<K, V, R> MapLeft, WhenMissing`3<K, V2, R> MapRight, WhenMatched`4<K, V, V2, R> Merge);
    [NullableContextAttribute("2")]
[PureAttribute]
public Map`2<K, R> Intersect(Map`2<K, V2> other, WhenMatched`4<K, V, V2, R> Merge);
    [PureAttribute]
public Map`2<K, V> Except(Map`2<K, V> other);
    [PureAttribute]
public Map`2<K, V> SymmetricExcept(Map`2<K, V> other);
    [PureAttribute]
public sealed virtual int CompareTo(Map`2<K, V> other);
    [NullableContextAttribute("0")]
[PureAttribute]
public int CompareTo(Map`2<K, V> other);
    [PureAttribute]
public int CompareKeysTo(Map`2<K, V> other);
    [PureAttribute]
public static Map`2<K, V> op_Implicit(SeqEmpty _);
    [PureAttribute]
public Map`2<K, V> Slice(K keyFrom, K keyTo);
    public Option`1<ValueTuple`2<K, V>> get_Min();
    public Option`1<ValueTuple`2<K, V>> get_Max();
    private sealed virtual override IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Keys();
    private sealed virtual override IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Values();
    [PureAttribute]
public sealed virtual bool TryGetValue(K key, V& value);
    [PureAttribute]
private sealed virtual override IEnumerator`1<KeyValuePair`2<K, V>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,V>>.GetEnumerator();
    public static override Map`2<K, V> get_AdditiveIdentity();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[CollectionBuilderAttribute("LanguageExt.Map", "createRange")]
public class LanguageExt.Map`3 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Map`3<OrdK, K, V> <Empty>k__BackingField;
    private MapInternal`3<OrdK, K, V> value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Map`3<OrdK, K, V> Empty { get; }
    internal MapInternal`3<OrdK, K, V> Value { get; }
    [NullableAttribute("2")]
[PureAttribute]
public object Case { get; }
    [PureAttribute]
public V Item { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public int Length { get; }
    [PureAttribute]
public Iterable`1<K> Keys { get; }
    [PureAttribute]
public Iterable`1<V> Values { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> Pairs { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
[ObsoleteAttribute("Use `Pairs` instead")]
public Iterable`1<ValueTuple`2<K, V>> ValueTuples { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Option`1<ValueTuple`2<K, V>> Min { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Option`1<ValueTuple`2<K, V>> Max { get; }
    [PureAttribute]
private IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.Keys { get; }
    [PureAttribute]
private IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.Values { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Map`3<OrdK, K, V> AdditiveIdentity { get; }
    public Map`3(IEnumerable`1<ValueTuple`2<K, V>> items);
    public Map`3(ReadOnlySpan`1<ValueTuple`2<K, V>> items);
    public Map`3(IEnumerable`1<ValueTuple`2<K, V>> items, bool tryAdd);
    public Map`3(ReadOnlySpan`1<ValueTuple`2<K, V>> items, bool tryAdd);
    internal Map`3(MapInternal`3<OrdK, K, V> value);
    internal Map`3(MapItem`2<K, V> root, bool rev);
    private static Map`3();
    [CompilerGeneratedAttribute]
public static override Map`3<OrdK, K, V> get_Empty();
    internal static Map`3<OrdK, K, V> Wrap(MapInternal`3<OrdK, K, V> map);
    internal MapInternal`3<OrdK, K, V> get_Value();
    [NullableContextAttribute("2")]
public object get_Case();
    public sealed virtual V get_Item(K key);
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public int get_Length();
    [PureAttribute]
public Map`3<OrdK, K, V> Add(K key, V value);
    [PureAttribute]
public Map`3<OrdK, K, V> TryAdd(K key, V value);
    [PureAttribute]
public Map`3<OrdK, K, V> TryAdd(K key, V value, Func`3<Map`3<OrdK, K, V>, V, Map`3<OrdK, K, V>> Fail);
    [PureAttribute]
public Map`3<OrdK, K, V> AddRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public Map`3<OrdK, K, V> AddRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public Map`3<OrdK, K, V> TryAddRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public Map`3<OrdK, K, V> TryAddRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public Map`3<OrdK, K, V> TryAddRange(IEnumerable`1<KeyValuePair`2<K, V>> range);
    [PureAttribute]
public Map`3<OrdK, K, V> AddOrUpdateRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public Map`3<OrdK, K, V> AddOrUpdateRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public Map`3<OrdK, K, V> AddOrUpdateRange(IEnumerable`1<KeyValuePair`2<K, V>> range);
    [PureAttribute]
public Map`3<OrdK, K, V> Remove(K key);
    [PureAttribute]
public Option`1<V> Find(K key);
    [PureAttribute]
public Seq`1<V> FindSeq(K key);
    [PureAttribute]
public R Find(K key, Func`2<V, R> Some, Func`1<R> None);
    [PureAttribute]
public Option`1<ValueTuple`2<K, V>> FindPredecessor(K key);
    [PureAttribute]
public Option`1<ValueTuple`2<K, V>> FindExactOrPredecessor(K key);
    [PureAttribute]
public Option`1<ValueTuple`2<K, V>> FindSuccessor(K key);
    [PureAttribute]
public Option`1<ValueTuple`2<K, V>> FindExactOrSuccessor(K key);
    [PureAttribute]
public ValueTuple`2<Map`3<OrdK, K, V>, V> FindOrAdd(K key, Func`1<V> None);
    [PureAttribute]
public ValueTuple`2<Map`3<OrdK, K, V>, V> FindOrAdd(K key, V value);
    [PureAttribute]
public ValueTuple`2<Map`3<OrdK, K, V>, Option`1<V>> FindOrMaybeAdd(K key, Func`1<Option`1<V>> None);
    [PureAttribute]
public ValueTuple`2<Map`3<OrdK, K, V>, Option`1<V>> FindOrMaybeAdd(K key, Option`1<V> None);
    [PureAttribute]
public Map`3<OrdK, K, V> SetItem(K key, V value);
    [PureAttribute]
public Map`3<OrdK, K, V> SetItem(K key, Func`2<V, V> Some);
    [PureAttribute]
public Map`3<OrdK, K, V> TrySetItem(K key, V value);
    [PureAttribute]
public Map`3<OrdK, K, V> TrySetItem(K key, Func`2<V, V> Some);
    [PureAttribute]
public Map`3<OrdK, K, V> TrySetItem(K key, Func`2<V, V> Some, Func`2<Map`2<K, V>, Map`2<K, V>> None);
    [PureAttribute]
public Map`3<OrdK, K, V> AddOrUpdate(K key, V value);
    [PureAttribute]
public Map`3<OrdK, K, V> AddOrUpdate(K key, Func`2<V, V> Some, Func`1<V> None);
    [PureAttribute]
public Map`3<OrdK, K, V> AddOrUpdate(K key, Func`2<V, V> Some, V None);
    [PureAttribute]
public Iterable`1<V> FindRange(K keyFrom, K keyTo);
    [PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> FindRangePairs(K keyFrom, K keyTo);
    [PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> Skip(int amount);
    [PureAttribute]
public sealed virtual bool ContainsKey(K key);
    [PureAttribute]
public bool Contains(K key, V value);
    [PureAttribute]
public Map`3<OrdK, K, V> Clear();
    [PureAttribute]
public Map`3<OrdK, K, V> SetItems(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [PureAttribute]
public Map`3<OrdK, K, V> SetItems(IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public Map`3<OrdK, K, V> SetItems(IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public Map`3<OrdK, K, V> TrySetItems(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [PureAttribute]
public Map`3<OrdK, K, V> TrySetItems(IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public Map`3<OrdK, K, V> TrySetItems(IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public Map`3<OrdK, K, V> TrySetItems(IEnumerable`1<K> keys, Func`2<V, V> Some);
    [PureAttribute]
public Map`3<OrdK, K, V> RemoveRange(IEnumerable`1<K> keys);
    [PureAttribute]
public bool Contains(KeyValuePair`2<K, V> pair);
    public Iterable`1<K> get_Keys();
    public Iterable`1<V> get_Values();
    [PureAttribute]
public IDictionary`2<KR, VR> ToDictionary(Func`2<ValueTuple`2<K, V>, KR> keySelector, Func`2<ValueTuple`2<K, V>, VR> valueSelector);
    public Iterable`1<ValueTuple`2<K, V>> get_Pairs();
    public Iterable`1<ValueTuple`2<K, V>> get_ValueTuples();
    [PureAttribute]
public sealed virtual IEnumerator`1<ValueTuple`2<K, V>> GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public Seq`1<ValueTuple`2<K, V>> ToSeq();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToFullString(string separator);
    [PureAttribute]
public string ToFullArrayString(string separator);
    [PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> AsEnumerable();
    internal Map`3<OrdK, K, V> SetRoot(MapItem`2<K, V> root);
    [PureAttribute]
public static override bool op_Equality(Map`3<OrdK, K, V> lhs, Map`3<OrdK, K, V> rhs);
    [PureAttribute]
public static override bool op_Inequality(Map`3<OrdK, K, V> lhs, Map`3<OrdK, K, V> rhs);
    [PureAttribute]
public static override bool op_LessThan(Map`3<OrdK, K, V> lhs, Map`3<OrdK, K, V> rhs);
    [PureAttribute]
public static override bool op_LessThanOrEqual(Map`3<OrdK, K, V> lhs, Map`3<OrdK, K, V> rhs);
    [PureAttribute]
public static override bool op_GreaterThan(Map`3<OrdK, K, V> lhs, Map`3<OrdK, K, V> rhs);
    [PureAttribute]
public static override bool op_GreaterThanOrEqual(Map`3<OrdK, K, V> lhs, Map`3<OrdK, K, V> rhs);
    [PureAttribute]
public sealed virtual Map`3<OrdK, K, V> Combine(Map`3<OrdK, K, V> y);
    [PureAttribute]
public static override Map`3<OrdK, K, V> op_Addition(Map`3<OrdK, K, V> lhs, Map`3<OrdK, K, V> rhs);
    [PureAttribute]
public static override Map`3<OrdK, K, V> op_Subtraction(Map`3<OrdK, K, V> lhs, Map`3<OrdK, K, V> rhs);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public sealed virtual bool Equals(Map`3<OrdK, K, V> y);
    [NullableContextAttribute("0")]
[PureAttribute]
public bool Equals(Map`3<OrdK, K, V> y);
    [PureAttribute]
public bool EqualsKeys(Map`3<OrdK, K, V> y);
    [PureAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[PureAttribute]
public sealed virtual int CompareTo(object obj);
    public Map`3<OrdK, K, V> Do(Action`1<V> f);
    [PureAttribute]
[EditorBrowsableAttribute("1")]
public Map`3<OrdK, K, U> Select(Func`2<V, U> mapper);
    [PureAttribute]
[EditorBrowsableAttribute("1")]
public Map`3<OrdK, K, U> Select(Func`3<K, V, U> mapper);
    [PureAttribute]
[EditorBrowsableAttribute("1")]
public Map`3<OrdK, K, V> Where(Func`2<V, bool> valuePred);
    [PureAttribute]
[EditorBrowsableAttribute("1")]
public Map`3<OrdK, K, V> Where(Func`3<K, V, bool> keyValuePred);
    [PureAttribute]
public Map`3<OrdK, K, V> Filter(Func`2<V, bool> valuePred);
    [PureAttribute]
public Map`3<OrdK, K, V> Filter(Func`3<K, V, bool> keyValuePred);
    [PureAttribute]
public bool ForAll(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<Tuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<KeyValuePair`2<K, V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<V, bool> pred);
    [PureAttribute]
public bool Exists(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<Tuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<KeyValuePair`2<K, V>, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<V, bool> pred);
    public Unit Iter(Action`2<K, V> action);
    public Unit Iter(Action`1<V> action);
    public Unit Iter(Action`1<Tuple`2<K, V>> action);
    public Unit Iter(Action`1<ValueTuple`2<K, V>> action);
    public Unit Iter(Action`1<KeyValuePair`2<K, V>> action);
    [NullableContextAttribute("2")]
[PureAttribute]
public Map`3<OrdK, K, U> Choose(Func`3<K, V, Option`1<U>> selector);
    [NullableContextAttribute("2")]
[PureAttribute]
public Map`3<OrdK, K, U> Choose(Func`2<V, Option`1<U>> selector);
    [PureAttribute]
public S Fold(S state, Func`4<S, K, V, S> folder);
    [PureAttribute]
public S Fold(S state, Func`3<S, V, S> folder);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`3<OrdK, K, V> op_Implicit(ValueTuple`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`3<OrdK, K, V> op_Implicit(ValueTuple`2<ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`3<OrdK, K, V> op_Implicit(ValueTuple`3<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`3<OrdK, K, V> op_Implicit(ValueTuple`4<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`3<OrdK, K, V> op_Implicit(ValueTuple`5<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`3<OrdK, K, V> op_Implicit(ValueTuple`6<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`3<OrdK, K, V> op_Implicit(ValueTuple`7<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`3<OrdK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`1<ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`3<OrdK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`3<OrdK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`3<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`3<OrdK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`4<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`3<OrdK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`5<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`3<OrdK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`6<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`3<OrdK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`7<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`3<OrdK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`1<ValueTuple`2<K, V>>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static Map`3<OrdK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<ValueTuple`2<K, V>, ValueTuple`2<K, V>>>> items);
    [PureAttribute]
public Map`3<OrdK, K, V> Union(Map`3<OrdK, K, V> other, WhenMatched`4<K, V, V, V> Merge);
    [PureAttribute]
public Map`3<OrdK, K, V> Union(Map`3<OrdK, K, V2> other, WhenMissing`3<K, V2, V> MapRight, WhenMatched`4<K, V, V2, V> Merge);
    [PureAttribute]
public Map`3<OrdK, K, V2> Union(Map`3<OrdK, K, V2> other, WhenMissing`3<K, V, V2> MapLeft, WhenMatched`4<K, V, V2, V2> Merge);
    [PureAttribute]
public Map`3<OrdK, K, R> Union(Map`3<OrdK, K, V2> other, WhenMissing`3<K, V, R> MapLeft, WhenMissing`3<K, V2, R> MapRight, WhenMatched`4<K, V, V2, R> Merge);
    [NullableContextAttribute("2")]
[PureAttribute]
public Map`3<OrdK, K, R> Intersect(Map`3<OrdK, K, V2> other, WhenMatched`4<K, V, V2, R> Merge);
    [PureAttribute]
public Map`3<OrdK, K, V> Except(Map`3<OrdK, K, V> other);
    [PureAttribute]
public Map`3<OrdK, K, V> SymmetricExcept(Map`3<OrdK, K, V> other);
    [PureAttribute]
public sealed virtual int CompareTo(Map`3<OrdK, K, V> other);
    [NullableContextAttribute("0")]
[PureAttribute]
public int CompareTo(Map`3<OrdK, K, V> other);
    [PureAttribute]
public int CompareKeysTo(Map`3<OrdK, K, V> other);
    public static Map`3<OrdK, K, V> op_Implicit(SeqEmpty _);
    [PureAttribute]
public Map`3<OrdK, K, V> Slice(K keyFrom, K keyTo);
    public Option`1<ValueTuple`2<K, V>> get_Min();
    public Option`1<ValueTuple`2<K, V>> get_Max();
    private sealed virtual override IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Keys();
    private sealed virtual override IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Values();
    [PureAttribute]
public sealed virtual bool TryGetValue(K key, V& value);
    [PureAttribute]
private sealed virtual override IEnumerator`1<KeyValuePair`2<K, V>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,V>>.GetEnumerator();
    public static override Map`3<OrdK, K, V> get_AdditiveIdentity();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.MapEnumerator`2 : ValueType {
    private int stackDepth;
    private MapItem`2[] stack;
    private MapItem`2<K, V> map;
    private int left;
    private bool rev;
    private int start;
    [CompilerGeneratedAttribute]
private MapItem`2<K, V> <NodeCurrent>k__BackingField;
    private MapItem`2<K, V> NodeCurrent { get; private set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<K, V> Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal MapEnumerator`2(MapItem`2<K, V> root, bool rev, int start);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private MapItem`2<K, V> get_NodeCurrent();
    [CompilerGeneratedAttribute]
private void set_NodeCurrent(MapItem`2<K, V> value);
    [IsReadOnlyAttribute]
public sealed virtual ValueTuple`2<K, V> get_Current();
    [IsReadOnlyAttribute]
private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    private MapItem`2<K, V> Next(MapItem`2<K, V> node);
    private MapItem`2<K, V> Prev(MapItem`2<K, V> node);
    private void Push(MapItem`2<K, V> node);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.MapExtensions : object {
    [ExtensionAttribute]
public static Map`2<Key, V> As(K`2<Map`1<Key>, V> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Map`2<K, V> ToMap(IEnumerable`1<ValueTuple`2<K, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static Map`2<K, V> ToMap(IEnumerable`1<Tuple`2<K, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static Map`2<K, V> ToMap(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static Map`2<ValueTuple`2<K1, K2>, V> ToMap(IEnumerable`1<ValueTuple`3<K1, K2, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static Map`2<ValueTuple`3<K1, K2, K3>, V> ToMap(IEnumerable`1<ValueTuple`4<K1, K2, K3, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static Map`2<ValueTuple`4<K1, K2, K3, K4>, V> ToMap(IEnumerable`1<ValueTuple`5<K1, K2, K3, K4, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static Map`2<K, U> Map(Map`2<K, V> self, Func`2<V, U> mapper);
    [ExtensionAttribute]
[PureAttribute]
public static Map`2<K, U> Map(Map`2<K, V> self, Func`3<K, V, U> mapper);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class LanguageExt.MapInternal`3 : object {
    public static MapInternal`3<OrdK, K, V> Empty;
    internal MapItem`2<K, V> Root;
    internal bool Rev;
    private int hashCode;
    [PureAttribute]
public V Item { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public int Length { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Option`1<ValueTuple`2<K, V>> Min { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Option`1<ValueTuple`2<K, V>> Max { get; }
    [PureAttribute]
public Iterable`1<K> Keys { get; }
    [PureAttribute]
public Iterable`1<V> Values { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> Pairs { get; }
    internal MapInternal`3(MapItem`2<K, V> root, bool rev);
    internal MapInternal`3(ReadOnlySpan`1<ValueTuple`2<K, V>> items, AddOpt option);
    internal MapInternal`3(IEnumerable`1<ValueTuple`2<K, V>> items, AddOpt option);
    internal MapInternal`3(IEnumerable`1<KeyValuePair`2<K, V>> items, AddOpt option);
    internal MapInternal`3(IEnumerable`1<Tuple`2<K, V>> items, AddOpt option);
    private static MapInternal`3();
    public V get_Item(K key);
    public bool get_IsEmpty();
    public int get_Count();
    public int get_Length();
    public Option`1<ValueTuple`2<K, V>> get_Min();
    public Option`1<ValueTuple`2<K, V>> get_Max();
    public virtual int GetHashCode();
    [PureAttribute]
public MapInternal`3<OrdK, K, V> Add(K key, V value);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> TryAdd(K key, V value);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> TryAdd(K key, V value, Func`3<MapInternal`3<OrdK, K, V>, V, MapInternal`3<OrdK, K, V>> Fail);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> AddRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> AddRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> TryAddRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> TryAddRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> TryAddRange(IEnumerable`1<KeyValuePair`2<K, V>> range);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> AddOrUpdateRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> AddOrUpdateRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> AddOrUpdateRange(IEnumerable`1<KeyValuePair`2<K, V>> range);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> Remove(K key);
    [PureAttribute]
public Option`1<V> Find(K key);
    [PureAttribute]
public Seq`1<V> FindSeq(K key);
    [PureAttribute]
public R Find(K key, Func`2<V, R> Some, Func`1<R> None);
    [PureAttribute]
public Option`1<ValueTuple`2<K, V>> FindPredecessor(K key);
    [PureAttribute]
public Option`1<ValueTuple`2<K, V>> FindOrPredecessor(K key);
    [PureAttribute]
public Option`1<ValueTuple`2<K, V>> FindSuccessor(K key);
    [PureAttribute]
public Option`1<ValueTuple`2<K, V>> FindOrSuccessor(K key);
    [PureAttribute]
public ValueTuple`2<MapInternal`3<OrdK, K, V>, V> FindOrAdd(K key, Func`1<V> None);
    [PureAttribute]
public ValueTuple`2<MapInternal`3<OrdK, K, V>, V> FindOrAdd(K key, V value);
    [PureAttribute]
public ValueTuple`2<MapInternal`3<OrdK, K, V>, Option`1<V>> FindOrMaybeAdd(K key, Func`1<Option`1<V>> value);
    [PureAttribute]
public ValueTuple`2<MapInternal`3<OrdK, K, V>, Option`1<V>> FindOrMaybeAdd(K key, Option`1<V> value);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> SetItem(K key, V value);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> SetItem(K key, Func`2<V, V> Some);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> TrySetItem(K key, V value);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> TrySetItem(K key, Func`2<V, V> Some);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> TrySetItem(K key, Func`2<V, V> Some, Func`2<Map`2<K, V>, Map`2<K, V>> None);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> AddOrUpdate(K key, V value);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> AddOrUpdate(K key, Func`2<V, V> Some, Func`1<V> None);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> AddOrUpdate(K key, Func`2<V, V> Some, V None);
    [PureAttribute]
public Iterable`1<V> FindRange(K keyFrom, K keyTo);
    [PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> FindRangePairs(K keyFrom, K keyTo);
    [PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> Skip(int amount);
    [PureAttribute]
public bool ContainsKey(K key);
    [PureAttribute]
public bool Contains(K key, V value);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> Clear();
    [PureAttribute]
public MapInternal`3<OrdK, K, V> AddRange(IEnumerable`1<KeyValuePair`2<K, V>> pairs);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> SetItems(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> SetItems(IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> SetItems(IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> TrySetItems(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> TrySetItems(IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> TrySetItems(IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> TrySetItems(IEnumerable`1<K> keys, Func`2<V, V> Some);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> RemoveRange(IEnumerable`1<K> keys);
    [PureAttribute]
public bool Contains(KeyValuePair`2<K, V> pair);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("TryGetValue is obsolete, use TryFind instead")]
public bool TryGetValue(K key, V& value);
    [PureAttribute]
public MapInternal`3<OrdK, K, U> Choose(Func`3<K, V, Option`1<U>> selector);
    [PureAttribute]
public MapInternal`3<OrdK, K, U> Choose(Func`2<V, Option`1<U>> selector);
    public Iterable`1<K> get_Keys();
    public Iterable`1<V> get_Values();
    [PureAttribute]
public IDictionary`2<KR, VR> ToDictionary(Func`2<ValueTuple`2<K, V>, KR> keySelector, Func`2<ValueTuple`2<K, V>, VR> valueSelector);
    public Iterable`1<ValueTuple`2<K, V>> get_Pairs();
    [PureAttribute]
public MapEnumerator`2<K, V> GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator`1<ValueTuple`2<K, V>> System.Collections.Generic.IEnumerable<(KKey,VValue)>.GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public Seq`1<ValueTuple`2<K, V>> ToSeq();
    [PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> AsEnumerable();
    private static KeyValuePair`2<K, V> ToKeyValuePair(ValueTuple`2<K, V> kv);
    internal MapInternal`3<OrdK, K, V> SetRoot(MapItem`2<K, V> root);
    [PureAttribute]
public static MapInternal`3<OrdK, K, V> op_Addition(MapInternal`3<OrdK, K, V> lhs, MapInternal`3<OrdK, K, V> rhs);
    [PureAttribute]
public MapInternal`3<OrdK, K, R> Union(MapInternal`3<OrdK, K, V2> other, WhenMissing`3<K, V, R> MapLeft, WhenMissing`3<K, V2, R> MapRight, WhenMatched`4<K, V, V2, R> Merge);
    [PureAttribute]
public MapInternal`3<OrdK, K, R> Intersect(MapInternal`3<OrdK, K, V2> other, WhenMatched`4<K, V, V2, R> Merge);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> Except(MapInternal`3<OrdK, K, V> other);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> SymmetricExcept(MapInternal`3<OrdK, K, V> other);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> Append(MapInternal`3<OrdK, K, V> rhs);
    [PureAttribute]
public static MapInternal`3<OrdK, K, V> op_Subtraction(MapInternal`3<OrdK, K, V> lhs, MapInternal`3<OrdK, K, V> rhs);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> Subtract(MapInternal`3<OrdK, K, V> rhs);
    [PureAttribute]
public bool Equals(MapInternal`3<OrdK, K, V> rhs);
    [PureAttribute]
public int CompareTo(MapInternal`3<OrdK, K, V> other);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> Filter(Func`3<K, V, bool> f);
    [PureAttribute]
public MapInternal`3<OrdK, K, V> Filter(Func`2<V, bool> f);
    [IteratorStateMachineAttribute("LanguageExt.MapInternal`3/<<get_Keys>g__Go|74_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<K> <get_Keys>g__Go|74_0();
    [IteratorStateMachineAttribute("LanguageExt.MapInternal`3/<<get_Values>g__Go|76_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<V> <get_Values>g__Go|76_0();
    [IteratorStateMachineAttribute("LanguageExt.MapInternal`3/<<AsEnumerable>g__Go|84_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<ValueTuple`2<K, V>> <AsEnumerable>g__Go|84_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.MapItem`2 : object {
    internal static MapItem`2<K, V> Empty;
    internal int Count;
    internal byte Height;
    internal MapItem`2<K, V> Left;
    internal MapItem`2<K, V> Right;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<K, V> <KeyValue>k__BackingField;
    internal bool IsEmpty { get; }
    internal int BalanceFactor { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<K, V> KeyValue { get; internal set; }
    internal MapItem`2(byte height, int count, ValueTuple`2<K, V> keyValue, MapItem`2<K, V> left, MapItem`2<K, V> right);
    private MapItem`2(SerializationInfo info, StreamingContext context);
    private static MapItem`2();
    internal bool get_IsEmpty();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal int get_BalanceFactor();
    [CompilerGeneratedAttribute]
public sealed virtual ValueTuple`2<K, V> get_KeyValue();
    [CompilerGeneratedAttribute]
internal void set_KeyValue(ValueTuple`2<K, V> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.MapKeyEnumerator`2 : ValueType {
    private int stackDepth;
    private MapItem`2[] stack;
    private MapItem`2<K, V> map;
    private int left;
    private bool rev;
    private int start;
    [CompilerGeneratedAttribute]
private MapItem`2<K, V> <NodeCurrent>k__BackingField;
    private MapItem`2<K, V> NodeCurrent { get; private set; }
    public K Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal MapKeyEnumerator`2(MapItem`2<K, V> root, bool rev, int start);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private MapItem`2<K, V> get_NodeCurrent();
    [CompilerGeneratedAttribute]
private void set_NodeCurrent(MapItem`2<K, V> value);
    [IsReadOnlyAttribute]
public sealed virtual K get_Current();
    [IsReadOnlyAttribute]
private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    private MapItem`2<K, V> Next(MapItem`2<K, V> node);
    private MapItem`2<K, V> Prev(MapItem`2<K, V> node);
    private void Push(MapItem`2<K, V> node);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class LanguageExt.MapModule : object {
    public static S Fold(MapItem`2<K, V> node, S state, Func`4<S, K, V, S> folder);
    public static S Fold(MapItem`2<K, V> node, S state, Func`3<S, V, S> folder);
    public static bool ForAll(MapItem`2<K, V> node, Func`3<K, V, bool> pred);
    public static bool Exists(MapItem`2<K, V> node, Func`3<K, V, bool> pred);
    public static MapItem`2<K, U> Map(MapItem`2<K, V> node, Func`2<V, U> mapper);
    public static MapItem`2<K, U> Map(MapItem`2<K, V> node, Func`3<K, V, U> mapper);
    public static MapItem`2<K, V> Add(MapItem`2<K, V> node, K key, V value);
    public static MapItem`2<K, V> SetItem(MapItem`2<K, V> node, K key, V value);
    public static MapItem`2<K, V> TrySetItem(MapItem`2<K, V> node, K key, V value);
    public static MapItem`2<K, V> TryAdd(MapItem`2<K, V> node, K key, V value);
    public static MapItem`2<K, V> AddOrUpdate(MapItem`2<K, V> node, K key, V value);
    public static MapItem`2<K, V> Remove(MapItem`2<K, V> node, K key);
    public static V Find(MapItem`2<K, V> node, K key);
    [IteratorStateMachineAttribute("LanguageExt.MapModule/<FindRange>d__13`3")]
public static IEnumerable`1<V> FindRange(MapItem`2<K, V> node, K a, K b);
    [IteratorStateMachineAttribute("LanguageExt.MapModule/<FindRangePairs>d__14`3")]
public static IEnumerable`1<ValueTuple`2<K, V>> FindRangePairs(MapItem`2<K, V> node, K a, K b);
    public static Option`1<V> TryFind(MapItem`2<K, V> node, K key);
    public static MapItem`2<K, V> Skip(MapItem`2<K, V> node, int amount);
    public static MapItem`2<K, V> Make(ValueTuple`2<K, V> kv, MapItem`2<K, V> l, MapItem`2<K, V> r);
    public static MapItem`2<K, V> Make(K k, V v, MapItem`2<K, V> l, MapItem`2<K, V> r);
    public static MapItem`2<K, V> Balance(MapItem`2<K, V> node);
    public static MapItem`2<K, V> RotRight(MapItem`2<K, V> node);
    public static MapItem`2<K, V> RotLeft(MapItem`2<K, V> node);
    public static MapItem`2<K, V> DblRotRight(MapItem`2<K, V> node);
    public static MapItem`2<K, V> DblRotLeft(MapItem`2<K, V> node);
    [NullableContextAttribute("2")]
internal static Option`1<ValueTuple`2<K, V>> Max(MapItem`2<K, V> node);
    [NullableContextAttribute("2")]
internal static Option`1<ValueTuple`2<K, V>> Min(MapItem`2<K, V> node);
    internal static Option`1<ValueTuple`2<K, V>> TryFindPredecessor(MapItem`2<K, V> root, K key);
    internal static Option`1<ValueTuple`2<K, V>> TryFindOrPredecessor(MapItem`2<K, V> root, K key);
    internal static Option`1<ValueTuple`2<K, V>> TryFindSuccessor(MapItem`2<K, V> root, K key);
    internal static Option`1<ValueTuple`2<K, V>> TryFindOrSuccessor(MapItem`2<K, V> root, K key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class LanguageExt.MapModuleM : object {
    public static MapItem`2<K, V> Add(MapItem`2<K, V> node, K key, V value, AddOpt option);
    public static MapItem`2<K, V> Balance(MapItem`2<K, V> node);
    public static MapItem`2<K, V> DblRotRight(MapItem`2<K, V> node);
    public static MapItem`2<K, V> DblRotLeft(MapItem`2<K, V> node);
    public static MapItem`2<K, V> RotRight(MapItem`2<K, V> node);
    public static MapItem`2<K, V> RotLeft(MapItem`2<K, V> node);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.MapOrdExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static Map`3<OrdK, K, U> Map(Map`3<OrdK, K, V> self, Func`2<V, U> mapper);
    [ExtensionAttribute]
[PureAttribute]
public static Map`3<OrdK, K, U> Map(Map`3<OrdK, K, V> self, Func`3<K, V, U> mapper);
    [ExtensionAttribute]
[PureAttribute]
public static int Count(Map`3<OrdK, K, V> self);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[PureAttribute]
public static int Sum(Map`3<OrdK, K, int> self);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.MapValueEnumerator`2 : ValueType {
    private int stackDepth;
    private MapItem`2[] stack;
    private MapItem`2<K, V> map;
    private int left;
    private bool rev;
    private int start;
    [CompilerGeneratedAttribute]
private MapItem`2<K, V> <NodeCurrent>k__BackingField;
    private MapItem`2<K, V> NodeCurrent { get; private set; }
    public V Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal MapValueEnumerator`2(MapItem`2<K, V> root, bool rev, int start);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
private MapItem`2<K, V> get_NodeCurrent();
    [CompilerGeneratedAttribute]
private void set_NodeCurrent(MapItem`2<K, V> value);
    [IsReadOnlyAttribute]
public sealed virtual V get_Current();
    [IsReadOnlyAttribute]
private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    private MapItem`2<K, V> Next(MapItem`2<K, V> node);
    private MapItem`2<K, V> Prev(MapItem`2<K, V> node);
    private void Push(MapItem`2<K, V> node);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[IsReadOnlyAttribute]
public class LanguageExt.Mass : ValueType {
    private double Value;
    public double Grams { get; }
    public double Kilograms { get; }
    public double Tonnes { get; }
    public double Ounces { get; }
    public double Pounds { get; }
    public double Stones { get; }
    public double ImperialTons { get; }
    public double ShortTons { get; }
    internal Mass(double value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Mass other);
    public sealed virtual bool Equals(Mass other);
    public bool Equals(Mass other, double epsilon);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Mass Add(Mass rhs);
    public Mass Subtract(Mass rhs);
    public Mass Multiply(double rhs);
    public Mass Divide(double rhs);
    public static Mass op_Multiply(Mass lhs, double rhs);
    public static Mass op_Multiply(double lhs, Mass rhs);
    public static Mass op_Addition(Mass lhs, Mass rhs);
    public static Mass op_Subtraction(Mass lhs, Mass rhs);
    public static Mass op_Division(Mass lhs, double rhs);
    public static double op_Division(Mass lhs, Mass rhs);
    public static bool op_Equality(Mass lhs, Mass rhs);
    public static bool op_Inequality(Mass lhs, Mass rhs);
    public static bool op_GreaterThan(Mass lhs, Mass rhs);
    public static bool op_LessThan(Mass lhs, Mass rhs);
    public static bool op_GreaterThanOrEqual(Mass lhs, Mass rhs);
    public static bool op_LessThanOrEqual(Mass lhs, Mass rhs);
    public Mass Round();
    public Mass Sqrt();
    public Mass Abs();
    public Mass Min(Mass rhs);
    public Mass Max(Mass rhs);
    public double get_Grams();
    public double get_Kilograms();
    public double get_Tonnes();
    public double get_Ounces();
    public double get_Pounds();
    public double get_Stones();
    public double get_ImperialTons();
    public double get_ShortTons();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.MCons`2 : MList`1<A> {
    [CompilerGeneratedAttribute]
private A <Head>k__BackingField;
    [CompilerGeneratedAttribute]
private K`2<M, MList`1<A>> <Tail>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public A Head { get; public set; }
    public K`2<M, MList`1<A>> Tail { get; public set; }
    public MCons`2(A Head, K`2<M, MList`1<A>> Tail);
    [CompilerGeneratedAttribute]
protected MCons`2(MCons`2<M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public A get_Head();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Head(A value);
    [CompilerGeneratedAttribute]
public K`2<M, MList`1<A>> get_Tail();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Tail(K`2<M, MList`1<A>> value);
    public virtual MList`1<B> Map(Func`2<A, B> f);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(MCons`2<M, A> left, MCons`2<M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(MCons`2<M, A> left, MCons`2<M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MList`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(MCons`2<M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override MCons`2<M, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(A& Head, K`2& Tail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.MemoExtensions : object {
    [ExtensionAttribute]
public static Func`1<T> Memo(Func`1<T> func);
    [ExtensionAttribute]
public static Func`2<T, R> Memo(Func`2<T, R> func);
    [ExtensionAttribute]
public static Func`2<T, R> MemoUnsafe(Func`2<T, R> func);
    [ExtensionAttribute]
public static IEnumerable`1<T> Memo(IEnumerable`1<T> seq);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.MIter`2 : MList`1<A> {
    [CompilerGeneratedAttribute]
private A <Head>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerator`1<A> <Tail>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public A Head { get; public set; }
    public IEnumerator`1<A> Tail { get; public set; }
    public MIter`2(A Head, IEnumerator`1<A> Tail);
    [CompilerGeneratedAttribute]
protected MIter`2(MIter`2<M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public A get_Head();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Head(A value);
    [CompilerGeneratedAttribute]
public IEnumerator`1<A> get_Tail();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Tail(IEnumerator`1<A> value);
    public virtual MList`1<B> Map(Func`2<A, B> f);
    public MList`1<A> ToCons();
    public K`2<M, MList`1<A>> TailM();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(MIter`2<M, A> left, MIter`2<M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(MIter`2<M, A> left, MIter`2<M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MList`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(MIter`2<M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override MIter`2<M, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(A& Head, IEnumerator`1& Tail);
}
public class LanguageExt.MList : object {
    [NullableContextAttribute("1")]
private static override K`2<MList, B> LanguageExt.Traits.Functor<LanguageExt.MList>.Map(Func`2<A, B> f, K`2<MList, A> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.MList`1 : object {
    public static MList`1<A> Nil;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected MList`1(MList`1<A> original);
    private static MList`1();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public abstract virtual MList`1<B> Map(Func`2<A, B> f);
    public static MList`1<A> Cons(A head, K`2<M, MList`1<A>> tail);
    internal static MList`1<A> Iter(A head, IEnumerator`1<A> tail);
    public K`2<M, MList`1<A>> Append(K`2<M, MList`1<A>> ys);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(MList`1<A> left, MList`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(MList`1<A> left, MList`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(MList`1<A> other);
    [CompilerGeneratedAttribute]
public abstract virtual MList`1<A> <Clone>$();
}
[ExtensionAttribute]
public static class LanguageExt.MListExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static MList`1<A> As(K`2<MList, A> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.MListMapEnumerator`2 : object {
    [CompilerGeneratedAttribute]
private IEnumerator`1<A> <Iter>P;
    [CompilerGeneratedAttribute]
private Func`2<A, B> <Map>P;
    private object System.Collections.IEnumerator.Current { get; }
    public B Current { get; }
    public MListMapEnumerator`2(IEnumerator`1<A> Iter, Func`2<A, B> Map);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual B get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.MNil`1 : MList`1<A> {
    public static MList`1<A> Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected MNil`1(MNil`1<A> original);
    private static MNil`1();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual MList`1<B> Map(Func`2<A, B> f);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(MNil`1<A> left, MNil`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(MNil`1<A> left, MNil`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MList`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(MNil`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override MNil`1<A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class LanguageExt.Modify`1 : ValueType {
    [CompilerGeneratedAttribute]
private Func`2<S, S> <f>k__BackingField;
    public Func`2<S, S> f { get; public set; }
    public Modify`1(Func`2<S, S> f);
    [CompilerGeneratedAttribute]
public Func`2<S, S> get_f();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_f(Func`2<S, S> value);
    public StateT`3<S, M, Unit> ToStateT();
    public State`2<S, Unit> ToState();
    public StateT`3<S, M, C> SelectMany(Func`2<Unit, StateT`3<S, M, B>> bind, Func`3<Unit, B, C> project);
    public State`2<S, C> SelectMany(Func`2<Unit, State`2<S, B>> bind, Func`3<Unit, B, C> project);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(Modify`1<S> left, Modify`1<S> right);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public static bool op_Equality(Modify`1<S> left, Modify`1<S> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Modify`1<S> other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`2& f);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.MonadExtensions : object {
    [ExtensionAttribute]
public static K`2<M, B> Bind(K`2<M, A> ma, Func`2<A, K`2<M, B>> f);
    [ExtensionAttribute]
public static K`2<M, B> Bind(K`2<M, A> ma, Func`2<A, Pure`1<B>> f);
    [ExtensionAttribute]
public static K`2<M, B> Bind(K`2<M, A> ma, Func`2<A, K`2<IO, B>> f);
    [ExtensionAttribute]
public static K`2<M, C> SelectMany(K`2<M, A> ma, Func`2<A, K`2<M, B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
public static K`2<M, C> SelectMany(K`2<M, A> ma, Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
public static K`2<M, C> SelectMany(K`2<M, A> ma, Func`2<A, K`2<IO, B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
public static K`2<M, A> Flatten(K`2<M, K`2<M, A>> mma);
    [ExtensionAttribute]
public static K`2<M, K`2<N, B>> BindT(K`2<M, K`2<N, A>> mna, Func`2<A, K`2<N, B>> f);
    [ExtensionAttribute]
public static K`2<M, K`2<N, B>> BindT(K`2<M, K`2<N, A>> mna, Func`2<A, K`2<M, K`2<N, B>>> f);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.MonadIOExtensions : object {
    [ExtensionAttribute]
public static K`2<M, IO`1<A>> ToIO(K`2<M, A> ma);
    [ExtensionAttribute]
public static K`2<M, B> MapIO(K`2<M, A> ma, Func`2<IO`1<A>, IO`1<B>> f);
    [ExtensionAttribute]
public static K`2<M, B> MapIO(Func`2<IO`1<A>, IO`1<B>> f, K`2<M, A> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Monoid : object {
    [PureAttribute]
public static A empty();
    [PureAttribute]
public static A combine(A x, A y);
    [PureAttribute]
public static A combine(A mx, A my, A mz, A[] xs);
    [PureAttribute]
public static A combine(IEnumerable`1<A> xs);
    [PureAttribute]
public static A combine(Seq`1<A> xs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.MonoidK : object {
    [PureAttribute]
public static K`2<M, A> empty();
    [PureAttribute]
public static K`2<M, A> combine(K`2<M, A> x, K`2<M, A> y);
    [PureAttribute]
public static K`2<M, A> combine(K`2<M, A> mx, K`2<M, A> my, K`2<M, A> mz, K`2[] xs);
    [PureAttribute]
public static K`2<M, A> combine(IEnumerable`1<K`2<M, A>> xs);
    [PureAttribute]
public static K`2<M, A> combine(Seq`1<K`2<M, A>> xs);
}
[NullableContextAttribute("1")]
internal interface LanguageExt.New`1 {
    public abstract virtual A New();
}
[NullableContextAttribute("1")]
internal interface LanguageExt.New`2 {
    public abstract virtual A New(B value);
    public abstract virtual void Set(A item, B value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.NoChange`1 : Change`1<A> {
    public static Change`1<A> Default;
    private static NoChange`1();
    public virtual bool Equals(Change`1<A> obj);
    public sealed virtual bool Equals(NoChange`1<A> rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class LanguageExt.NonEqAttribute : Attribute {
}
public class LanguageExt.NonHashAttribute : Attribute {
}
public class LanguageExt.NonOrdAttribute : Attribute {
}
public class LanguageExt.NonRecordAttribute : Attribute {
}
public class LanguageExt.NonShowAttribute : Attribute {
}
public class LanguageExt.NonStructuralAttribute : Attribute {
}
public class LanguageExt.NotAppendableException : Exception {
    [NullableContextAttribute("1")]
public NotAppendableException(Type t);
}
public class LanguageExt.NotDivisibleException : Exception {
    [NullableContextAttribute("1")]
public NotDivisibleException(Type t);
}
public class LanguageExt.NotMultiplicableException : Exception {
    [NullableContextAttribute("1")]
public NotMultiplicableException(Type t);
}
public class LanguageExt.NotSubtractableException : Exception {
    [NullableContextAttribute("1")]
public NotSubtractableException(Type t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Number`1 : object {
    public static override int GetHashCode(A x);
    public static override bool Equals(A x, A y);
    public static override int Compare(A x, A y);
    public static override A Add(A x, A y);
    public static override A Subtract(A x, A y);
    public static override A Multiply(A x, A y);
    public static override A Negate(A x);
    public static override A Abs(A x);
    public static override A Signum(A x);
    public static override A FromInteger(int x);
    public static override A FromDecimal(decimal x);
    public static override A FromFloat(float x);
    public static override A FromDouble(double x);
    public static override A Divide(A x, A y);
}
[ExtensionAttribute]
public static class LanguageExt.ObjectExt : object {
    [ExtensionAttribute]
[PureAttribute]
public static bool IsNull(A value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.ObservableExt : object {
    [ExtensionAttribute]
[PureAttribute]
public static IObservable`1<T> PostSubscribe(IObservable`1<T> self, Action action);
    [ExtensionAttribute]
[PureAttribute]
public static IObservable`1<T> PostSubscribe(IObservable`1<T> self, Func`1<Unit> action);
    [ExtensionAttribute]
public static IAsyncEnumerable`1<A> ToAsyncEnumerable(IObservable`1<A> observable, CancellationToken token);
}
internal static class LanguageExt.Opt : object {
    internal static MethodImplOptions Default;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Option : object {
    private static override K`2<Option, B> LanguageExt.Traits.Monad<LanguageExt.Option>.Bind(K`2<Option, A> ma, Func`2<A, K`2<Option, B>> f);
    private static override K`2<Option, B> LanguageExt.Traits.Functor<LanguageExt.Option>.Map(Func`2<A, B> f, K`2<Option, A> ma);
    private static override K`2<Option, A> LanguageExt.Traits.Applicative<LanguageExt.Option>.Pure(A value);
    private static override K`2<Option, B> LanguageExt.Traits.Applicative<LanguageExt.Option>.Apply(K`2<Option, Func`2<A, B>> mf, K`2<Option, A> ma);
    private static override K`2<Option, B> LanguageExt.Traits.Applicative<LanguageExt.Option>.Action(K`2<Option, A> ma, K`2<Option, B> mb);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Option>.FoldWhile(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S initialState, K`2<Option, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Option>.FoldBackWhile(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S initialState, K`2<Option, A> ta);
    private static override K`2<F, K`2<Option, B>> LanguageExt.Traits.Traversable<LanguageExt.Option>.Traverse(Func`2<A, K`2<F, B>> f, K`2<Option, A> ta);
    private static override K`2<Option, A> LanguageExt.Traits.MonoidK<LanguageExt.Option>.Empty();
    private static override K`2<Option, A> LanguageExt.Traits.SemigroupK<LanguageExt.Option>.Combine(K`2<Option, A> ma, K`2<Option, A> mb);
    private static K`2<Option, X> Some(X value);
    private static K`2<Option, X> None();
    private static override K`2<Option, A> LanguageExt.Traits.Fallible<LanguageExt.Unit,LanguageExt.Option>.Fail(Unit _);
    private static override K`2<Option, A> LanguageExt.Traits.Fallible<LanguageExt.Unit,LanguageExt.Option>.Catch(K`2<Option, A> fa, Func`2<Unit, bool> Predicate, Func`2<Unit, K`2<Option, A>> Fail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class LanguageExt.Option`1 : ValueType {
    [NullableAttribute("2")]
internal A Value;
    internal bool isSome;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Option`1<A> None;
    [NullableAttribute("2")]
[PureAttribute]
public object Case { get; }
    [PureAttribute]
public bool IsSome { get; }
    [PureAttribute]
public bool IsNone { get; }
    internal Option`1(A value);
    public Option`1(IEnumerable`1<A> option);
    private Option`1(SerializationInfo info, StreamingContext context);
    private static Option`1();
    [PureAttribute]
public static Option`1<A> Some(A value);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public object get_Case();
    [PureAttribute]
public sealed virtual bool Equals(Option`1<A> other);
    [NullableContextAttribute("0")]
[PureAttribute]
public bool Equals(Option`1<A> other);
    [PureAttribute]
public sealed virtual int CompareTo(Option`1<A> other);
    [NullableContextAttribute("0")]
[PureAttribute]
public int CompareTo(Option`1<A> other);
    [PureAttribute]
public static A op_Explicit(Option`1<A> ma);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Option`1<A> op_Implicit(A a);
    [NullableContextAttribute("0")]
[PureAttribute]
public static override Option`1<A> op_Implicit(Fail`1<Unit> a);
    [PureAttribute]
public static Option`1<A> op_Implicit(Unit& fail);
    [PureAttribute]
public static bool op_LessThan(Option`1<A> lhs, Option`1<A> rhs);
    [PureAttribute]
public static bool op_LessThanOrEqual(Option`1<A> lhs, Option`1<A> rhs);
    [PureAttribute]
public static bool op_GreaterThan(Option`1<A> lhs, Option`1<A> rhs);
    [PureAttribute]
public static bool op_GreaterThanOrEqual(Option`1<A> lhs, Option`1<A> rhs);
    [PureAttribute]
public static bool op_Equality(Option`1<A> lhs, Option`1<A> rhs);
    [PureAttribute]
public static bool op_Inequality(Option`1<A> lhs, Option`1<A> rhs);
    [PureAttribute]
public static override Option`1<A> op_BitwiseOr(Option`1<A> lhs, Option`1<A> rhs);
    [PureAttribute]
public static override Option`1<A> op_BitwiseOr(K`2<Option, A> lhs, Option`1<A> rhs);
    [PureAttribute]
public static override Option`1<A> op_BitwiseOr(Option`1<A> lhs, K`2<Option, A> rhs);
    [PureAttribute]
public static override Option`1<A> op_BitwiseOr(Option`1<A> ma, Pure`1<A> mb);
    [NullableContextAttribute("0")]
[PureAttribute]
public static override Option`1<A> op_BitwiseOr(Option`1<A> ma, Fail`1<Unit> mb);
    [PureAttribute]
public static override Option`1<A> op_BitwiseOr(Option`1<A> ma, CatchM`3<Unit, Option, A> mb);
    [PureAttribute]
public static bool op_True(Option`1<A> value);
    [PureAttribute]
public static bool op_False(Option`1<A> value);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[PureAttribute]
public sealed virtual int CompareTo(object obj);
    [PureAttribute]
public virtual string ToString();
    public sealed virtual bool get_IsSome();
    public sealed virtual bool get_IsNone();
    public Option`1<A> Do(Action`1<A> f);
    [PureAttribute]
public Option`1<B> Select(Func`2<A, B> f);
    [PureAttribute]
public Option`1<B> Map(Func`2<A, B> f);
    [PureAttribute]
public K`2<F, Option`1<B>> Traverse(Func`2<A, K`2<F, B>> f);
    [PureAttribute]
public K`2<M, Option`1<B>> TraverseM(Func`2<A, K`2<M, B>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public Option`1<B> Bind(Func`2<A, Option`1<B>> f);
    [PureAttribute]
public Option`1<B> Bind(Func`2<A, K`2<Option, B>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public Option`1<B> BiBind(Func`2<A, Option`1<B>> Some, Func`1<Option`1<B>> None);
    [NullableContextAttribute("2")]
[PureAttribute]
public Option`1<C> SelectMany(Func`2<A, Option`1<B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Option`1<C> SelectMany(Func`2<A, Fail`1<Unit>> bind, Func`3<A, Unit, C> project);
    [PureAttribute]
public sealed virtual R MatchUntyped(Func`2<object, R> Some, Func`1<R> None);
    [PureAttribute]
public sealed virtual Type GetUnderlyingType();
    [PureAttribute]
public Arr`1<A> ToArray();
    [PureAttribute]
public Lst`1<A> ToList();
    [PureAttribute]
public Seq`1<A> ToSeq();
    [PureAttribute]
public Seq`1<A> AsEnumerable();
    [PureAttribute]
public Eff`1<A> ToEff();
    [PureAttribute]
public OptionT`2<IO, A> ToIO();
    [PureAttribute]
public StreamT`2<M, A> ToStream();
    [PureAttribute]
public Eff`1<A> ToEff(Error Fail);
    [PureAttribute]
public Fin`1<A> ToFin();
    [PureAttribute]
public Fin`1<A> ToFin(Error Fail);
    [PureAttribute]
public Either`2<L, A> ToEither(L defaultLeftValue);
    [PureAttribute]
public Either`2<L, A> ToEither();
    [PureAttribute]
public Either`2<L, A> ToEither(Func`1<L> Left);
    [PureAttribute]
public Validation`2<L, A> ToValidation(Func`1<L> Fail);
    [PureAttribute]
public Validation`2<L, A> ToValidation(L Fail);
    [PureAttribute]
public Validation`2<L, A> ToValidation();
    [PureAttribute]
public SomeUnitContext`1<A> Some(Action`1<A> f);
    [PureAttribute]
public SomeContext`2<A, B> Some(Func`2<A, B> f);
    [PureAttribute]
public B Match(Func`2<A, B> Some, Func`1<B> None);
    [PureAttribute]
public B Match(Func`2<A, B> Some, B None);
    public Unit Match(Action`1<A> Some, Action None);
    public Unit IfSome(Action`1<A> f);
    public Unit IfSome(Func`2<A, Unit> f);
    [PureAttribute]
public A IfNone(Func`1<A> None);
    public Unit IfNone(Action None);
    [PureAttribute]
public A IfNone(A noneValue);
    [PureAttribute]
public S Fold(S state, Func`3<S, A, S> folder);
    [PureAttribute]
public S FoldBack(S state, Func`3<S, A, S> folder);
    [PureAttribute]
public S BiFold(S state, Func`3<S, A, S> Some, Func`3<S, Unit, S> None);
    [PureAttribute]
public S BiFold(S state, Func`3<S, A, S> Some, Func`2<S, S> None);
    [PureAttribute]
public Option`1<B> BiMap(Func`2<A, B> Some, Func`2<Unit, B> None);
    [PureAttribute]
public Option`1<B> BiMap(Func`2<A, B> Some, Func`1<B> None);
    [PureAttribute]
public int Count();
    [PureAttribute]
public bool ForAll(Func`2<A, bool> pred);
    [PureAttribute]
public bool BiForAll(Func`2<A, bool> Some, Func`2<Unit, bool> None);
    [PureAttribute]
public bool BiForAll(Func`2<A, bool> Some, Func`1<bool> None);
    [PureAttribute]
public bool Exists(Func`2<A, bool> pred);
    [PureAttribute]
public bool BiExists(Func`2<A, bool> Some, Func`2<Unit, bool> None);
    [PureAttribute]
public bool BiExists(Func`2<A, bool> Some, Func`1<bool> None);
    public Unit Iter(Action`1<A> Some);
    public Unit BiIter(Action`1<A> Some, Action`1<Unit> None);
    public Unit BiIter(Action`1<A> Some, Action None);
    [PureAttribute]
public Option`1<A> Filter(Func`2<A, bool> pred);
    [PureAttribute]
public Option`1<A> Where(Func`2<A, bool> pred);
    [NullableContextAttribute("2")]
[PureAttribute]
public Option`1<Func`2<B, C>> ParMap(Func`3<A, B, C> func);
    [NullableContextAttribute("2")]
[PureAttribute]
public Option`1<Func`2<B, Func`2<C, D>>> ParMap(Func`4<A, B, C, D> func);
    public sealed virtual IEnumerator`1<A> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("2")]
[PureAttribute]
public Option`1<B> Bind(Func`2<A, Pure`1<B>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public Option`1<B> Bind(Func`2<A, Fail`1<Unit>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public Option`1<C> SelectMany(Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public static override Option`1<A> op_Implicit(Pure`1<A> mr);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Optional : object {
    internal static Action noneIgnore;
    internal static Func`1<Unit> noneIgnoreF;
    private static Optional();
    public static Unit ifSome(OA opt, Action`1<A> f);
    public static Unit ifSome(OA opt, Func`2<A, Unit> f);
    [PureAttribute]
public static A ifNone(OA opt, Func`1<A> None);
    [PureAttribute]
public static A ifNone(OA opt, A noneValue);
    [PureAttribute]
public static R matchUntyped(OA ma, Func`2<object, R> Some, Func`1<R> None);
    [PureAttribute]
public static Arr`1<A> toArray(OA ma);
    [PureAttribute]
public static Lst`1<A> toList(OA ma);
    [PureAttribute]
public static Seq`1<A> asEnumerable(OA ma);
    [PureAttribute]
public static Either`2<L, A> toEither(OA ma, L defaultLeftValue);
    [PureAttribute]
public static Either`2<L, A> toEither(OA ma, Func`1<L> Left);
    [PureAttribute]
public static Option`1<A> toOption(OA ma);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.OptionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Option`1<A> As(K`2<Option, A> ma);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Validation`2<F, A> ToValidation(Option`1<A> ma, F defaultFailureValue);
    [ExtensionAttribute]
[PureAttribute]
public static Option`1<A> Flatten(Option`1<Option`1<A>> ma);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("LanguageExt.OptionExtensions/<Somes>d__3`1")]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<A> Somes(IEnumerable`1<Option`1<A>> self);
    [ExtensionAttribute]
[PureAttribute]
public static Seq`1<A> Somes(Seq`1<Option`1<A>> self);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[PureAttribute]
public static Option`1<A> Add(Option`1<A> x, Option`1<A> y);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[PureAttribute]
public static Option`1<A> Subtract(Option`1<A> x, Option`1<A> y);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[PureAttribute]
public static Option`1<A> Product(Option`1<A> x, Option`1<A> y);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[PureAttribute]
public static Option`1<A> Divide(Option`1<A> x, Option`1<A> y);
    [ExtensionAttribute]
[PureAttribute]
public static Option`1<B> Apply(Option`1<Func`2<A, B>> fab, Option`1<A> fa);
    [ExtensionAttribute]
[PureAttribute]
public static Option`1<C> Apply(Option`1<Func`3<A, B, C>> fabc, Option`1<A> fa, Option`1<B> fb);
    [ExtensionAttribute]
[PureAttribute]
public static Option`1<Func`2<B, C>> Apply(Option`1<Func`3<A, B, C>> fabc, Option`1<A> fa);
    [ExtensionAttribute]
[PureAttribute]
public static Option`1<Func`2<B, C>> Apply(Option`1<Func`2<A, Func`2<B, C>>> fabc, Option`1<A> fa);
    [ExtensionAttribute]
[PureAttribute]
public static Option`1<B> Action(Option`1<A> fa, Option`1<B> fb);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[PureAttribute]
public static Nullable`1<A> ToNullable(Option`1<A> ma);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static R Match(Option`1<bool> ma, Func`1<R> True, Func`1<R> False, Func`1<R> None);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<R> Match(IEnumerable`1<Option`1<T>> list, Func`2<T, IEnumerable`1<R>> Some, Func`1<IEnumerable`1<R>> None);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<R> Match(IEnumerable`1<Option`1<T>> list, Func`2<T, IEnumerable`1<R>> Some, IEnumerable`1<R> None);
    [NullableContextAttribute("0")]
[IteratorStateMachineAttribute("LanguageExt.OptionExtensions/<<Somes>g__ToSequence|4_0>d`1")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<A> <Somes>g__ToSequence|4_0(Seq`1<Option`1<A>> items);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.OptionIsNoneException : Exception {
    public OptionIsNoneException(string message);
    public OptionIsNoneException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.OptionT : object {
    public static OptionT`2<M, B> bind(OptionT`2<M, A> ma, Func`2<A, OptionT`2<M, B>> f);
    public static OptionT`2<M, B> map(Func`2<A, B> f, OptionT`2<M, A> ma);
    public static OptionT`2<M, A> Some(A value);
    public static OptionT`2<M, A> None();
    public static OptionT`2<M, B> apply(OptionT`2<M, Func`2<A, B>> mf, OptionT`2<M, A> ma);
    public static OptionT`2<M, B> action(OptionT`2<M, A> ma, OptionT`2<M, B> mb);
    public static OptionT`2<M, A> lift(Option`1<A> ma);
    public static OptionT`2<M, A> lift(K`2<M, A> ma);
    public static OptionT`2<M, A> lift(Pure`1<A> ma);
    [NullableContextAttribute("0")]
public static OptionT`2<M, A> lift(Fail`1<Unit> ma);
    public static OptionT`2<M, A> liftIO(IO`1<A> ma);
    public static K`2<M, B> match(OptionT`2<M, A> ma, Func`2<A, B> Some, Func`1<B> None);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.OptionT`1 : object {
    public static OptionT`2<M, A> Some(A value);
    public static OptionT`2<M, A> None();
    public static OptionT`2<M, A> lift(Option`1<A> ma);
    public static OptionT`2<M, A> lift(Pure`1<A> ma);
    [NullableContextAttribute("0")]
public static OptionT`2<M, A> lift(Fail`1<Unit> ma);
    public static OptionT`2<M, A> liftIO(IO`1<A> ma);
    private static override K`2<OptionT`1<M>, B> LanguageExt.Traits.Monad<LanguageExt.OptionT<M>>.Bind(K`2<OptionT`1<M>, A> ma, Func`2<A, K`2<OptionT`1<M>, B>> f);
    private static override K`2<OptionT`1<M>, B> LanguageExt.Traits.Functor<LanguageExt.OptionT<M>>.Map(Func`2<A, B> f, K`2<OptionT`1<M>, A> ma);
    private static override K`2<OptionT`1<M>, A> LanguageExt.Traits.Applicative<LanguageExt.OptionT<M>>.Pure(A value);
    private static override K`2<OptionT`1<M>, B> LanguageExt.Traits.Applicative<LanguageExt.OptionT<M>>.Apply(K`2<OptionT`1<M>, Func`2<A, B>> mf, K`2<OptionT`1<M>, A> ma);
    private static override K`2<OptionT`1<M>, B> LanguageExt.Traits.Applicative<LanguageExt.OptionT<M>>.Action(K`2<OptionT`1<M>, A> ma, K`2<OptionT`1<M>, B> mb);
    private static override K`2<OptionT`1<M>, A> LanguageExt.Traits.MonadT<LanguageExt.OptionT<M>,M>.Lift(K`2<M, A> ma);
    private static override K`2<OptionT`1<M>, A> LanguageExt.Traits.MonadIO<LanguageExt.OptionT<M>>.LiftIO(IO`1<A> ma);
    private static override K`2<OptionT`1<M>, A> LanguageExt.Traits.MonoidK<LanguageExt.OptionT<M>>.Empty();
    private static override K`2<OptionT`1<M>, A> LanguageExt.Traits.SemigroupK<LanguageExt.OptionT<M>>.Combine(K`2<OptionT`1<M>, A> ma, K`2<OptionT`1<M>, A> mb);
    private static override K`2<OptionT`1<M>, A> LanguageExt.Traits.Fallible<LanguageExt.Unit,LanguageExt.OptionT<M>>.Fail(Unit error);
    private static override K`2<OptionT`1<M>, A> LanguageExt.Traits.Fallible<LanguageExt.Unit,LanguageExt.OptionT<M>>.Catch(K`2<OptionT`1<M>, A> fa, Func`2<Unit, bool> Predicate, Func`2<Unit, K`2<OptionT`1<M>, A>> Fail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.OptionT`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private K`2<M, Option`1<A>> <runOption>k__BackingField;
    public static OptionT`2<M, A> None;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public K`2<M, Option`1<A>> runOption { get; public set; }
    public OptionT`2(K`2<M, Option`1<A>> runOption);
    [CompilerGeneratedAttribute]
protected OptionT`2(OptionT`2<M, A> original);
    private static OptionT`2();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public K`2<M, Option`1<A>> get_runOption();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_runOption(K`2<M, Option`1<A>> value);
    public static OptionT`2<M, A> Some(A value);
    public static OptionT`2<M, A> Lift(Pure`1<A> monad);
    public static OptionT`2<M, A> Lift(Option`1<A> monad);
    [NullableContextAttribute("0")]
public static OptionT`2<M, A> Lift(Fail`1<Unit> monad);
    public static OptionT`2<M, A> Lift(K`2<M, A> monad);
    public static OptionT`2<M, A> Lift(K`2<M, Option`1<A>> monad);
    public static OptionT`2<M, A> LiftIO(IO`1<A> monad);
    public static OptionT`2<M, A> LiftIO(IO`1<Option`1<A>> monad);
    public K`2<M, B> Match(Func`2<A, B> Some, Func`1<B> None);
    public K`2<M, Unit> Match(Action`1<A> Some, Action None);
    public K`2<M, Unit> IfSome(Action`1<A> f);
    [PureAttribute]
public K`2<M, Unit> IfSome(Func`2<A, Unit> f);
    [PureAttribute]
public K`2<M, A> IfNone(Func`1<A> None);
    [PureAttribute]
public K`2<M, Unit> IfNone(Action None);
    [PureAttribute]
public K`2<M, A> IfNone(A noneValue);
    public K`2<M, Option`1<A>> Run();
    public OptionT`2<M1, B> MapT(Func`2<K`2<M, Option`1<A>>, K`2<M1, Option`1<B>>> f);
    public OptionT`2<M, B> MapM(Func`2<K`2<M, A>, K`2<M, B>> f);
    public OptionT`2<M, B> Map(Func`2<A, B> f);
    public OptionT`2<M, B> Select(Func`2<A, B> f);
    public OptionT`2<M, B> Bind(Func`2<A, K`2<OptionT`1<M>, B>> f);
    public OptionT`2<M, B> Bind(Func`2<A, OptionT`2<M, B>> f);
    public OptionT`2<M, B> BiBind(Func`2<A, OptionT`2<M, B>> Some, Func`1<OptionT`2<M, B>> None);
    public OptionT`2<M, A> BindNone(Func`1<OptionT`2<M, A>> None);
    public OptionT`2<M, B> Bind(Func`2<A, IO`1<B>> f);
    public OptionT`2<M, B> Bind(Func`2<A, Pure`1<B>> f);
    public OptionT`2<M, C> SelectMany(Func`2<A, K`2<OptionT`1<M>, B>> bind, Func`3<A, B, C> project);
    public OptionT`2<M, C> SelectMany(Func`2<A, OptionT`2<M, B>> bind, Func`3<A, B, C> project);
    public OptionT`2<M, C> SelectMany(Func`2<A, K`2<M, B>> bind, Func`3<A, B, C> project);
    public OptionT`2<M, C> SelectMany(Func`2<A, Option`1<B>> bind, Func`3<A, B, C> project);
    public OptionT`2<M, C> SelectMany(Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    public OptionT`2<M, C> SelectMany(Func`2<A, IO`1<B>> bind, Func`3<A, B, C> project);
    public static OptionT`2<M, A> op_RightShift(OptionT`2<M, A> lhs, OptionT`2<M, A> rhs);
    public static OptionT`2<M, A> op_RightShift(OptionT`2<M, A> lhs, K`2<OptionT`1<M>, A> rhs);
    public static OptionT`2<M, A> op_RightShift(OptionT`2<M, A> lhs, OptionT`2<M, Unit> rhs);
    public static OptionT`2<M, A> op_RightShift(OptionT`2<M, A> lhs, K`2<OptionT`1<M>, Unit> rhs);
    public static OptionT`2<M, A> op_Implicit(Option`1& ma);
    public static override OptionT`2<M, A> op_Implicit(Pure`1<A> ma);
    [NullableContextAttribute("0")]
public static override OptionT`2<M, A> op_Implicit(Fail`1<Unit> ma);
    public static OptionT`2<M, A> op_Implicit(Unit& fail);
    public static OptionT`2<M, A> op_Implicit(IO`1<A> ma);
    public static OptionT`2<M, A> op_Implicit(Lift`1<A> ma);
    public static OptionT`2<M, A> op_Implicit(Lift`2<EnvIO, A> ma);
    public static OptionT`2<M, A> op_Implicit(IO`1<Option`1<A>> ma);
    public EitherT`3<L, M, A> ToEither(L left);
    public EitherT`3<L, M, A> ToEither(Func`1<L> left);
    public EitherT`3<L, M, A> ToEither();
    public StreamT`2<M, A> ToStream();
    public static override OptionT`2<M, A> op_BitwiseOr(OptionT`2<M, A> lhs, OptionT`2<M, A> rhs);
    public static override OptionT`2<M, A> op_BitwiseOr(K`2<OptionT`1<M>, A> lhs, OptionT`2<M, A> rhs);
    public static override OptionT`2<M, A> op_BitwiseOr(OptionT`2<M, A> lhs, K`2<OptionT`1<M>, A> rhs);
    public static override OptionT`2<M, A> op_BitwiseOr(OptionT`2<M, A> ma, Pure`1<A> mb);
    public static override OptionT`2<M, A> op_BitwiseOr(OptionT`2<M, A> ma, Fail`1<Unit> _);
    public static override OptionT`2<M, A> op_BitwiseOr(OptionT`2<M, A> ma, CatchM`3<Unit, OptionT`1<M>, A> mb);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(OptionT`2<M, A> left, OptionT`2<M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(OptionT`2<M, A> left, OptionT`2<M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(OptionT`2<M, A> other);
    [CompilerGeneratedAttribute]
public virtual OptionT`2<M, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(K`2& runOption);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.OptionTExt : object {
    [ExtensionAttribute]
public static OptionT`2<M, A> As(K`2<OptionT`1<M>, A> ma);
    [ExtensionAttribute]
public static K`2<M, Option`1<A>> Run(K`2<OptionT`1<M>, A> ma);
    [ExtensionAttribute]
public static OptionT`2<IO, A> Flatten(Task`1<OptionT`2<IO, A>> tma);
    [ExtensionAttribute]
public static OptionT`2<IO, A> ToIO(Task`1<Option`1<A>> ma);
    [ExtensionAttribute]
[PureAttribute]
public static OptionT`2<M, A> Flatten(OptionT`2<M, OptionT`2<M, A>> mma);
    [ExtensionAttribute]
[PureAttribute]
public static OptionT`2<M, C> SelectMany(K`2<M, A> ma, Func`2<A, K`2<OptionT`1<M>, B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
[PureAttribute]
public static OptionT`2<M, C> SelectMany(K`2<M, A> ma, Func`2<A, OptionT`2<M, B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
[PureAttribute]
public static OptionT`2<M, B> Apply(OptionT`2<M, Func`2<A, B>> mf, OptionT`2<M, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static OptionT`2<M, B> Action(OptionT`2<M, A> ma, OptionT`2<M, B> mb);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Ord : object {
    [PureAttribute]
public static bool greaterThan(A x, A y);
    [PureAttribute]
public static bool greaterOrEq(A x, A y);
    [PureAttribute]
public static bool lessThan(A x, A y);
    [PureAttribute]
public static bool lessOrEq(A x, A y);
    [PureAttribute]
public static int compare(A x, A y);
    [PureAttribute]
public static A max(A x, A y);
    [PureAttribute]
public static A min(A x, A y);
    [PureAttribute]
public static A min(A x, A[] tail);
    [PureAttribute]
public static A max(A x, A[] tail);
}
public class LanguageExt.OrdAttribute : Attribute {
    [NullableContextAttribute("1")]
public OrdAttribute(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.OrdComparer`1 : object {
    [CompilerGeneratedAttribute]
private Func`3<A, A, int> <Comparer>P;
    public OrdComparer`1(Func`3<A, A, int> Comparer);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(A x, A y);
}
public class LanguageExt.OrdComparer`2 : object {
    [NullableAttribute("1")]
public static IComparer`1<A> Default;
    private static OrdComparer`2();
    [NullableContextAttribute("2")]
public sealed virtual int Compare(A x, A y);
}
public interface LanguageExt.Ordinal`1 {
    private static StringComparison LanguageExt.HashableString<STRING>.Comparison { get; }
    private static override StringComparison LanguageExt.HashableString<STRING>.get_Comparison();
}
public interface LanguageExt.OrdinalIgnoreCase`1 {
    private static StringComparison LanguageExt.HashableString<STRING>.Comparison { get; }
    private static override StringComparison LanguageExt.HashableString<STRING>.get_Comparison();
}
[NullableContextAttribute("1")]
public interface LanguageExt.OrdString`1 {
    private static override int LanguageExt.Traits.Ord<STRING>.Compare(STRING lhs, STRING rhs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.OutExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static Option`1<V> TryGetValue(IDictionary`2<K, V> self, K Key);
    [ExtensionAttribute]
[PureAttribute]
public static Option`1<V> TryGetValue(IReadOnlyDictionary`2<K, V> self, K ReadOnlyKey);
}
public static class LanguageExt.Patch : object {
    public static Patch`2<EqA, A> unsafeFromSeq(Seq`1<Edit`2<EqA, A>> edits);
    public static Patch`2<EqA, A> fromSeq(Seq`1<Edit`2<EqA, A>> edits);
    internal static Seq`1<Edit`2<EqA, A>> normalise(Seq`1<Edit`2<EqA, A>> edits);
    public static Patch`2<EqA, A> append(Patch`2<EqA, A> px, Patch`2<EqA, A> py);
    public static Patch`2<EqA, A> inverse(Patch`2<EqA, A> patch);
    [NullableContextAttribute("1")]
public static bool applicable(Patch`2<EqA, A> pa, IEnumerable`1<A> va);
    public static bool composable(Patch`2<EqA, A> pa, Patch`2<EqA, A> pb);
    [NullableContextAttribute("1")]
private static PatchParams`3<A, Edit`2<EqA, A>, MInt32> parms();
    public static int sizeChange(Patch`2<EqA, A> patch);
    public static Lst`1<A> apply(Patch`2<EqA, A> patch, Lst`1<A> va);
    public static Seq`1<A> apply(Patch`2<EqA, A> patch, Seq`1<A> va);
    public static Arr`1<A> apply(Patch`2<EqA, A> patch, Arr`1<A> va);
    [NullableContextAttribute("1")]
public static A[] apply(Patch`2<EqA, A> patch, A[] va);
    public static SpanArray`1<A> apply(Patch`2<EqA, A> patch, SpanArray`1<A> va);
    [NullableContextAttribute("1")]
public static List`1<A> apply(Patch`2<EqA, A> patch, List`1<A> va);
    [NullableContextAttribute("1")]
public static Iterable`1<A> apply(Patch`2<EqA, A> patch, IEnumerable`1<A> va);
    public static Patch`2<EqA, A> empty();
    [NullableContextAttribute("1")]
public static A ours(A x, A y);
    [NullableContextAttribute("1")]
public static A theirs(A x, A y);
    public static ValueTuple`2<Patch`2<EqA, A>, Patch`2<EqA, A>> transform(Patch`2<EqA, A> p, Patch`2<EqA, A> q);
    [NullableContextAttribute("1")]
public static ValueTuple`2<Patch`2<EqA, A>, Patch`2<EqA, A>> transformWith(Func`3<A, A, A> conflict, Patch`2<EqA, A> p, Patch`2<EqA, A> q);
    [NullableContextAttribute("1")]
public static Patch`2<EqA, A> diff(IEnumerable`1<A> va, IEnumerable`1<A> vb);
    [CompilerGeneratedAttribute]
internal static ValueTuple`3<Seq`1<Insert<EqA, A>>, Seq`1<Delete<EqA, A>>, Seq`1<Replace<EqA, A>>> <normalise>g__partition3|2_0(Seq`1<Edit`2<EqA, A>> grp);
    [CompilerGeneratedAttribute]
internal static Seq`1<Edit`2<EqA, A>> <normalise>g__normalise1|2_1(Seq`1<Insert<EqA, A>> inserts, Seq`1<Delete<EqA, A>> deletes, Seq`1<Replace<EqA, A>> replaces);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<int, Edit`2<EqA, A>> <inverse>g__go|4_0(int off, Edit`2<EqA, A> edit);
    [CompilerGeneratedAttribute]
internal static bool <composable>g__go|6_0(Seq`1<Edit`2<EqA, A>> ea, Seq`1<Edit`2<EqA, A>> eb, int off);
    [CompilerGeneratedAttribute]
internal static int <composable>g__offset|6_1(Edit`2<EqA, A> edit);
    [CompilerGeneratedAttribute]
internal static Unit <apply>g__go|15_0(Seq`1<Edit`2<EqA, A>> edits, SpanArray`1<A> src, SpanArray`1<A> dest, int si);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<Seq`1<Edit`2<EqA, A>>, Seq`1<Edit`2<EqA, A>>> <transformWith>g__go|20_0(Seq`1<Edit`2<EqA, A>> xs, int a, Seq`1<Edit`2<EqA, A>> ys, int b, Func`3<A, A, A> conflict);
    [CompilerGeneratedAttribute]
internal static int <transformWith>g__offset|20_1(Edit`2<EqA, A> edit);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<Seq`1<Edit`2<EqA, A>>, Seq`1<Edit`2<EqA, A>>> <transformWith>g__cons2|20_2(ValueTuple`2<Edit`2<EqA, A>, Edit`2<EqA, A>> head, ValueTuple`2<Seq`1<Edit`2<EqA, A>>, Seq`1<Edit`2<EqA, A>>> tail);
    [CompilerGeneratedAttribute]
internal static Seq`1<Edit`2<EqA, A>> <diff>g__adjust|21_0(int o, Seq`1<Edit`2<EqA, A>> list);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class LanguageExt.Patch`2 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Patch`2<EqA, A> <Empty>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Seq`1<Edit`2<EqA, A>> Edits;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Patch`2<EqA, A> Empty { get; }
    internal Patch`2(Seq`1<Edit`2<EqA, A>> edits);
    private static Patch`2();
    [CompilerGeneratedAttribute]
public static override Patch`2<EqA, A> get_Empty();
    public sealed virtual bool Equals(Patch`2<EqA, A> mb);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool op_Equality(Patch`2<EqA, A> pa, Patch`2<EqA, A> pb);
    public static bool op_Inequality(Patch`2<EqA, A> pa, Patch`2<EqA, A> pb);
    public static override Patch`2<EqA, A> op_Addition(Patch`2<EqA, A> pa, Patch`2<EqA, A> pb);
    public static Patch`2<EqA, A> op_UnaryNegation(Patch`2<EqA, A> pa);
    public virtual int GetHashCode();
    public virtual string ToString();
    public bool Applicable(IEnumerable`1<A> document);
    public sealed virtual Patch`2<EqA, A> Combine(Patch`2<EqA, A> mb);
    public Patch`2<EqA, A> Inverse();
    public int SizeChange();
    public Iterable`1<A> Apply(IEnumerable`1<A> va);
    public Seq`1<A> Apply(Seq`1<A> va);
    public Lst`1<A> Apply(Lst`1<A> va);
    public SpanArray`1<A> Apply(SpanArray`1<A> va);
    public Arr`1<A> Apply(Arr`1<A> va);
    public A[] Apply(A[] va);
    public List`1<A> Apply(List`1<A> va);
    [CompilerGeneratedAttribute]
internal static Seq`1<Edit`2<EqA, A>> <Combine>g__replace|14_0(int i, A o, A n, Seq`1<Edit`2<EqA, A>> seq);
    [CompilerGeneratedAttribute]
internal static Seq`1<Edit`2<EqA, A>> <Combine>g__merge|14_1(Seq`1<Edit`2<EqA, A>> ex, Seq`1<Edit`2<EqA, A>> ey, int off);
    [CompilerGeneratedAttribute]
internal static int <Combine>g__offset|14_2(Edit`2<EqA, A> edit);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class LanguageExt.PatchInternal : object {
    [NullableContextAttribute("2")]
public static ValueTuple`2<A, Seq`1<C>> mapAccumR(Func`3<A, B, ValueTuple`2<A, C>> f, A state, Seq`1<B> t);
    [NullableContextAttribute("2")]
public static ValueTuple`2<A, Seq`1<C>> mapAccumL(Func`3<A, B, ValueTuple`2<A, C>> f, A state, Seq`1<B> t);
    public static ValueTuple`2<C, Seq`1<O>> leastChanges(PatchParams`3<V, O, C> p, SpanArray`1<V> ss, SpanArray`1<V> tt);
    [NullableContextAttribute("0")]
private static ValueTuple`2<int, int> quotRem(int x, int y);
    private static A minimumBy(Func`3<A, A, int> compare, Lst`1<A> list);
    [NullableContextAttribute("2")]
private static SpanArray`1<A> constructN(int n, Func`2<SpanArray`1<A>, A> f);
    public static SpanArray`1<ValueTuple`2<C, Seq`1<Option`1<O>>>> rawChanges(PatchParams`3<V, O, C> p, SpanArray`1<V> src, SpanArray`1<V> dst);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.PatchParams`3 : object {
    public Func`3<V, V, bool> equivalent;
    public Func`3<int, V, O> delete;
    public Func`3<int, V, O> insert;
    public Func`4<int, V, V, O> substitute;
    public Func`2<O, C> cost;
    public Func`2<O, int> positionOffset;
    public PatchParams`3(Func`3<V, V, bool> equivalent, Func`3<int, V, O> delete, Func`3<int, V, O> insert, Func`4<int, V, V, O> substitute, Func`2<O, C> cost, Func`2<O, int> positionOffset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Pipes.Client : object {
    [PureAttribute]
public static Client`4<REQ, RES, M, R> Pure(R value);
    [PureAttribute]
public static Client`4<REQ, RES, M, RES> request(REQ value);
    [PureAttribute]
public static Client`4<REQ, RES, M, R> lift(K`2<M, R> ma);
    [PureAttribute]
public static Client`4<REQ, RES, M, R> liftIO(IO`1<R> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pipes.Client`4 : Proxy`6<REQ, RES, Unit, Void, M, A> {
    public Proxy`6<REQ, RES, Unit, Void, M, A> Value;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Client`4(Proxy`6<REQ, RES, Unit, Void, M, A> value);
    [CompilerGeneratedAttribute]
protected Client`4(Client`4<REQ, RES, M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [PureAttribute]
public virtual Proxy`6<REQ, RES, Unit, Void, M, A> ToProxy();
    [PureAttribute]
public virtual Proxy`6<REQ, RES, Unit, Void, M, B> Bind(Func`2<A, Proxy`6<REQ, RES, Unit, Void, M, B>> f);
    [PureAttribute]
public virtual Proxy`6<REQ, RES, Unit, Void, M, B> Map(Func`2<A, B> f);
    [PureAttribute]
public virtual Proxy`6<REQ, RES, Unit, Void, M, B> MapM(Func`2<K`2<M, A>, K`2<M, B>> f);
    [PureAttribute]
public virtual Proxy`6<REQ, RES, Unit, Void, M, IO`1<A>> ToIO();
    [PureAttribute]
public Client`4<REQ, RES, M, B> Bind(Func`2<A, Client`4<REQ, RES, M, B>> f);
    [PureAttribute]
public Client`4<REQ, RES, M, B> SelectMany(Func`2<A, Client`4<REQ, RES, M, B>> f);
    [PureAttribute]
public Client`4<REQ, RES, M, C> SelectMany(Func`2<A, Client`4<REQ, RES, M, B>> f, Func`3<A, B, C> project);
    [PureAttribute]
public Client`4<REQ, RES, M, B> Select(Func`2<A, B> f);
    [PureAttribute]
public virtual Proxy`6<REQ, RES, C1, C, M, A> For(Func`2<Void, Proxy`6<REQ, RES, C1, C, M, Unit>> body);
    [PureAttribute]
public virtual Proxy`6<REQ, RES, Unit, Void, M, S> Action(Proxy`6<REQ, RES, Unit, Void, M, S> r);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, Unit, Void, M, A> PairEachRequestWithRespond(Func`2<REQ, Proxy`6<UOutA, AUInA, REQ, RES, M, A>> lhs);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, Unit, Void, M, A> ReplaceRequest(Func`2<REQ, Proxy`6<UOutA, AUInA, Unit, Void, M, RES>> lhs);
    [PureAttribute]
public virtual Proxy`6<REQ, RES, DInC, DOutC, M, A> PairEachRespondWithRequest(Func`2<Void, Proxy`6<Unit, Void, DInC, DOutC, M, A>> rhs);
    [PureAttribute]
public virtual Proxy`6<REQ, RES, DInC, DOutC, M, A> ReplaceRespond(Func`2<Void, Proxy`6<REQ, RES, DInC, DOutC, M, Unit>> rhs);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, RES, REQ, M, A> Reflect();
    [PureAttribute]
public virtual Proxy`6<REQ, RES, Unit, Void, M, A> Observe();
    [PureAttribute]
public void Deconstruct(Proxy`6& value);
    [PureAttribute]
public static Effect`2<M, A> op_BitwiseOr(Func`2<REQ, Server`4<REQ, RES, M, A>> x, Client`4<REQ, RES, M, A> y);
    [PureAttribute]
public static Client`4<REQ, RES, M, A> op_BitwiseAnd(Client`4<REQ, RES, M, A> lhs, Client`4<REQ, RES, M, A> rhs);
    [PureAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Client`4<REQ, RES, M, A> left, Client`4<REQ, RES, M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Client`4<REQ, RES, M, A> left, Client`4<REQ, RES, M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Proxy`6<REQ, RES, Unit, Void, M, A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Client`4<REQ, RES, M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override Client`4<REQ, RES, M, A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Pipes.Consumer : object {
    [PureAttribute]
public static Consumer`3<A, M, R> Pure(R value);
    [PureAttribute]
public static Consumer`3<A, M, A> awaiting();
    [PureAttribute]
public static Consumer`3<A, M, R> lift(K`2<M, R> ma);
    [PureAttribute]
public static Consumer`3<A, M, R> liftIO(IO`1<R> ma);
    [PureAttribute]
public static Consumer`3<A, M, R> mapM(Func`2<A, K`2<M, Unit>> f);
    [PureAttribute]
public static Consumer`3<A, M, R> mapM(Func`2<A, IO`1<Unit>> f);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.Pipes.Consumer`2 : object {
    public abstract virtual Consumer`2<IN, B> Select(Func`2<A, B> f);
    public abstract virtual Consumer`2<IN, B> Bind(Func`2<A, Consumer`2<IN, B>> f);
    public abstract virtual Consumer`3<IN, M, B> Bind(Func`2<A, Consumer`3<IN, M, B>> f);
    public abstract virtual Pipe`3<IN, OUT, B> Bind(Func`2<A, Producer`2<OUT, B>> f);
    public Consumer`2<IN, B> Bind(Func`2<A, Pure`1<B>> f);
    public Consumer`2<IN, B> Bind(Func`2<A, Fail`1<Error>> f);
    public Consumer`3<IN, M, B> Bind(Func`2<A, K`2<M, B>> f);
    public Consumer`2<IN, B> Bind(Func`2<A, IO`1<B>> f);
    public abstract virtual Consumer`3<IN, M, A> Interpret();
    public abstract virtual Pipe`3<IN, OUT, A> ToPipe();
    public Consumer`2<IN, B> Map(Func`2<A, B> f);
    public Consumer`2<IN, C> SelectMany(Func`2<A, Pure`1<B>> f, Func`3<A, B, C> project);
    public Consumer`2<IN, C> SelectMany(Func`2<A, Fail`1<Error>> f, Func`3<A, B, C> project);
    public Consumer`2<IN, C> SelectMany(Func`2<A, IO`1<B>> f, Func`3<A, B, C> project);
    public Consumer`3<IN, M, C> SelectMany(Func`2<A, K`2<M, B>> f, Func`3<A, B, C> project);
    public Consumer`2<IN, C> SelectMany(Func`2<A, Consumer`2<IN, B>> f, Func`3<A, B, C> project);
    public Consumer`3<IN, M, C> SelectMany(Func`2<A, Consumer`3<IN, M, B>> f, Func`3<A, B, C> project);
    public Pipe`3<IN, OUT, C> SelectMany(Func`2<A, Producer`2<OUT, B>> f, Func`3<A, B, C> project);
    public Consumer`2<IN, C> SelectMany(Func`2<A, Guard`2<Error, Unit>> bind, Func`3<A, Unit, C> project);
    public static Consumer`2<IN, A> op_Implicit(Pure`1<A> ma);
    public static Consumer`2<IN, A> op_BitwiseAnd(Consumer`2<IN, A> lhs, Consumer`2<IN, A> rhs);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pipes.Consumer`3 : Proxy`6<Unit, IN, Unit, Void, M, A> {
    public Proxy`6<Unit, IN, Unit, Void, M, A> Value;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Consumer`3(Proxy`6<Unit, IN, Unit, Void, M, A> value);
    [CompilerGeneratedAttribute]
protected Consumer`3(Consumer`3<IN, M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [PureAttribute]
public virtual Proxy`6<Unit, IN, Unit, Void, M, A> ToProxy();
    [PureAttribute]
public virtual Proxy`6<Unit, IN, Unit, Void, M, S> Bind(Func`2<A, Proxy`6<Unit, IN, Unit, Void, M, S>> f);
    [PureAttribute]
public virtual Proxy`6<Unit, IN, Unit, Void, M, B> MapM(Func`2<K`2<M, A>, K`2<M, B>> f);
    [PureAttribute]
public virtual Proxy`6<Unit, IN, Unit, Void, M, IO`1<A>> ToIO();
    [PureAttribute]
public Consumer`3<IN, M, B> Bind(Func`2<A, Consumer`3<IN, M, B>> f);
    [PureAttribute]
public Consumer`3<IN, M, B> Bind(Func`2<A, K`2<M, B>> f);
    [PureAttribute]
public virtual Proxy`6<Unit, IN, Unit, Void, M, S> Map(Func`2<A, S> f);
    [PureAttribute]
public Consumer`3<IN, M, C> SelectMany(Func`2<A, Consumer`3<IN, M, B>> f, Func`3<A, B, C> project);
    [PureAttribute]
public Consumer`3<IN, M, C> SelectMany(Func`2<A, K`2<M, B>> f, Func`3<A, B, C> project);
    [PureAttribute]
public Consumer`3<IN, M, B> Select(Func`2<A, B> f);
    [PureAttribute]
public virtual Proxy`6<Unit, IN, C1, C, M, A> For(Func`2<Void, Proxy`6<Unit, IN, C1, C, M, Unit>> body);
    [PureAttribute]
public virtual Proxy`6<Unit, IN, Unit, Void, M, S> Action(Proxy`6<Unit, IN, Unit, Void, M, S> r);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, Unit, Void, M, A> PairEachRequestWithRespond(Func`2<Unit, Proxy`6<UOutA, AUInA, Unit, IN, M, A>> lhs);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, Unit, Void, M, A> ReplaceRequest(Func`2<Unit, Proxy`6<UOutA, AUInA, Unit, Void, M, IN>> lhs);
    [PureAttribute]
public virtual Proxy`6<Unit, IN, DInC, DOutC, M, A> PairEachRespondWithRequest(Func`2<Void, Proxy`6<Unit, Void, DInC, DOutC, M, A>> rhs);
    [PureAttribute]
public virtual Proxy`6<Unit, IN, DInC, DOutC, M, A> ReplaceRespond(Func`2<Void, Proxy`6<Unit, IN, DInC, DOutC, M, Unit>> rhs);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, IN, Unit, M, A> Reflect();
    [PureAttribute]
public virtual Proxy`6<Unit, IN, Unit, Void, M, A> Observe();
    [PureAttribute]
public void Deconstruct(Proxy`6& value);
    [PureAttribute]
public static Consumer`3<IN, M, A> op_Implicit(Consumer`2<IN, A> c);
    [PureAttribute]
public static Consumer`3<IN, M, A> op_Implicit(Pure`1<A> p);
    [PureAttribute]
public static Effect`2<M, A> op_BitwiseOr(IN p1, Consumer`3<IN, M, A> p2);
    [PureAttribute]
public Consumer`3<IN, M, C> SelectMany(Func`2<A, Consumer`2<IN, B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public static Consumer`3<IN, M, A> op_BitwiseAnd(Consumer`3<IN, M, A> lhs, Consumer`3<IN, M, A> rhs);
    [PureAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Consumer`3<IN, M, A> left, Consumer`3<IN, M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Consumer`3<IN, M, A> left, Consumer`3<IN, M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Proxy`6<Unit, IN, Unit, Void, M, A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Consumer`3<IN, M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override Consumer`3<IN, M, A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.Pipes.Effect : object {
    [ExtensionAttribute]
[PureAttribute]
public static K`2<M, R> RunEffect(Proxy`6<Void, Unit, Unit, Void, M, R> ma);
    internal static K`2<M, R> runIterator(Iterator`6<Void, Unit, Unit, Void, M, R> iter, Func`2<Proxy`6<Void, Unit, Unit, Void, M, R>, K`2<M, R>> go);
    [ExtensionAttribute]
[PureAttribute]
private static Proxy`6<UOut, UIn, DIn, DOut, N, R> HoistX(Proxy`6<UOut, UIn, DIn, DOut, M, R> ma, Func`2<K`2<M, Proxy`6<UOut, UIn, DIn, DOut, N, R>>, K`2<N, Proxy`6<UOut, UIn, DIn, DOut, N, R>>> nat);
    [PureAttribute]
public static Effect`2<M, R> lift(K`2<M, R> ma);
    [PureAttribute]
public static Effect`2<M, R> liftIO(IO`1<R> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Effect`2<M, C> SelectMany(K`2<M, A> ma, Func`2<A, Effect`2<M, B>> bind, Func`3<A, B, C> project);
    [CompilerGeneratedAttribute]
internal static K`2<M, R> <RunEffect>g__Go|0_0(Proxy`6<Void, Unit, Unit, Void, M, R> p);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pipes.Effect`2 : Proxy`6<Void, Unit, Unit, Void, M, A> {
    public Proxy`6<Void, Unit, Unit, Void, M, A> Value;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Effect`2(Proxy`6<Void, Unit, Unit, Void, M, A> value);
    [CompilerGeneratedAttribute]
protected Effect`2(Effect`2<M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [PureAttribute]
public virtual Proxy`6<Void, Unit, Unit, Void, M, A> ToProxy();
    [PureAttribute]
public virtual Proxy`6<Void, Unit, Unit, Void, M, S> Bind(Func`2<A, Proxy`6<Void, Unit, Unit, Void, M, S>> f);
    [PureAttribute]
public Effect`2<M, S> Bind(Func`2<A, Effect`2<M, S>> f);
    [PureAttribute]
public Effect`2<M, B> Bind(Func`2<A, K`2<M, B>> f);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, Unit, Void, M, B> Map(Func`2<A, B> f);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, Unit, Void, M, B> MapM(Func`2<K`2<M, A>, K`2<M, B>> f);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, Unit, Void, M, IO`1<A>> ToIO();
    [PureAttribute]
public virtual Proxy`6<Void, Unit, C1, C, M, A> For(Func`2<Void, Proxy`6<Void, Unit, C1, C, M, Unit>> body);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, Unit, Void, M, S> Action(Proxy`6<Void, Unit, Unit, Void, M, S> r);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, Unit, Void, M, A> PairEachRequestWithRespond(Func`2<Void, Proxy`6<UOutA, AUInA, Void, Unit, M, A>> lhs);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, Unit, Void, M, A> ReplaceRequest(Func`2<Void, Proxy`6<UOutA, AUInA, Unit, Void, M, Unit>> lhs);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, DInC, DOutC, M, A> PairEachRespondWithRequest(Func`2<Void, Proxy`6<Unit, Void, DInC, DOutC, M, A>> rhs);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, DInC, DOutC, M, A> ReplaceRespond(Func`2<Void, Proxy`6<Void, Unit, DInC, DOutC, M, Unit>> rhs);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, Unit, Void, M, A> Reflect();
    [PureAttribute]
public virtual Proxy`6<Void, Unit, Unit, Void, M, A> Observe();
    [PureAttribute]
public void Deconstruct(Proxy`6& value);
    [PureAttribute]
public Effect`2<M, C> SelectMany(Func`2<A, Effect`2<M, B>> f, Func`3<A, B, C> project);
    [PureAttribute]
public Effect`2<M, C> SelectMany(Func`2<A, IO`1<B>> f, Func`3<A, B, C> project);
    [PureAttribute]
public K`2<M, C> SelectMany(Func`2<A, K`2<M, B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public static Effect`2<M, A> op_BitwiseAnd(Effect`2<M, A> lhs, Effect`2<M, A> rhs);
    [PureAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Effect`2<M, A> left, Effect`2<M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Effect`2<M, A> left, Effect`2<M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Proxy`6<Void, Unit, Unit, Void, M, A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Effect`2<M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override Effect`2<M, A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class LanguageExt.Pipes.Iterator`6 : Proxy`6<UOut, UIn, DIn, DOut, M, A> {
    [CompilerGeneratedAttribute]
private Func`1<Proxy`6<UOut, UIn, DIn, DOut, M, A>> <Next>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Func`1<Proxy`6<UOut, UIn, DIn, DOut, M, A>> Next { get; public set; }
    protected Iterator`6(Func`1<Proxy`6<UOut, UIn, DIn, DOut, M, A>> Next);
    [CompilerGeneratedAttribute]
protected Iterator`6(Iterator`6<UOut, UIn, DIn, DOut, M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Func`1<Proxy`6<UOut, UIn, DIn, DOut, M, A>> get_Next();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Next(Func`1<Proxy`6<UOut, UIn, DIn, DOut, M, A>> value);
    public abstract virtual IEnumerable`1<Proxy`6<UOut, UIn, DIn, DOut, M, Unit>> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Iterator`6<UOut, UIn, DIn, DOut, M, A> left, Iterator`6<UOut, UIn, DIn, DOut, M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Iterator`6<UOut, UIn, DIn, DOut, M, A> left, Iterator`6<UOut, UIn, DIn, DOut, M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Proxy`6<UOut, UIn, DIn, DOut, M, A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Iterator`6<UOut, UIn, DIn, DOut, M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public abstract virtual override Iterator`6<UOut, UIn, DIn, DOut, M, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`1& Next);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pipes.IteratorAsyncEnumerable`8 : Iterator`6<UOut, UIn, DIn, DOut, M, A> {
    [CompilerGeneratedAttribute]
private IAsyncEnumerable`1<X> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<X, Proxy`6<UOut, UIn, DIn, DOut, M, Unit>> <Yield>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IAsyncEnumerable`1<X> Items { get; public set; }
    public Func`2<X, Proxy`6<UOut, UIn, DIn, DOut, M, Unit>> Yield { get; public set; }
    public IteratorAsyncEnumerable`8(IAsyncEnumerable`1<X> Items, Func`2<X, Proxy`6<UOut, UIn, DIn, DOut, M, Unit>> Yield, Func`1<Proxy`6<UOut, UIn, DIn, DOut, M, A>> Next);
    [CompilerGeneratedAttribute]
protected IteratorAsyncEnumerable`8(IteratorAsyncEnumerable`8<UOut, UIn, DIn, DOut, F, X, M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IAsyncEnumerable`1<X> get_Items();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Items(IAsyncEnumerable`1<X> value);
    [CompilerGeneratedAttribute]
public Func`2<X, Proxy`6<UOut, UIn, DIn, DOut, M, Unit>> get_Yield();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Yield(Func`2<X, Proxy`6<UOut, UIn, DIn, DOut, M, Unit>> value);
    public virtual Proxy`6<UOut, UIn, DIn, DOut, M, A> ToProxy();
    [IteratorStateMachineAttribute("LanguageExt.Pipes.IteratorAsyncEnumerable`8/<Run>d__12")]
public virtual IEnumerable`1<Proxy`6<UOut, UIn, DIn, DOut, M, Unit>> Run();
    public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> Bind(Func`2<A, Proxy`6<UOut, UIn, DIn, DOut, M, B>> f);
    public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> Map(Func`2<A, B> f);
    public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> MapM(Func`2<K`2<M, A>, K`2<M, B>> f);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, IO`1<A>> ToIO();
    public virtual Proxy`6<UOut, UIn, C1, C, M, A> For(Func`2<DOut, Proxy`6<UOut, UIn, C1, C, M, DIn>> body);
    public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> Action(Proxy`6<UOut, UIn, DIn, DOut, M, B> r);
    public virtual Proxy`6<UOutA, AUInA, DIn, DOut, M, A> PairEachRequestWithRespond(Func`2<UOut, Proxy`6<UOutA, AUInA, UOut, UIn, M, A>> lhs);
    public virtual Proxy`6<UOutA, AUInA, DIn, DOut, M, A> ReplaceRequest(Func`2<UOut, Proxy`6<UOutA, AUInA, DIn, DOut, M, UIn>> lhs);
    public virtual Proxy`6<UOut, UIn, DInC, DOutC, M, A> PairEachRespondWithRequest(Func`2<DOut, Proxy`6<DIn, DOut, DInC, DOutC, M, A>> rhs);
    public virtual Proxy`6<UOut, UIn, DInC, DOutC, M, A> ReplaceRespond(Func`2<DOut, Proxy`6<UOut, UIn, DInC, DOutC, M, DIn>> rhs);
    public virtual Proxy`6<DOut, DIn, UIn, UOut, M, A> Reflect();
    public virtual Proxy`6<UOut, UIn, DIn, DOut, M, A> Observe();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(IteratorAsyncEnumerable`8<UOut, UIn, DIn, DOut, F, X, M, A> left, IteratorAsyncEnumerable`8<UOut, UIn, DIn, DOut, F, X, M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(IteratorAsyncEnumerable`8<UOut, UIn, DIn, DOut, F, X, M, A> left, IteratorAsyncEnumerable`8<UOut, UIn, DIn, DOut, F, X, M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Iterator`6<UOut, UIn, DIn, DOut, M, A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(IteratorAsyncEnumerable`8<UOut, UIn, DIn, DOut, F, X, M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override IteratorAsyncEnumerable`8<UOut, UIn, DIn, DOut, F, X, M, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(IAsyncEnumerable`1& Items, Func`2& Yield, Func`1& Next);
    [CompilerGeneratedAttribute]
private Proxy`6<UOut, UIn, DIn, DOut, M, IO`1<A>> <ToIO>b__16_0();
    [CompilerGeneratedAttribute]
private Proxy`6<DOut, DIn, UIn, UOut, M, Unit> <Reflect>b__23_0(X x);
    [CompilerGeneratedAttribute]
private Proxy`6<DOut, DIn, UIn, UOut, M, A> <Reflect>b__23_1();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pipes.IteratorFoldable`8 : Iterator`6<UOut, UIn, DIn, DOut, M, A> {
    [CompilerGeneratedAttribute]
private K`2<F, X> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<X, Proxy`6<UOut, UIn, DIn, DOut, M, Unit>> <Yield>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public K`2<F, X> Items { get; public set; }
    public Func`2<X, Proxy`6<UOut, UIn, DIn, DOut, M, Unit>> Yield { get; public set; }
    public IteratorFoldable`8(K`2<F, X> Items, Func`2<X, Proxy`6<UOut, UIn, DIn, DOut, M, Unit>> Yield, Func`1<Proxy`6<UOut, UIn, DIn, DOut, M, A>> Next);
    [CompilerGeneratedAttribute]
protected IteratorFoldable`8(IteratorFoldable`8<UOut, UIn, DIn, DOut, F, X, M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public K`2<F, X> get_Items();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Items(K`2<F, X> value);
    [CompilerGeneratedAttribute]
public Func`2<X, Proxy`6<UOut, UIn, DIn, DOut, M, Unit>> get_Yield();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Yield(Func`2<X, Proxy`6<UOut, UIn, DIn, DOut, M, Unit>> value);
    public virtual Proxy`6<UOut, UIn, DIn, DOut, M, A> ToProxy();
    [IteratorStateMachineAttribute("LanguageExt.Pipes.IteratorFoldable`8/<Run>d__12")]
public virtual IEnumerable`1<Proxy`6<UOut, UIn, DIn, DOut, M, Unit>> Run();
    public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> Bind(Func`2<A, Proxy`6<UOut, UIn, DIn, DOut, M, B>> f);
    public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> Map(Func`2<A, B> f);
    public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> MapM(Func`2<K`2<M, A>, K`2<M, B>> f);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, IO`1<A>> ToIO();
    public virtual Proxy`6<UOut, UIn, C1, C, M, A> For(Func`2<DOut, Proxy`6<UOut, UIn, C1, C, M, DIn>> body);
    public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> Action(Proxy`6<UOut, UIn, DIn, DOut, M, B> r);
    public virtual Proxy`6<UOutA, AUInA, DIn, DOut, M, A> PairEachRequestWithRespond(Func`2<UOut, Proxy`6<UOutA, AUInA, UOut, UIn, M, A>> lhs);
    public virtual Proxy`6<UOutA, AUInA, DIn, DOut, M, A> ReplaceRequest(Func`2<UOut, Proxy`6<UOutA, AUInA, DIn, DOut, M, UIn>> lhs);
    public virtual Proxy`6<UOut, UIn, DInC, DOutC, M, A> PairEachRespondWithRequest(Func`2<DOut, Proxy`6<DIn, DOut, DInC, DOutC, M, A>> rhs);
    public virtual Proxy`6<UOut, UIn, DInC, DOutC, M, A> ReplaceRespond(Func`2<DOut, Proxy`6<UOut, UIn, DInC, DOutC, M, DIn>> rhs);
    public virtual Proxy`6<DOut, DIn, UIn, UOut, M, A> Reflect();
    public virtual Proxy`6<UOut, UIn, DIn, DOut, M, A> Observe();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(IteratorFoldable`8<UOut, UIn, DIn, DOut, F, X, M, A> left, IteratorFoldable`8<UOut, UIn, DIn, DOut, F, X, M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(IteratorFoldable`8<UOut, UIn, DIn, DOut, F, X, M, A> left, IteratorFoldable`8<UOut, UIn, DIn, DOut, F, X, M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Iterator`6<UOut, UIn, DIn, DOut, M, A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(IteratorFoldable`8<UOut, UIn, DIn, DOut, F, X, M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override IteratorFoldable`8<UOut, UIn, DIn, DOut, F, X, M, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(K`2& Items, Func`2& Yield, Func`1& Next);
    [CompilerGeneratedAttribute]
private Proxy`6<UOut, UIn, DIn, DOut, M, IO`1<A>> <ToIO>b__16_0();
    [CompilerGeneratedAttribute]
private Proxy`6<DOut, DIn, UIn, UOut, M, Unit> <Reflect>b__23_0(X x);
    [CompilerGeneratedAttribute]
private Proxy`6<DOut, DIn, UIn, UOut, M, A> <Reflect>b__23_1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Pipes.Pipe : object {
    [PureAttribute]
public static Pipe`4<A, B, M, R> Pure(R value);
    [PureAttribute]
public static Pipe`4<A, Y, M, A> awaiting();
    [PureAttribute]
public static Pipe`4<IN, OUT, M, Unit> yield(OUT value);
    public static Pipe`4<A, A, M, Unit> filter(Func`2<A, bool> f);
    public static Pipe`4<A, B, M, R> map(Func`2<A, B> f);
    public static Pipe`4<A, B, M, Unit> map(Func`2<A, B> f);
    public static Pipe`3<A, B, Unit> map(Func`2<A, B> f);
    [PureAttribute]
public static Pipe`4<A, B, M, R> mapM(Func`2<A, K`2<M, B>> f);
    [PureAttribute]
public static Pipe`4<A, B, M, R> lift(K`2<M, R> ma);
    [PureAttribute]
public static Pipe`4<A, B, M, R> liftIO(IO`1<R> ma);
    [PureAttribute]
public static Pipe`4<IN, OUT, M, Unit> foldWhile(OUT Initial, Func`3<OUT, IN, OUT> Fold, Func`2<OUT, bool> WhileState);
    public static Pipe`4<IN, OUT, M, Unit> foldUntil(OUT Initial, Func`3<OUT, IN, OUT> Fold, Func`2<OUT, bool> UntilState);
    [PureAttribute]
public static Pipe`4<IN, OUT, M, Unit> foldWhile(OUT Initial, Func`3<OUT, IN, OUT> Fold, Func`2<IN, bool> WhileValue);
    public static Pipe`4<IN, OUT, M, Unit> foldUntil(OUT Initial, Func`3<OUT, IN, OUT> Fold, Func`2<IN, bool> UntilValue);
    public static Pipe`4<IN, OUT, M, Unit> scan(Func`3<S, IN, S> Step, S Begin, Func`2<S, OUT> Done);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.Pipes.Pipe`3 : object {
    public abstract virtual Pipe`3<IN, OUT, B> Select(Func`2<A, B> f);
    public abstract virtual Pipe`4<IN, OUT, M, A> Interpret();
    public abstract virtual Pipe`3<IN, OUT, B> Bind(Func`2<A, Pipe`3<IN, OUT, B>> f);
    public abstract virtual Pipe`4<IN, OUT, M, B> Bind(Func`2<A, Pipe`4<IN, OUT, M, B>> f);
    public abstract virtual Pipe`3<IN, OUT, B> Bind(Func`2<A, Consumer`2<IN, B>> f);
    public abstract virtual Pipe`3<IN, OUT, B> Bind(Func`2<A, Producer`2<OUT, B>> f);
    public Pipe`3<IN, OUT, B> Bind(Func`2<A, Pure`1<B>> f);
    public Pipe`3<IN, OUT, B> Bind(Func`2<A, Fail`1<Error>> f);
    public Pipe`4<IN, OUT, M, B> Bind(Func`2<A, K`2<M, B>> f);
    public Pipe`3<IN, OUT, B> Bind(Func`2<A, IO`1<B>> f);
    public Pipe`3<IN, OUT, B> Map(Func`2<A, B> f);
    public Pipe`3<IN, OUT, C> SelectMany(Func`2<A, Pipe`3<IN, OUT, B>> f, Func`3<A, B, C> project);
    public Pipe`3<IN, OUT, C> SelectMany(Func`2<A, Pure`1<B>> f, Func`3<A, B, C> project);
    public Pipe`3<IN, OUT, C> SelectMany(Func`2<A, Fail`1<Error>> f, Func`3<A, B, C> project);
    public Pipe`4<IN, OUT, M, C> SelectMany(Func`2<A, K`2<M, B>> f, Func`3<A, B, C> project);
    public Pipe`3<IN, OUT, C> SelectMany(Func`2<A, IO`1<B>> f, Func`3<A, B, C> project);
    public Pipe`4<IN, OUT, M, C> SelectMany(Func`2<A, Pipe`4<IN, OUT, M, B>> f, Func`3<A, B, C> project);
    public Pipe`3<IN, OUT, C> SelectMany(Func`2<A, Consumer`2<IN, B>> f, Func`3<A, B, C> project);
    public Pipe`3<IN, OUT, C> SelectMany(Func`2<A, Producer`2<OUT, B>> f, Func`3<A, B, C> project);
    public Pipe`3<IN, OUT, C> SelectMany(Func`2<A, Guard`2<Error, Unit>> bind, Func`3<A, Unit, C> project);
    public static Pipe`3<IN, OUT, A> op_Implicit(Pure`1<A> ma);
    public static Pipe`3<IN, OUT, A> op_BitwiseAnd(Pipe`3<IN, OUT, A> lhs, Pipe`3<IN, OUT, A> rhs);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pipes.Pipe`4 : Proxy`6<Unit, IN, Unit, OUT, M, A> {
    public Proxy`6<Unit, IN, Unit, OUT, M, A> Value;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Pipe`4(Proxy`6<Unit, IN, Unit, OUT, M, A> value);
    [CompilerGeneratedAttribute]
protected Pipe`4(Pipe`4<IN, OUT, M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [PureAttribute]
public virtual Proxy`6<Unit, IN, Unit, OUT, M, A> ToProxy();
    [PureAttribute]
public virtual Proxy`6<Unit, IN, Unit, OUT, M, S> Bind(Func`2<A, Proxy`6<Unit, IN, Unit, OUT, M, S>> f);
    [PureAttribute]
public Pipe`4<IN, OUT, M, B> Bind(Func`2<A, K`2<M, B>> f);
    [PureAttribute]
public Pipe`4<IN, OUT, M, B> Bind(Func`2<A, IO`1<B>> f);
    [PureAttribute]
public virtual Proxy`6<Unit, IN, Unit, OUT, M, B> Map(Func`2<A, B> f);
    [PureAttribute]
public virtual Proxy`6<Unit, IN, Unit, OUT, M, B> MapM(Func`2<K`2<M, A>, K`2<M, B>> f);
    [PureAttribute]
public virtual Proxy`6<Unit, IN, Unit, OUT, M, IO`1<A>> ToIO();
    [PureAttribute]
public Pipe`4<IN, OUT, M, B> Bind(Func`2<A, Pipe`4<IN, OUT, M, B>> f);
    [PureAttribute]
public Pipe`4<IN, OUT, M, B> Select(Func`2<A, B> f);
    [PureAttribute]
public virtual Proxy`6<Unit, IN, C1, C, M, A> For(Func`2<OUT, Proxy`6<Unit, IN, C1, C, M, Unit>> body);
    [PureAttribute]
public virtual Proxy`6<Unit, IN, Unit, OUT, M, S> Action(Proxy`6<Unit, IN, Unit, OUT, M, S> r);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, Unit, OUT, M, A> PairEachRequestWithRespond(Func`2<Unit, Proxy`6<UOutA, AUInA, Unit, IN, M, A>> lhs);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, Unit, OUT, M, A> ReplaceRequest(Func`2<Unit, Proxy`6<UOutA, AUInA, Unit, OUT, M, IN>> lhs);
    [PureAttribute]
public virtual Proxy`6<Unit, IN, DInC, DOutC, M, A> PairEachRespondWithRequest(Func`2<OUT, Proxy`6<Unit, OUT, DInC, DOutC, M, A>> rhs);
    [PureAttribute]
public virtual Proxy`6<Unit, IN, DInC, DOutC, M, A> ReplaceRespond(Func`2<OUT, Proxy`6<Unit, IN, DInC, DOutC, M, Unit>> rhs);
    [PureAttribute]
public virtual Proxy`6<OUT, Unit, IN, Unit, M, A> Reflect();
    [PureAttribute]
public virtual Proxy`6<Unit, IN, Unit, OUT, M, A> Observe();
    [PureAttribute]
public void Deconstruct(Proxy`6& value);
    [PureAttribute]
public static Producer`3<OUT, M, A> op_BitwiseOr(Producer`3<IN, M, A> p1, Pipe`4<IN, OUT, M, A> p2);
    [PureAttribute]
public static Producer`3<OUT, M, A> op_BitwiseOr(Producer`2<IN, A> p1, Pipe`4<IN, OUT, M, A> p2);
    [PureAttribute]
public static Producer`3<OUT, M, A> op_BitwiseOr(Producer`2<OUT, IN> p1, Pipe`4<IN, OUT, M, A> p2);
    [PureAttribute]
public static Consumer`3<IN, M, A> op_BitwiseOr(Pipe`4<IN, OUT, M, A> p1, Consumer`2<OUT, A> p2);
    [PureAttribute]
public static Consumer`3<IN, M, A> op_BitwiseOr(Pipe`4<IN, OUT, M, A> p1, Consumer`3<OUT, M, A> p2);
    [PureAttribute]
public Pipe`4<IN, C, M, A> Then(Pipe`4<OUT, C, M, A> pipe);
    [PureAttribute]
public static Pipe`4<IN, OUT, M, A> op_Implicit(Pipe`3<IN, OUT, A> p);
    [PureAttribute]
public static Pipe`4<IN, OUT, M, A> op_Implicit(Pure`1<A> p);
    [PureAttribute]
public Pipe`4<IN, OUT, M, B> SelectMany(Func`2<A, Pipe`3<IN, OUT, B>> bind);
    [PureAttribute]
public Pipe`4<IN, OUT, M, C> SelectMany(Func`2<A, Pipe`3<IN, OUT, B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Pipe`4<IN, OUT, M, B> SelectMany(Func`2<A, Pipe`4<IN, OUT, M, B>> f);
    [PureAttribute]
public Pipe`4<IN, OUT, M, C> SelectMany(Func`2<A, Pipe`4<IN, OUT, M, B>> f, Func`3<A, B, C> project);
    [PureAttribute]
public Pipe`4<IN, OUT, M, C> SelectMany(Func`2<A, K`2<M, B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Pipe`4<IN, OUT, M, C> SelectMany(Func`2<A, IO`1<B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public static Pipe`4<IN, OUT, M, A> op_BitwiseAnd(Pipe`4<IN, OUT, M, A> lhs, Pipe`4<IN, OUT, M, A> rhs);
    [PureAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Pipe`4<IN, OUT, M, A> left, Pipe`4<IN, OUT, M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Pipe`4<IN, OUT, M, A> left, Pipe`4<IN, OUT, M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Proxy`6<Unit, IN, Unit, OUT, M, A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Pipe`4<IN, OUT, M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override Pipe`4<IN, OUT, M, A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.Pipes.Producer : object {
    [PureAttribute]
public static Producer`3<OUT, M, R> Pure(R value);
    [PureAttribute]
public static Producer`3<OUT, M, Unit> yield(OUT value);
    [PureAttribute]
public static Producer`3<X, M, Unit> yieldAll(IEnumerable`1<X> xs);
    [PureAttribute]
public static Producer`3<X, M, Unit> yieldAll(IAsyncEnumerable`1<X> xs);
    [PureAttribute]
public static Producer`3<X, M, Unit> yieldAll(IObservable`1<X> xs);
    [PureAttribute]
public static Producer`3<A, M, Unit> repeatM(K`2<M, A> ma);
    [PureAttribute]
public static Producer`3<OUT, M, R> lift(K`2<M, R> ma);
    [PureAttribute]
public static Producer`3<OUT, M, R> liftIO(IO`1<R> ma);
    [ExtensionAttribute]
public static Producer`3<S, M, Unit> FoldUntil(Producer`3<S, M, A> ma, S Initial, Func`3<S, A, S> Fold, Func`2<A, bool> UntilValue);
    [ExtensionAttribute]
public static Producer`3<S, M, Unit> FoldWhile(Producer`3<S, M, A> ma, S Initial, Func`3<S, A, S> Fold, Func`2<A, bool> WhileValue);
    [ExtensionAttribute]
public static Producer`3<S, M, Unit> FoldUntil(Producer`3<S, M, A> ma, S Initial, Func`3<S, A, S> Fold, Func`2<S, bool> UntilState);
    [ExtensionAttribute]
public static Producer`3<S, M, Unit> FoldWhile(Producer`3<S, M, A> ma, S Initial, Func`3<S, A, S> Fold, Func`2<S, bool> WhileState);
    public static Producer`3<OUT, M, Unit> merge_OLD(Seq`1<Producer`3<OUT, M, Unit>> ms);
    public static Producer`3<OUT, M, Unit> merge(Seq`1<Producer`3<OUT, M, Unit>> ms);
    public static Producer`3<OUT, M, Unit> merge(Queue`3[] ms);
    public static Producer`3<OUT, M, Unit> merge(Producer`3[] ms);
    public static Producer`3<OUT, M, Unit> merge(Proxy`6[] ms);
    public static Producer`3<OUT, M, Unit> merge(Seq`1<Queue`3<OUT, M, Unit>> ms);
    public static Producer`3<OUT, M, Unit> merge(Seq`1<Proxy`6<Void, Unit, Unit, OUT, M, Unit>> ms);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.Pipes.Producer`2 : object {
    public abstract virtual Producer`2<OUT, B> Select(Func`2<A, B> f);
    public abstract virtual Producer`2<OUT, B> Bind(Func`2<A, Producer`2<OUT, B>> f);
    public abstract virtual Producer`3<OUT, M, B> Bind(Func`2<A, Producer`3<OUT, M, B>> f);
    public abstract virtual Producer`3<OUT, M, A> Interpret();
    public abstract virtual Pipe`3<IN, OUT, A> ToPipe();
    public Producer`2<OUT, B> Bind(Func`2<A, Pure`1<B>> f);
    public Producer`2<OUT, B> Bind(Func`2<A, Fail`1<Error>> f);
    public Producer`3<OUT, M, B> Bind(Func`2<A, K`2<M, B>> f);
    public Producer`2<OUT, B> Bind(Func`2<A, IO`1<B>> f);
    public Producer`2<OUT, B> Map(Func`2<A, B> f);
    public Producer`2<OUT, C> SelectMany(Func`2<A, Producer`2<OUT, B>> f, Func`3<A, B, C> project);
    public Producer`3<OUT, M, C> SelectMany(Func`2<A, Producer`3<OUT, M, B>> f, Func`3<A, B, C> project);
    public Producer`2<OUT, C> SelectMany(Func`2<A, Pure`1<B>> f, Func`3<A, B, C> project);
    public Producer`2<OUT, C> SelectMany(Func`2<A, Fail`1<Error>> f, Func`3<A, B, C> project);
    public Producer`2<OUT, C> SelectMany(Func`2<A, IO`1<B>> f, Func`3<A, B, C> project);
    public Producer`3<OUT, M, C> SelectMany(Func`2<A, K`2<M, B>> f, Func`3<A, B, C> project);
    public Producer`2<OUT, C> SelectMany(Func`2<A, Guard`2<Error, Unit>> bind, Func`3<A, Unit, C> project);
    public static Producer`2<OUT, A> op_Implicit(Pure`1<A> ma);
    public static Producer`2<OUT, A> op_BitwiseAnd(Producer`2<OUT, A> lhs, Producer`2<OUT, A> rhs);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pipes.Producer`3 : Proxy`6<Void, Unit, Unit, OUT, M, A> {
    public Proxy`6<Void, Unit, Unit, OUT, M, A> Value;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Producer`3(Proxy`6<Void, Unit, Unit, OUT, M, A> value);
    [CompilerGeneratedAttribute]
protected Producer`3(Producer`3<OUT, M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [PureAttribute]
public virtual Proxy`6<Void, Unit, Unit, OUT, M, A> ToProxy();
    [PureAttribute]
public virtual Proxy`6<Void, Unit, Unit, OUT, M, S> Bind(Func`2<A, Proxy`6<Void, Unit, Unit, OUT, M, S>> f);
    [PureAttribute]
public Producer`3<OUT, M, B> Bind(Func`2<A, K`2<M, B>> f);
    [PureAttribute]
public Producer`3<OUT, M, B> Bind(Func`2<A, IO`1<B>> f);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, Unit, OUT, M, B> Map(Func`2<A, B> f);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, Unit, OUT, M, B> MapM(Func`2<K`2<M, A>, K`2<M, B>> f);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, Unit, OUT, M, IO`1<A>> ToIO();
    [PureAttribute]
public Producer`3<OUT, M, B> Bind(Func`2<A, Producer`3<OUT, M, B>> f);
    [PureAttribute]
public Producer`3<OUT, M, B> SelectMany(Func`2<A, Producer`3<OUT, M, B>> f);
    [PureAttribute]
public Producer`3<OUT, M, C> SelectMany(Func`2<A, Producer`3<OUT, M, B>> f, Func`3<A, B, C> project);
    [PureAttribute]
public Producer`3<OUT, M, B> Select(Func`2<A, B> f);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, C1, C, M, A> For(Func`2<OUT, Proxy`6<Void, Unit, C1, C, M, Unit>> body);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, Unit, OUT, M, B> Action(Proxy`6<Void, Unit, Unit, OUT, M, B> r);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, Unit, OUT, M, A> PairEachRequestWithRespond(Func`2<Void, Proxy`6<UOutA, AUInA, Void, Unit, M, A>> lhs);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, Unit, OUT, M, A> ReplaceRequest(Func`2<Void, Proxy`6<UOutA, AUInA, Unit, OUT, M, Unit>> lhs);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, DInC, DOutC, M, A> PairEachRespondWithRequest(Func`2<OUT, Proxy`6<Unit, OUT, DInC, DOutC, M, A>> rhs);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, DInC, DOutC, M, A> ReplaceRespond(Func`2<OUT, Proxy`6<Void, Unit, DInC, DOutC, M, Unit>> rhs);
    [PureAttribute]
public virtual Proxy`6<OUT, Unit, Unit, Void, M, A> Reflect();
    [PureAttribute]
public virtual Proxy`6<Void, Unit, Unit, OUT, M, A> Observe();
    [PureAttribute]
public static Effect`2<M, A> op_BitwiseOr(Producer`3<OUT, M, A> p1, Consumer`3<OUT, M, A> p2);
    [PureAttribute]
public static Effect`2<M, A> op_BitwiseOr(Producer`3<OUT, M, A> p1, Consumer`2<OUT, A> p2);
    [PureAttribute]
public void Deconstruct(Proxy`6& value);
    [PureAttribute]
public static Producer`3<OUT, M, A> op_Implicit(Producer`2<OUT, A> p);
    [PureAttribute]
public static Producer`3<OUT, M, A> op_Implicit(Pure`1<A> p);
    [PureAttribute]
public Producer`3<OUT, M, B> SelectMany(Func`2<A, Producer`2<OUT, B>> bind);
    [PureAttribute]
public Producer`3<OUT, M, C> SelectMany(Func`2<A, Producer`2<OUT, B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Producer`3<OUT, M, C> SelectMany(Func`2<A, K`2<M, B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public static Producer`3<OUT, M, A> op_BitwiseAnd(Producer`3<OUT, M, A> lhs, Producer`3<OUT, M, A> rhs);
    [PureAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Producer`3<OUT, M, A> left, Producer`3<OUT, M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Producer`3<OUT, M, A> left, Producer`3<OUT, M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Proxy`6<Void, Unit, Unit, OUT, M, A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Producer`3<OUT, M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override Producer`3<OUT, M, A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.Pipes.Proxy : object {
    internal static MethodImplOptions mops;
    [PureAttribute]
public static Consumer`2<A, A> awaiting();
    [PureAttribute]
public static Producer`2<A, Unit> yield(A value);
    public static Queue`3<A, M, Unit> Queue();
    [PureAttribute]
public static Producer`2<X, Unit> yieldAll(K`2<F, X> xs);
    [PureAttribute]
public static Producer`2<X, Unit> yieldAll(IAsyncEnumerable`1<X> xs);
    [PureAttribute]
public static Producer`2<X, Unit> yieldAll(IObservable`1<X> xs);
    [PureAttribute]
public static Producer`3<OUT, M, R> tail(Producer`3<OUT, M, R> ma);
    [PureAttribute]
public static Consumer`3<IN, M, R> tail(Consumer`3<IN, M, R> ma);
    [PureAttribute]
public static Pipe`4<IN, OUT, M, R> tail(Pipe`4<IN, OUT, M, R> ma);
    [PureAttribute]
public static Producer`3<OUT, M, Unit> repeat(Producer`3<OUT, M, R> ma);
    [PureAttribute]
public static Consumer`3<IN, M, Unit> repeat(Consumer`3<IN, M, R> ma);
    [PureAttribute]
public static Pipe`4<IN, OUT, M, Unit> repeat(Pipe`4<IN, OUT, M, R> ma);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Proxy`6<A1, A, B1, B, M, R> lift(K`2<M, R> ma);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Proxy`6<A1, A, B1, B, M, R> liftIO(K`2<IO, R> ma);
    internal static Unit dispose(A d);
    internal static Unit anyDispose(A x);
    [PureAttribute]
public static Pipe`4<A, A, M, R> cat();
    [PureAttribute]
public static Proxy`6<UOut, UIn, UOut, UIn, M, A> pull(UOut a1);
    [PureAttribute]
public static Proxy`6<UOut, UIn, UOut, UIn, M, A> push(UIn a);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Proxy`6<X1, X, DIn, DOut, M, DIn> respond(DOut value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Proxy`6<UOut, UIn, Y1, Y, M, UIn> request(UOut value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Proxy`6<DOut, DIn, UIn, UOut, M, R> reflect(Proxy`6<UOut, UIn, DIn, DOut, M, R> p);
    [ExtensionAttribute]
[PureAttribute]
public static Producer`3<OUT_B, M, A> ForEach(Producer`3<OUT_A, M, A> p, Func`2<OUT_A, Producer`3<OUT_B, M, Unit>> body);
    [ExtensionAttribute]
[PureAttribute]
public static Effect`2<M, A> ForEach(Producer`3<OUT, M, A> p, Func`2<OUT, Effect`2<M, Unit>> fb);
    [ExtensionAttribute]
[PureAttribute]
public static Consumer`3<IN, M, A> ForEach(Pipe`4<IN, OUT, M, A> p0, Func`2<OUT, Consumer`3<IN, M, Unit>> fb);
    [ExtensionAttribute]
[PureAttribute]
public static Pipe`4<IN, OUT, M, R> ForEach(Pipe`4<IN, B, M, R> p0, Func`2<B, Pipe`4<IN, OUT, M, Unit>> fb);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Proxy`6<UOut, UIn, DIn, DOut, M, B> compose(Proxy`6<UOut, UIn, DIn, DOut, M, A> p1, Proxy`6<Unit, A, DIn, DOut, M, B> p2);
    [PureAttribute]
public static Effect`2<M, A> compose(Effect`2<M, OUT> p1, Consumer`3<OUT, M, A> p2);
    [PureAttribute]
public static Consumer`3<A, M, C> compose(Consumer`3<A, M, B> p1, Consumer`3<B, M, C> p2);
    [PureAttribute]
public static Producer`3<OUT, M, C> compose(Producer`3<OUT, M, IN> p1, Pipe`4<IN, OUT, M, C> p2);
    [PureAttribute]
public static Pipe`4<A, Y, M, C> compose(Pipe`4<A, Y, M, B> p1, Pipe`4<B, Y, M, C> p2);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Proxy`6<A1, A, Y1, Y, M, C> compose(Proxy`6<Unit, B, Y1, Y, M, C> p2, Proxy`6<A1, A, Y1, Y, M, B> p1);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Proxy`6<A1, A, Y1, Y, M, C> compose(Func`2<B1, Proxy`6<A1, A, Y1, Y, M, B>> fb1, Proxy`6<B1, B, Y1, Y, M, C> p0);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Proxy`6<A1, A, C1, C, M, R> compose(Proxy`6<A1, A, B1, B, M, R> p, Func`2<B, Proxy`6<B1, B, C1, C, M, R>> fb);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Proxy`6<A1, A, C1, C, M, R> compose(Func`2<B1, Proxy`6<A1, A, B1, B, M, R>> fb1, Proxy`6<B1, B, C1, C, M, R> p);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Proxy`6<A1, A, C1, C, M, R> compose(Proxy`6<A1, A, Unit, B, M, R> p1, Proxy`6<Unit, B, C1, C, M, R> p2);
    [PureAttribute]
public static Effect`2<M, R> compose(Producer`3<B, M, R> p1, Consumer`3<B, M, R> p2);
    [PureAttribute]
public static Producer`3<C, M, R> compose(Producer`3<B, M, R> p1, Pipe`4<B, C, M, R> p2);
    [PureAttribute]
public static Consumer`3<A, M, R> compose(Pipe`4<A, B, M, R> p1, Consumer`3<B, M, R> p2);
    [PureAttribute]
public static Pipe`4<A, C, M, R> compose(Pipe`4<A, B, M, R> p1, Pipe`4<B, C, M, R> p2);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`2<A, Proxy`6<X1, X, C1, C, M, A1>> compose(Func`2<A, Proxy`6<X1, X, B1, B, M, A1>> fa, Func`2<B, Proxy`6<X1, X, C1, C, M, B1>> fb);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Func`2<A, Proxy`6<X1, X, C1, C, M, A1>> Then(Func`2<A, Proxy`6<X1, X, B1, B, M, A1>> fa, Func`2<B, Proxy`6<X1, X, C1, C, M, B1>> fb);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Proxy`6<X1, X, C1, C, M, A1> compose(Proxy`6<X1, X, B1, B, M, A1> p0, Func`2<B, Proxy`6<X1, X, C1, C, M, B1>> fb);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Proxy`6<X1, X, C1, C, M, A1> Then(Proxy`6<X1, X, B1, B, M, A1> p0, Func`2<B, Proxy`6<X1, X, C1, C, M, B1>> fb);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`2<C1, Proxy`6<A1, A, Y1, Y, M, C>> compose(Func`2<B1, Proxy`6<A1, A, Y1, Y, M, B>> fb1, Func`2<C1, Proxy`6<B1, B, Y1, Y, M, C>> fc1);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Proxy`6<A1, A, B1, B, M, R> observe(Proxy`6<A1, A, B1, B, M, R> p0);
    [PureAttribute]
public static A closed(Void value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Proxy`6<A1, A, B1, B, M, S> apply(Proxy`6<A1, A, B1, B, M, Func`2<R, S>> pf, Proxy`6<A1, A, B1, B, M, R> px);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Proxy`6<A1, A, B1, B, M, S> Apply(Proxy`6<A1, A, B1, B, M, Func`2<R, S>> pf, Proxy`6<A1, A, B1, B, M, R> px);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Proxy`6<A1, A, B1, B, M, S> Action(Proxy`6<A1, A, B1, B, M, R> l, Proxy`6<A1, A, B1, B, M, S> r);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Proxy`6<A1, A, B1, B, M, R> Pure(R value);
    [PureAttribute]
public static K`2<M, ValueTuple`2<A, B>> collect(Effect`2<M, A> ma, Effect`2<M, B> mb);
    [PureAttribute]
public static K`2<M, ValueTuple`3<A, B, C>> collect(Effect`2<M, A> ma, Effect`2<M, B> mb, Effect`2<M, C> mc);
    [PureAttribute]
public static Producer`3<ValueTuple`2<A, B>, M, Unit> yield(Effect`2<M, A> ma, Effect`2<M, B> mb);
    [PureAttribute]
public static Producer`3<ValueTuple`3<A, B, C>, M, Unit> yield(Effect`2<M, A> ma, Effect`2<M, B> mb, Effect`2<M, C> mc);
    public static Pipe`3<A, A, Unit> filter(Func`2<A, bool> f);
    public static Pipe`3<A, B, Unit> map(Func`2<A, B> f);
    [PureAttribute]
public static Pipe`3<IN, OUT, Unit> foldWhile(OUT Initial, Func`3<OUT, IN, OUT> Fold, Func`2<OUT, bool> State);
    public static Pipe`3<IN, OUT, Unit> foldUntil(OUT Initial, Func`3<OUT, IN, OUT> Fold, Func`2<OUT, bool> State);
    [PureAttribute]
public static Pipe`3<IN, OUT, Unit> foldWhile(OUT Initial, Func`3<OUT, IN, OUT> Fold, Func`2<IN, bool> Value);
    public static Pipe`3<IN, OUT, Unit> foldUntil(OUT Initial, Func`3<OUT, IN, OUT> Fold, Func`2<IN, bool> Value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Pipes.Proxy`5 : object {
    private static override K`2<Proxy`5<UOut, UIn, DIn, DOut, M>, B> LanguageExt.Traits.Monad<LanguageExt.Pipes.Proxy<UOut,UIn,DIn,DOut,M>>.Bind(K`2<Proxy`5<UOut, UIn, DIn, DOut, M>, A> ma, Func`2<A, K`2<Proxy`5<UOut, UIn, DIn, DOut, M>, B>> f);
    private static override K`2<Proxy`5<UOut, UIn, DIn, DOut, M>, B> LanguageExt.Traits.Functor<LanguageExt.Pipes.Proxy<UOut,UIn,DIn,DOut,M>>.Map(Func`2<A, B> f, K`2<Proxy`5<UOut, UIn, DIn, DOut, M>, A> ma);
    private static override K`2<Proxy`5<UOut, UIn, DIn, DOut, M>, A> LanguageExt.Traits.Applicative<LanguageExt.Pipes.Proxy<UOut,UIn,DIn,DOut,M>>.Pure(A value);
    private static override K`2<Proxy`5<UOut, UIn, DIn, DOut, M>, B> LanguageExt.Traits.Applicative<LanguageExt.Pipes.Proxy<UOut,UIn,DIn,DOut,M>>.Apply(K`2<Proxy`5<UOut, UIn, DIn, DOut, M>, Func`2<A, B>> mf, K`2<Proxy`5<UOut, UIn, DIn, DOut, M>, A> ma);
    private static override K`2<Proxy`5<UOut, UIn, DIn, DOut, M>, A> LanguageExt.Traits.MonadT<LanguageExt.Pipes.Proxy<UOut,UIn,DIn,DOut,M>,M>.Lift(K`2<M, A> ma);
    private static override K`2<Proxy`5<UOut, UIn, DIn, DOut, M>, A> LanguageExt.Traits.MonadIO<LanguageExt.Pipes.Proxy<UOut,UIn,DIn,DOut,M>>.LiftIO(IO`1<A> ma);
    private static override K`2<Proxy`5<UOut, UIn, DIn, DOut, M>, IO`1<A>> LanguageExt.Traits.MonadIO<LanguageExt.Pipes.Proxy<UOut,UIn,DIn,DOut,M>>.ToIO(K`2<Proxy`5<UOut, UIn, DIn, DOut, M>, A> ma);
    private static override K`2<Proxy`5<UOut, UIn, DIn, DOut, M>, A> LanguageExt.Traits.Applicative<LanguageExt.Pipes.Proxy<UOut,UIn,DIn,DOut,M>>.Actions(IEnumerable`1<K`2<Proxy`5<UOut, UIn, DIn, DOut, M>, A>> fas);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.Pipes.Proxy`6 : object {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected Proxy`6(Proxy`6<UOut, UIn, DIn, DOut, M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public abstract virtual Proxy`6<UOut, UIn, DIn, DOut, M, A> ToProxy();
    public abstract virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> Bind(Func`2<A, Proxy`6<UOut, UIn, DIn, DOut, M, B>> f);
    public abstract virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> Map(Func`2<A, B> f);
    public abstract virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> MapM(Func`2<K`2<M, A>, K`2<M, B>> f);
    public abstract virtual Proxy`6<UOut, UIn, DIn, DOut, M, IO`1<A>> ToIO();
    public abstract virtual Proxy`6<UOut, UIn, C1, C, M, A> For(Func`2<DOut, Proxy`6<UOut, UIn, C1, C, M, DIn>> body);
    public abstract virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> Action(Proxy`6<UOut, UIn, DIn, DOut, M, B> r);
    public abstract virtual Proxy`6<UOutA, AUInA, DIn, DOut, M, A> PairEachRequestWithRespond(Func`2<UOut, Proxy`6<UOutA, AUInA, UOut, UIn, M, A>> lhs);
    public abstract virtual Proxy`6<UOutA, AUInA, DIn, DOut, M, A> ReplaceRequest(Func`2<UOut, Proxy`6<UOutA, AUInA, DIn, DOut, M, UIn>> lhs);
    public abstract virtual Proxy`6<UOut, UIn, DInC, DOutC, M, A> PairEachRespondWithRequest(Func`2<DOut, Proxy`6<DIn, DOut, DInC, DOutC, M, A>> rhs);
    public abstract virtual Proxy`6<UOut, UIn, DInC, DOutC, M, A> ReplaceRespond(Func`2<DOut, Proxy`6<UOut, UIn, DInC, DOutC, M, DIn>> rhs);
    public abstract virtual Proxy`6<DOut, DIn, UIn, UOut, M, A> Reflect();
    public abstract virtual Proxy`6<UOut, UIn, DIn, DOut, M, A> Observe();
    [PureAttribute]
public Proxy`6<UOut, UIn, DIn, DOut, M, C> SelectMany(Func`2<A, Proxy`6<UOut, UIn, DIn, DOut, M, B>> f, Func`3<A, B, C> project);
    [PureAttribute]
public Proxy`6<UOut, UIn, DIn, DOut, M, B> Select(Func`2<A, B> f);
    [PureAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Proxy`6<UOut, UIn, DIn, DOut, M, A> left, Proxy`6<UOut, UIn, DIn, DOut, M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Proxy`6<UOut, UIn, DIn, DOut, M, A> left, Proxy`6<UOut, UIn, DIn, DOut, M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Proxy`6<UOut, UIn, DIn, DOut, M, A> other);
    [CompilerGeneratedAttribute]
public abstract virtual Proxy`6<UOut, UIn, DIn, DOut, M, A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class LanguageExt.Pipes.ProxyM`6 : Proxy`6<UOut, UIn, DIn, DOut, M, A> {
    [CompilerGeneratedAttribute]
private K`2<M, Proxy`6<UOut, UIn, DIn, DOut, M, A>> <Value>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public K`2<M, Proxy`6<UOut, UIn, DIn, DOut, M, A>> Value { get; public set; }
    public ProxyM`6(K`2<M, Proxy`6<UOut, UIn, DIn, DOut, M, A>> Value);
    [CompilerGeneratedAttribute]
protected ProxyM`6(ProxyM`6<UOut, UIn, DIn, DOut, M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public K`2<M, Proxy`6<UOut, UIn, DIn, DOut, M, A>> get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(K`2<M, Proxy`6<UOut, UIn, DIn, DOut, M, A>> value);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, A> ToProxy();
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> Bind(Func`2<A, Proxy`6<UOut, UIn, DIn, DOut, M, B>> f);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> Map(Func`2<A, B> f);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> MapM(Func`2<K`2<M, A>, K`2<M, B>> f);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, IO`1<A>> ToIO();
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, C1, C, M, A> For(Func`2<DOut, Proxy`6<UOut, UIn, C1, C, M, DIn>> body);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, S> Action(Proxy`6<UOut, UIn, DIn, DOut, M, S> r);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, DIn, DOut, M, A> PairEachRequestWithRespond(Func`2<UOut, Proxy`6<UOutA, AUInA, UOut, UIn, M, A>> fb1);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, DIn, DOut, M, A> ReplaceRequest(Func`2<UOut, Proxy`6<UOutA, AUInA, DIn, DOut, M, UIn>> lhs);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DInC, DOutC, M, A> PairEachRespondWithRequest(Func`2<DOut, Proxy`6<DIn, DOut, DInC, DOutC, M, A>> rhs);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DInC, DOutC, M, A> ReplaceRespond(Func`2<DOut, Proxy`6<UOut, UIn, DInC, DOutC, M, DIn>> rhs);
    [PureAttribute]
public virtual Proxy`6<DOut, DIn, UIn, UOut, M, A> Reflect();
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, A> Observe();
    [PureAttribute]
public void Deconstruct(K`2& value);
    [PureAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ProxyM`6<UOut, UIn, DIn, DOut, M, A> left, ProxyM`6<UOut, UIn, DIn, DOut, M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ProxyM`6<UOut, UIn, DIn, DOut, M, A> left, ProxyM`6<UOut, UIn, DIn, DOut, M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Proxy`6<UOut, UIn, DIn, DOut, M, A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(ProxyM`6<UOut, UIn, DIn, DOut, M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override ProxyM`6<UOut, UIn, DIn, DOut, M, A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pipes.Pure`6 : Proxy`6<UOut, UIn, DIn, DOut, M, A> {
    [CompilerGeneratedAttribute]
private A <Value>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public A Value { get; public set; }
    public Pure`6(A Value);
    [CompilerGeneratedAttribute]
protected Pure`6(Pure`6<UOut, UIn, DIn, DOut, M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public A get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(A value);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, A> ToProxy();
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> Bind(Func`2<A, Proxy`6<UOut, UIn, DIn, DOut, M, B>> f);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> Map(Func`2<A, B> f);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> MapM(Func`2<K`2<M, A>, K`2<M, B>> f);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, IO`1<A>> ToIO();
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, C1, C, M, A> For(Func`2<DOut, Proxy`6<UOut, UIn, C1, C, M, DIn>> body);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> Action(Proxy`6<UOut, UIn, DIn, DOut, M, B> r);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, DIn, DOut, M, A> PairEachRequestWithRespond(Func`2<UOut, Proxy`6<UOutA, AUInA, UOut, UIn, M, A>> _);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, DIn, DOut, M, A> ReplaceRequest(Func`2<UOut, Proxy`6<UOutA, AUInA, DIn, DOut, M, UIn>> _);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DInC, DOutC, M, A> PairEachRespondWithRequest(Func`2<DOut, Proxy`6<DIn, DOut, DInC, DOutC, M, A>> _);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DInC, DOutC, M, A> ReplaceRespond(Func`2<DOut, Proxy`6<UOut, UIn, DInC, DOutC, M, DIn>> _);
    [PureAttribute]
public virtual Proxy`6<DOut, DIn, UIn, UOut, M, A> Reflect();
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, A> Observe();
    [PureAttribute]
public void Deconstruct(A& value);
    [PureAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Pure`6<UOut, UIn, DIn, DOut, M, A> left, Pure`6<UOut, UIn, DIn, DOut, M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Pure`6<UOut, UIn, DIn, DOut, M, A> left, Pure`6<UOut, UIn, DIn, DOut, M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Proxy`6<UOut, UIn, DIn, DOut, M, A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Pure`6<UOut, UIn, DIn, DOut, M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override Pure`6<UOut, UIn, DIn, DOut, M, A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.Pipes.PureProxy : object {
    [NullableContextAttribute("2")]
public static Pipe`3<IN, OUT, A> PipePure(A value);
    public static Producer`2<OUT, A> ProducerPure(A value);
    public static Consumer`2<IN, A> ConsumerPure(A value);
    [NullableContextAttribute("2")]
public static Pipe`3<IN, OUT, A> PipeFail(Error value);
    public static Producer`2<OUT, A> ProducerFail(Error value);
    public static Consumer`2<IN, A> ConsumerFail(Error value);
    [NullableContextAttribute("2")]
public static Pipe`3<IN, OUT, A> PipeLift(Func`1<A> t);
    public static Producer`2<OUT, A> ProducerLift(Func`1<A> t);
    public static Consumer`2<IN, A> ConsumerLift(Func`1<A> t);
    [NullableContextAttribute("2")]
public static Pipe`3<IN, OUT, A> PipeLiftIO(IO`1<A> ma);
    public static Producer`2<OUT, A> ProducerLiftIO(IO`1<A> ma);
    public static Consumer`2<IN, A> ConsumerLiftIO(IO`1<A> ma);
    public static Pipe`3<IN, OUT, Unit> PipeFold(K`2<F, OUT> items);
    public static Producer`2<OUT, Unit> ProducerFold(K`2<F, OUT> items);
    public static Consumer`2<IN, Unit> ConsumerFold(K`2<F, A> items);
    public static Consumer`2<IN, IN> ConsumerAwait();
    [NullableContextAttribute("2")]
public static Pipe`3<IN, OUT, IN> PipeAwait();
    public static Producer`2<OUT, Unit> ProducerYield(OUT value);
    public static Pipe`3<IN, OUT, Unit> PipeYield(OUT value);
    [ExtensionAttribute]
public static Consumer`3<IN, M, C> SelectMany(K`2<M, A> ma, Func`2<A, Consumer`2<IN, B>> f, Func`3<A, B, C> project);
    [ExtensionAttribute]
public static Producer`3<OUT, M, C> SelectMany(K`2<M, A> ma, Func`2<A, Producer`2<OUT, B>> f, Func`3<A, B, C> project);
    [ExtensionAttribute]
public static Pipe`4<IN, OUT, M, C> SelectMany(K`2<M, A> ma, Func`2<A, Pipe`3<IN, OUT, B>> f, Func`3<A, B, C> project);
    [ExtensionAttribute]
public static Consumer`3<IN, M, C> SelectMany(K`2<M, A> ma, Func`2<A, Consumer`3<IN, M, B>> f, Func`3<A, B, C> project);
    [ExtensionAttribute]
public static Producer`3<OUT, M, C> SelectMany(K`2<M, A> ma, Func`2<A, Producer`3<OUT, M, B>> f, Func`3<A, B, C> project);
    [ExtensionAttribute]
public static Pipe`4<IN, OUT, M, C> SelectMany(K`2<M, A> ma, Func`2<A, Pipe`4<IN, OUT, M, B>> f, Func`3<A, B, C> project);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pipes.Queue`3 : Producer`3<OUT, M, A> {
    private Channel`1<OUT> channel;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public K`2<M, Unit> DoneM { get; }
    internal Queue`3(Proxy`6<Void, Unit, Unit, OUT, M, A> value, Channel`1<OUT> channel);
    [CompilerGeneratedAttribute]
protected Queue`3(Queue`3<OUT, M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public Unit Enqueue(OUT value);
    public K`2<M, Unit> EnqueueM(OUT value);
    public Unit Done();
    public K`2<M, Unit> get_DoneM();
    [PureAttribute]
public virtual Proxy`6<Void, Unit, Unit, OUT, M, A> ToProxy();
    [PureAttribute]
public virtual Proxy`6<Void, Unit, Unit, OUT, M, S> Bind(Func`2<A, Proxy`6<Void, Unit, Unit, OUT, M, S>> f);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, Unit, OUT, M, B> Map(Func`2<A, B> f);
    [PureAttribute]
public Producer`3<OUT, M, B> Select(Func`2<A, B> f);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, C1, C, M, A> For(Func`2<OUT, Proxy`6<Void, Unit, C1, C, M, Unit>> body);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, Unit, OUT, M, B> Action(Proxy`6<Void, Unit, Unit, OUT, M, B> r);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, Unit, OUT, M, A> PairEachRequestWithRespond(Func`2<Void, Proxy`6<UOutA, AUInA, Void, Unit, M, A>> lhs);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, Unit, OUT, M, A> ReplaceRequest(Func`2<Void, Proxy`6<UOutA, AUInA, Unit, OUT, M, Unit>> lhs);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, DInC, DOutC, M, A> PairEachRespondWithRequest(Func`2<OUT, Proxy`6<Unit, OUT, DInC, DOutC, M, A>> rhs);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, DInC, DOutC, M, A> ReplaceRespond(Func`2<OUT, Proxy`6<Void, Unit, DInC, DOutC, M, Unit>> rhs);
    [PureAttribute]
public virtual Proxy`6<OUT, Unit, Unit, Void, M, A> Reflect();
    [PureAttribute]
public virtual Proxy`6<Void, Unit, Unit, OUT, M, A> Observe();
    [PureAttribute]
public static Effect`2<M, A> op_BitwiseOr(Queue`3<OUT, M, A> p1, Consumer`3<OUT, M, A> p2);
    [PureAttribute]
public static Effect`2<M, A> op_BitwiseOr(Queue`3<OUT, M, A> p1, Consumer`2<OUT, A> p2);
    [PureAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Queue`3<OUT, M, A> left, Queue`3<OUT, M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Queue`3<OUT, M, A> left, Queue`3<OUT, M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Producer`3<OUT, M, A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Queue`3<OUT, M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override Queue`3<OUT, M, A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pipes.Request`6 : Proxy`6<UOut, UIn, DIn, DOut, M, A> {
    [CompilerGeneratedAttribute]
private UOut <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<UIn, Proxy`6<UOut, UIn, DIn, DOut, M, A>> <Next>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public UOut Value { get; public set; }
    public Func`2<UIn, Proxy`6<UOut, UIn, DIn, DOut, M, A>> Next { get; public set; }
    public Request`6(UOut Value, Func`2<UIn, Proxy`6<UOut, UIn, DIn, DOut, M, A>> Next);
    [CompilerGeneratedAttribute]
protected Request`6(Request`6<UOut, UIn, DIn, DOut, M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public UOut get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(UOut value);
    [CompilerGeneratedAttribute]
public Func`2<UIn, Proxy`6<UOut, UIn, DIn, DOut, M, A>> get_Next();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Next(Func`2<UIn, Proxy`6<UOut, UIn, DIn, DOut, M, A>> value);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, A> ToProxy();
    [PureAttribute]
public void Deconstruct(UOut& value, Func`2& fun);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, C1, C, M, A> For(Func`2<DOut, Proxy`6<UOut, UIn, C1, C, M, DIn>> body);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, S> Action(Proxy`6<UOut, UIn, DIn, DOut, M, S> r);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, DIn, DOut, M, A> ReplaceRequest(Func`2<UOut, Proxy`6<UOutA, AUInA, DIn, DOut, M, UIn>> lhs);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DInC, DOutC, M, A> ReplaceRespond(Func`2<DOut, Proxy`6<UOut, UIn, DInC, DOutC, M, DIn>> rhs);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, DIn, DOut, M, A> PairEachRequestWithRespond(Func`2<UOut, Proxy`6<UOutA, AUInA, UOut, UIn, M, A>> lhs);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DInC, DOutC, M, A> PairEachRespondWithRequest(Func`2<DOut, Proxy`6<DIn, DOut, DInC, DOutC, M, A>> rhs);
    [PureAttribute]
public virtual Proxy`6<DOut, DIn, UIn, UOut, M, A> Reflect();
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, A> Observe();
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> Bind(Func`2<A, Proxy`6<UOut, UIn, DIn, DOut, M, B>> f);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> Map(Func`2<A, B> f);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> MapM(Func`2<K`2<M, A>, K`2<M, B>> f);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, IO`1<A>> ToIO();
    [PureAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Request`6<UOut, UIn, DIn, DOut, M, A> left, Request`6<UOut, UIn, DIn, DOut, M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Request`6<UOut, UIn, DIn, DOut, M, A> left, Request`6<UOut, UIn, DIn, DOut, M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Proxy`6<UOut, UIn, DIn, DOut, M, A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Request`6<UOut, UIn, DIn, DOut, M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override Request`6<UOut, UIn, DIn, DOut, M, A> <Clone>$();
    [CompilerGeneratedAttribute]
private Proxy`6<DOut, DIn, UIn, UOut, M, A> <Reflect>b__19_0(UIn x);
    [CompilerGeneratedAttribute]
private Proxy`6<UOut, UIn, DIn, DOut, M, A> <Observe>b__20_0(UIn x);
    [CompilerGeneratedAttribute]
private Proxy`6<UOut, UIn, DIn, DOut, M, IO`1<A>> <ToIO>b__24_0(UIn a);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pipes.Respond`6 : Proxy`6<UOut, UIn, DIn, DOut, M, A> {
    [CompilerGeneratedAttribute]
private DOut <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<DIn, Proxy`6<UOut, UIn, DIn, DOut, M, A>> <Next>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public DOut Value { get; public set; }
    public Func`2<DIn, Proxy`6<UOut, UIn, DIn, DOut, M, A>> Next { get; public set; }
    public Respond`6(DOut Value, Func`2<DIn, Proxy`6<UOut, UIn, DIn, DOut, M, A>> Next);
    [CompilerGeneratedAttribute]
protected Respond`6(Respond`6<UOut, UIn, DIn, DOut, M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public DOut get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(DOut value);
    [CompilerGeneratedAttribute]
public Func`2<DIn, Proxy`6<UOut, UIn, DIn, DOut, M, A>> get_Next();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Next(Func`2<DIn, Proxy`6<UOut, UIn, DIn, DOut, M, A>> value);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, A> ToProxy();
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> Bind(Func`2<A, Proxy`6<UOut, UIn, DIn, DOut, M, B>> f);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> Map(Func`2<A, B> f);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, B> MapM(Func`2<K`2<M, A>, K`2<M, B>> f);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, IO`1<A>> ToIO();
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, C1, C, M, A> For(Func`2<DOut, Proxy`6<UOut, UIn, C1, C, M, DIn>> body);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, S> Action(Proxy`6<UOut, UIn, DIn, DOut, M, S> r);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, DIn, DOut, M, A> ReplaceRequest(Func`2<UOut, Proxy`6<UOutA, AUInA, DIn, DOut, M, UIn>> lhs);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DInC, DOutC, M, A> ReplaceRespond(Func`2<DOut, Proxy`6<UOut, UIn, DInC, DOutC, M, DIn>> rhs);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, DIn, DOut, M, A> PairEachRequestWithRespond(Func`2<UOut, Proxy`6<UOutA, AUInA, UOut, UIn, M, A>> fb1);
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DInC, DOutC, M, A> PairEachRespondWithRequest(Func`2<DOut, Proxy`6<DIn, DOut, DInC, DOutC, M, A>> rhs);
    [PureAttribute]
public virtual Proxy`6<DOut, DIn, UIn, UOut, M, A> Reflect();
    [PureAttribute]
public virtual Proxy`6<UOut, UIn, DIn, DOut, M, A> Observe();
    [PureAttribute]
public void Deconstruct(DOut& value, Func`2& fun);
    [PureAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Respond`6<UOut, UIn, DIn, DOut, M, A> left, Respond`6<UOut, UIn, DIn, DOut, M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Respond`6<UOut, UIn, DIn, DOut, M, A> left, Respond`6<UOut, UIn, DIn, DOut, M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Proxy`6<UOut, UIn, DIn, DOut, M, A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Respond`6<UOut, UIn, DIn, DOut, M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override Respond`6<UOut, UIn, DIn, DOut, M, A> <Clone>$();
    [CompilerGeneratedAttribute]
private Proxy`6<UOut, UIn, DIn, DOut, M, IO`1<A>> <ToIO>b__15_0(DIn a);
    [CompilerGeneratedAttribute]
private Proxy`6<DOut, DIn, UIn, UOut, M, A> <Reflect>b__22_0(DIn x);
    [CompilerGeneratedAttribute]
private Proxy`6<UOut, UIn, DIn, DOut, M, A> <Observe>b__23_0(DIn x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Pipes.Server : object {
    [PureAttribute]
public static Server`4<REQ, RES, M, R> Pure(R value);
    [PureAttribute]
public static Server`4<REQ, RES, M, REQ> respond(RES value);
    [PureAttribute]
public static Server`4<REQ, RES, M, R> lift(K`2<M, R> ma);
    [PureAttribute]
public static Server`4<REQ, RES, M, R> liftIO(IO`1<R> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pipes.Server`4 : Proxy`6<Void, Unit, REQ, RES, M, A> {
    public Proxy`6<Void, Unit, REQ, RES, M, A> Value;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Server`4(Proxy`6<Void, Unit, REQ, RES, M, A> value);
    [CompilerGeneratedAttribute]
protected Server`4(Server`4<REQ, RES, M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [PureAttribute]
public virtual Proxy`6<Void, Unit, REQ, RES, M, A> ToProxy();
    [PureAttribute]
public virtual Proxy`6<Void, Unit, REQ, RES, M, B> Bind(Func`2<A, Proxy`6<Void, Unit, REQ, RES, M, B>> f);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, REQ, RES, M, B> Map(Func`2<A, B> f);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, REQ, RES, M, B> MapM(Func`2<K`2<M, A>, K`2<M, B>> f);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, REQ, RES, M, IO`1<A>> ToIO();
    [PureAttribute]
public Server`4<REQ, RES, M, B> Bind(Func`2<A, Server`4<REQ, RES, M, B>> f);
    [PureAttribute]
public Server`4<REQ, RES, M, B> SelectMany(Func`2<A, Server`4<REQ, RES, M, B>> f);
    [PureAttribute]
public Server`4<REQ, RES, M, C> SelectMany(Func`2<A, Server`4<REQ, RES, M, B>> f, Func`3<A, B, C> project);
    [PureAttribute]
public Server`4<REQ, RES, M, B> Select(Func`2<A, B> f);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, C1, C, M, A> For(Func`2<RES, Proxy`6<Void, Unit, C1, C, M, REQ>> body);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, REQ, RES, M, S> Action(Proxy`6<Void, Unit, REQ, RES, M, S> r);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, REQ, RES, M, A> PairEachRequestWithRespond(Func`2<Void, Proxy`6<UOutA, AUInA, Void, Unit, M, A>> lhs);
    [PureAttribute]
public virtual Proxy`6<UOutA, AUInA, REQ, RES, M, A> ReplaceRequest(Func`2<Void, Proxy`6<UOutA, AUInA, REQ, RES, M, Unit>> lhs);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, DInC, DOutC, M, A> PairEachRespondWithRequest(Func`2<RES, Proxy`6<REQ, RES, DInC, DOutC, M, A>> rhs);
    [PureAttribute]
public virtual Proxy`6<Void, Unit, DInC, DOutC, M, A> ReplaceRespond(Func`2<RES, Proxy`6<Void, Unit, DInC, DOutC, M, REQ>> rhs);
    [PureAttribute]
public virtual Proxy`6<RES, REQ, Unit, Void, M, A> Reflect();
    [PureAttribute]
public virtual Proxy`6<Void, Unit, REQ, RES, M, A> Observe();
    [PureAttribute]
public void Deconstruct(Proxy`6& value);
    [PureAttribute]
public static Server`4<REQ, RES, M, A> op_BitwiseAnd(Server`4<REQ, RES, M, A> lhs, Server`4<REQ, RES, M, A> rhs);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Server`4<REQ, RES, M, A> left, Server`4<REQ, RES, M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Server`4<REQ, RES, M, A> left, Server`4<REQ, RES, M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Proxy`6<Void, Unit, REQ, RES, M, A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Server`4<REQ, RES, M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override Server`4<REQ, RES, M, A> <Clone>$();
}
public class LanguageExt.Pipes.Void : object {
    [NullableContextAttribute("1")]
[PureAttribute]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class LanguageExt.Pool`2 : object {
    private static ConcurrentStack`1<A> stack;
    private static Pool`2();
    public static A Pop();
    public static void Push(A value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class LanguageExt.Pool`3 : object {
    private static ConcurrentStack`1<A> stack;
    private static Pool`3();
    public static A Pop(B value);
    public static void Push(A value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.Prelude : object {
    public static Eff`1<Unit> unitEff;
    public static IO`1<CancellationToken> cancelToken;
    public static IO`1<Unit> cancelIO;
    public static IO`1<Unit> unitIO;
    public static IO`1<EnvIO> envIO;
    public static SeqEmpty Empty;
    private static RandomNumberGenerator rnd;
    private static int wordTop;
    public static Unit unit { get; }
    [PureAttribute]
internal static Eff`1<MinRT> runtimeMinRT { get; }
    public static Eff`1<CancellationToken> cancelTokenEff { get; }
    [PureAttribute]
public static Iterable`1<int> Naturals { get; }
    [PureAttribute]
public static Iterable`1<long> LongNaturals { get; }
    [NullableAttribute("0")]
[PureAttribute]
public static Fail`1<Unit> None { get; }
    private static Prelude();
    public static Ref`1<A> Ref(A value, Func`2<A, bool> validator);
    public static R atomic(Func`1<R> op, Isolation isolation);
    public static Unit atomic(Action op, Isolation isolation);
    public static R snapshot(Func`1<R> op);
    public static Unit snapshot(Action op);
    public static R serial(Func`1<R> op);
    public static Unit serial(Action op);
    public static A swap(Ref`1<A> r, Func`2<A, A> f);
    public static A commute(Ref`1<A> r, Func`2<A, A> f);
    public static Atom`1<A> Atom(A value);
    public static Option`1<Atom`1<A>> Atom(A value, Func`2<A, bool> validator);
    public static Atom`2<M, A> Atom(M metadata, A value);
    public static Option`1<Atom`2<M, A>> Atom(M metadata, A value, Func`2<A, bool> validator);
    public static A swap(Atom`1<A> ma, Func`2<A, A> f);
    public static A swap(Atom`1<A> ma, Func`2<A, Option`1<A>> f);
    public static A swap(Atom`2<M, A> ma, Func`3<M, A, A> f);
    public static A swap(Atom`2<M, A> ma, Func`3<M, A, Option`1<A>> f);
    [PureAttribute]
public static Task`1<A> TaskSucc(A self);
    [PureAttribute]
public static Task`1<A> TaskFail(Exception ex);
    [PureAttribute]
public static Task`1<A> flatten(Task`1<Task`1<A>> self);
    [PureAttribute]
public static Task`1<A> flatten(Task`1<Task`1<Task`1<A>>> self);
    [PureAttribute]
public static Task`1<int> count(Task`1<A> self);
    [PureAttribute]
public static Task`1<B> bind(Task`1<A> self, Func`2<A, Task`1<B>> bind);
    [PureAttribute]
public static Task`1<bool> exists(Task`1<A> self, Func`2<A, bool> pred);
    [PureAttribute]
public static Task`1<bool> existsAsync(Task`1<A> self, Func`2<A, Task`1<bool>> pred);
    [PureAttribute]
public static Task`1<bool> forall(Task`1<A> self, Func`2<A, bool> pred);
    [PureAttribute]
public static Task`1<bool> forallAsync(Task`1<A> self, Func`2<A, Task`1<bool>> pred);
    [PureAttribute]
public static Task`1<A> filter(Task`1<A> self, Func`2<A, bool> pred);
    public static Task`1<Unit> iter(Task`1<A> self, Action`1<A> f);
    [PureAttribute]
public static Task`1<B> map(Task`1<A> self, Func`2<A, B> map);
    [PureAttribute]
public static Task`1<B> mapAsync(Task`1<A> self, Func`2<A, Task`1<B>> map);
    [ExtensionAttribute]
[PureAttribute]
public static Task`1<A> plus(Task`1<A> ma, Task`1<A> mb);
    [ExtensionAttribute]
[PureAttribute]
public static Task`1<A> plusFirst(Task`1<A> ma, Task`1<A> mb);
    [PureAttribute]
public static Task`1<A> choice(Task`1<A> ma, Task`1[] tail);
    [AsyncStateMachineAttribute("LanguageExt.Prelude/<choice>d__34`1")]
[PureAttribute]
public static Task`1<A> choice(Seq`1<Task`1<A>> xs);
    [AsyncStateMachineAttribute("LanguageExt.Prelude/<apply>d__35`2")]
[PureAttribute]
public static Task`1<B> apply(Task`1<Func`2<A, B>> fab, Task`1<A> fa);
    [PureAttribute]
public static Task`1<B> apply(Func`2<A, B> fab, Task`1<A> fa);
    [AsyncStateMachineAttribute("LanguageExt.Prelude/<apply>d__37`3")]
[PureAttribute]
public static Task`1<C> apply(Task`1<Func`3<A, B, C>> fabc, Task`1<A> fa, Task`1<B> fb);
    [AsyncStateMachineAttribute("LanguageExt.Prelude/<apply>d__38`3")]
[PureAttribute]
public static Task`1<C> apply(Func`3<A, B, C> fabc, Task`1<A> fa, Task`1<B> fb);
    [AsyncStateMachineAttribute("LanguageExt.Prelude/<apply>d__39`3")]
[PureAttribute]
public static Task`1<Func`2<B, C>> apply(Task`1<Func`3<A, B, C>> fabc, Task`1<A> fa);
    [PureAttribute]
public static Task`1<Func`2<B, C>> apply(Func`3<A, B, C> fabc, Task`1<A> fa);
    [AsyncStateMachineAttribute("LanguageExt.Prelude/<apply>d__41`3")]
[PureAttribute]
public static Task`1<Func`2<B, C>> apply(Task`1<Func`2<A, Func`2<B, C>>> fabc, Task`1<A> fa);
    [PureAttribute]
public static Task`1<Func`2<B, C>> apply(Func`2<A, Func`2<B, C>> fabc, Task`1<A> fa);
    [PureAttribute]
public static ValueTask`1<A> ValueTaskSucc(A self);
    [PureAttribute]
public static ValueTask`1<A> ValueTaskFail(Exception ex);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTask`1<A> flatten(ValueTask`1<ValueTask`1<A>> self);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTask`1<A> flatten(ValueTask`1<ValueTask`1<ValueTask`1<A>>> self);
    [NullableContextAttribute("0")]
[PureAttribute]
public static ValueTask`1<int> count(ValueTask`1<A> self);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTask`1<B> bind(ValueTask`1<A> self, Func`2<A, ValueTask`1<B>> bind);
    [NullableContextAttribute("0")]
[PureAttribute]
public static ValueTask`1<bool> exists(ValueTask`1<A> self, Func`2<A, bool> pred);
    [NullableContextAttribute("0")]
[PureAttribute]
public static ValueTask`1<bool> existsAsync(ValueTask`1<A> self, Func`2<A, ValueTask`1<bool>> pred);
    [NullableContextAttribute("0")]
[PureAttribute]
public static ValueTask`1<bool> forall(ValueTask`1<A> self, Func`2<A, bool> pred);
    [NullableContextAttribute("0")]
[PureAttribute]
public static ValueTask`1<bool> forallAsync(ValueTask`1<A> self, Func`2<A, ValueTask`1<bool>> pred);
    [PureAttribute]
public static ValueTask`1<A> filter(ValueTask`1<A> self, Func`2<A, bool> pred);
    [NullableContextAttribute("0")]
public static ValueTask`1<Unit> iter(ValueTask`1<A> self, Action`1<A> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTask`1<B> map(ValueTask`1<A> self, Func`2<A, B> map);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTask`1<B> mapAsync(ValueTask`1<A> self, Func`2<A, ValueTask`1<B>> map);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<A> plus(ValueTask`1<A> ma, ValueTask`1<A> mb);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<A> plusFirst(ValueTask`1<A> ma, ValueTask`1<A> mb);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTask`1<A> choice(ValueTask`1<A> ma, ValueTask`1[] tail);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("LanguageExt.Prelude/<choice>d__60`1")]
[PureAttribute]
public static ValueTask`1<A> choice(Seq`1<ValueTask`1<A>> xs);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("LanguageExt.Prelude/<apply>d__61`2")]
[PureAttribute]
public static ValueTask`1<B> apply(ValueTask`1<Func`2<A, B>> fab, ValueTask`1<A> fa);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTask`1<B> apply(Func`2<A, B> fab, ValueTask`1<A> fa);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("LanguageExt.Prelude/<apply>d__63`3")]
[PureAttribute]
public static ValueTask`1<C> apply(ValueTask`1<Func`3<A, B, C>> fabc, ValueTask`1<A> fa, ValueTask`1<B> fb);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("LanguageExt.Prelude/<apply>d__64`3")]
[PureAttribute]
public static ValueTask`1<C> apply(Func`3<A, B, C> fabc, ValueTask`1<A> fa, ValueTask`1<B> fb);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("LanguageExt.Prelude/<apply>d__65`3")]
[PureAttribute]
public static ValueTask`1<Func`2<B, C>> apply(ValueTask`1<Func`3<A, B, C>> fabc, ValueTask`1<A> fa);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTask`1<Func`2<B, C>> apply(Func`3<A, B, C> fabc, ValueTask`1<A> fa);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("LanguageExt.Prelude/<apply>d__67`3")]
[PureAttribute]
public static ValueTask`1<Func`2<B, C>> apply(ValueTask`1<Func`2<A, Func`2<B, C>>> fabc, ValueTask`1<A> fa);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTask`1<Func`2<B, C>> apply(Func`2<A, Func`2<B, C>> fabc, ValueTask`1<A> fa);
    public static Unit get_unit();
    public static Unit ignore(A anything);
    [ExtensionAttribute]
public static Unit Ignore(A anything);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`2<A, B> add(ValueTuple`1<A> self, B second);
    [PureAttribute]
public static bool contains(ValueTuple`1<A> self, A value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`1<R> map(ValueTuple`1<A> self, Func`2<A, R> map);
    public static Unit iter(ValueTuple`1<A> self, Action`1<A> func);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`3<T1, T2, T3> ad(ValueTuple`2<T1, T2> self, T3 third);
    [NullableContextAttribute("2")]
[PureAttribute]
public static T1 head(ValueTuple`2<T1, T2> self);
    [NullableContextAttribute("2")]
[PureAttribute]
public static T2 last(ValueTuple`2<T1, T2> self);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`1<T2> tail(ValueTuple`2<T1, T2> self);
    [ExtensionAttribute]
[PureAttribute]
public static A sum(ValueTuple`2<A, A> self);
    [ExtensionAttribute]
[PureAttribute]
public static A product(ValueTuple`2<A, A> self);
    [ExtensionAttribute]
[PureAttribute]
public static bool contains(ValueTuple`2<A, A> self, A value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static R map(ValueTuple`2<A, B> self, Func`2<ValueTuple`2<A, B>, R> map);
    [NullableContextAttribute("2")]
[PureAttribute]
public static R map(ValueTuple`2<A, B> self, Func`3<A, B, R> map);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`2<R1, R2> bimap(ValueTuple`2<T1, T2> self, Func`2<T1, R1> firstMap, Func`2<T2, R2> secondMap);
    public static Unit iter(ValueTuple`2<T1, T2> self, Action`1<T1> first, Action`1<T2> second);
    [NullableContextAttribute("2")]
public static Unit iter(ValueTuple`2<T1, T2> self, Action`2<T1, T2> func);
    [PureAttribute]
public static S fold(ValueTuple`2<T1, T2> self, S state, Func`4<S, T1, T2, S> fold);
    [PureAttribute]
public static S bifold(ValueTuple`2<T1, T2> self, S state, Func`3<S, T1, S> firstFold, Func`3<S, T2, S> secondFold);
    [PureAttribute]
public static S bifoldBack(ValueTuple`2<T1, T2> self, S state, Func`3<S, T2, S> firstFold, Func`3<S, T1, S> secondFold);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`4<T1, T2, T3, T4> add(ValueTuple`3<T1, T2, T3> self, T4 fourth);
    [NullableContextAttribute("2")]
[PureAttribute]
public static T1 head(ValueTuple`3<T1, T2, T3> self);
    [NullableContextAttribute("2")]
[PureAttribute]
public static T3 last(ValueTuple`3<T1, T2, T3> self);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`2<T2, T3> tail(ValueTuple`3<T1, T2, T3> self);
    [PureAttribute]
public static A sum(ValueTuple`3<A, A, A> self);
    [PureAttribute]
public static A product(ValueTuple`3<A, A, A> self);
    [PureAttribute]
public static bool contains(ValueTuple`3<A, A, A> self, A value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static R map(ValueTuple`3<A, B, C> self, Func`2<ValueTuple`3<A, B, C>, R> map);
    [NullableContextAttribute("2")]
[PureAttribute]
public static R map(ValueTuple`3<A, B, C> self, Func`4<A, B, C, R> map);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`3<R1, R2, R3> trimap(ValueTuple`3<T1, T2, T3> self, Func`2<T1, R1> firstMap, Func`2<T2, R2> secondMap, Func`2<T3, R3> thirdMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`3<R1, T2, T3> mapFirst(ValueTuple`3<T1, T2, T3> self, Func`2<T1, R1> firstMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`3<T1, R2, T3> mapSecond(ValueTuple`3<T1, T2, T3> self, Func`2<T2, R2> secondMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`3<T1, T2, R3> mapThird(ValueTuple`3<T1, T2, T3> self, Func`2<T3, R3> thirdMap);
    [NullableContextAttribute("2")]
public static Unit iter(ValueTuple`3<T1, T2, T3> self, Action`3<T1, T2, T3> func);
    public static Unit iter(ValueTuple`3<T1, T2, T3> self, Action`1<T1> first, Action`1<T2> second, Action`1<T3> third);
    [NullableContextAttribute("2")]
[PureAttribute]
public static S fold(ValueTuple`3<T1, T2, T3> self, S state, Func`5<S, T1, T2, T3, S> fold);
    [PureAttribute]
public static S trifold(ValueTuple`3<T1, T2, T3> self, S state, Func`3<S, T1, S> firstFold, Func`3<S, T2, S> secondFold, Func`3<S, T3, S> thirdFold);
    [PureAttribute]
public static S trifoldBack(ValueTuple`3<T1, T2, T3> self, S state, Func`3<S, T3, S> firstFold, Func`3<S, T2, S> secondFold, Func`3<S, T1, S> thirdFold);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`5<A, B, C, D, E> add(ValueTuple`4<A, B, C, D> self, E fifth);
    [NullableContextAttribute("2")]
[PureAttribute]
public static A head(ValueTuple`4<A, B, C, D> self);
    [NullableContextAttribute("2")]
[PureAttribute]
public static D last(ValueTuple`4<A, B, C, D> self);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`3<B, C, D> tail(ValueTuple`4<A, B, C, D> self);
    [PureAttribute]
public static bool contains(ValueTuple`4<A, A, A, A> self, A value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static R map(ValueTuple`4<A, B, C, D> self, Func`2<ValueTuple`4<A, B, C, D>, R> map);
    [NullableContextAttribute("2")]
[PureAttribute]
public static R map(ValueTuple`4<A, B, C, D> self, Func`5<A, B, C, D, R> map);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`4<W, X, Y, Z> map(ValueTuple`4<A, B, C, D> self, Func`2<A, W> firstMap, Func`2<B, X> secondMap, Func`2<C, Y> thirdMap, Func`2<D, Z> fourthMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`4<R1, B, C, D> mapFirst(ValueTuple`4<A, B, C, D> self, Func`2<A, R1> firstMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`4<A, R2, C, D> mapSecond(ValueTuple`4<A, B, C, D> self, Func`2<B, R2> secondMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`4<A, B, R3, D> mapThird(ValueTuple`4<A, B, C, D> self, Func`2<C, R3> thirdMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`4<A, B, C, R4> mapFourth(ValueTuple`4<A, B, C, D> self, Func`2<D, R4> fourthMap);
    [NullableContextAttribute("2")]
public static Unit iter(ValueTuple`4<A, B, C, D> self, Action`4<A, B, C, D> func);
    public static Unit iter(ValueTuple`4<A, B, C, D> self, Action`1<A> first, Action`1<B> second, Action`1<C> third, Action`1<D> fourth);
    [NullableContextAttribute("2")]
[PureAttribute]
public static S fold(ValueTuple`4<A, B, C, D> self, S state, Func`6<S, A, B, C, D, S> fold);
    [PureAttribute]
public static S quadFold(ValueTuple`4<A, B, C, D> self, S state, Func`3<S, A, S> firstFold, Func`3<S, B, S> secondFold, Func`3<S, C, S> thirdFold, Func`3<S, D, S> fourthFold);
    [PureAttribute]
public static S quadFoldBack(ValueTuple`4<A, B, C, D> self, S state, Func`3<S, D, S> firstFold, Func`3<S, C, S> secondFold, Func`3<S, B, S> thirdFold, Func`3<S, A, S> fourthFold);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTuple`6<A, B, C, D, E, F> add(ValueTuple`5<A, B, C, D, E> self, F sixth);
    [NullableContextAttribute("2")]
[PureAttribute]
public static A head(ValueTuple`5<A, B, C, D, E> self);
    [NullableContextAttribute("2")]
[PureAttribute]
public static E last(ValueTuple`5<A, B, C, D, E> self);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`4<B, C, D, E> tail(ValueTuple`5<A, B, C, D, E> self);
    [PureAttribute]
public static bool contains(ValueTuple`5<A, A, A, A, A> self, A value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static R map(ValueTuple`5<A, B, C, D, E> self, Func`2<ValueTuple`5<A, B, C, D, E>, R> map);
    [NullableContextAttribute("2")]
[PureAttribute]
public static R map(ValueTuple`5<A, B, C, D, E> self, Func`6<A, B, C, D, E, R> map);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`5<V, W, X, Y, Z> map(ValueTuple`5<A, B, C, D, E> self, Func`2<A, V> firstMap, Func`2<B, W> secondMap, Func`2<C, X> thirdMap, Func`2<D, Y> fourthMap, Func`2<E, Z> fifthMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`5<R1, B, C, D, E> mapFirst(ValueTuple`5<A, B, C, D, E> self, Func`2<A, R1> firstMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`5<A, R2, C, D, E> mapSecond(ValueTuple`5<A, B, C, D, E> self, Func`2<B, R2> secondMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`5<A, B, R3, D, E> mapThird(ValueTuple`5<A, B, C, D, E> self, Func`2<C, R3> thirdMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`5<A, B, C, R4, E> mapFourth(ValueTuple`5<A, B, C, D, E> self, Func`2<D, R4> fourthMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`5<A, B, C, D, R5> mapFifth(ValueTuple`5<A, B, C, D, E> self, Func`2<E, R5> fifthMap);
    [NullableContextAttribute("2")]
public static Unit iter(ValueTuple`5<A, B, C, D, E> self, Action`5<A, B, C, D, E> func);
    public static Unit iter(ValueTuple`5<A, B, C, D, E> self, Action`1<A> first, Action`1<B> second, Action`1<C> third, Action`1<D> fourth, Action`1<E> fifth);
    [NullableContextAttribute("2")]
[PureAttribute]
public static S fold(ValueTuple`5<A, B, C, D, E> self, S state, Func`7<S, A, B, C, D, E, S> fold);
    [PureAttribute]
public static S quintFold(ValueTuple`5<A, B, C, D, E> self, S state, Func`3<S, A, S> firstFold, Func`3<S, B, S> secondFold, Func`3<S, C, S> thirdFold, Func`3<S, D, S> fourthFold, Func`3<S, E, S> fifthFold);
    [PureAttribute]
public static S quintFoldBack(ValueTuple`5<A, B, C, D, E> self, S state, Func`3<S, E, S> firstFold, Func`3<S, D, S> secondFold, Func`3<S, C, S> thirdFold, Func`3<S, B, S> fourthFold, Func`3<S, A, S> fifthFold);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`7<A, B, C, D, E, F, G> add(ValueTuple`6<A, B, C, D, E, F> self, G seventh);
    [NullableContextAttribute("2")]
[PureAttribute]
public static A head(ValueTuple`6<A, B, C, D, E, F> self);
    [NullableContextAttribute("2")]
[PureAttribute]
public static F last(ValueTuple`6<A, B, C, D, E, F> self);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`5<B, C, D, E, F> tail(ValueTuple`6<A, B, C, D, E, F> self);
    [PureAttribute]
public static bool contains(ValueTuple`6<A, A, A, A, A, A> self, A value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static R map(ValueTuple`6<A, B, C, D, E, F> self, Func`2<ValueTuple`6<A, B, C, D, E, F>, R> map);
    [NullableContextAttribute("2")]
[PureAttribute]
public static R map(ValueTuple`6<A, B, C, D, E, F> self, Func`7<A, B, C, D, E, F, R> map);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`6<U, V, W, X, Y, Z> map(ValueTuple`6<A, B, C, D, E, F> self, Func`2<A, U> firstMap, Func`2<B, V> secondMap, Func`2<C, W> thirdMap, Func`2<D, X> fourthMap, Func`2<E, Y> fifthMap, Func`2<F, Z> sixthMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`6<R1, B, C, D, E, F> mapFirst(ValueTuple`6<A, B, C, D, E, F> self, Func`2<A, R1> firstMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`6<A, R2, C, D, E, F> mapSecond(ValueTuple`6<A, B, C, D, E, F> self, Func`2<B, R2> secondMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`6<A, B, R3, D, E, F> mapThird(ValueTuple`6<A, B, C, D, E, F> self, Func`2<C, R3> thirdMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`6<A, B, C, R4, E, F> mapFourth(ValueTuple`6<A, B, C, D, E, F> self, Func`2<D, R4> fourthMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`6<A, B, C, D, R5, F> mapFifth(ValueTuple`6<A, B, C, D, E, F> self, Func`2<E, R5> fifthMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`6<A, B, C, D, E, R6> mapSixth(ValueTuple`6<A, B, C, D, E, F> self, Func`2<F, R6> sixthMap);
    [NullableContextAttribute("2")]
public static Unit iter(ValueTuple`6<A, B, C, D, E, F> self, Action`6<A, B, C, D, E, F> func);
    public static Unit iter(ValueTuple`6<A, B, C, D, E, F> self, Action`1<A> first, Action`1<B> second, Action`1<C> third, Action`1<D> fourth, Action`1<E> fifth, Action`1<F> sixth);
    [NullableContextAttribute("2")]
[PureAttribute]
public static S fold(ValueTuple`6<A, B, C, D, E, F> self, S state, Func`8<S, A, B, C, D, E, F, S> fold);
    [PureAttribute]
public static S sextFold(ValueTuple`6<A, B, C, D, E, F> self, S state, Func`3<S, A, S> firstFold, Func`3<S, B, S> secondFold, Func`3<S, C, S> thirdFold, Func`3<S, D, S> fourthFold, Func`3<S, E, S> fifthFold, Func`3<S, F, S> sixthFold);
    [PureAttribute]
public static S sextFoldBack(ValueTuple`6<A, B, C, D, E, F> self, S state, Func`3<S, F, S> firstFold, Func`3<S, E, S> secondFold, Func`3<S, D, S> thirdFold, Func`3<S, C, S> fourthFold, Func`3<S, B, S> fifthFold, Func`3<S, A, S> sixthFold);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`8<A, B, C, D, E, F, G, ValueTuple`1<H>> add(ValueTuple`7<A, B, C, D, E, F, G> self, H eighth);
    [NullableContextAttribute("2")]
[PureAttribute]
public static A head(ValueTuple`7<A, B, C, D, E, F, G> self);
    [NullableContextAttribute("2")]
[PureAttribute]
public static G last(ValueTuple`7<A, B, C, D, E, F, G> self);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`6<B, C, D, E, F, G> tail(ValueTuple`7<A, B, C, D, E, F, G> self);
    [PureAttribute]
public static bool contains(ValueTuple`7<A, A, A, A, A, A, A> self, A value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static R map(ValueTuple`7<A, B, C, D, E, F, G> self, Func`2<ValueTuple`7<A, B, C, D, E, F, G>, R> map);
    [NullableContextAttribute("2")]
[PureAttribute]
public static R map(ValueTuple`7<A, B, C, D, E, F, G> self, Func`8<A, B, C, D, E, F, G, R> map);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`7<T, U, V, W, X, Y, Z> map(ValueTuple`7<A, B, C, D, E, F, G> self, Func`2<A, T> firstMap, Func`2<B, U> secondMap, Func`2<C, V> thirdMap, Func`2<D, W> fourthMap, Func`2<E, X> fifthMap, Func`2<F, Y> sixthMap, Func`2<G, Z> seventhMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`7<R1, B, C, D, E, F, G> mapFirst(ValueTuple`7<A, B, C, D, E, F, G> self, Func`2<A, R1> firstMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`7<A, R2, C, D, E, F, G> mapSecond(ValueTuple`7<A, B, C, D, E, F, G> self, Func`2<B, R2> secondMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`7<A, B, R3, D, E, F, G> mapThird(ValueTuple`7<A, B, C, D, E, F, G> self, Func`2<C, R3> thirdMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`7<A, B, C, R4, E, F, G> mapFourth(ValueTuple`7<A, B, C, D, E, F, G> self, Func`2<D, R4> fourthMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`7<A, B, C, D, R5, F, G> mapFifth(ValueTuple`7<A, B, C, D, E, F, G> self, Func`2<E, R5> fifthMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`7<A, B, C, D, E, R6, G> mapSixth(ValueTuple`7<A, B, C, D, E, F, G> self, Func`2<F, R6> sixthMap);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`7<A, B, C, D, E, F, R7> mapSeventh(ValueTuple`7<A, B, C, D, E, F, G> self, Func`2<G, R7> seventhMap);
    [NullableContextAttribute("2")]
public static Unit iter(ValueTuple`7<A, B, C, D, E, F, G> self, Action`7<A, B, C, D, E, F, G> func);
    public static Unit iter(ValueTuple`7<A, B, C, D, E, F, G> self, Action`1<A> first, Action`1<B> second, Action`1<C> third, Action`1<D> fourth, Action`1<E> fifth, Action`1<F> sixth, Action`1<G> seventh);
    [NullableContextAttribute("2")]
[PureAttribute]
public static S fold(ValueTuple`7<A, B, C, D, E, F, G> self, S state, Func`9<S, A, B, C, D, E, F, G, S> fold);
    [PureAttribute]
public static S septFold(ValueTuple`7<A, B, C, D, E, F, G> self, S state, Func`3<S, A, S> firstFold, Func`3<S, B, S> secondFold, Func`3<S, C, S> thirdFold, Func`3<S, D, S> fourthFold, Func`3<S, E, S> fifthFold, Func`3<S, F, S> sixthFold, Func`3<S, G, S> seventhFold);
    [PureAttribute]
public static S septFoldBack(ValueTuple`7<A, B, C, D, E, F, G> self, S state, Func`3<S, G, S> firstFold, Func`3<S, F, S> secondFold, Func`3<S, E, S> thirdFold, Func`3<S, D, S> fourthFold, Func`3<S, C, S> fifthFold, Func`3<S, B, S> sixthFold, Func`3<S, A, S> seventhFold);
    public static Eff`1<B> apply(Eff`1<Func`2<A, B>> mf, Eff`1<A> ma);
    public static Eff`1<C> apply(Eff`1<Func`3<A, B, C>> mf, Eff`1<A> ma, Eff`1<B> mb);
    public static Eff`1<Func`2<B, C>> apply(Eff`1<Func`3<A, B, C>> mf, Eff`1<A> ma);
    public static Eff`1<D> apply(Eff`1<Func`4<A, B, C, D>> mf, Eff`1<A> ma, Eff`1<B> mb, Eff`1<C> mc);
    public static Eff`1<Func`2<C, D>> apply(Eff`1<Func`4<A, B, C, D>> mf, Eff`1<A> ma, Eff`1<B> mb);
    [NullableContextAttribute("2")]
public static Eff`1<Func`2<B, Func`2<C, D>>> apply(Eff`1<Func`4<A, B, C, D>> mf, Eff`1<A> ma);
    public static Eff`1<E> apply(Eff`1<Func`5<A, B, C, D, E>> mf, Eff`1<A> ma, Eff`1<B> mb, Eff`1<C> mc, Eff`1<D> md);
    public static Eff`1<Func`2<D, E>> apply(Eff`1<Func`5<A, B, C, D, E>> mf, Eff`1<A> ma, Eff`1<B> mb, Eff`1<C> mc);
    [NullableContextAttribute("2")]
public static Eff`1<Func`2<C, Func`2<D, E>>> apply(Eff`1<Func`5<A, B, C, D, E>> mf, Eff`1<A> ma, Eff`1<B> mb);
    [NullableContextAttribute("2")]
public static Eff`1<Func`2<B, Func`2<C, Func`2<D, E>>>> apply(Eff`1<Func`5<A, B, C, D, E>> mf, Eff`1<A> ma);
    public static Eff`1<B> apply(Func`2<A, B> f, Eff`1<A> ma);
    public static Eff`1<C> apply(Func`3<A, B, C> f, Eff`1<A> ma, Eff`1<B> mb);
    public static Eff`1<Func`2<B, C>> apply(Func`3<A, B, C> f, Eff`1<A> ma);
    public static Eff`1<D> apply(Func`4<A, B, C, D> f, Eff`1<A> ma, Eff`1<B> mb, Eff`1<C> mc);
    public static Eff`1<Func`2<C, D>> apply(Func`4<A, B, C, D> f, Eff`1<A> ma, Eff`1<B> mb);
    [NullableContextAttribute("2")]
public static Eff`1<Func`2<B, Func`2<C, D>>> apply(Func`4<A, B, C, D> f, Eff`1<A> ma);
    public static Eff`1<E> apply(Func`5<A, B, C, D, E> f, Eff`1<A> ma, Eff`1<B> mb, Eff`1<C> mc, Eff`1<D> md);
    public static Eff`1<Func`2<D, E>> apply(Func`5<A, B, C, D, E> f, Eff`1<A> ma, Eff`1<B> mb, Eff`1<C> mc);
    [NullableContextAttribute("2")]
public static Eff`1<Func`2<C, Func`2<D, E>>> apply(Func`5<A, B, C, D, E> f, Eff`1<A> ma, Eff`1<B> mb);
    [NullableContextAttribute("2")]
public static Eff`1<Func`2<B, Func`2<C, Func`2<D, E>>>> apply(Func`5<A, B, C, D, E> f, Eff`1<A> ma);
    [PureAttribute]
public static Eff`1<A> timeout(TimeSpan timeout, Eff`1<A> ma);
    [PureAttribute]
public static Eff`1<A> SuccessEff(A value);
    [PureAttribute]
public static Eff`1<A> FailEff(Error error);
    internal static Eff`1<MinRT> get_runtimeMinRT();
    public static Eff`1<A> localCancel(Eff`1<A> ma);
    public static Eff`1<CancellationToken> get_cancelTokenEff();
    [PureAttribute]
public static Eff`1<A> flatten(Eff`1<Eff`1<A>> mma);
    [PureAttribute]
public static Eff`1<Unit> liftEff(Action action);
    [PureAttribute]
public static Eff`1<A> liftEff(Func`1<A> f);
    [PureAttribute]
public static Eff`1<A> liftEff(Func`1<Either`2<Error, A>> f);
    [PureAttribute]
public static Eff`1<A> liftEff(Func`1<Fin`1<A>> f);
    [PureAttribute]
public static Eff`1<A> liftEff(Func`2<MinRT, Either`2<Error, A>> f);
    [PureAttribute]
public static Eff`1<A> liftEff(Func`2<MinRT, A> f);
    [PureAttribute]
public static Eff`1<A> liftEff(Func`2<MinRT, Fin`1<A>> f);
    [PureAttribute]
public static Eff`1<A> liftEff(Func`2<MinRT, Task`1<A>> f);
    [PureAttribute]
public static Eff`1<A> liftEff(Func`2<MinRT, Task`1<Fin`1<A>>> f);
    [PureAttribute]
public static Eff`1<A> liftEff(Func`1<Task`1<A>> f);
    [PureAttribute]
public static Eff`1<A> liftEff(Func`1<Task`1<Fin`1<A>>> f);
    [PureAttribute]
public static Eff`1<B> map(Eff`1<A> ma, Func`2<A, B> f);
    [PureAttribute]
public static Eff`1<A> mapFail(Eff`1<A> ma, Func`2<Error, Error> f);
    [PureAttribute]
public static Eff`1<B> bimap(Eff`1<A> ma, Func`2<A, B> Succ, Func`2<Error, Error> Fail);
    [PureAttribute]
public static Eff`1<B> match(Eff`1<A> ma, Func`2<A, B> Succ, Func`2<Error, B> Fail);
    [PureAttribute]
public static Eff`1<A> ifFail(Eff`1<A> ma, Func`2<Error, A> Fail);
    [PureAttribute]
public static Eff`1<A> ifFailEff(Eff`1<A> ma, Func`2<Error, Eff`1<A>> Fail);
    [PureAttribute]
public static Eff`1<A> filter(Eff`1<A> ma, Func`2<A, bool> predicate);
    [ObsoleteAttribute("Use either: `Prelude.liftEff`, `Eff<A>.Lift`, or `Eff<A>.LiftIO` (for async)")]
[PureAttribute]
public static Eff`1<A> EffMaybe(Func`1<Fin`1<A>> f);
    [ObsoleteAttribute("Use either: `Prelude.lift`, `Prelude.liftEff`, `Eff<A>.Lift`, or `Eff<A>.LiftIO` (for async)")]
[PureAttribute]
public static Eff`1<A> Eff(Func`1<A> f);
    public static Eff`2<RT, B> apply(K`2<Eff`1<RT>, Func`2<A, B>> mf, K`2<Eff`1<RT>, A> ma);
    public static Eff`2<RT, C> apply(K`2<Eff`1<RT>, Func`3<A, B, C>> mf, K`2<Eff`1<RT>, A> ma, K`2<Eff`1<RT>, B> mb);
    [NullableContextAttribute("2")]
public static Eff`2<RT, Func`2<B, C>> apply(K`2<Eff`1<RT>, Func`3<A, B, C>> mf, K`2<Eff`1<RT>, A> ma);
    public static Eff`2<RT, D> apply(K`2<Eff`1<RT>, Func`4<A, B, C, D>> mf, K`2<Eff`1<RT>, A> ma, K`2<Eff`1<RT>, B> mb, K`2<Eff`1<RT>, C> mc);
    [NullableContextAttribute("2")]
public static Eff`2<RT, Func`2<C, D>> apply(K`2<Eff`1<RT>, Func`4<A, B, C, D>> mf, K`2<Eff`1<RT>, A> ma, K`2<Eff`1<RT>, B> mb);
    [NullableContextAttribute("2")]
public static Eff`2<RT, Func`2<B, Func`2<C, D>>> apply(K`2<Eff`1<RT>, Func`4<A, B, C, D>> mf, K`2<Eff`1<RT>, A> ma);
    public static Eff`2<RT, E> apply(K`2<Eff`1<RT>, Func`5<A, B, C, D, E>> mf, K`2<Eff`1<RT>, A> ma, K`2<Eff`1<RT>, B> mb, K`2<Eff`1<RT>, C> mc, K`2<Eff`1<RT>, D> md);
    [NullableContextAttribute("2")]
public static Eff`2<RT, Func`2<D, E>> apply(K`2<Eff`1<RT>, Func`5<A, B, C, D, E>> mf, K`2<Eff`1<RT>, A> ma, K`2<Eff`1<RT>, B> mb, K`2<Eff`1<RT>, C> mc);
    [NullableContextAttribute("2")]
public static Eff`2<RT, Func`2<C, Func`2<D, E>>> apply(K`2<Eff`1<RT>, Func`5<A, B, C, D, E>> mf, K`2<Eff`1<RT>, A> ma, K`2<Eff`1<RT>, B> mb);
    [NullableContextAttribute("2")]
public static Eff`2<RT, Func`2<B, Func`2<C, Func`2<D, E>>>> apply(K`2<Eff`1<RT>, Func`5<A, B, C, D, E>> mf, K`2<Eff`1<RT>, A> ma);
    [PureAttribute]
public static Eff`2<RT, A> SuccessEff(A value);
    [PureAttribute]
public static Eff`2<RT, A> FailEff(Error error);
    [PureAttribute]
public static Eff`2<RT, RT> runtime();
    [NullableContextAttribute("2")]
[PureAttribute]
public static Eff`2<RT, ValueTuple`2<RT, EnvIO>> getState();
    public static Eff`2<RT, A> localCancel(Eff`2<RT, A> ma);
    [PureAttribute]
public static Eff`2<OuterRT, A> localEff(Func`2<OuterRT, InnerRT> f, Eff`2<InnerRT, A> ma);
    [PureAttribute]
public static Eff`2<RT, A> flatten(Eff`2<RT, Eff`2<RT, A>> mma);
    [PureAttribute]
public static Eff`2<RT, A> liftEff(Func`2<RT, Either`2<Error, A>> f);
    [PureAttribute]
public static Eff`2<RT, A> liftEff(Func`2<RT, Fin`1<A>> f);
    [PureAttribute]
public static Eff`2<RT, A> liftEff(Func`2<RT, A> f);
    [PureAttribute]
public static Eff`2<RT, A> liftEff(Func`2<RT, Task`1<A>> f);
    [PureAttribute]
public static Eff`2<RT, A> liftEff(Func`2<RT, Task`1<Fin`1<A>>> f);
    [PureAttribute]
public static Eff`2<RT, A> liftEff(IO`1<A> ma);
    [PureAttribute]
public static Eff`2<RT, B> map(Eff`2<RT, A> ma, Func`2<A, B> f);
    [PureAttribute]
public static Eff`2<RT, A> mapFail(Eff`2<RT, A> ma, Func`2<Error, Error> f);
    [PureAttribute]
public static Eff`2<RT, B> bimap(Eff`2<RT, A> ma, Func`2<A, B> Succ, Func`2<Error, Error> Fail);
    [PureAttribute]
public static Eff`2<RT, B> match(Eff`2<RT, A> ma, Func`2<A, B> Succ, Func`2<Error, B> Fail);
    [PureAttribute]
public static Eff`2<RT, A> ifFail(Eff`2<RT, A> ma, Func`2<Error, A> Fail);
    [PureAttribute]
public static Eff`2<RT, A> ifFailEff(Eff`2<RT, A> ma, Func`2<Error, Eff`2<RT, A>> Fail);
    [PureAttribute]
public static Eff`2<RT, A> filter(Eff`2<RT, A> ma, Func`2<A, bool> predicate);
    [ObsoleteAttribute("Use either: `Prelude.liftEff`, `Eff<A>.Lift`, or `Eff<A>.LiftIO` (for async)")]
[PureAttribute]
public static Eff`2<RT, A> EffMaybe(Func`2<RT, Fin`1<A>> f);
    [ObsoleteAttribute("Use either: `Prelude.lift`, `Prelude.liftEff`, `Eff<A>.Lift`, or `Eff<A>.LiftIO` (for async)")]
[PureAttribute]
public static Eff`2<RT, A> Eff(Func`2<RT, A> f);
    public static IO`1<Ref`1<A>> refIO(A value, Func`2<A, bool> validator);
    public static IO`1<R> atomicIO(Func`1<R> op, Isolation isolation);
    public static IO`1<Unit> atomicIO(Action op, Isolation isolation);
    public static IO`1<R> snapshotIO(Func`1<R> op);
    public static IO`1<Unit> snapshotIO(Action op);
    public static IO`1<R> serialIO(Func`1<R> op);
    public static IO`1<Unit> serialIO(Action op);
    public static IO`1<A> swapIO(Ref`1<A> r, Func`2<A, A> f);
    public static IO`1<A> commuteIO(Ref`1<A> r, Func`2<A, A> f);
    public static IO`1<Atom`1<A>> atomIO(A value);
    public static IO`1<Atom`1<A>> atomIO(A value, Func`2<A, bool> validator);
    public static IO`1<Atom`2<M, A>> atomIO(M metadata, A value);
    public static IO`1<Atom`2<M, A>> atomIO(M metadata, A value, Func`2<A, bool> validator);
    public static IO`1<A> swapIO(Atom`1<A> ma, Func`2<A, A> f);
    public static IO`1<A> swapIO(Atom`2<M, A> ma, Func`3<M, A, A> f);
    public static IO`1<A> swapIO(Atom`1<A> ma, Func`2<A, Option`1<A>> f);
    public static IO`1<A> swapIO(Atom`2<M, A> ma, Func`3<M, A, Option`1<A>> f);
    public static IO`1<A> valueIO(Atom`1<A> ma);
    public static IO`1<A> valueIO(Atom`2<M, A> ma);
    public static IO`1<A> writeIO(Atom`1<A> ma, A value);
    public static IO`1<A> writeIO(Atom`2<M, A> ma, A value);
    [PureAttribute]
public static K`2<M, A> postIO(K`2<M, A> ma);
    [NullableContextAttribute("0")]
[PureAttribute]
public static K`2<M, ForkIO`1<A>> forkIO(K`2<M, A> ma, Option`1<TimeSpan> timeout);
    [NullableContextAttribute("0")]
[PureAttribute]
public static K`2<M, ForkIO`1<Option`1<A>>> forkIO(StreamT`2<M, A> ma, Option`1<TimeSpan> timeout);
    [PureAttribute]
public static K`2<M, A> awaitIO(K`2<M, ForkIO`1<A>> ma);
    public static IO`1<Unit> yieldIO(double milliseconds);
    public static K`2<M, Seq`1<A>> awaitAll(K`2[] ms);
    public static IO`1<Seq`1<A>> awaitAll(K`2[] ms);
    public static IO`1<Seq`1<A>> awaitAll(IO`1[] ms);
    [NullableContextAttribute("0")]
public static K`2<M, Seq`1<A>> awaitAll(K`2[] forks);
    [NullableContextAttribute("2")]
public static IO`1<Seq`1<A>> awaitAll(IO`1[] mfs);
    [NullableContextAttribute("0")]
public static K`2<M, Seq`1<A>> awaitAll(Seq`1<K`2<M, A>> ms);
    [NullableContextAttribute("2")]
public static IO`1<Seq`1<A>> awaitAll(Seq`1<K`2<IO, A>> ms);
    [NullableContextAttribute("2")]
public static IO`1<Seq`1<A>> awaitAll(Seq`1<IO`1<A>> ms);
    [NullableContextAttribute("0")]
public static K`2<M, Seq`1<A>> awaitAll(Seq`1<K`2<M, ForkIO`1<A>>> forks);
    [NullableContextAttribute("2")]
public static IO`1<Seq`1<A>> awaitAll(Seq`1<IO`1<ForkIO`1<A>>> mfs);
    public static K`2<M, A> awaitAny(K`2[] forks);
    public static IO`1<A> awaitAny(IO`1[] ms);
    public static IO`1<A> awaitAny(K`2[] ms);
    public static K`2<M, A> awaitAny(K`2[] forks);
    public static IO`1<A> awaitAny(IO`1[] forks);
    public static K`2<M, A> awaitAny(Seq`1<K`2<M, ForkIO`1<A>>> forks);
    public static K`2<M, A> awaitAny(Seq`1<K`2<M, A>> forks);
    public static IO`1<A> awaitAny(Seq`1<K`2<IO, A>> ms);
    public static IO`1<A> awaitAny(Seq`1<IO`1<A>> ms);
    public static IO`1<A> awaitAny(Seq`1<IO`1<ForkIO`1<A>>> mfs);
    [PureAttribute]
public static K`2<M, A> timeoutIO(TimeSpan timeout, K`2<M, A> ma);
    public static K`2<M, A> repeatIO(K`2<M, A> ma);
    public static K`2<M, A> repeatIO(Schedule schedule, K`2<M, A> ma);
    public static K`2<M, A> repeatWhileIO(K`2<M, A> ma, Func`2<A, bool> predicate);
    public static K`2<M, A> repeatWhileIO(Schedule schedule, K`2<M, A> ma, Func`2<A, bool> predicate);
    public static K`2<M, A> repeatUntilIO(K`2<M, A> ma, Func`2<A, bool> predicate);
    public static K`2<M, A> repeatUntilIO(Schedule schedule, K`2<M, A> ma, Func`2<A, bool> predicate);
    public static K`2<M, A> retryIO(K`2<M, A> ma);
    public static K`2<M, A> retryIO(Schedule schedule, K`2<M, A> ma);
    public static K`2<M, A> retryWhileIO(K`2<M, A> ma, Func`2<Error, bool> predicate);
    public static K`2<M, A> retryWhileIO(Schedule schedule, K`2<M, A> ma, Func`2<Error, bool> predicate);
    public static K`2<M, A> retryUntilIO(K`2<M, A> ma, Func`2<Error, bool> predicate);
    public static K`2<M, A> retryUntilIO(Schedule schedule, K`2<M, A> ma, Func`2<Error, bool> predicate);
    [NullableContextAttribute("2")]
public static K`2<M, ValueTuple`2<A, B>> zipIO(ValueTuple`2<K`2<M, A>, K`2<M, B>> tuple);
    [NullableContextAttribute("2")]
public static K`2<M, ValueTuple`3<A, B, C>> zipIO(ValueTuple`3<K`2<M, A>, K`2<M, B>, K`2<M, C>> tuple);
    [NullableContextAttribute("2")]
public static K`2<M, ValueTuple`4<A, B, C, D>> zipIO(ValueTuple`4<K`2<M, A>, K`2<M, B>, K`2<M, C>, K`2<M, D>> tuple);
    public static K`2<M, ValueTuple`2<A, B>> zipIO(K`2<M, A> First, K`2<M, B> Second);
    public static K`2<M, ValueTuple`3<A, B, C>> zipIO(K`2<M, A> First, K`2<M, B> Second, K`2<M, C> Third);
    public static K`2<M, ValueTuple`4<A, B, C, D>> zipIO(K`2<M, A> First, K`2<M, B> Second, K`2<M, C> Third, K`2<M, D> Fourth);
    [PureAttribute]
public static Schedule intersect(Schedule a, Schedule b);
    [PureAttribute]
public static Schedule union(Schedule a, Schedule b);
    [PureAttribute]
public static Schedule interleave(Schedule a, Schedule b);
    [PureAttribute]
public static Schedule append(Schedule a, Schedule b);
    [PureAttribute]
public static Schedule take(Schedule s, int amount);
    [PureAttribute]
public static Schedule skip(Schedule s, int amount);
    [PureAttribute]
public static Schedule tail(Schedule s);
    [PureAttribute]
public static Schedule map(Schedule s, Func`2<Duration, Duration> f);
    [PureAttribute]
public static Schedule filter(Schedule s, Func`2<Duration, bool> pred);
    [PureAttribute]
public static Schedule bind(Schedule s, Func`2<Duration, Schedule> f);
    public static StreamT`2<M, A> merge(K`2<StreamT`1<M>, A> first, K`2<StreamT`1<M>, A> second);
    public static StreamT`2<M, A> merge(K`2<StreamT`1<M>, A> first, K`2<StreamT`1<M>, A> second, K`2[] rest);
    public static StreamT`2<M, ValueTuple`2<A, B>> zip(K`2<StreamT`1<M>, A> first, K`2<StreamT`1<M>, B> second);
    public static StreamT`2<M, ValueTuple`3<A, B, C>> zip(K`2<StreamT`1<M>, A> first, K`2<StreamT`1<M>, B> second, K`2<StreamT`1<M>, C> third);
    public static StreamT`2<M, ValueTuple`4<A, B, C, D>> zip(K`2<StreamT`1<M>, A> first, K`2<StreamT`1<M>, B> second, K`2<StreamT`1<M>, C> third, K`2<StreamT`1<M>, D> fourth);
    [ExtensionAttribute]
[PureAttribute]
public static Seq`1<A> Cons(A head);
    [ExtensionAttribute]
[PureAttribute]
public static Seq`1<A> Cons(A head, SeqEmpty empty);
    [ExtensionAttribute]
[PureAttribute]
public static Seq`1<A> Cons(A head, Seq`1<A> tail);
    [ExtensionAttribute]
[PureAttribute]
public static Seq`1<A> Cons(A head, A[] tail);
    [ExtensionAttribute]
[PureAttribute]
public static Seq`1<A> Cons(A head, Arr`1<A> tail);
    [ExtensionAttribute]
[PureAttribute]
public static Seq`1<A> Cons(A head, IEnumerable`1<A> tail);
    [ExtensionAttribute]
[PureAttribute]
public static Lst`1<A> Cons(A head, Lst`1<A> tail);
    [ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<A> Sort(IEnumerable`1<A> xs);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[PureAttribute]
public static Seq`1<A> Sort(Seq`1<A> xs);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[PureAttribute]
public static Lst`1<A> Sort(Lst`1<A> xs);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[PureAttribute]
public static Arr`1<A> Sort(Arr`1<A> xs);
    [ExtensionAttribute]
[PureAttribute]
public static A[] Sort(A[] xs);
    public static Iterable`1<int> get_Naturals();
    public static Iterable`1<long> get_LongNaturals();
    [PureAttribute]
public static Range`1<long> Range(long from, long count, long step);
    [PureAttribute]
public static Range`1<int> Range(int from, int count, int step);
    [PureAttribute]
public static Range`1<char> Range(char from, char to);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Map`2<K, V> Map();
    [NullableContextAttribute("2")]
[PureAttribute]
public static Map`2<K, V> Map(ValueTuple`2<K, V> head, ValueTuple`2[] tail);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Map`2<K, V> toMap(IEnumerable`1<ValueTuple`2<K, V>> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Map`2<K, V> toMap(ReadOnlySpan`1<ValueTuple`2<K, V>> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Map`3<OrdK, K, V> Map();
    [NullableContextAttribute("2")]
[PureAttribute]
public static Map`3<OrdK, K, V> Map(ValueTuple`2<K, V> head, ValueTuple`2[] tail);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Map`3<OrdK, K, V> toMap(IEnumerable`1<ValueTuple`2<K, V>> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Map`3<OrdK, K, V> toMap(ReadOnlySpan`1<ValueTuple`2<K, V>> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static HashMap`2<K, V> HashMap();
    [NullableContextAttribute("2")]
[PureAttribute]
public static HashMap`2<K, V> HashMap(ValueTuple`2<K, V> head, ValueTuple`2[] tail);
    [NullableContextAttribute("2")]
[PureAttribute]
public static HashMap`2<K, V> toHashMap(IEnumerable`1<ValueTuple`2<K, V>> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static HashMap`2<K, V> toHashMap(ReadOnlySpan`1<ValueTuple`2<K, V>> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static HashMap`3<EqK, K, V> HashMap();
    [NullableContextAttribute("2")]
[PureAttribute]
public static HashMap`3<EqK, K, V> HashMap(ValueTuple`2<K, V> head, ValueTuple`2[] tail);
    [NullableContextAttribute("2")]
[PureAttribute]
public static HashMap`3<EqK, K, V> toHashMap(IEnumerable`1<ValueTuple`2<K, V>> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static HashMap`3<EqK, K, V> toHashMap(ReadOnlySpan`1<ValueTuple`2<K, V>> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static TrackingHashMap`2<K, V> TrackingHashMap();
    [NullableContextAttribute("2")]
[PureAttribute]
public static TrackingHashMap`2<K, V> TrackingHashMap(ValueTuple`2<K, V> head, ValueTuple`2[] tail);
    [NullableContextAttribute("2")]
[PureAttribute]
public static TrackingHashMap`2<K, V> toTrackingHashMap(IEnumerable`1<ValueTuple`2<K, V>> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static TrackingHashMap`2<K, V> toTrackingHashMap(ReadOnlySpan`1<ValueTuple`2<K, V>> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> TrackingHashMap();
    [NullableContextAttribute("2")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> TrackingHashMap(ValueTuple`2<K, V> head, ValueTuple`2[] tail);
    [NullableContextAttribute("2")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> toTrackingHashMap(IEnumerable`1<ValueTuple`2<K, V>> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> toTrackingHashMap(ReadOnlySpan`1<ValueTuple`2<K, V>> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static AtomHashMap`2<K, V> AtomHashMap();
    [NullableContextAttribute("2")]
[PureAttribute]
public static AtomHashMap`2<K, V> AtomHashMap(ValueTuple`2<K, V> head, ValueTuple`2[] tail);
    [NullableContextAttribute("2")]
[PureAttribute]
public static AtomHashMap`2<K, V> AtomHashMap(HashMap`2<K, V> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static AtomHashMap`2<K, V> toAtomHashMap(IEnumerable`1<ValueTuple`2<K, V>> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static AtomHashMap`2<K, V> toAtomHashMap(ReadOnlySpan`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public static AtomHashMap`3<EqK, K, V> AtomHashMap();
    [PureAttribute]
public static AtomHashMap`3<EqK, K, V> AtomHashMap(ValueTuple`2<K, V> head, ValueTuple`2[] tail);
    [PureAttribute]
public static AtomHashMap`3<EqK, K, V> AtomHashMap(HashMap`3<EqK, K, V> items);
    [PureAttribute]
public static AtomHashMap`3<EqK, K, V> toAtomHashMap(IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public static AtomHashMap`3<EqK, K, V> toAtomHashMap(ReadOnlySpan`1<ValueTuple`2<K, V>> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Lst`1<T> List();
    [PureAttribute]
public static Lst`1<T> List(T x, T[] xs);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Lst`1<T> toList(Arr`1<T> items);
    [PureAttribute]
public static Lst`1<T> toList(IEnumerable`1<T> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Lst`1<T> toList(ReadOnlySpan`1<T> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Arr`1<T> Array();
    [PureAttribute]
public static Arr`1<T> Array(T x, T[] xs);
    [PureAttribute]
public static Arr`1<T> toArray(IEnumerable`1<T> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Arr`1<T> toArray(ReadOnlySpan`1<T> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Que`1<T> Queue();
    [PureAttribute]
public static Que`1<T> Queue(T[] items);
    [PureAttribute]
public static Que`1<T> toQueue(IEnumerable`1<T> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Que`1<T> toQueue(ReadOnlySpan`1<T> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Stck`1<T> Stack();
    [PureAttribute]
public static Stck`1<T> Stack(T[] items);
    [PureAttribute]
public static Stck`1<T> toStack(IEnumerable`1<T> items);
    [PureAttribute]
public static Stck`1<T> toStackRev(IEnumerable`1<T> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Map`2<K, V> toMapUpdate(IEnumerable`1<ValueTuple`2<K, V>> keyValues);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Map`2<K, V> toMapUpdate(ReadOnlySpan`1<ValueTuple`2<K, V>> keyValues);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Map`2<K, V> toMapTry(IEnumerable`1<ValueTuple`2<K, V>> keyValues);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Map`2<K, V> toMapTry(ReadOnlySpan`1<ValueTuple`2<K, V>> keyValues);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Set`1<T> Set();
    [PureAttribute]
public static Set`1<T> Set(T head, T[] tail);
    [PureAttribute]
public static Set`1<T> toSet(IEnumerable`1<T> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Set`1<T> toSet(ReadOnlySpan`1<T> items);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Set`2<OrdT, T> Set();
    [PureAttribute]
public static Set`2<OrdT, T> Set(T head, T[] tail);
    [PureAttribute]
public static Set`2<OrdT, T> toSet(IEnumerable`1<T> items);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Set`2<OrdT, T> toSet(ReadOnlySpan`1<T> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static HashSet`1<T> HashSet();
    [PureAttribute]
public static HashSet`1<T> HashSet(T head, T[] tail);
    [PureAttribute]
public static HashSet`1<T> toHashSet(IEnumerable`1<T> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static HashSet`1<T> toHashSet(ReadOnlySpan`1<T> items);
    [NullableContextAttribute("0")]
[PureAttribute]
public static HashSet`2<EqT, T> HashSet();
    [PureAttribute]
public static HashSet`2<EqT, T> HashSet(T head, T[] tail);
    [PureAttribute]
public static HashSet`2<EqT, T> toHashSet(IEnumerable`1<T> items);
    [NullableContextAttribute("0")]
[PureAttribute]
public static HashSet`2<EqT, T> toHashSet(ReadOnlySpan`1<T> items);
    [PureAttribute]
public static IQueryable`1<T> Query(T[] items);
    [PureAttribute]
public static IQueryable`1<T> toQuery(IEnumerable`1<T> items);
    public static B match(IEnumerable`1<A> list, Func`1<B> Empty, Func`2<Seq`1<A>, B> More);
    [PureAttribute]
public static B match(IEnumerable`1<A> list, Func`1<B> Empty, Func`3<A, Seq`1<A>, B> More);
    [PureAttribute]
public static R match(IEnumerable`1<T> list, Func`1<R> Empty, Func`2<T, R> One, Func`3<T, Seq`1<T>, R> More);
    [PureAttribute]
public static R match(Map`2<K, V> map, K key, Func`2<V, R> Some, Func`1<R> None);
    public static Unit match(Map`2<K, V> map, K key, Action`1<V> Some, Action None);
    [PureAttribute]
public static R match(HashMap`2<K, V> map, K key, Func`2<V, R> Some, Func`1<R> None);
    public static Unit match(HashMap`2<K, V> map, K key, Action`1<V> Some, Action None);
    [PureAttribute]
public static Iterable`1<A> Iterable();
    [PureAttribute]
public static Iterable`1<A> Iterable(ReadOnlySpan`1<A> value);
    [PureAttribute]
public static Iterable`1<A> Iterable(A fst, A snd, A[] rest);
    [PureAttribute]
public static Iterable`1<A> Iterable(IEnumerable`1<A> value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> Seq();
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: Seq1(x), you should now call [x] - alternatively use Seq(x) as Seq1(x) has been deprecated.")]
public static Seq`1<A> Seq1(A value);
    [PureAttribute]
public static Seq`1<A> Seq(A value);
    [PureAttribute]
public static Seq`1<A> Seq(A a, A b);
    [PureAttribute]
public static Seq`1<A> Seq(A a, A b, A c);
    [PureAttribute]
public static Seq`1<A> Seq(A a, A b, A c, A d);
    [PureAttribute]
public static Seq`1<A> Seq(A a, A b, A c, A d, A e);
    [PureAttribute]
public static Seq`1<A> Seq(A a, A b, A c, A d, A e, A f);
    [PureAttribute]
public static Seq`1<A> Seq(A a, A b, A c, A d, A e, A f, A g);
    [PureAttribute]
public static Seq`1<A> Seq(A a, A b, A c, A d, A e, A f, A g, A h);
    [PureAttribute]
public static Seq`1<A> Seq(A a, A b, A c, A d, A e, A f, A g, A h, A[] tail);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> Seq(ReadOnlySpan`1<A> value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> Seq(IEnumerable`1<A> value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> toSeq(IEnumerable`1<A> value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Seq`1<A> toSeq(Nullable`1<A> value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> toSeq(A[] value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> toSeq(Arr`1<A> value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> toSeq(IList`1<A> value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> toSeq(ICollection`1<A> value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<R> toSeq(Either`2<L, R> value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> toSeq(ValueTuple`1<A> tup);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> toSeq(ValueTuple`2<A, A> tup);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> toSeq(ValueTuple`3<A, A, A> tup);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> toSeq(ValueTuple`4<A, A, A, A> tup);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> toSeq(ValueTuple`5<A, A, A, A, A> tup);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> toSeq(ValueTuple`6<A, A, A, A, A, A> tup);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> toSeq(ValueTuple`7<A, A, A, A, A, A, A> tup);
    [PureAttribute]
public static AtomSeq`1<A> AtomSeq();
    [PureAttribute]
public static AtomSeq`1<A> AtomSeq(A[] items);
    [PureAttribute]
public static AtomSeq`1<A> AtomSeq(Seq`1<A> items);
    [PureAttribute]
public static AtomSeq`1<A> AtomSeq(IEnumerable`1<A> items);
    [ExtensionAttribute]
public static Patch`2<EqA, A> Diff(IEnumerable`1<A> va, IEnumerable`1<A> vb);
    [ExtensionAttribute]
public static IEnumerable`1<A> Apply(IEnumerable`1<A> va, Patch`2<EqA, A> patch);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Lst`1<A> Apply(Lst`1<A> va, Patch`2<EqA, A> patch);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Seq`1<A> Apply(Seq`1<A> va, Patch`2<EqA, A> patch);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static SpanArray`1<A> Apply(SpanArray`1<A> va, Patch`2<EqA, A> patch);
    [ExtensionAttribute]
public static A[] Apply(A[] va, Patch`2<EqA, A> patch);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Arr`1<A> Apply(Arr`1<A> va, Patch`2<EqA, A> patch);
    [ExtensionAttribute]
public static List`1<A> Apply(List`1<A> va, Patch`2<EqA, A> patch);
    [ExtensionAttribute]
public static bool Applicable(IEnumerable`1<A> va, Patch`2<EqA, A> patch);
    [NullableContextAttribute("2")]
public static Lens`2<A, C> lens(Lens`2<A, B> la, Lens`2<B, C> lb);
    [NullableContextAttribute("2")]
public static Lens`2<A, D> lens(Lens`2<A, B> la, Lens`2<B, C> lb, Lens`2<C, D> lc);
    [NullableContextAttribute("2")]
public static Lens`2<A, E> lens(Lens`2<A, B> la, Lens`2<B, C> lb, Lens`2<C, D> lc, Lens`2<D, E> ld);
    [NullableContextAttribute("2")]
public static Lens`2<A, F> lens(Lens`2<A, B> la, Lens`2<B, C> lb, Lens`2<C, D> lc, Lens`2<D, E> ld, Lens`2<E, F> le);
    [NullableContextAttribute("2")]
public static Lens`2<A, G> lens(Lens`2<A, B> la, Lens`2<B, C> lb, Lens`2<C, D> lc, Lens`2<D, E> ld, Lens`2<E, F> le, Lens`2<F, G> lf);
    [NullableContextAttribute("2")]
public static Lens`2<A, H> lens(Lens`2<A, B> la, Lens`2<B, C> lb, Lens`2<C, D> lc, Lens`2<D, E> ld, Lens`2<E, F> le, Lens`2<F, G> lf, Lens`2<G, H> lg);
    [NullableContextAttribute("2")]
public static Lens`2<A, I> lens(Lens`2<A, B> la, Lens`2<B, C> lb, Lens`2<C, D> lc, Lens`2<D, E> ld, Lens`2<E, F> le, Lens`2<F, G> lf, Lens`2<G, H> lg, Lens`2<H, I> lh);
    [NullableContextAttribute("2")]
public static Lens`2<A, J> lens(Lens`2<A, B> la, Lens`2<B, C> lb, Lens`2<C, D> lc, Lens`2<D, E> ld, Lens`2<E, F> le, Lens`2<F, G> lf, Lens`2<G, H> lg, Lens`2<H, I> lh, Lens`2<I, J> li);
    [NullableContextAttribute("2")]
public static Lens`2<A, K> lens(Lens`2<A, B> la, Lens`2<B, C> lb, Lens`2<C, D> lc, Lens`2<D, E> ld, Lens`2<E, F> le, Lens`2<F, G> lf, Lens`2<G, H> lg, Lens`2<H, I> lh, Lens`2<I, J> li, Lens`2<J, K> lj);
    [PureAttribute]
public static Either`2<L, R> Right(R value);
    [PureAttribute]
public static Pure`1<R> Right(R value);
    [PureAttribute]
public static Either`2<L, R> Left(L value);
    [PureAttribute]
public static Fail`1<L> Left(L value);
    [PureAttribute]
public static Either`2<L, R> flatten(Either`2<L, Either`2<L, R>> ma);
    [PureAttribute]
public static Either`2<L, R> plus(Either`2<L, R> x, Either`2<L, R> y);
    [PureAttribute]
public static Either`2<L, R> subtract(Either`2<L, R> x, Either`2<L, R> y);
    [PureAttribute]
public static Either`2<L, R> product(Either`2<L, R> x, Either`2<L, R> y);
    [PureAttribute]
public static Either`2<L, R> divide(Either`2<L, R> x, Either`2<L, R> y);
    [PureAttribute]
public static Either`2<L, B> apply(Either`2<L, Func`2<A, B>> fab, Either`2<L, A> fa);
    [PureAttribute]
public static Either`2<L, C> apply(Either`2<L, Func`3<A, B, C>> fabc, Either`2<L, A> fa, Either`2<L, B> fb);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Either`2<L, Func`2<B, C>> apply(Either`2<L, Func`3<A, B, C>> fabc, Either`2<L, A> fa);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Either`2<L, Func`2<B, C>> apply(Either`2<L, Func`2<A, Func`2<B, C>>> fabc, Either`2<L, A> fa);
    [PureAttribute]
public static Either`2<L, B> action(Either`2<L, A> fa, Either`2<L, B> fb);
    [NullableContextAttribute("2")]
[PureAttribute]
public static bool isRight(Either`2<L, R> value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static bool isLeft(Either`2<L, R> value);
    [PureAttribute]
public static R ifLeft(Either`2<L, R> either, Func`1<R> Left);
    [PureAttribute]
public static R ifLeft(Either`2<L, R> either, Func`2<L, R> leftMap);
    [PureAttribute]
public static R ifLeft(Either`2<L, R> either, R rightValue);
    [PureAttribute]
public static Unit ifLeft(Either`2<L, R> either, Action`1<L> Left);
    [PureAttribute]
public static Unit ifRight(Either`2<L, R> either, Action`1<R> Right);
    [PureAttribute]
public static L ifRight(Either`2<L, R> either, L leftValue);
    [PureAttribute]
public static L ifRight(Either`2<L, R> either, Func`1<L> Left);
    [PureAttribute]
public static L ifRight(Either`2<L, R> either, Func`2<R, L> leftMap);
    [PureAttribute]
public static Ret match(Either`2<L, R> either, Func`2<L, Ret> Left, Func`2<R, Ret> Right);
    public static Unit match(Either`2<L, R> either, Action`1<L> Left, Action`1<R> Right);
    [PureAttribute]
public static S bifold(Either`2<L, R> either, S state, Func`3<S, L, S> Left, Func`3<S, R, S> Right);
    [PureAttribute]
public static bool forall(Either`2<L, R> either, Func`2<R, bool> pred);
    [PureAttribute]
public static bool biforall(Either`2<L, R> either, Func`2<L, bool> Left, Func`2<R, bool> Right);
    [NullableContextAttribute("2")]
[PureAttribute]
public static int count(Either`2<L, R> either);
    [PureAttribute]
public static bool exists(Either`2<L, R> either, Func`2<R, bool> pred);
    [PureAttribute]
public static Either`2<L, Ret> map(Either`2<L, R> either, Func`2<R, Ret> mapper);
    [PureAttribute]
public static Either`2<LRet, RRet> bimap(Either`2<L, R> either, Func`2<L, LRet> Left, Func`2<R, RRet> Right);
    [PureAttribute]
public static Either`2<L, Ret> bind(Either`2<L, R> either, Func`2<R, Either`2<L, Ret>> binder);
    [ExtensionAttribute]
[PureAttribute]
public static Iterable`1<Ret> Match(IEnumerable`1<Either`2<L, R>> list, Func`2<R, Ret> Right, Func`2<L, Ret> Left);
    [PureAttribute]
public static Iterable`1<Ret> match(IEnumerable`1<Either`2<L, R>> list, Func`2<R, Ret> Right, Func`2<L, Ret> Left);
    [NullableContextAttribute("2")]
[PureAttribute]
[ObsoleteAttribute("Use ToList() instead")]
public static Lst`1<R> rightToList(Either`2<L, R> either);
    [NullableContextAttribute("2")]
[PureAttribute]
[ObsoleteAttribute("Use ToArray() instead")]
public static Arr`1<R> rightToArray(Either`2<L, R> either);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Lst`1<L> leftToList(Either`2<L, R> either);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Arr`1<L> leftToArray(Either`2<L, R> either);
    [PureAttribute]
public static Iterable`1<L> lefts(IEnumerable`1<Either`2<L, R>> self);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<L> lefts(Seq`1<Either`2<L, R>> self);
    [PureAttribute]
public static Iterable`1<R> rights(IEnumerable`1<Either`2<L, R>> self);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<R> rights(Seq`1<Either`2<L, R>> self);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`2<Iterable`1<L>, Iterable`1<R>> partition(IEnumerable`1<Either`2<L, R>> self);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`2<Seq`1<L>, Seq`1<R>> partition(Seq`1<Either`2<L, R>> self);
    [PureAttribute]
public static Fin`1<R> flatten(Fin`1<Fin`1<R>> ma);
    [PureAttribute]
public static Fin`1<R> plus(Fin`1<R> x, Fin`1<R> y);
    [PureAttribute]
public static Fin`1<R> subtract(Fin`1<R> x, Fin`1<R> y);
    [PureAttribute]
public static Fin`1<R> product(Fin`1<R> x, Fin`1<R> y);
    [PureAttribute]
public static Fin`1<R> divide(Fin`1<R> x, Fin`1<R> y);
    [PureAttribute]
public static Fin`1<B> apply(Fin`1<Func`2<A, B>> fab, Fin`1<A> fa);
    [PureAttribute]
public static Fin`1<B> apply(Func`2<A, B> fab, Fin`1<A> fa);
    [PureAttribute]
public static Fin`1<C> apply(Fin`1<Func`3<A, B, C>> fabc, Fin`1<A> fa, Fin`1<B> fb);
    [PureAttribute]
public static Fin`1<C> apply(Func`3<A, B, C> fabc, Fin`1<A> fa, Fin`1<B> fb);
    [PureAttribute]
public static Fin`1<Func`2<B, C>> apply(Fin`1<Func`3<A, B, C>> fabc, Fin`1<A> fa);
    [PureAttribute]
public static Fin`1<Func`2<B, C>> apply(Func`3<A, B, C> fabc, Fin`1<A> fa);
    [PureAttribute]
public static Fin`1<Func`2<B, C>> apply(Fin`1<Func`2<A, Func`2<B, C>>> fabc, Fin`1<A> fa);
    [PureAttribute]
public static Fin`1<Func`2<B, C>> apply(Func`2<A, Func`2<B, C>> fabc, Fin`1<A> fa);
    [PureAttribute]
public static Fin`1<B> action(Fin`1<A> fa, Fin`1<B> fb);
    [PureAttribute]
public static bool isSucc(Fin`1<A> value);
    [PureAttribute]
public static bool isFail(Fin`1<A> value);
    [PureAttribute]
public static Fin`1<A> FinSucc(A value);
    [PureAttribute]
public static Fin`1<A> FinFail(Error value);
    [PureAttribute]
public static A ifFail(Fin`1<A> ma, Func`2<Error, A> Fail);
    [PureAttribute]
public static A ifFail(Fin`1<A> ma, A alternative);
    [PureAttribute]
public static Unit ifFail(Fin`1<A> ma, Action`1<Error> Left);
    [PureAttribute]
public static Unit ifSucc(Fin`1<A> ma, Action`1<A> Succ);
    [PureAttribute]
public static B match(Fin`1<A> ma, Func`2<A, B> Succ, Func`2<Error, B> Fail);
    public static Unit match(Fin`1<A> ma, Action`1<A> Succ, Action`1<Error> Fail);
    [PureAttribute]
public static S bifold(Fin`1<A> ma, S state, Func`3<S, A, S> Right, Func`3<S, Error, S> Left);
    [PureAttribute]
public static bool forall(Fin`1<A> ma, Func`2<A, bool> pred);
    [PureAttribute]
public static bool exists(Fin`1<A> ma, Func`2<A, bool> pred);
    [PureAttribute]
public static Fin`1<B> map(Fin`1<A> ma, Func`2<A, B> f);
    [PureAttribute]
public static Fin`1<B> bimap(Fin`1<A> ma, Func`2<A, B> Succ, Func`2<Error, Error> Fail);
    [PureAttribute]
public static Fin`1<B> bind(Fin`1<A> ma, Func`2<A, Fin`1<B>> f);
    [ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<B> Match(IEnumerable`1<Fin`1<A>> xs, Func`2<A, B> Succ, Func`2<Error, B> Fail);
    [IteratorStateMachineAttribute("LanguageExt.Prelude/<match>d__580`2")]
[PureAttribute]
public static IEnumerable`1<B> match(IEnumerable`1<Fin`1<A>> xs, Func`2<A, B> Succ, Func`2<Error, B> Fail);
    [PureAttribute]
public static IEnumerable`1<A> succs(IEnumerable`1<Fin`1<A>> xs);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> succs(Seq`1<Fin`1<A>> xs);
    [PureAttribute]
public static IEnumerable`1<Error> fails(IEnumerable`1<Fin`1<A>> xs);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<Error> fails(Seq`1<Fin`1<A>> xs);
    [PureAttribute]
public static ValueTuple`2<IEnumerable`1<Error>, IEnumerable`1<A>> partition(IEnumerable`1<Fin`1<A>> xs);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`2<Seq`1<Error>, Seq`1<A>> partition(Seq`1<Fin`1<A>> xs);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<T> toOption(Nullable`1<T> self);
    [NullableContextAttribute("0")]
[PureAttribute]
public static R match(Nullable`1<T> self, Func`2<T, R> Some, Func`1<R> None);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("LanguageExt.Prelude/<matchAsync>d__589`2")]
public static Task`1<R> matchAsync(Nullable`1<T> self, Func`2<T, Task`1<R>> Some, Func`1<R> None);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("LanguageExt.Prelude/<matchAsync>d__590`2")]
public static Task`1<R> matchAsync(Nullable`1<T> self, Func`2<T, Task`1<R>> Some, Func`1<Task`1<R>> None);
    [NullableContextAttribute("0")]
public static Unit match(Nullable`1<T> self, Action`1<T> Some, Action None);
    [NullableContextAttribute("0")]
public static Unit ifSome(Nullable`1<T> self, Action`1<T> someHandler);
    [NullableContextAttribute("0")]
public static Unit ifSome(Nullable`1<T> self, Func`2<T, Unit> someHandler);
    [NullableContextAttribute("0")]
[PureAttribute]
public static T ifNone(Nullable`1<T> self, Func`1<T> None);
    [NullableContextAttribute("0")]
[PureAttribute]
public static T ifNone(Nullable`1<T> self, T noneValue);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Either`2<L, T> toEither(Nullable`1<T> self, L defaultLeftValue);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Either`2<L, T> toEither(Nullable`1<T> self, Func`1<L> Left);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Nullable`1<T> append(Nullable`1<T> lhs, Nullable`1<T> rhs);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Nullable`1<T> plus(Nullable`1<T> lhs, Nullable`1<T> rhs);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Nullable`1<T> subtract(Nullable`1<T> lhs, Nullable`1<T> rhs);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Nullable`1<T> product(Nullable`1<T> lhs, Nullable`1<T> rhs);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Nullable`1<T> divide(Nullable`1<T> lhs, Nullable`1<T> rhs);
    [NullableContextAttribute("0")]
[IteratorStateMachineAttribute("LanguageExt.Prelude/<somes>d__603`1")]
[PureAttribute]
public static IEnumerable`1<T> somes(IEnumerable`1<Nullable`1<T>> self);
    [NullableContextAttribute("0")]
public static Unit iter(Nullable`1<T> self, Action`1<T> action);
    [NullableContextAttribute("0")]
[PureAttribute]
public static int count(Nullable`1<T> self);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool forall(Nullable`1<T> self, Func`2<T, bool> pred);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool forall(Nullable`1<T> self, Func`2<T, bool> Some, Func`1<bool> None);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool exists(Nullable`1<T> self, Func`2<T, bool> pred);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool exists(Nullable`1<T> self, Func`2<T, bool> Some, Func`1<bool> None);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Nullable`1<R> map(Nullable`1<T> self, Func`2<T, R> mapper);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Nullable`1<R> map(Nullable`1<T> self, Func`2<T, R> Some, Func`1<R> None);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Nullable`1<T> filter(Nullable`1<T> self, Func`2<T, bool> pred);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Nullable`1<T> filter(Nullable`1<T> self, Func`2<T, bool> Some, Func`1<bool> None);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Nullable`1<R> bind(Nullable`1<T> self, Func`2<T, Nullable`1<R>> binder);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Nullable`1<R> bind(Nullable`1<T> self, Func`2<T, Nullable`1<R>> Some, Func`1<Nullable`1<R>> None);
    [PureAttribute]
public static int sum(Nullable`1<int> self);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Option`1<A> flatten(Option`1<Option`1<A>> ma);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<T> subtract(Option`1<T> lhs, Option`1<T> rhs);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<T> product(Option`1<T> lhs, Option`1<T> rhs);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<T> divide(Option`1<T> lhs, Option`1<T> rhs);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<T> add(Option`1<T> lhs, Option`1<T> rhs);
    [NullableContextAttribute("2")]
[PureAttribute]
public static bool isSome(Option`1<T> value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static bool isNone(Option`1<T> value);
    [NullableContextAttribute("0")]
public static Fail`1<Unit> get_None();
    [PureAttribute]
public static Option`1<A> Some(A value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<A> Some(Nullable`1<A> value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Option`1<A> Optional(A value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<A> Optional(Nullable`1<A> value);
    public static Unit ifSome(Option`1<T> option, Action`1<T> Some);
    [PureAttribute]
public static T ifNone(Option`1<T> option, Func`1<T> None);
    [PureAttribute]
public static T ifNone(Option`1<T> option, T noneValue);
    [PureAttribute]
public static R match(Option`1<T> option, Func`2<T, R> Some, Func`1<R> None);
    public static Unit match(Option`1<T> option, Action`1<T> Some, Action None);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Option`1<B> apply(Option`1<Func`2<A, B>> fab, Option`1<A> fa);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Option`1<C> apply(Option`1<Func`3<A, B, C>> fabc, Option`1<A> fa, Option`1<B> fb);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Option`1<Func`2<B, C>> apply(Option`1<Func`3<A, B, C>> fabc, Option`1<A> fa);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Option`1<Func`2<B, C>> apply(Option`1<Func`2<A, Func`2<B, C>>> fabc, Option`1<A> fa);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Option`1<B> action(Option`1<A> fa, Option`1<B> fb);
    [PureAttribute]
public static S bifold(Option`1<A> option, S state, Func`3<S, A, S> Some, Func`2<S, S> None);
    [PureAttribute]
public static S bifold(Option`1<A> option, S state, Func`3<S, A, S> Some, Func`3<S, Unit, S> None);
    [PureAttribute]
public static bool forall(Option`1<A> option, Func`2<A, bool> pred);
    [PureAttribute]
public static bool biforall(Option`1<A> option, Func`2<A, bool> Some, Func`2<Unit, bool> None);
    [PureAttribute]
public static bool biforall(Option`1<A> option, Func`2<A, bool> Some, Func`1<bool> None);
    [NullableContextAttribute("2")]
[PureAttribute]
public static int count(Option`1<A> option);
    [PureAttribute]
public static bool exists(Option`1<A> option, Func`2<A, bool> pred);
    [PureAttribute]
public static bool biexists(Option`1<A> option, Func`2<A, bool> Some, Func`2<Unit, bool> None);
    [PureAttribute]
public static bool biexists(Option`1<A> option, Func`2<A, bool> Some, Func`1<bool> None);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Option`1<B> map(Option`1<A> option, Func`2<A, B> f);
    [PureAttribute]
public static Option`1<B> bimap(Option`1<A> option, Func`2<A, B> Some, Func`1<B> None);
    [PureAttribute]
public static Option`1<B> bimap(Option`1<A> option, Func`2<A, B> Some, Func`2<Unit, B> None);
    [PureAttribute]
public static Option`1<T> filter(Option`1<T> option, Func`2<T, bool> pred);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Option`1<R> bind(Option`1<T> option, Func`2<T, Option`1<R>> binder);
    [PureAttribute]
public static IEnumerable`1<R> match(IEnumerable`1<Option`1<T>> list, Func`2<T, IEnumerable`1<R>> Some, Func`1<IEnumerable`1<R>> None);
    [PureAttribute]
public static IEnumerable`1<R> match(IEnumerable`1<Option`1<T>> list, Func`2<T, IEnumerable`1<R>> Some, IEnumerable`1<R> None);
    [PureAttribute]
public static IEnumerable`1<T> somes(IEnumerable`1<Option`1<T>> list);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Lst`1<T> toList(Option`1<T> option);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Arr`1<T> toArray(Option`1<T> option);
    public static Validation`2<F, A> Success(A value);
    public static Validation`2<F, A> Fail(F value);
    public static Validation`2<F, A> Fail(Seq`1<F> values);
    public static Lift`1<Unit> lift(Action action);
    public static Lift`1<A> lift(Func`1<A> function);
    public static Lift`2<A, B> lift(Func`2<A, B> function);
    public static IO`1<Unit> liftIO(Func`1<Task> action);
    public static IO`1<Unit> liftIO(Func`2<EnvIO, Task> action);
    public static IO`1<A> liftIO(Func`1<Task`1<A>> function);
    public static IO`1<A> liftIO(Func`2<EnvIO, Task`1<A>> function);
    public static OptionT`2<IO, A> liftIO(Option`1<A> ma);
    public static OptionT`2<IO, A> liftIO(Task`1<Option`1<A>> ma);
    public static EitherT`3<L, IO, A> liftIO(Either`2<L, A> ma);
    public static EitherT`3<L, IO, A> liftIO(Task`1<Either`2<L, A>> ma);
    public static FinT`2<IO, A> liftIO(Task`1<Fin`1<A>> ma);
    public static ValidationT`3<L, IO, A> liftIO(Validation`2<L, A> ma);
    public static ValidationT`3<L, IO, A> liftIO(Task`1<Validation`2<L, A>> ma);
    public static K`2<T, A> liftIO(IO`1<A> ma);
    [PureAttribute]
public static K`2<F, Unit> guard(bool flag);
    [PureAttribute]
public static Guard`2<E, Unit> guard(bool flag, Func`1<E> False);
    [PureAttribute]
public static Guard`2<E, Unit> guard(bool flag, E False);
    [PureAttribute]
public static Guard`2<Error, Unit> guard(bool flag, Func`1<Error> False);
    [PureAttribute]
public static Guard`2<Error, Unit> guard(bool flag, Error False);
    [PureAttribute]
public static Guard`2<E, Unit> guardnot(bool flag, Func`1<E> True);
    [PureAttribute]
public static Guard`2<E, Unit> guardnot(bool flag, E True);
    [PureAttribute]
public static Guard`2<Error, Unit> guardnot(bool flag, Func`1<Error> True);
    [PureAttribute]
public static Guard`2<Error, Unit> guardnot(bool flag, Error True);
    [PureAttribute]
public static K`2<M, A> iff(K`2<M, bool> Pred, K`2<M, A> Then, K`2<M, A> Else);
    [PureAttribute]
public static K`2<M, A> iff(K`2<M, bool> Pred, K`2<M, A> Then, K`2<IO, A> Else);
    [PureAttribute]
public static K`2<M, A> iff(K`2<M, bool> Pred, K`2<IO, A> Then, K`2<M, A> Else);
    [PureAttribute]
public static K`2<M, A> iff(K`2<M, bool> Pred, K`2<IO, A> Then, K`2<IO, A> Else);
    [PureAttribute]
public static K`2<M, A> iff(K`2<M, bool> Pred, K`2<M, A> Then, Pure`1<A> Else);
    [PureAttribute]
public static K`2<M, A> iff(K`2<M, bool> Pred, Pure`1<A> Then, K`2<M, A> Else);
    [PureAttribute]
public static K`2<M, A> iff(K`2<M, bool> Pred, Pure`1<A> Then, Pure`1<A> Else);
    [PureAttribute]
public static K`2<M, A> iff(K`2<M, bool> Pred, Pure`1<A> Then, K`2<IO, A> Else);
    [PureAttribute]
public static K`2<M, A> iff(K`2<M, bool> Pred, K`2<IO, A> Then, Pure`1<A> Else);
    public static K`2<F, A> iff(bool Pred, K`2<F, A> Then, K`2<F, A> Else);
    [PureAttribute]
public static K`2<F, Unit> unless(bool flag, K`2<F, Unit> alternative);
    [PureAttribute]
public static K`2<M, Unit> unless(K`2<M, bool> Pred, K`2<M, Unit> Then);
    [PureAttribute]
public static K`2<M, Unit> unless(K`2<M, bool> Pred, K`2<IO, Unit> Then);
    [PureAttribute]
public static K`2<M, Unit> unless(K`2<M, bool> Pred, Pure`1<Unit> Then);
    [PureAttribute]
public static K`2<F, Unit> when(bool flag, K`2<F, Unit> alternative);
    [PureAttribute]
public static K`2<M, Unit> when(K`2<M, bool> Pred, K`2<M, Unit> Then);
    [PureAttribute]
public static K`2<M, Unit> when(K`2<M, bool> Pred, K`2<IO, Unit> Then);
    [PureAttribute]
public static K`2<M, Unit> when(K`2<M, bool> Pred, Pure`1<Unit> Then);
    public static Identity`1<A> Id(A value);
    public static Pure`1<A> Pure(A value);
    public static Fail`1<E> Fail(E error);
    public static K`2<F, A> pure(A value);
    public static K`2<F, A> fail(E error);
    public static K`2<F, Unit> fail(E error);
    public static K`2<F, A> error(Error error);
    public static K`2<F, Unit> error(Error error);
    public static Writer`2<W, Unit> tell(W item);
    public static Writer`2<W, A> write(ValueTuple`2<A, W> item);
    public static Writer`2<W, A> write(A value, W item);
    public static Writer`2<W, A> pass(Writer`2<W, ValueTuple`2<A, Func`2<W, W>>> action);
    public static Writer`2<W, ValueTuple`2<A, W>> listen(Writer`2<W, A> ma);
    public static Writer`2<W, ValueTuple`2<A, B>> listens(Func`2<W, B> f, Writer`2<W, A> ma);
    public static Writer`2<W, A> censor(Func`2<W, W> f, Writer`2<W, A> ma);
    public static K`2<F, A> actions(K`2[] ms);
    public static K`2<F, A> actions(IEnumerable`1<K`2<F, A>> ms);
    public static K`2<F, A> actions(Seq`1<K`2<F, A>> ms);
    public static CatchM`3<Error, M, A> catchOf(Func`2<E, K`2<M, A>> Fail);
    public static CatchM`3<Error, M, A> catchOfFold(Func`2<E, K`2<M, A>> Fail);
    public static CatchM`3<Error, M, A> catch(Error error, Func`2<Error, K`2<M, A>> Fail);
    public static CatchM`3<Error, M, A> catch(Error error, K`2<M, A> Fail);
    public static CatchM`3<Error, M, A> catch(int errorCode, Func`2<Error, K`2<M, A>> Fail);
    public static CatchM`3<Error, M, A> catch(int errorCode, K`2<M, A> Fail);
    public static CatchM`3<Error, M, A> catch(Func`2<Error, bool> predicate, Func`2<Error, K`2<M, A>> Fail);
    public static CatchM`3<Error, M, A> catch(Func`2<Error, bool> predicate, K`2<M, A> Fail);
    public static CatchM`3<Error, M, A> catch(Func`2<Error, K`2<M, A>> Fail);
    public static CatchM`3<Error, M, A> catch(K`2<M, A> Fail);
    public static CatchM`3<Error, M, A> expected(Func`2<Expected, K`2<M, A>> Fail);
    public static CatchM`3<Error, M, A> expectedOf(Func`2<E, K`2<M, A>> Fail);
    public static CatchM`3<Error, M, A> exceptional(Func`2<Exceptional, K`2<M, A>> Fail);
    public static CatchM`3<Error, M, A> exceptionalOf(Func`2<E, K`2<M, A>> Fail);
    public static CatchM`3<Error, M, A> expectedFold(Func`2<Expected, K`2<M, A>> Fail);
    public static CatchM`3<Error, M, A> expectedOfFold(Func`2<E, K`2<M, A>> Fail);
    public static CatchM`3<Error, M, A> exceptionalFold(Func`2<Exceptional, K`2<M, A>> Fail);
    public static CatchM`3<Error, M, A> exceptionalOfFold(Func`2<E, K`2<M, A>> Fail);
    internal static CatchM`3<E, M, A> matchError(Func`2<E, bool> predicate, Func`2<E, K`2<M, A>> Fail);
    internal static CatchM`3<E, M, A> matchError(Func`2<E, bool> predicate, Func`2<E, K`2<IO, A>> Fail);
    public static CatchM`3<E, M, A> catch(E error, Func`2<E, K`2<M, A>> Fail);
    public static CatchM`3<E, M, A> catch(E error, K`2<M, A> Fail);
    public static CatchM`3<E, M, A> catch(Func`2<E, bool> predicate, Func`2<E, K`2<M, A>> Fail);
    public static CatchM`3<E, M, A> catch(Func`2<E, bool> predicate, K`2<M, A> Fail);
    public static CatchM`3<E, M, A> catch(Func`2<E, K`2<M, A>> Fail);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`2<T1, Func`2<T2, R>> curry(Func`3<T1, T2, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`2<T1, Func`2<T2, Func`2<T3, R>>> curry(Func`4<T1, T2, T3, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`2<T1, Func`2<T2, Func`2<T3, Func`2<T4, R>>>> curry(Func`5<T1, T2, T3, T4, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`2<T1, Func`2<T2, Func`2<T3, Func`2<T4, Func`2<T5, R>>>>> curry(Func`6<T1, T2, T3, T4, T5, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`2<T1, Func`2<T2, Func`2<T3, Func`2<T4, Func`2<T5, Func`2<T6, R>>>>>> curry(Func`7<T1, T2, T3, T4, T5, T6, R> func);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`2<T1, Func`2<T2, Func`2<T3, Func`2<T4, Func`2<T5, Func`2<T6, Func`2<T7, R>>>>>>> curry(Func`8<T1, T2, T3, T4, T5, T6, T7, R> func);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`2<T1, Func`2<T2, Func`2<T3, Func`2<T4, Func`2<T5, Func`2<T6, Func`2<T7, Func`2<T8, R>>>>>>>> curry(Func`9<T1, T2, T3, T4, T5, T6, T7, T8, R> func);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`2<T1, Func`2<T2, Func`2<T3, Func`2<T4, Func`2<T5, Func`2<T6, Func`2<T7, Func`2<T8, Func`2<T9, R>>>>>>>>> curry(Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> func);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`2<T1, Func`2<T2, Func`2<T3, Func`2<T4, Func`2<T5, Func`2<T6, Func`2<T7, Func`2<T8, Func`2<T9, Func`2<T10, R>>>>>>>>>> curry(Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> func);
    [PureAttribute]
public static Func`2<T1, R> lpar(Func`3<T1, T2, R> func, T2 b);
    [PureAttribute]
public static Func`2<T2, R> par(Func`3<T1, T2, R> func, T1 a);
    [PureAttribute]
public static Func`2<T3, R> par(Func`4<T1, T2, T3, R> func, T1 a, T2 b);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`3<T2, T3, R> par(Func`4<T1, T2, T3, R> func, T1 a);
    [PureAttribute]
public static Func`2<T4, R> par(Func`5<T1, T2, T3, T4, R> func, T1 a, T2 b, T3 c);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`3<T3, T4, R> par(Func`5<T1, T2, T3, T4, R> func, T1 a, T2 b);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`4<T2, T3, T4, R> par(Func`5<T1, T2, T3, T4, R> func, T1 a);
    [PureAttribute]
public static Func`2<T5, R> par(Func`6<T1, T2, T3, T4, T5, R> func, T1 a, T2 b, T3 c, T4 d);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`3<T4, T5, R> par(Func`6<T1, T2, T3, T4, T5, R> func, T1 a, T2 b, T3 c);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`4<T3, T4, T5, R> par(Func`6<T1, T2, T3, T4, T5, R> func, T1 a, T2 b);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`5<T2, T3, T4, T5, R> par(Func`6<T1, T2, T3, T4, T5, R> func, T1 a);
    [PureAttribute]
public static Func`2<T6, R> par(Func`7<T1, T2, T3, T4, T5, T6, R> func, T1 a, T2 b, T3 c, T4 d, T5 e);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`3<T5, T6, R> par(Func`7<T1, T2, T3, T4, T5, T6, R> func, T1 a, T2 b, T3 c, T4 d);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`4<T4, T5, T6, R> par(Func`7<T1, T2, T3, T4, T5, T6, R> func, T1 a, T2 b, T3 c);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`5<T3, T4, T5, T6, R> par(Func`7<T1, T2, T3, T4, T5, T6, R> func, T1 a, T2 b);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`6<T2, T3, T4, T5, T6, R> par(Func`7<T1, T2, T3, T4, T5, T6, R> func, T1 a);
    [PureAttribute]
public static Func`2<T7, R> par(Func`8<T1, T2, T3, T4, T5, T6, T7, R> func, T1 a, T2 b, T3 c, T4 d, T5 e, T6 f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`3<T6, T7, R> par(Func`8<T1, T2, T3, T4, T5, T6, T7, R> func, T1 a, T2 b, T3 c, T4 d, T5 e);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`4<T5, T6, T7, R> par(Func`8<T1, T2, T3, T4, T5, T6, T7, R> func, T1 a, T2 b, T3 c, T4 d);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`5<T4, T5, T6, T7, R> par(Func`8<T1, T2, T3, T4, T5, T6, T7, R> func, T1 a, T2 b, T3 c);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`6<T3, T4, T5, T6, T7, R> par(Func`8<T1, T2, T3, T4, T5, T6, T7, R> func, T1 a, T2 b);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`7<T2, T3, T4, T5, T6, T7, R> par(Func`8<T1, T2, T3, T4, T5, T6, T7, R> func, T1 a);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`8<T2, T3, T4, T5, T6, T7, T8, R> par(Func`9<T1, T2, T3, T4, T5, T6, T7, T8, R> func, T1 a);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`7<T3, T4, T5, T6, T7, T8, R> par(Func`9<T1, T2, T3, T4, T5, T6, T7, T8, R> func, T1 a, T2 b);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`6<T4, T5, T6, T7, T8, R> par(Func`9<T1, T2, T3, T4, T5, T6, T7, T8, R> func, T1 a, T2 b, T3 c);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`5<T5, T6, T7, T8, R> par(Func`9<T1, T2, T3, T4, T5, T6, T7, T8, R> func, T1 a, T2 b, T3 c, T4 d);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`4<T6, T7, T8, R> par(Func`9<T1, T2, T3, T4, T5, T6, T7, T8, R> func, T1 a, T2 b, T3 c, T4 d, T5 e);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`3<T7, T8, R> par(Func`9<T1, T2, T3, T4, T5, T6, T7, T8, R> func, T1 a, T2 b, T3 c, T4 d, T5 e, T6 f);
    [PureAttribute]
public static Func`2<T8, R> par(Func`9<T1, T2, T3, T4, T5, T6, T7, T8, R> func, T1 a, T2 b, T3 c, T4 d, T5 e, T6 f, T7 g);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`9<T2, T3, T4, T5, T6, T7, T8, T9, R> par(Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> func, T1 a);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`8<T3, T4, T5, T6, T7, T8, T9, R> par(Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> func, T1 a, T2 b);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`7<T4, T5, T6, T7, T8, T9, R> par(Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> func, T1 a, T2 b, T3 c);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`6<T5, T6, T7, T8, T9, R> par(Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> func, T1 a, T2 b, T3 c, T4 d);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`5<T6, T7, T8, T9, R> par(Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> func, T1 a, T2 b, T3 c, T4 d, T5 e);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`4<T7, T8, T9, R> par(Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> func, T1 a, T2 b, T3 c, T4 d, T5 e, T6 f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`3<T8, T9, R> par(Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> func, T1 a, T2 b, T3 c, T4 d, T5 e, T6 f, T7 g);
    [PureAttribute]
public static Func`2<T9, R> par(Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> func, T1 a, T2 b, T3 c, T4 d, T5 e, T6 f, T7 g, T8 h);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`10<T2, T3, T4, T5, T6, T7, T8, T9, T10, R> par(Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> func, T1 a);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`9<T3, T4, T5, T6, T7, T8, T9, T10, R> par(Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> func, T1 a, T2 b);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`8<T4, T5, T6, T7, T8, T9, T10, R> par(Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> func, T1 a, T2 b, T3 c);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`7<T5, T6, T7, T8, T9, T10, R> par(Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> func, T1 a, T2 b, T3 c, T4 d);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`6<T6, T7, T8, T9, T10, R> par(Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> func, T1 a, T2 b, T3 c, T4 d, T5 e);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`5<T7, T8, T9, T10, R> par(Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> func, T1 a, T2 b, T3 c, T4 d, T5 e, T6 f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`4<T8, T9, T10, R> par(Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> func, T1 a, T2 b, T3 c, T4 d, T5 e, T6 f, T7 g);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`3<T9, T10, R> par(Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> func, T1 a, T2 b, T3 c, T4 d, T5 e, T6 f, T7 g, T8 h);
    [PureAttribute]
public static Func`2<T10, R> par(Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> func, T1 a, T2 b, T3 c, T4 d, T5 e, T6 f, T7 g, T8 h, T9 i);
    [PureAttribute]
public static Action`1<T2> par(Action`2<T1, T2> func, T1 a);
    [PureAttribute]
public static Action`1<T3> par(Action`3<T1, T2, T3> func, T1 a, T2 b);
    [PureAttribute]
public static Action`2<T2, T3> par(Action`3<T1, T2, T3> func, T1 a);
    [PureAttribute]
public static Action`1<T4> par(Action`4<T1, T2, T3, T4> func, T1 a, T2 b, T3 c);
    [PureAttribute]
public static Action`2<T3, T4> par(Action`4<T1, T2, T3, T4> func, T1 a, T2 b);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`3<T2, T3, T4> par(Action`4<T1, T2, T3, T4> func, T1 a);
    [PureAttribute]
public static Action`1<T5> par(Action`5<T1, T2, T3, T4, T5> func, T1 a, T2 b, T3 c, T4 d);
    [PureAttribute]
public static Action`2<T4, T5> par(Action`5<T1, T2, T3, T4, T5> func, T1 a, T2 b, T3 c);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`3<T3, T4, T5> par(Action`5<T1, T2, T3, T4, T5> func, T1 a, T2 b);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`4<T2, T3, T4, T5> par(Action`5<T1, T2, T3, T4, T5> func, T1 a);
    [PureAttribute]
public static Action`1<T6> par(Action`6<T1, T2, T3, T4, T5, T6> func, T1 a, T2 b, T3 c, T4 d, T5 e);
    [PureAttribute]
public static Action`2<T5, T6> par(Action`6<T1, T2, T3, T4, T5, T6> func, T1 a, T2 b, T3 c, T4 d);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`3<T4, T5, T6> par(Action`6<T1, T2, T3, T4, T5, T6> func, T1 a, T2 b, T3 c);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`4<T3, T4, T5, T6> par(Action`6<T1, T2, T3, T4, T5, T6> func, T1 a, T2 b);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`5<T2, T3, T4, T5, T6> par(Action`6<T1, T2, T3, T4, T5, T6> func, T1 a);
    [PureAttribute]
public static Action`1<T7> par(Action`7<T1, T2, T3, T4, T5, T6, T7> func, T1 a, T2 b, T3 c, T4 d, T5 e, T6 f);
    [PureAttribute]
public static Action`2<T6, T7> par(Action`7<T1, T2, T3, T4, T5, T6, T7> func, T1 a, T2 b, T3 c, T4 d, T5 e);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`3<T5, T6, T7> par(Action`7<T1, T2, T3, T4, T5, T6, T7> func, T1 a, T2 b, T3 c, T4 d);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`4<T4, T5, T6, T7> par(Action`7<T1, T2, T3, T4, T5, T6, T7> func, T1 a, T2 b, T3 c);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`5<T3, T4, T5, T6, T7> par(Action`7<T1, T2, T3, T4, T5, T6, T7> func, T1 a, T2 b);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`6<T2, T3, T4, T5, T6, T7> par(Action`7<T1, T2, T3, T4, T5, T6, T7> func, T1 a);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`7<T2, T3, T4, T5, T6, T7, T8> par(Action`8<T1, T2, T3, T4, T5, T6, T7, T8> func, T1 a);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`6<T3, T4, T5, T6, T7, T8> par(Action`8<T1, T2, T3, T4, T5, T6, T7, T8> func, T1 a, T2 b);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`5<T4, T5, T6, T7, T8> par(Action`8<T1, T2, T3, T4, T5, T6, T7, T8> func, T1 a, T2 b, T3 c);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`4<T5, T6, T7, T8> par(Action`8<T1, T2, T3, T4, T5, T6, T7, T8> func, T1 a, T2 b, T3 c, T4 d);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`3<T6, T7, T8> par(Action`8<T1, T2, T3, T4, T5, T6, T7, T8> func, T1 a, T2 b, T3 c, T4 d, T5 e);
    [PureAttribute]
public static Action`2<T7, T8> par(Action`8<T1, T2, T3, T4, T5, T6, T7, T8> func, T1 a, T2 b, T3 c, T4 d, T5 e, T6 f);
    [PureAttribute]
public static Action`1<T8> par(Action`8<T1, T2, T3, T4, T5, T6, T7, T8> func, T1 a, T2 b, T3 c, T4 d, T5 e, T6 f, T7 g);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`8<T2, T3, T4, T5, T6, T7, T8, T9> par(Action`9<T1, T2, T3, T4, T5, T6, T7, T8, T9> func, T1 a);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`7<T3, T4, T5, T6, T7, T8, T9> par(Action`9<T1, T2, T3, T4, T5, T6, T7, T8, T9> func, T1 a, T2 b);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`6<T4, T5, T6, T7, T8, T9> par(Action`9<T1, T2, T3, T4, T5, T6, T7, T8, T9> func, T1 a, T2 b, T3 c);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`5<T5, T6, T7, T8, T9> par(Action`9<T1, T2, T3, T4, T5, T6, T7, T8, T9> func, T1 a, T2 b, T3 c, T4 d);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`4<T6, T7, T8, T9> par(Action`9<T1, T2, T3, T4, T5, T6, T7, T8, T9> func, T1 a, T2 b, T3 c, T4 d, T5 e);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`3<T7, T8, T9> par(Action`9<T1, T2, T3, T4, T5, T6, T7, T8, T9> func, T1 a, T2 b, T3 c, T4 d, T5 e, T6 f);
    [PureAttribute]
public static Action`2<T8, T9> par(Action`9<T1, T2, T3, T4, T5, T6, T7, T8, T9> func, T1 a, T2 b, T3 c, T4 d, T5 e, T6 f, T7 g);
    [PureAttribute]
public static Action`1<T9> par(Action`9<T1, T2, T3, T4, T5, T6, T7, T8, T9> func, T1 a, T2 b, T3 c, T4 d, T5 e, T6 f, T7 g, T8 h);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`9<T2, T3, T4, T5, T6, T7, T8, T9, T10> par(Action`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> func, T1 a);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`8<T3, T4, T5, T6, T7, T8, T9, T10> par(Action`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> func, T1 a, T2 b);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`7<T4, T5, T6, T7, T8, T9, T10> par(Action`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> func, T1 a, T2 b, T3 c);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`6<T5, T6, T7, T8, T9, T10> par(Action`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> func, T1 a, T2 b, T3 c, T4 d);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`5<T6, T7, T8, T9, T10> par(Action`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> func, T1 a, T2 b, T3 c, T4 d, T5 e);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`4<T7, T8, T9, T10> par(Action`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> func, T1 a, T2 b, T3 c, T4 d, T5 e, T6 f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`3<T8, T9, T10> par(Action`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> func, T1 a, T2 b, T3 c, T4 d, T5 e, T6 f, T7 g);
    [PureAttribute]
public static Action`2<T9, T10> par(Action`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> func, T1 a, T2 b, T3 c, T4 d, T5 e, T6 f, T7 g, T8 h);
    [PureAttribute]
public static Action`1<T10> par(Action`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> func, T1 a, T2 b, T3 c, T4 d, T5 e, T6 f, T7 g, T8 h, T9 i);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Func`3<T1, T2, R> Uncurry(Func`2<T1, Func`2<T2, R>> function);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Func`4<T1, T2, T3, R> Uncurry(Func`2<T1, Func`2<T2, Func`2<T3, R>>> function);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Func`5<T1, T2, T3, T4, R> Uncurry(Func`2<T1, Func`2<T2, Func`2<T3, Func`2<T4, R>>>> function);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Func`6<T1, T2, T3, T4, T5, R> Uncurry(Func`2<T1, Func`2<T2, Func`2<T3, Func`2<T4, Func`2<T5, R>>>>> function);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Func`7<T1, T2, T3, T4, T5, T6, R> Uncurry(Func`2<T1, Func`2<T2, Func`2<T3, Func`2<T4, Func`2<T5, Func`2<T6, R>>>>>> function);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Func`8<T1, T2, T3, T4, T5, T6, T7, R> Uncurry(Func`2<T1, Func`2<T2, Func`2<T3, Func`2<T4, Func`2<T5, Func`2<T6, Func`2<T7, R>>>>>>> function);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Func`9<T1, T2, T3, T4, T5, T6, T7, T8, R> Uncurry(Func`2<T1, Func`2<T2, Func`2<T3, Func`2<T4, Func`2<T5, Func`2<T6, Func`2<T7, Func`2<T8, R>>>>>>>> function);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`3<T1, T2, R> uncurry(Func`2<T1, Func`2<T2, R>> function);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`4<T1, T2, T3, R> uncurry(Func`2<T1, Func`2<T2, Func`2<T3, R>>> function);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`5<T1, T2, T3, T4, R> uncurry(Func`2<T1, Func`2<T2, Func`2<T3, Func`2<T4, R>>>> function);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`6<T1, T2, T3, T4, T5, R> uncurry(Func`2<T1, Func`2<T2, Func`2<T3, Func`2<T4, Func`2<T5, R>>>>> function);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`7<T1, T2, T3, T4, T5, T6, R> uncurry(Func`2<T1, Func`2<T2, Func`2<T3, Func`2<T4, Func`2<T5, Func`2<T6, R>>>>>> function);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`8<T1, T2, T3, T4, T5, T6, T7, R> uncurry(Func`2<T1, Func`2<T2, Func`2<T3, Func`2<T4, Func`2<T5, Func`2<T6, Func`2<T7, R>>>>>>> function);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`9<T1, T2, T3, T4, T5, T6, T7, T8, R> uncurry(Func`2<T1, Func`2<T2, Func`2<T3, Func`2<T4, Func`2<T5, Func`2<T6, Func`2<T7, Func`2<T8, R>>>>>>>> function);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`2<B, Func`2<A, R>> flip(Func`2<A, Func`2<B, R>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`2<C, Func`2<B, Func`2<A, R>>> flip(Func`2<A, Func`2<B, Func`2<C, R>>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`3<B, A, R> flip(Func`3<A, B, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`4<C, B, A, R> flip(Func`4<A, B, C, R> f);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Func`2<B, Func`2<A, R>> Flip(Func`2<A, Func`2<B, R>> f);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Func`2<C, Func`2<B, Func`2<A, R>>> Flip(Func`2<A, Func`2<B, Func`2<C, R>>> f);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Func`3<B, A, R> Flip(Func`3<A, B, R> f);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Func`4<C, B, A, R> Flip(Func`4<A, B, C, R> f);
    [PureAttribute]
public static int hash(IEnumerable`1<A> xs);
    [PureAttribute]
public static int hash(IEnumerable`1<A> xs);
    [NullableContextAttribute("2")]
[PureAttribute]
public static int hash(Arr`1<A> xs);
    [NullableContextAttribute("2")]
[PureAttribute]
public static int hash(HashMap`2<K, V> xs);
    [NullableContextAttribute("2")]
[PureAttribute]
public static int hash(HashMap`3<EqK, K, V> xs);
    [NullableContextAttribute("2")]
[PureAttribute]
public static int hash(HashSet`1<A> xs);
    [NullableContextAttribute("0")]
[PureAttribute]
public static int hash(HashSet`2<EqA, A> xs);
    [NullableContextAttribute("2")]
[PureAttribute]
public static int hash(Lst`1<A> xs);
    [NullableContextAttribute("2")]
[PureAttribute]
public static int hash(Map`2<K, V> xs);
    [NullableContextAttribute("2")]
[PureAttribute]
public static int hash(Map`3<OrdK, K, V> xs);
    [NullableContextAttribute("2")]
[PureAttribute]
public static int hash(Que`1<A> xs);
    [NullableContextAttribute("2")]
[PureAttribute]
public static int hash(Seq`1<A> xs);
    [NullableContextAttribute("2")]
[PureAttribute]
public static int hash(Set`1<A> xs);
    [NullableContextAttribute("0")]
[PureAttribute]
public static int hash(Set`2<OrdA, A> xs);
    [NullableContextAttribute("2")]
[PureAttribute]
public static int hash(Stck`1<A> xs);
    [PureAttribute]
public static Func`1<R> fun(Func`1<R> f);
    [PureAttribute]
public static Func`2<T1, R> fun(Func`2<T1, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`3<T1, T2, R> fun(Func`3<T1, T2, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`4<T1, T2, T3, R> fun(Func`4<T1, T2, T3, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`5<T1, T2, T3, T4, R> fun(Func`5<T1, T2, T3, T4, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`6<T1, T2, T3, T4, T5, R> fun(Func`6<T1, T2, T3, T4, T5, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`7<T1, T2, T3, T4, T5, T6, R> fun(Func`7<T1, T2, T3, T4, T5, T6, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`8<T1, T2, T3, T4, T5, T6, T7, R> fun(Func`8<T1, T2, T3, T4, T5, T6, T7, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`9<T1, T2, T3, T4, T5, T6, T7, T8, R> fun(Func`9<T1, T2, T3, T4, T5, T6, T7, T8, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> fun(Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> fun(Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R> fun(Func`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R> fun(Func`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R> fun(Func`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R> fun(Func`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R> fun(Func`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R> fun(Func`17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, R> f);
    [PureAttribute]
public static Func`1<Unit> fun(Action f);
    [PureAttribute]
public static Func`2<T1, Unit> fun(Action`1<T1> f);
    [PureAttribute]
public static Func`3<T1, T2, Unit> fun(Action`2<T1, T2> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`4<T1, T2, T3, Unit> fun(Action`3<T1, T2, T3> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`5<T1, T2, T3, T4, Unit> fun(Action`4<T1, T2, T3, T4> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`6<T1, T2, T3, T4, T5, Unit> fun(Action`5<T1, T2, T3, T4, T5> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`7<T1, T2, T3, T4, T5, T6, Unit> fun(Action`6<T1, T2, T3, T4, T5, T6> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Func`8<T1, T2, T3, T4, T5, T6, T7, Unit> fun(Action`7<T1, T2, T3, T4, T5, T6, T7> f);
    [PureAttribute]
public static Action act(Action f);
    [PureAttribute]
public static Action`1<T1> act(Action`1<T1> f);
    [PureAttribute]
public static Action`2<T1, T2> act(Action`2<T1, T2> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`3<T1, T2, T3> act(Action`3<T1, T2, T3> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`4<T1, T2, T3, T4> act(Action`4<T1, T2, T3, T4> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`5<T1, T2, T3, T4, T5> act(Action`5<T1, T2, T3, T4, T5> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`6<T1, T2, T3, T4, T5, T6> act(Action`6<T1, T2, T3, T4, T5, T6> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`7<T1, T2, T3, T4, T5, T6, T7> act(Action`7<T1, T2, T3, T4, T5, T6, T7> f);
    [PureAttribute]
public static Action act(Func`1<R> f);
    [PureAttribute]
public static Action`1<T1> act(Func`2<T1, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`2<T1, T2> act(Func`3<T1, T2, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`3<T1, T2, T3> act(Func`4<T1, T2, T3, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`4<T1, T2, T3, T4> act(Func`5<T1, T2, T3, T4, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`5<T1, T2, T3, T4, T5> act(Func`6<T1, T2, T3, T4, T5, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`6<T1, T2, T3, T4, T5, T6> act(Func`7<T1, T2, T3, T4, T5, T6, R> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Action`7<T1, T2, T3, T4, T5, T6, T7> act(Func`8<T1, T2, T3, T4, T5, T6, T7, R> f);
    [PureAttribute]
public static Expression`1<Func`1<R>> expr(Expression`1<Func`1<R>> f);
    [PureAttribute]
public static Expression`1<Func`2<T1, R>> expr(Expression`1<Func`2<T1, R>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Expression`1<Func`3<T1, T2, R>> expr(Expression`1<Func`3<T1, T2, R>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Expression`1<Func`4<T1, T2, T3, R>> expr(Expression`1<Func`4<T1, T2, T3, R>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Expression`1<Func`5<T1, T2, T3, T4, R>> expr(Expression`1<Func`5<T1, T2, T3, T4, R>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Expression`1<Func`6<T1, T2, T3, T4, T5, R>> expr(Expression`1<Func`6<T1, T2, T3, T4, T5, R>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Expression`1<Func`7<T1, T2, T3, T4, T5, T6, R>> expr(Expression`1<Func`7<T1, T2, T3, T4, T5, T6, R>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Expression`1<Func`8<T1, T2, T3, T4, T5, T6, T7, R>> expr(Expression`1<Func`8<T1, T2, T3, T4, T5, T6, T7, R>> f);
    [PureAttribute]
public static Expression`1<Action> expr(Expression`1<Action> f);
    [PureAttribute]
public static Expression`1<Action`1<T1>> expr(Expression`1<Action`1<T1>> f);
    [PureAttribute]
public static Expression`1<Action`2<T1, T2>> expr(Expression`1<Action`2<T1, T2>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Expression`1<Action`3<T1, T2, T3>> expr(Expression`1<Action`3<T1, T2, T3>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Expression`1<Action`4<T1, T2, T3, T4>> expr(Expression`1<Action`4<T1, T2, T3, T4>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Expression`1<Action`5<T1, T2, T3, T4, T5>> expr(Expression`1<Action`5<T1, T2, T3, T4, T5>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Expression`1<Action`6<T1, T2, T3, T4, T5, T6>> expr(Expression`1<Action`6<T1, T2, T3, T4, T5, T6>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Expression`1<Action`7<T1, T2, T3, T4, T5, T6, T7>> expr(Expression`1<Action`7<T1, T2, T3, T4, T5, T6, T7>> f);
    [PureAttribute]
public static Func`1<T2> compose(Func`1<T1> a, Func`2<T1, T2> b);
    [PureAttribute]
public static Func`2<T1, T3> compose(Func`2<T1, T2> a, Func`2<T2, T3> b);
    [PureAttribute]
public static Func`2<T1, T4> compose(Func`2<T1, T2> a, Func`2<T2, T3> b, Func`2<T3, T4> c);
    [PureAttribute]
public static Func`2<T1, T5> compose(Func`2<T1, T2> a, Func`2<T2, T3> b, Func`2<T3, T4> c, Func`2<T4, T5> d);
    [PureAttribute]
public static Func`2<T1, T6> compose(Func`2<T1, T2> a, Func`2<T2, T3> b, Func`2<T3, T4> c, Func`2<T4, T5> d, Func`2<T5, T6> e);
    [PureAttribute]
public static Func`2<T1, T7> compose(Func`2<T1, T2> a, Func`2<T2, T3> b, Func`2<T3, T4> c, Func`2<T4, T5> d, Func`2<T5, T6> e, Func`2<T6, T7> f);
    public static Func`1<A> memo(Func`1<A> func);
    public static Func`2<A, B> memo(Func`2<A, B> func);
    public static Func`2<T, R> memoUnsafe(Func`2<T, R> func);
    public static Seq`1<T> memo(IEnumerable`1<T> seq);
    [PureAttribute]
public static A identity(A x);
    [PureAttribute]
public static Func`2<B, A> constant(A x);
    [PureAttribute]
public static A constant(A x, B _);
    [PureAttribute]
public static Func`2<A, A> constantA(A x);
    [PureAttribute]
public static A constantA(A x, A _);
    public static Action failwith(string message);
    public static R failwith(string message);
    public static R raiseapp(string message);
    public static R raise(Exception ex);
    [PureAttribute]
public static bool exceptionIs(Exception e);
    public static Func`2<A, bool> not(Func`2<A, bool> f);
    public static Func`3<A, B, bool> not(Func`3<A, B, bool> f);
    [NullableContextAttribute("2")]
public static Func`4<A, B, C, bool> not(Func`4<A, B, C, bool> f);
    public static bool not(bool value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool isDefault(A value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool notDefault(A value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool isnull(A value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool notnull(A value);
    [PureAttribute]
public static string toString(A value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static bool notEmpty(string value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static bool isEmpty(string value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`2<A1, B> mapFirst(Func`2<A, A1> f, ValueTuple`2<A, B> pair);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`2<A, B1> mapSecond(Func`2<B, B1> f, ValueTuple`2<A, B> pair);
    public static int random(int max);
    public static string randomBase64(int bytesCount);
    [PureAttribute]
public static K`2<M, A> use(K`2<M, A> acquire, Action`1<A> release);
    [PureAttribute]
public static IO`1<A> use(Func`1<A> acquire, Action`1<A> release);
    [PureAttribute]
public static IO`1<A> use(Func`1<A> acquire, Func`2<A, IO`1<Unit>> release);
    [PureAttribute]
public static K`2<M, A> use(K`2<M, A> acquire, Func`2<A, IO`1<Unit>> release);
    [PureAttribute]
public static IO`1<A> use(Func`2<EnvIO, A> acquire);
    [PureAttribute]
public static IO`1<A> use(Func`1<A> acquire);
    [PureAttribute]
public static IO`1<A> useAsync(Func`1<A> acquire);
    [PureAttribute]
public static K`2<M, A> use(K`2<M, A> acquire);
    [PureAttribute]
public static K`2<M, A> useAsync(K`2<M, A> acquire);
    [PureAttribute]
public static IO`1<Unit> release(A value);
    [PureAttribute]
public static K`2<M, A> bracketIO(K`2<M, A> computation);
    [PureAttribute]
public static K`2<M, C> bracketIO(K`2<M, A> Acq, Func`2<A, IO`1<C>> Use, Func`2<A, IO`1<B>> Fin);
    public static Unit delay(Action f, TimeSpan delayFor);
    public static Unit delay(Action f, DateTime delayUntil);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Option`1<A> convert(object value);
    [PureAttribute]
public static K`2<M, A> convert(object value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<long> parseLong(string value);
    [PureAttribute]
public static K`2<M, long> parseLong(string value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<int> parseInt(string value);
    [PureAttribute]
public static K`2<M, int> parseInt(string value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<int> parseInt(string value, int fromBase);
    [PureAttribute]
public static K`2<M, int> parseInt(string value, int fromBase);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<short> parseShort(string value);
    [PureAttribute]
public static K`2<M, short> parseShort(string value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<char> parseChar(string value);
    [PureAttribute]
public static K`2<M, char> parseChar(string value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<sbyte> parseSByte(string value);
    [PureAttribute]
public static K`2<M, sbyte> parseSByte(string value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<byte> parseByte(string value);
    [PureAttribute]
public static K`2<M, byte> parseByte(string value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<ulong> parseULong(string value);
    [PureAttribute]
public static K`2<M, ulong> parseULong(string value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<UInt32> parseUInt(string value);
    [PureAttribute]
public static K`2<M, UInt32> parseUInt(string value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<ushort> parseUShort(string value);
    [PureAttribute]
public static K`2<M, ushort> parseUShort(string value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<float> parseFloat(string value);
    [PureAttribute]
public static K`2<M, float> parseFloat(string value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<double> parseDouble(string value);
    [PureAttribute]
public static K`2<M, double> parseDouble(string value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<decimal> parseDecimal(string value);
    [PureAttribute]
public static K`2<M, decimal> parseDecimal(string value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<bool> parseBool(string value);
    [PureAttribute]
public static K`2<M, bool> parseBool(string value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<Guid> parseGuid(string value);
    [PureAttribute]
public static K`2<M, Guid> parseGuid(string value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<DateTime> parseDateTime(string value);
    [PureAttribute]
public static K`2<M, DateTime> parseDateTime(string value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<DateTimeOffset> parseDateTimeOffset(string value);
    [PureAttribute]
public static K`2<M, DateTimeOffset> parseDateTimeOffset(string value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<TimeSpan> parseTimeSpan(string value);
    [PureAttribute]
public static K`2<M, TimeSpan> parseTimeSpan(string value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<TEnum> parseEnum(string value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static K`2<M, TEnum> parseEnum(string value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<TEnum> parseEnumIgnoreCase(string value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static K`2<M, TEnum> parseEnumIgnoreCase(string value);
    [PureAttribute]
public static Option`1<IPAddress> parseIPAddress(string value);
    [PureAttribute]
public static K`2<M, IPAddress> parseIPAddress(string value);
    private static Option`1<A> Parse(TryParse`1<A> tryParse, string value);
    private static K`2<M, A> Parse(TryParse`1<A> tryParse, string value);
    private static Option`1<A> ParseIgnoreCase(TryParseIgnoreCase`1<A> tryParse, string value);
    private static K`2<M, A> ParseIgnoreCase(TryParseIgnoreCase`1<A> tryParse, string value);
    [NullableContextAttribute("2")]
public static Prism`2<A, B> prism(Lens`2<A, B> la);
    [NullableContextAttribute("2")]
public static Prism`2<A, B> prism(Lens`2<A, Option`1<B>> la);
    [NullableContextAttribute("2")]
public static Prism`2<A, C> prism(Prism`2<A, B> pa, Prism`2<B, C> pb);
    [NullableContextAttribute("2")]
public static Prism`2<A, D> prism(Prism`2<A, B> pa, Prism`2<B, C> pb, Prism`2<C, D> pc);
    [NullableContextAttribute("2")]
public static Prism`2<A, E> prism(Prism`2<A, B> pa, Prism`2<B, C> pb, Prism`2<C, D> pc, Prism`2<D, E> pd);
    [NullableContextAttribute("2")]
public static Prism`2<A, F> prism(Prism`2<A, B> pa, Prism`2<B, C> pb, Prism`2<C, D> pc, Prism`2<D, E> pd, Prism`2<E, F> pe);
    [NullableContextAttribute("2")]
public static Prism`2<A, G> prism(Prism`2<A, B> pa, Prism`2<B, C> pb, Prism`2<C, D> pc, Prism`2<D, E> pd, Prism`2<E, F> pe, Prism`2<F, G> pf);
    [NullableContextAttribute("2")]
public static Prism`2<A, H> prism(Prism`2<A, B> pa, Prism`2<B, C> pb, Prism`2<C, D> pc, Prism`2<D, E> pd, Prism`2<E, F> pe, Prism`2<F, G> pf, Prism`2<G, H> pg);
    [NullableContextAttribute("2")]
public static Prism`2<A, I> prism(Prism`2<A, B> pa, Prism`2<B, C> pb, Prism`2<C, D> pc, Prism`2<D, E> pd, Prism`2<E, F> pe, Prism`2<F, G> pf, Prism`2<G, H> pg, Prism`2<H, I> ph);
    [NullableContextAttribute("2")]
public static Prism`2<A, J> prism(Prism`2<A, B> pa, Prism`2<B, C> pb, Prism`2<C, D> pc, Prism`2<D, E> pd, Prism`2<E, F> pe, Prism`2<F, G> pf, Prism`2<G, H> pg, Prism`2<H, I> ph, Prism`2<I, J> pi);
    [NullableContextAttribute("2")]
public static Prism`2<A, K> prism(Prism`2<A, B> pa, Prism`2<B, C> pb, Prism`2<C, D> pc, Prism`2<D, E> pd, Prism`2<E, F> pe, Prism`2<F, G> pf, Prism`2<G, H> pg, Prism`2<H, I> ph, Prism`2<I, J> pi, Prism`2<J, K> pj);
    [PureAttribute]
public static bool equals(A x, A y);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool equals(Option`1<A> x, Option`1<A> y);
    [PureAttribute]
public static bool equals(Either`2<L, R> x, Either`2<L, R> y);
    [PureAttribute]
public static bool equals(Either`2<A, B> x, Either`2<A, B> y);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool equals(Nullable`1<A> mx, Nullable`1<A> my);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool equals(Lst`1<A> x, Lst`1<A> y);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool equals(HashSet`1<A> x, HashSet`1<A> y);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool equals(Que`1<A> x, Que`1<A> y);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool equals(Set`1<A> x, Set`1<A> y);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool equals(Arr`1<A> x, Arr`1<A> y);
    [PureAttribute]
public static bool equals(A[] x, A[] y);
    [PureAttribute]
public static bool equals(IEnumerable`1<A> x, IEnumerable`1<A> y);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool equals(Seq`1<A> x, Seq`1<A> y);
    public static K`2<F, Unit> ignore(K`2<F, A> fa);
    [PureAttribute]
public static K`2<F, B> map(Func`2<A, B> f, K`2<F, A> ma);
    [PureAttribute]
public static bool greaterThan(A x, A y);
    [PureAttribute]
public static bool greaterOrEq(A x, A y);
    [PureAttribute]
public static bool lessThan(A x, A y);
    [PureAttribute]
public static bool lessOrEq(A x, A y);
    [PureAttribute]
public static int compare(A x, A y);
    [NullableContextAttribute("0")]
[PureAttribute]
public static int compare(Option`1<A> x, Option`1<A> y);
    [PureAttribute]
public static int compare(Either`2<A, B> x, Either`2<A, B> y);
    [PureAttribute]
public static int compare(Validation`2<A, B> x, Validation`2<A, B> y);
    [PureAttribute]
public static int compare(A[] x, A[] y);
    [NullableContextAttribute("0")]
[PureAttribute]
public static int compare(Lst`1<A> x, Lst`1<A> y);
    [PureAttribute]
public static int compare(Either`2<L, R> x, Either`2<L, R> y);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Ask`2<Env, Env> ask();
    [NullableContextAttribute("2")]
[PureAttribute]
public static Ask`2<Env, A> asks(Func`2<Env, A> f);
    [PureAttribute]
public static A combine(A x, A y);
    [PureAttribute]
public static Either`2<L, R> combine(Either`2<L, R> lhs, Either`2<L, R> rhs);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Option`1<A> combine(Option`1<A> x, Option`1<A> y);
    [IteratorStateMachineAttribute("LanguageExt.Prelude/<combine>d__1085`1")]
[PureAttribute]
public static IEnumerable`1<A> combine(IEnumerable`1<A> x, IEnumerable`1<A> y);
    [PureAttribute]
public static K`2<M, A> combine(K`2<M, A> mx, K`2<M, A> my);
    [IteratorStateMachineAttribute("LanguageExt.Prelude/<<get_Naturals>g__Go|364_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<int> <get_Naturals>g__Go|364_0();
    [IteratorStateMachineAttribute("LanguageExt.Prelude/<<get_LongNaturals>g__Go|366_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<long> <get_LongNaturals>g__Go|366_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.AlreadyFlat`1 : FlattenResult`1<A> {
    public static FlattenResult`1<A> Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected AlreadyFlat`1(AlreadyFlat`1<A> original);
    private static AlreadyFlat`1();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual FlattenResult`1<B> Map(Func`2<A, B> f);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(AlreadyFlat`1<A> left, AlreadyFlat`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(AlreadyFlat`1<A> left, AlreadyFlat`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FlattenResult`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(AlreadyFlat`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override AlreadyFlat`1<A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Pretty.AvailablePerLine : PageWidth {
    [CompilerGeneratedAttribute]
private int <LineLength>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RibbonFraction>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public int LineLength { get; public set; }
    public double RibbonFraction { get; public set; }
    public AvailablePerLine(int LineLength, double RibbonFraction);
    [CompilerGeneratedAttribute]
protected AvailablePerLine(AvailablePerLine original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public int get_LineLength();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LineLength(int value);
    [CompilerGeneratedAttribute]
public double get_RibbonFraction();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RibbonFraction(double value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(AvailablePerLine left, AvailablePerLine right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(AvailablePerLine left, AvailablePerLine right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(PageWidth other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(AvailablePerLine other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override AvailablePerLine <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& LineLength, Double& RibbonFraction);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.Cons`1 : LayoutPipeline`1<A> {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Doc`1<A> <Doc>k__BackingField;
    [CompilerGeneratedAttribute]
private LayoutPipeline`1<A> <Pipeline>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public int Value { get; public set; }
    public Doc`1<A> Doc { get; public set; }
    public LayoutPipeline`1<A> Pipeline { get; public set; }
    public Cons`1(int Value, Doc`1<A> Doc, LayoutPipeline`1<A> Pipeline);
    [CompilerGeneratedAttribute]
protected Cons`1(Cons`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public int get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(int value);
    [CompilerGeneratedAttribute]
public Doc`1<A> get_Doc();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Doc(Doc`1<A> value);
    [CompilerGeneratedAttribute]
public LayoutPipeline`1<A> get_Pipeline();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Pipeline(LayoutPipeline`1<A> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Cons`1<A> left, Cons`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Cons`1<A> left, Cons`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(LayoutPipeline`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Cons`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override Cons`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& Value, Doc`1& Doc, LayoutPipeline`1& Pipeline);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Pretty.Doc : object {
    public static Doc`1<Unit> Fail;
    public static Doc`1<Unit> Empty;
    public static Doc`1<Unit> HardLine;
    public static Doc`1<Unit> LineOrSpace;
    public static Doc`1<Unit> LineOrEmpty;
    public static Doc`1<Unit> SoftLineOrSpace;
    public static Doc`1<Unit> SoftLineOrEmpty;
    private static Doc();
    public static Doc`1<Unit> Char(char c);
    public static Doc`1<Unit> Text(string text);
    public static Doc`1<Unit> FlatAlt(Doc`1<Unit> da, Doc`1<Unit> db);
    public static Doc`1<Unit> Union(Doc`1<Unit> da, Doc`1<Unit> db);
    public static Doc`1<Unit> Cat(Doc`1<Unit> da, Doc`1<Unit> db);
    public static Doc`1<Unit> Nest(int indent, Doc`1<Unit> doc);
    public static Doc`1<Unit> Column(Func`2<int, Doc`1<Unit>> f);
    public static Doc`1<Unit> PageWidth(Func`2<PageWidth, Doc`1<Unit>> f);
    public static Doc`1<Unit> Nesting(Func`2<int, Doc`1<Unit>> f);
    public static Doc`1<Unit> Group(Doc`1<Unit> doc);
    public static Doc`1<Unit> Align(Doc`1<Unit> doc);
    public static Doc`1<Unit> Hang(int offset, Doc`1<Unit> doc);
    public static Doc`1<Unit> Indent(int indent, Doc`1<Unit> doc);
    public static Doc`1<Unit> EncloseSep(Doc`1<Unit> leftDelim, Doc`1<Unit> rightDelim, Doc`1<Unit> sep, Seq`1<Doc`1<Unit>> docs);
    public static Doc`1<Unit> EncloseSep(Doc`1<Unit> leftDelim, Doc`1<Unit> rightDelim, Doc`1<Unit> sep, Doc`1[] docs);
    public static Doc`1<Unit> List(Seq`1<Doc`1<Unit>> docs);
    public static Doc`1<Unit> Tuple(Seq`1<Doc`1<Unit>> docs);
    public static Doc`1<Unit> List(Doc`1[] docs);
    public static Doc`1<Unit> Tuple(Doc`1[] docs);
    public static Doc`1<Unit> Spaces(int n);
    public static Doc`1<Unit> HorizSep(Seq`1<Doc`1<Unit>> docs);
    public static Doc`1<Unit> VertSep(Seq`1<Doc`1<Unit>> docs);
    public static Doc`1<Unit> Sep(Doc`1<Unit> sep, Seq`1<Doc`1<Unit>> docs);
    public static Doc`1<Unit> Sep(Seq`1<Doc`1<Unit>> docs);
    public static Doc`1<Unit> FillSep(Seq`1<Doc`1<Unit>> docs);
    public static Doc`1<Unit> HardSep(Seq`1<Doc`1<Unit>> docs);
    public static Doc`1<Unit> HorizCat(Seq`1<Doc`1<Unit>> docs);
    public static Doc`1<Unit> VertCat(Seq`1<Doc`1<Unit>> docs);
    public static Doc`1<Unit> Width(Doc`1<Unit> doc, Func`2<int, Doc`1<Unit>> f);
    public static Doc`1<Unit> Fill(int width, Doc`1<Unit> doc);
    public static Doc`1<Unit> Between(Doc`1<Unit> left, Doc`1<Unit> right, Doc`1<Unit> middle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.Pretty.Doc`1 : object {
    public Doc`1<A> Empty;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected Doc`1(Doc`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual Doc`1<A> Append(Doc`1<A> d);
    public static Doc`1<A> op_Addition(Doc`1<A> x, Doc`1<A> y);
    public static Doc`1<A> op_Addition(string x, Doc`1<A> y);
    public static Doc`1<A> op_Addition(Doc`1<A> x, string y);
    public static Doc`1<A> op_BitwiseOr(Doc`1<A> x, Doc`1<A> y);
    public static Doc`1<A> op_BitwiseOr(string x, Doc`1<A> y);
    public static Doc`1<A> op_BitwiseOr(Doc`1<A> x, string y);
    public Doc`1<B> Select(Func`2<A, B> f);
    public Doc`1<B> Map(Func`2<A, B> f);
    public abstract virtual Doc`1<B> ReAnnotate(Func`2<A, B> f);
    public abstract virtual FlattenResult`1<Doc`1<A>> ChangesUponFlattening();
    public abstract virtual Doc`1<A> Flatten();
    public static Doc`1<A> op_Implicit(string x);
    public string Show();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Doc`1<A> left, Doc`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Doc`1<A> left, Doc`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Doc`1<A> other);
    [CompilerGeneratedAttribute]
public abstract virtual Doc`1<A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Pretty.DocAnn : object {
    public static Doc`1<A> Annotate(A annotation, Doc`1<A> doc);
    public static Doc`1<A> Fail();
    public static Doc`1<A> Empty();
    public static Doc`1<A> Char(char c);
    public static Doc`1<A> Text(string text);
    public static Doc`1<A> FlatAlt(Doc`1<A> da, Doc`1<A> db);
    public static Doc`1<A> Union(Doc`1<A> da, Doc`1<A> db);
    public static Doc`1<A> Cat(Doc`1<A> da, Doc`1<A> db);
    public static Doc`1<A> Nest(int indent, Doc`1<A> doc);
    public static Doc`1<A> Column(Func`2<int, Doc`1<A>> f);
    public static Doc`1<A> PageWidth(Func`2<PageWidth, Doc`1<A>> f);
    public static Doc`1<A> Nesting(Func`2<int, Doc`1<A>> f);
    public static Doc`1<A> HardLine();
    public static Doc`1<A> LineOrSpace();
    public static Doc`1<A> LineOrEmpty();
    public static Doc`1<A> SoftLineOrSpace();
    public static Doc`1<A> SoftLineOrEmpty();
    public static Doc`1<A> Group(Doc`1<A> doc);
    public static Doc`1<A> Align(Doc`1<A> doc);
    public static Doc`1<A> Hang(int offset, Doc`1<A> doc);
    public static Doc`1<A> Indent(int indent, Doc`1<A> doc);
    public static Doc`1<A> Sep(Doc`1<A> sep, Seq`1<Doc`1<A>> docs);
    public static Doc`1<A> BetweenSep(Doc`1<A> leftDelim, Doc`1<A> rightDelim, Doc`1<A> sep, Seq`1<Doc`1<A>> docs);
    public static Doc`1<A> BetweenSep(Doc`1<A> leftDelim, Doc`1<A> rightDelim, Doc`1<A> sep, Doc`1[] docs);
    public static Doc`1<A> List(Seq`1<Doc`1<A>> docs);
    public static Doc`1<A> Tuple(Seq`1<Doc`1<A>> docs);
    public static Doc`1<A> List(Doc`1[] docs);
    public static Doc`1<A> Tuple(Doc`1[] docs);
    public static Doc`1<A> Spaces(int n);
    public static Doc`1<A> HorizSep(Seq`1<Doc`1<A>> docs);
    public static Doc`1<A> VertSep(Seq`1<Doc`1<A>> docs);
    public static Doc`1<A> Sep(Seq`1<Doc`1<A>> docs);
    public static Doc`1<A> FillSep(Seq`1<Doc`1<A>> docs);
    public static Doc`1<A> HardSep(Seq`1<Doc`1<A>> docs);
    public static Doc`1<A> HorizCat(Seq`1<Doc`1<A>> docs);
    public static Doc`1<A> VertCat(Seq`1<Doc`1<A>> docs);
    public static Doc`1<A> Width(Doc`1<A> doc, Func`2<int, Doc`1<A>> f);
    public static Doc`1<A> Fill(int width, Doc`1<A> doc);
    public static Doc`1<A> Between(Doc`1<A> left, Doc`1<A> middle, Doc`1<A> right);
    [CompilerGeneratedAttribute]
internal static string <Spaces>g__FastSpace|28_0(int x);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.DocAnnotate`1 : Doc`1<A> {
    [CompilerGeneratedAttribute]
private A <Annotation>k__BackingField;
    [CompilerGeneratedAttribute]
private Doc`1<A> <Doc>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public A Annotation { get; public set; }
    public Doc`1<A> Doc { get; public set; }
    public DocAnnotate`1(A Annotation, Doc`1<A> Doc);
    [CompilerGeneratedAttribute]
protected DocAnnotate`1(DocAnnotate`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public A get_Annotation();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Annotation(A value);
    [CompilerGeneratedAttribute]
public Doc`1<A> get_Doc();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Doc(Doc`1<A> value);
    public virtual Doc`1<B> ReAnnotate(Func`2<A, B> f);
    public virtual FlattenResult`1<Doc`1<A>> ChangesUponFlattening();
    public virtual Doc`1<A> Flatten();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DocAnnotate`1<A> left, DocAnnotate`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DocAnnotate`1<A> left, DocAnnotate`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Doc`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(DocAnnotate`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override DocAnnotate`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(A& Annotation, Doc`1& Doc);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Doc`1<A> <ChangesUponFlattening>b__12_0(Doc`1<A> d);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.DocCat`1 : Doc`1<A> {
    [CompilerGeneratedAttribute]
private Doc`1<A> <DocA>k__BackingField;
    [CompilerGeneratedAttribute]
private Doc`1<A> <DocB>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Doc`1<A> DocA { get; public set; }
    public Doc`1<A> DocB { get; public set; }
    public DocCat`1(Doc`1<A> DocA, Doc`1<A> DocB);
    [CompilerGeneratedAttribute]
protected DocCat`1(DocCat`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Doc`1<A> get_DocA();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DocA(Doc`1<A> value);
    [CompilerGeneratedAttribute]
public Doc`1<A> get_DocB();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DocB(Doc`1<A> value);
    public virtual Doc`1<B> ReAnnotate(Func`2<A, B> f);
    public virtual FlattenResult`1<Doc`1<A>> ChangesUponFlattening();
    public virtual Doc`1<A> Flatten();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DocCat`1<A> left, DocCat`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DocCat`1<A> left, DocCat`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Doc`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(DocCat`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override DocCat`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Doc`1& DocA, Doc`1& DocB);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.DocChar`1 : Doc`1<A> {
    [CompilerGeneratedAttribute]
private char <Value>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public char Value { get; public set; }
    public DocChar`1(char Value);
    [CompilerGeneratedAttribute]
protected DocChar`1(DocChar`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public char get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(char value);
    public virtual Doc`1<B> ReAnnotate(Func`2<A, B> f);
    public virtual FlattenResult`1<Doc`1<A>> ChangesUponFlattening();
    public virtual Doc`1<A> Flatten();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DocChar`1<A> left, DocChar`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DocChar`1<A> left, DocChar`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Doc`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(DocChar`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override DocChar`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Char& Value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.DocColumn`1 : Doc`1<A> {
    [CompilerGeneratedAttribute]
private Func`2<int, Doc`1<A>> <React>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Func`2<int, Doc`1<A>> React { get; public set; }
    public DocColumn`1(Func`2<int, Doc`1<A>> React);
    [CompilerGeneratedAttribute]
protected DocColumn`1(DocColumn`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Func`2<int, Doc`1<A>> get_React();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_React(Func`2<int, Doc`1<A>> value);
    public virtual Doc`1<B> ReAnnotate(Func`2<A, B> f);
    public virtual FlattenResult`1<Doc`1<A>> ChangesUponFlattening();
    public virtual Doc`1<A> Flatten();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DocColumn`1<A> left, DocColumn`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DocColumn`1<A> left, DocColumn`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Doc`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(DocColumn`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override DocColumn`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`2& React);
    [CompilerGeneratedAttribute]
private Doc`1<A> <ChangesUponFlattening>b__8_0(int x);
    [CompilerGeneratedAttribute]
private Doc`1<A> <Flatten>b__9_0(int x);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.DocEmpty`1 : Doc`1<A> {
    public static Doc`1<A> Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected DocEmpty`1(DocEmpty`1<A> original);
    private static DocEmpty`1();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual Doc`1<B> ReAnnotate(Func`2<A, B> f);
    public virtual FlattenResult`1<Doc`1<A>> ChangesUponFlattening();
    public virtual Doc`1<A> Flatten();
    public virtual Doc`1<A> Append(Doc`1<A> d);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DocEmpty`1<A> left, DocEmpty`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DocEmpty`1<A> left, DocEmpty`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Doc`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(DocEmpty`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override DocEmpty`1<A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.DocFail`1 : Doc`1<A> {
    public static Doc`1<A> Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected DocFail`1(DocFail`1<A> original);
    private static DocFail`1();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual Doc`1<B> ReAnnotate(Func`2<A, B> f);
    public virtual FlattenResult`1<Doc`1<A>> ChangesUponFlattening();
    public virtual Doc`1<A> Flatten();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DocFail`1<A> left, DocFail`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DocFail`1<A> left, DocFail`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Doc`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(DocFail`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override DocFail`1<A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.DocFlatAlt`1 : Doc`1<A> {
    [CompilerGeneratedAttribute]
private Doc`1<A> <Primary>k__BackingField;
    [CompilerGeneratedAttribute]
private Doc`1<A> <Alt>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Doc`1<A> Primary { get; public set; }
    public Doc`1<A> Alt { get; public set; }
    public DocFlatAlt`1(Doc`1<A> Primary, Doc`1<A> Alt);
    [CompilerGeneratedAttribute]
protected DocFlatAlt`1(DocFlatAlt`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Doc`1<A> get_Primary();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Primary(Doc`1<A> value);
    [CompilerGeneratedAttribute]
public Doc`1<A> get_Alt();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Alt(Doc`1<A> value);
    public virtual Doc`1<B> ReAnnotate(Func`2<A, B> f);
    public virtual FlattenResult`1<Doc`1<A>> ChangesUponFlattening();
    public virtual Doc`1<A> Flatten();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DocFlatAlt`1<A> left, DocFlatAlt`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DocFlatAlt`1<A> left, DocFlatAlt`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Doc`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(DocFlatAlt`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override DocFlatAlt`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Doc`1& Primary, Doc`1& Alt);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.DocLine`1 : Doc`1<A> {
    public static Doc`1<A> Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected DocLine`1(DocLine`1<A> original);
    private static DocLine`1();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual Doc`1<B> ReAnnotate(Func`2<A, B> f);
    public virtual FlattenResult`1<Doc`1<A>> ChangesUponFlattening();
    public virtual Doc`1<A> Flatten();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DocLine`1<A> left, DocLine`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DocLine`1<A> left, DocLine`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Doc`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(DocLine`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override DocLine`1<A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.DocNest`1 : Doc`1<A> {
    [CompilerGeneratedAttribute]
private int <Indent>k__BackingField;
    [CompilerGeneratedAttribute]
private Doc`1<A> <Doc>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public int Indent { get; public set; }
    public Doc`1<A> Doc { get; public set; }
    public DocNest`1(int Indent, Doc`1<A> Doc);
    [CompilerGeneratedAttribute]
protected DocNest`1(DocNest`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public int get_Indent();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Indent(int value);
    [CompilerGeneratedAttribute]
public Doc`1<A> get_Doc();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Doc(Doc`1<A> value);
    public virtual Doc`1<B> ReAnnotate(Func`2<A, B> f);
    public virtual FlattenResult`1<Doc`1<A>> ChangesUponFlattening();
    public virtual Doc`1<A> Flatten();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DocNest`1<A> left, DocNest`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DocNest`1<A> left, DocNest`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Doc`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(DocNest`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override DocNest`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& Indent, Doc`1& Doc);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Doc`1<A> <ChangesUponFlattening>b__12_0(Doc`1<A> d);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.DocNesting`1 : Doc`1<A> {
    [CompilerGeneratedAttribute]
private Func`2<int, Doc`1<A>> <React>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Func`2<int, Doc`1<A>> React { get; public set; }
    public DocNesting`1(Func`2<int, Doc`1<A>> React);
    [CompilerGeneratedAttribute]
protected DocNesting`1(DocNesting`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Func`2<int, Doc`1<A>> get_React();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_React(Func`2<int, Doc`1<A>> value);
    public virtual Doc`1<B> ReAnnotate(Func`2<A, B> f);
    public virtual FlattenResult`1<Doc`1<A>> ChangesUponFlattening();
    public virtual Doc`1<A> Flatten();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DocNesting`1<A> left, DocNesting`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DocNesting`1<A> left, DocNesting`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Doc`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(DocNesting`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override DocNesting`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`2& React);
    [CompilerGeneratedAttribute]
private Doc`1<A> <ChangesUponFlattening>b__8_0(int x);
    [CompilerGeneratedAttribute]
private Doc`1<A> <Flatten>b__9_0(int x);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.DocPageWidth`1 : Doc`1<A> {
    [CompilerGeneratedAttribute]
private Func`2<PageWidth, Doc`1<A>> <React>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Func`2<PageWidth, Doc`1<A>> React { get; public set; }
    public DocPageWidth`1(Func`2<PageWidth, Doc`1<A>> React);
    [CompilerGeneratedAttribute]
protected DocPageWidth`1(DocPageWidth`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Func`2<PageWidth, Doc`1<A>> get_React();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_React(Func`2<PageWidth, Doc`1<A>> value);
    public virtual Doc`1<B> ReAnnotate(Func`2<A, B> f);
    public virtual FlattenResult`1<Doc`1<A>> ChangesUponFlattening();
    public virtual Doc`1<A> Flatten();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DocPageWidth`1<A> left, DocPageWidth`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DocPageWidth`1<A> left, DocPageWidth`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Doc`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(DocPageWidth`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override DocPageWidth`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`2& React);
    [CompilerGeneratedAttribute]
private Doc`1<A> <ChangesUponFlattening>b__8_0(PageWidth x);
    [CompilerGeneratedAttribute]
private Doc`1<A> <Flatten>b__9_0(PageWidth x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.Pretty.DocStream`1 : object {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected DocStream`1(DocStream`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public DocStream`1<B> Select(Func`2<A, B> f);
    public DocStream`1<B> Map(Func`2<A, B> f);
    public abstract virtual DocStream`1<B> ReAnnotate(Func`2<A, B> f);
    public string Show();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DocStream`1<A> left, DocStream`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DocStream`1<A> left, DocStream`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(DocStream`1<A> other);
    [CompilerGeneratedAttribute]
public abstract virtual DocStream`1<A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.DocText`1 : Doc`1<A> {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Text { get; public set; }
    public int Length { get; }
    public DocText`1(string Text);
    [CompilerGeneratedAttribute]
protected DocText`1(DocText`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Text(string value);
    public virtual Doc`1<B> ReAnnotate(Func`2<A, B> f);
    public virtual FlattenResult`1<Doc`1<A>> ChangesUponFlattening();
    public virtual Doc`1<A> Flatten();
    public int get_Length();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DocText`1<A> left, DocText`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DocText`1<A> left, DocText`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Doc`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(DocText`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override DocText`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Text);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.DocUnion`1 : Doc`1<A> {
    [CompilerGeneratedAttribute]
private Doc`1<A> <DocA>k__BackingField;
    [CompilerGeneratedAttribute]
private Doc`1<A> <DocB>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Doc`1<A> DocA { get; public set; }
    public Doc`1<A> DocB { get; public set; }
    public DocUnion`1(Doc`1<A> DocA, Doc`1<A> DocB);
    [CompilerGeneratedAttribute]
protected DocUnion`1(DocUnion`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Doc`1<A> get_DocA();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DocA(Doc`1<A> value);
    [CompilerGeneratedAttribute]
public Doc`1<A> get_DocB();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DocB(Doc`1<A> value);
    public virtual Doc`1<B> ReAnnotate(Func`2<A, B> f);
    public virtual FlattenResult`1<Doc`1<A>> ChangesUponFlattening();
    public virtual Doc`1<A> Flatten();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DocUnion`1<A> left, DocUnion`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DocUnion`1<A> left, DocUnion`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Doc`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(DocUnion`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override DocUnion`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Doc`1& DocA, Doc`1& DocB);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.Pretty.FastSpace : object {
    public static string Show(int n);
    private static string FastSpaceInternal(int x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Pretty.FittingPredicate`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`5<PageWidth, int, Option`1<int>, DocStream`1<A>, bool> <FP>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`5<PageWidth, int, Option`1<int>, DocStream`1<A>, bool> FP { get; public set; }
    public FittingPredicate`1(Func`5<PageWidth, int, Option`1<int>, DocStream`1<A>, bool> FP);
    [CompilerGeneratedAttribute]
protected FittingPredicate`1(FittingPredicate`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Func`5<PageWidth, int, Option`1<int>, DocStream`1<A>, bool> get_FP();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FP(Func`5<PageWidth, int, Option`1<int>, DocStream`1<A>, bool> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(FittingPredicate`1<A> left, FittingPredicate`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(FittingPredicate`1<A> left, FittingPredicate`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(FittingPredicate`1<A> other);
    [CompilerGeneratedAttribute]
public virtual FittingPredicate`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`5& FP);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.Flattened`1 : FlattenResult`1<A> {
    [CompilerGeneratedAttribute]
private A <Value>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public A Value { get; public set; }
    public Flattened`1(A Value);
    [CompilerGeneratedAttribute]
protected Flattened`1(Flattened`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public A get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(A value);
    public virtual FlattenResult`1<B> Map(Func`2<A, B> f);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Flattened`1<A> left, Flattened`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Flattened`1<A> left, Flattened`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FlattenResult`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Flattened`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override Flattened`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(A& Value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.Pretty.FlattenResult`1 : object {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected FlattenResult`1(FlattenResult`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public abstract virtual FlattenResult`1<B> Map(Func`2<A, B> f);
    public FlattenResult`1<B> Select(Func`2<A, B> f);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(FlattenResult`1<A> left, FlattenResult`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(FlattenResult`1<A> left, FlattenResult`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(FlattenResult`1<A> other);
    [CompilerGeneratedAttribute]
public abstract virtual FlattenResult`1<A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Pretty.Layout : object {
    public static DocStream`1<A> pretty(LayoutOptions options, Doc`1<A> doc);
    public static DocStream`1<A> smart(LayoutOptions options, Doc`1<A> doc);
    public static DocStream`1<A> layout(FittingPredicate`1<A> fittingPredicate, LayoutOptions options, Doc`1<A> doc);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <pretty>g__go|0_1(Option`1<int> mx, DocStream`1<A> doc);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <smart>g__go|1_0(PageWidth pageWidth, int minNest, Option`1<int> mx, DocStream`1<A> doc);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static DocStream`1<A> <layout>g__best|2_0(int nest, int col, LayoutPipeline`1<A> pipeline, <>c__DisplayClass2_0`1& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static DocStream`1<A> <layout>g__selectNicer|2_1(FittingPredicate`1<A> fits, int lineIndent, int currentColumn, DocStream`1<A> x, DocStream`1<A> y, <>c__DisplayClass2_0`1& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Pretty.LayoutOptions : object {
    [CompilerGeneratedAttribute]
private PageWidth <PageWidth>k__BackingField;
    public static LayoutOptions Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public PageWidth PageWidth { get; public set; }
    public LayoutOptions(PageWidth PageWidth);
    [CompilerGeneratedAttribute]
protected LayoutOptions(LayoutOptions original);
    private static LayoutOptions();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public PageWidth get_PageWidth();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PageWidth(PageWidth value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(LayoutOptions left, LayoutOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(LayoutOptions left, LayoutOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(LayoutOptions other);
    [CompilerGeneratedAttribute]
public virtual LayoutOptions <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(PageWidth& PageWidth);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.Pretty.LayoutPipeline`1 : object {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected LayoutPipeline`1(LayoutPipeline`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(LayoutPipeline`1<A> left, LayoutPipeline`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(LayoutPipeline`1<A> left, LayoutPipeline`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(LayoutPipeline`1<A> other);
    [CompilerGeneratedAttribute]
public abstract virtual LayoutPipeline`1<A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.NeverFlat`1 : FlattenResult`1<A> {
    public static FlattenResult`1<A> Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected NeverFlat`1(NeverFlat`1<A> original);
    private static NeverFlat`1();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual FlattenResult`1<B> Map(Func`2<A, B> f);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(NeverFlat`1<A> left, NeverFlat`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(NeverFlat`1<A> left, NeverFlat`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FlattenResult`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(NeverFlat`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override NeverFlat`1<A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.Nil`1 : LayoutPipeline`1<A> {
    public static LayoutPipeline`1<A> Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected Nil`1(Nil`1<A> original);
    private static Nil`1();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Nil`1<A> left, Nil`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Nil`1<A> left, Nil`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(LayoutPipeline`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Nil`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override Nil`1<A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.Pretty.PageWidth : object {
    public static PageWidth Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected PageWidth(PageWidth original);
    private static PageWidth();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(PageWidth left, PageWidth right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(PageWidth left, PageWidth right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(PageWidth other);
    [CompilerGeneratedAttribute]
public abstract virtual PageWidth <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.SAnnPop`1 : DocStream`1<A> {
    [CompilerGeneratedAttribute]
private DocStream`1<A> <Next>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public DocStream`1<A> Next { get; public set; }
    public SAnnPop`1(DocStream`1<A> Next);
    [CompilerGeneratedAttribute]
protected SAnnPop`1(SAnnPop`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public DocStream`1<A> get_Next();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Next(DocStream`1<A> value);
    public virtual DocStream`1<B> ReAnnotate(Func`2<A, B> f);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SAnnPop`1<A> left, SAnnPop`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SAnnPop`1<A> left, SAnnPop`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DocStream`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(SAnnPop`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SAnnPop`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(DocStream`1& Next);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.SAnnPush`1 : DocStream`1<A> {
    [CompilerGeneratedAttribute]
private A <Ann>k__BackingField;
    [CompilerGeneratedAttribute]
private DocStream`1<A> <Next>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public A Ann { get; public set; }
    public DocStream`1<A> Next { get; public set; }
    public SAnnPush`1(A Ann, DocStream`1<A> Next);
    [CompilerGeneratedAttribute]
protected SAnnPush`1(SAnnPush`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public A get_Ann();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Ann(A value);
    [CompilerGeneratedAttribute]
public DocStream`1<A> get_Next();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Next(DocStream`1<A> value);
    public virtual DocStream`1<B> ReAnnotate(Func`2<A, B> f);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SAnnPush`1<A> left, SAnnPush`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SAnnPush`1<A> left, SAnnPush`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DocStream`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(SAnnPush`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SAnnPush`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(A& Ann, DocStream`1& Next);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.SChar`1 : DocStream`1<A> {
    [CompilerGeneratedAttribute]
private char <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private DocStream`1<A> <Next>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public char Value { get; public set; }
    public DocStream`1<A> Next { get; public set; }
    public SChar`1(char Value, DocStream`1<A> Next);
    [CompilerGeneratedAttribute]
protected SChar`1(SChar`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public char get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(char value);
    [CompilerGeneratedAttribute]
public DocStream`1<A> get_Next();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Next(DocStream`1<A> value);
    public virtual DocStream`1<B> ReAnnotate(Func`2<A, B> f);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SChar`1<A> left, SChar`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SChar`1<A> left, SChar`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DocStream`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(SChar`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SChar`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Char& Value, DocStream`1& Next);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.SEmpty`1 : DocStream`1<A> {
    public static DocStream`1<A> Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected SEmpty`1(SEmpty`1<A> original);
    private static SEmpty`1();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual DocStream`1<B> ReAnnotate(Func`2<A, B> f);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SEmpty`1<A> left, SEmpty`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SEmpty`1<A> left, SEmpty`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DocStream`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(SEmpty`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SEmpty`1<A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.SFail`1 : DocStream`1<A> {
    public static DocStream`1<A> Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected SFail`1(SFail`1<A> original);
    private static SFail`1();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual DocStream`1<B> ReAnnotate(Func`2<A, B> f);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SFail`1<A> left, SFail`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SFail`1<A> left, SFail`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DocStream`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(SFail`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SFail`1<A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.SLine`1 : DocStream`1<A> {
    [CompilerGeneratedAttribute]
private int <Indent>k__BackingField;
    [CompilerGeneratedAttribute]
private DocStream`1<A> <Next>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public int Indent { get; public set; }
    public DocStream`1<A> Next { get; public set; }
    public SLine`1(int Indent, DocStream`1<A> Next);
    [CompilerGeneratedAttribute]
protected SLine`1(SLine`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public int get_Indent();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Indent(int value);
    [CompilerGeneratedAttribute]
public DocStream`1<A> get_Next();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Next(DocStream`1<A> value);
    public virtual DocStream`1<B> ReAnnotate(Func`2<A, B> f);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SLine`1<A> left, SLine`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SLine`1<A> left, SLine`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DocStream`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(SLine`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SLine`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& Indent, DocStream`1& Next);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.SText`1 : DocStream`1<A> {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private DocStream`1<A> <Next>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Value { get; public set; }
    public DocStream`1<A> Next { get; public set; }
    public SText`1(string Value, DocStream`1<A> Next);
    [CompilerGeneratedAttribute]
protected SText`1(SText`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(string value);
    [CompilerGeneratedAttribute]
public DocStream`1<A> get_Next();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Next(DocStream`1<A> value);
    public virtual DocStream`1<B> ReAnnotate(Func`2<A, B> f);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SText`1<A> left, SText`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SText`1<A> left, SText`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DocStream`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(SText`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SText`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Value, DocStream`1& Next);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Pretty.Unbounded : PageWidth {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected Unbounded(Unbounded original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(Unbounded left, Unbounded right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(Unbounded left, Unbounded right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(PageWidth other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(Unbounded other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override Unbounded <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pretty.UndoAnn`1 : LayoutPipeline`1<A> {
    [CompilerGeneratedAttribute]
private LayoutPipeline`1<A> <Pipeline>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public LayoutPipeline`1<A> Pipeline { get; public set; }
    public UndoAnn`1(LayoutPipeline`1<A> Pipeline);
    [CompilerGeneratedAttribute]
protected UndoAnn`1(UndoAnn`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public LayoutPipeline`1<A> get_Pipeline();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Pipeline(LayoutPipeline`1<A> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(UndoAnn`1<A> left, UndoAnn`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(UndoAnn`1<A> left, UndoAnn`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(LayoutPipeline`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(UndoAnn`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override UndoAnn`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(LayoutPipeline`1& Pipeline);
}
public static class LanguageExt.Prism : object {
    [NullableContextAttribute("2")]
public static Prism`2<A, A> identity();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class LanguageExt.Prism`2 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<A, Option`1<B>> Get;
    public Func`2<B, Func`2<A, A>> SetF;
    private Prism`2(Func`2<A, Option`1<B>> get, Func`2<B, Func`2<A, A>> set);
    public A Set(B value, A cont);
    public static Prism`2<A, B> New(Func`2<A, Option`1<B>> Get, Func`2<B, Func`2<A, A>> Set);
    public static Prism`2<A, B> New(Lens`2<A, B> lens);
    public static Prism`2<A, B> New(Lens`2<A, Option`1<B>> lens);
    public Func`2<A, A> Update(Func`2<B, B> f);
    public A Update(Func`2<B, B> f, A value);
    [PureAttribute]
public static Prism`2<A, B> op_Implicit(Lens`2<A, B> value);
    [PureAttribute]
public static Prism`2<A, B> op_Implicit(Lens`2<A, Option`1<B>> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.ProxyExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static Producer`3<OUT, M, B> Bind(Proxy`6<Void, Unit, Unit, OUT, M, A> ma, Func`2<A, Producer`3<OUT, M, B>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Consumer`3<IN, M, B> Bind(Proxy`6<Unit, IN, Unit, Void, M, A> ma, Func`2<A, Consumer`3<IN, M, B>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Pipe`4<IN, OUT, M, B> Bind(Proxy`6<Unit, IN, Unit, OUT, M, A> ma, Func`2<A, Pipe`4<IN, OUT, M, B>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Client`4<REQ, RES, M, B> Bind(Proxy`6<REQ, RES, Unit, Void, M, A> ma, Func`2<A, Client`4<REQ, RES, M, B>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Server`4<REQ, RES, M, B> Bind(Proxy`6<Void, Unit, REQ, RES, M, A> ma, Func`2<A, Server`4<REQ, RES, M, B>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Producer`3<OUT, M, B> SelectMany(Proxy`6<Void, Unit, Unit, OUT, M, A> ma, Func`2<A, Producer`3<OUT, M, B>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Consumer`3<IN, M, B> SelectMany(Proxy`6<Unit, IN, Unit, Void, M, A> ma, Func`2<A, Consumer`3<IN, M, B>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Pipe`4<IN, OUT, M, B> SelectMany(Proxy`6<Unit, IN, Unit, OUT, M, A> ma, Func`2<A, Pipe`4<IN, OUT, M, B>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Client`4<REQ, RES, M, B> SelectMany(Proxy`6<REQ, RES, Unit, Void, M, A> ma, Func`2<A, Client`4<REQ, RES, M, B>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Server`4<REQ, RES, M, B> SelectMany(Proxy`6<Void, Unit, REQ, RES, M, A> ma, Func`2<A, Server`4<REQ, RES, M, B>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Producer`3<OUT, M, C> SelectMany(Proxy`6<Void, Unit, Unit, OUT, M, A> ma, Func`2<A, Producer`3<OUT, M, B>> f, Func`3<A, B, C> project);
    [ExtensionAttribute]
[PureAttribute]
public static Consumer`3<IN, M, C> SelectMany(Proxy`6<Unit, IN, Unit, Void, M, A> ma, Func`2<A, Consumer`3<IN, M, B>> f, Func`3<A, B, C> project);
    [ExtensionAttribute]
[PureAttribute]
public static Pipe`4<IN, OUT, M, C> SelectMany(Proxy`6<Unit, IN, Unit, OUT, M, A> ma, Func`2<A, Pipe`4<IN, OUT, M, B>> f, Func`3<A, B, C> project);
    [ExtensionAttribute]
[PureAttribute]
public static Client`4<REQ, RES, M, C> SelectMany(Proxy`6<REQ, RES, Unit, Void, M, A> ma, Func`2<A, Client`4<REQ, RES, M, B>> f, Func`3<A, B, C> project);
    [ExtensionAttribute]
[PureAttribute]
public static Server`4<REQ, RES, M, C> SelectMany(Proxy`6<Void, Unit, REQ, RES, M, A> ma, Func`2<A, Server`4<REQ, RES, M, B>> f, Func`3<A, B, C> project);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class LanguageExt.Pure`1 : ValueType {
    [CompilerGeneratedAttribute]
private A <Value>k__BackingField;
    public A Value { get; public set; }
    public Pure`1(A Value);
    [CompilerGeneratedAttribute]
public A get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(A value);
    public Pure`1<B> Map(Func`2<A, B> f);
    [NullableContextAttribute("2")]
public Pure`1<B> Bind(Func`2<A, Pure`1<B>> f);
    public Either`2<L, A> Bind(Func`2<A, Fail`1<L>> f);
    public IO`1<B> Bind(Func`2<A, IO`1<B>> f);
    [NullableContextAttribute("2")]
public Pure`1<C> SelectMany(Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    public Either`2<L, C> SelectMany(Func`2<A, Fail`1<L>> bind, Func`3<A, Unit, C> project);
    public IO`1<C> SelectMany(Func`2<A, IO`1<B>> bind, Func`3<A, B, C> project);
    public Option`1<A> ToOption();
    public Either`2<L, A> ToEither();
    public Fin`1<A> ToFin();
    public IO`1<A> ToIO();
    public Eff`2<RT, A> ToEff();
    public Eff`1<A> ToEff();
    public Either`2<L, B> Bind(Func`2<A, Either`2<L, B>> bind);
    public Fin`1<B> Bind(Func`2<A, Fin`1<B>> bind);
    public Eff`2<RT, B> Bind(Func`2<A, Eff`2<RT, B>> bind);
    public Eff`1<B> Bind(Func`2<A, Eff`1<B>> bind);
    public K`2<M, B> Bind(Func`2<A, K`2<M, B>> bind);
    public Reader`2<Env, B> Bind(Func`2<A, Reader`2<Env, B>> bind);
    public ReaderT`3<Env, M, B> Bind(Func`2<A, ReaderT`3<Env, M, B>> bind);
    public State`2<S, B> Bind(Func`2<A, State`2<S, B>> bind);
    public StateT`3<S, M, B> Bind(Func`2<A, StateT`3<S, M, B>> bind);
    public OptionT`2<M, B> Bind(Func`2<A, OptionT`2<M, B>> bind);
    [NullableContextAttribute("2")]
public Option`1<B> Bind(Func`2<A, Option`1<B>> bind);
    public Either`2<L, C> SelectMany(Func`2<A, Either`2<L, B>> bind, Func`3<A, B, C> project);
    public Fin`1<C> SelectMany(Func`2<A, Fin`1<B>> bind, Func`3<A, B, C> project);
    public Eff`2<RT, C> SelectMany(Func`2<A, Eff`2<RT, B>> bind, Func`3<A, B, C> project);
    public Eff`1<C> SelectMany(Func`2<A, Eff`1<B>> bind, Func`3<A, B, C> project);
    public K`2<M, C> SelectMany(Func`2<A, K`2<M, B>> bind, Func`3<A, B, C> project);
    public Reader`2<Env, C> SelectMany(Func`2<A, Reader`2<Env, B>> bind, Func`3<A, B, C> project);
    public Reader`2<Env, C> SelectMany(Func`2<A, K`2<Reader`1<Env>, B>> bind, Func`3<A, B, C> project);
    public ReaderT`3<Env, M, C> SelectMany(Func`2<A, ReaderT`3<Env, M, B>> bind, Func`3<A, B, C> project);
    public ReaderT`3<Env, M, C> SelectMany(Func`2<A, K`2<ReaderT`2<Env, M>, B>> bind, Func`3<A, B, C> project);
    public State`2<S, C> SelectMany(Func`2<A, State`2<S, B>> bind, Func`3<A, B, C> project);
    public State`2<S, C> SelectMany(Func`2<A, K`2<State`1<S>, B>> bind, Func`3<A, B, C> project);
    public StateT`3<S, M, C> SelectMany(Func`2<A, StateT`3<S, M, B>> bind, Func`3<A, B, C> project);
    public StateT`3<S, M, C> SelectMany(Func`2<A, K`2<StateT`2<S, M>, B>> bind, Func`3<A, B, C> project);
    public OptionT`2<M, C> SelectMany(Func`2<A, OptionT`2<M, B>> bind, Func`3<A, B, C> project);
    public OptionT`2<M, C> SelectMany(Func`2<A, K`2<OptionT`1<M>, B>> bind, Func`3<A, B, C> project);
    [NullableContextAttribute("2")]
public Option`1<C> SelectMany(Func`2<A, Option`1<B>> bind, Func`3<A, B, C> project);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(Pure`1<A> left, Pure`1<A> right);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public static bool op_Equality(Pure`1<A> left, Pure`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Pure`1<A> other);
    [CompilerGeneratedAttribute]
public void Deconstruct(A& Value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.Pure`2 : Free`2<F, A> {
    [CompilerGeneratedAttribute]
private A <Value>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public A Value { get; public set; }
    public Pure`2(A Value);
    [CompilerGeneratedAttribute]
private Pure`2(Pure`2<F, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public A get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(A value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Pure`2<F, A> left, Pure`2<F, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Pure`2<F, A> left, Pure`2<F, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Free`2<F, A> other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Pure`2<F, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override Pure`2<F, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(A& Value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.PureExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Pure`1<A> Flatten(Pure`1<Pure`1<A>> mma);
    [ExtensionAttribute]
public static Validation`2<F, B> Bind(Pure`1<A> ma, Func`2<A, Validation`2<F, B>> bind);
    [ExtensionAttribute]
public static Validation`2<F, A> ToValidation(Pure`1<A> ma);
    [ExtensionAttribute]
public static Validation`2<F, C> SelectMany(Pure`1<A> ma, Func`2<A, Validation`2<F, B>> bind, Func`3<A, B, C> project);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class LanguageExt.Put`1 : ValueType {
    [CompilerGeneratedAttribute]
private S <Value>k__BackingField;
    public S Value { get; public set; }
    public Put`1(S Value);
    [CompilerGeneratedAttribute]
public S get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(S value);
    public StateT`3<S, M, Unit> ToStateT();
    public State`2<S, Unit> ToState();
    public StateT`3<S, M, C> SelectMany(Func`2<Unit, StateT`3<S, M, B>> bind, Func`3<Unit, B, C> project);
    public State`2<S, C> SelectMany(Func`2<Unit, State`2<S, B>> bind, Func`3<Unit, B, C> project);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(Put`1<S> left, Put`1<S> right);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public static bool op_Equality(Put`1<S> left, Put`1<S> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Put`1<S> other);
    [CompilerGeneratedAttribute]
public void Deconstruct(S& Value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[CollectionBuilderAttribute("LanguageExt.Queue", "createRange")]
public class LanguageExt.Que`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Que`1<A> Empty;
    private QueInternal`1<A> value;
    internal QueInternal`1<A> Value { get; }
    [NullableAttribute("2")]
[PureAttribute]
public object Case { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public int Length { get; }
    internal Que`1(QueInternal`1<A> value);
    public Que`1(IEnumerable`1<A> items);
    public Que`1(ReadOnlySpan`1<A> items);
    private static Que`1();
    internal QueInternal`1<A> get_Value();
    public Que`1<A> Do(Action`1<A> f);
    [NullableContextAttribute("2")]
public object get_Case();
    public bool get_IsEmpty();
    public int get_Count();
    public int get_Length();
    [PureAttribute]
public Que`1<A> Clear();
    [PureAttribute]
public A Peek();
    [PureAttribute]
public Que`1<A> Dequeue();
    [PureAttribute]
public ValueTuple`2<Que`1<A>, A> DequeueUnsafe();
    [PureAttribute]
public ValueTuple`2<Que`1<A>, Option`1<A>> TryDequeue();
    [PureAttribute]
public Option`1<A> TryPeek();
    [PureAttribute]
public Que`1<A> Enqueue(A value);
    [PureAttribute]
public Seq`1<A> ToSeq();
    [PureAttribute]
public Iterable`1<A> AsIterable();
    [PureAttribute]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public static Que`1<A> op_Addition(Que`1<A> lhs, Que`1<A> rhs);
    [PureAttribute]
public Que`1<A> Combine(Que`1<A> rhs);
    [PureAttribute]
public static Que`1<A> op_Subtraction(Que`1<A> lhs, Que`1<A> rhs);
    [PureAttribute]
public Que`1<A> Subtract(Que`1<A> rhs);
    [PureAttribute]
public static bool op_Equality(Que`1<A> lhs, Que`1<A> rhs);
    [PureAttribute]
public static bool op_Inequality(Que`1<A> lhs, Que`1<A> rhs);
    [PureAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public sealed virtual bool Equals(Que`1<A> other);
    public static Que`1<A> op_Implicit(SeqEmpty _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.QueInternal`1 : object {
    public static QueInternal`1<A> Empty;
    private StckInternal`1<A> forward;
    private StckInternal`1<A> backward;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private StckInternal`1<A> backwardRev;
    private int hashCode;
    private StckInternal`1<A> BackwardRev { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    internal QueInternal`1(IEnumerable`1<A> items);
    internal QueInternal`1(ReadOnlySpan`1<A> items);
    private QueInternal`1(StckInternal`1<A> f, StckInternal`1<A> b);
    private static QueInternal`1();
    private StckInternal`1<A> get_BackwardRev();
    public int get_Count();
    public bool get_IsEmpty();
    [PureAttribute]
public QueInternal`1<A> Clear();
    [PureAttribute]
public A Peek();
    [PureAttribute]
public QueInternal`1<A> Dequeue();
    [PureAttribute]
public QueInternal`1<A> Dequeue(A& outValue);
    [PureAttribute]
public ValueTuple`2<QueInternal`1<A>, Option`1<A>> TryDequeue();
    [PureAttribute]
public Option`1<A> TryPeek();
    [PureAttribute]
public QueInternal`1<A> Enqueue(A value);
    [PureAttribute]
public Seq`1<A> ToSeq();
    [PureAttribute]
public Iterable`1<A> AsIterable();
    [PureAttribute]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public static QueInternal`1<A> op_Addition(QueInternal`1<A> lhs, QueInternal`1<A> rhs);
    [PureAttribute]
public QueInternal`1<A> Combine(QueInternal`1<A> rhs);
    [PureAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private ValueTuple`2<QueInternal`1<A>, Option`1<A>> <TryDequeue>b__19_0(A x);
    [CompilerGeneratedAttribute]
private ValueTuple`2<QueInternal`1<A>, Option`1<A>> <TryDequeue>b__19_1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Query : object {
    public static T head(IQueryable`1<T> list);
    public static Option`1<T> headOrNone(IQueryable`1<T> list);
    public static Either`2<L, R> headOrLeft(IQueryable`1<R> list, L left);
    public static IQueryable`1<T> tail(IQueryable`1<T> list);
    public static IQueryable`1<R> map(IQueryable`1<T> list, Expression`1<Func`2<T, R>> map);
    public static IQueryable`1<R> map(IQueryable`1<T> list, Expression`1<Func`3<int, T, R>> map);
    public static IQueryable`1<T> filter(IQueryable`1<T> list, Expression`1<Func`2<T, bool>> predicate);
    public static IQueryable`1<U> choose(IQueryable`1<T> list, Expression`1<Func`2<T, Option`1<U>>> selector);
    public static IQueryable`1<U> choose(IQueryable`1<T> list, Expression`1<Func`3<int, T, Option`1<U>>> selector);
    public static IQueryable`1<R> collect(IQueryable`1<T> list, Expression`1<Func`2<T, IEnumerable`1<R>>> map);
    public static int sum(IQueryable`1<int> list);
    public static float sum(IQueryable`1<float> list);
    public static double sum(IQueryable`1<double> list);
    public static decimal sum(IQueryable`1<decimal> list);
    public static IQueryable`1<T> rev(IQueryable`1<T> list);
    public static IQueryable`1<T> append(IQueryable`1<T> lhs, IQueryable`1<T> rhs);
    public static S fold(IQueryable`1<T> list, S state, Expression`1<Func`3<S, T, S>> folder);
    public static S foldBack(IQueryable`1<T> list, S state, Expression`1<Func`3<S, T, S>> folder);
    public static T reduce(IQueryable`1<T> list, Expression`1<Func`3<T, T, T>> reducer);
    public static T reduceBack(IQueryable`1<T> list, Expression`1<Func`3<T, T, T>> reducer);
    public static Option`1<T> find(IQueryable`1<T> list, Expression`1<Func`2<T, bool>> pred);
    public static Lst`1<T> freeze(IQueryable`1<T> list);
    public static IQueryable`1<V> zip(IQueryable`1<T> list, IEnumerable`1<U> other, Expression`1<Func`3<T, U, V>> zipper);
    public static int length(IQueryable`1<T> list);
    public static bool forall(IQueryable`1<T> list, Expression`1<Func`2<T, bool>> pred);
    public static IQueryable`1<T> distinct(IQueryable`1<T> list);
    public static IQueryable`1<T> take(IQueryable`1<T> list, int count);
    public static IQueryable`1<T> takeWhile(IQueryable`1<T> list, Expression`1<Func`2<T, bool>> pred);
    public static IQueryable`1<T> takeWhile(IQueryable`1<T> list, Expression`1<Func`3<T, int, bool>> pred);
    public static bool exists(IQueryable`1<T> list, Expression`1<Func`2<T, bool>> pred);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.QueryExtensions : object {
    [ExtensionAttribute]
public static T Head(IQueryable`1<T> list);
    [ExtensionAttribute]
public static Option`1<T> HeadOrNone(IQueryable`1<T> list);
    [ExtensionAttribute]
public static Either`2<S, T> HeadOrLeft(IQueryable`1<T> list, S left);
    [ExtensionAttribute]
public static IQueryable`1<T> Tail(IQueryable`1<T> list);
    [ExtensionAttribute]
public static IQueryable`1<R> Map(IQueryable`1<T> list, Expression`1<Func`2<T, R>> map);
    [ExtensionAttribute]
public static IQueryable`1<R> Map(IQueryable`1<T> list, Expression`1<Func`3<int, T, R>> map);
    [ExtensionAttribute]
public static IQueryable`1<T> Filter(IQueryable`1<T> list, Expression`1<Func`2<T, bool>> predicate);
    [ExtensionAttribute]
public static IQueryable`1<U> Choose(IQueryable`1<T> list, Expression`1<Func`2<T, Option`1<U>>> selector);
    [ExtensionAttribute]
public static IQueryable`1<U> Choose(IQueryable`1<T> list, Expression`1<Func`3<int, T, Option`1<U>>> selector);
    [ExtensionAttribute]
public static IQueryable`1<R> Collect(IQueryable`1<T> list, Expression`1<Func`2<T, IEnumerable`1<R>>> map);
    [ExtensionAttribute]
public static IQueryable`1<T> Rev(IQueryable`1<T> list);
    [ExtensionAttribute]
public static IQueryable`1<T> Append(IQueryable`1<T> lhs, IQueryable`1<T> rhs);
    [ExtensionAttribute]
public static S Fold(IQueryable`1<T> list, S state, Expression`1<Func`3<S, T, S>> folder);
    [ExtensionAttribute]
public static S FoldBack(IQueryable`1<T> list, S state, Expression`1<Func`3<S, T, S>> folder);
    [ExtensionAttribute]
public static T Reduce(IQueryable`1<T> list, Expression`1<Func`3<T, T, T>> reducer);
    [ExtensionAttribute]
public static T ReduceBack(IQueryable`1<T> list, Expression`1<Func`3<T, T, T>> reducer);
    [ExtensionAttribute]
public static Lst`1<T> Freeze(IQueryable`1<T> list);
    [ExtensionAttribute]
public static IQueryable`1<V> Zip(IQueryable`1<T> list, IEnumerable`1<U> other, Expression`1<Func`3<T, U, V>> zipper);
    [ExtensionAttribute]
public static int Length(IQueryable`1<T> list);
    [ExtensionAttribute]
public static bool ForAll(IQueryable`1<T> list, Expression`1<Func`2<T, bool>> pred);
    [ExtensionAttribute]
public static IQueryable`1<T> Distinct(IQueryable`1<T> list);
    [ExtensionAttribute]
public static bool Exists(IQueryable`1<T> list, Expression`1<Func`2<T, bool>> pred);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Queue : object {
    [PureAttribute]
public static Que`1<T> singleton(T item);
    [PureAttribute]
public static Que`1<T> createRange(IEnumerable`1<T> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Que`1<T> createRange(ReadOnlySpan`1<T> items);
    [PureAttribute]
public static Que`1<T> enq(Que`1<T> queue, T value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`2<Que`1<T>, T> deqUnsafe(Que`1<T> queue);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`2<Que`1<T>, Option`1<T>> deq(Que`1<T> queue);
    [PureAttribute]
public static T peekUnsafe(Que`1<T> queue);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Option`1<T> peek(Que`1<T> queue);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Que`1<T> clear(Que`1<T> queue);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Que`1<R> map(Que`1<T> queue, Func`3<int, T, R> map);
    [PureAttribute]
public static Que`1<T> filter(Que`1<T> queue, Func`2<T, bool> predicate);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Que`1<U> choose(Que`1<T> queue, Func`2<T, Option`1<U>> selector);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Que`1<U> choose(Que`1<T> queue, Func`3<int, T, Option`1<U>> selector);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Que`1<R> collect(Que`1<T> queue, Func`2<T, IEnumerable`1<R>> map);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Que`1<T> rev(Que`1<T> queue);
    [PureAttribute]
public static Que`1<T> append(Que`1<T> lhs, IEnumerable`1<T> rhs);
    [PureAttribute]
public static S fold(Que`1<T> queue, S state, Func`3<S, T, S> folder);
    [PureAttribute]
public static S foldBack(Que`1<T> queue, S state, Func`3<S, T, S> folder);
    [PureAttribute]
public static T reduce(Que`1<T> queue, Func`3<T, T, T> reducer);
    [PureAttribute]
public static T reduceBack(Que`1<T> queue, Func`3<T, T, T> reducer);
    [PureAttribute]
public static IEnumerable`1<S> scan(Que`1<T> queue, S state, Func`3<S, T, S> folder);
    [PureAttribute]
public static IEnumerable`1<S> scanBack(Que`1<T> queue, S state, Func`3<S, T, S> folder);
    [PureAttribute]
public static Option`1<T> find(Que`1<T> queue, Func`2<T, bool> pred);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Que`1<V> zip(Que`1<T> queue, IEnumerable`1<U> other, Func`3<T, U, V> zipper);
    [NullableContextAttribute("2")]
[PureAttribute]
public static int length(Que`1<T> queue);
    public static Unit iter(Que`1<T> queue, Action`1<T> action);
    public static Unit iter(Que`1<T> queue, Action`2<int, T> action);
    [PureAttribute]
public static bool forall(Que`1<T> queue, Func`2<T, bool> pred);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Que`1<T> distinct(Que`1<T> queue);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Que`1<T> distinct(Que`1<T> queue);
    [PureAttribute]
public static IEnumerable`1<T> take(Que`1<T> queue, int count);
    [PureAttribute]
public static IEnumerable`1<T> takeWhile(Que`1<T> queue, Func`2<T, bool> pred);
    [PureAttribute]
public static IEnumerable`1<T> takeWhile(Que`1<T> queue, Func`3<T, int, bool> pred);
    [PureAttribute]
public static bool exists(Que`1<T> queue, Func`2<T, bool> pred);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.QueueExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTuple`2<Que`1<T>, T> PopUnsafe(Que`1<T> queue);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTuple`2<Que`1<T>, Option`1<T>> Pop(Que`1<T> queue);
    [ExtensionAttribute]
[PureAttribute]
public static T PeekUnsafe(Que`1<T> queue);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Option`1<T> Peek(Que`1<T> queue);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Que`1<R> Map(Que`1<T> queue, Func`2<T, R> map);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Que`1<R> Map(Que`1<T> queue, Func`3<int, T, R> map);
    [ExtensionAttribute]
[PureAttribute]
public static Que`1<T> Filter(Que`1<T> queue, Func`2<T, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Que`1<U> Choose(Que`1<T> queue, Func`2<T, Option`1<U>> selector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Que`1<U> Choose(Que`1<T> queue, Func`3<int, T, Option`1<U>> selector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Que`1<R> Collect(Que`1<T> queue, Func`2<T, IEnumerable`1<R>> map);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Que`1<T> Rev(Que`1<T> queue);
    [ExtensionAttribute]
[PureAttribute]
public static Que`1<T> Append(Que`1<T> lhs, IEnumerable`1<T> rhs);
    [ExtensionAttribute]
[PureAttribute]
public static S Fold(Que`1<T> queue, S state, Func`3<S, T, S> folder);
    [ExtensionAttribute]
[PureAttribute]
public static S FoldBack(Que`1<T> queue, S state, Func`3<S, T, S> folder);
    [ExtensionAttribute]
[PureAttribute]
public static T ReduceBack(Que`1<T> queue, Func`3<T, T, T> reducer);
    [ExtensionAttribute]
[PureAttribute]
public static T Reduce(Que`1<T> queue, Func`3<T, T, T> reducer);
    [ExtensionAttribute]
[PureAttribute]
public static Que`1<S> Scan(Que`1<T> queue, S state, Func`3<S, T, S> folder);
    [ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<S> ScanBack(Que`1<T> queue, S state, Func`3<S, T, S> folder);
    [ExtensionAttribute]
[PureAttribute]
public static Option`1<T> Find(Que`1<T> queue, Func`2<T, bool> pred);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static int Length(Que`1<T> queue);
    [ExtensionAttribute]
public static Unit Iter(Que`1<T> queue, Action`1<T> action);
    [ExtensionAttribute]
public static Unit Iter(Que`1<T> queue, Action`2<int, T> action);
    [ExtensionAttribute]
[PureAttribute]
public static bool ForAll(Que`1<T> queue, Func`2<T, bool> pred);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Que`1<T> Distinct(Que`1<T> queue);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[PureAttribute]
public static Que`1<T> Distinct(Que`1<T> list);
    [ExtensionAttribute]
[PureAttribute]
public static bool Exists(Que`1<T> queue, Func`2<T, bool> pred);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Range : object {
    public static Range`1<A> zero();
    [PureAttribute]
public static Range`1<A> fromMinMax(A min, A max);
    [PureAttribute]
public static Range`1<A> fromMinMax(A min, A max, A step);
    [PureAttribute]
public static Range`1<A> fromCount(A min, A count);
    [PureAttribute]
public static Range`1<A> fromCount(A min, A count, A step);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Range>.FoldWhile(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<Range, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Range>.FoldBackWhile(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<Range, A> ta);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Range`1 : object {
    [CompilerGeneratedAttribute]
private A <From>k__BackingField;
    [CompilerGeneratedAttribute]
private A <To>k__BackingField;
    [CompilerGeneratedAttribute]
private A <Step>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<A> <runRange>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public A From { get; public set; }
    public A To { get; public set; }
    public A Step { get; public set; }
    public IEnumerable`1<A> runRange { get; public set; }
    [NullableAttribute("2")]
[PureAttribute]
public object Case { get; }
    public Range`1(A From, A To, A Step, IEnumerable`1<A> runRange);
    [CompilerGeneratedAttribute]
protected Range`1(Range`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public A get_From();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_From(A value);
    [CompilerGeneratedAttribute]
public A get_To();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_To(A value);
    [CompilerGeneratedAttribute]
public A get_Step();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Step(A value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<A> get_runRange();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_runRange(IEnumerable`1<A> value);
    [NullableContextAttribute("2")]
public object get_Case();
    [PureAttribute]
public Seq`1<A> ToSeq();
    [PureAttribute]
public Iterable`1<A> AsIterable();
    [PureAttribute]
public StreamT`2<M, A> AsStream();
    [PureAttribute]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Range`1<A> left, Range`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Range`1<A> left, Range`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Range`1<A> other);
    [CompilerGeneratedAttribute]
public virtual Range`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(A& From, A& To, A& Step, IEnumerable`1& runRange);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.RangeExtensions : object {
    [ExtensionAttribute]
public static Range`1<A> As(K`2<Range, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static bool InRange(K`2<Range, A> ma, A value);
    [ExtensionAttribute]
[PureAttribute]
public static bool Overlaps(K`2<Range, A> ma, Range`1<A> other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class LanguageExt.Ratio`1 : ValueType {
    public A Numerator;
    public A Denominator;
    public Ratio`1(A num, A den);
}
[ExtensionAttribute]
public static class LanguageExt.ReadableExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static K`2<M, A> Local(K`2<M, A> ma, Func`2<Env, Env> f);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Reader : object {
    public static Reader`2<Env, B> bind(Reader`2<Env, A> ma, Func`2<A, Reader`2<Env, B>> f);
    public static Reader`2<Env, B> map(Func`2<A, B> f, Reader`2<Env, A> ma);
    public static Reader`2<Env, A> Pure(A value);
    public static Reader`2<Env, B> apply(Reader`2<Env, Func`2<A, B>> mf, Reader`2<Env, A> ma);
    public static Reader`2<Env, B> action(Reader`2<Env, A> ma, Reader`2<Env, B> mb);
    public static Reader`2<Env, Env> ask();
    public static Reader`2<Env, A> asks(Func`2<Env, A> f);
    public static Reader`2<Env, A> asksM(Func`2<Env, Reader`2<Env, A>> f);
    public static Reader`2<Env, A> local(Func`2<Env, Env> f, Reader`2<Env, A> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Reader`1 : object {
    private static K`2<Reader`1<Env>, Env> LanguageExt.Traits.Readable<LanguageExt.Reader<Env>,Env>.Ask { get; }
    private static override K`2<Reader`1<Env>, B> LanguageExt.Traits.Monad<LanguageExt.Reader<Env>>.Bind(K`2<Reader`1<Env>, A> ma, Func`2<A, K`2<Reader`1<Env>, B>> f);
    private static override K`2<Reader`1<Env>, B> LanguageExt.Traits.Functor<LanguageExt.Reader<Env>>.Map(Func`2<A, B> f, K`2<Reader`1<Env>, A> ma);
    private static override K`2<Reader`1<Env>, A> LanguageExt.Traits.Applicative<LanguageExt.Reader<Env>>.Pure(A value);
    private static override K`2<Reader`1<Env>, B> LanguageExt.Traits.Applicative<LanguageExt.Reader<Env>>.Apply(K`2<Reader`1<Env>, Func`2<A, B>> mf, K`2<Reader`1<Env>, A> ma);
    private static override K`2<Reader`1<Env>, B> LanguageExt.Traits.Applicative<LanguageExt.Reader<Env>>.Action(K`2<Reader`1<Env>, A> ma, K`2<Reader`1<Env>, B> mb);
    private static override K`2<Reader`1<Env>, Env> LanguageExt.Traits.Readable<LanguageExt.Reader<Env>,Env>.get_Ask();
    private static override K`2<Reader`1<Env>, A> LanguageExt.Traits.Readable<LanguageExt.Reader<Env>,Env>.Asks(Func`2<Env, A> f);
    private static override K`2<Reader`1<Env>, A> LanguageExt.Traits.Readable<LanguageExt.Reader<Env>,Env>.Local(Func`2<Env, Env> f, K`2<Reader`1<Env>, A> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Reader`2 : object {
    [CompilerGeneratedAttribute]
private Func`2<Env, A> <runReader>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Func`2<Env, A> runReader { get; public set; }
    public Reader`2(Func`2<Env, A> runReader);
    [CompilerGeneratedAttribute]
protected Reader`2(Reader`2<Env, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Func`2<Env, A> get_runReader();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_runReader(Func`2<Env, A> value);
    public static Reader`2<Env, A> Pure(A value);
    public static Reader`2<Env, A> Asks(Func`2<Env, A> f);
    public static Reader`2<Env, A> AsksM(Func`2<Env, Reader`2<Env, A>> f);
    public static Reader`2<Env, A> Lift(Pure`1<A> monad);
    public static Reader`2<Env, A> Lift(Func`1<A> f);
    public Reader`2<Env1, A> With(Func`2<Env1, Env> f);
    public Reader`2<Env, A> Local(Func`2<Env, Env> f);
    public Reader`2<Env, B> Map(Func`2<A, B> f);
    public Reader`2<Env, B> Select(Func`2<A, B> f);
    public Reader`2<Env, B> Bind(Func`2<A, K`2<Reader`1<Env>, B>> f);
    public Reader`2<Env, B> Bind(Func`2<A, Reader`2<Env, B>> f);
    public Reader`2<Env, B> Bind(Func`2<A, Ask`2<Env, B>> f);
    public Reader`2<Env, C> SelectMany(Func`2<A, K`2<Reader`1<Env>, B>> bind, Func`3<A, B, C> project);
    public Reader`2<Env, C> SelectMany(Func`2<A, Reader`2<Env, B>> bind, Func`3<A, B, C> project);
    public Reader`2<Env, C> SelectMany(Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    public Reader`2<Env, C> SelectMany(Func`2<A, Ask`2<Env, B>> bind, Func`3<A, B, C> project);
    public static Reader`2<Env, A> op_Implicit(Pure`1<A> ma);
    public static Reader`2<Env, A> op_Implicit(Ask`2<Env, A> ma);
    public static Reader`2<Env, A> op_RightShift(Reader`2<Env, A> lhs, Reader`2<Env, A> rhs);
    public static Reader`2<Env, A> op_RightShift(Reader`2<Env, A> lhs, K`2<Reader`1<Env>, A> rhs);
    public static Reader`2<Env, A> op_RightShift(Reader`2<Env, A> lhs, Reader`2<Env, Unit> rhs);
    public static Reader`2<Env, A> op_RightShift(Reader`2<Env, A> lhs, K`2<Reader`1<Env>, Unit> rhs);
    public A Run(Env env);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Reader`2<Env, A> left, Reader`2<Env, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Reader`2<Env, A> left, Reader`2<Env, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Reader`2<Env, A> other);
    [CompilerGeneratedAttribute]
public virtual Reader`2<Env, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`2& runReader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.ReaderExt : object {
    [ExtensionAttribute]
public static Reader`2<Env, A> As(K`2<Reader`1<Env>, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Reader`2<Env, A> Flatten(Reader`2<Env, Reader`2<Env, A>> mma);
    [ExtensionAttribute]
public static ReaderT`3<Env, M, A> As(K`2<ReaderT`2<Env, M>, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static ReaderT`3<Env, M, A> Flatten(ReaderT`3<Env, M, ReaderT`3<Env, M, A>> mma);
    [ExtensionAttribute]
public static ReaderT`3<Env, M, C> SelectMany(K`2<M, A> ma, Func`2<A, K`2<ReaderT`2<Env, M>, B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
public static ReaderT`3<Env, M, C> SelectMany(K`2<M, A> ma, Func`2<A, ReaderT`3<Env, M, B>> bind, Func`3<A, B, C> project);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ReaderT : object {
    public static ReaderT`3<Env, M, A> combine(ReaderT`3<Env, M, A> ma, ReaderT`3<Env, M, A> mb);
    public static ReaderT`3<Env, M, B> bind(ReaderT`3<Env, M, A> ma, Func`2<A, ReaderT`3<Env, M, B>> f);
    public static ReaderT`3<Env, M, B> map(Func`2<A, B> f, ReaderT`3<Env, M, A> ma);
    public static ReaderT`3<Env, M, A> Pure(A value);
    public static ReaderT`3<Env, M, B> apply(ReaderT`3<Env, M, Func`2<A, B>> mf, ReaderT`3<Env, M, A> ma);
    public static ReaderT`3<Env, M, B> action(ReaderT`3<Env, M, A> ma, ReaderT`3<Env, M, B> mb);
    public static ReaderT`3<Env, M, A> lift(K`2<M, A> ma);
    public static ReaderT`3<Env, M, A> liftIO(IO`1<A> effect);
    public static ReaderT`3<Env, M, Env> ask();
    public static ReaderT`3<Env, M, A> asks(Func`2<Env, A> f);
    public static ReaderT`3<Env, M, A> asksM(Func`2<Env, K`2<M, A>> f);
    public static ReaderT`3<Env, M, A> local(Func`2<Env, Env> f, ReaderT`3<Env, M, A> ma);
    public static ReaderT`3<Env, M, A> with(Func`2<Env, SubEnv> f, ReaderT`3<SubEnv, M, A> ma);
}
public class LanguageExt.ReaderT`1 : object {
    [NullableContextAttribute("1")]
public static ReaderT`3<Env, M, A> lift(K`2<M, A> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ReaderT`2 : object {
    private static K`2<ReaderT`2<Env, M>, Env> LanguageExt.Traits.Readable<LanguageExt.ReaderT<Env,M>,Env>.Ask { get; }
    public static ReaderT`3<Env, M, A> Pure(A value);
    public static ReaderT`3<Env, M, A> liftIO(IO`1<A> effect);
    private static override K`2<ReaderT`2<Env, M>, B> LanguageExt.Traits.Monad<LanguageExt.ReaderT<Env,M>>.Bind(K`2<ReaderT`2<Env, M>, A> ma, Func`2<A, K`2<ReaderT`2<Env, M>, B>> f);
    private static override K`2<ReaderT`2<Env, M>, B> LanguageExt.Traits.Functor<LanguageExt.ReaderT<Env,M>>.Map(Func`2<A, B> f, K`2<ReaderT`2<Env, M>, A> ma);
    private static override K`2<ReaderT`2<Env, M>, A> LanguageExt.Traits.Applicative<LanguageExt.ReaderT<Env,M>>.Pure(A value);
    private static override K`2<ReaderT`2<Env, M>, B> LanguageExt.Traits.Applicative<LanguageExt.ReaderT<Env,M>>.Apply(K`2<ReaderT`2<Env, M>, Func`2<A, B>> mf, K`2<ReaderT`2<Env, M>, A> ma);
    private static override K`2<ReaderT`2<Env, M>, B> LanguageExt.Traits.Applicative<LanguageExt.ReaderT<Env,M>>.Action(K`2<ReaderT`2<Env, M>, A> ma, K`2<ReaderT`2<Env, M>, B> mb);
    private static override K`2<ReaderT`2<Env, M>, A> LanguageExt.Traits.MonadT<LanguageExt.ReaderT<Env,M>,M>.Lift(K`2<M, A> ma);
    private static override K`2<ReaderT`2<Env, M>, Env> LanguageExt.Traits.Readable<LanguageExt.ReaderT<Env,M>,Env>.get_Ask();
    private static override K`2<ReaderT`2<Env, M>, A> LanguageExt.Traits.Readable<LanguageExt.ReaderT<Env,M>,Env>.Asks(Func`2<Env, A> f);
    private static override K`2<ReaderT`2<Env, M>, A> LanguageExt.Traits.Readable<LanguageExt.ReaderT<Env,M>,Env>.Local(Func`2<Env, Env> f, K`2<ReaderT`2<Env, M>, A> ma);
    private static override K`2<ReaderT`2<Env, M>, A> LanguageExt.Traits.MonadIO<LanguageExt.ReaderT<Env,M>>.LiftIO(IO`1<A> ma);
    private static override K`2<ReaderT`2<Env, M>, IO`1<A>> LanguageExt.Traits.MonadIO<LanguageExt.ReaderT<Env,M>>.ToIO(K`2<ReaderT`2<Env, M>, A> ma);
    private static override K`2<ReaderT`2<Env, M>, A> LanguageExt.Traits.SemigroupK<LanguageExt.ReaderT<Env,M>>.Combine(K`2<ReaderT`2<Env, M>, A> ma, K`2<ReaderT`2<Env, M>, A> mb);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ReaderT`3 : object {
    [CompilerGeneratedAttribute]
private Func`2<Env, K`2<M, A>> <runReader>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Func`2<Env, K`2<M, A>> runReader { get; public set; }
    public ReaderT`3(Func`2<Env, K`2<M, A>> runReader);
    [CompilerGeneratedAttribute]
protected ReaderT`3(ReaderT`3<Env, M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Func`2<Env, K`2<M, A>> get_runReader();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_runReader(Func`2<Env, K`2<M, A>> value);
    public static ReaderT`3<Env, M, A> Pure(A value);
    public static ReaderT`3<Env, M, A> Asks(Func`2<Env, A> f);
    public static ReaderT`3<Env, M, A> AsksM(Func`2<Env, K`2<M, A>> f);
    public static ReaderT`3<Env, M, A> Lift(Pure`1<A> monad);
    public static ReaderT`3<Env, M, A> Lift(K`2<M, A> monad);
    public static ReaderT`3<Env, M, A> Lift(Func`1<A> f);
    public static ReaderT`3<Env, M, A> LiftIO(IO`1<A> ma);
    public ReaderT`3<Env1, M, A> With(Func`2<Env1, Env> f);
    public ReaderT`3<Env, M, A> Local(Func`2<Env, Env> f);
    public ReaderT`3<Env, M1, B> MapM(Func`2<K`2<M, A>, K`2<M1, B>> f);
    public ReaderT`3<Env, M, B> Map(Func`2<A, B> f);
    public ReaderT`3<Env, M, B> Select(Func`2<A, B> f);
    public ReaderT`3<Env, M, B> Bind(Func`2<A, K`2<ReaderT`2<Env, M>, B>> f);
    public ReaderT`3<Env, M, B> Bind(Func`2<A, ReaderT`3<Env, M, B>> f);
    public ReaderT`3<Env, M, B> Bind(Func`2<A, Ask`2<Env, B>> f);
    public ReaderT`3<Env, M, B> Bind(Func`2<A, IO`1<B>> f);
    public ReaderT`3<Env, M, C> SelectMany(Func`2<A, K`2<ReaderT`2<Env, M>, B>> bind, Func`3<A, B, C> project);
    public ReaderT`3<Env, M, C> SelectMany(Func`2<A, ReaderT`3<Env, M, B>> bind, Func`3<A, B, C> project);
    public ReaderT`3<Env, M, C> SelectMany(Func`2<A, K`2<M, B>> bind, Func`3<A, B, C> project);
    public ReaderT`3<Env, M, C> SelectMany(Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    public ReaderT`3<Env, M, C> SelectMany(Func`2<A, Ask`2<Env, B>> bind, Func`3<A, B, C> project);
    public ReaderT`3<Env, M, C> SelectMany(Func`2<A, IO`1<B>> bind, Func`3<A, B, C> project);
    public static ReaderT`3<Env, M, A> op_RightShift(ReaderT`3<Env, M, A> lhs, ReaderT`3<Env, M, A> rhs);
    public static ReaderT`3<Env, M, A> op_RightShift(ReaderT`3<Env, M, A> lhs, K`2<ReaderT`2<Env, M>, A> rhs);
    public static ReaderT`3<Env, M, A> op_RightShift(ReaderT`3<Env, M, A> lhs, ReaderT`3<Env, M, Unit> rhs);
    public static ReaderT`3<Env, M, A> op_RightShift(ReaderT`3<Env, M, A> lhs, K`2<ReaderT`2<Env, M>, Unit> rhs);
    public static ReaderT`3<Env, M, A> op_Implicit(Pure`1<A> ma);
    public static ReaderT`3<Env, M, A> op_Implicit(Ask`2<Env, A> ma);
    public static ReaderT`3<Env, M, A> op_Implicit(IO`1<A> ma);
    public static ReaderT`3<Env, M, A> op_BitwiseOr(ReaderT`3<Env, M, A> ma, ReaderT`3<Env, M, A> mb);
    public static ReaderT`3<Env, M, A> op_BitwiseOr(ReaderT`3<Env, M, A> ma, Pure`1<A> mb);
    public static ReaderT`3<Env, M, A> op_BitwiseOr(ReaderT`3<Env, M, A> ma, Ask`2<Env, A> mb);
    public static ReaderT`3<Env, M, A> op_BitwiseOr(Ask`2<Env, A> ma, ReaderT`3<Env, M, A> mb);
    public static ReaderT`3<Env, M, A> op_BitwiseOr(ReaderT`3<Env, M, A> ma, IO`1<A> mb);
    public static ReaderT`3<Env, M, A> op_BitwiseOr(IO`1<A> ma, ReaderT`3<Env, M, A> mb);
    public K`2<M, A> Run(Env env);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ReaderT`3<Env, M, A> left, ReaderT`3<Env, M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ReaderT`3<Env, M, A> left, ReaderT`3<Env, M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(ReaderT`3<Env, M, A> other);
    [CompilerGeneratedAttribute]
public virtual ReaderT`3<Env, M, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`2& runReader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.Record`1 : object {
    protected Record`1(SerializationInfo info, StreamingContext context);
    public static bool op_Equality(Record`1<RECORDTYPE> x, Record`1<RECORDTYPE> y);
    public static bool op_Inequality(Record`1<RECORDTYPE> x, Record`1<RECORDTYPE> y);
    public static bool op_GreaterThan(Record`1<RECORDTYPE> x, Record`1<RECORDTYPE> y);
    public static bool op_GreaterThanOrEqual(Record`1<RECORDTYPE> x, Record`1<RECORDTYPE> y);
    public static bool op_LessThan(Record`1<RECORDTYPE> x, Record`1<RECORDTYPE> y);
    public static bool op_LessThanOrEqual(Record`1<RECORDTYPE> x, Record`1<RECORDTYPE> y);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public virtual int CompareTo(RECORDTYPE other);
    [NullableContextAttribute("2")]
public virtual bool Equals(RECORDTYPE other);
    public virtual string ToString();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.RecordType`1 : object {
    public static Func`2<A, int> Hash { get; }
    public static Func`3<A, object, bool> Equality { get; }
    public static Func`3<A, A, bool> EqualityTyped { get; }
    public static Func`3<A, A, int> Compare { get; }
    public static Func`2<A, string> ToString { get; }
    public static Action`2<A, SerializationInfo> SetObjectData { get; }
    public static Action`2<A, SerializationInfo> GetObjectData { get; }
    public static Func`2<A, int> get_Hash();
    public static Func`3<A, object, bool> get_Equality();
    public static Func`3<A, A, bool> get_EqualityTyped();
    public static Func`3<A, A, int> get_Compare();
    public static Func`2<A, string> get_ToString();
    public static Action`2<A, SerializationInfo> get_SetObjectData();
    public static Action`2<A, SerializationInfo> get_GetObjectData();
    [ObsoleteAttribute("Don't use Equals - use either RecordType<A>.Equality or RecordType<A>.EqualityTyped")]
public static bool Equals(object objA, object objB);
}
internal static class LanguageExt.RecordTypeCompare`1 : object {
    [NullableAttribute("1")]
internal static Func`3<A, A, int> Compare;
    private static RecordTypeCompare`1();
}
internal static class LanguageExt.RecordTypeEquality`1 : object {
    [NullableAttribute("1")]
internal static Func`3<A, object, bool> Equality;
    private static RecordTypeEquality`1();
}
internal static class LanguageExt.RecordTypeEqualityTyped`1 : object {
    [NullableAttribute("1")]
internal static Func`3<A, A, bool> EqualityTyped;
    private static RecordTypeEqualityTyped`1();
}
internal static class LanguageExt.RecordTypeGetObjectData`1 : object {
    [NullableAttribute("1")]
internal static Action`2<A, SerializationInfo> GetObjectData;
    private static RecordTypeGetObjectData`1();
}
internal static class LanguageExt.RecordTypeHash`1 : object {
    [NullableAttribute("1")]
internal static Func`2<A, int> Hash;
    private static RecordTypeHash`1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.RecordTypeIgnoreBase`1 : object {
    public static Func`2<A, int> Hash;
    public static Func`3<A, object, bool> Equality;
    public static Func`3<A, A, bool> EqualityTyped;
    public static Func`3<A, A, int> Compare;
    public static Func`2<A, string> ToString;
    public static Action`2<A, SerializationInfo> SetObjectData;
    public static Action`2<A, SerializationInfo> GetObjectData;
    private static RecordTypeIgnoreBase`1();
    [ObsoleteAttribute("Don't use Equals - use either RecordType<A>.Equality or RecordType<A>.EqualityTyped")]
public static bool Equals(object objA, object objB);
}
internal static class LanguageExt.RecordTypeIncludeBase`1 : object {
    internal static bool IncludeBase;
    private static RecordTypeIncludeBase`1();
}
internal static class LanguageExt.RecordTypeSetObjectData`1 : object {
    [NullableAttribute("1")]
internal static Action`2<A, SerializationInfo> SetObjectData;
    private static RecordTypeSetObjectData`1();
}
internal static class LanguageExt.RecordTypeToString`1 : object {
    [NullableAttribute("1")]
internal static Func`2<A, string> ToString;
    private static RecordTypeToString`1();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class LanguageExt.RecurseIO`1 : IOResponse`1<A> {
    [CompilerGeneratedAttribute]
private IO`1<A> <Computation>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IO`1<A> Computation { get; public set; }
    public RecurseIO`1(IO`1<A> Computation);
    [CompilerGeneratedAttribute]
protected RecurseIO`1(RecurseIO`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IO`1<A> get_Computation();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Computation(IO`1<A> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RecurseIO`1<A> left, RecurseIO`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RecurseIO`1<A> left, RecurseIO`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(IOResponse`1<A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(RecurseIO`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override RecurseIO`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(IO`1& Computation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Ref`1 : object {
    internal long Id;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private AtomChangedEvent`1<A> Change;
    public A Value { get; public set; }
    public IO`1<A> ValueIO { get; public set; }
    internal Ref`1(long id);
    [CompilerGeneratedAttribute]
public void add_Change(AtomChangedEvent`1<A> value);
    [CompilerGeneratedAttribute]
public void remove_Change(AtomChangedEvent`1<A> value);
    protected virtual override void Finalize();
    internal void OnChange(A value);
    public A get_Value();
    public void set_Value(A value);
    public IO`1<A> get_ValueIO();
    public void set_ValueIO(IO`1<A> value);
    public static A op_Implicit(Ref`1<A> value);
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(A other);
    public A Swap(Func`2<A, A> f);
    public IO`1<A> SwapIO(Func`2<A, A> f);
    public CommuteRef`1<A> Commute(Func`2<A, A> f);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private A <get_ValueIO>b__11_0(EnvIO _);
    [CompilerGeneratedAttribute]
private Unit <set_ValueIO>b__12_0(A v);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class LanguageExt.ReferenceEqualityComparer`1 : object {
    public sealed virtual bool Equals(A x, A y);
    public sealed virtual int GetHashCode(A obj);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class LanguageExt.Reflect : object {
    [NullableContextAttribute("1")]
private static bool Intersects(A[] ma, A[] mb);
    [NullableContextAttribute("1")]
public static IEnumerable`1<FieldInfo> GetPublicInstanceFields(bool includeBase, Type[] excludeAttrs);
    [NullableContextAttribute("1")]
public static bool IsStatic(PropertyInfo p);
    [NullableContextAttribute("1")]
public static Option`1<MethodInfo> GetPublicStaticMethod(Type type, string name, Type argA);
    [NullableContextAttribute("1")]
public static Option`1<MethodInfo> GetPublicStaticMethod(string name, Type argA);
    public static Option`1<MethodInfo> GetPublicStaticMethod(string name);
    public static Option`1<MethodInfo> GetPublicStaticMethod(string name);
    [NullableContextAttribute("1")]
public static Option`1<MethodInfo> GetPublicStaticMethod(string name, Type argA, Type argB);
    [NullableContextAttribute("1")]
public static Option`1<MethodInfo> GetPublicInstanceMethod(string name, bool includeBase);
    public static Option`1<MethodInfo> GetPublicInstanceMethod(string name, bool includeBase);
    public static Option`1<MethodInfo> GetPublicInstanceMethod(string name, bool includeBase);
    [NullableContextAttribute("1")]
public static Option`1<MethodInfo> GetPublicInstanceMethod(Type type, string name, bool includeBase);
    [NullableContextAttribute("1")]
public static Option`1<MethodInfo> GetPublicInstanceMethod(string name, Type arg1, Type arg2, bool includeBase);
    public static Option`1<ConstructorInfo> GetConstructor();
    public static Option`1<ConstructorInfo> GetConstructor();
    public static Option`1<ConstructorInfo> GetConstructor();
    public static Option`1<ConstructorInfo> GetConstructor();
    public static Option`1<ConstructorInfo> GetConstructor();
    public static bool IsFunc(Type type);
    public static bool IsAnonymous(Type type);
}
public class LanguageExt.RefValidationFailedException : Exception {
}
public enum LanguageExt.Relation : Enum {
    public int value__;
    public static Relation Causes;
    public static Relation CausedBy;
    public static Relation Concurrent;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Resources : object {
    private AtomHashMap`2<object, TrackedResource> resources;
    [NullableAttribute("2")]
private Resources parent;
    [NullableContextAttribute("2")]
public Resources(Resources parent);
    public static IO`1<Resources> NewIO(Resources parent);
    public sealed virtual void Dispose();
    public Unit DisposeU(EnvIO envIO);
    public Unit DisposeU();
    public IO`1<Unit> DisposeIO();
    public Unit Acquire(A value);
    public Unit AcquireAsync(A value);
    public Unit Acquire(A value, Func`2<A, IO`1<Unit>> release);
    public IO`1<Unit> Release(A value);
    public IO`1<Unit> ReleaseAll();
    internal Unit Merge(Resources rhs);
    [CompilerGeneratedAttribute]
private Unit <DisposeIO>b__7_0(EnvIO _);
    [CompilerGeneratedAttribute]
private Unit <ReleaseAll>b__12_0(EnvIO envIO);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ResultIsNullException : Exception {
    public ResultIsNullException(string message);
    public ResultIsNullException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchBind : Schedule {
    [CompilerGeneratedAttribute]
private Schedule <Schedule>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Duration, Schedule> <BindF>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Schedule Schedule { get; public set; }
    public Func`2<Duration, Schedule> BindF { get; public set; }
    public SchBind(Schedule Schedule, Func`2<Duration, Schedule> BindF);
    [CompilerGeneratedAttribute]
protected SchBind(SchBind original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Schedule get_Schedule();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Schedule(Schedule value);
    [CompilerGeneratedAttribute]
public Func`2<Duration, Schedule> get_BindF();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_BindF(Func`2<Duration, Schedule> value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchBind left, SchBind right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchBind left, SchBind right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchBind other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchBind <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Schedule& Schedule, Func`2& BindF);
    [CompilerGeneratedAttribute]
private Iterable`1<Duration> <Run>b__11_0(Duration x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchBind2 : Schedule {
    [CompilerGeneratedAttribute]
private Schedule <Schedule>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Duration, Schedule> <BindF>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<Duration, Duration, Duration> <Project>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Schedule Schedule { get; public set; }
    public Func`2<Duration, Schedule> BindF { get; public set; }
    public Func`3<Duration, Duration, Duration> Project { get; public set; }
    public SchBind2(Schedule Schedule, Func`2<Duration, Schedule> BindF, Func`3<Duration, Duration, Duration> Project);
    [CompilerGeneratedAttribute]
protected SchBind2(SchBind2 original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Schedule get_Schedule();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Schedule(Schedule value);
    [CompilerGeneratedAttribute]
public Func`2<Duration, Schedule> get_BindF();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_BindF(Func`2<Duration, Schedule> value);
    [CompilerGeneratedAttribute]
public Func`3<Duration, Duration, Duration> get_Project();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Project(Func`3<Duration, Duration, Duration> value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchBind2 left, SchBind2 right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchBind2 left, SchBind2 right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchBind2 other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchBind2 <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Schedule& Schedule, Func`2& BindF, Func`3& Project);
    [CompilerGeneratedAttribute]
private Iterable`1<Duration> <Run>b__15_0(Duration x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchCombine : Schedule {
    [CompilerGeneratedAttribute]
private Schedule <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private Schedule <Right>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Schedule Left { get; public set; }
    public Schedule Right { get; public set; }
    public SchCombine(Schedule Left, Schedule Right);
    [CompilerGeneratedAttribute]
protected SchCombine(SchCombine original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Schedule get_Left();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Left(Schedule value);
    [CompilerGeneratedAttribute]
public Schedule get_Right();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Right(Schedule value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchCombine left, SchCombine right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchCombine left, SchCombine right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchCombine other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchCombine <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Schedule& Left, Schedule& Right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchCons : Schedule {
    [CompilerGeneratedAttribute]
private Duration <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private Schedule <Right>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Duration Left { get; public set; }
    public Schedule Right { get; public set; }
    public SchCons(Duration Left, Schedule Right);
    [CompilerGeneratedAttribute]
protected SchCons(SchCons original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Duration get_Left();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Left(Duration value);
    [CompilerGeneratedAttribute]
public Schedule get_Right();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Right(Schedule value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchCons left, SchCons right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchCons left, SchCons right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchCons other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchCons <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Duration& Left, Schedule& Right);
    [IteratorStateMachineAttribute("LanguageExt.SchCons/<<Run>g__Go|11_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<Duration> <Run>g__Go|11_0();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class LanguageExt.SchDayOfWeek : Schedule {
    [CompilerGeneratedAttribute]
private DayOfWeek <Day>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<DateTime> <CurrentTimeFn>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public DayOfWeek Day { get; public set; }
    public Func`1<DateTime> CurrentTimeFn { get; public set; }
    public SchDayOfWeek(DayOfWeek Day, Func`1<DateTime> CurrentTimeFn);
    [CompilerGeneratedAttribute]
protected SchDayOfWeek(SchDayOfWeek original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public DayOfWeek get_Day();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Day(DayOfWeek value);
    [CompilerGeneratedAttribute]
public Func`1<DateTime> get_CurrentTimeFn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CurrentTimeFn(Func`1<DateTime> value);
    [NullableContextAttribute("1")]
public virtual Iterable`1<Duration> Run();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SchDayOfWeek left, SchDayOfWeek right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SchDayOfWeek left, SchDayOfWeek right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(SchDayOfWeek other);
    [NullableContextAttribute("1")]
[PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchDayOfWeek <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(DayOfWeek& Day, Func`1& CurrentTimeFn);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("LanguageExt.SchDayOfWeek/<<Run>g__Go|11_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<Duration> <Run>g__Go|11_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchDecorrelate : Schedule {
    [CompilerGeneratedAttribute]
private Schedule <Schedule>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Factor>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private Option`1<int> <Seed>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Schedule Schedule { get; public set; }
    public double Factor { get; public set; }
    [NullableAttribute("0")]
public Option`1<int> Seed { get; public set; }
    [NullableContextAttribute("0")]
public SchDecorrelate(Schedule Schedule, double Factor, Option`1<int> Seed);
    [CompilerGeneratedAttribute]
protected SchDecorrelate(SchDecorrelate original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Schedule get_Schedule();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Schedule(Schedule value);
    [CompilerGeneratedAttribute]
public double get_Factor();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Factor(double value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public Option`1<int> get_Seed();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Seed(Option`1<int> value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchDecorrelate left, SchDecorrelate right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchDecorrelate left, SchDecorrelate right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchDecorrelate other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchDecorrelate <Clone>$();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public void Deconstruct(Schedule& Schedule, Double& Factor, Option`1& Seed);
    [IteratorStateMachineAttribute("LanguageExt.SchDecorrelate/<<Run>g__Go|15_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<Duration> <Run>g__Go|15_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.Schedule : object {
    public static ScheduleTransformer Identity;
    public static Schedule Forever;
    public static Schedule Never;
    public static Schedule Once;
    public static ScheduleTransformer NoDelayOnFirst;
    public static ScheduleTransformer RepeatForever;
    internal static Func`1<DateTime> LiveNowFn;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [PureAttribute]
public Schedule Tail { get; }
    [CompilerGeneratedAttribute]
protected Schedule(Schedule original);
    private static Schedule();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [PureAttribute]
public static Schedule TimeSeries(Duration[] durations);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Schedule TimeSeries(Arr`1<Duration> durations);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Schedule TimeSeries(Seq`1<Duration> durations);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Schedule TimeSeries(Lst`1<Duration> durations);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Schedule TimeSeries(Set`1<Duration> durations);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Schedule TimeSeries(HashSet`1<Duration> durations);
    [PureAttribute]
public static ScheduleTransformer Transform(Func`2<Schedule, Schedule> transform);
    [PureAttribute]
public static ScheduleTransformer recurs(int times);
    [PureAttribute]
public static Schedule spaced(Duration space);
    [PureAttribute]
public static Schedule linear(Duration seed, double factor);
    [PureAttribute]
public static Schedule exponential(Duration seed, double factor);
    [PureAttribute]
public static Schedule fibonacci(Duration seed);
    [PureAttribute]
public static Schedule upto(Duration max, Func`1<DateTime> currentTimeFn);
    [PureAttribute]
internal static Duration secondsToIntervalStart(DateTime startTime, DateTime currentTime, Duration interval);
    [PureAttribute]
public static Schedule fixedInterval(Duration interval, Func`1<DateTime> currentTimeFn);
    [PureAttribute]
public static Schedule windowed(Duration interval, Func`1<DateTime> currentTimeFn);
    [PureAttribute]
internal static int durationToIntervalStart(int intervalStart, int currentIntervalPosition, int intervalWidth);
    [PureAttribute]
internal static int roundBetween(int value, int min, int max);
    [PureAttribute]
public static Schedule secondOfMinute(int second, Func`1<DateTime> currentTimeFn);
    [PureAttribute]
public static Schedule minuteOfHour(int minute, Func`1<DateTime> currentTimeFn);
    [PureAttribute]
public static Schedule hourOfDay(int hour, Func`1<DateTime> currentTimeFn);
    [PureAttribute]
public static Schedule dayOfWeek(DayOfWeek day, Func`1<DateTime> currentTimeFn);
    [PureAttribute]
public static ScheduleTransformer maxDelay(Duration max);
    [PureAttribute]
public static ScheduleTransformer maxCumulativeDelay(Duration max);
    [NullableContextAttribute("0")]
[PureAttribute]
public static ScheduleTransformer jitter(Duration minRandom, Duration maxRandom, Option`1<int> seed);
    [NullableContextAttribute("0")]
[PureAttribute]
public static ScheduleTransformer jitter(double factor, Option`1<int> seed);
    [NullableContextAttribute("0")]
[PureAttribute]
public static ScheduleTransformer decorrelate(double factor, Option`1<int> seed);
    [PureAttribute]
public static ScheduleTransformer resetAfter(Duration max);
    [PureAttribute]
public static ScheduleTransformer repeat(int times);
    [PureAttribute]
public static ScheduleTransformer intersperse(Schedule schedule);
    [PureAttribute]
public static ScheduleTransformer intersperse(Duration[] durations);
    [ObsoleteAttribute("`Spaced` has been renamed to `spaced`")]
public static Schedule Spaced(Duration space);
    [ObsoleteAttribute("`Recurs` has been renamed to `recurs`")]
public static ScheduleTransformer Recurs(int times);
    [ObsoleteAttribute("`Exponential` has been renamed to `exponential`")]
public static Schedule Exponential(Duration seed, double factor);
    [ObsoleteAttribute("`Fibonacci` has been renamed to `fibonacci`")]
public static Schedule Fibonacci(Duration seed);
    [PureAttribute]
public static Schedule op_BitwiseOr(Schedule a, Schedule b);
    [PureAttribute]
public static Schedule op_BitwiseOr(Schedule a, ScheduleTransformer b);
    [PureAttribute]
public static Schedule op_BitwiseOr(ScheduleTransformer a, Schedule b);
    [PureAttribute]
public static Schedule op_BitwiseAnd(Schedule a, Schedule b);
    [PureAttribute]
public static Schedule op_BitwiseAnd(Schedule a, ScheduleTransformer b);
    [PureAttribute]
public static Schedule op_BitwiseAnd(ScheduleTransformer a, Schedule b);
    [PureAttribute]
public static override Schedule op_Addition(Schedule a, Schedule b);
    [PureAttribute]
public abstract virtual Iterable`1<Duration> Run();
    [PureAttribute]
public Schedule Intersect(Schedule b);
    [PureAttribute]
public Schedule Union(Schedule b);
    [PureAttribute]
public Schedule Interleave(Schedule b);
    [PureAttribute]
public sealed virtual Schedule Combine(Schedule b);
    [PureAttribute]
public Schedule Take(int amount);
    [PureAttribute]
public Schedule Skip(int amount);
    public Schedule get_Tail();
    [PureAttribute]
public Schedule Prepend(Duration value);
    [PureAttribute]
public Schedule Map(Func`2<Duration, Duration> f);
    [PureAttribute]
public Schedule Map(Func`3<Duration, int, Duration> f);
    [PureAttribute]
public Schedule Filter(Func`2<Duration, bool> pred);
    [PureAttribute]
public Schedule Where(Func`2<Duration, bool> pred);
    [PureAttribute]
public Schedule Select(Func`2<Duration, Duration> f);
    [PureAttribute]
public Schedule Select(Func`3<Duration, int, Duration> f);
    [PureAttribute]
public Schedule Bind(Func`2<Duration, Schedule> f);
    [PureAttribute]
public Schedule SelectMany(Func`2<Duration, Schedule> f);
    [PureAttribute]
public Schedule SelectMany(Func`2<Duration, Schedule> bind, Func`3<Duration, Duration, Duration> project);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(Schedule left, Schedule right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(Schedule left, Schedule right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(Schedule other);
    [CompilerGeneratedAttribute]
public abstract virtual Schedule <Clone>$();
}
[ExtensionAttribute]
public static class LanguageExt.ScheduleExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static Schedule ToSchedule(Seq`1<Duration> seq);
    [ExtensionAttribute]
[PureAttribute]
public static Schedule ToSchedule(Arr`1<Duration> array);
    [ExtensionAttribute]
[PureAttribute]
public static Schedule ToSchedule(Lst`1<Duration> list);
    [ExtensionAttribute]
[PureAttribute]
public static Schedule ToSchedule(Set`1<Duration> set);
    [ExtensionAttribute]
[PureAttribute]
public static Schedule ToSchedule(HashSet`1<Duration> hashSet);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static Schedule Cons(Duration value, Schedule s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class LanguageExt.ScheduleTransformer : ValueType {
    private Func`2<Schedule, Schedule> Map;
    internal ScheduleTransformer(Func`2<Schedule, Schedule> map);
    public Schedule Apply(Schedule schedule);
    public static ScheduleTransformer op_Addition(ScheduleTransformer f, ScheduleTransformer g);
    public static Schedule op_Implicit(ScheduleTransformer t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchFibonacci : Schedule {
    [CompilerGeneratedAttribute]
private Duration <Seed>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Duration Seed { get; public set; }
    public SchFibonacci(Duration Seed);
    [CompilerGeneratedAttribute]
protected SchFibonacci(SchFibonacci original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Duration get_Seed();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Seed(Duration value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchFibonacci left, SchFibonacci right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchFibonacci left, SchFibonacci right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchFibonacci other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchFibonacci <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Duration& Seed);
    [IteratorStateMachineAttribute("LanguageExt.SchFibonacci/<<Run>g__Go|7_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<Duration> <Run>g__Go|7_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchFilter : Schedule {
    [CompilerGeneratedAttribute]
private Schedule <Schedule>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Duration, bool> <Pred>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Schedule Schedule { get; public set; }
    public Func`2<Duration, bool> Pred { get; public set; }
    public SchFilter(Schedule Schedule, Func`2<Duration, bool> Pred);
    [CompilerGeneratedAttribute]
protected SchFilter(SchFilter original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Schedule get_Schedule();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Schedule(Schedule value);
    [CompilerGeneratedAttribute]
public Func`2<Duration, bool> get_Pred();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Pred(Func`2<Duration, bool> value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchFilter left, SchFilter right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchFilter left, SchFilter right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchFilter other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchFilter <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Schedule& Schedule, Func`2& Pred);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class LanguageExt.SchFixed : Schedule {
    [CompilerGeneratedAttribute]
private Duration <Interval>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<DateTime> <CurrentTimeFn>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Duration Interval { get; public set; }
    public Func`1<DateTime> CurrentTimeFn { get; public set; }
    public SchFixed(Duration Interval, Func`1<DateTime> CurrentTimeFn);
    [CompilerGeneratedAttribute]
protected SchFixed(SchFixed original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Duration get_Interval();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Interval(Duration value);
    [CompilerGeneratedAttribute]
public Func`1<DateTime> get_CurrentTimeFn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CurrentTimeFn(Func`1<DateTime> value);
    [NullableContextAttribute("1")]
public virtual Iterable`1<Duration> Run();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SchFixed left, SchFixed right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SchFixed left, SchFixed right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(SchFixed other);
    [NullableContextAttribute("1")]
[PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchFixed <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Duration& Interval, Func`1& CurrentTimeFn);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("LanguageExt.SchFixed/<<Run>g__Go|11_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<Duration> <Run>g__Go|11_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchForever : Schedule {
    public static Schedule Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected SchForever(SchForever original);
    private static SchForever();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchForever left, SchForever right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchForever left, SchForever right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchForever other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchForever <Clone>$();
    [IteratorStateMachineAttribute("LanguageExt.SchForever/<<Run>g__Go|3_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<Duration> <Run>g__Go|3_0();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class LanguageExt.SchHourOfDay : Schedule {
    [CompilerGeneratedAttribute]
private int <Hour>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<DateTime> <CurrentTimeFn>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public int Hour { get; public set; }
    public Func`1<DateTime> CurrentTimeFn { get; public set; }
    public SchHourOfDay(int Hour, Func`1<DateTime> CurrentTimeFn);
    [CompilerGeneratedAttribute]
protected SchHourOfDay(SchHourOfDay original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public int get_Hour();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Hour(int value);
    [CompilerGeneratedAttribute]
public Func`1<DateTime> get_CurrentTimeFn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CurrentTimeFn(Func`1<DateTime> value);
    [NullableContextAttribute("1")]
public virtual Iterable`1<Duration> Run();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SchHourOfDay left, SchHourOfDay right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SchHourOfDay left, SchHourOfDay right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(SchHourOfDay other);
    [NullableContextAttribute("1")]
[PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchHourOfDay <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& Hour, Func`1& CurrentTimeFn);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("LanguageExt.SchHourOfDay/<<Run>g__Go|11_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<Duration> <Run>g__Go|11_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchInterleave : Schedule {
    [CompilerGeneratedAttribute]
private Schedule <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private Schedule <Right>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Schedule Left { get; public set; }
    public Schedule Right { get; public set; }
    public SchInterleave(Schedule Left, Schedule Right);
    [CompilerGeneratedAttribute]
protected SchInterleave(SchInterleave original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Schedule get_Left();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Left(Schedule value);
    [CompilerGeneratedAttribute]
public Schedule get_Right();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Right(Schedule value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchInterleave left, SchInterleave right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchInterleave left, SchInterleave right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchInterleave other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchInterleave <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Schedule& Left, Schedule& Right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchIntersect : Schedule {
    [CompilerGeneratedAttribute]
private Schedule <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private Schedule <Right>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Schedule Left { get; public set; }
    public Schedule Right { get; public set; }
    public SchIntersect(Schedule Left, Schedule Right);
    [CompilerGeneratedAttribute]
protected SchIntersect(SchIntersect original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Schedule get_Left();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Left(Schedule value);
    [CompilerGeneratedAttribute]
public Schedule get_Right();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Right(Schedule value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchIntersect left, SchIntersect right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchIntersect left, SchIntersect right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchIntersect other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchIntersect <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Schedule& Left, Schedule& Right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchItems : Schedule {
    [CompilerGeneratedAttribute]
private Iterable`1<Duration> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Iterable`1<Duration> Items { get; public set; }
    public SchItems(Iterable`1<Duration> Items);
    [CompilerGeneratedAttribute]
protected SchItems(SchItems original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Iterable`1<Duration> get_Items();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Items(Iterable`1<Duration> value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchItems left, SchItems right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchItems left, SchItems right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchItems other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchItems <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Iterable`1& Items);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchJitter1 : Schedule {
    [CompilerGeneratedAttribute]
private Schedule <Schedule>k__BackingField;
    [CompilerGeneratedAttribute]
private Duration <MinRandom>k__BackingField;
    [CompilerGeneratedAttribute]
private Duration <MaxRandom>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private Option`1<int> <Seed>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Schedule Schedule { get; public set; }
    public Duration MinRandom { get; public set; }
    public Duration MaxRandom { get; public set; }
    [NullableAttribute("0")]
public Option`1<int> Seed { get; public set; }
    [NullableContextAttribute("0")]
public SchJitter1(Schedule Schedule, Duration MinRandom, Duration MaxRandom, Option`1<int> Seed);
    [CompilerGeneratedAttribute]
protected SchJitter1(SchJitter1 original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Schedule get_Schedule();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Schedule(Schedule value);
    [CompilerGeneratedAttribute]
public Duration get_MinRandom();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MinRandom(Duration value);
    [CompilerGeneratedAttribute]
public Duration get_MaxRandom();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MaxRandom(Duration value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public Option`1<int> get_Seed();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Seed(Option`1<int> value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchJitter1 left, SchJitter1 right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchJitter1 left, SchJitter1 right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchJitter1 other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchJitter1 <Clone>$();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public void Deconstruct(Schedule& Schedule, Duration& MinRandom, Duration& MaxRandom, Option`1& Seed);
    [CompilerGeneratedAttribute]
private Duration <Run>b__19_0(Duration x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchJitter2 : Schedule {
    [CompilerGeneratedAttribute]
private Schedule <Schedule>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Factor>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private Option`1<int> <Seed>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Schedule Schedule { get; public set; }
    public double Factor { get; public set; }
    [NullableAttribute("0")]
public Option`1<int> Seed { get; public set; }
    [NullableContextAttribute("0")]
public SchJitter2(Schedule Schedule, double Factor, Option`1<int> Seed);
    [CompilerGeneratedAttribute]
protected SchJitter2(SchJitter2 original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Schedule get_Schedule();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Schedule(Schedule value);
    [CompilerGeneratedAttribute]
public double get_Factor();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Factor(double value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public Option`1<int> get_Seed();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Seed(Option`1<int> value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchJitter2 left, SchJitter2 right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchJitter2 left, SchJitter2 right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchJitter2 other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchJitter2 <Clone>$();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public void Deconstruct(Schedule& Schedule, Double& Factor, Option`1& Seed);
    [CompilerGeneratedAttribute]
private Duration <Run>b__15_0(Duration x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchLinear : Schedule {
    [CompilerGeneratedAttribute]
private Duration <Seed>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Factor>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Duration Seed { get; public set; }
    public double Factor { get; public set; }
    public SchLinear(Duration Seed, double Factor);
    [CompilerGeneratedAttribute]
protected SchLinear(SchLinear original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Duration get_Seed();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Seed(Duration value);
    [CompilerGeneratedAttribute]
public double get_Factor();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Factor(double value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchLinear left, SchLinear right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchLinear left, SchLinear right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchLinear other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchLinear <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Duration& Seed, Double& Factor);
    [IteratorStateMachineAttribute("LanguageExt.SchLinear/<<Run>g__Go|11_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<Duration> <Run>g__Go|11_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchMap : Schedule {
    [CompilerGeneratedAttribute]
private Schedule <Schedule>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Duration, Duration> <F>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Schedule Schedule { get; public set; }
    public Func`2<Duration, Duration> F { get; public set; }
    public SchMap(Schedule Schedule, Func`2<Duration, Duration> F);
    [CompilerGeneratedAttribute]
protected SchMap(SchMap original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Schedule get_Schedule();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Schedule(Schedule value);
    [CompilerGeneratedAttribute]
public Func`2<Duration, Duration> get_F();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_F(Func`2<Duration, Duration> value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchMap left, SchMap right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchMap left, SchMap right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchMap other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchMap <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Schedule& Schedule, Func`2& F);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchMapIndex : Schedule {
    [CompilerGeneratedAttribute]
private Schedule <Schedule>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<Duration, int, Duration> <F>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Schedule Schedule { get; public set; }
    public Func`3<Duration, int, Duration> F { get; public set; }
    public SchMapIndex(Schedule Schedule, Func`3<Duration, int, Duration> F);
    [CompilerGeneratedAttribute]
protected SchMapIndex(SchMapIndex original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Schedule get_Schedule();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Schedule(Schedule value);
    [CompilerGeneratedAttribute]
public Func`3<Duration, int, Duration> get_F();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_F(Func`3<Duration, int, Duration> value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchMapIndex left, SchMapIndex right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchMapIndex left, SchMapIndex right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchMapIndex other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchMapIndex <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Schedule& Schedule, Func`3& F);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchMaxCumulativeDelay : Schedule {
    [CompilerGeneratedAttribute]
private Schedule <Schedule>k__BackingField;
    [CompilerGeneratedAttribute]
private Duration <Max>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Schedule Schedule { get; public set; }
    public Duration Max { get; public set; }
    public SchMaxCumulativeDelay(Schedule Schedule, Duration Max);
    [CompilerGeneratedAttribute]
protected SchMaxCumulativeDelay(SchMaxCumulativeDelay original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Schedule get_Schedule();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Schedule(Schedule value);
    [CompilerGeneratedAttribute]
public Duration get_Max();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Max(Duration value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchMaxCumulativeDelay left, SchMaxCumulativeDelay right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchMaxCumulativeDelay left, SchMaxCumulativeDelay right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchMaxCumulativeDelay other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchMaxCumulativeDelay <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Schedule& Schedule, Duration& Max);
    [IteratorStateMachineAttribute("LanguageExt.SchMaxCumulativeDelay/<<Run>g__Go|11_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<Duration> <Run>g__Go|11_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchMaxDelay : Schedule {
    [CompilerGeneratedAttribute]
private Schedule <Schedule>k__BackingField;
    [CompilerGeneratedAttribute]
private Duration <Max>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Schedule Schedule { get; public set; }
    public Duration Max { get; public set; }
    public SchMaxDelay(Schedule Schedule, Duration Max);
    [CompilerGeneratedAttribute]
protected SchMaxDelay(SchMaxDelay original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Schedule get_Schedule();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Schedule(Schedule value);
    [CompilerGeneratedAttribute]
public Duration get_Max();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Max(Duration value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchMaxDelay left, SchMaxDelay right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchMaxDelay left, SchMaxDelay right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchMaxDelay other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchMaxDelay <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Schedule& Schedule, Duration& Max);
    [CompilerGeneratedAttribute]
private Duration <Run>b__11_0(Duration x);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class LanguageExt.SchMinuteOfHour : Schedule {
    [CompilerGeneratedAttribute]
private int <Minute>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<DateTime> <CurrentTimeFn>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public int Minute { get; public set; }
    public Func`1<DateTime> CurrentTimeFn { get; public set; }
    public SchMinuteOfHour(int Minute, Func`1<DateTime> CurrentTimeFn);
    [CompilerGeneratedAttribute]
protected SchMinuteOfHour(SchMinuteOfHour original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public int get_Minute();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Minute(int value);
    [CompilerGeneratedAttribute]
public Func`1<DateTime> get_CurrentTimeFn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CurrentTimeFn(Func`1<DateTime> value);
    [NullableContextAttribute("1")]
public virtual Iterable`1<Duration> Run();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SchMinuteOfHour left, SchMinuteOfHour right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SchMinuteOfHour left, SchMinuteOfHour right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(SchMinuteOfHour other);
    [NullableContextAttribute("1")]
[PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchMinuteOfHour <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& Minute, Func`1& CurrentTimeFn);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("LanguageExt.SchMinuteOfHour/<<Run>g__Go|11_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<Duration> <Run>g__Go|11_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchNever : Schedule {
    public static Schedule Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected SchNever(SchNever original);
    private static SchNever();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchNever left, SchNever right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchNever left, SchNever right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchNever other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchNever <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchRepeat : Schedule {
    [CompilerGeneratedAttribute]
private Schedule <Schedule>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Times>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Schedule Schedule { get; public set; }
    public int Times { get; public set; }
    public SchRepeat(Schedule Schedule, int Times);
    [CompilerGeneratedAttribute]
protected SchRepeat(SchRepeat original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Schedule get_Schedule();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Schedule(Schedule value);
    [CompilerGeneratedAttribute]
public int get_Times();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Times(int value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchRepeat left, SchRepeat right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchRepeat left, SchRepeat right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchRepeat other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchRepeat <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Schedule& Schedule, Int32& Times);
    [IteratorStateMachineAttribute("LanguageExt.SchRepeat/<<Run>g__Go|11_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<Duration> <Run>g__Go|11_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchRepeatForever : Schedule {
    [CompilerGeneratedAttribute]
private Schedule <Schedule>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Schedule Schedule { get; public set; }
    public SchRepeatForever(Schedule Schedule);
    [CompilerGeneratedAttribute]
protected SchRepeatForever(SchRepeatForever original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Schedule get_Schedule();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Schedule(Schedule value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchRepeatForever left, SchRepeatForever right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchRepeatForever left, SchRepeatForever right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchRepeatForever other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchRepeatForever <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Schedule& Schedule);
    [IteratorStateMachineAttribute("LanguageExt.SchRepeatForever/<<Run>g__Go|7_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<Duration> <Run>g__Go|7_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchResetAfter : Schedule {
    [CompilerGeneratedAttribute]
private Schedule <Schedule>k__BackingField;
    [CompilerGeneratedAttribute]
private Duration <Max>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Schedule Schedule { get; public set; }
    public Duration Max { get; public set; }
    public SchResetAfter(Schedule Schedule, Duration Max);
    [CompilerGeneratedAttribute]
protected SchResetAfter(SchResetAfter original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Schedule get_Schedule();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Schedule(Schedule value);
    [CompilerGeneratedAttribute]
public Duration get_Max();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Max(Duration value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchResetAfter left, SchResetAfter right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchResetAfter left, SchResetAfter right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchResetAfter other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchResetAfter <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Schedule& Schedule, Duration& Max);
    [IteratorStateMachineAttribute("LanguageExt.SchResetAfter/<<Run>g__Go|11_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<Duration> <Run>g__Go|11_0();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class LanguageExt.SchSecondOfMinute : Schedule {
    [CompilerGeneratedAttribute]
private int <Second>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<DateTime> <CurrentTimeFn>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public int Second { get; public set; }
    public Func`1<DateTime> CurrentTimeFn { get; public set; }
    public SchSecondOfMinute(int Second, Func`1<DateTime> CurrentTimeFn);
    [CompilerGeneratedAttribute]
protected SchSecondOfMinute(SchSecondOfMinute original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public int get_Second();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Second(int value);
    [CompilerGeneratedAttribute]
public Func`1<DateTime> get_CurrentTimeFn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CurrentTimeFn(Func`1<DateTime> value);
    [NullableContextAttribute("1")]
public virtual Iterable`1<Duration> Run();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SchSecondOfMinute left, SchSecondOfMinute right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SchSecondOfMinute left, SchSecondOfMinute right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(SchSecondOfMinute other);
    [NullableContextAttribute("1")]
[PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchSecondOfMinute <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& Second, Func`1& CurrentTimeFn);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("LanguageExt.SchSecondOfMinute/<<Run>g__Go|11_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<Duration> <Run>g__Go|11_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchSkip : Schedule {
    [CompilerGeneratedAttribute]
private Schedule <Schedule>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Schedule Schedule { get; public set; }
    public int Count { get; public set; }
    public SchSkip(Schedule Schedule, int Count);
    [CompilerGeneratedAttribute]
protected SchSkip(SchSkip original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Schedule get_Schedule();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Schedule(Schedule value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Count(int value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchSkip left, SchSkip right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchSkip left, SchSkip right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchSkip other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchSkip <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Schedule& Schedule, Int32& Count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchTail : Schedule {
    [CompilerGeneratedAttribute]
private Schedule <Schedule>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Schedule Schedule { get; public set; }
    public SchTail(Schedule Schedule);
    [CompilerGeneratedAttribute]
protected SchTail(SchTail original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Schedule get_Schedule();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Schedule(Schedule value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchTail left, SchTail right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchTail left, SchTail right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchTail other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchTail <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Schedule& Schedule);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchTake : Schedule {
    [CompilerGeneratedAttribute]
private Schedule <Schedule>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Schedule Schedule { get; public set; }
    public int Count { get; public set; }
    public SchTake(Schedule Schedule, int Count);
    [CompilerGeneratedAttribute]
protected SchTake(SchTake original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Schedule get_Schedule();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Schedule(Schedule value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Count(int value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchTake left, SchTake right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchTake left, SchTake right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchTake other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchTake <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Schedule& Schedule, Int32& Count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SchUnion : Schedule {
    [CompilerGeneratedAttribute]
private Schedule <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private Schedule <Right>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Schedule Left { get; public set; }
    public Schedule Right { get; public set; }
    public SchUnion(Schedule Left, Schedule Right);
    [CompilerGeneratedAttribute]
protected SchUnion(SchUnion original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Schedule get_Left();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Left(Schedule value);
    [CompilerGeneratedAttribute]
public Schedule get_Right();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Right(Schedule value);
    public virtual Iterable`1<Duration> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SchUnion left, SchUnion right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SchUnion left, SchUnion right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SchUnion other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchUnion <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Schedule& Left, Schedule& Right);
    [IteratorStateMachineAttribute("LanguageExt.SchUnion/<<Run>g__Go|11_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<Duration> <Run>g__Go|11_0();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class LanguageExt.SchUpTo : Schedule {
    [CompilerGeneratedAttribute]
private Duration <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<DateTime> <CurrentTimeFn>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Duration Max { get; public set; }
    public Func`1<DateTime> CurrentTimeFn { get; public set; }
    public SchUpTo(Duration Max, Func`1<DateTime> CurrentTimeFn);
    [CompilerGeneratedAttribute]
protected SchUpTo(SchUpTo original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Duration get_Max();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Max(Duration value);
    [CompilerGeneratedAttribute]
public Func`1<DateTime> get_CurrentTimeFn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CurrentTimeFn(Func`1<DateTime> value);
    [NullableContextAttribute("1")]
public virtual Iterable`1<Duration> Run();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SchUpTo left, SchUpTo right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SchUpTo left, SchUpTo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(SchUpTo other);
    [NullableContextAttribute("1")]
[PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchUpTo <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Duration& Max, Func`1& CurrentTimeFn);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("LanguageExt.SchUpTo/<<Run>g__Go|11_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<Duration> <Run>g__Go|11_0();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class LanguageExt.SchWindowed : Schedule {
    [CompilerGeneratedAttribute]
private Duration <Interval>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<DateTime> <CurrentTimeFn>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Duration Interval { get; public set; }
    public Func`1<DateTime> CurrentTimeFn { get; public set; }
    public SchWindowed(Duration Interval, Func`1<DateTime> CurrentTimeFn);
    [CompilerGeneratedAttribute]
protected SchWindowed(SchWindowed original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Duration get_Interval();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Interval(Duration value);
    [CompilerGeneratedAttribute]
public Func`1<DateTime> get_CurrentTimeFn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CurrentTimeFn(Func`1<DateTime> value);
    [NullableContextAttribute("1")]
public virtual Iterable`1<Duration> Run();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SchWindowed left, SchWindowed right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SchWindowed left, SchWindowed right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Schedule other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(SchWindowed other);
    [NullableContextAttribute("1")]
[PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SchWindowed <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Duration& Interval, Func`1& CurrentTimeFn);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("LanguageExt.SchWindowed/<<Run>g__Go|11_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<Duration> <Run>g__Go|11_0();
}
[IsReadOnlyAttribute]
internal class LanguageExt.Sec : ValueType {
    public static int Mask;
    public int Offset;
    public Sec(int offset);
    public Sec Next();
}
public static class LanguageExt.Semigroup : object {
    [NullableContextAttribute("1")]
[PureAttribute]
public static A combine(A x, A y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.SemigroupK : object {
    [ExtensionAttribute]
[PureAttribute]
public static K`2<M, A> Combine(K`2<M, A> mx, K`2<M, A> my);
    [PureAttribute]
public static K`2<M, A> combine(K`2<M, A> mx, K`2<M, A> my);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Seq : object {
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> flatten(Seq`1<Seq`1<A>> ma);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> empty();
    [PureAttribute]
public static Seq`1<A> singleton(A value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> create();
    [PureAttribute]
public static Seq`1<A> create(A[] items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> createRange(ReadOnlySpan`1<A> items);
    [PureAttribute]
public static Seq`1<A> createRange(IEnumerable`1<A> items);
    [PureAttribute]
public static Seq`1<A> generate(int count, Func`2<int, A> generator);
    [PureAttribute]
public static Seq`1<A> repeat(A item, int count);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Option`1<A> head(Seq`1<A> list);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Option`1<A> last(Seq`1<A> list);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> init(Seq`1<A> list);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<A> tail(Seq`1<A> list);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<B> map(Seq`1<A> list, Func`2<A, B> map);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<B> map(Seq`1<A> list, Func`3<int, A, B> map);
    [PureAttribute]
public static Seq`1<A> filter(Seq`1<A> list, Func`2<A, bool> predicate);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<B> choose(Seq`1<A> list, Func`2<A, Option`1<B>> selector);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<B> choose(Seq`1<A> list, Func`3<int, A, Option`1<B>> selector);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<T> rev(Seq`1<T> list);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<T> append(Seq`1<T> lhs, Seq`1<T> rhs);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<T> append(Seq`1<T> x, Seq`1<Seq`1<T>> xs);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<T> append(Seq`1[] lists);
    [PureAttribute]
public static Seq`1<S> scan(Seq`1<T> list, S state, Func`3<S, T, S> folder);
    [PureAttribute]
public static Seq`1<S> scanBack(Seq`1<T> list, S state, Func`3<S, T, S> folder);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<V> zip(Seq`1<T> list, Seq`1<U> other, Func`3<T, U, V> zipper);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<ValueTuple`2<T, U>> zip(Seq`1<T> list, Seq`1<U> other);
    [PureAttribute]
public static bool forall(Seq`1<T> list, Func`2<T, bool> pred);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<T> distinct(Seq`1<T> list);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Seq`1<T> distinct(Seq`1<T> list);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<T> distinct(Seq`1<T> list, Func`2<T, K> keySelector, Option`1<Func`3<K, K, bool>> compare);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<T> take(Seq`1<T> list, int count);
    [PureAttribute]
public static Seq`1<T> takeWhile(Seq`1<T> list, Func`2<T, bool> pred);
    [PureAttribute]
public static Seq`1<T> takeWhile(Seq`1<T> list, Func`3<T, int, bool> pred);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<Seq`1<A>> tails(Seq`1<A> self);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Seq`1<Seq`1<A>> tailsr(Seq`1<A> self);
    [PureAttribute]
public static ValueTuple`2<Seq`1<T>, Seq`1<T>> span(Seq`1<T> self, Func`2<T, bool> pred);
    internal static Seq`1<A> FromSingleValue(A value);
    internal static Seq`1<A> FromArray(A[] value);
    internal static Seq`1<A> FromArray(A[] value, int length);
    private static override K`2<Seq, B> LanguageExt.Traits.Monad<LanguageExt.Seq>.Bind(K`2<Seq, A> ma, Func`2<A, K`2<Seq, B>> f);
    private static override K`2<Seq, B> LanguageExt.Traits.Functor<LanguageExt.Seq>.Map(Func`2<A, B> f, K`2<Seq, A> ma);
    private static override K`2<Seq, A> LanguageExt.Traits.Applicative<LanguageExt.Seq>.Pure(A value);
    private static override K`2<Seq, B> LanguageExt.Traits.Applicative<LanguageExt.Seq>.Apply(K`2<Seq, Func`2<A, B>> mf, K`2<Seq, A> ma);
    private static override K`2<Seq, B> LanguageExt.Traits.Applicative<LanguageExt.Seq>.Action(K`2<Seq, A> ma, K`2<Seq, B> mb);
    private static override K`2<Seq, A> LanguageExt.Traits.MonoidK<LanguageExt.Seq>.Empty();
    private static override K`2<Seq, A> LanguageExt.Traits.SemigroupK<LanguageExt.Seq>.Combine(K`2<Seq, A> ma, K`2<Seq, A> mb);
    private static override int LanguageExt.Traits.Foldable<LanguageExt.Seq>.Count(K`2<Seq, A> ta);
    private static override bool LanguageExt.Traits.Foldable<LanguageExt.Seq>.IsEmpty(K`2<Seq, A> ta);
    private static override Option`1<A> LanguageExt.Traits.Foldable<LanguageExt.Seq>.At(K`2<Seq, A> ta, Index index);
    private static override Option`1<A> LanguageExt.Traits.Foldable<LanguageExt.Seq>.Head(K`2<Seq, A> ta);
    private static override Option`1<A> LanguageExt.Traits.Foldable<LanguageExt.Seq>.Last(K`2<Seq, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Seq>.FoldWhile(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<Seq, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Seq>.FoldBackWhile(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<Seq, A> ta);
    private static override K`2<F, K`2<Seq, B>> LanguageExt.Traits.Traversable<LanguageExt.Seq>.Traverse(Func`2<A, K`2<F, B>> f, K`2<Seq, A> ta);
    private static override K`2<F, K`2<Seq, B>> LanguageExt.Traits.Traversable<LanguageExt.Seq>.TraverseM(Func`2<A, K`2<F, B>> f, K`2<Seq, A> ta);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[CollectionBuilderAttribute("LanguageExt.Seq", "createRange")]
public class LanguageExt.Seq`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Seq`1<A> <Empty>k__BackingField;
    private ISeqInternal`1<A> value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Seq`1<A> Empty { get; }
    internal ISeqInternal`1<A> Value { get; }
    [NullableAttribute("2")]
[PureAttribute]
public object Case { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Lens`2<Seq`1<A>, A> head { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Lens`2<Seq`1<A>, Option`1<A>> headOrNone { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Lens`2<Seq`1<A>, Seq`1<A>> tail { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Lens`2<Seq`1<A>, A> last { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Lens`2<Seq`1<A>, Option`1<A>> lastOrNone { get; }
    public A Item { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Option`1<A> Head { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Seq`1<A> Tail { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Seq`1<A> Init { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Option`1<A> Last { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public int Length { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Seq`1<Seq`1<A>> Inits { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Seq`1<Seq`1<A>> NonEmptyInits { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Seq`1<Seq`1<A>> Tails { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Seq`1<Seq`1<A>> NonEmptyTails { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Seq`1<A> AdditiveIdentity { get; }
    public Seq`1(IEnumerable`1<A> ma);
    public Seq`1(ReadOnlySpan`1<A> ma);
    internal Seq`1(ISeqInternal`1<A> value);
    private static Seq`1();
    [CompilerGeneratedAttribute]
public static override Seq`1<A> get_Empty();
    internal ISeqInternal`1<A> get_Value();
    [NullableContextAttribute("2")]
public object get_Case();
    public void Deconstruct(A& head, Seq`1& tail);
    public static Lens`2<Seq`1<A>, A> get_head();
    public static Lens`2<Seq`1<A>, Option`1<A>> get_headOrNone();
    public static Lens`2<Seq`1<A>, Seq`1<A>> get_tail();
    public static Lens`2<Seq`1<A>, A> get_last();
    public static Lens`2<Seq`1<A>, Option`1<A>> get_lastOrNone();
    [NullableContextAttribute("2")]
[PureAttribute]
public static Lens`2<Seq`1<A>, Seq`1<B>> map(Lens`2<A, B> lens);
    public A get_Item(Index index);
    [PureAttribute]
public Seq`1<A> Add(A value);
    [PureAttribute]
public Seq`1<A> Concat(IEnumerable`1<A> items);
    [PureAttribute]
public Seq`1<A> Concat(Lst`1& items);
    [PureAttribute]
public Seq`1<A> Concat(ReadOnlySpan`1& items);
    [PureAttribute]
public Seq`1<A> Concat(Set`1& items);
    [PureAttribute]
public Seq`1<A> Concat(HashSet`1& items);
    public Seq`1<A> Concat(Arr`1& items);
    public Seq`1<A> Concat(Stck`1& items);
    public Seq`1<A> Concat(IReadOnlyCollection`1<A> items);
    [PureAttribute]
public Seq`1<A> Concat(Seq`1& rhs);
    [PureAttribute]
internal Seq`1<A> Cons(A value);
    public Option`1<A> get_Head();
    public Seq`1<A> get_Tail();
    public Seq`1<A> get_Init();
    public Option`1<A> get_Last();
    public bool get_IsEmpty();
    public int get_Count();
    public int get_Length();
    [PureAttribute]
public IEnumerable`1<A> AsEnumerable();
    [PureAttribute]
public StreamT`2<M, A> AsStream();
    [PureAttribute]
public Iterable`1<A> AsIterable();
    [PureAttribute]
public B Match(Func`1<B> Empty, Func`3<A, Seq`1<A>, B> Tail);
    [PureAttribute]
public B Match(Func`1<B> Empty, Func`2<A, B> Head, Func`3<A, Seq`1<A>, B> Tail);
    [PureAttribute]
public B Match(Func`1<B> Empty, Func`2<Seq`1<A>, B> Seq);
    [PureAttribute]
public B Match(Func`1<B> Empty, Func`2<A, B> Head, Func`2<Seq`1<A>, B> Tail);
    [PureAttribute]
public Seq`1<A> Do(Action`1<A> f);
    [PureAttribute]
public K`2<F, Seq`1<B>> Traverse(Func`2<A, K`2<F, B>> f);
    [PureAttribute]
public K`2<M, Seq`1<B>> TraverseM(Func`2<A, K`2<M, B>> f);
    [PureAttribute]
public Seq`1<B> Map(Func`2<A, B> f);
    [PureAttribute]
public Seq`1<B> Map(Func`3<A, int, B> f);
    [PureAttribute]
public Seq`1<B> Select(Func`2<A, B> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public Seq`1<B> Bind(Func`2<A, Seq`1<B>> f);
    [PureAttribute]
public Seq`1<B> Bind(Func`2<A, K`2<Seq, B>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public Seq`1<C> SelectMany(Func`2<A, Seq`1<B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Seq`1<A> Filter(Func`2<A, bool> f);
    [PureAttribute]
public Seq`1<A> Where(Func`2<A, bool> f);
    [PureAttribute]
public bool Exists(Func`2<A, bool> f);
    [PureAttribute]
public bool ForAll(Func`2<A, bool> f);
    [PureAttribute]
public bool Any();
    [PureAttribute]
public Seq`1<A> Intersperse(A value);
    [PureAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[PureAttribute]
public sealed virtual int CompareTo(object obj);
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToFullString(string separator);
    [PureAttribute]
public string ToFullArrayString(string separator);
    [PureAttribute]
public sealed virtual Seq`1<A> Combine(Seq`1<A> y);
    public static override Seq`1<A> op_Addition(Seq`1<A> x, Seq`1<A> y);
    public static override bool op_GreaterThan(Seq`1<A> x, Seq`1<A> y);
    public static override bool op_GreaterThanOrEqual(Seq`1<A> x, Seq`1<A> y);
    public static override bool op_LessThan(Seq`1<A> x, Seq`1<A> y);
    public static override bool op_LessThanOrEqual(Seq`1<A> x, Seq`1<A> y);
    public static override bool op_Equality(Seq`1<A> x, Seq`1<A> y);
    public static override bool op_Inequality(Seq`1<A> x, Seq`1<A> y);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [PureAttribute]
public sealed virtual bool Equals(Seq`1<A> rhs);
    [NullableContextAttribute("0")]
[PureAttribute]
public bool Equals(Seq`1<A> rhs);
    [PureAttribute]
public Seq`1<A> Skip(int amount);
    [PureAttribute]
public Seq`1<A> Take(int amount);
    [PureAttribute]
public Seq`1<A> TakeWhile(Func`2<A, bool> pred);
    [PureAttribute]
public Seq`1<A> TakeWhile(Func`3<A, int, bool> pred);
    public Seq`1<Seq`1<A>> get_Inits();
    public Seq`1<Seq`1<A>> get_NonEmptyInits();
    public Seq`1<Seq`1<A>> get_Tails();
    public Seq`1<Seq`1<A>> get_NonEmptyTails();
    public ValueTuple`2<Seq`1<A>, Seq`1<A>> Partition(Func`2<A, bool> predicate);
    [PureAttribute]
public sealed virtual int CompareTo(Seq`1<A> rhs);
    [NullableContextAttribute("0")]
[PureAttribute]
public int CompareTo(Seq`1<A> rhs);
    public Seq`1<A> Strict();
    [PureAttribute]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public static Seq`1<A> op_Implicit(SeqEmpty _);
    [NullableContextAttribute("2")]
[PureAttribute]
public Seq`1<B> Cast();
    public static override Seq`1<A> get_AdditiveIdentity();
    [IteratorStateMachineAttribute("LanguageExt.Seq`1/<<Bind>g__Yield|63_0>d`1")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<B> <Bind>g__Yield|63_0(Seq`1<A> ma, Func`2<A, Seq`1<B>> bnd);
    [IteratorStateMachineAttribute("LanguageExt.Seq`1/<<Bind>g__Yield|64_0>d`1")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<B> <Bind>g__Yield|64_0(K`2<Seq, A> ma, Func`2<A, K`2<Seq, B>> bnd);
    [IteratorStateMachineAttribute("LanguageExt.Seq`1/<<SelectMany>g__Yield|65_0>d`2")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<C> <SelectMany>g__Yield|65_0(Seq`1<A> ma, Func`2<A, Seq`1<B>> bnd, Func`3<A, B, C> prj);
    [IteratorStateMachineAttribute("LanguageExt.Seq`1/<<Filter>g__Yield|66_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<A> <Filter>g__Yield|66_0(Seq`1<A> items, Func`2<A, bool> f);
    [IteratorStateMachineAttribute("LanguageExt.Seq`1/<<TakeWhile>g__Yield|90_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<A> <TakeWhile>g__Yield|90_0(IEnumerable`1<A> xs, Func`2<A, bool> f);
    [IteratorStateMachineAttribute("LanguageExt.Seq`1/<<TakeWhile>g__Yield|91_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<A> <TakeWhile>g__Yield|91_0(IEnumerable`1<A> xs, Func`3<A, int, bool> f);
    [IteratorStateMachineAttribute("LanguageExt.Seq`1/<<get_Tails>g__go|97_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<Seq`1<A>> <get_Tails>g__go|97_0(Seq`1<A> ma);
    [IteratorStateMachineAttribute("LanguageExt.Seq`1/<<get_NonEmptyTails>g__go|99_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<Seq`1<A>> <get_NonEmptyTails>g__go|99_0(Seq`1<A> ma);
    [IteratorStateMachineAttribute("LanguageExt.Seq`1/<<Cast>g__Yield|107_0>d`1")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<B> <Cast>g__Yield|107_0(Seq`1<A> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class LanguageExt.SeqConcat`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Seq`1<ISeqInternal`1<A>> ms;
    private int selfHash;
    public A Item { get; }
    public SeqType Type { get; }
    public A Head { get; }
    public ISeqInternal`1<A> Tail { get; }
    public bool IsEmpty { get; }
    public ISeqInternal`1<A> Init { get; }
    public A Last { get; }
    public int Count { get; }
    public SeqConcat`1(Seq`1<ISeqInternal`1<A>> ms);
    public sealed virtual A get_Item(int index);
    public sealed virtual Option`1<A> At(int index);
    public sealed virtual SeqType get_Type();
    public sealed virtual A get_Head();
    public sealed virtual ISeqInternal`1<A> get_Tail();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual ISeqInternal`1<A> get_Init();
    public sealed virtual A get_Last();
    public sealed virtual int get_Count();
    public SeqConcat`1<A> AddSeq(ISeqInternal`1<A> ma);
    public SeqConcat`1<A> AddSeqRange(Seq`1<ISeqInternal`1<A>> ma);
    public SeqConcat`1<A> ConsSeq(ISeqInternal`1<A> ma);
    public sealed virtual ISeqInternal`1<A> Add(A value);
    public sealed virtual ISeqInternal`1<A> Cons(A value);
    public sealed virtual bool Exists(Func`2<A, bool> f);
    public sealed virtual S Fold(S state, Func`3<S, A, S> f);
    public sealed virtual S FoldBack(S state, Func`3<S, A, S> f);
    public sealed virtual bool ForAll(Func`2<A, bool> f);
    [IteratorStateMachineAttribute("LanguageExt.SeqConcat`1/<GetEnumerator>d__29")]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    public sealed virtual Unit Iter(Action`1<A> f);
    public sealed virtual ISeqInternal`1<A> Skip(int amount);
    public sealed virtual ISeqInternal`1<A> Strict();
    public sealed virtual ISeqInternal`1<A> Take(int amount);
    [IteratorStateMachineAttribute("LanguageExt.SeqConcat`1/<System-Collections-IEnumerable-GetEnumerator>d__34")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private ISeqInternal`1<A> Flatten();
    public virtual int GetHashCode();
    public sealed virtual int GetHashCode(int hash);
}
public class LanguageExt.SeqEmpty : ValueType {
    public static SeqEmpty Default;
    private static SeqEmpty();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class LanguageExt.SeqEmptyInternal`1 : object {
    public static ISeqInternal`1<A> Default;
    public A Item { get; }
    public A Head { get; }
    public ISeqInternal`1<A> Tail { get; }
    public bool IsEmpty { get; }
    public ISeqInternal`1<A> Init { get; }
    public A Last { get; }
    public int Count { get; }
    public SeqType Type { get; }
    private static SeqEmptyInternal`1();
    public sealed virtual A get_Item(int index);
    public sealed virtual Option`1<A> At(int index);
    public sealed virtual A get_Head();
    public sealed virtual ISeqInternal`1<A> get_Tail();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual ISeqInternal`1<A> get_Init();
    public sealed virtual A get_Last();
    public sealed virtual int get_Count();
    public sealed virtual ISeqInternal`1<A> Add(A value);
    public sealed virtual ISeqInternal`1<A> Cons(A value);
    public sealed virtual S Fold(S state, Func`3<S, A, S> f);
    public sealed virtual S FoldBack(S state, Func`3<S, A, S> f);
    public sealed virtual ISeqInternal`1<A> Skip(int amount);
    public sealed virtual ISeqInternal`1<A> Strict();
    public sealed virtual ISeqInternal`1<A> Take(int amount);
    [IteratorStateMachineAttribute("LanguageExt.SeqEmptyInternal`1/<GetEnumerator>d__23")]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    [IteratorStateMachineAttribute("LanguageExt.SeqEmptyInternal`1/<System-Collections-IEnumerable-GetEnumerator>d__24")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual Unit Iter(Action`1<A> f);
    public sealed virtual bool Exists(Func`2<A, bool> f);
    public sealed virtual bool ForAll(Func`2<A, bool> f);
    public sealed virtual SeqType get_Type();
    public virtual int GetHashCode();
    public sealed virtual int GetHashCode(int offsetBasis);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.SeqExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Seq`1<A> As(K`2<Seq, A> xs);
    [ExtensionAttribute]
[PureAttribute]
public static Seq`1<A> Flatten(Seq`1<Seq`1<A>> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Seq`1<B> Choose(Seq`1<A> list, Func`2<A, Option`1<B>> selector);
    [ExtensionAttribute]
[PureAttribute]
public static Seq`1<B> Choose(Seq`1<A> list, Func`3<int, A, Option`1<B>> selector);
    [ExtensionAttribute]
[PureAttribute]
public static Seq`1<T> Rev(Seq`1<T> list);
    [ExtensionAttribute]
[PureAttribute]
public static Seq`1<T> Append(Seq`1<T> lhs, Seq`1<T> rhs);
    [ExtensionAttribute]
[PureAttribute]
public static Seq`1<T> Append(Seq`1<T> x, Seq`1<Seq`1<T>> xs);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static Seq`1<S> Scan(Seq`1<T> list, S state, Func`3<S, T, S> folder);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static Seq`1<S> ScanBack(Seq`1<T> list, S state, Func`3<S, T, S> folder);
    [ExtensionAttribute]
[PureAttribute]
public static Seq`1<V> Zip(Seq`1<T> list, Seq`1<U> other, Func`3<T, U, V> zipper);
    [ExtensionAttribute]
[PureAttribute]
public static Seq`1<ValueTuple`2<T, U>> Zip(Seq`1<T> list, Seq`1<U> other);
    [ExtensionAttribute]
[PureAttribute]
public static Seq`1<T> Distinct(Seq`1<T> list);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[PureAttribute]
public static Seq`1<T> Distinct(Seq`1<T> list);
    [ExtensionAttribute]
[PureAttribute]
public static Seq`1<T> Distinct(Seq`1<T> list, Func`2<T, K> keySelector, Option`1<Func`3<K, K, bool>> compare);
    [ExtensionAttribute]
[PureAttribute]
public static Seq`1<Seq`1<A>> Tails(Seq`1<A> self);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTuple`2<Seq`1<T>, Seq`1<T>> Span(Seq`1<T> self, Func`2<T, bool> pred);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static IQueryable`1<A> AsQueryable(Seq`1<A> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class LanguageExt.SeqLazy`1 : object {
    private static int DefaultCapacity;
    private static int NoCons;
    private A[] data;
    private int start;
    private int count;
    private int consDisallowed;
    private Enum`1<A> seq;
    private int seqStart;
    private int selfHash;
    public A Item { get; }
    public A Head { get; }
    public ISeqInternal`1<A> Tail { get; }
    public bool IsEmpty { get; }
    public A Last { get; }
    public ISeqInternal`1<A> Init { get; }
    public int Count { get; }
    public SeqType Type { get; }
    internal SeqLazy`1(IEnumerable`1<A> ma);
    private SeqLazy`1(A[] data, int start, int count, int noCons, Enum`1<A> seq, int seqStart);
    public sealed virtual A get_Item(int index);
    public sealed virtual Option`1<A> At(int index);
    private ValueTuple`2<bool, A> StreamTo(int index);
    public sealed virtual A get_Head();
    public sealed virtual ISeqInternal`1<A> get_Tail();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual A get_Last();
    public sealed virtual ISeqInternal`1<A> get_Init();
    public sealed virtual int get_Count();
    public sealed virtual ISeqInternal`1<A> Add(A value);
    public sealed virtual ISeqInternal`1<A> Cons(A value);
    private SeqLazy`1<A> CloneCons(A value);
    public sealed virtual S Fold(S state, Func`3<S, A, S> f);
    public sealed virtual S FoldBack(S state, Func`3<S, A, S> f);
    public sealed virtual ISeqInternal`1<A> Skip(int amount);
    private void InternalStrict();
    public sealed virtual ISeqInternal`1<A> Strict();
    public sealed virtual ISeqInternal`1<A> Take(int amount);
    [IteratorStateMachineAttribute("LanguageExt.SeqLazy`1/<GetEnumerator>d__36")]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    [IteratorStateMachineAttribute("LanguageExt.SeqLazy`1/<System-Collections-IEnumerable-GetEnumerator>d__37")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual Unit Iter(Action`1<A> f);
    public sealed virtual bool Exists(Func`2<A, bool> f);
    public sealed virtual bool ForAll(Func`2<A, bool> f);
    public sealed virtual SeqType get_Type();
    public virtual int GetHashCode();
    public sealed virtual int GetHashCode(int hash);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class LanguageExt.SeqLoan`1 : object {
    internal A[] data;
    internal ArrayPool`1<A> pool;
    internal int start;
    internal int count;
    internal int freed;
    private int selfHash;
    private static bool ClearArray;
    public A Item { get; }
    [PureAttribute]
public A Head { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Seq`1<A> Tail { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Seq`1<A> Init { get; }
    public bool IsEmpty { get; }
    public A Last { get; }
    public int Count { get; }
    internal SeqLoan`1(A[] data, ArrayPool`1<A> pool, int start, int count);
    private static SeqLoan`1();
    public static SeqLoan`1<A> Rent(ArrayPool`1<A> pool, int size);
    public static SeqLoan`1<A> Rent(int size);
    public A get_Item(int index);
    public A get_Head();
    [PureAttribute]
public Seq`1<A> ToSeq();
    [PureAttribute]
public ReadOnlySpan`1<A> ToReadOnlySpan();
    [PureAttribute]
public Span`1<A> ToSpan();
    public Seq`1<A> get_Tail();
    public Seq`1<A> get_Init();
    public bool get_IsEmpty();
    public A get_Last();
    public int get_Count();
    public S Fold(S state, Func`3<S, A, S> f);
    public S FoldBack(S state, Func`3<S, A, S> f);
    public Seq`1<A> Skip(int amount);
    public Seq`1<A> Take(int amount);
    [NullableContextAttribute("0")]
public Enumerator<A> GetEnumerator();
    public Unit Iter(Action`1<A> f);
    public bool Exists(Func`2<A, bool> f);
    public bool ForAll(Func`2<A, bool> f);
    public Seq`1<A> Append(Seq`1<A> right);
    public Seq`1<A> Append(SeqLoan`1<A> right);
    public virtual int GetHashCode();
    private int GetHashCode(int offsetBasis);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private void Free();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class LanguageExt.SeqStrict`1 : object {
    public static int DefaultCapacity;
    private static int NoCons;
    private static int NoAdd;
    internal A[] data;
    internal int start;
    internal int count;
    private int consDisallowed;
    private int addDisallowed;
    private int selfHash;
    public static SeqStrict`1<A> Empty { get; }
    public A Item { get; }
    public A Head { get; }
    public ISeqInternal`1<A> Tail { get; }
    public ISeqInternal`1<A> Init { get; }
    public bool IsEmpty { get; }
    public A Last { get; }
    public int Count { get; }
    public SeqType Type { get; }
    public SeqStrict`1(A[] data, int start, int count, int consDisallowed, int addDisallowed);
    public SeqStrict`1(A[] data, int start, int count);
    public static SeqStrict`1<A> get_Empty();
    public sealed virtual A get_Item(int index);
    public sealed virtual Option`1<A> At(int index);
    public sealed virtual ISeqInternal`1<A> Add(A value);
    private SeqStrict`1<A> Concat(A[] items, int itemsStart, int itemsCount);
    public sealed virtual ISeqInternal`1<A> Cons(A value);
    private SeqStrict`1<A> CloneCons(A value);
    private SeqStrict`1<A> CloneAdd(A value);
    private SeqStrict`1<A> CloneAddRange(A[] values, int valuesStart, int valuesCount);
    public sealed virtual A get_Head();
    public sealed virtual ISeqInternal`1<A> get_Tail();
    public sealed virtual ISeqInternal`1<A> get_Init();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual A get_Last();
    public sealed virtual int get_Count();
    public sealed virtual S Fold(S state, Func`3<S, A, S> f);
    public sealed virtual S FoldBack(S state, Func`3<S, A, S> f);
    public sealed virtual ISeqInternal`1<A> Skip(int amount);
    public sealed virtual ISeqInternal`1<A> Take(int amount);
    public sealed virtual ISeqInternal`1<A> Strict();
    internal static SeqStrict`1<A> FromSingleValue(A value);
    [IteratorStateMachineAttribute("LanguageExt.SeqStrict`1/<GetEnumerator>d__40")]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    [IteratorStateMachineAttribute("LanguageExt.SeqStrict`1/<System-Collections-IEnumerable-GetEnumerator>d__41")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public SeqStrict`1<A> SetItem(int index, A value);
    public sealed virtual Unit Iter(Action`1<A> f);
    public sealed virtual bool Exists(Func`2<A, bool> f);
    public sealed virtual bool ForAll(Func`2<A, bool> f);
    public sealed virtual SeqType get_Type();
    public SeqStrict`1<A> Append(SeqStrict`1<A> right);
    public virtual int GetHashCode();
    public sealed virtual int GetHashCode(int offsetBasis);
    public static SeqStrict`1<A> FromEnumerable(IEnumerable`1<A> ma);
    public SeqStrict`1<A> Rev();
    public SeqStrict`1<B> Map(Func`2<A, B> f);
    public SeqStrict`1<B> Map(Func`3<A, int, B> f);
    public SeqStrict`1<A> Filter(Func`2<A, bool> f);
}
internal enum LanguageExt.SeqType : Enum {
    public int value__;
    public static SeqType Empty;
    public static SeqType Lazy;
    public static SeqType Strict;
    public static SeqType Concat;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Set : object {
    [NullableContextAttribute("2")]
[PureAttribute]
public static bool isEmpty(Set`1<T> set);
    [PureAttribute]
public static Set`1<A> singleton(A value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Set`1<T> create();
    [PureAttribute]
public static Set`1<T> createRange(IEnumerable`1<T> range);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Set`1<A> createRange(ReadOnlySpan`1<A> range);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Set`1<T> empty();
    [PureAttribute]
public static Set`1<T> add(Set`1<T> set, T value);
    [PureAttribute]
public static Set`1<T> tryAdd(Set`1<T> set, T value);
    [PureAttribute]
public static Set`1<T> addOrUpdate(Set`1<T> set, T value);
    [PureAttribute]
public static Set`1<A> addRange(Set`1<A> set, IEnumerable`1<A> range);
    [PureAttribute]
public static Set`1<A> tryAddRange(Set`1<A> set, IEnumerable`1<A> range);
    [PureAttribute]
public static Set`1<A> addOrUpdateRange(Set`1<A> set, IEnumerable`1<A> range);
    [PureAttribute]
public static Option`1<T> find(Set`1<T> set, T value);
    [PureAttribute]
public static bool exists(Set`1<T> set, Func`2<T, bool> pred);
    [NullableContextAttribute("2")]
[PureAttribute]
public static bool equals(Set`1<T> setA, Set`1<T> setB);
    [NullableContextAttribute("2")]
[PureAttribute]
public static int length(Set`1<T> set);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Set`1<T> subtract(Set`1<T> setA, Set`1<T> setB);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Set`1<T> union(Set`1<T> setA, Set`1<T> setB);
    [PureAttribute]
public static Set`1<T> filter(Set`1<T> set, Func`2<T, bool> pred);
    [PureAttribute]
public static S fold(Set`1<T> set, S state, Func`3<S, T, S> folder);
    [PureAttribute]
public static S foldBack(Set`1<T> set, S state, Func`3<S, T, S> folder);
    [PureAttribute]
public static Set`1<T> intersect(Set`1<T> setA, IEnumerable`1<T> setB);
    [PureAttribute]
public static Set`1<T> except(Set`1<T> setA, IEnumerable`1<T> setB);
    [PureAttribute]
public static Set`1<T> symmetricExcept(Set`1<T> setA, IEnumerable`1<T> setB);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Set`1<R> map(Set`1<T> set, Func`2<T, R> mapper);
    [PureAttribute]
public static bool contains(Set`1<T> set, T value);
    [PureAttribute]
public static Set`1<T> remove(Set`1<T> set, T value);
    [PureAttribute]
public static bool isSubset(Set`1<T> setA, IEnumerable`1<T> setB);
    [PureAttribute]
public static bool isSuperset(Set`1<T> setA, IEnumerable`1<T> setB);
    [PureAttribute]
public static bool isProperSubset(Set`1<T> setA, IEnumerable`1<T> setB);
    [PureAttribute]
public static bool isProperSuperset(Set`1<T> setA, IEnumerable`1<T> setB);
    [PureAttribute]
public static bool overlaps(Set`1<T> setA, IEnumerable`1<T> setB);
    private static override K`2<Set, B> LanguageExt.Traits.Monad<LanguageExt.Set>.Bind(K`2<Set, A> ma, Func`2<A, K`2<Set, B>> f);
    private static override K`2<Set, B> LanguageExt.Traits.Functor<LanguageExt.Set>.Map(Func`2<A, B> f, K`2<Set, A> ma);
    private static override K`2<Set, A> LanguageExt.Traits.Applicative<LanguageExt.Set>.Pure(A value);
    private static override K`2<Set, B> LanguageExt.Traits.Applicative<LanguageExt.Set>.Apply(K`2<Set, Func`2<A, B>> mf, K`2<Set, A> ma);
    private static override K`2<Set, B> LanguageExt.Traits.Applicative<LanguageExt.Set>.Action(K`2<Set, A> ma, K`2<Set, B> mb);
    private static override K`2<Set, A> LanguageExt.Traits.MonoidK<LanguageExt.Set>.Empty();
    private static override K`2<Set, A> LanguageExt.Traits.SemigroupK<LanguageExt.Set>.Combine(K`2<Set, A> ma, K`2<Set, A> mb);
    private static override bool LanguageExt.Traits.Foldable<LanguageExt.Set>.Contains(A value, K`2<Set, A> ta);
    private static override int LanguageExt.Traits.Foldable<LanguageExt.Set>.Count(K`2<Set, A> ta);
    private static override bool LanguageExt.Traits.Foldable<LanguageExt.Set>.IsEmpty(K`2<Set, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Set>.FoldWhile(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<Set, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Set>.FoldBackWhile(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S state, K`2<Set, A> ta);
    private static override K`2<F, K`2<Set, B>> LanguageExt.Traits.Traversable<LanguageExt.Set>.Traverse(Func`2<A, K`2<F, B>> f, K`2<Set, A> ta);
    private static override K`2<F, K`2<Set, B>> LanguageExt.Traits.Traversable<LanguageExt.Set>.TraverseM(Func`2<A, K`2<F, B>> f, K`2<Set, A> ta);
    private static override Option`1<A> LanguageExt.Traits.Foldable<LanguageExt.Set>.Head(K`2<Set, A> ta);
    private static override Option`1<A> LanguageExt.Traits.Foldable<LanguageExt.Set>.Last(K`2<Set, A> ta);
    private static override Option`1<A> LanguageExt.Traits.Foldable<LanguageExt.Set>.Min(K`2<Set, A> ta);
    private static override Option`1<A> LanguageExt.Traits.Foldable<LanguageExt.Set>.Max(K`2<Set, A> ta);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool isEmpty(Set`2<OrdT, T> set);
    [PureAttribute]
public static Set`2<OrdA, A> singleton(A value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Set`2<OrdT, T> create();
    [PureAttribute]
public static Set`2<OrdT, T> createRange(IEnumerable`1<T> range);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Set`2<OrdA, A> createRange(ReadOnlySpan`1<A> range);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Set`2<OrdT, T> empty();
    [PureAttribute]
public static Set`2<OrdT, T> add(Set`2<OrdT, T> set, T value);
    [PureAttribute]
public static Set`2<OrdT, T> tryAdd(Set`2<OrdT, T> set, T value);
    [PureAttribute]
public static Set`2<OrdT, T> addOrUpdate(Set`2<OrdT, T> set, T value);
    [PureAttribute]
public static Set`2<OrdT, T> addRange(Set`2<OrdT, T> set, IEnumerable`1<T> range);
    [PureAttribute]
public static Set`2<OrdT, T> tryAddRange(Set`2<OrdT, T> set, IEnumerable`1<T> range);
    [PureAttribute]
public static Set`2<OrdT, T> addOrUpdateRange(Set`2<OrdT, T> set, IEnumerable`1<T> range);
    [PureAttribute]
public static Option`1<T> find(Set`2<OrdT, T> set, T value);
    [PureAttribute]
public static bool exists(Set`2<OrdT, T> set, Func`2<T, bool> pred);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool equals(Set`2<OrdT, T> setA, Set`2<OrdT, T> setB);
    [NullableContextAttribute("0")]
[PureAttribute]
public static int length(Set`2<OrdT, T> set);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Set`2<OrdT, T> subtract(Set`2<OrdT, T> setA, Set`2<OrdT, T> setB);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Set`2<OrdT, T> union(Set`2<OrdT, T> setA, Set`2<OrdT, T> setB);
    [PureAttribute]
public static Set`2<OrdT, T> filter(Set`2<OrdT, T> set, Func`2<T, bool> pred);
    [PureAttribute]
public static S fold(Set`2<OrdT, T> set, S state, Func`3<S, T, S> folder);
    [PureAttribute]
public static S foldBack(Set`2<OrdT, T> set, S state, Func`3<S, T, S> folder);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Set`2<OrdT, T> intersect(Set`2<OrdT, T> setA, Set`2<OrdT, T> setB);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Set`2<OrdT, T> except(Set`2<OrdT, T> setA, Set`2<OrdT, T> setB);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Set`2<OrdT, T> symmetricExcept(Set`2<OrdT, T> setA, Set`2<OrdT, T> setB);
    [PureAttribute]
public static Set`2<OrdR, R> map(Set`2<OrdT, T> set, Func`2<T, R> mapper);
    [PureAttribute]
public static Set`2<OrdT, T> map(Set`2<OrdT, T> set, Func`2<T, T> mapper);
    [PureAttribute]
public static bool contains(Set`2<OrdT, T> set, T value);
    [PureAttribute]
public static Set`2<OrdT, T> remove(Set`2<OrdT, T> set, T value);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool isSubset(Set`2<OrdT, T> setA, Set`2<OrdT, T> setB);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool isSuperset(Set`2<OrdT, T> setA, Set`2<OrdT, T> setB);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool isProperSubset(Set`2<OrdT, T> setA, Set`2<OrdT, T> setB);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool isProperSuperset(Set`2<OrdT, T> setA, Set`2<OrdT, T> setB);
    [NullableContextAttribute("0")]
[PureAttribute]
public static bool overlaps(Set`2<OrdT, T> setA, Set`2<OrdT, T> setB);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[CollectionBuilderAttribute("LanguageExt.Set", "createRange")]
public class LanguageExt.Set`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Set`1<A> <Empty>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private SetInternal`2<OrdDefault`1<A>, A> value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Set`1<A> Empty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal SetInternal`2<OrdDefault`1<A>, A> Value { get; }
    [NullableAttribute("2")]
[PureAttribute]
public object Case { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public int Length { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Option`1<A> Min { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Option`1<A> Max { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Set`1<A> AdditiveIdentity { get; }
    public Set`1(IEnumerable`1<A> items);
    public Set`1(ReadOnlySpan`1<A> items);
    internal Set`1(SetInternal`2<OrdDefault`1<A>, A> set);
    internal Set`1(SetItem`1<A> root);
    public Set`1(IEnumerable`1<A> items, bool tryAdd);
    public Set`1(ReadOnlySpan`1<A> items, bool tryAdd);
    private static Set`1();
    [CompilerGeneratedAttribute]
public static override Set`1<A> get_Empty();
    internal SetInternal`2<OrdDefault`1<A>, A> get_Value();
    [PureAttribute]
public static Lens`2<Set`1<A>, bool> item(A key);
    [PureAttribute]
public static Lens`2<Set`1<A>, Set`1<A>> map(Lens`2<A, A> lens);
    private static Set`1<A> Wrap(SetInternal`2<OrdDefault`1<A>, A> set);
    [NullableContextAttribute("2")]
private static Set`1<B> Wrap(SetInternal`2<OrdDefault`1<B>, B> set);
    [NullableContextAttribute("2")]
public object get_Case();
    [PureAttribute]
public StreamT`2<M, A> AsStream();
    [PureAttribute]
public Set`1<A> Add(A value);
    [PureAttribute]
public Set`1<A> TryAdd(A value);
    [PureAttribute]
public Set`1<A> AddOrUpdate(A value);
    [PureAttribute]
public Set`1<A> AddRange(IEnumerable`1<A> range);
    [PureAttribute]
public Set`1<A> TryAddRange(IEnumerable`1<A> range);
    [PureAttribute]
public Set`1<A> AddOrUpdateRange(IEnumerable`1<A> range);
    [PureAttribute]
public Option`1<A> Find(A value);
    [PureAttribute]
public Iterable`1<A> FindRange(A keyFrom, A keyTo);
    [PureAttribute]
public Option`1<A> FindPredecessor(A key);
    [PureAttribute]
public Option`1<A> FindExactOrPredecessor(A key);
    [PureAttribute]
public Option`1<A> FindSuccessor(A key);
    [PureAttribute]
public Option`1<A> FindExactOrSuccessor(A key);
    [PureAttribute]
public Set`1<A> Intersect(IEnumerable`1<A> other);
    [PureAttribute]
public Set`1<A> Except(IEnumerable`1<A> other);
    [PureAttribute]
public Set`1<A> Except(Set`1<A> other);
    [PureAttribute]
public Set`1<A> SymmetricExcept(IEnumerable`1<A> other);
    [PureAttribute]
public Set`1<A> SymmetricExcept(Set`1<A> other);
    [PureAttribute]
public Set`1<A> Union(IEnumerable`1<A> other);
    [PureAttribute]
public Set`1<A> Clear();
    [PureAttribute]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public Set`1<A> Remove(A value);
    [PureAttribute]
public Set`1<A> RemoveRange(IEnumerable`1<A> values);
    public Set`1<A> Do(Action`1<A> f);
    [PureAttribute]
public Set`1<B> Map(Func`2<A, B> map);
    [PureAttribute]
public K`2<F, Set`1<B>> Traverse(Func`2<A, K`2<F, B>> f);
    [PureAttribute]
public K`2<M, Set`1<B>> TraverseM(Func`2<A, K`2<M, B>> f);
    [PureAttribute]
public Set`1<A> Filter(Func`2<A, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<A, bool> pred);
    [PureAttribute]
public bool Contains(A value);
    [PureAttribute]
public bool SetEquals(IEnumerable`1<A> other);
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public int get_Length();
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<A> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<A> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<A> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<A> other);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<A> other);
    public void CopyTo(A[] array, int index);
    public void CopyTo(Array array, int index);
    [PureAttribute]
public static override Set`1<A> op_Addition(Set`1<A> lhs, Set`1<A> rhs);
    [PureAttribute]
public sealed virtual Set`1<A> Combine(Set`1<A> rhs);
    [PureAttribute]
public static override Set`1<A> op_Subtraction(Set`1<A> lhs, Set`1<A> rhs);
    [PureAttribute]
public Set`1<A> Subtract(Set`1<A> rhs);
    [PureAttribute]
public sealed virtual bool Equals(Set`1<A> other);
    [PureAttribute]
public static override bool op_Equality(Set`1<A> lhs, Set`1<A> rhs);
    [PureAttribute]
public static override bool op_Inequality(Set`1<A> lhs, Set`1<A> rhs);
    [PureAttribute]
public static override bool op_LessThan(Set`1<A> lhs, Set`1<A> rhs);
    [PureAttribute]
public static override bool op_LessThanOrEqual(Set`1<A> lhs, Set`1<A> rhs);
    [PureAttribute]
public static override bool op_GreaterThan(Set`1<A> lhs, Set`1<A> rhs);
    [PureAttribute]
public static override bool op_GreaterThanOrEqual(Set`1<A> lhs, Set`1<A> rhs);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[PureAttribute]
public sealed virtual int CompareTo(object obj);
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToFullString(string separator);
    [PureAttribute]
public string ToFullArrayString(string separator);
    [PureAttribute]
public Seq`1<A> ToSeq();
    [PureAttribute]
public Iterable`1<A> AsEnumerable();
    [PureAttribute]
public Set`1<B> Select(Func`2<A, B> f);
    [PureAttribute]
public Set`1<A> Where(Func`2<A, bool> pred);
    [NullableContextAttribute("2")]
[PureAttribute]
public Set`1<B> Bind(Func`2<A, Set`1<B>> f);
    [NullableContextAttribute("2")]
[PureAttribute]
public Set`1<C> SelectMany(Func`2<A, Set`1<B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Iterable`1<A> Skip(int amount);
    [PureAttribute]
public sealed virtual int CompareTo(Set`1<A> other);
    [NullableContextAttribute("0")]
[PureAttribute]
public int CompareTo(Set`1<A> other);
    [PureAttribute]
public static Set`1<A> op_Implicit(SeqEmpty _);
    [PureAttribute]
public Set`1<A> Slice(A keyFrom, A keyTo);
    public Option`1<A> get_Min();
    public Option`1<A> get_Max();
    public static override Set`1<A> get_AdditiveIdentity();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[CollectionBuilderAttribute("LanguageExt.Set", "createRange")]
public class LanguageExt.Set`2 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Set`2<OrdA, A> Empty;
    private SetInternal`2<OrdA, A> value;
    private SetInternal`2<OrdA, A> Value { get; }
    [NullableAttribute("2")]
[PureAttribute]
public object Case { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public int Length { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Option`1<A> Min { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Option`1<A> Max { get; }
    public Set`2(IEnumerable`1<A> items);
    public Set`2(ReadOnlySpan`1<A> items);
    internal Set`2(SetInternal`2<OrdA, A> set);
    internal Set`2(SetItem`1<A> root);
    public Set`2(IEnumerable`1<A> items, bool tryAdd);
    public Set`2(ReadOnlySpan`1<A> items, bool tryAdd);
    private static Set`2();
    private SetInternal`2<OrdA, A> get_Value();
    private static Set`2<OrdA, A> Wrap(SetInternal`2<OrdA, A> set);
    private static Set`2<OrdB, B> Wrap(SetInternal`2<OrdB, B> set);
    [NullableContextAttribute("2")]
public object get_Case();
    [PureAttribute]
public Set`2<OrdA, A> Add(A value);
    [PureAttribute]
public Set`2<OrdA, A> TryAdd(A value);
    [PureAttribute]
public Set`2<OrdA, A> AddOrUpdate(A value);
    [PureAttribute]
public Set`2<OrdA, A> AddRange(IEnumerable`1<A> range);
    [PureAttribute]
public Set`2<OrdA, A> TryAddRange(IEnumerable`1<A> range);
    [PureAttribute]
public Set`2<OrdA, A> AddOrUpdateRange(IEnumerable`1<A> range);
    [PureAttribute]
public Option`1<A> Find(A value);
    [PureAttribute]
public Option`1<A> FindPredecessor(A key);
    [PureAttribute]
public Option`1<A> FindExactOrPredecessor(A key);
    [PureAttribute]
public Option`1<A> FindSuccessor(A key);
    [PureAttribute]
public Option`1<A> FindExactOrSuccessor(A key);
    [PureAttribute]
public Iterable`1<A> FindRange(A keyFrom, A keyTo);
    [PureAttribute]
public Set`2<OrdA, A> Intersect(Set`2<OrdA, A> other);
    [PureAttribute]
public Set`2<OrdA, A> Except(Set`2<OrdA, A> other);
    [PureAttribute]
public Set`2<OrdA, A> Except(IEnumerable`1<A> other);
    [PureAttribute]
public Set`2<OrdA, A> SymmetricExcept(Set`2<OrdA, A> other);
    [PureAttribute]
public Set`2<OrdA, A> SymmetricExcept(IEnumerable`1<A> other);
    [PureAttribute]
public Set`2<OrdA, A> Union(Set`2<OrdA, A> other);
    [PureAttribute]
public Set`2<OrdA, A> Clear();
    [PureAttribute]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public Set`2<OrdA, A> Remove(A value);
    [PureAttribute]
public S Fold(S state, Func`3<S, A, S> folder);
    [PureAttribute]
public S FoldBack(S state, Func`3<S, A, S> folder);
    public Set`2<OrdA, A> Do(Action`1<A> f);
    [PureAttribute]
public Set`2<OrdB, B> Map(Func`2<A, B> map);
    [PureAttribute]
public Set`2<OrdA, A> Map(Func`2<A, A> map);
    [PureAttribute]
public Set`2<OrdA, A> Filter(Func`2<A, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<A, bool> pred);
    [PureAttribute]
public bool Contains(A value);
    [PureAttribute]
public bool SetEquals(Set`2<OrdA, A> other);
    public bool get_IsEmpty();
    public int get_Count();
    public int get_Length();
    [PureAttribute]
public bool IsProperSubsetOf(Set`2<OrdA, A> other);
    [PureAttribute]
public bool IsProperSupersetOf(Set`2<OrdA, A> other);
    [PureAttribute]
public bool IsSubsetOf(Set`2<OrdA, A> other);
    [PureAttribute]
public bool IsSupersetOf(Set`2<OrdA, A> other);
    [PureAttribute]
public bool Overlaps(Set`2<OrdA, A> other);
    public void CopyTo(A[] array, int index);
    public void CopyTo(Array array, int index);
    [PureAttribute]
public static Set`2<OrdA, A> op_Addition(Set`2<OrdA, A> lhs, Set`2<OrdA, A> rhs);
    [PureAttribute]
public Set`2<OrdA, A> Append(Set`2<OrdA, A> rhs);
    [PureAttribute]
public static Set`2<OrdA, A> op_Subtraction(Set`2<OrdA, A> lhs, Set`2<OrdA, A> rhs);
    [PureAttribute]
public Set`2<OrdA, A> Subtract(Set`2<OrdA, A> rhs);
    [PureAttribute]
public sealed virtual bool Equals(Set`2<OrdA, A> other);
    [PureAttribute]
public static bool op_Equality(Set`2<OrdA, A> lhs, Set`2<OrdA, A> rhs);
    [PureAttribute]
public static bool op_Inequality(Set`2<OrdA, A> lhs, Set`2<OrdA, A> rhs);
    [PureAttribute]
public static bool op_LessThan(Set`2<OrdA, A> lhs, Set`2<OrdA, A> rhs);
    [PureAttribute]
public static bool op_LessThanOrEqual(Set`2<OrdA, A> lhs, Set`2<OrdA, A> rhs);
    [PureAttribute]
public static bool op_GreaterThan(Set`2<OrdA, A> lhs, Set`2<OrdA, A> rhs);
    [PureAttribute]
public static bool op_GreaterThanOrEqual(Set`2<OrdA, A> lhs, Set`2<OrdA, A> rhs);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public virtual int GetHashCode();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public Seq`1<A> ToSeq();
    [PureAttribute]
public Iterable`1<A> AsEnumerable();
    [PureAttribute]
public Set`2<OrdA, A> Where(Func`2<A, bool> pred);
    [NullableContextAttribute("0")]
[PureAttribute]
public Set`2<OrdB, B> Bind(Func`2<A, Set`2<OrdB, B>> f);
    [PureAttribute]
public Set`2<OrdA, A> Bind(Func`2<A, Set`2<OrdA, A>> f);
    [PureAttribute]
public Iterable`1<A> Skip(int amount);
    [PureAttribute]
public sealed virtual int CompareTo(Set`2<OrdA, A> other);
    public static Set`2<OrdA, A> op_Implicit(SeqEmpty _);
    [PureAttribute]
public Set`2<OrdA, A> Slice(A keyFrom, A keyTo);
    public Option`1<A> get_Min();
    public Option`1<A> get_Max();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.SetExtensions : object {
    [ExtensionAttribute]
public static Set`1<A> As(K`2<Set, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static IQueryable`1<A> AsQueryable(Set`1<A> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SetInternal`2 : object {
    public static SetInternal`2<OrdA, A> Empty;
    private SetItem`1<A> set;
    private int hashCode;
    [PureAttribute]
public int Count { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Option`1<A> Min { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[PureAttribute]
public Option`1<A> Max { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public bool IsReadOnly { get; }
    internal SetInternal`2(SetItem`1<A> root);
    public SetInternal`2(IEnumerable`1<A> items);
    internal SetInternal`2(IEnumerable`1<A> items, AddOpt option);
    internal SetInternal`2(ReadOnlySpan`1<A> items, AddOpt option);
    private static SetInternal`2();
    public virtual int GetHashCode();
    public Iterable`1<A> AsIterable();
    public Iterable`1<A> Skip(int amount);
    public int get_Count();
    public Option`1<A> get_Min();
    public Option`1<A> get_Max();
    [PureAttribute]
public SetInternal`2<OrdA, A> Add(A value);
    [PureAttribute]
public SetInternal`2<OrdA, A> TryAdd(A value);
    [PureAttribute]
public SetInternal`2<OrdA, A> AddOrUpdate(A value);
    [PureAttribute]
public SetInternal`2<OrdA, A> AddRange(IEnumerable`1<A> xs);
    [PureAttribute]
public SetInternal`2<OrdA, A> TryAddRange(IEnumerable`1<A> xs);
    [PureAttribute]
public SetInternal`2<OrdA, A> AddOrUpdateRange(IEnumerable`1<A> xs);
    [PureAttribute]
public int Length();
    [PureAttribute]
public Option`1<A> Find(A value);
    [PureAttribute]
public Option`1<A> FindPredecessor(A key);
    [PureAttribute]
public Option`1<A> FindOrPredecessor(A key);
    [PureAttribute]
public Option`1<A> FindSuccessor(A key);
    [PureAttribute]
public Option`1<A> FindOrSuccessor(A key);
    [PureAttribute]
public Iterable`1<A> FindRange(A keyFrom, A keyTo);
    [PureAttribute]
public SetInternal`2<OrdA, A> Intersect(IEnumerable`1<A> other);
    [PureAttribute]
public SetInternal`2<OrdA, A> Except(SetInternal`2<OrdA, A> rhs);
    [PureAttribute]
public SetInternal`2<OrdA, A> Except(IEnumerable`1<A> other);
    [PureAttribute]
public SetInternal`2<OrdA, A> SymmetricExcept(SetInternal`2<OrdA, A> rhs);
    [PureAttribute]
public SetInternal`2<OrdA, A> SymmetricExcept(IEnumerable`1<A> other);
    [PureAttribute]
public SetInternal`2<OrdA, A> Union(IEnumerable`1<A> other);
    [PureAttribute]
public SetInternal`2<OrdA, A> Clear();
    [PureAttribute]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    [PureAttribute]
public SetInternal`2<OrdA, A> Remove(A value);
    [PureAttribute]
public S Fold(S state, Func`3<S, A, S> folder);
    [PureAttribute]
public S FoldBack(S state, Func`3<S, A, S> folder);
    [PureAttribute]
public SetInternal`2<OrdB, B> Map(Func`2<A, B> f);
    [PureAttribute]
public SetInternal`2<OrdA, A> Map(Func`2<A, A> f);
    [PureAttribute]
public SetInternal`2<OrdA, A> Filter(Func`2<A, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<A, bool> pred);
    [PureAttribute]
public bool Contains(A value);
    [PureAttribute]
public bool SetEquals(IEnumerable`1<A> other);
    public bool get_IsEmpty();
    public bool get_IsReadOnly();
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<A> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<A> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<A> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<A> other);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<A> other);
    public void CopyTo(A[] array, int index);
    public void CopyTo(Array array, int index);
    [PureAttribute]
public static SetInternal`2<OrdA, A> op_Addition(SetInternal`2<OrdA, A> lhs, SetInternal`2<OrdA, A> rhs);
    [PureAttribute]
public SetInternal`2<OrdA, A> Append(SetInternal`2<OrdA, A> rhs);
    [PureAttribute]
public static SetInternal`2<OrdA, A> op_Subtraction(SetInternal`2<OrdA, A> lhs, SetInternal`2<OrdA, A> rhs);
    [PureAttribute]
public SetInternal`2<OrdA, A> Subtract(SetInternal`2<OrdA, A> rhs);
    [PureAttribute]
public sealed virtual bool Equals(SetInternal`2<OrdA, A> other);
    [PureAttribute]
public int CompareTo(SetInternal`2<OrdA, A> other);
    [PureAttribute]
public int CompareTo(SetInternal`2<OrdA, A> other);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("LanguageExt.SetInternal`2/<<AsIterable>g__Yield|7_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<A> <AsIterable>g__Yield|7_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.SetItem`1 : object {
    public static SetItem`1<K> Empty;
    public int Count;
    public byte Height;
    public SetItem`1<K> Left;
    public SetItem`1<K> Right;
    [CompilerGeneratedAttribute]
private K <Key>k__BackingField;
    public bool IsEmpty { get; }
    [PureAttribute]
internal int BalanceFactor { get; }
    [PureAttribute]
public K Key { get; internal set; }
    internal SetItem`1(byte height, int count, K key, SetItem`1<K> left, SetItem`1<K> right);
    private static SetItem`1();
    public bool get_IsEmpty();
    internal int get_BalanceFactor();
    [CompilerGeneratedAttribute]
public K get_Key();
    [CompilerGeneratedAttribute]
internal void set_Key(K value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class LanguageExt.SetModule : object {
    [PureAttribute]
public static S Fold(SetItem`1<K> node, S state, Func`3<S, K, S> folder);
    [PureAttribute]
public static S FoldBack(SetItem`1<K> node, S state, Func`3<S, K, S> folder);
    [PureAttribute]
public static bool ForAll(SetItem`1<K> node, Func`2<K, bool> pred);
    [PureAttribute]
public static bool Exists(SetItem`1<K> node, Func`2<K, bool> pred);
    [PureAttribute]
public static SetItem`1<K> Add(SetItem`1<K> node, K key);
    [PureAttribute]
public static SetItem`1<K> TryAdd(SetItem`1<K> node, K key);
    [PureAttribute]
public static SetItem`1<K> AddOrUpdate(SetItem`1<K> node, K key);
    [PureAttribute]
public static SetItem`1<K> AddTreeToRight(SetItem`1<K> node, SetItem`1<K> toAdd);
    [PureAttribute]
public static SetItem`1<K> Remove(SetItem`1<K> node, K key);
    [PureAttribute]
public static bool Contains(SetItem`1<K> node, K key);
    [PureAttribute]
public static K Find(SetItem`1<K> node, K key);
    [IteratorStateMachineAttribute("LanguageExt.SetModule/<FindRange>d__11`2")]
[PureAttribute]
public static IEnumerable`1<K> FindRange(SetItem`1<K> node, K a, K b);
    [PureAttribute]
public static Option`1<K> TryFind(SetItem`1<K> node, K key);
    [PureAttribute]
public static SetItem`1<K> Skip(SetItem`1<K> node, int amount);
    [PureAttribute]
public static SetItem`1<K> Make(K k, SetItem`1<K> l, SetItem`1<K> r);
    [PureAttribute]
public static SetItem`1<K> Balance(SetItem`1<K> node);
    [PureAttribute]
public static SetItem`1<K> RotRight(SetItem`1<K> node);
    [PureAttribute]
public static SetItem`1<K> RotLeft(SetItem`1<K> node);
    [PureAttribute]
public static SetItem`1<K> DblRotRight(SetItem`1<K> node);
    [PureAttribute]
public static SetItem`1<K> DblRotLeft(SetItem`1<K> node);
    [PureAttribute]
public static SetItem`1<B> Map(SetItem`1<A> node, Func`2<A, B> f);
    internal static Option`1<A> Max(SetItem`1<A> node);
    internal static Option`1<A> Min(SetItem`1<A> node);
    internal static Option`1<A> TryFindPredecessor(SetItem`1<A> root, A key);
    internal static Option`1<A> TryFindOrPredecessor(SetItem`1<A> root, A key);
    internal static Option`1<A> TryFindSuccessor(SetItem`1<A> root, A key);
    internal static Option`1<A> TryFindOrSuccessor(SetItem`1<A> root, A key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class LanguageExt.SetModuleM : object {
    public static SetItem`1<K> Add(SetItem`1<K> node, K key, AddOpt option);
    public static SetItem`1<K> Balance(SetItem`1<K> node);
    public static SetItem`1<K> DblRotRight(SetItem`1<K> node);
    public static SetItem`1<K> DblRotLeft(SetItem`1<K> node);
    public static SetItem`1<K> RotRight(SetItem`1<K> node);
    public static SetItem`1<K> RotLeft(SetItem`1<K> node);
}
internal static class LanguageExt.SingletonRandom : object {
    [NullableAttribute("1")]
private static Random Random;
    [NullableAttribute("1")]
private static Func`2<int, Random> Provider;
    private static SingletonRandom();
    internal static double NextDouble(Option`1<int> seed);
    internal static double Uniform(double a, double b, Option`1<int> seed);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.SomeContext`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Option`1<A> option;
    private Func`2<A, B> someHandler;
    internal SomeContext`2(Option`1<A> option, Func`2<A, B> someHandler);
    public B None(Func`1<B> noneHandler);
    public B None(B noneValue);
}
public class LanguageExt.SomeNotInitialisedException : Exception {
    [NullableContextAttribute("1")]
public SomeNotInitialisedException(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.SomeUnitContext`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Option`1<A> option;
    private Action`1<A> someHandler;
    [NullableAttribute("2")]
private Action noneHandler;
    internal SomeUnitContext`1(Option`1<A> option, Action`1<A> someHandler);
    public Unit None(Action f);
    private Unit HandleSome(A value);
    private Unit HandleNone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class LanguageExt.SpanArray`1 : ValueType {
    public A[] Data;
    public int Count;
    private int Index;
    private int EndIndex;
    public A Item { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SpanArray`1<A> Tail { get; }
    public A Head { get; }
    public A Last { get; }
    private SpanArray`1(A[] data, int index, int count);
    public Option`1<A> Elem(int index);
    [IteratorStateMachineAttribute("LanguageExt.SpanArray`1/<GetEnumerator>d__6")]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    public A get_Item(int index);
    public void set_Item(int index, A value);
    public static SpanArray`1<A> New(IEnumerable`1<A> sequence);
    public static SpanArray`1<A> New(A[] data);
    public static SpanArray`1<A> New(int n);
    public SpanArray`1<A> Slice(int index, int count);
    public SpanArray`1<A> Take(int n);
    public SpanArray`1<A> Skip(int n);
    public SpanArray`1<A> get_Tail();
    public A get_Head();
    public A get_Last();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Unit UnsafeCopy(SpanArray`1<A> dest);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Stack : object {
    public static Stck`1<A> singleton(A item);
    public static Stck`1<A> createRange(IEnumerable`1<A> items);
    [NullableContextAttribute("2")]
public static Stck`1<A> createRange(ReadOnlySpan`1<A> items);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Stck`1<T> rev(Stck`1<T> stack);
    [NullableContextAttribute("2")]
[PureAttribute]
public static bool isEmpty(Stck`1<T> stack);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Stck`1<T> clear(Stck`1<T> stack);
    [PureAttribute]
public static T peek(Stck`1<T> stack);
    [PureAttribute]
public static Stck`1<T> peek(Stck`1<T> stack, Action`1<T> Some, Action None);
    [PureAttribute]
public static R peek(Stck`1<T> stack, Func`2<T, R> Some, Func`1<R> None);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Option`1<T> trypeek(Stck`1<T> stack);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Stck`1<T> pop(Stck`1<T> stack);
    [NullableContextAttribute("2")]
[PureAttribute]
public static ValueTuple`2<Stck`1<T>, Option`1<T>> trypop(Stck`1<T> stack);
    [PureAttribute]
public static Stck`1<T> pop(Stck`1<T> stack, Action`1<T> Some, Action None);
    [PureAttribute]
public static R pop(Stck`1<T> stack, Func`3<Stck`1<T>, T, R> Some, Func`1<R> None);
    [PureAttribute]
public static Stck`1<T> push(Stck`1<T> stack, T value);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Stck`1<R> map(Stck`1<T> stack, Func`2<T, R> map);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Stck`1<R> map(Stck`1<T> stack, Func`3<int, T, R> map);
    [PureAttribute]
public static Stck`1<T> filter(Stck`1<T> stack, Func`2<T, bool> predicate);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Stck`1<U> choose(Stck`1<T> stack, Func`2<T, Option`1<U>> selector);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Stck`1<U> choose(Stck`1<T> stack, Func`3<int, T, Option`1<U>> selector);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Stck`1<R> collect(Stck`1<T> stack, Func`2<T, IEnumerable`1<R>> map);
    [PureAttribute]
public static Stck`1<T> append(Stck`1<T> lhs, IEnumerable`1<T> rhs);
    [PureAttribute]
public static S fold(Stck`1<T> stack, S state, Func`3<S, T, S> folder);
    [PureAttribute]
public static S foldBack(Stck`1<T> stack, S state, Func`3<S, T, S> folder);
    [PureAttribute]
public static S foldWhile(Stck`1<T> stack, S state, Func`3<S, T, S> folder, Func`2<T, bool> preditem);
    [PureAttribute]
public static S foldWhile(Stck`1<T> stack, S state, Func`3<S, T, S> folder, Func`2<S, bool> predstate);
    [PureAttribute]
public static S foldBackWhile(Stck`1<T> stack, S state, Func`3<S, T, S> folder, Func`2<T, bool> preditem);
    [PureAttribute]
public static S foldBackWhile(Stck`1<T> stack, S state, Func`3<S, T, S> folder, Func`2<S, bool> predstate);
    [PureAttribute]
public static T reduce(Stck`1<T> stack, Func`3<T, T, T> reducer);
    [PureAttribute]
public static T reduceBack(Stck`1<T> stack, Func`3<T, T, T> reducer);
    [PureAttribute]
public static Stck`1<S> scan(Stck`1<T> stack, S state, Func`3<S, T, S> folder);
    [PureAttribute]
public static Stck`1<S> scanBack(Stck`1<T> stack, S state, Func`3<S, T, S> folder);
    [PureAttribute]
public static Option`1<T> find(Stck`1<T> stack, Func`2<T, bool> pred);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Stck`1<V> zip(Stck`1<T> stack, IEnumerable`1<U> other, Func`3<T, U, V> zipper);
    [NullableContextAttribute("2")]
[PureAttribute]
public static int length(Stck`1<T> stack);
    public static Unit iter(Stck`1<T> stack, Action`1<T> action);
    public static Unit iter(Stck`1<T> stack, Action`2<int, T> action);
    [PureAttribute]
public static bool forall(Stck`1<T> stack, Func`2<T, bool> pred);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Stck`1<T> distinct(Stck`1<T> stack);
    [NullableContextAttribute("0")]
[PureAttribute]
public static Stck`1<T> distinct(Stck`1<T> stack);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Stck`1<T> distinct(Stck`1<T> stack, Func`2<T, K> keySelector, Option`1<Func`3<K, K, bool>> compare);
    [NullableContextAttribute("2")]
[PureAttribute]
public static Stck`1<T> take(Stck`1<T> stack, int count);
    [PureAttribute]
public static Stck`1<T> takeWhile(Stck`1<T> stack, Func`2<T, bool> pred);
    [PureAttribute]
public static Stck`1<T> takeWhile(Stck`1<T> stack, Func`3<T, int, bool> pred);
    [PureAttribute]
public static bool exists(Stck`1<T> stack, Func`2<T, bool> pred);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.StackExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Stck`1<R> Map(Stck`1<T> stack, Func`2<T, R> map);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Stck`1<R> Map(Stck`1<T> stack, Func`3<int, T, R> map);
    [ExtensionAttribute]
[PureAttribute]
public static Stck`1<T> Filter(Stck`1<T> stack, Func`2<T, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Stck`1<U> Choose(Stck`1<T> stack, Func`2<T, Option`1<U>> selector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Stck`1<U> Choose(Stck`1<T> stack, Func`3<int, T, Option`1<U>> selector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Stck`1<R> Collect(Stck`1<T> stack, Func`2<T, IEnumerable`1<R>> map);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Stck`1<T> Rev(Stck`1<T> stack);
    [ExtensionAttribute]
[PureAttribute]
public static S Fold(Stck`1<T> stack, S state, Func`3<S, T, S> folder);
    [ExtensionAttribute]
[PureAttribute]
public static S FoldBack(Stck`1<T> stack, S state, Func`3<S, T, S> folder);
    [ExtensionAttribute]
[PureAttribute]
public static S FoldWhile(Stck`1<T> stack, S state, Func`3<S, T, S> folder, Func`2<T, bool> preditem);
    [ExtensionAttribute]
[PureAttribute]
public static S FoldWhile(Stck`1<T> stack, S state, Func`3<S, T, S> folder, Func`2<S, bool> predstate);
    [ExtensionAttribute]
[PureAttribute]
public static S FoldBackWhile(Stck`1<T> stack, S state, Func`3<S, T, S> folder, Func`2<T, bool> preditem);
    [ExtensionAttribute]
[PureAttribute]
public static S FoldBackWhile(Stck`1<T> stack, S state, Func`3<S, T, S> folder, Func`2<S, bool> predstate);
    [PureAttribute]
public static T ReduceBack(Stck`1<T> stack, Func`3<T, T, T> reducer);
    [ExtensionAttribute]
[PureAttribute]
public static T Reduce(Stck`1<T> stack, Func`3<T, T, T> reducer);
    [ExtensionAttribute]
[PureAttribute]
public static Stck`1<S> Scan(Stck`1<T> stack, S state, Func`3<S, T, S> folder);
    [ExtensionAttribute]
[PureAttribute]
public static Stck`1<S> ScanBack(Stck`1<T> stack, S state, Func`3<S, T, S> folder);
    [ExtensionAttribute]
[PureAttribute]
public static Option`1<T> Find(Stck`1<T> stack, Func`2<T, bool> pred);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static int Length(Stck`1<T> stack);
    [ExtensionAttribute]
public static Unit Iter(Stck`1<T> stack, Action`1<T> action);
    [ExtensionAttribute]
public static Unit Iter(Stck`1<T> stack, Action`2<int, T> action);
    [ExtensionAttribute]
[PureAttribute]
public static bool ForAll(Stck`1<T> stack, Func`2<T, bool> pred);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Stck`1<T> Distinct(Stck`1<T> stack);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[PureAttribute]
public static Stck`1<T> Distinct(Stck`1<T> stack);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Stck`1<T> Distinct(Stck`1<T> stack, Func`2<T, K> keySelector, Option`1<Func`3<K, K, bool>> compare);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static Stck`1<T> Take(Stck`1<T> stack, int count);
    [ExtensionAttribute]
[PureAttribute]
public static Stck`1<T> TakeWhile(Stck`1<T> stack, Func`2<T, bool> pred);
    [ExtensionAttribute]
[PureAttribute]
public static Stck`1<T> TakeWhile(Stck`1<T> stack, Func`3<T, int, bool> pred);
    [ExtensionAttribute]
[PureAttribute]
public static bool Exists(Stck`1<T> stack, Func`2<T, bool> pred);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.State : object {
    public static State`2<S, B> bind(State`2<S, A> ma, Func`2<A, State`2<S, B>> f);
    public static State`2<S, B> map(Func`2<A, B> f, State`2<S, A> ma);
    public static State`2<S, A> Pure(A value);
    public static State`2<S, B> apply(State`2<S, Func`2<A, B>> mf, State`2<S, A> ma);
    public static State`2<S, B> action(State`2<S, A> ma, State`2<S, B> mb);
    public static State`2<S, S> get();
    public static State`2<S, A> gets(Func`2<S, A> f);
    public static State`2<S, A> getsM(Func`2<S, State`2<S, A>> f);
    public static State`2<S, Unit> put(S state);
    public static State`2<S, Unit> modify(Func`2<S, S> f);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.State`1 : object {
    public static State`2<S, A> Pure(A value);
    private static override K`2<State`1<S>, B> LanguageExt.Traits.Monad<LanguageExt.State<S>>.Bind(K`2<State`1<S>, A> ma, Func`2<A, K`2<State`1<S>, B>> f);
    private static override K`2<State`1<S>, B> LanguageExt.Traits.Functor<LanguageExt.State<S>>.Map(Func`2<A, B> f, K`2<State`1<S>, A> ma);
    private static override K`2<State`1<S>, A> LanguageExt.Traits.Applicative<LanguageExt.State<S>>.Pure(A value);
    private static override K`2<State`1<S>, B> LanguageExt.Traits.Applicative<LanguageExt.State<S>>.Apply(K`2<State`1<S>, Func`2<A, B>> mf, K`2<State`1<S>, A> ma);
    private static override K`2<State`1<S>, B> LanguageExt.Traits.Applicative<LanguageExt.State<S>>.Action(K`2<State`1<S>, A> ma, K`2<State`1<S>, B> mb);
    private static override K`2<State`1<S>, Unit> LanguageExt.Traits.Stateful<LanguageExt.State<S>,S>.Modify(Func`2<S, S> modify);
    private static override K`2<State`1<S>, A> LanguageExt.Traits.Stateful<LanguageExt.State<S>,S>.Gets(Func`2<S, A> f);
    private static override K`2<State`1<S>, Unit> LanguageExt.Traits.Stateful<LanguageExt.State<S>,S>.Put(S value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.State`2 : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<S, ValueTuple`2<A, S>> <runState>k__BackingField;
    [CompilerGeneratedAttribute]
private static State`2<S, S> <Get>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<S, ValueTuple`2<A, S>> runState { get; public set; }
    public static State`2<S, S> Get { get; }
    public State`2(Func`2<S, ValueTuple`2<A, S>> runState);
    [CompilerGeneratedAttribute]
protected State`2(State`2<S, A> original);
    private static State`2();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Func`2<S, ValueTuple`2<A, S>> get_runState();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_runState(Func`2<S, ValueTuple`2<A, S>> value);
    public static State`2<S, A> Pure(A value);
    public static State`2<S, Unit> Modify(Func`2<S, S> f);
    public static State`2<S, Unit> Put(S value);
    [CompilerGeneratedAttribute]
public static State`2<S, S> get_Get();
    public static State`2<S, A> Gets(Func`2<S, A> f);
    public static State`2<S, A> GetsM(Func`2<S, State`2<S, A>> f);
    public static State`2<S, A> Lift(Pure`1<A> monad);
    public static State`2<S, A> Lift(Func`1<A> f);
    public State`2<S, B> Map(Func`2<A, B> f);
    public State`2<S, B> Select(Func`2<A, B> f);
    public State`2<S, B> Bind(Func`2<A, K`2<State`1<S>, B>> f);
    public State`2<S, B> Bind(Func`2<A, State`2<S, B>> f);
    public State`2<S, B> Bind(Func`2<A, Gets`2<S, B>> f);
    public State`2<S, Unit> Bind(Func`2<A, Put`1<S>> f);
    public State`2<S, Unit> Bind(Func`2<A, Modify`1<S>> f);
    public State`2<S, C> SelectMany(Func`2<A, K`2<State`1<S>, B>> bind, Func`3<A, B, C> project);
    public State`2<S, C> SelectMany(Func`2<A, State`2<S, B>> bind, Func`3<A, B, C> project);
    public State`2<S, C> SelectMany(Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    public State`2<S, C> SelectMany(Func`2<A, Put`1<S>> bind, Func`3<A, Unit, C> project);
    public State`2<S, C> SelectMany(Func`2<A, Gets`2<S, B>> bind, Func`3<A, B, C> project);
    public State`2<S, C> SelectMany(Func`2<A, Modify`1<S>> bind, Func`3<A, Unit, C> project);
    public static State`2<S, A> op_Implicit(Pure`1<A> ma);
    public static State`2<S, A> op_RightShift(State`2<S, A> lhs, State`2<S, A> rhs);
    public static State`2<S, A> op_RightShift(State`2<S, A> lhs, K`2<State`1<S>, A> rhs);
    public static State`2<S, A> op_RightShift(State`2<S, A> lhs, State`2<S, Unit> rhs);
    public static State`2<S, A> op_RightShift(State`2<S, A> lhs, K`2<State`1<S>, Unit> rhs);
    public ValueTuple`2<A, S> Run(S state);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(State`2<S, A> left, State`2<S, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(State`2<S, A> left, State`2<S, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(State`2<S, A> other);
    [CompilerGeneratedAttribute]
public virtual State`2<S, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`2& runState);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.StatefulExtensions : object {
    [ExtensionAttribute]
public static State`2<S, A> As(K`2<State`1<S>, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static State`2<S, A> Flatten(State`2<S, State`2<S, A>> mma);
    [ExtensionAttribute]
[PureAttribute]
public static State`2<S, A> Flatten(State`2<S, K`2<State`1<S>, A>> mma);
    [ExtensionAttribute]
public static K`2<M, A> Bracket(K`2<M, Unit> stateSetter, K`2<M, A> operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.StateT : object {
    public static StateT`3<S, M, B> bind(StateT`3<S, M, A> ma, Func`2<A, StateT`3<S, M, B>> f);
    public static StateT`3<S, M, B> map(Func`2<A, B> f, StateT`3<S, M, A> ma);
    public static StateT`3<S, M, A> Pure(A value);
    public static StateT`3<S, M, B> apply(StateT`3<S, M, Func`2<A, B>> mf, StateT`3<S, M, A> ma);
    public static StateT`3<S, M, B> action(StateT`3<S, M, A> ma, StateT`3<S, M, B> mb);
    public static StateT`3<S, M, A> lift(K`2<M, A> ma);
    public static StateT`3<S, M, A> liftIO(IO`1<A> effect);
    public static StateT`3<S, M, S> get();
    public static StateT`3<S, M, A> gets(Func`2<S, A> f);
    public static StateT`3<S, M, A> getsM(Func`2<S, K`2<M, A>> f);
    public static StateT`3<S, M, Unit> put(S state);
    public static StateT`3<S, M, Unit> modify(Func`2<S, S> f);
    public static StateT`3<S, M, Unit> modifyM(Func`2<S, K`2<M, S>> f);
}
public class LanguageExt.StateT`1 : object {
    [NullableContextAttribute("1")]
public static StateT`3<S, M, A> lift(K`2<M, A> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.StateT`2 : object {
    public static StateT`3<S, M, A> Pure(A value);
    public static StateT`3<S, M, A> liftIO(IO`1<A> effect);
    private static override K`2<StateT`2<S, M>, B> LanguageExt.Traits.Monad<LanguageExt.StateT<S,M>>.Bind(K`2<StateT`2<S, M>, A> ma, Func`2<A, K`2<StateT`2<S, M>, B>> f);
    private static override K`2<StateT`2<S, M>, B> LanguageExt.Traits.Functor<LanguageExt.StateT<S,M>>.Map(Func`2<A, B> f, K`2<StateT`2<S, M>, A> ma);
    private static override K`2<StateT`2<S, M>, A> LanguageExt.Traits.Applicative<LanguageExt.StateT<S,M>>.Pure(A value);
    private static override K`2<StateT`2<S, M>, B> LanguageExt.Traits.Applicative<LanguageExt.StateT<S,M>>.Apply(K`2<StateT`2<S, M>, Func`2<A, B>> mf, K`2<StateT`2<S, M>, A> ma);
    private static override K`2<StateT`2<S, M>, B> LanguageExt.Traits.Applicative<LanguageExt.StateT<S,M>>.Action(K`2<StateT`2<S, M>, A> ma, K`2<StateT`2<S, M>, B> mb);
    private static override K`2<StateT`2<S, M>, A> LanguageExt.Traits.MonadT<LanguageExt.StateT<S,M>,M>.Lift(K`2<M, A> ma);
    private static override K`2<StateT`2<S, M>, Unit> LanguageExt.Traits.Stateful<LanguageExt.StateT<S,M>,S>.Modify(Func`2<S, S> modify);
    private static override K`2<StateT`2<S, M>, A> LanguageExt.Traits.Stateful<LanguageExt.StateT<S,M>,S>.Gets(Func`2<S, A> f);
    private static override K`2<StateT`2<S, M>, Unit> LanguageExt.Traits.Stateful<LanguageExt.StateT<S,M>,S>.Put(S value);
    private static override K`2<StateT`2<S, M>, A> LanguageExt.Traits.MonadIO<LanguageExt.StateT<S,M>>.LiftIO(IO`1<A> ma);
    private static override K`2<StateT`2<S, M>, A> LanguageExt.Traits.SemigroupK<LanguageExt.StateT<S,M>>.Combine(K`2<StateT`2<S, M>, A> ma, K`2<StateT`2<S, M>, A> mb);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.StateT`3 : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<S, K`2<M, ValueTuple`2<A, S>>> <runState>k__BackingField;
    [CompilerGeneratedAttribute]
private static StateT`3<S, M, S> <Get>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<S, K`2<M, ValueTuple`2<A, S>>> runState { get; public set; }
    public static StateT`3<S, M, S> Get { get; }
    public StateT`3(Func`2<S, K`2<M, ValueTuple`2<A, S>>> runState);
    [CompilerGeneratedAttribute]
protected StateT`3(StateT`3<S, M, A> original);
    private static StateT`3();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Func`2<S, K`2<M, ValueTuple`2<A, S>>> get_runState();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_runState(Func`2<S, K`2<M, ValueTuple`2<A, S>>> value);
    public static StateT`3<S, M, A> Pure(A value);
    public static StateT`3<S, M, Unit> Modify(Func`2<S, S> f);
    public static StateT`3<S, M, Unit> ModifyM(Func`2<S, K`2<M, S>> f);
    public static StateT`3<S, M, Unit> Put(S value);
    public static StateT`3<S, M, A> State(A value, S state);
    public static StateT`3<S, M, A> State(ValueTuple`2<A, S> ma);
    [CompilerGeneratedAttribute]
public static StateT`3<S, M, S> get_Get();
    public static StateT`3<S, M, A> Gets(Func`2<S, A> f);
    public static StateT`3<S, M, A> GetsM(Func`2<S, K`2<M, A>> f);
    public static StateT`3<S, M, A> Lift(Pure`1<A> monad);
    public static StateT`3<S, M, A> Lift(K`2<M, A> monad);
    public static StateT`3<S, M, A> Lift(Func`1<A> f);
    public static StateT`3<S, M, A> LiftIO(IO`1<A> ma);
    public StateT`3<S, M1, B> MapT(Func`2<K`2<M, ValueTuple`2<A, S>>, K`2<M1, ValueTuple`2<B, S>>> f);
    public StateT`3<S, M, B> MapM(Func`2<K`2<M, A>, K`2<M, B>> f);
    public StateT`3<S, M, B> Map(Func`2<A, B> f);
    public StateT`3<S, M, B> Select(Func`2<A, B> f);
    public StateT`3<S, M, B> Bind(Func`2<A, K`2<StateT`2<S, M>, B>> f);
    public StateT`3<S, M, B> Bind(Func`2<A, StateT`3<S, M, B>> f);
    public StateT`3<S, M, B> Bind(Func`2<A, Gets`2<S, B>> f);
    public StateT`3<S, M, Unit> Bind(Func`2<A, Put`1<S>> f);
    public StateT`3<S, M, Unit> Bind(Func`2<A, Modify`1<S>> f);
    public StateT`3<S, M, B> Bind(Func`2<A, IO`1<B>> f);
    public StateT`3<S, M, B> Bind(Func`2<A, K`2<IO, B>> f);
    public StateT`3<S, M, C> SelectMany(Func`2<A, K`2<StateT`2<S, M>, B>> bind, Func`3<A, B, C> project);
    public StateT`3<S, M, C> SelectMany(Func`2<A, StateT`3<S, M, B>> bind, Func`3<A, B, C> project);
    public StateT`3<S, M, C> SelectMany(Func`2<A, K`2<M, B>> bind, Func`3<A, B, C> project);
    public StateT`3<S, M, C> SelectMany(Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    public StateT`3<S, M, C> SelectMany(Func`2<A, Put`1<S>> bind, Func`3<A, Unit, C> project);
    public StateT`3<S, M, C> SelectMany(Func`2<A, Gets`2<S, B>> bind, Func`3<A, B, C> project);
    public StateT`3<S, M, C> SelectMany(Func`2<A, Modify`1<S>> bind, Func`3<A, Unit, C> project);
    public StateT`3<S, M, C> SelectMany(Func`2<A, IO`1<B>> bind, Func`3<A, B, C> project);
    public StateT`3<S, M, C> SelectMany(Func`2<A, K`2<IO, B>> bind, Func`3<A, B, C> project);
    public static StateT`3<S, M, A> op_RightShift(StateT`3<S, M, A> lhs, StateT`3<S, M, A> rhs);
    public static StateT`3<S, M, A> op_RightShift(StateT`3<S, M, A> lhs, K`2<StateT`2<S, M>, A> rhs);
    public static StateT`3<S, M, A> op_RightShift(StateT`3<S, M, A> lhs, StateT`3<S, M, Unit> rhs);
    public static StateT`3<S, M, A> op_RightShift(StateT`3<S, M, A> lhs, K`2<StateT`2<S, M>, Unit> rhs);
    public static StateT`3<S, M, A> op_Implicit(Pure`1<A> ma);
    public static StateT`3<S, M, A> op_Implicit(IO`1<A> ma);
    public static StateT`3<S, M, A> op_BitwiseOr(StateT`3<S, M, A> ma, StateT`3<S, M, A> mb);
    public static StateT`3<S, M, A> op_BitwiseOr(StateT`3<S, M, A> ma, Pure`1<A> mb);
    public static StateT`3<S, M, A> op_BitwiseOr(Pure`1<A> ma, StateT`3<S, M, A> mb);
    public static StateT`3<S, M, A> op_BitwiseOr(IO`1<A> ma, StateT`3<S, M, A> mb);
    public K`2<M, ValueTuple`2<A, S>> Run(S state);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(StateT`3<S, M, A> left, StateT`3<S, M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(StateT`3<S, M, A> left, StateT`3<S, M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(StateT`3<S, M, A> other);
    [CompilerGeneratedAttribute]
public virtual StateT`3<S, M, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`2& runState);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.StateTExtensions : object {
    [ExtensionAttribute]
public static StateT`3<Env, M, A> As(K`2<StateT`2<Env, M>, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static StateT`3<Env, M, A> Flatten(StateT`3<Env, M, StateT`3<Env, M, A>> mma);
    [ExtensionAttribute]
public static StateT`3<Env, M, C> SelectMany(K`2<M, A> ma, Func`2<A, K`2<StateT`2<Env, M>, B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
public static StateT`3<Env, M, C> SelectMany(K`2<M, A> ma, Func`2<A, StateT`3<Env, M, B>> bind, Func`3<A, B, C> project);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[CollectionBuilderAttribute("LanguageExt.Stack", "createRange")]
public class LanguageExt.Stck`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Stck`1<A> <Empty>k__BackingField;
    private StckInternal`1<A> value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Stck`1<A> Empty { get; }
    private StckInternal`1<A> Value { get; }
    [NullableAttribute("2")]
[PureAttribute]
public object Case { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public int Length { get; }
    internal Stck`1(StckInternal`1<A> value);
    public Stck`1(IEnumerable`1<A> initial);
    public Stck`1(ReadOnlySpan`1<A> initial);
    private static Stck`1();
    [CompilerGeneratedAttribute]
public static override Stck`1<A> get_Empty();
    private StckInternal`1<A> get_Value();
    [NullableContextAttribute("2")]
public object get_Case();
    [PureAttribute]
public Stck`1<A> Reverse();
    public bool get_IsEmpty();
    public int get_Count();
    public int get_Length();
    [PureAttribute]
public Stck`1<A> Clear();
    [PureAttribute]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    [PureAttribute]
public Seq`1<A> ToSeq();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToFullString(string separator);
    [PureAttribute]
public string ToFullArrayString(string separator);
    [PureAttribute]
public Iterable`1<A> AsIterable();
    public Stck`1<A> Do(Action`1<A> f);
    [PureAttribute]
public A Peek();
    [PureAttribute]
public Stck`1<A> Peek(Action`1<A> Some, Action None);
    [PureAttribute]
public R Peek(Func`2<A, R> Some, Func`1<R> None);
    [PureAttribute]
public Option`1<A> TryPeek();
    [PureAttribute]
public Stck`1<A> Pop();
    [PureAttribute]
public ValueTuple`2<Stck`1<A>, Option`1<A>> TryPop();
    [PureAttribute]
public Stck`1<A> Pop(Action`1<A> Some, Action None);
    [PureAttribute]
public R Pop(Func`3<Stck`1<A>, A, R> Some, Func`1<R> None);
    [PureAttribute]
public Stck`1<A> Push(A value);
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public static Stck`1<A> op_Implicit(SeqEmpty _);
    [PureAttribute]
public static override Stck`1<A> op_Addition(Stck`1<A> lhs, Stck`1<A> rhs);
    [PureAttribute]
public sealed virtual Stck`1<A> Combine(Stck`1<A> rhs);
    [PureAttribute]
public static Stck`1<A> op_Subtraction(Stck`1<A> lhs, Stck`1<A> rhs);
    [PureAttribute]
public Stck`1<A> Subtract(Stck`1<A> rhs);
    [PureAttribute]
public static bool op_Equality(Stck`1<A> lhs, Stck`1<A> rhs);
    [PureAttribute]
public static bool op_Inequality(Stck`1<A> lhs, Stck`1<A> rhs);
    [PureAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public sealed virtual bool Equals(Stck`1<A> other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.StckInternal`1 : object {
    public static StckInternal`1<A> Empty;
    [NullableAttribute("2")]
private A value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private StckInternal`1<A> tail;
    private int hashCode;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    internal StckInternal`1(A value, StckInternal`1<A> tail);
    public StckInternal`1(A[] initial);
    public StckInternal`1(ReadOnlySpan`1<A> initial);
    internal StckInternal`1(Lst`1<A> initial);
    private static StckInternal`1();
    [CompilerGeneratedAttribute]
public int get_Count();
    [PureAttribute]
public StckInternal`1<A> Reverse();
    public bool get_IsEmpty();
    [PureAttribute]
public StckInternal`1<A> Clear();
    [PureAttribute]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    [PureAttribute]
public Iterable`1<A> AsIterable();
    [PureAttribute]
public A Peek();
    [PureAttribute]
public StckInternal`1<A> Peek(Action`1<A> Some, Action None);
    [PureAttribute]
public R Peek(Func`2<A, R> Some, Func`1<R> None);
    [PureAttribute]
public Option`1<A> TryPeek();
    [PureAttribute]
public StckInternal`1<A> Pop();
    [PureAttribute]
public ValueTuple`2<StckInternal`1<A>, Option`1<A>> TryPop();
    [PureAttribute]
public StckInternal`1<A> Pop(Action`1<A> Some, Action None);
    [PureAttribute]
public R Pop(Func`3<StckInternal`1<A>, A, R> Some, Func`1<R> None);
    [PureAttribute]
public StckInternal`1<A> Push(A value);
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public static StckInternal`1<A> op_Addition(StckInternal`1<A> lhs, StckInternal`1<A> rhs);
    [PureAttribute]
public StckInternal`1<A> Combine(StckInternal`1<A> rhs);
    public virtual int GetHashCode();
    [IteratorStateMachineAttribute("LanguageExt.StckInternal`1/<<AsIterable>g__Yield|17_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<A> <AsIterable>g__Yield|17_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.STM : object {
    private static long refIdNext;
    private static AtomHashMap`3<EqLong, long, RefState> state;
    private static AsyncLocal`1<Transaction> transaction;
    public static long TransactionId { get; }
    private static STM();
    private static void OnChange(TrieMap`3<EqLong, long, Change`1<RefState>> patch);
    internal static Ref`1<A> NewRef(A value, Func`2<A, bool> validator);
    internal static R DoTransaction(Func`1<R> op, Isolation isolation);
    [NullableContextAttribute("2")]
internal static ValueTask`1<R> DoTransaction(Func`1<ValueTask`1<R>> op, Isolation isolation);
    internal static Eff`1<R> DoTransaction(Eff`1<R> op, Isolation isolation);
    internal static Eff`2<RT, R> DoTransaction(Eff`2<RT, R> op, Isolation isolation);
    internal static R DoTransaction(Func`1<CommuteRef`1<R>> op, Isolation isolation);
    private static R RunTransaction(Func`1<R> op, Isolation isolation);
    private static Eff`2<RT, R> RunTransaction(Eff`2<RT, R> op, Isolation isolation);
    private static Eff`1<R> RunTransaction(Eff`1<R> op, Isolation isolation);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("LanguageExt.STM/<RunTransaction>d__14`1")]
private static ValueTask`1<R> RunTransaction(Func`1<ValueTask`1<R>> op, Isolation isolation);
    private static R RunTransaction(Func`1<CommuteRef`1<R>> op, Isolation isolation);
    private static R ValidateAndCommit(Transaction t, Isolation isolation, R result, long returnRefId);
    private static void ValidateReads(Transaction t, TrieMap`3<EqLong, long, RefState> s);
    private static TrieMap`3<EqLong, long, RefState> CommitWrites(Transaction t, TrieMap`3<EqLong, long, RefState> s);
    private static ValueTuple`2<TrieMap`3<EqLong, long, RefState>, R> CommitCommutes(Transaction t, TrieMap`3<EqLong, long, RefState> s, long returnRefId, R result);
    internal static object Read(long id);
    internal static void Write(long id, object value);
    internal static A Commute(long id, Func`2<A, A> f);
    internal static A Commute(long id, X x, Func`3<X, A, A> f);
    internal static A Commute(long id, X x, Y y, Func`4<X, Y, A, A> f);
    internal static void Finalise(long id);
    private static Func`2<object, object> CastCommute(Func`2<A, A> f);
    public static long get_TransactionId();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class LanguageExt.StopEv`1 : Ev`1<A> {
    public static Ev`1<A> Default;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
private StopEv`1(StopEv`1<A> original);
    private static StopEv`1();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(StopEv`1<A> left, StopEv`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(StopEv`1<A> left, StopEv`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Ev`1<A> other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(StopEv`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override StopEv`1<A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class LanguageExt.StreamAsyncEnumerableT`2 : StreamT`2<M, A> {
    [CompilerGeneratedAttribute]
private IAsyncEnumerable`1<A> <items>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IAsyncEnumerable`1<A> items { get; public set; }
    public K`2<M, MList`1<A>> runListT { get; }
    public StreamAsyncEnumerableT`2(IAsyncEnumerable`1<A> items);
    [CompilerGeneratedAttribute]
protected StreamAsyncEnumerableT`2(StreamAsyncEnumerableT`2<M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IAsyncEnumerable`1<A> get_items();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_items(IAsyncEnumerable`1<A> value);
    public virtual K`2<M, MList`1<A>> get_runListT();
    public virtual StreamT`2<M, A> Tail();
    public virtual StreamT`2<M, B> Map(Func`2<A, B> f);
    public virtual StreamT`2<M, A> Merge(K`2<StreamT`1<M>, A> rhs);
    [AsyncIteratorStateMachineAttribute("LanguageExt.StreamAsyncEnumerableT`2/<MergeSync>d__12")]
private static IAsyncEnumerable`1<A> MergeSync(IAsyncEnumerable`1<A> lhs, IEnumerable`1<A> rhs);
    [AsyncIteratorStateMachineAttribute("LanguageExt.StreamAsyncEnumerableT`2/<MergeAsync>d__13")]
private static IAsyncEnumerable`1<A> MergeAsync(IAsyncEnumerable`1<A> lhs, IAsyncEnumerable`1<A> rhs);
    private static Task EnumerateAsync(IAsyncEnumerable`1<A> ma, ConcurrentQueue`1<A> queue, AutoResetEvent wait);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(StreamAsyncEnumerableT`2<M, A> left, StreamAsyncEnumerableT`2<M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(StreamAsyncEnumerableT`2<M, A> left, StreamAsyncEnumerableT`2<M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(StreamT`2<M, A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(StreamAsyncEnumerableT`2<M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override StreamAsyncEnumerableT`2<M, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(IAsyncEnumerable`1& items);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private K`2<M, MList`1<A>> <get_runListT>b__8_0(EnvIO e);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class LanguageExt.StreamEnumerableT`2 : StreamT`2<M, A> {
    [CompilerGeneratedAttribute]
private IEnumerable`1<A> <items>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IEnumerable`1<A> items { get; public set; }
    public K`2<M, MList`1<A>> runListT { get; }
    public StreamEnumerableT`2(IEnumerable`1<A> items);
    [CompilerGeneratedAttribute]
protected StreamEnumerableT`2(StreamEnumerableT`2<M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IEnumerable`1<A> get_items();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_items(IEnumerable`1<A> value);
    public virtual K`2<M, MList`1<A>> get_runListT();
    public virtual StreamT`2<M, A> Tail();
    public static StreamT`2<M, A> Lift(IEnumerator`1<A> iter);
    public virtual StreamT`2<M, B> Map(Func`2<A, B> f);
    public virtual StreamT`2<M, A> Merge(K`2<StreamT`1<M>, A> rhs);
    [IteratorStateMachineAttribute("LanguageExt.StreamEnumerableT`2/<MergeSync>d__13")]
private static IEnumerable`1<A> MergeSync(IEnumerable`1<A> lhs, IEnumerable`1<A> rhs);
    [AsyncIteratorStateMachineAttribute("LanguageExt.StreamEnumerableT`2/<MergeAsync>d__14")]
private static IAsyncEnumerable`1<A> MergeAsync(IEnumerable`1<A> lhs, IAsyncEnumerable`1<A> rhs);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(StreamEnumerableT`2<M, A> left, StreamEnumerableT`2<M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(StreamEnumerableT`2<M, A> left, StreamEnumerableT`2<M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(StreamT`2<M, A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(StreamEnumerableT`2<M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override StreamEnumerableT`2<M, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(IEnumerable`1& items);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class LanguageExt.StreamLiftM`2 : StreamT`2<M, A> {
    [CompilerGeneratedAttribute]
private K`2<M, A> <pureMA>k__BackingField;
    [CompilerGeneratedAttribute]
private K`2<M, MList`1<A>> <runListT>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public K`2<M, A> pureMA { get; public set; }
    public K`2<M, MList`1<A>> runListT { get; }
    public StreamLiftM`2(K`2<M, A> pureMA);
    [CompilerGeneratedAttribute]
protected StreamLiftM`2(StreamLiftM`2<M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public K`2<M, A> get_pureMA();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_pureMA(K`2<M, A> value);
    [CompilerGeneratedAttribute]
public virtual K`2<M, MList`1<A>> get_runListT();
    public virtual StreamT`2<M, A> Tail();
    public virtual StreamT`2<M, B> Map(Func`2<A, B> f);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(StreamLiftM`2<M, A> left, StreamLiftM`2<M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(StreamLiftM`2<M, A> left, StreamLiftM`2<M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(StreamT`2<M, A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(StreamLiftM`2<M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override StreamLiftM`2<M, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(K`2& pureMA);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class LanguageExt.StreamMainT`2 : StreamT`2<M, A> {
    [CompilerGeneratedAttribute]
private K`2<M, MList`1<A>> <runListT>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public K`2<M, MList`1<A>> runListT { get; }
    public StreamMainT`2(K`2<M, MList`1<A>> runListT);
    [CompilerGeneratedAttribute]
protected StreamMainT`2(StreamMainT`2<M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual K`2<M, MList`1<A>> get_runListT();
    public virtual StreamT`2<M, B> Map(Func`2<A, B> f);
    public virtual StreamT`2<M, A> Tail();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(StreamMainT`2<M, A> left, StreamMainT`2<M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(StreamMainT`2<M, A> left, StreamMainT`2<M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(StreamT`2<M, A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(StreamMainT`2<M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override StreamMainT`2<M, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(K`2& runListT);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class LanguageExt.StreamPureT`2 : StreamT`2<M, A> {
    [CompilerGeneratedAttribute]
private A <value>k__BackingField;
    [CompilerGeneratedAttribute]
private K`2<M, MList`1<A>> <runListT>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public A value { get; public set; }
    public K`2<M, MList`1<A>> runListT { get; }
    public StreamPureT`2(A value);
    [CompilerGeneratedAttribute]
protected StreamPureT`2(StreamPureT`2<M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public A get_value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_value(A value);
    [CompilerGeneratedAttribute]
public virtual K`2<M, MList`1<A>> get_runListT();
    public virtual StreamT`2<M, A> Tail();
    public virtual StreamT`2<M, B> Map(Func`2<A, B> f);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(StreamPureT`2<M, A> left, StreamPureT`2<M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(StreamPureT`2<M, A> left, StreamPureT`2<M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(StreamT`2<M, A> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(StreamPureT`2<M, A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override StreamPureT`2<M, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(A& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.StreamT : object {
    public static StreamT`2<M, A> pure(A value);
    public static StreamT`2<M, A> liftF(K`2<F, A> items);
    public static StreamT`2<M, A> lift(IAsyncEnumerable`1<A> items);
    public static StreamT`2<M, A> liftM(IAsyncEnumerable`1<K`2<M, A>> items);
    public static StreamT`2<M, A> lift(IEnumerable`1<A> items);
    public static StreamT`2<M, A> liftM(IEnumerable`1<K`2<M, A>> items);
    public static StreamT`2<M, A> lift(Seq`1<A> items);
    public static StreamT`2<M, A> liftM(Seq`1<K`2<M, A>> items);
    public static StreamT`2<M, A> lift(K`2<M, A> ma);
    public static StreamT`2<M, A> liftIO(IO`1<A> ma);
    public static StreamT`2<M, A> liftIO(K`2<IO, A> ma);
    public static StreamT`2<M, A> merge(K`2<StreamT`1<M>, A> first, K`2<StreamT`1<M>, A> second);
    public static StreamT`2<M, A> merge(K`2<StreamT`1<M>, A> first, K`2<StreamT`1<M>, A> second, K`2[] rest);
    public static StreamT`2<M, ValueTuple`2<A, B>> zip(K`2<StreamT`1<M>, A> first, K`2<StreamT`1<M>, B> second);
    public static StreamT`2<M, ValueTuple`3<A, B, C>> zip(K`2<StreamT`1<M>, A> first, K`2<StreamT`1<M>, B> second, K`2<StreamT`1<M>, C> third);
    public static StreamT`2<M, ValueTuple`4<A, B, C, D>> zip(K`2<StreamT`1<M>, A> first, K`2<StreamT`1<M>, B> second, K`2<StreamT`1<M>, C> third, K`2<StreamT`1<M>, D> fourth);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.StreamT`1 : object {
    public static StreamT`2<M, A> pure(A value);
    public static StreamT`2<M, A> lift(IEnumerable`1<A> items);
    public static StreamT`2<M, A> lift(IAsyncEnumerable`1<A> items);
    public static StreamT`2<M, A> lift(Seq`1<A> items);
    public static StreamT`2<M, A> liftIO(IO`1<A> ma);
    private static override K`2<StreamT`1<M>, B> LanguageExt.Traits.Monad<LanguageExt.StreamT<M>>.Bind(K`2<StreamT`1<M>, A> mma, Func`2<A, K`2<StreamT`1<M>, B>> f);
    private static override K`2<StreamT`1<M>, B> LanguageExt.Traits.Functor<LanguageExt.StreamT<M>>.Map(Func`2<A, B> f, K`2<StreamT`1<M>, A> mma);
    private static override K`2<StreamT`1<M>, A> LanguageExt.Traits.Applicative<LanguageExt.StreamT<M>>.Pure(A value);
    private static override K`2<StreamT`1<M>, B> LanguageExt.Traits.Applicative<LanguageExt.StreamT<M>>.Apply(K`2<StreamT`1<M>, Func`2<A, B>> mf, K`2<StreamT`1<M>, A> ma);
    private static override K`2<StreamT`1<M>, A> LanguageExt.Traits.MonadT<LanguageExt.StreamT<M>,M>.Lift(K`2<M, A> ma);
    private static override K`2<StreamT`1<M>, A> LanguageExt.Traits.SemigroupK<LanguageExt.StreamT<M>>.Combine(K`2<StreamT`1<M>, A> lhs, K`2<StreamT`1<M>, A> rhs);
    private static override K`2<StreamT`1<M>, A> LanguageExt.Traits.MonoidK<LanguageExt.StreamT<M>>.Empty();
    private static override K`2<StreamT`1<M>, A> LanguageExt.Traits.MonadIO<LanguageExt.StreamT<M>>.LiftIO(IO`1<A> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.StreamT`2 : object {
    [CompilerGeneratedAttribute]
private static StreamT`2<M, A> <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public K`2<M, MList`1<A>> runListT { get; }
    public static StreamT`2<M, A> Empty { get; }
    [CompilerGeneratedAttribute]
protected StreamT`2(StreamT`2<M, A> original);
    private static StreamT`2();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public abstract virtual K`2<M, MList`1<A>> get_runListT();
    public abstract virtual StreamT`2<M, A> Tail();
    public abstract virtual StreamT`2<M, B> Map(Func`2<A, B> f);
    [CompilerGeneratedAttribute]
public static override StreamT`2<M, A> get_Empty();
    public static StreamT`2<M, A> Pure(A value);
    public static StreamT`2<M, A> LiftF(K`2<F, A> foldable);
    public static StreamT`2<M, A> Lift(IAsyncEnumerable`1<A> stream);
    public static StreamT`2<M, A> LiftM(IAsyncEnumerable`1<K`2<M, A>> stream);
    public static StreamT`2<M, A> Lift(IEnumerable`1<A> stream);
    public static StreamT`2<M, A> LiftM(IEnumerable`1<K`2<M, A>> stream);
    public static StreamT`2<M, A> Lift(Seq`1<A> stream);
    public static StreamT`2<M, A> LiftM(Seq`1<K`2<M, A>> stream);
    public static StreamT`2<M, A> Lift(K`2<M, A> ma);
    public static StreamT`2<M, A> LiftIO(IO`1<A> ma);
    public static StreamT`2<M, A> LiftIO(K`2<IO, A> ma);
    public K`2<M, Option`1<ValueTuple`2<A, StreamT`2<M, A>>>> Run();
    public K`2<M, Unit> Iter();
    public K`2<M, Option`1<A>> Head();
    public K`2<M, A> HeadUnsafe();
    public StreamT`2<M, S> Fold(S state, Func`3<S, A, Option`1<S>> f);
    public StreamT`2<M, S> FoldUntil(S state, Func`3<S, A, S> f, Func`3<S, A, bool> until);
    public StreamT`2<M, S> FoldWhile(S state, Func`3<S, A, S> f, Func`3<S, A, bool> while);
    public K`2<M, S> FoldM(S state, Func`3<S, A, K`2<M, S>> f);
    public sealed virtual StreamT`2<M, A> Combine(StreamT`2<M, A> second);
    public StreamT`2<M, A> Combine(K`2<StreamT`1<M>, A> second);
    public virtual StreamT`2<M, A> Merge(K`2<StreamT`1<M>, A> second);
    public StreamT`2<M, A> Merge(K`2<StreamT`1<M>, A> second, K`2[] rest);
    public virtual StreamT`2<M, ValueTuple`2<A, B>> Zip(K`2<StreamT`1<M>, B> second);
    public StreamT`2<M, ValueTuple`3<A, B, C>> Zip(K`2<StreamT`1<M>, B> second, K`2<StreamT`1<M>, C> third);
    public StreamT`2<M, ValueTuple`4<A, B, C, D>> Zip(K`2<StreamT`1<M>, B> second, K`2<StreamT`1<M>, C> third, K`2<StreamT`1<M>, D> fourth);
    public StreamT`2<M, A> Filter(Func`2<A, bool> f);
    public StreamT`2<M, A> Where(Func`2<A, bool> f);
    public StreamT`2<M, B> Select(Func`2<A, B> f);
    public StreamT`2<M, B> Bind(Func`2<A, StreamT`2<M, B>> f);
    public StreamT`2<M, B> Bind(Func`2<A, K`2<StreamT`1<M>, B>> f);
    public StreamT`2<M, B> Bind(Func`2<A, Pure`1<B>> f);
    public StreamT`2<M, B> Bind(Func`2<A, IO`1<B>> f);
    public StreamT`2<M, B> Bind(Func`2<A, K`2<IO, B>> f);
    public StreamT`2<M, C> SelectMany(Func`2<A, StreamT`2<M, B>> bind, Func`3<A, B, C> project);
    public StreamT`2<M, C> SelectMany(Func`2<A, K`2<StreamT`1<M>, B>> bind, Func`3<A, B, C> project);
    public StreamT`2<M, C> SelectMany(Func`2<A, Pure`2<M, B>> bind, Func`3<A, B, C> project);
    public StreamT`2<M, C> SelectMany(Func`2<A, IO`1<B>> bind, Func`3<A, B, C> project);
    public StreamT`2<M, C> SelectMany(Func`2<A, K`2<IO, B>> bind, Func`3<A, B, C> project);
    public static StreamT`2<M, A> op_Implicit(Pure`1<A> value);
    public static StreamT`2<M, A> op_Implicit(Iterable`1<A> value);
    public static StreamT`2<M, A> op_Implicit(IO`1<A> value);
    public static StreamT`2<M, A> op_Addition(StreamT`2<M, A> lhs, K`2<StreamT`1<M>, A> rhs);
    public static StreamT`2<M, A> op_BitwiseAnd(StreamT`2<M, A> lhs, K`2<StreamT`1<M>, A> rhs);
    public static StreamT`2<M, A> op_RightShift(StreamT`2<M, A> lhs, K`2<StreamT`1<M>, A> rhs);
    public static StreamT`2<M, A> op_RightShift(StreamT`2<M, A> lhs, K`2<StreamT`1<M>, Unit> rhs);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(StreamT`2<M, A> left, StreamT`2<M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(StreamT`2<M, A> left, StreamT`2<M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(StreamT`2<M, A> other);
    [CompilerGeneratedAttribute]
public abstract virtual StreamT`2<M, A> <Clone>$();
    [CompilerGeneratedAttribute]
internal static K`2<M, MList`1<A>> <Merge>g__go|30_0(K`2<M, MList`1<A>> lhs, K`2<M, MList`1<A>> rhs);
    [IteratorStateMachineAttribute("LanguageExt.StreamT`2/<<Merge>g__JoinIter|30_1>d")]
[CompilerGeneratedAttribute]
internal static IEnumerator`1<A> <Merge>g__JoinIter|30_1(IEnumerator`1<A> lhs, IEnumerator`1<A> rhs);
    [CompilerGeneratedAttribute]
internal static K`2<M, MList`1<ValueTuple`2<A, B>>> <Zip>g__go|32_0(K`2<M, MList`1<A>> lhs, K`2<M, MList`1<B>> rhs);
    [IteratorStateMachineAttribute("LanguageExt.StreamT`2/<<Zip>g__JoinIter|32_1>d`1")]
[CompilerGeneratedAttribute]
internal static IEnumerator`1<A> <Zip>g__JoinIter|32_1(IEnumerator`1<A> lhs, IEnumerator`1<A> rhs);
}
[IsReadOnlyAttribute]
public class LanguageExt.StringCultureIgnoreCaseM : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [NullableAttribute("1")]
public string Value { get; public set; }
    public static StringComparison Comparison { get; }
    [NullableContextAttribute("1")]
public StringCultureIgnoreCaseM(string Value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Value();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(string value);
    [NullableContextAttribute("1")]
private static override Fin`1<StringCultureIgnoreCaseM> LanguageExt.Traits.Domain.DomainType<LanguageExt.StringCultureIgnoreCaseM,System.String>.From(string repr);
    [NullableContextAttribute("1")]
public static StringCultureIgnoreCaseM From(string repr);
    [NullableContextAttribute("1")]
public sealed virtual string To();
    public static override StringComparison get_Comparison();
    [NullableContextAttribute("1")]
public static string op_Implicit(StringCultureIgnoreCaseM value);
    [NullableContextAttribute("1")]
public static StringCultureIgnoreCaseM op_Implicit(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static override bool op_Inequality(StringCultureIgnoreCaseM left, StringCultureIgnoreCaseM right);
    [CompilerGeneratedAttribute]
public static override bool op_Equality(StringCultureIgnoreCaseM left, StringCultureIgnoreCaseM right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(StringCultureIgnoreCaseM other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void Deconstruct(String& Value);
}
[IsReadOnlyAttribute]
public class LanguageExt.StringCultureM : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [NullableAttribute("1")]
public string Value { get; public set; }
    public static StringComparison Comparison { get; }
    [NullableContextAttribute("1")]
public StringCultureM(string Value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Value();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(string value);
    [NullableContextAttribute("1")]
private static override Fin`1<StringCultureM> LanguageExt.Traits.Domain.DomainType<LanguageExt.StringCultureM,System.String>.From(string repr);
    [NullableContextAttribute("1")]
public static StringCultureM From(string repr);
    [NullableContextAttribute("1")]
public sealed virtual string To();
    public static override StringComparison get_Comparison();
    [NullableContextAttribute("1")]
public static string op_Implicit(StringCultureM value);
    [NullableContextAttribute("1")]
public static StringCultureM op_Implicit(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static override bool op_Inequality(StringCultureM left, StringCultureM right);
    [CompilerGeneratedAttribute]
public static override bool op_Equality(StringCultureM left, StringCultureM right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(StringCultureM other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void Deconstruct(String& Value);
}
[IsReadOnlyAttribute]
public class LanguageExt.StringInvariantIgnoreCaseM : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [NullableAttribute("1")]
public string Value { get; public set; }
    public static StringComparison Comparison { get; }
    [NullableContextAttribute("1")]
public StringInvariantIgnoreCaseM(string Value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Value();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(string value);
    [NullableContextAttribute("1")]
private static override Fin`1<StringInvariantIgnoreCaseM> LanguageExt.Traits.Domain.DomainType<LanguageExt.StringInvariantIgnoreCaseM,System.String>.From(string repr);
    [NullableContextAttribute("1")]
public static StringInvariantIgnoreCaseM From(string repr);
    [NullableContextAttribute("1")]
public sealed virtual string To();
    public static override StringComparison get_Comparison();
    [NullableContextAttribute("1")]
public static string op_Implicit(StringInvariantIgnoreCaseM value);
    [NullableContextAttribute("1")]
public static StringInvariantIgnoreCaseM op_Implicit(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static override bool op_Inequality(StringInvariantIgnoreCaseM left, StringInvariantIgnoreCaseM right);
    [CompilerGeneratedAttribute]
public static override bool op_Equality(StringInvariantIgnoreCaseM left, StringInvariantIgnoreCaseM right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(StringInvariantIgnoreCaseM other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void Deconstruct(String& Value);
}
[IsReadOnlyAttribute]
public class LanguageExt.StringInvariantM : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [NullableAttribute("1")]
public string Value { get; public set; }
    public static StringComparison Comparison { get; }
    [NullableContextAttribute("1")]
public StringInvariantM(string Value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Value();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(string value);
    [NullableContextAttribute("1")]
public static override Fin`1<StringInvariantM> From(string repr);
    [NullableContextAttribute("1")]
public static override StringInvariantM FromUnsafe(string repr);
    [NullableContextAttribute("1")]
public sealed virtual string To();
    public static override StringComparison get_Comparison();
    [NullableContextAttribute("1")]
public static string op_Implicit(StringInvariantM value);
    [NullableContextAttribute("1")]
public static StringInvariantM op_Implicit(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static override bool op_Inequality(StringInvariantM left, StringInvariantM right);
    [CompilerGeneratedAttribute]
public static override bool op_Equality(StringInvariantM left, StringInvariantM right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(StringInvariantM other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void Deconstruct(String& Value);
}
[IsReadOnlyAttribute]
public class LanguageExt.StringM : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [NullableAttribute("1")]
public string Value { get; public set; }
    public static StringComparison Comparison { get; }
    [NullableContextAttribute("1")]
public StringM(string Value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Value();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(string value);
    [NullableContextAttribute("1")]
private static override Fin`1<StringM> LanguageExt.Traits.Domain.DomainType<LanguageExt.StringM,System.String>.From(string repr);
    [NullableContextAttribute("1")]
public static StringM From(string repr);
    [NullableContextAttribute("1")]
public static override StringM FromUnsafe(string repr);
    [NullableContextAttribute("1")]
public sealed virtual string To();
    public static override StringComparison get_Comparison();
    [NullableContextAttribute("1")]
public static string op_Implicit(StringM value);
    [NullableContextAttribute("1")]
public static StringM op_Implicit(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static override bool op_Inequality(StringM left, StringM right);
    [CompilerGeneratedAttribute]
public static override bool op_Equality(StringM left, StringM right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(StringM other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void Deconstruct(String& Value);
}
[NullableContextAttribute("1")]
public interface LanguageExt.StringM`1 {
    private static SELF LanguageExt.Traits.Monoid<SELF>.Empty { get; }
    public int Length { get; }
    private sealed virtual override SELF LanguageExt.Traits.Semigroup<SELF>.Combine(SELF rhs);
    private static override SELF LanguageExt.Traits.Monoid<SELF>.get_Empty();
    public virtual int get_Length();
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IEquatable<SELF>.Equals(SELF rhs);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IComparable<SELF>.CompareTo(SELF rhs);
    private static override SELF System.IParsable<SELF>.Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("2")]
private static override bool System.IParsable<SELF>.TryParse(string s, IFormatProvider provider, SELF& result);
    [NullableContextAttribute("0")]
private static override SELF System.ISpanParsable<SELF>.Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    [NullableContextAttribute("0")]
private static override bool System.ISpanParsable<SELF>.TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, SELF& result);
}
[IsReadOnlyAttribute]
public class LanguageExt.StringOrdinalIgnoreCaseM : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [NullableAttribute("1")]
public string Value { get; public set; }
    public static StringComparison Comparison { get; }
    [NullableContextAttribute("1")]
public StringOrdinalIgnoreCaseM(string Value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Value();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(string value);
    [NullableContextAttribute("1")]
private static override Fin`1<StringOrdinalIgnoreCaseM> LanguageExt.Traits.Domain.DomainType<LanguageExt.StringOrdinalIgnoreCaseM,System.String>.From(string repr);
    [NullableContextAttribute("1")]
public static StringInvariantM From(string repr);
    [NullableContextAttribute("1")]
public sealed virtual string To();
    public static override StringComparison get_Comparison();
    [NullableContextAttribute("1")]
public static string op_Implicit(StringOrdinalIgnoreCaseM value);
    [NullableContextAttribute("1")]
public static StringOrdinalIgnoreCaseM op_Implicit(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static override bool op_Inequality(StringOrdinalIgnoreCaseM left, StringOrdinalIgnoreCaseM right);
    [CompilerGeneratedAttribute]
public static override bool op_Equality(StringOrdinalIgnoreCaseM left, StringOrdinalIgnoreCaseM right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(StringOrdinalIgnoreCaseM other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void Deconstruct(String& Value);
}
[IsReadOnlyAttribute]
public class LanguageExt.StringOrdinalM : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [NullableAttribute("1")]
public string Value { get; public set; }
    public static StringComparison Comparison { get; }
    [NullableContextAttribute("1")]
public StringOrdinalM(string Value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Value();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(string value);
    [NullableContextAttribute("1")]
private static override Fin`1<StringOrdinalM> LanguageExt.Traits.Domain.DomainType<LanguageExt.StringOrdinalM,System.String>.From(string repr);
    [NullableContextAttribute("1")]
public static StringOrdinalM From(string repr);
    [NullableContextAttribute("1")]
public sealed virtual string To();
    public static override StringComparison get_Comparison();
    [NullableContextAttribute("1")]
public static string op_Implicit(StringOrdinalM value);
    [NullableContextAttribute("1")]
public static StringOrdinalM op_Implicit(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static override bool op_Inequality(StringOrdinalM left, StringOrdinalM right);
    [CompilerGeneratedAttribute]
public static override bool op_Equality(StringOrdinalM left, StringOrdinalM right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(StringOrdinalM other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void Deconstruct(String& Value);
}
public static class LanguageExt.SysInfo : object {
    private static int processorCount;
    private static int defaultAsyncSequenceParallelism;
    public static int ProcessorCount { get; }
    public static int DefaultAsyncSequenceParallelism { get; public set; }
    public static int get_ProcessorCount();
    public static int get_DefaultAsyncSequenceParallelism();
    public static void set_DefaultAsyncSequenceParallelism(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.TaskExtensions : object {
    [ExtensionAttribute]
public static bool CompletedSuccessfully(Task`1<A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Task`1<A> AsFailedTask(Exception ex);
    [ExtensionAttribute]
[PureAttribute]
public static Task`1<A> AsTask(A self);
    [ExtensionAttribute]
[PureAttribute]
public static Task`1<A> ToRef(ValueTask`1<A> self);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<Flatten>d__4`1")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<A> Flatten(Task`1<Task`1<A>> self);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<Flatten>d__5`1")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<A> Flatten(Task`1<Task`1<Task`1<A>>> self);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<Select>d__6`2")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<U> Select(Task`1<T> self, Func`2<T, U> map);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<Where>d__7`1")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<T> Where(Task`1<T> self, Func`2<T, bool> pred);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<SelectMany>d__8`2")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<U> SelectMany(Task`1<T> self, Func`2<T, Task`1<U>> bind);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<SelectMany>d__9`3")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<V> SelectMany(Task`1<T> self, Func`2<T, Task`1<U>> bind, Func`3<T, U, V> project);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<Count>d__10`1")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<int> Count(Task`1<T> self);
    [ExtensionAttribute]
[PureAttribute]
public static Task`1<U> Bind(Task`1<T> self, Func`2<T, Task`1<U>> bind);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<Exists>d__12`1")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<bool> Exists(Task`1<T> self, Func`2<T, bool> pred);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<ExistsAsync>d__13`1")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<bool> ExistsAsync(Task`1<T> self, Func`2<T, Task`1<bool>> pred);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<ForAll>d__14`1")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<bool> ForAll(Task`1<T> self, Func`2<T, bool> pred);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<ForAllAsync>d__15`1")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<bool> ForAllAsync(Task`1<T> self, Func`2<T, Task`1<bool>> pred);
    [ExtensionAttribute]
[PureAttribute]
public static Task`1<T> Filter(Task`1<T> self, Func`2<T, bool> pred);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<Fold>d__17`2")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<S> Fold(Task`1<T> self, S state, Func`3<S, T, S> folder);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<FoldAsync>d__18`2")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<S> FoldAsync(Task`1<T> self, S state, Func`3<S, T, Task`1<S>> folder);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<Iter>d__19`1")]
[ExtensionAttribute]
public static Task`1<Unit> Iter(Task`1<T> self, Action`1<T> f);
    [ExtensionAttribute]
public static Task`1<A> Do(Task`1<A> ma, Action`1<A> f);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<Map>d__21`2")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<U> Map(Task`1<T> self, Func`2<T, U> map);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<MapAsync>d__22`2")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<U> MapAsync(Task`1<T> self, Func`2<T, Task`1<U>> map);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<Join>d__23`4")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<V> Join(Task`1<T> source, Task`1<U> inner, Func`2<T, K> outerKeyMap, Func`2<U, K> innerKeyMap, Func`3<T, U, V> project);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<GroupJoin>d__24`4")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<V> GroupJoin(Task`1<T> source, Task`1<U> inner, Func`2<T, K> outerKeyMap, Func`2<U, K> innerKeyMap, Func`3<T, Task`1<U>, V> project);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<Plus>d__25`1")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<A> Plus(Task`1<A> ma, Task`1<A> mb);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<PlusFirst>d__26`1")]
[ExtensionAttribute]
[PureAttribute]
public static Task`1<A> PlusFirst(Task`1<A> ma, Task`1<A> mb);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<Cast>d__27`1")]
[ExtensionAttribute]
public static Task`1<A> Cast(Task source);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<ToUnit>d__28")]
[ExtensionAttribute]
public static Task`1<Unit> ToUnit(Task source);
    [ExtensionAttribute]
internal static Task`1<IList`1<B>> WindowMap(IEnumerable`1<Task`1<A>> ma, Func`2<A, B> f, CancellationToken token);
    [AsyncStateMachineAttribute("LanguageExt.TaskExtensions/<WindowMap>d__30`2")]
[ExtensionAttribute]
internal static Task`1<IList`1<B>> WindowMap(IEnumerable`1<Task`1<A>> ma, int windowSize, Func`2<A, B> f, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class LanguageExt.Tasks : object {
    [AsyncStateMachineAttribute("LanguageExt.Tasks/<ForAll>d__0`1")]
[PureAttribute]
public static Task`1<bool> ForAll(IEnumerable`1<Task`1<A>> fs, Func`2<A, bool> pred, CancellationToken token);
    [AsyncStateMachineAttribute("LanguageExt.Tasks/<ForAll>d__1`1")]
[PureAttribute]
public static Task`1<bool> ForAll(IEnumerable`1<Task`1<A>> fs, Func`2<A, bool> pred, int windowSize, CancellationToken token);
    [AsyncStateMachineAttribute("LanguageExt.Tasks/<Exists>d__2`1")]
[PureAttribute]
public static Task`1<bool> Exists(IEnumerable`1<Task`1<A>> fs, Func`2<A, bool> pred, CancellationToken token);
    [AsyncStateMachineAttribute("LanguageExt.Tasks/<Exists>d__3`1")]
[PureAttribute]
public static Task`1<bool> Exists(IEnumerable`1<Task`1<A>> fs, Func`2<A, bool> pred, int windowSize, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Tell`1 : object {
    [CompilerGeneratedAttribute]
private W <Value>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public W Value { get; public set; }
    public Tell`1(W Value);
    [CompilerGeneratedAttribute]
protected Tell`1(Tell`1<W> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public W get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(W value);
    public WriterT`3<W, M, Unit> ToWriterT();
    public Writer`2<W, Unit> ToWriter();
    public WriterT`3<W, M, C> SelectMany(Func`2<Unit, WriterT`3<W, M, B>> bind, Func`3<Unit, B, C> project);
    public Writer`2<W, C> SelectMany(Func`2<Unit, Writer`2<W, B>> bind, Func`3<Unit, B, C> project);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Tell`1<W> left, Tell`1<W> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Tell`1<W> left, Tell`1<W> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Tell`1<W> other);
    [CompilerGeneratedAttribute]
public virtual Tell`1<W> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(W& Value);
    [CompilerGeneratedAttribute]
private K`2<M, ValueTuple`2<Unit, W>> <ToWriterT>b__7_0(W w);
    [CompilerGeneratedAttribute]
private ValueTuple`2<Unit, W> <ToWriter>b__8_0(W w);
}
[IsReadOnlyAttribute]
public class LanguageExt.Time : ValueType {
    private double Value;
    public double Seconds { get; }
    public double Milliseconds { get; }
    public double Minutes { get; }
    public double Hours { get; }
    public double Days { get; }
    internal Time(double value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public sealed virtual bool Equals(Time other);
    public bool Equals(Time other, double epsilon);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Time other);
    public Time Add(Time rhs);
    public Time Subtract(Time rhs);
    public Time Multiply(double rhs);
    public Time Divide(double rhs);
    public static Time op_Multiply(Time lhs, double rhs);
    public static Time op_Multiply(double lhs, Time rhs);
    public static TimeSq op_Multiply(Time lhs, Time rhs);
    public static TimeSq op_ExclusiveOr(Time lhs, int power);
    public static Time op_Division(Time lhs, double rhs);
    public static Time op_Addition(Time lhs, Time rhs);
    public static DateTime op_Addition(DateTime lhs, Time rhs);
    public static Time op_Subtraction(Time lhs, Time rhs);
    public static DateTime op_Subtraction(DateTime lhs, Time rhs);
    public static double op_Division(Time lhs, Time rhs);
    public static bool op_Equality(Time lhs, Time rhs);
    public static bool op_Inequality(Time lhs, Time rhs);
    public static bool op_GreaterThan(Time lhs, Time rhs);
    public static bool op_LessThan(Time lhs, Time rhs);
    public static bool op_GreaterThanOrEqual(Time lhs, Time rhs);
    public static bool op_LessThanOrEqual(Time lhs, Time rhs);
    public Time Pow(double power);
    public Time Round();
    public Time Sqrt();
    public Time Abs();
    public Time Min(Time rhs);
    public Time Max(Time rhs);
    public TimeSpan ToTimeSpan();
    public static TimeSpan op_Implicit(Time value);
    public static Time op_Implicit(TimeSpan value);
    public double get_Seconds();
    public double get_Milliseconds();
    public double get_Minutes();
    public double get_Hours();
    public double get_Days();
}
[IsReadOnlyAttribute]
public class LanguageExt.TimeSq : ValueType {
    private double Value;
    public double Seconds2 { get; }
    internal TimeSq(double value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public sealed virtual bool Equals(TimeSq other);
    public bool Equals(TimeSq other, double epsilon);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(TimeSq other);
    public TimeSq Add(TimeSq rhs);
    public TimeSq Subtract(TimeSq rhs);
    public TimeSq Multiply(double rhs);
    public TimeSq Divide(double rhs);
    public static TimeSq op_Multiply(TimeSq lhs, double rhs);
    public static TimeSq op_Multiply(double lhs, TimeSq rhs);
    public static TimeSq op_Division(TimeSq lhs, double rhs);
    public static TimeSq op_Addition(TimeSq lhs, TimeSq rhs);
    public static TimeSq op_Subtraction(TimeSq lhs, TimeSq rhs);
    public static double op_Division(TimeSq lhs, TimeSq rhs);
    public static bool op_Equality(TimeSq lhs, TimeSq rhs);
    public static bool op_Inequality(TimeSq lhs, TimeSq rhs);
    public static bool op_GreaterThan(TimeSq lhs, TimeSq rhs);
    public static bool op_LessThan(TimeSq lhs, TimeSq rhs);
    public static bool op_GreaterThanOrEqual(TimeSq lhs, TimeSq rhs);
    public static bool op_LessThanOrEqual(TimeSq lhs, TimeSq rhs);
    public TimeSq Round();
    public Time Sqrt();
    public TimeSq Abs();
    public TimeSq Min(TimeSq rhs);
    public TimeSq Max(TimeSq rhs);
    public double get_Seconds2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class LanguageExt.TrackedResource : object {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected TrackedResource(TrackedResource original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public abstract virtual IO`1<Unit> Release();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(TrackedResource left, TrackedResource right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(TrackedResource left, TrackedResource right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(TrackedResource other);
    [CompilerGeneratedAttribute]
public abstract virtual TrackedResource <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.TrackedResourceAsyncDisposable`1 : TrackedResource {
    [CompilerGeneratedAttribute]
private A <Value>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public A Value { get; public set; }
    public TrackedResourceAsyncDisposable`1(A Value);
    [CompilerGeneratedAttribute]
protected TrackedResourceAsyncDisposable`1(TrackedResourceAsyncDisposable`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public A get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(A value);
    public virtual IO`1<Unit> Release();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TrackedResourceAsyncDisposable`1<A> left, TrackedResourceAsyncDisposable`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TrackedResourceAsyncDisposable`1<A> left, TrackedResourceAsyncDisposable`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(TrackedResource other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(TrackedResourceAsyncDisposable`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override TrackedResourceAsyncDisposable`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(A& Value);
    [AsyncStateMachineAttribute("LanguageExt.TrackedResourceAsyncDisposable`1/<<Release>b__7_0>d")]
[CompilerGeneratedAttribute]
private Task`1<Unit> <Release>b__7_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.TrackedResourceDisposable`1 : TrackedResource {
    [CompilerGeneratedAttribute]
private A <Value>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public A Value { get; public set; }
    public TrackedResourceDisposable`1(A Value);
    [CompilerGeneratedAttribute]
protected TrackedResourceDisposable`1(TrackedResourceDisposable`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public A get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(A value);
    public virtual IO`1<Unit> Release();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TrackedResourceDisposable`1<A> left, TrackedResourceDisposable`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TrackedResourceDisposable`1<A> left, TrackedResourceDisposable`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(TrackedResource other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(TrackedResourceDisposable`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override TrackedResourceDisposable`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(A& Value);
    [CompilerGeneratedAttribute]
private Unit <Release>b__7_1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class LanguageExt.TrackedResourceWithFree`1 : TrackedResource {
    [CompilerGeneratedAttribute]
private A <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<A, IO`1<Unit>> <Dispose>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public A Value { get; public set; }
    public Func`2<A, IO`1<Unit>> Dispose { get; public set; }
    public TrackedResourceWithFree`1(A Value, Func`2<A, IO`1<Unit>> Dispose);
    [CompilerGeneratedAttribute]
protected TrackedResourceWithFree`1(TrackedResourceWithFree`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public A get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(A value);
    [CompilerGeneratedAttribute]
public Func`2<A, IO`1<Unit>> get_Dispose();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Dispose(Func`2<A, IO`1<Unit>> value);
    public virtual IO`1<Unit> Release();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TrackedResourceWithFree`1<A> left, TrackedResourceWithFree`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TrackedResourceWithFree`1<A> left, TrackedResourceWithFree`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(TrackedResource other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(TrackedResourceWithFree`1<A> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override TrackedResourceWithFree`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(A& Value, Func`2& Dispose);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class LanguageExt.TrackingHashMap : object {
    [PureAttribute]
public static TrackingHashMap`2<K, V> empty();
    [PureAttribute]
public static TrackingHashMap`2<K, V> singleton(ValueTuple`2<K, V> value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`2<K, V> singleton(K key, V value);
    [PureAttribute]
public static TrackingHashMap`2<K, V> create();
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`2<K, V> create(Tuple`2<K, V> head, Tuple`2[] tail);
    [PureAttribute]
public static TrackingHashMap`2<K, V> create(ValueTuple`2<K, V> head, ValueTuple`2[] tail);
    [PureAttribute]
public static TrackingHashMap`2<K, V> create(KeyValuePair`2<K, V> head, KeyValuePair`2[] tail);
    [PureAttribute]
public static TrackingHashMap`2<K, V> createRange(IEnumerable`1<Tuple`2<K, V>> keyValues);
    [PureAttribute]
public static TrackingHashMap`2<K, V> createRange(IEnumerable`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static TrackingHashMap`2<K, V> createRange(ReadOnlySpan`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static TrackingHashMap`2<K, V> createRange(IEnumerable`1<KeyValuePair`2<K, V>> keyValues);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`2<K, V> add(TrackingHashMap`2<K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`2<K, V> tryAdd(TrackingHashMap`2<K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`2<K, V> addOrUpdate(TrackingHashMap`2<K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`2<K, V> addOrUpdate(TrackingHashMap`2<K, V> map, K key, Func`2<V, V> Some, Func`1<V> None);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`2<K, V> addOrUpdate(TrackingHashMap`2<K, V> map, K key, Func`2<V, V> Some, V None);
    [PureAttribute]
public static TrackingHashMap`2<K, V> addRange(TrackingHashMap`2<K, V> map, IEnumerable`1<Tuple`2<K, V>> keyValues);
    [PureAttribute]
public static TrackingHashMap`2<K, V> addRange(TrackingHashMap`2<K, V> map, IEnumerable`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static TrackingHashMap`2<K, V> addRange(TrackingHashMap`2<K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> keyValues);
    [PureAttribute]
public static TrackingHashMap`2<K, V> tryAddRange(TrackingHashMap`2<K, V> map, IEnumerable`1<Tuple`2<K, V>> keyValues);
    [PureAttribute]
public static TrackingHashMap`2<K, V> tryAddRange(TrackingHashMap`2<K, V> map, IEnumerable`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static TrackingHashMap`2<K, V> tryAddRange(TrackingHashMap`2<K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> keyValues);
    [PureAttribute]
public static TrackingHashMap`2<K, V> addOrUpdateRange(TrackingHashMap`2<K, V> map, IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public static TrackingHashMap`2<K, V> addOrUpdateRange(TrackingHashMap`2<K, V> map, IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public static TrackingHashMap`2<K, V> addOrUpdateRange(TrackingHashMap`2<K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> range);
    [PureAttribute]
public static TrackingHashMap`2<K, V> remove(TrackingHashMap`2<K, V> map, K key);
    [PureAttribute]
public static bool containsKey(TrackingHashMap`2<K, V> map, K key);
    [PureAttribute]
public static bool contains(TrackingHashMap`2<K, V> map, KeyValuePair`2<K, V> kv);
    [PureAttribute]
public static bool contains(TrackingHashMap`2<K, V> map, Tuple`2<K, V> kv);
    [PureAttribute]
public static bool contains(TrackingHashMap`2<K, V> map, ValueTuple`2<K, V> kv);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`2<K, V> setItem(TrackingHashMap`2<K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`2<K, V> trySetItem(TrackingHashMap`2<K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`2<K, V> trySetItem(TrackingHashMap`2<K, V> map, K key, Func`2<V, V> Some);
    [PureAttribute]
public static TrackingHashMap`2<K, V> setItems(TrackingHashMap`2<K, V> map, IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public static TrackingHashMap`2<K, V> setItems(TrackingHashMap`2<K, V> map, IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public static TrackingHashMap`2<K, V> setItems(TrackingHashMap`2<K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> items);
    [PureAttribute]
public static TrackingHashMap`2<K, V> trySetItems(TrackingHashMap`2<K, V> map, IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public static TrackingHashMap`2<K, V> trySetItems(TrackingHashMap`2<K, V> map, IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public static TrackingHashMap`2<K, V> trySetItems(TrackingHashMap`2<K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> items);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`2<K, V> trySetItems(TrackingHashMap`2<K, V> map, IEnumerable`1<K> keys, Func`2<V, V> Some);
    [PureAttribute]
public static Option`1<V> find(TrackingHashMap`2<K, V> map, K key);
    [NullableContextAttribute("1")]
[PureAttribute]
public static IEnumerable`1<V> findSeq(TrackingHashMap`2<K, V> map, K key);
    [NullableContextAttribute("1")]
[PureAttribute]
public static R find(TrackingHashMap`2<K, V> map, K key, Func`2<V, R> Some, Func`1<R> None);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`2<K, V> setItem(TrackingHashMap`2<K, V> map, K key, Func`2<V, V> mapper);
    public static Unit iter(TrackingHashMap`2<K, V> map, Action`1<V> action);
    public static Unit iter(TrackingHashMap`2<K, V> map, Action`2<K, V> action);
    [PureAttribute]
public static bool forall(TrackingHashMap`2<K, V> map, Func`2<V, bool> pred);
    [PureAttribute]
public static bool forall(TrackingHashMap`2<K, V> map, Func`3<K, V, bool> pred);
    [PureAttribute]
public static bool forall(TrackingHashMap`2<K, V> map, Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public static bool forall(TrackingHashMap`2<K, V> map, Func`2<KeyValuePair`2<K, V>, bool> pred);
    [PureAttribute]
public static TrackingHashMap`2<K, V> filter(TrackingHashMap`2<K, V> map, Func`2<V, bool> predicate);
    [PureAttribute]
public static TrackingHashMap`2<K, V> filter(TrackingHashMap`2<K, V> map, Func`3<K, V, bool> predicate);
    [PureAttribute]
public static int length(TrackingHashMap`2<K, T> map);
    [NullableContextAttribute("1")]
[PureAttribute]
public static S fold(TrackingHashMap`2<K, V> map, S state, Func`4<S, K, V, S> folder);
    [NullableContextAttribute("1")]
[PureAttribute]
public static S fold(TrackingHashMap`2<K, V> map, S state, Func`3<S, V, S> folder);
    [PureAttribute]
public static bool exists(TrackingHashMap`2<K, V> map, Func`3<K, V, bool> pred);
    [PureAttribute]
public static bool exists(TrackingHashMap`2<K, V> map, Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public static bool exists(TrackingHashMap`2<K, V> map, Func`2<KeyValuePair`2<K, V>, bool> pred);
    [PureAttribute]
public static bool exists(TrackingHashMap`2<K, V> map, Func`2<V, bool> pred);
    [PureAttribute]
public static TrackingHashMap`3<EqK, K, V> singleton(ValueTuple`2<K, V> value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> singleton(K key, V value);
    [PureAttribute]
public static TrackingHashMap`3<EqK, K, V> empty();
    [PureAttribute]
public static TrackingHashMap`3<EqK, K, V> create();
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> create(Tuple`2<K, V> head, Tuple`2[] tail);
    [PureAttribute]
public static TrackingHashMap`3<EqK, K, V> create(ValueTuple`2<K, V> head, ValueTuple`2[] tail);
    [PureAttribute]
public static TrackingHashMap`3<EqK, K, V> create(KeyValuePair`2<K, V> head, KeyValuePair`2[] tail);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> createRange(IEnumerable`1<Tuple`2<K, V>> keyValues);
    [PureAttribute]
public static TrackingHashMap`3<EqK, K, V> createRange(IEnumerable`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static TrackingHashMap`3<EqK, K, V> createRange(ReadOnlySpan`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static TrackingHashMap`3<EqK, K, V> createRange(IEnumerable`1<KeyValuePair`2<K, V>> keyValues);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> add(TrackingHashMap`3<EqK, K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> tryAdd(TrackingHashMap`3<EqK, K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> addOrUpdate(TrackingHashMap`3<EqK, K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> addOrUpdate(TrackingHashMap`3<EqK, K, V> map, K key, Func`2<V, V> Some, Func`1<V> None);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> addOrUpdate(TrackingHashMap`3<EqK, K, V> map, K key, Func`2<V, V> Some, V None);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> addRange(TrackingHashMap`3<EqK, K, V> map, IEnumerable`1<Tuple`2<K, V>> keyValues);
    [PureAttribute]
public static TrackingHashMap`3<EqK, K, V> addRange(TrackingHashMap`3<EqK, K, V> map, IEnumerable`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static TrackingHashMap`3<EqK, K, V> addRange(TrackingHashMap`3<EqK, K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> keyValues);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> tryAddRange(TrackingHashMap`3<EqK, K, V> map, IEnumerable`1<Tuple`2<K, V>> keyValues);
    [PureAttribute]
public static TrackingHashMap`3<EqK, K, V> tryAddRange(TrackingHashMap`3<EqK, K, V> map, IEnumerable`1<ValueTuple`2<K, V>> keyValues);
    [PureAttribute]
public static TrackingHashMap`3<EqK, K, V> tryAddRange(TrackingHashMap`3<EqK, K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> keyValues);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> addOrUpdateRange(TrackingHashMap`3<EqK, K, V> map, IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public static TrackingHashMap`3<EqK, K, V> addOrUpdateRange(TrackingHashMap`3<EqK, K, V> map, IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public static TrackingHashMap`3<EqK, K, V> addOrUpdateRange(TrackingHashMap`3<EqK, K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> range);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> remove(TrackingHashMap`3<EqK, K, V> map, K key);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool containsKey(TrackingHashMap`3<EqK, K, V> map, K key);
    [PureAttribute]
public static bool contains(TrackingHashMap`3<EqK, K, V> map, KeyValuePair`2<K, V> kv);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool contains(TrackingHashMap`3<EqK, K, V> map, Tuple`2<K, V> kv);
    [PureAttribute]
public static bool contains(TrackingHashMap`3<EqK, K, V> map, ValueTuple`2<K, V> kv);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> setItem(TrackingHashMap`3<EqK, K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> trySetItem(TrackingHashMap`3<EqK, K, V> map, K key, V value);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> trySetItem(TrackingHashMap`3<EqK, K, V> map, K key, Func`2<V, V> Some);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> setItems(TrackingHashMap`3<EqK, K, V> map, IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public static TrackingHashMap`3<EqK, K, V> setItems(TrackingHashMap`3<EqK, K, V> map, IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public static TrackingHashMap`3<EqK, K, V> setItems(TrackingHashMap`3<EqK, K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> items);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> trySetItems(TrackingHashMap`3<EqK, K, V> map, IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public static TrackingHashMap`3<EqK, K, V> trySetItems(TrackingHashMap`3<EqK, K, V> map, IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public static TrackingHashMap`3<EqK, K, V> trySetItems(TrackingHashMap`3<EqK, K, V> map, IEnumerable`1<KeyValuePair`2<K, V>> items);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> trySetItems(TrackingHashMap`3<EqK, K, V> map, IEnumerable`1<K> keys, Func`2<V, V> Some);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Option`1<V> find(TrackingHashMap`3<EqK, K, V> map, K key);
    [NullableContextAttribute("1")]
[PureAttribute]
public static IEnumerable`1<V> findSeq(TrackingHashMap`3<EqK, K, V> map, K key);
    [NullableContextAttribute("1")]
[PureAttribute]
public static R find(TrackingHashMap`3<EqK, K, V> map, K key, Func`2<V, R> Some, Func`1<R> None);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> setItem(TrackingHashMap`3<EqK, K, V> map, K key, Func`2<V, V> mapper);
    [NullableContextAttribute("1")]
public static Unit iter(TrackingHashMap`3<EqK, K, V> map, Action`1<V> action);
    [NullableContextAttribute("1")]
public static Unit iter(TrackingHashMap`3<EqK, K, V> map, Action`2<K, V> action);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool forall(TrackingHashMap`3<EqK, K, V> map, Func`2<V, bool> pred);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool forall(TrackingHashMap`3<EqK, K, V> map, Func`3<K, V, bool> pred);
    [PureAttribute]
public static bool forall(TrackingHashMap`3<EqK, K, V> map, Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public static bool forall(TrackingHashMap`3<EqK, K, V> map, Func`2<KeyValuePair`2<K, V>, bool> pred);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> filter(TrackingHashMap`3<EqK, K, V> map, Func`2<V, bool> predicate);
    [NullableContextAttribute("1")]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> filter(TrackingHashMap`3<EqK, K, V> map, Func`3<K, V, bool> predicate);
    [PureAttribute]
public static int length(TrackingHashMap`3<EqK, K, T> map);
    [NullableContextAttribute("1")]
[PureAttribute]
public static S fold(TrackingHashMap`3<EqK, K, V> map, S state, Func`4<S, K, V, S> folder);
    [NullableContextAttribute("1")]
[PureAttribute]
public static S fold(TrackingHashMap`3<EqK, K, V> map, S state, Func`3<S, V, S> folder);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool exists(TrackingHashMap`3<EqK, K, V> map, Func`3<K, V, bool> pred);
    [PureAttribute]
public static bool exists(TrackingHashMap`3<EqK, K, V> map, Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public static bool exists(TrackingHashMap`3<EqK, K, V> map, Func`2<KeyValuePair`2<K, V>, bool> pred);
    [NullableContextAttribute("1")]
[PureAttribute]
public static bool exists(TrackingHashMap`3<EqK, K, V> map, Func`2<V, bool> pred);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[CollectionBuilderAttribute("LanguageExt.TrackingHashMap", "createRange")]
public class LanguageExt.TrackingHashMap`2 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static TrackingHashMap`2<K, V> <Empty>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private TrieMap`3<EqDefault`1<K>, K, V> value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private TrieMap`3<EqDefault`1<K>, K, Change`1<V>> changes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TrackingHashMap`2<K, V> Empty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal TrieMap`3<EqDefault`1<K>, K, V> Value { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal TrieMap`3<EqDefault`1<K>, K, Change`1<V>> ChangesInternal { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public HashMap`2<K, Change`1<V>> Changes { get; }
    [PureAttribute]
public V Item { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public int Length { get; }
    [PureAttribute]
public Iterable`1<K> Keys { get; }
    [PureAttribute]
public Iterable`1<V> Values { get; }
    [PureAttribute]
private IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.Keys { get; }
    [PureAttribute]
private IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.Values { get; }
    internal TrackingHashMap`2(TrieMap`3<EqDefault`1<K>, K, V> value, TrieMap`3<EqDefault`1<K>, K, Change`1<V>> changes);
    public TrackingHashMap`2(IEnumerable`1<ValueTuple`2<K, V>> items);
    public TrackingHashMap`2(IEnumerable`1<ValueTuple`2<K, V>> items, bool tryAdd);
    public TrackingHashMap`2(ReadOnlySpan`1<ValueTuple`2<K, V>> items);
    public TrackingHashMap`2(ReadOnlySpan`1<ValueTuple`2<K, V>> items, bool tryAdd);
    private static TrackingHashMap`2();
    [CompilerGeneratedAttribute]
public static override TrackingHashMap`2<K, V> get_Empty();
    internal TrieMap`3<EqDefault`1<K>, K, V> get_Value();
    internal TrieMap`3<EqDefault`1<K>, K, Change`1<V>> get_ChangesInternal();
    public HashMap`2<K, Change`1<V>> get_Changes();
    [PureAttribute]
public TrackingHashMap`2<K, V> Snapshot();
    [PureAttribute]
public static Lens`2<TrackingHashMap`2<K, V>, V> item(K key);
    [PureAttribute]
public static Lens`2<TrackingHashMap`2<K, V>, Option`1<V>> itemOrNone(K key);
    private TrackingHashMap`2<K, V> Wrap(ValueTuple`2<TrieMap`3<EqDefault`1<K>, K, V>, TrieMap`3<EqDefault`1<K>, K, Change`1<V>>> pair);
    private TrackingHashMap`2<K, V> Wrap(K key, ValueTuple`2<TrieMap`3<EqDefault`1<K>, K, V>, Change`1<V>> pair);
    public sealed virtual V get_Item(K key);
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public int get_Length();
    [PureAttribute]
public TrackingHashMap`2<K, V> Filter(Func`2<V, bool> pred);
    [PureAttribute]
public TrackingHashMap`2<K, V> Filter(Func`3<K, V, bool> pred);
    [PureAttribute]
public TrackingHashMap`2<K, V> Add(K key, V value);
    [PureAttribute]
public TrackingHashMap`2<K, V> TryAdd(K key, V value);
    [PureAttribute]
public TrackingHashMap`2<K, V> AddOrUpdate(K key, V value);
    [PureAttribute]
public TrackingHashMap`2<K, V> AddOrUpdate(K key, Func`2<V, V> Some, Func`1<V> None);
    [PureAttribute]
public TrackingHashMap`2<K, V> AddOrUpdate(K key, Func`2<V, V> Some, V None);
    [PureAttribute]
public TrackingHashMap`2<K, V> AddRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public TrackingHashMap`2<K, V> AddRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public TrackingHashMap`2<K, V> TryAddRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public TrackingHashMap`2<K, V> TryAddRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public TrackingHashMap`2<K, V> TryAddRange(IEnumerable`1<KeyValuePair`2<K, V>> range);
    [PureAttribute]
public TrackingHashMap`2<K, V> AddOrUpdateRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public TrackingHashMap`2<K, V> AddOrUpdateRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public TrackingHashMap`2<K, V> AddOrUpdateRange(IEnumerable`1<KeyValuePair`2<K, V>> range);
    [PureAttribute]
public TrackingHashMap`2<K, V> Remove(K key);
    [PureAttribute]
public Option`1<V> Find(K key);
    [PureAttribute]
public Seq`1<V> FindSeq(K key);
    [PureAttribute]
public R Find(K key, Func`2<V, R> Some, Func`1<R> None);
    [PureAttribute]
public ValueTuple`2<TrackingHashMap`2<K, V>, V> FindOrAdd(K key, Func`1<V> None);
    [PureAttribute]
public ValueTuple`2<TrackingHashMap`2<K, V>, V> FindOrAdd(K key, V value);
    [PureAttribute]
public ValueTuple`2<TrackingHashMap`2<K, V>, Option`1<V>> FindOrMaybeAdd(K key, Func`1<Option`1<V>> None);
    [PureAttribute]
public ValueTuple`2<TrackingHashMap`2<K, V>, Option`1<V>> FindOrMaybeAdd(K key, Option`1<V> None);
    [PureAttribute]
public TrackingHashMap`2<K, V> SetItem(K key, V value);
    [PureAttribute]
public TrackingHashMap`2<K, V> SetItem(K key, Func`2<V, V> Some);
    [PureAttribute]
public TrackingHashMap`2<K, V> TrySetItem(K key, V value);
    [PureAttribute]
public TrackingHashMap`2<K, V> TrySetItem(K key, Func`2<V, V> Some);
    [PureAttribute]
public sealed virtual bool ContainsKey(K key);
    [PureAttribute]
public bool Contains(K key, V value);
    [PureAttribute]
public bool Contains(V value);
    [PureAttribute]
public bool Contains(V value);
    [PureAttribute]
public bool Contains(K key, V value);
    [PureAttribute]
public TrackingHashMap`2<K, V> Clear();
    [PureAttribute]
public TrackingHashMap`2<K, V> AddRange(IEnumerable`1<KeyValuePair`2<K, V>> pairs);
    [PureAttribute]
public TrackingHashMap`2<K, V> SetItems(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [PureAttribute]
public TrackingHashMap`2<K, V> SetItems(IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public TrackingHashMap`2<K, V> SetItems(IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public TrackingHashMap`2<K, V> TrySetItems(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [PureAttribute]
public TrackingHashMap`2<K, V> TrySetItems(IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public TrackingHashMap`2<K, V> TrySetItems(IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public TrackingHashMap`2<K, V> TrySetItems(IEnumerable`1<K> keys, Func`2<V, V> Some);
    [PureAttribute]
public TrackingHashMap`2<K, V> RemoveRange(IEnumerable`1<K> keys);
    [PureAttribute]
public bool Contains(KeyValuePair`2<K, V> pair);
    public Iterable`1<K> get_Keys();
    public Iterable`1<V> get_Values();
    [PureAttribute]
public IReadOnlyDictionary`2<K, V> ToDictionary();
    [PureAttribute]
public IDictionary`2<KR, VR> ToDictionary(Func`2<ValueTuple`2<K, V>, KR> keySelector, Func`2<ValueTuple`2<K, V>, VR> valueSelector);
    public sealed virtual IEnumerator`1<ValueTuple`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public Seq`1<ValueTuple`2<K, V>> ToSeq();
    [PureAttribute]
public HashMap`2<K, V> ToHashMap();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToFullString(string separator);
    [PureAttribute]
public string ToFullArrayString(string separator);
    [PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> AsEnumerable();
    [PureAttribute]
public static TrackingHashMap`2<K, V> op_Implicit(SeqEmpty _);
    [PureAttribute]
public static bool op_Equality(TrackingHashMap`2<K, V> lhs, TrackingHashMap`2<K, V> rhs);
    [PureAttribute]
public static bool op_Inequality(TrackingHashMap`2<K, V> lhs, TrackingHashMap`2<K, V> rhs);
    [PureAttribute]
public static override TrackingHashMap`2<K, V> op_Addition(TrackingHashMap`2<K, V> lhs, TrackingHashMap`2<K, V> rhs);
    [PureAttribute]
public sealed virtual TrackingHashMap`2<K, V> Combine(TrackingHashMap`2<K, V> rhs);
    [PureAttribute]
public static TrackingHashMap`2<K, V> op_Subtraction(TrackingHashMap`2<K, V> lhs, TrackingHashMap`2<K, V> rhs);
    [PureAttribute]
public TrackingHashMap`2<K, V> Subtract(TrackingHashMap`2<K, V> rhs);
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsSubsetOf(TrackingHashMap`2<K, V> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<K> rhs);
    [PureAttribute]
public TrackingHashMap`2<K, V> Intersect(IEnumerable`1<K> rhs);
    [PureAttribute]
public TrackingHashMap`2<K, V> Intersect(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    [PureAttribute]
public TrackingHashMap`2<K, V> Intersect(IEnumerable`1<ValueTuple`2<K, V>> rhs, WhenMatched`4<K, V, V, V> Merge);
    [PureAttribute]
public TrackingHashMap`2<K, V> Intersect(HashMap`2<K, V> rhs, WhenMatched`4<K, V, V, V> Merge);
    [PureAttribute]
public TrackingHashMap`2<K, V> Intersect(TrackingHashMap`2<K, V> rhs, WhenMatched`4<K, V, V, V> Merge);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<K> other);
    [PureAttribute]
public TrackingHashMap`2<K, V> Except(IEnumerable`1<K> rhs);
    [PureAttribute]
public TrackingHashMap`2<K, V> Except(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    [PureAttribute]
public TrackingHashMap`2<K, V> SymmetricExcept(TrackingHashMap`2<K, V> rhs);
    [PureAttribute]
public TrackingHashMap`2<K, V> SymmetricExcept(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    [PureAttribute]
public TrackingHashMap`2<K, V> Union(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    [PureAttribute]
public TrackingHashMap`2<K, V> Union(IEnumerable`1<ValueTuple`2<K, V>> other, WhenMatched`4<K, V, V, V> Merge);
    [PureAttribute]
public TrackingHashMap`2<K, V> Union(IEnumerable`1<ValueTuple`2<K, W>> other, WhenMissing`3<K, W, V> MapRight, WhenMatched`4<K, V, W, V> Merge);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public sealed virtual bool Equals(TrackingHashMap`2<K, V> other);
    [NullableContextAttribute("0")]
[PureAttribute]
public bool Equals(TrackingHashMap`2<K, V> other);
    [PureAttribute]
public bool EqualsKeys(TrackingHashMap`2<K, V> other);
    [PureAttribute]
public virtual int GetHashCode();
    public TrackingHashMap`2<K, V> Do(Action`1<V> f);
    [PureAttribute]
[EditorBrowsableAttribute("1")]
public TrackingHashMap`2<K, V> Where(Func`2<V, bool> pred);
    [PureAttribute]
[EditorBrowsableAttribute("1")]
public TrackingHashMap`2<K, V> Where(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool ForAll(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<KeyValuePair`2<K, V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<V, bool> pred);
    public bool Exists(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<KeyValuePair`2<K, V>, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<V, bool> pred);
    public Unit Iter(Action`2<K, V> action);
    public Unit Iter(Action`1<V> action);
    public Unit Iter(Action`1<Tuple`2<K, V>> action);
    public Unit Iter(Action`1<ValueTuple`2<K, V>> action);
    public Unit Iter(Action`1<KeyValuePair`2<K, V>> action);
    [PureAttribute]
public S Fold(S state, Func`4<S, K, V, S> folder);
    [PureAttribute]
public S Fold(S state, Func`3<S, V, S> folder);
    [PureAttribute]
private sealed virtual override IEnumerator`1<KeyValuePair`2<K, V>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,V>>.GetEnumerator();
    private sealed virtual override IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Keys();
    private sealed virtual override IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Values();
    [PureAttribute]
public sealed virtual bool TryGetValue(K key, V& value);
    [PureAttribute]
public IReadOnlyDictionary`2<K, V> ToReadOnlyDictionary();
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`2<K, V> op_Implicit(ValueTuple`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`2<K, V> op_Implicit(ValueTuple`2<ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`2<K, V> op_Implicit(ValueTuple`3<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`2<K, V> op_Implicit(ValueTuple`4<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`2<K, V> op_Implicit(ValueTuple`5<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`2<K, V> op_Implicit(ValueTuple`6<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`2<K, V> op_Implicit(ValueTuple`7<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`1<ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`3<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`4<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`5<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`6<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`7<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`1<ValueTuple`2<K, V>>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`2<K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<ValueTuple`2<K, V>, ValueTuple`2<K, V>>>> items);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[CollectionBuilderAttribute("LanguageExt.TrackingHashMap", "createRange")]
public class LanguageExt.TrackingHashMap`3 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static TrackingHashMap`3<EqK, K, V> <Empty>k__BackingField;
    private TrieMap`3<EqK, K, V> value;
    private TrieMap`3<EqK, K, Change`1<V>> changes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TrackingHashMap`3<EqK, K, V> Empty { get; }
    internal TrieMap`3<EqK, K, V> Value { get; }
    internal TrieMap`3<EqK, K, Change`1<V>> ChangesInternal { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public HashMap`3<EqK, K, Change`1<V>> Changes { get; }
    [PureAttribute]
public V Item { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public int Length { get; }
    [PureAttribute]
public Iterable`1<K> Keys { get; }
    [PureAttribute]
public Iterable`1<V> Values { get; }
    [PureAttribute]
private IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.Keys { get; }
    [PureAttribute]
private IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.Values { get; }
    internal TrackingHashMap`3(TrieMap`3<EqK, K, V> value, TrieMap`3<EqK, K, Change`1<V>> changes);
    public TrackingHashMap`3(IEnumerable`1<ValueTuple`2<K, V>> items);
    public TrackingHashMap`3(IEnumerable`1<ValueTuple`2<K, V>> items, bool tryAdd);
    public TrackingHashMap`3(ReadOnlySpan`1<ValueTuple`2<K, V>> items);
    public TrackingHashMap`3(ReadOnlySpan`1<ValueTuple`2<K, V>> items, bool tryAdd);
    private static TrackingHashMap`3();
    [CompilerGeneratedAttribute]
public static override TrackingHashMap`3<EqK, K, V> get_Empty();
    internal TrieMap`3<EqK, K, V> get_Value();
    internal TrieMap`3<EqK, K, Change`1<V>> get_ChangesInternal();
    public HashMap`3<EqK, K, Change`1<V>> get_Changes();
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> Snapshot();
    [PureAttribute]
public static Lens`2<TrackingHashMap`3<EqK, K, V>, V> item(K key);
    [PureAttribute]
public static Lens`2<TrackingHashMap`3<EqK, K, V>, Option`1<V>> itemOrNone(K key);
    private TrackingHashMap`3<EqK, K, V> Wrap(ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> pair);
    private TrackingHashMap`3<EqK, K, V> Wrap(K key, ValueTuple`2<TrieMap`3<EqK, K, V>, Change`1<V>> pair);
    public sealed virtual V get_Item(K key);
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public int get_Length();
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> Filter(Func`2<V, bool> pred);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> Filter(Func`3<K, V, bool> pred);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> Add(K key, V value);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> TryAdd(K key, V value);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> AddOrUpdate(K key, V value);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> AddOrUpdate(K key, Func`2<V, V> Some, Func`1<V> None);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> AddOrUpdate(K key, Func`2<V, V> Some, V None);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> AddRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> AddRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> TryAddRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> TryAddRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> TryAddRange(IEnumerable`1<KeyValuePair`2<K, V>> range);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> AddOrUpdateRange(IEnumerable`1<Tuple`2<K, V>> range);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> AddOrUpdateRange(IEnumerable`1<ValueTuple`2<K, V>> range);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> AddOrUpdateRange(IEnumerable`1<KeyValuePair`2<K, V>> range);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> Remove(K key);
    [PureAttribute]
public Option`1<V> Find(K key);
    [PureAttribute]
public Seq`1<V> FindSeq(K key);
    [PureAttribute]
public R Find(K key, Func`2<V, R> Some, Func`1<R> None);
    [PureAttribute]
public ValueTuple`2<TrackingHashMap`3<EqK, K, V>, V> FindOrAdd(K key, Func`1<V> None);
    [PureAttribute]
public ValueTuple`2<TrackingHashMap`3<EqK, K, V>, V> FindOrAdd(K key, V value);
    [PureAttribute]
public ValueTuple`2<TrackingHashMap`3<EqK, K, V>, Option`1<V>> FindOrMaybeAdd(K key, Func`1<Option`1<V>> None);
    [PureAttribute]
public ValueTuple`2<TrackingHashMap`3<EqK, K, V>, Option`1<V>> FindOrMaybeAdd(K key, Option`1<V> None);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> SetItem(K key, V value);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> SetItem(K key, Func`2<V, V> Some);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> TrySetItem(K key, V value);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> TrySetItem(K key, Func`2<V, V> Some);
    [PureAttribute]
public sealed virtual bool ContainsKey(K key);
    [PureAttribute]
public bool Contains(K key, V value);
    [PureAttribute]
public bool Contains(V value);
    [PureAttribute]
public bool Contains(V value);
    [PureAttribute]
public bool Contains(K key, V value);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> Clear();
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> AddRange(IEnumerable`1<KeyValuePair`2<K, V>> pairs);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> SetItems(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> SetItems(IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> SetItems(IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> TrySetItems(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> TrySetItems(IEnumerable`1<Tuple`2<K, V>> items);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> TrySetItems(IEnumerable`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> TrySetItems(IEnumerable`1<K> keys, Func`2<V, V> Some);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> RemoveRange(IEnumerable`1<K> keys);
    [PureAttribute]
public bool Contains(KeyValuePair`2<K, V> pair);
    public Iterable`1<K> get_Keys();
    public Iterable`1<V> get_Values();
    [PureAttribute]
public IReadOnlyDictionary`2<K, V> ToDictionary();
    [PureAttribute]
public IDictionary`2<KR, VR> ToDictionary(Func`2<ValueTuple`2<K, V>, KR> keySelector, Func`2<ValueTuple`2<K, V>, VR> valueSelector);
    public sealed virtual IEnumerator`1<ValueTuple`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public Seq`1<ValueTuple`2<K, V>> ToSeq();
    [PureAttribute]
public HashMap`3<EqK, K, V> ToHashMap();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToFullString(string separator);
    [PureAttribute]
public string ToFullArrayString(string separator);
    [PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> AsEnumerable();
    [PureAttribute]
public static TrackingHashMap`3<EqK, K, V> op_Implicit(SeqEmpty _);
    [PureAttribute]
public static bool op_Equality(TrackingHashMap`3<EqK, K, V> lhs, TrackingHashMap`3<EqK, K, V> rhs);
    [PureAttribute]
public static bool op_Inequality(TrackingHashMap`3<EqK, K, V> lhs, TrackingHashMap`3<EqK, K, V> rhs);
    [PureAttribute]
public static override TrackingHashMap`3<EqK, K, V> op_Addition(TrackingHashMap`3<EqK, K, V> lhs, TrackingHashMap`3<EqK, K, V> rhs);
    [PureAttribute]
public sealed virtual TrackingHashMap`3<EqK, K, V> Combine(TrackingHashMap`3<EqK, K, V> rhs);
    [PureAttribute]
public static TrackingHashMap`3<EqK, K, V> op_Subtraction(TrackingHashMap`3<EqK, K, V> lhs, TrackingHashMap`3<EqK, K, V> rhs);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> Subtract(TrackingHashMap`3<EqK, K, V> rhs);
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsSubsetOf(TrackingHashMap`3<EqK, K, V> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<K> rhs);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> Intersect(IEnumerable`1<K> rhs);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> Intersect(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> Intersect(IEnumerable`1<ValueTuple`2<K, V>> rhs, WhenMatched`4<K, V, V, V> Merge);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> Intersect(HashMap`3<EqK, K, V> rhs, WhenMatched`4<K, V, V, V> Merge);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> Intersect(TrackingHashMap`3<EqK, K, V> rhs, WhenMatched`4<K, V, V, V> Merge);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<K> other);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> Except(IEnumerable`1<K> rhs);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> Except(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> SymmetricExcept(TrackingHashMap`3<EqK, K, V> rhs);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> SymmetricExcept(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> Union(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> Union(IEnumerable`1<ValueTuple`2<K, V>> other, WhenMatched`4<K, V, V, V> Merge);
    [PureAttribute]
public TrackingHashMap`3<EqK, K, V> Union(IEnumerable`1<ValueTuple`2<K, W>> other, WhenMissing`3<K, W, V> MapRight, WhenMatched`4<K, V, W, V> Merge);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public sealed virtual bool Equals(TrackingHashMap`3<EqK, K, V> other);
    [NullableContextAttribute("0")]
[PureAttribute]
public bool Equals(TrackingHashMap`3<EqK, K, V> other);
    [PureAttribute]
public bool EqualsKeys(TrackingHashMap`3<EqK, K, V> other);
    [PureAttribute]
public virtual int GetHashCode();
    public TrackingHashMap`3<EqK, K, V> Do(Action`1<V> f);
    [PureAttribute]
[EditorBrowsableAttribute("1")]
public TrackingHashMap`3<EqK, K, V> Where(Func`2<V, bool> pred);
    [PureAttribute]
[EditorBrowsableAttribute("1")]
public TrackingHashMap`3<EqK, K, V> Where(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool ForAll(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<KeyValuePair`2<K, V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<V, bool> pred);
    public bool Exists(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<KeyValuePair`2<K, V>, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<V, bool> pred);
    public Unit Iter(Action`2<K, V> action);
    public Unit Iter(Action`1<V> action);
    public Unit Iter(Action`1<Tuple`2<K, V>> action);
    public Unit Iter(Action`1<ValueTuple`2<K, V>> action);
    public Unit Iter(Action`1<KeyValuePair`2<K, V>> action);
    [PureAttribute]
public S Fold(S state, Func`4<S, K, V, S> folder);
    [PureAttribute]
private sealed virtual override IEnumerator`1<KeyValuePair`2<K, V>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,V>>.GetEnumerator();
    private sealed virtual override IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Keys();
    private sealed virtual override IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Values();
    [PureAttribute]
public sealed virtual bool TryGetValue(K key, V& value);
    [PureAttribute]
public IReadOnlyDictionary`2<K, V> ToReadOnlyDictionary();
    [PureAttribute]
public S Fold(S state, Func`3<S, V, S> folder);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`3<EqK, K, V> op_Implicit(ValueTuple`1<ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`3<EqK, K, V> op_Implicit(ValueTuple`2<ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`3<EqK, K, V> op_Implicit(ValueTuple`3<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`3<EqK, K, V> op_Implicit(ValueTuple`4<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`3<EqK, K, V> op_Implicit(ValueTuple`5<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`3<EqK, K, V> op_Implicit(ValueTuple`6<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`3<EqK, K, V> op_Implicit(ValueTuple`7<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`3<EqK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`1<ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`3<EqK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`3<EqK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`3<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`3<EqK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`4<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`3<EqK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`5<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`3<EqK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`6<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`3<EqK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`7<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`3<EqK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`1<ValueTuple`2<K, V>>>> items);
    [PureAttribute]
[ObsoleteAttribute("Use collection intialiser instead.  So, instead of: (x, y, z), you should now call [x, y, z]")]
public static TrackingHashMap`3<EqK, K, V> op_Implicit(ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`8<ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<K, V>, ValueTuple`2<ValueTuple`2<K, V>, ValueTuple`2<K, V>>>> items);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.TrackingHashMapExtensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static TrackingHashMap`2<K, V> ToTrackingHashMap(IEnumerable`1<ValueTuple`2<K, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static TrackingHashMap`2<K, V> ToTrackingHashMap(IEnumerable`1<Tuple`2<K, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static TrackingHashMap`2<K, V> ToTrackingHashMap(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static TrackingHashMap`2<K1, TrackingHashMap`2<K2, V>> ToTrackingHashMap(IEnumerable`1<ValueTuple`3<K1, K2, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static TrackingHashMap`2<K1, TrackingHashMap`2<K2, V>> ToTrackingHashMap(IEnumerable`1<Tuple`3<K1, K2, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static TrackingHashMap`2<K1, TrackingHashMap`2<K2, TrackingHashMap`2<K3, V>>> ToTrackingHashMap(IEnumerable`1<ValueTuple`4<K1, K2, K3, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static TrackingHashMap`2<K1, TrackingHashMap`2<K2, TrackingHashMap`2<K3, V>>> ToTrackingHashMap(IEnumerable`1<Tuple`4<K1, K2, K3, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static TrackingHashMap`2<K1, TrackingHashMap`2<K2, TrackingHashMap`2<K3, TrackingHashMap`2<K4, V>>>> ToTrackingHashMap(IEnumerable`1<ValueTuple`5<K1, K2, K3, K4, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static TrackingHashMap`2<K1, TrackingHashMap`2<K2, TrackingHashMap`2<K3, TrackingHashMap`2<K4, V>>>> ToTrackingHashMap(IEnumerable`1<Tuple`5<K1, K2, K3, K4, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static int Count(TrackingHashMap`2<K, V> self);
    [ExtensionAttribute]
[PureAttribute]
public static int Sum(TrackingHashMap`2<K, int> self);
    [ExtensionAttribute]
[PureAttribute]
public static Option`1<T> Find(TrackingHashMap`2<A, TrackingHashMap`2<B, T>> self, A outerKey, B innerKey);
    [ExtensionAttribute]
[PureAttribute]
public static Option`1<T> Find(TrackingHashMap`2<A, TrackingHashMap`2<B, TrackingHashMap`2<C, T>>> self, A aKey, B bKey, C cKey);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static R Find(TrackingHashMap`2<A, TrackingHashMap`2<B, T>> self, A outerKey, B innerKey, Func`2<T, R> Some, Func`1<R> None);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static R Find(TrackingHashMap`2<A, TrackingHashMap`2<B, TrackingHashMap`2<C, T>>> self, A aKey, B bKey, C cKey, Func`2<T, R> Some, Func`1<R> None);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static R Find(TrackingHashMap`2<A, TrackingHashMap`2<B, TrackingHashMap`2<C, TrackingHashMap`2<D, T>>>> self, A aKey, B bKey, C cKey, D dKey, Func`2<T, R> Some, Func`1<R> None);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static TrackingHashMap`2<A, TrackingHashMap`2<B, T>> AddOrUpdate(TrackingHashMap`2<A, TrackingHashMap`2<B, T>> self, A outerKey, B innerKey, Func`2<T, T> Some, Func`1<T> None);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static TrackingHashMap`2<A, TrackingHashMap`2<B, T>> AddOrUpdate(TrackingHashMap`2<A, TrackingHashMap`2<B, T>> self, A outerKey, B innerKey, T value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static TrackingHashMap`2<A, TrackingHashMap`2<B, TrackingHashMap`2<C, T>>> AddOrUpdate(TrackingHashMap`2<A, TrackingHashMap`2<B, TrackingHashMap`2<C, T>>> self, A aKey, B bKey, C cKey, T value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static TrackingHashMap`2<A, TrackingHashMap`2<B, TrackingHashMap`2<C, T>>> AddOrUpdate(TrackingHashMap`2<A, TrackingHashMap`2<B, TrackingHashMap`2<C, T>>> self, A aKey, B bKey, C cKey, Func`2<T, T> Some, Func`1<T> None);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static TrackingHashMap`2<A, TrackingHashMap`2<B, TrackingHashMap`2<C, TrackingHashMap`2<D, T>>>> AddOrUpdate(TrackingHashMap`2<A, TrackingHashMap`2<B, TrackingHashMap`2<C, TrackingHashMap`2<D, T>>>> self, A aKey, B bKey, C cKey, D dKey, T value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static TrackingHashMap`2<A, TrackingHashMap`2<B, TrackingHashMap`2<C, TrackingHashMap`2<D, T>>>> AddOrUpdate(TrackingHashMap`2<A, TrackingHashMap`2<B, TrackingHashMap`2<C, TrackingHashMap`2<D, T>>>> self, A aKey, B bKey, C cKey, D dKey, Func`2<T, T> Some, Func`1<T> None);
    [ExtensionAttribute]
[PureAttribute]
public static TrackingHashMap`2<A, TrackingHashMap`2<B, T>> Remove(TrackingHashMap`2<A, TrackingHashMap`2<B, T>> self, A outerKey, B innerKey);
    [ExtensionAttribute]
[PureAttribute]
public static TrackingHashMap`2<A, TrackingHashMap`2<B, TrackingHashMap`2<C, T>>> Remove(TrackingHashMap`2<A, TrackingHashMap`2<B, TrackingHashMap`2<C, T>>> self, A aKey, B bKey, C cKey);
    [ExtensionAttribute]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> ToTrackingHashMap(IEnumerable`1<ValueTuple`2<K, V>> items);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> ToTrackingHashMap(IEnumerable`1<Tuple`2<K, V>> items);
    [ExtensionAttribute]
[PureAttribute]
public static TrackingHashMap`3<EqK, K, V> ToTrackingHashMap(IEnumerable`1<KeyValuePair`2<K, V>> items);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Trait : object {
    [PureAttribute]
public static A plus(A x, A y);
    [PureAttribute]
public static A subtract(A x, A y);
    [PureAttribute]
public static A product(A x, A y);
    [PureAttribute]
public static A negate(A x);
    [PureAttribute]
public static Ratio`1<A> Ratio(A num, A den);
    [PureAttribute]
public static A pi();
    [PureAttribute]
public static A exp(A x);
    [PureAttribute]
public static A sqrt(A x);
    [PureAttribute]
public static A log(A x);
    [PureAttribute]
public static A pow(A x, A y);
    [PureAttribute]
public static A logBase(A x, A y);
    [PureAttribute]
public static A sin(A x);
    [PureAttribute]
public static A cos(A x);
    [PureAttribute]
public static A tan(A x);
    [PureAttribute]
public static A asin(A x);
    [PureAttribute]
public static A acos(A x);
    [PureAttribute]
public static A atan(A x);
    [PureAttribute]
public static A sinh(A x);
    [PureAttribute]
public static A cosh(A x);
    [PureAttribute]
public static A tanh(A x);
    [PureAttribute]
public static A asinh(A x);
    [PureAttribute]
public static A acosh(A x);
    [PureAttribute]
public static A atanh(A x);
    [NullableContextAttribute("0")]
[PureAttribute]
public static A fromRational(Ratio`1<int> x);
    [PureAttribute]
public static A divide(A x, A y);
    [PureAttribute]
public static A abs(A x);
    [PureAttribute]
public static A signum(A x);
    [PureAttribute]
public static A fromInteger(int x);
    [PureAttribute]
public static A fromDecimal(decimal x);
    [PureAttribute]
public static A fromFloat(float x);
    [PureAttribute]
public static A fromDouble(double x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Traits.Alternative : object {
    public static K`2<F, A> empty();
    public static K`2<F, A> combine(K`2<F, A> ma, K`2<F, A> mb);
    public static K`2<F, A> oneOf(K`2[] ms);
    public static K`2<F, A> oneOf(Seq`1<K`2<F, A>> ms);
    public static K`2<F, Seq`1<A>> some(K`2<F, A> v);
    public static K`2<F, Seq`1<A>> many(K`2<F, A> v);
    public static K`2<F, Unit> guard(bool flag);
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.Alternative`1 {
    public static virtual K`2<F, Seq`1<A>> Some(K`2<F, A> v);
    public static virtual K`2<F, Seq`1<A>> Many(K`2<F, A> v);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static K`2<F, Seq`1<A>> <Some>g__many_v|0_0(<>c__DisplayClass0_0`1& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static K`2<F, Seq`1<A>> <Some>g__some_v|0_1(<>c__DisplayClass0_0`1& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static K`2<F, Seq`1<A>> <Many>g__many_v|1_0(<>c__DisplayClass1_0`1& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static K`2<F, Seq`1<A>> <Many>g__some_v|1_1(<>c__DisplayClass1_0`1& );
}
internal static class LanguageExt.Traits.Append`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static K`2<F, Func`3<A, Seq`1<A>, Seq`1<A>>> cons;
    private static Append`2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Traits.Applicative : object {
    [PureAttribute]
public static K`2<F, A> pure(A value);
    [PureAttribute]
public static K`2<F, B> apply(K`2<F, Func`2<A, B>> mf, K`2<F, A> ma);
    [PureAttribute]
public static K`2<F, Func`2<B, C>> apply(K`2<F, Func`3<A, B, C>> mf, K`2<F, A> ma);
    [PureAttribute]
public static K`2<F, C> apply(K`2<F, Func`3<A, B, C>> mf, K`2<F, A> ma, K`2<F, B> mb);
    [PureAttribute]
public static K`2<F, D> apply(K`2<F, Func`4<A, B, C, D>> mf, K`2<F, A> ma, K`2<F, B> mb, K`2<F, C> mc);
    [PureAttribute]
public static K`2<F, Func`2<C, D>> apply(K`2<F, Func`4<A, B, C, D>> mf, K`2<F, A> ma, K`2<F, B> mb);
    [PureAttribute]
public static K`2<F, Func`2<B, Func`2<C, D>>> apply(K`2<F, Func`4<A, B, C, D>> mf, K`2<F, A> ma);
    [PureAttribute]
public static K`2<F, B> action(K`2<F, A> ma, K`2<F, B> mb);
    [PureAttribute]
public static K`2<F, A> actions(IEnumerable`1<K`2<F, A>> ma);
    [PureAttribute]
public static K`2<F, Unit> when(bool flag, K`2<F, Unit> fx);
    [PureAttribute]
public static K`2<F, Unit> unless(bool flag, K`2<F, Unit> fx);
    [PureAttribute]
public static K`2<F, B> lift(Func`2<A, B> f, K`2<F, A> fa);
    [PureAttribute]
public static K`2<F, C> lift(Func`3<A, B, C> f, K`2<F, A> fa, K`2<F, B> fb);
    [PureAttribute]
public static K`2<F, C> lift(Func`2<A, Func`2<B, C>> f, K`2<F, A> fa, K`2<F, B> fb);
    [PureAttribute]
public static K`2<F, D> lift(Func`4<A, B, C, D> f, K`2<F, A> fa, K`2<F, B> fb, K`2<F, C> fc);
    [PureAttribute]
public static K`2<F, D> lift(Func`2<A, Func`2<B, Func`2<C, D>>> f, K`2<F, A> fa, K`2<F, B> fb, K`2<F, C> fc);
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.Applicative`1 {
    public static abstract virtual K`2<F, A> Pure(A value);
    public static abstract virtual K`2<F, B> Apply(K`2<F, Func`2<A, B>> mf, K`2<F, A> ma);
    public static virtual K`2<F, B> Action(K`2<F, A> ma, K`2<F, B> mb);
    public static virtual K`2<F, C> Apply(K`2<F, Func`3<A, B, C>> mf, K`2<F, A> ma, K`2<F, B> mb);
    public static virtual K`2<F, Func`2<B, C>> Apply(K`2<F, Func`3<A, B, C>> mf, K`2<F, A> ma);
    public static virtual K`2<F, C> Apply(K`2<F, Func`2<A, Func`2<B, C>>> mf, K`2<F, A> ma, K`2<F, B> mb);
    public static virtual K`2<F, A> Actions(K`2[] fas);
    public static virtual K`2<F, A> Actions(Seq`1<K`2<F, A>> fas);
    public static virtual K`2<F, A> Actions(IEnumerable`1<K`2<F, A>> fas);
    public static virtual K`2<F, A> Actions(IAsyncEnumerable`1<K`2<F, A>> fas);
}
[NullableContextAttribute("1")]
[TraitAttribute("Num*")]
public interface LanguageExt.Traits.Arithmetic`1 {
    [PureAttribute]
public static abstract virtual A Add(A x, A y);
    [PureAttribute]
public static abstract virtual A Subtract(A x, A y);
    [PureAttribute]
public static abstract virtual A Multiply(A x, A y);
    [PureAttribute]
public static abstract virtual A Negate(A x);
}
[NullableContextAttribute("1")]
[TraitAttribute("Bool*")]
public interface LanguageExt.Traits.Bool`1 {
    [PureAttribute]
public static abstract virtual A True();
    [PureAttribute]
public static abstract virtual A False();
    [PureAttribute]
public static abstract virtual A And(A a, A b);
    [PureAttribute]
public static abstract virtual A Or(A a, A b);
    [PureAttribute]
public static abstract virtual A Not(A a);
    [PureAttribute]
public static abstract virtual A XOr(A a, A b);
    [PureAttribute]
public static abstract virtual A Implies(A a, A b);
    [PureAttribute]
public static abstract virtual A BiCondition(A a, A b);
}
[NullableContextAttribute("1")]
[TraitAttribute("Choice*")]
public interface LanguageExt.Traits.Choice`3 {
    [PureAttribute]
public static abstract virtual bool IsLeft(CH choice);
    [PureAttribute]
public static abstract virtual bool IsRight(CH choice);
    [PureAttribute]
public static abstract virtual bool IsBottom(CH choice);
    [PureAttribute]
public static abstract virtual C Match(CH choice, Func`2<L, C> Left, Func`2<R, C> Right, Func`1<C> Bottom);
    public static abstract virtual Unit Match(CH choice, Action`1<L> Left, Action`1<R> Right, Action Bottom);
}
[NullableContextAttribute("1")]
[TraitAttribute("Const*")]
public interface LanguageExt.Traits.Const`1 {
    public static TYPE Value { get; }
    public static abstract virtual TYPE get_Value();
}
public interface LanguageExt.Traits.Domain.Amount`2 {
}
public interface LanguageExt.Traits.Domain.DomainType`1 {
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.Domain.DomainType`2 {
    public static abstract virtual Fin`1<SELF> From(REPR repr);
    public static virtual SELF FromUnsafe(REPR repr);
    public abstract virtual REPR To();
}
public interface LanguageExt.Traits.Domain.Identifier`1 {
}
public interface LanguageExt.Traits.Domain.Locus`3 {
}
public interface LanguageExt.Traits.Domain.VectorSpace`2 {
}
public static class LanguageExt.Traits.Eq : object {
    [NullableContextAttribute("1")]
public static IEqualityComparer`1<A> Comparer();
}
[TraitAttribute("Eq*")]
public interface LanguageExt.Traits.Eq`1 {
    [NullableContextAttribute("1")]
[PureAttribute]
public static abstract virtual bool Equals(A x, A y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Traits.Fallible : object {
    public static K`2<F, A> fail(E error);
    public static K`2<F, A> error(Error error);
    public static K`2<F, Unit> fail(E error);
    public static K`2<F, Unit> error(Error error);
}
[NullableContextAttribute("2")]
public interface LanguageExt.Traits.Fallible`1 {
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.Fallible`2 {
    public static abstract virtual K`2<F, A> Fail(E error);
    public static abstract virtual K`2<F, A> Catch(K`2<F, A> fa, Func`2<E, bool> Predicate, Func`2<E, K`2<F, A>> Fail);
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.Fallible`4 {
    [PureAttribute]
public static abstract virtual FA op_Implicit(Fail`1<E> fail);
    [PureAttribute]
public static abstract virtual FA op_Implicit(Pure`1<A> fail);
    [PureAttribute]
public static abstract virtual FA op_BitwiseOr(FA lhs, FA rhs);
    [PureAttribute]
public static abstract virtual FA op_BitwiseOr(K`2<F, A> lhs, FA rhs);
    [PureAttribute]
public static abstract virtual FA op_BitwiseOr(FA lhs, K`2<F, A> rhs);
    [PureAttribute]
public static abstract virtual FA op_BitwiseOr(FA lhs, Pure`1<A> rhs);
    [PureAttribute]
public static abstract virtual FA op_BitwiseOr(FA lhs, Fail`1<E> rhs);
    [PureAttribute]
public static abstract virtual FA op_BitwiseOr(FA lhs, CatchM`3<E, F, A> rhs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.Traits.FallibleExtensions : object {
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Func`2<Error, bool> Predicate, Func`2<Error, K`2<F, A>> Fail);
    [ExtensionAttribute]
public static K`2<M, A> Catch(K`2<M, A> ma, Func`2<Error, bool> Predicate, Func`2<Error, K`2<IO, A>> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Func`2<Error, bool> Predicate, Func`2<Error, Error> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Func`2<Error, bool> Predicate, Func`2<Error, A> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, CatchM`3<Error, F, A> catch);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Error Match, Func`2<Error, K`2<F, A>> Fail);
    [ExtensionAttribute]
public static K`2<M, A> Catch(K`2<M, A> ma, Error Match, Func`2<Error, K`2<IO, A>> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Error Match, Func`2<Error, Error> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Error Match, Func`2<Error, A> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, int Code, Func`2<Error, K`2<F, A>> Fail);
    [ExtensionAttribute]
public static K`2<M, A> Catch(K`2<M, A> ma, int Code, Func`2<Error, K`2<IO, A>> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, int Code, Func`2<Error, Error> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, int Code, Func`2<Error, A> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Func`2<E, K`2<F, A>> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Func`2<Error, K`2<F, A>> Fail);
    [ExtensionAttribute]
public static K`2<M, A> Catch(K`2<M, A> ma, Func`2<Error, K`2<IO, A>> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Func`2<Error, Error> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Func`2<Error, A> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Fail`1<Error> fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Error fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Pure`1<A> value);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, A value);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, K`2<F, A> alternative);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.Traits.FallibleExtensionsE : object {
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Func`2<E, bool> Predicate, Func`2<E, K`2<F, A>> Fail);
    [ExtensionAttribute]
public static K`2<M, A> Catch(K`2<M, A> ma, Func`2<E, bool> Predicate, Func`2<E, K`2<IO, A>> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Func`2<E, bool> Predicate, Func`2<E, E> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Func`2<E, bool> Predicate, Func`2<E, A> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, CatchM`3<E, F, A> catch);
    [ExtensionAttribute]
public static K`2<M, A> Catch(K`2<M, A> ma, E Match, Func`2<E, K`2<IO, A>> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, E Match, Func`2<E, E> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, E Match, Func`2<E, A> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Func`2<E, K`2<F, A>> Fail);
    [ExtensionAttribute]
public static K`2<M, A> Catch(K`2<M, A> ma, Func`2<E, K`2<IO, A>> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Func`2<E, E> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Func`2<E, A> Fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Fail`1<E> fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, E fail);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, Pure`1<A> value);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, A value);
    [ExtensionAttribute]
public static K`2<F, A> Catch(K`2<F, A> fa, K`2<F, A> alternative);
}
[NullableContextAttribute("1")]
[TraitAttribute("Float*")]
public interface LanguageExt.Traits.Floating`1 {
    [PureAttribute]
public static abstract virtual A Pi();
    [PureAttribute]
public static abstract virtual A Exp(A x);
    [PureAttribute]
public static abstract virtual A Sqrt(A x);
    [PureAttribute]
public static abstract virtual A Log(A x);
    [PureAttribute]
public static abstract virtual A Pow(A x, A y);
    [PureAttribute]
public static abstract virtual A LogBase(A x, A y);
    [PureAttribute]
public static abstract virtual A Sin(A x);
    [PureAttribute]
public static abstract virtual A Cos(A x);
    [PureAttribute]
public static abstract virtual A Tan(A x);
    [PureAttribute]
public static abstract virtual A Asin(A x);
    [PureAttribute]
public static abstract virtual A Acos(A x);
    [PureAttribute]
public static abstract virtual A Atan(A x);
    [PureAttribute]
public static abstract virtual A Sinh(A x);
    [PureAttribute]
public static abstract virtual A Cosh(A x);
    [PureAttribute]
public static abstract virtual A Tanh(A x);
    [PureAttribute]
public static abstract virtual A Asinh(A x);
    [PureAttribute]
public static abstract virtual A Acosh(A x);
    [PureAttribute]
public static abstract virtual A Atanh(A x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Traits.Foldable : object {
    public static S foldWhile(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S initialState, K`2<T, A> ta);
    public static S foldWhile(Func`3<S, A, S> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S initialState, K`2<T, A> ta);
    public static S foldBackWhile(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S initialState, K`2<T, A> ta);
    public static S foldBackWhile(Func`3<S, A, S> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S initialState, K`2<T, A> ta);
    public static K`2<M, S> foldWhileM(Func`2<A, Func`2<S, K`2<M, S>>> f, Func`2<A, bool> predicate, S initialState, K`2<T, A> ta);
    public static K`2<M, S> foldWhileM(Func`3<S, A, K`2<M, S>> f, Func`2<A, bool> predicate, S initialState, K`2<T, A> ta);
    public static K`2<M, S> foldBackWhileM(Func`2<S, Func`2<A, K`2<M, S>>> f, Func`2<A, bool> predicate, S initialState, K`2<T, A> ta);
    public static K`2<M, S> foldBackWhileM(Func`3<S, A, K`2<M, S>> f, Func`2<A, bool> predicate, S initialState, K`2<T, A> ta);
    public static S foldUntil(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S initialState, K`2<T, A> ta);
    public static S foldUntil(Func`3<S, A, S> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S initialState, K`2<T, A> ta);
    public static K`2<M, S> foldUntilM(Func`2<A, Func`2<S, K`2<M, S>>> f, Func`2<A, bool> predicate, S initialState, K`2<T, A> ta);
    public static K`2<M, S> foldUntilM(Func`3<S, A, K`2<M, S>> f, Func`2<A, bool> predicate, S initialState, K`2<T, A> ta);
    public static S foldBackUntil(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S initialState, K`2<T, A> ta);
    public static S foldBackUntil(Func`3<S, A, S> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S initialState, K`2<T, A> ta);
    public static K`2<M, S> foldBackUntilM(Func`2<S, Func`2<A, K`2<M, S>>> f, Func`2<A, bool> predicate, S initialState, K`2<T, A> ta);
    public static K`2<M, S> foldBackUntilM(Func`3<S, A, K`2<M, S>> f, Func`2<A, bool> predicate, S initialState, K`2<T, A> ta);
    public static S fold(Func`2<A, Func`2<S, S>> f, S initialState, K`2<T, A> ta);
    public static S fold(Func`3<S, A, S> f, S initialState, K`2<T, A> ta);
    public static K`2<M, S> foldM(Func`2<A, Func`2<S, K`2<M, S>>> f, S initialState, K`2<T, A> ta);
    public static K`2<M, S> foldM(Func`3<S, A, K`2<M, S>> f, S initialState, K`2<T, A> ta);
    public static S foldBack(Func`2<S, Func`2<A, S>> f, S initialState, K`2<T, A> ta);
    public static S foldBack(Func`3<S, A, S> f, S initialState, K`2<T, A> ta);
    public static K`2<M, S> foldBackM(Func`2<S, Func`2<A, K`2<M, S>>> f, S initialState, K`2<T, A> ta);
    public static K`2<M, S> foldBackM(Func`3<S, A, K`2<M, S>> f, S initialState, K`2<T, A> ta);
    public static A fold(K`2<T, A> tm);
    public static A foldWhile(Func`2<ValueTuple`2<A, A>, bool> predicate, K`2<T, A> tm);
    public static A foldUntil(Func`2<ValueTuple`2<A, A>, bool> predicate, K`2<T, A> tm);
    public static B foldMap(Func`2<A, B> f, K`2<T, A> ta);
    public static B foldMapWhile(Func`2<A, B> f, Func`2<ValueTuple`2<B, A>, bool> predicate, K`2<T, A> ta);
    public static B foldMapUntil(Func`2<A, B> f, Func`2<ValueTuple`2<B, A>, bool> predicate, K`2<T, A> ta);
    public static B foldMapBack(Func`2<A, B> f, K`2<T, A> ta);
    public static B foldMapBackWhile(Func`2<A, B> f, Func`2<ValueTuple`2<B, A>, bool> predicate, K`2<T, A> ta);
    public static B foldMapBackUntil(Func`2<A, B> f, Func`2<ValueTuple`2<B, A>, bool> predicate, K`2<T, A> ta);
    public static Seq`1<A> toSeq(K`2<T, A> ta);
    public static Lst`1<A> toLst(K`2<T, A> ta);
    public static Arr`1<A> toArr(K`2<T, A> ta);
    public static Iterable`1<A> toEnumerable(K`2<T, A> ta);
    public static bool isEmpty(K`2<T, A> ta);
    public static int count(K`2<T, A> ta);
    public static bool exists(Func`2<A, bool> predicate, K`2<T, A> ta);
    public static bool forAll(Func`2<A, bool> predicate, K`2<T, A> ta);
    public static bool contains(A value, K`2<T, A> ta);
    public static bool contains(A value, K`2<T, A> ta);
    public static Option`1<A> find(Func`2<A, bool> predicate, K`2<T, A> ta);
    public static Option`1<A> findBack(Func`2<A, bool> predicate, K`2<T, A> ta);
    public static Seq`1<A> findAll(Func`2<A, bool> predicate, K`2<T, A> ta);
    public static Seq`1<A> findAllBack(Func`2<A, bool> predicate, K`2<T, A> ta);
    public static A sum(K`2<T, A> ta);
    public static A product(K`2<T, A> ta);
    public static Option`1<A> head(K`2<T, A> ta);
    public static Option`1<A> last(K`2<T, A> ta);
    public static K`2<F, Unit> iter(Func`2<A, K`2<F, B>> f, K`2<T, A> ta);
    public static Unit iter(Action`2<int, A> f, K`2<T, A> ta);
    public static Unit iter(Action`1<A> f, K`2<T, A> ta);
    public static Option`1<A> min(K`2<T, A> ta);
    public static Option`1<A> min(K`2<T, A> ta);
    public static Option`1<A> max(K`2<T, A> ta);
    public static Option`1<A> max(K`2<T, A> ta);
    public static A min(K`2<T, A> ta, A initialMin);
    public static A min(K`2<T, A> ta, A initialMin);
    public static A max(K`2<T, A> ta, A initialMax);
    public static A max(K`2<T, A> ta, A initialMax);
    public static A average(K`2<T, A> ta);
    public static B average(Func`2<A, B> f, K`2<T, A> ta);
    public static Option`1<A> at(K`2<T, A> ta, Index index);
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.Foldable`1 {
    public static abstract virtual S FoldWhile(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S initialState, K`2<T, A> ta);
    public static abstract virtual S FoldBackWhile(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S initialState, K`2<T, A> ta);
    public static virtual S FoldOption(Func`2<S, Func`2<A, Option`1<S>>> f, S initialState, K`2<T, A> ta);
    public static virtual S FoldBackOption(Func`2<A, Func`2<S, Option`1<S>>> f, S initialState, K`2<T, A> ta);
    public static virtual K`2<M, S> FoldWhileM(Func`2<A, Func`2<S, K`2<M, S>>> f, Func`2<A, bool> predicate, S initialState, K`2<T, A> ta);
    public static virtual K`2<M, S> FoldBackWhileM(Func`2<S, Func`2<A, K`2<M, S>>> f, Func`2<A, bool> predicate, S initialState, K`2<T, A> ta);
    public static virtual S FoldUntil(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S initialState, K`2<T, A> ta);
    public static virtual K`2<M, S> FoldUntilM(Func`2<A, Func`2<S, K`2<M, S>>> f, Func`2<A, bool> predicate, S initialState, K`2<T, A> ta);
    public static virtual S FoldBackUntil(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S initialState, K`2<T, A> ta);
    public static virtual K`2<M, S> FoldBackUntilM(Func`2<S, Func`2<A, K`2<M, S>>> f, Func`2<A, bool> predicate, S initialState, K`2<T, A> ta);
    public static virtual S Fold(Func`2<A, Func`2<S, S>> f, S initialState, K`2<T, A> ta);
    public static virtual K`2<M, S> FoldM(Func`2<A, Func`2<S, K`2<M, S>>> f, S initialState, K`2<T, A> ta);
    public static virtual S FoldBack(Func`2<S, Func`2<A, S>> f, S initialState, K`2<T, A> ta);
    public static virtual K`2<M, S> FoldBackM(Func`2<S, Func`2<A, K`2<M, S>>> f, S initialState, K`2<T, A> ta);
    public static virtual A Fold(K`2<T, A> tm);
    public static virtual A FoldWhile(Func`2<ValueTuple`2<A, A>, bool> predicate, K`2<T, A> tm);
    public static virtual A FoldUntil(Func`2<ValueTuple`2<A, A>, bool> predicate, K`2<T, A> tm);
    public static virtual B FoldMap(Func`2<A, B> f, K`2<T, A> ta);
    public static virtual B FoldMapWhile(Func`2<A, B> f, Func`2<ValueTuple`2<B, A>, bool> predicate, K`2<T, A> ta);
    public static virtual B FoldMapUntil(Func`2<A, B> f, Func`2<ValueTuple`2<B, A>, bool> predicate, K`2<T, A> ta);
    public static virtual B FoldMapBack(Func`2<A, B> f, K`2<T, A> ta);
    public static virtual B FoldMapBackWhile(Func`2<A, B> f, Func`2<ValueTuple`2<B, A>, bool> predicate, K`2<T, A> ta);
    public static virtual B FoldMapBackUntil(Func`2<A, B> f, Func`2<ValueTuple`2<B, A>, bool> predicate, K`2<T, A> ta);
    public static virtual Seq`1<A> ToSeq(K`2<T, A> ta);
    public static virtual Lst`1<A> ToLst(K`2<T, A> ta);
    public static virtual Arr`1<A> ToArr(K`2<T, A> ta);
    public static virtual Iterable`1<A> ToIterable(K`2<T, A> ta);
    public static virtual bool IsEmpty(K`2<T, A> ta);
    public static virtual int Count(K`2<T, A> ta);
    public static virtual bool Exists(Func`2<A, bool> predicate, K`2<T, A> ta);
    public static virtual bool ForAll(Func`2<A, bool> predicate, K`2<T, A> ta);
    public static virtual bool Contains(A value, K`2<T, A> ta);
    public static virtual bool Contains(A value, K`2<T, A> ta);
    public static virtual Option`1<A> Find(Func`2<A, bool> predicate, K`2<T, A> ta);
    public static virtual Option`1<A> FindBack(Func`2<A, bool> predicate, K`2<T, A> ta);
    public static virtual Seq`1<A> FindAll(Func`2<A, bool> predicate, K`2<T, A> ta);
    public static virtual Seq`1<A> FindAllBack(Func`2<A, bool> predicate, K`2<T, A> ta);
    public static virtual A Sum(K`2<T, A> ta);
    public static virtual A Product(K`2<T, A> ta);
    public static virtual Option`1<A> Head(K`2<T, A> ta);
    public static virtual Option`1<A> Last(K`2<T, A> ta);
    public static virtual K`2<F, Unit> Iter(Func`2<A, K`2<F, B>> f, K`2<T, A> ta);
    public static virtual Unit Iter(Action`1<A> f, K`2<T, A> ta);
    public static virtual Unit Iter(Action`2<int, A> f, K`2<T, A> ta);
    public static virtual Option`1<A> Min(K`2<T, A> ta);
    public static virtual Option`1<A> Min(K`2<T, A> ta);
    public static virtual Option`1<A> Max(K`2<T, A> ta);
    public static virtual Option`1<A> Max(K`2<T, A> ta);
    public static virtual A Min(K`2<T, A> ta, A initialMin);
    public static virtual A Min(K`2<T, A> ta, A initialMin);
    public static virtual A Max(K`2<T, A> ta, A initialMax);
    public static virtual A Max(K`2<T, A> ta, A initialMax);
    public static virtual A Average(K`2<T, A> ta);
    public static virtual B Average(Func`2<A, B> f, K`2<T, A> ta);
    public static virtual Option`1<A> At(K`2<T, A> ta, Index index);
}
[TraitAttribute("Fraction*")]
public interface LanguageExt.Traits.Fraction`1 {
    [PureAttribute]
public static abstract virtual A FromRational(Ratio`1<int> x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Traits.Functor : object {
    public static K`2<F, B> map(Func`2<A, B> f, K`2<F, A> fa);
    public static K`2<F, Unit> ignore(K`2<F, A> fa);
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.Functor`1 {
    public static abstract virtual K`2<F, B> Map(Func`2<A, B> f, K`2<F, A> ma);
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.Has`2 {
    public static K`2<M, TRAIT> Ask { get; }
    public static abstract virtual K`2<M, TRAIT> get_Ask();
}
public static class LanguageExt.Traits.Has`3 : object {
    [NullableAttribute("1")]
public static K`2<M, VALUE> ask;
    private static Has`3();
}
public static class LanguageExt.Traits.Hashable : object {
    [NullableContextAttribute("1")]
[PureAttribute]
public static int code(A x);
}
[NullableContextAttribute("2")]
[TraitAttribute("Ix*")]
public interface LanguageExt.Traits.Indexable`3 {
    [NullableContextAttribute("1")]
public static abstract virtual Option`1<VALUE> TryGet(A ma, KEY key);
    [NullableContextAttribute("1")]
public static abstract virtual VALUE Get(A ma, KEY key);
}
[NullableContextAttribute("2")]
public interface LanguageExt.Traits.K`2 {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.Traits.KExtensions : object {
    [ExtensionAttribute]
public static K`2<F, A> Kind(K`2<F, A> fa);
    [ExtensionAttribute]
public static FA SafeCast(K`2<F, A> fa);
    [ExtensionAttribute]
public static K`2<M, K`2<N, A>> KindT(K`2<M, NA> mna);
    [ExtensionAttribute]
public static K`2<M, NA> AsT(K`2<M, K`2<N, A>> mna);
}
[NullableContextAttribute("2")]
[TraitAttribute("Lift*")]
public interface LanguageExt.Traits.Liftable`2 {
    [NullableContextAttribute("1")]
[PureAttribute]
public static abstract virtual LA Lift(A x);
}
public static class LanguageExt.Traits.Local : object {
    [NullableContextAttribute("1")]
public static K`2<M, A> with(Func`2<InnerEnv, InnerEnv> f, K`2<M, A> ma);
}
[NullableContextAttribute("2")]
public interface LanguageExt.Traits.Local`2 {
    [NullableContextAttribute("1")]
public static abstract virtual K`2<M, A> With(Func`2<InnerEnv, InnerEnv> f, K`2<M, A> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Traits.Monad : object {
    [PureAttribute]
public static K`2<M, A> pure(A value);
    [PureAttribute]
public static K`2<M, A> flatten(K`2<M, K`2<M, A>> mma);
    [PureAttribute]
public static K`2<M, B> bind(K`2<M, A> ma, Func`2<A, K`2<M, B>> f);
    [PureAttribute]
public static MB bind(K`2<M, A> ma, Func`2<A, MB> f);
    [PureAttribute]
public static K`2<M, Unit> when(K`2<M, bool> Pred, K`2<M, Unit> Then);
    [PureAttribute]
public static K`2<M, Unit> when(K`2<M, bool> Pred, K`2<IO, Unit> Then);
    [PureAttribute]
public static K`2<M, Unit> when(K`2<M, bool> Pred, Pure`1<Unit> Then);
    [PureAttribute]
public static K`2<M, Unit> unless(K`2<M, bool> Pred, K`2<M, Unit> Then);
    [PureAttribute]
public static K`2<M, Unit> unless(K`2<M, bool> Pred, K`2<IO, Unit> Then);
    [PureAttribute]
public static K`2<M, Unit> unless(K`2<M, bool> Pred, Pure`1<Unit> Then);
    [PureAttribute]
public static K`2<M, A> iff(K`2<M, bool> Pred, K`2<M, A> Then, K`2<M, A> Else);
    [PureAttribute]
public static K`2<M, A> iff(K`2<M, bool> Pred, K`2<M, A> Then, K`2<IO, A> Else);
    [PureAttribute]
public static K`2<M, A> iff(K`2<M, bool> Pred, K`2<IO, A> Then, K`2<M, A> Else);
    [PureAttribute]
public static K`2<M, A> iff(K`2<M, bool> Pred, K`2<IO, A> Then, K`2<IO, A> Else);
    [PureAttribute]
public static K`2<M, A> iff(K`2<M, bool> Pred, K`2<M, A> Then, Pure`1<A> Else);
    [PureAttribute]
public static K`2<M, A> iff(K`2<M, bool> Pred, Pure`1<A> Then, K`2<M, A> Else);
    [PureAttribute]
public static K`2<M, A> iff(K`2<M, bool> Pred, Pure`1<A> Then, Pure`1<A> Else);
    [PureAttribute]
public static K`2<M, A> iff(K`2<M, bool> Pred, Pure`1<A> Then, K`2<IO, A> Else);
    [PureAttribute]
public static K`2<M, A> iff(K`2<M, bool> Pred, K`2<IO, A> Then, Pure`1<A> Else);
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.Monad`1 {
    public static abstract virtual K`2<M, B> Bind(K`2<M, A> ma, Func`2<A, K`2<M, B>> f);
    public static virtual K`2<M, A> Flatten(K`2<M, K`2<M, A>> mma);
    public static virtual K`2<M, B> Map(Func`2<A, B> f, K`2<M, A> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Traits.MonadIO : object {
    public static K`2<M, A> liftIO(IO`1<A> ma);
    public static K`2<M, A> liftIO(K`2<IO, A> ma);
    public static K`2<M, IO`1<A>> toIO(K`2<M, A> ma);
    public static K`2<M, B> mapIO(Func`2<IO`1<A>, IO`1<B>> f, K`2<M, A> ma);
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.MonadIO`1 {
    public static virtual K`2<M, A> LiftIO(K`2<IO, A> ma);
    public static virtual K`2<M, A> LiftIO(IO`1<A> ma);
    public static virtual K`2<M, IO`1<A>> ToIO(K`2<M, A> ma);
    public static virtual K`2<M, B> MapIO(K`2<M, A> ma, Func`2<IO`1<A>, IO`1<B>> f);
}
public static class LanguageExt.Traits.MonadT : object {
    [NullableContextAttribute("1")]
public static K`2<MTran, A> lift(K`2<M, A> ma);
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.MonadT`2 {
    public static abstract virtual K`2<T, A> Lift(K`2<M, A> ma);
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.Monoid`1 {
    [PureAttribute]
public static A Empty { get; }
    public static abstract virtual A get_Empty();
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.MonoidK`1 {
    [PureAttribute]
public static abstract virtual K`2<M, A> Empty();
}
public static class LanguageExt.Traits.Mutates : object {
    [NullableContextAttribute("1")]
public static K`2<F, A> mutate(Func`2<A, A> f);
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.Mutates`2 {
    public static K`2<M, Atom`1<InnerEnv>> Mutable { get; }
    public static abstract virtual K`2<M, Atom`1<InnerEnv>> get_Mutable();
}
[NullableContextAttribute("1")]
[TraitAttribute("Num*")]
public interface LanguageExt.Traits.Num`1 {
    [PureAttribute]
public static abstract virtual A Abs(A x);
    [PureAttribute]
public static abstract virtual A Signum(A x);
    [PureAttribute]
public static abstract virtual A FromInteger(int x);
    [PureAttribute]
public static abstract virtual A FromDecimal(decimal x);
    [PureAttribute]
public static abstract virtual A FromFloat(float x);
    [PureAttribute]
public static abstract virtual A FromDouble(double x);
    [PureAttribute]
public static abstract virtual A Divide(A x, A y);
}
[NullableContextAttribute("1")]
[TraitAttribute("Opt*")]
public interface LanguageExt.Traits.Optional`2 {
    [PureAttribute]
public static OA None { get; }
    [PureAttribute]
public static abstract virtual bool IsSome(OA opt);
    [PureAttribute]
public static abstract virtual bool IsNone(OA opt);
    [PureAttribute]
public static abstract virtual B Match(OA opt, Func`2<A, B> Some, Func`1<B> None);
    [PureAttribute]
public static abstract virtual B Match(OA opt, Func`2<A, B> Some, B None);
    public static abstract virtual Unit Match(OA opt, Action`1<A> Some, Action None);
    public static abstract virtual OA get_None();
    [PureAttribute]
public static abstract virtual OA Some(A value);
    [PureAttribute]
public static abstract virtual OA MkOptional(A value);
}
[TraitAttribute("Ord*")]
public interface LanguageExt.Traits.Ord`1 {
    [NullableContextAttribute("1")]
[PureAttribute]
public static abstract virtual int Compare(A x, A y);
}
[TraitAttribute("Pred*")]
public interface LanguageExt.Traits.Pred`1 {
    [NullableContextAttribute("1")]
[PureAttribute]
public static abstract virtual bool True(A value);
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.Range.Range`3 {
    public static SELF Zero;
    [PureAttribute]
public A From { get; }
    [PureAttribute]
public A To { get; }
    [PureAttribute]
public A Step { get; }
    [PureAttribute]
public bool StepIsAscending { get; }
    [NullableAttribute("2")]
[PureAttribute]
public object Case { get; }
    private static Range`3();
    public static abstract virtual SELF New(A from, A to, A step);
    public abstract virtual A get_From();
    public abstract virtual A get_To();
    public abstract virtual A get_Step();
    public virtual bool get_StepIsAscending();
    [NullableContextAttribute("2")]
public virtual object get_Case();
    [PureAttribute]
public static SELF FromMinMax(A min, A max, A step);
    [PureAttribute]
public static SELF FromCount(A min, A count, A step);
    [PureAttribute]
public virtual bool InRange(A value);
    [PureAttribute]
public virtual bool Overlaps(SELF other);
    [PureAttribute]
public virtual Seq`1<A> ToSeq();
    [PureAttribute]
public virtual Iterable`1<A> AsIterable();
    [PureAttribute]
private sealed virtual override IEnumerator`1<A> System.Collections.Generic.IEnumerable<A>.GetEnumerator();
    [PureAttribute]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public virtual S Fold(S state, Func`3<S, A, S> f);
    [IteratorStateMachineAttribute("LanguageExt.Traits.Range.Range`3/<<AsIterable>g__Go|17_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<A> <AsIterable>g__Go|17_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Traits.Readable : object {
    public static K`2<M, Env> ask();
    public static K`2<M, A> asks(Func`2<Env, A> f);
    public static K`2<M, A> asksM(Func`2<Env, K`2<M, A>> f);
    public static K`2<M, A> local(Func`2<Env, Env> f, K`2<M, A> ma);
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.Readable`2 {
    public static K`2<M, Env> Ask { get; }
    public static abstract virtual K`2<M, A> Asks(Func`2<Env, A> f);
    public static virtual K`2<M, Env> get_Ask();
    public static abstract virtual K`2<M, A> Local(Func`2<Env, Env> f, K`2<M, A> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Traits.Resolve.EqResolve`1 : object {
    [NullableAttribute("2")]
public static string ResolutionError;
    public static Func`2<A, int> GetHashCodeFunc;
    public static MethodInfo GetHashCodeMethod;
    public static IntPtr GetHashCodeMethodPtr;
    public static Func`3<A, A, bool> EqualsFunc;
    public static MethodInfo EqualsMethod;
    public static IntPtr EqualsMethodPtr;
    public static bool Exists { get; }
    private static EqResolve`1();
    public static int GetHashCode(A value);
    public static bool Equals(A lhs, A rhs);
    public static bool get_Exists();
    private static void MakeDefault();
    private static int DefaultGetHashCode(A value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Traits.Resolve.HashableResolve`1 : object {
    [NullableAttribute("2")]
public static string ResolutionError;
    public static Func`2<A, int> GetHashCodeFunc;
    public static MethodInfo GetHashCodeMethod;
    public static IntPtr GetHashCodeMethodPtr;
    public static bool Exists { get; }
    private static HashableResolve`1();
    public static int GetHashCode(A value);
    public static bool get_Exists();
    private static void MakeDefault();
    private static int DefaultGetHashCode(A value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Traits.Resolve.OrdResolve`1 : object {
    [NullableAttribute("2")]
public static string ResolutionError;
    public static Func`2<A, int> GetHashCodeFunc;
    public static MethodInfo GetHashCodeMethod;
    public static IntPtr GetHashCodeMethodPtr;
    public static Func`3<A, A, bool> EqualsFunc;
    public static MethodInfo EqualsMethod;
    public static IntPtr EqualsMethodPtr;
    public static Func`3<A, A, int> CompareFunc;
    public static MethodInfo CompareMethod;
    public static IntPtr CompareMethodPtr;
    public static bool Exists { get; }
    private static OrdResolve`1();
    public static int GetHashCode(A value);
    public static bool Equals(A lhs, A rhs);
    public static int Compare(A lhs, A rhs);
    public static bool get_Exists();
    private static void MakeComparer(Type source);
    private static void MakeDefault();
    private static void MakeDelegateDefault();
    private static void MakeTraitDefault();
    private static int DefaultGetHashCode(A value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class LanguageExt.Traits.Resolve.Resolver : object {
    public static MethodInfo Method(Type type, string name, Type[] types);
    public static Type Find(Type type, string prefix);
    private static Type MakeGeneric(Type generic, Type concrete);
    [NullableContextAttribute("2")]
private static Type FindType(Assembly asm, string name);
    private static Assembly LoadAssembly(AssemblyName name);
    [IteratorStateMachineAttribute("LanguageExt.Traits.Resolve.Resolver/<GetAssemblies>d__5")]
private static IEnumerable`1<AssemblyName> GetAssemblies();
    public static MethodInfo GetHashCodeMethod(Type type);
    public static MethodInfo GetHashCodeMethodAlways(Type type);
    public static MethodInfo GetEqualsMethod(Type type);
    public static MethodInfo GetEqualsMethodAlways(Type type);
    public static MethodInfo GetCompareMethod(Type type);
    public static MethodInfo GetCompareMethodAlways(Type type);
}
public static class LanguageExt.Traits.SemiAlternative : object {
    [NullableContextAttribute("1")]
public static K`2<F, A> combine(K`2<F, A> ma, K`2<F, A> mb);
}
public interface LanguageExt.Traits.SemiAlternative`1 {
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.Semigroup`1 {
    [PureAttribute]
public abstract virtual A Combine(A rhs);
    public static virtual A op_Addition(A lhs, A rhs);
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.SemigroupK`1 {
    [PureAttribute]
public static abstract virtual K`2<M, A> Combine(K`2<M, A> lhs, K`2<M, A> rhs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Traits.Stateful : object {
    public static K`2<M, Unit> put(S value);
    public static K`2<M, Unit> modify(Func`2<S, S> modify);
    public static K`2<M, Unit> modifyM(Func`2<S, K`2<M, S>> modify);
    public static K`2<M, S> get();
    public static K`2<M, A> gets(Func`2<S, A> f);
    public static K`2<M, A> getsM(Func`2<S, K`2<M, A>> f);
    public static K`2<M, A> state(Func`2<S, ValueTuple`2<A, S>> f);
    public static K`2<M, A> bracket(K`2<M, Unit> stateSetter, K`2<M, A> operation);
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.Stateful`2 {
    public static K`2<M, S> Get { get; }
    public static abstract virtual K`2<M, Unit> Put(S value);
    public static abstract virtual K`2<M, Unit> Modify(Func`2<S, S> modify);
    public static abstract virtual K`2<M, A> Gets(Func`2<S, A> f);
    public static virtual K`2<M, S> get_Get();
}
public interface LanguageExt.Traits.Trait {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Traits.Traversable : object {
    public static K`2<F, K`2<T, B>> traverse(Func`2<A, K`2<F, B>> f, K`2<T, A> ta);
    public static K`2<F, K`2<T, A>> sequence(K`2<T, K`2<F, A>> ta);
    public static K`2<M, K`2<T, B>> traverseM(Func`2<A, K`2<M, B>> f, K`2<T, A> ta);
    public static K`2<M, K`2<T, A>> sequenceM(K`2<T, K`2<M, A>> ta);
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.Traversable`1 {
    public static abstract virtual K`2<F, K`2<T, B>> Traverse(Func`2<A, K`2<F, B>> f, K`2<T, A> ta);
    public static virtual K`2<F, K`2<T, A>> Sequence(K`2<T, K`2<F, A>> ta);
    public static virtual K`2<M, K`2<T, B>> TraverseM(Func`2<A, K`2<M, B>> f, K`2<T, A> ta);
    public static virtual K`2<F, K`2<T, A>> SequenceM(K`2<T, K`2<F, A>> ta);
    public static virtual K`2<F, K`2<T, B>> TraverseDefault(Func`2<A, K`2<F, B>> f, K`2<T, A> ta);
}
public class LanguageExt.Traits.UnliftIO`2 : MulticastDelegate {
    public UnliftIO`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual IO`1<A> Invoke(K`2<M, A> ma);
    public virtual IAsyncResult BeginInvoke(K`2<M, A> ma, AsyncCallback callback, object object);
    public virtual IO`1<A> EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Traits.Writable : object {
    public static K`2<M, Unit> tell(W item);
    public static K`2<M, A> write(ValueTuple`2<A, W> item);
    public static K`2<M, A> write(A value, W item);
    public static K`2<M, A> pass(K`2<M, ValueTuple`2<A, Func`2<W, W>>> action);
    public static K`2<M, ValueTuple`2<A, W>> listen(K`2<M, A> ma);
    public static K`2<M, ValueTuple`2<A, B>> listens(Func`2<W, B> f, K`2<M, A> ma);
    public static K`2<M, A> censor(Func`2<W, W> f, K`2<M, A> ma);
}
[NullableContextAttribute("1")]
public interface LanguageExt.Traits.Writable`2 {
    public static abstract virtual K`2<M, Unit> Tell(W item);
    public static abstract virtual K`2<M, ValueTuple`2<A, W>> Listen(K`2<M, A> ma);
    public static abstract virtual K`2<M, A> Pass(K`2<M, ValueTuple`2<A, Func`2<W, W>>> action);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Trampoline : object {
    public static Trampoline`1<A> Pure(A value);
    public static Trampoline`1<A> More(Func`1<Trampoline`1<A>> value);
    public static Trampoline`1<B> Bind(Trampoline`1<A> ma, Func`2<A, Trampoline`1<B>> f);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.Trampoline`1 : object {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected Trampoline`1(Trampoline`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public A Run();
    public Trampoline`1<B> Bind(Func`2<A, Trampoline`1<B>> f);
    public Trampoline`1<B> Map(Func`2<A, B> f);
    public Trampoline`1<B> Select(Func`2<A, B> f);
    public Trampoline`1<C> SelectMany(Func`2<A, Trampoline`1<B>> bind, Func`3<A, B, C> project);
    protected abstract virtual Either`2<Func`1<Trampoline`1<A>>, A> Resume();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Trampoline`1<A> left, Trampoline`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Trampoline`1<A> left, Trampoline`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Trampoline`1<A> other);
    [CompilerGeneratedAttribute]
public abstract virtual Trampoline`1<A> <Clone>$();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Trampoline`1<A> <Run>b__2_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.TraversableExtensions : object {
    [ExtensionAttribute]
public static K`2<F, K`2<T, B>> Traverse(K`2<T, A> ta, Func`2<A, K`2<F, B>> f);
    [ExtensionAttribute]
public static K`2<F, K`2<T, A>> Sequence(K`2<T, K`2<F, A>> ta);
    [ExtensionAttribute]
public static K`2<M, K`2<T, B>> TraverseM(Func`2<A, K`2<M, B>> f, K`2<T, A> ta);
    [ExtensionAttribute]
public static K`2<F, K`2<T, A>> SequenceM(K`2<T, K`2<F, A>> ta);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class LanguageExt.TrieMap`3 : object {
    public static TrieMap`3<EqK, K, V> Empty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Node<EqK, K, V> Root;
    private int count;
    private int hash;
    internal static TrieMap`3<EqK, K, V> EmptyForMutating { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public V Item { get; }
    public Iterable`1<K> Keys { get; }
    public Iterable`1<V> Values { get; }
    private TrieMap`3(Node<EqK, K, V> root, int count);
    public TrieMap`3(IEnumerable`1<ValueTuple`2<K, V>> items, bool tryAdd);
    public TrieMap`3(ReadOnlySpan`1<ValueTuple`2<K, V>> items, bool tryAdd);
    private static TrieMap`3();
    internal static TrieMap`3<EqK, K, V> get_EmptyForMutating();
    public bool get_IsEmpty();
    public int get_Count();
    public TrieMap`3<EqK, K, V> Add(K key, V value);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, Change`1<V>> AddWithLog(K key, V value);
    public TrieMap`3<EqK, K, V> TryAdd(K key, V value);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, Change`1<V>> TryAddWithLog(K key, V value);
    public TrieMap`3<EqK, K, V> AddOrUpdate(K key, V value);
    internal TrieMap`3<EqK, K, V> AddOrUpdateInPlace(K key, V value);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, Change`1<V>> AddOrUpdateWithLog(K key, V value);
    public TrieMap`3<EqK, K, V> AddOrUpdate(K key, Func`2<V, V> Some, Func`1<V> None);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, Change`1<V>> AddOrUpdateWithLog(K key, Func`2<V, V> Some, Func`1<V> None);
    public TrieMap`3<EqK, K, V> AddOrMaybeUpdate(K key, Func`2<V, V> Some, Func`1<Option`1<V>> None);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, Change`1<V>> AddOrMaybeUpdateWithLog(K key, Func`2<V, V> Some, Func`1<Option`1<V>> None);
    public TrieMap`3<EqK, K, V> AddOrUpdate(K key, Func`2<V, V> Some, V None);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, Change`1<V>> AddOrUpdateWithLog(K key, Func`2<V, V> Some, V None);
    public TrieMap`3<EqK, K, V> AddRange(IEnumerable`1<ValueTuple`2<K, V>> items);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> AddRangeWithLog(IEnumerable`1<ValueTuple`2<K, V>> items);
    public TrieMap`3<EqK, K, V> AddRange(IEnumerable`1<Tuple`2<K, V>> items);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> AddRangeWithLog(IEnumerable`1<Tuple`2<K, V>> items);
    public TrieMap`3<EqK, K, V> AddRange(IEnumerable`1<KeyValuePair`2<K, V>> items);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> AddRangeWithLog(IEnumerable`1<KeyValuePair`2<K, V>> items);
    public TrieMap`3<EqK, K, V> TryAddRange(IEnumerable`1<ValueTuple`2<K, V>> items);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> TryAddRangeWithLog(IEnumerable`1<ValueTuple`2<K, V>> items);
    public TrieMap`3<EqK, K, V> TryAddRange(IEnumerable`1<Tuple`2<K, V>> items);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> TryAddRangeWithLog(IEnumerable`1<Tuple`2<K, V>> items);
    public TrieMap`3<EqK, K, V> TryAddRange(IEnumerable`1<KeyValuePair`2<K, V>> items);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> TryAddRangeWithLog(IEnumerable`1<KeyValuePair`2<K, V>> items);
    public TrieMap`3<EqK, K, V> AddOrUpdateRange(IEnumerable`1<ValueTuple`2<K, V>> items);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> AddOrUpdateRangeWithLog(IEnumerable`1<ValueTuple`2<K, V>> items);
    public TrieMap`3<EqK, K, V> AddOrUpdateRange(IEnumerable`1<Tuple`2<K, V>> items);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> AddOrUpdateRangeWithLog(IEnumerable`1<Tuple`2<K, V>> items);
    public TrieMap`3<EqK, K, V> AddOrUpdateRange(IEnumerable`1<KeyValuePair`2<K, V>> items);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> AddOrUpdateRangeWithLog(IEnumerable`1<KeyValuePair`2<K, V>> items);
    public TrieMap`3<EqK, K, V> SetItems(IEnumerable`1<ValueTuple`2<K, V>> items);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> SetItemsWithLog(IEnumerable`1<ValueTuple`2<K, V>> items);
    public TrieMap`3<EqK, K, V> SetItems(IEnumerable`1<KeyValuePair`2<K, V>> items);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> SetItemsWithLog(IEnumerable`1<KeyValuePair`2<K, V>> items);
    public TrieMap`3<EqK, K, V> SetItems(IEnumerable`1<Tuple`2<K, V>> items);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> SetItemsWithLog(IEnumerable`1<Tuple`2<K, V>> items);
    public TrieMap`3<EqK, K, V> TrySetItems(IEnumerable`1<ValueTuple`2<K, V>> items);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> TrySetItemsWithLog(IEnumerable`1<ValueTuple`2<K, V>> items);
    public TrieMap`3<EqK, K, V> TrySetItems(IEnumerable`1<KeyValuePair`2<K, V>> items);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> TrySetItemsWithLog(IEnumerable`1<KeyValuePair`2<K, V>> items);
    public TrieMap`3<EqK, K, V> TrySetItems(IEnumerable`1<Tuple`2<K, V>> items);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> TrySetItemsWithLog(IEnumerable`1<Tuple`2<K, V>> items);
    public TrieMap`3<EqK, K, V> TrySetItems(IEnumerable`1<K> items, Func`2<V, V> Some);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> TrySetItemsWithLog(IEnumerable`1<K> items, Func`2<V, V> Some);
    public TrieMap`3<EqK, K, V> RemoveRange(IEnumerable`1<K> items);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> RemoveRangeWithLog(IEnumerable`1<K> items);
    public TrieMap`3<EqK, K, V> SetItem(K key, V value);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, Change`1<V>> SetItemWithLog(K key, V value);
    public TrieMap`3<EqK, K, V> SetItem(K key, Func`2<V, V> Some);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, Change`1<V>> SetItemWithLog(K key, Func`2<V, V> Some);
    public TrieMap`3<EqK, K, V> TrySetItem(K key, V value);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, Change`1<V>> TrySetItemWithLog(K key, V value);
    public TrieMap`3<EqK, K, V> TrySetItem(K key, Func`2<V, V> Some);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, Change`1<V>> TrySetItemWithLog(K key, Func`2<V, V> Some);
    public TrieMap`3<EqK, K, V> Remove(K key);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, Change`1<V>> RemoveWithLog(K key);
    public V get_Item(K key);
    public ValueTuple`2<K, V> Get(K key);
    public Option`1<ValueTuple`2<K, V>> GetOption(K key);
    public Option`1<K> GetKeyOption(K key);
    public TrieMap`3<EqK, K, V> Clear();
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> ClearWithLog();
    public virtual int GetHashCode();
    public bool ContainsKey(K key);
    public bool Contains(V value);
    public bool Contains(V value);
    public bool Contains(K key, V value);
    public bool Contains(K key, V Value);
    public Option`1<V> Find(K key);
    private ValueTuple`3<bool, K, V> FindInternal(K key);
    public R Find(K key, Func`2<V, R> Some, Func`1<R> None);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, V> FindOrAdd(K key, Func`1<V> None);
    public ValueTuple`3<TrieMap`3<EqK, K, V>, V, Change`1<V>> FindOrAddWithLog(K key, Func`1<V> None);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, V> FindOrAdd(K key, V value);
    public ValueTuple`3<TrieMap`3<EqK, K, V>, V, Change`1<V>> FindOrAddWithLog(K key, V value);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, Option`1<V>> FindOrMaybeAdd(K key, Func`1<Option`1<V>> None);
    public ValueTuple`3<TrieMap`3<EqK, K, V>, V, Change`1<V>> FindOrMaybeAddWithLog(K key, Func`1<Option`1<V>> None);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, Option`1<V>> FindOrMaybeAdd(K key, Option`1<V> value);
    public ValueTuple`3<TrieMap`3<EqK, K, V>, Option`1<V>, Change`1<V>> FindOrMaybeAddWithLog(K key, Option`1<V> value);
    public Seq`1<V> FindAll(K key);
    internal static TrieMap`3<EqK, K, Change`1<V>> FindChanges(TrieMap`3<EqK, K, V> mx, TrieMap`3<EqK, K, V> my);
    public TrieMap`3<EqK, K, U> Map(Func`2<V, U> f);
    public ValueTuple`2<TrieMap`3<EqK, K, U>, TrieMap`3<EqK, K, Change`1<U>>> MapWithLog(Func`2<V, U> f);
    public TrieMap`3<EqK, K, U> Map(Func`3<K, V, U> f);
    public ValueTuple`2<TrieMap`3<EqK, K, U>, TrieMap`3<EqK, K, Change`1<U>>> MapWithLog(Func`3<K, V, U> f);
    public TrieMap`3<EqK, K, V> Filter(Func`2<V, bool> f);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> FilterWithLog(Func`2<V, bool> f);
    public TrieMap`3<EqK, K, V> Filter(Func`3<K, V, bool> f);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> FilterWithLog(Func`3<K, V, bool> f);
    public TrieMap`3<EqK, K, V> Append(TrieMap`3<EqK, K, V> rhs);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> AppendWithLog(TrieMap`3<EqK, K, V> rhs);
    public TrieMap`3<EqK, K, V> Subtract(TrieMap`3<EqK, K, V> rhs);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> SubtractWithLog(TrieMap`3<EqK, K, V> rhs);
    public static TrieMap`3<EqK, K, V> op_Addition(TrieMap`3<EqK, K, V> lhs, TrieMap`3<EqK, K, V> rhs);
    public static TrieMap`3<EqK, K, V> op_Subtraction(TrieMap`3<EqK, K, V> lhs, TrieMap`3<EqK, K, V> rhs);
    public static bool op_Equality(TrieMap`3<EqK, K, V> lhs, TrieMap`3<EqK, K, V> rhs);
    public static bool op_Inequality(TrieMap`3<EqK, K, V> lhs, TrieMap`3<EqK, K, V> rhs);
    [NullableContextAttribute("2")]
public virtual bool Equals(object rhs);
    public sealed virtual bool Equals(TrieMap`3<EqK, K, V> rhs);
    [NullableContextAttribute("0")]
public bool Equals(TrieMap`3<EqK, K, V> rhs);
    public TrieMap`3<EqK, K, V> Update(K key, V value);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, Change`1<V>> UpdateWithLog(K key, V value);
    private TrieMap`3<EqK, K, V> Update(K key, V value, UpdateType<EqK, K, V> type, bool mutate);
    private ValueTuple`2<TrieMap`3<EqK, K, V>, Change`1<V>> UpdateWithLog(K key, V value, UpdateType<EqK, K, V> type, bool mutate);
    public bool IsProperSubsetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    public bool IsProperSubsetOf(IEnumerable`1<K> other);
    public bool IsProperSupersetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    public bool IsProperSupersetOf(IEnumerable`1<K> other);
    public bool IsSubsetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    public bool IsSubsetOf(IEnumerable`1<K> other);
    public bool IsSubsetOf(TrieMap`3<EqK, K, V> other);
    public bool IsSupersetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    public bool IsSupersetOf(IEnumerable`1<K> other);
    public bool Overlaps(IEnumerable`1<ValueTuple`2<K, V>> other);
    public bool Overlaps(IEnumerable`1<K> other);
    public TrieMap`3<EqK, K, V> Intersect(IEnumerable`1<K> other);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> IntersectWithLog(IEnumerable`1<K> other);
    public TrieMap`3<EqK, K, V> Intersect(IEnumerable`1<ValueTuple`2<K, V>> other);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> IntersectWithLog(IEnumerable`1<ValueTuple`2<K, V>> other);
    public TrieMap`3<EqK, K, V> Intersect(IEnumerable`1<ValueTuple`2<K, V>> other, WhenMatched`4<K, V, V, V> Merge);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> IntersectWithLog(TrieMap`3<EqK, K, V> other, WhenMatched`4<K, V, V, V> Merge);
    public TrieMap`3<EqK, K, V> Except(IEnumerable`1<K> other);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> ExceptWithLog(IEnumerable`1<K> other);
    public TrieMap`3<EqK, K, V> Except(IEnumerable`1<ValueTuple`2<K, V>> other);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> ExceptWithLog(IEnumerable`1<ValueTuple`2<K, V>> other);
    public TrieMap`3<EqK, K, V> SymmetricExcept(TrieMap`3<EqK, K, V> rhs);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> SymmetricExceptWithLog(TrieMap`3<EqK, K, V> rhs);
    public TrieMap`3<EqK, K, V> SymmetricExcept(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> SymmetricExceptWithLog(IEnumerable`1<ValueTuple`2<K, V>> rhs);
    public TrieMap`3<EqK, K, V> Union(IEnumerable`1<ValueTuple`2<K, V>> other);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> UnionWithLog(IEnumerable`1<ValueTuple`2<K, V>> other);
    public TrieMap`3<EqK, K, V> Union(IEnumerable`1<ValueTuple`2<K, V>> other, WhenMatched`4<K, V, V, V> Merge);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> UnionWithLog(IEnumerable`1<ValueTuple`2<K, V>> other, WhenMatched`4<K, V, V, V> Merge);
    public TrieMap`3<EqK, K, V> Union(IEnumerable`1<ValueTuple`2<K, W>> other, WhenMissing`3<K, W, V> MapRight, WhenMatched`4<K, V, W, V> Merge);
    public ValueTuple`2<TrieMap`3<EqK, K, V>, TrieMap`3<EqK, K, Change`1<V>>> UnionWithLog(IEnumerable`1<ValueTuple`2<K, W>> other, WhenMissing`3<K, W, V> MapRight, WhenMatched`4<K, V, W, V> Merge);
    public TrieMap`3<EqK, K, W> Union(IEnumerable`1<ValueTuple`2<K, W>> other, WhenMissing`3<K, V, W> MapLeft, WhenMatched`4<K, V, W, W> Merge);
    public ValueTuple`2<TrieMap`3<EqK, K, W>, TrieMap`3<EqK, K, Change`1<W>>> UnionWithLog(IEnumerable`1<ValueTuple`2<K, W>> other, WhenMissing`3<K, V, W> MapLeft, WhenMatched`4<K, V, W, W> Merge);
    public TrieMap`3<EqK, K, R> Union(IEnumerable`1<ValueTuple`2<K, W>> other, WhenMissing`3<K, V, R> MapLeft, WhenMissing`3<K, W, R> MapRight, WhenMatched`4<K, V, W, R> Merge);
    public ValueTuple`2<TrieMap`3<EqK, K, R>, TrieMap`3<EqK, K, Change`1<R>>> UnionWithLog(IEnumerable`1<ValueTuple`2<K, W>> other, WhenMissing`3<K, V, R> MapLeft, WhenMissing`3<K, W, R> MapRight, WhenMatched`4<K, V, W, R> Merge);
    private static Node<EqK, K, V> Merge(ValueTuple`2<K, V> pair1, ValueTuple`2<K, V> pair2, UInt32 pair1Hash, UInt32 pair2Hash, Sec section);
    public Iterable`1<ValueTuple`2<K, V>> AsIterable();
    public sealed virtual IEnumerator`1<ValueTuple`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static int BitCount(int bits);
    private static int Index(UInt32 bits, int location);
    private static int Index(UInt32 bitmap, UInt32 location);
    private static UInt32 Mask(int index);
    private static ValueTuple`2<A[], A> SetItem(A[] items, int index, A value, bool mutate);
    private static A[] Clone(A[] items, int count);
    private static A[] Clone(A[] items);
    private static A[] Insert(A[] array, int index, A value);
    private static A[] RemoveAt(A[] array, int index);
    public virtual string ToString();
    private string TupleToString(ValueTuple`2<K, V> tuple);
    public Iterable`1<K> get_Keys();
    public Iterable`1<V> get_Values();
    public bool TryGetValue(K key, V& value);
}
[ExtensionAttribute]
internal static class LanguageExt.TrieMapExtentsions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static TrieMap`3<EqK, K, V> Merge(TrieMap`3<EqK, K, V> lhs, TrieMap`3<EqK, K, V> rhs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class LanguageExt.TrieSet`2 : object {
    public static TrieSet`2<EqK, K> Empty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Node<EqK, K> Root;
    private int count;
    private int hash;
    public bool IsEmpty { get; }
    public int Count { get; }
    public K Item { get; }
    private TrieSet`2(Node<EqK, K> root, int count);
    public TrieSet`2(ReadOnlySpan`1<K> items, bool tryAdd);
    public TrieSet`2(IEnumerable`1<K> items, bool tryAdd);
    private static TrieSet`2();
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public TrieSet`2<EqK, K> Add(K key);
    public TrieSet`2<EqK, K> TryAdd(K key);
    public TrieSet`2<EqK, K> AddOrUpdate(K key);
    public TrieSet`2<EqK, K> AddRange(IEnumerable`1<K> items);
    public TrieSet`2<EqK, K> TryAddRange(IEnumerable`1<K> items);
    public TrieSet`2<EqK, K> AddOrUpdateRange(IEnumerable`1<K> items);
    public TrieSet`2<EqK, K> SetItems(IEnumerable`1<K> items);
    public TrieSet`2<EqK, K> TrySetItems(IEnumerable`1<K> items);
    public TrieSet`2<EqK, K> RemoveRange(IEnumerable`1<K> items);
    public TrieSet`2<EqK, K> SetItem(K key);
    public TrieSet`2<EqK, K> TrySetItem(K key);
    public TrieSet`2<EqK, K> Update(K key);
    public TrieSet`2<EqK, K> Remove(K key);
    public K get_Item(K key);
    public TrieSet`2<EqK, K> Clear();
    public virtual int GetHashCode();
    public bool ContainsKey(K key);
    public Option`1<K> Find(K key);
    private ValueTuple`2<bool, K> FindInternal(K key);
    public TrieSet`2<EqU, U> Map(Func`2<K, U> f);
    public TrieSet`2<EqK, K> Map(Func`2<K, K> f);
    public TrieSet`2<EqK, K> Filter(Func`2<K, bool> f);
    public TrieSet`2<EqK, K> Append(TrieSet`2<EqK, K> rhs);
    public TrieSet`2<EqK, K> Subtract(TrieSet`2<EqK, K> rhs);
    public static TrieSet`2<EqK, K> op_Addition(TrieSet`2<EqK, K> lhs, TrieSet`2<EqK, K> rhs);
    public static TrieSet`2<EqK, K> op_Subtraction(TrieSet`2<EqK, K> lhs, TrieSet`2<EqK, K> rhs);
    public static bool op_Equality(TrieSet`2<EqK, K> lhs, TrieSet`2<EqK, K> rhs);
    public static bool op_Inequality(TrieSet`2<EqK, K> lhs, TrieSet`2<EqK, K> rhs);
    [NullableContextAttribute("2")]
public virtual bool Equals(object rhs);
    public sealed virtual bool Equals(TrieSet`2<EqK, K> rhs);
    private TrieSet`2<EqK, K> Update(K key, UpdateType<EqK, K> type, bool mutate);
    public bool IsProperSubsetOf(IEnumerable`1<K> other);
    public bool IsProperSupersetOf(IEnumerable`1<K> other);
    public bool IsSubsetOf(IEnumerable`1<K> other);
    public bool IsSubsetOf(TrieSet`2<EqK, K> other);
    public bool IsSupersetOf(IEnumerable`1<K> other);
    public bool Overlaps(IEnumerable`1<K> other);
    public TrieSet`2<EqK, K> Intersect(IEnumerable`1<K> other);
    public TrieSet`2<EqK, K> Except(IEnumerable`1<K> other);
    public TrieSet`2<EqK, K> SymmetricExcept(IEnumerable`1<K> rhs);
    public TrieSet`2<EqK, K> SymmetricExcept(TrieSet`2<EqK, K> rhs);
    public TrieSet`2<EqK, K> Union(IEnumerable`1<K> other);
    private static Node<EqK, K> Merge(K key1, K key2, UInt32 pair1Hash, UInt32 pair2Hash, Sec section);
    public Iterable`1<K> AsEnumerable();
    public IEnumerator`1<K> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static int BitCount(int bits);
    private static int Index(UInt32 bits, int location);
    private static int Index(UInt32 bitmap, UInt32 location);
    private static UInt32 Mask(int index);
    private static A[] SetItem(A[] items, int index, A value, bool mutate);
    private static A[] Clone(A[] items, int count);
    private static A[] Clone(A[] items);
    private static A[] Insert(A[] array, int index, A value);
    private static A[] RemoveAt(A[] array, int index);
    public virtual string ToString();
    public bool TryGetValue(K key, K& value);
    private sealed virtual override IEnumerator`1<K> System.Collections.Generic.IEnumerable<K>.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Try : object {
    public static Try`1<A> Succ(A value);
    public static Try`1<A> Fail(Error value);
    public static Try`1<A> lift(Func`1<Fin`1<A>> ma);
    public static Try`1<A> lift(Fin`1<A> ma);
    public static Try`1<A> lift(Pure`1<A> ma);
    public static Try`1<A> lift(Fail`1<Error> ma);
    public static Try`1<A> lift(Error ma);
    public static Try`1<A> lift(Func`1<A> f);
    public static Try`1<B> bind(Try`1<A> ma, Func`2<A, Try`1<B>> f);
    public static Try`1<B> map(Func`2<A, B> f, Try`1<A> ma);
    public static Try`1<B> apply(Try`1<Func`2<A, B>> mf, Try`1<A> ma);
    public static Try`1<B> action(Try`1<A> ma, Try`1<B> mb);
    public static Fin`1<B> match(Try`1<A> ma, Func`2<A, B> Succ, Func`2<Error, B> Fail);
    private static override K`2<Try, B> LanguageExt.Traits.Monad<LanguageExt.Try>.Bind(K`2<Try, A> ma, Func`2<A, K`2<Try, B>> f);
    private static override K`2<Try, B> LanguageExt.Traits.Functor<LanguageExt.Try>.Map(Func`2<A, B> f, K`2<Try, A> ma);
    private static override K`2<Try, A> LanguageExt.Traits.Applicative<LanguageExt.Try>.Pure(A value);
    private static override K`2<Try, B> LanguageExt.Traits.Applicative<LanguageExt.Try>.Apply(K`2<Try, Func`2<A, B>> mf, K`2<Try, A> ma);
    private static override K`2<Try, B> LanguageExt.Traits.Applicative<LanguageExt.Try>.Action(K`2<Try, A> ma, K`2<Try, B> mb);
    private static override K`2<Try, A> LanguageExt.Traits.SemigroupK<LanguageExt.Try>.Combine(K`2<Try, A> ma, K`2<Try, A> mb);
    private static override K`2<Try, A> LanguageExt.Traits.Fallible<LanguageExt.Common.Error,LanguageExt.Try>.Fail(Error value);
    private static override K`2<Try, A> LanguageExt.Traits.Fallible<LanguageExt.Common.Error,LanguageExt.Try>.Catch(K`2<Try, A> fa, Func`2<Error, bool> Predicate, Func`2<Error, K`2<Try, A>> Fail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Try`1 : object {
    [CompilerGeneratedAttribute]
private Func`1<Fin`1<A>> <runTry>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public Func`1<Fin`1<A>> runTry { get; public set; }
    public Try`1(Func`1<Fin`1<A>> runTry);
    [CompilerGeneratedAttribute]
protected Try`1(Try`1<A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Func`1<Fin`1<A>> get_runTry();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_runTry(Func`1<Fin`1<A>> value);
    public static Try`1<A> Succ(A value);
    public static Try`1<A> Fail(Error value);
    public static Try`1<A> Lift(Pure`1<A> pure);
    public static Try`1<A> Lift(Fin`1<A> result);
    public static Try`1<A> Lift(Func`1<Fin`1<A>> result);
    public static Try`1<A> Lift(Func`1<A> result);
    public static Try`1<A> Lift(Fail`1<Error> fail);
    public B Match(Func`2<A, B> Succ, Func`2<Error, B> Fail);
    public A IfFail(Func`2<Error, A> Fail);
    public Fin`1<A> IfFailM(Func`2<Error, Fin`1<A>> Fail);
    public Try`1<B> Map(Func`2<A, B> f);
    public Try`1<B> Select(Func`2<A, B> f);
    public Try`1<B> Bind(Func`2<A, K`2<Try, B>> f);
    public Try`1<B> Bind(Func`2<A, Try`1<B>> f);
    public Try`1<B> Bind(Func`2<A, Pure`1<B>> f);
    public Try`1<B> BiBind(Func`2<A, Try`1<B>> Succ, Func`2<Error, Try`1<B>> Fail);
    public Try`1<A> BindFail(Func`2<Error, Try`1<A>> Fail);
    public Try`1<C> SelectMany(Func`2<A, K`2<Try, B>> bind, Func`3<A, B, C> project);
    public Try`1<C> SelectMany(Func`2<A, Try`1<B>> bind, Func`3<A, B, C> project);
    public Try`1<C> SelectMany(Func`2<A, Fin`1<B>> bind, Func`3<A, B, C> project);
    public Try`1<C> SelectMany(Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    public static override Try`1<A> op_Implicit(Pure`1<A> ma);
    public static Try`1<A> op_Implicit(Error ma);
    public static override Try`1<A> op_Implicit(Fail`1<Error> ma);
    public static Try`1<A> op_Implicit(Fail`1<Exception> ma);
    public static override Try`1<A> op_BitwiseOr(Try`1<A> lhs, Try`1<A> rhs);
    public static override Try`1<A> op_BitwiseOr(Try`1<A> lhs, K`2<Try, A> rhs);
    public static override Try`1<A> op_BitwiseOr(K`2<Try, A> lhs, Try`1<A> rhs);
    public static override Try`1<A> op_BitwiseOr(Try`1<A> ma, Pure`1<A> mb);
    public static override Try`1<A> op_BitwiseOr(Try`1<A> ma, Fail`1<Error> mb);
    public static Try`1<A> op_BitwiseOr(Try`1<A> ma, Fail`1<Exception> mb);
    public static Try`1<A> op_BitwiseOr(Try`1<A> ma, Exception mb);
    public static override Try`1<A> op_BitwiseOr(Try`1<A> ma, CatchM`3<Error, Try, A> mb);
    [PureAttribute]
public Try`1<A> Combine(Try`1<A> rhs);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Try`1<A> left, Try`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Try`1<A> left, Try`1<A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Try`1<A> other);
    [CompilerGeneratedAttribute]
public virtual Try`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`1& runTry);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.TryExt : object {
    [ExtensionAttribute]
public static Try`1<A> As(K`2<Try, A> ma);
    [ExtensionAttribute]
public static Fin`1<A> Run(K`2<Try, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Try`1<A> Flatten(K`2<Try, Try`1<A>> mma);
    [ExtensionAttribute]
[PureAttribute]
public static Try`1<A> Flatten(K`2<Try, K`2<Try, A>> mma);
    [ExtensionAttribute]
[PureAttribute]
public static Try`1<B> Apply(Try`1<Func`2<A, B>> mf, Try`1<A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Try`1<B> Action(Try`1<A> ma, Try`1<B> mb);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.TryT : object {
    public static TryT`2<M, B> bind(TryT`2<M, A> ma, Func`2<A, TryT`2<M, B>> f);
    public static TryT`2<M, B> map(Func`2<A, B> f, TryT`2<M, A> ma);
    public static TryT`2<M, A> Succ(A value);
    public static TryT`2<M, A> Fail(Error value);
    public static TryT`2<M, B> apply(TryT`2<M, Func`2<A, B>> mf, TryT`2<M, A> ma);
    public static TryT`2<M, B> action(TryT`2<M, A> ma, TryT`2<M, B> mb);
    public static TryT`2<M, A> lift(Func`1<Fin`1<A>> ma);
    public static TryT`2<M, A> lift(Fin`1<A> ma);
    public static TryT`2<M, A> lift(K`2<M, A> ma);
    public static TryT`2<M, A> lift(Pure`1<A> ma);
    public static TryT`2<M, A> lift(Fail`1<Error> ma);
    public static TryT`2<M, A> lift(Error ma);
    public static TryT`2<M, A> liftIO(IO`1<A> ma);
    public static K`2<M, B> match(TryT`2<M, A> ma, Func`2<A, B> Succ, Func`2<Error, B> Fail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.TryT`1 : object {
    public static TryT`2<M, A> Succ(A value);
    public static TryT`2<M, A> Fail(Error value);
    public static TryT`2<M, A> lift(Func`1<Fin`1<A>> ma);
    public static TryT`2<M, A> lift(Fin`1<A> ma);
    public static TryT`2<M, A> lift(Pure`1<A> ma);
    public static TryT`2<M, A> lift(Fail`1<Error> ma);
    public static TryT`2<M, A> lift(Error ma);
    public static TryT`2<M, A> liftIO(IO`1<A> ma);
    private static override K`2<TryT`1<M>, B> LanguageExt.Traits.Monad<LanguageExt.TryT<M>>.Bind(K`2<TryT`1<M>, A> ma, Func`2<A, K`2<TryT`1<M>, B>> f);
    private static override K`2<TryT`1<M>, B> LanguageExt.Traits.Functor<LanguageExt.TryT<M>>.Map(Func`2<A, B> f, K`2<TryT`1<M>, A> ma);
    private static override K`2<TryT`1<M>, A> LanguageExt.Traits.Applicative<LanguageExt.TryT<M>>.Pure(A value);
    private static override K`2<TryT`1<M>, B> LanguageExt.Traits.Applicative<LanguageExt.TryT<M>>.Apply(K`2<TryT`1<M>, Func`2<A, B>> mf, K`2<TryT`1<M>, A> ma);
    private static override K`2<TryT`1<M>, B> LanguageExt.Traits.Applicative<LanguageExt.TryT<M>>.Action(K`2<TryT`1<M>, A> ma, K`2<TryT`1<M>, B> mb);
    private static override K`2<TryT`1<M>, A> LanguageExt.Traits.MonadT<LanguageExt.TryT<M>,M>.Lift(K`2<M, A> ma);
    private static override K`2<TryT`1<M>, A> LanguageExt.Traits.MonadIO<LanguageExt.TryT<M>>.LiftIO(IO`1<A> ma);
    private static override K`2<TryT`1<M>, A> LanguageExt.Traits.SemigroupK<LanguageExt.TryT<M>>.Combine(K`2<TryT`1<M>, A> ma, K`2<TryT`1<M>, A> mb);
    private static override K`2<TryT`1<M>, A> LanguageExt.Traits.Fallible<LanguageExt.Common.Error,LanguageExt.TryT<M>>.Fail(Error error);
    private static override K`2<TryT`1<M>, A> LanguageExt.Traits.Fallible<LanguageExt.Common.Error,LanguageExt.TryT<M>>.Catch(K`2<TryT`1<M>, A> fa, Func`2<Error, bool> Predicate, Func`2<Error, K`2<TryT`1<M>, A>> Fail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.TryT`2 : object {
    [CompilerGeneratedAttribute]
private K`2<M, Try`1<A>> <runTry>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public K`2<M, Try`1<A>> runTry { get; public set; }
    public TryT`2(K`2<M, Try`1<A>> runTry);
    [CompilerGeneratedAttribute]
protected TryT`2(TryT`2<M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public K`2<M, Try`1<A>> get_runTry();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_runTry(K`2<M, Try`1<A>> value);
    public static TryT`2<M, A> Succ(A value);
    public static TryT`2<M, A> Fail(Error value);
    public static TryT`2<M, A> Lift(Pure`1<A> pure);
    public static TryT`2<M, A> Lift(Fin`1<A> result);
    public static TryT`2<M, A> Lift(Func`1<Fin`1<A>> result);
    public static TryT`2<M, A> Lift(Fail`1<Error> fail);
    public static TryT`2<M, A> Lift(K`2<M, A> monad);
    public static TryT`2<M, A> LiftIO(IO`1<A> monad);
    public K`2<M, B> Match(Func`2<A, B> Succ, Func`2<Error, B> Fail);
    public K`2<M, A> IfFail(Func`2<Error, A> Fail);
    public K`2<M, A> IfFailM(Func`2<Error, K`2<M, A>> Fail);
    public TryT`2<M1, B> MapT(Func`2<K`2<M, Fin`1<A>>, K`2<M1, Fin`1<B>>> f);
    public TryT`2<M, B> Map(Func`2<A, B> f);
    public TryT`2<M, B> Select(Func`2<A, B> f);
    public TryT`2<M, B> Bind(Func`2<A, K`2<TryT`1<M>, B>> f);
    public TryT`2<M, B> Bind(Func`2<A, TryT`2<M, B>> f);
    public TryT`2<M, B> BiBind(Func`2<A, TryT`2<M, B>> Succ, Func`2<Error, TryT`2<M, B>> Fail);
    public TryT`2<M, A> BindFail(Func`2<Error, TryT`2<M, A>> Fail);
    public TryT`2<M, B> Bind(Func`2<A, IO`1<B>> f);
    public TryT`2<M, B> Bind(Func`2<A, Pure`1<B>> f);
    public TryT`2<M, C> SelectMany(Func`2<A, K`2<TryT`1<M>, B>> bind, Func`3<A, B, C> project);
    public TryT`2<M, C> SelectMany(Func`2<A, TryT`2<M, B>> bind, Func`3<A, B, C> project);
    public TryT`2<M, C> SelectMany(Func`2<A, K`2<M, B>> bind, Func`3<A, B, C> project);
    public TryT`2<M, C> SelectMany(Func`2<A, Fin`1<B>> bind, Func`3<A, B, C> project);
    public TryT`2<M, C> SelectMany(Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    public TryT`2<M, C> SelectMany(Func`2<A, IO`1<B>> bind, Func`3<A, B, C> project);
    public static TryT`2<M, A> op_RightShift(TryT`2<M, A> lhs, TryT`2<M, A> rhs);
    public static TryT`2<M, A> op_RightShift(TryT`2<M, A> lhs, K`2<TryT`1<M>, A> rhs);
    public static TryT`2<M, A> op_RightShift(TryT`2<M, A> lhs, TryT`2<M, Unit> rhs);
    public static TryT`2<M, A> op_RightShift(TryT`2<M, A> lhs, K`2<TryT`1<M>, Unit> rhs);
    public static override TryT`2<M, A> op_Implicit(Pure`1<A> ma);
    public static TryT`2<M, A> op_Implicit(Error ma);
    public static override TryT`2<M, A> op_Implicit(Fail`1<Error> ma);
    public static TryT`2<M, A> op_Implicit(Fail`1<Exception> ma);
    public static TryT`2<M, A> op_Implicit(IO`1<A> ma);
    public static override TryT`2<M, A> op_BitwiseOr(TryT`2<M, A> lhs, TryT`2<M, A> rhs);
    public static override TryT`2<M, A> op_BitwiseOr(K`2<TryT`1<M>, A> lhs, TryT`2<M, A> rhs);
    public static override TryT`2<M, A> op_BitwiseOr(TryT`2<M, A> lhs, K`2<TryT`1<M>, A> rhs);
    public static override TryT`2<M, A> op_BitwiseOr(TryT`2<M, A> ma, Pure`1<A> mb);
    public static override TryT`2<M, A> op_BitwiseOr(TryT`2<M, A> ma, Fail`1<Error> mb);
    public static TryT`2<M, A> op_BitwiseOr(TryT`2<M, A> ma, Fail`1<Exception> mb);
    public static override TryT`2<M, A> op_BitwiseOr(TryT`2<M, A> ma, CatchM`3<Error, TryT`1<M>, A> mb);
    public TryT`2<M, A> Combine(TryT`2<M, A> rhs);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TryT`2<M, A> left, TryT`2<M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TryT`2<M, A> left, TryT`2<M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(TryT`2<M, A> other);
    [CompilerGeneratedAttribute]
public virtual TryT`2<M, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(K`2& runTry);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.TryTExt : object {
    [ExtensionAttribute]
public static TryT`2<M, A> As(K`2<TryT`1<M>, A> ma);
    [ExtensionAttribute]
public static K`2<M, Fin`1<A>> Run(K`2<TryT`1<M>, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static TryT`2<M, A> Flatten(K`2<TryT`1<M>, TryT`2<M, A>> mma);
    [ExtensionAttribute]
[PureAttribute]
public static TryT`2<M, A> Flatten(K`2<TryT`1<M>, K`2<TryT`1<M>, A>> mma);
    [ExtensionAttribute]
[PureAttribute]
public static TryT`2<M, C> SelectMany(K`2<M, A> ma, Func`2<A, K`2<TryT`1<M>, B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
[PureAttribute]
public static TryT`2<M, C> SelectMany(K`2<M, A> ma, Func`2<A, TryT`2<M, B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
[PureAttribute]
public static TryT`2<M, B> Apply(TryT`2<M, Func`2<A, B>> mf, TryT`2<M, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static TryT`2<M, B> Action(TryT`2<M, A> ma, TryT`2<M, B> mb);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.TypeInfoAllMemberExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<ConstructorInfo> GetAllConstructors(TypeInfo typeInfo, bool includeBase);
    [ExtensionAttribute]
public static IEnumerable`1<EventInfo> GetAllEvents(TypeInfo typeInfo, bool includeBase);
    [ExtensionAttribute]
public static IEnumerable`1<FieldInfo> GetAllFields(TypeInfo typeInfo, bool includeBase);
    [ExtensionAttribute]
public static IEnumerable`1<MemberInfo> GetAllMembers(TypeInfo typeInfo, bool includeBase);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetAllMethods(TypeInfo typeInfo, bool includeBase);
    [ExtensionAttribute]
public static IEnumerable`1<TypeInfo> GetAllNestedTypes(TypeInfo typeInfo, bool includeBase);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetAllProperties(TypeInfo typeInfo, bool includeBase);
    [IteratorStateMachineAttribute("LanguageExt.TypeInfoAllMemberExtensions/<GetAll>d__7`1")]
private static IEnumerable`1<T> GetAll(TypeInfo typeInfo, Func`2<TypeInfo, IEnumerable`1<T>> accessor, bool includeBase);
}
[IsReadOnlyAttribute]
public class LanguageExt.Unit : ValueType {
    public static Unit Default;
    private static Unit();
    [PureAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("1")]
[PureAttribute]
public virtual string ToString();
    [PureAttribute]
public sealed virtual bool Equals(Unit other);
    [PureAttribute]
public static bool op_Equality(Unit lhs, Unit rhs);
    [PureAttribute]
public static bool op_Inequality(Unit lhs, Unit rhs);
    [PureAttribute]
public static bool op_GreaterThan(Unit lhs, Unit rhs);
    [PureAttribute]
public static bool op_GreaterThanOrEqual(Unit lhs, Unit rhs);
    [PureAttribute]
public static bool op_LessThan(Unit lhs, Unit rhs);
    [PureAttribute]
public static bool op_LessThanOrEqual(Unit lhs, Unit rhs);
    [NullableContextAttribute("1")]
[PureAttribute]
public T Return(T anything);
    [NullableContextAttribute("1")]
[PureAttribute]
public T Return(Func`1<T> anything);
    [PureAttribute]
public sealed virtual int CompareTo(Unit other);
    [PureAttribute]
public static Unit op_Addition(Unit a, Unit b);
    [PureAttribute]
public static ValueTuple op_Implicit(Unit _);
    [PureAttribute]
public static Unit op_Implicit(ValueTuple _);
    [PureAttribute]
public static Unit op_Implicit(Seq`1<Unit> _);
    [PureAttribute]
public static Unit op_Implicit(Lst`1<Unit> _);
    [NullableContextAttribute("1")]
[PureAttribute]
public static Unit op_Implicit(Iterable`1<Unit> _);
}
[ExtensionAttribute]
public static class LanguageExt.UnitsAccelExtensions : object {
    [ExtensionAttribute]
public static Accel MetresPerSecond2(int self);
    [ExtensionAttribute]
public static Accel MetresPerSecond2(float self);
    [ExtensionAttribute]
public static Accel MetresPerSecond2(double self);
}
[ExtensionAttribute]
public static class LanguageExt.UnitsAreaExtensions : object {
    [ExtensionAttribute]
public static Area SqKilometres(int self);
    [ExtensionAttribute]
public static Area SqKilometres(float self);
    [ExtensionAttribute]
public static Area SqKilometres(double self);
    [ExtensionAttribute]
public static Area SqMetres(int self);
    [ExtensionAttribute]
public static Area SqMetres(float self);
    [ExtensionAttribute]
public static Area SqMetres(double self);
    [ExtensionAttribute]
public static Area SqCentimetres(int self);
    [ExtensionAttribute]
public static Area SqCentimetres(float self);
    [ExtensionAttribute]
public static Area SqCentimetres(double self);
    [ExtensionAttribute]
public static Area SqMillimetres(int self);
    [ExtensionAttribute]
public static Area SqMillimetres(float self);
    [ExtensionAttribute]
public static Area SqMillimetres(double self);
}
[ExtensionAttribute]
public static class LanguageExt.UnitsLengthExtensions : object {
    [ExtensionAttribute]
public static Length Miles(int self);
    [ExtensionAttribute]
public static Length Miles(float self);
    [ExtensionAttribute]
public static Length Miles(double self);
    [ExtensionAttribute]
public static Length NauticalMiles(int self);
    [ExtensionAttribute]
public static Length NauticalMiles(float self);
    [ExtensionAttribute]
public static Length NauticalMiles(double self);
    [ExtensionAttribute]
public static Length Yards(int self);
    [ExtensionAttribute]
public static Length Yards(float self);
    [ExtensionAttribute]
public static Length Yards(double self);
    [ExtensionAttribute]
public static Length Feet(int self);
    [ExtensionAttribute]
public static Length Feet(float self);
    [ExtensionAttribute]
public static Length Feet(double self);
    [ExtensionAttribute]
public static Length Inches(int self);
    [ExtensionAttribute]
public static Length Inches(float self);
    [ExtensionAttribute]
public static Length Inches(double self);
    [ExtensionAttribute]
public static Length Kilometres(int self);
    [ExtensionAttribute]
public static Length Kilometres(float self);
    [ExtensionAttribute]
public static Length Kilometres(double self);
    [ExtensionAttribute]
public static Length Metres(int self);
    [ExtensionAttribute]
public static Length Metres(float self);
    [ExtensionAttribute]
public static Length Metres(double self);
    [ExtensionAttribute]
public static Length Centimetres(int self);
    [ExtensionAttribute]
public static Length Centimetres(float self);
    [ExtensionAttribute]
public static Length Centimetres(double self);
    [ExtensionAttribute]
public static Length Millimetres(int self);
    [ExtensionAttribute]
public static Length Millimetres(float self);
    [ExtensionAttribute]
public static Length Millimetres(double self);
    [ExtensionAttribute]
public static Length Micrometres(int self);
    [ExtensionAttribute]
public static Length Micrometres(float self);
    [ExtensionAttribute]
public static Length Micrometres(double self);
    [ExtensionAttribute]
public static Length Nanometres(int self);
    [ExtensionAttribute]
public static Length Nanometres(float self);
    [ExtensionAttribute]
public static Length Nanometres(double self);
    [ExtensionAttribute]
public static Length Angstroms(int self);
    [ExtensionAttribute]
public static Length Angstroms(float self);
    [ExtensionAttribute]
public static Length Angstroms(double self);
}
[ExtensionAttribute]
public static class LanguageExt.UnitsMassExtensions : object {
    [ExtensionAttribute]
public static Mass Grams(int self);
    [ExtensionAttribute]
public static Mass Grams(double self);
    [ExtensionAttribute]
public static Mass Grams(float self);
    [ExtensionAttribute]
public static Mass Kilograms(int self);
    [ExtensionAttribute]
public static Mass Kilograms(double self);
    [ExtensionAttribute]
public static Mass Kilograms(float self);
    [ExtensionAttribute]
public static Mass Tonnes(int self);
    [ExtensionAttribute]
public static Mass Tonnes(double self);
    [ExtensionAttribute]
public static Mass Tonnes(float self);
    [ExtensionAttribute]
public static Mass Ounces(int self);
    [ExtensionAttribute]
public static Mass Ounces(double self);
    [ExtensionAttribute]
public static Mass Ounces(float self);
    [ExtensionAttribute]
public static Mass Pounds(int self);
    [ExtensionAttribute]
public static Mass Pounds(double self);
    [ExtensionAttribute]
public static Mass Pounds(float self);
    [ExtensionAttribute]
public static Mass Stones(int self);
    [ExtensionAttribute]
public static Mass Stones(double self);
    [ExtensionAttribute]
public static Mass Stones(float self);
    [ExtensionAttribute]
public static Mass ImperialTons(int self);
    [ExtensionAttribute]
public static Mass ImperialTons(double self);
    [ExtensionAttribute]
public static Mass ImperialTons(float self);
    [ExtensionAttribute]
public static Mass ShortTon(int self);
    [ExtensionAttribute]
public static Mass ShortTon(double self);
    [ExtensionAttribute]
public static Mass ShortTon(float self);
}
public class LanguageExt.UnitsOfMeasure : object {
    public static Length mm;
    public static Length millimetre;
    public static Length millimetres;
    public static Length millimeter;
    public static Length millimeters;
    public static Length cm;
    public static Length centimetre;
    public static Length centimetres;
    public static Length centimeter;
    public static Length centimeters;
    public static Length m;
    public static Length metre;
    public static Length metres;
    public static Length meter;
    public static Length meters;
    public static Length km;
    public static Length kilometre;
    public static Length kilometres;
    public static Length kilometer;
    public static Length kilometers;
    public static Length inch;
    public static Length inches;
    public static Length ft;
    public static Length foot;
    public static Length feet;
    public static Length yd;
    public static Length yard;
    public static Length yards;
    public static Length mile;
    public static Length miles;
    public static Length nauticalMile;
    public static Area mm2;
    public static Area millimetre2;
    public static Area millimeter2;
    public static Area cm2;
    public static Area centimetre2;
    public static Area centimeter2;
    public static Area m2;
    public static Area metre2;
    public static Area meter2;
    public static Area km2;
    public static Area kilometre2;
    public static Area kilometer2;
    public static Time s;
    public static Time sec;
    public static Time second;
    public static Time seconds;
    public static Time min;
    public static Time mins;
    public static Time minute;
    public static Time minutes;
    public static Time hr;
    public static Time hrs;
    public static Time hour;
    public static Time hours;
    public static Time day;
    public static Time days;
    public static Time ms;
    public static Time millisecond;
    public static Time milliseconds;
    public static Velocity mph;
    public static Velocity kph;
    public static Accel ms2;
    public static Temperature degC;
    public static Temperature degF;
    public static Temperature K;
    public static Mass g;
    public static Mass gram;
    public static Mass kg;
    public static Mass kilogram;
    public static Mass tonne;
    public static Mass oz;
    public static Mass ounce;
    public static Mass lb;
    public static Mass pound;
    public static Mass st;
    public static Mass stone;
    public static Mass ton;
    public static Mass shortTon;
    private static UnitsOfMeasure();
}
[ExtensionAttribute]
public static class LanguageExt.UnitsTimeExtensions : object {
    [ExtensionAttribute]
public static Time Milliseconds(int self);
    [ExtensionAttribute]
public static Time Milliseconds(float self);
    [ExtensionAttribute]
public static Time Milliseconds(double self);
    [ExtensionAttribute]
public static Time Seconds(int self);
    [ExtensionAttribute]
public static Time Seconds(float self);
    [ExtensionAttribute]
public static Time Seconds(double self);
    [ExtensionAttribute]
public static Time Minutes(int self);
    [ExtensionAttribute]
public static Time Minutes(float self);
    [ExtensionAttribute]
public static Time Minutes(double self);
    [ExtensionAttribute]
public static Time Hours(int self);
    [ExtensionAttribute]
public static Time Hours(float self);
    [ExtensionAttribute]
public static Time Hours(double self);
    [ExtensionAttribute]
public static Time Days(int self);
    [ExtensionAttribute]
public static Time Days(float self);
    [ExtensionAttribute]
public static Time Days(double self);
}
[ExtensionAttribute]
public static class LanguageExt.UnitsVelocityExtensions : object {
    [ExtensionAttribute]
public static Velocity MetresPerSecond(int self);
    [ExtensionAttribute]
public static Velocity MetresPerSecond(float self);
    [ExtensionAttribute]
public static Velocity MetresPerSecond(double self);
    [ExtensionAttribute]
public static Velocity KilometresPerSecond(int self);
    [ExtensionAttribute]
public static Velocity KilometresPerSecond(float self);
    [ExtensionAttribute]
public static Velocity KilometresPerSecond(double self);
    [ExtensionAttribute]
public static Velocity KilometresPerHour(int self);
    [ExtensionAttribute]
public static Velocity KilometresPerHour(float self);
    [ExtensionAttribute]
public static Velocity KilometresPerHour(double self);
    [ExtensionAttribute]
public static Velocity MilesPerSecond(int self);
    [ExtensionAttribute]
public static Velocity MilesPerSecond(float self);
    [ExtensionAttribute]
public static Velocity MilesPerSecond(double self);
    [ExtensionAttribute]
public static Velocity MilesPerHour(int self);
    [ExtensionAttribute]
public static Velocity MilesPerHour(float self);
    [ExtensionAttribute]
public static Velocity MilesPerHour(double self);
    [ExtensionAttribute]
public static Velocity Knots(int self);
    [ExtensionAttribute]
public static Velocity Knots(float self);
    [ExtensionAttribute]
public static Velocity Knots(double self);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.UnsafeValueAccess.UnsafeValueAccessExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static A ValueUnsafe(Option`1<A> option);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static A Value(Option`1<A> option);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static R Value(Either`2<L, R> either);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static R ValueUnsafe(Either`2<L, R> either);
    [ExtensionAttribute]
public static Seq`1<A> ToSeqUnsafe(A[] value);
    [ExtensionAttribute]
public static Seq`1<A> ToSeqUnsafe(A[] value, int length);
    [ExtensionAttribute]
public static SeqLoan`1<A> ToSeqLoanUnsafe(A[] value, ArrayPool`1<A> pool);
    [ExtensionAttribute]
public static SeqLoan`1<A> ToSeqLoanUnsafe(A[] value, int length, ArrayPool`1<A> pool);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.Validation : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Validation`1 : object {
    private static override K`2<Validation`1<FAIL>, B> LanguageExt.Traits.Monad<LanguageExt.Validation<FAIL>>.Bind(K`2<Validation`1<FAIL>, A> ma, Func`2<A, K`2<Validation`1<FAIL>, B>> f);
    private static override K`2<Validation`1<FAIL>, B> LanguageExt.Traits.Functor<LanguageExt.Validation<FAIL>>.Map(Func`2<A, B> f, K`2<Validation`1<FAIL>, A> ma);
    private static override K`2<Validation`1<FAIL>, A> LanguageExt.Traits.Applicative<LanguageExt.Validation<FAIL>>.Pure(A value);
    private static override K`2<Validation`1<FAIL>, B> LanguageExt.Traits.Applicative<LanguageExt.Validation<FAIL>>.Apply(K`2<Validation`1<FAIL>, Func`2<A, B>> mf, K`2<Validation`1<FAIL>, A> ma);
    private static override K`2<Validation`1<FAIL>, B> LanguageExt.Traits.Applicative<LanguageExt.Validation<FAIL>>.Action(K`2<Validation`1<FAIL>, A> ma, K`2<Validation`1<FAIL>, B> mb);
    private static override K`2<Validation`1<FAIL>, A> LanguageExt.Traits.MonoidK<LanguageExt.Validation<FAIL>>.Empty();
    private static override K`2<Validation`1<FAIL>, A> LanguageExt.Traits.SemigroupK<LanguageExt.Validation<FAIL>>.Combine(K`2<Validation`1<FAIL>, A> ma, K`2<Validation`1<FAIL>, A> mb);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Validation<FAIL>>.FoldWhile(Func`2<A, Func`2<S, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S initialState, K`2<Validation`1<FAIL>, A> ta);
    private static override S LanguageExt.Traits.Foldable<LanguageExt.Validation<FAIL>>.FoldBackWhile(Func`2<S, Func`2<A, S>> f, Func`2<ValueTuple`2<S, A>, bool> predicate, S initialState, K`2<Validation`1<FAIL>, A> ta);
    private static override K`2<F, K`2<Validation`1<FAIL>, B>> LanguageExt.Traits.Traversable<LanguageExt.Validation<FAIL>>.Traverse(Func`2<A, K`2<F, B>> f, K`2<Validation`1<FAIL>, A> ta);
    private static K`2<Validation`1<FAIL>, A> Succ(A value);
    private static K`2<Validation`1<FAIL>, A> Fail(FAIL value);
    private static override K`2<Validation`1<FAIL>, A> LanguageExt.Traits.Fallible<FAIL,LanguageExt.Validation<FAIL>>.Fail(FAIL error);
    private static override K`2<Validation`1<FAIL>, A> LanguageExt.Traits.Fallible<FAIL,LanguageExt.Validation<FAIL>>.Catch(K`2<Validation`1<FAIL>, A> fa, Func`2<FAIL, bool> Predicate, Func`2<FAIL, K`2<Validation`1<FAIL>, A>> Fail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.Validation`2 : object {
    [CompilerGeneratedAttribute]
private static Validation`2<F, A> <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [PureAttribute]
public bool IsSuccess { get; }
    [PureAttribute]
public bool IsFail { get; }
    internal A SuccessValue { get; }
    internal F FailValue { get; }
    [PureAttribute]
public static Validation`2<F, A> Empty { get; }
    [CompilerGeneratedAttribute]
protected Validation`2(Validation`2<F, A> original);
    private static Validation`2();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [PureAttribute]
public static Validation`2<F, A> Success(A value);
    [PureAttribute]
public static Validation`2<F, A> Fail(F value);
    public abstract virtual bool get_IsSuccess();
    public abstract virtual bool get_IsFail();
    [PureAttribute]
public abstract virtual B Match(Func`2<A, B> Succ, Func`2<F, B> Fail);
    [PureAttribute]
public abstract virtual ReadOnlySpan`1<F> FailSpan();
    [PureAttribute]
public abstract virtual ReadOnlySpan`1<A> SuccessSpan();
    [PureAttribute]
public abstract virtual int CompareTo(Validation`2<F, A> other);
    [PureAttribute]
public abstract virtual bool Equals(Validation`2<F, A> other);
    internal abstract virtual A get_SuccessValue();
    internal abstract virtual F get_FailValue();
    [PureAttribute]
public abstract virtual Validation`2<F, B> Map(Func`2<A, B> f);
    [PureAttribute]
public abstract virtual Validation`2<F1, A1> BiMap(Func`2<A, A1> Succ, Func`2<F, F1> Fail);
    [PureAttribute]
public abstract virtual Validation`2<F, B> Bind(Func`2<A, Validation`2<F, B>> f);
    [PureAttribute]
public abstract virtual Validation`2<F1, A1> BiBind(Func`2<A, Validation`2<F1, A1>> Succ, Func`2<F, Validation`2<F1, A1>> Fail);
    [PureAttribute]
public Validation`2<F1, A> BindFail(Func`2<F, Validation`2<F1, A>> Fail);
    [CompilerGeneratedAttribute]
public static Validation`2<F, A> get_Empty();
    [PureAttribute]
public static A op_Explicit(Validation`2<F, A> ma);
    [PureAttribute]
public static F op_Explicit(Validation`2<F, A> ma);
    [PureAttribute]
public static Validation`2<F, A> op_Implicit(A value);
    [PureAttribute]
public static Validation`2<F, A> op_Implicit(F value);
    public Unit Match(Action`1<A> Succ, Action`1<F> Fail);
    [PureAttribute]
public A IfFail(Func`1<A> Fail);
    [PureAttribute]
public A IfFail(Func`2<F, A> failMap);
    [PureAttribute]
public A IfFail(A successValue);
    public Unit IfFail(Action`1<F> Fail);
    public Unit IfRight(Action`1<A> Success);
    [PureAttribute]
public ValidationUnitContext`2<F, A> Success(Action`1<A> success);
    [PureAttribute]
public ValidationContext`3<F, A, B> Success(Func`2<A, B> success);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("2")]
[PureAttribute]
public sealed virtual int CompareTo(object obj);
    [IteratorStateMachineAttribute("LanguageExt.Validation`2/<GetEnumerator>d__39")]
[PureAttribute]
public sealed virtual IEnumerator`1<A> GetEnumerator();
    [PureAttribute]
public Lst`1<F> FailToList();
    [PureAttribute]
public Arr`1<F> FailToArray();
    public Lst`1<A> ToList();
    public Arr`1<A> ToArray();
    [PureAttribute]
public Seq`1<A> ToSeq();
    [PureAttribute]
public Seq`1<F> FailToSeq();
    [PureAttribute]
public Either`2<F, A> ToEither();
    [PureAttribute]
public Option`1<A> ToOption();
    [PureAttribute]
public StreamT`2<M, A> ToStream();
    [PureAttribute]
public StreamT`2<M, F> FailToStream();
    [PureAttribute]
public static bool op_LessThan(Validation`2<F, A> lhs, Fail`1<F> rhs);
    [PureAttribute]
public static bool op_LessThanOrEqual(Validation`2<F, A> lhs, Fail`1<F> rhs);
    [PureAttribute]
public static bool op_GreaterThan(Validation`2<F, A> lhs, Fail`1<F> rhs);
    [PureAttribute]
public static bool op_GreaterThanOrEqual(Validation`2<F, A> lhs, Fail`1<F> rhs);
    [PureAttribute]
public static bool op_LessThan(Validation`2<F, A> lhs, Pure`1<A> rhs);
    [PureAttribute]
public static bool op_LessThanOrEqual(Validation`2<F, A> lhs, Pure`1<A> rhs);
    [PureAttribute]
public static bool op_GreaterThan(Validation`2<F, A> lhs, Pure`1<A> rhs);
    [PureAttribute]
public static bool op_GreaterThanOrEqual(Validation`2<F, A> lhs, Pure`1<A> rhs);
    [PureAttribute]
public static bool op_LessThan(Fail`1<F> lhs, Validation`2<F, A> rhs);
    [PureAttribute]
public static bool op_LessThanOrEqual(Fail`1<F> lhs, Validation`2<F, A> rhs);
    [PureAttribute]
public static bool op_GreaterThan(Fail`1<F> lhs, Validation`2<F, A> rhs);
    [PureAttribute]
public static bool op_GreaterThanOrEqual(Fail`1<F> lhs, Validation`2<F, A> rhs);
    [PureAttribute]
public static bool op_LessThan(Pure`1<A> lhs, Validation`2<F, A> rhs);
    [PureAttribute]
public static bool op_LessThanOrEqual(Pure`1<A> lhs, Validation`2<F, A> rhs);
    [PureAttribute]
public static bool op_GreaterThan(Pure`1<A> lhs, Validation`2<F, A> rhs);
    [PureAttribute]
public static bool op_GreaterThanOrEqual(Pure`1<A> lhs, Validation`2<F, A> rhs);
    [PureAttribute]
public static bool op_LessThan(Validation`2<F, A> lhs, Validation`2<F, A> rhs);
    [PureAttribute]
public static bool op_LessThanOrEqual(Validation`2<F, A> lhs, Validation`2<F, A> rhs);
    [PureAttribute]
public static bool op_GreaterThan(Validation`2<F, A> lhs, Validation`2<F, A> rhs);
    [PureAttribute]
public static bool op_GreaterThanOrEqual(Validation`2<F, A> lhs, Validation`2<F, A> rhs);
    [PureAttribute]
public static bool op_Equality(Validation`2<F, A> lhs, Fail`1<F> rhs);
    [PureAttribute]
public static bool op_Equality(Validation`2<F, A> lhs, Pure`1<A> rhs);
    [PureAttribute]
public static bool op_Equality(Fail`1<F> lhs, Validation`2<F, A> rhs);
    [PureAttribute]
public static bool op_Equality(Pure`1<A> lhs, Validation`2<F, A> rhs);
    [PureAttribute]
public static bool op_Inequality(Validation`2<F, A> lhs, Fail`1<F> rhs);
    [PureAttribute]
public static bool op_Inequality(Validation`2<F, A> lhs, Pure`1<A> rhs);
    [PureAttribute]
public static bool op_Inequality(Fail`1<F> lhs, Validation`2<F, A> rhs);
    [PureAttribute]
public static bool op_Inequality(Pure`1<A> lhs, Validation`2<F, A> rhs);
    [PureAttribute]
public static override Validation`2<F, A> op_BitwiseOr(Validation`2<F, A> lhs, Validation`2<F, A> rhs);
    [PureAttribute]
public static override Validation`2<F, A> op_BitwiseOr(K`2<Validation`1<F>, A> lhs, Validation`2<F, A> rhs);
    [PureAttribute]
public static override Validation`2<F, A> op_BitwiseOr(Validation`2<F, A> lhs, K`2<Validation`1<F>, A> rhs);
    public static Validation`2<F, A> op_BitwiseOr(Validation`2<F, A> lhs, A rhs);
    [PureAttribute]
public static override Validation`2<F, A> op_BitwiseOr(Validation`2<F, A> lhs, Pure`1<A> rhs);
    [PureAttribute]
public static override Validation`2<F, A> op_BitwiseOr(Validation`2<F, A> lhs, Fail`1<F> rhs);
    public static override Validation`2<F, A> op_BitwiseOr(Validation`2<F, A> lhs, CatchM`3<F, Validation`1<F>, A> rhs);
    [PureAttribute]
public static Validation`2<F, A> op_BitwiseOr(Validation`2<F, A> lhs, F rhs);
    [PureAttribute]
public static Validation`2<F, Seq`1<A>> op_BitwiseAnd(Validation`2<F, A> lhs, Validation`2<F, A> rhs);
    [PureAttribute]
public static Validation`2<F, Seq`1<A>> op_BitwiseAnd(Validation`2<F, Seq`1<A>> lhs, Validation`2<F, A> rhs);
    [PureAttribute]
public static Validation`2<F, Seq`1<A>> op_BitwiseAnd(Validation`2<F, A> lhs, Validation`2<F, Seq`1<A>> rhs);
    [PureAttribute]
public static Validation`2<F, Seq`1<A>> op_BitwiseAnd(Validation`2<F, A> lhs, Pure`1<A> rhs);
    [PureAttribute]
public static Validation`2<F, Seq`1<A>> op_BitwiseAnd(Validation`2<F, A> lhs, Fail`1<F> rhs);
    [PureAttribute]
public static bool op_True(Validation`2<F, A> value);
    [PureAttribute]
public static bool op_False(Validation`2<F, A> value);
    [PureAttribute]
public sealed virtual int CompareTo(Validation`2<F, A> other);
    [PureAttribute]
public int CompareTo(Validation`2<F, A> other);
    [PureAttribute]
public int CompareTo(Fail`1<F> other);
    [PureAttribute]
public sealed virtual int CompareTo(Pure`1<A> other);
    [NullableContextAttribute("2")]
[PureAttribute]
public sealed virtual int CompareTo(A other);
    [NullableContextAttribute("2")]
[PureAttribute]
public int CompareTo(F other);
    [NullableContextAttribute("2")]
[PureAttribute]
public sealed virtual bool Equals(A other);
    [NullableContextAttribute("2")]
[PureAttribute]
public bool Equals(F other);
    [PureAttribute]
public virtual bool Equals(Validation`2<F, A> other);
    [PureAttribute]
public virtual bool Equals(Validation`2<F, A> other);
    [PureAttribute]
public bool Equals(Fail`1<F> other);
    [PureAttribute]
public sealed virtual bool Equals(Pure`1<A> other);
    [PureAttribute]
public B MatchUntyped(Func`2<object, B> Succ, Func`2<object, B> Fail);
    public Unit Iter(Action`1<A> Succ);
    [PureAttribute]
public bool ForAll(Func`2<A, bool> Succ);
    [PureAttribute]
public bool BiForAll(Func`2<A, bool> Succ, Func`2<F, bool> Fail);
    [PureAttribute]
public S Fold(S state, Func`3<S, A, S> Succ);
    [PureAttribute]
public S BiFold(S state, Func`3<S, A, S> Succ, Func`3<S, F, S> Fail);
    [PureAttribute]
public bool Exists(Func`2<A, bool> pred);
    public Validation`2<F, A> Do(Action`1<A> f);
    [PureAttribute]
public K`2<AF, Validation`2<F, B>> Traverse(Func`2<A, K`2<AF, B>> f);
    [PureAttribute]
public Validation`2<F1, A> MapFail(Func`2<F, F1> f);
    [PureAttribute]
public Validation`2<F, B> Bind(Func`2<A, K`2<Validation`1<F>, B>> f);
    [PureAttribute]
public Validation`2<F, A> Filter(Func`2<A, bool> pred);
    [PureAttribute]
[EditorBrowsableAttribute("1")]
public Validation`2<F, A> Where(Func`2<A, bool> pred);
    [PureAttribute]
public Validation`2<F, B> Select(Func`2<A, B> f);
    [PureAttribute]
public Validation`2<F, B> SelectMany(Func`2<A, Validation`2<F, S>> bind, Func`3<A, S, B> project);
    [PureAttribute]
public Validation`2<F, B> Bind(Func`2<A, Pure`1<B>> f);
    [PureAttribute]
public Validation`2<F, A> Bind(Func`2<A, Fail`1<F>> f);
    [PureAttribute]
public Validation`2<F, Unit> Bind(Func`2<A, Guard`2<F, Unit>> f);
    [PureAttribute]
public Validation`2<F, C> SelectMany(Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    [PureAttribute]
public Validation`2<F, C> SelectMany(Func`2<A, Fail`1<F>> bind, Func`3<A, B, C> _);
    [PureAttribute]
public Validation`2<F, C> SelectMany(Func`2<A, Guard`2<F, Unit>> f, Func`3<A, Unit, C> project);
    [PureAttribute]
public static override Validation`2<F, A> op_Implicit(Pure`1<A> mr);
    [PureAttribute]
public static override Validation`2<F, A> op_Implicit(Fail`1<F> mr);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Validation`2<F, A> left, Validation`2<F, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Validation`2<F, A> left, Validation`2<F, A> right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public abstract virtual Validation`2<F, A> <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ValidationContext`3 : ValueType {
    private Validation`2<F, A> validation;
    private Func`2<A, B> success;
    internal ValidationContext`3(Validation`2<F, A> validation, Func`2<A, B> success);
    [PureAttribute]
public B Fail(Func`2<F, B> fail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.ValidationExtensions : object {
    [ExtensionAttribute]
public static Validation`2<F, A> As(K`2<Validation`1<F>, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Validation`2<L, A> Flatten(Validation`2<L, Validation`2<L, A>> mma);
    [ExtensionAttribute]
[PureAttribute]
public static Validation`2<L, B> Apply(Validation`2<L, Func`2<A, B>> mf, Validation`2<L, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Validation`2<L, C> Apply(Validation`2<L, Func`3<A, B, C>> mf, Validation`2<L, A> ma, Validation`2<L, B> mb);
    [ExtensionAttribute]
[PureAttribute]
public static Validation`2<L, Func`2<B, C>> Apply(Validation`2<L, Func`3<A, B, C>> mf, Validation`2<L, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Validation`2<L, B> ApplyM(Validation`2<L, Func`2<A, Validation`2<L, B>>> mf, Validation`2<L, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Validation`2<L, C> ApplyM(Validation`2<L, Func`3<A, B, Validation`2<L, C>>> mf, Validation`2<L, A> ma, Validation`2<L, B> mb);
    [ExtensionAttribute]
[PureAttribute]
public static Validation`2<L, Func`2<B, Validation`2<L, C>>> ApplyM(Validation`2<L, Func`3<A, B, Validation`2<L, C>>> mf, Validation`2<L, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Validation`2<L, B> Action(Validation`2<L, A> ma, Validation`2<L, B> mb);
    [IteratorStateMachineAttribute("LanguageExt.ValidationExtensions/<Successes>d__9`2")]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<S> Successes(IEnumerable`1<Validation`2<F, S>> vs);
    [IteratorStateMachineAttribute("LanguageExt.ValidationExtensions/<Fails>d__10`2")]
[ExtensionAttribute]
[PureAttribute]
public static IEnumerable`1<F> Fails(IEnumerable`1<Validation`2<F, S>> vs);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[PureAttribute]
public static Seq`1<S> Successes(Seq`1<Validation`2<F, S>> vs);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[PureAttribute]
public static Seq`1<F> Fails(Seq`1<Validation`2<F, S>> vs);
    [ExtensionAttribute]
[PureAttribute]
public static Fin`1<A> ToFin(Validation`2<Error, A> ma);
}
[ExtensionAttribute]
public static class LanguageExt.ValidationGuardExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Validation`2<F, C> SelectMany(Validation`2<F, A> ma, Func`2<A, Guard`2<F, Unit>> f, Func`3<A, Unit, C> project);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ValidationT : object {
    public static ValidationT`3<L, M, B> bind(ValidationT`3<L, M, A> ma, Func`2<A, ValidationT`3<L, M, B>> f);
    public static ValidationT`3<L, M, B> map(Func`2<A, B> f, ValidationT`3<L, M, A> ma);
    public static ValidationT`3<L, M, A> Right(A value);
    public static ValidationT`3<L, M, A> Left(L value);
    public static ValidationT`3<L, M, B> apply(ValidationT`3<L, M, Func`2<A, B>> mf, ValidationT`3<L, M, A> ma);
    public static ValidationT`3<L, M, B> action(ValidationT`3<L, M, A> ma, ValidationT`3<L, M, B> mb);
    public static ValidationT`3<L, M, A> lift(Validation`2<L, A> ma);
    public static ValidationT`3<L, M, A> lift(K`2<M, A> ma);
    public static ValidationT`3<L, M, A> lift(Pure`1<A> ma);
    public static ValidationT`3<L, M, A> lift(Fail`1<L> ma);
    public static ValidationT`3<L, M, A> liftIO(IO`1<A> ma);
    public static K`2<M, B> match(ValidationT`3<L, M, A> ma, Func`2<A, B> Succ, Func`2<L, B> Fail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ValidationT`2 : object {
    public static ValidationT`3<F, M, A> Right(A value);
    public static ValidationT`3<F, M, A> Left(F value);
    public static ValidationT`3<F, M, A> lift(Validation`2<F, A> ma);
    public static ValidationT`3<F, M, A> lift(Pure`1<A> ma);
    public static ValidationT`3<F, M, A> lift(Fail`1<F> ma);
    public static ValidationT`3<F, M, A> liftIO(IO`1<A> ma);
    private static override K`2<ValidationT`2<F, M>, B> LanguageExt.Traits.Monad<LanguageExt.ValidationT<F,M>>.Bind(K`2<ValidationT`2<F, M>, A> ma, Func`2<A, K`2<ValidationT`2<F, M>, B>> f);
    private static override K`2<ValidationT`2<F, M>, B> LanguageExt.Traits.Functor<LanguageExt.ValidationT<F,M>>.Map(Func`2<A, B> f, K`2<ValidationT`2<F, M>, A> ma);
    private static override K`2<ValidationT`2<F, M>, A> LanguageExt.Traits.Applicative<LanguageExt.ValidationT<F,M>>.Pure(A value);
    private static override K`2<ValidationT`2<F, M>, B> LanguageExt.Traits.Applicative<LanguageExt.ValidationT<F,M>>.Apply(K`2<ValidationT`2<F, M>, Func`2<A, B>> mf, K`2<ValidationT`2<F, M>, A> ma);
    private static override K`2<ValidationT`2<F, M>, B> LanguageExt.Traits.Applicative<LanguageExt.ValidationT<F,M>>.Action(K`2<ValidationT`2<F, M>, A> ma, K`2<ValidationT`2<F, M>, B> mb);
    private static override K`2<ValidationT`2<F, M>, A> LanguageExt.Traits.MonadT<LanguageExt.ValidationT<F,M>,M>.Lift(K`2<M, A> ma);
    private static override K`2<ValidationT`2<F, M>, A> LanguageExt.Traits.MonadIO<LanguageExt.ValidationT<F,M>>.LiftIO(IO`1<A> ma);
    private static override K`2<ValidationT`2<F, M>, A> LanguageExt.Traits.MonoidK<LanguageExt.ValidationT<F,M>>.Empty();
    private static override K`2<ValidationT`2<F, M>, A> LanguageExt.Traits.SemigroupK<LanguageExt.ValidationT<F,M>>.Combine(K`2<ValidationT`2<F, M>, A> ma, K`2<ValidationT`2<F, M>, A> mb);
    private static override K`2<ValidationT`2<F, M>, A> LanguageExt.Traits.Fallible<F,LanguageExt.ValidationT<F,M>>.Fail(F error);
    private static override K`2<ValidationT`2<F, M>, A> LanguageExt.Traits.Fallible<F,LanguageExt.ValidationT<F,M>>.Catch(K`2<ValidationT`2<F, M>, A> fa, Func`2<F, bool> Predicate, Func`2<F, K`2<ValidationT`2<F, M>, A>> Fail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ValidationT`3 : object {
    [CompilerGeneratedAttribute]
private K`2<M, Validation`2<F, A>> <runValidation>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public K`2<M, Validation`2<F, A>> runValidation { get; public set; }
    public ValidationT`3(K`2<M, Validation`2<F, A>> runValidation);
    [CompilerGeneratedAttribute]
protected ValidationT`3(ValidationT`3<F, M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public K`2<M, Validation`2<F, A>> get_runValidation();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_runValidation(K`2<M, Validation`2<F, A>> value);
    public static ValidationT`3<F, M, A> Success(A value);
    public static ValidationT`3<F, M, A> Fail(F value);
    public static ValidationT`3<F, M, A> Lift(Pure`1<A> pure);
    public static ValidationT`3<F, M, A> Lift(Validation`2<F, A> Validation);
    public static ValidationT`3<F, M, A> Lift(Fail`1<F> fail);
    public static ValidationT`3<F, M, A> Lift(K`2<M, A> monad);
    public static ValidationT`3<F, M, A> LiftIO(IO`1<A> monad);
    public K`2<M, B> Match(Func`2<A, B> Succ, Func`2<F, B> Fail);
    public K`2<M, Validation`2<F, A>> Run();
    public ValidationT`3<F, M1, B> MapT(Func`2<K`2<M, Validation`2<F, A>>, K`2<M1, Validation`2<F, B>>> f);
    public ValidationT`3<F, M, B> MapM(Func`2<K`2<M, A>, K`2<M, B>> f);
    public ValidationT`3<F, M, B> Map(Func`2<A, B> f);
    public ValidationT`3<F, M, B> Select(Func`2<A, B> f);
    public ValidationT`3<F, M, B> Bind(Func`2<A, K`2<ValidationT`2<F, M>, B>> f);
    public ValidationT`3<F, M, B> Bind(Func`2<A, ValidationT`3<F, M, B>> f);
    public ValidationT`3<F, M, B> BiBind(Func`2<A, ValidationT`3<F, M, B>> Succ, Func`2<F, ValidationT`3<F, M, B>> Fail);
    public ValidationT`3<F, M, A> BindFail(Func`2<F, ValidationT`3<F, M, A>> Fail);
    public ValidationT`3<F, M, B> Bind(Func`2<A, IO`1<B>> f);
    public ValidationT`3<F, M, B> Bind(Func`2<A, Pure`1<B>> f);
    public ValidationT`3<F, M, C> SelectMany(Func`2<A, K`2<ValidationT`2<F, M>, B>> bind, Func`3<A, B, C> project);
    public ValidationT`3<F, M, C> SelectMany(Func`2<A, ValidationT`3<F, M, B>> bind, Func`3<A, B, C> project);
    public ValidationT`3<F, M, C> SelectMany(Func`2<A, K`2<M, B>> bind, Func`3<A, B, C> project);
    public ValidationT`3<F, M, C> SelectMany(Func`2<A, Validation`2<F, B>> bind, Func`3<A, B, C> project);
    public ValidationT`3<F, M, C> SelectMany(Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    public ValidationT`3<F, M, C> SelectMany(Func`2<A, IO`1<B>> bind, Func`3<A, B, C> project);
    public static ValidationT`3<F, M, A> op_RightShift(ValidationT`3<F, M, A> lhs, ValidationT`3<F, M, A> rhs);
    public static ValidationT`3<F, M, A> op_RightShift(ValidationT`3<F, M, A> lhs, K`2<ValidationT`2<F, M>, A> rhs);
    public static ValidationT`3<F, M, A> op_RightShift(ValidationT`3<F, M, A> lhs, ValidationT`3<F, M, Unit> rhs);
    public static ValidationT`3<F, M, A> op_RightShift(ValidationT`3<F, M, A> lhs, K`2<ValidationT`2<F, M>, Unit> rhs);
    public static override ValidationT`3<F, M, A> op_Implicit(Pure`1<A> ma);
    public static override ValidationT`3<F, M, A> op_Implicit(Fail`1<F> ma);
    public static ValidationT`3<F, M, A> op_Implicit(F fail);
    public static ValidationT`3<F, M, A> op_Implicit(IO`1<A> ma);
    [PureAttribute]
public static override ValidationT`3<F, M, A> op_BitwiseOr(ValidationT`3<F, M, A> lhs, ValidationT`3<F, M, A> rhs);
    [PureAttribute]
public static override ValidationT`3<F, M, A> op_BitwiseOr(K`2<ValidationT`2<F, M>, A> lhs, ValidationT`3<F, M, A> rhs);
    [PureAttribute]
public static override ValidationT`3<F, M, A> op_BitwiseOr(ValidationT`3<F, M, A> lhs, K`2<ValidationT`2<F, M>, A> rhs);
    [PureAttribute]
public static override ValidationT`3<F, M, A> op_BitwiseOr(ValidationT`3<F, M, A> lhs, Pure`1<A> rhs);
    [PureAttribute]
public static override ValidationT`3<F, M, A> op_BitwiseOr(ValidationT`3<F, M, A> lhs, Fail`1<F> rhs);
    [PureAttribute]
public static override ValidationT`3<F, M, A> op_BitwiseOr(ValidationT`3<F, M, A> lhs, CatchM`3<F, ValidationT`2<F, M>, A> rhs);
    public static ValidationT`3<F, M, Seq`1<A>> op_BitwiseAnd(ValidationT`3<F, M, A> ma, ValidationT`3<F, M, A> mb);
    public StreamT`2<M, A> ToStream();
    public StreamT`2<M, F> FailToStream();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ValidationT`3<F, M, A> left, ValidationT`3<F, M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ValidationT`3<F, M, A> left, ValidationT`3<F, M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(ValidationT`3<F, M, A> other);
    [CompilerGeneratedAttribute]
public virtual ValidationT`3<F, M, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(K`2& runValidation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.ValidationTExt : object {
    [ExtensionAttribute]
public static ValidationT`3<L, M, A> As(K`2<ValidationT`2<L, M>, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static ValidationT`3<L, M, A> Flatten(ValidationT`3<L, M, ValidationT`3<L, M, A>> mma);
    [ExtensionAttribute]
public static ValidationT`3<L, IO, A> Flatten(Task`1<ValidationT`3<L, IO, A>> tma);
    [ExtensionAttribute]
public static ValidationT`3<L, IO, A> ToIO(Task`1<Validation`2<L, A>> ma);
    [ExtensionAttribute]
public static OptionT`2<M, A> ToOption(ValidationT`3<F, M, A> ma);
    [ExtensionAttribute]
public static EitherT`3<F, M, A> ToEither(ValidationT`3<F, M, A> ma);
    [ExtensionAttribute]
public static FinT`2<M, A> ToFin(ValidationT`3<Error, M, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static ValidationT`3<L, M, C> SelectMany(K`2<M, A> ma, Func`2<A, K`2<ValidationT`2<L, M>, B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
[PureAttribute]
public static ValidationT`3<L, M, C> SelectMany(K`2<M, A> ma, Func`2<A, ValidationT`3<L, M, B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
[PureAttribute]
public static ValidationT`3<L, M, B> Apply(ValidationT`3<L, M, Func`2<A, B>> mf, ValidationT`3<L, M, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static ValidationT`3<L, M, B> Action(ValidationT`3<L, M, A> ma, ValidationT`3<L, M, B> mb);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ValidationUnitContext`2 : ValueType {
    private Validation`2<F, A> validation;
    private Action`1<A> success;
    internal ValidationUnitContext`2(Validation`2<F, A> validation, Action`1<A> success);
    public Unit Left(Action`1<F> fail);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ValueIsNoneException : Exception {
    public static ValueIsNoneException Default;
    public ValueIsNoneException(string message);
    public ValueIsNoneException(string message, Exception innerException);
    private static ValueIsNoneException();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.ValueIsNullException : Exception {
    public ValueIsNullException(string message);
    public ValueIsNullException(string message, Exception innerException);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.ValueTaskExtensions : object {
    [ExtensionAttribute]
public static bool CompletedSuccessfully(ValueTask`1<A> ma);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<A> AsFailedValueTask(Exception ex);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<A> AsValueTask(A self);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<A> ToValue(Task`1<A> self);
    [AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<Flatten>d__4`1")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<A> Flatten(ValueTask`1<ValueTask`1<A>> self);
    [AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<Flatten>d__5`1")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<A> Flatten(ValueTask`1<ValueTask`1<ValueTask`1<A>>> self);
    [AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<Select>d__6`2")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<U> Select(ValueTask`1<T> self, Func`2<T, U> map);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<Where>d__7`1")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<T> Where(ValueTask`1<T> self, Func`2<T, bool> pred);
    [AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<SelectMany>d__8`2")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<U> SelectMany(ValueTask`1<T> self, Func`2<T, ValueTask`1<U>> bind);
    [AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<SelectMany>d__9`3")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<V> SelectMany(ValueTask`1<T> self, Func`2<T, ValueTask`1<U>> bind, Func`3<T, U, V> project);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<Count>d__10`1")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<int> Count(ValueTask`1<T> self);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<U> Bind(ValueTask`1<T> self, Func`2<T, ValueTask`1<U>> bind);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<Exists>d__12`1")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<bool> Exists(ValueTask`1<T> self, Func`2<T, bool> pred);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<ExistsAsync>d__13`1")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<bool> ExistsAsync(ValueTask`1<T> self, Func`2<T, ValueTask`1<bool>> pred);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<ForAll>d__14`1")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<bool> ForAll(ValueTask`1<T> self, Func`2<T, bool> pred);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<ForAllAsync>d__15`1")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<bool> ForAllAsync(ValueTask`1<T> self, Func`2<T, ValueTask`1<bool>> pred);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<T> Filter(ValueTask`1<T> self, Func`2<T, bool> pred);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<Fold>d__17`2")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<S> Fold(ValueTask`1<T> self, S state, Func`3<S, T, S> folder);
    [AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<FoldAsync>d__18`2")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<S> FoldAsync(ValueTask`1<T> self, S state, Func`3<S, T, ValueTask`1<S>> folder);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<Iter>d__19`1")]
[ExtensionAttribute]
public static ValueTask`1<Unit> Iter(ValueTask`1<T> self, Action`1<T> f);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ValueTask`1<A> Do(ValueTask`1<A> ma, Action`1<A> f);
    [AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<Map>d__21`2")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<U> Map(ValueTask`1<T> self, Func`2<T, U> map);
    [AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<MapAsync>d__22`2")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<U> MapAsync(ValueTask`1<T> self, Func`2<T, ValueTask`1<U>> map);
    [AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<Join>d__23`4")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<V> Join(ValueTask`1<T> source, ValueTask`1<U> inner, Func`2<T, K> outerKeyMap, Func`2<U, K> innerKeyMap, Func`3<T, U, V> project);
    [AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<GroupJoin>d__24`4")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<V> GroupJoin(ValueTask`1<T> source, ValueTask`1<U> inner, Func`2<T, K> outerKeyMap, Func`2<U, K> innerKeyMap, Func`3<T, ValueTask`1<U>, V> project);
    [AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<Plus>d__25`1")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<A> Plus(ValueTask`1<A> ma, ValueTask`1<A> mb);
    [AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<PlusFirst>d__26`1")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTask`1<A> PlusFirst(ValueTask`1<A> ma, ValueTask`1<A> mb);
    [ExtensionAttribute]
public static ValueTask`1<A> Cast(ValueTask source);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<ToUnit>d__28")]
[ExtensionAttribute]
public static ValueTask`1<Unit> ToUnit(ValueTask source);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ValueTask`1<Unit> WindowIter(IEnumerable`1<ValueTask`1<A>> ma, Action`1<A> f);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<WindowIter>d__30`1")]
[ExtensionAttribute]
public static ValueTask`1<Unit> WindowIter(IEnumerable`1<ValueTask`1<A>> ma, int windowSize, Action`1<A> f);
    [ExtensionAttribute]
internal static ValueTask`1<IList`1<B>> WindowMap(IEnumerable`1<ValueTask`1<A>> ma, Func`2<A, B> f, CancellationToken token);
    [AsyncStateMachineAttribute("LanguageExt.ValueTaskExtensions/<WindowMap>d__32`2")]
[ExtensionAttribute]
internal static ValueTask`1<IList`1<B>> WindowMap(IEnumerable`1<ValueTask`1<A>> ma, int windowSize, Func`2<A, B> f, CancellationToken token);
}
internal static class LanguageExt.ValueTasks : object {
    [AsyncStateMachineAttribute("LanguageExt.ValueTasks/<ForAll>d__0`1")]
[PureAttribute]
public static ValueTask`1<bool> ForAll(IEnumerable`1<ValueTask`1<A>> fs, Func`2<A, bool> pred, CancellationToken token);
    [AsyncStateMachineAttribute("LanguageExt.ValueTasks/<ForAll>d__1`1")]
[PureAttribute]
public static ValueTask`1<bool> ForAll(IEnumerable`1<ValueTask`1<A>> fs, Func`2<A, bool> pred, int windowSize, CancellationToken token);
    [AsyncStateMachineAttribute("LanguageExt.ValueTasks/<Exists>d__2`1")]
[PureAttribute]
public static ValueTask`1<bool> Exists(IEnumerable`1<ValueTask`1<A>> fs, Func`2<A, bool> pred, CancellationToken token);
    [AsyncStateMachineAttribute("LanguageExt.ValueTasks/<Exists>d__3`1")]
[PureAttribute]
public static ValueTask`1<bool> Exists(IEnumerable`1<ValueTask`1<A>> fs, Func`2<A, bool> pred, int windowSize, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class LanguageExt.VectorClock : object {
    public static VectorClock`1<A> Single(A x, long y);
    public static VectorClock`4<OrdA, NumB, A, B> Single(A x, B y);
    public static VectorClock`1<A> fromList(Seq`1<ValueTuple`2<A, long>> list);
    public static VectorClock`4<OrdA, NumB, A, B> fromList(Seq`1<ValueTuple`2<A, B>> list);
    public static VectorClock`1<A> combine(Func`4<A, Option`1<long>, Option`1<long>, Option`1<long>> f, VectorClock`1<A> vc1, VectorClock`1<A> vc2);
    public static VectorClock`4<OrdA, NumB, A, B> combine(Func`4<A, Option`1<B>, Option`1<B>, Option`1<B>> f, VectorClock`4<OrdA, NumB, A, B> vc1, VectorClock`4<OrdA, NumB, A, B> vc2);
    public static VectorClock`1<A> max(VectorClock`1<A> vc1, VectorClock`1<A> vc2);
    public static VectorClock`4<OrdA, NumB, A, B> max(VectorClock`4<OrdA, NumB, A, B> vc1, VectorClock`4<OrdA, NumB, A, B> vc2);
    public static Relation relation(VectorClock`1<A> vc1, VectorClock`1<A> vc2);
    public static Relation relation(VectorClock`4<OrdA, NumB, A, B> vc1, VectorClock`4<OrdA, NumB, A, B> vc2);
    public static bool causes(VectorClock`1<A> vc1, VectorClock`1<A> vc2);
    public static bool causes(VectorClock`4<OrdA, NumB, A, B> vc1, VectorClock`4<OrdA, NumB, A, B> vc2);
    public static Option`1<VectorClock`1<A>> diff(VectorClock`1<A> vc1, VectorClock`1<A> vc2);
    public static Option`1<VectorClock`4<OrdA, NumB, A, B>> diff(VectorClock`4<OrdA, NumB, A, B> vc1, VectorClock`4<OrdA, NumB, A, B> vc2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.VectorClock`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Seq`1<ValueTuple`2<A, long>> <Entries>k__BackingField;
    public static VectorClock`1<A> Empty;
    private Nullable`1<bool> valid;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Seq`1<ValueTuple`2<A, long>> Entries { get; public set; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public bool Valid { get; }
    public VectorClock`1(Seq`1<ValueTuple`2<A, long>> Entries);
    [CompilerGeneratedAttribute]
protected VectorClock`1(VectorClock`1<A> original);
    private static VectorClock`1();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Seq`1<ValueTuple`2<A, long>> get_Entries();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Entries(Seq`1<ValueTuple`2<A, long>> value);
    public virtual bool Equals(VectorClock`1<A> rhs);
    public virtual int GetHashCode();
    public static VectorClock`1<A> Single(A x, long y);
    public static VectorClock`1<A> fromList(Seq`1<ValueTuple`2<A, long>> list);
    public Seq`1<ValueTuple`2<A, long>> ToSeq();
    public bool get_IsEmpty();
    public int get_Count();
    public ValueTuple`2<Option`1<long>, VectorClock`1<A>> Extract(A index);
    [NullableContextAttribute("0")]
public Option`1<long> Lookup(A index);
    public bool Contains(A index);
    public VectorClock`1<A> Remove(A index);
    public VectorClock`1<A> Insert(A index, long value);
    public Option`1<VectorClock`1<A>> Inc(A index);
    public VectorClock`1<A> Inc(A index, long defaultValue);
    public static VectorClock`1<A> combine(Func`4<A, Option`1<long>, Option`1<long>, Option`1<long>> f, VectorClock`1<A> vc1, VectorClock`1<A> vc2);
    public VectorClock`1<A> Max(VectorClock`1<A> vc2);
    public static VectorClock`1<A> max(VectorClock`1<A> vc1, VectorClock`1<A> vc2);
    public Relation Relation(VectorClock`1<A> vc2);
    public static Relation relation(VectorClock`1<A> vc1, VectorClock`1<A> vc2);
    public bool Causes(VectorClock`1<A> vc2);
    public static bool causes(VectorClock`1<A> vc1, VectorClock`1<A> vc2);
    public Option`1<VectorClock`1<A>> Diff(VectorClock`1<A> vc2);
    public static Option`1<VectorClock`1<A>> diff(VectorClock`1<A> vc1, VectorClock`1<A> vc2);
    public bool get_Valid();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(VectorClock`1<A> left, VectorClock`1<A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(VectorClock`1<A> left, VectorClock`1<A> right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual VectorClock`1<A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Seq`1& Entries);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static Seq`1<ValueTuple`2<A, long>> <Extract>g__go|17_0(Seq`1<ValueTuple`2<A, long>> zs, <>c__DisplayClass17_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static Seq`1<ValueTuple`2<A, long>> <Insert>g__go|21_0(Seq`1<ValueTuple`2<A, long>> entries, <>c__DisplayClass21_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static Option`1<ValueTuple`2<A, long>> <combine>g__mk|24_1(A x, Option`1<long> v);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static Option`1<long> <max>g__maxEntry|26_0(A _, Option`1<long> ea, Option`1<long> eb);
    [CompilerGeneratedAttribute]
internal static Relation <relation>g__go|28_0(Seq`1<ValueTuple`2<A, long>> es1, Seq`1<ValueTuple`2<A, long>> es2);
    [CompilerGeneratedAttribute]
internal static bool <relation>g__checkCauses|28_1(Seq`1<ValueTuple`2<A, long>> es1, Seq`1<ValueTuple`2<A, long>> es2);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static Option`1<long> <diff>g__diffOne|32_0(A _, Option`1<long> ox, Option`1<long> oy);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.VectorClock`4 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Seq`1<ValueTuple`2<A, B>> <Entries>k__BackingField;
    public static VectorClock`4<OrdA, NumB, A, B> Empty;
    private Nullable`1<bool> valid;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Seq`1<ValueTuple`2<A, B>> Entries { get; public set; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public bool Valid { get; }
    public VectorClock`4(Seq`1<ValueTuple`2<A, B>> Entries);
    [CompilerGeneratedAttribute]
protected VectorClock`4(VectorClock`4<OrdA, NumB, A, B> original);
    private static VectorClock`4();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Seq`1<ValueTuple`2<A, B>> get_Entries();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Entries(Seq`1<ValueTuple`2<A, B>> value);
    public virtual bool Equals(VectorClock`4<OrdA, NumB, A, B> rhs);
    public virtual int GetHashCode();
    public static VectorClock`4<OrdA, NumB, A, B> Single(A x, B y);
    public static VectorClock`4<OrdA, NumB, A, B> fromList(Seq`1<ValueTuple`2<A, B>> list);
    public Seq`1<ValueTuple`2<A, B>> ToList();
    public bool get_IsEmpty();
    public int get_Count();
    public ValueTuple`2<Option`1<B>, VectorClock`4<OrdA, NumB, A, B>> Extract(A index);
    public Option`1<B> Lookup(A index);
    public bool Contains(A index);
    public VectorClock`4<OrdA, NumB, A, B> Remove(A index);
    public VectorClock`4<OrdA, NumB, A, B> Insert(A index, B value);
    public Option`1<VectorClock`4<OrdA, NumB, A, B>> Inc(A index);
    public VectorClock`4<OrdA, NumB, A, B> Inc(A index, B defaultValue);
    public static VectorClock`4<OrdA, NumB, A, B> combine(Func`4<A, Option`1<B>, Option`1<B>, Option`1<B>> f, VectorClock`4<OrdA, NumB, A, B> vc1, VectorClock`4<OrdA, NumB, A, B> vc2);
    public static VectorClock`4<OrdA, NumB, A, B> max(VectorClock`4<OrdA, NumB, A, B> vc1, VectorClock`4<OrdA, NumB, A, B> vc2);
    public Relation Relation(VectorClock`4<OrdA, NumB, A, B> vc1, VectorClock`4<OrdA, NumB, A, B> vc2);
    public static Relation relation(VectorClock`4<OrdA, NumB, A, B> vc1, VectorClock`4<OrdA, NumB, A, B> vc2);
    public bool Causes(VectorClock`4<OrdA, NumB, A, B> vc2);
    public static bool causes(VectorClock`4<OrdA, NumB, A, B> vc1, VectorClock`4<OrdA, NumB, A, B> vc2);
    public Option`1<VectorClock`4<OrdA, NumB, A, B>> Diff(VectorClock`4<OrdA, NumB, A, B> vc2);
    public static Option`1<VectorClock`4<OrdA, NumB, A, B>> diff(VectorClock`4<OrdA, NumB, A, B> vc1, VectorClock`4<OrdA, NumB, A, B> vc2);
    public bool get_Valid();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(VectorClock`4<OrdA, NumB, A, B> left, VectorClock`4<OrdA, NumB, A, B> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(VectorClock`4<OrdA, NumB, A, B> left, VectorClock`4<OrdA, NumB, A, B> right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual VectorClock`4<OrdA, NumB, A, B> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Seq`1& Entries);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static Seq`1<ValueTuple`2<A, B>> <Extract>g__go|17_0(Seq`1<ValueTuple`2<A, B>> zs, <>c__DisplayClass17_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static Seq`1<ValueTuple`2<A, B>> <Insert>g__go|21_0(Seq`1<ValueTuple`2<A, B>> entries, <>c__DisplayClass21_0& );
    [CompilerGeneratedAttribute]
internal static Option`1<ValueTuple`2<A, B>> <combine>g__mk|24_1(A x, Option`1<B> v);
    [CompilerGeneratedAttribute]
internal static Option`1<B> <max>g__maxEntry|25_0(A _, Option`1<B> ea, Option`1<B> eb);
    [CompilerGeneratedAttribute]
internal static Relation <relation>g__go|27_0(Seq`1<ValueTuple`2<A, B>> es1, Seq`1<ValueTuple`2<A, B>> es2);
    [CompilerGeneratedAttribute]
internal static bool <relation>g__checkCauses|27_1(Seq`1<ValueTuple`2<A, B>> es1, Seq`1<ValueTuple`2<A, B>> es2);
    [CompilerGeneratedAttribute]
internal static Option`1<B> <diff>g__diffOne|31_0(A _, Option`1<B> ox, Option`1<B> oy);
}
[IsReadOnlyAttribute]
public class LanguageExt.Velocity : ValueType {
    private double Value;
    public double MetresPerSecond { get; }
    public double KilometresPerSecond { get; }
    public double KilometresPerHour { get; }
    public double MilesPerSecond { get; }
    public double MilesPerHour { get; }
    public double Knots { get; }
    internal Velocity(double value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public sealed virtual bool Equals(Velocity other);
    public bool Equals(Velocity other, double epsilon);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Velocity other);
    public Velocity Add(Velocity rhs);
    public Velocity Subtract(Velocity rhs);
    public Velocity Multiply(double rhs);
    public Velocity Divide(double rhs);
    public static Velocity op_Multiply(Velocity lhs, double rhs);
    public static Velocity op_Multiply(double lhs, Velocity rhs);
    public static Length op_Multiply(Velocity lhs, Time rhs);
    public static Length op_Multiply(Time lhs, Velocity rhs);
    public static VelocitySq op_Multiply(Velocity lhs, Velocity rhs);
    public static VelocitySq op_ExclusiveOr(Velocity lhs, int power);
    public static Velocity op_Addition(Velocity lhs, Velocity rhs);
    public static Velocity op_Subtraction(Velocity lhs, Velocity rhs);
    public static Velocity op_Division(Velocity lhs, double rhs);
    public static double op_Division(Velocity lhs, Velocity rhs);
    public static Accel op_Division(Velocity lhs, Time rhs);
    public static Time op_Division(Velocity lhs, Accel rhs);
    public static bool op_Equality(Velocity lhs, Velocity rhs);
    public static bool op_Inequality(Velocity lhs, Velocity rhs);
    public static bool op_GreaterThan(Velocity lhs, Velocity rhs);
    public static bool op_LessThan(Velocity lhs, Velocity rhs);
    public static bool op_GreaterThanOrEqual(Velocity lhs, Velocity rhs);
    public static bool op_LessThanOrEqual(Velocity lhs, Velocity rhs);
    public Velocity Round();
    public Velocity Abs();
    public Velocity Min(Velocity rhs);
    public Velocity Max(Velocity rhs);
    public double get_MetresPerSecond();
    public double get_KilometresPerSecond();
    public double get_KilometresPerHour();
    public double get_MilesPerSecond();
    public double get_MilesPerHour();
    public double get_Knots();
}
[IsReadOnlyAttribute]
public class LanguageExt.VelocitySq : ValueType {
    private double Value;
    public double MetresPerSecond2 { get; }
    internal VelocitySq(double value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public sealed virtual bool Equals(VelocitySq other);
    public bool Equals(VelocitySq other, double epsilon);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(VelocitySq other);
    public VelocitySq Add(VelocitySq rhs);
    public VelocitySq Subtract(VelocitySq rhs);
    public VelocitySq Multiply(double rhs);
    public VelocitySq Divide(double rhs);
    public static VelocitySq op_Multiply(VelocitySq lhs, double rhs);
    public static VelocitySq op_Multiply(double lhs, VelocitySq rhs);
    public static VelocitySq op_Addition(VelocitySq lhs, VelocitySq rhs);
    public static VelocitySq op_Subtraction(VelocitySq lhs, VelocitySq rhs);
    public static VelocitySq op_Division(VelocitySq lhs, double rhs);
    public static double op_Division(VelocitySq lhs, VelocitySq rhs);
    public static bool op_Equality(VelocitySq lhs, VelocitySq rhs);
    public static bool op_Inequality(VelocitySq lhs, VelocitySq rhs);
    public static bool op_GreaterThan(VelocitySq lhs, VelocitySq rhs);
    public static bool op_LessThan(VelocitySq lhs, VelocitySq rhs);
    public static bool op_GreaterThanOrEqual(VelocitySq lhs, VelocitySq rhs);
    public static bool op_LessThanOrEqual(VelocitySq lhs, VelocitySq rhs);
    public Velocity Sqrt();
    public VelocitySq Round();
    public VelocitySq Abs();
    public VelocitySq Min(VelocitySq rhs);
    public VelocitySq Max(VelocitySq rhs);
    public double get_MetresPerSecond2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class LanguageExt.Version : object {
    [ExtensionAttribute]
public static Version`3<Actor, K, V> ToVersion(VersionVector`6<ConflictV, OrdActor, TLong, Actor, long, V> vector, K key);
    [ExtensionAttribute]
public static VersionVector`6<ConflictV, OrdActor, TLong, Actor, long, V> ToVector(Version`3<Actor, K, V> version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class LanguageExt.Version`3 : object {
    [CompilerGeneratedAttribute]
private K <Key>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public K Key { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Option`1<V> Value { get; }
    protected Version`3(K Key);
    [CompilerGeneratedAttribute]
protected Version`3(Version`3<Actor, K, V> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public K get_Key();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Key(K value);
    public abstract virtual Version`3<Actor, K, V> Write(Actor actor, long timeStamp, V value);
    public Version`3<Actor, K, V> Write(Actor actor, V value);
    public abstract virtual Version`3<Actor, K, V> Delete(Actor actor, long timeStamp);
    public Version`3<Actor, K, V> Delete(Actor actor);
    public abstract virtual Option`1<V> get_Value();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Version`3<Actor, K, V> left, Version`3<Actor, K, V> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Version`3<Actor, K, V> left, Version`3<Actor, K, V> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Version`3<Actor, K, V> other);
    [CompilerGeneratedAttribute]
public abstract virtual Version`3<Actor, K, V> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(K& Key);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class LanguageExt.VersionDeletedVector`5 : VersionNone`3<Actor, K, V> {
    [CompilerGeneratedAttribute]
private VersionVector`6<ConflictV, OrdActor, TLong, Actor, long, V> <Vector>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public VersionVector`6<ConflictV, OrdActor, TLong, Actor, long, V> Vector { get; public set; }
    public VersionDeletedVector`5(K Key, VersionVector`6<ConflictV, OrdActor, TLong, Actor, long, V> Vector);
    [CompilerGeneratedAttribute]
protected VersionDeletedVector`5(VersionDeletedVector`5<ConflictV, OrdActor, Actor, K, V> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public VersionVector`6<ConflictV, OrdActor, TLong, Actor, long, V> get_Vector();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Vector(VersionVector`6<ConflictV, OrdActor, TLong, Actor, long, V> value);
    public virtual Version`3<Actor, K, V> Write(Actor actor, long timeStamp, V value);
    public virtual Version`3<Actor, K, V> Delete(Actor actor, long timeStamp);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(VersionDeletedVector`5<ConflictV, OrdActor, Actor, K, V> left, VersionDeletedVector`5<ConflictV, OrdActor, Actor, K, V> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(VersionDeletedVector`5<ConflictV, OrdActor, Actor, K, V> left, VersionDeletedVector`5<ConflictV, OrdActor, Actor, K, V> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(VersionNone`3<Actor, K, V> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(VersionDeletedVector`5<ConflictV, OrdActor, Actor, K, V> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override VersionDeletedVector`5<ConflictV, OrdActor, Actor, K, V> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(K& Key, VersionVector`6& Vector);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class LanguageExt.VersionHashMap`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private VersionHashMap`6<LastWriteWins`1<V>, TString, EqDefault`1<K>, string, K, V> Items;
    public static VersionHashMap`2<K, V> Empty { get; }
    [PureAttribute]
public Version`3<string, K, V> Item { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public int Length { get; }
    [PureAttribute]
public Iterable`1<K> Keys { get; }
    [PureAttribute]
public Iterable`1<V> Values { get; }
    private VersionHashMap`2(VersionHashMap`6<LastWriteWins`1<V>, TString, EqDefault`1<K>, string, K, V> items);
    public static VersionHashMap`2<K, V> get_Empty();
    public Version`3<string, K, V> get_Item(K key);
    public bool get_IsEmpty();
    public int get_Count();
    public int get_Length();
    public Unit SwapKey(K key, Func`2<Version`3<string, K, V>, Version`3<string, K, V>> swap);
    public Unit Update(Version`3<string, K, V> version);
    public Unit RemoveOlderThan(DateTime cutoff);
    public Unit RemoveOlderThan(long timeStamp);
    public Unit RemoveDeletedItemsOlderThan(DateTime cutoff);
    public Unit RemoveDeletedItemsOlderThan(long timeStamp);
    [PureAttribute]
public Option`1<V> Find(K value);
    [PureAttribute]
public Version`3<string, K, V> FindVersion(K value);
    public Iterable`1<K> get_Keys();
    public Iterable`1<V> get_Values();
    [PureAttribute]
public HashMap`2<K, V> ToHashMap();
    public sealed virtual IEnumerator`1<ValueTuple`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public Seq`1<ValueTuple`2<K, V>> ToSeq();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToFullString(string separator);
    [PureAttribute]
public string ToFullArrayString(string separator);
    [PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> AsIterable();
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsSubsetOf(HashMap`2<K, V> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<K> rhs);
    public Unit Intersect(IEnumerable`1<K> rhs);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<K> other);
    public Unit Except(IEnumerable`1<K> rhs);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public sealed virtual bool Equals(VersionHashMap`2<K, V> other);
    [PureAttribute]
public virtual int GetHashCode();
    [PureAttribute]
public VersionHashMap`2<K, V> Where(Func`3<long, Option`1<V>, bool> pred);
    [PureAttribute]
public VersionHashMap`2<K, V> Where(Func`4<K, long, Option`1<V>, bool> pred);
    [PureAttribute]
public VersionHashMap`2<K, V> Filter(Func`3<long, Option`1<V>, bool> pred);
    [PureAttribute]
public VersionHashMap`2<K, V> Filter(Func`4<K, long, Option`1<V>, bool> pred);
    public Unit FilterInPlace(Func`3<long, Option`1<V>, bool> pred);
    public Unit FilterInPlace(Func`4<K, long, Option`1<V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<KeyValuePair`2<K, V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<V, bool> pred);
    [PureAttribute]
public bool Exists(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<V, bool> pred);
    public Unit Iter(Action`2<K, V> action);
    public Unit Iter(Action`1<V> action);
    public Unit Iter(Action`1<ValueTuple`2<K, V>> action);
    public Unit Iter(Action`1<KeyValuePair`2<K, V>> action);
    [PureAttribute]
public S Fold(S state, Func`4<S, K, V, S> folder);
    [PureAttribute]
public S Fold(S state, Func`3<S, V, S> folder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class LanguageExt.VersionHashMap`3 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private VersionHashMap`6<ConflictV, TString, EqDefault`1<K>, string, K, V> Items;
    public static VersionHashMap`3<ConflictV, K, V> Empty { get; }
    [PureAttribute]
public Version`3<string, K, V> Item { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public int Length { get; }
    [PureAttribute]
public Iterable`1<K> Keys { get; }
    [PureAttribute]
public Iterable`1<V> Values { get; }
    private VersionHashMap`3(VersionHashMap`6<ConflictV, TString, EqDefault`1<K>, string, K, V> items);
    public static VersionHashMap`3<ConflictV, K, V> get_Empty();
    public Version`3<string, K, V> get_Item(K key);
    public bool get_IsEmpty();
    public int get_Count();
    public int get_Length();
    public Unit SwapKey(K key, Func`2<Version`3<string, K, V>, Version`3<string, K, V>> swap);
    public Unit Update(Version`3<string, K, V> version);
    public Unit RemoveOlderThan(DateTime cutoff);
    public Unit RemoveOlderThan(long timeStamp);
    public Unit RemoveDeletedItemsOlderThan(DateTime cutoff);
    public Unit RemoveDeletedItemsOlderThan(long timeStamp);
    [PureAttribute]
public Option`1<V> Find(K value);
    [PureAttribute]
public Version`3<string, K, V> FindVersion(K value);
    public Iterable`1<K> get_Keys();
    public Iterable`1<V> get_Values();
    [PureAttribute]
public HashMap`2<K, V> ToHashMap();
    public sealed virtual IEnumerator`1<ValueTuple`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public Seq`1<ValueTuple`2<K, V>> ToSeq();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToFullString(string separator);
    [PureAttribute]
public string ToFullArrayString(string separator);
    [PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> AsIterable();
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsSubsetOf(HashMap`2<K, V> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<K> rhs);
    public Unit Intersect(IEnumerable`1<K> rhs);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<K> other);
    public Unit Except(IEnumerable`1<K> rhs);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public sealed virtual bool Equals(VersionHashMap`3<ConflictV, K, V> other);
    [PureAttribute]
public virtual int GetHashCode();
    [PureAttribute]
public VersionHashMap`3<ConflictV, K, V> Where(Func`3<long, Option`1<V>, bool> pred);
    [PureAttribute]
public VersionHashMap`3<ConflictV, K, V> Where(Func`4<K, long, Option`1<V>, bool> pred);
    [PureAttribute]
public VersionHashMap`3<ConflictV, K, V> Filter(Func`3<long, Option`1<V>, bool> pred);
    [PureAttribute]
public VersionHashMap`3<ConflictV, K, V> Filter(Func`4<K, long, Option`1<V>, bool> pred);
    public Unit FilterInPlace(Func`3<long, Option`1<V>, bool> pred);
    public Unit FilterInPlace(Func`4<K, long, Option`1<V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<KeyValuePair`2<K, V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<V, bool> pred);
    [PureAttribute]
public bool Exists(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<V, bool> pred);
    public Unit Iter(Action`2<K, V> action);
    public Unit Iter(Action`1<V> action);
    public Unit Iter(Action`1<ValueTuple`2<K, V>> action);
    public Unit Iter(Action`1<KeyValuePair`2<K, V>> action);
    [PureAttribute]
public S Fold(S state, Func`4<S, K, V, S> folder);
    [PureAttribute]
public S Fold(S state, Func`3<S, V, S> folder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class LanguageExt.VersionHashMap`6 : object {
    internal TrieMap`3 modreq(System.Runtime.CompilerServices.IsVolatile) Items;
    public static VersionHashMap`6<ConflictV, OrdActor, EqK, Actor, K, V> Empty { get; }
    [PureAttribute]
public Version`3<Actor, K, V> Item { get; }
    [PureAttribute]
public bool IsEmpty { get; }
    [PureAttribute]
public int Count { get; }
    [PureAttribute]
public int Length { get; }
    [PureAttribute]
public Iterable`1<K> Keys { get; }
    [PureAttribute]
public Iterable`1<V> Values { get; }
    private VersionHashMap`6(TrieMap`3<EqK, K, VersionVector`6<ConflictV, OrdActor, TLong, Actor, long, V>> items);
    public static VersionHashMap`6<ConflictV, OrdActor, EqK, Actor, K, V> get_Empty();
    public Version`3<Actor, K, V> get_Item(K key);
    public bool get_IsEmpty();
    public int get_Count();
    public int get_Length();
    public Unit SwapKey(K key, Func`2<Version`3<Actor, K, V>, Version`3<Actor, K, V>> swap);
    public Unit Update(Version`3<Actor, K, V> nversion);
    public Unit RemoveOlderThan(DateTime cutoff);
    public Unit RemoveOlderThan(long timeStamp);
    public Unit RemoveDeletedItemsOlderThan(DateTime cutoff);
    public Unit RemoveDeletedItemsOlderThan(long timeStamp);
    [PureAttribute]
public Option`1<V> Find(K value);
    [PureAttribute]
public Version`3<Actor, K, V> FindVersion(K key);
    public Iterable`1<K> get_Keys();
    public Iterable`1<V> get_Values();
    [PureAttribute]
public HashMap`2<K, V> ToHashMap();
    public sealed virtual IEnumerator`1<ValueTuple`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [PureAttribute]
public Seq`1<ValueTuple`2<K, V>> ToSeq();
    [PureAttribute]
public virtual string ToString();
    [PureAttribute]
public string ToFullString(string separator);
    [PureAttribute]
public string ToFullArrayString(string separator);
    [PureAttribute]
public Iterable`1<ValueTuple`2<K, V>> AsIterable();
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsProperSubsetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsProperSupersetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsSubsetOf(IEnumerable`1<K> other);
    [PureAttribute]
public bool IsSubsetOf(HashMap`2<K, V> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool IsSupersetOf(IEnumerable`1<K> rhs);
    public Unit Intersect(IEnumerable`1<K> rhs);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<ValueTuple`2<K, V>> other);
    [PureAttribute]
public bool Overlaps(IEnumerable`1<K> other);
    public Unit Except(IEnumerable`1<K> rhs);
    [NullableContextAttribute("2")]
[PureAttribute]
public virtual bool Equals(object obj);
    [PureAttribute]
public sealed virtual bool Equals(VersionHashMap`6<ConflictV, OrdActor, EqK, Actor, K, V> other);
    [PureAttribute]
public virtual int GetHashCode();
    [PureAttribute]
public VersionHashMap`6<ConflictV, OrdActor, EqK, Actor, K, V> Where(Func`3<long, Option`1<V>, bool> pred);
    [PureAttribute]
public VersionHashMap`6<ConflictV, OrdActor, EqK, Actor, K, V> Where(Func`4<K, long, Option`1<V>, bool> pred);
    [PureAttribute]
public VersionHashMap`6<ConflictV, OrdActor, EqK, Actor, K, V> Filter(Func`3<long, Option`1<V>, bool> pred);
    [PureAttribute]
public VersionHashMap`6<ConflictV, OrdActor, EqK, Actor, K, V> Filter(Func`4<K, long, Option`1<V>, bool> pred);
    public Unit FilterInPlace(Func`3<long, Option`1<V>, bool> pred);
    public Unit FilterInPlace(Func`4<K, long, Option`1<V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<KeyValuePair`2<K, V>, bool> pred);
    [PureAttribute]
public bool ForAll(Func`2<V, bool> pred);
    [PureAttribute]
public bool Exists(Func`3<K, V, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<ValueTuple`2<K, V>, bool> pred);
    [PureAttribute]
public bool Exists(Func`2<V, bool> pred);
    public Unit Iter(Action`2<K, V> action);
    public Unit Iter(Action`1<V> action);
    public Unit Iter(Action`1<ValueTuple`2<K, V>> action);
    public Unit Iter(Action`1<KeyValuePair`2<K, V>> action);
    [PureAttribute]
public S Fold(S state, Func`4<S, K, V, S> folder);
    [PureAttribute]
public S Fold(S state, Func`3<S, V, S> folder);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class LanguageExt.VersionNeverExistedVector`5 : VersionNone`3<Actor, K, V> {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public VersionNeverExistedVector`5(K Key);
    [CompilerGeneratedAttribute]
protected VersionNeverExistedVector`5(VersionNeverExistedVector`5<ConflictV, OrdActor, Actor, K, V> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public static Version`3<Actor, K, V> New(K key);
    public virtual Version`3<Actor, K, V> Write(Actor actor, long timeStamp, V value);
    public virtual Version`3<Actor, K, V> Delete(Actor actor, long timeStamp);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(VersionNeverExistedVector`5<ConflictV, OrdActor, Actor, K, V> left, VersionNeverExistedVector`5<ConflictV, OrdActor, Actor, K, V> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(VersionNeverExistedVector`5<ConflictV, OrdActor, Actor, K, V> left, VersionNeverExistedVector`5<ConflictV, OrdActor, Actor, K, V> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(VersionNone`3<Actor, K, V> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(VersionNeverExistedVector`5<ConflictV, OrdActor, Actor, K, V> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override VersionNeverExistedVector`5<ConflictV, OrdActor, Actor, K, V> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(K& Key);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class LanguageExt.VersionNone`3 : Version`3<Actor, K, V> {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Option`1<V> Value { get; }
    protected VersionNone`3(K Key);
    [CompilerGeneratedAttribute]
protected VersionNone`3(VersionNone`3<Actor, K, V> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual Option`1<V> get_Value();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(VersionNone`3<Actor, K, V> left, VersionNone`3<Actor, K, V> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(VersionNone`3<Actor, K, V> left, VersionNone`3<Actor, K, V> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Version`3<Actor, K, V> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(VersionNone`3<Actor, K, V> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public abstract virtual override VersionNone`3<Actor, K, V> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(K& Key);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class LanguageExt.VersionSome`3 : Version`3<Actor, K, V> {
    [CompilerGeneratedAttribute]
private V <value>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public V value { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Option`1<V> Value { get; }
    protected VersionSome`3(K Key, V value);
    [CompilerGeneratedAttribute]
protected VersionSome`3(VersionSome`3<Actor, K, V> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public V get_value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_value(V value);
    public virtual Option`1<V> get_Value();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(VersionSome`3<Actor, K, V> left, VersionSome`3<Actor, K, V> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(VersionSome`3<Actor, K, V> left, VersionSome`3<Actor, K, V> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(Version`3<Actor, K, V> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(VersionSome`3<Actor, K, V> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public abstract virtual override VersionSome`3<Actor, K, V> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(K& Key, V& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class LanguageExt.VersionValueVector`5 : VersionSome`3<Actor, K, V> {
    [CompilerGeneratedAttribute]
private VersionVector`6<ConflictV, OrdActor, TLong, Actor, long, V> <Vector>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public VersionVector`6<ConflictV, OrdActor, TLong, Actor, long, V> Vector { get; public set; }
    public VersionValueVector`5(K Key, VersionVector`6<ConflictV, OrdActor, TLong, Actor, long, V> Vector);
    [CompilerGeneratedAttribute]
protected VersionValueVector`5(VersionValueVector`5<ConflictV, OrdActor, Actor, K, V> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public VersionVector`6<ConflictV, OrdActor, TLong, Actor, long, V> get_Vector();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Vector(VersionVector`6<ConflictV, OrdActor, TLong, Actor, long, V> value);
    public virtual Version`3<Actor, K, V> Write(Actor actor, long timeStamp, V value);
    public virtual Version`3<Actor, K, V> Delete(Actor actor, long timeStamp);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(VersionValueVector`5<ConflictV, OrdActor, Actor, K, V> left, VersionValueVector`5<ConflictV, OrdActor, Actor, K, V> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(VersionValueVector`5<ConflictV, OrdActor, Actor, K, V> left, VersionValueVector`5<ConflictV, OrdActor, Actor, K, V> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(VersionSome`3<Actor, K, V> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(VersionValueVector`5<ConflictV, OrdActor, Actor, K, V> other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override VersionValueVector`5<ConflictV, OrdActor, Actor, K, V> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(K& Key, VersionVector`6& Vector);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.VersionVector`3 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Option`1<A> <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private VectorClock`1<Actor> <Vector>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Option`1<A> Value { get; public set; }
    public long TimeStamp { get; public set; }
    public VectorClock`1<Actor> Vector { get; public set; }
    public VersionVector`3(Option`1<A> Value, long TimeStamp, VectorClock`1<Actor> Vector);
    [CompilerGeneratedAttribute]
protected VersionVector`3(VersionVector`3<ConflictA, Actor, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Option`1<A> get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(Option`1<A> value);
    [CompilerGeneratedAttribute]
public long get_TimeStamp();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TimeStamp(long value);
    [CompilerGeneratedAttribute]
public VectorClock`1<Actor> get_Vector();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Vector(VectorClock`1<Actor> value);
    public VersionVector`3<ConflictA, Actor, A> Put(VersionVector`3<ConflictA, Actor, A> version);
    private VersionVector`3<ConflictA, Actor, A> ResolveConflict(VersionVector`3<ConflictA, Actor, A> version);
    public VersionVector`3<ConflictA, Actor, A> Put(Actor actor, long timeStamp, Option`1<A> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(VersionVector`3<ConflictA, Actor, A> left, VersionVector`3<ConflictA, Actor, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(VersionVector`3<ConflictA, Actor, A> left, VersionVector`3<ConflictA, Actor, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(VersionVector`3<ConflictA, Actor, A> other);
    [CompilerGeneratedAttribute]
public virtual VersionVector`3<ConflictA, Actor, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Option`1& Value, Int64& TimeStamp, VectorClock`1& Vector);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.VersionVector`6 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Option`1<A> <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TimeStamp>k__BackingField;
    [CompilerGeneratedAttribute]
private VectorClock`4<OrdActor, NumClock, Actor, Clock> <Vector>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Option`1<A> Value { get; public set; }
    public long TimeStamp { get; public set; }
    public VectorClock`4<OrdActor, NumClock, Actor, Clock> Vector { get; public set; }
    public VersionVector`6(Option`1<A> Value, long TimeStamp, VectorClock`4<OrdActor, NumClock, Actor, Clock> Vector);
    [CompilerGeneratedAttribute]
protected VersionVector`6(VersionVector`6<ConflictA, OrdActor, NumClock, Actor, Clock, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Option`1<A> get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(Option`1<A> value);
    [CompilerGeneratedAttribute]
public long get_TimeStamp();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TimeStamp(long value);
    [CompilerGeneratedAttribute]
public VectorClock`4<OrdActor, NumClock, Actor, Clock> get_Vector();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Vector(VectorClock`4<OrdActor, NumClock, Actor, Clock> value);
    public VersionVector`6<ConflictA, OrdActor, NumClock, Actor, Clock, A> Put(VersionVector`6<ConflictA, OrdActor, NumClock, Actor, Clock, A> version);
    private VersionVector`6<ConflictA, OrdActor, NumClock, Actor, Clock, A> ResolveConflict(VersionVector`6<ConflictA, OrdActor, NumClock, Actor, Clock, A> version);
    public VersionVector`6<ConflictA, OrdActor, NumClock, Actor, Clock, A> Put(Actor actor, long timeStamp, Option`1<A> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(VersionVector`6<ConflictA, OrdActor, NumClock, Actor, Clock, A> left, VersionVector`6<ConflictA, OrdActor, NumClock, Actor, Clock, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(VersionVector`6<ConflictA, OrdActor, NumClock, Actor, Clock, A> left, VersionVector`6<ConflictA, OrdActor, NumClock, Actor, Clock, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(VersionVector`6<ConflictA, OrdActor, NumClock, Actor, Clock, A> other);
    [CompilerGeneratedAttribute]
public virtual VersionVector`6<ConflictA, OrdActor, NumClock, Actor, Clock, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Option`1& Value, Int64& TimeStamp, VectorClock`4& Vector);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.WaitAsync : object {
    [AsyncStateMachineAttribute("LanguageExt.WaitAsync/<WaitAll>d__0`2")]
public static ValueTask`1<ValueTuple`2<A, B>> WaitAll(ValueTask`1<A> va, ValueTask`1<B> vb);
    [AsyncStateMachineAttribute("LanguageExt.WaitAsync/<WaitAll>d__1`3")]
public static ValueTask`1<ValueTuple`3<A, B, C>> WaitAll(ValueTask`1<A> va, ValueTask`1<B> vb, ValueTask`1<C> vc);
    [AsyncStateMachineAttribute("LanguageExt.WaitAsync/<WaitAll>d__2`4")]
public static ValueTask`1<ValueTuple`4<A, B, C, D>> WaitAll(ValueTask`1<A> va, ValueTask`1<B> vb, ValueTask`1<C> vc, ValueTask`1<D> vd);
    [AsyncStateMachineAttribute("LanguageExt.WaitAsync/<WaitAll>d__3`5")]
public static ValueTask`1<ValueTuple`5<A, B, C, D, E>> WaitAll(ValueTask`1<A> va, ValueTask`1<B> vb, ValueTask`1<C> vc, ValueTask`1<D> vd, ValueTask`1<E> ve);
    [AsyncStateMachineAttribute("LanguageExt.WaitAsync/<WaitAll>d__4`6")]
public static ValueTask`1<ValueTuple`6<A, B, C, D, E, F>> WaitAll(ValueTask`1<A> va, ValueTask`1<B> vb, ValueTask`1<C> vc, ValueTask`1<D> vd, ValueTask`1<E> ve, ValueTask`1<F> vf);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("LanguageExt.WaitAsync/<WaitOneAsync>d__5")]
[ExtensionAttribute]
public static Task`1<bool> WaitOneAsync(WaitHandle handle, int millisecondsTimeout, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Task`1<bool> WaitOneAsync(WaitHandle handle, TimeSpan timeout, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Task`1<bool> WaitOneAsync(WaitHandle handle, CancellationToken cancellationToken);
}
public class LanguageExt.WhenMatched`4 : MulticastDelegate {
    public WhenMatched`4(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual C Invoke(K key, A left, B right);
    public virtual IAsyncResult BeginInvoke(K key, A left, B right, AsyncCallback callback, object object);
    public virtual C EndInvoke(IAsyncResult result);
}
public class LanguageExt.WhenMissing`3 : MulticastDelegate {
    public WhenMissing`3(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual B Invoke(K key, A value);
    public virtual IAsyncResult BeginInvoke(K key, A value, AsyncCallback callback, object object);
    public virtual B EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.WritableExtensions : object {
    [ExtensionAttribute]
public static Writer`2<W, A> As(K`2<Writer`1<W>, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static Writer`2<W, A> Flatten(Writer`2<W, Writer`2<W, A>> mma);
    [ExtensionAttribute]
public static K`2<M, A> Pass(K`2<M, ValueTuple`2<A, Func`2<W, W>>> action);
    [ExtensionAttribute]
public static K`2<M, ValueTuple`2<A, B>> Listens(Func`2<W, B> f, K`2<M, A> ma);
    [ExtensionAttribute]
public static K`2<M, ValueTuple`2<A, B>> Listens(K`2<M, A> ma, Func`2<W, B> f);
    [ExtensionAttribute]
public static K`2<M, A> Censor(K`2<M, A> ma, Func`2<W, W> f);
    [ExtensionAttribute]
public static K`2<M, A> Censor(Func`2<W, W> f, K`2<M, A> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Writer : object {
    public static Writer`2<W, A> Pure(A value);
    public static Writer`2<W, B> bind(Writer`2<W, A> ma, Func`2<A, Writer`2<W, B>> f);
    public static Writer`2<W, B> map(Func`2<A, B> f, Writer`2<W, A> ma);
    public static Writer`2<W, B> apply(Writer`2<W, Func`2<A, B>> mf, Writer`2<W, A> ma);
    public static Writer`2<W, B> action(Writer`2<W, A> ma, Writer`2<W, B> mb);
    public static Writer`2<W, Unit> tell(W item);
    public static Writer`2<W, A> write(ValueTuple`2<A, W> item);
    public static Writer`2<W, A> write(A value, W item);
    public static Writer`2<W, A> pass(Writer`2<W, ValueTuple`2<A, Func`2<W, W>>> action);
    public static Writer`2<W, ValueTuple`2<A, W>> listen(Writer`2<W, A> ma);
    public static Writer`2<W, ValueTuple`2<A, B>> listens(Func`2<W, B> f, Writer`2<W, A> ma);
    public static Writer`2<W, A> censor(Func`2<W, W> f, Writer`2<W, A> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Writer`1 : object {
    public static Writer`2<W, A> Pure(A value);
    private static override K`2<Writer`1<W>, B> LanguageExt.Traits.Monad<LanguageExt.Writer<W>>.Bind(K`2<Writer`1<W>, A> ma, Func`2<A, K`2<Writer`1<W>, B>> f);
    private static override K`2<Writer`1<W>, B> LanguageExt.Traits.Functor<LanguageExt.Writer<W>>.Map(Func`2<A, B> f, K`2<Writer`1<W>, A> ma);
    private static override K`2<Writer`1<W>, A> LanguageExt.Traits.Applicative<LanguageExt.Writer<W>>.Pure(A value);
    private static override K`2<Writer`1<W>, B> LanguageExt.Traits.Applicative<LanguageExt.Writer<W>>.Apply(K`2<Writer`1<W>, Func`2<A, B>> mf, K`2<Writer`1<W>, A> ma);
    private static override K`2<Writer`1<W>, B> LanguageExt.Traits.Applicative<LanguageExt.Writer<W>>.Action(K`2<Writer`1<W>, A> ma, K`2<Writer`1<W>, B> mb);
    private static override K`2<Writer`1<W>, Unit> LanguageExt.Traits.Writable<LanguageExt.Writer<W>,W>.Tell(W item);
    private static override K`2<Writer`1<W>, ValueTuple`2<A, W>> LanguageExt.Traits.Writable<LanguageExt.Writer<W>,W>.Listen(K`2<Writer`1<W>, A> ma);
    private static override K`2<Writer`1<W>, A> LanguageExt.Traits.Writable<LanguageExt.Writer<W>,W>.Pass(K`2<Writer`1<W>, ValueTuple`2<A, Func`2<W, W>>> action);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.Writer`2 : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<W, ValueTuple`2<A, W>> <runWriter>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<W, ValueTuple`2<A, W>> runWriter { get; public set; }
    public Writer`2(Func`2<W, ValueTuple`2<A, W>> runWriter);
    [CompilerGeneratedAttribute]
protected Writer`2(Writer`2<W, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Func`2<W, ValueTuple`2<A, W>> get_runWriter();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_runWriter(Func`2<W, ValueTuple`2<A, W>> value);
    public static Writer`2<W, A> Pure(A value);
    public Writer`2<W, A> Write(ValueTuple`2<A, W> result);
    public Writer`2<W, A> Write(A value, W output);
    public Writer`2<W, ValueTuple`2<A, W>> Listen();
    public Writer`2<W, ValueTuple`2<A, B>> Listens(Func`2<W, B> f);
    public Writer`2<W, A> Censor(Func`2<W, W> f);
    public static Writer`2<W, A> Lift(Pure`1<A> monad);
    public static Writer`2<W, A> Lift(Func`1<A> f);
    public Writer`2<W, B> Map(Func`2<A, B> f);
    public Writer`2<W, B> Select(Func`2<A, B> f);
    public Writer`2<W, B> Bind(Func`2<A, K`2<Writer`1<W>, B>> f);
    public Writer`2<W, B> Bind(Func`2<A, Writer`2<W, B>> f);
    public Writer`2<W, Unit> Bind(Func`2<A, Tell`1<W>> f);
    public Writer`2<W, C> SelectMany(Func`2<A, K`2<Writer`1<W>, B>> bind, Func`3<A, B, C> project);
    public Writer`2<W, C> SelectMany(Func`2<A, Writer`2<W, B>> bind, Func`3<A, B, C> project);
    public Writer`2<W, C> SelectMany(Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    public Writer`2<W, C> SelectMany(Func`2<A, Tell`1<W>> bind, Func`3<A, Unit, C> project);
    public static Writer`2<W, A> op_RightShift(Writer`2<W, A> lhs, Writer`2<W, A> rhs);
    public static Writer`2<W, A> op_RightShift(Writer`2<W, A> lhs, K`2<Writer`1<W>, A> rhs);
    public static Writer`2<W, A> op_RightShift(Writer`2<W, A> lhs, Writer`2<W, Unit> rhs);
    public static Writer`2<W, A> op_RightShift(Writer`2<W, A> lhs, K`2<Writer`1<W>, Unit> rhs);
    public static Writer`2<W, A> op_Implicit(Pure`1<A> ma);
    public ValueTuple`2<A, W> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(Writer`2<W, A> left, Writer`2<W, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(Writer`2<W, A> left, Writer`2<W, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(Writer`2<W, A> other);
    [CompilerGeneratedAttribute]
public virtual Writer`2<W, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`2& runWriter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.WriterT : object {
    public static WriterT`3<W, M, B> bind(WriterT`3<W, M, A> ma, Func`2<A, WriterT`3<W, M, B>> f);
    public static WriterT`3<W, M, B> map(Func`2<A, B> f, WriterT`3<W, M, A> ma);
    public static WriterT`3<W, M, A> Pure(A value);
    public static WriterT`3<W, M, B> apply(WriterT`3<W, M, Func`2<A, B>> mf, WriterT`3<W, M, A> ma);
    public static WriterT`3<W, M, B> action(WriterT`3<W, M, A> ma, WriterT`3<W, M, B> mb);
    public static WriterT`3<W, M, A> lift(K`2<M, A> ma);
    public static WriterT`3<W, M, A> liftIO(IO`1<A> effect);
    public static WriterT`3<W, M, Unit> tell(W item);
    public static WriterT`3<W, M, A> write(ValueTuple`2<A, W> item);
    public static WriterT`3<W, M, A> write(A value, W item);
    public static WriterT`3<W, M, A> pass(WriterT`3<W, M, ValueTuple`2<A, Func`2<W, W>>> action);
    public static WriterT`3<W, M, ValueTuple`2<A, W>> listen(WriterT`3<W, M, A> ma);
    public static WriterT`3<W, M, ValueTuple`2<A, B>> listens(Func`2<W, B> f, WriterT`3<W, M, A> ma);
    public static WriterT`3<W, M, A> censor(Func`2<W, W> f, WriterT`3<W, M, A> ma);
}
public class LanguageExt.WriterT`1 : object {
    [NullableContextAttribute("1")]
public static WriterT`3<W, M, A> lift(K`2<M, A> ma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.WriterT`2 : object {
    public static WriterT`3<W, M, A> Pure(A value);
    public static WriterT`3<W, M, A> liftIO(IO`1<A> effect);
    private static override K`2<WriterT`2<W, M>, B> LanguageExt.Traits.Monad<LanguageExt.WriterT<W,M>>.Bind(K`2<WriterT`2<W, M>, A> ma, Func`2<A, K`2<WriterT`2<W, M>, B>> f);
    private static override K`2<WriterT`2<W, M>, B> LanguageExt.Traits.Functor<LanguageExt.WriterT<W,M>>.Map(Func`2<A, B> f, K`2<WriterT`2<W, M>, A> ma);
    private static override K`2<WriterT`2<W, M>, A> LanguageExt.Traits.Applicative<LanguageExt.WriterT<W,M>>.Pure(A value);
    private static override K`2<WriterT`2<W, M>, B> LanguageExt.Traits.Applicative<LanguageExt.WriterT<W,M>>.Apply(K`2<WriterT`2<W, M>, Func`2<A, B>> mf, K`2<WriterT`2<W, M>, A> ma);
    private static override K`2<WriterT`2<W, M>, B> LanguageExt.Traits.Applicative<LanguageExt.WriterT<W,M>>.Action(K`2<WriterT`2<W, M>, A> ma, K`2<WriterT`2<W, M>, B> mb);
    private static override K`2<WriterT`2<W, M>, A> LanguageExt.Traits.MonadT<LanguageExt.WriterT<W,M>,M>.Lift(K`2<M, A> ma);
    private static override K`2<WriterT`2<W, M>, A> LanguageExt.Traits.MonadIO<LanguageExt.WriterT<W,M>>.LiftIO(IO`1<A> ma);
    private static override K`2<WriterT`2<W, M>, A> LanguageExt.Traits.SemigroupK<LanguageExt.WriterT<W,M>>.Combine(K`2<WriterT`2<W, M>, A> ma, K`2<WriterT`2<W, M>, A> mb);
    private static override K`2<WriterT`2<W, M>, Unit> LanguageExt.Traits.Writable<LanguageExt.WriterT<W,M>,W>.Tell(W item);
    private static override K`2<WriterT`2<W, M>, ValueTuple`2<A, W>> LanguageExt.Traits.Writable<LanguageExt.WriterT<W,M>,W>.Listen(K`2<WriterT`2<W, M>, A> ma);
    private static override K`2<WriterT`2<W, M>, A> LanguageExt.Traits.Writable<LanguageExt.WriterT<W,M>,W>.Pass(K`2<WriterT`2<W, M>, ValueTuple`2<A, Func`2<W, W>>> action);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class LanguageExt.WriterT`3 : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<W, K`2<M, ValueTuple`2<A, W>>> <runWriter>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<W, K`2<M, ValueTuple`2<A, W>>> runWriter { get; public set; }
    public WriterT`3(Func`2<W, K`2<M, ValueTuple`2<A, W>>> runWriter);
    [CompilerGeneratedAttribute]
protected WriterT`3(WriterT`3<W, M, A> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Func`2<W, K`2<M, ValueTuple`2<A, W>>> get_runWriter();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_runWriter(Func`2<W, K`2<M, ValueTuple`2<A, W>>> value);
    public static WriterT`3<W, M, A> Pure(A value);
    public WriterT`3<W, M, A> Write(ValueTuple`2<A, W> result);
    public WriterT`3<W, M, A> Write(A value, W output);
    public WriterT`3<W, M, ValueTuple`2<A, W>> Listen();
    public WriterT`3<W, M, ValueTuple`2<A, B>> Listens(Func`2<W, B> f);
    public WriterT`3<W, M, A> Censor(Func`2<W, W> f);
    public static WriterT`3<W, M, A> Lift(Pure`1<A> monad);
    public static WriterT`3<W, M, A> Lift(K`2<M, A> monad);
    public static WriterT`3<W, M, A> Lift(Func`1<A> f);
    public static WriterT`3<W, M, A> LiftIO(IO`1<A> ma);
    public WriterT`3<W, M1, B> MapT(Func`2<K`2<M, ValueTuple`2<A, W>>, K`2<M1, ValueTuple`2<B, W>>> f);
    public WriterT`3<W, M, B> MapM(Func`2<K`2<M, A>, K`2<M, B>> f);
    public WriterT`3<W, M, B> Map(Func`2<A, B> f);
    public WriterT`3<W, M, B> Select(Func`2<A, B> f);
    public WriterT`3<W, M, B> Bind(Func`2<A, K`2<WriterT`2<W, M>, B>> f);
    public WriterT`3<W, M, B> Bind(Func`2<A, WriterT`3<W, M, B>> f);
    public WriterT`3<W, M, Unit> Bind(Func`2<A, Tell`1<W>> f);
    public WriterT`3<W, M, B> Bind(Func`2<A, IO`1<B>> f);
    public WriterT`3<W, M, C> SelectMany(Func`2<A, K`2<WriterT`2<W, M>, B>> bind, Func`3<A, B, C> project);
    public WriterT`3<W, M, C> SelectMany(Func`2<A, WriterT`3<W, M, B>> bind, Func`3<A, B, C> project);
    public WriterT`3<W, M, C> SelectMany(Func`2<A, K`2<M, B>> bind, Func`3<A, B, C> project);
    public WriterT`3<W, M, C> SelectMany(Func`2<A, Pure`1<B>> bind, Func`3<A, B, C> project);
    public WriterT`3<W, M, C> SelectMany(Func`2<A, Tell`1<W>> bind, Func`3<A, Unit, C> project);
    public WriterT`3<W, M, C> SelectMany(Func`2<A, IO`1<B>> bind, Func`3<A, B, C> project);
    public static WriterT`3<W, M, A> op_RightShift(WriterT`3<W, M, A> lhs, WriterT`3<W, M, A> rhs);
    public static WriterT`3<W, M, A> op_RightShift(WriterT`3<W, M, A> lhs, K`2<WriterT`2<W, M>, A> rhs);
    public static WriterT`3<W, M, A> op_RightShift(WriterT`3<W, M, A> lhs, WriterT`3<W, M, Unit> rhs);
    public static WriterT`3<W, M, A> op_RightShift(WriterT`3<W, M, A> lhs, K`2<WriterT`2<W, M>, Unit> rhs);
    public static WriterT`3<W, M, A> op_Implicit(Pure`1<A> ma);
    public static WriterT`3<W, M, A> op_Implicit(IO`1<A> ma);
    public static WriterT`3<W, M, A> op_BitwiseOr(WriterT`3<W, M, A> ma, WriterT`3<W, M, A> mb);
    public static WriterT`3<W, M, A> op_BitwiseOr(WriterT`3<W, M, A> ma, Pure`1<A> mb);
    public static WriterT`3<W, M, A> op_BitwiseOr(Pure`1<A> ma, WriterT`3<W, M, A> mb);
    public static WriterT`3<W, M, A> op_BitwiseOr(IO`1<A> ma, WriterT`3<W, M, A> mb);
    public K`2<M, ValueTuple`2<A, W>> Run();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(WriterT`3<W, M, A> left, WriterT`3<W, M, A> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(WriterT`3<W, M, A> left, WriterT`3<W, M, A> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(WriterT`3<W, M, A> other);
    [CompilerGeneratedAttribute]
public virtual WriterT`3<W, M, A> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Func`2& runWriter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class LanguageExt.WriterTExtensions : object {
    [ExtensionAttribute]
public static WriterT`3<W, M, A> As(K`2<WriterT`2<W, M>, A> ma);
    [ExtensionAttribute]
[PureAttribute]
public static WriterT`3<W, M, A> Flatten(WriterT`3<W, M, WriterT`3<W, M, A>> mma);
    [ExtensionAttribute]
public static WriterT`3<W, M, C> SelectMany(K`2<M, A> ma, Func`2<A, K`2<WriterT`2<W, M>, B>> bind, Func`3<A, B, C> project);
    [ExtensionAttribute]
public static WriterT`3<W, M, C> SelectMany(K`2<M, A> ma, Func`2<A, WriterT`3<W, M, B>> bind, Func`3<A, B, C> project);
}
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[IsReadOnlyAttribute]
public class Temperature : ValueType {
    private UnitType Type;
    private double Value;
    public static Temperature AbsoluteZero;
    public static Temperature ZeroCelsius;
    public static Temperature ZeroFahrenheit;
    public Temperature Kelvin { get; }
    public double KValue { get; }
    public Temperature Celsius { get; }
    public Temperature Fahrenheit { get; }
    internal Temperature(UnitType type, double value);
    private static Temperature();
    private static double CtoK(double x);
    private static double KtoC(double x);
    private static double FtoK(double x);
    private static double KtoF(double x);
    private static double CtoF(double x);
    private static double FtoC(double x);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Temperature rhs);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public Temperature get_Kelvin();
    public double get_KValue();
    public Temperature get_Celsius();
    public Temperature get_Fahrenheit();
    public bool Equals(Temperature rhs, double epsilon);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Temperature rhs);
    public Temperature Add(Temperature rhs);
    public Temperature Subtract(Temperature rhs);
    public Temperature Multiply(double rhs);
    public Temperature Divide(double rhs);
    public static Temperature op_Multiply(Temperature lhs, double rhs);
    public static Temperature op_Multiply(double lhs, Temperature rhs);
    public static Temperature op_Addition(Temperature lhs, Temperature rhs);
    public static Temperature op_Subtraction(Temperature lhs, Temperature rhs);
    public static Temperature op_Division(Temperature lhs, double rhs);
    public static bool op_Equality(Temperature lhs, Temperature rhs);
    public static bool op_Inequality(Temperature lhs, Temperature rhs);
    public static bool op_GreaterThan(Temperature lhs, Temperature rhs);
    public static bool op_LessThan(Temperature lhs, Temperature rhs);
    public static bool op_GreaterThanOrEqual(Temperature lhs, Temperature rhs);
    public static bool op_LessThanOrEqual(Temperature lhs, Temperature rhs);
    public Temperature Round();
    public Temperature Abs();
    public Temperature Min(Temperature rhs);
    public Temperature Max(Temperature rhs);
}
[ExtensionAttribute]
public static class UnitsTemperatureExtensions : object {
    [ExtensionAttribute]
public static Temperature Celsius(int self);
    [ExtensionAttribute]
public static Temperature Celsius(float self);
    [ExtensionAttribute]
public static Temperature Celsius(double self);
    [ExtensionAttribute]
public static Temperature Fahrenheit(int self);
    [ExtensionAttribute]
public static Temperature Fahrenheit(float self);
    [ExtensionAttribute]
public static Temperature Fahrenheit(double self);
    [ExtensionAttribute]
public static Temperature Kelvin(int self);
    [ExtensionAttribute]
public static Temperature Kelvin(float self);
    [ExtensionAttribute]
public static Temperature Kelvin(double self);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ValueTuple1Extensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTuple`2<A, B> Add(ValueTuple`1<A> self, B second);
    [ExtensionAttribute]
[PureAttribute]
public static bool Contains(ValueTuple`1<A> self, A value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTuple`1<R> Map(ValueTuple`1<A> self, Func`2<A, R> map);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[PureAttribute]
public static ValueTuple`1<R> Select(ValueTuple`1<A> self, Func`2<A, R> map);
    [ExtensionAttribute]
public static Unit Iter(ValueTuple`1<A> self, Action`1<A> func);
    [ExtensionAttribute]
[PureAttribute]
public static S Fold(ValueTuple`1<A> self, S state, Func`3<S, A, S> fold);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ValueTuple2Extensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`3<A, B, C> Add(ValueTuple`2<A, B> self, C third);
    [ExtensionAttribute]
[PureAttribute]
public static T1 Head(ValueTuple`2<T1, T2> self);
    [ExtensionAttribute]
[PureAttribute]
public static T2 Last(ValueTuple`2<T1, T2> self);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`1<T2> Tail(ValueTuple`2<T1, T2> self);
    [ExtensionAttribute]
[PureAttribute]
public static R Map(ValueTuple`2<A, B> self, Func`2<ValueTuple`2<A, B>, R> map);
    [ExtensionAttribute]
[PureAttribute]
public static R Map(ValueTuple`2<A, B> self, Func`3<A, B, R> map);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`2<R1, R2> BiMap(ValueTuple`2<T1, T2> self, Func`2<T1, R1> firstMap, Func`2<T2, R2> secondMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`2<R1, T2> MapFirst(ValueTuple`2<T1, T2> self, Func`2<T1, R1> firstMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`2<T1, R2> MapSecond(ValueTuple`2<T1, T2> self, Func`2<T2, R2> secondMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`2<R1, R2> Select(ValueTuple`2<T1, T2> self, Func`2<ValueTuple`2<T1, T2>, ValueTuple`2<R1, R2>> map);
    [ExtensionAttribute]
public static Unit Iter(ValueTuple`2<T1, T2> self, Action`2<T1, T2> func);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Unit Iter(ValueTuple`2<T1, T2> self, Action`1<T1> first, Action`1<T2> second);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static S Fold(ValueTuple`2<T1, T2> self, S state, Func`4<S, T1, T2, S> fold);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static S BiFold(ValueTuple`2<T1, T2> self, S state, Func`3<S, T1, S> firstFold, Func`3<S, T2, S> secondFold);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static S BiFoldBack(ValueTuple`2<T1, T2> self, S state, Func`3<S, T2, S> firstFold, Func`3<S, T1, S> secondFold);
    [ExtensionAttribute]
[PureAttribute]
public static Arr`1<ValueTuple`2<C, D>> Traverse(ValueTuple`2<Arr`1<A>, Arr`1<B>> tuple, Func`2<ValueTuple`2<A, B>, ValueTuple`2<C, D>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Arr`1<ValueTuple`2<C, D>> Traverse(ValueTuple`2<Arr`1<A>, Arr`1<B>> tuple, Func`3<A, B, ValueTuple`2<C, D>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Arr`1<ValueTuple`2<A, B>> Sequence(ValueTuple`2<Arr`1<A>, Arr`1<B>> tuple);
    [ExtensionAttribute]
[PureAttribute]
public static Either`2<L, ValueTuple`2<C, D>> Traverse(ValueTuple`2<Either`2<L, A>, Either`2<L, B>> tuple, Func`2<ValueTuple`2<A, B>, ValueTuple`2<C, D>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Either`2<L, ValueTuple`2<C, D>> Traverse(ValueTuple`2<Either`2<L, A>, Either`2<L, B>> tuple, Func`3<A, B, ValueTuple`2<C, D>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Either`2<L, ValueTuple`2<A, B>> Sequence(ValueTuple`2<Either`2<L, A>, Either`2<L, B>> tuple);
    [ExtensionAttribute]
[PureAttribute]
public static HashSet`1<ValueTuple`2<C, D>> Traverse(ValueTuple`2<HashSet`1<A>, HashSet`1<B>> tuple, Func`2<ValueTuple`2<A, B>, ValueTuple`2<C, D>> f);
    [ExtensionAttribute]
[PureAttribute]
public static HashSet`1<ValueTuple`2<C, D>> Traverse(ValueTuple`2<HashSet`1<A>, HashSet`1<B>> tuple, Func`3<A, B, ValueTuple`2<C, D>> f);
    [ExtensionAttribute]
[PureAttribute]
public static HashSet`1<ValueTuple`2<A, B>> Sequence(ValueTuple`2<HashSet`1<A>, HashSet`1<B>> tuple);
    [ExtensionAttribute]
[PureAttribute]
public static Lst`1<ValueTuple`2<C, D>> Traverse(ValueTuple`2<Lst`1<A>, Lst`1<B>> tuple, Func`2<ValueTuple`2<A, B>, ValueTuple`2<C, D>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Lst`1<ValueTuple`2<C, D>> Traverse(ValueTuple`2<Lst`1<A>, Lst`1<B>> tuple, Func`3<A, B, ValueTuple`2<C, D>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Lst`1<ValueTuple`2<A, B>> Sequence(ValueTuple`2<Lst`1<A>, Lst`1<B>> tuple);
    [ExtensionAttribute]
[PureAttribute]
public static Option`1<ValueTuple`2<C, D>> Traverse(ValueTuple`2<Option`1<A>, Option`1<B>> tuple, Func`2<ValueTuple`2<A, B>, ValueTuple`2<C, D>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Option`1<ValueTuple`2<C, D>> Traverse(ValueTuple`2<Option`1<A>, Option`1<B>> tuple, Func`3<A, B, ValueTuple`2<C, D>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Option`1<ValueTuple`2<A, B>> Sequence(ValueTuple`2<Option`1<A>, Option`1<B>> tuple);
    [ExtensionAttribute]
[PureAttribute]
public static Set`1<ValueTuple`2<C, D>> Traverse(ValueTuple`2<Set`1<A>, Set`1<B>> tuple, Func`2<ValueTuple`2<A, B>, ValueTuple`2<C, D>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Set`1<ValueTuple`2<C, D>> Traverse(ValueTuple`2<Set`1<A>, Set`1<B>> tuple, Func`3<A, B, ValueTuple`2<C, D>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Set`1<ValueTuple`2<A, B>> Sequence(ValueTuple`2<Set`1<A>, Set`1<B>> tuple);
    [ExtensionAttribute]
[PureAttribute]
public static Task`1<ValueTuple`2<C, D>> Traverse(ValueTuple`2<Task`1<A>, Task`1<B>> tuple, Func`2<ValueTuple`2<A, B>, ValueTuple`2<C, D>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Task`1<ValueTuple`2<C, D>> Traverse(ValueTuple`2<Task`1<A>, Task`1<B>> tuple, Func`3<A, B, ValueTuple`2<C, D>> f);
    [ExtensionAttribute]
[PureAttribute]
public static Task`1<ValueTuple`2<A, B>> Sequence(ValueTuple`2<Task`1<A>, Task`1<B>> tuple);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ValueTuple3Extensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`4<T1, T2, T3, T4> Add(ValueTuple`3<T1, T2, T3> self, T4 fourth);
    [ExtensionAttribute]
[PureAttribute]
public static T1 Head(ValueTuple`3<T1, T2, T3> self);
    [ExtensionAttribute]
[PureAttribute]
public static T3 Last(ValueTuple`3<T1, T2, T3> self);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`2<T2, T3> Tail(ValueTuple`3<T1, T2, T3> self);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static A Sum(ValueTuple`3<A, A, A> self);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static A Product(ValueTuple`3<A, A, A> self);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static bool Contains(ValueTuple`3<A, A, A> self, A value);
    [ExtensionAttribute]
[PureAttribute]
public static R Map(ValueTuple`3<A, B, C> self, Func`2<ValueTuple`3<A, B, C>, R> map);
    [ExtensionAttribute]
[PureAttribute]
public static R Map(ValueTuple`3<A, B, C> self, Func`4<A, B, C, R> map);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`3<R1, R2, R3> Map(ValueTuple`3<T1, T2, T3> self, Func`2<T1, R1> firstMap, Func`2<T2, R2> secondMap, Func`2<T3, R3> thirdMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`3<R1, T2, T3> MapFirst(ValueTuple`3<T1, T2, T3> self, Func`2<T1, R1> firstMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`3<T1, R2, T3> MapSecond(ValueTuple`3<T1, T2, T3> self, Func`2<T2, R2> secondMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`3<T1, T2, R3> MapThird(ValueTuple`3<T1, T2, T3> self, Func`2<T3, R3> thirdMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`3<R1, R2, R3> Select(ValueTuple`3<T1, T2, T3> self, Func`2<ValueTuple`3<T1, T2, T3>, ValueTuple`3<R1, R2, R3>> map);
    [ExtensionAttribute]
public static Unit Iter(ValueTuple`3<T1, T2, T3> self, Action`3<T1, T2, T3> func);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Unit Iter(ValueTuple`3<T1, T2, T3> self, Action`1<T1> first, Action`1<T2> second, Action`1<T3> third);
    [ExtensionAttribute]
[PureAttribute]
public static S Fold(ValueTuple`3<T1, T2, T3> self, S state, Func`5<S, T1, T2, T3, S> fold);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static S TriFold(ValueTuple`3<T1, T2, T3> self, S state, Func`3<S, T1, S> firstFold, Func`3<S, T2, S> secondFold, Func`3<S, T3, S> thirdFold);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static S TriFoldBack(ValueTuple`3<T1, T2, T3> self, S state, Func`3<S, T3, S> firstFold, Func`3<S, T2, S> secondFold, Func`3<S, T1, S> thirdFold);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ValueTuple4Extensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`5<A, B, C, D, E> Add(ValueTuple`4<A, B, C, D> self, E fifth);
    [ExtensionAttribute]
[PureAttribute]
public static A Head(ValueTuple`4<A, B, C, D> self);
    [ExtensionAttribute]
[PureAttribute]
public static D Last(ValueTuple`4<A, B, C, D> self);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`3<B, C, D> Tail(ValueTuple`4<A, B, C, D> self);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static bool Contains(ValueTuple`4<A, A, A, A> self, A value);
    [ExtensionAttribute]
[PureAttribute]
public static R Map(ValueTuple`4<A, B, C, D> self, Func`2<ValueTuple`4<A, B, C, D>, R> map);
    [ExtensionAttribute]
[PureAttribute]
public static R Map(ValueTuple`4<A, B, C, D> self, Func`5<A, B, C, D, R> map);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`4<W, X, Y, Z> Map(ValueTuple`4<A, B, C, D> self, Func`2<A, W> firstMap, Func`2<B, X> secondMap, Func`2<C, Y> thirdMap, Func`2<D, Z> fourthMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`4<R1, B, C, D> MapFirst(ValueTuple`4<A, B, C, D> self, Func`2<A, R1> firstMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`4<A, R2, C, D> MapSecond(ValueTuple`4<A, B, C, D> self, Func`2<B, R2> secondMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`4<A, B, R3, D> MapThird(ValueTuple`4<A, B, C, D> self, Func`2<C, R3> thirdMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`4<A, B, C, R4> MapFourth(ValueTuple`4<A, B, C, D> self, Func`2<D, R4> fourthMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`4<W, X, Y, Z> Select(ValueTuple`4<A, B, C, D> self, Func`2<ValueTuple`4<A, B, C, D>, ValueTuple`4<W, X, Y, Z>> map);
    [ExtensionAttribute]
public static Unit Iter(ValueTuple`4<A, B, C, D> self, Action`4<A, B, C, D> func);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Unit Iter(ValueTuple`4<A, B, C, D> self, Action`1<A> first, Action`1<B> second, Action`1<C> third, Action`1<D> fourth);
    [ExtensionAttribute]
[PureAttribute]
public static S Fold(ValueTuple`4<A, B, C, D> self, S state, Func`6<S, A, B, C, D, S> fold);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static S QuadFold(ValueTuple`4<A, B, C, D> self, S state, Func`3<S, A, S> firstFold, Func`3<S, B, S> secondFold, Func`3<S, C, S> thirdFold, Func`3<S, D, S> fourthFold);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static S QuadFoldBack(ValueTuple`4<A, B, C, D> self, S state, Func`3<S, D, S> firstFold, Func`3<S, C, S> secondFold, Func`3<S, B, S> thirdFold, Func`3<S, A, S> fourthFold);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ValueTuple5Extensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`6<A, B, C, D, E, F> Add(ValueTuple`5<A, B, C, D, E> self, F sixth);
    [ExtensionAttribute]
[PureAttribute]
public static A Head(ValueTuple`5<A, B, C, D, E> self);
    [ExtensionAttribute]
[PureAttribute]
public static E Last(ValueTuple`5<A, B, C, D, E> self);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`4<B, C, D, E> Tail(ValueTuple`5<A, B, C, D, E> self);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static bool Contains(ValueTuple`5<A, A, A, A, A> self, A value);
    [ExtensionAttribute]
[PureAttribute]
public static R Map(ValueTuple`5<A, B, C, D, E> self, Func`2<ValueTuple`5<A, B, C, D, E>, R> map);
    [ExtensionAttribute]
[PureAttribute]
public static R Map(ValueTuple`5<A, B, C, D, E> self, Func`6<A, B, C, D, E, R> map);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`5<V, W, X, Y, Z> Map(ValueTuple`5<A, B, C, D, E> self, Func`2<A, V> firstMap, Func`2<B, W> secondMap, Func`2<C, X> thirdMap, Func`2<D, Y> fourthMap, Func`2<E, Z> fifthMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`5<R1, B, C, D, E> MapFirst(ValueTuple`5<A, B, C, D, E> self, Func`2<A, R1> firstMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`5<A, R2, C, D, E> MapSecond(ValueTuple`5<A, B, C, D, E> self, Func`2<B, R2> secondMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`5<A, B, R3, D, E> MapThird(ValueTuple`5<A, B, C, D, E> self, Func`2<C, R3> thirdMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`5<A, B, C, R4, E> MapFourth(ValueTuple`5<A, B, C, D, E> self, Func`2<D, R4> fourthMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`5<A, B, C, D, R5> MapFifth(ValueTuple`5<A, B, C, D, E> self, Func`2<E, R5> fifthMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`5<V, W, X, Y, Z> Select(ValueTuple`5<A, B, C, D, E> self, Func`2<ValueTuple`5<A, B, C, D, E>, ValueTuple`5<V, W, X, Y, Z>> map);
    [ExtensionAttribute]
public static Unit Iter(ValueTuple`5<A, B, C, D, E> self, Action`5<A, B, C, D, E> func);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Unit Iter(ValueTuple`5<A, B, C, D, E> self, Action`1<A> first, Action`1<B> second, Action`1<C> third, Action`1<D> fourth, Action`1<E> fifth);
    [ExtensionAttribute]
[PureAttribute]
public static S Fold(ValueTuple`5<A, B, C, D, E> self, S state, Func`7<S, A, B, C, D, E, S> fold);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static S QuintFold(ValueTuple`5<A, B, C, D, E> self, S state, Func`3<S, A, S> firstFold, Func`3<S, B, S> secondFold, Func`3<S, C, S> thirdFold, Func`3<S, D, S> fourthFold, Func`3<S, E, S> fifthFold);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static S QuintFoldBack(ValueTuple`5<A, B, C, D, E> self, S state, Func`3<S, E, S> firstFold, Func`3<S, D, S> secondFold, Func`3<S, C, S> thirdFold, Func`3<S, B, S> fourthFold, Func`3<S, A, S> fifthFold);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ValueTuple6Extensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`7<A, B, C, D, E, F, G> Add(ValueTuple`6<A, B, C, D, E, F> self, G seventh);
    [ExtensionAttribute]
[PureAttribute]
public static A Head(ValueTuple`6<A, B, C, D, E, F> self);
    [ExtensionAttribute]
[PureAttribute]
public static F Last(ValueTuple`6<A, B, C, D, E, F> self);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`5<B, C, D, E, F> Tail(ValueTuple`6<A, B, C, D, E, F> self);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static bool Contains(ValueTuple`6<A, A, A, A, A, A> self, A value);
    [ExtensionAttribute]
[PureAttribute]
public static R Map(ValueTuple`6<A, B, C, D, E, F> self, Func`2<ValueTuple`6<A, B, C, D, E, F>, R> map);
    [ExtensionAttribute]
[PureAttribute]
public static R Map(ValueTuple`6<A, B, C, D, E, F> self, Func`7<A, B, C, D, E, F, R> map);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`6<U, V, W, X, Y, Z> Map(ValueTuple`6<A, B, C, D, E, F> self, Func`2<A, U> firstMap, Func`2<B, V> secondMap, Func`2<C, W> thirdMap, Func`2<D, X> fourthMap, Func`2<E, Y> fifthMap, Func`2<F, Z> sixthMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`6<R1, B, C, D, E, F> MapFirst(ValueTuple`6<A, B, C, D, E, F> self, Func`2<A, R1> firstMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`6<A, R2, C, D, E, F> MapSecond(ValueTuple`6<A, B, C, D, E, F> self, Func`2<B, R2> secondMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`6<A, B, R3, D, E, F> MapThird(ValueTuple`6<A, B, C, D, E, F> self, Func`2<C, R3> thirdMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`6<A, B, C, R4, E, F> MapFourth(ValueTuple`6<A, B, C, D, E, F> self, Func`2<D, R4> fourthMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`6<A, B, C, D, R5, F> MapFifth(ValueTuple`6<A, B, C, D, E, F> self, Func`2<E, R5> fifthMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`6<A, B, C, D, E, R6> MapSixth(ValueTuple`6<A, B, C, D, E, F> self, Func`2<F, R6> sixthMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`6<U, V, W, X, Y, Z> Select(ValueTuple`6<A, B, C, D, E, F> self, Func`2<ValueTuple`6<A, B, C, D, E, F>, ValueTuple`6<U, V, W, X, Y, Z>> map);
    [ExtensionAttribute]
public static Unit Iter(ValueTuple`6<A, B, C, D, E, F> self, Action`6<A, B, C, D, E, F> func);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Unit Iter(ValueTuple`6<A, B, C, D, E, F> self, Action`1<A> first, Action`1<B> second, Action`1<C> third, Action`1<D> fourth, Action`1<E> fifth, Action`1<F> sixth);
    [ExtensionAttribute]
[PureAttribute]
public static S Fold(ValueTuple`6<A, B, C, D, E, F> self, S state, Func`8<S, A, B, C, D, E, F, S> fold);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static S SextFold(ValueTuple`6<A, B, C, D, E, F> self, S state, Func`3<S, A, S> firstFold, Func`3<S, B, S> secondFold, Func`3<S, C, S> thirdFold, Func`3<S, D, S> fourthFold, Func`3<S, E, S> fifthFold, Func`3<S, F, S> sixthFold);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static S SextFoldBack(ValueTuple`6<A, B, C, D, E, F> self, S state, Func`3<S, F, S> firstFold, Func`3<S, E, S> secondFold, Func`3<S, D, S> thirdFold, Func`3<S, C, S> fourthFold, Func`3<S, B, S> fifthFold, Func`3<S, A, S> sixthFold);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ValueTuple7Extensions : object {
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`8<A, B, C, D, E, F, G, ValueTuple`1<H>> Add(ValueTuple`7<A, B, C, D, E, F, G> self, H eighth);
    [ExtensionAttribute]
[PureAttribute]
public static A Head(ValueTuple`7<A, B, C, D, E, F, G> self);
    [ExtensionAttribute]
[PureAttribute]
public static G Last(ValueTuple`7<A, B, C, D, E, F, G> self);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`6<B, C, D, E, F, G> Tail(ValueTuple`7<A, B, C, D, E, F, G> self);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static bool Contains(ValueTuple`7<A, A, A, A, A, A, A> self, A value);
    [ExtensionAttribute]
[PureAttribute]
public static R Map(ValueTuple`7<A, B, C, D, E, F, G> self, Func`2<ValueTuple`7<A, B, C, D, E, F, G>, R> map);
    [ExtensionAttribute]
[PureAttribute]
public static R Map(ValueTuple`7<A, B, C, D, E, F, G> self, Func`8<A, B, C, D, E, F, G, R> map);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`7<T, U, V, W, X, Y, Z> Map(ValueTuple`7<A, B, C, D, E, F, G> self, Func`2<A, T> firstMap, Func`2<B, U> secondMap, Func`2<C, V> thirdMap, Func`2<D, W> fourthMap, Func`2<E, X> fifthMap, Func`2<F, Y> sixthMap, Func`2<G, Z> seventhMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`7<R1, B, C, D, E, F, G> MapFirst(ValueTuple`7<A, B, C, D, E, F, G> self, Func`2<A, R1> firstMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`7<A, R2, C, D, E, F, G> MapSecond(ValueTuple`7<A, B, C, D, E, F, G> self, Func`2<B, R2> secondMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`7<A, B, R3, D, E, F, G> MapThird(ValueTuple`7<A, B, C, D, E, F, G> self, Func`2<C, R3> thirdMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`7<A, B, C, R4, E, F, G> MapFourth(ValueTuple`7<A, B, C, D, E, F, G> self, Func`2<D, R4> fourthMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`7<A, B, C, D, R5, F, G> MapFifth(ValueTuple`7<A, B, C, D, E, F, G> self, Func`2<E, R5> fifthMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`7<A, B, C, D, E, R6, G> MapSixth(ValueTuple`7<A, B, C, D, E, F, G> self, Func`2<F, R6> sixthMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`7<A, B, C, D, E, F, R7> MapSeventh(ValueTuple`7<A, B, C, D, E, F, G> self, Func`2<G, R7> seventhMap);
    [ExtensionAttribute]
[PureAttribute]
public static ValueTuple`6<U, V, W, X, Y, Z> Select(ValueTuple`7<A, B, C, D, E, F, G> self, Func`2<ValueTuple`7<A, B, C, D, E, F, G>, ValueTuple`6<U, V, W, X, Y, Z>> map);
    [ExtensionAttribute]
public static Unit Iter(ValueTuple`7<A, B, C, D, E, F, G> self, Action`7<A, B, C, D, E, F, G> func);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Unit Iter(ValueTuple`7<A, B, C, D, E, F, G> self, Action`1<A> first, Action`1<B> second, Action`1<C> third, Action`1<D> fourth, Action`1<E> fifth, Action`1<F> sixth, Action`1<G> seventh);
    [ExtensionAttribute]
[PureAttribute]
public static S Fold(ValueTuple`7<A, B, C, D, E, F, G> self, S state, Func`9<S, A, B, C, D, E, F, G, S> fold);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static S SeptFold(ValueTuple`7<A, B, C, D, E, F, G> self, S state, Func`3<S, A, S> firstFold, Func`3<S, B, S> secondFold, Func`3<S, C, S> thirdFold, Func`3<S, D, S> fourthFold, Func`3<S, E, S> fifthFold, Func`3<S, F, S> sixthFold, Func`3<S, G, S> seventhFold);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[PureAttribute]
public static S SeptFoldBack(ValueTuple`7<A, B, C, D, E, F, G> self, S state, Func`3<S, G, S> firstFold, Func`3<S, F, S> secondFold, Func`3<S, E, S> thirdFold, Func`3<S, D, S> fourthFold, Func`3<S, C, S> fifthFold, Func`3<S, B, S> sixthFold, Func`3<S, A, S> seventhFold);
}
