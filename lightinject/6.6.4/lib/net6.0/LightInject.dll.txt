public class LightInject.AssemblyLoader : object {
    [IteratorStateMachineAttribute("LightInject.AssemblyLoader/<Load>d__0")]
public sealed virtual IEnumerable`1<Assembly> Load(string searchPattern);
    protected virtual bool CanLoad(string fileName);
    protected virtual Assembly LoadAssembly(string filename);
    protected virtual string GetAssemblyCodeBasePath();
}
public class LightInject.AssemblyScanner : object {
    private ITypeExtractor concreteTypeExtractor;
    private ITypeExtractor compositionRootTypeExtractor;
    private ICompositionRootExecutor compositionRootExecutor;
    private IGenericArgumentMapper genericArgumentMapper;
    private Assembly currentAssembly;
    public AssemblyScanner(ITypeExtractor concreteTypeExtractor, ITypeExtractor compositionRootTypeExtractor, ICompositionRootExecutor compositionRootExecutor, IGenericArgumentMapper genericArgumentMapper);
    public sealed virtual void Scan(Assembly assembly, IServiceRegistry serviceRegistry, Func`1<ILifetime> lifetimeFactory, Func`3<Type, Type, bool> shouldRegister, Func`3<Type, Type, string> serviceNameProvider);
    public sealed virtual void Scan(Assembly assembly, IServiceRegistry serviceRegistry);
    [IteratorStateMachineAttribute("LightInject.AssemblyScanner/<GetBaseTypes>d__8")]
private static IEnumerable`1<Type> GetBaseTypes(Type concreteType);
    private void ExecuteCompositionRoots(IEnumerable`1<Type> compositionRoots);
    private Type[] GetConcreteTypes(Assembly assembly);
    private Type[] GetCompositionRootTypes(Assembly assembly);
    private void BuildImplementationMap(Type implementingType, IServiceRegistry serviceRegistry, Func`1<ILifetime> lifetimeFactory, Func`3<Type, Type, bool> shouldRegister, Func`3<Type, Type, string> serviceNameProvider);
    private void RegisterInternal(Type serviceType, Type implementingType, IServiceRegistry serviceRegistry, ILifetime lifetime, Func`3<Type, Type, string> serviceNameProvider);
}
public class LightInject.CachedTypeExtractor : object {
    private ITypeExtractor typeExtractor;
    private ThreadSafeDictionary`2<Assembly, Type[]> cache;
    public CachedTypeExtractor(ITypeExtractor typeExtractor);
    public sealed virtual Type[] Execute(Assembly assembly);
}
public class LightInject.CompositionRootAttributeExtractor : object {
    public sealed virtual CompositionRootTypeAttribute[] GetAttributes(Assembly assembly);
}
public class LightInject.CompositionRootExecutor : object {
    private IServiceRegistry serviceRegistry;
    private Func`2<Type, ICompositionRoot> activator;
    private IList`1<Type> executedCompositionRoots;
    private object syncRoot;
    public CompositionRootExecutor(IServiceRegistry serviceRegistry, Func`2<Type, ICompositionRoot> activator);
    public sealed virtual void Execute(Type compositionRootType);
    public sealed virtual void Execute(TCompositionRoot compositionRoot);
}
[AttributeUsageAttribute("1")]
public class LightInject.CompositionRootTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <CompositionRootType>k__BackingField;
    public Type CompositionRootType { get; private set; }
    public CompositionRootTypeAttribute(Type compositionRootType);
    [CompilerGeneratedAttribute]
public Type get_CompositionRootType();
    [CompilerGeneratedAttribute]
private void set_CompositionRootType(Type value);
}
public class LightInject.CompositionRootTypeExtractor : object {
    private ICompositionRootAttributeExtractor compositionRootAttributeExtractor;
    public CompositionRootTypeExtractor(ICompositionRootAttributeExtractor compositionRootAttributeExtractor);
    public sealed virtual Type[] Execute(Assembly assembly);
}
public class LightInject.ConcreteTypeExtractor : object {
    private static List`1<Type> InternalTypes;
    private static ConcreteTypeExtractor();
    public sealed virtual Type[] Execute(Assembly assembly);
    private static bool IsConcreteType(TypeInfo typeInfo);
    private static bool IsCompilerGenerated(TypeInfo typeInfo);
}
public class LightInject.ConstructionInfo : object {
    [CompilerGeneratedAttribute]
private Type <ImplementingType>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo <Constructor>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PropertyDependency> <PropertyDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ConstructorDependency> <ConstructorDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private Delegate <FactoryDelegate>k__BackingField;
    public Type ImplementingType { get; public set; }
    public ConstructorInfo Constructor { get; public set; }
    public List`1<PropertyDependency> PropertyDependencies { get; private set; }
    public List`1<ConstructorDependency> ConstructorDependencies { get; private set; }
    public Delegate FactoryDelegate { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_ImplementingType();
    [CompilerGeneratedAttribute]
public void set_ImplementingType(Type value);
    [CompilerGeneratedAttribute]
public ConstructorInfo get_Constructor();
    [CompilerGeneratedAttribute]
public void set_Constructor(ConstructorInfo value);
    [CompilerGeneratedAttribute]
public List`1<PropertyDependency> get_PropertyDependencies();
    [CompilerGeneratedAttribute]
private void set_PropertyDependencies(List`1<PropertyDependency> value);
    [CompilerGeneratedAttribute]
public List`1<ConstructorDependency> get_ConstructorDependencies();
    [CompilerGeneratedAttribute]
private void set_ConstructorDependencies(List`1<ConstructorDependency> value);
    [CompilerGeneratedAttribute]
public Delegate get_FactoryDelegate();
    [CompilerGeneratedAttribute]
public void set_FactoryDelegate(Delegate value);
}
public class LightInject.ConstructionInfoProvider : object {
    private IConstructionInfoBuilder constructionInfoBuilder;
    private ThreadSafeDictionary`2<Registration, ConstructionInfo> cache;
    public ConstructionInfoProvider(IConstructionInfoBuilder constructionInfoBuilder);
    public sealed virtual ConstructionInfo GetConstructionInfo(Registration registration);
}
public class LightInject.ConstructorDependency : Dependency {
    [CompilerGeneratedAttribute]
private ParameterInfo <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDecoratorTarget>k__BackingField;
    public ParameterInfo Parameter { get; public set; }
    public bool IsDecoratorTarget { get; public set; }
    public string Name { get; }
    [CompilerGeneratedAttribute]
public ParameterInfo get_Parameter();
    [CompilerGeneratedAttribute]
public void set_Parameter(ParameterInfo value);
    [CompilerGeneratedAttribute]
public bool get_IsDecoratorTarget();
    [CompilerGeneratedAttribute]
public void set_IsDecoratorTarget(bool value);
    public virtual string get_Name();
    public virtual string ToString();
}
public class LightInject.ConstructorDependencySelector : object {
    public virtual IEnumerable`1<ConstructorDependency> Execute(ConstructorInfo constructor);
}
public class LightInject.ContainerOptions : object {
    private static Lazy`1<ContainerOptions> DefaultOptions;
    [CompilerGeneratedAttribute]
private bool <EnableVariance>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Type, bool> <VarianceFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Type, Action`1<LogEntry>> <LogFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<String[], string> <DefaultServiceSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnablePropertyInjection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableCurrentScope>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableOptionalArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OptimizeForLargeObjectGraphs>k__BackingField;
    public static ContainerOptions Default { get; }
    public bool EnableVariance { get; public set; }
    public Func`2<Type, bool> VarianceFilter { get; public set; }
    public Func`2<Type, Action`1<LogEntry>> LogFactory { get; public set; }
    public Func`2<String[], string> DefaultServiceSelector { get; public set; }
    public bool EnablePropertyInjection { get; public set; }
    public bool EnableCurrentScope { get; public set; }
    public bool EnableOptionalArguments { get; public set; }
    public bool OptimizeForLargeObjectGraphs { get; public set; }
    private static ContainerOptions();
    public static ContainerOptions get_Default();
    [CompilerGeneratedAttribute]
public bool get_EnableVariance();
    [CompilerGeneratedAttribute]
public void set_EnableVariance(bool value);
    [CompilerGeneratedAttribute]
public Func`2<Type, bool> get_VarianceFilter();
    [CompilerGeneratedAttribute]
public void set_VarianceFilter(Func`2<Type, bool> value);
    [CompilerGeneratedAttribute]
public Func`2<Type, Action`1<LogEntry>> get_LogFactory();
    [CompilerGeneratedAttribute]
public void set_LogFactory(Func`2<Type, Action`1<LogEntry>> value);
    [CompilerGeneratedAttribute]
public Func`2<String[], string> get_DefaultServiceSelector();
    [CompilerGeneratedAttribute]
public void set_DefaultServiceSelector(Func`2<String[], string> value);
    [CompilerGeneratedAttribute]
public bool get_EnablePropertyInjection();
    [CompilerGeneratedAttribute]
public void set_EnablePropertyInjection(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableCurrentScope();
    [CompilerGeneratedAttribute]
public void set_EnableCurrentScope(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableOptionalArguments();
    [CompilerGeneratedAttribute]
public void set_EnableOptionalArguments(bool value);
    [CompilerGeneratedAttribute]
public bool get_OptimizeForLargeObjectGraphs();
    [CompilerGeneratedAttribute]
public void set_OptimizeForLargeObjectGraphs(bool value);
    private static ContainerOptions CreateDefaultContainerOptions();
}
public class LightInject.DecoratorRegistration : Registration {
    [CompilerGeneratedAttribute]
private Func`2<ServiceRegistration, bool> <CanDecorate>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<IServiceFactory, ServiceRegistration, Type> <ImplementingTypeFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public Func`2<ServiceRegistration, bool> CanDecorate { get; public set; }
    public Func`3<IServiceFactory, ServiceRegistration, Type> ImplementingTypeFactory { get; public set; }
    public int Index { get; public set; }
    public bool HasDeferredImplementingType { get; }
    [CompilerGeneratedAttribute]
public Func`2<ServiceRegistration, bool> get_CanDecorate();
    [CompilerGeneratedAttribute]
public void set_CanDecorate(Func`2<ServiceRegistration, bool> value);
    [CompilerGeneratedAttribute]
public Func`3<IServiceFactory, ServiceRegistration, Type> get_ImplementingTypeFactory();
    [CompilerGeneratedAttribute]
public void set_ImplementingTypeFactory(Func`3<IServiceFactory, ServiceRegistration, Type> value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    public bool get_HasDeferredImplementingType();
}
public abstract class LightInject.Dependency : object {
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServiceName>k__BackingField;
    [CompilerGeneratedAttribute]
private Delegate <FactoryExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    public Type ServiceType { get; public set; }
    public string ServiceName { get; public set; }
    public Delegate FactoryExpression { get; public set; }
    public string Name { get; }
    public bool IsRequired { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_ServiceType();
    [CompilerGeneratedAttribute]
public void set_ServiceType(Type value);
    [CompilerGeneratedAttribute]
public string get_ServiceName();
    [CompilerGeneratedAttribute]
public void set_ServiceName(string value);
    [CompilerGeneratedAttribute]
public Delegate get_FactoryExpression();
    [CompilerGeneratedAttribute]
public void set_FactoryExpression(Delegate value);
    public abstract virtual string get_Name();
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
public void set_IsRequired(bool value);
    public virtual string ToString();
}
public class LightInject.Emitter : object {
    private ILGenerator generator;
    private Type[] parameterTypes;
    private Stack`1<Type> stack;
    private List`1<LocalBuilder> variables;
    private List`1<Instruction> instructions;
    public Type StackType { get; }
    public List`1<Instruction> Instructions { get; }
    public Emitter(ILGenerator generator, Type[] parameterTypes);
    public sealed virtual Type get_StackType();
    public sealed virtual List`1<Instruction> get_Instructions();
    public sealed virtual void Emit(OpCode code);
    public sealed virtual void Emit(OpCode code, int arg);
    public sealed virtual void Emit(OpCode code, long arg);
    public sealed virtual void Emit(OpCode code, sbyte arg);
    public sealed virtual void Emit(OpCode code, byte arg);
    public sealed virtual void Emit(OpCode code, Type type);
    public sealed virtual void Emit(OpCode code, ConstructorInfo constructor);
    public sealed virtual void Emit(OpCode code, LocalBuilder localBuilder);
    public sealed virtual void Emit(OpCode code, MethodInfo methodInfo);
    public sealed virtual LocalBuilder DeclareLocal(Type type);
    public sealed virtual void Emit(OpCode code, string arg);
}
[ExtensionAttribute]
public static class LightInject.EmitterExtensions : object {
    [ExtensionAttribute]
public static void UnboxOrCast(IEmitter emitter, Type type);
    [ExtensionAttribute]
public static void PushConstant(IEmitter emitter, int index, Type type);
    [ExtensionAttribute]
public static void PushConstant(IEmitter emitter, int index);
    [ExtensionAttribute]
public static void PushArrayElement(IEmitter emitter);
    [ExtensionAttribute]
public static void PushArguments(IEmitter emitter, ParameterInfo[] parameters);
    [ExtensionAttribute]
public static void Call(IEmitter emitter, MethodInfo methodInfo);
    [ExtensionAttribute]
public static void New(IEmitter emitter, ConstructorInfo constructorInfo);
    [ExtensionAttribute]
public static void Push(IEmitter emitter, LocalBuilder localBuilder);
    [ExtensionAttribute]
public static void PushArgument(IEmitter emitter, int index);
    [ExtensionAttribute]
public static void Store(IEmitter emitter, LocalBuilder localBuilder);
    [ExtensionAttribute]
public static void PushNewArray(IEmitter emitter, Type elementType);
    [ExtensionAttribute]
public static void Push(IEmitter emitter, int value);
    [ExtensionAttribute]
public static void Cast(IEmitter emitter, Type type);
    [ExtensionAttribute]
public static void Return(IEmitter emitter);
}
public static class LightInject.Ensure : object {
    public static void IsNotNull(T value, string paramName);
}
[ExtensionAttribute]
internal static class LightInject.EnumerableTypeExtensions : object {
    private static ThreadSafeDictionary`2<Type, Type> EnumerableTypes;
    private static EnumerableTypeExtensions();
    [ExtensionAttribute]
public static Type GetEnumerableType(Type returnType);
    private static Type CreateEnumerableType(Type type);
}
internal static class LightInject.FuncHelper : object {
    public static MethodInfo CreateScopedFuncMethod;
    public static MethodInfo CreateScopedGenericFuncMethod;
    public static MethodInfo CreateScopedGenericNamedFuncMethod;
    private static FuncHelper();
    public static Func`1<object> CreateScopedFunc(GetInstanceDelegate getInstanceDelegate, Object[] constants, Scope scope);
    public static Func`1<T> CreateScopedGenericFunc(ServiceContainer serviceContainer, Scope scope);
    public static Func`2<string, T> CreateScopedGenericNamedFunc(ServiceContainer serviceContainer, Scope scope);
}
public class LightInject.GenericArgumentMapper : object {
    public sealed virtual GenericMappingResult Map(Type genericServiceType, Type openGenericImplementingType);
    public sealed virtual Type TryMakeGenericType(Type genericServiceType, Type openGenericImplementingType);
    private static Dictionary`2<string, Type> CreateMap(Type genericServiceType, Type openGenericImplementingType, String[] genericParameterNames);
    private static Type[] GetGenericArgumentsOrParameters(Type type);
    private static void MapGenericArguments(Type[] serviceTypeGenericArguments, Type[] baseTypeGenericArguments, IDictionary`2<string, Type> map);
    private static Type GetBaseTypeImplementingGenericTypeDefinition(Type implementingType, Type genericTypeDefinition);
    private static bool ImplementsOpenGenericTypeDefinition(Type genericTypeDefinition, Type baseType);
}
public class LightInject.GenericMappingResult : object {
    private String[] genericParameterNames;
    private IDictionary`2<string, Type> genericArgumentMap;
    private Type genericServiceType;
    private Type openGenericImplementingType;
    public bool IsValid { get; }
    internal GenericMappingResult(String[] genericParameterNames, IDictionary`2<string, Type> genericArgumentMap, Type genericServiceType, Type openGenericImplementingType);
    public bool get_IsValid();
    public Type[] GetMappedArguments();
    [CompilerGeneratedAttribute]
private bool <get_IsValid>b__6_0(string n);
    [CompilerGeneratedAttribute]
private bool <GetMappedArguments>b__7_0(string n);
    [CompilerGeneratedAttribute]
private Type <GetMappedArguments>b__7_1(string parameterName);
}
public class LightInject.GetInstanceDelegate : MulticastDelegate {
    public GetInstanceDelegate(object object, IntPtr method);
    public virtual object Invoke(Object[] args, Scope scope);
    public virtual IAsyncResult BeginInvoke(Object[] args, Scope scope, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public interface LightInject.IAssemblyLoader {
    public abstract virtual IEnumerable`1<Assembly> Load(string searchPattern);
}
public interface LightInject.IAssemblyScanner {
    public abstract virtual void Scan(Assembly assembly, IServiceRegistry serviceRegistry, Func`1<ILifetime> lifetime, Func`3<Type, Type, bool> shouldRegister, Func`3<Type, Type, string> serviceNameProvider);
    public abstract virtual void Scan(Assembly assembly, IServiceRegistry serviceRegistry);
}
public interface LightInject.ICloneableLifeTime {
    public abstract virtual ILifetime Clone();
}
public interface LightInject.ICompositionRoot {
    public abstract virtual void Compose(IServiceRegistry serviceRegistry);
}
public interface LightInject.ICompositionRootAttributeExtractor {
    public abstract virtual CompositionRootTypeAttribute[] GetAttributes(Assembly assembly);
}
public interface LightInject.ICompositionRootExecutor {
    public abstract virtual void Execute(Type compositionRootType);
    public abstract virtual void Execute(TCompositionRoot compositionRoot);
}
public interface LightInject.IConstructionInfoBuilder {
    public abstract virtual ConstructionInfo Execute(Registration registration);
}
public interface LightInject.IConstructionInfoProvider {
    public abstract virtual ConstructionInfo GetConstructionInfo(Registration registration);
}
public interface LightInject.IConstructorDependencySelector {
    public abstract virtual IEnumerable`1<ConstructorDependency> Execute(ConstructorInfo constructor);
}
public interface LightInject.IConstructorSelector {
    public abstract virtual ConstructorInfo Execute(Type implementingType);
}
public interface LightInject.IEmitter {
    public Type StackType { get; }
    public List`1<Instruction> Instructions { get; }
    public abstract virtual Type get_StackType();
    public abstract virtual List`1<Instruction> get_Instructions();
    public abstract virtual void Emit(OpCode code);
    public abstract virtual void Emit(OpCode code, string arg);
    public abstract virtual void Emit(OpCode code, int arg);
    public abstract virtual void Emit(OpCode code, long arg);
    public abstract virtual void Emit(OpCode code, sbyte arg);
    public abstract virtual void Emit(OpCode code, byte arg);
    public abstract virtual void Emit(OpCode code, Type type);
    public abstract virtual void Emit(OpCode code, ConstructorInfo constructor);
    public abstract virtual void Emit(OpCode code, LocalBuilder localBuilder);
    public abstract virtual void Emit(OpCode code, MethodInfo methodInfo);
    public abstract virtual LocalBuilder DeclareLocal(Type type);
}
public interface LightInject.IGenericArgumentMapper {
    public abstract virtual GenericMappingResult Map(Type genericServiceType, Type openGenericImplementingType);
    public abstract virtual Type TryMakeGenericType(Type genericServiceType, Type openGenericImplementingType);
}
public interface LightInject.ILifetime {
    public abstract virtual object GetInstance(Func`1<object> createInstance, Scope scope);
}
public interface LightInject.IMethodSkeleton {
    public abstract virtual IEmitter GetEmitter();
    public abstract virtual Delegate CreateDelegate(Type delegateType);
}
public class LightInject.ImmutableHashTable`2 : object {
    public static ImmutableHashTable`2<TKey, TValue> Empty;
    public int Count;
    internal ImmutableHashTree`2[] Buckets;
    internal int Divisor;
    internal ImmutableHashTable`2(ImmutableHashTable`2<TKey, TValue> previous, TKey key, TValue value);
    private static ImmutableHashTable`2();
    private void AddExistingValues(ImmutableHashTable`2<TKey, TValue> previous);
    private void InitializeBuckets(int startIndex, int count);
}
[ExtensionAttribute]
public static class LightInject.ImmutableHashTableExtensions : object {
    [ExtensionAttribute]
[ExcludeFromCodeCoverageAttribute]
public static TValue Search(ImmutableHashTable`2<TKey, TValue> hashTable, TKey key);
    [ExtensionAttribute]
public static ImmutableHashTable`2<TKey, TValue> Add(ImmutableHashTable`2<TKey, TValue> hashTable, TKey key, TValue value);
    [ExtensionAttribute]
[ExcludeFromCodeCoverageAttribute]
internal static GetInstanceDelegate Search(ImmutableHashTable`2<Type, GetInstanceDelegate> hashTable, Type key);
}
public class LightInject.ImmutableHashTree`2 : object {
    public static ImmutableHashTree`2<TKey, TValue> Empty;
    public TKey Key;
    public TValue Value;
    public ImmutableList`1<KeyValue`2<TKey, TValue>> Duplicates;
    public int HashCode;
    public ImmutableHashTree`2<TKey, TValue> Left;
    public ImmutableHashTree`2<TKey, TValue> Right;
    public int Height;
    public bool IsEmpty;
    public ImmutableHashTree`2(TKey key, TValue value, ImmutableHashTree`2<TKey, TValue> hashTree);
    public ImmutableHashTree`2(TKey key, TValue value, ImmutableHashTree`2<TKey, TValue> left, ImmutableHashTree`2<TKey, TValue> right);
    private static ImmutableHashTree`2();
    private static ImmutableHashTree`2<TKey, TValue> RotateLeft(ImmutableHashTree`2<TKey, TValue> node);
    private static ImmutableHashTree`2<TKey, TValue> RotateRight(ImmutableHashTree`2<TKey, TValue> node);
    private bool IsLeftHeavy();
    private bool IsRightHeavy();
}
[ExtensionAttribute]
public static class LightInject.ImmutableHashTreeExtensions : object {
    [ExtensionAttribute]
public static TValue Search(ImmutableHashTree`2<TKey, TValue> tree, TKey key);
    [ExtensionAttribute]
public static ImmutableHashTree`2<TKey, TValue> Add(ImmutableHashTree`2<TKey, TValue> tree, TKey key, TValue value);
    [IteratorStateMachineAttribute("LightInject.ImmutableHashTreeExtensions/<InOrder>d__2`2")]
[ExtensionAttribute]
public static IEnumerable`1<KeyValue`2<TKey, TValue>> InOrder(ImmutableHashTree`2<TKey, TValue> hashTree);
    private static ImmutableHashTree`2<TKey, TValue> AddToLeftBranch(ImmutableHashTree`2<TKey, TValue> tree, TKey key, TValue value);
    private static ImmutableHashTree`2<TKey, TValue> AddToRightBranch(ImmutableHashTree`2<TKey, TValue> tree, TKey key, TValue value);
}
public class LightInject.ImmutableList`1 : object {
    public static ImmutableList`1<T> Empty;
    public T[] Items;
    public int Count;
    public ImmutableList`1(ImmutableList`1<T> previousList, T value);
    private static ImmutableList`1();
    public ImmutableList`1<T> Add(T value);
}
public class LightInject.ImmutableMapTree`1 : object {
    public static ImmutableMapTree`1<TValue> Empty;
    public int Key;
    public TValue Value;
    public ImmutableMapTree`1<TValue> Left;
    public ImmutableMapTree`1<TValue> Right;
    public int Height;
    public bool IsEmpty;
    public ImmutableMapTree`1(int key, TValue value, ImmutableMapTree`1<TValue> hashTree);
    public ImmutableMapTree`1(int key, TValue value, ImmutableMapTree`1<TValue> left, ImmutableMapTree`1<TValue> right);
    private static ImmutableMapTree`1();
    private static ImmutableMapTree`1<TValue> RotateLeft(ImmutableMapTree`1<TValue> node);
    private static ImmutableMapTree`1<TValue> RotateRight(ImmutableMapTree`1<TValue> node);
    private bool IsLeftHeavy();
    private bool IsRightHeavy();
}
[ExtensionAttribute]
public static class LightInject.ImmutableMapTreeExtensions : object {
    [ExtensionAttribute]
public static TValue Search(ImmutableMapTree`1<TValue> tree, int key);
    [ExtensionAttribute]
public static ImmutableMapTree`1<TValue> Add(ImmutableMapTree`1<TValue> tree, int key, TValue value);
    private static ImmutableMapTree`1<TValue> AddToLeftBranch(ImmutableMapTree`1<TValue> tree, int key, TValue value);
    private static ImmutableMapTree`1<TValue> AddToRightBranch(ImmutableMapTree`1<TValue> tree, int key, TValue value);
}
public class LightInject.Instruction : object {
    [CompilerGeneratedAttribute]
private OpCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<ILGenerator> <Emit>k__BackingField;
    public OpCode Code { get; private set; }
    public Action`1<ILGenerator> Emit { get; private set; }
    public Instruction(OpCode code, Action`1<ILGenerator> emitAction);
    [CompilerGeneratedAttribute]
public OpCode get_Code();
    [CompilerGeneratedAttribute]
private void set_Code(OpCode value);
    [CompilerGeneratedAttribute]
public Action`1<ILGenerator> get_Emit();
    [CompilerGeneratedAttribute]
private void set_Emit(Action`1<ILGenerator> value);
    public virtual string ToString();
}
public class LightInject.Instruction`1 : Instruction {
    [CompilerGeneratedAttribute]
private T <Argument>k__BackingField;
    public T Argument { get; private set; }
    public Instruction`1(OpCode code, T argument, Action`1<ILGenerator> emitAction);
    [CompilerGeneratedAttribute]
public T get_Argument();
    [CompilerGeneratedAttribute]
private void set_Argument(T value);
    public virtual string ToString();
}
public interface LightInject.IPropertyDependencySelector {
    public abstract virtual IEnumerable`1<PropertyDependency> Execute(Type type);
}
public interface LightInject.IPropertySelector {
    public abstract virtual IEnumerable`1<PropertyInfo> Execute(Type type);
}
public interface LightInject.IScopeManager {
    public Scope CurrentScope { get; public set; }
    public IServiceFactory ServiceFactory { get; }
    public abstract virtual Scope get_CurrentScope();
    public abstract virtual void set_CurrentScope(Scope value);
    public abstract virtual IServiceFactory get_ServiceFactory();
    public abstract virtual Scope BeginScope();
    public abstract virtual void EndScope(Scope scope);
}
public interface LightInject.IScopeManagerProvider {
    public abstract virtual IScopeManager GetScopeManager(IServiceFactory serviceFactory);
}
public interface LightInject.IServiceContainer {
    public IScopeManagerProvider ScopeManagerProvider { get; public set; }
    public abstract virtual IScopeManagerProvider get_ScopeManagerProvider();
    public abstract virtual void set_ScopeManagerProvider(IScopeManagerProvider value);
    public abstract virtual bool CanGetInstance(Type serviceType, string serviceName);
    public abstract virtual object InjectProperties(object instance);
    public abstract virtual void Compile();
    public abstract virtual void Compile(Func`2<ServiceRegistration, bool> predicate);
    public abstract virtual void Compile(string serviceName);
}
public interface LightInject.IServiceFactory {
    public abstract virtual Scope BeginScope();
    public abstract virtual object GetInstance(Type serviceType);
    public abstract virtual object GetInstance(Type serviceType, Object[] arguments);
    public abstract virtual object GetInstance(Type serviceType, string serviceName, Object[] arguments);
    public abstract virtual object GetInstance(Type serviceType, string serviceName);
    public abstract virtual object TryGetInstance(Type serviceType);
    public abstract virtual object TryGetInstance(Type serviceType, string serviceName);
    public abstract virtual IEnumerable`1<object> GetAllInstances(Type serviceType);
    public abstract virtual object Create(Type serviceType);
}
public interface LightInject.IServiceNameProvider {
    public abstract virtual string GetServiceName(Type serviceType, Type implementingType);
}
public interface LightInject.IServiceRegistry {
    public IEnumerable`1<ServiceRegistration> AvailableServices { get; }
    public abstract virtual IEnumerable`1<ServiceRegistration> get_AvailableServices();
    public abstract virtual IServiceRegistry Register(Type serviceType, Type implementingType);
    public abstract virtual IServiceRegistry Register(Type serviceType, Type implementingType, ILifetime lifetime);
    public abstract virtual IServiceRegistry Register(Type serviceType, Type implementingType, string serviceName);
    public abstract virtual IServiceRegistry Register(Type serviceType, Type implementingType, string serviceName, ILifetime lifetime);
    public abstract virtual IServiceRegistry Register();
    public abstract virtual IServiceRegistry Register(ILifetime lifetime);
    public abstract virtual IServiceRegistry Register(string serviceName);
    public abstract virtual IServiceRegistry Register(string serviceName, ILifetime lifetime);
    public abstract virtual IServiceRegistry RegisterInstance(TService instance);
    public abstract virtual IServiceRegistry RegisterInstance(TService instance, string serviceName);
    public abstract virtual IServiceRegistry RegisterInstance(Type serviceType, object instance);
    public abstract virtual IServiceRegistry RegisterInstance(Type serviceType, object instance, string serviceName);
    public abstract virtual IServiceRegistry Register();
    public abstract virtual IServiceRegistry Register(ILifetime lifetime);
    public abstract virtual IServiceRegistry Register(Type serviceType);
    public abstract virtual IServiceRegistry Register(Type serviceType, ILifetime lifetime);
    public abstract virtual IServiceRegistry Register(Func`2<IServiceFactory, TService> factory);
    public abstract virtual IServiceRegistry Register(Func`3<IServiceFactory, T, TService> factory);
    public abstract virtual IServiceRegistry Register(Func`3<IServiceFactory, T, TService> factory, string serviceName);
    public abstract virtual IServiceRegistry Register(Func`4<IServiceFactory, T1, T2, TService> factory);
    public abstract virtual IServiceRegistry Register(Func`4<IServiceFactory, T1, T2, TService> factory, string serviceName);
    public abstract virtual IServiceRegistry Register(Func`5<IServiceFactory, T1, T2, T3, TService> factory);
    public abstract virtual IServiceRegistry Register(Func`5<IServiceFactory, T1, T2, T3, TService> factory, string serviceName);
    public abstract virtual IServiceRegistry Register(Func`6<IServiceFactory, T1, T2, T3, T4, TService> factory);
    public abstract virtual IServiceRegistry Register(Func`6<IServiceFactory, T1, T2, T3, T4, TService> factory, string serviceName);
    public abstract virtual IServiceRegistry Register(Func`2<IServiceFactory, TService> factory, ILifetime lifetime);
    public abstract virtual IServiceRegistry Register(Func`2<IServiceFactory, TService> factory, string serviceName);
    public abstract virtual IServiceRegistry Register(Func`2<IServiceFactory, TService> factory, string serviceName, ILifetime lifetime);
    public abstract virtual IServiceRegistry RegisterOrdered(Type serviceType, Type[] implementingTypes, Func`2<Type, ILifetime> lifetimeFactory);
    public abstract virtual IServiceRegistry RegisterOrdered(Type serviceType, Type[] implementingTypes, Func`2<Type, ILifetime> lifeTimeFactory, Func`2<int, string> serviceNameFormatter);
    public abstract virtual IServiceRegistry RegisterFallback(Func`3<Type, string, bool> predicate, Func`2<ServiceRequest, object> factory);
    public abstract virtual IServiceRegistry RegisterFallback(Func`3<Type, string, bool> predicate, Func`2<ServiceRequest, object> factory, ILifetime lifetime);
    public abstract virtual IServiceRegistry Register(ServiceRegistration serviceRegistration);
    public abstract virtual IServiceRegistry RegisterAssembly(Assembly assembly);
    public abstract virtual IServiceRegistry RegisterAssembly(Assembly assembly, Func`3<Type, Type, bool> shouldRegister);
    public abstract virtual IServiceRegistry RegisterAssembly(Assembly assembly, Func`1<ILifetime> lifetimeFactory);
    public abstract virtual IServiceRegistry RegisterAssembly(Assembly assembly, Func`1<ILifetime> lifetimeFactory, Func`3<Type, Type, bool> shouldRegister);
    public abstract virtual IServiceRegistry RegisterAssembly(Assembly assembly, Func`1<ILifetime> lifetimeFactory, Func`3<Type, Type, bool> shouldRegister, Func`3<Type, Type, string> serviceNameProvider);
    public abstract virtual IServiceRegistry RegisterFrom();
    public abstract virtual IServiceRegistry RegisterFrom(TCompositionRoot compositionRoot);
    public abstract virtual IServiceRegistry RegisterConstructorDependency(Func`3<IServiceFactory, ParameterInfo, TDependency> factory);
    public abstract virtual IServiceRegistry RegisterConstructorDependency(Func`4<IServiceFactory, ParameterInfo, Object[], TDependency> factory);
    public abstract virtual IServiceRegistry RegisterPropertyDependency(Func`3<IServiceFactory, PropertyInfo, TDependency> factory);
    public abstract virtual IServiceRegistry RegisterAssembly(string searchPattern);
    public abstract virtual IServiceRegistry Decorate(Type serviceType, Type decoratorType, Func`2<ServiceRegistration, bool> predicate);
    public abstract virtual IServiceRegistry Decorate(Type serviceType, Type decoratorType);
    public abstract virtual IServiceRegistry Decorate();
    public abstract virtual IServiceRegistry Decorate(Func`3<IServiceFactory, TService, TService> factory);
    public abstract virtual IServiceRegistry Decorate(DecoratorRegistration decoratorRegistration);
    public abstract virtual IServiceRegistry Override(Func`2<ServiceRegistration, bool> serviceSelector, Func`3<IServiceFactory, ServiceRegistration, ServiceRegistration> serviceRegistrationFactory);
    public abstract virtual IServiceRegistry Initialize(Func`2<ServiceRegistration, bool> predicate, Action`2<IServiceFactory, object> processor);
    public abstract virtual IServiceRegistry SetDefaultLifetime();
}
public interface LightInject.ITypeConstructionInfoBuilder {
    public abstract virtual ConstructionInfo Execute(Registration registration);
}
public interface LightInject.ITypeExtractor {
    public abstract virtual Type[] Execute(Assembly assembly);
}
public class LightInject.KeyValue`2 : object {
    public TKey Key;
    public TValue Value;
    public KeyValue`2(TKey key, TValue value);
}
public class LightInject.LazyConcurrentDictionary`2 : object {
    private ConcurrentDictionary`2<TKey, Lazy`1<TValue>> concurrentDictionary;
    public TValue GetOrAdd(TKey key, Func`2<TKey, TValue> valueFactory);
    public bool ContainsUninitializedValue(TKey key);
    public void Remove(TKey key);
}
internal static class LightInject.LazyHelper : object {
    public static MethodInfo CreateScopedLazyMethod;
    public static MethodInfo CreateScopedLazyFromDelegateMethod;
    private static LazyHelper();
    public static Lazy`1<T> CreateScopedLazy(ServiceContainer serviceContainer, Scope scope);
    public static Lazy`1<T> CreateScopedLazyFromDelegate(GetInstanceDelegate getInstanceDelegate, Object[] constants, Scope scope);
}
[AttributeUsageAttribute("4")]
public class LightInject.LifeSpanAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; }
    public LifeSpanAttribute(int value);
    [CompilerGeneratedAttribute]
public int get_Value();
}
internal static class LightInject.LifetimeHelper : object {
    public static MethodInfo GetInstanceMethod;
    public static MethodInfo GetCurrentScopeMethod;
    private static ThreadSafeDictionary`2<Type, MethodInfo> NonClosingGetInstanceMethods;
    private static LifetimeHelper();
    public static MethodInfo GetNonClosingGetInstanceMethod(Type lifetimeType);
    private static MethodInfo ResolveNonClosingGetInstanceMethod(Type lifetimeType);
}
public class LightInject.LogEntry : object {
    [CompilerGeneratedAttribute]
private LogLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public LogLevel Level { get; private set; }
    public string Message { get; private set; }
    public LogEntry(LogLevel level, string message);
    [CompilerGeneratedAttribute]
public LogLevel get_Level();
    [CompilerGeneratedAttribute]
private void set_Level(LogLevel value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
}
[ExtensionAttribute]
public static class LightInject.LogExtensions : object {
    [ExtensionAttribute]
public static void Info(Action`1<LogEntry> logAction, string message);
    [ExtensionAttribute]
public static void Warning(Action`1<LogEntry> logAction, string message);
}
public class LightInject.LogicalThreadStorage`1 : object {
    private AsyncLocal`1<T> asyncLocal;
    public T Value { get; public set; }
    public T get_Value();
    public void set_Value(T value);
}
public enum LightInject.LogLevel : Enum {
    public int value__;
    public static LogLevel Info;
    public static LogLevel Warning;
}
public class LightInject.MostResolvableConstructorSelector : object {
    private Func`3<Type, string, bool> canGetInstance;
    private bool enableOptionalArguments;
    public MostResolvableConstructorSelector(Func`3<Type, string, bool> canGetInstance, bool enableOptionalArguments);
    public MostResolvableConstructorSelector(Func`3<Type, string, bool> canGetInstance);
    public sealed virtual ConstructorInfo Execute(Type implementingType);
    protected virtual string GetServiceName(ParameterInfo parameter);
    private bool CanCreateParameterDependencies(IEnumerable`1<ParameterInfo> parameters);
    private bool CanCreateParameterDependency(ParameterInfo parameterInfo);
}
[LifeSpanAttribute("30")]
public class LightInject.PerContainerLifetime : object {
    private object syncRoot;
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) singleton;
    public sealed virtual object GetInstance(Func`1<object> createInstance, Scope scope);
    public object GetInstance(GetInstanceDelegate createInstance, Scope scope, Object[] arguments);
    public sealed virtual ILifetime Clone();
}
public class LightInject.PerLogicalCallContextScopeManager : ScopeManager {
    private LogicalThreadStorage`1<Scope> currentScope;
    public Scope CurrentScope { get; public set; }
    public PerLogicalCallContextScopeManager(IServiceFactory serviceFactory);
    public virtual Scope get_CurrentScope();
    public virtual void set_CurrentScope(Scope value);
}
public class LightInject.PerLogicalCallContextScopeManagerProvider : ScopeManagerProvider {
    protected virtual IScopeManager CreateScopeManager(IServiceFactory serviceFactory);
}
[LifeSpanAttribute("10")]
public class LightInject.PerRequestLifeTime : object {
    public sealed virtual object GetInstance(Func`1<object> createInstance, Scope scope);
    public sealed virtual ILifetime Clone();
}
[LifeSpanAttribute("20")]
public class LightInject.PerScopeLifetime : object {
    public sealed virtual object GetInstance(Func`1<object> createInstance, Scope scope);
    public sealed virtual ILifetime Clone();
}
public class LightInject.PerThreadScopeManager : ScopeManager {
    private ThreadLocal`1<Scope> threadLocalScope;
    public Scope CurrentScope { get; public set; }
    public PerThreadScopeManager(IServiceFactory serviceFactory);
    public virtual Scope get_CurrentScope();
    public virtual void set_CurrentScope(Scope value);
}
public class LightInject.PerThreadScopeManagerProvider : ScopeManagerProvider {
    protected virtual IScopeManager CreateScopeManager(IServiceFactory serviceFactory);
}
public class LightInject.PropertyDependency : Dependency {
    [CompilerGeneratedAttribute]
private PropertyInfo <Property>k__BackingField;
    public PropertyInfo Property { get; public set; }
    public string Name { get; }
    [CompilerGeneratedAttribute]
public PropertyInfo get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(PropertyInfo value);
    public virtual string get_Name();
    public virtual string ToString();
}
public class LightInject.PropertyDependencySelector : object {
    [CompilerGeneratedAttribute]
private IPropertySelector <PropertySelector>k__BackingField;
    protected IPropertySelector PropertySelector { get; private set; }
    public PropertyDependencySelector(IPropertySelector propertySelector);
    [CompilerGeneratedAttribute]
protected IPropertySelector get_PropertySelector();
    [CompilerGeneratedAttribute]
private void set_PropertySelector(IPropertySelector value);
    public virtual IEnumerable`1<PropertyDependency> Execute(Type type);
}
public class LightInject.PropertySelector : object {
    public sealed virtual IEnumerable`1<PropertyInfo> Execute(Type type);
    protected virtual bool IsInjectable(PropertyInfo propertyInfo);
    private static bool IsReadOnly(PropertyInfo propertyInfo);
}
internal static class LightInject.ReflectionHelper : object {
    private static Lazy`1<ThreadSafeDictionary`2<Type, MethodInfo>> GetInstanceWithParametersMethods;
    private static ReflectionHelper();
    public static MethodInfo GetGetInstanceWithParametersMethod(Type serviceType);
    public static Delegate CreateGetNamedInstanceWithParametersDelegate(IServiceFactory factory, Type delegateType, string serviceName);
    private static Lazy`1<ThreadSafeDictionary`2<Type, MethodInfo>> CreateLazyGetInstanceWithParametersMethods();
    private static MethodInfo CreateGetInstanceWithParametersMethod(Type serviceType);
    private static Func`2<TArg, TService> CreateGenericGetNamedParameterizedInstanceDelegate(IServiceFactory factory, string serviceName);
    private static Func`3<TArg1, TArg2, TService> CreateGenericGetNamedParameterizedInstanceDelegate(IServiceFactory factory, string serviceName);
    private static Func`4<TArg1, TArg2, TArg3, TService> CreateGenericGetNamedParameterizedInstanceDelegate(IServiceFactory factory, string serviceName);
    private static Func`5<TArg1, TArg2, TArg3, TArg4, TService> CreateGenericGetNamedParameterizedInstanceDelegate(IServiceFactory factory, string serviceName);
}
public abstract class LightInject.Registration : object {
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ImplementingType>k__BackingField;
    [CompilerGeneratedAttribute]
private Delegate <FactoryExpression>k__BackingField;
    public Type ServiceType { get; public set; }
    public Type ImplementingType { get; public set; }
    public Delegate FactoryExpression { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_ServiceType();
    [CompilerGeneratedAttribute]
public void set_ServiceType(Type value);
    [CompilerGeneratedAttribute]
public virtual Type get_ImplementingType();
    [CompilerGeneratedAttribute]
public virtual void set_ImplementingType(Type value);
    [CompilerGeneratedAttribute]
public Delegate get_FactoryExpression();
    [CompilerGeneratedAttribute]
public void set_FactoryExpression(Delegate value);
}
public static class LightInject.RuntimeArgumentsLoader : object {
    public static Object[] Load(Object[] constants);
}
public class LightInject.Scope : object {
    public bool IsDisposed;
    public Scope ParentScope;
    private object lockObject;
    private IScopeManager scopeManager;
    private ServiceContainer serviceFactory;
    private List`1<object> disposableObjects;
    private ImmutableMapTree`1<object> createdInstances;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> Completed;
    public Scope(IScopeManager scopeManager, Scope parentScope);
    public Scope(ServiceContainer serviceFactory);
    [CompilerGeneratedAttribute]
public void add_Completed(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Completed(EventHandler`1<EventArgs> value);
    public void TrackInstance(object disposable);
    public sealed virtual void Dispose();
    public sealed virtual ValueTask DisposeAsync();
    private void EndScope();
    public sealed virtual Scope BeginScope();
    public sealed virtual object GetInstance(Type serviceType);
    public sealed virtual object GetInstance(Type serviceType, string serviceName);
    public sealed virtual object GetInstance(Type serviceType, Object[] arguments);
    public sealed virtual object GetInstance(Type serviceType, string serviceName, Object[] arguments);
    public sealed virtual object TryGetInstance(Type serviceType);
    public sealed virtual object TryGetInstance(Type serviceType, string serviceName);
    public sealed virtual IEnumerable`1<object> GetAllInstances(Type serviceType);
    public sealed virtual object Create(Type serviceType);
    internal object GetScopedInstance(GetInstanceDelegate getInstanceDelegate, Object[] arguments, int instanceDelegateIndex);
    [AsyncStateMachineAttribute("LightInject.Scope/<<DisposeAsync>g__Await|14_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask <DisposeAsync>g__Await|14_0(int i, ValueTask vt, List`1<object> toDispose, HashSet`1<object> disposedObjects);
}
internal static class LightInject.ScopeLoader : object {
    public static MethodInfo GetThisOrCurrentScopeMethod;
    public static MethodInfo GetScopedInstanceMethod;
    public static MethodInfo ValidateScopeMethod;
    public static MethodInfo ValidateTrackedTransientMethod;
    private static ScopeLoader();
    public static object ValidateTrackedTransient(object instance, Scope scope);
    public static Scope ValidateScope(Scope scope);
    public static Scope GetThisOrCurrentScope(Scope scope, IScopeManager scopeManager);
}
public abstract class LightInject.ScopeManager : object {
    [CompilerGeneratedAttribute]
private IServiceFactory <ServiceFactory>k__BackingField;
    public Scope CurrentScope { get; public set; }
    public IServiceFactory ServiceFactory { get; }
    protected ScopeManager(IServiceFactory serviceFactory);
    public abstract virtual Scope get_CurrentScope();
    public abstract virtual void set_CurrentScope(Scope value);
    [CompilerGeneratedAttribute]
public sealed virtual IServiceFactory get_ServiceFactory();
    public sealed virtual Scope BeginScope();
    public sealed virtual void EndScope(Scope scope);
    protected Scope GetThisScopeOrFirstValidAncestor(Scope scope);
}
public abstract class LightInject.ScopeManagerProvider : object {
    private object lockObject;
    private IScopeManager scopeManager;
    public sealed virtual IScopeManager GetScopeManager(IServiceFactory serviceFactory);
    protected abstract virtual IScopeManager CreateScopeManager(IServiceFactory serviceFactory);
}
public class LightInject.ServiceContainer : object {
    private static string UnresolvedDependencyError;
    private static MethodInfo OpenGenericTrackInstanceMethod;
    private Action`1<LogEntry> log;
    private Func`3<Type, Type[], IMethodSkeleton> methodSkeletonFactory;
    private ServiceRegistry`1<Action`1<IEmitter>> emitters;
    private ServiceRegistry`1<Delegate> constructorDependencyFactories;
    private ServiceRegistry`1<Delegate> propertyDependencyFactories;
    private ServiceRegistry`1<ServiceRegistration> availableServices;
    private object lockObject;
    private ContainerOptions options;
    private Storage`1<object> constants;
    private Storage`1<ILifetime> disposableLifeTimes;
    private Storage`1<DecoratorRegistration> decorators;
    private Storage`1<ServiceOverride> overrides;
    private Storage`1<FactoryRule> factoryRules;
    private Storage`1<Initializer> initializers;
    private Stack`1<Action`1<IEmitter>> dependencyStack;
    private Lazy`1<IConstructionInfoProvider> constructionInfoProvider;
    private List`1<IDisposable> disposableObjects;
    private LazyConcurrentDictionary`2<ServiceRegistration, int> servicesToDelegatesIndex;
    private ImmutableHashTable`2<Type, GetInstanceDelegate> delegates;
    private ImmutableHashTable`2<ValueTuple`2<Type, string>, GetInstanceDelegate> namedDelegates;
    private ImmutableHashTree`2<Type, Func`4<Object[], Scope, object, object>> propertyInjectionDelegates;
    private bool isLocked;
    private Type defaultLifetimeType;
    [CompilerGeneratedAttribute]
private IScopeManagerProvider <ScopeManagerProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IPropertyDependencySelector <PropertyDependencySelector>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeExtractor <CompositionRootTypeExtractor>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceNameProvider <ServiceNameProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ICompositionRootExecutor <CompositionRootExecutor>k__BackingField;
    [CompilerGeneratedAttribute]
private IConstructorDependencySelector <ConstructorDependencySelector>k__BackingField;
    [CompilerGeneratedAttribute]
private IConstructorSelector <ConstructorSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private IGenericArgumentMapper <GenericArgumentMapper>k__BackingField;
    [CompilerGeneratedAttribute]
private IAssemblyScanner <AssemblyScanner>k__BackingField;
    [CompilerGeneratedAttribute]
private IAssemblyLoader <AssemblyLoader>k__BackingField;
    public IScopeManagerProvider ScopeManagerProvider { get; public set; }
    public IPropertyDependencySelector PropertyDependencySelector { get; public set; }
    public ITypeExtractor CompositionRootTypeExtractor { get; public set; }
    public IServiceNameProvider ServiceNameProvider { get; public set; }
    public ICompositionRootExecutor CompositionRootExecutor { get; public set; }
    public IConstructorDependencySelector ConstructorDependencySelector { get; public set; }
    public IConstructorSelector ConstructorSelector { get; public set; }
    public IGenericArgumentMapper GenericArgumentMapper { get; public set; }
    public IAssemblyScanner AssemblyScanner { get; public set; }
    public IAssemblyLoader AssemblyLoader { get; public set; }
    public IEnumerable`1<ServiceRegistration> AvailableServices { get; }
    private ILifetime DefaultLifetime { get; }
    public ServiceContainer(Action`1<ContainerOptions> configureOptions);
    public ServiceContainer(ContainerOptions options);
    private ServiceContainer(ContainerOptions options, ServiceRegistry`1<Delegate> constructorDependencyFactories, ServiceRegistry`1<Delegate> propertyDependencyFactories, ServiceRegistry`1<ServiceRegistration> availableServices, Storage`1<DecoratorRegistration> decorators, Storage`1<ServiceOverride> overrides, Storage`1<FactoryRule> factoryRules, Storage`1<Initializer> initializers, Lazy`1<IConstructionInfoProvider> constructionInfoProvider, Func`3<Type, Type[], IMethodSkeleton> methodSkeletonFactory, Action`1<LogEntry> log, ICompositionRootExecutor compositionRootExecutor, IServiceNameProvider serviceNameProvider, IPropertyDependencySelector propertyDependencySelector, IGenericArgumentMapper genericArgumentMapper, IAssemblyScanner assemblyScanner, IConstructorDependencySelector constructorDependencySelector, IConstructorSelector constructorSelector, IAssemblyLoader assemblyLoader, IScopeManagerProvider scopeManagerProvider);
    private static ServiceContainer();
    [CompilerGeneratedAttribute]
public sealed virtual IScopeManagerProvider get_ScopeManagerProvider();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ScopeManagerProvider(IScopeManagerProvider value);
    [CompilerGeneratedAttribute]
public IPropertyDependencySelector get_PropertyDependencySelector();
    [CompilerGeneratedAttribute]
public void set_PropertyDependencySelector(IPropertyDependencySelector value);
    [CompilerGeneratedAttribute]
public ITypeExtractor get_CompositionRootTypeExtractor();
    [CompilerGeneratedAttribute]
public void set_CompositionRootTypeExtractor(ITypeExtractor value);
    [CompilerGeneratedAttribute]
public IServiceNameProvider get_ServiceNameProvider();
    [CompilerGeneratedAttribute]
public void set_ServiceNameProvider(IServiceNameProvider value);
    [CompilerGeneratedAttribute]
public ICompositionRootExecutor get_CompositionRootExecutor();
    [CompilerGeneratedAttribute]
public void set_CompositionRootExecutor(ICompositionRootExecutor value);
    [CompilerGeneratedAttribute]
public IConstructorDependencySelector get_ConstructorDependencySelector();
    [CompilerGeneratedAttribute]
public void set_ConstructorDependencySelector(IConstructorDependencySelector value);
    [CompilerGeneratedAttribute]
public IConstructorSelector get_ConstructorSelector();
    [CompilerGeneratedAttribute]
public void set_ConstructorSelector(IConstructorSelector value);
    [CompilerGeneratedAttribute]
public IGenericArgumentMapper get_GenericArgumentMapper();
    [CompilerGeneratedAttribute]
public void set_GenericArgumentMapper(IGenericArgumentMapper value);
    [CompilerGeneratedAttribute]
public IAssemblyScanner get_AssemblyScanner();
    [CompilerGeneratedAttribute]
public void set_AssemblyScanner(IAssemblyScanner value);
    [CompilerGeneratedAttribute]
public IAssemblyLoader get_AssemblyLoader();
    [CompilerGeneratedAttribute]
public void set_AssemblyLoader(IAssemblyLoader value);
    public sealed virtual IEnumerable`1<ServiceRegistration> get_AvailableServices();
    private ILifetime get_DefaultLifetime();
    public sealed virtual bool CanGetInstance(Type serviceType, string serviceName);
    public sealed virtual Scope BeginScope();
    public sealed virtual object InjectProperties(object instance);
    public sealed virtual IServiceRegistry Register(Func`2<IServiceFactory, TService> factory, string serviceName, ILifetime lifetime);
    public sealed virtual IServiceRegistry RegisterFallback(Func`3<Type, string, bool> predicate, Func`2<ServiceRequest, object> factory);
    public sealed virtual IServiceRegistry RegisterFallback(Func`3<Type, string, bool> predicate, Func`2<ServiceRequest, object> factory, ILifetime lifetime);
    public sealed virtual IServiceRegistry Register(ServiceRegistration serviceRegistration);
    public sealed virtual IServiceRegistry RegisterAssembly(Assembly assembly);
    public sealed virtual IServiceRegistry RegisterAssembly(Assembly assembly, Func`3<Type, Type, bool> shouldRegister);
    public sealed virtual IServiceRegistry RegisterAssembly(Assembly assembly, Func`1<ILifetime> lifetimeFactory);
    public sealed virtual IServiceRegistry RegisterAssembly(Assembly assembly, Func`1<ILifetime> lifetimeFactory, Func`3<Type, Type, bool> shouldRegister);
    public sealed virtual IServiceRegistry RegisterAssembly(Assembly assembly, Func`1<ILifetime> lifetimeFactory, Func`3<Type, Type, bool> shouldRegister, Func`3<Type, Type, string> serviceNameProvider);
    public sealed virtual IServiceRegistry RegisterFrom();
    public sealed virtual IServiceRegistry RegisterFrom(TCompositionRoot compositionRoot);
    public sealed virtual IServiceRegistry RegisterConstructorDependency(Func`3<IServiceFactory, ParameterInfo, TDependency> factory);
    public sealed virtual IServiceRegistry RegisterConstructorDependency(Func`4<IServiceFactory, ParameterInfo, Object[], TDependency> factory);
    public sealed virtual IServiceRegistry RegisterPropertyDependency(Func`3<IServiceFactory, PropertyInfo, TDependency> factory);
    public sealed virtual IServiceRegistry RegisterAssembly(string searchPattern);
    public sealed virtual IServiceRegistry Decorate(Type serviceType, Type decoratorType, Func`2<ServiceRegistration, bool> predicate);
    public sealed virtual IServiceRegistry Decorate(Type serviceType, Type decoratorType);
    public sealed virtual IServiceRegistry Decorate();
    public sealed virtual IServiceRegistry Decorate(Func`3<IServiceFactory, TService, TService> factory);
    public sealed virtual IServiceRegistry Decorate(DecoratorRegistration decoratorRegistration);
    public sealed virtual IServiceRegistry Override(Func`2<ServiceRegistration, bool> serviceSelector, Func`3<IServiceFactory, ServiceRegistration, ServiceRegistration> serviceRegistrationFactory);
    public sealed virtual IServiceRegistry Initialize(Func`2<ServiceRegistration, bool> predicate, Action`2<IServiceFactory, object> processor);
    public sealed virtual IServiceRegistry Register(Type serviceType, Type implementingType, ILifetime lifetime);
    public sealed virtual IServiceRegistry Register(Type serviceType, Type implementingType, string serviceName, ILifetime lifetime);
    public sealed virtual IServiceRegistry Register();
    public sealed virtual IServiceRegistry Register(ILifetime lifetime);
    public sealed virtual IServiceRegistry Register(string serviceName);
    public sealed virtual IServiceRegistry Register(string serviceName, ILifetime lifetime);
    public sealed virtual IServiceRegistry Register(Func`2<IServiceFactory, TService> factory, ILifetime lifetime);
    public sealed virtual IServiceRegistry Register(Func`2<IServiceFactory, TService> factory, string serviceName);
    public sealed virtual IServiceRegistry Register();
    public sealed virtual IServiceRegistry Register(Type serviceType);
    public sealed virtual IServiceRegistry Register(Type serviceType, ILifetime lifetime);
    public sealed virtual IServiceRegistry Register(ILifetime lifetime);
    public sealed virtual IServiceRegistry RegisterInstance(TService instance, string serviceName);
    public sealed virtual IServiceRegistry RegisterInstance(TService instance);
    public sealed virtual IServiceRegistry RegisterInstance(Type serviceType, object instance);
    public sealed virtual IServiceRegistry RegisterInstance(Type serviceType, object instance, string serviceName);
    public sealed virtual IServiceRegistry Register(Func`2<IServiceFactory, TService> factory);
    public sealed virtual IServiceRegistry Register(Func`3<IServiceFactory, T, TService> factory);
    public sealed virtual IServiceRegistry Register(Func`3<IServiceFactory, T, TService> factory, string serviceName);
    public sealed virtual IServiceRegistry Register(Func`4<IServiceFactory, T1, T2, TService> factory);
    public sealed virtual IServiceRegistry Register(Func`4<IServiceFactory, T1, T2, TService> factory, string serviceName);
    public sealed virtual IServiceRegistry Register(Func`5<IServiceFactory, T1, T2, T3, TService> factory);
    public sealed virtual IServiceRegistry Register(Func`5<IServiceFactory, T1, T2, T3, TService> factory, string serviceName);
    public sealed virtual IServiceRegistry Register(Func`6<IServiceFactory, T1, T2, T3, T4, TService> factory);
    public sealed virtual IServiceRegistry Register(Func`6<IServiceFactory, T1, T2, T3, T4, TService> factory, string serviceName);
    public sealed virtual IServiceRegistry Register(Type serviceType, Type implementingType, string serviceName);
    public sealed virtual IServiceRegistry Register(Type serviceType, Type implementingType);
    public sealed virtual IServiceRegistry RegisterOrdered(Type serviceType, Type[] implementingTypes, Func`2<Type, ILifetime> lifeTimeFactory);
    public sealed virtual IServiceRegistry RegisterOrdered(Type serviceType, Type[] implementingTypes, Func`2<Type, ILifetime> lifeTimeFactory, Func`2<int, string> serviceNameFormatter);
    public sealed virtual void Compile(Func`2<ServiceRegistration, bool> predicate);
    public sealed virtual void Compile();
    public sealed virtual void Compile(string serviceName);
    public sealed virtual object GetInstance(Type serviceType);
    public sealed virtual object GetInstance(Type serviceType, Object[] arguments);
    public sealed virtual object GetInstance(Type serviceType, string serviceName, Object[] arguments);
    public sealed virtual object TryGetInstance(Type serviceType);
    public sealed virtual object TryGetInstance(Type serviceType, string serviceName);
    public sealed virtual object GetInstance(Type serviceType, string serviceName);
    public sealed virtual IEnumerable`1<object> GetAllInstances(Type serviceType);
    public sealed virtual object Create(Type serviceType);
    public sealed virtual IServiceRegistry SetDefaultLifetime();
    public sealed virtual void Dispose();
    public ServiceContainer Clone();
    internal static TService TrackInstance(TService instance, ServiceContainer container);
    internal object GetInstance(Type serviceType, Scope scope);
    internal object GetInstance(Type serviceType, Scope scope, string serviceName);
    internal IEnumerable`1<object> GetAllInstances(Type serviceType, Scope scope);
    internal object GetInstance(Type serviceType, Object[] arguments, Scope scope);
    internal object GetInstance(Type serviceType, string serviceName, Object[] arguments, Scope scope);
    internal object TryGetInstance(Type serviceType, Scope scope);
    internal object TryGetInstance(Type serviceType, string serviceName, Scope scope);
    internal object Create(Type serviceType, Scope scope);
    private static void EmitEnumerable(IList`1<Action`1<IEmitter>> serviceEmitters, Type elementType, IEmitter emitter);
    private static void EmitNewArray(IList`1<Action`1<IEmitter>> emitMethods, Type elementType, IEmitter emitter);
    private static ILifetime CloneLifeTime(ILifetime lifetime);
    private static ConstructorDependency GetConstructorDependencyThatRepresentsDecoratorTarget(DecoratorRegistration decoratorRegistration, ConstructionInfo constructionInfo);
    private static void PushRuntimeArguments(IEmitter emitter);
    private DecoratorRegistration CreateClosedGenericDecoratorRegistration(ServiceRegistration serviceRegistration, DecoratorRegistration openGenericDecorator);
    private bool TryCreateClosedGenericDecoratorType(Type serviceType, Type implementingType, Type& closedGenericDecoratorType);
    private Func`4<Object[], Scope, object, object> CreatePropertyInjectionDelegate(Type concreteType);
    private ConstructionInfoProvider CreateConstructionInfoProvider();
    private TypeConstructionInfoBuilder CreateTypeConstructionInfoBuilder();
    private Delegate GetConstructorDependencyDelegate(Type type, string serviceName);
    private Delegate GetPropertyDependencyExpression(Type type, string serviceName);
    private GetInstanceDelegate CreateDynamicMethodDelegate(Action`1<IEmitter> serviceEmitter);
    private Action`1<IEmitter> GetEmitMethod(Type serviceType, string serviceName);
    private Action`1<IEmitter> TryGetFallbackEmitMethod(Type serviceType, string serviceName);
    private Action`1<IEmitter> CreateEmitMethodWrapper(Action`1<IEmitter> emitter, Type serviceType, string serviceName);
    private Action`1<IEmitter> GetRegisteredEmitMethod(Type serviceType, string serviceName);
    private ServiceRegistration AddServiceRegistration(ServiceRegistration serviceRegistration);
    private void RegisterEmitMethod(Type serviceType, string serviceName, Action`1<IEmitter> emitMethod);
    private ServiceRegistration UpdateServiceRegistration(ServiceRegistration existingRegistration, ServiceRegistration newRegistration);
    private DecoratorRegistration[] GetDecorators(ServiceRegistration serviceRegistration);
    private IEnumerable`1<DecoratorRegistration> GetOpenGenericDecoratorRegistrations(ServiceRegistration serviceRegistration);
    private IEnumerable`1<DecoratorRegistration> GetDeferredDecoratorRegistrations(ServiceRegistration serviceRegistration);
    private void EmitNewDecoratorInstance(DecoratorRegistration decoratorRegistration, IEmitter emitter, Action`1<IEmitter> pushInstance);
    private void EmitNewDecoratorUsingFactoryDelegate(Delegate factoryDelegate, IEmitter emitter, Action`1<IEmitter> pushInstance);
    private void EmitNewInstance(ServiceRegistration serviceRegistration, IEmitter emitter);
    private void EmitDecorators(ServiceRegistration serviceRegistration, IEnumerable`1<DecoratorRegistration> serviceDecorators, IEmitter emitter, Action`1<IEmitter> decoratorTargetEmitMethod);
    private void EmitNewInstanceUsingImplementingType(IEmitter emitter, ConstructionInfo constructionInfo, Action`1<IEmitter> decoratorTargetEmitMethod);
    private void EmitNewInstanceUsingFactoryDelegate(ServiceRegistration serviceRegistration, IEmitter emitter);
    private void EmitConstructorDependencies(ConstructionInfo constructionInfo, IEmitter emitter, Action`1<IEmitter> decoratorTargetEmitter);
    private void EmitConstructorDependency(IEmitter emitter, Dependency dependency);
    private void EmitPropertyDependency(IEmitter emitter, PropertyDependency propertyDependency, LocalBuilder instanceVariable);
    private Action`1<IEmitter> GetEmitMethodForDependency(Dependency dependency);
    private Action`1<IEmitter> GetEmitMethodForDefaultValue(ConstructorDependency constructorDependency);
    private void EmitDependencyUsingFactoryExpression(IEmitter emitter, Dependency dependency);
    private void EmitPropertyDependencies(ConstructionInfo constructionInfo, IEmitter emitter);
    private Action`1<IEmitter> CreateEmitMethodForUnknownService(Type serviceType, string serviceName);
    private Action`1<IEmitter> CreateEmitMethodBasedOnFuncServiceRequest(Type serviceType);
    private Action`1<IEmitter> CreateEmitMethodBasedParameterizedFuncRequest(Type serviceType, string serviceName);
    private Delegate CreateGetInstanceWithParametersDelegate(Type serviceType);
    private Action`1<IEmitter> CreateServiceEmitterBasedOnFactoryRule(FactoryRule rule, Type serviceType, string serviceName);
    private Action`1<IEmitter> CreateEmitMethodForArrayServiceRequest(Type serviceType);
    private Action`1<IEmitter> CreateEmitMethodForListServiceRequest(Type serviceType);
    private Action`1<IEmitter> CreateEmitMethodForReadOnlyCollectionServiceRequest(Type serviceType);
    private Action`1<IEmitter> CreateEmitMethodBasedOnLazyServiceRequest(Type serviceType);
    private ThreadSafeDictionary`2<string, ServiceRegistration> GetOpenGenericServiceRegistrations(Type openGenericServiceType);
    private Action`1<IEmitter> CreateEmitMethodBasedOnClosedGenericServiceRequest(Type closedGenericServiceType, string serviceName);
    private Action`1<IEmitter> CreateEmitMethodForEnumerableServiceServiceRequest(Type serviceType);
    private Action`1<IEmitter> CreateServiceEmitterBasedOnSingleNamedInstance(Type serviceType);
    private bool CanRedirectRequestForDefaultServiceToSingleNamedService(Type serviceType, string serviceName);
    private ConstructionInfo GetConstructionInfo(Registration registration);
    private ThreadSafeDictionary`2<string, Action`1<IEmitter>> GetEmitMethods(Type serviceType);
    private ThreadSafeDictionary`2<string, ServiceRegistration> GetAvailableServices(Type serviceType);
    private ThreadSafeDictionary`2<string, Delegate> GetConstructorDependencyFactories(Type dependencyType);
    private ThreadSafeDictionary`2<string, Delegate> GetPropertyDependencyFactories(Type dependencyType);
    private void RegisterService(Type serviceType, Type implementingType, ILifetime lifetime, string serviceName);
    private void EnsureConstructable(Type serviceType, Type implementingType);
    private Action`1<IEmitter> ResolveEmitMethod(ServiceRegistration serviceRegistration);
    private void EmitNewInstanceWithDecorators(ServiceRegistration serviceRegistration, IEmitter emitter);
    private int GetInstanceDelegateIndex(ServiceRegistration serviceRegistration, Action`1<IEmitter> emitMethod);
    private void EmitLifetime(ServiceRegistration serviceRegistration, Action`1<IEmitter> emitMethod, IEmitter emitter);
    private void PushScope(IEmitter emitter);
    private int CreateScopeManagerIndex();
    private int CreateInstanceDelegateIndex(Action`1<IEmitter> emitMethod);
    private int CreateLifetimeIndex(ILifetime lifetime);
    private GetInstanceDelegate CreateDefaultDelegate(Type serviceType, bool throwError);
    private GetInstanceDelegate CreateNamedDelegate(ValueTuple`2<Type, string> key, bool throwError);
    private GetInstanceDelegate CreateDelegate(Type serviceType, string serviceName, bool throwError);
    private void RegisterValue(Type serviceType, object value, string serviceName);
    private void RegisterServiceFromLambdaExpression(Delegate factory, ILifetime lifetime, string serviceName);
    [CompilerGeneratedAttribute]
private ILifetime <RegisterAssembly>b__81_0();
    [CompilerGeneratedAttribute]
internal static string <Compile>g__GetPrettyName|127_0(Type type);
    [CompilerGeneratedAttribute]
private Action`1<IEmitter> <CreateEmitMethodBasedOnClosedGenericServiceRequest>g__RegisterAndGetEmitMethod|196_0(<>c__DisplayClass196_0& );
    [CompilerGeneratedAttribute]
internal static bool <EmitNewInstanceWithDecorators>g__IsNotServiceFactory|208_2(Type serviceType);
    [CompilerGeneratedAttribute]
internal static bool <EmitLifetime>g__IsNotServiceFactory|210_0(Type serviceType);
}
[ExtensionAttribute]
public static class LightInject.ServiceFactoryExtensions : object {
    [ExtensionAttribute]
public static TService GetInstance(IServiceFactory factory);
    [ExtensionAttribute]
public static TService GetInstance(IServiceFactory factory, string serviceName);
    [ExtensionAttribute]
public static TService GetInstance(IServiceFactory factory, T value);
    [ExtensionAttribute]
public static TService GetInstance(IServiceFactory factory, T value, string serviceName);
    [ExtensionAttribute]
public static TService GetInstance(IServiceFactory factory, T1 arg1, T2 arg2);
    [ExtensionAttribute]
public static TService GetInstance(IServiceFactory factory, T1 arg1, T2 arg2, string serviceName);
    [ExtensionAttribute]
public static TService GetInstance(IServiceFactory factory, T1 arg1, T2 arg2, T3 arg3);
    [ExtensionAttribute]
public static TService GetInstance(IServiceFactory factory, T1 arg1, T2 arg2, T3 arg3, string serviceName);
    [ExtensionAttribute]
public static TService GetInstance(IServiceFactory factory, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [ExtensionAttribute]
public static TService GetInstance(IServiceFactory factory, T1 arg1, T2 arg2, T3 arg3, T4 arg4, string serviceName);
    [ExtensionAttribute]
public static TService TryGetInstance(IServiceFactory factory);
    [ExtensionAttribute]
public static TService TryGetInstance(IServiceFactory factory, string serviceName);
    [ExtensionAttribute]
public static IEnumerable`1<TService> GetAllInstances(IServiceFactory factory);
    [ExtensionAttribute]
public static TService Create(IServiceFactory factory);
}
internal static class LightInject.ServiceFactoryLoader : object {
    public static MethodInfo LoadServiceFactoryMethod;
    private static ServiceFactoryLoader();
    public static IServiceFactory LoadServiceFactory(IServiceFactory serviceFactory, IScopeManager scopeManager, Scope scope);
}
public class LightInject.ServiceNameProvider : object {
    public sealed virtual string GetServiceName(Type serviceType, Type implementingType);
}
public class LightInject.ServiceRegistration : Registration {
    [CompilerGeneratedAttribute]
private string <ServiceName>k__BackingField;
    [CompilerGeneratedAttribute]
private ILifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string ServiceName { get; public set; }
    public ILifetime Lifetime { get; public set; }
    public object Value { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ServiceName();
    [CompilerGeneratedAttribute]
public void set_ServiceName(string value);
    [CompilerGeneratedAttribute]
public ILifetime get_Lifetime();
    [CompilerGeneratedAttribute]
public void set_Lifetime(ILifetime value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class LightInject.ServiceRegistryExtensions : object {
    [ExtensionAttribute]
public static IServiceRegistry Register(IServiceRegistry serviceRegistry, Type serviceType, Func`2<IServiceFactory, object> factory);
    [ExtensionAttribute]
public static IServiceRegistry Register(IServiceRegistry serviceRegistry, Type serviceType, Func`2<IServiceFactory, object> factory, ILifetime lifetime);
    [ExtensionAttribute]
public static IServiceRegistry Register(IServiceRegistry serviceRegistry, Type serviceType, Func`2<IServiceFactory, object> factory, string serviceName);
    [ExtensionAttribute]
public static IServiceRegistry Register(IServiceRegistry serviceRegistry, Type serviceType, Func`2<IServiceFactory, object> factory, string serviceName, ILifetime lifetime);
    [ExtensionAttribute]
public static IServiceRegistry RegisterSingleton(IServiceRegistry serviceRegistry, Type serviceType, Func`2<IServiceFactory, object> factory);
    [ExtensionAttribute]
public static IServiceRegistry RegisterSingleton(IServiceRegistry serviceRegistry, Type serviceType, Func`2<IServiceFactory, object> factory, string serviceName);
    [ExtensionAttribute]
public static IServiceRegistry RegisterScoped(IServiceRegistry serviceRegistry, Type serviceType, Func`2<IServiceFactory, object> factory);
    [ExtensionAttribute]
public static IServiceRegistry RegisterScoped(IServiceRegistry serviceRegistry, Type serviceType, Func`2<IServiceFactory, object> factory, string serviceName);
    [ExtensionAttribute]
public static IServiceRegistry RegisterTransient(IServiceRegistry serviceRegistry, Type serviceType, Func`2<IServiceFactory, object> factory);
    [ExtensionAttribute]
public static IServiceRegistry RegisterTransient(IServiceRegistry serviceRegistry, Type serviceType, Func`2<IServiceFactory, object> factory, string serviceName);
    [ExtensionAttribute]
public static IServiceRegistry RegisterSingleton(IServiceRegistry serviceRegistry);
    [ExtensionAttribute]
public static IServiceRegistry RegisterSingleton(IServiceRegistry serviceRegistry);
    [ExtensionAttribute]
public static IServiceRegistry RegisterSingleton(IServiceRegistry serviceRegistry, string serviceName);
    [ExtensionAttribute]
public static IServiceRegistry RegisterSingleton(IServiceRegistry serviceRegistry, Type serviceType, Type implementingType);
    [ExtensionAttribute]
public static IServiceRegistry RegisterSingleton(IServiceRegistry serviceRegistry, Type serviceType);
    [ExtensionAttribute]
public static IServiceRegistry RegisterSingleton(IServiceRegistry serviceRegistry, Type serviceType, Type implementingType, string serviceName);
    [ExtensionAttribute]
public static IServiceRegistry RegisterSingleton(IServiceRegistry serviceRegistry, Func`2<IServiceFactory, TService> factory);
    [ExtensionAttribute]
public static IServiceRegistry RegisterSingleton(IServiceRegistry serviceRegistry, Func`2<IServiceFactory, TService> factory, string serviceName);
    [ExtensionAttribute]
public static IServiceRegistry RegisterScoped(IServiceRegistry serviceRegistry);
    [ExtensionAttribute]
public static IServiceRegistry RegisterScoped(IServiceRegistry serviceRegistry);
    [ExtensionAttribute]
public static IServiceRegistry RegisterScoped(IServiceRegistry serviceRegistry, string serviceName);
    [ExtensionAttribute]
public static IServiceRegistry RegisterScoped(IServiceRegistry serviceRegistry, Type serviceType, Type implementingType);
    [ExtensionAttribute]
public static IServiceRegistry RegisterScoped(IServiceRegistry serviceRegistry, Type serviceType);
    [ExtensionAttribute]
public static IServiceRegistry RegisterScoped(IServiceRegistry serviceRegistry, Type serviceType, Type implementingType, string serviceName);
    [ExtensionAttribute]
public static IServiceRegistry RegisterScoped(IServiceRegistry serviceRegistry, Func`2<IServiceFactory, TService> factory);
    [ExtensionAttribute]
public static IServiceRegistry RegisterScoped(IServiceRegistry serviceRegistry, Func`2<IServiceFactory, TService> factory, string serviceName);
    [ExtensionAttribute]
public static IServiceRegistry RegisterTransient(IServiceRegistry serviceRegistry);
    [ExtensionAttribute]
public static IServiceRegistry RegisterTransient(IServiceRegistry serviceRegistry);
    [ExtensionAttribute]
public static IServiceRegistry RegisterTransient(IServiceRegistry serviceRegistry, string serviceName);
    [ExtensionAttribute]
public static IServiceRegistry RegisterTransient(IServiceRegistry serviceRegistry, Type serviceType, Type implementingType);
    [ExtensionAttribute]
public static IServiceRegistry RegisterTransient(IServiceRegistry serviceRegistry, Type serviceType);
    [ExtensionAttribute]
public static IServiceRegistry RegisterTransient(IServiceRegistry serviceRegistry, Type serviceType, Type implementingType, string serviceName);
    [ExtensionAttribute]
public static IServiceRegistry RegisterTransient(IServiceRegistry serviceRegistry, Func`2<IServiceFactory, TService> factory);
    [ExtensionAttribute]
public static IServiceRegistry RegisterTransient(IServiceRegistry serviceRegistry, Func`2<IServiceFactory, TService> factory, string serviceName);
    [ExtensionAttribute]
public static IServiceRegistry Override(IServiceRegistry serviceRegistry);
    [ExtensionAttribute]
public static IServiceRegistry Override(IServiceRegistry serviceRegistry, ILifetime lifetime);
    [ExtensionAttribute]
public static IServiceRegistry Initialize(IServiceRegistry serviceRegistry, Action`2<IServiceFactory, TService> processor);
}
public class LightInject.ServiceRequest : object {
    [CompilerGeneratedAttribute]
private Type <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServiceName>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceFactory <ServiceFactory>k__BackingField;
    public Type ServiceType { get; private set; }
    public string ServiceName { get; private set; }
    public IServiceFactory ServiceFactory { get; private set; }
    public ServiceRequest(Type serviceType, string serviceName, IServiceFactory serviceFactory);
    [CompilerGeneratedAttribute]
public Type get_ServiceType();
    [CompilerGeneratedAttribute]
private void set_ServiceType(Type value);
    [CompilerGeneratedAttribute]
public string get_ServiceName();
    [CompilerGeneratedAttribute]
private void set_ServiceName(string value);
    [CompilerGeneratedAttribute]
public IServiceFactory get_ServiceFactory();
    [CompilerGeneratedAttribute]
private void set_ServiceFactory(IServiceFactory value);
}
internal static class LightInject.ServiceRequestHelper : object {
    public static MethodInfo CreateServiceRequestMethod;
    private static ServiceRequestHelper();
    public static ServiceRequest CreateServiceRequest(string serviceName, IServiceFactory serviceFactory);
}
public class LightInject.ThreadSafeDictionary`2 : ConcurrentDictionary`2<TKey, TValue> {
    public ThreadSafeDictionary`2(IEqualityComparer`1<TKey> comparer);
}
public class LightInject.TypeConstructionInfoBuilder : object {
    private IConstructorSelector constructorSelector;
    private IConstructorDependencySelector constructorDependencySelector;
    private IPropertyDependencySelector propertyDependencySelector;
    private Func`3<Type, string, Delegate> getConstructorDependencyExpression;
    private Func`3<Type, string, Delegate> getPropertyDependencyExpression;
    public TypeConstructionInfoBuilder(IConstructorSelector constructorSelector, IConstructorDependencySelector constructorDependencySelector, IPropertyDependencySelector propertyDependencySelector, Func`3<Type, string, Delegate> getConstructorDependencyExpression, Func`3<Type, string, Delegate> getPropertyDependencyExpression);
    public sealed virtual ConstructionInfo Execute(Registration registration);
    private IEnumerable`1<ConstructorDependency> GetConstructorDependencies(ConstructorInfo constructorInfo);
    private IEnumerable`1<PropertyDependency> GetPropertyDependencies(Type implementingType);
}
[ExtensionAttribute]
internal static class LightInject.TypeHelper : object {
    public static Type TryMakeGenericType(Type openGenericType, Type[] closedGenericArguments);
    [ExtensionAttribute]
public static bool IsEnumerableOfT(Type type);
    [ExtensionAttribute]
public static bool IsListOfT(Type type);
    [ExtensionAttribute]
public static bool IsCollectionOfT(Type type);
    [ExtensionAttribute]
public static bool IsReadOnlyCollectionOfT(Type type);
    [ExtensionAttribute]
public static bool IsReadOnlyListOfT(Type type);
    [ExtensionAttribute]
public static bool IsLazy(Type type);
    [ExtensionAttribute]
public static bool IsFuncRepresentingService(Type type);
    [ExtensionAttribute]
public static bool IsFuncWithParameters(Type type);
    [ExtensionAttribute]
public static bool IsFuncRepresentingNamedService(Type type);
    [ExtensionAttribute]
public static bool IsClosedGeneric(Type type);
    public static Type GetElementType(Type type);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
