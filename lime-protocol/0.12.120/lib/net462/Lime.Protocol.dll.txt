public class Lime.Protocol.Client.ClientChannel : ChannelBase {
    public ClientChannel(ITransport transport, TimeSpan sendTimeout, int envelopeBufferSize, bool fillEnvelopeRecipients, bool autoReplyPings, bool autoNotifyReceipt, Nullable`1<TimeSpan> remotePingInterval, Nullable`1<TimeSpan> remoteIdleTimeout, Nullable`1<TimeSpan> consumeTimeout, Nullable`1<TimeSpan> closeTimeout, IChannelCommandProcessor channelCommandProcessor);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.ClientChannel/<StartNewSessionAsync>d__1")]
public sealed virtual Task`1<Session> StartNewSessionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.ClientChannel/<NegotiateSessionAsync>d__2")]
public sealed virtual Task`1<Session> NegotiateSessionAsync(SessionCompression sessionCompression, SessionEncryption sessionEncryption, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.ClientChannel/<ReceiveAuthenticatingSessionAsync>d__3")]
[ObsoleteAttribute("Use ReceiveSessionAsync instead")]
public sealed virtual Task`1<Session> ReceiveAuthenticatingSessionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.ClientChannel/<AuthenticateSessionAsync>d__4")]
public sealed virtual Task`1<Session> AuthenticateSessionAsync(Identity identity, Authentication authentication, string instance, CancellationToken cancellationToken);
    public sealed virtual Task SendReceivedNotificationAsync(string messageId, Node to, CancellationToken cancellationToken);
    public sealed virtual Task SendFinishingSessionAsync(CancellationToken cancellationToken);
    public sealed virtual Task`1<Session> ReceiveFinishedSessionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.ClientChannel/<ReceiveSessionAsync>d__8")]
public virtual Task`1<Session> ReceiveSessionAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Session> <>n__0(CancellationToken cancellationToken);
}
public class Lime.Protocol.Client.ClientChannelBuilder : object {
    private Func`1<ITransport> _transportFactory;
    private List`1<Func`2<IClientChannel, IChannelModule`1<Message>>> _messageChannelModules;
    private List`1<Func`2<IClientChannel, IChannelModule`1<Notification>>> _notificationChannelModules;
    private List`1<Func`2<IClientChannel, IChannelModule`1<Command>>> _commandChannelModules;
    private List`1<Func`3<IClientChannel, CancellationToken, Task>> _builtHandlers;
    [CompilerGeneratedAttribute]
private Uri <ServerUri>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SendTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <ConsumeTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <CloseTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EnvelopeBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private IChannelCommandProcessor <ChannelCommandProcessor>k__BackingField;
    public Uri ServerUri { get; }
    public TimeSpan SendTimeout { get; private set; }
    public Nullable`1<TimeSpan> ConsumeTimeout { get; private set; }
    public Nullable`1<TimeSpan> CloseTimeout { get; private set; }
    public int EnvelopeBufferSize { get; private set; }
    public IChannelCommandProcessor ChannelCommandProcessor { get; private set; }
    private ClientChannelBuilder(Func`1<ITransport> transportFactory, Uri serverUri);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_ServerUri();
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_SendTimeout();
    [CompilerGeneratedAttribute]
private void set_SendTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<TimeSpan> get_ConsumeTimeout();
    [CompilerGeneratedAttribute]
private void set_ConsumeTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<TimeSpan> get_CloseTimeout();
    [CompilerGeneratedAttribute]
private void set_CloseTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_EnvelopeBufferSize();
    [CompilerGeneratedAttribute]
private void set_EnvelopeBufferSize(int value);
    [CompilerGeneratedAttribute]
public sealed virtual IChannelCommandProcessor get_ChannelCommandProcessor();
    [CompilerGeneratedAttribute]
private void set_ChannelCommandProcessor(IChannelCommandProcessor value);
    public static ClientChannelBuilder Create(Uri serverUri);
    public static ClientChannelBuilder Create(ITransport transport, Uri serverUri);
    public static ClientChannelBuilder Create(Func`1<ITransport> transportFactory, Uri serverUri);
    public sealed virtual IClientChannelBuilder WithSendTimeout(TimeSpan sendTimeout);
    public sealed virtual IClientChannelBuilder WithConsumeTimeout(Nullable`1<TimeSpan> consumeTimeout);
    public sealed virtual IClientChannelBuilder WithCloseTimeout(Nullable`1<TimeSpan> closeTimeout);
    [ObsoleteAttribute("Use the WithEnvelopeBufferSize method")]
public IClientChannelBuilder WithBuffersLimit(int buffersLimit);
    public sealed virtual IClientChannelBuilder WithEnvelopeBufferSize(int envelopeBufferSize);
    public sealed virtual IClientChannelBuilder WithChannelCommandProcessor(IChannelCommandProcessor channelCommandProcessor);
    public sealed virtual IClientChannelBuilder AddMessageModule(IChannelModule`1<Message> module);
    public sealed virtual IClientChannelBuilder AddMessageModule(Func`2<IClientChannel, IChannelModule`1<Message>> moduleFactory);
    public sealed virtual IClientChannelBuilder AddNotificationModule(IChannelModule`1<Notification> module);
    public sealed virtual IClientChannelBuilder AddNotificationModule(Func`2<IClientChannel, IChannelModule`1<Notification>> moduleFactory);
    public sealed virtual IClientChannelBuilder AddCommandModule(IChannelModule`1<Command> module);
    public sealed virtual IClientChannelBuilder AddCommandModule(Func`2<IClientChannel, IChannelModule`1<Command>> moduleFactory);
    public sealed virtual IClientChannelBuilder AddBuiltHandler(Func`3<IClientChannel, CancellationToken, Task> builtHandler);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.ClientChannelBuilder/<BuildAsync>d__45")]
public sealed virtual Task`1<IClientChannel> BuildAsync(CancellationToken cancellationToken);
    public sealed virtual IEstablishedClientChannelBuilder CreateEstablishedClientChannelBuilder();
}
[ExtensionAttribute]
public static class Lime.Protocol.Client.ClientChannelExtensions : object {
    [AsyncStateMachineAttribute("Lime.Protocol.Client.ClientChannelExtensions/<EstablishSessionAsync>d__0")]
[ExtensionAttribute]
public static Task`1<Session> EstablishSessionAsync(IClientChannel channel, Func`2<SessionCompression[], SessionCompression> compressionSelector, Func`2<SessionEncryption[], SessionEncryption> encryptionSelector, Identity identity, Func`3<AuthenticationScheme[], Authentication, Authentication> authenticator, string instance, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.ClientChannelExtensions/<FinishSessionAsync>d__1")]
[ExtensionAttribute]
public static Task`1<Session> FinishSessionAsync(IClientChannel clientChannel, CancellationToken cancellationToken);
}
internal class Lime.Protocol.Client.ClientProxyFactory : object {
    public sealed virtual T CreateProxy(IClientChannel clientChannel);
}
public class Lime.Protocol.Client.EstablishedClientChannelBuilder : object {
    private List`1<Func`3<IClientChannel, CancellationToken, Task>> _establishedHandlers;
    [CompilerGeneratedAttribute]
private IClientChannelBuilder <ChannelBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private Identity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <EstablishmentTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<SessionCompression[], SessionCompression> <CompressionSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<SessionEncryption[], SessionEncryption> <EncryptionSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<AuthenticationScheme[], Authentication, Authentication> <Authenticator>k__BackingField;
    public IClientChannelBuilder ChannelBuilder { get; }
    public Identity Identity { get; private set; }
    public string Instance { get; private set; }
    public TimeSpan EstablishmentTimeout { get; private set; }
    public Func`2<SessionCompression[], SessionCompression> CompressionSelector { get; private set; }
    public Func`2<SessionEncryption[], SessionEncryption> EncryptionSelector { get; private set; }
    public Func`3<AuthenticationScheme[], Authentication, Authentication> Authenticator { get; private set; }
    public IEnumerable`1<Func`3<IClientChannel, CancellationToken, Task>> EstablishedHandlers { get; }
    public EstablishedClientChannelBuilder(IClientChannelBuilder clientChannelBuilder);
    [CompilerGeneratedAttribute]
public sealed virtual IClientChannelBuilder get_ChannelBuilder();
    [CompilerGeneratedAttribute]
public sealed virtual Identity get_Identity();
    [CompilerGeneratedAttribute]
private void set_Identity(Identity value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Instance();
    [CompilerGeneratedAttribute]
private void set_Instance(string value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_EstablishmentTimeout();
    [CompilerGeneratedAttribute]
private void set_EstablishmentTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<SessionCompression[], SessionCompression> get_CompressionSelector();
    [CompilerGeneratedAttribute]
private void set_CompressionSelector(Func`2<SessionCompression[], SessionCompression> value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<SessionEncryption[], SessionEncryption> get_EncryptionSelector();
    [CompilerGeneratedAttribute]
private void set_EncryptionSelector(Func`2<SessionEncryption[], SessionEncryption> value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`3<AuthenticationScheme[], Authentication, Authentication> get_Authenticator();
    [CompilerGeneratedAttribute]
private void set_Authenticator(Func`3<AuthenticationScheme[], Authentication, Authentication> value);
    public sealed virtual IEnumerable`1<Func`3<IClientChannel, CancellationToken, Task>> get_EstablishedHandlers();
    public sealed virtual IEstablishedClientChannelBuilder WithEstablishmentTimeout(TimeSpan timeout);
    public sealed virtual IEstablishedClientChannelBuilder WithCompression(SessionCompression compression);
    public sealed virtual IEstablishedClientChannelBuilder WithCompression(Func`2<SessionCompression[], SessionCompression> compressionSelector);
    public sealed virtual IEstablishedClientChannelBuilder WithEncryption(SessionEncryption encryption);
    public sealed virtual IEstablishedClientChannelBuilder WithEncryption(Func`2<SessionEncryption[], SessionEncryption> encryptionSelector);
    public sealed virtual IEstablishedClientChannelBuilder WithPlainAuthentication(string password);
    public sealed virtual IEstablishedClientChannelBuilder WithKeyAuthentication(string key);
    public sealed virtual IEstablishedClientChannelBuilder WithTransportAuthentication(DomainRole domainRole);
    public sealed virtual IEstablishedClientChannelBuilder WithExternalAuthentication(string token, string issuer);
    public sealed virtual IEstablishedClientChannelBuilder WithAuthentication();
    public sealed virtual IEstablishedClientChannelBuilder WithAuthentication(Authentication authentication);
    public sealed virtual IEstablishedClientChannelBuilder WithAuthentication(Func`3<AuthenticationScheme[], Authentication, Authentication> authenticator);
    public sealed virtual IEstablishedClientChannelBuilder WithIdentity(Identity identity);
    public sealed virtual IEstablishedClientChannelBuilder WithInstance(string instance);
    public sealed virtual IEstablishedClientChannelBuilder AddEstablishedHandler(Func`3<IClientChannel, CancellationToken, Task> establishedHandler);
    public sealed virtual IEstablishedClientChannelBuilder Copy();
    [AsyncStateMachineAttribute("Lime.Protocol.Client.EstablishedClientChannelBuilder/<BuildAndEstablishAsync>d__47")]
public sealed virtual Task`1<IClientChannel> BuildAndEstablishAsync(CancellationToken cancellationToken);
    internal EstablishedClientChannelBuilder ShallowCopy();
}
public interface Lime.Protocol.Client.IClientChannel {
    public abstract virtual Task`1<Session> StartNewSessionAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<Session> NegotiateSessionAsync(SessionCompression sessionCompression, SessionEncryption sessionEncryption, CancellationToken cancellationToken);
    public abstract virtual Task`1<Session> ReceiveAuthenticatingSessionAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<Session> AuthenticateSessionAsync(Identity identity, Authentication authentication, string instance, CancellationToken cancellationToken);
    public abstract virtual Task SendReceivedNotificationAsync(string messageId, Node to, CancellationToken cancellationToken);
    public abstract virtual Task SendFinishingSessionAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<Session> ReceiveFinishedSessionAsync(CancellationToken cancellationToken);
}
public interface Lime.Protocol.Client.IClientChannelBuilder {
    public Uri ServerUri { get; }
    public TimeSpan SendTimeout { get; }
    public Nullable`1<TimeSpan> ConsumeTimeout { get; }
    public Nullable`1<TimeSpan> CloseTimeout { get; }
    public int EnvelopeBufferSize { get; }
    public IChannelCommandProcessor ChannelCommandProcessor { get; }
    public abstract virtual Uri get_ServerUri();
    public abstract virtual TimeSpan get_SendTimeout();
    public abstract virtual Nullable`1<TimeSpan> get_ConsumeTimeout();
    public abstract virtual Nullable`1<TimeSpan> get_CloseTimeout();
    public abstract virtual int get_EnvelopeBufferSize();
    public abstract virtual IChannelCommandProcessor get_ChannelCommandProcessor();
    public abstract virtual IClientChannelBuilder WithSendTimeout(TimeSpan sendTimeout);
    public abstract virtual IClientChannelBuilder WithConsumeTimeout(Nullable`1<TimeSpan> consumeTimeout);
    public abstract virtual IClientChannelBuilder WithCloseTimeout(Nullable`1<TimeSpan> closeTimeout);
    public abstract virtual IClientChannelBuilder WithEnvelopeBufferSize(int envelopeBufferSize);
    public abstract virtual IClientChannelBuilder WithChannelCommandProcessor(IChannelCommandProcessor channelCommandProcessor);
    public abstract virtual IClientChannelBuilder AddMessageModule(IChannelModule`1<Message> module);
    public abstract virtual IClientChannelBuilder AddMessageModule(Func`2<IClientChannel, IChannelModule`1<Message>> moduleFactory);
    public abstract virtual IClientChannelBuilder AddNotificationModule(IChannelModule`1<Notification> module);
    public abstract virtual IClientChannelBuilder AddNotificationModule(Func`2<IClientChannel, IChannelModule`1<Notification>> moduleFactory);
    public abstract virtual IClientChannelBuilder AddCommandModule(IChannelModule`1<Command> module);
    public abstract virtual IClientChannelBuilder AddCommandModule(Func`2<IClientChannel, IChannelModule`1<Command>> moduleFactory);
    public abstract virtual IClientChannelBuilder AddBuiltHandler(Func`3<IClientChannel, CancellationToken, Task> builtHandler);
    public abstract virtual Task`1<IClientChannel> BuildAsync(CancellationToken cancellationToken);
    public abstract virtual IEstablishedClientChannelBuilder CreateEstablishedClientChannelBuilder();
}
public interface Lime.Protocol.Client.IClientProxyFactory {
    public abstract virtual T CreateProxy(IClientChannel clientChannel);
}
public interface Lime.Protocol.Client.IEstablishedClientChannelBuilder {
    public IClientChannelBuilder ChannelBuilder { get; }
    public Identity Identity { get; }
    public string Instance { get; }
    public TimeSpan EstablishmentTimeout { get; }
    public Func`2<SessionCompression[], SessionCompression> CompressionSelector { get; }
    public Func`2<SessionEncryption[], SessionEncryption> EncryptionSelector { get; }
    public Func`3<AuthenticationScheme[], Authentication, Authentication> Authenticator { get; }
    public IEnumerable`1<Func`3<IClientChannel, CancellationToken, Task>> EstablishedHandlers { get; }
    public abstract virtual IClientChannelBuilder get_ChannelBuilder();
    public abstract virtual Identity get_Identity();
    public abstract virtual string get_Instance();
    public abstract virtual TimeSpan get_EstablishmentTimeout();
    public abstract virtual Func`2<SessionCompression[], SessionCompression> get_CompressionSelector();
    public abstract virtual Func`2<SessionEncryption[], SessionEncryption> get_EncryptionSelector();
    public abstract virtual Func`3<AuthenticationScheme[], Authentication, Authentication> get_Authenticator();
    public abstract virtual IEnumerable`1<Func`3<IClientChannel, CancellationToken, Task>> get_EstablishedHandlers();
    public abstract virtual IEstablishedClientChannelBuilder WithEstablishmentTimeout(TimeSpan timeout);
    public abstract virtual IEstablishedClientChannelBuilder WithCompression(SessionCompression compression);
    public abstract virtual IEstablishedClientChannelBuilder WithCompression(Func`2<SessionCompression[], SessionCompression> compressionSelector);
    public abstract virtual IEstablishedClientChannelBuilder WithEncryption(SessionEncryption encryption);
    public abstract virtual IEstablishedClientChannelBuilder WithEncryption(Func`2<SessionEncryption[], SessionEncryption> encryptionSelector);
    public abstract virtual IEstablishedClientChannelBuilder WithPlainAuthentication(string password);
    public abstract virtual IEstablishedClientChannelBuilder WithKeyAuthentication(string key);
    public abstract virtual IEstablishedClientChannelBuilder WithExternalAuthentication(string token, string issuer);
    public abstract virtual IEstablishedClientChannelBuilder WithTransportAuthentication(DomainRole domainRole);
    public abstract virtual IEstablishedClientChannelBuilder WithAuthentication();
    public abstract virtual IEstablishedClientChannelBuilder WithAuthentication(Authentication authentication);
    public abstract virtual IEstablishedClientChannelBuilder WithAuthentication(Func`3<AuthenticationScheme[], Authentication, Authentication> authenticator);
    public abstract virtual IEstablishedClientChannelBuilder WithIdentity(Identity identity);
    public abstract virtual IEstablishedClientChannelBuilder WithInstance(string instance);
    public abstract virtual IEstablishedClientChannelBuilder AddEstablishedHandler(Func`3<IClientChannel, CancellationToken, Task> establishedHandler);
    public abstract virtual IEstablishedClientChannelBuilder Copy();
    public abstract virtual Task`1<IClientChannel> BuildAndEstablishAsync(CancellationToken cancellationToken);
}
public interface Lime.Protocol.Client.IOnDemandClientChannel {
    public bool IsEstablished { get; }
    public ICollection`1<Func`2<ChannelInformation, Task>> ChannelCreatedHandlers { get; }
    public ICollection`1<Func`2<ChannelInformation, Task>> ChannelDiscardedHandlers { get; }
    public ICollection`1<Func`2<FailedChannelInformation, Task`1<bool>>> ChannelCreationFailedHandlers { get; }
    public ICollection`1<Func`2<FailedChannelInformation, Task`1<bool>>> ChannelOperationFailedHandlers { get; }
    public abstract virtual bool get_IsEstablished();
    public abstract virtual Task EstablishAsync(CancellationToken cancellationToken);
    public abstract virtual ICollection`1<Func`2<ChannelInformation, Task>> get_ChannelCreatedHandlers();
    public abstract virtual ICollection`1<Func`2<ChannelInformation, Task>> get_ChannelDiscardedHandlers();
    public abstract virtual ICollection`1<Func`2<FailedChannelInformation, Task`1<bool>>> get_ChannelCreationFailedHandlers();
    public abstract virtual ICollection`1<Func`2<FailedChannelInformation, Task`1<bool>>> get_ChannelOperationFailedHandlers();
    public abstract virtual Task FinishAsync(CancellationToken cancellationToken);
}
public class Lime.Protocol.Client.MultiplexerClientChannel : object {
    private IOnDemandClientChannel[] _channels;
    private IChannelListener[] _listeners;
    private SemaphoreSlim _semaphore;
    private BufferBlock`1<BufferedEnvelope> _outputBufferBlock;
    private ActionBlock`1[] _outputActionBlocks;
    private BufferBlock`1<Message> _inputMessageBufferBlock;
    private BufferBlock`1<Notification> _inputNotificationBufferBlock;
    private TransformBlock`2<Command, Command> _processCommandTransformBlock;
    private BufferBlock`1<Command> _inputCommandBufferBlock;
    private IChannelCommandProcessor _channelCommandProcessor;
    private long _outputCounter;
    [CompilerGeneratedAttribute]
private ICollection`1<Func`2<ChannelInformation, Task>> <ChannelCreatedHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<Func`2<ChannelInformation, Task>> <ChannelDiscardedHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<Func`2<FailedChannelInformation, Task`1<bool>>> <ChannelCreationFailedHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<Func`2<FailedChannelInformation, Task`1<bool>>> <ChannelOperationFailedHandlers>k__BackingField;
    public bool IsEstablished { get; }
    public ICollection`1<Func`2<ChannelInformation, Task>> ChannelCreatedHandlers { get; }
    public ICollection`1<Func`2<ChannelInformation, Task>> ChannelDiscardedHandlers { get; }
    public ICollection`1<Func`2<FailedChannelInformation, Task`1<bool>>> ChannelCreationFailedHandlers { get; }
    public ICollection`1<Func`2<FailedChannelInformation, Task`1<bool>>> ChannelOperationFailedHandlers { get; }
    public MultiplexerClientChannel(IEstablishedClientChannelBuilder builder, int count, int inputBufferSize, int outputBufferSize, IChannelCommandProcessor channelCommandProcessor);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.MultiplexerClientChannel/<SendMessageAsync>d__12")]
public sealed virtual Task SendMessageAsync(Message message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.MultiplexerClientChannel/<SendNotificationAsync>d__13")]
public sealed virtual Task SendNotificationAsync(Notification notification, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.MultiplexerClientChannel/<SendCommandAsync>d__14")]
public sealed virtual Task SendCommandAsync(Command command, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.MultiplexerClientChannel/<ReceiveMessageAsync>d__15")]
public sealed virtual Task`1<Message> ReceiveMessageAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.MultiplexerClientChannel/<ReceiveNotificationAsync>d__16")]
public sealed virtual Task`1<Notification> ReceiveNotificationAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.MultiplexerClientChannel/<ReceiveCommandAsync>d__17")]
public sealed virtual Task`1<Command> ReceiveCommandAsync(CancellationToken cancellationToken);
    public sealed virtual Task`1<Command> ProcessCommandAsync(Command requestCommand, CancellationToken cancellationToken);
    public sealed virtual bool get_IsEstablished();
    [AsyncStateMachineAttribute("Lime.Protocol.Client.MultiplexerClientChannel/<EstablishAsync>d__21")]
public sealed virtual Task EstablishAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<Func`2<ChannelInformation, Task>> get_ChannelCreatedHandlers();
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<Func`2<ChannelInformation, Task>> get_ChannelDiscardedHandlers();
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<Func`2<FailedChannelInformation, Task`1<bool>>> get_ChannelCreationFailedHandlers();
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<Func`2<FailedChannelInformation, Task`1<bool>>> get_ChannelOperationFailedHandlers();
    [AsyncStateMachineAttribute("Lime.Protocol.Client.MultiplexerClientChannel/<FinishAsync>d__34")]
public sealed virtual Task FinishAsync(CancellationToken cancellationToken);
    private void AttachCollection(INotifyCollectionChanged observableCollection, ICollection`1<T> collection);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.MultiplexerClientChannel/<EstablishIfRequiredAsync>d__36")]
private Task EstablishIfRequiredAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.MultiplexerClientChannel/<SendToBufferAsync>d__37")]
private Task SendToBufferAsync(Envelope envelope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.MultiplexerClientChannel/<SendToChannelAsync>d__38")]
private Task SendToChannelAsync(IOnDemandClientChannel channel, Envelope e);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private Command <.ctor>b__11_0(Command c);
}
public class Lime.Protocol.Client.OnDemandClientChannel : object {
    private IEstablishedClientChannelBuilder _builder;
    private SemaphoreSlim _semaphore;
    private IClientChannel _clientChannel;
    private bool _disposed;
    private Task`1<Session> _finishedSessionTask;
    private CancellationTokenSource _cts;
    [CompilerGeneratedAttribute]
private ICollection`1<Func`2<ChannelInformation, Task>> <ChannelCreatedHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<Func`2<ChannelInformation, Task>> <ChannelDiscardedHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<Func`2<FailedChannelInformation, Task`1<bool>>> <ChannelCreationFailedHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<Func`2<FailedChannelInformation, Task`1<bool>>> <ChannelOperationFailedHandlers>k__BackingField;
    public bool IsEstablished { get; }
    public ICollection`1<Func`2<ChannelInformation, Task>> ChannelCreatedHandlers { get; }
    public ICollection`1<Func`2<ChannelInformation, Task>> ChannelDiscardedHandlers { get; }
    public ICollection`1<Func`2<FailedChannelInformation, Task`1<bool>>> ChannelCreationFailedHandlers { get; }
    public ICollection`1<Func`2<FailedChannelInformation, Task`1<bool>>> ChannelOperationFailedHandlers { get; }
    public OnDemandClientChannel(IEstablishedClientChannelBuilder builder);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.OnDemandClientChannel/<SendCommandAsync>d__7")]
public sealed virtual Task SendCommandAsync(Command command, CancellationToken cancellationToken);
    public sealed virtual Task`1<Command> ReceiveCommandAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.OnDemandClientChannel/<ProcessCommandAsync>d__9")]
public sealed virtual Task`1<Command> ProcessCommandAsync(Command requestCommand, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.OnDemandClientChannel/<SendMessageAsync>d__10")]
public sealed virtual Task SendMessageAsync(Message message, CancellationToken cancellationToken);
    public sealed virtual Task`1<Message> ReceiveMessageAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.OnDemandClientChannel/<SendNotificationAsync>d__12")]
public sealed virtual Task SendNotificationAsync(Notification notification, CancellationToken cancellationToken);
    public sealed virtual Task`1<Notification> ReceiveNotificationAsync(CancellationToken cancellationToken);
    public sealed virtual bool get_IsEstablished();
    public sealed virtual Task EstablishAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<Func`2<ChannelInformation, Task>> get_ChannelCreatedHandlers();
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<Func`2<ChannelInformation, Task>> get_ChannelDiscardedHandlers();
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<Func`2<FailedChannelInformation, Task`1<bool>>> get_ChannelCreationFailedHandlers();
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<Func`2<FailedChannelInformation, Task`1<bool>>> get_ChannelOperationFailedHandlers();
    [AsyncStateMachineAttribute("Lime.Protocol.Client.OnDemandClientChannel/<FinishAsync>d__29")]
public sealed virtual Task FinishAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.OnDemandClientChannel/<SendAsync>d__30`1")]
private Task SendAsync(T envelope, CancellationToken cancellationToken, Func`3<IClientChannel, T, Task> sendFunc, string operationName);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.OnDemandClientChannel/<ReceiveAsync>d__31`1")]
private Task`1<T> ReceiveAsync(CancellationToken cancellationToken, Func`3<IClientChannel, CancellationToken, Task`1<T>> receiveFunc, string operationName);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.OnDemandClientChannel/<HandleChannelOperationExceptionAsync>d__32")]
private Task`1<bool> HandleChannelOperationExceptionAsync(Exception ex, string operationName, IChannel channel, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.OnDemandClientChannel/<InvokeHandlersAsync>d__33")]
private static Task`1<bool> InvokeHandlersAsync(IEnumerable`1<Func`2<FailedChannelInformation, Task`1<bool>>> handlers, FailedChannelInformation failedChannelInformation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.OnDemandClientChannel/<InvokeHandlersAsync>d__34")]
private static Task InvokeHandlersAsync(IEnumerable`1<Func`2<ChannelInformation, Task>> handlers, ChannelInformation channelInformation, CancellationToken cancellationToken);
    private static void ThrowIfAny(IReadOnlyList`1<Exception> exceptions);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.OnDemandClientChannel/<GetChannelAsync>d__36")]
private Task`1<IClientChannel> GetChannelAsync(CancellationToken cancellationToken, string operationName);
    private static bool ShouldCreateChannel(IChannel channel);
    private static bool ChannelIsEstablished(IChannel channel);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.OnDemandClientChannel/<DiscardChannelAsync>d__39")]
private Task DiscardChannelAsync(IChannel clientChannel, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Client.OnDemandClientChannel/<DiscardChannelUnsynchronizedAsync>d__40")]
private Task DiscardChannelUnsynchronizedAsync(IChannel clientChannel, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
[DataContractAttribute]
public class Lime.Protocol.Command : Envelope {
    public static string URI_KEY;
    public static string TYPE_KEY;
    public static string RESOURCE_KEY;
    public static string METHOD_KEY;
    public static string STATUS_KEY;
    public static string REASON_KEY;
    [CompilerGeneratedAttribute]
private LimeUri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private Document <Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private Reason <Reason>k__BackingField;
    [DataMemberAttribute]
public LimeUri Uri { get; public set; }
    [DataMemberAttribute]
public MediaType Type { get; }
    [DataMemberAttribute]
public Document Resource { get; public set; }
    [DataMemberAttribute]
public CommandMethod Method { get; public set; }
    [DataMemberAttribute]
[DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public CommandStatus Status { get; public set; }
    [DataMemberAttribute]
public Reason Reason { get; public set; }
    [JsonConstructorAttribute]
public Command(string id);
    [CompilerGeneratedAttribute]
public LimeUri get_Uri();
    [CompilerGeneratedAttribute]
public void set_Uri(LimeUri value);
    public MediaType get_Type();
    [CompilerGeneratedAttribute]
public Document get_Resource();
    [CompilerGeneratedAttribute]
public void set_Resource(Document value);
    [CompilerGeneratedAttribute]
public CommandMethod get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(CommandMethod value);
    [CompilerGeneratedAttribute]
public CommandStatus get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(CommandStatus value);
    [CompilerGeneratedAttribute]
public Reason get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(Reason value);
    private sealed virtual override Document Lime.Protocol.IDocumentContainer.GetDocument();
}
[DataContractAttribute]
public enum Lime.Protocol.CommandMethod : Enum {
    public int value__;
    [EnumMemberAttribute]
public static CommandMethod Get;
    [EnumMemberAttribute]
public static CommandMethod Set;
    [EnumMemberAttribute]
public static CommandMethod Delete;
    [EnumMemberAttribute]
public static CommandMethod Subscribe;
    [EnumMemberAttribute]
public static CommandMethod Unsubscribe;
    [EnumMemberAttribute]
public static CommandMethod Observe;
    [EnumMemberAttribute]
public static CommandMethod Merge;
}
[DataContractAttribute]
public enum Lime.Protocol.CommandStatus : Enum {
    public int value__;
    [EnumMemberAttribute]
public static CommandStatus Pending;
    [EnumMemberAttribute]
public static CommandStatus Success;
    [EnumMemberAttribute]
public static CommandStatus Failure;
}
[DefaultMemberAttribute("Item")]
public class Lime.Protocol.DictionaryDocument`2 : Document {
    private IDictionary`2<TKey, TValue> _json;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public DictionaryDocument`2(MediaType mediaType);
    public DictionaryDocument`2(IDictionary`2<TKey, TValue> json, MediaType mediaType);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
}
[DataContractAttribute]
public abstract class Lime.Protocol.Document : object {
    protected MediaType _mediaType;
    protected Document(MediaType mediaType);
    public sealed virtual MediaType GetMediaType();
    public static Document op_Implicit(string value);
}
[DataContractAttribute]
public class Lime.Protocol.DocumentCollection : Document {
    public static string MIME_TYPE;
    public static string TOTAL_KEY;
    public static string ITEM_TYPE_KEY;
    public static string ITEMS_KEY;
    [CompilerGeneratedAttribute]
private int <Total>k__BackingField;
    [CompilerGeneratedAttribute]
private MediaType <ItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private Document[] <Items>k__BackingField;
    [DataMemberAttribute]
public int Total { get; public set; }
    [DataMemberAttribute]
public MediaType ItemType { get; public set; }
    [DataMemberAttribute]
public Document[] Items { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Total();
    [CompilerGeneratedAttribute]
public void set_Total(int value);
    [CompilerGeneratedAttribute]
public MediaType get_ItemType();
    [CompilerGeneratedAttribute]
public void set_ItemType(MediaType value);
    [CompilerGeneratedAttribute]
public Document[] get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(Document[] value);
    public sealed virtual IEnumerator GetEnumerator();
}
[DataContractAttribute]
public class Lime.Protocol.DocumentContainer : Document {
    public static string MIME_TYPE;
    public static string TYPE_KEY;
    public static string VALUE_KEY;
    public static MediaType MediaType;
    [CompilerGeneratedAttribute]
private Document <Value>k__BackingField;
    [DataMemberAttribute]
public MediaType Type { get; }
    [DataMemberAttribute]
public Document Value { get; public set; }
    private static DocumentContainer();
    public MediaType get_Type();
    [CompilerGeneratedAttribute]
public Document get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Document value);
    private sealed virtual override Document Lime.Protocol.IDocumentContainer.GetDocument();
}
[DataContractAttribute]
public abstract class Lime.Protocol.Envelope : object {
    public static string ID_KEY;
    public static string FROM_KEY;
    public static string PP_KEY;
    public static string TO_KEY;
    public static string METADATA_KEY;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <From>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <Pp>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <To>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [DataMemberAttribute]
public string Id { get; public set; }
    [DataMemberAttribute]
public Node From { get; public set; }
    [DataMemberAttribute]
public Node Pp { get; public set; }
    [DataMemberAttribute]
public Node To { get; public set; }
    [DataMemberAttribute]
public IDictionary`2<string, string> Metadata { get; public set; }
    protected Envelope(string id);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public Node get_From();
    [CompilerGeneratedAttribute]
public void set_From(Node value);
    [CompilerGeneratedAttribute]
public Node get_Pp();
    [CompilerGeneratedAttribute]
public void set_Pp(Node value);
    [CompilerGeneratedAttribute]
public Node get_To();
    [CompilerGeneratedAttribute]
public void set_To(Node value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(IDictionary`2<string, string> value);
    internal Envelope MemberwiseClone();
}
[ExtensionAttribute]
public static class Lime.Protocol.EnvelopeExtensions : object {
    public static string COMMAND_MIME_TYPE;
    public static string MESSAGE_MIME_TYPE;
    public static string NOTIFICATION_MIME_TYPE;
    public static MediaType CommandMediaType;
    public static MediaType MessageMediaType;
    public static MediaType NotificationMediaType;
    private static EnvelopeExtensions();
    [ExtensionAttribute]
public static JsonDocument ToDocument(Command command, JsonSerializer jsonSerializer);
    [ExtensionAttribute]
public static JsonDocument ToDocument(Message message, JsonSerializer jsonSerializer);
    [ExtensionAttribute]
public static JsonDocument ToDocument(Notification notification, JsonSerializer jsonSerializer);
    public static JsonDocument ToDocument(T envelope, MediaType mediaType, JsonSerializer jsonSerializer);
    [ExtensionAttribute]
public static Message ToMessage(JsonDocument jsonDocument, JsonSerializer jsonSerializer);
    [ExtensionAttribute]
public static Command ToCommand(JsonDocument jsonDocument, JsonSerializer jsonSerializer);
    [ExtensionAttribute]
public static Notification ToNotification(JsonDocument jsonDocument, JsonSerializer jsonSerializer);
    [ExtensionAttribute]
public static Envelope ToEnvelope(JsonDocument jsonDocument, MediaType mediaType, JsonSerializer jsonSerializer);
    [ExtensionAttribute]
public static TEnvelope ShallowCopy(TEnvelope envelope);
    [ExtensionAttribute]
public static Node GetSender(Envelope envelope);
}
public static class Lime.Protocol.EnvelopeId : object {
    public static string NewId();
}
[DataContractAttribute]
public enum Lime.Protocol.EnvelopeType : Enum {
    public int value__;
    [EnumMemberAttribute]
public static EnvelopeType Message;
    [EnumMemberAttribute]
public static EnvelopeType Notification;
    [EnumMemberAttribute]
public static EnvelopeType Command;
    [EnumMemberAttribute]
public static EnvelopeType Session;
}
[DataContractAttribute]
public enum Lime.Protocol.Event : Enum {
    public int value__;
    [EnumMemberAttribute]
public static Event Failed;
    [EnumMemberAttribute]
public static Event Accepted;
    [EnumMemberAttribute]
[ObsoleteAttribute("This specific event should not be sent anymore")]
public static Event Validated;
    [EnumMemberAttribute]
[ObsoleteAttribute("This specific event should not be sent anymore")]
public static Event Authorized;
    [EnumMemberAttribute]
public static Event Dispatched;
    [EnumMemberAttribute]
public static Event Received;
    [EnumMemberAttribute]
public static Event Consumed;
    [EnumMemberAttribute]
public static Event Deleted;
}
public class Lime.Protocol.Identity : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    public string Name { get; public set; }
    public string Domain { get; public set; }
    public Identity(string name, string domain);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Domain();
    [CompilerGeneratedAttribute]
public void set_Domain(string value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(Identity left, Identity right);
    public static bool op_Inequality(Identity left, Identity right);
    public static Identity op_Implicit(string value);
    public static string op_Implicit(Identity identity);
    public Node ToNode();
    public static Identity Parse(string s);
    public static bool TryParse(string s, Identity& value);
    public Identity ToImmutableIdentity();
}
[DataContractAttribute]
public class Lime.Protocol.IdentityDocument : Document {
    public static string MIME_TYPE;
    public static MediaType MediaType;
    [CompilerGeneratedAttribute]
private Identity <Value>k__BackingField;
    public Identity Value { get; public set; }
    public IdentityDocument(Identity value);
    private static IdentityDocument();
    [CompilerGeneratedAttribute]
public Identity get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Identity value);
    public virtual string ToString();
    public static IdentityDocument Parse(string value);
}
public interface Lime.Protocol.IDocument {
    public abstract virtual MediaType GetMediaType();
}
public interface Lime.Protocol.IDocumentContainer {
    public abstract virtual Document GetDocument();
}
public interface Lime.Protocol.IIdentity {
    public string Name { get; }
    public string Domain { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Domain();
}
public class Lime.Protocol.Immutable.Identity : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    public string Name { get; }
    public string Domain { get; }
    public Identity(string name, string domain);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Domain();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(Identity left, Identity right);
    public static bool op_Inequality(Identity left, Identity right);
    public static Identity op_Implicit(string value);
    public static string op_Implicit(Identity identity);
    public Node ToNode();
    public static Identity Parse(string s);
    public static bool TryParse(string s, Identity& value);
    public Identity Copy(string name, string domain);
    public Identity ToMutableIdentity();
}
public class Lime.Protocol.Immutable.Node : Identity {
    [CompilerGeneratedAttribute]
private string <Instance>k__BackingField;
    public string Instance { get; }
    public bool IsComplete { get; }
    public Node(string name, string domain, string instance);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Instance();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public static bool op_Equality(Node left, Node right);
    public static bool op_Inequality(Node left, Node right);
    public static Node op_Implicit(string value);
    public static string op_Implicit(Node node);
    public virtual int GetHashCode();
    public static Node Parse(string s);
    public static bool TryParse(string s, Node& value);
    public Identity ToIdentity();
    public bool get_IsComplete();
    public Node Copy(string name, string domain, string instance);
    public Node ToMutableNode();
}
public interface Lime.Protocol.INode {
    public string Instance { get; }
    public abstract virtual string get_Instance();
}
public class Lime.Protocol.JsonDocument : DictionaryDocument`2<string, object> {
    public JsonDocument(MediaType mediaType);
    public JsonDocument(IDictionary`2<string, object> json, MediaType mediaType);
    public void SetMediaType(MediaType mediaType);
}
public class Lime.Protocol.LimeUri : object {
    public static string LIME_URI_SCHEME;
    private Uri _absoluteUri;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Path { get; }
    public bool IsRelative { get; }
    public LimeUri(string uriPath);
    [CompilerGeneratedAttribute]
public string get_Path();
    public bool get_IsRelative();
    public Uri ToUri();
    public Uri ToUri(Identity authority);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public static LimeUri Parse(string value);
    public static Uri GetBaseUri(Identity authority);
    public static LimeUri op_Implicit(string value);
    public static string op_Implicit(LimeUri limeUri);
    private bool ReceivedUriPathIsEncoded(string uri);
    private void ValidatLimeScheme(Uri absoluteUri);
}
public class Lime.Protocol.Listeners.BufferedChannelListener : object {
    private Func`3<Message, CancellationToken, Task`1<bool>> _messageConsumer;
    private Func`3<Notification, CancellationToken, Task`1<bool>> _notificationConsumer;
    private Func`3<Command, CancellationToken, Task`1<bool>> _commandConsumer;
    private object _syncRoot;
    private CancellationTokenSource _cts;
    [CompilerGeneratedAttribute]
private Channel`1<Message> <MessageBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private Channel`1<Notification> <NotificationBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private Channel`1<Command> <CommandBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<Message> <MessageListenerTask>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<Notification> <NotificationListenerTask>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<Command> <CommandListenerTask>k__BackingField;
    public Channel`1<Message> MessageBuffer { get; }
    public Channel`1<Notification> NotificationBuffer { get; }
    public Channel`1<Command> CommandBuffer { get; }
    public Task`1<Message> MessageListenerTask { get; private set; }
    public Task`1<Notification> NotificationListenerTask { get; private set; }
    public Task`1<Command> CommandListenerTask { get; private set; }
    public BufferedChannelListener(Func`3<Message, CancellationToken, Task`1<bool>> messageConsumer, Func`3<Notification, CancellationToken, Task`1<bool>> notificationConsumer, Func`3<Command, CancellationToken, Task`1<bool>> commandConsumer, int capacity);
    [CompilerGeneratedAttribute]
public Channel`1<Message> get_MessageBuffer();
    [CompilerGeneratedAttribute]
public Channel`1<Notification> get_NotificationBuffer();
    [CompilerGeneratedAttribute]
public Channel`1<Command> get_CommandBuffer();
    [CompilerGeneratedAttribute]
public sealed virtual Task`1<Message> get_MessageListenerTask();
    [CompilerGeneratedAttribute]
private void set_MessageListenerTask(Task`1<Message> value);
    [CompilerGeneratedAttribute]
public sealed virtual Task`1<Notification> get_NotificationListenerTask();
    [CompilerGeneratedAttribute]
private void set_NotificationListenerTask(Task`1<Notification> value);
    [CompilerGeneratedAttribute]
public sealed virtual Task`1<Command> get_CommandListenerTask();
    [CompilerGeneratedAttribute]
private void set_CommandListenerTask(Task`1<Command> value);
    public sealed virtual void Start(IEstablishedReceiverChannel channel);
    public sealed virtual void Stop();
    [AsyncStateMachineAttribute("Lime.Protocol.Listeners.BufferedChannelListener/<CreateListenerTask>d__29`1")]
private Task`1<T> CreateListenerTask(Func`2<CancellationToken, Task`1<T>> producer, Channel`1<T> channel, Func`3<T, CancellationToken, Task`1<bool>> consumer, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
public class Lime.Protocol.Listeners.ChannelListener : object {
    private Func`3<Message, CancellationToken, Task`1<bool>> _messageConsumer;
    private Func`3<Notification, CancellationToken, Task`1<bool>> _notificationConsumer;
    private Func`3<Command, CancellationToken, Task`1<bool>> _commandConsumer;
    private CancellationTokenSource _cts;
    private object _syncRoot;
    [CompilerGeneratedAttribute]
private Task`1<Message> <MessageListenerTask>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<Notification> <NotificationListenerTask>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<Command> <CommandListenerTask>k__BackingField;
    public Task`1<Message> MessageListenerTask { get; private set; }
    public Task`1<Notification> NotificationListenerTask { get; private set; }
    public Task`1<Command> CommandListenerTask { get; private set; }
    [ObsoleteAttribute("Use the constructor where the consumers accepts a cancellationToken as argument")]
public ChannelListener(Func`2<Message, Task`1<bool>> messageConsumer, Func`2<Notification, Task`1<bool>> notificationConsumer, Func`2<Command, Task`1<bool>> commandConsumer);
    public ChannelListener(Func`3<Message, CancellationToken, Task`1<bool>> messageConsumer, Func`3<Notification, CancellationToken, Task`1<bool>> notificationConsumer, Func`3<Command, CancellationToken, Task`1<bool>> commandConsumer);
    public sealed virtual void Start(IEstablishedReceiverChannel channel);
    public sealed virtual void Stop();
    [CompilerGeneratedAttribute]
public sealed virtual Task`1<Message> get_MessageListenerTask();
    [CompilerGeneratedAttribute]
private void set_MessageListenerTask(Task`1<Message> value);
    [CompilerGeneratedAttribute]
public sealed virtual Task`1<Notification> get_NotificationListenerTask();
    [CompilerGeneratedAttribute]
private void set_NotificationListenerTask(Task`1<Notification> value);
    [CompilerGeneratedAttribute]
public sealed virtual Task`1<Command> get_CommandListenerTask();
    [CompilerGeneratedAttribute]
private void set_CommandListenerTask(Task`1<Command> value);
    public sealed virtual void Dispose();
    private Task`1<T> CreateListenerTask(Func`2<CancellationToken, Task`1<T>> producer, Func`3<T, CancellationToken, Task`1<bool>> consumer);
}
public class Lime.Protocol.Listeners.DataflowChannelListener : object {
    private ChannelListener _channelListener;
    public Task`1<Message> MessageListenerTask { get; }
    public Task`1<Notification> NotificationListenerTask { get; }
    public Task`1<Command> CommandListenerTask { get; }
    public DataflowChannelListener(ITargetBlock`1<Message> messageTargetBlock, ITargetBlock`1<Notification> notificationTargetBlock, ITargetBlock`1<Command> commandTargetBlock);
    public sealed virtual void Start(IEstablishedReceiverChannel channel);
    public sealed virtual void Stop();
    public sealed virtual Task`1<Message> get_MessageListenerTask();
    public sealed virtual Task`1<Notification> get_NotificationListenerTask();
    public sealed virtual Task`1<Command> get_CommandListenerTask();
    public sealed virtual void Dispose();
}
public class Lime.Protocol.Listeners.EventChannelListener : object {
    private ChannelListener _channelListener;
    [CompilerGeneratedAttribute]
private EventHandler`1<EnvelopeEventArgs`1<Message>> MessageReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<EnvelopeEventArgs`1<Notification>> NotificationReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<EnvelopeEventArgs`1<Command>> CommandReceived;
    public Task`1<Message> MessageListenerTask { get; }
    public Task`1<Notification> NotificationListenerTask { get; }
    public Task`1<Command> CommandListenerTask { get; }
    [AsyncStateMachineAttribute("Lime.Protocol.Listeners.EventChannelListener/<RaiseMessageReceivedAsync>d__2")]
private Task`1<bool> RaiseMessageReceivedAsync(Message envelope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Listeners.EventChannelListener/<RaiseNotificationReceivedAsync>d__3")]
private Task`1<bool> RaiseNotificationReceivedAsync(Notification envelope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Listeners.EventChannelListener/<RaiseCommandReceivedAsync>d__4")]
private Task`1<bool> RaiseCommandReceivedAsync(Command envelope, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public void add_MessageReceived(EventHandler`1<EnvelopeEventArgs`1<Message>> value);
    [CompilerGeneratedAttribute]
public void remove_MessageReceived(EventHandler`1<EnvelopeEventArgs`1<Message>> value);
    [CompilerGeneratedAttribute]
public void add_NotificationReceived(EventHandler`1<EnvelopeEventArgs`1<Notification>> value);
    [CompilerGeneratedAttribute]
public void remove_NotificationReceived(EventHandler`1<EnvelopeEventArgs`1<Notification>> value);
    [CompilerGeneratedAttribute]
public void add_CommandReceived(EventHandler`1<EnvelopeEventArgs`1<Command>> value);
    [CompilerGeneratedAttribute]
public void remove_CommandReceived(EventHandler`1<EnvelopeEventArgs`1<Command>> value);
    public sealed virtual void Start(IEstablishedReceiverChannel channel);
    public sealed virtual void Stop();
    public sealed virtual Task`1<Message> get_MessageListenerTask();
    public sealed virtual Task`1<Notification> get_NotificationListenerTask();
    public sealed virtual Task`1<Command> get_CommandListenerTask();
    public sealed virtual void Dispose();
}
public interface Lime.Protocol.Listeners.IChannelListener {
    public Task`1<Message> MessageListenerTask { get; }
    public Task`1<Notification> NotificationListenerTask { get; }
    public Task`1<Command> CommandListenerTask { get; }
    public abstract virtual Task`1<Message> get_MessageListenerTask();
    public abstract virtual Task`1<Notification> get_NotificationListenerTask();
    public abstract virtual Task`1<Command> get_CommandListenerTask();
    public abstract virtual void Start(IEstablishedReceiverChannel channel);
    public abstract virtual void Stop();
}
public class Lime.Protocol.MediaType : object {
    public static MediaType TextPlain;
    public static MediaType ApplicationJson;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subtype>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Suffix>k__BackingField;
    public string Type { get; public set; }
    public string Subtype { get; public set; }
    public string Suffix { get; public set; }
    public bool IsJson { get; }
    public MediaType(string type, string subtype, string suffix);
    private static MediaType();
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Subtype();
    [CompilerGeneratedAttribute]
public void set_Subtype(string value);
    [CompilerGeneratedAttribute]
public string get_Suffix();
    [CompilerGeneratedAttribute]
public void set_Suffix(string value);
    public bool get_IsJson();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(MediaType left, MediaType right);
    public static bool op_Inequality(MediaType left, MediaType right);
    public static MediaType op_Implicit(string value);
    public static string op_Implicit(MediaType mediaType);
    public static MediaType Parse(string s);
    public static bool TryParse(string s, MediaType& mediaType);
}
[DataContractAttribute]
public class Lime.Protocol.Message : Envelope {
    public static string TYPE_KEY;
    public static string CONTENT_KEY;
    [CompilerGeneratedAttribute]
private Document <Content>k__BackingField;
    [DataMemberAttribute]
public MediaType Type { get; }
    [DataMemberAttribute]
public Document Content { get; public set; }
    public Message(string id);
    public MediaType get_Type();
    [CompilerGeneratedAttribute]
public Document get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(Document value);
    private sealed virtual override Document Lime.Protocol.IDocumentContainer.GetDocument();
}
public class Lime.Protocol.Network.BufferOverflowException : Exception {
    public BufferOverflowException(string message);
    public BufferOverflowException(string message, Exception innerException);
}
public class Lime.Protocol.Network.CancellableTransportDecorator : object {
    private ITransport _transport;
    private IDisposable _disposableTransport;
    public SessionCompression Compression { get; }
    public SessionEncryption Encryption { get; }
    public bool IsConnected { get; }
    public string LocalEndPoint { get; }
    public string RemoteEndPoint { get; }
    public IReadOnlyDictionary`2<string, object> Options { get; }
    public CancellableTransportDecorator(ITransport transport, bool disposeIfDisposable);
    public sealed virtual SessionCompression get_Compression();
    public sealed virtual SessionEncryption get_Encryption();
    public sealed virtual bool get_IsConnected();
    public sealed virtual string get_LocalEndPoint();
    public sealed virtual string get_RemoteEndPoint();
    public sealed virtual IReadOnlyDictionary`2<string, object> get_Options();
    public sealed virtual Task SendAsync(Envelope envelope, CancellationToken cancellationToken);
    public sealed virtual Task`1<Envelope> ReceiveAsync(CancellationToken cancellationToken);
    public sealed virtual Task OpenAsync(Uri uri, CancellationToken cancellationToken);
    public sealed virtual Task CloseAsync(CancellationToken cancellationToken);
    public sealed virtual SessionCompression[] GetSupportedCompression();
    public sealed virtual Task SetCompressionAsync(SessionCompression compression, CancellationToken cancellationToken);
    public sealed virtual SessionEncryption[] GetSupportedEncryption();
    public sealed virtual Task SetEncryptionAsync(SessionEncryption encryption, CancellationToken cancellationToken);
    public sealed virtual Task SetOptionAsync(string name, object value);
    public sealed virtual void add_Closing(EventHandler`1<DeferralEventArgs> value);
    public sealed virtual void remove_Closing(EventHandler`1<DeferralEventArgs> value);
    public sealed virtual void add_Closed(EventHandler value);
    public sealed virtual void remove_Closed(EventHandler value);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class Lime.Protocol.Network.CancellationTokenSourceExtensions : object {
    [ExtensionAttribute]
public static void CancelIfNotRequested(CancellationTokenSource cts);
    [ExtensionAttribute]
public static void CancelAndDispose(CancellationTokenSource cts);
    [ExtensionAttribute]
public static bool IsCancellationRequestedOrDisposed(CancellationTokenSource cts);
}
public abstract class Lime.Protocol.Network.ChannelBase : object {
    private static TimeSpan ExceptionHandlerTimeout;
    private static TimeSpan StopTimeout;
    private TimeSpan _closeTimeout;
    private ReceiverChannel _receiverChannel;
    private SenderChannel _senderChannel;
    private IChannelCommandProcessor _channelCommandProcessor;
    private IDisposable _remotePingChannelModule;
    private SessionState _state;
    private bool _closeTransportInvoked;
    [CompilerGeneratedAttribute]
private ITransport <Transport>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <RemoteNode>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <LocalNode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<IChannelModule`1<Message>> <MessageModules>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<IChannelModule`1<Notification>> <NotificationModules>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<IChannelModule`1<Command>> <CommandModules>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<ExceptionEventArgs> ConsumerException;
    [CompilerGeneratedAttribute]
private EventHandler`1<ExceptionEventArgs> SenderException;
    public ITransport Transport { get; }
    public Node RemoteNode { get; protected set; }
    public Node LocalNode { get; protected set; }
    public string SessionId { get; protected set; }
    public SessionState State { get; protected set; }
    public ICollection`1<IChannelModule`1<Message>> MessageModules { get; }
    public ICollection`1<IChannelModule`1<Notification>> NotificationModules { get; }
    public ICollection`1<IChannelModule`1<Command>> CommandModules { get; }
    protected ChannelBase(ITransport transport, TimeSpan sendTimeout, Nullable`1<TimeSpan> consumeTimeout, TimeSpan closeTimeout, int envelopeBufferSize, bool fillEnvelopeRecipients, bool autoReplyPings, Nullable`1<TimeSpan> remotePingInterval, Nullable`1<TimeSpan> remoteIdleTimeout, IChannelCommandProcessor channelCommandProcessor);
    private static ChannelBase();
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public sealed virtual ITransport get_Transport();
    [CompilerGeneratedAttribute]
public sealed virtual Node get_RemoteNode();
    [CompilerGeneratedAttribute]
protected void set_RemoteNode(Node value);
    [CompilerGeneratedAttribute]
public sealed virtual Node get_LocalNode();
    [CompilerGeneratedAttribute]
protected void set_LocalNode(Node value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SessionId();
    [CompilerGeneratedAttribute]
protected void set_SessionId(string value);
    public sealed virtual SessionState get_State();
    protected void set_State(SessionState value);
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<IChannelModule`1<Message>> get_MessageModules();
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<IChannelModule`1<Notification>> get_NotificationModules();
    [CompilerGeneratedAttribute]
public sealed virtual ICollection`1<IChannelModule`1<Command>> get_CommandModules();
    [CompilerGeneratedAttribute]
public sealed virtual void add_ConsumerException(EventHandler`1<ExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ConsumerException(EventHandler`1<ExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_SenderException(EventHandler`1<ExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_SenderException(EventHandler`1<ExceptionEventArgs> value);
    public virtual Task SendMessageAsync(Message message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.ChannelBase/<ReceiveMessageAsync>d__45")]
public virtual Task`1<Message> ReceiveMessageAsync(CancellationToken cancellationToken);
    public virtual Task SendCommandAsync(Command command, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.ChannelBase/<ReceiveCommandAsync>d__47")]
public virtual Task`1<Command> ReceiveCommandAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.ChannelBase/<ProcessCommandAsync>d__48")]
public virtual Task`1<Command> ProcessCommandAsync(Command requestCommand, CancellationToken cancellationToken);
    public virtual Task SendNotificationAsync(Notification notification, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.ChannelBase/<ReceiveNotificationAsync>d__50")]
public virtual Task`1<Notification> ReceiveNotificationAsync(CancellationToken cancellationToken);
    public virtual Task SendSessionAsync(Session session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.ChannelBase/<ReceiveSessionAsync>d__52")]
public virtual Task`1<Session> ReceiveSessionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.ChannelBase/<CloseTransportAsync>d__53")]
protected Task CloseTransportAsync();
    [AsyncStateMachineAttribute("Lime.Protocol.Network.ChannelBase/<StopChannelTasks>d__54")]
private Task StopChannelTasks();
    [AsyncStateMachineAttribute("Lime.Protocol.Network.ChannelBase/<Transport_Closing>d__55")]
private void Transport_Closing(object sender, DeferralEventArgs e);
    private static void OnStateChanged(IEnumerable`1<IChannelModule`1<T>> modules, SessionState state);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.ChannelBase/<HandleConsumerExceptionAsync>d__57")]
private Task HandleConsumerExceptionAsync(Exception exception);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.ChannelBase/<HandleSenderExceptionAsync>d__58")]
private Task HandleSenderExceptionAsync(Exception exception);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.ChannelBase/<HandleExceptionAndCloseAsync>d__59")]
private Task HandleExceptionAndCloseAsync(Exception exception, EventHandler`1<ExceptionEventArgs> handler);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.ChannelBase/<RaiseExceptionHandlerAsync>d__60")]
private Task RaiseExceptionHandlerAsync(EventHandler`1<ExceptionEventArgs> handler, Exception exception);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class Lime.Protocol.Network.ChannelCommandProcessor : object {
    private ConcurrentDictionary`2<string, TaskCompletionSource`1<Command>> _pendingCommandsDictionary;
    [AsyncStateMachineAttribute("Lime.Protocol.Network.ChannelCommandProcessor/<ProcessCommandAsync>d__2")]
public sealed virtual Task`1<Command> ProcessCommandAsync(ICommandSenderChannel commandSenderChannel, Command requestCommand, CancellationToken cancellationToken);
    public sealed virtual bool TrySubmitCommandResult(Command responseCommand);
    public sealed virtual void CancelAll();
}
[ExtensionAttribute]
public static class Lime.Protocol.Network.ChannelExtensions : object {
    [ExtensionAttribute]
public static Task SendAsync(IEstablishedSenderChannel channel, T envelope);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.ChannelExtensions/<SendAsync>d__1`1")]
[ExtensionAttribute]
public static Task SendAsync(IEstablishedSenderChannel channel, T envelope, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsActive(IChannel channel);
    [ExtensionAttribute]
public static bool IsEstablished(IChannel channel);
}
public class Lime.Protocol.Network.ChannelInformation : object {
    [CompilerGeneratedAttribute]
private string <SessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <LocalNode>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <RemoteNode>k__BackingField;
    public string SessionId { get; }
    public SessionState State { get; }
    public Node LocalNode { get; }
    public Node RemoteNode { get; }
    public ChannelInformation(string sessionId, SessionState state, Node localNode, Node remoteNode);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SessionId();
    [CompilerGeneratedAttribute]
public sealed virtual SessionState get_State();
    [CompilerGeneratedAttribute]
public sealed virtual Node get_LocalNode();
    [CompilerGeneratedAttribute]
public sealed virtual Node get_RemoteNode();
}
[ExtensionAttribute]
public static class Lime.Protocol.Network.CommandProcessorExtensions : object {
    [ExtensionAttribute]
public static Task`1<Command> ProcessCommandOrThrowAsync(ICommandProcessor channel, CommandMethod method, LimeUri uri, CancellationToken cancellationToken, Node from, Node to, Node pp, IDictionary`2<string, string> metadata);
    [ExtensionAttribute]
public static Task`1<Command> ProcessCommandOrThrowAsync(ICommandProcessor channel, CommandMethod method, LimeUri uri, TRequestResource resource, CancellationToken cancellationToken, Node from, Node to, Node pp, IDictionary`2<string, string> metadata);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.CommandProcessorExtensions/<ProcessCommandOrThrowAsync>d__2")]
[ExtensionAttribute]
public static Task`1<Command> ProcessCommandOrThrowAsync(ICommandProcessor channel, Command requestCommand, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TResponseResource> ProcessCommandWithResponseResourceAsync(ICommandProcessor channel, CommandMethod method, LimeUri uri, CancellationToken cancellationToken, Node from, Node to, Node pp, IDictionary`2<string, string> metadata);
    [ExtensionAttribute]
public static Task`1<TResponseResource> ProcessCommandWithResponseResourceAsync(ICommandProcessor channel, CommandMethod method, LimeUri uri, TRequestResource resource, CancellationToken cancellationToken, Node from, Node to, Node pp, IDictionary`2<string, string> metadata);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.CommandProcessorExtensions/<ProcessCommandWithResponseResourceAsync>d__5`1")]
[ExtensionAttribute]
public static Task`1<TResponseResource> ProcessCommandWithResponseResourceAsync(ICommandProcessor channel, Command requestCommand, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TResource> GetResourceAsync(ICommandProcessor channel, LimeUri uri, CancellationToken cancellationToken, Node from, Node to, Node pp, IDictionary`2<string, string> metadata);
    [ExtensionAttribute]
public static Task SetResourceAsync(ICommandProcessor channel, LimeUri uri, TRequestResource resource, CancellationToken cancellationToken, Node from, Node to, Node pp, IDictionary`2<string, string> metadata);
    [ExtensionAttribute]
public static Task`1<TResponseResource> SetResourceAsync(ICommandProcessor channel, LimeUri uri, TRequestResource resource, CancellationToken cancellationToken, Node from, Node to, Node pp, IDictionary`2<string, string> metadata);
    [ExtensionAttribute]
public static Task DeleteResourceAsync(ICommandProcessor channel, LimeUri uri, CancellationToken cancellationToken, Node from, Node to, Node pp, IDictionary`2<string, string> metadata);
    [ExtensionAttribute]
public static Task DeleteResourceAsync(ICommandProcessor channel, LimeUri uri, CancellationToken cancellationToken, Node from, Node to, Node pp, IDictionary`2<string, string> metadata);
    [ExtensionAttribute]
public static Task MergeResourceAsync(ICommandProcessor channel, LimeUri uri, TRequestResource resource, CancellationToken cancellationToken, Node from, Node to, Node pp, IDictionary`2<string, string> metadata);
    [ExtensionAttribute]
public static Task`1<TResponseResource> MergeResourceAsync(ICommandProcessor channel, LimeUri uri, TRequestResource resource, CancellationToken cancellationToken, Node from, Node to, Node pp, IDictionary`2<string, string> metadata);
    [ExtensionAttribute]
public static Task SubscribeResourceAsync(ICommandProcessor channel, LimeUri uri, CancellationToken cancellationToken, Node from, Node to, Node pp, IDictionary`2<string, string> metadata);
    [ExtensionAttribute]
public static Task SubscribeResourceAsync(ICommandProcessor channel, LimeUri uri, CancellationToken cancellationToken, Node from, Node to, Node pp, IDictionary`2<string, string> metadata);
    [ExtensionAttribute]
public static Task UnsubscribeResourceAsync(ICommandProcessor channel, LimeUri uri, CancellationToken cancellationToken, Node from, Node to, Node pp, IDictionary`2<string, string> metadata);
    [ExtensionAttribute]
public static Task UnsubscribeResourceAsync(ICommandProcessor channel, LimeUri uri, CancellationToken cancellationToken, Node from, Node to, Node pp, IDictionary`2<string, string> metadata);
    [ExtensionAttribute]
public static Task ObserveResourceAsync(ICommandProcessor channel, LimeUri uri, TRequestResource resource, CancellationToken cancellationToken, Node from, Node to, Node pp, IDictionary`2<string, string> metadata);
    [ExtensionAttribute]
public static Task`1<TResponseResource> ObserveResourceAsync(ICommandProcessor channel, LimeUri uri, TRequestResource resource, CancellationToken cancellationToken, Node from, Node to, Node pp, IDictionary`2<string, string> metadata);
}
[ExtensionAttribute]
public static class Lime.Protocol.Network.CommandSenderChannelExtensions : object {
    [ExtensionAttribute]
public static Task SendCommandAsync(ICommandSenderChannel channel, Command command);
}
public enum Lime.Protocol.Network.DataOperation : Enum {
    public int value__;
    public static DataOperation Send;
    public static DataOperation Receive;
    public static DataOperation Error;
    public static DataOperation Information;
}
public class Lime.Protocol.Network.DeferralEventArgs : EventArgs {
    private DeferralManager _deferrals;
    public IDisposable GetDeferral();
    public Task WaitForDeferralsAsync(CancellationToken cancellationToken);
}
public class Lime.Protocol.Network.EnvelopeEventArgs`1 : DeferralEventArgs {
    [CompilerGeneratedAttribute]
private T <Envelope>k__BackingField;
    public T Envelope { get; }
    public EnvelopeEventArgs`1(T envelope);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Envelope();
}
public class Lime.Protocol.Network.EnvelopeTooLargeException : Exception {
    public EnvelopeTooLargeException(string message);
    public EnvelopeTooLargeException(string message, Envelope envelope);
    public EnvelopeTooLargeException(string message, Exception innerException);
    public EnvelopeTooLargeException(string message, Envelope envelope, Exception innerException);
    private void AddEnvelopePropertiesToData(Envelope envelope);
}
public class Lime.Protocol.Network.ExceptionEventArgs : DeferralEventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; }
    public ExceptionEventArgs(Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
public class Lime.Protocol.Network.FailedChannelInformation : ChannelInformation {
    [CompilerGeneratedAttribute]
private bool <IsConnected>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationName>k__BackingField;
    public bool IsConnected { get; }
    public Exception Exception { get; }
    public string OperationName { get; }
    public FailedChannelInformation(string sessionId, SessionState state, Node localNode, Node remoteNode, bool isConnected, Exception exception, string operationName);
    [CompilerGeneratedAttribute]
public bool get_IsConnected();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public string get_OperationName();
}
public interface Lime.Protocol.Network.IChannel {
    public ITransport Transport { get; }
    public ICollection`1<IChannelModule`1<Message>> MessageModules { get; }
    public ICollection`1<IChannelModule`1<Notification>> NotificationModules { get; }
    public ICollection`1<IChannelModule`1<Command>> CommandModules { get; }
    public abstract virtual ITransport get_Transport();
    public abstract virtual ICollection`1<IChannelModule`1<Message>> get_MessageModules();
    public abstract virtual ICollection`1<IChannelModule`1<Notification>> get_NotificationModules();
    public abstract virtual ICollection`1<IChannelModule`1<Command>> get_CommandModules();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ConsumerException(EventHandler`1<ExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ConsumerException(EventHandler`1<ExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SenderException(EventHandler`1<ExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SenderException(EventHandler`1<ExceptionEventArgs> value);
}
public interface Lime.Protocol.Network.IChannelCommandProcessor {
    public abstract virtual Task`1<Command> ProcessCommandAsync(ICommandSenderChannel commandSenderChannel, Command requestCommand, CancellationToken cancellationToken);
    public abstract virtual bool TrySubmitCommandResult(Command responseCommand);
    public abstract virtual void CancelAll();
}
public interface Lime.Protocol.Network.IChannelInformation {
    public string SessionId { get; }
    public SessionState State { get; }
    public Node LocalNode { get; }
    public Node RemoteNode { get; }
    public abstract virtual string get_SessionId();
    public abstract virtual SessionState get_State();
    public abstract virtual Node get_LocalNode();
    public abstract virtual Node get_RemoteNode();
}
public interface Lime.Protocol.Network.IChannelModule`1 {
    public abstract virtual void OnStateChanged(SessionState state);
    public abstract virtual Task`1<T> OnReceivingAsync(T envelope, CancellationToken cancellationToken);
    public abstract virtual Task`1<T> OnSendingAsync(T envelope, CancellationToken cancellationToken);
}
public interface Lime.Protocol.Network.ICommandChannel {
}
public interface Lime.Protocol.Network.ICommandProcessor {
    public abstract virtual Task`1<Command> ProcessCommandAsync(Command requestCommand, CancellationToken cancellationToken);
}
public interface Lime.Protocol.Network.ICommandReceiverChannel {
    public abstract virtual Task`1<Command> ReceiveCommandAsync(CancellationToken cancellationToken);
}
public interface Lime.Protocol.Network.ICommandSenderChannel {
    public abstract virtual Task SendCommandAsync(Command command, CancellationToken cancellationToken);
}
public interface Lime.Protocol.Network.IEnvelopeContainer`1 {
    public T Envelope { get; }
    public abstract virtual T get_Envelope();
}
public interface Lime.Protocol.Network.IEstablishedChannel {
}
public interface Lime.Protocol.Network.IEstablishedReceiverChannel {
}
public interface Lime.Protocol.Network.IEstablishedSenderChannel {
}
public interface Lime.Protocol.Network.IMessageChannel {
}
public interface Lime.Protocol.Network.IMessageReceiverChannel {
    public abstract virtual Task`1<Message> ReceiveMessageAsync(CancellationToken cancellationToken);
}
public interface Lime.Protocol.Network.IMessageSenderChannel {
    public abstract virtual Task SendMessageAsync(Message message, CancellationToken cancellationToken);
}
public interface Lime.Protocol.Network.INotificationChannel {
}
public interface Lime.Protocol.Network.INotificationReceiverChannel {
    public abstract virtual Task`1<Notification> ReceiveNotificationAsync(CancellationToken cancellationToken);
}
public interface Lime.Protocol.Network.INotificationSenderChannel {
    public abstract virtual Task SendNotificationAsync(Notification notification, CancellationToken cancellationToken);
}
public interface Lime.Protocol.Network.IReceiverChannel {
}
public interface Lime.Protocol.Network.ISenderChannel {
}
public interface Lime.Protocol.Network.ISessionChannel {
}
public interface Lime.Protocol.Network.ISessionReceiverChannel {
    public abstract virtual Task`1<Session> ReceiveSessionAsync(CancellationToken cancellationToken);
}
public interface Lime.Protocol.Network.ISessionSenderChannel {
    public abstract virtual Task SendSessionAsync(Session session, CancellationToken cancellationToken);
}
public interface Lime.Protocol.Network.ITraceWriter {
    public bool IsEnabled { get; }
    public abstract virtual Task TraceAsync(string data, DataOperation operation);
    public abstract virtual bool get_IsEnabled();
}
public interface Lime.Protocol.Network.ITransport {
    public abstract virtual Task SendAsync(Envelope envelope, CancellationToken cancellationToken);
    public abstract virtual Task`1<Envelope> ReceiveAsync(CancellationToken cancellationToken);
    public abstract virtual Task OpenAsync(Uri uri, CancellationToken cancellationToken);
    public abstract virtual Task CloseAsync(CancellationToken cancellationToken);
    public abstract virtual SessionCompression[] GetSupportedCompression();
    public abstract virtual Task SetCompressionAsync(SessionCompression compression, CancellationToken cancellationToken);
    public abstract virtual SessionEncryption[] GetSupportedEncryption();
    public abstract virtual Task SetEncryptionAsync(SessionEncryption encryption, CancellationToken cancellationToken);
    public abstract virtual Task SetOptionAsync(string name, object value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Closing(EventHandler`1<DeferralEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Closing(EventHandler`1<DeferralEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Closed(EventHandler value);
}
public interface Lime.Protocol.Network.ITransportInformation {
    public SessionCompression Compression { get; }
    public SessionEncryption Encryption { get; }
    public bool IsConnected { get; }
    public string LocalEndPoint { get; }
    public string RemoteEndPoint { get; }
    public IReadOnlyDictionary`2<string, object> Options { get; }
    public abstract virtual SessionCompression get_Compression();
    public abstract virtual SessionEncryption get_Encryption();
    public abstract virtual bool get_IsConnected();
    public abstract virtual string get_LocalEndPoint();
    public abstract virtual string get_RemoteEndPoint();
    public abstract virtual IReadOnlyDictionary`2<string, object> get_Options();
}
public class Lime.Protocol.Network.JsonBuffer : object {
    private int _bufferSize;
    private int _maxBufferSize;
    private ArrayPool`1<byte> _arrayPool;
    private Byte[] _buffer;
    private int _bufferCurPos;
    private int _jsonStartPos;
    private int _jsonCurPos;
    private int _jsonStackedBrackets;
    private bool _jsonStarted;
    private bool _insideQuotes;
    private bool _isEscaping;
    public Byte[] Buffer { get; }
    public int BufferCurPos { get; public set; }
    public JsonBuffer(int bufferSize, int maxBufferSize, ArrayPool`1<byte> arrayPool);
    public Byte[] get_Buffer();
    public void set_BufferCurPos(int value);
    public int get_BufferCurPos();
    public bool TryExtractJsonFromBuffer(Byte[]& json);
    public void IncreaseBuffer();
    public static bool TryExtractJsonFromBuffer(ReadOnlySequence`1<byte> buffer, ReadOnlySequence`1& json);
    private void Reset();
    public virtual string ToString();
    public sealed virtual void Dispose();
}
public class Lime.Protocol.Network.LimeException : Exception {
    [CompilerGeneratedAttribute]
private Reason <Reason>k__BackingField;
    public Reason Reason { get; private set; }
    public LimeException(int reasonCode, string reasonDescription, Exception innerException);
    public LimeException(Reason reason, Exception innerException);
    [CompilerGeneratedAttribute]
public Reason get_Reason();
    [CompilerGeneratedAttribute]
private void set_Reason(Reason value);
}
[ExtensionAttribute]
public static class Lime.Protocol.Network.MessageSenderChannelExtensions : object {
    [ExtensionAttribute]
public static Task SendMessageAsync(IMessageSenderChannel channel, Message message);
}
public class Lime.Protocol.Network.Modules.ChannelModule`1 : ChannelModuleBase`1<T> {
    private Func`3<T, CancellationToken, Task`1<T>> _onReceivingFunc;
    private Func`3<T, CancellationToken, Task`1<T>> _onSendingFunc;
    private Action`1<SessionState> _onStateChangedAction;
    public ChannelModule`1(Func`3<T, CancellationToken, Task`1<T>> onReceivingFunc, Func`3<T, CancellationToken, Task`1<T>> onSendingFunc, Action`1<SessionState> onStateChangedAction);
    public virtual Task`1<T> OnReceivingAsync(T envelope, CancellationToken cancellationToken);
    public virtual Task`1<T> OnSendingAsync(T envelope, CancellationToken cancellationToken);
    public virtual void OnStateChanged(SessionState state);
}
public abstract class Lime.Protocol.Network.Modules.ChannelModuleBase`1 : object {
    public virtual void OnStateChanged(SessionState state);
    public virtual Task`1<T> OnReceivingAsync(T envelope, CancellationToken cancellationToken);
    public virtual Task`1<T> OnSendingAsync(T envelope, CancellationToken cancellationToken);
}
public class Lime.Protocol.Network.Modules.ExtractContainerMessageModule : ChannelModuleBase`1<Message> {
    public virtual Task`1<Message> OnReceivingAsync(Message envelope, CancellationToken cancellationToken);
}
public class Lime.Protocol.Network.Modules.FillEnvelopeRecipientsChannelModule : object {
    [CompilerGeneratedAttribute]
private FillEnvelopeRecipientsChannelModule`1<Message> <MessageChannelModule>k__BackingField;
    [CompilerGeneratedAttribute]
private FillEnvelopeRecipientsChannelModule`1<Notification> <NotificationChannelModule>k__BackingField;
    [CompilerGeneratedAttribute]
private FillEnvelopeRecipientsChannelModule`1<Command> <CommandChannelModule>k__BackingField;
    public FillEnvelopeRecipientsChannelModule`1<Message> MessageChannelModule { get; }
    public FillEnvelopeRecipientsChannelModule`1<Notification> NotificationChannelModule { get; }
    public FillEnvelopeRecipientsChannelModule`1<Command> CommandChannelModule { get; }
    private FillEnvelopeRecipientsChannelModule(FillEnvelopeRecipientsChannelModule`1<Message> messageChannelModule, FillEnvelopeRecipientsChannelModule`1<Notification> notificationChannelModule, FillEnvelopeRecipientsChannelModule`1<Command> commandChannelModule);
    [CompilerGeneratedAttribute]
public FillEnvelopeRecipientsChannelModule`1<Message> get_MessageChannelModule();
    [CompilerGeneratedAttribute]
public FillEnvelopeRecipientsChannelModule`1<Notification> get_NotificationChannelModule();
    [CompilerGeneratedAttribute]
public FillEnvelopeRecipientsChannelModule`1<Command> get_CommandChannelModule();
    public static FillEnvelopeRecipientsChannelModule`1<Message> op_Implicit(FillEnvelopeRecipientsChannelModule fillEnvelopeRecipientsChannelModule);
    public static FillEnvelopeRecipientsChannelModule`1<Notification> op_Implicit(FillEnvelopeRecipientsChannelModule fillEnvelopeRecipientsChannelModule);
    public static FillEnvelopeRecipientsChannelModule`1<Command> op_Implicit(FillEnvelopeRecipientsChannelModule fillEnvelopeRecipientsChannelModule);
    public static FillEnvelopeRecipientsChannelModule CreateAndRegister(IChannel channel);
}
public class Lime.Protocol.Network.Modules.FillEnvelopeRecipientsChannelModule`1 : ChannelModuleBase`1<T> {
    private IChannel _channel;
    public FillEnvelopeRecipientsChannelModule`1(IChannel channel);
    public virtual Task`1<T> OnSendingAsync(T envelope, CancellationToken cancellationToken);
    public virtual Task`1<T> OnReceivingAsync(T envelope, CancellationToken cancellationToken);
}
public class Lime.Protocol.Network.Modules.NotifyReceiptChannelModule : ChannelModuleBase`1<Message> {
    private IChannel _channel;
    public NotifyReceiptChannelModule(IChannel channel);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.Modules.NotifyReceiptChannelModule/<OnReceivingAsync>d__2")]
public virtual Task`1<Message> OnReceivingAsync(Message envelope, CancellationToken cancellationToken);
    protected virtual Notification CreateNotification(Message message);
}
public class Lime.Protocol.Network.Modules.RemotePingChannelModule : object {
    public static string PING_URI;
    private static TimeSpan DefaultFinishChannelTimeout;
    private IChannel _channel;
    private TimeSpan _remotePingInterval;
    private TimeSpan _remoteIdleTimeout;
    private TimeSpan _finishChannelTimeout;
    private CancellationTokenSource _cts;
    private object _syncRoot;
    private Task _pingRemoteTask;
    private string _lastPingCommandRequestId;
    private bool _hasPendingPingRequest;
    private bool _disposing;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastReceivedEnvelope>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<ExceptionEventArgs> RemotePingException;
    public DateTimeOffset LastReceivedEnvelope { get; private set; }
    protected RemotePingChannelModule(IChannel channel, TimeSpan remotePingInterval, Nullable`1<TimeSpan> remoteIdleTimeout, Nullable`1<TimeSpan> finishChannelTimeout);
    private static RemotePingChannelModule();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastReceivedEnvelope();
    [CompilerGeneratedAttribute]
private void set_LastReceivedEnvelope(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public void add_RemotePingException(EventHandler`1<ExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RemotePingException(EventHandler`1<ExceptionEventArgs> value);
    public sealed virtual void OnStateChanged(SessionState state);
    public sealed virtual Task`1<Message> OnReceivingAsync(Message envelope, CancellationToken cancellationToken);
    public sealed virtual Task`1<Message> OnSendingAsync(Message envelope, CancellationToken cancellationToken);
    public sealed virtual Task`1<Notification> OnReceivingAsync(Notification envelope, CancellationToken cancellationToken);
    public sealed virtual Task`1<Notification> OnSendingAsync(Notification envelope, CancellationToken cancellationToken);
    public sealed virtual Task`1<Command> OnReceivingAsync(Command envelope, CancellationToken cancellationToken);
    public sealed virtual Task`1<Command> OnSendingAsync(Command envelope, CancellationToken cancellationToken);
    public static RemotePingChannelModule CreateAndRegister(IChannel channel, TimeSpan remotePingInterval, Nullable`1<TimeSpan> remoteIdleTimeout);
    private Task`1<T> ReceiveEnvelope(T envelope);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.Modules.RemotePingChannelModule/<PingRemoteAsync>d__29")]
private Task PingRemoteAsync();
    protected virtual Task FinishAsync(IClientChannel clientChannel, CancellationToken cancellationToken);
    protected virtual Task FinishAsync(IServerChannel serverChannel, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
public class Lime.Protocol.Network.Modules.ReplyPingChannelModule : ChannelModuleBase`1<Command> {
    public static string PING_MEDIA_TYPE;
    public static string PING_URI;
    private static Document PingDocument;
    private IChannel _channel;
    public ReplyPingChannelModule(IChannel channel);
    private static ReplyPingChannelModule();
    [AsyncStateMachineAttribute("Lime.Protocol.Network.Modules.ReplyPingChannelModule/<OnReceivingAsync>d__5")]
public virtual Task`1<Command> OnReceivingAsync(Command envelope, CancellationToken cancellationToken);
}
public class Lime.Protocol.Network.Modules.Resend.DiscardDeadMessageHandler : object {
    [CompilerGeneratedAttribute]
private static DiscardDeadMessageHandler <Instance>k__BackingField;
    public static DiscardDeadMessageHandler Instance { get; }
    private static DiscardDeadMessageHandler();
    [CompilerGeneratedAttribute]
public static DiscardDeadMessageHandler get_Instance();
    public sealed virtual Task HandleDeadMessageAsync(Message message, IChannelInformation channelInformation, CancellationToken cancellationToken);
}
public interface Lime.Protocol.Network.Modules.Resend.IDeadMessageHandler {
    public abstract virtual Task HandleDeadMessageAsync(Message message, IChannelInformation channelInformation, CancellationToken cancellationToken);
}
public interface Lime.Protocol.Network.Modules.Resend.IKeyProvider {
    public abstract virtual string GetChannelKey(IChannel channel);
    public abstract virtual string GetMessageKey(Message message, IChannel channel);
    public abstract virtual string GetMessageKey(Notification notification, IChannel channel);
}
public interface Lime.Protocol.Network.Modules.Resend.IMessageStorage {
    public abstract virtual Task AddAsync(string channelKey, string messageKey, Message message, DateTimeOffset resendAt, CancellationToken cancellationToken);
    public abstract virtual Task`1<Message> RemoveAsync(string channelKey, string messageKey, CancellationToken cancellationToken);
    public abstract virtual Task`1<IEnumerable`1<string>> GetMessagesToResendKeysAsync(string channelKey, DateTimeOffset reference, CancellationToken cancellationToken);
}
public class Lime.Protocol.Network.Modules.Resend.KeyProvider : object {
    [CompilerGeneratedAttribute]
private static KeyProvider <Instance>k__BackingField;
    public static KeyProvider Instance { get; }
    private static KeyProvider();
    [CompilerGeneratedAttribute]
public static KeyProvider get_Instance();
    public sealed virtual string GetChannelKey(IChannel channel);
    public sealed virtual string GetMessageKey(Message message, IChannel channel);
    public sealed virtual string GetMessageKey(Notification notification, IChannel channel);
}
public class Lime.Protocol.Network.Modules.Resend.MemoryMessageStorage : object {
    private TimeSpan _resendExpiration;
    private int _checkForRemovalInterval;
    private ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MessageToResend>> _channelMessageDictionary;
    private long _addCount;
    public MemoryMessageStorage(TimeSpan resendExpiration, int checkForRemovalInterval);
    public sealed virtual Task AddAsync(string channelKey, string messageKey, Message message, DateTimeOffset resendAt, CancellationToken cancellationToken);
    public sealed virtual Task`1<IEnumerable`1<string>> GetMessagesToResendKeysAsync(string channelKey, DateTimeOffset reference, CancellationToken cancellationToken);
    public sealed virtual Task`1<Message> RemoveAsync(string channelKey, string messageKey, CancellationToken cancellationToken);
    private ConcurrentDictionary`2<string, MessageToResend> GetMessageDictionary(string channelKey);
    private void RemoveOldPendingMessages();
}
public class Lime.Protocol.Network.Modules.Resend.ResendMessagesChannelModule : object {
    private static string RESENT_COUNT_METADATA_KEY;
    private static string RESENT_SESSION_KEY;
    private static string RESENT_CHANNEL_ROLE_METADATA_KEY;
    private IChannel _channel;
    private IMessageStorage _messageStorage;
    private IKeyProvider _keyProvider;
    private IDeadMessageHandler _deadMessageHandler;
    private int _maxResendCount;
    private TimeSpan _resendWindow;
    private Event[] _eventsToRemovePendingMessage;
    private object _syncRoot;
    private Func`4<Exception, IChannel, Message, Task> _resendExceptionHandler;
    private string _channelKey;
    private Task _resendTask;
    private CancellationTokenSource _cts;
    private bool _disposing;
    public ResendMessagesChannelModule(IChannel channel, IMessageStorage messageStorage, IKeyProvider keyProvider, IDeadMessageHandler deadMessageHandler, int maxResendCount, TimeSpan resendWindow, Event[] eventsToRemovePendingMessage, Func`4<Exception, IChannel, Message, Task> resendExceptionHandler);
    public virtual void OnStateChanged(SessionState state);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.Modules.Resend.ResendMessagesChannelModule/<OnSendingAsync>d__18")]
public virtual Task`1<Message> OnSendingAsync(Message envelope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.Modules.Resend.ResendMessagesChannelModule/<OnReceivingAsync>d__19")]
public virtual Task`1<Notification> OnReceivingAsync(Notification envelope, CancellationToken cancellationToken);
    public virtual Task`1<Notification> OnSendingAsync(Notification envelope, CancellationToken cancellationToken);
    public virtual Task`1<Message> OnReceivingAsync(Message envelope, CancellationToken cancellationToken);
    public virtual void RegisterTo(IChannel channel);
    public static ResendMessagesChannelModule CreateAndRegister(IChannel channel, int maxResendCount, TimeSpan resendWindow, IMessageStorage messageStorage, IKeyProvider keyProvider, IDeadMessageHandler deadMessageHandler, Event[] eventsToRemovePendingMessage);
    private void StartResendTask();
    private void StopResendTask();
    [AsyncStateMachineAttribute("Lime.Protocol.Network.Modules.Resend.ResendMessagesChannelModule/<ResendExpiredMessagesAsync>d__26")]
private Task ResendExpiredMessagesAsync(CancellationToken cancellationToken);
    private static int GetMessageResendCount(Message expiredMessage);
    private void SetMessageResendCount(Message expiredMessage, int resendCount);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private Task <StartResendTask>b__24_0();
}
public class Lime.Protocol.Network.Modules.ThroughputControlChannelModule : object {
    private IChannel _channel;
    private RateGate _rateGate;
    private ThroughputControlChannelModule(IChannel channel, int throughput);
    public sealed virtual Task`1<Message> OnReceivingAsync(Message envelope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.Modules.ThroughputControlChannelModule/<OnSendingAsync>d__4")]
public sealed virtual Task`1<Message> OnSendingAsync(Message envelope, CancellationToken cancellationToken);
    public sealed virtual Task`1<Command> OnReceivingAsync(Command envelope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.Modules.ThroughputControlChannelModule/<OnSendingAsync>d__6")]
public sealed virtual Task`1<Command> OnSendingAsync(Command envelope, CancellationToken cancellationToken);
    public sealed virtual Task`1<Notification> OnReceivingAsync(Notification envelope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.Modules.ThroughputControlChannelModule/<OnSendingAsync>d__8")]
public sealed virtual Task`1<Notification> OnSendingAsync(Notification envelope, CancellationToken cancellationToken);
    public sealed virtual void OnStateChanged(SessionState state);
    public sealed virtual void Dispose();
    public static ThroughputControlChannelModule CreateAndRegister(IChannel channel, int throughput);
}
[ExtensionAttribute]
public static class Lime.Protocol.Network.NotificationSenderChannelExtensions : object {
    [ExtensionAttribute]
public static Task SendNotificationAsync(INotificationSenderChannel channel, Notification notification);
}
internal class Lime.Protocol.Network.ReceiverChannel : object {
    private IChannelInformation _channelInformation;
    private ITransport _transport;
    private IChannelCommandProcessor _channelCommandProcessor;
    private ICollection`1<IChannelModule`1<Message>> _messageModules;
    private ICollection`1<IChannelModule`1<Notification>> _notificationModules;
    private ICollection`1<IChannelModule`1<Command>> _commandModules;
    private Func`2<Exception, Task> _exceptionHandler;
    private Nullable`1<TimeSpan> _consumeTimeout;
    private TimeSpan _closeTimeout;
    private CancellationTokenSource _consumerCts;
    private Channel`1<Message> _messageBuffer;
    private Channel`1<Command> _commandBuffer;
    private Channel`1<Notification> _notificationBuffer;
    private Channel`1<Session> _sessionBuffer;
    private SemaphoreSlim _sessionSemaphore;
    private SemaphoreSlim _startStopSemaphore;
    private Task _receiveFromTransportTask;
    private bool _isDisposing;
    public ReceiverChannel(IChannelInformation channelInformation, ITransport transport, IChannelCommandProcessor channelCommandProcessor, ICollection`1<IChannelModule`1<Message>> messageModules, ICollection`1<IChannelModule`1<Notification>> notificationModules, ICollection`1<IChannelModule`1<Command>> commandModules, Func`2<Exception, Task> exceptionHandler, int envelopeBufferSize, Nullable`1<TimeSpan> consumeTimeout, Nullable`1<TimeSpan> closeTimeout);
    public sealed virtual Task`1<Message> ReceiveMessageAsync(CancellationToken cancellationToken);
    public sealed virtual Task`1<Command> ReceiveCommandAsync(CancellationToken cancellationToken);
    public sealed virtual Task`1<Notification> ReceiveNotificationAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.ReceiverChannel/<ReceiveSessionAsync>d__22")]
public sealed virtual Task`1<Session> ReceiveSessionAsync(CancellationToken cancellationToken);
    public void Start();
    [AsyncStateMachineAttribute("Lime.Protocol.Network.ReceiverChannel/<StopAsync>d__24")]
public sealed virtual Task StopAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private bool IsChannelEstablished();
    [AsyncStateMachineAttribute("Lime.Protocol.Network.ReceiverChannel/<ReceiveFromTransportAsync>d__27")]
private Task ReceiveFromTransportAsync();
    [AsyncStateMachineAttribute("Lime.Protocol.Network.ReceiverChannel/<WriteToBufferAsync>d__28")]
private Task WriteToBufferAsync(Envelope envelope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.ReceiverChannel/<ReceiveFromBufferAsync>d__29`1")]
private Task`1<T> ReceiveFromBufferAsync(ChannelReader`1<T> reader, IEnumerable`1<IChannelModule`1<T>> modules, CancellationToken cancellationToken);
    private void TryCompleteWriters(Exception exception);
    private void RaiseReceiverException(Exception exception);
}
internal class Lime.Protocol.Network.SenderChannel : object {
    private IChannelInformation _channelInformation;
    private ITransport _transport;
    private ICollection`1<IChannelModule`1<Message>> _messageModules;
    private ICollection`1<IChannelModule`1<Notification>> _notificationModules;
    private ICollection`1<IChannelModule`1<Command>> _commandModules;
    private Func`2<Exception, Task> _exceptionHandler;
    private TimeSpan _sendTimeout;
    private TimeSpan _closeTimeout;
    private CancellationTokenSource _senderCts;
    private Channel`1<Envelope> _envelopeBuffer;
    private SemaphoreSlim _sessionSemaphore;
    private SemaphoreSlim _startStopSemaphore;
    private bool _isDisposing;
    private Task _sendToTransportTask;
    public SenderChannel(IChannelInformation channelInformation, ITransport transport, ICollection`1<IChannelModule`1<Message>> messageModules, ICollection`1<IChannelModule`1<Notification>> notificationModules, ICollection`1<IChannelModule`1<Command>> commandModules, Func`2<Exception, Task> exceptionHandler, int envelopeBufferSize, TimeSpan sendTimeout, Nullable`1<TimeSpan> closeTimeout);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.SenderChannel/<SendMessageAsync>d__15")]
public sealed virtual Task SendMessageAsync(Message message, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.SenderChannel/<SendNotificationAsync>d__16")]
public sealed virtual Task SendNotificationAsync(Notification notification, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.SenderChannel/<SendCommandAsync>d__17")]
public sealed virtual Task SendCommandAsync(Command command, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.SenderChannel/<SendSessionAsync>d__18")]
public sealed virtual Task SendSessionAsync(Session session, CancellationToken cancellationToken);
    public void Start();
    [AsyncStateMachineAttribute("Lime.Protocol.Network.SenderChannel/<StopAsync>d__20")]
public sealed virtual Task StopAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Lime.Protocol.Network.SenderChannel/<SendToBufferAsync>d__22`1")]
private Task SendToBufferAsync(T envelope, IEnumerable`1<IChannelModule`1<T>> modules, CancellationToken cancellationToken);
    private bool IsChannelEstablished();
    [AsyncStateMachineAttribute("Lime.Protocol.Network.SenderChannel/<SendToTransportAsync>d__24")]
private Task SendToTransportAsync();
    private void RaiseSenderException(Exception exception);
}
public class Lime.Protocol.Network.SynchronizedTransportDecorator : object {
    private ITransport _transport;
    private SemaphoreSlim _sendSemaphore;
    private SemaphoreSlim _receiveSemaphore;
    public SessionCompression Compression { get; }
    public SessionEncryption Encryption { get; }
    public bool IsConnected { get; }
    public string LocalEndPoint { get; }
    public string RemoteEndPoint { get; }
    public IReadOnlyDictionary`2<string, object> Options { get; }
    public SynchronizedTransportDecorator(ITransport transport);
    public sealed virtual SessionCompression get_Compression();
    public sealed virtual SessionEncryption get_Encryption();
    public sealed virtual bool get_IsConnected();
    public sealed virtual string get_LocalEndPoint();
    public sealed virtual string get_RemoteEndPoint();
    public sealed virtual IReadOnlyDictionary`2<string, object> get_Options();
    [AsyncStateMachineAttribute("Lime.Protocol.Network.SynchronizedTransportDecorator/<SendAsync>d__16")]
public sealed virtual Task SendAsync(Envelope envelope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.SynchronizedTransportDecorator/<ReceiveAsync>d__17")]
public sealed virtual Task`1<Envelope> ReceiveAsync(CancellationToken cancellationToken);
    public sealed virtual Task OpenAsync(Uri uri, CancellationToken cancellationToken);
    public sealed virtual Task CloseAsync(CancellationToken cancellationToken);
    public sealed virtual SessionCompression[] GetSupportedCompression();
    public sealed virtual Task SetCompressionAsync(SessionCompression compression, CancellationToken cancellationToken);
    public sealed virtual SessionEncryption[] GetSupportedEncryption();
    public sealed virtual Task SetEncryptionAsync(SessionEncryption encryption, CancellationToken cancellationToken);
    public sealed virtual Task SetOptionAsync(string name, object value);
    public sealed virtual void add_Closing(EventHandler`1<DeferralEventArgs> value);
    public sealed virtual void remove_Closing(EventHandler`1<DeferralEventArgs> value);
    public sealed virtual void add_Closed(EventHandler value);
    public sealed virtual void remove_Closed(EventHandler value);
}
public class Lime.Protocol.Network.TraceWriter : object {
    public bool IsEnabled { get; }
    public sealed virtual Task TraceAsync(string data, DataOperation operation);
    public sealed virtual bool get_IsEnabled();
}
[ExtensionAttribute]
public static class Lime.Protocol.Network.TraceWriterExtensions : object {
    [ExtensionAttribute]
public static Task TraceIfEnabledAsync(ITraceWriter traceWriter, string data, DataOperation operation);
}
public abstract class Lime.Protocol.Network.TransportBase : object {
    private bool _isOpen;
    private bool _closingInvoked;
    private bool _closedInvoked;
    private SemaphoreSlim _openCloseSemaphore;
    [CompilerGeneratedAttribute]
private SessionCompression <Compression>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionEncryption <Encryption>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<DeferralEventArgs> Closing;
    [CompilerGeneratedAttribute]
private EventHandler Closed;
    public SessionCompression Compression { get; protected set; }
    public SessionEncryption Encryption { get; protected set; }
    public bool IsConnected { get; }
    public string LocalEndPoint { get; }
    public string RemoteEndPoint { get; }
    public IReadOnlyDictionary`2<string, object> Options { get; }
    public abstract virtual Task SendAsync(Envelope envelope, CancellationToken cancellationToken);
    public abstract virtual Task`1<Envelope> ReceiveAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.TransportBase/<OpenAsync>d__7")]
public virtual Task OpenAsync(Uri uri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Network.TransportBase/<CloseAsync>d__8")]
public virtual Task CloseAsync(CancellationToken cancellationToken);
    public virtual SessionCompression[] GetSupportedCompression();
    [CompilerGeneratedAttribute]
public virtual SessionCompression get_Compression();
    [CompilerGeneratedAttribute]
protected virtual void set_Compression(SessionCompression value);
    public virtual Task SetCompressionAsync(SessionCompression compression, CancellationToken cancellationToken);
    public virtual SessionEncryption[] GetSupportedEncryption();
    [CompilerGeneratedAttribute]
public virtual SessionEncryption get_Encryption();
    [CompilerGeneratedAttribute]
protected virtual void set_Encryption(SessionEncryption value);
    public abstract virtual bool get_IsConnected();
    public virtual string get_LocalEndPoint();
    public virtual string get_RemoteEndPoint();
    public virtual IReadOnlyDictionary`2<string, object> get_Options();
    public virtual Task SetEncryptionAsync(SessionEncryption encryption, CancellationToken cancellationToken);
    public virtual Task SetOptionAsync(string name, object value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Closing(EventHandler`1<DeferralEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Closing(EventHandler`1<DeferralEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Closed(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Closed(EventHandler value);
    protected abstract virtual Task PerformCloseAsync(CancellationToken cancellationToken);
    protected abstract virtual Task PerformOpenAsync(Uri uri, CancellationToken cancellationToken);
    protected virtual Task OnClosingAsync();
    protected virtual void OnClosed();
}
public class Lime.Protocol.Network.TransportInformation : object {
    [CompilerGeneratedAttribute]
private SessionCompression <Compression>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionEncryption <Encryption>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConnected>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalEndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemoteEndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Options>k__BackingField;
    public SessionCompression Compression { get; }
    public SessionEncryption Encryption { get; }
    public bool IsConnected { get; }
    public string LocalEndPoint { get; }
    public string RemoteEndPoint { get; }
    public IReadOnlyDictionary`2<string, object> Options { get; }
    public TransportInformation(SessionCompression compression, SessionEncryption encryption, bool isConnected, string localEndPoint, string remoteEndPoint, IReadOnlyDictionary`2<string, object> options);
    [CompilerGeneratedAttribute]
public sealed virtual SessionCompression get_Compression();
    [CompilerGeneratedAttribute]
public sealed virtual SessionEncryption get_Encryption();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsConnected();
    [CompilerGeneratedAttribute]
public sealed virtual string get_LocalEndPoint();
    [CompilerGeneratedAttribute]
public sealed virtual string get_RemoteEndPoint();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyDictionary`2<string, object> get_Options();
}
[ExtensionAttribute]
public static class Lime.Protocol.Network.X509CertificateExtensions : object {
    [ExtensionAttribute]
public static String[] GetDomains(X509Certificate2 certificate);
    [ExtensionAttribute]
public static DomainRole GetDomainRole(X509Certificate2 certificate, Identity identity);
}
public class Lime.Protocol.Node : Identity {
    [CompilerGeneratedAttribute]
private string <Instance>k__BackingField;
    public string Instance { get; public set; }
    public bool IsComplete { get; }
    public Node(string name, string domain, string instance);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Instance();
    [CompilerGeneratedAttribute]
public void set_Instance(string value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public static bool op_Equality(Node left, Node right);
    public static bool op_Inequality(Node left, Node right);
    public static Node op_Implicit(string value);
    public static string op_Implicit(Node node);
    public virtual int GetHashCode();
    public static Node Parse(string s);
    public static bool TryParse(string s, Node& value);
    public Identity ToIdentity();
    public bool get_IsComplete();
    public Node Copy();
    public Node ToImmutableNode();
}
[DataContractAttribute]
public class Lime.Protocol.NodeDocument : Document {
    public static string MIME_TYPE;
    public static MediaType MediaType;
    [CompilerGeneratedAttribute]
private Identity <Value>k__BackingField;
    public Identity Value { get; public set; }
    public NodeDocument(Node value);
    private static NodeDocument();
    [CompilerGeneratedAttribute]
public Identity get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(Identity value);
    public virtual string ToString();
    public static NodeDocument Parse(string value);
}
[DataContractAttribute]
public class Lime.Protocol.Notification : Envelope {
    public static string EVENT_KEY;
    public static string REASON_KEY;
    [CompilerGeneratedAttribute]
private Event <Event>k__BackingField;
    [CompilerGeneratedAttribute]
private Reason <Reason>k__BackingField;
    [DataMemberAttribute]
public Event Event { get; public set; }
    [DataMemberAttribute]
public Reason Reason { get; public set; }
    public Notification(string id);
    [CompilerGeneratedAttribute]
public Event get_Event();
    [CompilerGeneratedAttribute]
public void set_Event(Event value);
    [CompilerGeneratedAttribute]
public Reason get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(Reason value);
}
public class Lime.Protocol.PlainDocument : Document {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public PlainDocument(MediaType mediaType);
    public PlainDocument(string value, MediaType mediaType);
    [CompilerGeneratedAttribute]
public string get_Value();
    public virtual string ToString();
    public static string op_Implicit(PlainDocument plainDocument);
}
[DataContractAttribute]
public class Lime.Protocol.Reason : object {
    public static string CODE_KEY;
    public static string DESCRIPTION_KEY;
    [CompilerGeneratedAttribute]
private int <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [DataMemberAttribute]
public int Code { get; public set; }
    [DataMemberAttribute]
public string Description { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(int value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    public virtual string ToString();
}
public static class Lime.Protocol.ReasonCodes : object {
    public static int GENERAL_ERROR;
    public static int SESSION_ERROR;
    public static int SESSION_REGISTRATION_ERROR;
    public static int SESSION_AUTHENTICATION_FAILED;
    public static int SESSION_UNREGISTER_FAILED;
    public static int SESSION_INVALID_ACTION_FOR_STATE;
    public static int SESSION_NEGOTIATION_TIMEOUT;
    public static int SESSION_NEGOTIATION_INVALID_OPTIONS;
    public static int SESSION_INVALID_SESSION_MODE_REQUESTED;
    public static int VALIDATION_ERROR;
    public static int VALIDATION_EMPTY_DOCUMENT;
    public static int VALIDATION_INVALID_RESOURCE;
    public static int VALIDATION_INVALID_STATUS;
    public static int VALIDATION_INVALID_IDENTITY;
    public static int VALIDATION_INVALID_RECIPIENTS;
    public static int VALIDATION_INVALID_METHOD;
    public static int VALIDATION_INVALID_URI;
    public static int AUTHORIZATION_ERROR;
    public static int AUTHORIZATION_UNAUTHORIZED_SENDER;
    public static int AUTHORIZATION_DESTINATION_ACCOUNT_NOT_FOUND;
    public static int AUTHORIZATION_QUOTA_THRESHOLD_EXCEEDED;
    public static int AUTHORIZATION_PERMISSION_REQUIRED;
    public static int ROUTING_ERROR;
    public static int ROUTING_DESTINATION_NOT_FOUND;
    public static int ROUTING_GATEWAY_NOT_FOUND;
    public static int ROUTING_ROUTE_NOT_FOUND;
    public static int DISPATCH_ERROR;
    public static int COMMAND_PROCESSING_ERROR;
    public static int COMMAND_RESOURCE_NOT_SUPPORTED;
    public static int COMMAND_METHOD_NOT_SUPPORTED;
    public static int COMMAND_INVALID_ARGUMENT;
    public static int COMMAND_INVALID_SESSION_MODE;
    public static int COMMAND_NOT_ALLOWED;
    public static int COMMAND_RESOURCE_NOT_FOUND;
    public static int MESSAGE_PROCESSING_ERROR;
    public static int MESSAGE_UNSUPPORTED_CONTENT_TYPE;
    public static int GATEWAY_ERROR;
    public static int GATEWAY_CONTENT_TYPE_NOT_SUPPORTED;
    public static int GATEWAY_DESTINATION_NOT_FOUND;
    public static int GATEWAY_NOT_SUPPORTED;
    public static int GATEWAY_REQUEST_LIMIT_REACHED;
    public static int GATEWAY_OPERATION_TIMED_OUT;
    public static int GATEWAY_UNAUTHORIZED_SENDER;
    public static int APPLICATION_ERROR;
}
[DataContractAttribute]
public abstract class Lime.Protocol.Security.Authentication : object {
    private AuthenticationScheme _scheme;
    public Authentication(AuthenticationScheme scheme);
    public AuthenticationScheme GetAuthenticationScheme();
}
[DataContractAttribute]
public enum Lime.Protocol.Security.AuthenticationScheme : Enum {
    public int value__;
    [EnumMemberAttribute]
public static AuthenticationScheme Guest;
    [EnumMemberAttribute]
public static AuthenticationScheme Plain;
    [EnumMemberAttribute]
public static AuthenticationScheme Transport;
    [EnumMemberAttribute]
public static AuthenticationScheme Key;
    [EnumMemberAttribute]
public static AuthenticationScheme External;
}
public enum Lime.Protocol.Security.DomainRole : Enum {
    public int value__;
    public static DomainRole Unknown;
    public static DomainRole Member;
    public static DomainRole Authority;
    public static DomainRole RootAuthority;
}
[DataContractAttribute]
public class Lime.Protocol.Security.ExternalAuthentication : Authentication {
    public static string TOKEN_KEY;
    public static string ISSUER_KEY;
    [CompilerGeneratedAttribute]
private string <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Issuer>k__BackingField;
    [DataMemberAttribute]
public string Token { get; public set; }
    [DataMemberAttribute]
public string Issuer { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(string value);
    [CompilerGeneratedAttribute]
public string get_Issuer();
    [CompilerGeneratedAttribute]
public void set_Issuer(string value);
    public void SetToBase64Token(string password);
    public string GetFromBase64Token();
}
[DataContractAttribute]
public class Lime.Protocol.Security.GuestAuthentication : Authentication {
}
public interface Lime.Protocol.Security.IAuthenticatableTransport {
    public abstract virtual Task`1<DomainRole> AuthenticateAsync(Identity identity);
}
[DataContractAttribute]
public class Lime.Protocol.Security.KeyAuthentication : Authentication {
    public static string KEY_KEY;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [DataMemberAttribute]
public string Key { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    public void SetToBase64Key(string key);
    public string GetFromBase64Key();
}
[DataContractAttribute]
public class Lime.Protocol.Security.PlainAuthentication : Authentication {
    public static string PASSWORD_KEY;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [DataMemberAttribute]
public string Password { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    public void SetToBase64Password(string password);
    public string GetFromBase64Password();
}
[DataContractAttribute]
public class Lime.Protocol.Security.TransportAuthentication : Authentication {
    [CompilerGeneratedAttribute]
private Nullable`1<DomainRole> <DomainRole>k__BackingField;
    [IgnoreDataMemberAttribute]
public Nullable`1<DomainRole> DomainRole { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<DomainRole> get_DomainRole();
    [CompilerGeneratedAttribute]
public void set_DomainRole(Nullable`1<DomainRole> value);
}
[ExtensionAttribute]
public static class Lime.Protocol.Serialization.DictionaryExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Do not use this. Use the dictionary direct key access.")]
public static void RemoveAndAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
}
public class Lime.Protocol.Serialization.DocumentSerializer : object {
    private IDocumentTypeResolver _documentTypeResolver;
    private JsonSerializer _jsonSerializer;
    private JsonSerializerSettings _settings;
    public DocumentSerializer(IDocumentTypeResolver documentTypeResolver);
    public sealed virtual Document Deserialize(string value, MediaType mediaType);
    public sealed virtual string Serialize(Document document);
}
public class Lime.Protocol.Serialization.DocumentTypeResolver : object {
    private Dictionary`2<MediaType, Type> _documentMediaTypeDictionary;
    public sealed virtual void RegisterDocument(Type documentType);
    public sealed virtual bool TryGetTypeForMediaType(MediaType mediaType, Type& documentType);
}
[ExtensionAttribute]
public static class Lime.Protocol.Serialization.DocumentTypeResolverExtensions : object {
    [ExtensionAttribute]
public static void RegisterDocument(IDocumentTypeResolver typeResolver);
    [ExtensionAttribute]
public static void RegisterAssemblyDocuments(IDocumentTypeResolver typeResolver, Assembly assembly);
}
public interface Lime.Protocol.Serialization.IDocumentSerializer {
    public abstract virtual string Serialize(Document document);
    public abstract virtual Document Deserialize(string value, MediaType mediaType);
}
public interface Lime.Protocol.Serialization.IDocumentTypeResolver {
    public abstract virtual void RegisterDocument(Type documentType);
    public abstract virtual bool TryGetTypeForMediaType(MediaType mediaType, Type& documentType);
}
public interface Lime.Protocol.Serialization.IEnvelopeSerializer {
    public abstract virtual string Serialize(Envelope envelope);
    public abstract virtual Envelope Deserialize(string envelopeString);
    public abstract virtual T Deserialize(TextReader reader);
}
[ExtensionAttribute]
public static class Lime.Protocol.Serialization.JsonDocumentExtensions : object {
    [ExtensionAttribute]
public static string ToJson(JsonDocument document, JsonSerializerSettings settings);
}
public class Lime.Protocol.Serialization.Newtonsoft.Converters.AuthenticationJsonConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool get_CanWrite();
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class Lime.Protocol.Serialization.Newtonsoft.Converters.DocumentCollectionJsonConverter : JsonConverter {
    private IDocumentTypeResolver _documentTypeResolver;
    public DocumentCollectionJsonConverter(IDocumentTypeResolver documentTypeResolver);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class Lime.Protocol.Serialization.Newtonsoft.Converters.DocumentContainerJsonConverter : JsonConverter {
    private static Dictionary`2<Type, bool> CanConvertDictionary;
    private static object SyncRoot;
    private IDocumentTypeResolver _documentTypeResolver;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public DocumentContainerJsonConverter(IDocumentTypeResolver documentTypeResolver);
    private static DocumentContainerJsonConverter();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private static object CreateInstance(Type objectType);
}
public class Lime.Protocol.Serialization.Newtonsoft.Converters.DocumentJsonConverter : JsonConverter {
    private JsonSerializer _alternativeSerializer;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public DocumentJsonConverter(JsonSerializerSettings settings);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class Lime.Protocol.Serialization.Newtonsoft.Converters.IdentityJsonConverter : StringBasedTypeJsonConverter`1<Identity> {
    protected virtual Identity CreateInstance(string tokenValue);
}
[JsonObjectAttribute]
internal class Lime.Protocol.Serialization.Newtonsoft.Converters.JsonDocumentCollection : DocumentCollection {
    internal JsonDocumentCollection(DocumentCollection collection);
}
[ExtensionAttribute]
public static class Lime.Protocol.Serialization.Newtonsoft.Converters.JTokenExtensions : object {
    [ExtensionAttribute]
public static object GetTokenValue(JToken token);
    [ExtensionAttribute]
public static Document ToDocument(JToken jToken, MediaType mediaType, JsonSerializer serializer, IDocumentTypeResolver documentTypeResolver);
}
public class Lime.Protocol.Serialization.Newtonsoft.Converters.LimeUriJsonConverter : StringBasedTypeJsonConverter`1<LimeUri> {
    protected virtual LimeUri CreateInstance(string tokenValue);
}
public class Lime.Protocol.Serialization.Newtonsoft.Converters.MediaTypeJsonConverter : StringBasedTypeJsonConverter`1<MediaType> {
    protected virtual MediaType CreateInstance(string tokenValue);
}
public class Lime.Protocol.Serialization.Newtonsoft.Converters.NodeJsonConverter : StringBasedTypeJsonConverter`1<Node> {
    protected virtual Node CreateInstance(string tokenValue);
}
public class Lime.Protocol.Serialization.Newtonsoft.Converters.SessionJsonConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual bool get_CanWrite();
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public abstract class Lime.Protocol.Serialization.Newtonsoft.Converters.StringBasedTypeJsonConverter`1 : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    protected abstract virtual T CreateInstance(string tokenValue);
}
public class Lime.Protocol.Serialization.Newtonsoft.EnvelopeSerializer : object {
    private Lazy`1<JsonSerializer> _serializer;
    [CompilerGeneratedAttribute]
private JsonSerializerSettings <Settings>k__BackingField;
    public JsonSerializerSettings Settings { get; }
    public JsonSerializer Serializer { get; }
    public EnvelopeSerializer(IDocumentTypeResolver documentTypeResolver);
    [CompilerGeneratedAttribute]
public JsonSerializerSettings get_Settings();
    public JsonSerializer get_Serializer();
    public sealed virtual string Serialize(Envelope envelope);
    public sealed virtual Envelope Deserialize(string envelopeString);
    public sealed virtual T Deserialize(TextReader reader);
    public bool TryAddConverter(JsonConverter jsonConverter, bool ignoreDuplicates);
    internal static JsonSerializerSettings CreateSettings(IDocumentTypeResolver documentTypeResolver);
    private static int FindCatchAllConverterIndex(IList`1<JsonConverter> converters);
    [CompilerGeneratedAttribute]
private JsonSerializer <.ctor>b__1_0();
    [CompilerGeneratedAttribute]
internal static bool <FindCatchAllConverterIndex>g__catchAllPredicate|12_0(JsonConverter c);
}
public static class Lime.Protocol.Serialization.TypeUtil : object {
    private static ConcurrentDictionary`2<AuthenticationScheme, Type> _authenticationSchemeDictionary;
    private static ConcurrentDictionary`2<Type, IDictionary`2<string, object>> _enumTypeValueDictionary;
    private static HashSet`1<Type> _dataContractTypes;
    private static TypeUtil();
    public static bool TryGetTypeForAuthenticationScheme(AuthenticationScheme scheme, Type& type);
    public static TEnum ParseEnum(string enumName);
    public static object ParseEnum(Type enumType, string enumName);
    public static IEnumerable`1<Type> GetEnumTypes();
    public static bool IsDataContractType(Type type);
    public static T GetDefaultValue();
    public static object CreateInstance(Type type);
    private static void RegisterInternalTypes();
    private static void RegisterType(Type type);
}
public static class Lime.Protocol.Serialization.TypeUtilEx : object {
    private static ConcurrentDictionary`2<Type, Delegate> TypeParseDelegateDictionary;
    private static ConcurrentDictionary`2<Type, Delegate> FormattedTypeParseDelegateDictionary;
    private static ConcurrentDictionary`2<Type, Func`2<string, object>> TypeParseFuncDictionary;
    private static ConcurrentDictionary`2<Type, Func`3<string, IFormatProvider, object>> FormattedTypeParseFuncDictionary;
    private static Char[] ArraySeparator;
    private static TypeUtilEx();
    public static Func`2<string, T> GetParseFunc();
    public static Func`3<string, IFormatProvider, T> GetFormattedParseFunc();
    public static Func`2<string, object> GetParseFuncForType(Type type);
    public static Func`3<string, IFormatProvider, object> GetFormattedParseFuncForType(Type type);
    private static Func`2<string, object> ParseFuncAdapter(Func`2<string, T> parseFunc);
    private static Func`3<string, IFormatProvider, object> FormattedParseFuncAdapter(Func`3<string, IFormatProvider, T> parseFunc);
    public static bool TryParseString(string value, Type type, Object& result, IFormatProvider formatProvider, StringSplitOptions arraySplitOptions);
    public static Func`2<object, object> BuildGetAccessor(PropertyInfo propertyInfo);
    public static Func`2<object, object> BuildGetAccessor(MethodInfo methodInfo);
    public static Action`2<object, object> BuildSetAccessor(PropertyInfo propertyInfo);
    public static Action`2<object, object> BuildSetAccessor(MethodInfo methodInfo);
}
public class Lime.Protocol.Server.AggregateTransportListener : object {
    private IReadOnlyCollection`1<ITransportListener> _transportListeners;
    private Channel`1<ITransport> _transportChannel;
    private List`1<Task> _listenerTasks;
    private CancellationTokenSource _cts;
    private bool _listenerFaulted;
    [CompilerGeneratedAttribute]
private Uri[] <ListenerUris>k__BackingField;
    public Uri[] ListenerUris { get; }
    public AggregateTransportListener(IEnumerable`1<ITransportListener> transportListeners, int capacity);
    [AsyncStateMachineAttribute("Lime.Protocol.Server.AggregateTransportListener/<StartAsync>d__6")]
public sealed virtual Task StartAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Server.AggregateTransportListener/<StopAsync>d__7")]
public sealed virtual Task StopAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual Uri[] get_ListenerUris();
    public sealed virtual Task`1<ITransport> AcceptTransportAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Server.AggregateTransportListener/<ListenAsync>d__12")]
private Task ListenAsync(ITransportListener transportListener, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
public class Lime.Protocol.Server.AuthenticationResult : object {
    [CompilerGeneratedAttribute]
private DomainRole <DomainRole>k__BackingField;
    [CompilerGeneratedAttribute]
private Authentication <Roundtrip>k__BackingField;
    public DomainRole DomainRole { get; }
    public Authentication Roundtrip { get; }
    public AuthenticationResult(DomainRole domainRole, Authentication roundtrip);
    [CompilerGeneratedAttribute]
public DomainRole get_DomainRole();
    [CompilerGeneratedAttribute]
public Authentication get_Roundtrip();
}
public interface Lime.Protocol.Server.INodeRegistry {
    public abstract virtual Task`1<Node> TryRegisterAsync(Node node, IServerChannel channel, CancellationToken cancellationToken);
    public abstract virtual Task`1<IServerChannel> GetAsync(Node node, CancellationToken cancellationToken);
    public abstract virtual Task UnregisterAsync(Node node, CancellationToken cancellationToken);
}
public interface Lime.Protocol.Server.IServer {
}
public interface Lime.Protocol.Server.IServerChannel {
    public abstract virtual Task`1<Session> ReceiveNewSessionAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<Session> NegotiateSessionAsync(SessionCompression[] compressionOptions, SessionEncryption[] encryptionOptions, CancellationToken cancellationToken);
    public abstract virtual Task SendNegotiatingSessionAsync(SessionCompression sessionCompression, SessionEncryption sessionEncryption, CancellationToken cancellationToken);
    public abstract virtual Task`1<Session> AuthenticateSessionAsync(AuthenticationScheme[] schemeOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<Session> AuthenticateSessionAsync(Authentication authenticationRoundtrip, CancellationToken cancellationToken);
    public abstract virtual Task SendEstablishedSessionAsync(Node node, CancellationToken cancellationToken);
    public abstract virtual Task`1<Session> ReceiveFinishingSessionAsync(CancellationToken cancellationToken);
    public abstract virtual Task SendFinishedSessionAsync(CancellationToken cancellationToken);
    public abstract virtual Task SendFailedSessionAsync(Reason reason, CancellationToken cancellationToken);
}
public interface Lime.Protocol.Server.IStartable {
    public abstract virtual Task StartAsync(CancellationToken cancellationToken);
}
public interface Lime.Protocol.Server.IStoppable {
    public abstract virtual Task StopAsync(CancellationToken cancellationToken);
}
public interface Lime.Protocol.Server.ITransportListener {
    public Uri[] ListenerUris { get; }
    public abstract virtual Uri[] get_ListenerUris();
    public abstract virtual Task`1<ITransport> AcceptTransportAsync(CancellationToken cancellationToken);
}
public class Lime.Protocol.Server.NodeRegistry : object {
    private ConcurrentDictionary`2<Node, IServerChannel> _nodeChannelsDictionary;
    public sealed virtual Task`1<Node> TryRegisterAsync(Node node, IServerChannel channel, CancellationToken cancellationToken);
    public sealed virtual Task`1<IServerChannel> GetAsync(Node node, CancellationToken cancellationToken);
    public sealed virtual Task UnregisterAsync(Node node, CancellationToken cancellationToken);
}
public class Lime.Protocol.Server.Server : object {
    private ITransportListener _transportListener;
    private Func`2<ITransport, IServerChannel> _serverChannelFactory;
    private SessionCompression[] _enabledCompressionOptions;
    private SessionEncryption[] _enabledEncryptionOptions;
    private AuthenticationScheme[] _schemeOptions;
    private Func`4<Identity, Authentication, CancellationToken, Task`1<AuthenticationResult>> _authenticator;
    private Func`2<IChannelInformation, IChannelListener> _channelListenerFactory;
    private INodeRegistry _nodeRegistry;
    private Func`2<Exception, Task`1<bool>> _exceptionHandler;
    private int _maxActiveChannels;
    private SemaphoreSlim _semaphore;
    private CancellationTokenSource _listenerCts;
    private Task _listenerTask;
    private ITargetBlock`1<IServerChannel> _consumerBlock;
    public Server(ITransportListener transportListener, Func`2<ITransport, IServerChannel> serverChannelFactory, SessionCompression[] enabledCompressionOptions, SessionEncryption[] enabledEncryptionOptions, AuthenticationScheme[] schemeOptions, Func`4<Identity, Authentication, CancellationToken, Task`1<AuthenticationResult>> authenticator, Func`2<IChannelInformation, IChannelListener> channelListenerFactory, INodeRegistry nodeRegistry, Func`2<Exception, Task`1<bool>> exceptionHandler, int maxActiveChannels);
    [AsyncStateMachineAttribute("Lime.Protocol.Server.Server/<StartAsync>d__15")]
public sealed virtual Task StartAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Server.Server/<StopAsync>d__16")]
public sealed virtual Task StopAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Server.Server/<AcceptTransportsAsync>d__17")]
private Task AcceptTransportsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Server.Server/<ConsumeAsync>d__18")]
private Task ConsumeAsync(IServerChannel serverChannel);
    [AsyncStateMachineAttribute("Lime.Protocol.Server.Server/<ListenAsync>d__19")]
private Task ListenAsync(IServerChannel serverChannel);
    [CompilerGeneratedAttribute]
private Task <StartAsync>b__15_0();
}
public class Lime.Protocol.Server.ServerBuilder : object {
    [CompilerGeneratedAttribute]
private Node <ServerNode>k__BackingField;
    [CompilerGeneratedAttribute]
private ITransportListener <TransportListener>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ITransport, IServerChannel> <ServerChannelFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionCompression[] <EnabledCompressionOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionEncryption[] <EnabledEncryptionOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationScheme[] <SchemeOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`4<Identity, Authentication, CancellationToken, Task`1<AuthenticationResult>> <Authenticator>k__BackingField;
    [CompilerGeneratedAttribute]
private INodeRegistry <NodeRegistry>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<IChannelInformation, IChannelListener> <ChannelListenerFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Exception, Task`1<bool>> <ExceptionHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxActiveChannels>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EnvelopeBufferSize>k__BackingField;
    public Node ServerNode { get; }
    public ITransportListener TransportListener { get; }
    public Func`2<ITransport, IServerChannel> ServerChannelFactory { get; private set; }
    public SessionCompression[] EnabledCompressionOptions { get; private set; }
    public SessionEncryption[] EnabledEncryptionOptions { get; private set; }
    public AuthenticationScheme[] SchemeOptions { get; private set; }
    public Func`4<Identity, Authentication, CancellationToken, Task`1<AuthenticationResult>> Authenticator { get; private set; }
    public INodeRegistry NodeRegistry { get; private set; }
    public Func`2<IChannelInformation, IChannelListener> ChannelListenerFactory { get; private set; }
    public Func`2<Exception, Task`1<bool>> ExceptionHandler { get; private set; }
    public int MaxActiveChannels { get; private set; }
    public int EnvelopeBufferSize { get; private set; }
    public ServerBuilder(Node serverNode, ITransportListener transportListener);
    [CompilerGeneratedAttribute]
public Node get_ServerNode();
    [CompilerGeneratedAttribute]
public ITransportListener get_TransportListener();
    [CompilerGeneratedAttribute]
public Func`2<ITransport, IServerChannel> get_ServerChannelFactory();
    [CompilerGeneratedAttribute]
private void set_ServerChannelFactory(Func`2<ITransport, IServerChannel> value);
    [CompilerGeneratedAttribute]
public SessionCompression[] get_EnabledCompressionOptions();
    [CompilerGeneratedAttribute]
private void set_EnabledCompressionOptions(SessionCompression[] value);
    [CompilerGeneratedAttribute]
public SessionEncryption[] get_EnabledEncryptionOptions();
    [CompilerGeneratedAttribute]
private void set_EnabledEncryptionOptions(SessionEncryption[] value);
    [CompilerGeneratedAttribute]
public AuthenticationScheme[] get_SchemeOptions();
    [CompilerGeneratedAttribute]
private void set_SchemeOptions(AuthenticationScheme[] value);
    [CompilerGeneratedAttribute]
public Func`4<Identity, Authentication, CancellationToken, Task`1<AuthenticationResult>> get_Authenticator();
    [CompilerGeneratedAttribute]
private void set_Authenticator(Func`4<Identity, Authentication, CancellationToken, Task`1<AuthenticationResult>> value);
    [CompilerGeneratedAttribute]
public INodeRegistry get_NodeRegistry();
    [CompilerGeneratedAttribute]
private void set_NodeRegistry(INodeRegistry value);
    [CompilerGeneratedAttribute]
public Func`2<IChannelInformation, IChannelListener> get_ChannelListenerFactory();
    [CompilerGeneratedAttribute]
private void set_ChannelListenerFactory(Func`2<IChannelInformation, IChannelListener> value);
    [CompilerGeneratedAttribute]
public Func`2<Exception, Task`1<bool>> get_ExceptionHandler();
    [CompilerGeneratedAttribute]
private void set_ExceptionHandler(Func`2<Exception, Task`1<bool>> value);
    [CompilerGeneratedAttribute]
public int get_MaxActiveChannels();
    [CompilerGeneratedAttribute]
private void set_MaxActiveChannels(int value);
    [CompilerGeneratedAttribute]
public int get_EnvelopeBufferSize();
    [CompilerGeneratedAttribute]
private void set_EnvelopeBufferSize(int value);
    public ServerBuilder WithServerChannelFactory(Func`2<ITransport, IServerChannel> serverChannelFactory);
    public ServerBuilder WithEnabledCompressionOptions(SessionCompression[] enabledCompressionOptions);
    public ServerBuilder WithEnabledEncryptionOptions(SessionEncryption[] enabledEncryptionOptions);
    public ServerBuilder WithEnabledSchemeOptions(AuthenticationScheme[] schemeOptions);
    public ServerBuilder WithAuthenticator(Func`4<Identity, Authentication, CancellationToken, Task`1<AuthenticationResult>> authenticator);
    public ServerBuilder WithNodeRegistry(INodeRegistry nodeRegistry);
    public ServerBuilder WithChannelListenerFactory(Func`2<IChannelInformation, IChannelListener> channelListenerFactory);
    public ServerBuilder WithChannelConsumers(Func`2<Message, Task`1<bool>> messageConsumer, Func`2<Notification, Task`1<bool>> notificationConsumer, Func`2<Command, Task`1<bool>> commandConsumer);
    public ServerBuilder WithExceptionHandler(Func`2<Exception, Task`1<bool>> exceptionHandler);
    public ServerBuilder WithMaxActiveChannels(int maxActiveChannels);
    public ServerBuilder WithEnvelopeBufferSize(int envelopeBufferSize);
    public IServer Build();
    [CompilerGeneratedAttribute]
private IServerChannel <.ctor>b__0_1(ITransport transport);
}
public class Lime.Protocol.Server.ServerChannel : ChannelBase {
    public ServerChannel(string sessionId, Node localNode, ITransport transport, TimeSpan sendTimeout, int envelopeBufferSize, bool fillEnvelopeRecipients, bool autoReplyPings, Nullable`1<TimeSpan> remotePingInterval, Nullable`1<TimeSpan> remoteIdleTimeout, Nullable`1<TimeSpan> consumeTimeout, Nullable`1<TimeSpan> closeTimeout, IChannelCommandProcessor channelCommandProcessor);
    [AsyncStateMachineAttribute("Lime.Protocol.Server.ServerChannel/<ReceiveNewSessionAsync>d__1")]
public sealed virtual Task`1<Session> ReceiveNewSessionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Server.ServerChannel/<NegotiateSessionAsync>d__2")]
public sealed virtual Task`1<Session> NegotiateSessionAsync(SessionCompression[] compressionOptions, SessionEncryption[] encryptionOptions, CancellationToken cancellationToken);
    public sealed virtual Task SendNegotiatingSessionAsync(SessionCompression sessionCompression, SessionEncryption sessionEncryption, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Server.ServerChannel/<AuthenticateSessionAsync>d__4")]
public sealed virtual Task`1<Session> AuthenticateSessionAsync(AuthenticationScheme[] schemeOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Server.ServerChannel/<AuthenticateSessionAsync>d__5")]
public sealed virtual Task`1<Session> AuthenticateSessionAsync(Authentication authenticationRoundtrip, CancellationToken cancellationToken);
    public sealed virtual Task SendEstablishedSessionAsync(Node node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Server.ServerChannel/<ReceiveFinishingSessionAsync>d__7")]
public sealed virtual Task`1<Session> ReceiveFinishingSessionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Server.ServerChannel/<SendFinishedSessionAsync>d__8")]
public sealed virtual Task SendFinishedSessionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Server.ServerChannel/<SendFailedSessionAsync>d__9")]
public sealed virtual Task SendFailedSessionAsync(Reason reason, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Server.ServerChannel/<ReceiveSessionAsync>d__10")]
public virtual Task`1<Session> ReceiveSessionAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Session> <>n__0(CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class Lime.Protocol.Server.ServerChannelExtensions : object {
    [AsyncStateMachineAttribute("Lime.Protocol.Server.ServerChannelExtensions/<EstablishSessionAsync>d__0")]
[ExtensionAttribute]
public static Task EstablishSessionAsync(IServerChannel channel, SessionCompression[] enabledCompressionOptions, SessionEncryption[] enabledEncryptionOptions, AuthenticationScheme[] schemeOptions, Func`4<Identity, Authentication, CancellationToken, Task`1<AuthenticationResult>> authenticationFunc, Func`4<Node, IServerChannel, CancellationToken, Task`1<Node>> registrationFunc, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Server.ServerChannelExtensions/<NegotiateSessionAsync>d__1")]
private static Task NegotiateSessionAsync(IServerChannel channel, SessionCompression[] compressionOptions, SessionEncryption[] encryptionOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Server.ServerChannelExtensions/<AuthenticateSessionAsync>d__2")]
private static Task AuthenticateSessionAsync(IServerChannel channel, AuthenticationScheme[] schemeOptions, Func`4<Identity, Authentication, CancellationToken, Task`1<AuthenticationResult>> authenticationFunc, Func`4<Node, IServerChannel, CancellationToken, Task`1<Node>> registrationFunc, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.Server.ServerChannelExtensions/<AuthenticateAsTransportAsync>d__3")]
private static Task AuthenticateAsTransportAsync(IServerChannel channel, TransportAuthentication transportAuthentication, Identity identity);
}
[ExtensionAttribute]
public static class Lime.Protocol.Server.StartableExtensions : object {
    [ExtensionAttribute]
public static Task StartAsync(IStartable startable);
}
[ExtensionAttribute]
public static class Lime.Protocol.Server.StoppableExtensions : object {
    [ExtensionAttribute]
public static Task StopAsync(IStoppable stoppable);
}
public class Lime.Protocol.Server.TransportEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ITransport <Transport>k__BackingField;
    public ITransport Transport { get; private set; }
    public TransportEventArgs(ITransport transport);
    [CompilerGeneratedAttribute]
public ITransport get_Transport();
    [CompilerGeneratedAttribute]
private void set_Transport(ITransport value);
}
[DataContractAttribute]
public class Lime.Protocol.Session : Envelope {
    public static string STATE_KEY;
    public static string MODE_KEY;
    public static string ENCRYPTION_OPTIONS_KEY;
    public static string ENCRYPTION_KEY;
    public static string COMPRESSION_OPTIONS_KEY;
    public static string COMPRESSION_KEY;
    public static string SCHEME_OPTIONS_KEY;
    public static string SCHEME_KEY;
    public static string AUTHENTICATION_KEY;
    public static string REASON_KEY;
    [CompilerGeneratedAttribute]
private SessionState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionEncryption[] <EncryptionOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SessionEncryption> <Encryption>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionCompression[] <CompressionOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SessionCompression> <Compression>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationScheme[] <SchemeOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Authentication <Authentication>k__BackingField;
    [CompilerGeneratedAttribute]
private Reason <Reason>k__BackingField;
    [DataMemberAttribute]
public SessionState State { get; public set; }
    [DataMemberAttribute]
public SessionEncryption[] EncryptionOptions { get; public set; }
    [DataMemberAttribute]
public Nullable`1<SessionEncryption> Encryption { get; public set; }
    [DataMemberAttribute]
public SessionCompression[] CompressionOptions { get; public set; }
    [DataMemberAttribute]
public Nullable`1<SessionCompression> Compression { get; public set; }
    [DataMemberAttribute]
public AuthenticationScheme[] SchemeOptions { get; public set; }
    [DataMemberAttribute]
public Nullable`1<AuthenticationScheme> Scheme { get; }
    [DataMemberAttribute]
public Authentication Authentication { get; public set; }
    [DataMemberAttribute]
public Reason Reason { get; public set; }
    [CompilerGeneratedAttribute]
public SessionState get_State();
    [CompilerGeneratedAttribute]
public void set_State(SessionState value);
    [CompilerGeneratedAttribute]
public SessionEncryption[] get_EncryptionOptions();
    [CompilerGeneratedAttribute]
public void set_EncryptionOptions(SessionEncryption[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<SessionEncryption> get_Encryption();
    [CompilerGeneratedAttribute]
public void set_Encryption(Nullable`1<SessionEncryption> value);
    [CompilerGeneratedAttribute]
public SessionCompression[] get_CompressionOptions();
    [CompilerGeneratedAttribute]
public void set_CompressionOptions(SessionCompression[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<SessionCompression> get_Compression();
    [CompilerGeneratedAttribute]
public void set_Compression(Nullable`1<SessionCompression> value);
    [CompilerGeneratedAttribute]
public AuthenticationScheme[] get_SchemeOptions();
    [CompilerGeneratedAttribute]
public void set_SchemeOptions(AuthenticationScheme[] value);
    public Nullable`1<AuthenticationScheme> get_Scheme();
    [CompilerGeneratedAttribute]
public Authentication get_Authentication();
    [CompilerGeneratedAttribute]
public void set_Authentication(Authentication value);
    [CompilerGeneratedAttribute]
public Reason get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(Reason value);
}
[DataContractAttribute]
public enum Lime.Protocol.SessionCompression : Enum {
    public int value__;
    [EnumMemberAttribute]
public static SessionCompression None;
    [EnumMemberAttribute]
public static SessionCompression GZip;
}
[DataContractAttribute]
public enum Lime.Protocol.SessionEncryption : Enum {
    public int value__;
    [EnumMemberAttribute]
public static SessionEncryption None;
    [EnumMemberAttribute]
public static SessionEncryption TLS;
}
[DataContractAttribute]
public enum Lime.Protocol.SessionState : Enum {
    public int value__;
    [EnumMemberAttribute]
public static SessionState New;
    [EnumMemberAttribute]
public static SessionState Negotiating;
    [EnumMemberAttribute]
public static SessionState Authenticating;
    [EnumMemberAttribute]
public static SessionState Established;
    [EnumMemberAttribute]
public static SessionState Finishing;
    [EnumMemberAttribute]
public static SessionState Finished;
    [EnumMemberAttribute]
public static SessionState Failed;
}
[ExtensionAttribute]
public static class Lime.Protocol.StringExtensions : object {
    private static string INDENT_STRING;
    private static int LowerCaseOffset;
    [ExtensionAttribute]
public static string RemoveCrLf(string value);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> ie, Action`1<T> action);
    [ExtensionAttribute]
public static string IndentJson(string jsonString);
    [ExtensionAttribute]
public static string ToCamelCase(string value);
    [ExtensionAttribute]
public static string ToTitleCase(string value);
    [ExtensionAttribute]
public static string ToBase64(string value);
    [ExtensionAttribute]
public static string FromBase64(string value);
    [ExtensionAttribute]
public static string Escape(string value);
    [ExtensionAttribute]
public static bool IsNullOrWhiteSpace(string value);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(string value);
    [ExtensionAttribute]
public static string TrimFirstDomainLabel(string domain);
}
[ExtensionAttribute]
public static class Lime.Protocol.Tracing.ActivityExtensions : object {
    [ExtensionAttribute]
public static void CopyTraceParent(IDictionary`2<string, string> from, IDictionary`2<string, string> to);
    [ExtensionAttribute]
public static void CopyTraceParent(Envelope from, Envelope to);
    [ExtensionAttribute]
public static bool ContainsW3CTraceContext(IDictionary`2<string, string> dictionary);
    [ExtensionAttribute]
public static bool ContainsW3CTraceContext(Envelope envelope);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Activity StartActivity(IDictionary`2<string, string> dictionary, string name, ActivityKind kind, ActivitySource activitySource, bool prioritizeDictionaryActivity);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Activity StartActivity(Envelope envelope, string name, ActivityKind kind, ActivitySource activitySource, bool prioritizeEnvelopeActivity);
    [ExtensionAttribute]
public static void InjectTraceParent(Activity activity, IDictionary`2<string, string> dictionary);
    [ExtensionAttribute]
public static void InjectTraceParent(Activity activity, Envelope envelope);
    [ExtensionAttribute]
public static void InjectTraceParentIfAbsent(Activity activity, Envelope envelope);
    [ExtensionAttribute]
public static void SetEnvelopeTags(Activity activity, Envelope envelope);
    [ExtensionAttribute]
public static void SetNotificationTags(Activity activity, Notification notification);
    [ExtensionAttribute]
public static void SetCommandTags(Activity activity, Command command);
    [ExtensionAttribute]
public static void SetSessionTags(Activity activity, Session session);
    [ExtensionAttribute]
public static void SetMessageTags(Activity activity, Message message);
    [ExtensionAttribute]
public static void SetCommandStatusTag(Activity activity, Command command);
    [ExtensionAttribute]
public static void SetNotificationStatusTag(Activity activity, Notification notification);
    [ExtensionAttribute]
public static void SetSessionStatusTag(Activity activity, Session session);
    [ExtensionAttribute]
public static string GetActivityName(Envelope envelope);
    [ExtensionAttribute]
public static void SetTransportTags(Activity activity, ITransport transport);
    [ExtensionAttribute]
public static void SetNodeTags(Activity activity, Node node);
    [ExtensionAttribute]
public static void AddChannelTags(Activity activity, IChannel channel);
}
public static class Lime.Protocol.Tracing.LimeActivitySource : object {
    public static string LimeProtocol;
    public static ActivitySource Instance;
    private static LimeActivitySource();
}
public static class Lime.Protocol.Tracing.TraceContext : object {
    public static string TraceParent;
    public static string TraceState;
}
[ExtensionAttribute]
public static class Lime.Protocol.TypeExtensions : object {
    [ExtensionAttribute]
public static EnvelopeType GetEnvelopeType(Type type);
    [ExtensionAttribute]
public static object GetDefaultValue(Type type);
}
public class Lime.Protocol.Util.AsyncCountdownEvent : object {
    private TaskCompletionSource`1<object> _tcs;
    private int _count;
    public int Id { get; }
    public int CurrentCount { get; }
    public AsyncCountdownEvent(int count);
    public int get_Id();
    public int get_CurrentCount();
    [AsyncStateMachineAttribute("Lime.Protocol.Util.AsyncCountdownEvent/<WaitAsync>d__7")]
public Task WaitAsync(CancellationToken cancellationToken);
    private bool ModifyCount(int signalCount);
    public bool TryAddCount(int signalCount);
    public bool TryAddCount();
    public bool TrySignal(int signalCount);
    public bool TrySignal();
    public void AddCount(int signalCount);
    public void AddCount();
    public void Signal(int signalCount);
    public void Signal();
    [CompilerGeneratedAttribute]
private void <WaitAsync>b__7_0();
}
public static class Lime.Protocol.Util.ChannelUtil : object {
    public static Channel`1<T> CreateForCapacity(int capacity, bool singleReader, bool singleWriter, bool allowSynchronousContinuations, BoundedChannelFullMode fullMode);
}
public class Lime.Protocol.Util.DeferralManager : object {
    private AsyncCountdownEvent _count;
    public IDisposable GetDeferral();
    public Task SignalAndWaitAsync(CancellationToken cancellationToken);
}
public static class Lime.Protocol.Util.ProducerConsumer : object {
    public static Task`1<T> CreateAsync(Func`2<CancellationToken, Task`1<T>> producer, Func`3<T, CancellationToken, Task`1<bool>> consumer, CancellationToken cancellationToken, bool handleCancellation);
}
[ExtensionAttribute]
public static class Lime.Protocol.Util.ProducerExtensions : object {
    [ExtensionAttribute]
public static Task`1<T> Consume(Func`2<CancellationToken, Task`1<T>> producer, Func`3<T, CancellationToken, Task`1<bool>> consumer, CancellationToken cancellationToken);
}
public class Lime.Protocol.Util.RateGate : object {
    private SemaphoreSlim _semaphore;
    private ConcurrentQueue`1<int> _exitTimes;
    private Timer _exitTimer;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private int <Occurrences>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeUnitMilliseconds>k__BackingField;
    public int Occurrences { get; }
    public int TimeUnitMilliseconds { get; }
    public RateGate(int occurrences, TimeSpan timeUnit);
    [CompilerGeneratedAttribute]
public int get_Occurrences();
    [CompilerGeneratedAttribute]
public int get_TimeUnitMilliseconds();
    protected virtual override void Finalize();
    private void ExitTimerCallback(object state);
    [AsyncStateMachineAttribute("Lime.Protocol.Util.RateGate/<WaitToProceedAsync>d__13")]
public Task WaitToProceedAsync(CancellationToken cancellationToken);
    public Task WaitToProceedAsync();
    private void CheckDisposed();
    public sealed virtual void Dispose();
    private void Dispose(bool isDisposing);
}
public static class Lime.Protocol.Util.TaskUtil : object {
    public static Task CompletedTask;
    public static Task`1<bool> TrueCompletedTask;
    public static Task`1<bool> FalseCompletedTask;
    private static TaskUtil();
}
[ExtensionAttribute]
public static class Lime.Protocol.UtilExtensions : object {
    public static string PING_URI_TEMPLATE;
    [ExtensionAttribute]
public static bool IsPingRequest(Command command);
    [ExtensionAttribute]
public static Uri GetResourceUri(Command command);
    [ExtensionAttribute]
public static void DisposeIfDisposable(T source);
    [ExtensionAttribute]
public static void RaiseEvent(EventHandler event, object sender, EventArgs e);
    [ExtensionAttribute]
[ObsoleteAttribute("Use null propagation instead (handler?.Invoke)")]
public static void RaiseEvent(EventHandler`1<T> event, object sender, T e);
    [AsyncStateMachineAttribute("Lime.Protocol.UtilExtensions/<WithCancellation>d__6`1")]
[ExtensionAttribute]
public static Task`1<T> WithCancellation(Task`1<T> task, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Lime.Protocol.UtilExtensions/<WithCancellation>d__7")]
[ExtensionAttribute]
public static Task WithCancellation(Task task, CancellationToken cancellationToken);
    [ExtensionAttribute]
[ObsoleteAttribute("This method should be avoided since uses a CancellationTokenSource which needs to be disposed")]
public static CancellationToken ToCancellationToken(TimeSpan delay);
    [ExtensionAttribute]
public static Identity GetIdentity(X509Certificate2 certificate);
    [ExtensionAttribute]
public static Identity GetIdentity(Uri uri);
    [ExtensionAttribute]
public static string ToCommaSepparate(IEnumerable`1<string> values);
    [ExtensionAttribute]
public static Byte[] ToSHA1Hash(string inputString);
    [ExtensionAttribute]
public static string ToSHA1HashString(string inputString);
    [ExtensionAttribute]
public static Task`1<T> AsCompletedTask(T value);
    [ExtensionAttribute]
public static Reason ToReason(Exception exception);
    [AsyncStateMachineAttribute("Lime.Protocol.UtilExtensions/<AsTask>d__16")]
[ExtensionAttribute]
public static Task AsTask(CancellationToken cancellationToken);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
