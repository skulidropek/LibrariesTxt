internal class LiteDB.AesEncryption : object {
    private Aes _aes;
    public AesEncryption(string password, Byte[] salt);
    public Byte[] Encrypt(Byte[] bytes);
    public Byte[] Decrypt(Byte[] encryptedValue, int offset, int count);
    public static Byte[] HashSHA1(string password);
    public static Byte[] Salt(int maxLength);
    public sealed virtual void Dispose();
}
internal class LiteDB.AsyncManualResetEvent : object {
    private TaskCompletionSource`1 modreq(System.Runtime.CompilerServices.IsVolatile) _tcs;
    public Task WaitAsync();
    public void Set();
    public void Reset();
}
[DefaultMemberAttribute("Item")]
public class LiteDB.BsonArray : BsonValue {
    private int _length;
    public IList`1<BsonValue> RawValue { get; }
    public BsonValue Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public BsonArray(List`1<BsonValue> array);
    public BsonArray(BsonValue[] array);
    public BsonArray(IEnumerable`1<BsonValue> items);
    public IList`1<BsonValue> get_RawValue();
    public virtual BsonValue get_Item(int index);
    public virtual void set_Item(int index, BsonValue value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(BsonValue item);
    public void AddRange(TCollection collection);
    public void AddRange(IEnumerable`1<BsonValue> items);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(BsonValue item);
    public sealed virtual void CopyTo(BsonValue[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<BsonValue> GetEnumerator();
    public sealed virtual int IndexOf(BsonValue item);
    public sealed virtual void Insert(int index, BsonValue item);
    public sealed virtual bool Remove(BsonValue item);
    public sealed virtual void RemoveAt(int index);
    [IteratorStateMachineAttribute("LiteDB.BsonArray/<System-Collections-IEnumerable-GetEnumerator>d__24")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual int CompareTo(BsonValue other);
    internal virtual int GetBytesCount(bool recalc);
}
public enum LiteDB.BsonAutoId : Enum {
    public int value__;
    public static BsonAutoId Int32;
    public static BsonAutoId Int64;
    public static BsonAutoId ObjectId;
    public static BsonAutoId Guid;
}
public class LiteDB.BsonCtorAttribute : Attribute {
}
[DefaultMemberAttribute("Item")]
public class LiteDB.BsonDataReader : object {
    private IEnumerator`1<BsonValue> _source;
    private EngineState _state;
    private string _collection;
    private bool _hasValues;
    private BsonValue _current;
    private bool _isFirst;
    private bool _disposed;
    public bool HasValues { get; }
    public BsonValue Current { get; }
    public string Collection { get; }
    public BsonValue Item { get; }
    internal BsonDataReader(BsonValue value, string collection);
    internal BsonDataReader(IEnumerable`1<BsonValue> values, string collection, EngineState state);
    public sealed virtual bool get_HasValues();
    public sealed virtual BsonValue get_Current();
    public sealed virtual string get_Collection();
    public sealed virtual bool Read();
    public sealed virtual BsonValue get_Item(string field);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
}
[ExtensionAttribute]
public static class LiteDB.BsonDataReaderExtensions : object {
    [IteratorStateMachineAttribute("LiteDB.BsonDataReaderExtensions/<ToEnumerable>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<BsonValue> ToEnumerable(IBsonDataReader reader);
    [ExtensionAttribute]
public static BsonValue[] ToArray(IBsonDataReader reader);
    [ExtensionAttribute]
public static IList`1<BsonValue> ToList(IBsonDataReader reader);
    [ExtensionAttribute]
public static BsonValue First(IBsonDataReader reader);
    [ExtensionAttribute]
public static BsonValue FirstOrDefault(IBsonDataReader reader);
    [ExtensionAttribute]
public static BsonValue Single(IBsonDataReader reader);
    [ExtensionAttribute]
public static BsonValue SingleOrDefault(IBsonDataReader reader);
}
[DefaultMemberAttribute("Item")]
public class LiteDB.BsonDocument : BsonValue {
    [CompilerGeneratedAttribute]
private PageAddress <RawId>k__BackingField;
    private int _length;
    public IDictionary`2<string, BsonValue> RawValue { get; }
    internal PageAddress RawId { get; internal set; }
    public BsonValue Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<BsonValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public BsonDocument(ConcurrentDictionary`2<string, BsonValue> dict);
    public BsonDocument(IDictionary`2<string, BsonValue> dict);
    public IDictionary`2<string, BsonValue> get_RawValue();
    [CompilerGeneratedAttribute]
internal PageAddress get_RawId();
    [CompilerGeneratedAttribute]
internal void set_RawId(PageAddress value);
    public virtual BsonValue get_Item(string key);
    public virtual void set_Item(string key, BsonValue value);
    public virtual int CompareTo(BsonValue other);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<BsonValue> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool ContainsKey(string key);
    [IteratorStateMachineAttribute("LiteDB.BsonDocument/<GetElements>d__22")]
public IEnumerable`1<KeyValuePair`2<string, BsonValue>> GetElements();
    public sealed virtual void Add(string key, BsonValue value);
    public sealed virtual bool Remove(string key);
    public sealed virtual void Clear();
    public sealed virtual bool TryGetValue(string key, BsonValue& value);
    public sealed virtual void Add(KeyValuePair`2<string, BsonValue> item);
    public sealed virtual bool Contains(KeyValuePair`2<string, BsonValue> item);
    public sealed virtual bool Remove(KeyValuePair`2<string, BsonValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, BsonValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public void CopyTo(BsonDocument other);
    internal virtual int GetBytesCount(bool recalc);
}
public class LiteDB.BsonExpression : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonExpressionType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsImmutable>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonDocument <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonExpression <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonExpression <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSource>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Fields>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsScalar>k__BackingField;
    private BsonExpressionEnumerableDelegate _funcEnumerable;
    private BsonExpressionScalarDelegate _funcScalar;
    private static ConcurrentDictionary`2<string, BsonExpressionEnumerableDelegate> _cacheEnumerable;
    private static ConcurrentDictionary`2<string, BsonExpressionScalarDelegate> _cacheScalar;
    public static BsonExpression Root;
    private static Dictionary`2<string, MethodInfo> _methods;
    private static Dictionary`2<string, MethodInfo> _functions;
    public string Source { get; internal set; }
    public BsonExpressionType Type { get; internal set; }
    public bool IsImmutable { get; internal set; }
    public BsonDocument Parameters { get; internal set; }
    internal BsonExpression Left { get; internal set; }
    internal BsonExpression Right { get; internal set; }
    internal bool UseSource { get; internal set; }
    internal Expression Expression { get; internal set; }
    public HashSet`1<string> Fields { get; internal set; }
    public bool IsScalar { get; internal set; }
    internal bool IsPredicate { get; }
    internal bool IsIndexable { get; }
    internal bool IsValue { get; }
    internal bool IsANY { get; }
    public static IEnumerable`1<MethodInfo> Methods { get; }
    public static IEnumerable`1<MethodInfo> Functions { get; }
    private static BsonExpression();
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
internal void set_Source(string value);
    [CompilerGeneratedAttribute]
public BsonExpressionType get_Type();
    [CompilerGeneratedAttribute]
internal void set_Type(BsonExpressionType value);
    [CompilerGeneratedAttribute]
public bool get_IsImmutable();
    [CompilerGeneratedAttribute]
internal void set_IsImmutable(bool value);
    [CompilerGeneratedAttribute]
public BsonDocument get_Parameters();
    [CompilerGeneratedAttribute]
internal void set_Parameters(BsonDocument value);
    [CompilerGeneratedAttribute]
internal BsonExpression get_Left();
    [CompilerGeneratedAttribute]
internal void set_Left(BsonExpression value);
    [CompilerGeneratedAttribute]
internal BsonExpression get_Right();
    [CompilerGeneratedAttribute]
internal void set_Right(BsonExpression value);
    [CompilerGeneratedAttribute]
internal bool get_UseSource();
    [CompilerGeneratedAttribute]
internal void set_UseSource(bool value);
    [CompilerGeneratedAttribute]
internal Expression get_Expression();
    [CompilerGeneratedAttribute]
internal void set_Expression(Expression value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_Fields();
    [CompilerGeneratedAttribute]
internal void set_Fields(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_IsScalar();
    [CompilerGeneratedAttribute]
internal void set_IsScalar(bool value);
    internal bool get_IsPredicate();
    internal bool get_IsIndexable();
    internal bool get_IsValue();
    internal bool get_IsANY();
    internal string DefaultFieldName();
    public static string op_Implicit(BsonExpression expr);
    public static BsonExpression op_Implicit(string expr);
    public IEnumerable`1<BsonValue> Execute(Collation collation);
    public IEnumerable`1<BsonValue> Execute(BsonDocument root, Collation collation);
    public IEnumerable`1<BsonValue> Execute(IEnumerable`1<BsonDocument> source, Collation collation);
    [IteratorStateMachineAttribute("LiteDB.BsonExpression/<Execute>d__57")]
internal IEnumerable`1<BsonValue> Execute(IEnumerable`1<BsonDocument> source, BsonDocument root, BsonValue current, Collation collation);
    internal IEnumerable`1<BsonValue> GetIndexKeys(BsonDocument doc, Collation collation);
    public BsonValue ExecuteScalar(Collation collation);
    public BsonValue ExecuteScalar(BsonDocument root, Collation collation);
    public BsonValue ExecuteScalar(IEnumerable`1<BsonDocument> source, Collation collation);
    internal BsonValue ExecuteScalar(IEnumerable`1<BsonDocument> source, BsonDocument root, BsonValue current, Collation collation);
    public static BsonExpression Create(string expression);
    public static BsonExpression Create(string expression, BsonValue[] args);
    public static BsonExpression Create(string expression, BsonDocument parameters);
    internal static BsonExpression Create(Tokenizer tokenizer, BsonExpressionParserMode mode, BsonDocument parameters);
    internal static BsonExpression ParseAndCompile(Tokenizer tokenizer, BsonExpressionParserMode mode, BsonDocument parameters, DocumentScope scope);
    internal static void Compile(BsonExpression expr, ExpressionContext context);
    internal static void SetParameters(BsonExpression expr, BsonDocument parameters);
    public static IEnumerable`1<MethodInfo> get_Methods();
    internal static MethodInfo GetMethod(string name, int parameterCount);
    public static IEnumerable`1<MethodInfo> get_Functions();
    internal static MethodInfo GetFunction(string name, int parameterCount);
    public virtual string ToString();
}
internal class LiteDB.BsonExpressionEnumerableDelegate : MulticastDelegate {
    public BsonExpressionEnumerableDelegate(object object, IntPtr method);
    public virtual IEnumerable`1<BsonValue> Invoke(IEnumerable`1<BsonDocument> source, BsonDocument root, BsonValue current, Collation collation, BsonDocument parameters);
    public virtual IAsyncResult BeginInvoke(IEnumerable`1<BsonDocument> source, BsonDocument root, BsonValue current, Collation collation, BsonDocument parameters, AsyncCallback callback, object object);
    public virtual IEnumerable`1<BsonValue> EndInvoke(IAsyncResult result);
}
internal class LiteDB.BsonExpressionFunctions : object {
    [IteratorStateMachineAttribute("LiteDB.BsonExpressionFunctions/<MAP>d__0")]
public static IEnumerable`1<BsonValue> MAP(BsonDocument root, Collation collation, BsonDocument parameters, IEnumerable`1<BsonValue> input, BsonExpression mapExpr);
    [IteratorStateMachineAttribute("LiteDB.BsonExpressionFunctions/<FILTER>d__1")]
public static IEnumerable`1<BsonValue> FILTER(BsonDocument root, Collation collation, BsonDocument parameters, IEnumerable`1<BsonValue> input, BsonExpression filterExpr);
    public static IEnumerable`1<BsonValue> SORT(BsonDocument root, Collation collation, BsonDocument parameters, IEnumerable`1<BsonValue> input, BsonExpression sortExpr, BsonValue order);
    public static IEnumerable`1<BsonValue> SORT(BsonDocument root, Collation collation, BsonDocument parameters, IEnumerable`1<BsonValue> input, BsonExpression sortExpr);
}
internal class LiteDB.BsonExpressionMethods : object {
    private static Random _random;
    private static BsonExpressionMethods();
    public static BsonValue COUNT(IEnumerable`1<BsonValue> values);
    public static BsonValue MIN(IEnumerable`1<BsonValue> values);
    public static BsonValue MAX(IEnumerable`1<BsonValue> values);
    public static BsonValue FIRST(IEnumerable`1<BsonValue> values);
    public static BsonValue LAST(IEnumerable`1<BsonValue> values);
    public static BsonValue AVG(IEnumerable`1<BsonValue> values);
    public static BsonValue SUM(IEnumerable`1<BsonValue> values);
    public static BsonValue ANY(IEnumerable`1<BsonValue> values);
    public static BsonValue MINVALUE();
    [VolatileAttribute]
public static BsonValue OBJECTID();
    [VolatileAttribute]
public static BsonValue GUID();
    [VolatileAttribute]
public static BsonValue NOW();
    [VolatileAttribute]
public static BsonValue NOW_UTC();
    [VolatileAttribute]
public static BsonValue TODAY();
    public static BsonValue MAXVALUE();
    public static BsonValue INT32(BsonValue value);
    public static BsonValue INT64(BsonValue value);
    public static BsonValue DOUBLE(Collation collation, BsonValue value);
    public static BsonValue DOUBLE(BsonValue value, BsonValue culture);
    public static BsonValue DECIMAL(Collation collation, BsonValue value);
    public static BsonValue DECIMAL(BsonValue value, BsonValue culture);
    public static BsonValue STRING(BsonValue value);
    public static BsonValue ARRAY(IEnumerable`1<BsonValue> values);
    public static BsonValue BINARY(BsonValue value);
    public static BsonValue OBJECTID(BsonValue value);
    public static BsonValue GUID(BsonValue value);
    public static BsonValue BOOLEAN(BsonValue value);
    public static BsonValue DATETIME(Collation collation, BsonValue value);
    public static BsonValue DATETIME(BsonValue value, BsonValue culture);
    public static BsonValue DATETIME_UTC(Collation collation, BsonValue value);
    public static BsonValue DATETIME_UTC(BsonValue value, BsonValue culture);
    public static BsonValue DATETIME(BsonValue year, BsonValue month, BsonValue day);
    public static BsonValue DATETIME_UTC(BsonValue year, BsonValue month, BsonValue day);
    public static BsonValue IS_MINVALUE(BsonValue value);
    public static BsonValue IS_NULL(BsonValue value);
    public static BsonValue IS_INT32(BsonValue value);
    public static BsonValue IS_INT64(BsonValue value);
    public static BsonValue IS_DOUBLE(BsonValue value);
    public static BsonValue IS_DECIMAL(BsonValue value);
    public static BsonValue IS_NUMBER(BsonValue value);
    public static BsonValue IS_STRING(BsonValue value);
    public static BsonValue IS_DOCUMENT(BsonValue value);
    public static BsonValue IS_ARRAY(BsonValue value);
    public static BsonValue IS_BINARY(BsonValue value);
    public static BsonValue IS_OBJECTID(BsonValue value);
    public static BsonValue IS_GUID(BsonValue value);
    public static BsonValue IS_BOOLEAN(BsonValue value);
    public static BsonValue IS_DATETIME(BsonValue value);
    public static BsonValue IS_MAXVALUE(BsonValue value);
    public static BsonValue INT(BsonValue value);
    public static BsonValue LONG(BsonValue value);
    public static BsonValue BOOL(BsonValue value);
    public static BsonValue DATE(Collation collation, BsonValue value);
    public static BsonValue DATE(BsonValue values, BsonValue culture);
    public static BsonValue DATE_UTC(Collation collation, BsonValue value);
    public static BsonValue DATE_UTC(BsonValue values, BsonValue culture);
    public static BsonValue DATE(BsonValue year, BsonValue month, BsonValue day);
    public static BsonValue DATE_UTC(BsonValue year, BsonValue month, BsonValue day);
    public static BsonValue IS_INT(BsonValue value);
    public static BsonValue IS_LONG(BsonValue value);
    public static BsonValue IS_BOOL(BsonValue value);
    public static BsonValue IS_DATE(BsonValue value);
    public static BsonValue YEAR(BsonValue value);
    public static BsonValue MONTH(BsonValue value);
    public static BsonValue DAY(BsonValue value);
    public static BsonValue HOUR(BsonValue value);
    public static BsonValue MINUTE(BsonValue value);
    public static BsonValue SECOND(BsonValue value);
    public static BsonValue DATEADD(BsonValue dateInterval, BsonValue number, BsonValue value);
    public static BsonValue DATEDIFF(BsonValue dateInterval, BsonValue starts, BsonValue ends);
    public static BsonValue TO_LOCAL(BsonValue date);
    public static BsonValue TO_UTC(BsonValue date);
    public static BsonValue ABS(BsonValue value);
    public static BsonValue ROUND(BsonValue value, BsonValue digits);
    public static BsonValue POW(BsonValue x, BsonValue y);
    public static BsonValue JSON(BsonValue json);
    public static BsonValue EXTEND(BsonValue source, BsonValue extend);
    [IteratorStateMachineAttribute("LiteDB.BsonExpressionMethods/<ITEMS>d__77")]
public static IEnumerable`1<BsonValue> ITEMS(BsonValue array);
    public static IEnumerable`1<BsonValue> CONCAT(IEnumerable`1<BsonValue> first, IEnumerable`1<BsonValue> second);
    [IteratorStateMachineAttribute("LiteDB.BsonExpressionMethods/<KEYS>d__79")]
public static IEnumerable`1<BsonValue> KEYS(BsonValue document);
    [IteratorStateMachineAttribute("LiteDB.BsonExpressionMethods/<VALUES>d__80")]
public static IEnumerable`1<BsonValue> VALUES(BsonValue document);
    public static BsonValue OID_CREATIONTIME(BsonValue objectId);
    public static BsonValue IIF(BsonValue test, BsonValue ifTrue, BsonValue ifFalse);
    public static BsonValue COALESCE(BsonValue left, BsonValue right);
    public static BsonValue LENGTH(BsonValue value);
    public static IEnumerable`1<BsonValue> TOP(IEnumerable`1<BsonValue> values, BsonValue num);
    public static IEnumerable`1<BsonValue> UNION(IEnumerable`1<BsonValue> left, IEnumerable`1<BsonValue> right);
    public static IEnumerable`1<BsonValue> EXCEPT(IEnumerable`1<BsonValue> left, IEnumerable`1<BsonValue> right);
    public static IEnumerable`1<BsonValue> DISTINCT(IEnumerable`1<BsonValue> items);
    [VolatileAttribute]
public static BsonValue RANDOM();
    [VolatileAttribute]
public static BsonValue RANDOM(BsonValue min, BsonValue max);
    public static BsonValue LOWER(BsonValue value);
    public static BsonValue UPPER(BsonValue value);
    public static BsonValue LTRIM(BsonValue value);
    public static BsonValue RTRIM(BsonValue value);
    public static BsonValue TRIM(BsonValue value);
    public static BsonValue INDEXOF(BsonValue value, BsonValue search);
    public static BsonValue INDEXOF(BsonValue value, BsonValue search, BsonValue startIndex);
    public static BsonValue SUBSTRING(BsonValue value, BsonValue startIndex);
    public static BsonValue SUBSTRING(BsonValue value, BsonValue startIndex, BsonValue length);
    public static BsonValue REPLACE(BsonValue value, BsonValue oldValue, BsonValue newValue);
    public static BsonValue LPAD(BsonValue value, BsonValue totalWidth, BsonValue paddingChar);
    public static BsonValue RPAD(BsonValue value, BsonValue totalWidth, BsonValue paddingChar);
    [IteratorStateMachineAttribute("LiteDB.BsonExpressionMethods/<SPLIT>d__104")]
public static IEnumerable`1<BsonValue> SPLIT(BsonValue value, BsonValue separator);
    [IteratorStateMachineAttribute("LiteDB.BsonExpressionMethods/<SPLIT>d__105")]
public static IEnumerable`1<BsonValue> SPLIT(BsonValue value, BsonValue pattern, BsonValue useRegex);
    public static BsonValue FORMAT(BsonValue value, BsonValue format);
    public static BsonValue JOIN(IEnumerable`1<BsonValue> values);
    public static BsonValue JOIN(IEnumerable`1<BsonValue> values, BsonValue separator);
    public static BsonValue IS_MATCH(BsonValue value, BsonValue pattern);
    public static BsonValue MATCH(BsonValue value, BsonValue pattern, BsonValue group);
}
internal class LiteDB.BsonExpressionOperators : object {
    public static BsonValue ADD(BsonValue left, BsonValue right);
    public static BsonValue MINUS(BsonValue left, BsonValue right);
    public static BsonValue MULTIPLY(BsonValue left, BsonValue right);
    public static BsonValue DIVIDE(BsonValue left, BsonValue right);
    public static BsonValue MOD(BsonValue left, BsonValue right);
    public static BsonValue EQ(Collation collation, BsonValue left, BsonValue right);
    public static BsonValue EQ_ALL(Collation collation, IEnumerable`1<BsonValue> left, BsonValue right);
    public static BsonValue EQ_ANY(Collation collation, IEnumerable`1<BsonValue> left, BsonValue right);
    public static BsonValue GT(BsonValue left, BsonValue right);
    public static BsonValue GT_ANY(Collation collation, IEnumerable`1<BsonValue> left, BsonValue right);
    public static BsonValue GT_ALL(Collation collation, IEnumerable`1<BsonValue> left, BsonValue right);
    public static BsonValue GTE(BsonValue left, BsonValue right);
    public static BsonValue GTE_ANY(Collation collation, IEnumerable`1<BsonValue> left, BsonValue right);
    public static BsonValue GTE_ALL(Collation collation, IEnumerable`1<BsonValue> left, BsonValue right);
    public static BsonValue LT(BsonValue left, BsonValue right);
    public static BsonValue LT_ANY(Collation collation, IEnumerable`1<BsonValue> left, BsonValue right);
    public static BsonValue LT_ALL(Collation collation, IEnumerable`1<BsonValue> left, BsonValue right);
    public static BsonValue LTE(Collation collation, BsonValue left, BsonValue right);
    public static BsonValue LTE_ANY(Collation collation, IEnumerable`1<BsonValue> left, BsonValue right);
    public static BsonValue LTE_ALL(Collation collation, IEnumerable`1<BsonValue> left, BsonValue right);
    public static BsonValue NEQ(Collation collation, BsonValue left, BsonValue right);
    public static BsonValue NEQ_ANY(Collation collation, IEnumerable`1<BsonValue> left, BsonValue right);
    public static BsonValue NEQ_ALL(Collation collation, IEnumerable`1<BsonValue> left, BsonValue right);
    public static BsonValue LIKE(Collation collation, BsonValue left, BsonValue right);
    public static BsonValue LIKE_ANY(Collation collation, IEnumerable`1<BsonValue> left, BsonValue right);
    public static BsonValue LIKE_ALL(Collation collation, IEnumerable`1<BsonValue> left, BsonValue right);
    public static BsonValue BETWEEN(Collation collation, BsonValue left, BsonValue right);
    public static BsonValue BETWEEN_ANY(Collation collation, IEnumerable`1<BsonValue> left, BsonValue right);
    public static BsonValue BETWEEN_ALL(Collation collation, IEnumerable`1<BsonValue> left, BsonValue right);
    public static BsonValue IN(Collation collation, BsonValue left, BsonValue right);
    public static BsonValue IN_ANY(Collation collation, IEnumerable`1<BsonValue> left, BsonValue right);
    public static BsonValue IN_ALL(Collation collation, IEnumerable`1<BsonValue> left, BsonValue right);
    public static BsonValue PARAMETER_PATH(BsonDocument doc, string name);
    public static BsonValue MEMBER_PATH(BsonValue value, string name);
    public static BsonValue ARRAY_INDEX(BsonValue value, int index, BsonExpression expr, BsonDocument root, Collation collation, BsonDocument parameters);
    [IteratorStateMachineAttribute("LiteDB.BsonExpressionOperators/<ARRAY_FILTER>d__35")]
public static IEnumerable`1<BsonValue> ARRAY_FILTER(BsonValue value, int index, BsonExpression filterExpr, BsonDocument root, Collation collation, BsonDocument parameters);
    public static BsonValue DOCUMENT_INIT(String[] keys, BsonValue[] values);
    public static BsonValue ARRAY_INIT(BsonValue[] values);
}
internal class LiteDB.BsonExpressionParser : object {
    private static Dictionary`2<string, Tuple`3<string, MethodInfo, BsonExpressionType>> _operators;
    private static MethodInfo _parameterPathMethod;
    private static MethodInfo _memberPathMethod;
    private static MethodInfo _arrayIndexMethod;
    private static MethodInfo _arrayFilterMethod;
    private static MethodInfo _documentInitMethod;
    private static MethodInfo _arrayInitMethod;
    private static MethodInfo _itemsMethod;
    private static MethodInfo _arrayMethod;
    private static BsonExpressionParser();
    private static MethodInfo M(string s);
    public static BsonExpression ParseFullExpression(Tokenizer tokenizer, ExpressionContext context, BsonDocument parameters, DocumentScope scope);
    public static BsonExpression ParseSingleExpression(Tokenizer tokenizer, ExpressionContext context, BsonDocument parameters, DocumentScope scope);
    public static BsonExpression ParseSelectDocumentBuilder(Tokenizer tokenizer, ExpressionContext context, BsonDocument parameters);
    public static BsonExpression ParseUpdateDocumentBuilder(Tokenizer tokenizer, ExpressionContext context, BsonDocument parameters);
    private static BsonExpression TryParseDouble(Tokenizer tokenizer, BsonDocument parameters);
    private static BsonExpression TryParseInt(Tokenizer tokenizer, BsonDocument parameters);
    private static BsonExpression TryParseBool(Tokenizer tokenizer, BsonDocument parameters);
    private static BsonExpression TryParseNull(Tokenizer tokenizer, BsonDocument parameters);
    private static BsonExpression TryParseString(Tokenizer tokenizer, BsonDocument parameters);
    private static BsonExpression TryParseDocument(Tokenizer tokenizer, ExpressionContext context, BsonDocument parameters, DocumentScope scope);
    private static BsonExpression TryParseSource(Tokenizer tokenizer, ExpressionContext context, BsonDocument parameters, DocumentScope scope);
    private static BsonExpression TryParseArray(Tokenizer tokenizer, ExpressionContext context, BsonDocument parameters, DocumentScope scope);
    private static BsonExpression TryParseParameter(Tokenizer tokenizer, ExpressionContext context, BsonDocument parameters, DocumentScope scope);
    private static BsonExpression TryParseInnerExpression(Tokenizer tokenizer, ExpressionContext context, BsonDocument parameters, DocumentScope scope);
    private static BsonExpression TryParseMethodCall(Tokenizer tokenizer, ExpressionContext context, BsonDocument parameters, DocumentScope scope);
    private static BsonExpression TryParsePath(Tokenizer tokenizer, ExpressionContext context, BsonDocument parameters, DocumentScope scope);
    private static Expression ParsePath(Tokenizer tokenizer, Expression expr, ExpressionContext context, BsonDocument parameters, HashSet`1<string> fields, Boolean& isImmutable, Boolean& useSource, Boolean& isScalar, StringBuilder src);
    private static BsonExpression TryParseFunction(Tokenizer tokenizer, ExpressionContext context, BsonDocument parameters, DocumentScope scope);
    private static BsonExpression ParseFunction(string functionName, BsonExpressionType type, Tokenizer tokenizer, ExpressionContext context, BsonDocument parameters, DocumentScope scope);
    private static BsonExpression NewArray(BsonExpression item0, BsonExpression item1);
    private static string ReadField(Tokenizer tokenizer, StringBuilder source);
    public static string ReadKey(Tokenizer tokenizer, StringBuilder source);
    private static string ReadOperant(Tokenizer tokenizer);
    private static BsonExpression ConvertToEnumerable(BsonExpression expr);
    private static BsonExpression ConvertToArray(BsonExpression expr);
    internal static BsonExpression CreateLogicExpression(BsonExpressionType type, BsonExpression left, BsonExpression right);
    internal static BsonExpression CreateConditionalExpression(BsonExpression test, BsonExpression ifTrue, BsonExpression ifFalse);
    [CompilerGeneratedAttribute]
internal static bool <ParseSelectDocumentBuilder>g__stop|12_0(Token t);
    [CompilerGeneratedAttribute]
internal static void <ParseSelectDocumentBuilder>g__Add|12_1(string alias, BsonExpression expr, <>c__DisplayClass12_0& );
}
internal enum LiteDB.BsonExpressionParserMode : Enum {
    public int value__;
    public static BsonExpressionParserMode Full;
    public static BsonExpressionParserMode Single;
    public static BsonExpressionParserMode SelectDocument;
    public static BsonExpressionParserMode UpdateDocument;
}
internal class LiteDB.BsonExpressionScalarDelegate : MulticastDelegate {
    public BsonExpressionScalarDelegate(object object, IntPtr method);
    public virtual BsonValue Invoke(IEnumerable`1<BsonDocument> source, BsonDocument root, BsonValue current, Collation collation, BsonDocument parameters);
    public virtual IAsyncResult BeginInvoke(IEnumerable`1<BsonDocument> source, BsonDocument root, BsonValue current, Collation collation, BsonDocument parameters, AsyncCallback callback, object object);
    public virtual BsonValue EndInvoke(IAsyncResult result);
}
public enum LiteDB.BsonExpressionType : Enum {
    public byte value__;
    public static BsonExpressionType Double;
    public static BsonExpressionType Int;
    public static BsonExpressionType String;
    public static BsonExpressionType Boolean;
    public static BsonExpressionType Null;
    public static BsonExpressionType Array;
    public static BsonExpressionType Document;
    public static BsonExpressionType Parameter;
    public static BsonExpressionType Call;
    public static BsonExpressionType Path;
    public static BsonExpressionType Modulo;
    public static BsonExpressionType Add;
    public static BsonExpressionType Subtract;
    public static BsonExpressionType Multiply;
    public static BsonExpressionType Divide;
    public static BsonExpressionType Equal;
    public static BsonExpressionType Like;
    public static BsonExpressionType Between;
    public static BsonExpressionType GreaterThan;
    public static BsonExpressionType GreaterThanOrEqual;
    public static BsonExpressionType LessThan;
    public static BsonExpressionType LessThanOrEqual;
    public static BsonExpressionType NotEqual;
    public static BsonExpressionType In;
    public static BsonExpressionType Or;
    public static BsonExpressionType And;
    public static BsonExpressionType Map;
    public static BsonExpressionType Filter;
    public static BsonExpressionType Sort;
    public static BsonExpressionType Source;
}
public class LiteDB.BsonFieldAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    public BsonFieldAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
public class LiteDB.BsonIdAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <AutoId>k__BackingField;
    public bool AutoId { get; private set; }
    public BsonIdAttribute(bool autoId);
    [CompilerGeneratedAttribute]
public bool get_AutoId();
    [CompilerGeneratedAttribute]
private void set_AutoId(bool value);
}
public class LiteDB.BsonIgnoreAttribute : Attribute {
}
public class LiteDB.BsonMapper : object {
    private Dictionary`2<Type, EntityMapper> _entities;
    private ConcurrentDictionary`2<Type, Func`2<object, BsonValue>> _customSerializer;
    private ConcurrentDictionary`2<Type, Func`2<BsonValue, object>> _customDeserializer;
    private Func`2<Type, object> _typeInstantiator;
    private ITypeNameBinder _typeNameBinder;
    public static BsonMapper Global;
    public Func`2<string, string> ResolveFieldName;
    [CompilerGeneratedAttribute]
private bool <SerializeNullValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TrimWhitespace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmptyStringToNull>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnumAsInteger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeFields>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeNonPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDepth>k__BackingField;
    public Action`3<Type, MemberInfo, MemberMapper> ResolveMember;
    public Func`2<Type, string> ResolveCollectionName;
    private Regex _lowerCaseDelimiter;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DeserializationCallback <OnDeserialization>k__BackingField;
    private HashSet`1<Type> _bsonTypes;
    private HashSet`1<Type> _basicTypes;
    public bool SerializeNullValues { get; public set; }
    public bool TrimWhitespace { get; public set; }
    public bool EmptyStringToNull { get; public set; }
    public bool EnumAsInteger { get; public set; }
    public bool IncludeFields { get; public set; }
    public bool IncludeNonPublic { get; public set; }
    public int MaxDepth { get; public set; }
    [NullableAttribute("2")]
public DeserializationCallback OnDeserialization { get; public set; }
    public BsonMapper(Func`2<Type, object> customTypeInstantiator, ITypeNameBinder typeNameBinder);
    private static BsonMapper();
    [CompilerGeneratedAttribute]
public bool get_SerializeNullValues();
    [CompilerGeneratedAttribute]
public void set_SerializeNullValues(bool value);
    [CompilerGeneratedAttribute]
public bool get_TrimWhitespace();
    [CompilerGeneratedAttribute]
public void set_TrimWhitespace(bool value);
    [CompilerGeneratedAttribute]
public bool get_EmptyStringToNull();
    [CompilerGeneratedAttribute]
public void set_EmptyStringToNull(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnumAsInteger();
    [CompilerGeneratedAttribute]
public void set_EnumAsInteger(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeFields();
    [CompilerGeneratedAttribute]
public void set_IncludeFields(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeNonPublic();
    [CompilerGeneratedAttribute]
public void set_IncludeNonPublic(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxDepth();
    [CompilerGeneratedAttribute]
public void set_MaxDepth(int value);
    public void RegisterType(Func`2<T, BsonValue> serialize, Func`2<BsonValue, T> deserialize);
    public void RegisterType(Type type, Func`2<object, BsonValue> serialize, Func`2<BsonValue, object> deserialize);
    public EntityBuilder`1<T> Entity();
    public BsonExpression GetExpression(Expression`1<Func`2<T, K>> predicate);
    public BsonExpression GetIndexExpression(Expression`1<Func`2<T, K>> predicate);
    public BsonMapper UseCamelCase();
    public BsonMapper UseLowerCaseDelimiter(char delimiter);
    internal EntityMapper GetEntityMapper(Type type);
    protected virtual EntityMapper BuildAddEntityMapper(Type type);
    protected virtual MemberInfo GetIdMember(IEnumerable`1<MemberInfo> members);
    protected virtual IEnumerable`1<MemberInfo> GetTypeMembers(Type type);
    protected virtual CreateObject GetTypeCtor(EntityMapper mapper);
    internal static void RegisterDbRef(BsonMapper mapper, MemberMapper member, ITypeNameBinder typeNameBinder, string collection);
    private static void RegisterDbRefItem(BsonMapper mapper, MemberMapper member, ITypeNameBinder typeNameBinder, string collection);
    private static void RegisterDbRefList(BsonMapper mapper, MemberMapper member, ITypeNameBinder typeNameBinder, string collection);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public DeserializationCallback get_OnDeserialization();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_OnDeserialization(DeserializationCallback value);
    public virtual object ToObject(Type type, BsonDocument doc);
    public virtual T ToObject(BsonDocument doc);
    public T Deserialize(BsonValue value);
    public object Deserialize(Type type, BsonValue value);
    private object DeserializeArray(Type type, BsonArray array);
    private object DeserializeList(Type type, BsonArray value);
    private void DeserializeDictionary(Type K, Type T, IDictionary dict, BsonDocument value);
    private void DeserializeObject(EntityMapper entity, object obj, BsonDocument value);
    private object DeserializeAnonymousType(Type type, BsonDocument value);
    public virtual BsonDocument ToDocument(Type type, object entity);
    public virtual BsonDocument ToDocument(T entity);
    public BsonValue Serialize(T obj);
    public BsonValue Serialize(Type type, object obj);
    internal BsonValue Serialize(Type type, object obj, int depth);
    private BsonArray SerializeArray(Type type, IEnumerable array, int depth);
    private BsonDocument SerializeDictionary(Type type, IDictionary dict, int depth);
    private BsonDocument SerializeObject(Type type, object obj, int depth);
}
internal class LiteDB.BsonReader : object {
    private bool _utcDate;
    public BsonReader(bool utcDate);
    public BsonDocument Deserialize(Byte[] bson);
    public BsonDocument ReadDocument(ByteReader reader);
    public BsonArray ReadArray(ByteReader reader);
    private BsonValue ReadElement(ByteReader reader, String& name);
}
public class LiteDB.BsonRefAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Collection>k__BackingField;
    public string Collection { get; public set; }
    public BsonRefAttribute(string collection);
    [CompilerGeneratedAttribute]
public string get_Collection();
    [CompilerGeneratedAttribute]
public void set_Collection(string value);
}
public class LiteDB.BsonSerializer : object {
    public static Byte[] Serialize(BsonDocument doc);
    public static BsonDocument Deserialize(Byte[] buffer, bool utcDate, HashSet`1<string> fields);
}
public enum LiteDB.BsonType : Enum {
    public byte value__;
    public static BsonType MinValue;
    public static BsonType Null;
    public static BsonType Int32;
    public static BsonType Int64;
    public static BsonType Double;
    public static BsonType Decimal;
    public static BsonType String;
    public static BsonType Document;
    public static BsonType Array;
    public static BsonType Binary;
    public static BsonType ObjectId;
    public static BsonType Guid;
    public static BsonType Boolean;
    public static BsonType DateTime;
    public static BsonType MaxValue;
}
[DefaultMemberAttribute("Item")]
public class LiteDB.BsonValue : object {
    public static DateTime UnixEpoch;
    public static BsonValue Null;
    public static BsonValue MinValue;
    public static BsonValue MaxValue;
    [CompilerGeneratedAttribute]
private BsonType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <RawValue>k__BackingField;
    public BsonType Type { get; }
    public object RawValue { get; }
    public BsonValue Item { get; public set; }
    public BsonValue Item { get; public set; }
    [DebuggerBrowsableAttribute("0")]
public BsonArray AsArray { get; }
    [DebuggerBrowsableAttribute("0")]
public BsonDocument AsDocument { get; }
    [DebuggerBrowsableAttribute("0")]
public Byte[] AsBinary { get; }
    [DebuggerBrowsableAttribute("0")]
public bool AsBoolean { get; }
    [DebuggerBrowsableAttribute("0")]
public string AsString { get; }
    [DebuggerBrowsableAttribute("0")]
public int AsInt32 { get; }
    [DebuggerBrowsableAttribute("0")]
public long AsInt64 { get; }
    [DebuggerBrowsableAttribute("0")]
public double AsDouble { get; }
    [DebuggerBrowsableAttribute("0")]
public decimal AsDecimal { get; }
    [DebuggerBrowsableAttribute("0")]
public DateTime AsDateTime { get; }
    [DebuggerBrowsableAttribute("0")]
public ObjectId AsObjectId { get; }
    [DebuggerBrowsableAttribute("0")]
public Guid AsGuid { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsNull { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsArray { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsDocument { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsInt32 { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsInt64 { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsDouble { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsDecimal { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsNumber { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsBinary { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsBoolean { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsString { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsObjectId { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsGuid { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsDateTime { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsMinValue { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsMaxValue { get; }
    public BsonValue(int value);
    public BsonValue(long value);
    public BsonValue(double value);
    public BsonValue(decimal value);
    public BsonValue(string value);
    public BsonValue(Byte[] value);
    public BsonValue(ObjectId value);
    public BsonValue(Guid value);
    public BsonValue(bool value);
    public BsonValue(DateTime value);
    protected BsonValue(BsonType type, object rawValue);
    public BsonValue(object value);
    private static BsonValue();
    public static BsonDocument DbRef(BsonValue id, string collection);
    [CompilerGeneratedAttribute]
public BsonType get_Type();
    [CompilerGeneratedAttribute]
public virtual object get_RawValue();
    public virtual BsonValue get_Item(string name);
    public virtual void set_Item(string name, BsonValue value);
    public virtual BsonValue get_Item(int index);
    public virtual void set_Item(int index, BsonValue value);
    public BsonArray get_AsArray();
    public BsonDocument get_AsDocument();
    public Byte[] get_AsBinary();
    public bool get_AsBoolean();
    public string get_AsString();
    public int get_AsInt32();
    public long get_AsInt64();
    public double get_AsDouble();
    public decimal get_AsDecimal();
    public DateTime get_AsDateTime();
    public ObjectId get_AsObjectId();
    public Guid get_AsGuid();
    public bool get_IsNull();
    public bool get_IsArray();
    public bool get_IsDocument();
    public bool get_IsInt32();
    public bool get_IsInt64();
    public bool get_IsDouble();
    public bool get_IsDecimal();
    public bool get_IsNumber();
    public bool get_IsBinary();
    public bool get_IsBoolean();
    public bool get_IsString();
    public bool get_IsObjectId();
    public bool get_IsGuid();
    public bool get_IsDateTime();
    public bool get_IsMinValue();
    public bool get_IsMaxValue();
    public static int op_Implicit(BsonValue value);
    public static BsonValue op_Implicit(int value);
    public static long op_Implicit(BsonValue value);
    public static BsonValue op_Implicit(long value);
    public static double op_Implicit(BsonValue value);
    public static BsonValue op_Implicit(double value);
    public static decimal op_Implicit(BsonValue value);
    public static BsonValue op_Implicit(decimal value);
    public static ulong op_Implicit(BsonValue value);
    public static BsonValue op_Implicit(ulong value);
    public static string op_Implicit(BsonValue value);
    public static BsonValue op_Implicit(string value);
    public static Byte[] op_Implicit(BsonValue value);
    public static BsonValue op_Implicit(Byte[] value);
    public static ObjectId op_Implicit(BsonValue value);
    public static BsonValue op_Implicit(ObjectId value);
    public static Guid op_Implicit(BsonValue value);
    public static BsonValue op_Implicit(Guid value);
    public static bool op_Implicit(BsonValue value);
    public static BsonValue op_Implicit(bool value);
    public static DateTime op_Implicit(BsonValue value);
    public static BsonValue op_Implicit(DateTime value);
    public static BsonValue op_Addition(BsonValue left, BsonValue right);
    public static BsonValue op_Subtraction(BsonValue left, BsonValue right);
    public static BsonValue op_Multiply(BsonValue left, BsonValue right);
    public static BsonValue op_Division(BsonValue left, BsonValue right);
    public virtual string ToString();
    public virtual int CompareTo(BsonValue other);
    public virtual int CompareTo(BsonValue other, Collation collation);
    public sealed virtual bool Equals(BsonValue other);
    public static bool op_Equality(BsonValue lhs, BsonValue rhs);
    public static bool op_Inequality(BsonValue lhs, BsonValue rhs);
    public static bool op_GreaterThanOrEqual(BsonValue lhs, BsonValue rhs);
    public static bool op_GreaterThan(BsonValue lhs, BsonValue rhs);
    public static bool op_LessThan(BsonValue lhs, BsonValue rhs);
    public static bool op_LessThanOrEqual(BsonValue lhs, BsonValue rhs);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual int GetBytesCount(bool recalc);
    protected int GetBytesCountElement(string key, BsonValue value);
}
internal class LiteDB.BsonValueResolver : object {
    public sealed virtual string ResolveMethod(MethodInfo method);
    public sealed virtual string ResolveMember(MemberInfo member);
    public sealed virtual string ResolveCtor(ConstructorInfo ctor);
}
internal static class LiteDB.BucketHelper : object {
    public static int BucketCount;
    private static Int32[] _bucketSize;
    private static BucketHelper();
    internal static int GetBucketIndex(int bufferSize);
    internal static int GetMaxSizeForBucket(int binIndex);
}
[ExtensionAttribute]
internal static class LiteDB.BufferExtensions : object {
    [ExtensionAttribute]
public static int BinaryCompareTo(Byte[] lh, Byte[] rh);
    [ExtensionAttribute]
public static bool IsFullZero(Byte[] data);
    [ExtensionAttribute]
public static Byte[] Fill(Byte[] array, byte value, int offset, int count);
    [ExtensionAttribute]
public static string ReadCString(Byte[] bytes, int startIndex, Int32& bytesCount);
    [ExtensionAttribute]
public static void ToBytes(short value, Byte[] array, int startIndex);
    [ExtensionAttribute]
public static void ToBytes(int value, Byte[] array, int startIndex);
    [ExtensionAttribute]
public static void ToBytes(long value, Byte[] array, int startIndex);
    [ExtensionAttribute]
public static void ToBytes(ushort value, Byte[] array, int startIndex);
    [ExtensionAttribute]
public static void ToBytes(UInt32 value, Byte[] array, int startIndex);
    [ExtensionAttribute]
public static void ToBytes(ulong value, Byte[] array, int startIndex);
    [ExtensionAttribute]
public static void ToBytes(float value, Byte[] array, int startIndex);
    [ExtensionAttribute]
public static void ToBytes(double value, Byte[] array, int startIndex);
}
[DefaultMemberAttribute("Item")]
internal class LiteDB.BufferSlice : object {
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Array>k__BackingField;
    public int Offset { get; }
    public int Count { get; }
    public Byte[] Array { get; }
    public byte Item { get; public set; }
    public BufferSlice(Byte[] array, int offset, int count);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public Byte[] get_Array();
    public byte get_Item(int index);
    public void set_Item(int index, byte value);
    public void Clear();
    public void Clear(int offset, int count);
    public void Fill(byte value);
    public bool All(byte value);
    public string ToHex();
    public BufferSlice Slice(int offset, int count);
    public Byte[] ToArray();
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class LiteDB.BufferSliceExtensions : object {
    [ExtensionAttribute]
public static bool ReadBool(BufferSlice buffer, int offset);
    [ExtensionAttribute]
public static byte ReadByte(BufferSlice buffer, int offset);
    [ExtensionAttribute]
public static short ReadInt16(BufferSlice buffer, int offset);
    [ExtensionAttribute]
public static ushort ReadUInt16(BufferSlice buffer, int offset);
    [ExtensionAttribute]
public static int ReadInt32(BufferSlice buffer, int offset);
    [ExtensionAttribute]
public static UInt32 ReadUInt32(BufferSlice buffer, int offset);
    [ExtensionAttribute]
public static long ReadInt64(BufferSlice buffer, int offset);
    [ExtensionAttribute]
public static double ReadDouble(BufferSlice buffer, int offset);
    [ExtensionAttribute]
public static decimal ReadDecimal(BufferSlice buffer, int offset);
    [ExtensionAttribute]
public static ObjectId ReadObjectId(BufferSlice buffer, int offset);
    [ExtensionAttribute]
public static Guid ReadGuid(BufferSlice buffer, int offset);
    [ExtensionAttribute]
public static Byte[] ReadBytes(BufferSlice buffer, int offset, int count);
    [ExtensionAttribute]
public static DateTime ReadDateTime(BufferSlice buffer, int offset);
    [ExtensionAttribute]
public static PageAddress ReadPageAddress(BufferSlice buffer, int offset);
    [ExtensionAttribute]
public static string ReadString(BufferSlice buffer, int offset, int count);
    [ExtensionAttribute]
public static string ReadCString(BufferSlice buffer, int offset, Int32& length);
    [ExtensionAttribute]
public static BsonValue ReadIndexKey(BufferSlice buffer, int offset);
    [ExtensionAttribute]
public static void Write(BufferSlice buffer, bool value, int offset);
    [ExtensionAttribute]
public static void Write(BufferSlice buffer, byte value, int offset);
    [ExtensionAttribute]
public static void Write(BufferSlice buffer, short value, int offset);
    [ExtensionAttribute]
public static void Write(BufferSlice buffer, ushort value, int offset);
    [ExtensionAttribute]
public static void Write(BufferSlice buffer, int value, int offset);
    [ExtensionAttribute]
public static void Write(BufferSlice buffer, UInt32 value, int offset);
    [ExtensionAttribute]
public static void Write(BufferSlice buffer, long value, int offset);
    [ExtensionAttribute]
public static void Write(BufferSlice buffer, double value, int offset);
    [ExtensionAttribute]
public static void Write(BufferSlice buffer, decimal value, int offset);
    [ExtensionAttribute]
public static void Write(BufferSlice buffer, DateTime value, int offset);
    [ExtensionAttribute]
public static void Write(BufferSlice buffer, PageAddress value, int offset);
    [ExtensionAttribute]
public static void Write(BufferSlice buffer, Guid value, int offset);
    [ExtensionAttribute]
public static void Write(BufferSlice buffer, ObjectId value, int offset);
    [ExtensionAttribute]
public static void Write(BufferSlice buffer, Byte[] value, int offset);
    [ExtensionAttribute]
public static void Write(BufferSlice buffer, string value, int offset);
    [ExtensionAttribute]
public static void WriteIndexKey(BufferSlice buffer, BsonValue value, int offset);
}
internal class LiteDB.ByteReader : object {
    private Byte[] _buffer;
    private int _length;
    private int _pos;
    public int Position { get; public set; }
    public ByteReader(Byte[] buffer);
    public int get_Position();
    public void set_Position(int value);
    public void Skip(int length);
    public byte ReadByte();
    public bool ReadBoolean();
    public ushort ReadUInt16();
    public UInt32 ReadUInt32();
    public ulong ReadUInt64();
    public short ReadInt16();
    public int ReadInt32();
    public long ReadInt64();
    public float ReadSingle();
    public double ReadDouble();
    public decimal ReadDecimal();
    public Byte[] ReadBytes(int count);
    public string ReadString();
    public string ReadString(int length);
    public string ReadBsonString();
    public string ReadCString();
    public DateTime ReadDateTime();
    public Guid ReadGuid();
    public ObjectId ReadObjectId();
    public BsonValue ReadBsonValue(ushort length);
}
public class LiteDB.Collation : object {
    private CompareInfo _compareInfo;
    public static Collation Default;
    public static Collation Binary;
    [CompilerGeneratedAttribute]
private int <LCID>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private CompareOptions <SortOptions>k__BackingField;
    public int LCID { get; }
    public CultureInfo Culture { get; }
    public CompareOptions SortOptions { get; }
    public Collation(string collation);
    public Collation(int lcid, CompareOptions sortOptions);
    private static Collation();
    [CompilerGeneratedAttribute]
public int get_LCID();
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public CompareOptions get_SortOptions();
    public sealed virtual int Compare(string left, string right);
    public sealed virtual int Compare(BsonValue left, BsonValue rigth);
    public sealed virtual bool Equals(BsonValue x, BsonValue y);
    public sealed virtual int GetHashCode(BsonValue obj);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class LiteDB.ConnectionString : object {
    private Dictionary`2<string, string> _values;
    [CompilerGeneratedAttribute]
private ConnectionType <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Filename>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private long <InitialSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Upgrade>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoRebuild>k__BackingField;
    [CompilerGeneratedAttribute]
private Collation <Collation>k__BackingField;
    public ConnectionType Connection { get; public set; }
    public string Filename { get; public set; }
    public string Password { get; public set; }
    public long InitialSize { get; public set; }
    public bool ReadOnly { get; public set; }
    public bool Upgrade { get; public set; }
    public bool AutoRebuild { get; public set; }
    public Collation Collation { get; public set; }
    public string Item { get; }
    public ConnectionString(string connectionString);
    [CompilerGeneratedAttribute]
public ConnectionType get_Connection();
    [CompilerGeneratedAttribute]
public void set_Connection(ConnectionType value);
    [CompilerGeneratedAttribute]
public string get_Filename();
    [CompilerGeneratedAttribute]
public void set_Filename(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public long get_InitialSize();
    [CompilerGeneratedAttribute]
public void set_InitialSize(long value);
    [CompilerGeneratedAttribute]
public bool get_ReadOnly();
    [CompilerGeneratedAttribute]
public void set_ReadOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_Upgrade();
    [CompilerGeneratedAttribute]
public void set_Upgrade(bool value);
    [CompilerGeneratedAttribute]
public bool get_AutoRebuild();
    [CompilerGeneratedAttribute]
public void set_AutoRebuild(bool value);
    [CompilerGeneratedAttribute]
public Collation get_Collation();
    [CompilerGeneratedAttribute]
public void set_Collation(Collation value);
    public string get_Item(string key);
    internal ILiteEngine CreateEngine(Action`1<EngineSettings> engineSettingsAction);
}
public enum LiteDB.ConnectionType : Enum {
    public int value__;
    public static ConnectionType Direct;
    public static ConnectionType Shared;
}
internal class LiteDB.Constants : object {
    public static int PAGE_SIZE;
    public static int PAGE_HEADER_SIZE;
    public static int ENCRYPTION_SALT_SIZE;
    public static int BUFFER_WRITABLE;
    public static int INDEX_NAME_MAX_LENGTH;
    public static int MAX_LEVEL_LENGTH;
    public static int MAX_INDEX_KEY_LENGTH;
    public static int MAX_INDEX_LENGTH;
    public static int PAGE_FREE_LIST_SLOTS;
    public static int MAX_DOCUMENT_SIZE;
    public static int MAX_OPEN_TRANSACTIONS;
    public static int MAX_TRANSACTION_SIZE;
    public static Int32[] MEMORY_SEGMENT_SIZES;
    public static int VIRTUAL_INDEX_MAX_CACHE;
    public static int CONTAINER_SORT_SIZE;
    public static int RANDOMIZER_SEED;
    private static Constants();
    [DebuggerHiddenAttribute]
[ConditionalAttribute("DEBUG")]
public static void LOG(string message, string category);
    [DebuggerHiddenAttribute]
[ConditionalAttribute("DEBUG")]
public static void LOG(bool conditional, string message, string category);
    [DebuggerHiddenAttribute]
public static void ENSURE(bool conditional, string message);
    [DebuggerHiddenAttribute]
public static void ENSURE(bool conditional, string format, Object[] args);
    [DebuggerHiddenAttribute]
public static void ENSURE(bool ifTest, bool conditional, string message);
    [DebuggerHiddenAttribute]
[ConditionalAttribute("DEBUG")]
public static void DEBUG(bool conditional, string message);
}
internal class LiteDB.ConvertResolver : object {
    public sealed virtual string ResolveMethod(MethodInfo method);
    public sealed virtual string ResolveMember(MemberInfo member);
    public sealed virtual string ResolveCtor(ConstructorInfo ctor);
}
public class LiteDB.CreateObject : MulticastDelegate {
    public CreateObject(object object, IntPtr method);
    public virtual object Invoke(BsonDocument value);
    public virtual IAsyncResult BeginInvoke(BsonDocument value, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
internal static class LiteDB.DateExtensions : object {
    [ExtensionAttribute]
public static DateTime Truncate(DateTime dt);
    [ExtensionAttribute]
public static int MonthDifference(DateTime startDate, DateTime endDate);
    [ExtensionAttribute]
public static int YearDifference(DateTime startDate, DateTime endDate);
}
internal class LiteDB.DateTimeResolver : object {
    public sealed virtual string ResolveMethod(MethodInfo method);
    public sealed virtual string ResolveMember(MemberInfo member);
    public sealed virtual string ResolveCtor(ConstructorInfo ctor);
}
public class LiteDB.DefaultTypeNameBinder : object {
    [CompilerGeneratedAttribute]
private static DefaultTypeNameBinder <Instance>k__BackingField;
    private static HashSet`1<string> _disallowedTypeNames;
    public static DefaultTypeNameBinder Instance { get; }
    private static DefaultTypeNameBinder();
    [CompilerGeneratedAttribute]
public static DefaultTypeNameBinder get_Instance();
    public sealed virtual string GetName(Type type);
    public sealed virtual Type GetType(string name);
}
[ExtensionAttribute]
internal static class LiteDB.DictionaryExtensions : object {
    [ExtensionAttribute]
public static T GetOrDefault(IDictionary`2<K, T> dict, K key, T defaultValue);
    [ExtensionAttribute]
public static T GetOrAdd(IDictionary`2<K, T> dict, K key, Func`2<K, T> valueFactoy);
    [ExtensionAttribute]
public static void ParseKeyValue(IDictionary`2<string, string> dict, string connectionString);
    [ExtensionAttribute]
public static T GetValue(Dictionary`2<string, string> dict, string key, T defaultValue);
    [ExtensionAttribute]
public static long GetFileSize(Dictionary`2<string, string> dict, string key, long defaultValue);
    [CompilerGeneratedAttribute]
internal static string <ParseKeyValue>g__ReadKey|2_0(<>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static string <ParseKeyValue>g__ReadValue|2_1(<>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static void <ParseKeyValue>g__EatWhitespace|2_2(<>c__DisplayClass2_0& );
}
internal enum LiteDB.DocumentScope : Enum {
    public int value__;
    public static DocumentScope Source;
    public static DocumentScope Root;
    public static DocumentScope Current;
}
public class LiteDB.Engine.AesStream : Stream {
    private Aes _aes;
    private ICryptoTransform _encryptor;
    private ICryptoTransform _decryptor;
    private string _name;
    private Stream _stream;
    private CryptoStream _reader;
    private CryptoStream _writer;
    private Byte[] _decryptedZeroes;
    private static Byte[] _emptyContent;
    private static ArrayPool`1<byte> _bufferPool;
    [CompilerGeneratedAttribute]
private Byte[] <Salt>k__BackingField;
    public Byte[] Salt { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public long StreamPosition { get; }
    public AesStream(string password, Stream stream);
    private static AesStream();
    [CompilerGeneratedAttribute]
public Byte[] get_Salt();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public long get_StreamPosition();
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual void Write(Byte[] array, int offset, int count);
    protected virtual void Dispose(bool disposing);
    public static Byte[] NewSalt();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    private bool IsBlank(Byte[] array, int offset);
}
internal class LiteDB.Engine.BasePage : object {
    protected PageBuffer _buffer;
    public static int SLOT_SIZE;
    public static int P_PAGE_ID;
    public static int P_PAGE_TYPE;
    public static int P_PREV_PAGE_ID;
    public static int P_NEXT_PAGE_ID;
    public static int P_INITIAL_SLOT;
    public static int P_TRANSACTION_ID;
    public static int P_IS_CONFIRMED;
    public static int P_COL_ID;
    public static int P_ITEMS_COUNT;
    public static int P_USED_BYTES;
    public static int P_FRAGMENTED_BYTES;
    public static int P_NEXT_FREE_POSITION;
    public static int P_HIGHEST_INDEX;
    [CompilerGeneratedAttribute]
private UInt32 <PageID>k__BackingField;
    [CompilerGeneratedAttribute]
private PageType <PageType>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <PrevPageID>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <NextPageID>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <PageListSlot>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <ItemsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <UsedBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <FragmentedBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NextFreePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <HighestIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ColID>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <TransactionID>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConfirmed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDirty>k__BackingField;
    private byte _startIndex;
    public UInt32 PageID { get; }
    public PageType PageType { get; private set; }
    public UInt32 PrevPageID { get; public set; }
    public UInt32 NextPageID { get; public set; }
    public byte PageListSlot { get; public set; }
    public byte ItemsCount { get; private set; }
    public ushort UsedBytes { get; private set; }
    public ushort FragmentedBytes { get; private set; }
    public ushort NextFreePosition { get; private set; }
    public byte HighestIndex { get; private set; }
    public int FreeBytes { get; }
    public int FooterSize { get; }
    public UInt32 ColID { get; public set; }
    public UInt32 TransactionID { get; public set; }
    public bool IsConfirmed { get; public set; }
    public bool IsDirty { get; public set; }
    public PageBuffer Buffer { get; }
    public BasePage(PageBuffer buffer, UInt32 pageID, PageType pageType);
    public BasePage(PageBuffer buffer);
    [CompilerGeneratedAttribute]
public UInt32 get_PageID();
    [CompilerGeneratedAttribute]
public PageType get_PageType();
    [CompilerGeneratedAttribute]
private void set_PageType(PageType value);
    [CompilerGeneratedAttribute]
public UInt32 get_PrevPageID();
    [CompilerGeneratedAttribute]
public void set_PrevPageID(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_NextPageID();
    [CompilerGeneratedAttribute]
public void set_NextPageID(UInt32 value);
    [CompilerGeneratedAttribute]
public byte get_PageListSlot();
    [CompilerGeneratedAttribute]
public void set_PageListSlot(byte value);
    [CompilerGeneratedAttribute]
public byte get_ItemsCount();
    [CompilerGeneratedAttribute]
private void set_ItemsCount(byte value);
    [CompilerGeneratedAttribute]
public ushort get_UsedBytes();
    [CompilerGeneratedAttribute]
private void set_UsedBytes(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_FragmentedBytes();
    [CompilerGeneratedAttribute]
private void set_FragmentedBytes(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_NextFreePosition();
    [CompilerGeneratedAttribute]
private void set_NextFreePosition(ushort value);
    [CompilerGeneratedAttribute]
public byte get_HighestIndex();
    [CompilerGeneratedAttribute]
private void set_HighestIndex(byte value);
    public int get_FreeBytes();
    public int get_FooterSize();
    [CompilerGeneratedAttribute]
public UInt32 get_ColID();
    [CompilerGeneratedAttribute]
public void set_ColID(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_TransactionID();
    [CompilerGeneratedAttribute]
public void set_TransactionID(UInt32 value);
    [CompilerGeneratedAttribute]
public bool get_IsConfirmed();
    [CompilerGeneratedAttribute]
public void set_IsConfirmed(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDirty();
    [CompilerGeneratedAttribute]
public void set_IsDirty(bool value);
    public PageBuffer get_Buffer();
    public virtual PageBuffer UpdateBuffer();
    public void MarkAsEmtpy();
    public BufferSlice Get(byte index);
    public BufferSlice Insert(ushort bytesLength, Byte& index);
    private BufferSlice InternalInsert(ushort bytesLength, Byte& index);
    public void Delete(byte index);
    public BufferSlice Update(byte index, ushort bytesLength);
    public void Defrag();
    private byte GetFreeIndex();
    [IteratorStateMachineAttribute("LiteDB.Engine.BasePage/<GetUsedIndexs>d__88")]
public IEnumerable`1<byte> GetUsedIndexs();
    private void UpdateHighestIndex();
    private bool IsValidPos(ushort position);
    private bool IsValidLen(ushort length);
    public static int CalcPositionAddr(byte index);
    public static int CalcLengthAddr(byte index);
    public static long GetPagePosition(UInt32 pageID);
    public static long GetPagePosition(int pageID);
    public static T ReadPage(PageBuffer buffer);
    public static T CreatePage(PageBuffer buffer, UInt32 pageID);
    public virtual string ToString();
}
internal abstract class LiteDB.Engine.BasePipe : object {
    protected TransactionService _transaction;
    protected IDocumentLookup _lookup;
    protected SortDisk _tempDisk;
    protected EnginePragmas _pragmas;
    protected UInt32 _maxItemsCount;
    public BasePipe(TransactionService transaction, IDocumentLookup lookup, SortDisk tempDisk, EnginePragmas pragmas, UInt32 maxItemsCount);
    public abstract virtual IEnumerable`1<BsonDocument> Pipe(IEnumerable`1<IndexNode> nodes, QueryPlan query);
    [IteratorStateMachineAttribute("LiteDB.Engine.BasePipe/<LoadDocument>d__7")]
protected IEnumerable`1<BsonDocument> LoadDocument(IEnumerable`1<IndexNode> nodes);
    [IteratorStateMachineAttribute("LiteDB.Engine.BasePipe/<Include>d__8")]
protected IEnumerable`1<BsonDocument> Include(IEnumerable`1<BsonDocument> source, BsonExpression path);
    [IteratorStateMachineAttribute("LiteDB.Engine.BasePipe/<Filter>d__9")]
protected IEnumerable`1<BsonDocument> Filter(IEnumerable`1<BsonDocument> source, BsonExpression expr);
    [IteratorStateMachineAttribute("LiteDB.Engine.BasePipe/<OrderBy>d__10")]
protected IEnumerable`1<BsonDocument> OrderBy(IEnumerable`1<BsonDocument> source, BsonExpression expr, int order, int offset, int limit);
    [CompilerGeneratedAttribute]
private void <Include>g__DoInclude|8_0(BsonDocument value, <>c__DisplayClass8_0& );
}
internal class LiteDB.Engine.BufferReader : object {
    private IEnumerator`1<BufferSlice> _source;
    private bool _utcDate;
    private BufferSlice _current;
    private int _currentPosition;
    private int _position;
    private bool _isEOF;
    private static ArrayPool`1<byte> _bufferPool;
    public int Position { get; }
    public bool IsEOF { get; }
    public BufferReader(Byte[] buffer, bool utcDate);
    public BufferReader(BufferSlice buffer, bool utcDate);
    public BufferReader(IEnumerable`1<BufferSlice> source, bool utcDate);
    private static BufferReader();
    public int get_Position();
    public bool get_IsEOF();
    private bool MoveForward(int count);
    public int Read(Byte[] buffer, int offset, int count);
    public int Skip(int count);
    public void Consume();
    public string ReadString(int count);
    public string ReadCString();
    private bool TryReadCStringCurrentSegment(String& value);
    private T ReadNumber(Func`3<Byte[], int, T> convert, int size);
    public int ReadInt32();
    public long ReadInt64();
    public UInt32 ReadUInt32();
    public double ReadDouble();
    public decimal ReadDecimal();
    public DateTime ReadDateTime();
    public Guid ReadGuid();
    public ObjectId ReadObjectId();
    public bool ReadBoolean();
    public byte ReadByte();
    internal PageAddress ReadPageAddress();
    public Byte[] ReadBytes(int count);
    public BsonValue ReadIndexKey();
    public Result`1<BsonDocument> ReadDocument(HashSet`1<string> fields);
    public Result`1<BsonArray> ReadArray();
    private BsonValue ReadElement(HashSet`1<string> remaining, String& name);
    public sealed virtual void Dispose();
}
internal class LiteDB.Engine.BufferWriter : object {
    private IEnumerator`1<BufferSlice> _source;
    private BufferSlice _current;
    private int _currentPosition;
    private int _position;
    private bool _isEOF;
    private static ArrayPool`1<byte> _bufferPool;
    public int Position { get; }
    public bool IsEOF { get; }
    public BufferWriter(Byte[] buffer);
    public BufferWriter(BufferSlice buffer);
    public BufferWriter(IEnumerable`1<BufferSlice> source);
    private static BufferWriter();
    public int get_Position();
    public bool get_IsEOF();
    private bool MoveForward(int count);
    public int Write(Byte[] buffer, int offset, int count);
    public int Write(Byte[] buffer);
    public int Skip(int count);
    public void Consume();
    public void WriteCString(string value);
    public void WriteString(string value, bool specs);
    private void WriteNumber(T value, Action`3<T, Byte[], int> toBytes, int size);
    public void Write(int value);
    public void Write(long value);
    public void Write(UInt32 value);
    public void Write(double value);
    public void Write(decimal value);
    public void Write(DateTime value);
    public void Write(Guid value);
    public void Write(ObjectId value);
    public void Write(bool value);
    public void Write(byte value);
    internal void Write(PageAddress address);
    public int WriteArray(BsonArray value, bool recalc);
    public int WriteDocument(BsonDocument value, bool recalc);
    private void WriteElement(string key, BsonValue value);
    public sealed virtual void Dispose();
}
internal class LiteDB.Engine.CollectionIndex : object {
    [CompilerGeneratedAttribute]
private byte <Slot>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <IndexType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonExpression <BsonExpr>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Unique>k__BackingField;
    [CompilerGeneratedAttribute]
private PageAddress <Head>k__BackingField;
    [CompilerGeneratedAttribute]
private PageAddress <Tail>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Reserved>k__BackingField;
    public UInt32 FreeIndexPageList;
    public byte Slot { get; }
    public byte IndexType { get; }
    public string Name { get; }
    public string Expression { get; }
    public BsonExpression BsonExpr { get; }
    public bool Unique { get; }
    public PageAddress Head { get; public set; }
    public PageAddress Tail { get; public set; }
    public byte Reserved { get; public set; }
    public bool IsEmpty { get; }
    public CollectionIndex(byte slot, byte indexType, string name, string expr, bool unique);
    public CollectionIndex(BufferReader reader);
    [CompilerGeneratedAttribute]
public byte get_Slot();
    [CompilerGeneratedAttribute]
public byte get_IndexType();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Expression();
    [CompilerGeneratedAttribute]
public BsonExpression get_BsonExpr();
    [CompilerGeneratedAttribute]
public bool get_Unique();
    [CompilerGeneratedAttribute]
public PageAddress get_Head();
    [CompilerGeneratedAttribute]
public void set_Head(PageAddress value);
    [CompilerGeneratedAttribute]
public PageAddress get_Tail();
    [CompilerGeneratedAttribute]
public void set_Tail(PageAddress value);
    [CompilerGeneratedAttribute]
public byte get_Reserved();
    [CompilerGeneratedAttribute]
public void set_Reserved(byte value);
    public bool get_IsEmpty();
    public void UpdateBuffer(BufferWriter writer);
    public static int GetLength(CollectionIndex index);
    public static int GetLength(string name, string expr);
}
internal class LiteDB.Engine.CollectionPage : BasePage {
    public static int P_INDEXES;
    public static int P_INDEXES_COUNT;
    [CompilerGeneratedAttribute]
private UInt32[] <FreeDataPageList>k__BackingField;
    private Dictionary`2<string, CollectionIndex> _indexes;
    public UInt32[] FreeDataPageList { get; }
    public CollectionIndex PK { get; }
    public CollectionPage(PageBuffer buffer, UInt32 pageID);
    public CollectionPage(PageBuffer buffer);
    [CompilerGeneratedAttribute]
public UInt32[] get_FreeDataPageList();
    public virtual PageBuffer UpdateBuffer();
    public CollectionIndex get_PK();
    public CollectionIndex GetCollectionIndex(string name);
    public ICollection`1<CollectionIndex> GetCollectionIndexes();
    public CollectionIndex[] GetCollectionIndexesSlots();
    public CollectionIndex InsertCollectionIndex(string name, string expr, bool unique);
    public CollectionIndex UpdateCollectionIndex(string name);
    public void DeleteCollectionIndex(string name);
}
internal class LiteDB.Engine.CollectionService : object {
    private HeaderPage _header;
    private DiskService _disk;
    private Snapshot _snapshot;
    private TransactionPages _transPages;
    public CollectionService(HeaderPage header, DiskService disk, Snapshot snapshot, TransactionPages transPages);
    public static void CheckName(string name, HeaderPage header);
    public bool Get(string name, bool addIfNotExists, CollectionPage& collectionPage);
    private void Add(string name, CollectionPage& collectionPage);
}
internal class LiteDB.Engine.ConcurrentStream : Stream {
    private Stream _stream;
    private bool _canWrite;
    private long _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ConcurrentStream(Stream stream, bool canWrite);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class LiteDB.Engine.CursorInfo : object {
    [CompilerGeneratedAttribute]
private string <Collection>k__BackingField;
    [CompilerGeneratedAttribute]
private Query <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Fetched>k__BackingField;
    [CompilerGeneratedAttribute]
private Stopwatch <Elapsed>k__BackingField;
    public string Collection { get; }
    public Query Query { get; public set; }
    public int Fetched { get; public set; }
    public Stopwatch Elapsed { get; }
    public CursorInfo(string collection, Query query);
    [CompilerGeneratedAttribute]
public string get_Collection();
    [CompilerGeneratedAttribute]
public Query get_Query();
    [CompilerGeneratedAttribute]
public void set_Query(Query value);
    [CompilerGeneratedAttribute]
public int get_Fetched();
    [CompilerGeneratedAttribute]
public void set_Fetched(int value);
    [CompilerGeneratedAttribute]
public Stopwatch get_Elapsed();
}
internal class LiteDB.Engine.DataBlock : object {
    public static int DATA_BLOCK_FIXED_SIZE;
    public static int P_EXTEND;
    public static int P_NEXT_BLOCK;
    public static int P_BUFFER;
    private DataPage _page;
    private BufferSlice _segment;
    [CompilerGeneratedAttribute]
private PageAddress <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Extend>k__BackingField;
    [CompilerGeneratedAttribute]
private PageAddress <NextBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private BufferSlice <Buffer>k__BackingField;
    public PageAddress Position { get; }
    public bool Extend { get; }
    public PageAddress NextBlock { get; private set; }
    public BufferSlice Buffer { get; }
    public DataBlock(DataPage page, byte index, BufferSlice segment);
    public DataBlock(DataPage page, byte index, BufferSlice segment, bool extend, PageAddress nextBlock);
    [CompilerGeneratedAttribute]
public PageAddress get_Position();
    [CompilerGeneratedAttribute]
public bool get_Extend();
    [CompilerGeneratedAttribute]
public PageAddress get_NextBlock();
    [CompilerGeneratedAttribute]
private void set_NextBlock(PageAddress value);
    [CompilerGeneratedAttribute]
public BufferSlice get_Buffer();
    public void SetNextBlock(PageAddress nextBlock);
    public virtual string ToString();
}
internal class LiteDB.Engine.DatafileLookup : object {
    protected DataService _data;
    protected bool _utcDate;
    protected HashSet`1<string> _fields;
    public DatafileLookup(DataService data, bool utcDate, HashSet`1<string> fields);
    public virtual BsonDocument Load(IndexNode node);
    public virtual BsonDocument Load(PageAddress rawId);
}
internal class LiteDB.Engine.DataPage : BasePage {
    private static Int32[] _freePageSlots;
    public DataPage(PageBuffer buffer);
    public DataPage(PageBuffer buffer, UInt32 pageID);
    private static DataPage();
    public DataBlock GetBlock(byte index);
    public DataBlock InsertBlock(int bytesLength, bool extend);
    public DataBlock UpdateBlock(DataBlock currentBlock, int bytesLength);
    public void DeleteBlock(byte index);
    [IteratorStateMachineAttribute("LiteDB.Engine.DataPage/<GetBlocks>d__6")]
public IEnumerable`1<PageAddress> GetBlocks();
    public static byte FreeIndexSlot(int freeBytes);
    public static int GetMinimumIndexSlot(int length);
}
internal class LiteDB.Engine.DataService : object {
    public static int MAX_DATA_BYTES_PER_PAGE;
    private Snapshot _snapshot;
    private UInt32 _maxItemsCount;
    public DataService(Snapshot snapshot, UInt32 maxItemsCount);
    public PageAddress Insert(BsonDocument doc);
    public void Update(CollectionPage col, PageAddress blockAddress, BsonDocument doc);
    [IteratorStateMachineAttribute("LiteDB.Engine.DataService/<Read>d__6")]
public IEnumerable`1<BufferSlice> Read(PageAddress address);
    public void Delete(PageAddress blockAddress);
}
internal class LiteDB.Engine.DiskReader : object {
    private EngineState _state;
    private MemoryCache _cache;
    private StreamPool _dataPool;
    private StreamPool _logPool;
    private Lazy`1<Stream> _dataStream;
    private Lazy`1<Stream> _logStream;
    public DiskReader(EngineState state, MemoryCache cache, StreamPool dataPool, StreamPool logPool);
    public PageBuffer ReadPage(long position, bool writable, FileOrigin origin);
    private void ReadStream(Stream stream, long position, BufferSlice buffer);
    public PageBuffer NewPage();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private Stream <.ctor>b__6_0();
    [CompilerGeneratedAttribute]
private Stream <.ctor>b__6_1();
}
internal class LiteDB.Engine.DiskService : object {
    private MemoryCache _cache;
    private EngineState _state;
    private IStreamFactory _dataFactory;
    private IStreamFactory _logFactory;
    private StreamPool _dataPool;
    private StreamPool _logPool;
    private Lazy`1<Stream> _writer;
    private long _dataLength;
    private long _logLength;
    private static ArrayPool`1<byte> _bufferPool;
    public MemoryCache Cache { get; }
    public UInt32 MAX_ITEMS_COUNT { get; }
    public DiskService(EngineSettings settings, EngineState state, Int32[] memorySegmentSizes);
    private static DiskService();
    public MemoryCache get_Cache();
    private void Initialize(Stream stream, Collation collation, long initialSize);
    public DiskReader GetReader();
    public UInt32 get_MAX_ITEMS_COUNT();
    public void DiscardDirtyPages(IEnumerable`1<PageBuffer> pages);
    public void DiscardCleanPages(IEnumerable`1<PageBuffer> pages);
    public PageBuffer NewPage();
    public int WriteLogDisk(IEnumerable`1<PageBuffer> pages);
    public long GetFileLength(FileOrigin origin);
    internal void MarkAsInvalidState();
    [IteratorStateMachineAttribute("LiteDB.Engine.DiskService/<ReadFull>d__23")]
public IEnumerable`1<PageBuffer> ReadFull(FileOrigin origin);
    public void WriteDataDisk(IEnumerable`1<PageBuffer> pages);
    public void SetLength(long length, FileOrigin origin);
    public string GetName(FileOrigin origin);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <MarkAsInvalidState>b__22_0();
}
internal class LiteDB.Engine.DocumentCacheEnumerable : object {
    private IEnumerator`1<BsonDocument> _enumerator;
    private List`1<PageAddress> _cache;
    private IDocumentLookup _lookup;
    public DocumentCacheEnumerable(IEnumerable`1<BsonDocument> source, IDocumentLookup lookup);
    public sealed virtual void Dispose();
    [IteratorStateMachineAttribute("LiteDB.Engine.DocumentCacheEnumerable/<GetEnumerator>d__5")]
public sealed virtual IEnumerator`1<BsonDocument> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class LiteDB.Engine.Done : object {
    public bool Running;
    public int Count;
}
internal class LiteDB.Engine.EnginePragmas : object {
    public static int P_USER_VERSION;
    public static int P_COLLATION_LCID;
    public static int P_COLLATION_SORT;
    public static int P_TIMEOUT;
    public static int P_UTC_DATE;
    public static int P_CHECKPOINT;
    public static int P_LIMIT_SIZE;
    [CompilerGeneratedAttribute]
private int <UserVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Collation <Collation>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LimitSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UtcDate>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Checkpoint>k__BackingField;
    private Dictionary`2<string, Pragma> _pragmas;
    private bool _isDirty;
    private HeaderPage _headerPage;
    public int UserVersion { get; private set; }
    public Collation Collation { get; private set; }
    public TimeSpan Timeout { get; private set; }
    public long LimitSize { get; private set; }
    public bool UtcDate { get; private set; }
    public int Checkpoint { get; private set; }
    public IEnumerable`1<Pragma> Pragmas { get; }
    public EnginePragmas(HeaderPage headerPage);
    public EnginePragmas(BufferSlice buffer, HeaderPage headerPage);
    [CompilerGeneratedAttribute]
public int get_UserVersion();
    [CompilerGeneratedAttribute]
private void set_UserVersion(int value);
    [CompilerGeneratedAttribute]
public Collation get_Collation();
    [CompilerGeneratedAttribute]
private void set_Collation(Collation value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Timeout();
    [CompilerGeneratedAttribute]
private void set_Timeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public long get_LimitSize();
    [CompilerGeneratedAttribute]
private void set_LimitSize(long value);
    [CompilerGeneratedAttribute]
public bool get_UtcDate();
    [CompilerGeneratedAttribute]
private void set_UtcDate(bool value);
    [CompilerGeneratedAttribute]
public int get_Checkpoint();
    [CompilerGeneratedAttribute]
private void set_Checkpoint(int value);
    public IEnumerable`1<Pragma> get_Pragmas();
    public void UpdateBuffer(BufferSlice buffer);
    public BsonValue Get(string name);
    public void Set(string name, BsonValue value, bool validate);
    [CompilerGeneratedAttribute]
private BsonValue <.ctor>b__36_0();
    [CompilerGeneratedAttribute]
private void <.ctor>b__36_1(BsonValue v);
    [CompilerGeneratedAttribute]
private void <.ctor>b__36_2(BufferSlice b);
    [CompilerGeneratedAttribute]
private void <.ctor>b__36_4(BufferSlice b);
    [CompilerGeneratedAttribute]
private BsonValue <.ctor>b__36_5();
    [CompilerGeneratedAttribute]
private void <.ctor>b__36_6(BsonValue v);
    [CompilerGeneratedAttribute]
private void <.ctor>b__36_7(BufferSlice b);
    [CompilerGeneratedAttribute]
private void <.ctor>b__36_9(BufferSlice b);
    [CompilerGeneratedAttribute]
private BsonValue <.ctor>b__36_10();
    [CompilerGeneratedAttribute]
private void <.ctor>b__36_11(BsonValue v);
    [CompilerGeneratedAttribute]
private void <.ctor>b__36_12(BufferSlice b);
    [CompilerGeneratedAttribute]
private void <.ctor>b__36_14(BufferSlice b);
    [CompilerGeneratedAttribute]
private BsonValue <.ctor>b__36_15();
    [CompilerGeneratedAttribute]
private void <.ctor>b__36_16(BsonValue v);
    [CompilerGeneratedAttribute]
private void <.ctor>b__36_17(BufferSlice b);
    [CompilerGeneratedAttribute]
private void <.ctor>b__36_19(BufferSlice b);
    [CompilerGeneratedAttribute]
private BsonValue <.ctor>b__36_20();
    [CompilerGeneratedAttribute]
private void <.ctor>b__36_21(BsonValue v);
    [CompilerGeneratedAttribute]
private void <.ctor>b__36_22(BufferSlice b);
    [CompilerGeneratedAttribute]
private void <.ctor>b__36_24(BufferSlice b);
    [CompilerGeneratedAttribute]
private BsonValue <.ctor>b__36_25();
    [CompilerGeneratedAttribute]
private void <.ctor>b__36_26(BsonValue v);
    [CompilerGeneratedAttribute]
private void <.ctor>b__36_27(BufferSlice b);
    [CompilerGeneratedAttribute]
private void <.ctor>b__36_29(BufferSlice b);
}
public class LiteDB.Engine.EngineSettings : object {
    [CompilerGeneratedAttribute]
private Stream <DataStream>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <LogStream>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <TempStream>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Filename>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private long <InitialSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Collation <Collation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoRebuild>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Upgrade>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<string, BsonValue, BsonValue> <ReadTransform>k__BackingField;
    public Stream DataStream { get; public set; }
    public Stream LogStream { get; public set; }
    public Stream TempStream { get; public set; }
    public string Filename { get; public set; }
    public string Password { get; public set; }
    public long InitialSize { get; public set; }
    public Collation Collation { get; public set; }
    public bool ReadOnly { get; public set; }
    public bool AutoRebuild { get; public set; }
    public bool Upgrade { get; public set; }
    public Func`3<string, BsonValue, BsonValue> ReadTransform { get; public set; }
    [CompilerGeneratedAttribute]
public Stream get_DataStream();
    [CompilerGeneratedAttribute]
public void set_DataStream(Stream value);
    [CompilerGeneratedAttribute]
public Stream get_LogStream();
    [CompilerGeneratedAttribute]
public void set_LogStream(Stream value);
    [CompilerGeneratedAttribute]
public Stream get_TempStream();
    [CompilerGeneratedAttribute]
public void set_TempStream(Stream value);
    [CompilerGeneratedAttribute]
public string get_Filename();
    [CompilerGeneratedAttribute]
public void set_Filename(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public long get_InitialSize();
    [CompilerGeneratedAttribute]
public void set_InitialSize(long value);
    [CompilerGeneratedAttribute]
public Collation get_Collation();
    [CompilerGeneratedAttribute]
public void set_Collation(Collation value);
    [CompilerGeneratedAttribute]
public bool get_ReadOnly();
    [CompilerGeneratedAttribute]
public void set_ReadOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_AutoRebuild();
    [CompilerGeneratedAttribute]
public void set_AutoRebuild(bool value);
    [CompilerGeneratedAttribute]
public bool get_Upgrade();
    [CompilerGeneratedAttribute]
public void set_Upgrade(bool value);
    [CompilerGeneratedAttribute]
public Func`3<string, BsonValue, BsonValue> get_ReadTransform();
    [CompilerGeneratedAttribute]
public void set_ReadTransform(Func`3<string, BsonValue, BsonValue> value);
    internal IStreamFactory CreateDataFactory(bool useAesStream);
    internal IStreamFactory CreateLogFactory();
    internal IStreamFactory CreateTempFactory();
}
internal class LiteDB.Engine.EngineState : object {
    public bool Disposed;
    private Exception _exception;
    private LiteEngine _engine;
    private EngineSettings _settings;
    public EngineState(LiteEngine engine, EngineSettings settings);
    public void Validate();
    public bool Handle(Exception ex);
    public BsonValue ReadTransform(string collection, BsonValue value);
}
public enum LiteDB.Engine.FileOrigin : Enum {
    public byte value__;
    public static FileOrigin None;
    public static FileOrigin Data;
    public static FileOrigin Log;
}
internal class LiteDB.Engine.FileReaderError : object {
    [CompilerGeneratedAttribute]
private DateTime <Created>k__BackingField;
    [CompilerGeneratedAttribute]
private FileOrigin <Origin>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <PageID>k__BackingField;
    [CompilerGeneratedAttribute]
private PageType <PageType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Collection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public DateTime Created { get; }
    public FileOrigin Origin { get; public set; }
    public long Position { get; public set; }
    public Nullable`1<UInt32> PageID { get; public set; }
    public PageType PageType { get; public set; }
    public string Collection { get; public set; }
    public string Message { get; public set; }
    public Exception Exception { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_Created();
    [CompilerGeneratedAttribute]
public FileOrigin get_Origin();
    [CompilerGeneratedAttribute]
public void set_Origin(FileOrigin value);
    [CompilerGeneratedAttribute]
public long get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_PageID();
    [CompilerGeneratedAttribute]
public void set_PageID(Nullable`1<UInt32> value);
    [CompilerGeneratedAttribute]
public PageType get_PageType();
    [CompilerGeneratedAttribute]
public void set_PageType(PageType value);
    [CompilerGeneratedAttribute]
public string get_Collection();
    [CompilerGeneratedAttribute]
public void set_Collection(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(Exception value);
}
internal class LiteDB.Engine.FileReaderV7 : object {
    private static int V7_PAGE_SIZE;
    private EngineSettings _settings;
    private Stream _stream;
    private AesEncryption _aes;
    private BsonDocument _header;
    private Byte[] _buffer;
    private bool _disposedValue;
    private static Byte[] arrayByteEmpty;
    public FileReaderV7(EngineSettings settings);
    private static FileReaderV7();
    public sealed virtual IDictionary`2<string, BsonValue> GetPragmas();
    public sealed virtual void Open();
    public static bool IsVersion(Byte[] buffer);
    public sealed virtual IEnumerable`1<string> GetCollections();
    [IteratorStateMachineAttribute("LiteDB.Engine.FileReaderV7/<GetIndexes>d__13")]
public sealed virtual IEnumerable`1<IndexInfo> GetIndexes(string collection);
    [IteratorStateMachineAttribute("LiteDB.Engine.FileReaderV7/<GetDocuments>d__14")]
public sealed virtual IEnumerable`1<BsonDocument> GetDocuments(string collection);
    private BsonDocument ReadPage(UInt32 pageID);
    private Byte[] ReadExtendData(UInt32 extendPageID);
    private HashSet`1<UInt32> VisitIndexPages(UInt32 startPageID);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal class LiteDB.Engine.FileReaderV8 : object {
    private Dictionary`2<string, UInt32> _collections;
    private Dictionary`2<string, List`1<IndexInfo>> _indexes;
    private Dictionary`2<UInt32, List`1<UInt32>> _collectionsDataPages;
    private Dictionary`2<string, BsonValue> _pragmas;
    private Stream _dataStream;
    private Stream _logStream;
    private IDictionary`2<UInt32, long> _logIndexMap;
    private UInt32 _maxPageID;
    private bool _disposed;
    private EngineSettings _settings;
    private IList`1<FileReaderError> _errors;
    public FileReaderV8(EngineSettings settings, IList`1<FileReaderError> errors);
    public sealed virtual void Open();
    public sealed virtual IDictionary`2<string, BsonValue> GetPragmas();
    public sealed virtual IEnumerable`1<string> GetCollections();
    public sealed virtual IEnumerable`1<IndexInfo> GetIndexes(string collection);
    [IteratorStateMachineAttribute("LiteDB.Engine.FileReaderV8/<GetDocuments>d__17")]
public sealed virtual IEnumerable`1<BsonDocument> GetDocuments(string collection);
    private void LoadPragmas();
    private void LoadDataPages();
    private void LoadCollections();
    private void LoadIndexes();
    public static bool IsVersion(Byte[] buffer);
    private void LoadIndexMap();
    private Result`1<BasePage> ReadPage(UInt32 pageID, PageInfo& pageInfo);
    private void HandleError(Exception ex, PageInfo pageInfo);
    private void HandleError(string message, PageInfo pageInfo);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal class LiteDB.Engine.FileStreamFactory : object {
    private string _filename;
    private string _password;
    private bool _readonly;
    private bool _hidden;
    private bool _useAesStream;
    public string Name { get; }
    public bool CloseOnDispose { get; }
    public FileStreamFactory(string filename, string password, bool readOnly, bool hidden, bool useAesStream);
    public sealed virtual string get_Name();
    public sealed virtual Stream GetStream(bool canWrite, bool sequencial);
    public sealed virtual long GetLength();
    public sealed virtual bool Exists();
    public sealed virtual void Delete();
    public sealed virtual bool IsLocked();
    public sealed virtual bool get_CloseOnDispose();
}
internal class LiteDB.Engine.GroupBy : object {
    [CompilerGeneratedAttribute]
private BsonExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonExpression <Select>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonExpression <Having>k__BackingField;
    public BsonExpression Expression { get; }
    public BsonExpression Select { get; }
    public BsonExpression Having { get; }
    public GroupBy(BsonExpression expression, BsonExpression select, BsonExpression having);
    [CompilerGeneratedAttribute]
public BsonExpression get_Expression();
    [CompilerGeneratedAttribute]
public BsonExpression get_Select();
    [CompilerGeneratedAttribute]
public BsonExpression get_Having();
}
internal class LiteDB.Engine.GroupByPipe : BasePipe {
    public GroupByPipe(TransactionService transaction, IDocumentLookup loader, SortDisk tempDisk, EnginePragmas pragmas, UInt32 maxItemsCount);
    public virtual IEnumerable`1<BsonDocument> Pipe(IEnumerable`1<IndexNode> nodes, QueryPlan query);
    [IteratorStateMachineAttribute("LiteDB.Engine.GroupByPipe/<GroupBy>d__2")]
private IEnumerable`1<DocumentCacheEnumerable> GroupBy(IEnumerable`1<BsonDocument> source, GroupBy groupBy);
    [IteratorStateMachineAttribute("LiteDB.Engine.GroupByPipe/<YieldDocuments>d__3")]
private IEnumerable`1<BsonDocument> YieldDocuments(BsonValue key, IEnumerator`1<BsonDocument> enumerator, GroupBy groupBy, Done done);
    [IteratorStateMachineAttribute("LiteDB.Engine.GroupByPipe/<SelectGroupBy>d__4")]
private IEnumerable`1<BsonDocument> SelectGroupBy(IEnumerable`1<DocumentCacheEnumerable> groups, GroupBy groupBy);
}
internal class LiteDB.Engine.HeaderPage : BasePage {
    public static string HEADER_INFO;
    public static byte FILE_VERSION;
    public static int P_HEADER_INFO;
    public static int P_FILE_VERSION;
    public static int P_FREE_EMPTY_PAGE_ID;
    public static int P_LAST_PAGE_ID;
    public static int P_CREATION_TIME;
    public static int P_INVALID_DATAFILE_STATE;
    public static int P_COLLECTIONS;
    public static int COLLECTIONS_SIZE;
    [CompilerGeneratedAttribute]
private UInt32 <FreeEmptyPageList>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LastPageID>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private EnginePragmas <Pragmas>k__BackingField;
    private BsonDocument _collections;
    private bool _isCollectionsChanged;
    public UInt32 FreeEmptyPageList { get; public set; }
    public UInt32 LastPageID { get; public set; }
    public DateTime CreationTime { get; }
    public EnginePragmas Pragmas { get; public set; }
    public HeaderPage(PageBuffer buffer, UInt32 pageID);
    public HeaderPage(PageBuffer buffer);
    [CompilerGeneratedAttribute]
public UInt32 get_FreeEmptyPageList();
    [CompilerGeneratedAttribute]
public void set_FreeEmptyPageList(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_LastPageID();
    [CompilerGeneratedAttribute]
public void set_LastPageID(UInt32 value);
    [CompilerGeneratedAttribute]
public DateTime get_CreationTime();
    [CompilerGeneratedAttribute]
public EnginePragmas get_Pragmas();
    [CompilerGeneratedAttribute]
public void set_Pragmas(EnginePragmas value);
    private void LoadPage();
    public virtual PageBuffer UpdateBuffer();
    public PageBuffer Savepoint();
    public void Restore(PageBuffer savepoint);
    public UInt32 GetCollectionPageID(string collection);
    [IteratorStateMachineAttribute("LiteDB.Engine.HeaderPage/<GetCollections>d__34")]
public IEnumerable`1<KeyValuePair`2<string, UInt32>> GetCollections();
    public void InsertCollection(string name, UInt32 pageID);
    public void DeleteCollection(string name);
    public void RenameCollection(string oldName, string newName);
    public int GetAvailableCollectionSpace();
}
internal interface LiteDB.Engine.IDocumentLookup {
    public abstract virtual BsonDocument Load(IndexNode node);
    public abstract virtual BsonDocument Load(PageAddress rawId);
}
internal interface LiteDB.Engine.IFileReader {
    public abstract virtual void Open();
    public abstract virtual IDictionary`2<string, BsonValue> GetPragmas();
    public abstract virtual IEnumerable`1<string> GetCollections();
    public abstract virtual IEnumerable`1<IndexInfo> GetIndexes(string name);
    public abstract virtual IEnumerable`1<BsonDocument> GetDocuments(string collection);
}
public interface LiteDB.Engine.ILiteEngine {
    public abstract virtual int Checkpoint();
    public abstract virtual long Rebuild(RebuildOptions options);
    public abstract virtual bool BeginTrans();
    public abstract virtual bool Commit();
    public abstract virtual bool Rollback();
    public abstract virtual IBsonDataReader Query(string collection, Query query);
    public abstract virtual int Insert(string collection, IEnumerable`1<BsonDocument> docs, BsonAutoId autoId);
    public abstract virtual int Update(string collection, IEnumerable`1<BsonDocument> docs);
    public abstract virtual int UpdateMany(string collection, BsonExpression transform, BsonExpression predicate);
    public abstract virtual int Upsert(string collection, IEnumerable`1<BsonDocument> docs, BsonAutoId autoId);
    public abstract virtual int Delete(string collection, IEnumerable`1<BsonValue> ids);
    public abstract virtual int DeleteMany(string collection, BsonExpression predicate);
    public abstract virtual bool DropCollection(string name);
    public abstract virtual bool RenameCollection(string name, string newName);
    public abstract virtual bool EnsureIndex(string collection, string name, BsonExpression expression, bool unique);
    public abstract virtual bool DropIndex(string collection, string name);
    public abstract virtual BsonValue Pragma(string name);
    public abstract virtual bool Pragma(string name, BsonValue value);
}
internal abstract class LiteDB.Engine.Index : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    public string Name { get; private set; }
    public int Order { get; public set; }
    internal Index(string name, int order);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(int value);
    public abstract virtual UInt32 GetCost(CollectionIndex index);
    public abstract virtual IEnumerable`1<IndexNode> Execute(IndexService indexer, CollectionIndex index);
    public virtual IEnumerable`1<IndexNode> Run(CollectionPage col, IndexService indexer);
}
internal class LiteDB.Engine.IndexAll : Index {
    public IndexAll(string name, int order);
    public virtual UInt32 GetCost(CollectionIndex index);
    public virtual IEnumerable`1<IndexNode> Execute(IndexService indexer, CollectionIndex index);
    public virtual string ToString();
}
internal class LiteDB.Engine.IndexCost : object {
    [CompilerGeneratedAttribute]
private UInt32 <Cost>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private Index <Index>k__BackingField;
    public UInt32 Cost { get; }
    public BsonExpression Expression { get; }
    public string IndexExpression { get; }
    public Index Index { get; }
    public IndexCost(CollectionIndex index, BsonExpression expr, BsonExpression value, Collation collation);
    public IndexCost(CollectionIndex index);
    [CompilerGeneratedAttribute]
public UInt32 get_Cost();
    [CompilerGeneratedAttribute]
public BsonExpression get_Expression();
    [CompilerGeneratedAttribute]
public string get_IndexExpression();
    [CompilerGeneratedAttribute]
public Index get_Index();
    private Index CreateIndex(BsonExpressionType type, string name, BsonValue value);
}
internal class LiteDB.Engine.IndexEquals : Index {
    private BsonValue _value;
    public IndexEquals(string name, BsonValue value);
    public virtual UInt32 GetCost(CollectionIndex index);
    [IteratorStateMachineAttribute("LiteDB.Engine.IndexEquals/<Execute>d__3")]
public virtual IEnumerable`1<IndexNode> Execute(IndexService indexer, CollectionIndex index);
    public virtual string ToString();
}
internal class LiteDB.Engine.IndexIn : Index {
    private BsonArray _values;
    public IndexIn(string name, BsonArray values, int order);
    public virtual UInt32 GetCost(CollectionIndex index);
    [IteratorStateMachineAttribute("LiteDB.Engine.IndexIn/<Execute>d__3")]
public virtual IEnumerable`1<IndexNode> Execute(IndexService indexer, CollectionIndex index);
    public virtual string ToString();
}
internal class LiteDB.Engine.IndexInfo : object {
    [CompilerGeneratedAttribute]
private string <Collection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Unique>k__BackingField;
    public string Collection { get; public set; }
    public string Name { get; public set; }
    public string Expression { get; public set; }
    public bool Unique { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Collection();
    [CompilerGeneratedAttribute]
public void set_Collection(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(string value);
    [CompilerGeneratedAttribute]
public bool get_Unique();
    [CompilerGeneratedAttribute]
public void set_Unique(bool value);
}
internal class LiteDB.Engine.IndexLike : Index {
    private string _startsWith;
    private bool _equals;
    private bool _testSqlLike;
    private string _pattern;
    public IndexLike(string name, BsonValue value, int order);
    public virtual UInt32 GetCost(CollectionIndex index);
    public virtual IEnumerable`1<IndexNode> Execute(IndexService indexer, CollectionIndex index);
    [IteratorStateMachineAttribute("LiteDB.Engine.IndexLike/<ExecuteStartsWith>d__7")]
private IEnumerable`1<IndexNode> ExecuteStartsWith(IndexService indexer, CollectionIndex index);
    private IEnumerable`1<IndexNode> ExecuteLike(IndexService indexer, CollectionIndex index);
    public virtual string ToString();
}
internal class LiteDB.Engine.IndexLookup : object {
    private IndexService _indexer;
    private string _name;
    public IndexLookup(IndexService indexer, string name);
    public sealed virtual BsonDocument Load(IndexNode node);
    public sealed virtual BsonDocument Load(PageAddress rawId);
}
internal class LiteDB.Engine.IndexNode : object {
    private static int INDEX_NODE_FIXED_SIZE;
    private static int P_SLOT;
    private static int P_LEVELS;
    private static int P_DATA_BLOCK;
    private static int P_NEXT_NODE;
    private static int P_PREV_NEXT;
    private IndexPage _page;
    private BufferSlice _segment;
    private static Byte[] arrayByteEmpty;
    [CompilerGeneratedAttribute]
private PageAddress <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Slot>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Levels>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonValue <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private PageAddress <DataBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private PageAddress <NextNode>k__BackingField;
    [CompilerGeneratedAttribute]
private PageAddress[] <Prev>k__BackingField;
    [CompilerGeneratedAttribute]
private PageAddress[] <Next>k__BackingField;
    private int P_KEY { get; }
    public PageAddress Position { get; }
    public byte Slot { get; }
    public byte Levels { get; }
    public BsonValue Key { get; }
    public PageAddress DataBlock { get; }
    public PageAddress NextNode { get; private set; }
    public PageAddress[] Prev { get; private set; }
    public PageAddress[] Next { get; private set; }
    public IndexPage Page { get; }
    public IndexNode(IndexPage page, byte index, BufferSlice segment);
    public IndexNode(IndexPage page, byte index, BufferSlice segment, byte slot, byte levels, BsonValue key, PageAddress dataBlock);
    public IndexNode(BsonDocument doc);
    private static IndexNode();
    private int get_P_KEY();
    [CompilerGeneratedAttribute]
public PageAddress get_Position();
    [CompilerGeneratedAttribute]
public byte get_Slot();
    [CompilerGeneratedAttribute]
public byte get_Levels();
    [CompilerGeneratedAttribute]
public BsonValue get_Key();
    [CompilerGeneratedAttribute]
public PageAddress get_DataBlock();
    [CompilerGeneratedAttribute]
public PageAddress get_NextNode();
    [CompilerGeneratedAttribute]
private void set_NextNode(PageAddress value);
    [CompilerGeneratedAttribute]
public PageAddress[] get_Prev();
    [CompilerGeneratedAttribute]
private void set_Prev(PageAddress[] value);
    [CompilerGeneratedAttribute]
public PageAddress[] get_Next();
    [CompilerGeneratedAttribute]
private void set_Next(PageAddress[] value);
    public IndexPage get_Page();
    public static int GetNodeLength(byte level, BsonValue key, Int32& keyLength);
    public static int GetKeyLength(BsonValue key, bool recalc);
    public void SetNextNode(PageAddress value);
    public void SetPrev(byte level, PageAddress value);
    public void SetNext(byte level, PageAddress value);
    public PageAddress GetNextPrev(byte level, int order);
    public virtual string ToString();
}
internal class LiteDB.Engine.IndexPage : BasePage {
    public IndexPage(PageBuffer buffer);
    public IndexPage(PageBuffer buffer, UInt32 pageID);
    public IndexNode GetIndexNode(byte index);
    public IndexNode InsertIndexNode(byte slot, byte level, BsonValue key, PageAddress dataBlock, int bytesLength);
    public void DeleteIndexNode(byte index);
    [IteratorStateMachineAttribute("LiteDB.Engine.IndexPage/<GetIndexNodes>d__5")]
public IEnumerable`1<IndexNode> GetIndexNodes();
    public static byte FreeIndexSlot(int freeBytes);
}
internal class LiteDB.Engine.IndexRange : Index {
    private BsonValue _start;
    private BsonValue _end;
    private bool _startEquals;
    private bool _endEquals;
    public IndexRange(string name, BsonValue start, BsonValue end, bool startEquals, bool endEquals, int order);
    public virtual UInt32 GetCost(CollectionIndex index);
    [IteratorStateMachineAttribute("LiteDB.Engine.IndexRange/<Execute>d__6")]
public virtual IEnumerable`1<IndexNode> Execute(IndexService indexer, CollectionIndex index);
    public virtual string ToString();
}
internal class LiteDB.Engine.IndexScan : Index {
    private Func`2<BsonValue, bool> _func;
    public IndexScan(string name, Func`2<BsonValue, bool> func, int order);
    public virtual UInt32 GetCost(CollectionIndex index);
    public virtual IEnumerable`1<IndexNode> Execute(IndexService indexer, CollectionIndex index);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool <Execute>b__3_0(IndexNode i);
}
internal class LiteDB.Engine.IndexService : object {
    private Snapshot _snapshot;
    private Collation _collation;
    private UInt32 _maxItemsCount;
    public Collation Collation { get; }
    public IndexService(Snapshot snapshot, Collation collation, UInt32 maxItemsCount);
    public Collation get_Collation();
    public CollectionIndex CreateIndex(string name, string expr, bool unique);
    public IndexNode AddNode(CollectionIndex index, BsonValue key, PageAddress dataBlock, IndexNode last);
    private IndexNode AddNode(CollectionIndex index, BsonValue key, PageAddress dataBlock, byte insertLevels, IndexNode last);
    public byte Flip();
    public IndexNode GetNode(PageAddress address);
    [IteratorStateMachineAttribute("LiteDB.Engine.IndexService/<GetNodeList>d__11")]
public IEnumerable`1<IndexNode> GetNodeList(PageAddress nodeAddress);
    public void DeleteAll(PageAddress pkAddress);
    public IndexNode DeleteList(PageAddress pkAddress, HashSet`1<PageAddress> toDelete);
    private void DeleteSingleNode(IndexNode node, CollectionIndex index);
    public void DropIndex(CollectionIndex index);
    [IteratorStateMachineAttribute("LiteDB.Engine.IndexService/<FindAll>d__16")]
public IEnumerable`1<IndexNode> FindAll(CollectionIndex index, int order);
    public IndexNode Find(CollectionIndex index, BsonValue value, bool sibling, int order);
}
internal class LiteDB.Engine.IndexVirtual : Index {
    private IEnumerable`1<BsonDocument> _source;
    private Dictionary`2<UInt32, BsonDocument> _cache;
    public IndexVirtual(IEnumerable`1<BsonDocument> source);
    public virtual UInt32 GetCost(CollectionIndex index);
    public virtual IEnumerable`1<IndexNode> Execute(IndexService indexer, CollectionIndex index);
    [IteratorStateMachineAttribute("LiteDB.Engine.IndexVirtual/<Run>d__5")]
public virtual IEnumerable`1<IndexNode> Run(CollectionPage col, IndexService indexer);
    public sealed virtual BsonDocument Load(IndexNode node);
    public sealed virtual BsonDocument Load(PageAddress rawId);
    public virtual string ToString();
}
internal interface LiteDB.Engine.IStreamFactory {
    public string Name { get; }
    public bool CloseOnDispose { get; }
    public abstract virtual string get_Name();
    public abstract virtual Stream GetStream(bool canWrite, bool sequencial);
    public abstract virtual long GetLength();
    public abstract virtual bool Exists();
    public abstract virtual void Delete();
    public abstract virtual bool IsLocked();
    public abstract virtual bool get_CloseOnDispose();
}
public class LiteDB.Engine.LiteEngine : object {
    private static ArrayPool`1<byte> _bufferPool;
    private LockService _locker;
    private DiskService _disk;
    private WalIndexService _walIndex;
    private HeaderPage _header;
    private TransactionMonitor _monitor;
    private SortDisk _sortDisk;
    private EngineState _state;
    private EngineSettings _settings;
    private Dictionary`2<string, SystemCollection> _systemCollections;
    private ConcurrentDictionary`2<string, long> _sequences;
    public LiteEngine(string filename);
    public LiteEngine(EngineSettings settings);
    private static LiteEngine();
    public IEnumerable`1<string> GetCollectionNames();
    public sealed virtual bool DropCollection(string name);
    public sealed virtual bool RenameCollection(string collection, string newName);
    public sealed virtual int Delete(string collection, IEnumerable`1<BsonValue> ids);
    public sealed virtual int DeleteMany(string collection, BsonExpression predicate);
    public sealed virtual bool EnsureIndex(string collection, string name, BsonExpression expression, bool unique);
    public sealed virtual bool DropIndex(string collection, string name);
    public sealed virtual int Insert(string collection, IEnumerable`1<BsonDocument> docs, BsonAutoId autoId);
    private void InsertDocument(Snapshot snapshot, BsonDocument doc, BsonAutoId autoId, IndexService indexer, DataService data);
    public sealed virtual BsonValue Pragma(string name);
    public sealed virtual bool Pragma(string name, BsonValue value);
    public sealed virtual IBsonDataReader Query(string collection, Query query);
    public sealed virtual long Rebuild(RebuildOptions options);
    public long Rebuild();
    internal void RebuildContent(IFileReader reader);
    private void Recovery(Collation collation);
    private BsonValue GetSequence(Snapshot snapshot, BsonAutoId autoId);
    private void SetSequence(Snapshot snapshot, BsonValue newId);
    private BsonValue GetLastId(Snapshot snapshot);
    internal SystemCollection GetSystemCollection(string name);
    internal void RegisterSystemCollection(SystemCollection systemCollection);
    internal void RegisterSystemCollection(string collectionName, Func`1<IEnumerable`1<BsonDocument>> factory);
    public sealed virtual bool BeginTrans();
    public sealed virtual bool Commit();
    public sealed virtual bool Rollback();
    private T AutoTransaction(Func`2<TransactionService, T> fn);
    private void CommitAndReleaseTransaction(TransactionService transaction);
    public sealed virtual int Update(string collection, IEnumerable`1<BsonDocument> docs);
    public sealed virtual int UpdateMany(string collection, BsonExpression transform, BsonExpression predicate);
    private bool UpdateDocument(Snapshot snapshot, CollectionPage col, BsonDocument doc, IndexService indexer, DataService data);
    private void TryUpgrade();
    [ObsoleteAttribute("Upgrade your LiteDB v4 datafiles using Upgrade=true in EngineSettings. You can use upgrade=true in connection string.")]
public static bool Upgrade(string filename, string password, Collation collation);
    public sealed virtual int Upsert(string collection, IEnumerable`1<BsonDocument> docs, BsonAutoId autoId);
    internal bool Open();
    internal List`1<Exception> Close();
    internal List`1<Exception> Close(Exception ex);
    public sealed virtual int Checkpoint();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void InitializeSystemCollections();
    [IteratorStateMachineAttribute("LiteDB.Engine.LiteEngine/<SysCols>d__54")]
private IEnumerable`1<BsonDocument> SysCols();
    [IteratorStateMachineAttribute("LiteDB.Engine.LiteEngine/<SysDatabase>d__55")]
private IEnumerable`1<BsonDocument> SysDatabase();
    [IteratorStateMachineAttribute("LiteDB.Engine.LiteEngine/<SysIndexes>d__56")]
private IEnumerable`1<BsonDocument> SysIndexes();
    [IteratorStateMachineAttribute("LiteDB.Engine.LiteEngine/<SysOpenCursors>d__57")]
private IEnumerable`1<BsonDocument> SysOpenCursors();
    [IteratorStateMachineAttribute("LiteDB.Engine.LiteEngine/<SysSequences>d__58")]
private IEnumerable`1<BsonDocument> SysSequences();
    [IteratorStateMachineAttribute("LiteDB.Engine.LiteEngine/<SysSnapshots>d__59")]
private IEnumerable`1<BsonDocument> SysSnapshots();
    [IteratorStateMachineAttribute("LiteDB.Engine.LiteEngine/<SysTransactions>d__60")]
private IEnumerable`1<BsonDocument> SysTransactions();
    [CompilerGeneratedAttribute]
private void <Close>b__48_0();
    [CompilerGeneratedAttribute]
private void <Close>b__48_1();
    [CompilerGeneratedAttribute]
private void <Close>b__48_2();
    [CompilerGeneratedAttribute]
private void <Close>b__48_3();
    [CompilerGeneratedAttribute]
private void <Close>b__48_4();
    [CompilerGeneratedAttribute]
private void <Close>b__49_0();
    [CompilerGeneratedAttribute]
private void <Close>b__49_1();
    [CompilerGeneratedAttribute]
private void <Close>b__49_2();
    [CompilerGeneratedAttribute]
private void <Close>b__49_3();
    [CompilerGeneratedAttribute]
private void <Close>b__49_4();
    [CompilerGeneratedAttribute]
private IEnumerable`1<BsonDocument> <InitializeSystemCollections>b__53_0();
    [CompilerGeneratedAttribute]
private IEnumerable`1<BsonDocument> <InitializeSystemCollections>b__53_1();
    [CompilerGeneratedAttribute]
private IEnumerable`1<BsonDocument> <InitializeSystemCollections>b__53_2();
    [CompilerGeneratedAttribute]
private IEnumerable`1<BsonDocument> <InitializeSystemCollections>b__53_3();
    [CompilerGeneratedAttribute]
private IEnumerable`1<BsonDocument> <InitializeSystemCollections>b__53_4();
    [CompilerGeneratedAttribute]
private IEnumerable`1<BsonDocument> <InitializeSystemCollections>b__53_5();
    [CompilerGeneratedAttribute]
private IEnumerable`1<BsonDocument> <InitializeSystemCollections>b__53_6();
}
internal enum LiteDB.Engine.LockMode : Enum {
    public int value__;
    public static LockMode Read;
    public static LockMode Write;
}
internal class LiteDB.Engine.LockService : object {
    private EnginePragmas _pragmas;
    private ReaderWriterLockSlim _transaction;
    private ConcurrentDictionary`2<string, object> _collections;
    public bool IsInTransaction { get; }
    public int TransactionsCount { get; }
    internal LockService(EnginePragmas pragmas);
    public bool get_IsInTransaction();
    public int get_TransactionsCount();
    public void EnterTransaction();
    public void ExitTransaction();
    public void EnterLock(string collectionName);
    public void ExitLock(string collectionName);
    public bool EnterExclusive();
    public bool TryEnterExclusive(Boolean& mustExit);
    public void ExitExclusive();
    public sealed virtual void Dispose();
}
internal class LiteDB.Engine.MemoryCache : object {
    private ConcurrentQueue`1<PageBuffer> _free;
    private ConcurrentDictionary`2<long, PageBuffer> _readable;
    private int _extends;
    private Int32[] _segmentSizes;
    public int PagesInUse { get; }
    public int FreePages { get; }
    public int ExtendSegments { get; }
    public int ExtendPages { get; }
    public int WritablePages { get; }
    public MemoryCache(Int32[] memorySegmentSizes);
    public PageBuffer GetReadablePage(long position, FileOrigin origin, Action`2<long, BufferSlice> factory);
    private long GetReadableKey(long position, FileOrigin origin);
    public PageBuffer GetWritablePage(long position, FileOrigin origin, Action`2<long, BufferSlice> factory);
    public PageBuffer NewPage();
    private PageBuffer NewPage(long position, FileOrigin origin);
    public bool TryMoveToReadable(PageBuffer page);
    public PageBuffer MoveToReadable(PageBuffer page);
    public void DiscardPage(PageBuffer page);
    private PageBuffer GetFreePage();
    private void Extend();
    public int get_PagesInUse();
    public int get_FreePages();
    public int get_ExtendSegments();
    public int get_ExtendPages();
    public int get_WritablePages();
    public ICollection`1<PageBuffer> GetPages();
    public int Clear();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private int <get_ExtendPages>b__22_0(int x);
}
internal class LiteDB.Engine.OrderBy : object {
    [CompilerGeneratedAttribute]
private BsonExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    public BsonExpression Expression { get; }
    public int Order { get; public set; }
    public OrderBy(BsonExpression expression, int order);
    [CompilerGeneratedAttribute]
public BsonExpression get_Expression();
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(int value);
}
[DebuggerStepThroughAttribute]
internal class LiteDB.Engine.PageAddress : ValueType {
    public static int SIZE;
    public static PageAddress Empty;
    public UInt32 PageID;
    public byte Index;
    public bool IsEmpty { get; }
    public PageAddress(UInt32 pageID, byte index);
    private static PageAddress();
    public bool get_IsEmpty();
    public virtual bool Equals(object obj);
    public static bool op_Equality(PageAddress lhs, PageAddress rhs);
    public static bool op_Inequality(PageAddress lhs, PageAddress rhs);
    public virtual int GetHashCode();
    public virtual string ToString();
    public BsonValue ToBsonValue();
}
internal class LiteDB.Engine.PageBuffer : BufferSlice {
    public int UniqueID;
    public long Position;
    public FileOrigin Origin;
    public int ShareCounter;
    public long Timestamp;
    public PageBuffer(Byte[] buffer, int offset, int uniqueID);
    public void Release();
    public virtual string ToString();
    public bool IsBlank();
}
internal class LiteDB.Engine.PagePosition : ValueType {
    public UInt32 PageID;
    public long Position;
    public static PagePosition Empty { get; }
    public bool IsEmpty { get; }
    public PagePosition(UInt32 pageID, long position);
    public static PagePosition get_Empty();
    public bool get_IsEmpty();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal enum LiteDB.Engine.PageType : Enum {
    public int value__;
    public static PageType Empty;
    public static PageType Header;
    public static PageType Collection;
    public static PageType Index;
    public static PageType Data;
}
internal class LiteDB.Engine.Pragma : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<BsonValue> <Get>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<BsonValue> <Set>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<BufferSlice> <Read>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<BsonValue, HeaderPage> <Validate>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<BufferSlice> <Write>k__BackingField;
    public string Name { get; public set; }
    public Func`1<BsonValue> Get { get; public set; }
    public Action`1<BsonValue> Set { get; public set; }
    public Action`1<BufferSlice> Read { get; public set; }
    public Action`2<BsonValue, HeaderPage> Validate { get; public set; }
    public Action`1<BufferSlice> Write { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Func`1<BsonValue> get_Get();
    [CompilerGeneratedAttribute]
public void set_Get(Func`1<BsonValue> value);
    [CompilerGeneratedAttribute]
public Action`1<BsonValue> get_Set();
    [CompilerGeneratedAttribute]
public void set_Set(Action`1<BsonValue> value);
    [CompilerGeneratedAttribute]
public Action`1<BufferSlice> get_Read();
    [CompilerGeneratedAttribute]
public void set_Read(Action`1<BufferSlice> value);
    [CompilerGeneratedAttribute]
public Action`2<BsonValue, HeaderPage> get_Validate();
    [CompilerGeneratedAttribute]
public void set_Validate(Action`2<BsonValue, HeaderPage> value);
    [CompilerGeneratedAttribute]
public Action`1<BufferSlice> get_Write();
    [CompilerGeneratedAttribute]
public void set_Write(Action`1<BufferSlice> value);
}
public static class LiteDB.Engine.Pragmas : object {
    public static string USER_VERSION;
    public static string COLLATION;
    public static string TIMEOUT;
    public static string LIMIT_SIZE;
    public static string UTC_DATE;
    public static string CHECKPOINT;
}
internal class LiteDB.Engine.QueryExecutor : object {
    private LiteEngine _engine;
    private EngineState _state;
    private TransactionMonitor _monitor;
    private SortDisk _sortDisk;
    private DiskService _disk;
    private EnginePragmas _pragmas;
    private CursorInfo _cursor;
    private string _collection;
    private Query _query;
    private IEnumerable`1<BsonDocument> _source;
    public QueryExecutor(LiteEngine engine, EngineState state, TransactionMonitor monitor, SortDisk sortDisk, DiskService disk, EnginePragmas pragmas, string collection, Query query, IEnumerable`1<BsonDocument> source);
    public BsonDataReader ExecuteQuery();
    internal BsonDataReader ExecuteQuery(bool executionPlan);
    internal BsonDataReader ExecuteQueryInto(string into, BsonAutoId autoId);
    [IteratorStateMachineAttribute("LiteDB.Engine.QueryExecutor/<<ExecuteQueryInto>g__GetResultset|13_0>d")]
[CompilerGeneratedAttribute]
private IEnumerable`1<BsonDocument> <ExecuteQueryInto>g__GetResultset|13_0();
}
internal class LiteDB.Engine.QueryOptimization : object {
    private Snapshot _snapshot;
    private Query _query;
    private Collation _collation;
    private QueryPlan _queryPlan;
    private List`1<BsonExpression> _terms;
    public QueryOptimization(Snapshot snapshot, Query query, IEnumerable`1<BsonDocument> source, Collation collation);
    public QueryPlan ProcessQuery();
    private void SplitWherePredicateInTerms();
    private void OptimizeTerms();
    private void DefineQueryFields();
    private void DefineIndex();
    private IndexCost ChooseIndex(HashSet`1<string> fields);
    private void DefineOrderBy();
    private void DefineGroupBy();
    private void DefineIncludes();
    [CompilerGeneratedAttribute]
private void <SplitWherePredicateInTerms>g__add|7_0(BsonExpression predicate);
}
internal class LiteDB.Engine.QueryPipe : BasePipe {
    public QueryPipe(TransactionService transaction, IDocumentLookup loader, SortDisk tempDisk, EnginePragmas pragmas, UInt32 maxItemsCount);
    public virtual IEnumerable`1<BsonDocument> Pipe(IEnumerable`1<IndexNode> nodes, QueryPlan query);
    [IteratorStateMachineAttribute("LiteDB.Engine.QueryPipe/<Select>d__2")]
private IEnumerable`1<BsonDocument> Select(IEnumerable`1<BsonDocument> source, BsonExpression select);
    [IteratorStateMachineAttribute("LiteDB.Engine.QueryPipe/<SelectAll>d__3")]
private IEnumerable`1<BsonDocument> SelectAll(IEnumerable`1<BsonDocument> source, BsonExpression select);
}
internal class LiteDB.Engine.QueryPlan : object {
    [CompilerGeneratedAttribute]
private string <Collection>k__BackingField;
    [CompilerGeneratedAttribute]
private Index <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <IndexCost>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIndexKeyOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BsonExpression> <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BsonExpression> <IncludeBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BsonExpression> <IncludeAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderBy <OrderBy>k__BackingField;
    [CompilerGeneratedAttribute]
private GroupBy <GroupBy>k__BackingField;
    [CompilerGeneratedAttribute]
private Select <Select>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Fields>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Limit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForUpdate>k__BackingField;
    public string Collection { get; public set; }
    public Index Index { get; public set; }
    public string IndexExpression { get; public set; }
    public UInt32 IndexCost { get; internal set; }
    public bool IsIndexKeyOnly { get; public set; }
    public List`1<BsonExpression> Filters { get; public set; }
    public List`1<BsonExpression> IncludeBefore { get; public set; }
    public List`1<BsonExpression> IncludeAfter { get; public set; }
    public OrderBy OrderBy { get; public set; }
    public GroupBy GroupBy { get; public set; }
    public Select Select { get; public set; }
    public HashSet`1<string> Fields { get; public set; }
    public int Limit { get; public set; }
    public int Offset { get; public set; }
    public bool ForUpdate { get; public set; }
    public QueryPlan(string collection);
    [CompilerGeneratedAttribute]
public string get_Collection();
    [CompilerGeneratedAttribute]
public void set_Collection(string value);
    [CompilerGeneratedAttribute]
public Index get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(Index value);
    [CompilerGeneratedAttribute]
public string get_IndexExpression();
    [CompilerGeneratedAttribute]
public void set_IndexExpression(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_IndexCost();
    [CompilerGeneratedAttribute]
internal void set_IndexCost(UInt32 value);
    [CompilerGeneratedAttribute]
public bool get_IsIndexKeyOnly();
    [CompilerGeneratedAttribute]
public void set_IsIndexKeyOnly(bool value);
    [CompilerGeneratedAttribute]
public List`1<BsonExpression> get_Filters();
    [CompilerGeneratedAttribute]
public void set_Filters(List`1<BsonExpression> value);
    [CompilerGeneratedAttribute]
public List`1<BsonExpression> get_IncludeBefore();
    [CompilerGeneratedAttribute]
public void set_IncludeBefore(List`1<BsonExpression> value);
    [CompilerGeneratedAttribute]
public List`1<BsonExpression> get_IncludeAfter();
    [CompilerGeneratedAttribute]
public void set_IncludeAfter(List`1<BsonExpression> value);
    [CompilerGeneratedAttribute]
public OrderBy get_OrderBy();
    [CompilerGeneratedAttribute]
public void set_OrderBy(OrderBy value);
    [CompilerGeneratedAttribute]
public GroupBy get_GroupBy();
    [CompilerGeneratedAttribute]
public void set_GroupBy(GroupBy value);
    [CompilerGeneratedAttribute]
public Select get_Select();
    [CompilerGeneratedAttribute]
public void set_Select(Select value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_Fields();
    [CompilerGeneratedAttribute]
public void set_Fields(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public int get_Limit();
    [CompilerGeneratedAttribute]
public void set_Limit(int value);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(int value);
    [CompilerGeneratedAttribute]
public bool get_ForUpdate();
    [CompilerGeneratedAttribute]
public void set_ForUpdate(bool value);
    public BasePipe GetPipe(TransactionService transaction, Snapshot snapshot, SortDisk tempDisk, EnginePragmas pragmas, UInt32 maxItemsCount);
    public IDocumentLookup GetLookup(Snapshot snapshot, EnginePragmas pragmas, UInt32 maxItemsCount);
    public BsonDocument GetExecutionPlan();
}
public class LiteDB.Engine.RebuildOptions : object {
    private string _buildId;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private Collation <Collation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeErrorReport>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<FileReaderError> <Errors>k__BackingField;
    public string Password { get; public set; }
    public Collation Collation { get; public set; }
    public bool IncludeErrorReport { get; public set; }
    internal IList`1<FileReaderError> Errors { get; }
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public Collation get_Collation();
    [CompilerGeneratedAttribute]
public void set_Collation(Collation value);
    [CompilerGeneratedAttribute]
public bool get_IncludeErrorReport();
    [CompilerGeneratedAttribute]
public void set_IncludeErrorReport(bool value);
    [CompilerGeneratedAttribute]
internal IList`1<FileReaderError> get_Errors();
    public IEnumerable`1<BsonDocument> GetErrorReport();
    [CompilerGeneratedAttribute]
private BsonDocument <GetErrorReport>b__16_0(FileReaderError x);
}
internal class LiteDB.Engine.RebuildService : object {
    private EngineSettings _settings;
    private int _fileVersion;
    public RebuildService(EngineSettings settings);
    public long Rebuild(RebuildOptions options);
    private Byte[] ReadFirstBytes(bool useAesStream);
}
internal class LiteDB.Engine.Select : object {
    [CompilerGeneratedAttribute]
private BsonExpression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <All>k__BackingField;
    public BsonExpression Expression { get; }
    public bool All { get; }
    public Select(BsonExpression expression, bool all);
    [CompilerGeneratedAttribute]
public BsonExpression get_Expression();
    [CompilerGeneratedAttribute]
public bool get_All();
}
internal class LiteDB.Engine.Snapshot : object {
    private HeaderPage _header;
    private LockService _locker;
    private DiskReader _reader;
    private DiskService _disk;
    private WalIndexService _walIndex;
    private UInt32 _transactionID;
    private TransactionPages _transPages;
    private int _readVersion;
    private LockMode _mode;
    private string _collectionName;
    private CollectionPage _collectionPage;
    private Dictionary`2<UInt32, BasePage> _localPages;
    private bool _disposed;
    public LockMode Mode { get; }
    public string CollectionName { get; }
    public CollectionPage CollectionPage { get; }
    public ICollection`1<BasePage> LocalPages { get; }
    public int ReadVersion { get; }
    public Snapshot(LockMode mode, string collectionName, HeaderPage header, UInt32 transactionID, TransactionPages transPages, LockService locker, WalIndexService walIndex, DiskReader reader, DiskService disk, bool addIfNotExists);
    public LockMode get_Mode();
    public string get_CollectionName();
    public CollectionPage get_CollectionPage();
    public ICollection`1<BasePage> get_LocalPages();
    public int get_ReadVersion();
    [IteratorStateMachineAttribute("LiteDB.Engine.Snapshot/<GetWritablePages>d__24")]
public IEnumerable`1<BasePage> GetWritablePages(bool dirty, bool includeCollectionPage);
    public void Clear();
    public sealed virtual void Dispose();
    public T GetPage(UInt32 pageID, bool useLatestVersion);
    public T GetPage(UInt32 pageID, FileOrigin& origin, Int64& position, Int32& walVersion, bool useLatestVersion);
    private T ReadPage(UInt32 pageID, FileOrigin& origin, Int64& position, Int32& walVersion, bool useLatestVersion);
    public DataPage GetFreeDataPage(int bytesLength);
    public IndexPage GetFreeIndexPage(int bytesLength, UInt32& freeIndexPageList);
    public T NewPage();
    public void AddOrRemoveFreeDataList(DataPage page);
    public void AddOrRemoveFreeIndexList(IndexPage page, UInt32& startPageID);
    private void AddFreeList(T page, UInt32& startPageID);
    private void RemoveFreeList(T page, UInt32& startPageID);
    private void DeletePage(T page);
    public void DropCollection(Action safePoint);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private void <DropCollection>b__38_0(HeaderPage h);
}
internal class LiteDB.Engine.SortContainer : object {
    private Collation _collation;
    private int _size;
    private int _remaining;
    private int _count;
    private bool _isEOF;
    private int _readPosition;
    private BufferReader _reader;
    private static ArrayPool`1<byte> _bufferPool;
    public KeyValuePair`2<BsonValue, PageAddress> Current;
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    public bool IsEOF { get; }
    public long Position { get; public set; }
    public int Count { get; }
    public SortContainer(Collation collation, int size);
    private static SortContainer();
    public bool get_IsEOF();
    [CompilerGeneratedAttribute]
public long get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(long value);
    public int get_Count();
    public void Insert(IEnumerable`1<KeyValuePair`2<BsonValue, PageAddress>> items, int order, BufferSlice buffer);
    public void InitializeReader(Stream stream, BufferSlice buffer, bool utcDate);
    public bool MoveNext();
    [IteratorStateMachineAttribute("LiteDB.Engine.SortContainer/<GetSourceFromStream>d__21")]
private IEnumerable`1<BufferSlice> GetSourceFromStream(Stream stream);
    public sealed virtual void Dispose();
}
internal class LiteDB.Engine.SortDisk : object {
    private IStreamFactory _factory;
    private StreamPool _pool;
    private ConcurrentBag`1<long> _freePositions;
    private long _lastContainerPosition;
    private int _containerSize;
    private EnginePragmas _pragmas;
    public int ContainerSize { get; }
    public SortDisk(IStreamFactory factory, int containerSize, EnginePragmas pragmas);
    public int get_ContainerSize();
    public Stream GetReader();
    public void Return(Stream stream);
    public void Return(long position);
    public long GetContainerPosition();
    public void Write(long position, BufferSlice buffer);
    public sealed virtual void Dispose();
}
internal class LiteDB.Engine.SortService : object {
    private SortDisk _disk;
    private List`1<SortContainer> _containers;
    private int _containerSize;
    private Done _done;
    private int _order;
    private EnginePragmas _pragmas;
    private BufferSlice _buffer;
    private Lazy`1<Stream> _reader;
    private static ArrayPool`1<byte> _bufferPool;
    public int Count { get; }
    public IReadOnlyCollection`1<SortContainer> Containers { get; }
    public SortService(SortDisk disk, int order, EnginePragmas pragmas);
    private static SortService();
    public int get_Count();
    public IReadOnlyCollection`1<SortContainer> get_Containers();
    public sealed virtual void Dispose();
    public void Insert(IEnumerable`1<KeyValuePair`2<BsonValue, PageAddress>> items);
    [IteratorStateMachineAttribute("LiteDB.Engine.SortService/<Sort>d__16")]
public IEnumerable`1<KeyValuePair`2<BsonValue, PageAddress>> Sort();
    [IteratorStateMachineAttribute("LiteDB.Engine.SortService/<SliptValues>d__17")]
private IEnumerable`1<IEnumerable`1<KeyValuePair`2<BsonValue, PageAddress>>> SliptValues(IEnumerable`1<KeyValuePair`2<BsonValue, PageAddress>> source, Done done);
    [IteratorStateMachineAttribute("LiteDB.Engine.SortService/<YieldValues>d__18")]
private IEnumerable`1<KeyValuePair`2<BsonValue, PageAddress>> YieldValues(IEnumerator`1<KeyValuePair`2<BsonValue, PageAddress>> source, Done done);
    [CompilerGeneratedAttribute]
private Stream <.ctor>b__13_0();
}
internal class LiteDB.Engine.StreamFactory : object {
    private Stream _stream;
    private string _password;
    public string Name { get; }
    public bool CloseOnDispose { get; }
    public StreamFactory(Stream stream, string password);
    public sealed virtual string get_Name();
    public sealed virtual Stream GetStream(bool canWrite, bool sequencial);
    public sealed virtual long GetLength();
    public sealed virtual bool Exists();
    public sealed virtual void Delete();
    public sealed virtual bool IsLocked();
    public sealed virtual bool get_CloseOnDispose();
}
internal class LiteDB.Engine.StreamPool : object {
    private ConcurrentBag`1<Stream> _pool;
    private Lazy`1<Stream> _writer;
    private IStreamFactory _factory;
    public Lazy`1<Stream> Writer { get; }
    public StreamPool(IStreamFactory factory, bool appendOnly);
    public Lazy`1<Stream> get_Writer();
    public Stream Rent();
    public void Return(Stream stream);
    public sealed virtual void Dispose();
}
internal class LiteDB.Engine.SysDump : SystemCollection {
    private HeaderPage _header;
    private TransactionMonitor _monitor;
    public SysDump(HeaderPage header, TransactionMonitor monitor);
    public virtual IEnumerable`1<BsonDocument> Input(BsonValue options);
    [IteratorStateMachineAttribute("LiteDB.Engine.SysDump/<DumpPages>d__4")]
private IEnumerable`1<BsonDocument> DumpPages(Nullable`1<UInt32> pageID);
}
internal class LiteDB.Engine.SysFile : SystemCollection {
    private Dictionary`2<string, SystemCollection> _formats;
    public virtual IEnumerable`1<BsonDocument> Input(BsonValue options);
    public virtual int Output(IEnumerable`1<BsonDocument> source, BsonValue options);
    private string GetFormat(BsonValue options);
}
internal class LiteDB.Engine.SysFileCsv : SystemCollection {
    private static IFormatProvider _numberFormat;
    private static SysFileCsv();
    [IteratorStateMachineAttribute("LiteDB.Engine.SysFileCsv/<Input>d__2")]
public virtual IEnumerable`1<BsonDocument> Input(BsonValue options);
    public virtual int Output(IEnumerable`1<BsonDocument> source, BsonValue options);
    private void WriteValue(BsonValue value, StreamWriter writer);
    private string ReadString(TextReader reader, char delimiter, Boolean& newLine);
}
internal class LiteDB.Engine.SysFileJson : SystemCollection {
    [IteratorStateMachineAttribute("LiteDB.Engine.SysFileJson/<Input>d__1")]
public virtual IEnumerable`1<BsonDocument> Input(BsonValue options);
    public virtual int Output(IEnumerable`1<BsonDocument> source, BsonValue options);
}
internal class LiteDB.Engine.SysPageList : SystemCollection {
    private HeaderPage _header;
    private TransactionMonitor _monitor;
    private Dictionary`2<UInt32, string> _collections;
    public SysPageList(HeaderPage header, TransactionMonitor monitor);
    [IteratorStateMachineAttribute("LiteDB.Engine.SysPageList/<Input>d__4")]
public virtual IEnumerable`1<BsonDocument> Input(BsonValue options);
    [IteratorStateMachineAttribute("LiteDB.Engine.SysPageList/<GetAllList>d__5")]
private IEnumerable`1<BsonDocument> GetAllList(TransactionService transaction, Snapshot snapshot);
    [IteratorStateMachineAttribute("LiteDB.Engine.SysPageList/<GetList>d__6")]
private IEnumerable`1<BsonDocument> GetList(UInt32 pageID, string indexName, TransactionService transaction, Snapshot snapshot);
}
internal class LiteDB.Engine.SysQuery : SystemCollection {
    private ILiteEngine _engine;
    public SysQuery(ILiteEngine engine);
    [IteratorStateMachineAttribute("LiteDB.Engine.SysQuery/<Input>d__2")]
public virtual IEnumerable`1<BsonDocument> Input(BsonValue options);
}
internal class LiteDB.Engine.SystemCollection : object {
    private string _name;
    private Func`1<IEnumerable`1<BsonDocument>> _input;
    public string Name { get; }
    public SystemCollection(string name);
    public SystemCollection(string name, Func`1<IEnumerable`1<BsonDocument>> input);
    public string get_Name();
    public virtual IEnumerable`1<BsonDocument> Input(BsonValue options);
    public virtual int Output(IEnumerable`1<BsonDocument> source, BsonValue options);
    protected static BsonValue GetOption(BsonValue options, string key);
    protected static BsonValue GetOption(BsonValue options, string key, BsonValue defaultValue);
}
public class LiteDB.Engine.TempStream : Stream {
    private Stream _stream;
    private string _filename;
    private long _maxMemoryUsage;
    public bool InMemory { get; }
    public bool InDisk { get; }
    public string Filename { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public TempStream(string filename, long maxMemoryUsage);
    public bool get_InMemory();
    public bool get_InDisk();
    public string get_Filename();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    protected virtual void Dispose(bool disposing);
}
internal class LiteDB.Engine.TransactionMonitor : object {
    private Dictionary`2<UInt32, TransactionService> _transactions;
    private ThreadLocal`1<TransactionService> _slot;
    private HeaderPage _header;
    private LockService _locker;
    private DiskService _disk;
    private WalIndexService _walIndex;
    private int _freePages;
    private int _initialSize;
    public ICollection`1<TransactionService> Transactions { get; }
    public int FreePages { get; }
    public int InitialSize { get; }
    public TransactionMonitor(HeaderPage header, LockService locker, DiskService disk, WalIndexService walIndex);
    public ICollection`1<TransactionService> get_Transactions();
    public int get_FreePages();
    public int get_InitialSize();
    public TransactionService GetTransaction(bool create, bool queryOnly, Boolean& isNew);
    public void ReleaseTransaction(TransactionService transaction);
    public TransactionService GetThreadTransaction();
    private int GetInitialSize();
    private bool TryExtend(TransactionService trans);
    public bool CheckSafepoint(TransactionService trans);
    public sealed virtual void Dispose();
}
internal class LiteDB.Engine.TransactionPages : object {
    [CompilerGeneratedAttribute]
private int <TransactionSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<UInt32, PagePosition> <DirtyPages>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<UInt32> <NewPages>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <FirstDeletedPageID>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LastDeletedPageID>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DeletedPages>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<HeaderPage> Commit;
    public int TransactionSize { get; public set; }
    public Dictionary`2<UInt32, PagePosition> DirtyPages { get; }
    public List`1<UInt32> NewPages { get; }
    public UInt32 FirstDeletedPageID { get; public set; }
    public UInt32 LastDeletedPageID { get; public set; }
    public int DeletedPages { get; public set; }
    public bool HeaderChanged { get; }
    [CompilerGeneratedAttribute]
public int get_TransactionSize();
    [CompilerGeneratedAttribute]
public void set_TransactionSize(int value);
    [CompilerGeneratedAttribute]
public Dictionary`2<UInt32, PagePosition> get_DirtyPages();
    [CompilerGeneratedAttribute]
public List`1<UInt32> get_NewPages();
    [CompilerGeneratedAttribute]
public UInt32 get_FirstDeletedPageID();
    [CompilerGeneratedAttribute]
public void set_FirstDeletedPageID(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_LastDeletedPageID();
    [CompilerGeneratedAttribute]
public void set_LastDeletedPageID(UInt32 value);
    [CompilerGeneratedAttribute]
public int get_DeletedPages();
    [CompilerGeneratedAttribute]
public void set_DeletedPages(int value);
    [CompilerGeneratedAttribute]
public void add_Commit(Action`1<HeaderPage> value);
    [CompilerGeneratedAttribute]
public void remove_Commit(Action`1<HeaderPage> value);
    public void OnCommit(HeaderPage header);
    public bool get_HeaderChanged();
}
internal class LiteDB.Engine.TransactionService : object {
    private HeaderPage _header;
    private LockService _locker;
    private DiskService _disk;
    private DiskReader _reader;
    private WalIndexService _walIndex;
    private TransactionMonitor _monitor;
    private Dictionary`2<string, Snapshot> _snapshots;
    private TransactionPages _transPages;
    private int _threadID;
    private UInt32 _transactionID;
    private DateTime _startTime;
    private LockMode _mode;
    private TransactionState _state;
    [CompilerGeneratedAttribute]
private bool <QueryOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTransactionSize>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CursorInfo> <OpenCursors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExplicitTransaction>k__BackingField;
    public int ThreadID { get; }
    public UInt32 TransactionID { get; }
    public TransactionState State { get; }
    public LockMode Mode { get; }
    public TransactionPages Pages { get; }
    public DateTime StartTime { get; }
    public IEnumerable`1<Snapshot> Snapshots { get; }
    public bool QueryOnly { get; }
    public int MaxTransactionSize { get; public set; }
    public List`1<CursorInfo> OpenCursors { get; }
    public bool ExplicitTransaction { get; public set; }
    public TransactionService(HeaderPage header, LockService locker, DiskService disk, WalIndexService walIndex, int maxTransactionSize, TransactionMonitor monitor, bool queryOnly);
    public int get_ThreadID();
    public UInt32 get_TransactionID();
    public TransactionState get_State();
    public LockMode get_Mode();
    public TransactionPages get_Pages();
    public DateTime get_StartTime();
    public IEnumerable`1<Snapshot> get_Snapshots();
    [CompilerGeneratedAttribute]
public bool get_QueryOnly();
    [CompilerGeneratedAttribute]
public int get_MaxTransactionSize();
    [CompilerGeneratedAttribute]
public void set_MaxTransactionSize(int value);
    [CompilerGeneratedAttribute]
public List`1<CursorInfo> get_OpenCursors();
    [CompilerGeneratedAttribute]
public bool get_ExplicitTransaction();
    [CompilerGeneratedAttribute]
public void set_ExplicitTransaction(bool value);
    protected virtual override void Finalize();
    public Snapshot CreateSnapshot(LockMode mode, string collection, bool addIfNotExists);
    public void Safepoint();
    private int PersistDirtyPages(bool commit);
    public void Commit();
    public void Rollback();
    private void ReturnNewPages();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool dispose);
    [CompilerGeneratedAttribute]
private Snapshot <CreateSnapshot>g__create|43_0(<>c__DisplayClass43_0& );
}
internal enum LiteDB.Engine.TransactionState : Enum {
    public int value__;
    public static TransactionState Active;
    public static TransactionState Committed;
    public static TransactionState Aborted;
    public static TransactionState Disposed;
}
internal class LiteDB.Engine.WalIndexService : object {
    private DiskService _disk;
    private LockService _locker;
    private Dictionary`2<UInt32, List`1<KeyValuePair`2<int, long>>> _index;
    private ReaderWriterLockSlim _indexLock;
    private HashSet`1<UInt32> _confirmTransactions;
    private int _currentReadVersion;
    private int _lastTransactionID;
    public int CurrentReadVersion { get; }
    public int LastTransactionID { get; }
    public WalIndexService(DiskService disk, LockService locker);
    public int get_CurrentReadVersion();
    public int get_LastTransactionID();
    public void Clear();
    public UInt32 NextTransactionID();
    public long GetPageIndex(UInt32 pageID, int version, Int32& walVersion);
    public void ConfirmTransaction(UInt32 transactionID, ICollection`1<PagePosition> pagePositions);
    public void RestoreIndex(HeaderPage& header);
    public int Checkpoint();
    public int TryCheckpoint();
    private int CheckpointInternal();
}
public class LiteDB.EntityBuilder`1 : object {
    private BsonMapper _mapper;
    private EntityMapper _entity;
    private ITypeNameBinder _typeNameBinder;
    internal EntityBuilder`1(BsonMapper mapper, ITypeNameBinder typeNameBinder);
    public EntityBuilder`1<T> Ignore(Expression`1<Func`2<T, K>> member);
    public EntityBuilder`1<T> Field(Expression`1<Func`2<T, K>> member, string field);
    public EntityBuilder`1<T> Id(Expression`1<Func`2<T, K>> member, bool autoId);
    public EntityBuilder`1<T> Ctor(Func`2<BsonDocument, T> createInstance);
    public EntityBuilder`1<T> DbRef(Expression`1<Func`2<T, K>> member, string collection);
    private EntityBuilder`1<T> GetMember(Expression`1<Func`2<TK, K>> member, Action`1<MemberMapper> action);
    [CompilerGeneratedAttribute]
private void <Ignore>b__4_0(MemberMapper p);
}
public class LiteDB.EntityMapper : object {
    [CompilerGeneratedAttribute]
private Type <ForType>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<MemberMapper> <Members>k__BackingField;
    [CompilerGeneratedAttribute]
private CreateObject <CreateInstance>k__BackingField;
    public Type ForType { get; }
    public List`1<MemberMapper> Members { get; }
    public MemberMapper Id { get; }
    public CreateObject CreateInstance { get; public set; }
    public EntityMapper(Type forType);
    [CompilerGeneratedAttribute]
public Type get_ForType();
    [CompilerGeneratedAttribute]
public List`1<MemberMapper> get_Members();
    public MemberMapper get_Id();
    [CompilerGeneratedAttribute]
public CreateObject get_CreateInstance();
    [CompilerGeneratedAttribute]
public void set_CreateInstance(CreateObject value);
    public MemberMapper GetMember(Expression expr);
}
internal class LiteDB.EnumerableResolver : object {
    public virtual string ResolveMethod(MethodInfo method);
    public virtual string ResolveMember(MemberInfo member);
    public sealed virtual string ResolveCtor(ConstructorInfo ctor);
}
internal class LiteDB.ExpressionContext : object {
    [CompilerGeneratedAttribute]
private ParameterExpression <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterExpression <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterExpression <Current>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterExpression <Collation>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterExpression <Parameters>k__BackingField;
    public ParameterExpression Source { get; }
    public ParameterExpression Root { get; }
    public ParameterExpression Current { get; }
    public ParameterExpression Collation { get; }
    public ParameterExpression Parameters { get; }
    [CompilerGeneratedAttribute]
public ParameterExpression get_Source();
    [CompilerGeneratedAttribute]
public ParameterExpression get_Root();
    [CompilerGeneratedAttribute]
public ParameterExpression get_Current();
    [CompilerGeneratedAttribute]
public ParameterExpression get_Collation();
    [CompilerGeneratedAttribute]
public ParameterExpression get_Parameters();
}
[ExtensionAttribute]
internal static class LiteDB.ExpressionExtensions : object {
    private static Regex _removeSelect;
    private static Regex _removeList;
    private static Regex _removeArray;
    private static ExpressionExtensions();
    [ExtensionAttribute]
public static string GetPath(Expression expr);
}
internal static class LiteDB.ExtendedLengthHelper : object {
    public static void ReadLength(byte typeByte, byte lengthByte, BsonType& type, UInt16& length);
    public static void WriteLength(BsonType type, ushort length, Byte& typeByte, Byte& lengthByte);
}
internal static class LiteDB.FileHelper : object {
    public static string GetSuffixFile(string filename, string suffix, bool checkIfExists);
    public static string GetLogFile(string filename);
    public static string GetTempFile(string filename);
    public static bool IsFileLocked(string filename);
    public static bool TryExec(int timeout, Action action);
    public static void Exec(int timeout, Action action);
    public static long ParseFileSize(string size);
    public static string FormatFileSize(long byteCount);
}
public class LiteDB.GenericGetter : MulticastDelegate {
    public GenericGetter(object object, IntPtr method);
    public virtual object Invoke(object obj);
    public virtual IAsyncResult BeginInvoke(object obj, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class LiteDB.GenericSetter : MulticastDelegate {
    public GenericSetter(object object, IntPtr method);
    public virtual void Invoke(object target, object value);
    public virtual IAsyncResult BeginInvoke(object target, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class LiteDB.GuidResolver : object {
    public sealed virtual string ResolveMethod(MethodInfo method);
    public sealed virtual string ResolveMember(MemberInfo member);
    public sealed virtual string ResolveCtor(ConstructorInfo ctor);
}
[ExtensionAttribute]
internal static class LiteDB.HashSetExtensions : object {
    [ExtensionAttribute]
public static HashSet`1<T> AddRange(HashSet`1<T> hash, IEnumerable`1<T> items);
}
[DefaultMemberAttribute("Item")]
public interface LiteDB.IBsonDataReader {
    public BsonValue Item { get; }
    public string Collection { get; }
    public BsonValue Current { get; }
    public bool HasValues { get; }
    public abstract virtual BsonValue get_Item(string field);
    public abstract virtual string get_Collection();
    public abstract virtual BsonValue get_Current();
    public abstract virtual bool get_HasValues();
    public abstract virtual bool Read();
}
internal class LiteDB.ICollectionResolver : EnumerableResolver {
    public virtual string ResolveMethod(MethodInfo method);
}
public interface LiteDB.ILiteCollection`1 {
    public string Name { get; }
    public BsonAutoId AutoId { get; }
    public EntityMapper EntityMapper { get; }
    public abstract virtual string get_Name();
    public abstract virtual BsonAutoId get_AutoId();
    public abstract virtual EntityMapper get_EntityMapper();
    public abstract virtual ILiteCollection`1<T> Include(Expression`1<Func`2<T, K>> keySelector);
    public abstract virtual ILiteCollection`1<T> Include(BsonExpression keySelector);
    public abstract virtual bool Upsert(T entity);
    public abstract virtual int Upsert(IEnumerable`1<T> entities);
    public abstract virtual bool Upsert(BsonValue id, T entity);
    public abstract virtual bool Update(T entity);
    public abstract virtual bool Update(BsonValue id, T entity);
    public abstract virtual int Update(IEnumerable`1<T> entities);
    public abstract virtual int UpdateMany(BsonExpression transform, BsonExpression predicate);
    public abstract virtual int UpdateMany(Expression`1<Func`2<T, T>> extend, Expression`1<Func`2<T, bool>> predicate);
    public abstract virtual BsonValue Insert(T entity);
    public abstract virtual void Insert(BsonValue id, T entity);
    public abstract virtual int Insert(IEnumerable`1<T> entities);
    public abstract virtual int InsertBulk(IEnumerable`1<T> entities, int batchSize);
    public abstract virtual bool EnsureIndex(string name, BsonExpression expression, bool unique);
    public abstract virtual bool EnsureIndex(BsonExpression expression, bool unique);
    public abstract virtual bool EnsureIndex(Expression`1<Func`2<T, K>> keySelector, bool unique);
    public abstract virtual bool EnsureIndex(string name, Expression`1<Func`2<T, K>> keySelector, bool unique);
    public abstract virtual bool DropIndex(string name);
    public abstract virtual ILiteQueryable`1<T> Query();
    public abstract virtual IEnumerable`1<T> Find(BsonExpression predicate, int skip, int limit);
    public abstract virtual IEnumerable`1<T> Find(Query query, int skip, int limit);
    public abstract virtual IEnumerable`1<T> Find(Expression`1<Func`2<T, bool>> predicate, int skip, int limit);
    public abstract virtual T FindById(BsonValue id);
    public abstract virtual T FindOne(BsonExpression predicate);
    public abstract virtual T FindOne(string predicate, BsonDocument parameters);
    public abstract virtual T FindOne(BsonExpression predicate, BsonValue[] args);
    public abstract virtual T FindOne(Expression`1<Func`2<T, bool>> predicate);
    public abstract virtual T FindOne(Query query);
    public abstract virtual IEnumerable`1<T> FindAll();
    public abstract virtual bool Delete(BsonValue id);
    public abstract virtual int DeleteAll();
    public abstract virtual int DeleteMany(BsonExpression predicate);
    public abstract virtual int DeleteMany(string predicate, BsonDocument parameters);
    public abstract virtual int DeleteMany(string predicate, BsonValue[] args);
    public abstract virtual int DeleteMany(Expression`1<Func`2<T, bool>> predicate);
    public abstract virtual int Count();
    public abstract virtual int Count(BsonExpression predicate);
    public abstract virtual int Count(string predicate, BsonDocument parameters);
    public abstract virtual int Count(string predicate, BsonValue[] args);
    public abstract virtual int Count(Expression`1<Func`2<T, bool>> predicate);
    public abstract virtual int Count(Query query);
    public abstract virtual long LongCount();
    public abstract virtual long LongCount(BsonExpression predicate);
    public abstract virtual long LongCount(string predicate, BsonDocument parameters);
    public abstract virtual long LongCount(string predicate, BsonValue[] args);
    public abstract virtual long LongCount(Expression`1<Func`2<T, bool>> predicate);
    public abstract virtual long LongCount(Query query);
    public abstract virtual bool Exists(BsonExpression predicate);
    public abstract virtual bool Exists(string predicate, BsonDocument parameters);
    public abstract virtual bool Exists(string predicate, BsonValue[] args);
    public abstract virtual bool Exists(Expression`1<Func`2<T, bool>> predicate);
    public abstract virtual bool Exists(Query query);
    public abstract virtual BsonValue Min(BsonExpression keySelector);
    public abstract virtual BsonValue Min();
    public abstract virtual K Min(Expression`1<Func`2<T, K>> keySelector);
    public abstract virtual BsonValue Max(BsonExpression keySelector);
    public abstract virtual BsonValue Max();
    public abstract virtual K Max(Expression`1<Func`2<T, K>> keySelector);
}
public interface LiteDB.ILiteDatabase {
    public BsonMapper Mapper { get; }
    public ILiteStorage`1<string> FileStorage { get; }
    public int UserVersion { get; public set; }
    public TimeSpan Timeout { get; public set; }
    public bool UtcDate { get; public set; }
    public long LimitSize { get; public set; }
    public int CheckpointSize { get; public set; }
    public Collation Collation { get; }
    public abstract virtual BsonMapper get_Mapper();
    public abstract virtual ILiteStorage`1<string> get_FileStorage();
    public abstract virtual ILiteCollection`1<T> GetCollection(string name, BsonAutoId autoId);
    public abstract virtual ILiteCollection`1<T> GetCollection();
    public abstract virtual ILiteCollection`1<T> GetCollection(BsonAutoId autoId);
    public abstract virtual ILiteCollection`1<BsonDocument> GetCollection(string name, BsonAutoId autoId);
    public abstract virtual bool BeginTrans();
    public abstract virtual bool Commit();
    public abstract virtual bool Rollback();
    public abstract virtual ILiteStorage`1<TFileId> GetStorage(string filesCollection, string chunksCollection);
    public abstract virtual IEnumerable`1<string> GetCollectionNames();
    public abstract virtual bool CollectionExists(string name);
    public abstract virtual bool DropCollection(string name);
    public abstract virtual bool RenameCollection(string oldName, string newName);
    public abstract virtual IBsonDataReader Execute(TextReader commandReader, BsonDocument parameters);
    public abstract virtual IBsonDataReader Execute(string command, BsonDocument parameters);
    public abstract virtual IBsonDataReader Execute(string command, BsonValue[] args);
    public abstract virtual void Checkpoint();
    public abstract virtual long Rebuild(RebuildOptions options);
    public abstract virtual BsonValue Pragma(string name);
    public abstract virtual BsonValue Pragma(string name, BsonValue value);
    public abstract virtual int get_UserVersion();
    public abstract virtual void set_UserVersion(int value);
    public abstract virtual TimeSpan get_Timeout();
    public abstract virtual void set_Timeout(TimeSpan value);
    public abstract virtual bool get_UtcDate();
    public abstract virtual void set_UtcDate(bool value);
    public abstract virtual long get_LimitSize();
    public abstract virtual void set_LimitSize(long value);
    public abstract virtual int get_CheckpointSize();
    public abstract virtual void set_CheckpointSize(int value);
    public abstract virtual Collation get_Collation();
}
public interface LiteDB.ILiteQueryable`1 {
    public abstract virtual ILiteQueryable`1<T> Include(BsonExpression path);
    public abstract virtual ILiteQueryable`1<T> Include(List`1<BsonExpression> paths);
    public abstract virtual ILiteQueryable`1<T> Include(Expression`1<Func`2<T, K>> path);
    public abstract virtual ILiteQueryable`1<T> Where(BsonExpression predicate);
    public abstract virtual ILiteQueryable`1<T> Where(string predicate, BsonDocument parameters);
    public abstract virtual ILiteQueryable`1<T> Where(string predicate, BsonValue[] args);
    public abstract virtual ILiteQueryable`1<T> Where(Expression`1<Func`2<T, bool>> predicate);
    public abstract virtual ILiteQueryable`1<T> OrderBy(BsonExpression keySelector, int order);
    public abstract virtual ILiteQueryable`1<T> OrderBy(Expression`1<Func`2<T, K>> keySelector, int order);
    public abstract virtual ILiteQueryable`1<T> OrderByDescending(BsonExpression keySelector);
    public abstract virtual ILiteQueryable`1<T> OrderByDescending(Expression`1<Func`2<T, K>> keySelector);
    public abstract virtual ILiteQueryable`1<T> GroupBy(BsonExpression keySelector);
    public abstract virtual ILiteQueryable`1<T> Having(BsonExpression predicate);
    public abstract virtual ILiteQueryableResult`1<BsonDocument> Select(BsonExpression selector);
    public abstract virtual ILiteQueryableResult`1<K> Select(Expression`1<Func`2<T, K>> selector);
}
public interface LiteDB.ILiteQueryableResult`1 {
    public abstract virtual ILiteQueryableResult`1<T> Limit(int limit);
    public abstract virtual ILiteQueryableResult`1<T> Skip(int offset);
    public abstract virtual ILiteQueryableResult`1<T> Offset(int offset);
    public abstract virtual ILiteQueryableResult`1<T> ForUpdate();
    public abstract virtual BsonDocument GetPlan();
    public abstract virtual IBsonDataReader ExecuteReader();
    public abstract virtual IEnumerable`1<BsonDocument> ToDocuments();
    public abstract virtual IEnumerable`1<T> ToEnumerable();
    public abstract virtual List`1<T> ToList();
    public abstract virtual T[] ToArray();
    public abstract virtual int Into(string newCollection, BsonAutoId autoId);
    public abstract virtual T First();
    public abstract virtual T FirstOrDefault();
    public abstract virtual T Single();
    public abstract virtual T SingleOrDefault();
    public abstract virtual int Count();
    public abstract virtual long LongCount();
    public abstract virtual bool Exists();
}
public interface LiteDB.ILiteRepository {
    public ILiteDatabase Database { get; }
    public abstract virtual ILiteDatabase get_Database();
    public abstract virtual BsonValue Insert(T entity, string collectionName);
    public abstract virtual int Insert(IEnumerable`1<T> entities, string collectionName);
    public abstract virtual bool Update(T entity, string collectionName);
    public abstract virtual int Update(IEnumerable`1<T> entities, string collectionName);
    public abstract virtual bool Upsert(T entity, string collectionName);
    public abstract virtual int Upsert(IEnumerable`1<T> entities, string collectionName);
    public abstract virtual bool Delete(BsonValue id, string collectionName);
    public abstract virtual int DeleteMany(BsonExpression predicate, string collectionName);
    public abstract virtual int DeleteMany(Expression`1<Func`2<T, bool>> predicate, string collectionName);
    public abstract virtual ILiteQueryable`1<T> Query(string collectionName);
    public abstract virtual bool EnsureIndex(string name, BsonExpression expression, bool unique, string collectionName);
    public abstract virtual bool EnsureIndex(BsonExpression expression, bool unique, string collectionName);
    public abstract virtual bool EnsureIndex(Expression`1<Func`2<T, K>> keySelector, bool unique, string collectionName);
    public abstract virtual bool EnsureIndex(string name, Expression`1<Func`2<T, K>> keySelector, bool unique, string collectionName);
    public abstract virtual T SingleById(BsonValue id, string collectionName);
    public abstract virtual List`1<T> Fetch(BsonExpression predicate, string collectionName);
    public abstract virtual List`1<T> Fetch(Expression`1<Func`2<T, bool>> predicate, string collectionName);
    public abstract virtual T First(BsonExpression predicate, string collectionName);
    public abstract virtual T First(Expression`1<Func`2<T, bool>> predicate, string collectionName);
    public abstract virtual T FirstOrDefault(BsonExpression predicate, string collectionName);
    public abstract virtual T FirstOrDefault(Expression`1<Func`2<T, bool>> predicate, string collectionName);
    public abstract virtual T Single(BsonExpression predicate, string collectionName);
    public abstract virtual T Single(Expression`1<Func`2<T, bool>> predicate, string collectionName);
    public abstract virtual T SingleOrDefault(BsonExpression predicate, string collectionName);
    public abstract virtual T SingleOrDefault(Expression`1<Func`2<T, bool>> predicate, string collectionName);
}
public interface LiteDB.ILiteStorage`1 {
    public abstract virtual LiteFileInfo`1<TFileId> FindById(TFileId id);
    public abstract virtual IEnumerable`1<LiteFileInfo`1<TFileId>> Find(BsonExpression predicate);
    public abstract virtual IEnumerable`1<LiteFileInfo`1<TFileId>> Find(string predicate, BsonDocument parameters);
    public abstract virtual IEnumerable`1<LiteFileInfo`1<TFileId>> Find(string predicate, BsonValue[] args);
    public abstract virtual IEnumerable`1<LiteFileInfo`1<TFileId>> Find(Expression`1<Func`2<LiteFileInfo`1<TFileId>, bool>> predicate);
    public abstract virtual IEnumerable`1<LiteFileInfo`1<TFileId>> FindAll();
    public abstract virtual bool Exists(TFileId id);
    public abstract virtual LiteFileStream`1<TFileId> OpenWrite(TFileId id, string filename, BsonDocument metadata);
    public abstract virtual LiteFileInfo`1<TFileId> Upload(TFileId id, string filename, Stream stream, BsonDocument metadata);
    public abstract virtual LiteFileInfo`1<TFileId> Upload(TFileId id, string filename);
    public abstract virtual bool SetMetadata(TFileId id, BsonDocument metadata);
    public abstract virtual LiteFileStream`1<TFileId> OpenRead(TFileId id);
    public abstract virtual LiteFileInfo`1<TFileId> Download(TFileId id, Stream stream);
    public abstract virtual LiteFileInfo`1<TFileId> Download(TFileId id, string filename, bool overwritten);
    public abstract virtual bool Delete(TFileId id);
}
[ExtensionAttribute]
internal static class LiteDB.IOExceptionExtensions : object {
    private static int ERROR_SHARING_VIOLATION;
    private static int ERROR_LOCK_VIOLATION;
    [ExtensionAttribute]
public static bool IsLocked(IOException ex);
    [ExtensionAttribute]
public static void WaitIfLocked(IOException ex, int timerInMilliseconds);
}
public interface LiteDB.ITypeNameBinder {
    public abstract virtual string GetName(Type type);
    public abstract virtual Type GetType(string name);
}
internal interface LiteDB.ITypeResolver {
    public abstract virtual string ResolveMethod(MethodInfo method);
    public abstract virtual string ResolveMember(MemberInfo member);
    public abstract virtual string ResolveCtor(ConstructorInfo ctor);
}
public class LiteDB.JsonReader : object {
    private static IFormatProvider _numberFormat;
    private Tokenizer _tokenizer;
    public long Position { get; }
    public JsonReader(TextReader reader);
    internal JsonReader(Tokenizer tokenizer);
    private static JsonReader();
    public long get_Position();
    public BsonValue Deserialize();
    [IteratorStateMachineAttribute("LiteDB.JsonReader/<DeserializeArray>d__7")]
public IEnumerable`1<BsonValue> DeserializeArray();
    internal BsonValue ReadValue(Token token);
    private BsonValue ReadObject();
    private BsonArray ReadArray();
    private BsonValue ReadExtendedDataType(string key, string value);
}
public class LiteDB.JsonSerializer : object {
    public static string Serialize(BsonValue value, bool indent);
    public static void Serialize(BsonValue value, TextWriter writer, bool indent);
    public static void Serialize(BsonValue value, StringBuilder sb, bool indent);
    public static BsonValue Deserialize(string json);
    public static BsonValue Deserialize(TextReader reader);
    public static IEnumerable`1<BsonValue> DeserializeArray(string json);
    public static IEnumerable`1<BsonValue> DeserializeArray(TextReader reader);
}
public class LiteDB.JsonWriter : object {
    private static IFormatProvider _numberFormat;
    private TextWriter _writer;
    private int _indent;
    private string _spacer;
    [CompilerGeneratedAttribute]
private int <Indent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Pretty>k__BackingField;
    public int Indent { get; public set; }
    public bool Pretty { get; public set; }
    public JsonWriter(TextWriter writer);
    private static JsonWriter();
    [CompilerGeneratedAttribute]
public int get_Indent();
    [CompilerGeneratedAttribute]
public void set_Indent(int value);
    [CompilerGeneratedAttribute]
public bool get_Pretty();
    [CompilerGeneratedAttribute]
public void set_Pretty(bool value);
    public void Serialize(BsonValue value);
    private void WriteValue(BsonValue value);
    private void WriteObject(BsonDocument obj);
    private void WriteArray(BsonArray arr);
    private void WriteString(string s);
    private void WriteExtendDataType(string type, string value);
    private void WriteKeyValue(string key, BsonValue value, bool comma);
    private void WriteStartBlock(string str, bool hasData);
    private void WriteEndBlock(string str, bool hasData);
    private void WriteNewLine();
    private void WriteIndent();
}
internal class LiteDB.LastItem`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLast>k__BackingField;
    public T Item { get; public set; }
    public bool IsLast { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public T get_Item();
    [CompilerGeneratedAttribute]
public void set_Item(T value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsLast();
    [CompilerGeneratedAttribute]
public void set_IsLast(bool value);
}
internal class LiteDB.LCID : object {
    private static IDictionary`2<int, string> _mappings;
    public static int Current { get; }
    private static LCID();
    public static CultureInfo GetCulture(int lcid);
    public static int GetLCID(string culture);
    public static int get_Current();
}
internal class LiteDB.LinqExpressionVisitor : ExpressionVisitor {
    private static Dictionary`2<Type, ITypeResolver> _resolver;
    private BsonMapper _mapper;
    private Expression _expr;
    private ParameterExpression _rootParameter;
    private BsonDocument _parameters;
    private int _paramIndex;
    private Type _dbRefType;
    private StringBuilder _builder;
    private Stack`1<Expression> _nodes;
    public LinqExpressionVisitor(BsonMapper mapper, Expression expr);
    private static LinqExpressionVisitor();
    public BsonExpression Resolve(bool predicate);
    protected virtual Expression VisitLambda(Expression`1<T> node);
    protected virtual Expression VisitInvocation(InvocationExpression node);
    protected virtual Expression VisitParameter(ParameterExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected virtual Expression VisitConstant(ConstantExpression node);
    protected virtual Expression VisitUnary(UnaryExpression node);
    protected virtual Expression VisitNew(NewExpression node);
    protected virtual Expression VisitMemberInit(MemberInitExpression node);
    protected virtual Expression VisitNewArray(NewArrayExpression node);
    protected virtual Expression VisitBinary(BinaryExpression node);
    protected virtual Expression VisitConditional(ConditionalExpression node);
    private Expression VisitCoalesce(BinaryExpression node);
    private Expression VisitArrayIndex(BinaryExpression node);
    private void ResolvePattern(string pattern, Expression obj, IList`1<Expression> args);
    private void VisitEnumerablePredicate(LambdaExpression lambda);
    private string GetOperator(ExpressionType nodeType);
    private string ResolveMember(MemberInfo member);
    private bool IsMethodIndexEval(MethodCallExpression node, Expression& obj, Expression& idx);
    private void VisitAsPredicate(Expression expr, bool ensurePredicate);
    private object Evaluate(Expression expr, Type[] validTypes);
    private bool TryGetResolver(Type declaringType, ITypeResolver& typeResolver);
}
[ExtensionAttribute]
internal static class LiteDB.LinqExtensions : object {
    [IteratorStateMachineAttribute("LiteDB.LinqExtensions/<Batch>d__0`1")]
[ExtensionAttribute]
public static IEnumerable`1<IEnumerable`1<T>> Batch(IEnumerable`1<T> source, int batchSize);
    [IteratorStateMachineAttribute("LiteDB.LinqExtensions/<YieldBatchElements>d__1`1")]
private static IEnumerable`1<T> YieldBatchElements(IEnumerator`1<T> source, int batchSize);
    [ExtensionAttribute]
public static IEnumerable`1<TSource> DistinctBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [IteratorStateMachineAttribute("LiteDB.LinqExtensions/<IsLast>d__3`1")]
[ExtensionAttribute]
public static IEnumerable`1<LastItem`1<T>> IsLast(IEnumerable`1<T> source);
}
public class LiteDB.LiteCollection`1 : object {
    private string _collection;
    private ILiteEngine _engine;
    private List`1<BsonExpression> _includes;
    private BsonMapper _mapper;
    private EntityMapper _entity;
    private MemberMapper _id;
    private BsonAutoId _autoId;
    public string Name { get; }
    public BsonAutoId AutoId { get; }
    public EntityMapper EntityMapper { get; }
    internal LiteCollection`1(string name, BsonAutoId autoId, ILiteEngine engine, BsonMapper mapper);
    public sealed virtual int Count();
    public sealed virtual int Count(BsonExpression predicate);
    public sealed virtual int Count(string predicate, BsonDocument parameters);
    public sealed virtual int Count(string predicate, BsonValue[] args);
    public sealed virtual int Count(Expression`1<Func`2<T, bool>> predicate);
    public sealed virtual int Count(Query query);
    public sealed virtual long LongCount();
    public sealed virtual long LongCount(BsonExpression predicate);
    public sealed virtual long LongCount(string predicate, BsonDocument parameters);
    public sealed virtual long LongCount(string predicate, BsonValue[] args);
    public sealed virtual long LongCount(Expression`1<Func`2<T, bool>> predicate);
    public sealed virtual long LongCount(Query query);
    public sealed virtual bool Exists(BsonExpression predicate);
    public sealed virtual bool Exists(string predicate, BsonDocument parameters);
    public sealed virtual bool Exists(string predicate, BsonValue[] args);
    public sealed virtual bool Exists(Expression`1<Func`2<T, bool>> predicate);
    public sealed virtual bool Exists(Query query);
    public sealed virtual BsonValue Min(BsonExpression keySelector);
    public sealed virtual BsonValue Min();
    public sealed virtual K Min(Expression`1<Func`2<T, K>> keySelector);
    public sealed virtual BsonValue Max(BsonExpression keySelector);
    public sealed virtual BsonValue Max();
    public sealed virtual K Max(Expression`1<Func`2<T, K>> keySelector);
    public sealed virtual bool Delete(BsonValue id);
    public sealed virtual int DeleteAll();
    public sealed virtual int DeleteMany(BsonExpression predicate);
    public sealed virtual int DeleteMany(string predicate, BsonDocument parameters);
    public sealed virtual int DeleteMany(string predicate, BsonValue[] args);
    public sealed virtual int DeleteMany(Expression`1<Func`2<T, bool>> predicate);
    public sealed virtual ILiteQueryable`1<T> Query();
    public sealed virtual IEnumerable`1<T> Find(BsonExpression predicate, int skip, int limit);
    public sealed virtual IEnumerable`1<T> Find(Query query, int skip, int limit);
    public sealed virtual IEnumerable`1<T> Find(Expression`1<Func`2<T, bool>> predicate, int skip, int limit);
    public sealed virtual T FindById(BsonValue id);
    public sealed virtual T FindOne(BsonExpression predicate);
    public sealed virtual T FindOne(string predicate, BsonDocument parameters);
    public sealed virtual T FindOne(BsonExpression predicate, BsonValue[] args);
    public sealed virtual T FindOne(Expression`1<Func`2<T, bool>> predicate);
    public sealed virtual T FindOne(Query query);
    public sealed virtual IEnumerable`1<T> FindAll();
    public sealed virtual ILiteCollection`1<T> Include(Expression`1<Func`2<T, K>> keySelector);
    public sealed virtual ILiteCollection`1<T> Include(BsonExpression keySelector);
    public sealed virtual bool EnsureIndex(string name, BsonExpression expression, bool unique);
    public sealed virtual bool EnsureIndex(BsonExpression expression, bool unique);
    public sealed virtual bool EnsureIndex(Expression`1<Func`2<T, K>> keySelector, bool unique);
    public sealed virtual bool EnsureIndex(string name, Expression`1<Func`2<T, K>> keySelector, bool unique);
    private BsonExpression GetIndexExpression(Expression`1<Func`2<T, K>> keySelector);
    public sealed virtual bool DropIndex(string name);
    public sealed virtual BsonValue Insert(T entity);
    public sealed virtual void Insert(BsonValue id, T entity);
    public sealed virtual int Insert(IEnumerable`1<T> entities);
    [ObsoleteAttribute("Use normal Insert()")]
public sealed virtual int InsertBulk(IEnumerable`1<T> entities, int batchSize);
    [IteratorStateMachineAttribute("LiteDB.LiteCollection`1/<GetBsonDocs>d__52")]
private IEnumerable`1<BsonDocument> GetBsonDocs(IEnumerable`1<T> documents);
    private bool RemoveDocId(BsonDocument doc);
    public sealed virtual bool Update(T entity);
    public sealed virtual bool Update(BsonValue id, T entity);
    public sealed virtual int Update(IEnumerable`1<T> entities);
    public sealed virtual int UpdateMany(BsonExpression transform, BsonExpression predicate);
    public sealed virtual int UpdateMany(Expression`1<Func`2<T, T>> extend, Expression`1<Func`2<T, bool>> predicate);
    public sealed virtual bool Upsert(T entity);
    public sealed virtual int Upsert(IEnumerable`1<T> entities);
    public sealed virtual bool Upsert(BsonValue id, T entity);
    public sealed virtual string get_Name();
    public sealed virtual BsonAutoId get_AutoId();
    public sealed virtual EntityMapper get_EntityMapper();
    [CompilerGeneratedAttribute]
private BsonDocument <Update>b__56_0(T x);
}
public class LiteDB.LiteDatabase : object {
    private ILiteEngine _engine;
    private BsonMapper _mapper;
    private bool _disposeOnClose;
    private ILiteStorage`1<string> _fs;
    public BsonMapper Mapper { get; }
    public ILiteStorage`1<string> FileStorage { get; }
    public int UserVersion { get; public set; }
    public TimeSpan Timeout { get; public set; }
    public bool UtcDate { get; public set; }
    public long LimitSize { get; public set; }
    public int CheckpointSize { get; public set; }
    public Collation Collation { get; }
    public LiteDatabase(string connectionString, BsonMapper mapper);
    public LiteDatabase(ConnectionString connectionString, BsonMapper mapper);
    public LiteDatabase(Stream stream, BsonMapper mapper, Stream logStream);
    public LiteDatabase(ILiteEngine engine, BsonMapper mapper, bool disposeOnClose);
    public sealed virtual BsonMapper get_Mapper();
    public sealed virtual ILiteCollection`1<T> GetCollection(string name, BsonAutoId autoId);
    public sealed virtual ILiteCollection`1<T> GetCollection();
    public sealed virtual ILiteCollection`1<T> GetCollection(BsonAutoId autoId);
    public sealed virtual ILiteCollection`1<BsonDocument> GetCollection(string name, BsonAutoId autoId);
    public sealed virtual bool BeginTrans();
    public sealed virtual bool Commit();
    public sealed virtual bool Rollback();
    public sealed virtual ILiteStorage`1<string> get_FileStorage();
    public sealed virtual ILiteStorage`1<TFileId> GetStorage(string filesCollection, string chunksCollection);
    public sealed virtual IEnumerable`1<string> GetCollectionNames();
    public sealed virtual bool CollectionExists(string name);
    public sealed virtual bool DropCollection(string name);
    public sealed virtual bool RenameCollection(string oldName, string newName);
    public sealed virtual IBsonDataReader Execute(TextReader commandReader, BsonDocument parameters);
    public sealed virtual IBsonDataReader Execute(string command, BsonDocument parameters);
    public sealed virtual IBsonDataReader Execute(string command, BsonValue[] args);
    public sealed virtual void Checkpoint();
    public sealed virtual long Rebuild(RebuildOptions options);
    public sealed virtual BsonValue Pragma(string name);
    public sealed virtual BsonValue Pragma(string name, BsonValue value);
    public sealed virtual int get_UserVersion();
    public sealed virtual void set_UserVersion(int value);
    public sealed virtual TimeSpan get_Timeout();
    public sealed virtual void set_Timeout(TimeSpan value);
    public sealed virtual bool get_UtcDate();
    public sealed virtual void set_UtcDate(bool value);
    public sealed virtual long get_LimitSize();
    public sealed virtual void set_LimitSize(long value);
    public sealed virtual int get_CheckpointSize();
    public sealed virtual void set_CheckpointSize(int value);
    public sealed virtual Collation get_Collation();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
}
public class LiteDB.LiteException : Exception {
    public static int FILE_NOT_FOUND;
    public static int DATABASE_SHUTDOWN;
    public static int INVALID_DATABASE;
    public static int FILE_SIZE_EXCEEDED;
    public static int COLLECTION_LIMIT_EXCEEDED;
    public static int INDEX_DROP_ID;
    public static int INDEX_DUPLICATE_KEY;
    public static int INVALID_INDEX_KEY;
    public static int INDEX_NOT_FOUND;
    public static int INVALID_DBREF;
    public static int LOCK_TIMEOUT;
    public static int INVALID_COMMAND;
    public static int ALREADY_EXISTS_COLLECTION_NAME;
    public static int ALREADY_OPEN_DATAFILE;
    public static int INVALID_TRANSACTION_STATE;
    public static int INDEX_NAME_LIMIT_EXCEEDED;
    public static int INVALID_INDEX_NAME;
    public static int INVALID_COLLECTION_NAME;
    public static int TEMP_ENGINE_ALREADY_DEFINED;
    public static int INVALID_EXPRESSION_TYPE;
    public static int COLLECTION_NOT_FOUND;
    public static int COLLECTION_ALREADY_EXIST;
    public static int INDEX_ALREADY_EXIST;
    public static int INVALID_UPDATE_FIELD;
    public static int ENGINE_DISPOSED;
    public static int INVALID_FORMAT;
    public static int DOCUMENT_MAX_DEPTH;
    public static int INVALID_CTOR;
    public static int UNEXPECTED_TOKEN;
    public static int INVALID_DATA_TYPE;
    public static int PROPERTY_NOT_MAPPED;
    public static int INVALID_TYPED_NAME;
    public static int PROPERTY_READ_WRITE;
    public static int INITIALSIZE_CRYPTO_NOT_SUPPORTED;
    public static int INVALID_INITIALSIZE;
    public static int INVALID_NULL_CHAR_STRING;
    public static int INVALID_FREE_SPACE_PAGE;
    public static int DATA_TYPE_NOT_ASSIGNABLE;
    public static int AVOID_USE_OF_PROCESS;
    public static int NOT_ENCRYPTED;
    public static int INVALID_PASSWORD;
    public static int ILLEGAL_DESERIALIZATION_TYPE;
    public static int INVALID_DATAFILE_STATE;
    [CompilerGeneratedAttribute]
private int <ErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    public int ErrorCode { get; private set; }
    public long Position { get; private set; }
    public bool IsCritical { get; }
    public LiteException(int code, string message);
    internal LiteException(int code, string message, Object[] args);
    internal LiteException(int code, Exception inner, string message, Object[] args);
    [CompilerGeneratedAttribute]
public int get_ErrorCode();
    [CompilerGeneratedAttribute]
private void set_ErrorCode(int value);
    [CompilerGeneratedAttribute]
public long get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(long value);
    public bool get_IsCritical();
    internal static LiteException FileNotFound(object fileId);
    internal static LiteException DatabaseShutdown();
    internal static LiteException InvalidDatabase();
    internal static LiteException FileSizeExceeded(long limit);
    internal static LiteException CollectionLimitExceeded(int limit);
    internal static LiteException IndexNameLimitExceeded(int limit);
    internal static LiteException InvalidIndexName(string name, string collection, string reason);
    internal static LiteException InvalidCollectionName(string name, string reason);
    internal static LiteException IndexDropId();
    internal static LiteException TempEngineAlreadyDefined();
    internal static LiteException CollectionNotFound(string key);
    internal static LiteException InvalidExpressionType(BsonExpression expr, BsonExpressionType type);
    internal static LiteException InvalidExpressionTypePredicate(BsonExpression expr);
    internal static LiteException CollectionAlreadyExist(string key);
    internal static LiteException IndexAlreadyExist(string name);
    internal static LiteException InvalidUpdateField(string field);
    internal static LiteException IndexDuplicateKey(string field, BsonValue key);
    internal static LiteException InvalidIndexKey(string text);
    internal static LiteException IndexNotFound(string name);
    internal static LiteException LockTimeout(string mode, TimeSpan ts);
    internal static LiteException LockTimeout(string mode, string collection, TimeSpan ts);
    internal static LiteException InvalidCommand(string command);
    internal static LiteException AlreadyExistsCollectionName(string newName);
    internal static LiteException AlreadyOpenDatafile(string filename);
    internal static LiteException InvalidDbRef(string path);
    internal static LiteException AlreadyExistsTransaction();
    internal static LiteException CollectionLockerNotFound(string collection);
    internal static LiteException InvalidFormat(string field);
    internal static LiteException DocumentMaxDepth(int depth, Type type);
    internal static LiteException InvalidCtor(Type type, Exception inner);
    internal static LiteException UnexpectedToken(Token token, string expected);
    internal static LiteException UnexpectedToken(string message, Token token);
    internal static LiteException InvalidDataType(string field, BsonValue value);
    internal static LiteException PropertyReadWrite(PropertyInfo prop);
    internal static LiteException PropertyNotMapped(string name);
    internal static LiteException InvalidTypedName(string type);
    internal static LiteException InitialSizeCryptoNotSupported();
    internal static LiteException InvalidInitialSize();
    internal static LiteException EngineDisposed();
    internal static LiteException InvalidNullCharInString();
    internal static LiteException InvalidPageType(PageType pageType, BasePage page);
    internal static LiteException InvalidFreeSpacePage(UInt32 pageID, int freeBytes, int length);
    internal static LiteException DataTypeNotAssignable(string type1, string type2);
    internal static LiteException FileNotEncrypted();
    internal static LiteException InvalidPassword();
    internal static LiteException IllegalDeserializationType(string typeName);
    internal static LiteException InvalidDatafileState(string message);
}
public class LiteDB.LiteFileInfo`1 : object {
    [CompilerGeneratedAttribute]
private TFileId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Filename>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MimeType>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Chunks>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <UploadDate>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonDocument <Metadata>k__BackingField;
    private BsonValue _fileId;
    private ILiteCollection`1<LiteFileInfo`1<TFileId>> _files;
    private ILiteCollection`1<BsonDocument> _chunks;
    public TFileId Id { get; internal set; }
    [BsonFieldAttribute("filename")]
public string Filename { get; internal set; }
    [BsonFieldAttribute("mimeType")]
public string MimeType { get; internal set; }
    [BsonFieldAttribute("length")]
public long Length { get; internal set; }
    [BsonFieldAttribute("chunks")]
public int Chunks { get; internal set; }
    [BsonFieldAttribute("uploadDate")]
public DateTime UploadDate { get; internal set; }
    [BsonFieldAttribute("metadata")]
public BsonDocument Metadata { get; public set; }
    [CompilerGeneratedAttribute]
public TFileId get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(TFileId value);
    [CompilerGeneratedAttribute]
public string get_Filename();
    [CompilerGeneratedAttribute]
internal void set_Filename(string value);
    [CompilerGeneratedAttribute]
public string get_MimeType();
    [CompilerGeneratedAttribute]
internal void set_MimeType(string value);
    [CompilerGeneratedAttribute]
public long get_Length();
    [CompilerGeneratedAttribute]
internal void set_Length(long value);
    [CompilerGeneratedAttribute]
public int get_Chunks();
    [CompilerGeneratedAttribute]
internal void set_Chunks(int value);
    [CompilerGeneratedAttribute]
public DateTime get_UploadDate();
    [CompilerGeneratedAttribute]
internal void set_UploadDate(DateTime value);
    [CompilerGeneratedAttribute]
public BsonDocument get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(BsonDocument value);
    internal void SetReference(BsonValue fileId, ILiteCollection`1<LiteFileInfo`1<TFileId>> files, ILiteCollection`1<BsonDocument> chunks);
    public LiteFileStream`1<TFileId> OpenRead();
    public LiteFileStream`1<TFileId> OpenWrite();
    public void CopyTo(Stream stream);
    public void SaveAs(string filename, bool overwritten);
}
public class LiteDB.LiteFileStream`1 : Stream {
    public static int MAX_CHUNK_SIZE;
    private ILiteCollection`1<LiteFileInfo`1<TFileId>> _files;
    private ILiteCollection`1<BsonDocument> _chunks;
    private LiteFileInfo`1<TFileId> _file;
    private BsonValue _fileId;
    private FileAccess _mode;
    private long _streamPosition;
    private int _currentChunkIndex;
    private Byte[] _currentChunkData;
    private int _positionInChunk;
    private MemoryStream _buffer;
    private bool _disposed;
    private Dictionary`2<int, long> _chunkLengths;
    public LiteFileInfo`1<TFileId> FileInfo { get; }
    public long Length { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Position { get; public set; }
    internal LiteFileStream`1(ILiteCollection`1<LiteFileInfo`1<TFileId>> files, ILiteCollection`1<BsonDocument> chunks, LiteFileInfo`1<TFileId> file, BsonValue fileId, FileAccess mode);
    public LiteFileInfo`1<TFileId> get_FileInfo();
    public virtual long get_Length();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    protected virtual void Dispose(bool disposing);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    private Byte[] GetChunkData(int index);
    private void SetReadStreamPosition(long newPosition);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    private void WriteChunks(bool flush);
}
public class LiteDB.LiteQueryable`1 : object {
    protected ILiteEngine _engine;
    protected BsonMapper _mapper;
    protected string _collection;
    protected Query _query;
    private bool _isSimpleType;
    internal LiteQueryable`1(ILiteEngine engine, BsonMapper mapper, string collection, Query query);
    public sealed virtual ILiteQueryable`1<T> Include(Expression`1<Func`2<T, K>> path);
    public sealed virtual ILiteQueryable`1<T> Include(BsonExpression path);
    public sealed virtual ILiteQueryable`1<T> Include(List`1<BsonExpression> paths);
    public sealed virtual ILiteQueryable`1<T> Where(BsonExpression predicate);
    public sealed virtual ILiteQueryable`1<T> Where(string predicate, BsonDocument parameters);
    public sealed virtual ILiteQueryable`1<T> Where(string predicate, BsonValue[] args);
    public sealed virtual ILiteQueryable`1<T> Where(Expression`1<Func`2<T, bool>> predicate);
    public sealed virtual ILiteQueryable`1<T> OrderBy(BsonExpression keySelector, int order);
    public sealed virtual ILiteQueryable`1<T> OrderBy(Expression`1<Func`2<T, K>> keySelector, int order);
    public sealed virtual ILiteQueryable`1<T> OrderByDescending(BsonExpression keySelector);
    public sealed virtual ILiteQueryable`1<T> OrderByDescending(Expression`1<Func`2<T, K>> keySelector);
    public sealed virtual ILiteQueryable`1<T> GroupBy(BsonExpression keySelector);
    public sealed virtual ILiteQueryable`1<T> Having(BsonExpression predicate);
    public sealed virtual ILiteQueryableResult`1<BsonDocument> Select(BsonExpression selector);
    public sealed virtual ILiteQueryableResult`1<K> Select(Expression`1<Func`2<T, K>> selector);
    public sealed virtual ILiteQueryableResult`1<T> ForUpdate();
    public sealed virtual ILiteQueryableResult`1<T> Offset(int offset);
    public sealed virtual ILiteQueryableResult`1<T> Skip(int offset);
    public sealed virtual ILiteQueryableResult`1<T> Limit(int limit);
    public sealed virtual IBsonDataReader ExecuteReader();
    [IteratorStateMachineAttribute("LiteDB.LiteQueryable`1/<ToDocuments>d__26")]
public sealed virtual IEnumerable`1<BsonDocument> ToDocuments();
    public sealed virtual IEnumerable`1<T> ToEnumerable();
    public sealed virtual List`1<T> ToList();
    public sealed virtual T[] ToArray();
    public sealed virtual BsonDocument GetPlan();
    public sealed virtual T Single();
    public sealed virtual T SingleOrDefault();
    public sealed virtual T First();
    public sealed virtual T FirstOrDefault();
    public sealed virtual int Count();
    public sealed virtual long LongCount();
    public sealed virtual bool Exists();
    public sealed virtual int Into(string newCollection, BsonAutoId autoId);
    [CompilerGeneratedAttribute]
private T <ToEnumerable>b__27_1(BsonValue x);
    [CompilerGeneratedAttribute]
private T <ToEnumerable>b__27_2(BsonDocument x);
}
public class LiteDB.LiteRepository : object {
    private ILiteDatabase _db;
    public ILiteDatabase Database { get; }
    public LiteRepository(ILiteDatabase database);
    public LiteRepository(string connectionString, BsonMapper mapper);
    public LiteRepository(ConnectionString connectionString, BsonMapper mapper);
    public LiteRepository(Stream stream, BsonMapper mapper, Stream logStream);
    public sealed virtual ILiteDatabase get_Database();
    public sealed virtual BsonValue Insert(T entity, string collectionName);
    public sealed virtual int Insert(IEnumerable`1<T> entities, string collectionName);
    public sealed virtual bool Update(T entity, string collectionName);
    public sealed virtual int Update(IEnumerable`1<T> entities, string collectionName);
    public sealed virtual bool Upsert(T entity, string collectionName);
    public sealed virtual int Upsert(IEnumerable`1<T> entities, string collectionName);
    public sealed virtual bool Delete(BsonValue id, string collectionName);
    public sealed virtual int DeleteMany(BsonExpression predicate, string collectionName);
    public sealed virtual int DeleteMany(Expression`1<Func`2<T, bool>> predicate, string collectionName);
    public sealed virtual ILiteQueryable`1<T> Query(string collectionName);
    public sealed virtual bool EnsureIndex(string name, BsonExpression expression, bool unique, string collectionName);
    public sealed virtual bool EnsureIndex(BsonExpression expression, bool unique, string collectionName);
    public sealed virtual bool EnsureIndex(Expression`1<Func`2<T, K>> keySelector, bool unique, string collectionName);
    public sealed virtual bool EnsureIndex(string name, Expression`1<Func`2<T, K>> keySelector, bool unique, string collectionName);
    public sealed virtual T SingleById(BsonValue id, string collectionName);
    public sealed virtual List`1<T> Fetch(BsonExpression predicate, string collectionName);
    public sealed virtual List`1<T> Fetch(Expression`1<Func`2<T, bool>> predicate, string collectionName);
    public sealed virtual T First(BsonExpression predicate, string collectionName);
    public sealed virtual T First(Expression`1<Func`2<T, bool>> predicate, string collectionName);
    public sealed virtual T FirstOrDefault(BsonExpression predicate, string collectionName);
    public sealed virtual T FirstOrDefault(Expression`1<Func`2<T, bool>> predicate, string collectionName);
    public sealed virtual T Single(BsonExpression predicate, string collectionName);
    public sealed virtual T Single(Expression`1<Func`2<T, bool>> predicate, string collectionName);
    public sealed virtual T SingleOrDefault(BsonExpression predicate, string collectionName);
    public sealed virtual T SingleOrDefault(Expression`1<Func`2<T, bool>> predicate, string collectionName);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
}
public class LiteDB.LiteStorage`1 : object {
    private ILiteDatabase _db;
    private ILiteCollection`1<LiteFileInfo`1<TFileId>> _files;
    private ILiteCollection`1<BsonDocument> _chunks;
    public LiteStorage`1(ILiteDatabase db, string filesCollection, string chunksCollection);
    public sealed virtual LiteFileInfo`1<TFileId> FindById(TFileId id);
    [IteratorStateMachineAttribute("LiteDB.LiteStorage`1/<Find>d__5")]
public sealed virtual IEnumerable`1<LiteFileInfo`1<TFileId>> Find(BsonExpression predicate);
    public sealed virtual IEnumerable`1<LiteFileInfo`1<TFileId>> Find(string predicate, BsonDocument parameters);
    public sealed virtual IEnumerable`1<LiteFileInfo`1<TFileId>> Find(string predicate, BsonValue[] args);
    public sealed virtual IEnumerable`1<LiteFileInfo`1<TFileId>> Find(Expression`1<Func`2<LiteFileInfo`1<TFileId>, bool>> predicate);
    public sealed virtual IEnumerable`1<LiteFileInfo`1<TFileId>> FindAll();
    public sealed virtual bool Exists(TFileId id);
    public sealed virtual LiteFileStream`1<TFileId> OpenWrite(TFileId id, string filename, BsonDocument metadata);
    public sealed virtual LiteFileInfo`1<TFileId> Upload(TFileId id, string filename, Stream stream, BsonDocument metadata);
    public sealed virtual LiteFileInfo`1<TFileId> Upload(TFileId id, string filename);
    public sealed virtual bool SetMetadata(TFileId id, BsonDocument metadata);
    public sealed virtual LiteFileStream`1<TFileId> OpenRead(TFileId id);
    public sealed virtual LiteFileInfo`1<TFileId> Download(TFileId id, Stream stream);
    public sealed virtual LiteFileInfo`1<TFileId> Download(TFileId id, string filename, bool overwritten);
    public sealed virtual bool Delete(TFileId id);
}
internal class LiteDB.MathResolver : object {
    public sealed virtual string ResolveMethod(MethodInfo method);
    public sealed virtual string ResolveMember(MemberInfo member);
    public sealed virtual string ResolveCtor(ConstructorInfo ctor);
}
public class LiteDB.MemberMapper : object {
    [CompilerGeneratedAttribute]
private bool <AutoId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DataType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private GenericGetter <Getter>k__BackingField;
    [CompilerGeneratedAttribute]
private GenericSetter <Setter>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<object, BsonMapper, BsonValue> <Serialize>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<BsonValue, BsonMapper, object> <Deserialize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDbRef>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnumerable>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <UnderlyingType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIgnore>k__BackingField;
    public bool AutoId { get; public set; }
    public string MemberName { get; public set; }
    public Type DataType { get; public set; }
    public string FieldName { get; public set; }
    public GenericGetter Getter { get; public set; }
    public GenericSetter Setter { get; public set; }
    public Func`3<object, BsonMapper, BsonValue> Serialize { get; public set; }
    public Func`3<BsonValue, BsonMapper, object> Deserialize { get; public set; }
    public bool IsDbRef { get; public set; }
    public bool IsEnumerable { get; public set; }
    public Type UnderlyingType { get; public set; }
    public bool IsIgnore { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AutoId();
    [CompilerGeneratedAttribute]
public void set_AutoId(bool value);
    [CompilerGeneratedAttribute]
public string get_MemberName();
    [CompilerGeneratedAttribute]
public void set_MemberName(string value);
    [CompilerGeneratedAttribute]
public Type get_DataType();
    [CompilerGeneratedAttribute]
public void set_DataType(Type value);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
public void set_FieldName(string value);
    [CompilerGeneratedAttribute]
public GenericGetter get_Getter();
    [CompilerGeneratedAttribute]
public void set_Getter(GenericGetter value);
    [CompilerGeneratedAttribute]
public GenericSetter get_Setter();
    [CompilerGeneratedAttribute]
public void set_Setter(GenericSetter value);
    [CompilerGeneratedAttribute]
public Func`3<object, BsonMapper, BsonValue> get_Serialize();
    [CompilerGeneratedAttribute]
public void set_Serialize(Func`3<object, BsonMapper, BsonValue> value);
    [CompilerGeneratedAttribute]
public Func`3<BsonValue, BsonMapper, object> get_Deserialize();
    [CompilerGeneratedAttribute]
public void set_Deserialize(Func`3<BsonValue, BsonMapper, object> value);
    [CompilerGeneratedAttribute]
public bool get_IsDbRef();
    [CompilerGeneratedAttribute]
public void set_IsDbRef(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsEnumerable();
    [CompilerGeneratedAttribute]
public void set_IsEnumerable(bool value);
    [CompilerGeneratedAttribute]
public Type get_UnderlyingType();
    [CompilerGeneratedAttribute]
public void set_UnderlyingType(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsIgnore();
    [CompilerGeneratedAttribute]
public void set_IsIgnore(bool value);
}
internal class LiteDB.MimeTypeConverter : object {
    private static IDictionary`2<string, string> _mappings;
    private static MimeTypeConverter();
    public static string GetMimeType(string filename);
}
internal class LiteDB.NullableResolver : object {
    public sealed virtual string ResolveMethod(MethodInfo method);
    public sealed virtual string ResolveMember(MemberInfo member);
    public sealed virtual string ResolveCtor(ConstructorInfo ctor);
}
internal class LiteDB.NumberResolver : object {
    private string _parseMethod;
    public NumberResolver(string parseMethod);
    public sealed virtual string ResolveMethod(MethodInfo method);
    public sealed virtual string ResolveMember(MemberInfo member);
    public sealed virtual string ResolveCtor(ConstructorInfo ctor);
}
public class LiteDB.ObjectId : object {
    [CompilerGeneratedAttribute]
private int <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Machine>k__BackingField;
    [CompilerGeneratedAttribute]
private short <Pid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Increment>k__BackingField;
    private static int _machine;
    private static short _pid;
    private static int _increment;
    public static ObjectId Empty { get; }
    public int Timestamp { get; }
    public int Machine { get; }
    public short Pid { get; }
    public int Increment { get; }
    public DateTime CreationTime { get; }
    public ObjectId(int timestamp, int machine, short pid, int increment);
    public ObjectId(ObjectId from);
    public ObjectId(string value);
    public ObjectId(Byte[] bytes, int startIndex);
    private static ObjectId();
    public static ObjectId get_Empty();
    [CompilerGeneratedAttribute]
public int get_Timestamp();
    [CompilerGeneratedAttribute]
public int get_Machine();
    [CompilerGeneratedAttribute]
public short get_Pid();
    [CompilerGeneratedAttribute]
public int get_Increment();
    public DateTime get_CreationTime();
    private static Byte[] FromHex(string value);
    public sealed virtual bool Equals(ObjectId other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(ObjectId other);
    public void ToByteArray(Byte[] bytes, int startIndex);
    public Byte[] ToByteArray();
    public virtual string ToString();
    public static bool op_Equality(ObjectId lhs, ObjectId rhs);
    public static bool op_Inequality(ObjectId lhs, ObjectId rhs);
    public static bool op_GreaterThanOrEqual(ObjectId lhs, ObjectId rhs);
    public static bool op_GreaterThan(ObjectId lhs, ObjectId rhs);
    public static bool op_LessThan(ObjectId lhs, ObjectId rhs);
    public static bool op_LessThanOrEqual(ObjectId lhs, ObjectId rhs);
    private static int GetCurrentProcessId();
    private static int GetMachineHash();
    public static ObjectId NewObjectId();
}
internal class LiteDB.ObjectIdResolver : object {
    public sealed virtual string ResolveMethod(MethodInfo method);
    public sealed virtual string ResolveMember(MemberInfo member);
    public sealed virtual string ResolveCtor(ConstructorInfo ctor);
}
internal class LiteDB.ParameterExpressionVisitor : ExpressionVisitor {
    [CompilerGeneratedAttribute]
private bool <IsParameter>k__BackingField;
    public bool IsParameter { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_IsParameter();
    [CompilerGeneratedAttribute]
private void set_IsParameter(bool value);
    protected virtual Expression VisitParameter(ParameterExpression node);
    public static bool Test(Expression node);
}
public class LiteDB.Query : object {
    public static int Ascending;
    public static int Descending;
    [CompilerGeneratedAttribute]
private BsonExpression <Select>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BsonExpression> <Includes>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BsonExpression> <Where>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonExpression <OrderBy>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonExpression <GroupBy>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonExpression <Having>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Limit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForUpdate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Into>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonAutoId <IntoAutoId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExplainPlan>k__BackingField;
    public BsonExpression Select { get; public set; }
    public List`1<BsonExpression> Includes { get; }
    public List`1<BsonExpression> Where { get; }
    public BsonExpression OrderBy { get; public set; }
    public int Order { get; public set; }
    public BsonExpression GroupBy { get; public set; }
    public BsonExpression Having { get; public set; }
    public int Offset { get; public set; }
    public int Limit { get; public set; }
    public bool ForUpdate { get; public set; }
    public string Into { get; public set; }
    public BsonAutoId IntoAutoId { get; public set; }
    public bool ExplainPlan { get; public set; }
    public static Query All();
    public static Query All(int order);
    public static Query All(string field, int order);
    public static BsonExpression EQ(string field, BsonValue value);
    public static BsonExpression LT(string field, BsonValue value);
    public static BsonExpression LTE(string field, BsonValue value);
    public static BsonExpression GT(string field, BsonValue value);
    public static BsonExpression GTE(string field, BsonValue value);
    public static BsonExpression Between(string field, BsonValue start, BsonValue end);
    public static BsonExpression StartsWith(string field, string value);
    public static BsonExpression Contains(string field, string value);
    public static BsonExpression Not(string field, BsonValue value);
    public static BsonExpression In(string field, BsonArray value);
    public static BsonExpression In(string field, BsonValue[] values);
    public static BsonExpression In(string field, IEnumerable`1<BsonValue> values);
    public static QueryAny Any();
    public static BsonExpression And(BsonExpression left, BsonExpression right);
    public static BsonExpression And(BsonExpression[] queries);
    public static BsonExpression Or(BsonExpression left, BsonExpression right);
    public static BsonExpression Or(BsonExpression[] queries);
    [CompilerGeneratedAttribute]
public BsonExpression get_Select();
    [CompilerGeneratedAttribute]
public void set_Select(BsonExpression value);
    [CompilerGeneratedAttribute]
public List`1<BsonExpression> get_Includes();
    [CompilerGeneratedAttribute]
public List`1<BsonExpression> get_Where();
    [CompilerGeneratedAttribute]
public BsonExpression get_OrderBy();
    [CompilerGeneratedAttribute]
public void set_OrderBy(BsonExpression value);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(int value);
    [CompilerGeneratedAttribute]
public BsonExpression get_GroupBy();
    [CompilerGeneratedAttribute]
public void set_GroupBy(BsonExpression value);
    [CompilerGeneratedAttribute]
public BsonExpression get_Having();
    [CompilerGeneratedAttribute]
public void set_Having(BsonExpression value);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(int value);
    [CompilerGeneratedAttribute]
public int get_Limit();
    [CompilerGeneratedAttribute]
public void set_Limit(int value);
    [CompilerGeneratedAttribute]
public bool get_ForUpdate();
    [CompilerGeneratedAttribute]
public void set_ForUpdate(bool value);
    [CompilerGeneratedAttribute]
public string get_Into();
    [CompilerGeneratedAttribute]
public void set_Into(string value);
    [CompilerGeneratedAttribute]
public BsonAutoId get_IntoAutoId();
    [CompilerGeneratedAttribute]
public void set_IntoAutoId(BsonAutoId value);
    [CompilerGeneratedAttribute]
public bool get_ExplainPlan();
    [CompilerGeneratedAttribute]
public void set_ExplainPlan(bool value);
    public string ToSQL(string collection);
}
public class LiteDB.QueryAny : object {
    public BsonExpression EQ(string arrayField, BsonValue value);
    public BsonExpression LT(string arrayField, BsonValue value);
    public BsonExpression LTE(string arrayField, BsonValue value);
    public BsonExpression GT(string arrayField, BsonValue value);
    public BsonExpression GTE(string arrayField, BsonValue value);
    public BsonExpression Between(string arrayField, BsonValue start, BsonValue end);
    public BsonExpression StartsWith(string arrayField, string value);
    public BsonExpression Not(string arrayField, BsonValue value);
}
internal static class LiteDB.Randomizer : object {
    private static Random _random;
    private static Randomizer();
    public static int Next();
    public static int Next(int minValue, int maxValue);
}
internal class LiteDB.Reflection : object {
    private static Dictionary`2<Type, CreateObject> _cacheCtor;
    public static Dictionary`2<Type, PropertyInfo> ConvertType;
    public static PropertyInfo DocumentItemProperty;
    private static Dictionary`2<MethodInfo, string> _cacheName;
    private static Reflection();
    public static object CreateInstance(Type type);
    public static bool IsNullable(Type type);
    public static Type UnderlyingTypeOf(Type type);
    public static Type GetGenericListOfType(Type type);
    public static Type GetGenericSetOfType(Type type);
    public static Type GetGenericDictionaryOfType(Type k, Type v);
    public static Type GetListItemType(Type listType);
    public static bool IsEnumerable(Type type);
    public static bool IsSimpleType(Type type);
    public static bool IsCollection(Type type);
    public static bool IsDictionary(Type type);
    public static MemberInfo SelectMember(IEnumerable`1<MemberInfo> members, Func`2[] predicates);
    public static string MethodName(MethodInfo method, int skipParameters);
    private static string MethodNameInternal(MethodInfo method, int skipParameters);
    private static string FriendlyTypeName(Type type);
    public static CreateObject CreateClass(Type type);
    public static CreateObject CreateStruct(Type type);
    public static GenericGetter CreateGenericGetter(Type type, MemberInfo memberInfo);
    public static GenericSetter CreateGenericSetter(Type type, MemberInfo memberInfo);
}
internal class LiteDB.RegexResolver : object {
    public sealed virtual string ResolveMethod(MethodInfo method);
    public sealed virtual string ResolveMember(MemberInfo member);
    public sealed virtual string ResolveCtor(ConstructorInfo ctor);
}
internal class LiteDB.Result`1 : ValueType {
    public T Value;
    public Exception Exception;
    public bool Ok { get; }
    public bool Fail { get; }
    public Result`1(T value, Exception ex);
    public bool get_Ok();
    public bool get_Fail();
    public T GetValue();
    public static T op_Implicit(Result`1<T> value);
    public static Result`1<T> op_Implicit(T value);
}
[DefaultMemberAttribute("Item")]
public class LiteDB.SharedDataReader : object {
    private IBsonDataReader _reader;
    private Action _dispose;
    private bool _disposed;
    public BsonValue Item { get; }
    public string Collection { get; }
    public BsonValue Current { get; }
    public bool HasValues { get; }
    public SharedDataReader(IBsonDataReader reader, Action dispose);
    public sealed virtual BsonValue get_Item(string field);
    public sealed virtual string get_Collection();
    public sealed virtual BsonValue get_Current();
    public sealed virtual bool get_HasValues();
    public sealed virtual bool Read();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
}
public class LiteDB.SharedEngine : object {
    private EngineSettings _settings;
    private Mutex _mutex;
    private LiteEngine _engine;
    private bool _transactionRunning;
    public SharedEngine(EngineSettings settings);
    private void OpenDatabase();
    private void CloseDatabase();
    public sealed virtual bool BeginTrans();
    public sealed virtual bool Commit();
    public sealed virtual bool Rollback();
    public sealed virtual IBsonDataReader Query(string collection, Query query);
    public sealed virtual BsonValue Pragma(string name);
    public sealed virtual bool Pragma(string name, BsonValue value);
    public sealed virtual int Checkpoint();
    public sealed virtual long Rebuild(RebuildOptions options);
    public sealed virtual int Insert(string collection, IEnumerable`1<BsonDocument> docs, BsonAutoId autoId);
    public sealed virtual int Update(string collection, IEnumerable`1<BsonDocument> docs);
    public sealed virtual int UpdateMany(string collection, BsonExpression extend, BsonExpression predicate);
    public sealed virtual int Upsert(string collection, IEnumerable`1<BsonDocument> docs, BsonAutoId autoId);
    public sealed virtual int Delete(string collection, IEnumerable`1<BsonValue> ids);
    public sealed virtual int DeleteMany(string collection, BsonExpression predicate);
    public sealed virtual bool DropCollection(string name);
    public sealed virtual bool RenameCollection(string name, string newName);
    public sealed virtual bool DropIndex(string collection, string name);
    public sealed virtual bool EnsureIndex(string collection, string name, BsonExpression expression, bool unique);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private void <Query>b__10_0();
}
internal class LiteDB.SqlParser : object {
    private ILiteEngine _engine;
    private Tokenizer _tokenizer;
    private BsonDocument _parameters;
    private Lazy`1<Collation> _collation;
    public SqlParser(ILiteEngine engine, Tokenizer tokenizer, BsonDocument parameters);
    private BsonDataReader ParseBegin();
    private BsonDataReader ParseCheckpoint();
    private BsonDataReader ParseCommit();
    private BsonDataReader ParseCreate();
    private BsonDataReader ParseDelete();
    private BsonDataReader ParseDrop();
    private BsonDataReader ParseInsert();
    private BsonAutoId ParseWithAutoId();
    [IteratorStateMachineAttribute("LiteDB.SqlParser/<ParseListOfExpressions>d__8")]
private IEnumerable`1<BsonExpression> ParseListOfExpressions();
    [IteratorStateMachineAttribute("LiteDB.SqlParser/<ParseListOfDocuments>d__9")]
private IEnumerable`1<BsonDocument> ParseListOfDocuments();
    private IBsonDataReader ParsePragma();
    private BsonDataReader ParseRebuild();
    private BsonDataReader ParseRename();
    private BsonDataReader ParseRollback();
    private IBsonDataReader ParseSelect();
    public static string ParseCollection(Tokenizer tokenizer);
    public static string ParseCollection(Tokenizer tokenizer, String& name, BsonValue& options);
    private BsonDataReader ParseUpdate();
    public IBsonDataReader Execute();
    [CompilerGeneratedAttribute]
private Collation <.ctor>b__22_0();
}
[ExtensionAttribute]
internal static class LiteDB.StreamExtensions : object {
    [ExtensionAttribute]
public static void FlushToDisk(Stream stream);
}
internal class LiteDB.StringEncoding : object {
    public static Encoding UTF8;
    private static StringEncoding();
}
[ExtensionAttribute]
internal static class LiteDB.StringExtensions : object {
    [ExtensionAttribute]
public static bool IsNullOrWhiteSpace(string str);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(string str);
    [ExtensionAttribute]
public static bool IsWord(string str);
    [ExtensionAttribute]
public static string Sha1(string value);
    [ExtensionAttribute]
public static bool SqlLike(string str, string pattern, Collation collation);
    [ExtensionAttribute]
public static string SqlLikeStartsWith(string str, Boolean& hasMore);
}
internal class LiteDB.StringResolver : object {
    public sealed virtual string ResolveMethod(MethodInfo method);
    public sealed virtual string ResolveMember(MemberInfo member);
    public sealed virtual string ResolveCtor(ConstructorInfo ctor);
}
internal class LiteDB.Token : object {
    private static HashSet`1<string> _keywords;
    [CompilerGeneratedAttribute]
private TokenType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    public TokenType Type { get; private set; }
    public string Value { get; private set; }
    public long Position { get; private set; }
    public bool IsOperand { get; }
    public Token(TokenType tokenType, string value, long position);
    private static Token();
    [CompilerGeneratedAttribute]
public TokenType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(TokenType value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    [CompilerGeneratedAttribute]
public long get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(long value);
    public Token Expect(TokenType type);
    public Token Expect(TokenType type1, TokenType type2);
    public Token Expect(TokenType type1, TokenType type2, TokenType type3);
    public Token Expect(string value, bool ignoreCase);
    public bool Is(string value, bool ignoreCase);
    public bool get_IsOperand();
    public virtual string ToString();
}
internal class LiteDB.Tokenizer : object {
    private TextReader _reader;
    private char _char;
    private Token _ahead;
    private bool _eof;
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <Current>k__BackingField;
    public bool EOF { get; }
    public long Position { get; private set; }
    public Token Current { get; private set; }
    public Tokenizer(string source);
    public Tokenizer(TextReader reader);
    public bool get_EOF();
    [CompilerGeneratedAttribute]
public long get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(long value);
    [CompilerGeneratedAttribute]
public Token get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(Token value);
    public bool CheckEOF();
    public static bool IsWordChar(char c, bool first);
    private char ReadChar();
    public Token LookAhead(bool eatWhitespace);
    public Token ReadToken(bool eatWhitespace);
    private Token ReadNext(bool eatWhitespace);
    private void EatWhitespace();
    private string ReadWord();
    private string ReadNumber(Boolean& dbl);
    private string ReadString(char quote);
    private void ReadLine();
    public static UInt32 ParseUnicode(char c1, char c2, char c3, char c4);
    public static UInt32 ParseSingleChar(char c1, UInt32 multiplier);
    public virtual string ToString();
}
internal enum LiteDB.TokenType : Enum {
    public int value__;
    public static TokenType OpenBrace;
    public static TokenType CloseBrace;
    public static TokenType OpenBracket;
    public static TokenType CloseBracket;
    public static TokenType OpenParenthesis;
    public static TokenType CloseParenthesis;
    public static TokenType Comma;
    public static TokenType Colon;
    public static TokenType SemiColon;
    public static TokenType At;
    public static TokenType Hashtag;
    public static TokenType Til;
    public static TokenType Period;
    public static TokenType Ampersand;
    public static TokenType Dollar;
    public static TokenType Exclamation;
    public static TokenType NotEquals;
    public static TokenType Equals;
    public static TokenType Greater;
    public static TokenType GreaterOrEquals;
    public static TokenType Less;
    public static TokenType LessOrEquals;
    public static TokenType Minus;
    public static TokenType Plus;
    public static TokenType Asterisk;
    public static TokenType Slash;
    public static TokenType Backslash;
    public static TokenType Percent;
    public static TokenType String;
    public static TokenType Int;
    public static TokenType Double;
    public static TokenType Whitespace;
    public static TokenType Word;
    public static TokenType EOF;
    public static TokenType Unknown;
}
[ExtensionAttribute]
internal static class LiteDB.TypeInfoExtensions : object {
    [ExtensionAttribute]
public static bool IsAnonymousType(Type type);
    [ExtensionAttribute]
public static bool IsEnumerable(Type type);
}
[ExtensionAttribute]
internal static class LiteDB.Utils.Extensions.EnumerableExtensions : object {
    [IteratorStateMachineAttribute("LiteDB.Utils.Extensions.EnumerableExtensions/<OnDispose>d__0`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> OnDispose(IEnumerable`1<T> source, Action onDispose);
}
[ExtensionAttribute]
public static class LiteDB.Utils.Extensions.StopWatchExtensions : object {
    [ExtensionAttribute]
public static IDisposable StartDisposable(Stopwatch stopwatch);
}
internal class LiteDB.Utils.TryCatch : object {
    public List`1<Exception> Exceptions;
    public bool InvalidDatafileState { get; }
    public TryCatch(Exception initial);
    public bool get_InvalidDatafileState();
    [DebuggerHiddenAttribute]
public void Catch(Action action);
}
internal class LiteDB.VolatileAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
