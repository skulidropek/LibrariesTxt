internal class Lucene.AlreadyClosedException : ObjectDisposedException {
    [ObsoleteAttribute("Use AlreadyClosedException.Create() instead.", "True")]
public AlreadyClosedException(string message);
    [ObsoleteAttribute("Use AlreadyClosedException.Create() instead.", "True")]
public AlreadyClosedException(string message, Exception innerException);
    [ObsoleteAttribute("Use AlreadyClosedException.Create() instead.", "True")]
public AlreadyClosedException(Exception cause);
    protected AlreadyClosedException(SerializationInfo info, StreamingContext context);
    public static Exception Create(string message);
    public static Exception Create(string objectName, string message);
    public static Exception Create(string message, Exception innerException);
    public static Exception Create(Exception cause);
}
internal class Lucene.ArrayIndexOutOfBoundsException : ArgumentOutOfRangeException {
    [ObsoleteAttribute("Use ArrayIndexOutOfBoundsException.Create() instead.", "True")]
public ArrayIndexOutOfBoundsException(string message);
    [ObsoleteAttribute("Use ArrayIndexOutOfBoundsException.Create() instead.", "True")]
public ArrayIndexOutOfBoundsException(string message, Exception innerException);
    [ObsoleteAttribute("Use ArrayIndexOutOfBoundsException.Create() instead.", "True")]
public ArrayIndexOutOfBoundsException(Exception cause);
    protected ArrayIndexOutOfBoundsException(SerializationInfo info, StreamingContext context);
    public static Exception Create();
    public static Exception Create(string message);
    public static Exception Create(string paramName, string message);
    public static Exception Create(string paramName, object actualValue, string message);
    public static Exception Create(string message, Exception innerException);
    public static Exception Create(Exception cause);
}
internal class Lucene.AssertionError : AssertionException {
    [ObsoleteAttribute("Use AssertionError.Create() instead.", "True")]
public AssertionError(string message);
    [ObsoleteAttribute("Use AssertionError.Create() instead.", "True")]
public AssertionError(string message, Exception innerException);
    [ObsoleteAttribute("Use AssertionError.Create() instead.", "True")]
public AssertionError(Exception cause);
    protected AssertionError(SerializationInfo info, StreamingContext context);
    public static Exception Create();
    public static Exception Create(string message);
    public static Exception Create(string message, Exception innerException);
    public static Exception Create(Exception cause);
}
internal class Lucene.ClassNotFoundException : Exception {
    [ObsoleteAttribute("Use ClassNotFoundException.Create() instead.", "True")]
public ClassNotFoundException(string message);
    [ObsoleteAttribute("Use ClassNotFoundException.Create() instead.", "True")]
public ClassNotFoundException(string message, Exception innerException);
    [ObsoleteAttribute("Use ClassNotFoundException.Create() instead.", "True")]
public ClassNotFoundException(Exception cause);
    protected ClassNotFoundException(SerializationInfo info, StreamingContext context);
    public static Exception Create();
    public static Exception Create(string message);
    public static Exception Create(string message, Exception innerException);
    public static Exception Create(Exception cause);
}
[ObsoleteAttribute("The MemberwiseClone() method in .NET does not throw exceptions. Remove the try-catch block and any reference to this error, as it is not required in .NET.")]
internal class Lucene.CloneNotSupportedException : object {
}
internal class Lucene.EOFException : EndOfStreamException {
    [ObsoleteAttribute("Use EOFException.Create() instead.", "True")]
public EOFException(string message);
    [ObsoleteAttribute("Use EOFException.Create() instead.", "True")]
public EOFException(string message, Exception innerException);
    [ObsoleteAttribute("Use EOFException.Create() instead.", "True")]
public EOFException(Exception cause);
    protected EOFException(SerializationInfo info, StreamingContext context);
    public static Exception Create();
    public static Exception Create(string message);
    public static Exception Create(string message, Exception innerException);
    public static Exception Create(Exception cause);
}
internal class Lucene.Error : Exception {
    [ObsoleteAttribute("Use Error.Create() instead.", "True")]
public Error(string message);
    [ObsoleteAttribute("Use Error.Create() instead.", "True")]
public Error(string message, Exception innerException);
    [ObsoleteAttribute("Use Error.Create() instead.", "True")]
public Error(Exception cause);
    protected Error(SerializationInfo info, StreamingContext context);
    public static Exception Create();
    public static Exception Create(string message);
    public static Exception Create(string message, Exception innerException);
    public static Exception Create(Exception cause);
}
[ExtensionAttribute]
internal static class Lucene.ExceptionExtensions : object {
    internal static Type NUnitResultStateExceptionType;
    internal static Type NUnitAssertionExceptionType;
    internal static Type NUnitMultipleAssertExceptionType;
    internal static Type NUnitInconclusiveExceptionType;
    internal static Type NUnitSuccessExceptionType;
    internal static Type NUnitInvalidPlatformException;
    internal static Type DebugAssertExceptionType;
    [ExtensionAttribute]
internal static bool IsAlwaysIgnored(Exception e);
    [ExtensionAttribute]
public static bool IsThrowable(Exception e);
    [ExtensionAttribute]
public static bool IsAssertionError(Exception e);
    [ExtensionAttribute]
public static bool IsError(Exception e);
    [ExtensionAttribute]
public static bool IsException(Exception e);
    [ExtensionAttribute]
public static bool IsRuntimeException(Exception e);
    [ExtensionAttribute]
public static bool IsIOException(Exception e);
    [ExtensionAttribute]
public static bool IsArrayIndexOutOfBoundsException(Exception e);
    [ExtensionAttribute]
public static bool IsStringIndexOutOfBoundsException(Exception e);
    [ExtensionAttribute]
public static bool IsIndexOutOfBoundsException(Exception e);
    [ExtensionAttribute]
public static bool IsNoSuchFileExceptionOrFileNotFoundException(Exception e);
    [ExtensionAttribute]
public static bool IsParseException(Exception e);
    [ExtensionAttribute]
public static bool IsNumberFormatException(Exception e);
    [ExtensionAttribute]
public static bool IsInvocationTargetException(Exception e);
    [ExtensionAttribute]
public static bool IsIllegalAccessException(Exception e);
    [ExtensionAttribute]
public static bool IsIllegalArgumentException(Exception e);
    [ExtensionAttribute]
public static bool IsNullPointerException(Exception e);
    [ExtensionAttribute]
public static bool IsInstantiationException(Exception e);
    [ExtensionAttribute]
public static bool IsUnsupportedOperationException(Exception e);
    [ExtensionAttribute]
public static bool IsUnsupportedEncodingException(Exception e);
    [ExtensionAttribute]
public static bool IsInterruptedException(Exception e);
    [ExtensionAttribute]
public static bool IsCompressorException(Exception e);
    [ExtensionAttribute]
public static bool IsDataFormatException(Exception e);
    [ExtensionAttribute]
public static bool IsSecurityException(Exception e);
    [ExtensionAttribute]
public static bool IsNoSuchDirectoryException(Exception e);
    [ExtensionAttribute]
public static bool IsOutOfMemoryError(Exception e);
    [ExtensionAttribute]
public static bool IsAlreadyClosedException(Exception e);
    [ExtensionAttribute]
public static bool IsClassCastException(Exception e);
    [ExtensionAttribute]
public static bool IsEOFException(Exception e);
    [ExtensionAttribute]
public static bool IsIllegalStateException(Exception e);
    [ExtensionAttribute]
public static bool IsStackOverflowError(Exception e);
    [ExtensionAttribute]
public static bool IsMissingResourceException(Exception e);
    [ExtensionAttribute]
public static bool IsNoClassDefFoundError(Exception e);
    [ExtensionAttribute]
public static bool IsClassNotFoundException(Exception e);
    [ExtensionAttribute]
public static bool IsNoSuchMethodException(Exception e);
    [ExtensionAttribute]
public static bool IsArithmeticException(Exception e);
    [ExtensionAttribute]
public static bool IsAccessDeniedException(Exception e);
    [ExtensionAttribute]
public static bool IsServiceConfigurationError(Exception e);
}
internal interface Lucene.IError {
}
internal class Lucene.IllegalArgumentException : ArgumentException {
    public IllegalArgumentException(string message);
    public IllegalArgumentException(string message, Exception innerException);
    public IllegalArgumentException(Exception cause);
    protected IllegalArgumentException(SerializationInfo info, StreamingContext context);
    public static Exception Create();
    public static Exception Create(string message);
    public static Exception Create(string message, Exception innerException);
    public static Exception Create(string message, string paramName);
    public static Exception Create(string message, string paramName, Exception innerException);
    public static Exception Create(Exception cause);
}
internal class Lucene.IllegalStateException : InvalidOperationException {
    [ObsoleteAttribute("Use IllegalStateException.Create() instead.", "True")]
public IllegalStateException(string message);
    [ObsoleteAttribute("Use IllegalStateException.Create() instead.", "True")]
public IllegalStateException(string message, Exception innerException);
    [ObsoleteAttribute("Use IllegalStateException.Create() instead.", "True")]
public IllegalStateException(Exception cause);
    protected IllegalStateException(SerializationInfo info, StreamingContext context);
    public static Exception Create();
    public static Exception Create(string message);
    public static Exception Create(string message, Exception innerException);
    public static Exception Create(Exception cause);
}
internal class Lucene.IndexOutOfBoundsException : ArgumentOutOfRangeException {
    [ObsoleteAttribute("Use IndexOutOfBoundsException.Create() instead.", "True")]
public IndexOutOfBoundsException(string message);
    [ObsoleteAttribute("Use IndexOutOfBoundsException.Create() instead.", "True")]
public IndexOutOfBoundsException(string message, Exception innerException);
    [ObsoleteAttribute("Use IndexOutOfBoundsException.Create() instead.", "True")]
public IndexOutOfBoundsException(Exception cause);
    protected IndexOutOfBoundsException(SerializationInfo info, StreamingContext context);
    public static Exception Create();
    public static Exception Create(string message);
    public static Exception Create(string paramName, string message);
    public static Exception Create(string paramName, object actualValue, string message);
    public static Exception Create(string message, Exception innerException);
    public static Exception Create(Exception cause);
}
internal interface Lucene.IRuntimeException {
}
public abstract class Lucene.Net.Analysis.Analyzer : object {
    private ReuseStrategy reuseStrategy;
    internal DisposableThreadLocal`1<object> storedValue;
    public static ReuseStrategy GLOBAL_REUSE_STRATEGY;
    public static ReuseStrategy PER_FIELD_REUSE_STRATEGY;
    public ReuseStrategy Strategy { get; }
    protected Analyzer(ReuseStrategy reuseStrategy);
    private static Analyzer();
    public static Analyzer NewAnonymous(Func`3<string, TextReader, TokenStreamComponents> createComponents);
    public static Analyzer NewAnonymous(Func`3<string, TextReader, TokenStreamComponents> createComponents, ReuseStrategy reuseStrategy);
    public static Analyzer NewAnonymous(Func`3<string, TextReader, TokenStreamComponents> createComponents, Func`3<string, TextReader, TextReader> initReader);
    public static Analyzer NewAnonymous(Func`3<string, TextReader, TokenStreamComponents> createComponents, Func`3<string, TextReader, TextReader> initReader, ReuseStrategy reuseStrategy);
    protected internal abstract virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
    public TokenStream GetTokenStream(string fieldName, TextReader reader);
    public TokenStream GetTokenStream(string fieldName, string text);
    protected internal virtual TextReader InitReader(string fieldName, TextReader reader);
    public virtual int GetPositionIncrementGap(string fieldName);
    public virtual int GetOffsetGap(string fieldName);
    public ReuseStrategy get_Strategy();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public abstract class Lucene.Net.Analysis.AnalyzerWrapper : Analyzer {
    protected internal AnalyzerWrapper(ReuseStrategy reuseStrategy);
    protected abstract virtual Analyzer GetWrappedAnalyzer(string fieldName);
    protected virtual TokenStreamComponents WrapComponents(string fieldName, TokenStreamComponents components);
    protected virtual TextReader WrapReader(string fieldName, TextReader reader);
    protected internal sealed virtual TokenStreamComponents CreateComponents(string fieldName, TextReader aReader);
    public virtual int GetPositionIncrementGap(string fieldName);
    public virtual int GetOffsetGap(string fieldName);
    protected internal virtual TextReader InitReader(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.CachingTokenFilter : TokenFilter {
    private IList`1<State> cache;
    private IEnumerator`1<State> iterator;
    private State finalState;
    public CachingTokenFilter(TokenStream input);
    public virtual bool IncrementToken();
    public virtual void End();
    public virtual void Reset();
    private void FillCache();
    protected virtual void Dispose(bool disposing);
}
public abstract class Lucene.Net.Analysis.CharFilter : TextReader {
    protected internal TextReader m_input;
    public bool IsReady { get; }
    public bool IsMarkSupported { get; }
    protected CharFilter(TextReader input);
    protected virtual void Dispose(bool disposing);
    protected abstract virtual int Correct(int currentOff);
    public int CorrectOffset(int currentOff);
    public abstract virtual int Read(Char[] buffer, int index, int count);
    public virtual int Read();
    public virtual long Skip(int n);
    public virtual void Reset();
    public virtual bool get_IsReady();
    public virtual bool get_IsMarkSupported();
    public virtual void Mark(int readAheadLimit);
}
public class Lucene.Net.Analysis.NumericTokenStream : TokenStream {
    public static string TOKEN_TYPE_FULL_PREC;
    public static string TOKEN_TYPE_LOWER_PREC;
    private INumericTermAttribute numericAtt;
    private ITypeAttribute typeAtt;
    private IPositionIncrementAttribute posIncrAtt;
    private int valSize;
    private int precisionStep;
    public int PrecisionStep { get; }
    public NumericTokenStream(int precisionStep);
    public NumericTokenStream(AttributeFactory factory, int precisionStep);
    private void InitializeInstanceFields();
    public NumericTokenStream SetInt64Value(long value);
    public NumericTokenStream SetInt32Value(int value);
    public NumericTokenStream SetDoubleValue(double value);
    public NumericTokenStream SetSingleValue(float value);
    public virtual void Reset();
    public virtual bool IncrementToken();
    public int get_PrecisionStep();
}
public class Lucene.Net.Analysis.ReusableStringReader : TextReader {
    private int pos;
    private int size;
    private string s;
    internal void SetValue(string s);
    public virtual int Read();
    public virtual int Read(Char[] c, int off, int len);
    public virtual string ReadToEnd();
    protected virtual void Dispose(bool disposing);
}
public abstract class Lucene.Net.Analysis.ReuseStrategy : object {
    public abstract virtual TokenStreamComponents GetReusableComponents(Analyzer analyzer, string fieldName);
    public abstract virtual void SetReusableComponents(Analyzer analyzer, string fieldName, TokenStreamComponents components);
    protected internal static object GetStoredValue(Analyzer analyzer);
    protected internal static void SetStoredValue(Analyzer analyzer, object storedValue);
}
public class Lucene.Net.Analysis.Token : CharTermAttribute {
    private int startOffset;
    private int endOffset;
    private string type;
    private int flags;
    private BytesRef payload;
    private int positionIncrement;
    private int positionLength;
    public static AttributeFactory TOKEN_ATTRIBUTE_FACTORY;
    public int PositionIncrement { get; public set; }
    public int PositionLength { get; public set; }
    public int StartOffset { get; }
    public int EndOffset { get; }
    public string Type { get; public set; }
    public int Flags { get; public set; }
    public BytesRef Payload { get; public set; }
    public Token(int start, int end);
    public Token(int start, int end, string typ);
    public Token(int start, int end, int flags);
    public Token(string text, int start, int end);
    public Token(string text, int start, int end, string typ);
    public Token(string text, int start, int end, int flags);
    public Token(Char[] startTermBuffer, int termBufferOffset, int termBufferLength, int start, int end);
    private static Token();
    public virtual int get_PositionIncrement();
    public virtual void set_PositionIncrement(int value);
    public virtual int get_PositionLength();
    public virtual void set_PositionLength(int value);
    public sealed virtual int get_StartOffset();
    public sealed virtual int get_EndOffset();
    public virtual void SetOffset(int startOffset, int endOffset);
    public sealed virtual string get_Type();
    public sealed virtual void set_Type(string value);
    public virtual int get_Flags();
    public virtual void set_Flags(int value);
    public virtual BytesRef get_Payload();
    public virtual void set_Payload(BytesRef value);
    public virtual void Clear();
    public virtual object Clone();
    public virtual Token Clone(Char[] newTermBuffer, int newTermOffset, int newTermLength, int newStartOffset, int newEndOffset);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private void ClearNoTermBuffer();
    public virtual Token Reinit(Char[] newTermBuffer, int newTermOffset, int newTermLength, int newStartOffset, int newEndOffset, string newType);
    public virtual Token Reinit(Char[] newTermBuffer, int newTermOffset, int newTermLength, int newStartOffset, int newEndOffset);
    public virtual Token Reinit(string newTerm, int newStartOffset, int newEndOffset, string newType);
    public virtual Token Reinit(string newTerm, int newTermOffset, int newTermLength, int newStartOffset, int newEndOffset, string newType);
    public virtual Token Reinit(string newTerm, int newStartOffset, int newEndOffset);
    public virtual Token Reinit(string newTerm, int newTermOffset, int newTermLength, int newStartOffset, int newEndOffset);
    public virtual void Reinit(Token prototype);
    public virtual void Reinit(Token prototype, string newTerm);
    public virtual void Reinit(Token prototype, Char[] newTermBuffer, int offset, int length);
    public virtual void CopyTo(IAttribute target);
    public virtual void ReflectWith(IAttributeReflector reflector);
    private void CheckOffsets(int startOffset, int endOffset);
}
[DefaultMemberAttribute("Item")]
public class Lucene.Net.Analysis.TokenAttributes.CharTermAttribute : Attribute {
    private static int MIN_BUFFER_SIZE;
    private Char[] termBuffer;
    private int termLength;
    private BytesRef bytes;
    private bool J2N.Text.ICharSequence.HasValue { get; }
    private Char[] Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Buffer { get; }
    [WritableArrayAttribute]
public Char[] Buffer { get; }
    private int Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Length { get; private set; }
    private int J2N.Text.ICharSequence.Length { get; }
    public int Length { get; public set; }
    public BytesRef BytesRef { get; }
    private char J2N.Text.ICharSequence.Item { get; }
    private char Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Item { get; private set; }
    public char Item { get; public set; }
    private sealed virtual override bool J2N.Text.ICharSequence.get_HasValue();
    public void CopyBuffer(Char[] buffer, int offset, int length);
    private sealed virtual override Char[] Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.get_Buffer();
    public Char[] get_Buffer();
    public Char[] ResizeBuffer(int newSize);
    private void GrowTermBuffer(int newSize);
    private sealed virtual override int Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.get_Length();
    private sealed virtual override void Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.set_Length(int value);
    private sealed virtual override int J2N.Text.ICharSequence.get_Length();
    public int get_Length();
    public void set_Length(int value);
    public CharTermAttribute SetLength(int length);
    public CharTermAttribute SetEmpty();
    public virtual void FillBytesRef();
    public virtual BytesRef get_BytesRef();
    private sealed virtual override char J2N.Text.ICharSequence.get_Item(int index);
    private sealed virtual override char Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.get_Item(int index);
    private sealed virtual override void Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.set_Item(int index, char value);
    public char get_Item(int index);
    public void set_Item(int index, char value);
    public sealed virtual ICharSequence Subsequence(int startIndex, int length);
    public CharTermAttribute Append(string value, int startIndex, int charCount);
    public CharTermAttribute Append(char value);
    public CharTermAttribute Append(Char[] value);
    public CharTermAttribute Append(Char[] value, int startIndex, int charCount);
    public CharTermAttribute Append(string value);
    public CharTermAttribute Append(StringBuilder value);
    public CharTermAttribute Append(StringBuilder value, int startIndex, int charCount);
    public CharTermAttribute Append(ICharTermAttribute value);
    public CharTermAttribute Append(ICharSequence value);
    public CharTermAttribute Append(ICharSequence value, int startIndex, int charCount);
    private Char[] InternalResizeBuffer(int length);
    private static Char[] CreateBuffer(int length);
    public virtual int GetHashCode();
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Equals(object other);
    public virtual string ToString();
    public virtual void ReflectWith(IAttributeReflector reflector);
    public virtual void CopyTo(IAttribute target);
    private sealed virtual override void Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.CopyBuffer(Char[] buffer, int offset, int length);
    private sealed virtual override Char[] Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.ResizeBuffer(int newSize);
    private sealed virtual override ICharTermAttribute Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.SetLength(int length);
    private sealed virtual override ICharTermAttribute Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.SetEmpty();
    private sealed virtual override ICharTermAttribute Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(ICharSequence value);
    private sealed virtual override ICharTermAttribute Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(ICharSequence value, int startIndex, int count);
    private sealed virtual override ICharTermAttribute Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(char value);
    private sealed virtual override ICharTermAttribute Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(Char[] value);
    private sealed virtual override ICharTermAttribute Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(Char[] value, int startIndex, int count);
    private sealed virtual override ICharTermAttribute Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(string value);
    private sealed virtual override ICharTermAttribute Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(string value, int startIndex, int count);
    private sealed virtual override ICharTermAttribute Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(StringBuilder value);
    private sealed virtual override ICharTermAttribute Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(StringBuilder value, int startIndex, int count);
    private sealed virtual override ICharTermAttribute Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(ICharTermAttribute value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(char value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(string value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(string value, int startIndex, int count);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(StringBuilder value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(StringBuilder value, int startIndex, int count);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(Char[] value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(Char[] value, int startIndex, int count);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(ICharSequence value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(ICharSequence value, int startIndex, int count);
}
public class Lucene.Net.Analysis.TokenAttributes.FlagsAttribute : Attribute {
    private int flags;
    public int Flags { get; public set; }
    public virtual int get_Flags();
    public virtual void set_Flags(int value);
    public virtual void Clear();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual void CopyTo(IAttribute target);
}
[DefaultMemberAttribute("Item")]
public interface Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute {
    public Char[] Buffer { get; }
    public int Length { get; public set; }
    public char Item { get; public set; }
    public abstract virtual void CopyBuffer(Char[] buffer, int offset, int length);
    public abstract virtual Char[] get_Buffer();
    public abstract virtual Char[] ResizeBuffer(int newSize);
    public abstract virtual int get_Length();
    public abstract virtual void set_Length(int value);
    public abstract virtual char get_Item(int index);
    public abstract virtual void set_Item(int index, char value);
    public abstract virtual ICharTermAttribute SetLength(int length);
    public abstract virtual ICharTermAttribute SetEmpty();
    public abstract virtual ICharTermAttribute Append(ICharSequence value);
    public abstract virtual ICharTermAttribute Append(ICharSequence value, int startIndex, int count);
    public abstract virtual ICharTermAttribute Append(char value);
    public abstract virtual ICharTermAttribute Append(Char[] value);
    public abstract virtual ICharTermAttribute Append(Char[] value, int startIndex, int count);
    public abstract virtual ICharTermAttribute Append(string value);
    public abstract virtual ICharTermAttribute Append(string value, int startIndex, int count);
    public abstract virtual ICharTermAttribute Append(StringBuilder value);
    public abstract virtual ICharTermAttribute Append(StringBuilder value, int startIndex, int count);
    public abstract virtual ICharTermAttribute Append(ICharTermAttribute value);
}
public interface Lucene.Net.Analysis.TokenAttributes.IFlagsAttribute {
    public int Flags { get; public set; }
    public abstract virtual int get_Flags();
    public abstract virtual void set_Flags(int value);
}
public interface Lucene.Net.Analysis.TokenAttributes.IKeywordAttribute {
    public bool IsKeyword { get; public set; }
    public abstract virtual bool get_IsKeyword();
    public abstract virtual void set_IsKeyword(bool value);
}
public interface Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute {
    public int StartOffset { get; }
    public int EndOffset { get; }
    public abstract virtual int get_StartOffset();
    public abstract virtual void SetOffset(int startOffset, int endOffset);
    public abstract virtual int get_EndOffset();
}
public interface Lucene.Net.Analysis.TokenAttributes.IPayloadAttribute {
    public BytesRef Payload { get; public set; }
    public abstract virtual BytesRef get_Payload();
    public abstract virtual void set_Payload(BytesRef value);
}
public interface Lucene.Net.Analysis.TokenAttributes.IPositionIncrementAttribute {
    public int PositionIncrement { get; public set; }
    public abstract virtual void set_PositionIncrement(int value);
    public abstract virtual int get_PositionIncrement();
}
public interface Lucene.Net.Analysis.TokenAttributes.IPositionLengthAttribute {
    public int PositionLength { get; public set; }
    public abstract virtual void set_PositionLength(int value);
    public abstract virtual int get_PositionLength();
}
public interface Lucene.Net.Analysis.TokenAttributes.ITermToBytesRefAttribute {
    public BytesRef BytesRef { get; }
    public abstract virtual void FillBytesRef();
    public abstract virtual BytesRef get_BytesRef();
}
public interface Lucene.Net.Analysis.TokenAttributes.ITypeAttribute {
    public string Type { get; public set; }
    public abstract virtual string get_Type();
    public abstract virtual void set_Type(string value);
}
public class Lucene.Net.Analysis.TokenAttributes.KeywordAttribute : Attribute {
    private bool keyword;
    public bool IsKeyword { get; public set; }
    public virtual void Clear();
    public virtual void CopyTo(IAttribute target);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool get_IsKeyword();
    public sealed virtual void set_IsKeyword(bool value);
}
public class Lucene.Net.Analysis.TokenAttributes.OffsetAttribute : Attribute {
    private int startOffset;
    private int endOffset;
    public int StartOffset { get; }
    public int EndOffset { get; }
    public virtual int get_StartOffset();
    public virtual void SetOffset(int startOffset, int endOffset);
    public virtual int get_EndOffset();
    public virtual void Clear();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual void CopyTo(IAttribute target);
}
public class Lucene.Net.Analysis.TokenAttributes.PayloadAttribute : Attribute {
    private BytesRef payload;
    public BytesRef Payload { get; public set; }
    public PayloadAttribute(BytesRef payload);
    public virtual BytesRef get_Payload();
    public virtual void set_Payload(BytesRef value);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual void CopyTo(IAttribute target);
}
public class Lucene.Net.Analysis.TokenAttributes.PositionIncrementAttribute : Attribute {
    private int positionIncrement;
    public int PositionIncrement { get; public set; }
    public virtual int get_PositionIncrement();
    public virtual void set_PositionIncrement(int value);
    public virtual void Clear();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual void CopyTo(IAttribute target);
}
public class Lucene.Net.Analysis.TokenAttributes.PositionLengthAttribute : Attribute {
    private int positionLength;
    public int PositionLength { get; public set; }
    public virtual int get_PositionLength();
    public virtual void set_PositionLength(int value);
    public virtual void Clear();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual void CopyTo(IAttribute target);
}
public class Lucene.Net.Analysis.TokenAttributes.TypeAttribute : Attribute {
    public static string DEFAULT_TYPE;
    private string type;
    public string Type { get; public set; }
    public TypeAttribute(string type);
    public virtual string get_Type();
    public virtual void set_Type(string value);
    public virtual void Clear();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual void CopyTo(IAttribute target);
}
public abstract class Lucene.Net.Analysis.TokenFilter : TokenStream {
    protected TokenStream m_input;
    protected internal TokenFilter(TokenStream input);
    public virtual void End();
    protected virtual void Dispose(bool disposing);
    public virtual void Reset();
}
public abstract class Lucene.Net.Analysis.Tokenizer : TokenStream {
    protected TextReader m_input;
    private TextReader inputPending;
    private static TextReader ILLEGAL_STATE_READER;
    protected internal Tokenizer(TextReader input);
    protected internal Tokenizer(AttributeFactory factory, TextReader input);
    private static Tokenizer();
    protected virtual void Dispose(bool disposing);
    protected internal int CorrectOffset(int currentOff);
    public void SetReader(TextReader input);
    public virtual void Reset();
    internal virtual bool SetReaderTestPoint();
}
public abstract class Lucene.Net.Analysis.TokenStream : AttributeSource {
    protected TokenStream(AttributeSource input);
    protected TokenStream(AttributeFactory factory);
    public abstract virtual bool IncrementToken();
    public virtual void End();
    public virtual void Reset();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class Lucene.Net.Analysis.TokenStreamComponents : object {
    protected Tokenizer m_source;
    protected TokenStream m_sink;
    internal ReusableStringReader reusableStringReader;
    public TokenStream TokenStream { get; }
    public Tokenizer Tokenizer { get; }
    public TokenStreamComponents(Tokenizer source, TokenStream result);
    public TokenStreamComponents(Tokenizer source);
    protected internal virtual void SetReader(TextReader reader);
    public virtual TokenStream get_TokenStream();
    public virtual Tokenizer get_Tokenizer();
}
public class Lucene.Net.Analysis.TokenStreamToAutomaton : object {
    private bool preservePositionIncrements;
    private bool unicodeArcs;
    public static int POS_SEP;
    public static int HOLE;
    public bool PreservePositionIncrements { get; public set; }
    public bool UnicodeArcs { get; public set; }
    public virtual bool get_PreservePositionIncrements();
    public virtual void set_PreservePositionIncrements(bool value);
    public virtual bool get_UnicodeArcs();
    public virtual void set_UnicodeArcs(bool value);
    protected internal virtual BytesRef ChangeToken(BytesRef in);
    public virtual Automaton ToAutomaton(TokenStream in);
    private static void AddHoles(State startState, RollingBuffer`1<Position> positions, int pos);
}
public class Lucene.Net.Codecs.BlockTermState : OrdTermState {
    [CompilerGeneratedAttribute]
private int <DocFreq>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalTermFreq>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TermBlockOrd>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BlockFilePointer>k__BackingField;
    public int DocFreq { get; public set; }
    public long TotalTermFreq { get; public set; }
    public int TermBlockOrd { get; public set; }
    public long BlockFilePointer { get; public set; }
    [CompilerGeneratedAttribute]
public int get_DocFreq();
    [CompilerGeneratedAttribute]
public void set_DocFreq(int value);
    [CompilerGeneratedAttribute]
public long get_TotalTermFreq();
    [CompilerGeneratedAttribute]
public void set_TotalTermFreq(long value);
    [CompilerGeneratedAttribute]
public int get_TermBlockOrd();
    [CompilerGeneratedAttribute]
public void set_TermBlockOrd(int value);
    [CompilerGeneratedAttribute]
public long get_BlockFilePointer();
    [CompilerGeneratedAttribute]
public void set_BlockFilePointer(long value);
    public virtual void CopyFrom(TermState other);
    public virtual string ToString();
}
public class Lucene.Net.Codecs.BlockTreeTermsReader : FieldsProducer {
    private IndexInput in;
    private PostingsReaderBase postingsReader;
    private IDictionary`2<string, FieldReader> fields;
    private long dirOffset;
    private long indexDirOffset;
    private string segment;
    private int version;
    internal Outputs`1<BytesRef> fstOutputs;
    internal BytesRef NO_OUTPUT;
    public int Count { get; }
    public BlockTreeTermsReader(Directory dir, FieldInfos fieldInfos, SegmentInfo info, PostingsReaderBase postingsReader, IOContext ioContext, string segmentSuffix, int indexDivisor);
    protected virtual int ReadHeader(IndexInput input);
    protected virtual int ReadIndexHeader(IndexInput input);
    protected virtual void SeekDir(IndexInput input, long dirOffset);
    protected virtual void Dispose(bool disposing);
    public virtual IEnumerator`1<string> GetEnumerator();
    public virtual Terms GetTerms(string field);
    public virtual int get_Count();
    internal virtual string BrToString(BytesRef b);
    public virtual long RamBytesUsed();
    public virtual void CheckIntegrity();
}
public class Lucene.Net.Codecs.BlockTreeTermsWriter : FieldsConsumer {
    public static int DEFAULT_MIN_BLOCK_SIZE;
    public static int DEFAULT_MAX_BLOCK_SIZE;
    internal static int OUTPUT_FLAGS_NUM_BITS;
    internal static int OUTPUT_FLAGS_MASK;
    internal static int OUTPUT_FLAG_IS_FLOOR;
    internal static int OUTPUT_FLAG_HAS_TERMS;
    internal static string TERMS_EXTENSION;
    internal static string TERMS_CODEC_NAME;
    public static int VERSION_START;
    public static int VERSION_APPEND_ONLY;
    public static int VERSION_META_ARRAY;
    public static int VERSION_CHECKSUM;
    public static int VERSION_CURRENT;
    internal static string TERMS_INDEX_EXTENSION;
    internal static string TERMS_INDEX_CODEC_NAME;
    private IndexOutput out;
    private IndexOutput indexOut;
    internal int minItemsInBlock;
    internal int maxItemsInBlock;
    internal PostingsWriterBase postingsWriter;
    internal FieldInfos fieldInfos;
    internal FieldInfo currentField;
    private IList`1<FieldMetaData> fields;
    internal RAMOutputStream scratchBytes;
    public BlockTreeTermsWriter(SegmentWriteState state, PostingsWriterBase postingsWriter, int minItemsInBlock, int maxItemsInBlock);
    protected internal virtual void WriteHeader(IndexOutput out);
    protected internal virtual void WriteIndexHeader(IndexOutput out);
    protected internal virtual void WriteTrailer(IndexOutput out, long dirStart);
    protected internal virtual void WriteIndexTrailer(IndexOutput indexOut, long dirStart);
    public virtual TermsConsumer AddField(FieldInfo field);
    internal static long EncodeOutput(long fp, bool hasTerms, bool isFloor);
    protected virtual void Dispose(bool disposing);
}
public abstract class Lucene.Net.Codecs.Codec : object {
    private static ICodecFactory codecFactory;
    private string name;
    private static Codec defaultCodec;
    public string Name { get; }
    public PostingsFormat PostingsFormat { get; }
    public DocValuesFormat DocValuesFormat { get; }
    public StoredFieldsFormat StoredFieldsFormat { get; }
    public TermVectorsFormat TermVectorsFormat { get; }
    public FieldInfosFormat FieldInfosFormat { get; }
    public SegmentInfoFormat SegmentInfoFormat { get; }
    public NormsFormat NormsFormat { get; }
    public LiveDocsFormat LiveDocsFormat { get; }
    public static ICollection`1<string> AvailableCodecs { get; }
    public static Codec Default { get; public set; }
    private static Codec();
    public static void SetCodecFactory(ICodecFactory codecFactory);
    public static ICodecFactory GetCodecFactory();
    public string get_Name();
    public abstract virtual PostingsFormat get_PostingsFormat();
    public abstract virtual DocValuesFormat get_DocValuesFormat();
    public abstract virtual StoredFieldsFormat get_StoredFieldsFormat();
    public abstract virtual TermVectorsFormat get_TermVectorsFormat();
    public abstract virtual FieldInfosFormat get_FieldInfosFormat();
    public abstract virtual SegmentInfoFormat get_SegmentInfoFormat();
    public abstract virtual NormsFormat get_NormsFormat();
    public abstract virtual LiveDocsFormat get_LiveDocsFormat();
    public static Codec ForName(string name);
    public static ICollection`1<string> get_AvailableCodecs();
    public static Codec get_Default();
    public static void set_Default(Codec value);
    public virtual string ToString();
}
[AttributeUsageAttribute("4")]
public class Lucene.Net.Codecs.CodecNameAttribute : ServiceNameAttribute {
    public CodecNameAttribute(string name);
}
public static class Lucene.Net.Codecs.CodecUtil : object {
    public static int CODEC_MAGIC;
    public static int FOOTER_MAGIC;
    private static CodecUtil();
    public static void WriteHeader(DataOutput out, string codec, int version);
    public static int HeaderLength(string codec);
    public static int CheckHeader(DataInput in, string codec, int minVersion, int maxVersion);
    public static int CheckHeaderNoMagic(DataInput in, string codec, int minVersion, int maxVersion);
    public static void WriteFooter(IndexOutput out);
    public static int FooterLength();
    public static long CheckFooter(ChecksumIndexInput in);
    public static long RetrieveChecksum(IndexInput in);
    private static void ValidateFooter(IndexInput in);
    [ObsoleteAttribute("Use CheckFooter(ChecksumIndexInput) instead, this should only used for files without checksums.")]
public static void CheckEOF(IndexInput in);
    public static long ChecksumEntireFile(IndexInput input);
}
public class Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat : StoredFieldsFormat {
    private string formatName;
    private string segmentSuffix;
    private CompressionMode compressionMode;
    private int chunkSize;
    public CompressingStoredFieldsFormat(string formatName, CompressionMode compressionMode, int chunkSize);
    public CompressingStoredFieldsFormat(string formatName, string segmentSuffix, CompressionMode compressionMode, int chunkSize);
    public virtual StoredFieldsReader FieldsReader(Directory directory, SegmentInfo si, FieldInfos fn, IOContext context);
    public virtual StoredFieldsWriter FieldsWriter(Directory directory, SegmentInfo si, IOContext context);
    public virtual string ToString();
}
public class Lucene.Net.Codecs.Compressing.CompressingStoredFieldsIndexReader : object {
    internal int maxDoc;
    internal Int32[] docBases;
    internal Int64[] startPointers;
    internal Int32[] avgChunkDocs;
    internal Int64[] avgChunkSizes;
    internal Reader[] docBasesDeltas;
    internal Reader[] startPointersDeltas;
    internal CompressingStoredFieldsIndexReader(IndexInput fieldsIndexIn, SegmentInfo si);
    internal static long MoveLowOrderBitToSign(long n);
    private int Block(int docID);
    private int RelativeDocBase(int block, int relativeChunk);
    private long RelativeStartPointer(int block, int relativeChunk);
    private int RelativeChunk(int block, int relativeDoc);
    internal long GetStartPointer(int docID);
    public object Clone();
    internal long RamBytesUsed();
}
public class Lucene.Net.Codecs.Compressing.CompressingStoredFieldsIndexWriter : object {
    internal static int BLOCK_SIZE;
    internal IndexOutput fieldsIndexOut;
    internal int totalDocs;
    internal int blockDocs;
    internal int blockChunks;
    internal long firstStartPointer;
    internal long maxStartPointer;
    internal Int32[] docBaseDeltas;
    internal Int64[] startPointerDeltas;
    internal CompressingStoredFieldsIndexWriter(IndexOutput indexOutput);
    internal static long MoveSignToLowOrderBit(long n);
    private void Reset();
    private void WriteBlock();
    internal void WriteIndex(int numDocs, long startPointer);
    internal void Finish(int numDocs, long maxPointer);
    public sealed virtual void Dispose();
}
public class Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader : StoredFieldsReader {
    private static int BUFFER_REUSE_THRESHOLD;
    private int version;
    private FieldInfos fieldInfos;
    private CompressingStoredFieldsIndexReader indexReader;
    private long maxPointer;
    private IndexInput fieldsStream;
    private int chunkSize;
    private int packedIntsVersion;
    private CompressionMode compressionMode;
    private Decompressor decompressor;
    private BytesRef bytes;
    private int numDocs;
    private bool closed;
    internal int Version { get; }
    internal CompressionMode CompressionMode { get; }
    internal int ChunkSize { get; }
    private CompressingStoredFieldsReader(CompressingStoredFieldsReader reader);
    public CompressingStoredFieldsReader(Directory d, SegmentInfo si, string segmentSuffix, FieldInfos fn, IOContext context, string formatName, CompressionMode compressionMode);
    private void EnsureOpen();
    protected virtual void Dispose(bool disposing);
    private static void ReadField(DataInput in, StoredFieldVisitor visitor, FieldInfo info, int bits);
    private static void SkipField(DataInput in, int bits);
    public virtual void VisitDocument(int docID, StoredFieldVisitor visitor);
    public virtual object Clone();
    internal int get_Version();
    internal CompressionMode get_CompressionMode();
    internal int get_ChunkSize();
    internal ChunkIterator GetChunkIterator(int startDocID);
    public virtual long RamBytesUsed();
    public virtual void CheckIntegrity();
}
public class Lucene.Net.Codecs.Compressing.CompressingStoredFieldsWriter : StoredFieldsWriter {
    internal static int MAX_DOCUMENTS_PER_CHUNK;
    internal static int STRING;
    internal static int BYTE_ARR;
    internal static int NUMERIC_INT32;
    internal static int NUMERIC_SINGLE;
    internal static int NUMERIC_INT64;
    internal static int NUMERIC_DOUBLE;
    internal static int TYPE_BITS;
    internal static int TYPE_MASK;
    internal static string CODEC_SFX_IDX;
    internal static string CODEC_SFX_DAT;
    internal static int VERSION_START;
    internal static int VERSION_BIG_CHUNKS;
    internal static int VERSION_CHECKSUM;
    internal static int VERSION_CURRENT;
    private Directory directory;
    private string segment;
    private string segmentSuffix;
    private CompressingStoredFieldsIndexWriter indexWriter;
    private IndexOutput fieldsStream;
    private CompressionMode compressionMode;
    private Compressor compressor;
    private int chunkSize;
    private GrowableByteArrayDataOutput bufferedDocs;
    private Int32[] numStoredFields;
    private Int32[] endOffsets;
    private int docBase;
    private int numBufferedDocs;
    public CompressingStoredFieldsWriter(Directory directory, SegmentInfo si, string segmentSuffix, IOContext context, string formatName, CompressionMode compressionMode, int chunkSize);
    private static CompressingStoredFieldsWriter();
    protected virtual void Dispose(bool disposing);
    public virtual void StartDocument(int numStoredFields);
    public virtual void FinishDocument();
    private static void SaveInt32s(Int32[] values, int length, DataOutput out);
    private void WriteHeader(int docBase, int numBufferedDocs, Int32[] numStoredFields, Int32[] lengths);
    private bool TriggerFlush();
    private void Flush();
    public virtual void WriteField(FieldInfo info, IIndexableField field);
    public virtual void Abort();
    public virtual void Finish(FieldInfos fis, int numDocs);
    public virtual int Merge(MergeState mergeState);
    private static int NextLiveDoc(int doc, IBits liveDocs, int maxDoc);
    private static int NextDeletedDoc(int doc, IBits liveDocs, int maxDoc);
}
public class Lucene.Net.Codecs.Compressing.CompressingTermVectorsFormat : TermVectorsFormat {
    private string formatName;
    private string segmentSuffix;
    private CompressionMode compressionMode;
    private int chunkSize;
    public CompressingTermVectorsFormat(string formatName, string segmentSuffix, CompressionMode compressionMode, int chunkSize);
    public sealed virtual TermVectorsReader VectorsReader(Directory directory, SegmentInfo segmentInfo, FieldInfos fieldInfos, IOContext context);
    public sealed virtual TermVectorsWriter VectorsWriter(Directory directory, SegmentInfo segmentInfo, IOContext context);
    public virtual string ToString();
}
public class Lucene.Net.Codecs.Compressing.CompressingTermVectorsReader : TermVectorsReader {
    private FieldInfos fieldInfos;
    internal CompressingStoredFieldsIndexReader indexReader;
    internal IndexInput vectorsStream;
    private int version;
    private int packedIntsVersion;
    private CompressionMode compressionMode;
    private Decompressor decompressor;
    private int chunkSize;
    private int numDocs;
    private bool closed;
    private BlockPackedReaderIterator reader;
    internal CompressionMode CompressionMode { get; }
    internal int ChunkSize { get; }
    internal int PackedInt32sVersion { get; }
    internal int Version { get; }
    internal CompressingStoredFieldsIndexReader Index { get; }
    internal IndexInput VectorsStream { get; }
    private CompressingTermVectorsReader(CompressingTermVectorsReader reader);
    public CompressingTermVectorsReader(Directory d, SegmentInfo si, string segmentSuffix, FieldInfos fn, IOContext context, string formatName, CompressionMode compressionMode);
    internal CompressionMode get_CompressionMode();
    internal int get_ChunkSize();
    internal int get_PackedInt32sVersion();
    internal int get_Version();
    internal CompressingStoredFieldsIndexReader get_Index();
    internal IndexInput get_VectorsStream();
    private void EnsureOpen();
    protected virtual void Dispose(bool disposing);
    public virtual object Clone();
    public virtual Fields Get(int doc);
    private Int32[][] PositionIndex(int skip, int numFields, Reader numTerms, Int32[] termFreqs);
    private Int32[][] ReadPositions(int skip, int numFields, Reader flags, Reader numTerms, Int32[] termFreqs, int flag, int totalPositions, Int32[][] positionIndex);
    private static int Sum(Int32[] arr);
    public virtual long RamBytesUsed();
    public virtual void CheckIntegrity();
}
public class Lucene.Net.Codecs.Compressing.CompressingTermVectorsWriter : TermVectorsWriter {
    internal static int MAX_DOCUMENTS_PER_CHUNK;
    internal static string VECTORS_EXTENSION;
    internal static string VECTORS_INDEX_EXTENSION;
    internal static string CODEC_SFX_IDX;
    internal static string CODEC_SFX_DAT;
    internal static int VERSION_START;
    internal static int VERSION_CHECKSUM;
    internal static int VERSION_CURRENT;
    internal static int BLOCK_SIZE;
    internal static int POSITIONS;
    internal static int OFFSETS;
    internal static int PAYLOADS;
    internal static int FLAGS_BITS;
    private Directory directory;
    private string segment;
    private string segmentSuffix;
    private CompressingStoredFieldsIndexWriter indexWriter;
    private IndexOutput vectorsStream;
    private CompressionMode compressionMode;
    private Compressor compressor;
    private int chunkSize;
    private int numDocs;
    private LinkedList`1<DocData> pendingDocs;
    private DocData curDoc;
    private FieldData curField;
    private BytesRef lastTerm;
    private Int32[] positionsBuf;
    private Int32[] startOffsetsBuf;
    private Int32[] lengthsBuf;
    private Int32[] payloadLengthsBuf;
    private GrowableByteArrayDataOutput termSuffixes;
    private GrowableByteArrayDataOutput payloadBytes;
    private BlockPackedWriter writer;
    public IComparer`1<BytesRef> Comparer { get; }
    public CompressingTermVectorsWriter(Directory directory, SegmentInfo si, string segmentSuffix, IOContext context, string formatName, CompressionMode compressionMode, int chunkSize);
    private static CompressingTermVectorsWriter();
    private DocData AddDocData(int numVectorFields);
    protected virtual void Dispose(bool disposing);
    public virtual void Abort();
    public virtual void StartDocument(int numVectorFields);
    public virtual void FinishDocument();
    public virtual void StartField(FieldInfo info, int numTerms, bool positions, bool offsets, bool payloads);
    public virtual void FinishField();
    public virtual void StartTerm(BytesRef term, int freq);
    public virtual void AddPosition(int position, int startOffset, int endOffset, BytesRef payload);
    private bool TriggerFlush();
    private void Flush();
    private int FlushNumFields(int chunkDocs);
    private Int32[] FlushFieldNums();
    private void FlushFields(int totalFields, Int32[] fieldNums);
    private void FlushFlags(int totalFields, Int32[] fieldNums);
    private void FlushNumTerms(int totalFields);
    private void FlushTermLengths();
    private void FlushTermFreqs();
    private void FlushPositions();
    private void FlushOffsets(Int32[] fieldNums);
    private void FlushPayloadLengths();
    public virtual void Finish(FieldInfos fis, int numDocs);
    public virtual IComparer`1<BytesRef> get_Comparer();
    public virtual void AddProx(int numProx, DataInput positions, DataInput offsets);
    public virtual int Merge(MergeState mergeState);
    private static int NextLiveDoc(int doc, IBits liveDocs, int maxDoc);
    private static int NextDeletedDoc(int doc, IBits liveDocs, int maxDoc);
}
public abstract class Lucene.Net.Codecs.Compressing.CompressionMode : object {
    public static CompressionMode FAST;
    public static CompressionMode HIGH_COMPRESSION;
    public static CompressionMode FAST_DECOMPRESSION;
    private static Decompressor LZ4_DECOMPRESSOR;
    private static CompressionMode();
    public abstract virtual Compressor NewCompressor();
    public abstract virtual Decompressor NewDecompressor();
}
public abstract class Lucene.Net.Codecs.Compressing.Compressor : object {
    public abstract virtual void Compress(Byte[] bytes, int off, int len, DataOutput out);
}
public abstract class Lucene.Net.Codecs.Compressing.Decompressor : object {
    public abstract virtual void Decompress(DataInput in, int originalLength, int offset, int length, BytesRef bytes);
    public abstract virtual object Clone();
}
public static class Lucene.Net.Codecs.Compressing.LZ4 : object {
    internal static int MEMORY_USAGE;
    internal static int MIN_MATCH;
    internal static int MAX_DISTANCE;
    internal static int LAST_LITERALS;
    internal static int HASH_LOG_HC;
    internal static int HASH_TABLE_SIZE_HC;
    internal static int OPTIMAL_ML;
    private static int Hash(int i, int hashBits);
    private static int HashHC(int i);
    private static int ReadInt32(Byte[] buf, int i);
    private static bool ReadInt32Equals(Byte[] buf, int i, int j);
    private static int CommonBytes(Byte[] b, int o1, int o2, int limit);
    private static int CommonBytesBackward(Byte[] b, int o1, int o2, int l1, int l2);
    public static int Decompress(DataInput compressed, int decompressedLen, Byte[] dest, int dOff);
    private static void EncodeLen(int l, DataOutput out);
    private static void EncodeLiterals(Byte[] bytes, int token, int anchor, int literalLen, DataOutput out);
    private static void EncodeLastLiterals(Byte[] bytes, int anchor, int literalLen, DataOutput out);
    private static void EncodeSequence(Byte[] bytes, int anchor, int matchRef, int matchOff, int matchLen, DataOutput out);
    public static void Compress(Byte[] bytes, int off, int len, DataOutput out, HashTable ht);
    private static void CopyTo(Match m1, Match m2);
    public static void CompressHC(Byte[] src, int srcOff, int srcLen, DataOutput out, HCHashTable ht);
}
public class Lucene.Net.Codecs.DefaultCodecFactory : NamedServiceFactory`1<Codec> {
    private static Type[] localCodecTypes;
    private IDictionary`2<string, Type> codecNameToTypeMap;
    private IDictionary`2<Type, Codec> codecInstanceCache;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <CustomCodecTypes>k__BackingField;
    public IEnumerable`1<Type> CustomCodecTypes { get; public set; }
    public ICollection`1<string> AvailableServices { get; }
    private static DefaultCodecFactory();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_CustomCodecTypes();
    [CompilerGeneratedAttribute]
public void set_CustomCodecTypes(IEnumerable`1<Type> value);
    protected virtual void Initialize();
    protected virtual void ScanForCodecs(IEnumerable`1<Assembly> assemblies);
    protected virtual void ScanForCodecs(Assembly assembly);
    protected virtual void PutCodecType(Type codec);
    private void PutCodecTypeImpl(Type codec);
    public virtual Codec GetCodec(string name);
    protected virtual Codec GetCodec(Type type);
    protected virtual Codec NewCodec(Type type);
    protected virtual Type GetCodecType(string name);
    public virtual ICollection`1<string> get_AvailableServices();
}
public class Lucene.Net.Codecs.DefaultDocValuesFormatFactory : NamedServiceFactory`1<DocValuesFormat> {
    private static Type[] localDocValuesFormatTypes;
    private IDictionary`2<string, Type> docValuesFormatNameToTypeMap;
    private IDictionary`2<Type, DocValuesFormat> docValuesFormatInstanceCache;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <CustomDocValuesFormatTypes>k__BackingField;
    public IEnumerable`1<Type> CustomDocValuesFormatTypes { get; public set; }
    public ICollection`1<string> AvailableServices { get; }
    private static DefaultDocValuesFormatFactory();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_CustomDocValuesFormatTypes();
    [CompilerGeneratedAttribute]
public void set_CustomDocValuesFormatTypes(IEnumerable`1<Type> value);
    protected virtual void Initialize();
    protected virtual void ScanForDocValuesFormats(IEnumerable`1<Assembly> assemblies);
    protected virtual void ScanForDocValuesFormats(Assembly assembly);
    protected virtual void PutDocValuesFormatType(Type docValuesFormat);
    private void PutDocValuesFormatTypeImpl(Type docValuesFormat);
    public virtual DocValuesFormat GetDocValuesFormat(string name);
    protected virtual DocValuesFormat GetDocValuesFormat(Type type);
    protected virtual DocValuesFormat NewDocValuesFormat(Type type);
    protected virtual Type GetDocValuesFormatType(string name);
    public virtual ICollection`1<string> get_AvailableServices();
}
public class Lucene.Net.Codecs.DefaultPostingsFormatFactory : NamedServiceFactory`1<PostingsFormat> {
    private static Type[] localPostingsFormatTypes;
    private IDictionary`2<string, Type> postingsFormatNameToTypeMap;
    private IDictionary`2<Type, PostingsFormat> postingsFormatInstanceCache;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <CustomPostingsFormatTypes>k__BackingField;
    public IEnumerable`1<Type> CustomPostingsFormatTypes { get; public set; }
    public ICollection`1<string> AvailableServices { get; }
    private static DefaultPostingsFormatFactory();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_CustomPostingsFormatTypes();
    [CompilerGeneratedAttribute]
public void set_CustomPostingsFormatTypes(IEnumerable`1<Type> value);
    protected virtual void Initialize();
    protected virtual void ScanForPostingsFormats(IEnumerable`1<Assembly> assemblies);
    protected virtual void ScanForPostingsFormats(Assembly assembly);
    protected virtual void PutPostingsFormatType(Type postingsFormat);
    private void PutPostingsFormatTypeImpl(Type postingsFormat);
    public virtual PostingsFormat GetPostingsFormat(string name);
    protected virtual PostingsFormat GetPostingsFormat(Type type);
    protected virtual PostingsFormat NewPostingsFormat(Type type);
    protected virtual Type GetPostingsFormatType(string name);
    public virtual ICollection`1<string> get_AvailableServices();
}
public abstract class Lucene.Net.Codecs.DocValuesConsumer : object {
    public abstract virtual void AddNumericField(FieldInfo field, IEnumerable`1<Nullable`1<long>> values);
    public abstract virtual void AddBinaryField(FieldInfo field, IEnumerable`1<BytesRef> values);
    public abstract virtual void AddSortedField(FieldInfo field, IEnumerable`1<BytesRef> values, IEnumerable`1<Nullable`1<long>> docToOrd);
    public abstract virtual void AddSortedSetField(FieldInfo field, IEnumerable`1<BytesRef> values, IEnumerable`1<Nullable`1<long>> docToOrdCount, IEnumerable`1<Nullable`1<long>> ords);
    public virtual void MergeNumericField(FieldInfo fieldInfo, MergeState mergeState, IList`1<NumericDocValues> toMerge, IList`1<IBits> docsWithField);
    [IteratorStateMachineAttribute("Lucene.Net.Codecs.DocValuesConsumer/<GetMergeNumericFieldEnumerable>d__6")]
private IEnumerable`1<Nullable`1<long>> GetMergeNumericFieldEnumerable(MergeState mergeState, IList`1<NumericDocValues> toMerge, IList`1<IBits> docsWithField);
    public virtual void MergeBinaryField(FieldInfo fieldInfo, MergeState mergeState, IList`1<BinaryDocValues> toMerge, IList`1<IBits> docsWithField);
    [IteratorStateMachineAttribute("Lucene.Net.Codecs.DocValuesConsumer/<GetMergeBinaryFieldEnumerable>d__8")]
private IEnumerable`1<BytesRef> GetMergeBinaryFieldEnumerable(MergeState mergeState, IList`1<BinaryDocValues> toMerge, IList`1<IBits> docsWithField);
    public virtual void MergeSortedField(FieldInfo fieldInfo, MergeState mergeState, IList`1<SortedDocValues> toMerge);
    [IteratorStateMachineAttribute("Lucene.Net.Codecs.DocValuesConsumer/<GetMergeSortValuesEnumerable>d__10")]
private IEnumerable`1<BytesRef> GetMergeSortValuesEnumerable(OrdinalMap map, SortedDocValues[] dvs);
    [IteratorStateMachineAttribute("Lucene.Net.Codecs.DocValuesConsumer/<GetMergeSortedFieldDocToOrdEnumerable>d__11")]
private IEnumerable`1<Nullable`1<long>> GetMergeSortedFieldDocToOrdEnumerable(AtomicReader[] readers, SortedDocValues[] dvs, OrdinalMap map);
    public virtual void MergeSortedSetField(FieldInfo fieldInfo, MergeState mergeState, IList`1<SortedSetDocValues> toMerge);
    [IteratorStateMachineAttribute("Lucene.Net.Codecs.DocValuesConsumer/<GetMergeSortedSetValuesEnumerable>d__13")]
private IEnumerable`1<BytesRef> GetMergeSortedSetValuesEnumerable(OrdinalMap map, SortedSetDocValues[] dvs);
    [IteratorStateMachineAttribute("Lucene.Net.Codecs.DocValuesConsumer/<GetMergeSortedSetDocToOrdCountEnumerable>d__14")]
private IEnumerable`1<Nullable`1<long>> GetMergeSortedSetDocToOrdCountEnumerable(AtomicReader[] readers, SortedSetDocValues[] dvs);
    [IteratorStateMachineAttribute("Lucene.Net.Codecs.DocValuesConsumer/<GetMergeSortedSetOrdsEnumerable>d__15")]
private IEnumerable`1<Nullable`1<long>> GetMergeSortedSetOrdsEnumerable(AtomicReader[] readers, SortedSetDocValues[] dvs, OrdinalMap map);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
public abstract class Lucene.Net.Codecs.DocValuesFormat : object {
    private static IDocValuesFormatFactory docValuesFormatFactory;
    private string name;
    public string Name { get; }
    public static ICollection`1<string> AvailableDocValuesFormats { get; }
    private static DocValuesFormat();
    public static void SetDocValuesFormatFactory(IDocValuesFormatFactory docValuesFormatFactory);
    public static IDocValuesFormatFactory GetDocValuesFormatFactory();
    public abstract virtual DocValuesConsumer FieldsConsumer(SegmentWriteState state);
    public abstract virtual DocValuesProducer FieldsProducer(SegmentReadState state);
    public string get_Name();
    public virtual string ToString();
    public static DocValuesFormat ForName(string name);
    public static ICollection`1<string> get_AvailableDocValuesFormats();
}
[AttributeUsageAttribute("4")]
public class Lucene.Net.Codecs.DocValuesFormatNameAttribute : ServiceNameAttribute {
    public DocValuesFormatNameAttribute(string name);
}
public abstract class Lucene.Net.Codecs.DocValuesProducer : object {
    public abstract virtual NumericDocValues GetNumeric(FieldInfo field);
    public abstract virtual BinaryDocValues GetBinary(FieldInfo field);
    public abstract virtual SortedDocValues GetSorted(FieldInfo field);
    public abstract virtual SortedSetDocValues GetSortedSet(FieldInfo field);
    public abstract virtual IBits GetDocsWithField(FieldInfo field);
    public abstract virtual long RamBytesUsed();
    public abstract virtual void CheckIntegrity();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
[AttributeUsageAttribute("4")]
public class Lucene.Net.Codecs.ExcludeCodecFromScanAttribute : ExcludeServiceAttribute {
}
[AttributeUsageAttribute("4")]
public class Lucene.Net.Codecs.ExcludeDocValuesFormatFromScanAttribute : ExcludeServiceAttribute {
}
[AttributeUsageAttribute("4")]
public class Lucene.Net.Codecs.ExcludePostingsFormatFromScanAttribute : ExcludeServiceAttribute {
}
public abstract class Lucene.Net.Codecs.FieldInfosFormat : object {
    public FieldInfosReader FieldInfosReader { get; }
    public FieldInfosWriter FieldInfosWriter { get; }
    public abstract virtual FieldInfosReader get_FieldInfosReader();
    public abstract virtual FieldInfosWriter get_FieldInfosWriter();
}
public abstract class Lucene.Net.Codecs.FieldInfosReader : object {
    public abstract virtual FieldInfos Read(Directory directory, string segmentName, string segmentSuffix, IOContext iocontext);
}
public abstract class Lucene.Net.Codecs.FieldInfosWriter : object {
    public abstract virtual void Write(Directory directory, string segmentName, string segmentSuffix, FieldInfos infos, IOContext context);
}
public abstract class Lucene.Net.Codecs.FieldsConsumer : object {
    public abstract virtual TermsConsumer AddField(FieldInfo field);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public virtual void Merge(MergeState mergeState, Fields fields);
}
public abstract class Lucene.Net.Codecs.FieldsProducer : Fields {
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public abstract virtual long RamBytesUsed();
    public abstract virtual void CheckIntegrity();
}
public abstract class Lucene.Net.Codecs.FilterCodec : Codec {
    protected Codec m_delegate;
    public DocValuesFormat DocValuesFormat { get; }
    public FieldInfosFormat FieldInfosFormat { get; }
    public LiveDocsFormat LiveDocsFormat { get; }
    public NormsFormat NormsFormat { get; }
    public PostingsFormat PostingsFormat { get; }
    public SegmentInfoFormat SegmentInfoFormat { get; }
    public StoredFieldsFormat StoredFieldsFormat { get; }
    public TermVectorsFormat TermVectorsFormat { get; }
    protected internal FilterCodec(Codec delegate);
    public virtual DocValuesFormat get_DocValuesFormat();
    public virtual FieldInfosFormat get_FieldInfosFormat();
    public virtual LiveDocsFormat get_LiveDocsFormat();
    public virtual NormsFormat get_NormsFormat();
    public virtual PostingsFormat get_PostingsFormat();
    public virtual SegmentInfoFormat get_SegmentInfoFormat();
    public virtual StoredFieldsFormat get_StoredFieldsFormat();
    public virtual TermVectorsFormat get_TermVectorsFormat();
}
public interface Lucene.Net.Codecs.ICodecFactory {
    public abstract virtual Codec GetCodec(string name);
}
public interface Lucene.Net.Codecs.IDocValuesFormatFactory {
    public abstract virtual DocValuesFormat GetDocValuesFormat(string name);
}
public interface Lucene.Net.Codecs.IPostingsFormatFactory {
    public abstract virtual PostingsFormat GetPostingsFormat(string name);
}
public abstract class Lucene.Net.Codecs.LiveDocsFormat : object {
    public abstract virtual IMutableBits NewLiveDocs(int size);
    public abstract virtual IMutableBits NewLiveDocs(IBits existing);
    public abstract virtual IBits ReadLiveDocs(Directory dir, SegmentCommitInfo info, IOContext context);
    public abstract virtual void WriteLiveDocs(IMutableBits bits, Directory dir, SegmentCommitInfo info, int newDelCount, IOContext context);
    public abstract virtual void Files(SegmentCommitInfo info, ICollection`1<string> files);
}
[ObsoleteAttribute("Only for reading existing 3.x indexes")]
[CodecNameAttribute("Lucene3x")]
public class Lucene.Net.Codecs.Lucene3x.Lucene3xCodec : Codec {
    private PostingsFormat postingsFormat;
    private StoredFieldsFormat fieldsFormat;
    private TermVectorsFormat vectorsFormat;
    private FieldInfosFormat fieldInfosFormat;
    private SegmentInfoFormat infosFormat;
    private Lucene3xNormsFormat normsFormat;
    internal static string COMPOUND_FILE_STORE_EXTENSION;
    private LiveDocsFormat liveDocsFormat;
    private DocValuesFormat docValuesFormat;
    public PostingsFormat PostingsFormat { get; }
    public DocValuesFormat DocValuesFormat { get; }
    public StoredFieldsFormat StoredFieldsFormat { get; }
    public TermVectorsFormat TermVectorsFormat { get; }
    public FieldInfosFormat FieldInfosFormat { get; }
    public SegmentInfoFormat SegmentInfoFormat { get; }
    public NormsFormat NormsFormat { get; }
    public LiveDocsFormat LiveDocsFormat { get; }
    public virtual PostingsFormat get_PostingsFormat();
    public virtual DocValuesFormat get_DocValuesFormat();
    public virtual StoredFieldsFormat get_StoredFieldsFormat();
    public virtual TermVectorsFormat get_TermVectorsFormat();
    public virtual FieldInfosFormat get_FieldInfosFormat();
    public virtual SegmentInfoFormat get_SegmentInfoFormat();
    public virtual NormsFormat get_NormsFormat();
    public virtual LiveDocsFormat get_LiveDocsFormat();
    public static ISet`1<string> GetDocStoreFiles(SegmentInfo info);
}
[ObsoleteAttribute("(4.0) this is only used to read indexes created before 4.0")]
internal class Lucene.Net.Codecs.Lucene3x.Lucene3xFieldInfosFormat : FieldInfosFormat {
    private FieldInfosReader reader;
    public FieldInfosReader FieldInfosReader { get; }
    public FieldInfosWriter FieldInfosWriter { get; }
    public virtual FieldInfosReader get_FieldInfosReader();
    public virtual FieldInfosWriter get_FieldInfosWriter();
}
[ObsoleteAttribute("Only for reading existing 3.x indexes")]
internal class Lucene.Net.Codecs.Lucene3x.Lucene3xFieldInfosReader : FieldInfosReader {
    internal static string FIELD_INFOS_EXTENSION;
    internal static int FORMAT_START;
    internal static int FORMAT_OMIT_POSITIONS;
    internal static int FORMAT_MINIMUM;
    internal static int FORMAT_CURRENT;
    internal static sbyte IS_INDEXED;
    internal static sbyte STORE_TERMVECTOR;
    internal static sbyte OMIT_NORMS;
    internal static sbyte STORE_PAYLOADS;
    internal static sbyte OMIT_TERM_FREQ_AND_POSITIONS;
    internal static sbyte OMIT_POSITIONS;
    public virtual FieldInfos Read(Directory directory, string segmentName, string segmentSuffix, IOContext iocontext);
}
[ObsoleteAttribute("(4.0)")]
internal class Lucene.Net.Codecs.Lucene3x.Lucene3xFields : FieldsProducer {
    private static bool DEBUG_SURROGATES;
    [CompilerGeneratedAttribute]
private TermInfosReader <Tis>k__BackingField;
    [CompilerGeneratedAttribute]
private TermInfosReader <TisNoIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexInput <FreqStream>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexInput <ProxStream>k__BackingField;
    private FieldInfos fieldInfos;
    internal IDictionary`2<string, FieldInfo> fields;
    internal IDictionary`2<string, Terms> preTerms;
    public TermInfosReader Tis { get; public set; }
    public TermInfosReader TisNoIndex { get; private set; }
    public IndexInput FreqStream { get; private set; }
    public IndexInput ProxStream { get; private set; }
    protected bool SortTermsByUnicode { get; }
    public int Count { get; }
    [ObsoleteAttribute("iterate fields and add their Count instead.")]
public long UniqueTermCount { get; }
    private TermInfosReader TermsDict { get; }
    public Lucene3xFields(Directory dir, FieldInfos fieldInfos, SegmentInfo info, IOContext context, int indexDivisor);
    [CompilerGeneratedAttribute]
public TermInfosReader get_Tis();
    [CompilerGeneratedAttribute]
public void set_Tis(TermInfosReader value);
    [CompilerGeneratedAttribute]
public TermInfosReader get_TisNoIndex();
    [CompilerGeneratedAttribute]
private void set_TisNoIndex(TermInfosReader value);
    [CompilerGeneratedAttribute]
public IndexInput get_FreqStream();
    [CompilerGeneratedAttribute]
private void set_FreqStream(IndexInput value);
    [CompilerGeneratedAttribute]
public IndexInput get_ProxStream();
    [CompilerGeneratedAttribute]
private void set_ProxStream(IndexInput value);
    protected virtual bool get_SortTermsByUnicode();
    public virtual IEnumerator`1<string> GetEnumerator();
    public virtual Terms GetTerms(string field);
    public virtual int get_Count();
    public virtual long get_UniqueTermCount();
    private TermInfosReader get_TermsDict();
    protected virtual void Dispose(bool disposing);
    public virtual long RamBytesUsed();
    public virtual void CheckIntegrity();
}
[ObsoleteAttribute("(4.0) this is only used to read indexes created before 4.0.")]
internal class Lucene.Net.Codecs.Lucene3x.Lucene3xNormsFormat : NormsFormat {
    public virtual DocValuesConsumer NormsConsumer(SegmentWriteState state);
    public virtual DocValuesProducer NormsProducer(SegmentReadState state);
}
[ObsoleteAttribute("Only for reading existing 3.x indexes")]
internal class Lucene.Net.Codecs.Lucene3x.Lucene3xNormsProducer : DocValuesProducer {
    internal static SByte[] NORMS_HEADER;
    internal static string NORMS_EXTENSION;
    internal static string SEPARATE_NORMS_EXTENSION;
    private IDictionary`2<string, NormsDocValues> norms;
    internal ISet`1<IndexInput> openFiles;
    internal IndexInput singleNormStream;
    internal int maxdoc;
    private AtomicInt64 ramBytesUsed;
    public Lucene3xNormsProducer(Directory dir, SegmentInfo info, FieldInfos fields, IOContext context);
    private static Lucene3xNormsProducer();
    protected virtual void Dispose(bool disposing);
    private static string GetNormFilename(SegmentInfo info, int number);
    private static bool HasSeparateNorms(SegmentInfo info, int number);
    public virtual NumericDocValues GetNumeric(FieldInfo field);
    public virtual BinaryDocValues GetBinary(FieldInfo field);
    public virtual SortedDocValues GetSorted(FieldInfo field);
    public virtual SortedSetDocValues GetSortedSet(FieldInfo field);
    public virtual IBits GetDocsWithField(FieldInfo field);
    public virtual long RamBytesUsed();
    public virtual void CheckIntegrity();
}
[ObsoleteAttribute("(4.0) this is only used to read indexes created before 4.0.")]
[PostingsFormatNameAttribute("Lucene3x")]
internal class Lucene.Net.Codecs.Lucene3x.Lucene3xPostingsFormat : PostingsFormat {
    public static string TERMS_EXTENSION;
    public static string TERMS_INDEX_EXTENSION;
    public static string FREQ_EXTENSION;
    public static string PROX_EXTENSION;
    public virtual FieldsConsumer FieldsConsumer(SegmentWriteState state);
    public virtual FieldsProducer FieldsProducer(SegmentReadState state);
}
[ObsoleteAttribute("(4.0) this is only used to read indexes created before 4.0.")]
public class Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat : SegmentInfoFormat {
    private SegmentInfoReader reader;
    public static int FORMAT_DIAGNOSTICS;
    public static int FORMAT_HAS_VECTORS;
    public static int FORMAT_3_1;
    public static string UPGRADED_SI_EXTENSION;
    public static string UPGRADED_SI_CODEC_NAME;
    public static int UPGRADED_SI_VERSION_START;
    public static int UPGRADED_SI_VERSION_CURRENT;
    public static string DS_OFFSET_KEY;
    public static string DS_NAME_KEY;
    public static string DS_COMPOUND_KEY;
    public static string NORMGEN_KEY;
    public static string NORMGEN_PREFIX;
    public SegmentInfoReader SegmentInfoReader { get; }
    public SegmentInfoWriter SegmentInfoWriter { get; }
    private static Lucene3xSegmentInfoFormat();
    public virtual SegmentInfoReader get_SegmentInfoReader();
    public virtual SegmentInfoWriter get_SegmentInfoWriter();
    public static int GetDocStoreOffset(SegmentInfo si);
    public static string GetDocStoreSegment(SegmentInfo si);
    public static bool GetDocStoreIsCompoundFile(SegmentInfo si);
}
[ObsoleteAttribute("Only for reading existing 3.x indexes")]
public class Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoReader : SegmentInfoReader {
    public static void ReadLegacyInfos(SegmentInfos infos, Directory directory, IndexInput input, int format);
    public virtual SegmentInfo Read(Directory directory, string segmentName, IOContext context);
    private static void AddIfExists(Directory dir, ISet`1<string> files, string fileName);
    private SegmentCommitInfo ReadLegacySegmentInfo(Directory dir, int format, IndexInput input);
    private SegmentInfo ReadUpgradedSegmentInfo(string name, Directory dir, IndexInput input);
}
[ObsoleteAttribute("(4.0) this is only used to read indexes created before 4.0.")]
internal class Lucene.Net.Codecs.Lucene3x.Lucene3xSkipListReader : MultiLevelSkipListReader {
    private bool currentFieldStoresPayloads;
    private Int64[] freqPointer;
    private Int64[] proxPointer;
    private Int32[] payloadLength;
    private long lastFreqPointer;
    private long lastProxPointer;
    private int lastPayloadLength;
    public long FreqPointer { get; }
    public long ProxPointer { get; }
    public int PayloadLength { get; }
    public Lucene3xSkipListReader(IndexInput skipStream, int maxSkipLevels, int skipInterval);
    public void Init(long skipPointer, long freqBasePointer, long proxBasePointer, int df, bool storesPayloads);
    public long get_FreqPointer();
    public long get_ProxPointer();
    public int get_PayloadLength();
    protected virtual void SeekChild(int level);
    protected virtual void SetLastSkipData(int level);
    protected virtual int ReadSkipData(int level, IndexInput skipStream);
}
[ObsoleteAttribute("Only for reading existing 3.x indexes")]
internal class Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsFormat : StoredFieldsFormat {
    public virtual StoredFieldsReader FieldsReader(Directory directory, SegmentInfo si, FieldInfos fn, IOContext context);
    public virtual StoredFieldsWriter FieldsWriter(Directory directory, SegmentInfo si, IOContext context);
}
[ObsoleteAttribute("Only for reading existing 3.x indexes")]
internal class Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader : StoredFieldsReader {
    private static int FORMAT_SIZE;
    public static string FIELDS_EXTENSION;
    public static string FIELDS_INDEX_EXTENSION;
    internal static int FORMAT_LUCENE_3_0_NO_COMPRESSED_FIELDS;
    internal static int FORMAT_LUCENE_3_2_NUMERIC_FIELDS;
    public static int FORMAT_CURRENT;
    internal static int FORMAT_MINIMUM;
    public static int FIELD_IS_BINARY;
    private static int _NUMERIC_BIT_SHIFT;
    internal static int FIELD_IS_NUMERIC_MASK;
    public static int FIELD_IS_NUMERIC_INT;
    public static int FIELD_IS_NUMERIC_LONG;
    public static int FIELD_IS_NUMERIC_FLOAT;
    public static int FIELD_IS_NUMERIC_DOUBLE;
    private FieldInfos fieldInfos;
    private IndexInput fieldsStream;
    private IndexInput indexStream;
    private int numTotalDocs;
    private int size;
    private bool closed;
    private int format;
    private int docStoreOffset;
    private CompoundFileDirectory storeCFSReader;
    private Lucene3xStoredFieldsReader(FieldInfos fieldInfos, int numTotalDocs, int size, int format, int docStoreOffset, IndexInput fieldsStream, IndexInput indexStream);
    public Lucene3xStoredFieldsReader(Directory d, SegmentInfo si, FieldInfos fn, IOContext context);
    public virtual object Clone();
    public static void CheckCodeVersion(Directory dir, string segment);
    private void EnsureOpen();
    protected virtual void Dispose(bool disposing);
    private void SeekIndex(int docID);
    public sealed virtual void VisitDocument(int n, StoredFieldVisitor visitor);
    private void ReadField(StoredFieldVisitor visitor, FieldInfo info, int bits);
    private void SkipField(int bits);
    public virtual long RamBytesUsed();
    public virtual void CheckIntegrity();
}
[ObsoleteAttribute("(4.0) this is only used to read indexes created before 4.0.")]
internal class Lucene.Net.Codecs.Lucene3x.Lucene3xTermVectorsFormat : TermVectorsFormat {
    public virtual TermVectorsReader VectorsReader(Directory directory, SegmentInfo segmentInfo, FieldInfos fieldInfos, IOContext context);
    public virtual TermVectorsWriter VectorsWriter(Directory directory, SegmentInfo segmentInfo, IOContext context);
}
[ObsoleteAttribute("Only for reading existing 3.x indexes")]
internal class Lucene.Net.Codecs.Lucene3x.Lucene3xTermVectorsReader : TermVectorsReader {
    internal static int FORMAT_UTF8_LENGTH_IN_BYTES;
    public static int FORMAT_CURRENT;
    public static int FORMAT_MINIMUM;
    internal static int FORMAT_SIZE;
    public static sbyte STORE_POSITIONS_WITH_TERMVECTOR;
    public static sbyte STORE_OFFSET_WITH_TERMVECTOR;
    public static string VECTORS_FIELDS_EXTENSION;
    public static string VECTORS_DOCUMENTS_EXTENSION;
    public static string VECTORS_INDEX_EXTENSION;
    private FieldInfos fieldInfos;
    private IndexInput tvx;
    private IndexInput tvd;
    private IndexInput tvf;
    private int size;
    private int numTotalDocs;
    private int docStoreOffset;
    private CompoundFileDirectory storeCFSReader;
    private int format;
    internal int Count { get; }
    internal Lucene3xTermVectorsReader(FieldInfos fieldInfos, IndexInput tvx, IndexInput tvd, IndexInput tvf, int size, int numTotalDocs, int docStoreOffset, int format);
    public Lucene3xTermVectorsReader(Directory d, SegmentInfo si, FieldInfos fieldInfos, IOContext context);
    internal virtual void SeekTvx(int docNum);
    private int CheckValidFormat(IndexInput in);
    protected virtual void Dispose(bool disposing);
    internal virtual int get_Count();
    public virtual Fields Get(int docID);
    public virtual object Clone();
    protected internal virtual bool SortTermsByUnicode();
    public virtual long RamBytesUsed();
    public virtual void CheckIntegrity();
}
[ObsoleteAttribute("(4.0)")]
internal class Lucene.Net.Codecs.Lucene3x.SegmentTermDocs : object {
    private FieldInfos fieldInfos;
    private TermInfosReader tis;
    protected IBits m_liveDocs;
    protected IndexInput m_freqStream;
    protected int m_count;
    protected internal int m_df;
    internal int doc;
    internal int freq;
    private int skipInterval;
    private int maxSkipLevels;
    private Lucene3xSkipListReader skipListReader;
    private long freqBasePointer;
    private long proxBasePointer;
    private long skipPointer;
    private bool haveSkipped;
    protected bool m_currentFieldStoresPayloads;
    protected IndexOptions m_indexOptions;
    public IBits LiveDocs { get; public set; }
    public int Doc { get; }
    public int Freq { get; }
    public SegmentTermDocs(IndexInput freqStream, TermInfosReader tis, FieldInfos fieldInfos);
    public virtual void Seek(Term term);
    public virtual IBits get_LiveDocs();
    public virtual void set_LiveDocs(IBits value);
    public virtual void Seek(SegmentTermEnum segmentTermEnum);
    internal virtual void Seek(TermInfo ti, Term term);
    public void Dispose();
    protected virtual void Dispose(bool disposing);
    public int get_Doc();
    public int get_Freq();
    protected internal virtual void SkippingDoc();
    public virtual bool Next();
    public virtual int Read(Int32[] docs, Int32[] freqs);
    private int ReadNoTf(Int32[] docs, Int32[] freqs, int length);
    protected internal virtual void SkipProx(long proxPointer, int payloadLength);
    public virtual bool SkipTo(int target);
}
[ObsoleteAttribute("(4.0) No longer used with flex indexing, except for reading old segments")]
internal class Lucene.Net.Codecs.Lucene3x.SegmentTermEnum : object {
    private IndexInput input;
    internal FieldInfos fieldInfos;
    internal long size;
    internal long position;
    public static int FORMAT_VERSION_UTF8_LENGTH_IN_BYTES;
    public static int FORMAT_CURRENT;
    public static int FORMAT_MINIMUM;
    private TermBuffer termBuffer;
    private TermBuffer prevBuffer;
    private TermBuffer scanBuffer;
    internal TermInfo termInfo;
    private int format;
    private bool isIndex;
    internal long indexPointer;
    internal int indexInterval;
    internal int skipInterval;
    internal int newSuffixStart;
    internal int maxSkipLevels;
    private bool first;
    public int DocFreq { get; }
    internal long FreqPointer { get; }
    internal long ProxPointer { get; }
    public SegmentTermEnum(IndexInput i, FieldInfos fis, bool isi);
    public object Clone();
    internal void Seek(long pointer, long p, Term t, TermInfo ti);
    public bool Next();
    internal int ScanTo(Term term);
    public Term Term();
    internal Term Prev();
    internal TermInfo TermInfo();
    internal void TermInfo(TermInfo ti);
    public int get_DocFreq();
    internal long get_FreqPointer();
    internal long get_ProxPointer();
    public sealed virtual void Dispose();
}
[ObsoleteAttribute("(4.0)")]
internal class Lucene.Net.Codecs.Lucene3x.SegmentTermPositions : SegmentTermDocs {
    private IndexInput proxStream;
    private IndexInput proxStreamOrig;
    private int proxCount;
    private int position;
    private BytesRef payload;
    private int payloadLength;
    private bool needToLoadPayload;
    private long lazySkipPointer;
    private int lazySkipProxCount;
    public int PayloadLength { get; }
    public bool IsPayloadAvailable { get; }
    public SegmentTermPositions(IndexInput freqStream, IndexInput proxStream, TermInfosReader tis, FieldInfos fieldInfos);
    internal virtual void Seek(TermInfo ti, Term term);
    protected virtual void Dispose(bool disposing);
    public int NextPosition();
    private int ReadDeltaPosition();
    protected internal sealed virtual void SkippingDoc();
    public sealed virtual bool Next();
    public sealed virtual int Read(Int32[] docs, Int32[] freqs);
    protected internal virtual void SkipProx(long proxPointer, int payloadLength);
    private void SkipPositions(int n);
    private void SkipPayload();
    private void LazySkip();
    public int get_PayloadLength();
    public BytesRef GetPayload();
    public bool get_IsPayloadAvailable();
}
[ObsoleteAttribute("(4.0)")]
internal class Lucene.Net.Codecs.Lucene3x.TermBuffer : object {
    private string field;
    private Term term;
    private BytesRef bytes;
    private int currentFieldNumber;
    private static IComparer`1<BytesRef> utf8AsUTF16Comparer;
    internal int newSuffixStart;
    private static TermBuffer();
    public int CompareTo(TermBuffer other);
    public void Read(IndexInput input, FieldInfos fieldInfos);
    public void Set(Term term);
    public void Set(TermBuffer other);
    public void Reset();
    public Term ToTerm();
    public object Clone();
}
[ObsoleteAttribute("(4.0) this class is no longer used in flexible indexing.")]
internal class Lucene.Net.Codecs.Lucene3x.TermInfo : object {
    [CompilerGeneratedAttribute]
private int <DocFreq>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FreqPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ProxPointer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SkipOffset>k__BackingField;
    public int DocFreq { get; public set; }
    public long FreqPointer { get; public set; }
    public long ProxPointer { get; public set; }
    public int SkipOffset { get; public set; }
    public TermInfo(int df, long fp, long pp);
    public TermInfo(TermInfo ti);
    [CompilerGeneratedAttribute]
public int get_DocFreq();
    [CompilerGeneratedAttribute]
public void set_DocFreq(int value);
    [CompilerGeneratedAttribute]
public long get_FreqPointer();
    [CompilerGeneratedAttribute]
public void set_FreqPointer(long value);
    [CompilerGeneratedAttribute]
public long get_ProxPointer();
    [CompilerGeneratedAttribute]
public void set_ProxPointer(long value);
    [CompilerGeneratedAttribute]
public int get_SkipOffset();
    [CompilerGeneratedAttribute]
public void set_SkipOffset(int value);
    public void Set(int docFreq, long freqPointer, long proxPointer, int skipOffset);
    public void Set(TermInfo ti);
}
[ObsoleteAttribute("(4.0) this class has been replaced by FormatPostingsTermsDictReader, except for reading old segments.")]
internal class Lucene.Net.Codecs.Lucene3x.TermInfosReader : object {
    private Directory directory;
    private string segment;
    private FieldInfos fieldInfos;
    private DisposableThreadLocal`1<ThreadResources> threadResources;
    private SegmentTermEnum origEnum;
    private long size;
    private TermInfosReaderIndex index;
    private int indexLength;
    private int totalIndexInterval;
    private static int DEFAULT_CACHE_SIZE;
    private DoubleBarrelLRUCache`2<CloneableTerm, TermInfoAndOrd> termsCache;
    private static IComparer`1<BytesRef> legacyComparer;
    public int SkipInterval { get; }
    public int MaxSkipLevels { get; }
    internal long Count { get; }
    internal TermInfosReader(Directory dir, string seg, FieldInfos fis, IOContext context, int indexDivisor);
    private static TermInfosReader();
    public int get_SkipInterval();
    public int get_MaxSkipLevels();
    public sealed virtual void Dispose();
    internal long get_Count();
    private ThreadResources GetThreadResources();
    private static int CompareAsUTF16(Term term1, Term term2);
    internal TermInfo Get(Term term);
    private TermInfo Get(Term term, bool mustSeekEnum);
    public void CacheCurrentTerm(SegmentTermEnum enumerator);
    internal static Term DeepCopyOf(Term other);
    internal TermInfo SeekEnum(SegmentTermEnum enumerator, Term term, bool useCache);
    internal TermInfo SeekEnum(SegmentTermEnum enumerator, Term term, TermInfoAndOrd tiOrd, bool useCache);
    private static bool SameTermInfo(TermInfo ti1, TermInfo ti2, SegmentTermEnum enumerator);
    private void EnsureIndexIsRead();
    internal long GetPosition(Term term);
    public SegmentTermEnum Terms();
    public SegmentTermEnum Terms(Term term);
    internal long RamBytesUsed();
}
[ObsoleteAttribute("Only for reading existing 3.x indexes")]
internal class Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex : object {
    private static int MAX_PAGE_BITS;
    private Term[] fields;
    private int totalIndexInterval;
    private IComparer`1<BytesRef> comparer;
    private PagedBytesDataInput dataInput;
    private Reader indexToDataOffset;
    private int indexSize;
    private int skipInterval;
    private long ramBytesUsed;
    internal int Length { get; }
    public TermInfosReaderIndex(SegmentTermEnum indexEnum, int indexDivisor, long tiiFileLength, int totalIndexInterval);
    private static int EstimatePageBits(long estSize);
    internal virtual void SeekEnum(SegmentTermEnum enumerator, int indexOffset);
    internal virtual int GetIndexOffset(Term term);
    internal virtual Term GetTerm(int termIndex);
    internal virtual int get_Length();
    internal virtual int CompareTo(Term term, int termIndex);
    private int CompareTo(Term term, int termIndex, PagedBytesDataInput input, BytesRef reuse);
    private int CompareField(Term term, int termIndex, PagedBytesDataInput input);
    internal virtual long RamBytesUsed();
}
internal class Lucene.Net.Codecs.Lucene40.BitVector : object {
    private Byte[] bits;
    private int size;
    private int count;
    private int version;
    private static string CODEC;
    public static int VERSION_PRE;
    public static int VERSION_START;
    public static int VERSION_DGAPS_CLEARED;
    public static int VERSION_CHECKSUM;
    public static int VERSION_CURRENT;
    public int Length { get; }
    public int Version { get; }
    private bool IsSparse { get; }
    public BitVector(int n);
    internal BitVector(Byte[] bits, int size);
    public BitVector(Directory d, string name, IOContext context);
    private static int GetNumBytes(int size);
    public object Clone();
    public void Set(int bit);
    public bool GetAndSet(int bit);
    public sealed virtual void Clear(int bit);
    public bool GetAndClear(int bit);
    public sealed virtual bool Get(int bit);
    public sealed virtual int get_Length();
    public int Count();
    public int GetRecomputedCount();
    public int get_Version();
    public void Write(Directory d, string name, IOContext context);
    public void InvertAll();
    private void ClearUnusedBits();
    public void SetAll();
    private void WriteBits(IndexOutput output);
    private void WriteClearedDgaps(IndexOutput output);
    private bool get_IsSparse();
    private bool VerifyCount();
    private void ReadBits(IndexInput input);
    private void ReadSetDgaps(IndexInput input);
    private void ReadClearedDgaps(IndexInput input);
}
internal enum Lucene.Net.Codecs.Lucene40.LegacyDocValuesType : Enum {
    public sbyte value__;
    public static LegacyDocValuesType NONE;
    public static LegacyDocValuesType VAR_INTS;
    public static LegacyDocValuesType FLOAT_32;
    public static LegacyDocValuesType FLOAT_64;
    public static LegacyDocValuesType BYTES_FIXED_STRAIGHT;
    public static LegacyDocValuesType BYTES_FIXED_DEREF;
    public static LegacyDocValuesType BYTES_VAR_STRAIGHT;
    public static LegacyDocValuesType BYTES_VAR_DEREF;
    public static LegacyDocValuesType FIXED_INTS_16;
    public static LegacyDocValuesType FIXED_INTS_32;
    public static LegacyDocValuesType FIXED_INTS_64;
    public static LegacyDocValuesType FIXED_INTS_8;
    public static LegacyDocValuesType BYTES_FIXED_SORTED;
    public static LegacyDocValuesType BYTES_VAR_SORTED;
}
[ExtensionAttribute]
internal static class Lucene.Net.Codecs.Lucene40.LegacyDocValuesTypeExtensions : object {
    internal static IDictionary`2<LegacyDocValuesType, DocValuesType> mapping;
    private static LegacyDocValuesTypeExtensions();
    [ExtensionAttribute]
public static DocValuesType GetMapping(LegacyDocValuesType legacyDocValuesType);
    [ExtensionAttribute]
public static LegacyDocValuesType ToLegacyDocValuesType(string name);
}
[ObsoleteAttribute("Only for reading old 4.0 segments")]
[CodecNameAttribute("Lucene40")]
public class Lucene.Net.Codecs.Lucene40.Lucene40Codec : Codec {
    private StoredFieldsFormat fieldsFormat;
    private TermVectorsFormat vectorsFormat;
    private FieldInfosFormat fieldInfosFormat;
    private SegmentInfoFormat infosFormat;
    private LiveDocsFormat liveDocsFormat;
    private PostingsFormat postingsFormat;
    private DocValuesFormat defaultDVFormat;
    private NormsFormat normsFormat;
    private PostingsFormat defaultFormat;
    public StoredFieldsFormat StoredFieldsFormat { get; }
    public TermVectorsFormat TermVectorsFormat { get; }
    public PostingsFormat PostingsFormat { get; }
    public FieldInfosFormat FieldInfosFormat { get; }
    public SegmentInfoFormat SegmentInfoFormat { get; }
    public DocValuesFormat DocValuesFormat { get; }
    public NormsFormat NormsFormat { get; }
    public LiveDocsFormat LiveDocsFormat { get; }
    public sealed virtual StoredFieldsFormat get_StoredFieldsFormat();
    public sealed virtual TermVectorsFormat get_TermVectorsFormat();
    public sealed virtual PostingsFormat get_PostingsFormat();
    public virtual FieldInfosFormat get_FieldInfosFormat();
    public virtual SegmentInfoFormat get_SegmentInfoFormat();
    public virtual DocValuesFormat get_DocValuesFormat();
    public virtual NormsFormat get_NormsFormat();
    public sealed virtual LiveDocsFormat get_LiveDocsFormat();
    public virtual PostingsFormat GetPostingsFormatForField(string field);
}
[ObsoleteAttribute("Only for reading old 4.0 and 4.1 segments")]
[DocValuesFormatNameAttribute("Lucene40")]
public class Lucene.Net.Codecs.Lucene40.Lucene40DocValuesFormat : DocValuesFormat {
    public static int MAX_BINARY_FIELD_LENGTH;
    internal static string VAR_INTS_CODEC_NAME;
    internal static int VAR_INTS_VERSION_START;
    internal static int VAR_INTS_VERSION_CURRENT;
    internal static sbyte VAR_INTS_PACKED;
    internal static sbyte VAR_INTS_FIXED_64;
    internal static string INTS_CODEC_NAME;
    internal static int INTS_VERSION_START;
    internal static int INTS_VERSION_CURRENT;
    internal static string FLOATS_CODEC_NAME;
    internal static int FLOATS_VERSION_START;
    internal static int FLOATS_VERSION_CURRENT;
    internal static string BYTES_FIXED_STRAIGHT_CODEC_NAME;
    internal static int BYTES_FIXED_STRAIGHT_VERSION_START;
    internal static int BYTES_FIXED_STRAIGHT_VERSION_CURRENT;
    internal static string BYTES_VAR_STRAIGHT_CODEC_NAME_IDX;
    internal static string BYTES_VAR_STRAIGHT_CODEC_NAME_DAT;
    internal static int BYTES_VAR_STRAIGHT_VERSION_START;
    internal static int BYTES_VAR_STRAIGHT_VERSION_CURRENT;
    internal static string BYTES_FIXED_DEREF_CODEC_NAME_IDX;
    internal static string BYTES_FIXED_DEREF_CODEC_NAME_DAT;
    internal static int BYTES_FIXED_DEREF_VERSION_START;
    internal static int BYTES_FIXED_DEREF_VERSION_CURRENT;
    internal static string BYTES_VAR_DEREF_CODEC_NAME_IDX;
    internal static string BYTES_VAR_DEREF_CODEC_NAME_DAT;
    internal static int BYTES_VAR_DEREF_VERSION_START;
    internal static int BYTES_VAR_DEREF_VERSION_CURRENT;
    internal static string BYTES_FIXED_SORTED_CODEC_NAME_IDX;
    internal static string BYTES_FIXED_SORTED_CODEC_NAME_DAT;
    internal static int BYTES_FIXED_SORTED_VERSION_START;
    internal static int BYTES_FIXED_SORTED_VERSION_CURRENT;
    internal static string BYTES_VAR_SORTED_CODEC_NAME_IDX;
    internal static string BYTES_VAR_SORTED_CODEC_NAME_DAT;
    internal static int BYTES_VAR_SORTED_VERSION_START;
    internal static int BYTES_VAR_SORTED_VERSION_CURRENT;
    private static Lucene40DocValuesFormat();
    public virtual DocValuesConsumer FieldsConsumer(SegmentWriteState state);
    public virtual DocValuesProducer FieldsProducer(SegmentReadState state);
}
[ObsoleteAttribute("Only for reading old 4.0 and 4.1 segments")]
internal class Lucene.Net.Codecs.Lucene40.Lucene40DocValuesReader : DocValuesProducer {
    private Directory dir;
    private SegmentReadState state;
    private string legacyKey;
    private static string segmentSuffix;
    private IDictionary`2<int, NumericDocValues> numericInstances;
    private IDictionary`2<int, BinaryDocValues> binaryInstances;
    private IDictionary`2<int, SortedDocValues> sortedInstances;
    private AtomicInt64 ramBytesUsed;
    internal Lucene40DocValuesReader(SegmentReadState state, string filename, string legacyKey);
    public virtual NumericDocValues GetNumeric(FieldInfo field);
    private NumericDocValues LoadVarInt32sField(IndexInput input);
    private NumericDocValues LoadByteField(IndexInput input);
    private NumericDocValues LoadInt16Field(IndexInput input);
    private NumericDocValues LoadInt32Field(IndexInput input);
    private NumericDocValues LoadInt64Field(IndexInput input);
    private NumericDocValues LoadSingleField(IndexInput input);
    private NumericDocValues LoadDoubleField(IndexInput input);
    public virtual BinaryDocValues GetBinary(FieldInfo field);
    private BinaryDocValues LoadBytesFixedStraight(FieldInfo field);
    private BinaryDocValues LoadBytesVarStraight(FieldInfo field);
    private BinaryDocValues LoadBytesFixedDeref(FieldInfo field);
    private BinaryDocValues LoadBytesVarDeref(FieldInfo field);
    public virtual SortedDocValues GetSorted(FieldInfo field);
    private SortedDocValues LoadBytesFixedSorted(IndexInput data, IndexInput index);
    private SortedDocValues LoadBytesVarSorted(IndexInput data, IndexInput index);
    private SortedDocValues CorrectBuggyOrds(SortedDocValues in);
    public virtual SortedSetDocValues GetSortedSet(FieldInfo field);
    public virtual IBits GetDocsWithField(FieldInfo field);
    protected virtual void Dispose(bool disposing);
    public virtual long RamBytesUsed();
    public virtual void CheckIntegrity();
}
[ObsoleteAttribute("Only for reading old 4.0 and 4.1 segments")]
public class Lucene.Net.Codecs.Lucene40.Lucene40FieldInfosFormat : FieldInfosFormat {
    private FieldInfosReader reader;
    internal static string FIELD_INFOS_EXTENSION;
    internal static string CODEC_NAME;
    internal static int FORMAT_START;
    internal static int FORMAT_CURRENT;
    internal static sbyte IS_INDEXED;
    internal static sbyte STORE_TERMVECTOR;
    internal static sbyte STORE_OFFSETS_IN_POSTINGS;
    internal static sbyte OMIT_NORMS;
    internal static sbyte STORE_PAYLOADS;
    internal static sbyte OMIT_TERM_FREQ_AND_POSITIONS;
    internal static sbyte OMIT_POSITIONS;
    public FieldInfosReader FieldInfosReader { get; }
    public FieldInfosWriter FieldInfosWriter { get; }
    public virtual FieldInfosReader get_FieldInfosReader();
    public virtual FieldInfosWriter get_FieldInfosWriter();
}
[ObsoleteAttribute("Only for reading old 4.0 and 4.1 segments")]
internal class Lucene.Net.Codecs.Lucene40.Lucene40FieldInfosReader : FieldInfosReader {
    internal static string LEGACY_DV_TYPE_KEY;
    internal static string LEGACY_NORM_TYPE_KEY;
    private static Lucene40FieldInfosReader();
    public virtual FieldInfos Read(Directory directory, string segmentName, string segmentSuffix, IOContext iocontext);
    private static LegacyDocValuesType GetDocValuesType(sbyte b);
}
public class Lucene.Net.Codecs.Lucene40.Lucene40LiveDocsFormat : LiveDocsFormat {
    internal static string DELETES_EXTENSION;
    public virtual IMutableBits NewLiveDocs(int size);
    public virtual IMutableBits NewLiveDocs(IBits existing);
    public virtual IBits ReadLiveDocs(Directory dir, SegmentCommitInfo info, IOContext context);
    public virtual void WriteLiveDocs(IMutableBits bits, Directory dir, SegmentCommitInfo info, int newDelCount, IOContext context);
    public virtual void Files(SegmentCommitInfo info, ICollection`1<string> files);
}
[ObsoleteAttribute("Only for reading old 4.0 and 4.1 segments")]
public class Lucene.Net.Codecs.Lucene40.Lucene40NormsFormat : NormsFormat {
    public virtual DocValuesConsumer NormsConsumer(SegmentWriteState state);
    public virtual DocValuesProducer NormsProducer(SegmentReadState state);
}
[ObsoleteAttribute("Only for reading old 4.0 segments")]
public class Lucene.Net.Codecs.Lucene40.Lucene40PostingsBaseFormat : PostingsBaseFormat {
    public virtual PostingsReaderBase PostingsReaderBase(SegmentReadState state);
    public virtual PostingsWriterBase PostingsWriterBase(SegmentWriteState state);
}
[ObsoleteAttribute("Only for reading old 4.0 segments")]
[PostingsFormatNameAttribute("Lucene40")]
public class Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat : PostingsFormat {
    protected int m_minBlockSize;
    protected int m_maxBlockSize;
    internal static string FREQ_EXTENSION;
    internal static string PROX_EXTENSION;
    private Lucene40PostingsFormat(int minBlockSize, int maxBlockSize);
    public virtual FieldsConsumer FieldsConsumer(SegmentWriteState state);
    public virtual FieldsProducer FieldsProducer(SegmentReadState state);
    public virtual string ToString();
}
[ObsoleteAttribute("Only for reading old 4.0 segments")]
public class Lucene.Net.Codecs.Lucene40.Lucene40PostingsReader : PostingsReaderBase {
    internal static string TERMS_CODEC;
    internal static string FRQ_CODEC;
    internal static string PRX_CODEC;
    internal static int VERSION_START;
    internal static int VERSION_LONG_SKIP;
    internal static int VERSION_CURRENT;
    private IndexInput freqIn;
    private IndexInput proxIn;
    internal int skipInterval;
    internal int maxSkipLevels;
    internal int skipMinimum;
    internal static int BUFFERSIZE;
    public Lucene40PostingsReader(Directory dir, FieldInfos fieldInfos, SegmentInfo segmentInfo, IOContext ioContext, string segmentSuffix);
    public virtual void Init(IndexInput termsIn);
    public virtual BlockTermState NewTermState();
    protected virtual void Dispose(bool disposing);
    public virtual void DecodeTerm(Int64[] longs, DataInput in, FieldInfo fieldInfo, BlockTermState termState, bool absolute);
    public virtual DocsEnum Docs(FieldInfo fieldInfo, BlockTermState termState, IBits liveDocs, DocsEnum reuse, DocsFlags flags);
    private bool CanReuse(DocsEnum reuse, IBits liveDocs);
    private DocsEnum NewDocsEnum(IBits liveDocs, FieldInfo fieldInfo, StandardTermState termState);
    public virtual DocsAndPositionsEnum DocsAndPositions(FieldInfo fieldInfo, BlockTermState termState, IBits liveDocs, DocsAndPositionsEnum reuse, DocsAndPositionsFlags flags);
    public virtual long RamBytesUsed();
    public virtual void CheckIntegrity();
}
[ObsoleteAttribute("Only for reading old 4.0-4.5 segments, and supporting IndexWriter.AddIndexes()")]
public class Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoFormat : SegmentInfoFormat {
    private SegmentInfoReader reader;
    private SegmentInfoWriter writer;
    public static string SI_EXTENSION;
    internal static string CODEC_NAME;
    internal static int VERSION_START;
    internal static int VERSION_CURRENT;
    public SegmentInfoReader SegmentInfoReader { get; }
    public SegmentInfoWriter SegmentInfoWriter { get; }
    public virtual SegmentInfoReader get_SegmentInfoReader();
    public virtual SegmentInfoWriter get_SegmentInfoWriter();
}
[ObsoleteAttribute("Only for reading old 4.0-4.5 segments")]
public class Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoReader : SegmentInfoReader {
    public virtual SegmentInfo Read(Directory dir, string segment, IOContext context);
}
[ObsoleteAttribute]
public class Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoWriter : SegmentInfoWriter {
    public virtual void Write(Directory dir, SegmentInfo si, FieldInfos fis, IOContext ioContext);
}
[ObsoleteAttribute("Only for reading old 4.0 segments")]
public class Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader : MultiLevelSkipListReader {
    private bool currentFieldStoresPayloads;
    private bool currentFieldStoresOffsets;
    private Int64[] freqPointer;
    private Int64[] proxPointer;
    private Int32[] payloadLength;
    private Int32[] offsetLength;
    private long lastFreqPointer;
    private long lastProxPointer;
    private int lastPayloadLength;
    private int lastOffsetLength;
    public long FreqPointer { get; }
    public long ProxPointer { get; }
    public int PayloadLength { get; }
    public int OffsetLength { get; }
    public Lucene40SkipListReader(IndexInput skipStream, int maxSkipLevels, int skipInterval);
    public virtual void Init(long skipPointer, long freqBasePointer, long proxBasePointer, int df, bool storesPayloads, bool storesOffsets);
    public virtual long get_FreqPointer();
    public virtual long get_ProxPointer();
    public virtual int get_PayloadLength();
    public virtual int get_OffsetLength();
    protected virtual void SeekChild(int level);
    protected virtual void SetLastSkipData(int level);
    protected virtual int ReadSkipData(int level, IndexInput skipStream);
}
public class Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsFormat : StoredFieldsFormat {
    public virtual StoredFieldsReader FieldsReader(Directory directory, SegmentInfo si, FieldInfos fn, IOContext context);
    public virtual StoredFieldsWriter FieldsWriter(Directory directory, SegmentInfo si, IOContext context);
}
public class Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader : StoredFieldsReader {
    private FieldInfos fieldInfos;
    private IndexInput fieldsStream;
    private IndexInput indexStream;
    private int numTotalDocs;
    private int size;
    private bool closed;
    public int Count { get; }
    private Lucene40StoredFieldsReader(FieldInfos fieldInfos, int numTotalDocs, int size, IndexInput fieldsStream, IndexInput indexStream);
    public Lucene40StoredFieldsReader(Directory d, SegmentInfo si, FieldInfos fn, IOContext context);
    public virtual object Clone();
    private void EnsureOpen();
    protected virtual void Dispose(bool disposing);
    public int get_Count();
    private void SeekIndex(int docID);
    public virtual void VisitDocument(int n, StoredFieldVisitor visitor);
    private void ReadField(StoredFieldVisitor visitor, FieldInfo info, int bits);
    private void SkipField(int bits);
    public IndexInput RawDocs(Int32[] lengths, int startDocID, int numDocs);
    public virtual long RamBytesUsed();
    public virtual void CheckIntegrity();
}
public class Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsWriter : StoredFieldsWriter {
    internal static int FIELD_IS_BINARY;
    private static int _NUMERIC_BIT_SHIFT;
    internal static int FIELD_IS_NUMERIC_MASK;
    internal static int FIELD_IS_NUMERIC_INT;
    internal static int FIELD_IS_NUMERIC_LONG;
    internal static int FIELD_IS_NUMERIC_FLOAT;
    internal static int FIELD_IS_NUMERIC_DOUBLE;
    internal static string CODEC_NAME_IDX;
    internal static string CODEC_NAME_DAT;
    internal static int VERSION_START;
    internal static int VERSION_CURRENT;
    internal static long HEADER_LENGTH_IDX;
    internal static long HEADER_LENGTH_DAT;
    public static string FIELDS_EXTENSION;
    public static string FIELDS_INDEX_EXTENSION;
    private Directory directory;
    private string segment;
    private IndexOutput fieldsStream;
    private IndexOutput indexStream;
    private static int MAX_RAW_MERGE_DOCS;
    public Lucene40StoredFieldsWriter(Directory directory, string segment, IOContext context);
    private static Lucene40StoredFieldsWriter();
    public virtual void StartDocument(int numStoredFields);
    protected virtual void Dispose(bool disposing);
    public virtual void Abort();
    public virtual void WriteField(FieldInfo info, IIndexableField field);
    public void AddRawDocuments(IndexInput stream, Int32[] lengths, int numDocs);
    public virtual void Finish(FieldInfos fis, int numDocs);
    public virtual int Merge(MergeState mergeState);
    private int CopyFieldsWithDeletions(MergeState mergeState, AtomicReader reader, Lucene40StoredFieldsReader matchingFieldsReader, Int32[] rawDocLengths);
    private int CopyFieldsNoDeletions(MergeState mergeState, AtomicReader reader, Lucene40StoredFieldsReader matchingFieldsReader, Int32[] rawDocLengths);
}
public class Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsFormat : TermVectorsFormat {
    public virtual TermVectorsReader VectorsReader(Directory directory, SegmentInfo segmentInfo, FieldInfos fieldInfos, IOContext context);
    public virtual TermVectorsWriter VectorsWriter(Directory directory, SegmentInfo segmentInfo, IOContext context);
}
public class Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader : TermVectorsReader {
    internal static sbyte STORE_POSITIONS_WITH_TERMVECTOR;
    internal static sbyte STORE_OFFSET_WITH_TERMVECTOR;
    internal static sbyte STORE_PAYLOAD_WITH_TERMVECTOR;
    internal static string VECTORS_FIELDS_EXTENSION;
    internal static string VECTORS_DOCUMENTS_EXTENSION;
    internal static string VECTORS_INDEX_EXTENSION;
    internal static string CODEC_NAME_FIELDS;
    internal static string CODEC_NAME_DOCS;
    internal static string CODEC_NAME_INDEX;
    internal static int VERSION_NO_PAYLOADS;
    internal static int VERSION_PAYLOADS;
    internal static int VERSION_START;
    internal static int VERSION_CURRENT;
    internal static long HEADER_LENGTH_FIELDS;
    internal static long HEADER_LENGTH_DOCS;
    internal static long HEADER_LENGTH_INDEX;
    private FieldInfos fieldInfos;
    private IndexInput tvx;
    private IndexInput tvd;
    private IndexInput tvf;
    private int size;
    private int numTotalDocs;
    internal IndexInput TvdStream { get; }
    internal IndexInput TvfStream { get; }
    internal int Count { get; }
    internal Lucene40TermVectorsReader(FieldInfos fieldInfos, IndexInput tvx, IndexInput tvd, IndexInput tvf, int size, int numTotalDocs);
    public Lucene40TermVectorsReader(Directory d, SegmentInfo si, FieldInfos fieldInfos, IOContext context);
    private static Lucene40TermVectorsReader();
    internal virtual IndexInput get_TvdStream();
    internal virtual IndexInput get_TvfStream();
    internal virtual void SeekTvx(int docNum);
    internal void RawDocs(Int32[] tvdLengths, Int32[] tvfLengths, int startDocID, int numDocs);
    protected virtual void Dispose(bool disposing);
    internal virtual int get_Count();
    public virtual Fields Get(int docID);
    public virtual object Clone();
    public virtual long RamBytesUsed();
    public virtual void CheckIntegrity();
}
public class Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsWriter : TermVectorsWriter {
    private Directory directory;
    private string segment;
    private IndexOutput tvx;
    private IndexOutput tvd;
    private IndexOutput tvf;
    private Int64[] fps;
    private int fieldCount;
    private int numVectorFields;
    private string lastFieldName;
    private BytesRef lastTerm;
    private Int32[] offsetStartBuffer;
    private Int32[] offsetEndBuffer;
    private BytesRef payloadData;
    private int bufferedIndex;
    private int bufferedFreq;
    private bool positions;
    private bool offsets;
    private bool payloads;
    internal int lastPosition;
    internal int lastOffset;
    internal int lastPayloadLength;
    internal BytesRef scratch;
    private static int MAX_RAW_MERGE_DOCS;
    public IComparer`1<BytesRef> Comparer { get; }
    public Lucene40TermVectorsWriter(Directory directory, string segment, IOContext context);
    public virtual void StartDocument(int numVectorFields);
    public virtual void StartField(FieldInfo info, int numTerms, bool positions, bool offsets, bool payloads);
    public virtual void FinishDocument();
    public virtual void StartTerm(BytesRef term, int freq);
    public virtual void AddProx(int numProx, DataInput positions, DataInput offsets);
    public virtual void AddPosition(int position, int startOffset, int endOffset, BytesRef payload);
    public virtual void FinishTerm();
    private void WritePosition(int delta, BytesRef payload);
    public virtual void Abort();
    private void AddRawDocuments(Lucene40TermVectorsReader reader, Int32[] tvdLengths, Int32[] tvfLengths, int numDocs);
    public virtual int Merge(MergeState mergeState);
    private int CopyVectorsWithDeletions(MergeState mergeState, Lucene40TermVectorsReader matchingVectorsReader, AtomicReader reader, Int32[] rawDocLengths, Int32[] rawDocLengths2);
    private int CopyVectorsNoDeletions(MergeState mergeState, Lucene40TermVectorsReader matchingVectorsReader, AtomicReader reader, Int32[] rawDocLengths, Int32[] rawDocLengths2);
    public virtual void Finish(FieldInfos fis, int numDocs);
    protected virtual void Dispose(bool disposing);
    public virtual IComparer`1<BytesRef> get_Comparer();
}
internal class Lucene.Net.Codecs.Lucene41.ForUtil : object {
    private static int ALL_VALUES_EQUAL;
    public static int MAX_ENCODED_SIZE;
    public static int MAX_DATA_SIZE;
    private Int32[] encodedSizes;
    private IEncoder[] encoders;
    private IDecoder[] decoders;
    private Int32[] iterations;
    internal ForUtil(float acceptableOverheadRatio, DataOutput out);
    internal ForUtil(DataInput in);
    private static ForUtil();
    private static int LoadMaxDataSize();
    private static int ComputeIterations(IDecoder decoder);
    private static int EncodedSize(Format format, int packedIntsVersion, int bitsPerValue);
    internal void WriteBlock(Int32[] data, Byte[] encoded, IndexOutput out);
    internal void ReadBlock(IndexInput in, Byte[] encoded, Int32[] decoded);
    internal void SkipBlock(IndexInput in);
    private static bool IsAllEqual(Int32[] data);
    private static int BitsRequired(Int32[] data);
}
[ObsoleteAttribute("Only for reading old 4.0 segments")]
[CodecNameAttribute("Lucene41")]
public class Lucene.Net.Codecs.Lucene41.Lucene41Codec : Codec {
    private StoredFieldsFormat fieldsFormat;
    private TermVectorsFormat vectorsFormat;
    private FieldInfosFormat fieldInfosFormat;
    private SegmentInfoFormat infosFormat;
    private LiveDocsFormat liveDocsFormat;
    private PostingsFormat postingsFormat;
    private PostingsFormat defaultFormat;
    private DocValuesFormat dvFormat;
    private NormsFormat normsFormat;
    public StoredFieldsFormat StoredFieldsFormat { get; }
    public TermVectorsFormat TermVectorsFormat { get; }
    public PostingsFormat PostingsFormat { get; }
    public FieldInfosFormat FieldInfosFormat { get; }
    public SegmentInfoFormat SegmentInfoFormat { get; }
    public LiveDocsFormat LiveDocsFormat { get; }
    public DocValuesFormat DocValuesFormat { get; }
    public NormsFormat NormsFormat { get; }
    public virtual StoredFieldsFormat get_StoredFieldsFormat();
    public sealed virtual TermVectorsFormat get_TermVectorsFormat();
    public sealed virtual PostingsFormat get_PostingsFormat();
    public virtual FieldInfosFormat get_FieldInfosFormat();
    public virtual SegmentInfoFormat get_SegmentInfoFormat();
    public sealed virtual LiveDocsFormat get_LiveDocsFormat();
    public virtual PostingsFormat GetPostingsFormatForField(string field);
    public virtual DocValuesFormat get_DocValuesFormat();
    public virtual NormsFormat get_NormsFormat();
}
public class Lucene.Net.Codecs.Lucene41.Lucene41PostingsBaseFormat : PostingsBaseFormat {
    public virtual PostingsReaderBase PostingsReaderBase(SegmentReadState state);
    public virtual PostingsWriterBase PostingsWriterBase(SegmentWriteState state);
}
[PostingsFormatNameAttribute("Lucene41")]
public class Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat : PostingsFormat {
    public static string DOC_EXTENSION;
    public static string POS_EXTENSION;
    public static string PAY_EXTENSION;
    private int minTermBlockSize;
    private int maxTermBlockSize;
    public static int BLOCK_SIZE;
    public Lucene41PostingsFormat(int minTermBlockSize, int maxTermBlockSize);
    private static Lucene41PostingsFormat();
    public virtual string ToString();
    public virtual FieldsConsumer FieldsConsumer(SegmentWriteState state);
    public virtual FieldsProducer FieldsProducer(SegmentReadState state);
}
public class Lucene.Net.Codecs.Lucene41.Lucene41PostingsReader : PostingsReaderBase {
    private IndexInput docIn;
    private IndexInput posIn;
    private IndexInput payIn;
    private ForUtil forUtil;
    private int version;
    public Lucene41PostingsReader(Directory dir, FieldInfos fieldInfos, SegmentInfo segmentInfo, IOContext ioContext, string segmentSuffix);
    public virtual void Init(IndexInput termsIn);
    internal static void ReadVInt32Block(IndexInput docIn, Int32[] docBuffer, Int32[] freqBuffer, int num, bool indexHasFreq);
    public virtual BlockTermState NewTermState();
    protected virtual void Dispose(bool disposing);
    public virtual void DecodeTerm(Int64[] longs, DataInput in, FieldInfo fieldInfo, BlockTermState termState, bool absolute);
    private void DecodeTerm(DataInput in, FieldInfo fieldInfo, Int32BlockTermState termState);
    public virtual DocsEnum Docs(FieldInfo fieldInfo, BlockTermState termState, IBits liveDocs, DocsEnum reuse, DocsFlags flags);
    public virtual DocsAndPositionsEnum DocsAndPositions(FieldInfo fieldInfo, BlockTermState termState, IBits liveDocs, DocsAndPositionsEnum reuse, DocsAndPositionsFlags flags);
    public virtual long RamBytesUsed();
    public virtual void CheckIntegrity();
}
public class Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter : PostingsWriterBase {
    internal static int maxSkipLevels;
    internal static string TERMS_CODEC;
    internal static string DOC_CODEC;
    internal static string POS_CODEC;
    internal static string PAY_CODEC;
    internal static int VERSION_START;
    internal static int VERSION_META_ARRAY;
    internal static int VERSION_CHECKSUM;
    internal static int VERSION_CURRENT;
    internal IndexOutput docOut;
    internal IndexOutput posOut;
    internal IndexOutput payOut;
    internal static Int32BlockTermState emptyState;
    internal Int32BlockTermState lastState;
    private bool fieldHasFreqs;
    private bool fieldHasPositions;
    private bool fieldHasOffsets;
    private bool fieldHasPayloads;
    private long docStartFP;
    private long posStartFP;
    private long payStartFP;
    internal Int32[] docDeltaBuffer;
    internal Int32[] freqBuffer;
    private int docBufferUpto;
    internal Int32[] posDeltaBuffer;
    internal Int32[] payloadLengthBuffer;
    internal Int32[] offsetStartDeltaBuffer;
    internal Int32[] offsetLengthBuffer;
    private int posBufferUpto;
    private Byte[] payloadBytes;
    private int payloadByteUpto;
    private int lastBlockDocID;
    private long lastBlockPosFP;
    private long lastBlockPayFP;
    private int lastBlockPosBufferUpto;
    private int lastBlockPayloadByteUpto;
    private int lastDocID;
    private int lastPosition;
    private int lastStartOffset;
    private int docCount;
    internal Byte[] encoded;
    private ForUtil forUtil;
    private Lucene41SkipWriter skipWriter;
    public Lucene41PostingsWriter(SegmentWriteState state, float acceptableOverheadRatio);
    public Lucene41PostingsWriter(SegmentWriteState state);
    private static Lucene41PostingsWriter();
    public virtual BlockTermState NewTermState();
    public virtual void Init(IndexOutput termsOut);
    public virtual int SetField(FieldInfo fieldInfo);
    public virtual void StartTerm();
    public virtual void StartDoc(int docId, int termDocFreq);
    public virtual void AddPosition(int position, BytesRef payload, int startOffset, int endOffset);
    public virtual void FinishDoc();
    public virtual void FinishTerm(BlockTermState state);
    public virtual void EncodeTerm(Int64[] longs, DataOutput out, FieldInfo fieldInfo, BlockTermState state, bool absolute);
    protected virtual void Dispose(bool disposing);
}
internal class Lucene.Net.Codecs.Lucene41.Lucene41SkipReader : MultiLevelSkipListReader {
    private int blockSize;
    private Int64[] docPointer;
    private Int64[] posPointer;
    private Int64[] payPointer;
    private Int32[] posBufferUpto;
    private Int32[] payloadByteUpto;
    private long lastPosPointer;
    private long lastPayPointer;
    private int lastPayloadByteUpto;
    private long lastDocPointer;
    private int lastPosBufferUpto;
    public long DocPointer { get; }
    public long PosPointer { get; }
    public int PosBufferUpto { get; }
    public long PayPointer { get; }
    public int PayloadByteUpto { get; }
    public int NextSkipDoc { get; }
    public Lucene41SkipReader(IndexInput skipStream, int maxSkipLevels, int blockSize, bool hasPos, bool hasOffsets, bool hasPayloads);
    internal int Trim(int df);
    public void Init(long skipPointer, long docBasePointer, long posBasePointer, long payBasePointer, int df);
    public long get_DocPointer();
    public long get_PosPointer();
    public int get_PosBufferUpto();
    public long get_PayPointer();
    public int get_PayloadByteUpto();
    public int get_NextSkipDoc();
    protected virtual void SeekChild(int level);
    protected virtual void SetLastSkipData(int level);
    protected virtual int ReadSkipData(int level, IndexInput skipStream);
}
internal class Lucene.Net.Codecs.Lucene41.Lucene41SkipWriter : MultiLevelSkipListWriter {
    private Int32[] lastSkipDoc;
    private Int64[] lastSkipDocPointer;
    private Int64[] lastSkipPosPointer;
    private Int64[] lastSkipPayPointer;
    private Int32[] lastPayloadByteUpto;
    private IndexOutput docOut;
    private IndexOutput posOut;
    private IndexOutput payOut;
    private int curDoc;
    private long curDocPointer;
    private long curPosPointer;
    private long curPayPointer;
    private int curPosBufferUpto;
    private int curPayloadByteUpto;
    private bool fieldHasPositions;
    private bool fieldHasOffsets;
    private bool fieldHasPayloads;
    public Lucene41SkipWriter(int maxSkipLevels, int blockSize, int docCount, IndexOutput docOut, IndexOutput posOut, IndexOutput payOut);
    public void SetField(bool fieldHasPositions, bool fieldHasOffsets, bool fieldHasPayloads);
    public virtual void ResetSkip();
    public void BufferSkip(int doc, int numDocs, long posFP, long payFP, int posBufferUpto, int payloadByteUpto);
    protected virtual void WriteSkipData(int level, IndexOutput skipBuffer);
}
public class Lucene.Net.Codecs.Lucene41.Lucene41StoredFieldsFormat : CompressingStoredFieldsFormat {
}
[ObsoleteAttribute("Only for reading old 4.2 segments")]
[CodecNameAttribute("Lucene42")]
public class Lucene.Net.Codecs.Lucene42.Lucene42Codec : Codec {
    private StoredFieldsFormat fieldsFormat;
    private TermVectorsFormat vectorsFormat;
    private FieldInfosFormat fieldInfosFormat;
    private SegmentInfoFormat infosFormat;
    private LiveDocsFormat liveDocsFormat;
    private PostingsFormat postingsFormat;
    private DocValuesFormat docValuesFormat;
    private PostingsFormat defaultFormat;
    private DocValuesFormat defaultDVFormat;
    private NormsFormat normsFormat;
    public StoredFieldsFormat StoredFieldsFormat { get; }
    public TermVectorsFormat TermVectorsFormat { get; }
    public PostingsFormat PostingsFormat { get; }
    public FieldInfosFormat FieldInfosFormat { get; }
    public SegmentInfoFormat SegmentInfoFormat { get; }
    public LiveDocsFormat LiveDocsFormat { get; }
    public DocValuesFormat DocValuesFormat { get; }
    public NormsFormat NormsFormat { get; }
    public sealed virtual StoredFieldsFormat get_StoredFieldsFormat();
    public sealed virtual TermVectorsFormat get_TermVectorsFormat();
    public sealed virtual PostingsFormat get_PostingsFormat();
    public virtual FieldInfosFormat get_FieldInfosFormat();
    public virtual SegmentInfoFormat get_SegmentInfoFormat();
    public sealed virtual LiveDocsFormat get_LiveDocsFormat();
    public virtual PostingsFormat GetPostingsFormatForField(string field);
    public virtual DocValuesFormat GetDocValuesFormatForField(string field);
    public sealed virtual DocValuesFormat get_DocValuesFormat();
    public virtual NormsFormat get_NormsFormat();
}
[ObsoleteAttribute("Only for reading old 4.2 segments")]
[DocValuesFormatNameAttribute("Lucene42")]
public class Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat : DocValuesFormat {
    public static int MAX_BINARY_FIELD_LENGTH;
    protected float m_acceptableOverheadRatio;
    internal static string DATA_CODEC;
    internal static string DATA_EXTENSION;
    internal static string METADATA_CODEC;
    internal static string METADATA_EXTENSION;
    public Lucene42DocValuesFormat(float acceptableOverheadRatio);
    private static Lucene42DocValuesFormat();
    public virtual DocValuesConsumer FieldsConsumer(SegmentWriteState state);
    public virtual DocValuesProducer FieldsProducer(SegmentReadState state);
}
internal class Lucene.Net.Codecs.Lucene42.Lucene42DocValuesProducer : DocValuesProducer {
    private IDictionary`2<int, NumericEntry> numerics;
    private IDictionary`2<int, BinaryEntry> binaries;
    private IDictionary`2<int, FSTEntry> fsts;
    private IndexInput data;
    private int version;
    private IDictionary`2<int, NumericDocValues> numericInstances;
    private IDictionary`2<int, BinaryDocValues> binaryInstances;
    private IDictionary`2<int, FST`1<Int64>> fstInstances;
    private int maxDoc;
    private AtomicInt64 ramBytesUsed;
    internal static sbyte NUMBER;
    internal static sbyte BYTES;
    internal static sbyte FST;
    internal static int BLOCK_SIZE;
    internal static sbyte DELTA_COMPRESSED;
    internal static sbyte TABLE_COMPRESSED;
    internal static sbyte UNCOMPRESSED;
    internal static sbyte GCD_COMPRESSED;
    internal static int VERSION_START;
    internal static int VERSION_GCD_COMPRESSION;
    internal static int VERSION_CHECKSUM;
    internal static int VERSION_CURRENT;
    internal Lucene42DocValuesProducer(SegmentReadState state, string dataCodec, string dataExtension, string metaCodec, string metaExtension);
    private void ReadFields(IndexInput meta);
    public virtual NumericDocValues GetNumeric(FieldInfo field);
    public virtual long RamBytesUsed();
    public virtual void CheckIntegrity();
    private NumericDocValues LoadNumeric(FieldInfo field);
    public virtual BinaryDocValues GetBinary(FieldInfo field);
    private BinaryDocValues LoadBinary(FieldInfo field);
    public virtual SortedDocValues GetSorted(FieldInfo field);
    public virtual SortedSetDocValues GetSortedSet(FieldInfo field);
    public virtual IBits GetDocsWithField(FieldInfo field);
    protected virtual void Dispose(bool disposing);
}
[ObsoleteAttribute("Only for reading old 4.2-4.5 segments")]
public class Lucene.Net.Codecs.Lucene42.Lucene42FieldInfosFormat : FieldInfosFormat {
    private FieldInfosReader reader;
    internal static string EXTENSION;
    internal static string CODEC_NAME;
    internal static int FORMAT_START;
    internal static int FORMAT_CURRENT;
    internal static sbyte IS_INDEXED;
    internal static sbyte STORE_TERMVECTOR;
    internal static sbyte STORE_OFFSETS_IN_POSTINGS;
    internal static sbyte OMIT_NORMS;
    internal static sbyte STORE_PAYLOADS;
    internal static sbyte OMIT_TERM_FREQ_AND_POSITIONS;
    internal static sbyte OMIT_POSITIONS;
    public FieldInfosReader FieldInfosReader { get; }
    public FieldInfosWriter FieldInfosWriter { get; }
    public virtual FieldInfosReader get_FieldInfosReader();
    public virtual FieldInfosWriter get_FieldInfosWriter();
}
[ObsoleteAttribute("Only for reading old 4.2-4.5 segments")]
internal class Lucene.Net.Codecs.Lucene42.Lucene42FieldInfosReader : FieldInfosReader {
    public virtual FieldInfos Read(Directory directory, string segmentName, string segmentSuffix, IOContext iocontext);
    private static DocValuesType GetDocValuesType(IndexInput input, byte b);
}
internal class Lucene.Net.Codecs.Lucene42.Lucene42NormsConsumer : DocValuesConsumer {
    internal static sbyte NUMBER;
    internal static int BLOCK_SIZE;
    internal static sbyte DELTA_COMPRESSED;
    internal static sbyte TABLE_COMPRESSED;
    internal static sbyte UNCOMPRESSED;
    internal static sbyte GCD_COMPRESSED;
    internal IndexOutput data;
    internal IndexOutput meta;
    internal int maxDoc;
    internal float acceptableOverheadRatio;
    internal Lucene42NormsConsumer(SegmentWriteState state, string dataCodec, string dataExtension, string metaCodec, string metaExtension, float acceptableOverheadRatio);
    public virtual void AddNumericField(FieldInfo field, IEnumerable`1<Nullable`1<long>> values);
    protected virtual void Dispose(bool disposing);
    public virtual void AddBinaryField(FieldInfo field, IEnumerable`1<BytesRef> values);
    public virtual void AddSortedField(FieldInfo field, IEnumerable`1<BytesRef> values, IEnumerable`1<Nullable`1<long>> docToOrd);
    public virtual void AddSortedSetField(FieldInfo field, IEnumerable`1<BytesRef> values, IEnumerable`1<Nullable`1<long>> docToOrdCount, IEnumerable`1<Nullable`1<long>> ords);
}
public class Lucene.Net.Codecs.Lucene42.Lucene42NormsFormat : NormsFormat {
    internal float acceptableOverheadRatio;
    private static string DATA_CODEC;
    private static string DATA_EXTENSION;
    private static string METADATA_CODEC;
    private static string METADATA_EXTENSION;
    public Lucene42NormsFormat(float acceptableOverheadRatio);
    public virtual DocValuesConsumer NormsConsumer(SegmentWriteState state);
    public virtual DocValuesProducer NormsProducer(SegmentReadState state);
}
public class Lucene.Net.Codecs.Lucene42.Lucene42TermVectorsFormat : CompressingTermVectorsFormat {
}
[ObsoleteAttribute("Only for reading old 4.3-4.5 segments")]
[CodecNameAttribute("Lucene45")]
public class Lucene.Net.Codecs.Lucene45.Lucene45Codec : Codec {
    private StoredFieldsFormat fieldsFormat;
    private TermVectorsFormat vectorsFormat;
    private FieldInfosFormat fieldInfosFormat;
    private SegmentInfoFormat infosFormat;
    private LiveDocsFormat liveDocsFormat;
    private PostingsFormat postingsFormat;
    private DocValuesFormat docValuesFormat;
    private PostingsFormat defaultFormat;
    private DocValuesFormat defaultDVFormat;
    private NormsFormat normsFormat;
    public StoredFieldsFormat StoredFieldsFormat { get; }
    public TermVectorsFormat TermVectorsFormat { get; }
    public PostingsFormat PostingsFormat { get; }
    public FieldInfosFormat FieldInfosFormat { get; }
    public SegmentInfoFormat SegmentInfoFormat { get; }
    public LiveDocsFormat LiveDocsFormat { get; }
    public DocValuesFormat DocValuesFormat { get; }
    public NormsFormat NormsFormat { get; }
    public sealed virtual StoredFieldsFormat get_StoredFieldsFormat();
    public sealed virtual TermVectorsFormat get_TermVectorsFormat();
    public sealed virtual PostingsFormat get_PostingsFormat();
    public virtual FieldInfosFormat get_FieldInfosFormat();
    public virtual SegmentInfoFormat get_SegmentInfoFormat();
    public sealed virtual LiveDocsFormat get_LiveDocsFormat();
    public virtual PostingsFormat GetPostingsFormatForField(string field);
    public virtual DocValuesFormat GetDocValuesFormatForField(string field);
    public sealed virtual DocValuesFormat get_DocValuesFormat();
    public sealed virtual NormsFormat get_NormsFormat();
}
public class Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer : DocValuesConsumer {
    internal static int BLOCK_SIZE;
    internal static int ADDRESS_INTERVAL;
    internal static long MISSING_ORD;
    public static int DELTA_COMPRESSED;
    public static int GCD_COMPRESSED;
    public static int TABLE_COMPRESSED;
    public static int BINARY_FIXED_UNCOMPRESSED;
    public static int BINARY_VARIABLE_UNCOMPRESSED;
    public static int BINARY_PREFIX_COMPRESSED;
    public static int SORTED_SET_WITH_ADDRESSES;
    public static int SORTED_SET_SINGLE_VALUED_SORTED;
    internal IndexOutput data;
    internal IndexOutput meta;
    internal int maxDoc;
    public Lucene45DocValuesConsumer(SegmentWriteState state, string dataCodec, string dataExtension, string metaCodec, string metaExtension);
    private static Lucene45DocValuesConsumer();
    public virtual void AddNumericField(FieldInfo field, IEnumerable`1<Nullable`1<long>> values);
    internal virtual void AddNumericField(FieldInfo field, IEnumerable`1<Nullable`1<long>> values, bool optimizeStorage);
    internal virtual void WriteMissingBitset(IEnumerable values);
    public virtual void AddBinaryField(FieldInfo field, IEnumerable`1<BytesRef> values);
    protected virtual void AddTermsDict(FieldInfo field, IEnumerable`1<BytesRef> values);
    public virtual void AddSortedField(FieldInfo field, IEnumerable`1<BytesRef> values, IEnumerable`1<Nullable`1<long>> docToOrd);
    private static bool IsSingleValued(IEnumerable`1<Nullable`1<long>> docToOrdCount);
    public virtual void AddSortedSetField(FieldInfo field, IEnumerable`1<BytesRef> values, IEnumerable`1<Nullable`1<long>> docToOrdCount, IEnumerable`1<Nullable`1<long>> ords);
    [IteratorStateMachineAttribute("Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer/<GetSortedSetEnumerable>d__23")]
private IEnumerable`1<Nullable`1<long>> GetSortedSetEnumerable(IEnumerable`1<Nullable`1<long>> docToOrdCount, IEnumerable`1<Nullable`1<long>> ords);
    protected virtual void Dispose(bool disposing);
}
[DocValuesFormatNameAttribute("Lucene45")]
public class Lucene.Net.Codecs.Lucene45.Lucene45DocValuesFormat : DocValuesFormat {
    internal static string DATA_CODEC;
    internal static string DATA_EXTENSION;
    internal static string META_CODEC;
    internal static string META_EXTENSION;
    internal static int VERSION_START;
    internal static int VERSION_SORTED_SET_SINGLE_VALUE_OPTIMIZED;
    internal static int VERSION_CHECKSUM;
    internal static int VERSION_CURRENT;
    internal static sbyte NUMERIC;
    internal static sbyte BINARY;
    internal static sbyte SORTED;
    internal static sbyte SORTED_SET;
    public virtual DocValuesConsumer FieldsConsumer(SegmentWriteState state);
    public virtual DocValuesProducer FieldsProducer(SegmentReadState state);
}
public class Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer : DocValuesProducer {
    private IDictionary`2<int, NumericEntry> numerics;
    private IDictionary`2<int, BinaryEntry> binaries;
    private IDictionary`2<int, SortedSetEntry> sortedSets;
    private IDictionary`2<int, NumericEntry> ords;
    private IDictionary`2<int, NumericEntry> ordIndexes;
    private AtomicInt64 ramBytesUsed;
    private IndexInput data;
    private int maxDoc;
    private int version;
    private IDictionary`2<int, MonotonicBlockPackedReader> addressInstances;
    private IDictionary`2<int, MonotonicBlockPackedReader> ordIndexInstances;
    protected internal Lucene45DocValuesProducer(SegmentReadState state, string dataCodec, string dataExtension, string metaCodec, string metaExtension);
    private void ReadSortedField(int fieldNumber, IndexInput meta);
    private void ReadSortedSetFieldWithAddresses(int fieldNumber, IndexInput meta);
    private void ReadFields(IndexInput meta);
    internal static NumericEntry ReadNumericEntry(IndexInput meta);
    internal static BinaryEntry ReadBinaryEntry(IndexInput meta);
    internal virtual SortedSetEntry ReadSortedSetEntry(IndexInput meta);
    public virtual NumericDocValues GetNumeric(FieldInfo field);
    public virtual long RamBytesUsed();
    public virtual void CheckIntegrity();
    internal virtual Int64Values GetNumeric(NumericEntry entry);
    public virtual BinaryDocValues GetBinary(FieldInfo field);
    private BinaryDocValues GetFixedBinary(BinaryEntry bytes);
    protected virtual MonotonicBlockPackedReader GetAddressInstance(IndexInput data, FieldInfo field, BinaryEntry bytes);
    private BinaryDocValues GetVariableBinary(FieldInfo field, BinaryEntry bytes);
    protected virtual MonotonicBlockPackedReader GetIntervalInstance(IndexInput data, FieldInfo field, BinaryEntry bytes);
    private BinaryDocValues GetCompressedBinary(FieldInfo field, BinaryEntry bytes);
    public virtual SortedDocValues GetSorted(FieldInfo field);
    protected virtual MonotonicBlockPackedReader GetOrdIndexInstance(IndexInput data, FieldInfo field, NumericEntry entry);
    public virtual SortedSetDocValues GetSortedSet(FieldInfo field);
    private IBits GetMissingBits(long offset);
    public virtual IBits GetDocsWithField(FieldInfo field);
    protected virtual void Dispose(bool disposing);
}
[CodecNameAttribute("Lucene46")]
public class Lucene.Net.Codecs.Lucene46.Lucene46Codec : Codec {
    private StoredFieldsFormat fieldsFormat;
    private TermVectorsFormat vectorsFormat;
    private FieldInfosFormat fieldInfosFormat;
    private SegmentInfoFormat segmentInfosFormat;
    private LiveDocsFormat liveDocsFormat;
    private PostingsFormat postingsFormat;
    private DocValuesFormat docValuesFormat;
    private PostingsFormat defaultFormat;
    private DocValuesFormat defaultDVFormat;
    private NormsFormat normsFormat;
    public StoredFieldsFormat StoredFieldsFormat { get; }
    public TermVectorsFormat TermVectorsFormat { get; }
    public PostingsFormat PostingsFormat { get; }
    public FieldInfosFormat FieldInfosFormat { get; }
    public SegmentInfoFormat SegmentInfoFormat { get; }
    public LiveDocsFormat LiveDocsFormat { get; }
    public DocValuesFormat DocValuesFormat { get; }
    public NormsFormat NormsFormat { get; }
    public sealed virtual StoredFieldsFormat get_StoredFieldsFormat();
    public sealed virtual TermVectorsFormat get_TermVectorsFormat();
    public sealed virtual PostingsFormat get_PostingsFormat();
    public sealed virtual FieldInfosFormat get_FieldInfosFormat();
    public sealed virtual SegmentInfoFormat get_SegmentInfoFormat();
    public sealed virtual LiveDocsFormat get_LiveDocsFormat();
    public virtual PostingsFormat GetPostingsFormatForField(string field);
    public virtual DocValuesFormat GetDocValuesFormatForField(string field);
    public sealed virtual DocValuesFormat get_DocValuesFormat();
    public sealed virtual NormsFormat get_NormsFormat();
}
public class Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosFormat : FieldInfosFormat {
    private FieldInfosReader reader;
    private FieldInfosWriter writer;
    internal static string EXTENSION;
    internal static string CODEC_NAME;
    internal static int FORMAT_START;
    internal static int FORMAT_CHECKSUM;
    internal static int FORMAT_CURRENT;
    internal static sbyte IS_INDEXED;
    internal static sbyte STORE_TERMVECTOR;
    internal static sbyte STORE_OFFSETS_IN_POSTINGS;
    internal static sbyte OMIT_NORMS;
    internal static sbyte STORE_PAYLOADS;
    internal static sbyte OMIT_TERM_FREQ_AND_POSITIONS;
    internal static sbyte OMIT_POSITIONS;
    public FieldInfosReader FieldInfosReader { get; }
    public FieldInfosWriter FieldInfosWriter { get; }
    public virtual FieldInfosReader get_FieldInfosReader();
    public virtual FieldInfosWriter get_FieldInfosWriter();
}
internal class Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosReader : FieldInfosReader {
    public virtual FieldInfos Read(Directory directory, string segmentName, string segmentSuffix, IOContext context);
    private static DocValuesType GetDocValuesType(IndexInput input, byte b);
}
internal class Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosWriter : FieldInfosWriter {
    public virtual void Write(Directory directory, string segmentName, string segmentSuffix, FieldInfos infos, IOContext context);
    private static sbyte DocValuesByte(DocValuesType type);
}
public class Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoFormat : SegmentInfoFormat {
    private SegmentInfoReader reader;
    private SegmentInfoWriter writer;
    public static string SI_EXTENSION;
    internal static string CODEC_NAME;
    internal static int VERSION_START;
    internal static int VERSION_CHECKSUM;
    internal static int VERSION_CURRENT;
    public SegmentInfoReader SegmentInfoReader { get; }
    public SegmentInfoWriter SegmentInfoWriter { get; }
    private static Lucene46SegmentInfoFormat();
    public virtual SegmentInfoReader get_SegmentInfoReader();
    public virtual SegmentInfoWriter get_SegmentInfoWriter();
}
public class Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoReader : SegmentInfoReader {
    public virtual SegmentInfo Read(Directory dir, string segment, IOContext context);
}
public class Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoWriter : SegmentInfoWriter {
    public virtual void Write(Directory dir, SegmentInfo si, FieldInfos fis, IOContext ioContext);
}
public class Lucene.Net.Codecs.MappingMultiDocsAndPositionsEnum : DocsAndPositionsEnum {
    private EnumWithSlice[] subs;
    internal int numSubs;
    internal int upto;
    internal DocMap currentMap;
    internal DocsAndPositionsEnum current;
    internal int currentBase;
    internal int doc;
    private MergeState mergeState;
    public MergeState MergeState { get; public set; }
    public int NumSubs { get; }
    [WritableArrayAttribute]
public EnumWithSlice[] Subs { get; }
    public int Freq { get; }
    public int DocID { get; }
    public int StartOffset { get; }
    public int EndOffset { get; }
    internal MappingMultiDocsAndPositionsEnum Reset(MultiDocsAndPositionsEnum postingsEnum);
    public MergeState get_MergeState();
    public void set_MergeState(MergeState value);
    public int get_NumSubs();
    public EnumWithSlice[] get_Subs();
    public virtual int get_Freq();
    public virtual int get_DocID();
    public virtual int Advance(int target);
    public virtual int NextDoc();
    public virtual int NextPosition();
    public virtual int get_StartOffset();
    public virtual int get_EndOffset();
    public virtual BytesRef GetPayload();
    public virtual long GetCost();
}
public class Lucene.Net.Codecs.MappingMultiDocsEnum : DocsEnum {
    private EnumWithSlice[] subs;
    internal int numSubs;
    internal int upto;
    internal DocMap currentMap;
    internal DocsEnum current;
    internal int currentBase;
    internal int doc;
    private MergeState mergeState;
    public MergeState MergeState { get; public set; }
    public int NumSubs { get; }
    [WritableArrayAttribute]
public EnumWithSlice[] Subs { get; }
    public int Freq { get; }
    public int DocID { get; }
    internal MappingMultiDocsEnum Reset(MultiDocsEnum docsEnum);
    public MergeState get_MergeState();
    public void set_MergeState(MergeState value);
    public int get_NumSubs();
    public EnumWithSlice[] get_Subs();
    public virtual int get_Freq();
    public virtual int get_DocID();
    public virtual int Advance(int target);
    public virtual int NextDoc();
    public virtual long GetCost();
}
public abstract class Lucene.Net.Codecs.MultiLevelSkipListReader : object {
    protected internal int m_maxNumberOfSkipLevels;
    private int numberOfSkipLevels;
    private int numberOfLevelsToBuffer;
    private int docCount;
    private bool haveSkipped;
    private IndexInput[] skipStream;
    private Int64[] skipPointer;
    private Int32[] skipInterval;
    private Int32[] numSkipped;
    protected internal Int32[] m_skipDoc;
    private int lastDoc;
    private Int64[] childPointer;
    private long lastChildPointer;
    private bool inputIsBuffered;
    private int skipMultiplier;
    public int Doc { get; }
    protected MultiLevelSkipListReader(IndexInput skipStream, int maxSkipLevels, int skipInterval, int skipMultiplier);
    protected internal MultiLevelSkipListReader(IndexInput skipStream, int maxSkipLevels, int skipInterval);
    public virtual int get_Doc();
    public virtual int SkipTo(int target);
    private bool LoadNextSkip(int level);
    protected virtual void SeekChild(int level);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Init(long skipPointer, int df);
    private void LoadSkipLevels();
    protected abstract virtual int ReadSkipData(int level, IndexInput skipStream);
    protected virtual void SetLastSkipData(int level);
}
public abstract class Lucene.Net.Codecs.MultiLevelSkipListWriter : object {
    protected internal int m_numberOfSkipLevels;
    private int skipInterval;
    private int skipMultiplier;
    private RAMOutputStream[] skipBuffer;
    protected MultiLevelSkipListWriter(int skipInterval, int skipMultiplier, int maxSkipLevels, int df);
    protected MultiLevelSkipListWriter(int skipInterval, int maxSkipLevels, int df);
    protected virtual void Init();
    public virtual void ResetSkip();
    protected abstract virtual void WriteSkipData(int level, IndexOutput skipBuffer);
    public virtual void BufferSkip(int df);
    public virtual long WriteSkip(IndexOutput output);
}
public abstract class Lucene.Net.Codecs.NormsFormat : object {
    public abstract virtual DocValuesConsumer NormsConsumer(SegmentWriteState state);
    public abstract virtual DocValuesProducer NormsProducer(SegmentReadState state);
}
[DocValuesFormatNameAttribute("PerFieldDV40")]
public abstract class Lucene.Net.Codecs.PerField.PerFieldDocValuesFormat : DocValuesFormat {
    public static string PER_FIELD_FORMAT_KEY;
    public static string PER_FIELD_SUFFIX_KEY;
    private static PerFieldDocValuesFormat();
    public sealed virtual DocValuesConsumer FieldsConsumer(SegmentWriteState state);
    internal static string GetSuffix(string formatName, string suffix);
    internal static string GetFullSegmentSuffix(string outerSegmentSuffix, string segmentSuffix);
    public sealed virtual DocValuesProducer FieldsProducer(SegmentReadState state);
    public abstract virtual DocValuesFormat GetDocValuesFormatForField(string field);
}
[PostingsFormatNameAttribute("PerField40")]
public abstract class Lucene.Net.Codecs.PerField.PerFieldPostingsFormat : PostingsFormat {
    public static string PER_FIELD_FORMAT_KEY;
    public static string PER_FIELD_SUFFIX_KEY;
    private static PerFieldPostingsFormat();
    public sealed virtual FieldsConsumer FieldsConsumer(SegmentWriteState state);
    internal static string GetSuffix(string formatName, string suffix);
    internal static string GetFullSegmentSuffix(string fieldName, string outerSegmentSuffix, string segmentSuffix);
    public sealed virtual FieldsProducer FieldsProducer(SegmentReadState state);
    public abstract virtual PostingsFormat GetPostingsFormatForField(string field);
}
public abstract class Lucene.Net.Codecs.PostingsBaseFormat : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    protected internal PostingsBaseFormat(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public abstract virtual PostingsReaderBase PostingsReaderBase(SegmentReadState state);
    public abstract virtual PostingsWriterBase PostingsWriterBase(SegmentWriteState state);
}
public abstract class Lucene.Net.Codecs.PostingsConsumer : object {
    public abstract virtual void StartDoc(int docId, int freq);
    public abstract virtual void AddPosition(int position, BytesRef payload, int startOffset, int endOffset);
    public abstract virtual void FinishDoc();
    public virtual TermStats Merge(MergeState mergeState, IndexOptions indexOptions, DocsEnum postings, FixedBitSet visitedDocs);
}
public abstract class Lucene.Net.Codecs.PostingsFormat : object {
    private static IPostingsFormatFactory postingsFormatFactory;
    public static PostingsFormat[] EMPTY;
    private string name;
    public string Name { get; }
    public static ICollection`1<string> AvailablePostingsFormats { get; }
    private static PostingsFormat();
    public static void SetPostingsFormatFactory(IPostingsFormatFactory postingsFormatFactory);
    public static IPostingsFormatFactory GetPostingsFormatFactory();
    public string get_Name();
    public abstract virtual FieldsConsumer FieldsConsumer(SegmentWriteState state);
    public abstract virtual FieldsProducer FieldsProducer(SegmentReadState state);
    public virtual string ToString();
    public static PostingsFormat ForName(string name);
    public static ICollection`1<string> get_AvailablePostingsFormats();
}
[AttributeUsageAttribute("4")]
public class Lucene.Net.Codecs.PostingsFormatNameAttribute : ServiceNameAttribute {
    public PostingsFormatNameAttribute(string name);
}
public abstract class Lucene.Net.Codecs.PostingsReaderBase : object {
    public abstract virtual void Init(IndexInput termsIn);
    public abstract virtual BlockTermState NewTermState();
    public abstract virtual void DecodeTerm(Int64[] longs, DataInput in, FieldInfo fieldInfo, BlockTermState state, bool absolute);
    public abstract virtual DocsEnum Docs(FieldInfo fieldInfo, BlockTermState state, IBits skipDocs, DocsEnum reuse, DocsFlags flags);
    public abstract virtual DocsAndPositionsEnum DocsAndPositions(FieldInfo fieldInfo, BlockTermState state, IBits skipDocs, DocsAndPositionsEnum reuse, DocsAndPositionsFlags flags);
    public abstract virtual long RamBytesUsed();
    public abstract virtual void CheckIntegrity();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
public abstract class Lucene.Net.Codecs.PostingsWriterBase : PostingsConsumer {
    public abstract virtual void Init(IndexOutput termsOut);
    public abstract virtual BlockTermState NewTermState();
    public abstract virtual void StartTerm();
    public abstract virtual void FinishTerm(BlockTermState state);
    public abstract virtual void EncodeTerm(Int64[] longs, DataOutput out, FieldInfo fieldInfo, BlockTermState state, bool absolute);
    public abstract virtual int SetField(FieldInfo fieldInfo);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
public abstract class Lucene.Net.Codecs.SegmentInfoFormat : object {
    public SegmentInfoReader SegmentInfoReader { get; }
    public SegmentInfoWriter SegmentInfoWriter { get; }
    public abstract virtual SegmentInfoReader get_SegmentInfoReader();
    public abstract virtual SegmentInfoWriter get_SegmentInfoWriter();
}
public abstract class Lucene.Net.Codecs.SegmentInfoReader : object {
    public abstract virtual SegmentInfo Read(Directory directory, string segmentName, IOContext context);
}
public abstract class Lucene.Net.Codecs.SegmentInfoWriter : object {
    public abstract virtual void Write(Directory dir, SegmentInfo info, FieldInfos fis, IOContext ioContext);
}
public abstract class Lucene.Net.Codecs.StoredFieldsFormat : object {
    public abstract virtual StoredFieldsReader FieldsReader(Directory directory, SegmentInfo si, FieldInfos fn, IOContext context);
    public abstract virtual StoredFieldsWriter FieldsWriter(Directory directory, SegmentInfo si, IOContext context);
}
public abstract class Lucene.Net.Codecs.StoredFieldsReader : object {
    public abstract virtual void VisitDocument(int n, StoredFieldVisitor visitor);
    public abstract virtual object Clone();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public abstract virtual long RamBytesUsed();
    public abstract virtual void CheckIntegrity();
}
public abstract class Lucene.Net.Codecs.StoredFieldsWriter : object {
    public abstract virtual void StartDocument(int numStoredFields);
    public virtual void FinishDocument();
    public abstract virtual void WriteField(FieldInfo info, IIndexableField field);
    public abstract virtual void Abort();
    public abstract virtual void Finish(FieldInfos fis, int numDocs);
    public virtual int Merge(MergeState mergeState);
    protected void AddDocument(IEnumerable`1<T1> doc, FieldInfos fieldInfos);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
public abstract class Lucene.Net.Codecs.TermsConsumer : object {
    private MappingMultiDocsEnum docsEnum;
    private MappingMultiDocsEnum docsAndFreqsEnum;
    private MappingMultiDocsAndPositionsEnum postingsEnum;
    public IComparer`1<BytesRef> Comparer { get; }
    public abstract virtual PostingsConsumer StartTerm(BytesRef text);
    public abstract virtual void FinishTerm(BytesRef text, TermStats stats);
    public abstract virtual void Finish(long sumTotalTermFreq, long sumDocFreq, int docCount);
    public abstract virtual IComparer`1<BytesRef> get_Comparer();
    public virtual void Merge(MergeState mergeState, IndexOptions indexOptions, TermsEnum termsEnum);
}
public class Lucene.Net.Codecs.TermStats : object {
    [CompilerGeneratedAttribute]
private int <DocFreq>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalTermFreq>k__BackingField;
    public int DocFreq { get; private set; }
    public long TotalTermFreq { get; private set; }
    public TermStats(int docFreq, long totalTermFreq);
    [CompilerGeneratedAttribute]
public int get_DocFreq();
    [CompilerGeneratedAttribute]
private void set_DocFreq(int value);
    [CompilerGeneratedAttribute]
public long get_TotalTermFreq();
    [CompilerGeneratedAttribute]
private void set_TotalTermFreq(long value);
}
public abstract class Lucene.Net.Codecs.TermVectorsFormat : object {
    public abstract virtual TermVectorsReader VectorsReader(Directory directory, SegmentInfo segmentInfo, FieldInfos fieldInfos, IOContext context);
    public abstract virtual TermVectorsWriter VectorsWriter(Directory directory, SegmentInfo segmentInfo, IOContext context);
}
public abstract class Lucene.Net.Codecs.TermVectorsReader : object {
    public abstract virtual Fields Get(int doc);
    public abstract virtual long RamBytesUsed();
    public abstract virtual void CheckIntegrity();
    public abstract virtual object Clone();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
public abstract class Lucene.Net.Codecs.TermVectorsWriter : object {
    public IComparer`1<BytesRef> Comparer { get; }
    public abstract virtual void StartDocument(int numVectorFields);
    public virtual void FinishDocument();
    public abstract virtual void StartField(FieldInfo info, int numTerms, bool positions, bool offsets, bool payloads);
    public virtual void FinishField();
    public abstract virtual void StartTerm(BytesRef term, int freq);
    public virtual void FinishTerm();
    public abstract virtual void AddPosition(int position, int startOffset, int endOffset, BytesRef payload);
    public abstract virtual void Abort();
    public abstract virtual void Finish(FieldInfos fis, int numDocs);
    public virtual void AddProx(int numProx, DataInput positions, DataInput offsets);
    public virtual int Merge(MergeState mergeState);
    protected void AddAllDocVectors(Fields vectors, MergeState mergeState);
    public abstract virtual IComparer`1<BytesRef> get_Comparer();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
internal class Lucene.Net.Configuration.ConfigurationReloadToken : object {
    private CancellationTokenSource _cts;
    public bool ActiveChangeCallbacks { get; }
    public bool HasChanged { get; }
    public sealed virtual bool get_ActiveChangeCallbacks();
    public sealed virtual bool get_HasChanged();
    public sealed virtual IDisposable RegisterChangeCallback(Action`1<object> callback, object state);
    public void OnReload();
}
[DefaultMemberAttribute("Item")]
internal class Lucene.Net.Configuration.ConfigurationRoot : object {
    private IList`1<IConfigurationProvider> _providers;
    private ConfigurationReloadToken _changeToken;
    public IEnumerable`1<IConfigurationProvider> Providers { get; }
    public string Item { get; public set; }
    public ConfigurationRoot(IList`1<IConfigurationProvider> providers);
    public sealed virtual IEnumerable`1<IConfigurationProvider> get_Providers();
    public sealed virtual string get_Item(string key);
    public sealed virtual void set_Item(string key, string value);
    public sealed virtual IEnumerable`1<IConfigurationSection> GetChildren();
    internal IEnumerable`1<IConfigurationSection> GetChildrenImplementation(string path);
    public sealed virtual IChangeToken GetReloadToken();
    public sealed virtual IConfigurationSection GetSection(string key);
    public sealed virtual void Reload();
    private void RaiseChanged();
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_1();
}
[DefaultMemberAttribute("Item")]
internal class Lucene.Net.Configuration.ConfigurationSection : object {
    private ConfigurationRoot _root;
    private string _path;
    private string _key;
    public string Path { get; }
    public string Key { get; }
    public string Value { get; public set; }
    public string Item { get; public set; }
    public ConfigurationSection(ConfigurationRoot root, string path);
    public sealed virtual string get_Path();
    public sealed virtual string get_Key();
    public sealed virtual string get_Value();
    public sealed virtual void set_Value(string value);
    public sealed virtual string get_Item(string key);
    public sealed virtual void set_Item(string key, string value);
    public sealed virtual IConfigurationSection GetSection(string key);
    public sealed virtual IEnumerable`1<IConfigurationSection> GetChildren();
    public sealed virtual IChangeToken GetReloadToken();
}
public static class Lucene.Net.Configuration.ConfigurationSettings : object {
    private static IConfigurationFactory configurationFactory;
    [CLSCompliantAttribute("False")]
public static IConfiguration CurrentConfiguration { get; }
    private static ConfigurationSettings();
    [CLSCompliantAttribute("False")]
public static void SetConfigurationFactory(IConfigurationFactory configurationFactory);
    [CLSCompliantAttribute("False")]
public static IConfigurationFactory GetConfigurationFactory();
    public static IConfiguration get_CurrentConfiguration();
}
internal class Lucene.Net.Configuration.DefaultConfigurationFactory : object {
    private IConfiguration configuration;
    public sealed virtual IConfiguration GetConfiguration();
}
internal class Lucene.Net.Configuration.EnvironmentVariablesConfigurationProvider : object {
    private bool ignoreSecurityExceptionsOnRead;
    private string _prefix;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, string> <Data>k__BackingField;
    private IChangeToken _reloadToken;
    protected ConcurrentDictionary`2<string, string> Data { get; protected set; }
    public EnvironmentVariablesConfigurationProvider(bool ignoreSecurityExceptionsOnRead);
    public EnvironmentVariablesConfigurationProvider(string prefix, bool ignoreSecurityExceptionsOnRead);
    public sealed virtual void Load();
    [CompilerGeneratedAttribute]
protected ConcurrentDictionary`2<string, string> get_Data();
    [CompilerGeneratedAttribute]
protected void set_Data(ConcurrentDictionary`2<string, string> value);
    public virtual bool TryGet(string key, String& value);
    public virtual void Set(string key, string value);
    public virtual IEnumerable`1<string> GetChildKeys(IEnumerable`1<string> earlierKeys, string parentPath);
    private static string Segment(string key, int prefixLength);
    public sealed virtual IChangeToken GetReloadToken();
    [CompilerGeneratedAttribute]
private string <TryGet>b__9_0(string name);
}
[CLSCompliantAttribute("False")]
public interface Lucene.Net.Configuration.IConfigurationFactory {
    public abstract virtual IConfiguration GetConfiguration();
}
public class Lucene.Net.Diagnostics.AssertionException : Exception {
    public AssertionException(string message);
    public AssertionException(string message, Exception innerException);
    protected AssertionException(SerializationInfo info, StreamingContext context);
}
internal static class Lucene.Net.Diagnostics.Debugging : object {
    public static bool AssertsEnabled;
    private static Debugging();
    [DebuggerStepThroughAttribute]
public static void Assert(bool condition);
    [DebuggerStepThroughAttribute]
public static void Assert(bool condition, string messageFormat, T0 p0);
    [DebuggerStepThroughAttribute]
public static void Assert(bool condition, string messageFormat, T0 p0, T1 p1);
    [DebuggerStepThroughAttribute]
public static void Assert(bool condition, string messageFormat, T0 p0, T1 p1, T2 p2);
    [DebuggerStepThroughAttribute]
public static void Assert(bool condition, string messageFormat, T0 p0, T1 p1, T2 p2, T3 p3);
    [DebuggerStepThroughAttribute]
public static void Assert(bool condition, string messageFormat, T0 p0, T1 p1, T2 p2, T3 p3, T4 p4);
    [DebuggerStepThroughAttribute]
public static void Assert(bool condition, string messageFormat, T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5);
    [DebuggerStepThroughAttribute]
public static void Assert(bool condition, string messageFormat, T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6);
    [DebuggerStepThroughAttribute]
public static void Assert(bool condition, string messageFormat, T0 p0, T1 p1, T2 p2, T3 p3, T4 p4, T5 p5, T6 p6, T7 p7);
    [DebuggerStepThroughAttribute]
public static void Assert(bool condition, string message);
}
public class Lucene.Net.Documents.BinaryDocValuesField : Field {
    [ObsoleteAttribute("Use TYPE instead. This field will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public static FieldType fType;
    public static FieldType TYPE;
    public BinaryDocValuesField(string name, BytesRef value);
    private static BinaryDocValuesField();
}
[ObsoleteAttribute("Use NumericDocValuesField instead")]
public class Lucene.Net.Documents.ByteDocValuesField : NumericDocValuesField {
    public ByteDocValuesField(string name, byte value);
    public virtual void SetByteValue(byte value);
}
public static class Lucene.Net.Documents.CompressionTools : object {
    public static Byte[] Compress(Byte[] value, int offset, int length, CompressionLevel compressionLevel);
    public static Byte[] Compress(Byte[] value, int offset, int length);
    public static Byte[] Compress(Byte[] value);
    public static Byte[] CompressString(string value);
    public static Byte[] CompressString(string value, CompressionLevel compressionLevel);
    public static Byte[] Decompress(BytesRef bytes);
    public static Byte[] Decompress(Byte[] value);
    public static Byte[] Decompress(Byte[] value, int offset, int length);
    public static string DecompressString(Byte[] value);
    public static string DecompressString(Byte[] value, int offset, int length);
    public static string DecompressString(BytesRef bytes);
}
public enum Lucene.Net.Documents.DateResolution : Enum {
    public int value__;
    public static DateResolution YEAR;
    public static DateResolution MONTH;
    public static DateResolution DAY;
    public static DateResolution HOUR;
    public static DateResolution MINUTE;
    public static DateResolution SECOND;
    public static DateResolution MILLISECOND;
}
public static class Lucene.Net.Documents.DateTools : object {
    private static string ToDateFormat(DateResolution resolution);
    public static string DateToString(DateTime date, DateResolution resolution);
    public static string DateToString(DateTime date, TimeZoneInfo timeZone, DateResolution resolution);
    private static string DateToString(DateTime date, DateResolution resolution, TimeZoneInfo timeZone);
    public static string DateToString(DateTimeOffset date, DateResolution resolution);
    public static string TimeToString(long time, DateResolution resolution, NumericRepresentation inputRepresentation);
    public static long StringToTime(string dateString, NumericRepresentation outputRepresentation);
    public static DateTime StringToDate(string dateString);
    public static DateTime Round(DateTime date, DateResolution resolution);
    public static long Round(long time, DateResolution resolution, NumericRepresentation inputRepresentation, NumericRepresentation outputRepresentation);
    public static long TicksToUnixTimeMilliseconds(long ticks);
    public static long UnixTimeMillisecondsToTicks(long unixTimeMilliseconds);
}
[ObsoleteAttribute("Use BinaryDocValuesField instead.")]
public class Lucene.Net.Documents.DerefBytesDocValuesField : BinaryDocValuesField {
    public static FieldType TYPE_FIXED_LEN;
    public static FieldType TYPE_VAR_LEN;
    public DerefBytesDocValuesField(string name, BytesRef bytes);
    public DerefBytesDocValuesField(string name, BytesRef bytes, bool isFixedLength);
    private static DerefBytesDocValuesField();
}
public class Lucene.Net.Documents.Document : object {
    private IList`1<IIndexableField> fields;
    private static String[] NO_STRINGS;
    public IList`1<IIndexableField> Fields { get; }
    private static Document();
    public sealed virtual IEnumerator`1<IIndexableField> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add(IIndexableField field);
    public void RemoveField(string name);
    public void RemoveFields(string name);
    public BytesRef[] GetBinaryValues(string name);
    public BytesRef GetBinaryValue(string name);
    public IIndexableField GetField(string name);
    public IIndexableField[] GetFields(string name);
    public IList`1<IIndexableField> get_Fields();
    public String[] GetValues(string name);
    public String[] GetValues(string name, string format);
    public String[] GetValues(string name, IFormatProvider provider);
    public String[] GetValues(string name, string format, IFormatProvider provider);
    public string Get(string name);
    public string Get(string name, string format);
    public string Get(string name, IFormatProvider provider);
    public string Get(string name, string format, IFormatProvider provider);
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    private string ToString(string format, IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider provider);
}
public class Lucene.Net.Documents.DocumentStoredFieldVisitor : StoredFieldVisitor {
    private Document doc;
    private ISet`1<string> fieldsToAdd;
    public Document Document { get; }
    public DocumentStoredFieldVisitor(ISet`1<string> fieldsToAdd);
    public DocumentStoredFieldVisitor(String[] fields);
    public virtual void BinaryField(FieldInfo fieldInfo, Byte[] value);
    public virtual void StringField(FieldInfo fieldInfo, string value);
    public virtual void Int32Field(FieldInfo fieldInfo, int value);
    public virtual void Int64Field(FieldInfo fieldInfo, long value);
    public virtual void SingleField(FieldInfo fieldInfo, float value);
    public virtual void DoubleField(FieldInfo fieldInfo, double value);
    public virtual Status NeedsField(FieldInfo fieldInfo);
    public virtual Document get_Document();
}
public class Lucene.Net.Documents.DoubleDocValuesField : NumericDocValuesField {
    public DoubleDocValuesField(string name, double value);
    public virtual void SetDoubleValue(double value);
    public virtual void SetInt64Value(long value);
}
public class Lucene.Net.Documents.DoubleField : Field {
    public static FieldType TYPE_NOT_STORED;
    public static FieldType TYPE_STORED;
    public DoubleField(string name, double value, Store stored);
    public DoubleField(string name, double value, FieldType type);
    private static DoubleField();
}
[ExtensionAttribute]
public static class Lucene.Net.Documents.Extensions.DocumentExtensions : object {
    [ExtensionAttribute]
public static T GetField(Document document, string name);
    [ExtensionAttribute]
public static T[] GetFields(Document document, string name);
    [ExtensionAttribute]
public static BinaryDocValuesField AddBinaryDocValuesField(Document document, string name, BytesRef value);
    [ExtensionAttribute]
public static DoubleDocValuesField AddDoubleDocValuesField(Document document, string name, double value);
    [ExtensionAttribute]
public static DoubleField AddDoubleField(Document document, string name, double value, Store stored);
    [ExtensionAttribute]
public static DoubleField AddDoubleField(Document document, string name, double value, FieldType type);
    [ExtensionAttribute]
public static SingleDocValuesField AddSingleDocValuesField(Document document, string name, float value);
    [ExtensionAttribute]
public static SingleField AddSingleField(Document document, string name, float value, Store stored);
    [ExtensionAttribute]
public static SingleField AddSingleField(Document document, string name, float value, FieldType type);
    [ExtensionAttribute]
public static Int32Field AddInt32Field(Document document, string name, int value, Store stored);
    [ExtensionAttribute]
public static Int32Field AddInt32Field(Document document, string name, int value, FieldType type);
    [ExtensionAttribute]
public static Int64Field AddInt64Field(Document document, string name, long value, Store stored);
    [ExtensionAttribute]
public static Int64Field AddInt64Field(Document document, string name, long value, FieldType type);
    [ExtensionAttribute]
public static NumericDocValuesField AddNumericDocValuesField(Document document, string name, long value);
    [ExtensionAttribute]
public static SortedDocValuesField AddSortedDocValuesField(Document document, string name, BytesRef bytes);
    [ExtensionAttribute]
public static SortedSetDocValuesField AddSortedSetDocValuesField(Document document, string name, BytesRef bytes);
    [ExtensionAttribute]
public static StoredField AddStoredField(Document document, string name, Byte[] value);
    [ExtensionAttribute]
public static StoredField AddStoredField(Document document, string name, Byte[] value, int offset, int length);
    [ExtensionAttribute]
public static StoredField AddStoredField(Document document, string name, BytesRef value);
    [ExtensionAttribute]
public static StoredField AddStoredField(Document document, string name, string value);
    [ExtensionAttribute]
public static StoredField AddStoredField(Document document, string name, int value);
    [ExtensionAttribute]
public static StoredField AddStoredField(Document document, string name, float value);
    [ExtensionAttribute]
public static StoredField AddStoredField(Document document, string name, long value);
    [ExtensionAttribute]
public static StoredField AddStoredField(Document document, string name, double value);
    [ExtensionAttribute]
public static StringField AddStringField(Document document, string name, string value, Store stored);
    [ExtensionAttribute]
public static TextField AddTextField(Document document, string name, TextReader reader);
    [ExtensionAttribute]
public static TextField AddTextField(Document document, string name, string value, Store stored);
    [ExtensionAttribute]
public static TextField AddTextField(Document document, string name, TokenStream stream);
}
[ExtensionAttribute]
public static class Lucene.Net.Documents.Extensions.IndexableFieldExtensions : object {
    [ExtensionAttribute]
public static byte GetByteValueOrDefault(IIndexableField field);
    [ExtensionAttribute]
public static short GetInt16ValueOrDefault(IIndexableField field);
    [ExtensionAttribute]
public static int GetInt32ValueOrDefault(IIndexableField field);
    [ExtensionAttribute]
public static long GetInt64ValueOrDefault(IIndexableField field);
    [ExtensionAttribute]
public static float GetSingleValueOrDefault(IIndexableField field);
    [ExtensionAttribute]
public static double GetDoubleValueOrDefault(IIndexableField field);
}
public class Lucene.Net.Documents.Field : object {
    protected FieldType m_type;
    protected string m_name;
    private object fieldsData;
    private NumericFieldType numericType;
    protected TokenStream m_tokenStream;
    private TokenStream internalTokenStream;
    protected float m_boost;
    protected internal object FieldsData { get; protected internal set; }
    public string Name { get; }
    public float Boost { get; public set; }
    public NumericFieldType NumericType { get; }
    public FieldType FieldType { get; }
    public IIndexableFieldType IndexableFieldType { get; }
    protected internal Field(string name, FieldType type);
    public Field(string name, TextReader reader, FieldType type);
    public Field(string name, TokenStream tokenStream, FieldType type);
    public Field(string name, Byte[] value, FieldType type);
    public Field(string name, Byte[] value, int offset, int length, FieldType type);
    public Field(string name, BytesRef bytes, FieldType type);
    public Field(string name, string value, FieldType type);
    [ObsoleteAttribute("Use StringField, TextField instead.")]
public Field(string name, string value, Store store, Index index);
    [ObsoleteAttribute("Use StringField, TextField instead.")]
public Field(string name, string value, Store store, Index index, TermVector termVector);
    [ObsoleteAttribute("Use TextField instead.")]
public Field(string name, TextReader reader);
    [ObsoleteAttribute("Use TextField instead.")]
public Field(string name, TextReader reader, TermVector termVector);
    [ObsoleteAttribute("Use TextField instead.")]
public Field(string name, TokenStream tokenStream);
    [ObsoleteAttribute("Use TextField instead.")]
public Field(string name, TokenStream tokenStream, TermVector termVector);
    [ObsoleteAttribute("Use StoredField instead.")]
public Field(string name, Byte[] value);
    [ObsoleteAttribute("Use StoredField instead.")]
public Field(string name, Byte[] value, int offset, int length);
    protected internal object get_FieldsData();
    protected internal void set_FieldsData(object value);
    public virtual string GetStringValue();
    public virtual string GetStringValue(IFormatProvider provider);
    public virtual string GetStringValue(string format);
    public virtual string GetStringValue(string format, IFormatProvider provider);
    public virtual TextReader GetReaderValue();
    public virtual TokenStream GetTokenStreamValue();
    public virtual void SetStringValue(string value);
    public virtual void SetReaderValue(TextReader value);
    public virtual void SetBytesValue(BytesRef value);
    public virtual void SetBytesValue(Byte[] value);
    public virtual void SetByteValue(byte value);
    public virtual void SetInt16Value(short value);
    public virtual void SetInt32Value(int value);
    public virtual void SetInt64Value(long value);
    public virtual void SetSingleValue(float value);
    public virtual void SetDoubleValue(double value);
    public virtual void SetTokenStream(TokenStream tokenStream);
    public virtual string get_Name();
    public virtual float get_Boost();
    public virtual void set_Boost(float value);
    [ObsoleteAttribute("In .NET, use of this method will cause boxing/unboxing. Instead, use the NumericType property to check the underlying type and call the appropriate GetXXXValue() method to retrieve the value.")]
public virtual object GetNumericValue();
    public virtual NumericFieldType get_NumericType();
    public virtual Nullable`1<byte> GetByteValue();
    public virtual Nullable`1<short> GetInt16Value();
    public virtual Nullable`1<int> GetInt32Value();
    public virtual Nullable`1<long> GetInt64Value();
    public virtual Nullable`1<float> GetSingleValue();
    public virtual Nullable`1<double> GetDoubleValue();
    public virtual BytesRef GetBinaryValue();
    public virtual string ToString();
    public virtual string ToString(string format);
    public virtual string ToString(IFormatProvider provider);
    public virtual string ToString(string format, IFormatProvider provider);
    public virtual FieldType get_FieldType();
    public virtual IIndexableFieldType get_IndexableFieldType();
    public virtual TokenStream GetTokenStream(Analyzer analyzer);
    [ObsoleteAttribute("This is here only to ease transition from the pre-4.0 APIs.")]
public static FieldType TranslateFieldType(Store store, Index index, TermVector termVector);
}
[ExtensionAttribute]
public static class Lucene.Net.Documents.FieldExtensions : object {
    [ExtensionAttribute]
public static bool IsStored(Store store);
    [ExtensionAttribute]
[ObsoleteAttribute("This is here only to ease transition from the pre-4.0 APIs.")]
public static bool IsIndexed(Index index);
    [ExtensionAttribute]
[ObsoleteAttribute("This is here only to ease transition from the pre-4.0 APIs.")]
public static bool IsAnalyzed(Index index);
    [ExtensionAttribute]
[ObsoleteAttribute("This is here only to ease transition from the pre-4.0 APIs.")]
public static bool OmitNorms(Index index);
    [ExtensionAttribute]
[ObsoleteAttribute("This is here only to ease transition from the pre-4.0 APIs.")]
public static bool IsStored(TermVector tv);
    [ExtensionAttribute]
[ObsoleteAttribute("This is here only to ease transition from the pre-4.0 APIs.")]
public static bool WithPositions(TermVector tv);
    [ExtensionAttribute]
[ObsoleteAttribute("This is here only to ease transition from the pre-4.0 APIs.")]
public static bool WithOffsets(TermVector tv);
    [ObsoleteAttribute("This is here only to ease transition from the pre-4.0 APIs.")]
public static Index ToIndex(bool indexed, bool analyed);
    [ObsoleteAttribute("This is here only to ease transition from the pre-4.0 APIs.")]
public static Index ToIndex(bool indexed, bool analyzed, bool omitNorms);
    [ObsoleteAttribute("This is here only to ease transition from the pre-4.0 APIs.")]
public static TermVector ToTermVector(bool stored, bool withOffsets, bool withPositions);
}
public class Lucene.Net.Documents.FieldType : object {
    private bool indexed;
    private bool stored;
    private bool tokenized;
    private bool storeTermVectors;
    private bool storeTermVectorOffsets;
    private bool storeTermVectorPositions;
    private bool storeTermVectorPayloads;
    private bool omitNorms;
    private IndexOptions indexOptions;
    private NumericType numericType;
    private bool frozen;
    private int numericPrecisionStep;
    private DocValuesType docValueType;
    public bool IsIndexed { get; public set; }
    public bool IsStored { get; public set; }
    public bool IsTokenized { get; public set; }
    public bool StoreTermVectors { get; public set; }
    public bool StoreTermVectorOffsets { get; public set; }
    public bool StoreTermVectorPositions { get; public set; }
    public bool StoreTermVectorPayloads { get; public set; }
    public bool OmitNorms { get; public set; }
    public IndexOptions IndexOptions { get; public set; }
    public NumericType NumericType { get; public set; }
    public int NumericPrecisionStep { get; public set; }
    public DocValuesType DocValueType { get; public set; }
    public FieldType(FieldType ref);
    private void CheckIfFrozen();
    public virtual FieldType Freeze();
    public virtual bool get_IsIndexed();
    public virtual void set_IsIndexed(bool value);
    public virtual bool get_IsStored();
    public virtual void set_IsStored(bool value);
    public virtual bool get_IsTokenized();
    public virtual void set_IsTokenized(bool value);
    public virtual bool get_StoreTermVectors();
    public virtual void set_StoreTermVectors(bool value);
    public virtual bool get_StoreTermVectorOffsets();
    public virtual void set_StoreTermVectorOffsets(bool value);
    public virtual bool get_StoreTermVectorPositions();
    public virtual void set_StoreTermVectorPositions(bool value);
    public virtual bool get_StoreTermVectorPayloads();
    public virtual void set_StoreTermVectorPayloads(bool value);
    public virtual bool get_OmitNorms();
    public virtual void set_OmitNorms(bool value);
    public virtual IndexOptions get_IndexOptions();
    public virtual void set_IndexOptions(IndexOptions value);
    public virtual NumericType get_NumericType();
    public virtual void set_NumericType(NumericType value);
    public virtual int get_NumericPrecisionStep();
    public virtual void set_NumericPrecisionStep(int value);
    public sealed virtual string ToString();
    public virtual DocValuesType get_DocValueType();
    public virtual void set_DocValueType(DocValuesType value);
}
[ObsoleteAttribute("Use NumericDocValuesField instead.")]
public class Lucene.Net.Documents.Int16DocValuesField : NumericDocValuesField {
    public Int16DocValuesField(string name, short value);
    public virtual void SetInt16Value(short value);
}
[ObsoleteAttribute("Deprecated, use NumericDocValuesField instead")]
public class Lucene.Net.Documents.Int32DocValuesField : NumericDocValuesField {
    public Int32DocValuesField(string name, int value);
    public virtual void SetInt32Value(int value);
}
public class Lucene.Net.Documents.Int32Field : Field {
    public static FieldType TYPE_NOT_STORED;
    public static FieldType TYPE_STORED;
    public Int32Field(string name, int value, Store stored);
    public Int32Field(string name, int value, FieldType type);
    private static Int32Field();
}
[ObsoleteAttribute("Use NumericDocValuesField instead")]
public class Lucene.Net.Documents.Int64DocValuesField : NumericDocValuesField {
    public Int64DocValuesField(string name, long value);
}
public class Lucene.Net.Documents.Int64Field : Field {
    public static FieldType TYPE_NOT_STORED;
    public static FieldType TYPE_STORED;
    public Int64Field(string name, long value, Store stored);
    public Int64Field(string name, long value, FieldType type);
    private static Int64Field();
}
public class Lucene.Net.Documents.NumericDocValuesField : Field {
    public static FieldType TYPE;
    public NumericDocValuesField(string name, long value);
    private static NumericDocValuesField();
}
public enum Lucene.Net.Documents.NumericFieldType : Enum {
    public int value__;
    public static NumericFieldType NONE;
    public static NumericFieldType BYTE;
    public static NumericFieldType INT16;
    public static NumericFieldType INT32;
    public static NumericFieldType INT64;
    public static NumericFieldType SINGLE;
    public static NumericFieldType DOUBLE;
}
public enum Lucene.Net.Documents.NumericRepresentation : Enum {
    public int value__;
    public static NumericRepresentation UNIX_TIME_MILLISECONDS;
    public static NumericRepresentation TICKS;
    public static NumericRepresentation TICKS_AS_MILLISECONDS;
}
public enum Lucene.Net.Documents.NumericType : Enum {
    public int value__;
    public static NumericType NONE;
    public static NumericType INT32;
    public static NumericType INT64;
    public static NumericType SINGLE;
    public static NumericType DOUBLE;
}
[ObsoleteAttribute("Use NumericDocValuesField instead.")]
public class Lucene.Net.Documents.PackedInt64DocValuesField : NumericDocValuesField {
    public PackedInt64DocValuesField(string name, long value);
}
public class Lucene.Net.Documents.SingleDocValuesField : NumericDocValuesField {
    public SingleDocValuesField(string name, float value);
    public virtual void SetSingleValue(float value);
    public virtual void SetInt64Value(long value);
}
public class Lucene.Net.Documents.SingleField : Field {
    public static FieldType TYPE_NOT_STORED;
    public static FieldType TYPE_STORED;
    public SingleField(string name, float value, Store stored);
    public SingleField(string name, float value, FieldType type);
    private static SingleField();
}
[ObsoleteAttribute("Use SortedDocValuesField instead.")]
public class Lucene.Net.Documents.SortedBytesDocValuesField : SortedDocValuesField {
    public static FieldType TYPE_FIXED_LEN;
    public static FieldType TYPE_VAR_LEN;
    public SortedBytesDocValuesField(string name, BytesRef bytes);
    public SortedBytesDocValuesField(string name, BytesRef bytes, bool isFixedLength);
    private static SortedBytesDocValuesField();
}
public class Lucene.Net.Documents.SortedDocValuesField : Field {
    public static FieldType TYPE;
    public SortedDocValuesField(string name, BytesRef bytes);
    private static SortedDocValuesField();
}
public class Lucene.Net.Documents.SortedSetDocValuesField : Field {
    public static FieldType TYPE;
    public SortedSetDocValuesField(string name, BytesRef bytes);
    private static SortedSetDocValuesField();
}
public class Lucene.Net.Documents.StoredField : Field {
    public static FieldType TYPE;
    public StoredField(string name, Byte[] value);
    public StoredField(string name, Byte[] value, int offset, int length);
    public StoredField(string name, BytesRef value);
    public StoredField(string name, string value);
    public StoredField(string name, int value);
    public StoredField(string name, float value);
    public StoredField(string name, long value);
    public StoredField(string name, double value);
    private static StoredField();
}
[ObsoleteAttribute("Use BinaryDocValuesField instead.")]
public class Lucene.Net.Documents.StraightBytesDocValuesField : BinaryDocValuesField {
    public static FieldType TYPE_FIXED_LEN;
    public static FieldType TYPE_VAR_LEN;
    public StraightBytesDocValuesField(string name, BytesRef bytes);
    public StraightBytesDocValuesField(string name, BytesRef bytes, bool isFixedLength);
    private static StraightBytesDocValuesField();
}
public class Lucene.Net.Documents.StringField : Field {
    public static FieldType TYPE_NOT_STORED;
    public static FieldType TYPE_STORED;
    public StringField(string name, string value, Store stored);
    private static StringField();
}
public class Lucene.Net.Documents.TextField : Field {
    public static FieldType TYPE_NOT_STORED;
    public static FieldType TYPE_STORED;
    public TextField(string name, TextReader reader);
    public TextField(string name, string value, Store store);
    public TextField(string name, TokenStream stream);
    private static TextField();
}
public abstract class Lucene.Net.Index.AtomicReader : IndexReader {
    private AtomicReaderContext readerContext;
    public IndexReaderContext Context { get; }
    public AtomicReaderContext AtomicContext { get; }
    public Fields Fields { get; }
    public FieldInfos FieldInfos { get; }
    public IBits LiveDocs { get; }
    public sealed virtual IndexReaderContext get_Context();
    public AtomicReaderContext get_AtomicContext();
    [ObsoleteAttribute("(4.0) use FieldInfos and check FieldInfo.HasNorms for the field instead.")]
public bool HasNorms(string field);
    public abstract virtual Fields get_Fields();
    public sealed virtual int DocFreq(Term term);
    public sealed virtual long TotalTermFreq(Term term);
    public sealed virtual long GetSumDocFreq(string field);
    public sealed virtual int GetDocCount(string field);
    public sealed virtual long GetSumTotalTermFreq(string field);
    public Terms GetTerms(string field);
    public DocsEnum GetTermDocsEnum(Term term);
    public DocsAndPositionsEnum GetTermPositionsEnum(Term term);
    public abstract virtual NumericDocValues GetNumericDocValues(string field);
    public abstract virtual BinaryDocValues GetBinaryDocValues(string field);
    public abstract virtual SortedDocValues GetSortedDocValues(string field);
    public abstract virtual SortedSetDocValues GetSortedSetDocValues(string field);
    public abstract virtual IBits GetDocsWithField(string field);
    public abstract virtual NumericDocValues GetNormValues(string field);
    public abstract virtual FieldInfos get_FieldInfos();
    public abstract virtual IBits get_LiveDocs();
    public abstract virtual void CheckIntegrity();
}
public class Lucene.Net.Index.AtomicReaderContext : IndexReaderContext {
    [CompilerGeneratedAttribute]
private int <Ord>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DocBase>k__BackingField;
    private AtomicReader reader;
    private IList`1<AtomicReaderContext> leaves;
    public int Ord { get; private set; }
    public int DocBase { get; private set; }
    public IList`1<AtomicReaderContext> Leaves { get; }
    public IList`1<IndexReaderContext> Children { get; }
    public IndexReader Reader { get; }
    public AtomicReader AtomicReader { get; }
    internal AtomicReaderContext(CompositeReaderContext parent, AtomicReader reader, int ord, int docBase, int leafOrd, int leafDocBase);
    internal AtomicReaderContext(AtomicReader atomicReader);
    [CompilerGeneratedAttribute]
public int get_Ord();
    [CompilerGeneratedAttribute]
private void set_Ord(int value);
    [CompilerGeneratedAttribute]
public int get_DocBase();
    [CompilerGeneratedAttribute]
private void set_DocBase(int value);
    public virtual IList`1<AtomicReaderContext> get_Leaves();
    public virtual IList`1<IndexReaderContext> get_Children();
    public virtual IndexReader get_Reader();
    public AtomicReader get_AtomicReader();
}
internal class Lucene.Net.Index.AutomatonTermsEnum : FilteredTermsEnum {
    private ByteRunAutomaton runAutomaton;
    private BytesRef commonSuffixRef;
    private Nullable`1<bool> finite;
    private Transition[][] allTransitions;
    private Int64[] visited;
    private long curGen;
    private BytesRef seekBytesRef;
    private bool linear;
    private BytesRef linearUpperBound;
    private IComparer`1<BytesRef> termComp;
    private Int32sRef savedStates;
    public AutomatonTermsEnum(TermsEnum tenum, CompiledAutomaton compiled);
    protected virtual AcceptStatus Accept(BytesRef term);
    protected virtual BytesRef NextSeekTerm(BytesRef term);
    private void SetLinear(int position);
    private bool NextString();
    private bool NextString(int state, int position);
    private int Backtrack(int position);
}
public abstract class Lucene.Net.Index.BaseCompositeReader`1 : CompositeReader {
    private R[] subReaders;
    private Int32[] starts;
    private int maxDoc;
    private int numDocs;
    private IList`1<IndexReader> subReadersList;
    public int NumDocs { get; }
    public int MaxDoc { get; }
    protected BaseCompositeReader`1(R[] subReaders);
    public sealed virtual Fields GetTermVectors(int docID);
    public sealed virtual int get_NumDocs();
    public sealed virtual int get_MaxDoc();
    public sealed virtual void Document(int docID, StoredFieldVisitor visitor);
    public sealed virtual int DocFreq(Term term);
    public sealed virtual long TotalTermFreq(Term term);
    public sealed virtual long GetSumDocFreq(string field);
    public sealed virtual int GetDocCount(string field);
    public sealed virtual long GetSumTotalTermFreq(string field);
    protected internal int ReaderIndex(int docID);
    protected internal int ReaderBase(int readerIndex);
    protected internal sealed virtual IList`1<IndexReader> GetSequentialSubReaders();
}
public abstract class Lucene.Net.Index.BinaryDocValues : object {
    public abstract virtual void Get(int docID, BytesRef result);
}
internal class Lucene.Net.Index.BinaryDocValuesFieldUpdates : DocValuesFieldUpdates {
    private FixedBitSet docsWithField;
    private PagedMutable docs;
    private PagedGrowableWriter offsets;
    private PagedGrowableWriter lengths;
    private BytesRef values;
    private int size;
    public BinaryDocValuesFieldUpdates(string field, int maxDoc);
    public virtual void AddFromIterator(int doc, DocValuesFieldUpdatesIterator iterator);
    public virtual void AddFromUpdate(int doc, DocValuesUpdate update);
    private void Add(int doc, BytesRef value);
    public virtual DocValuesFieldUpdatesIterator GetIterator();
    public virtual void Merge(DocValuesFieldUpdates other);
    public virtual bool Any();
}
internal class Lucene.Net.Index.BinaryDocValuesUpdate : DocValuesUpdate {
    private static long RAW_VALUE_SIZE_IN_BYTES;
    internal static BytesRef MISSING;
    internal BytesRef value;
    internal BinaryDocValuesUpdate(Term term, string field, BytesRef value);
    private static BinaryDocValuesUpdate();
    internal virtual long GetValueSizeInBytes();
    public virtual string ToString();
}
internal class Lucene.Net.Index.BinaryDocValuesWriter : DocValuesWriter {
    private static int MAX_LENGTH;
    private static int BLOCK_BITS;
    private PagedBytes bytes;
    private DataOutput bytesOut;
    private Counter iwBytesUsed;
    private AppendingDeltaPackedInt64Buffer lengths;
    private FixedBitSet docsWithField;
    private FieldInfo fieldInfo;
    private int addedValues;
    private long bytesUsed;
    public BinaryDocValuesWriter(FieldInfo fieldInfo, Counter iwBytesUsed);
    private static BinaryDocValuesWriter();
    public virtual void AddValue(int docID, BytesRef value);
    private long DocsWithFieldBytesUsed();
    private void UpdateBytesUsed();
    public virtual void Finish(int maxDoc);
    public virtual void Flush(SegmentWriteState state, DocValuesConsumer dvConsumer);
    public virtual void Abort();
    [IteratorStateMachineAttribute("Lucene.Net.Index.BinaryDocValuesWriter/<GetBytesIterator>d__17")]
private IEnumerable`1<BytesRef> GetBytesIterator(int maxDocParam);
}
internal class Lucene.Net.Index.BitsSlice : object {
    private IBits parent;
    private int start;
    private int length;
    public int Length { get; }
    public BitsSlice(IBits parent, ReaderSlice slice);
    public sealed virtual bool Get(int doc);
    public sealed virtual int get_Length();
}
public class Lucene.Net.Index.BufferedUpdates : object {
    internal static int BYTES_PER_DEL_TERM;
    internal static int BYTES_PER_DEL_DOCID;
    internal static int BYTES_PER_DEL_QUERY;
    internal static int BYTES_PER_NUMERIC_FIELD_ENTRY;
    internal static int BYTES_PER_NUMERIC_UPDATE_ENTRY;
    internal static int BYTES_PER_BINARY_FIELD_ENTRY;
    internal static int BYTES_PER_BINARY_UPDATE_ENTRY;
    internal AtomicInt32 numTermDeletes;
    internal AtomicInt32 numNumericUpdates;
    internal AtomicInt32 numBinaryUpdates;
    internal IDictionary`2<Term, int> terms;
    internal IDictionary`2<Query, int> queries;
    internal IList`1<int> docIDs;
    internal IDictionary`2<string, LinkedDictionary`2<Term, NumericDocValuesUpdate>> numericUpdates;
    internal IDictionary`2<string, LinkedDictionary`2<Term, BinaryDocValuesUpdate>> binaryUpdates;
    internal static int MAX_INT32;
    internal AtomicInt64 bytesUsed;
    private static bool VERBOSE_DELETES;
    internal long gen;
    private static BufferedUpdates();
    public virtual string ToString();
    internal virtual void AddQuery(Query query, int docIDUpto);
    internal virtual void AddDocID(int docID);
    internal virtual void AddTerm(Term term, int docIDUpto);
    internal virtual void AddNumericUpdate(NumericDocValuesUpdate update, int docIDUpto);
    internal virtual void AddBinaryUpdate(BinaryDocValuesUpdate update, int docIDUpto);
    internal virtual void Clear();
    internal virtual bool Any();
}
internal class Lucene.Net.Index.BufferedUpdatesStream : object {
    private List`1<FrozenBufferedUpdates> updates;
    private long nextGen;
    private Term lastDeleteTerm;
    private InfoStream infoStream;
    private AtomicInt64 bytesUsed;
    private AtomicInt32 numTerms;
    private static IComparer`1<SegmentCommitInfo> sortSegInfoByDelGen;
    public int NumTerms { get; }
    public long BytesUsed { get; }
    public BufferedUpdatesStream(InfoStream infoStream);
    private static BufferedUpdatesStream();
    public virtual long Push(FrozenBufferedUpdates packet);
    public virtual void Clear();
    public virtual bool Any();
    public virtual int get_NumTerms();
    public virtual long get_BytesUsed();
    public virtual ApplyDeletesResult ApplyDeletesAndUpdates(ReaderPool readerPool, IList`1<SegmentCommitInfo> infos);
    internal virtual long GetNextGen();
    public virtual void Prune(SegmentInfos segmentInfos);
    private void Prune(int count);
    private long ApplyTermDeletes(IEnumerable`1<Term> termsIter, ReadersAndUpdates rld, SegmentReader reader);
    private void ApplyDocValuesUpdates(IEnumerable`1<T1> updates, ReadersAndUpdates rld, SegmentReader reader, Container dvUpdatesContainer);
    private static long ApplyQueryDeletes(IEnumerable`1<QueryAndLimit> queriesIter, ReadersAndUpdates rld, SegmentReader reader);
    private bool CheckDeleteTerm(Term term);
    private bool CheckDeleteStats();
}
public class Lucene.Net.Index.ByteSliceReader : DataInput {
    private ByteBlockPool pool;
    private int bufferUpto;
    private Byte[] buffer;
    private int upto;
    private int limit;
    private int level;
    [CompilerGeneratedAttribute]
private int <BufferOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndIndex>k__BackingField;
    public int BufferOffset { get; internal set; }
    public int EndIndex { get; internal set; }
    [CompilerGeneratedAttribute]
public int get_BufferOffset();
    [CompilerGeneratedAttribute]
internal void set_BufferOffset(int value);
    [CompilerGeneratedAttribute]
public int get_EndIndex();
    [CompilerGeneratedAttribute]
internal void set_EndIndex(int value);
    public void Init(ByteBlockPool pool, int startIndex, int endIndex);
    public bool Eof();
    public virtual byte ReadByte();
    public long WriteTo(DataOutput out);
    public void NextSlice();
    public virtual void ReadBytes(Byte[] b, int offset, int len);
}
internal class Lucene.Net.Index.ByteSliceWriter : DataOutput {
    private Byte[] slice;
    private int upto;
    private ByteBlockPool pool;
    internal int offset0;
    public int Address { get; }
    public ByteSliceWriter(ByteBlockPool pool);
    public void Init(int address);
    public virtual void WriteByte(byte b);
    public virtual void WriteBytes(Byte[] b, int offset, int len);
    public int get_Address();
}
public class Lucene.Net.Index.CheckAbort : object {
    private double workCount;
    private OneMerge merge;
    private Directory dir;
    public static CheckAbort NONE;
    public CheckAbort(OneMerge merge, Directory dir);
    private static CheckAbort();
    public virtual void Work(double units);
}
public class Lucene.Net.Index.CheckIndex : object {
    private TextWriter infoStream;
    private Directory dir;
    private bool crossCheckTermVectors;
    private bool verbose;
    public bool CrossCheckTermVectors { get; public set; }
    public TextWriter InfoStream { get; public set; }
    public bool InfoStreamIsVerbose { get; public set; }
    public CheckIndex(Directory dir);
    public virtual bool get_CrossCheckTermVectors();
    public virtual void set_CrossCheckTermVectors(bool value);
    public virtual TextWriter get_InfoStream();
    public virtual void set_InfoStream(TextWriter value);
    public virtual bool get_InfoStreamIsVerbose();
    public virtual void set_InfoStreamIsVerbose(bool value);
    public virtual void FlushInfoStream();
    private static void Msg(TextWriter out, string msg);
    public virtual Status DoCheckIndex();
    public virtual Status DoCheckIndex(IList`1<string> onlySegments);
    public static FieldNormStatus TestFieldNorms(AtomicReader reader, TextWriter infoStream);
    private static TermIndexStatus CheckFields(Fields fields, IBits liveDocs, int maxDoc, FieldInfos fieldInfos, bool doPrint, bool isVectors, TextWriter infoStream, bool verbose);
    public static TermIndexStatus TestPostings(AtomicReader reader, TextWriter infoStream);
    public static TermIndexStatus TestPostings(AtomicReader reader, TextWriter infoStream, bool verbose);
    public static StoredFieldStatus TestStoredFields(AtomicReader reader, TextWriter infoStream);
    public static DocValuesStatus TestDocValues(AtomicReader reader, TextWriter infoStream);
    private static void CheckBinaryDocValues(string fieldName, AtomicReader reader, BinaryDocValues dv, IBits docsWithField);
    private static void CheckSortedDocValues(string fieldName, AtomicReader reader, SortedDocValues dv, IBits docsWithField);
    private static void CheckSortedSetDocValues(string fieldName, AtomicReader reader, SortedSetDocValues dv, IBits docsWithField);
    private static void CheckNumericDocValues(string fieldName, AtomicReader reader, NumericDocValues ndv, IBits docsWithField);
    private static void CheckDocValues(FieldInfo fi, AtomicReader reader, DocValuesStatus status);
    private static void CheckNorms(FieldInfo fi, AtomicReader reader);
    public static TermVectorStatus TestTermVectors(AtomicReader reader, TextWriter infoStream);
    public static TermVectorStatus TestTermVectors(AtomicReader reader, TextWriter infoStream, bool verbose, bool crossCheckTermVectors);
    public virtual void FixIndex(Status result);
    [STAThreadAttribute]
public static void Main(String[] args);
}
internal class Lucene.Net.Index.CoalescedUpdates : object {
    internal IDictionary`2<Query, int> queries;
    internal IList`1<IEnumerable`1<Term>> iterables;
    internal IList`1<NumericDocValuesUpdate> numericDVUpdates;
    internal IList`1<BinaryDocValuesUpdate> binaryDVUpdates;
    public virtual string ToString();
    internal virtual void Update(FrozenBufferedUpdates in);
    public virtual IEnumerable`1<Term> TermsIterable();
    public virtual IEnumerable`1<QueryAndLimit> QueriesIterable();
}
public abstract class Lucene.Net.Index.CompositeReader : IndexReader {
    private CompositeReaderContext modreq(System.Runtime.CompilerServices.IsVolatile) readerContext;
    public IndexReaderContext Context { get; }
    public virtual string ToString();
    protected internal abstract virtual IList`1<IndexReader> GetSequentialSubReaders();
    public sealed virtual IndexReaderContext get_Context();
}
public class Lucene.Net.Index.CompositeReaderContext : IndexReaderContext {
    private IList`1<IndexReaderContext> children;
    private IList`1<AtomicReaderContext> leaves;
    private CompositeReader reader;
    public IList`1<AtomicReaderContext> Leaves { get; }
    public IList`1<IndexReaderContext> Children { get; }
    public IndexReader Reader { get; }
    internal CompositeReaderContext(CompositeReaderContext parent, CompositeReader reader, int ordInParent, int docbaseInParent, IList`1<IndexReaderContext> children);
    internal CompositeReaderContext(CompositeReader reader, IList`1<IndexReaderContext> children, IList`1<AtomicReaderContext> leaves);
    private CompositeReaderContext(CompositeReaderContext parent, CompositeReader reader, int ordInParent, int docbaseInParent, IList`1<IndexReaderContext> children, IList`1<AtomicReaderContext> leaves);
    internal static CompositeReaderContext Create(CompositeReader reader);
    public virtual IList`1<AtomicReaderContext> get_Leaves();
    public virtual IList`1<IndexReaderContext> get_Children();
    public virtual IndexReader get_Reader();
}
public class Lucene.Net.Index.ConcurrentMergeScheduler : MergeScheduler {
    private int mergeThreadPriority;
    protected internal IList`1<MergeThread> m_mergeThreads;
    public static int DEFAULT_MAX_THREAD_COUNT;
    public static int DEFAULT_MAX_MERGE_COUNT;
    private int maxThreadCount;
    private int maxMergeCount;
    protected internal Directory m_dir;
    protected internal IndexWriter m_writer;
    protected internal int m_mergeThreadCount;
    protected internal static IComparer`1<MergeThread> compareByMergeDocCount;
    private bool suppressExceptions;
    public int MaxThreadCount { get; }
    public int MaxMergeCount { get; }
    public int MergeThreadPriority { get; }
    protected bool IsVerbose { get; }
    protected int MergeThreadCount { get; }
    private static ConcurrentMergeScheduler();
    public virtual void SetMaxMergesAndThreads(int maxMergeCount, int maxThreadCount);
    public virtual int get_MaxThreadCount();
    public virtual int get_MaxMergeCount();
    public virtual int get_MergeThreadPriority();
    public virtual void SetMergeThreadPriority(int priority);
    protected virtual void UpdateMergeThreads();
    protected virtual bool get_IsVerbose();
    protected internal virtual void Message(string message);
    private void InitMergeThreadPriority();
    protected virtual void Dispose(bool disposing);
    public virtual void Sync();
    protected virtual int get_MergeThreadCount();
    public virtual void Merge(IndexWriter writer, MergeTrigger trigger, bool newMergesFound);
    protected virtual void DoMerge(OneMerge merge);
    protected virtual MergeThread GetMergeThread(IndexWriter writer, OneMerge merge);
    protected virtual void HandleMergeException(Exception exc);
    public virtual void SetSuppressExceptions();
    public virtual void ClearSuppressExceptions();
    public virtual string ToString();
    public virtual object Clone();
}
public class Lucene.Net.Index.CorruptIndexException : IOException {
    public CorruptIndexException(string message);
    public CorruptIndexException(string message, Exception ex);
    protected CorruptIndexException(SerializationInfo info, StreamingContext context);
}
public abstract class Lucene.Net.Index.DirectoryReader : BaseCompositeReader`1<AtomicReader> {
    public static int DEFAULT_TERMS_INDEX_DIVISOR;
    protected Directory m_directory;
    public Directory Directory { get; }
    public long Version { get; }
    public IndexCommit IndexCommit { get; }
    protected DirectoryReader(Directory directory, AtomicReader[] segmentReaders);
    private static DirectoryReader();
    public static DirectoryReader Open(Directory directory);
    public static DirectoryReader Open(Directory directory, int termInfosIndexDivisor);
    public static DirectoryReader Open(IndexWriter writer, bool applyAllDeletes);
    public static DirectoryReader Open(IndexCommit commit);
    public static DirectoryReader Open(IndexCommit commit, int termInfosIndexDivisor);
    public static DirectoryReader OpenIfChanged(DirectoryReader oldReader);
    public static DirectoryReader OpenIfChanged(DirectoryReader oldReader, IndexCommit commit);
    public static DirectoryReader OpenIfChanged(DirectoryReader oldReader, IndexWriter writer, bool applyAllDeletes);
    public static IList`1<IndexCommit> ListCommits(Directory dir);
    public static bool IndexExists(Directory directory);
    public Directory get_Directory();
    protected internal abstract virtual DirectoryReader DoOpenIfChanged();
    protected internal abstract virtual DirectoryReader DoOpenIfChanged(IndexCommit commit);
    protected internal abstract virtual DirectoryReader DoOpenIfChanged(IndexWriter writer, bool applyAllDeletes);
    public abstract virtual long get_Version();
    public abstract virtual bool IsCurrent();
    public abstract virtual IndexCommit get_IndexCommit();
}
internal abstract class Lucene.Net.Index.DocConsumer : object {
    public abstract virtual void ProcessDocument(Builder fieldInfos);
    internal abstract virtual void FinishDocument();
    public abstract virtual void Flush(SegmentWriteState state);
    public abstract virtual void Abort();
}
internal abstract class Lucene.Net.Index.DocFieldConsumer : object {
    internal abstract virtual void Flush(IDictionary`2<string, DocFieldConsumerPerField> fieldsToFlush, SegmentWriteState state);
    internal abstract virtual void Abort();
    public abstract virtual void StartDocument();
    public abstract virtual DocFieldConsumerPerField AddField(FieldInfo fi);
    public abstract virtual void FinishDocument();
}
internal abstract class Lucene.Net.Index.DocFieldConsumerPerField : object {
    internal FieldInfo FieldInfo { get; }
    public abstract virtual void ProcessFields(IIndexableField[] fields, int count);
    internal abstract virtual void Abort();
    internal abstract virtual FieldInfo get_FieldInfo();
}
internal class Lucene.Net.Index.DocFieldProcessor : DocConsumer {
    internal DocFieldConsumer consumer;
    internal StoredFieldsConsumer storedConsumer;
    internal Codec codec;
    internal DocFieldProcessorPerField[] fields;
    internal int fieldCount;
    internal DocFieldProcessorPerField[] fieldHash;
    internal int hashMask;
    internal int totalFieldCount;
    internal int fieldGen;
    internal DocState docState;
    internal Counter bytesUsed;
    private static IComparer`1<DocFieldProcessorPerField> fieldsComp;
    public DocFieldProcessor(DocumentsWriterPerThread docWriter, DocFieldConsumer consumer, StoredFieldsConsumer storedConsumer);
    private static DocFieldProcessor();
    public virtual void Flush(SegmentWriteState state);
    public virtual void Abort();
    public ICollection`1<DocFieldConsumerPerField> Fields();
    private void Rehash();
    public virtual void ProcessDocument(Builder fieldInfos);
    internal virtual void FinishDocument();
}
internal class Lucene.Net.Index.DocFieldProcessorPerField : object {
    internal DocFieldConsumerPerField consumer;
    internal FieldInfo fieldInfo;
    internal DocFieldProcessorPerField next;
    internal int lastGen;
    internal int fieldCount;
    internal IIndexableField[] fields;
    public DocFieldProcessorPerField(DocFieldProcessor docFieldProcessor, FieldInfo fieldInfo);
    public void AddField(IIndexableField field);
    public void Abort();
}
internal class Lucene.Net.Index.DocInverter : DocFieldConsumer {
    internal InvertedDocConsumer consumer;
    internal InvertedDocEndConsumer endConsumer;
    internal DocState docState;
    public DocInverter(DocState docState, InvertedDocConsumer consumer, InvertedDocEndConsumer endConsumer);
    internal virtual void Flush(IDictionary`2<string, DocFieldConsumerPerField> fieldsToFlush, SegmentWriteState state);
    public virtual void StartDocument();
    public virtual void FinishDocument();
    internal virtual void Abort();
    public virtual DocFieldConsumerPerField AddField(FieldInfo fi);
}
internal class Lucene.Net.Index.DocInverterPerField : DocFieldConsumerPerField {
    internal FieldInfo fieldInfo;
    internal InvertedDocConsumerPerField consumer;
    internal InvertedDocEndConsumerPerField endConsumer;
    internal DocState docState;
    internal FieldInvertState fieldState;
    internal FieldInfo FieldInfo { get; }
    public DocInverterPerField(DocInverter parent, FieldInfo fieldInfo);
    internal virtual void Abort();
    public virtual void ProcessFields(IIndexableField[] fields, int count);
    internal virtual FieldInfo get_FieldInfo();
}
public abstract class Lucene.Net.Index.DocsAndPositionsEnum : DocsEnum {
    public int StartOffset { get; }
    public int EndOffset { get; }
    public abstract virtual int NextPosition();
    public abstract virtual int get_StartOffset();
    public abstract virtual int get_EndOffset();
    public abstract virtual BytesRef GetPayload();
}
[FlagsAttribute]
public enum Lucene.Net.Index.DocsAndPositionsFlags : Enum {
    public int value__;
    public static DocsAndPositionsFlags NONE;
    public static DocsAndPositionsFlags OFFSETS;
    public static DocsAndPositionsFlags PAYLOADS;
}
public abstract class Lucene.Net.Index.DocsEnum : DocIdSetIterator {
    private AttributeSource atts;
    public int Freq { get; }
    public AttributeSource Attributes { get; }
    public abstract virtual int get_Freq();
    public virtual AttributeSource get_Attributes();
}
[FlagsAttribute]
public enum Lucene.Net.Index.DocsFlags : Enum {
    public int value__;
    public static DocsFlags NONE;
    public static DocsFlags FREQS;
}
public class Lucene.Net.Index.DocTermOrds : object {
    private static int TNUM_OFFSET;
    public static int DEFAULT_INDEX_INTERVAL_BITS;
    private int indexIntervalBits;
    private int indexIntervalMask;
    private int indexInterval;
    protected int m_maxTermDocFreq;
    protected string m_field;
    protected int m_numTermsInField;
    protected long m_termInstances;
    private long memsz;
    protected int m_total_time;
    protected int m_phase1_time;
    protected Int32[] m_index;
    [CLSCompliantAttribute("False")]
protected SByte[][] m_tnums;
    protected long m_sizeOfIndexedStrings;
    protected BytesRef[] m_indexedTermsArray;
    protected BytesRef m_prefix;
    protected int m_ordBase;
    protected DocsEnum m_docsEnum;
    public int NumTerms { get; }
    public bool IsEmpty { get; }
    public DocTermOrds(AtomicReader reader, IBits liveDocs, string field);
    public DocTermOrds(AtomicReader reader, IBits liveDocs, string field, BytesRef termPrefix);
    public DocTermOrds(AtomicReader reader, IBits liveDocs, string field, BytesRef termPrefix, int maxTermDocFreq);
    public DocTermOrds(AtomicReader reader, IBits liveDocs, string field, BytesRef termPrefix, int maxTermDocFreq, int indexIntervalBits);
    protected DocTermOrds(string field, int maxTermDocFreq, int indexIntervalBits);
    public virtual long RamUsedInBytes();
    public virtual TermsEnum GetOrdTermsEnum(AtomicReader reader);
    public virtual int get_NumTerms();
    public virtual bool get_IsEmpty();
    protected virtual void VisitTerm(TermsEnum te, int termNum);
    protected virtual void SetActualDocFreq(int termNum, int df);
    protected virtual void Uninvert(AtomicReader reader, IBits liveDocs, BytesRef termPrefix);
    private static int VInt32Size(int x);
    private static int WriteInt32(int x, SByte[] arr, int pos);
    public virtual BytesRef LookupTerm(TermsEnum termsEnum, int ord);
    public virtual SortedSetDocValues GetIterator(AtomicReader reader);
}
internal class Lucene.Net.Index.DocumentsWriter : object {
    private Directory directory;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) closed;
    private InfoStream infoStream;
    private LiveIndexWriterConfig config;
    private AtomicInt32 numDocsInRAM;
    internal DocumentsWriterDeleteQueue modreq(System.Runtime.CompilerServices.IsVolatile) deleteQueue;
    private DocumentsWriterFlushQueue ticketQueue;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) pendingChangesInCurrentFullFlush;
    internal DocumentsWriterPerThreadPool perThreadPool;
    internal FlushPolicy flushPolicy;
    internal DocumentsWriterFlushControl flushControl;
    private IndexWriter writer;
    private ConcurrentQueue`1<IEvent> events;
    private DocumentsWriterDeleteQueue modreq(System.Runtime.CompilerServices.IsVolatile) currentFullFlushDelQueue;
    internal DocumentsWriterDeleteQueue CurrentDeleteSession { get; }
    internal int NumDocs { get; }
    public int BufferedDeleteTermsSize { get; }
    public int NumBufferedDeleteTerms { get; }
    public LiveIndexWriterConfig IndexWriterConfig { get; }
    public ConcurrentQueue`1<IEvent> EventQueue { get; }
    internal DocumentsWriter(IndexWriter writer, LiveIndexWriterConfig config, Directory directory);
    internal bool DeleteQueries(Query[] queries);
    internal bool DeleteTerms(Term[] terms);
    internal bool UpdateNumericDocValue(Term term, string field, Nullable`1<long> value);
    internal bool UpdateBinaryDocValue(Term term, string field, BytesRef value);
    internal DocumentsWriterDeleteQueue get_CurrentDeleteSession();
    private bool ApplyAllDeletes(DocumentsWriterDeleteQueue deleteQueue);
    internal int PurgeBuffer(IndexWriter writer, bool forced);
    internal int get_NumDocs();
    private void EnsureOpen();
    internal void Abort(IndexWriter writer);
    internal void LockAndAbortAll(IndexWriter indexWriter);
    private void AbortThreadState(ThreadState perThread, ISet`1<string> newFiles);
    internal void UnlockAllAfterAbortAll(IndexWriter indexWriter);
    internal bool AnyChanges();
    public int get_BufferedDeleteTermsSize();
    public int get_NumBufferedDeleteTerms();
    public bool AnyDeletions();
    public sealed virtual void Dispose();
    private bool PreUpdate();
    private bool PostUpdate(DocumentsWriterPerThread flushingDWPT, bool hasEvents);
    private void EnsureInitialized(ThreadState state);
    internal bool UpdateDocuments(IEnumerable`1<IEnumerable`1<IIndexableField>> docs, Analyzer analyzer, Term delTerm);
    internal bool UpdateDocument(IEnumerable`1<IIndexableField> doc, Analyzer analyzer, Term delTerm);
    private bool DoFlush(DocumentsWriterPerThread flushingDWPT);
    internal void SubtractFlushedNumDocs(int numFlushed);
    private bool SetFlushingDeleteQueue(DocumentsWriterDeleteQueue session);
    internal bool FlushAllThreads(IndexWriter indexWriter);
    internal void FinishFullFlush(bool success);
    public LiveIndexWriterConfig get_IndexWriterConfig();
    private void PutEvent(IEvent event);
    public ConcurrentQueue`1<IEvent> get_EventQueue();
}
internal class Lucene.Net.Index.DocumentsWriterDeleteQueue : object {
    private Node tail;
    private DeleteSlice globalSlice;
    private BufferedUpdates globalBufferedUpdates;
    private ReentrantLock globalBufferLock;
    internal long generation;
    public int NumGlobalTermDeletes { get; }
    public int BufferedUpdatesTermsSize { get; }
    public long BytesUsed { get; }
    internal DocumentsWriterDeleteQueue(long generation);
    internal DocumentsWriterDeleteQueue(BufferedUpdates globalBufferedUpdates, long generation);
    internal void AddDelete(Query[] queries);
    internal void AddDelete(Term[] terms);
    internal void AddNumericUpdate(NumericDocValuesUpdate update);
    internal void AddBinaryUpdate(BinaryDocValuesUpdate update);
    internal void Add(Term term, DeleteSlice slice);
    internal void Add(Node item);
    internal bool AnyChanges();
    internal void TryApplyGlobalSlice();
    internal FrozenBufferedUpdates FreezeGlobalBuffer(DeleteSlice callerSlice);
    internal DeleteSlice NewSlice();
    internal bool UpdateSlice(DeleteSlice slice);
    public int get_NumGlobalTermDeletes();
    internal void Clear();
    private bool ForceApplyGlobalSlice();
    public int get_BufferedUpdatesTermsSize();
    public long get_BytesUsed();
    public virtual string ToString();
}
internal class Lucene.Net.Index.DocumentsWriterFlushControl : object {
    private long hardMaxBytesPerDWPT;
    private long activeBytes;
    private long flushBytes;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) numPending;
    private int numDocsSinceStalled;
    internal AtomicBoolean flushDeletes;
    private bool fullFlush;
    private Queue`1<DocumentsWriterPerThread> flushQueue;
    private LinkedList`1<BlockedFlush> blockedFlushes;
    private IDictionary`2<DocumentsWriterPerThread, long> flushingWriters;
    internal double maxConfiguredRamBuffer;
    internal long peakActiveBytes;
    internal long peakFlushBytes;
    internal long peakNetBytes;
    internal long peakDelta;
    internal DocumentsWriterStallControl stallControl;
    private DocumentsWriterPerThreadPool perThreadPool;
    private FlushPolicy flushPolicy;
    private bool closed;
    private DocumentsWriter documentsWriter;
    private LiveIndexWriterConfig config;
    private BufferedUpdatesStream bufferedUpdatesStream;
    private InfoStream infoStream;
    private IList`1<DocumentsWriterPerThread> fullFlushBuffer;
    public long ActiveBytes { get; }
    public long FlushBytes { get; }
    public long NetBytes { get; }
    private long StallLimitBytes { get; }
    public int NumGlobalTermDeletes { get; }
    public long DeleteBytesUsed { get; }
    internal int NumFlushingDWPT { get; }
    internal int NumActiveDWPT { get; }
    internal bool IsFullFlush { get; }
    internal int NumQueuedFlushes { get; }
    internal int NumBlockedFlushes { get; }
    public InfoStream InfoStream { get; }
    internal DocumentsWriterFlushControl(DocumentsWriter documentsWriter, LiveIndexWriterConfig config, BufferedUpdatesStream bufferedUpdatesStream);
    public long get_ActiveBytes();
    public long get_FlushBytes();
    public long get_NetBytes();
    private long get_StallLimitBytes();
    private bool AssertMemory();
    private void CommitPerThreadBytes(ThreadState perThread);
    private bool UpdatePeaks(long delta);
    internal DocumentsWriterPerThread DoAfterDocument(ThreadState perThread, bool isUpdate);
    private bool AssertNumDocsSinceStalled(bool stalled);
    internal void DoAfterFlush(DocumentsWriterPerThread dwpt);
    private bool UpdateStallState();
    public void WaitForFlush();
    public void SetFlushPending(ThreadState perThread);
    internal void DoOnAbort(ThreadState state);
    internal DocumentsWriterPerThread TryCheckoutForFlush(ThreadState perThread);
    private void CheckoutAndBlock(ThreadState perThread);
    private DocumentsWriterPerThread InternalTryCheckOutForFlush(ThreadState perThread);
    public virtual string ToString();
    internal DocumentsWriterPerThread NextPendingFlush();
    internal void SetClosed();
    public IEnumerator`1<ThreadState> AllActiveThreadStates();
    private IEnumerator`1<ThreadState> GetPerThreadsIterator(int upto);
    internal void DoOnDelete();
    public int get_NumGlobalTermDeletes();
    public long get_DeleteBytesUsed();
    internal int get_NumFlushingDWPT();
    public bool GetAndResetApplyAllDeletes();
    public void SetApplyAllDeletes();
    internal int get_NumActiveDWPT();
    internal ThreadState ObtainAndLock();
    internal void MarkForFullFlush();
    private bool AssertActiveDeleteQueue(DocumentsWriterDeleteQueue queue);
    internal void AddFlushableState(ThreadState perThread);
    private void PruneBlockedQueue(DocumentsWriterDeleteQueue flushingQueue);
    internal void FinishFullFlush();
    internal bool AssertBlockedFlushes(DocumentsWriterDeleteQueue flushingQueue);
    internal void AbortFullFlushes(ISet`1<string> newFiles);
    internal void AbortPendingFlushes(ISet`1<string> newFiles);
    internal bool get_IsFullFlush();
    internal int get_NumQueuedFlushes();
    internal int get_NumBlockedFlushes();
    internal void WaitIfStalled();
    internal bool AnyStalledThreads();
    public InfoStream get_InfoStream();
}
internal class Lucene.Net.Index.DocumentsWriterFlushQueue : object {
    private Queue`1<FlushTicket> queue;
    private AtomicInt32 ticketCount;
    private ReentrantLock purgeLock;
    internal bool HasTickets { get; }
    public int TicketCount { get; }
    internal virtual void AddDeletes(DocumentsWriterDeleteQueue deleteQueue);
    private void IncTickets();
    private void DecTickets();
    internal virtual SegmentFlushTicket AddFlushTicket(DocumentsWriterPerThread dwpt);
    internal virtual void AddSegment(SegmentFlushTicket ticket, FlushedSegment segment);
    internal virtual void MarkTicketFailed(SegmentFlushTicket ticket);
    internal virtual bool get_HasTickets();
    private int InnerPurge(IndexWriter writer);
    internal virtual int ForcePurge(IndexWriter writer);
    internal virtual int TryPurge(IndexWriter writer);
    public virtual int get_TicketCount();
    internal virtual void Clear();
}
internal class Lucene.Net.Index.DocumentsWriterPerThread : object {
    private static IndexingChain defaultIndexingChain;
    private static bool INFO_VERBOSE;
    internal Codec codec;
    internal TrackingDirectoryWrapper directory;
    internal Directory directoryOrig;
    internal DocState docState;
    internal DocConsumer consumer;
    internal Counter bytesUsed;
    internal SegmentWriteState flushState;
    internal BufferedUpdates pendingUpdates;
    private SegmentInfo segmentInfo;
    internal bool aborting;
    internal bool hasAborted;
    private Builder fieldInfos;
    private InfoStream infoStream;
    private int numDocsInRAM;
    internal DocumentsWriterDeleteQueue deleteQueue;
    private DeleteSlice deleteSlice;
    private NumberFormatInfo nf;
    internal Allocator byteBlockAllocator;
    internal Allocator intBlockAllocator;
    private LiveIndexWriterConfig indexWriterConfig;
    private HashSet`1<string> filesToDelete;
    internal static int BYTE_BLOCK_NOT_MASK;
    internal static int MAX_TERM_LENGTH_UTF8;
    public static IndexingChain DefaultIndexingChain { get; }
    public int NumDeleteTerms { get; }
    public int NumDocsInRAM { get; }
    public ISet`1<string> PendingFilesToDelete { get; }
    internal SegmentInfo SegmentInfo { get; }
    public long BytesUsed { get; }
    public DocumentsWriterPerThread(string segmentName, Directory directory, LiveIndexWriterConfig indexWriterConfig, InfoStream infoStream, DocumentsWriterDeleteQueue deleteQueue, Builder fieldInfos);
    private static DocumentsWriterPerThread();
    public static IndexingChain get_DefaultIndexingChain();
    internal virtual void Abort(ISet`1<string> createdFiles);
    internal virtual void SetAborting();
    internal virtual bool CheckAndResetHasAborted();
    internal bool TestPoint(string message);
    public virtual void UpdateDocument(IEnumerable`1<IIndexableField> doc, Analyzer analyzer, Term delTerm);
    public virtual int UpdateDocuments(IEnumerable`1<IEnumerable`1<IIndexableField>> docs, Analyzer analyzer, Term delTerm);
    private void FinishDocument(Term delTerm);
    internal virtual void DeleteDocID(int docIDUpto);
    public virtual int get_NumDeleteTerms();
    public virtual int get_NumDocsInRAM();
    internal virtual FrozenBufferedUpdates PrepareFlush();
    internal virtual FlushedSegment Flush();
    public virtual ISet`1<string> get_PendingFilesToDelete();
    internal virtual void SealFlushedSegment(FlushedSegment flushedSegment);
    internal virtual SegmentInfo get_SegmentInfo();
    public virtual long get_BytesUsed();
    public virtual string ToString();
}
internal class Lucene.Net.Index.DocumentsWriterPerThreadPool : object {
    private ThreadState[] threadStates;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) numThreadStatesActive;
    private ThreadState[] freeList;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) freeCount;
    public int MaxThreadStates { get; }
    public int NumThreadStatesActive { get; }
    internal DocumentsWriterPerThreadPool(int maxNumThreadStates);
    public object Clone();
    public int get_MaxThreadStates();
    public int get_NumThreadStatesActive();
    public ThreadState NewThreadState();
    private bool AssertUnreleasedThreadStatesInactive();
    internal void DeactivateUnreleasedStates();
    internal static DocumentsWriterPerThread Reset(ThreadState threadState, bool closed);
    public ThreadState GetAndLock();
    public void Release(ThreadState state);
    internal ThreadState GetThreadState(int ord);
    internal ThreadState MinContendedThreadState();
    internal int NumDeactivatedThreadStates();
    internal static void DeactivateThreadState(ThreadState threadState);
}
internal class Lucene.Net.Index.DocumentsWriterStallControl : object {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) stalled;
    private int numWaiting;
    private bool wasStalled;
    private IDictionary`2<ThreadJob, bool> waiting;
    internal bool HasBlocked { get; }
    internal bool IsHealthy { get; }
    internal bool WasStalled { get; }
    internal void UpdateStalled(bool stalled);
    internal void WaitIfStalled();
    internal bool AnyStalledThreads();
    private bool IncWaiters();
    private bool DecrWaiters();
    internal bool get_HasBlocked();
    internal bool get_IsHealthy();
    internal bool IsThreadQueued(ThreadJob t);
    internal bool get_WasStalled();
}
public class Lucene.Net.Index.DocValues : object {
    public static BinaryDocValues EMPTY_BINARY;
    public static NumericDocValues EMPTY_NUMERIC;
    public static SortedDocValues EMPTY_SORTED;
    public static SortedSetDocValues EMPTY_SORTED_SET;
    private static DocValues();
    public static SortedSetDocValues Singleton(SortedDocValues dv);
    public static SortedDocValues UnwrapSingleton(SortedSetDocValues dv);
    public static IBits DocsWithValue(SortedDocValues dv, int maxDoc);
    public static IBits DocsWithValue(SortedSetDocValues dv, int maxDoc);
}
internal abstract class Lucene.Net.Index.DocValuesFieldUpdates : object {
    internal string field;
    internal DocValuesFieldUpdatesType type;
    protected DocValuesFieldUpdates(string field, DocValuesFieldUpdatesType type);
    public abstract virtual void AddFromIterator(int doc, DocValuesFieldUpdatesIterator iterator);
    public abstract virtual void AddFromUpdate(int doc, DocValuesUpdate update);
    public abstract virtual DocValuesFieldUpdatesIterator GetIterator();
    public abstract virtual void Merge(DocValuesFieldUpdates other);
    public abstract virtual bool Any();
}
internal abstract class Lucene.Net.Index.DocValuesFieldUpdatesIterator : object {
    public int Doc { get; }
    public abstract virtual int NextDoc();
    public abstract virtual int get_Doc();
    public abstract virtual void Reset();
}
internal abstract class Lucene.Net.Index.DocValuesFieldUpdatesIterator`1 : DocValuesFieldUpdatesIterator {
    public int Doc { get; }
    public T Value { get; }
    public abstract virtual int NextDoc();
    public abstract virtual int get_Doc();
    public abstract virtual T get_Value();
    public abstract virtual void Reset();
}
internal enum Lucene.Net.Index.DocValuesFieldUpdatesType : Enum {
    public int value__;
    public static DocValuesFieldUpdatesType NUMERIC;
    public static DocValuesFieldUpdatesType BINARY;
}
internal class Lucene.Net.Index.DocValuesProcessor : StoredFieldsConsumer {
    private IDictionary`2<string, DocValuesWriter> writers;
    private Counter bytesUsed;
    public DocValuesProcessor(Counter bytesUsed);
    public virtual void StartDocument();
    internal virtual void FinishDocument();
    public virtual void AddField(int docID, IIndexableField field, FieldInfo fieldInfo);
    public virtual void Flush(SegmentWriteState state);
    internal void AddBinaryField(FieldInfo fieldInfo, int docID, BytesRef value);
    internal void AddSortedField(FieldInfo fieldInfo, int docID, BytesRef value);
    internal void AddSortedSetField(FieldInfo fieldInfo, int docID, BytesRef value);
    internal void AddNumericField(FieldInfo fieldInfo, int docID, long value);
    private static string GetTypeDesc(DocValuesWriter obj);
    public virtual void Abort();
}
public enum Lucene.Net.Index.DocValuesType : Enum {
    public int value__;
    public static DocValuesType NONE;
    public static DocValuesType NUMERIC;
    public static DocValuesType BINARY;
    public static DocValuesType SORTED;
    public static DocValuesType SORTED_SET;
}
internal abstract class Lucene.Net.Index.DocValuesUpdate : object {
    private static int RAW_SIZE_IN_BYTES;
    internal DocValuesFieldUpdatesType type;
    internal Term term;
    internal string field;
    internal int docIDUpto;
    protected DocValuesUpdate(DocValuesFieldUpdatesType type, Term term, string field);
    private static DocValuesUpdate();
    internal abstract virtual long GetValueSizeInBytes();
    internal int GetSizeInBytes();
    public virtual string ToString();
}
internal abstract class Lucene.Net.Index.DocValuesWriter : object {
    public abstract virtual void Abort();
    public abstract virtual void Finish(int numDoc);
    public abstract virtual void Flush(SegmentWriteState state, DocValuesConsumer consumer);
}
[ExtensionAttribute]
public static class Lucene.Net.Index.Extensions.IndexWriterConfigExtensions : object {
    [ExtensionAttribute]
public static LiveIndexWriterConfig SetTermIndexInterval(LiveIndexWriterConfig config, int interval);
    [ExtensionAttribute]
public static LiveIndexWriterConfig SetMaxBufferedDeleteTerms(LiveIndexWriterConfig config, int maxBufferedDeleteTerms);
    [ExtensionAttribute]
public static LiveIndexWriterConfig SetRAMBufferSizeMB(LiveIndexWriterConfig config, double ramBufferSizeMB);
    [ExtensionAttribute]
public static LiveIndexWriterConfig SetMaxBufferedDocs(LiveIndexWriterConfig config, int maxBufferedDocs);
    [ExtensionAttribute]
public static LiveIndexWriterConfig SetMergedSegmentWarmer(LiveIndexWriterConfig config, IndexReaderWarmer mergeSegmentWarmer);
    [ExtensionAttribute]
public static LiveIndexWriterConfig SetReaderTermsIndexDivisor(LiveIndexWriterConfig config, int divisor);
    [ExtensionAttribute]
public static LiveIndexWriterConfig SetUseCompoundFile(LiveIndexWriterConfig config, bool useCompoundFile);
    [ExtensionAttribute]
public static LiveIndexWriterConfig SetCheckIntegrityAtMerge(LiveIndexWriterConfig config, bool checkIntegrityAtMerge);
    [ExtensionAttribute]
public static IndexWriterConfig SetTermIndexInterval(IndexWriterConfig config, int interval);
    [ExtensionAttribute]
public static IndexWriterConfig SetMaxBufferedDeleteTerms(IndexWriterConfig config, int maxBufferedDeleteTerms);
    [ExtensionAttribute]
public static IndexWriterConfig SetRAMBufferSizeMB(IndexWriterConfig config, double ramBufferSizeMB);
    [ExtensionAttribute]
public static IndexWriterConfig SetMaxBufferedDocs(IndexWriterConfig config, int maxBufferedDocs);
    [ExtensionAttribute]
public static IndexWriterConfig SetMergedSegmentWarmer(IndexWriterConfig config, IndexReaderWarmer mergeSegmentWarmer);
    [ExtensionAttribute]
public static IndexWriterConfig SetReaderTermsIndexDivisor(IndexWriterConfig config, int divisor);
    [ExtensionAttribute]
public static IndexWriterConfig SetUseCompoundFile(IndexWriterConfig config, bool useCompoundFile);
    [ExtensionAttribute]
public static IndexWriterConfig SetCheckIntegrityAtMerge(IndexWriterConfig config, bool checkIntegrityAtMerge);
    [ExtensionAttribute]
public static IndexWriterConfig SetDefaultWriteLockTimeout(IndexWriterConfig config, long writeLockTimeout);
    [ExtensionAttribute]
public static IndexWriterConfig SetOpenMode(IndexWriterConfig config, OpenMode openMode);
    [ExtensionAttribute]
public static IndexWriterConfig SetIndexDeletionPolicy(IndexWriterConfig config, IndexDeletionPolicy deletionPolicy);
    [ExtensionAttribute]
public static IndexWriterConfig SetIndexCommit(IndexWriterConfig config, IndexCommit commit);
    [ExtensionAttribute]
public static IndexWriterConfig SetSimilarity(IndexWriterConfig config, Similarity similarity);
    [ExtensionAttribute]
public static IndexWriterConfig SetMergeScheduler(IndexWriterConfig config, IMergeScheduler mergeScheduler);
    [ExtensionAttribute]
public static IndexWriterConfig SetWriteLockTimeout(IndexWriterConfig config, long writeLockTimeout);
    [ExtensionAttribute]
public static IndexWriterConfig SetMergePolicy(IndexWriterConfig config, MergePolicy mergePolicy);
    [ExtensionAttribute]
public static IndexWriterConfig SetCodec(IndexWriterConfig config, Codec codec);
    [ExtensionAttribute]
internal static IndexWriterConfig SetIndexerThreadPool(IndexWriterConfig config, DocumentsWriterPerThreadPool threadPool);
    [ExtensionAttribute]
public static IndexWriterConfig SetMaxThreadStates(IndexWriterConfig config, int maxThreadStates);
    [ExtensionAttribute]
public static IndexWriterConfig SetReaderPooling(IndexWriterConfig config, bool readerPooling);
    [ExtensionAttribute]
internal static IndexWriterConfig SetIndexingChain(IndexWriterConfig config, IndexingChain indexingChain);
    [ExtensionAttribute]
internal static IndexWriterConfig SetFlushPolicy(IndexWriterConfig config, FlushPolicy flushPolicy);
    [ExtensionAttribute]
public static IndexWriterConfig SetRAMPerThreadHardLimitMB(IndexWriterConfig config, int perThreadHardLimitMB);
}
public class Lucene.Net.Index.FieldInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Number>k__BackingField;
    private bool indexed;
    private DocValuesType docValueType;
    private bool storeTermVector;
    private DocValuesType normType;
    private bool omitNorms;
    private IndexOptions indexOptions;
    private bool storePayloads;
    private IDictionary`2<string, string> attributes;
    private long dvGen;
    public string Name { get; private set; }
    public int Number { get; private set; }
    public DocValuesType DocValuesType { get; internal set; }
    public IndexOptions IndexOptions { get; }
    public bool HasDocValues { get; }
    public long DocValuesGen { get; public set; }
    public DocValuesType NormType { get; internal set; }
    public bool OmitsNorms { get; }
    public bool HasNorms { get; }
    public bool IsIndexed { get; }
    public bool HasPayloads { get; }
    public bool HasVectors { get; }
    public IDictionary`2<string, string> Attributes { get; }
    public FieldInfo(string name, bool indexed, int number, bool storeTermVector, bool omitNorms, bool storePayloads, IndexOptions indexOptions, DocValuesType docValues, DocValuesType normsType, IDictionary`2<string, string> attributes);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_Number();
    [CompilerGeneratedAttribute]
private void set_Number(int value);
    private bool CheckConsistency();
    internal void Update(IIndexableFieldType ft);
    internal void Update(bool indexed, bool storeTermVector, bool omitNorms, bool storePayloads, IndexOptions indexOptions);
    public DocValuesType get_DocValuesType();
    internal void set_DocValuesType(DocValuesType value);
    public IndexOptions get_IndexOptions();
    public bool get_HasDocValues();
    public long get_DocValuesGen();
    public void set_DocValuesGen(long value);
    public DocValuesType get_NormType();
    internal void set_NormType(DocValuesType value);
    internal void SetStoreTermVectors();
    internal void SetStorePayloads();
    public bool get_OmitsNorms();
    public bool get_HasNorms();
    public bool get_IsIndexed();
    public bool get_HasPayloads();
    public bool get_HasVectors();
    public string GetAttribute(string key);
    public string PutAttribute(string key, string value);
    public IDictionary`2<string, string> get_Attributes();
}
public class Lucene.Net.Index.FieldInfos : object {
    private bool hasFreq;
    private bool hasProx;
    private bool hasPayloads;
    private bool hasOffsets;
    private bool hasVectors;
    private bool hasNorms;
    private bool hasDocValues;
    private IDictionary`2<int, FieldInfo> byNumber;
    private IDictionary`2<string, FieldInfo> byName;
    private ICollection`1<FieldInfo> values;
    public bool HasFreq { get; }
    public bool HasProx { get; }
    public bool HasPayloads { get; }
    public bool HasOffsets { get; }
    public bool HasVectors { get; }
    public bool HasNorms { get; }
    public bool HasDocValues { get; }
    public int Count { get; }
    public FieldInfos(FieldInfo[] infos);
    public virtual bool get_HasFreq();
    public virtual bool get_HasProx();
    public virtual bool get_HasPayloads();
    public virtual bool get_HasOffsets();
    public virtual bool get_HasVectors();
    public virtual bool get_HasNorms();
    public virtual bool get_HasDocValues();
    public virtual int get_Count();
    public virtual IEnumerator`1<FieldInfo> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual FieldInfo FieldInfo(string fieldName);
    public virtual FieldInfo FieldInfo(int fieldNumber);
}
public class Lucene.Net.Index.FieldInvertState : object {
    private string name;
    private int position;
    private int length;
    private int numOverlap;
    private int offset;
    private int maxTermFrequency;
    private int uniqueTermCount;
    private float boost;
    private AttributeSource attributeSource;
    public int Position { get; internal set; }
    public int Length { get; public set; }
    public int NumOverlap { get; public set; }
    public int Offset { get; internal set; }
    public float Boost { get; public set; }
    public int MaxTermFrequency { get; internal set; }
    public int UniqueTermCount { get; internal set; }
    public AttributeSource AttributeSource { get; internal set; }
    public string Name { get; internal set; }
    public FieldInvertState(string name);
    public FieldInvertState(string name, int position, int length, int numOverlap, int offset, float boost);
    internal void Reset();
    public int get_Position();
    internal void set_Position(int value);
    public int get_Length();
    public void set_Length(int value);
    public int get_NumOverlap();
    public void set_NumOverlap(int value);
    public int get_Offset();
    internal void set_Offset(int value);
    public float get_Boost();
    public void set_Boost(float value);
    public int get_MaxTermFrequency();
    internal void set_MaxTermFrequency(int value);
    public int get_UniqueTermCount();
    internal void set_UniqueTermCount(int value);
    public AttributeSource get_AttributeSource();
    internal void set_AttributeSource(AttributeSource value);
    public string get_Name();
    internal void set_Name(string value);
}
public abstract class Lucene.Net.Index.Fields : object {
    public static Fields[] EMPTY_ARRAY;
    public int Count { get; }
    [ObsoleteAttribute("Iterate fields and add their Count instead. This method is only provided as a transition mechanism to access this statistic for 3.x indexes, which do not have this statistic per-field.")]
public long UniqueTermCount { get; }
    private static Fields();
    public abstract virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public abstract virtual Terms GetTerms(string field);
    public abstract virtual int get_Count();
    public virtual long get_UniqueTermCount();
}
public class Lucene.Net.Index.FilterAtomicReader : AtomicReader {
    protected AtomicReader m_input;
    public IBits LiveDocs { get; }
    public FieldInfos FieldInfos { get; }
    public int NumDocs { get; }
    public int MaxDoc { get; }
    public Fields Fields { get; }
    public FilterAtomicReader(AtomicReader input);
    public static AtomicReader Unwrap(AtomicReader reader);
    public virtual IBits get_LiveDocs();
    public virtual FieldInfos get_FieldInfos();
    public virtual Fields GetTermVectors(int docID);
    public virtual int get_NumDocs();
    public virtual int get_MaxDoc();
    public virtual void Document(int docID, StoredFieldVisitor visitor);
    protected internal virtual void DoClose();
    public virtual Fields get_Fields();
    public virtual string ToString();
    public virtual NumericDocValues GetNumericDocValues(string field);
    public virtual BinaryDocValues GetBinaryDocValues(string field);
    public virtual SortedDocValues GetSortedDocValues(string field);
    public virtual SortedSetDocValues GetSortedSetDocValues(string field);
    public virtual NumericDocValues GetNormValues(string field);
    public virtual IBits GetDocsWithField(string field);
    public virtual void CheckIntegrity();
}
public abstract class Lucene.Net.Index.FilterDirectoryReader : DirectoryReader {
    protected DirectoryReader m_input;
    public long Version { get; }
    public IndexCommit IndexCommit { get; }
    protected FilterDirectoryReader(DirectoryReader input);
    protected FilterDirectoryReader(DirectoryReader input, SubReaderWrapper wrapper);
    protected abstract virtual DirectoryReader DoWrapDirectoryReader(DirectoryReader input);
    private DirectoryReader WrapDirectoryReader(DirectoryReader input);
    protected internal sealed virtual DirectoryReader DoOpenIfChanged();
    protected internal sealed virtual DirectoryReader DoOpenIfChanged(IndexCommit commit);
    protected internal sealed virtual DirectoryReader DoOpenIfChanged(IndexWriter writer, bool applyAllDeletes);
    public virtual long get_Version();
    public virtual bool IsCurrent();
    public virtual IndexCommit get_IndexCommit();
    protected internal virtual void DoClose();
}
public abstract class Lucene.Net.Index.FilteredTermsEnum : TermsEnum {
    private BytesRef initialSeekTerm;
    private bool doSeek;
    private BytesRef actualTerm;
    private TermsEnum tenum;
    public AttributeSource Attributes { get; }
    public BytesRef Term { get; }
    public IComparer`1<BytesRef> Comparer { get; }
    public int DocFreq { get; }
    public long TotalTermFreq { get; }
    public long Ord { get; }
    protected FilteredTermsEnum(TermsEnum tenum);
    protected FilteredTermsEnum(TermsEnum tenum, bool startWithSeek);
    protected abstract virtual AcceptStatus Accept(BytesRef term);
    protected void SetInitialSeekTerm(BytesRef term);
    protected virtual BytesRef NextSeekTerm(BytesRef currentTerm);
    public virtual AttributeSource get_Attributes();
    public virtual BytesRef get_Term();
    public virtual IComparer`1<BytesRef> get_Comparer();
    public virtual int get_DocFreq();
    public virtual long get_TotalTermFreq();
    public virtual bool SeekExact(BytesRef term);
    public virtual SeekStatus SeekCeil(BytesRef term);
    public virtual void SeekExact(long ord);
    public virtual long get_Ord();
    public virtual DocsEnum Docs(IBits bits, DocsEnum reuse, DocsFlags flags);
    public virtual DocsAndPositionsEnum DocsAndPositions(IBits bits, DocsAndPositionsEnum reuse, DocsAndPositionsFlags flags);
    public virtual void SeekExact(BytesRef term, TermState state);
    public virtual TermState GetTermState();
    public virtual bool MoveNext();
    [ObsoleteAttribute("Use MoveNext() and Term instead. This method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public virtual BytesRef Next();
}
internal class Lucene.Net.Index.FlushByRamOrCountsPolicy : FlushPolicy {
    protected internal bool FlushOnDocCount { get; }
    protected internal bool FlushOnDeleteTerms { get; }
    protected internal bool FlushOnRAM { get; }
    public virtual void OnDelete(DocumentsWriterFlushControl control, ThreadState state);
    public virtual void OnInsert(DocumentsWriterFlushControl control, ThreadState state);
    protected virtual void MarkLargestWriterPending(DocumentsWriterFlushControl control, ThreadState perThreadState, long currentBytesPerThread);
    protected internal virtual bool get_FlushOnDocCount();
    protected internal virtual bool get_FlushOnDeleteTerms();
    protected internal virtual bool get_FlushOnRAM();
}
internal abstract class Lucene.Net.Index.FlushPolicy : object {
    protected LiveIndexWriterConfig m_indexWriterConfig;
    protected InfoStream m_infoStream;
    public abstract virtual void OnDelete(DocumentsWriterFlushControl control, ThreadState state);
    public virtual void OnUpdate(DocumentsWriterFlushControl control, ThreadState state);
    public abstract virtual void OnInsert(DocumentsWriterFlushControl control, ThreadState state);
    protected internal virtual void Init(LiveIndexWriterConfig indexWriterConfig);
    protected virtual ThreadState FindLargestNonPendingWriter(DocumentsWriterFlushControl control, ThreadState perThreadState);
    private bool AssertMessage(string s);
    public virtual object Clone();
}
internal class Lucene.Net.Index.FreqProxTermsWriter : TermsHashConsumer {
    internal BytesRef payload;
    public virtual void Abort();
    public virtual void Flush(IDictionary`2<string, TermsHashConsumerPerField> fieldsToFlush, SegmentWriteState state);
    public virtual TermsHashConsumerPerField AddField(TermsHashPerField termsHashPerField, FieldInfo fieldInfo);
    internal virtual void FinishDocument(TermsHash termsHash);
    internal virtual void StartDocument();
}
internal class Lucene.Net.Index.FreqProxTermsWriterPerField : TermsHashConsumerPerField {
    internal FreqProxTermsWriter parent;
    internal TermsHashPerField termsHashPerField;
    internal FieldInfo fieldInfo;
    internal DocState docState;
    internal FieldInvertState fieldState;
    private bool hasFreq;
    private bool hasProx;
    private bool hasOffsets;
    internal IPayloadAttribute payloadAttribute;
    internal IOffsetAttribute offsetAttribute;
    internal bool hasPayloads;
    internal BytesRef payload;
    internal int StreamCount { get; }
    public FreqProxTermsWriterPerField(TermsHashPerField termsHashPerField, FreqProxTermsWriter parent, FieldInfo fieldInfo);
    internal virtual int get_StreamCount();
    internal virtual void Finish();
    [ExceptionToNetNumericConventionAttribute]
internal virtual void SkippingLongTerm();
    public sealed virtual int CompareTo(FreqProxTermsWriterPerField other);
    internal void Reset();
    private void SetIndexOptions(IndexOptions indexOptions);
    internal virtual bool Start(IIndexableField[] fields, int count);
    internal virtual void Start(IIndexableField f);
    internal void WriteProx(int termID, int proxCode);
    internal void WriteOffsets(int termID, int offsetAccum);
    internal virtual void NewTerm(int termID);
    internal virtual void AddTerm(int termID);
    internal virtual ParallelPostingsArray CreatePostingsArray(int size);
    public void Abort();
    internal void Flush(string fieldName, FieldsConsumer consumer, SegmentWriteState state);
}
internal class Lucene.Net.Index.FrozenBufferedUpdates : object {
    internal static int BYTES_PER_DEL_QUERY;
    internal PrefixCodedTerms terms;
    internal int termCount;
    internal Query[] queries;
    internal Int32[] queryLimits;
    internal NumericDocValuesUpdate[] numericDVUpdates;
    internal BinaryDocValuesUpdate[] binaryDVUpdates;
    internal int bytesUsed;
    internal int numTermDeletes;
    private long gen;
    internal bool isSegmentPrivate;
    public long DelGen { get; public set; }
    public FrozenBufferedUpdates(BufferedUpdates deletes, bool isSegmentPrivate);
    private static FrozenBufferedUpdates();
    public virtual void set_DelGen(long value);
    public virtual long get_DelGen();
    public virtual IEnumerable`1<Term> GetTermsEnumerable();
    public virtual IEnumerable`1<QueryAndLimit> GetQueriesEnumerable();
    public virtual string ToString();
    public virtual bool Any();
}
public interface Lucene.Net.Index.IConcurrentMergeScheduler {
    public int MaxThreadCount { get; }
    public int MaxMergeCount { get; }
    public int MergeThreadPriority { get; }
    public abstract virtual int get_MaxThreadCount();
    public abstract virtual int get_MaxMergeCount();
    public abstract virtual int get_MergeThreadPriority();
    public abstract virtual void SetMergeThreadPriority(int priority);
    public abstract virtual void Sync();
    public abstract virtual void SetMaxMergesAndThreads(int maxMergeCount, int maxThreadCount);
    public abstract virtual void SetSuppressExceptions();
    public abstract virtual void ClearSuppressExceptions();
}
public interface Lucene.Net.Index.IIndexableField {
    public string Name { get; }
    public IIndexableFieldType IndexableFieldType { get; }
    public float Boost { get; }
    public NumericFieldType NumericType { get; }
    public abstract virtual string get_Name();
    public abstract virtual IIndexableFieldType get_IndexableFieldType();
    public abstract virtual float get_Boost();
    public abstract virtual BytesRef GetBinaryValue();
    public abstract virtual string GetStringValue();
    public abstract virtual string GetStringValue(IFormatProvider provider);
    public abstract virtual string GetStringValue(string format);
    public abstract virtual string GetStringValue(string format, IFormatProvider provider);
    public abstract virtual TextReader GetReaderValue();
    [ObsoleteAttribute("In .NET, use of this method will cause boxing/unboxing. Instead, use the NumericType property to check the underlying type and call the appropriate GetXXXValue() method to retrieve the value.")]
public abstract virtual object GetNumericValue();
    public abstract virtual NumericFieldType get_NumericType();
    public abstract virtual Nullable`1<byte> GetByteValue();
    public abstract virtual Nullable`1<short> GetInt16Value();
    public abstract virtual Nullable`1<int> GetInt32Value();
    public abstract virtual Nullable`1<long> GetInt64Value();
    public abstract virtual Nullable`1<float> GetSingleValue();
    public abstract virtual Nullable`1<double> GetDoubleValue();
    public abstract virtual TokenStream GetTokenStream(Analyzer analyzer);
}
public interface Lucene.Net.Index.IIndexableFieldType {
    public bool IsIndexed { get; }
    public bool IsStored { get; }
    public bool IsTokenized { get; }
    public bool StoreTermVectors { get; }
    public bool StoreTermVectorOffsets { get; }
    public bool StoreTermVectorPositions { get; }
    public bool StoreTermVectorPayloads { get; }
    public bool OmitNorms { get; }
    public IndexOptions IndexOptions { get; }
    public DocValuesType DocValueType { get; }
    public abstract virtual bool get_IsIndexed();
    public abstract virtual bool get_IsStored();
    public abstract virtual bool get_IsTokenized();
    public abstract virtual bool get_StoreTermVectors();
    public abstract virtual bool get_StoreTermVectorOffsets();
    public abstract virtual bool get_StoreTermVectorPositions();
    public abstract virtual bool get_StoreTermVectorPayloads();
    public abstract virtual bool get_OmitNorms();
    public abstract virtual IndexOptions get_IndexOptions();
    public abstract virtual DocValuesType get_DocValueType();
}
public interface Lucene.Net.Index.IMergeScheduler {
    public abstract virtual void Merge(IndexWriter writer, MergeTrigger trigger, bool newMergesFound);
    public abstract virtual object Clone();
}
public abstract class Lucene.Net.Index.IndexCommit : object {
    public string SegmentsFileName { get; }
    public ICollection`1<string> FileNames { get; }
    public Directory Directory { get; }
    public bool IsDeleted { get; }
    public int SegmentCount { get; }
    public long Generation { get; }
    public IDictionary`2<string, string> UserData { get; }
    public abstract virtual string get_SegmentsFileName();
    public abstract virtual ICollection`1<string> get_FileNames();
    public abstract virtual Directory get_Directory();
    public abstract virtual void Delete();
    public abstract virtual bool get_IsDeleted();
    public abstract virtual int get_SegmentCount();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public abstract virtual long get_Generation();
    public abstract virtual IDictionary`2<string, string> get_UserData();
    public virtual int CompareTo(IndexCommit commit);
}
public abstract class Lucene.Net.Index.IndexDeletionPolicy : object {
    public abstract virtual void OnInit(IList`1<T> commits);
    public abstract virtual void OnCommit(IList`1<T> commits);
    public virtual object Clone();
}
internal class Lucene.Net.Index.IndexFileDeleter : object {
    private IList`1<string> deletable;
    private IDictionary`2<string, RefCount> refCounts;
    private IList`1<CommitPoint> commits;
    private List`1<string> lastFiles;
    private IList`1<CommitPoint> commitsToDelete;
    private InfoStream infoStream;
    private Directory directory;
    private IndexDeletionPolicy policy;
    internal bool startingCommitDeleted;
    private SegmentInfos lastSegmentInfos;
    public static bool VERBOSE_REF_COUNTS;
    private IndexWriter writer;
    private bool IsLocked { get; }
    public SegmentInfos LastSegmentInfos { get; }
    public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos, InfoStream infoStream, IndexWriter writer, bool initialIndexExists);
    private bool get_IsLocked();
    private void EnsureOpen();
    public SegmentInfos get_LastSegmentInfos();
    private void DeleteCommits();
    public void Refresh(string segmentName);
    public void Refresh();
    public sealed virtual void Dispose();
    internal void RevisitPolicy();
    public void DeletePendingFiles();
    public void Checkpoint(SegmentInfos segmentInfos, bool isCommit);
    internal void IncRef(SegmentInfos segmentInfos, bool isCommit);
    internal void IncRef(ICollection`1<string> files);
    internal void IncRef(string fileName);
    internal void DecRef(ICollection`1<string> files);
    internal void DecRef(string fileName);
    internal void DecRef(SegmentInfos segmentInfos);
    public bool Exists(string fileName);
    private RefCount GetRefCount(string fileName);
    internal void DeleteFiles(IList`1<string> files);
    internal void DeleteNewFiles(ICollection`1<string> files);
    internal void DeleteFile(string fileName);
}
public class Lucene.Net.Index.IndexFileNames : object {
    public static string SEGMENTS;
    public static string GEN_EXTENSION;
    public static string SEGMENTS_GEN;
    public static string COMPOUND_FILE_EXTENSION;
    public static string COMPOUND_FILE_ENTRIES_EXTENSION;
    public static String[] INDEX_EXTENSIONS;
    public static Regex CODEC_FILE_PATTERN;
    private static IndexFileNames();
    public static string FileNameFromGeneration(string base, string ext, long gen);
    public static string SegmentFileName(string segmentName, string segmentSuffix, string ext);
    public static bool MatchesExtension(string filename, string ext);
    private static int IndexOfSegmentName(string filename);
    public static string StripSegmentName(string filename);
    public static string ParseSegmentName(string filename);
    public static string StripExtension(string filename);
    public static string GetExtension(string filename);
}
public class Lucene.Net.Index.IndexFormatTooNewException : CorruptIndexException {
    public IndexFormatTooNewException(string resourceDesc, int version, int minVersion, int maxVersion);
    public IndexFormatTooNewException(DataInput input, int version, int minVersion, int maxVersion);
    internal IndexFormatTooNewException(string message);
    protected IndexFormatTooNewException(SerializationInfo info, StreamingContext context);
}
public class Lucene.Net.Index.IndexFormatTooOldException : CorruptIndexException {
    public IndexFormatTooOldException(string resourceDesc, string version);
    public IndexFormatTooOldException(DataInput input, string version);
    public IndexFormatTooOldException(string resourceDesc, int version, int minVersion, int maxVersion);
    public IndexFormatTooOldException(DataInput input, int version, int minVersion, int maxVersion);
    internal IndexFormatTooOldException(string message);
    protected IndexFormatTooOldException(SerializationInfo info, StreamingContext context);
}
public class Lucene.Net.Index.IndexNotFoundException : FileNotFoundException {
    public IndexNotFoundException(string message);
    private IndexNotFoundException(SerializationInfo info, StreamingContext context);
}
public enum Lucene.Net.Index.IndexOptions : Enum {
    public int value__;
    public static IndexOptions NONE;
    public static IndexOptions DOCS_ONLY;
    public static IndexOptions DOCS_AND_FREQS;
    public static IndexOptions DOCS_AND_FREQS_AND_POSITIONS;
    public static IndexOptions DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS;
}
public class Lucene.Net.Index.IndexOptionsComparer : object {
    [CompilerGeneratedAttribute]
private static IComparer`1<IndexOptions> <Default>k__BackingField;
    public static IComparer`1<IndexOptions> Default { get; }
    private static IndexOptionsComparer();
    [CompilerGeneratedAttribute]
public static IComparer`1<IndexOptions> get_Default();
    public sealed virtual int Compare(IndexOptions x, IndexOptions y);
}
public abstract class Lucene.Net.Index.IndexReader : object {
    private bool closed;
    private bool closedByChild;
    private AtomicInt32 refCount;
    private IEventAggregator eventAggregator;
    private ISet`1<IReaderClosedListener> readerClosedListeners;
    private ConditionalWeakTable`2<IndexReader, object> parentReaders;
    private object parentReadersLock;
    [ExcludeFromRamUsageEstimationAttribute]
private ISet`1<GetParentReadersEvent> getParentReadersEvents;
    [ExcludeFromRamUsageEstimationAttribute]
private ISet`1<GetCacheKeysEvent> getCacheKeysEvents;
    public int RefCount { get; }
    public int NumDocs { get; }
    public int MaxDoc { get; }
    public int NumDeletedDocs { get; }
    public bool HasDeletions { get; }
    public IndexReaderContext Context { get; }
    public IList`1<AtomicReaderContext> Leaves { get; }
    public object CoreCacheKey { get; }
    public object CombinedCoreAndDeletesKey { get; }
    public void AddReaderClosedListener(IReaderClosedListener listener);
    public void RemoveReaderClosedListener(IReaderClosedListener listener);
    public void RegisterParentReader(IndexReader reader);
    private void NotifyReaderClosedListeners(Exception th);
    private void ReportCloseToParentReaders();
    public int get_RefCount();
    public void IncRef();
    public bool TryIncRef();
    public void DecRef();
    protected internal void EnsureOpen();
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    [ObsoleteAttribute("Use DirectoryReader.Open(Directory)")]
public static DirectoryReader Open(Directory directory);
    [ObsoleteAttribute("Use DirectoryReader.Open(Directory, int)")]
public static DirectoryReader Open(Directory directory, int termInfosIndexDivisor);
    [ObsoleteAttribute("Use DirectoryReader.Open(IndexWriter, bool)")]
public static DirectoryReader Open(IndexWriter writer, bool applyAllDeletes);
    [ObsoleteAttribute("Use DirectoryReader.Open(IndexCommit)")]
public static DirectoryReader Open(IndexCommit commit);
    [ObsoleteAttribute("Use DirectoryReader.Open(IndexCommit, int)/>")]
public static DirectoryReader Open(IndexCommit commit, int termInfosIndexDivisor);
    public abstract virtual Fields GetTermVectors(int docID);
    public Terms GetTermVector(int docID, string field);
    public abstract virtual int get_NumDocs();
    public abstract virtual int get_MaxDoc();
    public int get_NumDeletedDocs();
    public abstract virtual void Document(int docID, StoredFieldVisitor visitor);
    public Document Document(int docID);
    public Document Document(int docID, ISet`1<string> fieldsToLoad);
    public virtual bool get_HasDeletions();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected internal abstract virtual void DoClose();
    internal void SubscribeToGetParentReadersEvent(GetParentReadersEvent getParentReadersEvent);
    internal void SubscribeToGetCacheKeysEvent(GetCacheKeysEvent getCacheKeysEvent);
    protected virtual override void Finalize();
    private void OnGetParentReaders(GetParentReadersEventArgs e);
    private void OnGetCacheKeys(GetCacheKeysEventArgs e);
    public abstract virtual IndexReaderContext get_Context();
    public IList`1<AtomicReaderContext> get_Leaves();
    public virtual object get_CoreCacheKey();
    public virtual object get_CombinedCoreAndDeletesKey();
    public abstract virtual int DocFreq(Term term);
    public abstract virtual long TotalTermFreq(Term term);
    public abstract virtual long GetSumDocFreq(string field);
    public abstract virtual int GetDocCount(string field);
    public abstract virtual long GetSumTotalTermFreq(string field);
}
public abstract class Lucene.Net.Index.IndexReaderContext : object {
    [CompilerGeneratedAttribute]
private CompositeReaderContext <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTopLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DocBaseInParent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OrdInParent>k__BackingField;
    public CompositeReaderContext Parent { get; private set; }
    public bool IsTopLevel { get; private set; }
    public int DocBaseInParent { get; private set; }
    public int OrdInParent { get; private set; }
    public IndexReader Reader { get; }
    public IList`1<AtomicReaderContext> Leaves { get; }
    public IList`1<IndexReaderContext> Children { get; }
    internal IndexReaderContext(CompositeReaderContext parent, int ordInParent, int docBaseInParent);
    [CompilerGeneratedAttribute]
public CompositeReaderContext get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(CompositeReaderContext value);
    [CompilerGeneratedAttribute]
public bool get_IsTopLevel();
    [CompilerGeneratedAttribute]
private void set_IsTopLevel(bool value);
    [CompilerGeneratedAttribute]
public int get_DocBaseInParent();
    [CompilerGeneratedAttribute]
private void set_DocBaseInParent(int value);
    [CompilerGeneratedAttribute]
public int get_OrdInParent();
    [CompilerGeneratedAttribute]
private void set_OrdInParent(int value);
    public abstract virtual IndexReader get_Reader();
    public abstract virtual IList`1<AtomicReaderContext> get_Leaves();
    public abstract virtual IList`1<IndexReaderContext> get_Children();
}
public class Lucene.Net.Index.IndexUpgrader : object {
    internal Directory dir;
    internal IndexWriterConfig iwc;
    internal bool deletePriorCommits;
    public IndexUpgrader(Directory dir, LuceneVersion matchVersion);
    public IndexUpgrader(Directory dir, LuceneVersion matchVersion, TextWriter infoStream, bool deletePriorCommits);
    public IndexUpgrader(Directory dir, IndexWriterConfig iwc, bool deletePriorCommits);
    private static void PrintUsage();
    public static void Main(String[] args);
    public static IndexUpgrader ParseArgs(String[] args);
    public void Upgrade();
}
public class Lucene.Net.Index.IndexWriter : object {
    private static int UNBOUNDED_MAX_MERGE_SEGMENTS;
    public static string WRITE_LOCK_NAME;
    public static string SOURCE;
    public static string SOURCE_MERGE;
    public static string SOURCE_FLUSH;
    public static string SOURCE_ADDINDEXES_READERS;
    public static int MAX_TERM_LENGTH;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) hitOOM;
    private Directory directory;
    private Analyzer analyzer;
    private long changeCount;
    private long lastCommitChangeCount;
    private IList`1<SegmentCommitInfo> rollbackSegments;
    internal SegmentInfos modreq(System.Runtime.CompilerServices.IsVolatile) pendingCommit;
    internal long pendingCommitChangeCount;
    private ICollection`1<string> filesToCommit;
    internal SegmentInfos segmentInfos;
    internal FieldNumbers globalFieldNumberMap;
    private DocumentsWriter docWriter;
    private ConcurrentQueue`1<IEvent> eventQueue;
    internal IndexFileDeleter deleter;
    private IDictionary`2<SegmentCommitInfo, bool> segmentsToMerge;
    private int mergeMaxNumSegments;
    private Lock writeLock;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) closed;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) closing;
    private HashSet`1<SegmentCommitInfo> mergingSegments;
    private MergePolicy mergePolicy;
    private IMergeScheduler mergeScheduler;
    private Queue`1<OneMerge> pendingMerges;
    private HashSet`1<OneMerge> runningMerges;
    private IList`1<OneMerge> mergeExceptions;
    private long mergeGen;
    private bool stopMerges;
    internal AtomicInt32 flushCount;
    internal AtomicInt32 flushDeletesCount;
    internal ReaderPool readerPool;
    internal BufferedUpdatesStream bufferedUpdatesStream;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) poolReaders;
    private LiveIndexWriterConfig config;
    internal Codec codec;
    internal InfoStream infoStream;
    private object commitLock;
    private object fullFlushLock;
    private bool keepFullyDeletedSegments;
    private FieldNumbers FieldNumberMap { get; }
    public LiveIndexWriterConfig Config { get; }
    public Directory Directory { get; }
    public Analyzer Analyzer { get; }
    public int MaxDoc { get; }
    public int NumDocs { get; }
    internal int SegmentCount { get; }
    internal int NumBufferedDocuments { get; }
    internal ICollection`1<string> IndexFileNames { get; }
    internal int FlushCount { get; }
    internal int FlushDeletesCount { get; }
    public ICollection`1<SegmentCommitInfo> MergingSegments { get; }
    public IDictionary`2<string, string> CommitData { get; }
    internal bool HoldsFullFlushLock { get; }
    internal DocumentsWriter DocsWriter { get; }
    internal int BufferedDeleteTermsSize { get; }
    internal int NumBufferedDeleteTerms { get; }
    public bool KeepFullyDeletedSegments { get; public set; }
    public bool IsClosed { get; }
    public IndexWriter(Directory d, IndexWriterConfig conf);
    private static IndexWriter();
    internal virtual DirectoryReader GetReader();
    public virtual DirectoryReader GetReader(bool applyAllDeletes);
    public virtual int NumDeletedDocs(SegmentCommitInfo info);
    protected internal void EnsureOpen(bool failIfDisposing);
    protected internal void EnsureOpen();
    private FieldNumbers get_FieldNumberMap();
    public virtual LiveIndexWriterConfig get_Config();
    private void MessageState();
    public sealed virtual void Dispose();
    public virtual void Dispose(bool waitForMerges);
    private bool AssertEventQueueAfterClose();
    private bool ShouldClose();
    private void CloseInternal(bool waitForMerges, bool doFlush);
    public virtual Directory get_Directory();
    public virtual Analyzer get_Analyzer();
    public virtual int get_MaxDoc();
    public virtual int get_NumDocs();
    public virtual bool HasDeletions();
    public virtual void AddDocument(IEnumerable`1<IIndexableField> doc);
    public virtual void AddDocument(IEnumerable`1<IIndexableField> doc, Analyzer analyzer);
    public virtual void AddDocuments(IEnumerable`1<IEnumerable`1<IIndexableField>> docs);
    public virtual void AddDocuments(IEnumerable`1<IEnumerable`1<IIndexableField>> docs, Analyzer analyzer);
    public virtual void UpdateDocuments(Term delTerm, IEnumerable`1<IEnumerable`1<IIndexableField>> docs);
    public virtual void UpdateDocuments(Term delTerm, IEnumerable`1<IEnumerable`1<IIndexableField>> docs, Analyzer analyzer);
    public virtual void DeleteDocuments(Term term);
    public virtual bool TryDeleteDocument(IndexReader readerIn, int docID);
    public virtual void DeleteDocuments(Term[] terms);
    public virtual void DeleteDocuments(Query query);
    public virtual void DeleteDocuments(Query[] queries);
    public virtual void UpdateDocument(Term term, IEnumerable`1<IIndexableField> doc);
    public virtual void UpdateDocument(Term term, IEnumerable`1<IIndexableField> doc, Analyzer analyzer);
    public virtual void UpdateNumericDocValue(Term term, string field, Nullable`1<long> value);
    public virtual void UpdateBinaryDocValue(Term term, string field, BytesRef value);
    internal int get_SegmentCount();
    internal int get_NumBufferedDocuments();
    internal ICollection`1<string> get_IndexFileNames();
    internal int GetDocCount(int i);
    internal int get_FlushCount();
    internal int get_FlushDeletesCount();
    internal string NewSegmentName();
    public virtual void ForceMerge(int maxNumSegments);
    public virtual void ForceMerge(int maxNumSegments, bool doWait);
    private bool MaxNumSegmentsMergesPending();
    public virtual void ForceMergeDeletes(bool doWait);
    public virtual void ForceMergeDeletes();
    public void MaybeMerge();
    private void MaybeMerge(MergeTrigger trigger, int maxNumSegments);
    private bool UpdatePendingMerges(MergeTrigger trigger, int maxNumSegments);
    public virtual ICollection`1<SegmentCommitInfo> get_MergingSegments();
    public virtual OneMerge NextMerge();
    public virtual bool HasPendingMerges();
    public virtual void Rollback();
    private void RollbackInternal();
    public virtual void DeleteAll();
    private void FinishMerges(bool waitForMerges);
    public virtual void WaitForMerges();
    internal virtual void Checkpoint();
    internal virtual void CheckpointNoSIS();
    internal void Changed();
    internal virtual void PublishFrozenUpdates(FrozenBufferedUpdates packet);
    internal virtual void PublishFlushedSegment(SegmentCommitInfo newSegment, FrozenBufferedUpdates packet, FrozenBufferedUpdates globalPacket);
    private void ResetMergeExceptions();
    private void NoDupDirs(Directory[] dirs);
    private IEnumerable`1<Lock> AcquireWriteLocks(Directory[] dirs);
    public virtual void AddIndexes(Directory[] dirs);
    public virtual void AddIndexes(IndexReader[] readers);
    private SegmentCommitInfo CopySegmentAsIs(SegmentCommitInfo info, string segName, IDictionary`2<string, string> dsNames, ISet`1<string> dsFilesCopied, IOContext context, ISet`1<string> copiedFiles);
    protected virtual void DoAfterFlush();
    protected virtual void DoBeforeFlush();
    public sealed virtual void PrepareCommit();
    private void PrepareCommitInternal();
    public void SetCommitData(IDictionary`2<string, string> commitUserData);
    public IDictionary`2<string, string> get_CommitData();
    public sealed virtual void Commit();
    public bool HasUncommittedChanges();
    private void CommitInternal();
    private void FinishCommit();
    internal virtual bool get_HoldsFullFlushLock();
    public void Flush(bool triggerMerge, bool applyAllDeletes);
    private bool DoFlush(bool applyAllDeletes);
    internal void MaybeApplyDeletes(bool applyAllDeletes);
    internal void ApplyAllDeletesAndUpdates();
    public long RamSizeInBytes();
    internal virtual DocumentsWriter get_DocsWriter();
    public int NumRamDocs();
    private void EnsureValidMerge(OneMerge merge);
    private static void SkipDeletedDoc(DocValuesFieldUpdatesIterator[] updatesIters, int deletedDoc);
    private void MaybeApplyMergedDVUpdates(OneMerge merge, MergeState mergeState, int docUpto, MergedDeletesAndUpdates holder, String[] mergingFields, DocValuesFieldUpdates[] dvFieldUpdates, DocValuesFieldUpdatesIterator[] updatesIters, int curDoc);
    private ReadersAndUpdates CommitMergedDeletesAndUpdates(OneMerge merge, MergeState mergeState);
    private bool CommitMerge(OneMerge merge, MergeState mergeState);
    private void HandleMergeException(Exception t, OneMerge merge);
    public virtual void Merge(OneMerge merge);
    internal virtual void MergeSuccess(OneMerge merge);
    internal bool RegisterMerge(OneMerge merge);
    internal void MergeInit(OneMerge merge);
    private void MergeInitImpl(OneMerge merge);
    internal static void SetDiagnostics(SegmentInfo info, string source);
    private static void SetDiagnostics(SegmentInfo info, string source, IDictionary`2<string, string> details);
    public void MergeFinish(OneMerge merge);
    private void CloseMergeReaders(OneMerge merge, bool suppressExceptions);
    private int MergeMiddle(OneMerge merge);
    internal virtual void AddMergeException(OneMerge merge);
    internal int get_BufferedDeleteTermsSize();
    internal int get_NumBufferedDeleteTerms();
    internal virtual SegmentCommitInfo NewestSegment();
    public virtual string SegString();
    public virtual string SegString(IEnumerable`1<SegmentCommitInfo> infos);
    public virtual string SegString(SegmentCommitInfo info);
    private void DoWait();
    public virtual bool get_KeepFullyDeletedSegments();
    public virtual void set_KeepFullyDeletedSegments(bool value);
    private bool FilesExist(SegmentInfos toSync);
    internal virtual SegmentInfos ToLiveInfos(SegmentInfos sis);
    private void StartCommit(SegmentInfos toSync);
    public static bool IsLocked(Directory directory);
    public static void Unlock(Directory directory);
    private void HandleOOM(Exception oom, string location);
    private bool TestPoint(string message);
    internal virtual bool NrtIsCurrent(SegmentInfos infos);
    public virtual bool get_IsClosed();
    public virtual void DeleteUnusedFiles();
    internal static ICollection`1<string> CreateCompoundFile(InfoStream infoStream, Directory directory, CheckAbort checkAbort, SegmentInfo info, IOContext context);
    internal void DeleteNewFiles(ICollection`1<string> files);
    internal void FlushFailed(SegmentInfo info);
    internal int Purge(bool forced);
    internal void ApplyDeletesAndPurge(bool forcePurge);
    internal void DoAfterSegmentFlushed(bool triggerMerge, bool forcePurge);
    internal virtual void IncRefDeleter(SegmentInfos segmentInfos);
    internal virtual void DecRefDeleter(SegmentInfos segmentInfos);
    private bool ProcessEvents(bool triggerMerge, bool forcePurge);
    private bool ProcessEvents(ConcurrentQueue`1<IEvent> queue, bool triggerMerge, bool forcePurge);
    private static bool SlowFileExists(Directory dir, string fileName);
}
public class Lucene.Net.Index.IndexWriterConfig : LiveIndexWriterConfig {
    public static int DEFAULT_TERM_INDEX_INTERVAL;
    public static int DISABLE_AUTO_FLUSH;
    public static int DEFAULT_MAX_BUFFERED_DELETE_TERMS;
    public static int DEFAULT_MAX_BUFFERED_DOCS;
    public static double DEFAULT_RAM_BUFFER_SIZE_MB;
    public static long WRITE_LOCK_TIMEOUT;
    public static bool DEFAULT_READER_POOLING;
    public static int DEFAULT_READER_TERMS_INDEX_DIVISOR;
    public static int DEFAULT_RAM_PER_THREAD_HARD_LIMIT_MB;
    public static int DEFAULT_MAX_THREAD_STATES;
    public static bool DEFAULT_USE_COMPOUND_FILE_SYSTEM;
    public static bool DEFAULT_CHECK_INTEGRITY_AT_MERGE;
    private SetOnce`1<IndexWriter> writer;
    public static long DefaultWriteLockTimeout { get; public set; }
    public OpenMode OpenMode { get; public set; }
    public IndexDeletionPolicy IndexDeletionPolicy { get; public set; }
    public IndexCommit IndexCommit { get; public set; }
    public Similarity Similarity { get; public set; }
    public IMergeScheduler MergeScheduler { get; public set; }
    public long WriteLockTimeout { get; public set; }
    public Codec Codec { get; public set; }
    public MergePolicy MergePolicy { get; public set; }
    internal DocumentsWriterPerThreadPool IndexerThreadPool { get; internal set; }
    public int MaxThreadStates { get; public set; }
    public bool UseReaderPooling { get; public set; }
    internal IndexingChain IndexingChain { get; internal set; }
    public int RAMPerThreadHardLimitMB { get; public set; }
    internal FlushPolicy FlushPolicy { get; internal set; }
    public IndexWriterConfig(LuceneVersion matchVersion, Analyzer analyzer);
    private static IndexWriterConfig();
    public static long get_DefaultWriteLockTimeout();
    public static void set_DefaultWriteLockTimeout(long value);
    internal IndexWriterConfig SetIndexWriter(IndexWriter writer);
    public object Clone();
    public OpenMode get_OpenMode();
    public void set_OpenMode(OpenMode value);
    public IndexDeletionPolicy get_IndexDeletionPolicy();
    public void set_IndexDeletionPolicy(IndexDeletionPolicy value);
    public IndexCommit get_IndexCommit();
    public void set_IndexCommit(IndexCommit value);
    public Similarity get_Similarity();
    public void set_Similarity(Similarity value);
    public IMergeScheduler get_MergeScheduler();
    public void set_MergeScheduler(IMergeScheduler value);
    public long get_WriteLockTimeout();
    public void set_WriteLockTimeout(long value);
    public Codec get_Codec();
    public void set_Codec(Codec value);
    public MergePolicy get_MergePolicy();
    public void set_MergePolicy(MergePolicy value);
    internal DocumentsWriterPerThreadPool get_IndexerThreadPool();
    internal void set_IndexerThreadPool(DocumentsWriterPerThreadPool value);
    public int get_MaxThreadStates();
    public void set_MaxThreadStates(int value);
    public bool get_UseReaderPooling();
    public void set_UseReaderPooling(bool value);
    internal IndexingChain get_IndexingChain();
    internal void set_IndexingChain(IndexingChain value);
    public int get_RAMPerThreadHardLimitMB();
    public void set_RAMPerThreadHardLimitMB(int value);
    internal FlushPolicy get_FlushPolicy();
    internal void set_FlushPolicy(FlushPolicy value);
    public IndexWriterConfig SetInfoStream(InfoStream infoStream);
    public IndexWriterConfig SetInfoStream(TextWriter printStream);
    public virtual string ToString();
}
internal abstract class Lucene.Net.Index.InvertedDocConsumer : object {
    public abstract virtual void Abort();
    internal abstract virtual void Flush(IDictionary`2<string, InvertedDocConsumerPerField> fieldsToFlush, SegmentWriteState state);
    internal abstract virtual InvertedDocConsumerPerField AddField(DocInverterPerField docInverterPerField, FieldInfo fieldInfo);
    internal abstract virtual void StartDocument();
    internal abstract virtual void FinishDocument();
}
internal abstract class Lucene.Net.Index.InvertedDocConsumerPerField : object {
    internal abstract virtual bool Start(IIndexableField[] fields, int count);
    internal abstract virtual void Start(IIndexableField field);
    internal abstract virtual void Add();
    internal abstract virtual void Finish();
    public abstract virtual void Abort();
}
internal abstract class Lucene.Net.Index.InvertedDocEndConsumer : object {
    internal abstract virtual void Flush(IDictionary`2<string, InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state);
    internal abstract virtual void Abort();
    internal abstract virtual InvertedDocEndConsumerPerField AddField(DocInverterPerField docInverterPerField, FieldInfo fieldInfo);
    internal abstract virtual void StartDocument();
    internal abstract virtual void FinishDocument();
}
internal abstract class Lucene.Net.Index.InvertedDocEndConsumerPerField : object {
    internal abstract virtual void Finish();
    internal abstract virtual void Abort();
}
public interface Lucene.Net.Index.ITwoPhaseCommit {
    public abstract virtual void PrepareCommit();
    public abstract virtual void Commit();
    public abstract virtual void Rollback();
}
public class Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy : IndexDeletionPolicy {
    public virtual void OnInit(IList`1<T> commits);
    public virtual void OnCommit(IList`1<T> commits);
}
public class Lucene.Net.Index.LiveIndexWriterConfig : object {
    private Analyzer analyzer;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) maxBufferedDocs;
    private double ramBufferSizeMB;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) maxBufferedDeleteTerms;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) readerTermsIndexDivisor;
    private IndexReaderWarmer modreq(System.Runtime.CompilerServices.IsVolatile) mergedSegmentWarmer;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) termIndexInterval;
    internal IndexDeletionPolicy modreq(System.Runtime.CompilerServices.IsVolatile) delPolicy;
    internal IndexCommit modreq(System.Runtime.CompilerServices.IsVolatile) commit;
    internal OpenMode modreq(System.Runtime.CompilerServices.IsVolatile) openMode;
    internal Similarity modreq(System.Runtime.CompilerServices.IsVolatile) similarity;
    internal IMergeScheduler modreq(System.Runtime.CompilerServices.IsVolatile) mergeScheduler;
    internal long writeLockTimeout;
    internal IndexingChain modreq(System.Runtime.CompilerServices.IsVolatile) indexingChain;
    internal Codec modreq(System.Runtime.CompilerServices.IsVolatile) codec;
    internal InfoStream modreq(System.Runtime.CompilerServices.IsVolatile) infoStream;
    internal MergePolicy modreq(System.Runtime.CompilerServices.IsVolatile) mergePolicy;
    internal DocumentsWriterPerThreadPool modreq(System.Runtime.CompilerServices.IsVolatile) indexerThreadPool;
    internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) readerPooling;
    internal FlushPolicy modreq(System.Runtime.CompilerServices.IsVolatile) flushPolicy;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) perThreadHardLimitMB;
    internal LuceneVersion matchVersion;
    internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) useCompoundFile;
    internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) checkIntegrityAtMerge;
    public Analyzer Analyzer { get; }
    public int TermIndexInterval { get; public set; }
    public int MaxBufferedDeleteTerms { get; public set; }
    public double RAMBufferSizeMB { get; public set; }
    public int MaxBufferedDocs { get; public set; }
    public IndexReaderWarmer MergedSegmentWarmer { get; public set; }
    public int ReaderTermsIndexDivisor { get; public set; }
    public OpenMode OpenMode { get; }
    public IndexDeletionPolicy IndexDeletionPolicy { get; }
    public IndexCommit IndexCommit { get; }
    public Similarity Similarity { get; }
    public IMergeScheduler MergeScheduler { get; }
    public long WriteLockTimeout { get; }
    public Codec Codec { get; }
    public MergePolicy MergePolicy { get; }
    internal DocumentsWriterPerThreadPool IndexerThreadPool { get; }
    public int MaxThreadStates { get; }
    public bool UseReaderPooling { get; }
    internal IndexingChain IndexingChain { get; }
    public int RAMPerThreadHardLimitMB { get; }
    internal FlushPolicy FlushPolicy { get; }
    public InfoStream InfoStream { get; }
    public bool UseCompoundFile { get; public set; }
    public bool CheckIntegrityAtMerge { get; public set; }
    internal LiveIndexWriterConfig(Analyzer analyzer, LuceneVersion matchVersion);
    internal LiveIndexWriterConfig(IndexWriterConfig config);
    public virtual Analyzer get_Analyzer();
    public virtual int get_TermIndexInterval();
    public virtual void set_TermIndexInterval(int value);
    public virtual int get_MaxBufferedDeleteTerms();
    public virtual void set_MaxBufferedDeleteTerms(int value);
    public virtual double get_RAMBufferSizeMB();
    public virtual void set_RAMBufferSizeMB(double value);
    public virtual int get_MaxBufferedDocs();
    public virtual void set_MaxBufferedDocs(int value);
    public virtual IndexReaderWarmer get_MergedSegmentWarmer();
    public virtual void set_MergedSegmentWarmer(IndexReaderWarmer value);
    public virtual int get_ReaderTermsIndexDivisor();
    public virtual void set_ReaderTermsIndexDivisor(int value);
    public virtual OpenMode get_OpenMode();
    public virtual IndexDeletionPolicy get_IndexDeletionPolicy();
    public virtual IndexCommit get_IndexCommit();
    public virtual Similarity get_Similarity();
    public virtual IMergeScheduler get_MergeScheduler();
    public virtual long get_WriteLockTimeout();
    public virtual Codec get_Codec();
    public virtual MergePolicy get_MergePolicy();
    internal virtual DocumentsWriterPerThreadPool get_IndexerThreadPool();
    public virtual int get_MaxThreadStates();
    public virtual bool get_UseReaderPooling();
    internal virtual IndexingChain get_IndexingChain();
    public virtual int get_RAMPerThreadHardLimitMB();
    internal virtual FlushPolicy get_FlushPolicy();
    public virtual InfoStream get_InfoStream();
    public virtual bool get_UseCompoundFile();
    public virtual void set_UseCompoundFile(bool value);
    public virtual bool get_CheckIntegrityAtMerge();
    public virtual void set_CheckIntegrityAtMerge(bool value);
    public virtual string ToString();
}
public class Lucene.Net.Index.LogByteSizeMergePolicy : LogMergePolicy {
    public static double DEFAULT_MIN_MERGE_MB;
    public static double DEFAULT_MAX_MERGE_MB;
    public static double DEFAULT_MAX_MERGE_MB_FOR_FORCED_MERGE;
    public double MaxMergeMB { get; public set; }
    public double MaxMergeMBForForcedMerge { get; public set; }
    public double MinMergeMB { get; public set; }
    private static LogByteSizeMergePolicy();
    protected virtual long Size(SegmentCommitInfo info);
    public virtual double get_MaxMergeMB();
    public virtual void set_MaxMergeMB(double value);
    public virtual double get_MaxMergeMBForForcedMerge();
    public virtual void set_MaxMergeMBForForcedMerge(double value);
    public virtual double get_MinMergeMB();
    public virtual void set_MinMergeMB(double value);
}
public class Lucene.Net.Index.LogDocMergePolicy : LogMergePolicy {
    public static int DEFAULT_MIN_MERGE_DOCS;
    public int MinMergeDocs { get; public set; }
    private static LogDocMergePolicy();
    protected virtual long Size(SegmentCommitInfo info);
    public virtual int get_MinMergeDocs();
    public virtual void set_MinMergeDocs(int value);
}
public abstract class Lucene.Net.Index.LogMergePolicy : MergePolicy {
    public static double LEVEL_LOG_SPAN;
    public static int DEFAULT_MERGE_FACTOR;
    public static int DEFAULT_MAX_MERGE_DOCS;
    public static double DEFAULT_NO_CFS_RATIO;
    protected int m_mergeFactor;
    protected long m_minMergeSize;
    protected long m_maxMergeSize;
    protected long m_maxMergeSizeForForcedMerge;
    protected int m_maxMergeDocs;
    protected bool m_calibrateSizeByDeletes;
    protected bool IsVerbose { get; }
    public int MergeFactor { get; public set; }
    public bool CalibrateSizeByDeletes { get; public set; }
    public int MaxMergeDocs { get; public set; }
    private static LogMergePolicy();
    protected virtual bool get_IsVerbose();
    protected virtual void Message(string message);
    public virtual int get_MergeFactor();
    public virtual void set_MergeFactor(int value);
    public virtual bool get_CalibrateSizeByDeletes();
    public virtual void set_CalibrateSizeByDeletes(bool value);
    protected virtual void Dispose(bool disposing);
    protected virtual long SizeDocs(SegmentCommitInfo info);
    protected virtual long SizeBytes(SegmentCommitInfo info);
    protected virtual bool IsMerged(SegmentInfos infos, int maxNumSegments, IDictionary`2<SegmentCommitInfo, bool> segmentsToMerge);
    private MergeSpecification FindForcedMergesSizeLimit(SegmentInfos infos, int last);
    private MergeSpecification FindForcedMergesMaxNumSegments(SegmentInfos infos, int maxNumSegments, int last);
    public virtual MergeSpecification FindForcedMerges(SegmentInfos infos, int maxNumSegments, IDictionary`2<SegmentCommitInfo, bool> segmentsToMerge);
    public virtual MergeSpecification FindForcedDeletesMerges(SegmentInfos segmentInfos);
    public virtual MergeSpecification FindMerges(MergeTrigger mergeTrigger, SegmentInfos infos);
    public virtual int get_MaxMergeDocs();
    public virtual void set_MaxMergeDocs(int value);
    public virtual string ToString();
}
public abstract class Lucene.Net.Index.MergePolicy : object {
    protected static double DEFAULT_NO_CFS_RATIO;
    protected static long DEFAULT_MAX_CFS_SEGMENT_SIZE;
    protected SetOnce`1<IndexWriter> m_writer;
    protected double m_noCFSRatio;
    protected long m_maxCFSSegmentSize;
    public double NoCFSRatio { get; public set; }
    public double MaxCFSSegmentSizeMB { get; public set; }
    protected MergePolicy(double defaultNoCFSRatio, long defaultMaxCFSSegmentSize);
    private static MergePolicy();
    public virtual object Clone();
    public virtual void SetIndexWriter(IndexWriter writer);
    public abstract virtual MergeSpecification FindMerges(MergeTrigger mergeTrigger, SegmentInfos segmentInfos);
    public abstract virtual MergeSpecification FindForcedMerges(SegmentInfos segmentInfos, int maxSegmentCount, IDictionary`2<SegmentCommitInfo, bool> segmentsToMerge);
    public abstract virtual MergeSpecification FindForcedDeletesMerges(SegmentInfos segmentInfos);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public virtual bool UseCompoundFile(SegmentInfos infos, SegmentCommitInfo mergedInfo);
    protected virtual long Size(SegmentCommitInfo info);
    protected bool IsMerged(SegmentInfos infos, SegmentCommitInfo info);
    public double get_NoCFSRatio();
    public void set_NoCFSRatio(double value);
    public double get_MaxCFSSegmentSizeMB();
    public void set_MaxCFSSegmentSizeMB(double value);
}
public abstract class Lucene.Net.Index.MergeScheduler : object {
    public abstract virtual void Merge(IndexWriter writer, MergeTrigger trigger, bool newMergesFound);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public virtual object Clone();
}
public class Lucene.Net.Index.MergeState : object {
    [CompilerGeneratedAttribute]
private SegmentInfo <SegmentInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldInfos <FieldInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<AtomicReader> <Readers>k__BackingField;
    [CompilerGeneratedAttribute]
private DocMap[] <DocMaps>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <DocBase>k__BackingField;
    [CompilerGeneratedAttribute]
private CheckAbort <CheckAbort>k__BackingField;
    [CompilerGeneratedAttribute]
private InfoStream <InfoStream>k__BackingField;
    [CompilerGeneratedAttribute]
private SegmentReader[] <MatchingSegmentReaders>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MatchedCount>k__BackingField;
    public SegmentInfo SegmentInfo { get; private set; }
    public FieldInfos FieldInfos { get; public set; }
    public IList`1<AtomicReader> Readers { get; private set; }
    [WritableArrayAttribute]
public DocMap[] DocMaps { get; public set; }
    [WritableArrayAttribute]
public Int32[] DocBase { get; public set; }
    public CheckAbort CheckAbort { get; private set; }
    public InfoStream InfoStream { get; private set; }
    [WritableArrayAttribute]
public SegmentReader[] MatchingSegmentReaders { get; public set; }
    public int MatchedCount { get; public set; }
    internal MergeState(IList`1<AtomicReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, CheckAbort checkAbort);
    [CompilerGeneratedAttribute]
public SegmentInfo get_SegmentInfo();
    [CompilerGeneratedAttribute]
private void set_SegmentInfo(SegmentInfo value);
    [CompilerGeneratedAttribute]
public FieldInfos get_FieldInfos();
    [CompilerGeneratedAttribute]
public void set_FieldInfos(FieldInfos value);
    [CompilerGeneratedAttribute]
public IList`1<AtomicReader> get_Readers();
    [CompilerGeneratedAttribute]
private void set_Readers(IList`1<AtomicReader> value);
    [CompilerGeneratedAttribute]
public DocMap[] get_DocMaps();
    [CompilerGeneratedAttribute]
public void set_DocMaps(DocMap[] value);
    [CompilerGeneratedAttribute]
public Int32[] get_DocBase();
    [CompilerGeneratedAttribute]
public void set_DocBase(Int32[] value);
    [CompilerGeneratedAttribute]
public CheckAbort get_CheckAbort();
    [CompilerGeneratedAttribute]
private void set_CheckAbort(CheckAbort value);
    [CompilerGeneratedAttribute]
public InfoStream get_InfoStream();
    [CompilerGeneratedAttribute]
private void set_InfoStream(InfoStream value);
    [CompilerGeneratedAttribute]
public SegmentReader[] get_MatchingSegmentReaders();
    [CompilerGeneratedAttribute]
public void set_MatchingSegmentReaders(SegmentReader[] value);
    [CompilerGeneratedAttribute]
public int get_MatchedCount();
    [CompilerGeneratedAttribute]
public void set_MatchedCount(int value);
}
public enum Lucene.Net.Index.MergeTrigger : Enum {
    public int value__;
    public static MergeTrigger SEGMENT_FLUSH;
    public static MergeTrigger FULL_FLUSH;
    public static MergeTrigger EXPLICIT;
    public static MergeTrigger MERGE_FINISHED;
    public static MergeTrigger CLOSING;
}
internal class Lucene.Net.Index.MultiBits : object {
    private IBits[] subs;
    private Int32[] starts;
    private bool sefaultValue;
    public int Length { get; }
    public MultiBits(IBits[] subs, Int32[] starts, bool defaultValue);
    private bool CheckLength(int reader, int doc);
    public sealed virtual bool Get(int doc);
    public virtual string ToString();
    public SubResult GetMatchingSub(ReaderSlice slice);
    public sealed virtual int get_Length();
}
public class Lucene.Net.Index.MultiDocsAndPositionsEnum : DocsAndPositionsEnum {
    private MultiTermsEnum parent;
    internal DocsAndPositionsEnum[] subDocsAndPositionsEnum;
    private EnumWithSlice[] subs;
    internal int numSubs;
    internal int upto;
    internal DocsAndPositionsEnum current;
    internal int currentBase;
    internal int doc;
    public int NumSubs { get; }
    [WritableArrayAttribute]
public EnumWithSlice[] Subs { get; }
    public int Freq { get; }
    public int DocID { get; }
    public int StartOffset { get; }
    public int EndOffset { get; }
    public MultiDocsAndPositionsEnum(MultiTermsEnum parent, int subReaderCount);
    public bool CanReuse(MultiTermsEnum parent);
    public MultiDocsAndPositionsEnum Reset(EnumWithSlice[] subs, int numSubs);
    public int get_NumSubs();
    public EnumWithSlice[] get_Subs();
    public virtual int get_Freq();
    public virtual int get_DocID();
    public virtual int Advance(int target);
    public virtual int NextDoc();
    public virtual int NextPosition();
    public virtual int get_StartOffset();
    public virtual int get_EndOffset();
    public virtual BytesRef GetPayload();
    public virtual long GetCost();
    public virtual string ToString();
}
public class Lucene.Net.Index.MultiDocsEnum : DocsEnum {
    private MultiTermsEnum parent;
    internal DocsEnum[] subDocsEnum;
    private EnumWithSlice[] subs;
    internal int numSubs;
    internal int upto;
    internal DocsEnum current;
    internal int currentBase;
    internal int doc;
    public int NumSubs { get; }
    [WritableArrayAttribute]
public EnumWithSlice[] Subs { get; }
    public int Freq { get; }
    public int DocID { get; }
    public MultiDocsEnum(MultiTermsEnum parent, int subReaderCount);
    internal MultiDocsEnum Reset(EnumWithSlice[] subs, int numSubs);
    public bool CanReuse(MultiTermsEnum parent);
    public int get_NumSubs();
    public EnumWithSlice[] get_Subs();
    public virtual int get_Freq();
    public virtual int get_DocID();
    public virtual int Advance(int target);
    public virtual int NextDoc();
    public virtual long GetCost();
    public virtual string ToString();
}
public static class Lucene.Net.Index.MultiDocValues : object {
    public static NumericDocValues GetNormValues(IndexReader r, string field);
    public static NumericDocValues GetNumericValues(IndexReader r, string field);
    public static IBits GetDocsWithField(IndexReader r, string field);
    public static BinaryDocValues GetBinaryValues(IndexReader r, string field);
    public static SortedDocValues GetSortedValues(IndexReader r, string field);
    public static SortedSetDocValues GetSortedSetValues(IndexReader r, string field);
}
public class Lucene.Net.Index.MultiFields : Fields {
    private Fields[] subs;
    private ReaderSlice[] subSlices;
    private IDictionary`2<string, Terms> terms;
    public int Count { get; }
    public MultiFields(Fields[] subs, ReaderSlice[] subSlices);
    public static Fields GetFields(IndexReader reader);
    public static IBits GetLiveDocs(IndexReader reader);
    public static Terms GetTerms(IndexReader r, string field);
    public static DocsEnum GetTermDocsEnum(IndexReader r, IBits liveDocs, string field, BytesRef term);
    public static DocsEnum GetTermDocsEnum(IndexReader r, IBits liveDocs, string field, BytesRef term, DocsFlags flags);
    public static DocsAndPositionsEnum GetTermPositionsEnum(IndexReader r, IBits liveDocs, string field, BytesRef term);
    public static DocsAndPositionsEnum GetTermPositionsEnum(IndexReader r, IBits liveDocs, string field, BytesRef term, DocsAndPositionsFlags flags);
    public virtual IEnumerator`1<string> GetEnumerator();
    public virtual Terms GetTerms(string field);
    public virtual int get_Count();
    public static FieldInfos GetMergedFieldInfos(IndexReader reader);
    public static ICollection`1<string> GetIndexedFields(IndexReader reader);
}
public class Lucene.Net.Index.MultiReader : BaseCompositeReader`1<IndexReader> {
    private bool closeSubReaders;
    public MultiReader(IndexReader[] subReaders);
    public MultiReader(IndexReader[] subReaders, bool closeSubReaders);
    protected internal virtual void DoClose();
}
public class Lucene.Net.Index.MultiTerms : Terms {
    private Terms[] subs;
    private ReaderSlice[] subSlices;
    private IComparer`1<BytesRef> termComp;
    private bool hasFreqs;
    private bool hasOffsets;
    private bool hasPositions;
    private bool hasPayloads;
    public long Count { get; }
    public long SumTotalTermFreq { get; }
    public long SumDocFreq { get; }
    public int DocCount { get; }
    public IComparer`1<BytesRef> Comparer { get; }
    public bool HasFreqs { get; }
    public bool HasOffsets { get; }
    public bool HasPositions { get; }
    public bool HasPayloads { get; }
    public MultiTerms(Terms[] subs, ReaderSlice[] subSlices);
    public virtual TermsEnum Intersect(CompiledAutomaton compiled, BytesRef startTerm);
    public virtual TermsEnum GetEnumerator();
    public virtual long get_Count();
    public virtual long get_SumTotalTermFreq();
    public virtual long get_SumDocFreq();
    public virtual int get_DocCount();
    public virtual IComparer`1<BytesRef> get_Comparer();
    public virtual bool get_HasFreqs();
    public virtual bool get_HasOffsets();
    public virtual bool get_HasPositions();
    public virtual bool get_HasPayloads();
}
public class Lucene.Net.Index.MultiTermsEnum : TermsEnum {
    private TermMergeQueue queue;
    private TermsEnumWithSlice[] subs;
    private TermsEnumWithSlice[] currentSubs;
    private TermsEnumWithSlice[] top;
    private EnumWithSlice[] subDocs;
    private EnumWithSlice[] subDocsAndPositions;
    private BytesRef lastSeek;
    private bool lastSeekExact;
    private BytesRef lastSeekScratch;
    private int numTop;
    private int numSubs;
    private BytesRef current;
    private IComparer`1<BytesRef> termComp;
    public int MatchCount { get; }
    [WritableArrayAttribute]
public TermsEnumWithSlice[] MatchArray { get; }
    public BytesRef Term { get; }
    public IComparer`1<BytesRef> Comparer { get; }
    public long Ord { get; }
    public int DocFreq { get; }
    public long TotalTermFreq { get; }
    public MultiTermsEnum(ReaderSlice[] slices);
    public int get_MatchCount();
    public TermsEnumWithSlice[] get_MatchArray();
    public virtual BytesRef get_Term();
    public virtual IComparer`1<BytesRef> get_Comparer();
    public TermsEnum Reset(TermsEnumIndex[] termsEnumsIndex);
    public virtual bool SeekExact(BytesRef term);
    public virtual SeekStatus SeekCeil(BytesRef term);
    public virtual void SeekExact(long ord);
    public virtual long get_Ord();
    private void PullTop();
    private void PushTop();
    public virtual bool MoveNext();
    [ObsoleteAttribute("Use MoveNext() and Term instead. This method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public virtual BytesRef Next();
    public virtual int get_DocFreq();
    public virtual long get_TotalTermFreq();
    public virtual DocsEnum Docs(IBits liveDocs, DocsEnum reuse, DocsFlags flags);
    public virtual DocsAndPositionsEnum DocsAndPositions(IBits liveDocs, DocsAndPositionsEnum reuse, DocsAndPositionsFlags flags);
    public virtual string ToString();
}
public class Lucene.Net.Index.NoDeletionPolicy : IndexDeletionPolicy {
    public static IndexDeletionPolicy INSTANCE;
    private static NoDeletionPolicy();
    public virtual void OnCommit(IList`1<T> commits);
    public virtual void OnInit(IList`1<T> commits);
    public virtual object Clone();
}
public class Lucene.Net.Index.NoMergePolicy : MergePolicy {
    public static MergePolicy NO_COMPOUND_FILES;
    public static MergePolicy COMPOUND_FILES;
    private bool useCompoundFile;
    private NoMergePolicy(bool useCompoundFile);
    private static NoMergePolicy();
    protected virtual void Dispose(bool disposing);
    public virtual MergeSpecification FindMerges(MergeTrigger mergeTrigger, SegmentInfos segmentInfos);
    public virtual MergeSpecification FindForcedMerges(SegmentInfos segmentInfos, int maxSegmentCount, IDictionary`2<SegmentCommitInfo, bool> segmentsToMerge);
    public virtual MergeSpecification FindForcedDeletesMerges(SegmentInfos segmentInfos);
    public virtual bool UseCompoundFile(SegmentInfos segments, SegmentCommitInfo newSegment);
    public virtual void SetIndexWriter(IndexWriter writer);
    protected virtual long Size(SegmentCommitInfo info);
    public virtual string ToString();
}
public class Lucene.Net.Index.NoMergeScheduler : MergeScheduler {
    public static MergeScheduler INSTANCE;
    private static NoMergeScheduler();
    protected virtual void Dispose(bool disposing);
    public virtual void Merge(IndexWriter writer, MergeTrigger trigger, bool newMergesFound);
    public virtual object Clone();
}
internal class Lucene.Net.Index.NormsConsumer : InvertedDocEndConsumer {
    internal virtual void Abort();
    internal virtual void Flush(IDictionary`2<string, InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state);
    internal virtual void FinishDocument();
    internal virtual void StartDocument();
    internal virtual InvertedDocEndConsumerPerField AddField(DocInverterPerField docInverterPerField, FieldInfo fieldInfo);
}
internal class Lucene.Net.Index.NormsConsumerPerField : InvertedDocEndConsumerPerField {
    private FieldInfo fieldInfo;
    private DocState docState;
    private Similarity similarity;
    private FieldInvertState fieldState;
    private NumericDocValuesWriter consumer;
    internal bool IsEmpty { get; }
    public NormsConsumerPerField(DocInverterPerField docInverterPerField, FieldInfo fieldInfo);
    public sealed virtual int CompareTo(NormsConsumerPerField other);
    internal virtual void Finish();
    internal void Flush(SegmentWriteState state, DocValuesConsumer normsWriter);
    internal bool get_IsEmpty();
    internal virtual void Abort();
}
public abstract class Lucene.Net.Index.NumericDocValues : object {
    public abstract virtual long Get(int docID);
}
internal class Lucene.Net.Index.NumericDocValuesFieldUpdates : DocValuesFieldUpdates {
    private FixedBitSet docsWithField;
    private PagedMutable docs;
    private PagedGrowableWriter values;
    private int size;
    public NumericDocValuesFieldUpdates(string field, int maxDoc);
    public virtual void AddFromIterator(int doc, DocValuesFieldUpdatesIterator iterator);
    public virtual void AddFromUpdate(int doc, DocValuesUpdate update);
    private void Add(int doc, Nullable`1<long> value);
    public virtual DocValuesFieldUpdatesIterator GetIterator();
    public virtual void Merge(DocValuesFieldUpdates other);
    public virtual bool Any();
}
internal class Lucene.Net.Index.NumericDocValuesUpdate : DocValuesUpdate {
    internal static long MISSING;
    internal long value;
    public NumericDocValuesUpdate(Term term, string field, Nullable`1<long> value);
    internal virtual long GetValueSizeInBytes();
    public virtual string ToString();
}
internal class Lucene.Net.Index.NumericDocValuesWriter : DocValuesWriter {
    private static long MISSING;
    private AppendingDeltaPackedInt64Buffer pending;
    private Counter iwBytesUsed;
    private long bytesUsed;
    private FixedBitSet docsWithField;
    private FieldInfo fieldInfo;
    public NumericDocValuesWriter(FieldInfo fieldInfo, Counter iwBytesUsed, bool trackDocsWithField);
    public virtual void AddValue(int docID, long value);
    private long DocsWithFieldBytesUsed();
    private void UpdateBytesUsed();
    public virtual void Finish(int maxDoc);
    public virtual void Flush(SegmentWriteState state, DocValuesConsumer dvConsumer);
    [IteratorStateMachineAttribute("Lucene.Net.Index.NumericDocValuesWriter/<GetNumericIterator>d__12")]
private IEnumerable`1<Nullable`1<long>> GetNumericIterator(int maxDoc);
    public virtual void Abort();
}
public enum Lucene.Net.Index.OpenMode : Enum {
    public int value__;
    public static OpenMode CREATE;
    public static OpenMode APPEND;
    public static OpenMode CREATE_OR_APPEND;
}
public class Lucene.Net.Index.OrdTermState : TermState {
    [CompilerGeneratedAttribute]
private long <Ord>k__BackingField;
    public long Ord { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Ord();
    [CompilerGeneratedAttribute]
public void set_Ord(long value);
    public virtual void CopyFrom(TermState other);
    public virtual string ToString();
}
public class Lucene.Net.Index.ParallelAtomicReader : AtomicReader {
    private FieldInfos fieldInfos;
    private ParallelFields fields;
    private AtomicReader[] parallelReaders;
    private AtomicReader[] storedFieldsReaders;
    private ISet`1<AtomicReader> completeReaderSet;
    private bool closeSubReaders;
    private int maxDoc;
    private int numDocs;
    private bool hasDeletions;
    private IDictionary`2<string, AtomicReader> fieldToReader;
    private IDictionary`2<string, AtomicReader> tvFieldToReader;
    public FieldInfos FieldInfos { get; }
    public IBits LiveDocs { get; }
    public Fields Fields { get; }
    public int NumDocs { get; }
    public int MaxDoc { get; }
    public ParallelAtomicReader(AtomicReader[] readers);
    public ParallelAtomicReader(bool closeSubReaders, AtomicReader[] readers);
    public ParallelAtomicReader(bool closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders);
    public virtual string ToString();
    public virtual FieldInfos get_FieldInfos();
    public virtual IBits get_LiveDocs();
    public virtual Fields get_Fields();
    public virtual int get_NumDocs();
    public virtual int get_MaxDoc();
    public virtual void Document(int docID, StoredFieldVisitor visitor);
    public virtual Fields GetTermVectors(int docID);
    protected internal virtual void DoClose();
    public virtual NumericDocValues GetNumericDocValues(string field);
    public virtual BinaryDocValues GetBinaryDocValues(string field);
    public virtual SortedDocValues GetSortedDocValues(string field);
    public virtual SortedSetDocValues GetSortedSetDocValues(string field);
    public virtual IBits GetDocsWithField(string field);
    public virtual NumericDocValues GetNormValues(string field);
    public virtual void CheckIntegrity();
}
public class Lucene.Net.Index.ParallelCompositeReader : BaseCompositeReader`1<IndexReader> {
    private bool closeSubReaders;
    private ISet`1<IndexReader> completeReaderSet;
    public ParallelCompositeReader(CompositeReader[] readers);
    public ParallelCompositeReader(bool closeSubReaders, CompositeReader[] readers);
    public ParallelCompositeReader(bool closeSubReaders, CompositeReader[] readers, CompositeReader[] storedFieldReaders);
    private static IndexReader[] PrepareSubReaders(CompositeReader[] readers, CompositeReader[] storedFieldsReaders);
    private static void Validate(CompositeReader[] readers, int maxDoc, Int32[] childMaxDoc, Boolean[] childAtomic);
    protected internal virtual void DoClose();
}
internal class Lucene.Net.Index.ParallelPostingsArray : object {
    internal static int BYTES_PER_POSTING;
    internal int size;
    internal Int32[] textStarts;
    internal Int32[] intStarts;
    internal Int32[] byteStarts;
    internal ParallelPostingsArray(int size);
    internal virtual int BytesPerPosting();
    internal virtual ParallelPostingsArray NewInstance(int size);
    internal ParallelPostingsArray Grow();
    internal virtual void CopyTo(ParallelPostingsArray toArray, int numToCopy);
}
public class Lucene.Net.Index.PersistentSnapshotDeletionPolicy : SnapshotDeletionPolicy {
    public static string SNAPSHOTS_PREFIX;
    private static int VERSION_START;
    private static int VERSION_CURRENT;
    private static string CODEC_NAME;
    private long nextWriteGen;
    private Directory dir;
    public string LastSaveFile { get; }
    public PersistentSnapshotDeletionPolicy(IndexDeletionPolicy primary, Directory dir);
    public PersistentSnapshotDeletionPolicy(IndexDeletionPolicy primary, Directory dir, OpenMode mode);
    public virtual IndexCommit Snapshot();
    public virtual void Release(IndexCommit commit);
    public virtual void Release(long gen);
    internal void Persist();
    private void ClearPriorSnapshots();
    public virtual string get_LastSaveFile();
    private void LoadPriorSnapshots();
}
internal class Lucene.Net.Index.PrefixCodedTerms : object {
    internal RAMFile buffer;
    private PrefixCodedTerms(RAMFile buffer);
    public virtual long GetSizeInBytes();
    public virtual IEnumerator`1<Term> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class Lucene.Net.Index.RandomAccessOrds : SortedSetDocValues {
    public int Cardinality { get; }
    public abstract virtual long OrdAt(int index);
    public abstract virtual int get_Cardinality();
}
[ExtensionAttribute]
public static class Lucene.Net.Index.RandomAccessOrdsExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use Cardinality property instead. This extension method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public static int Cardinality(RandomAccessOrds randomAccessOrds);
}
public class Lucene.Net.Index.ReaderManager : ReferenceManager`1<DirectoryReader> {
    public ReaderManager(IndexWriter writer, bool applyAllDeletes);
    public ReaderManager(Directory dir);
    protected virtual void DecRef(DirectoryReader reference);
    protected virtual DirectoryReader RefreshIfNeeded(DirectoryReader referenceToRefresh);
    protected virtual bool TryIncRef(DirectoryReader reference);
    protected virtual int GetRefCount(DirectoryReader reference);
}
internal class Lucene.Net.Index.ReadersAndUpdates : object {
    [CompilerGeneratedAttribute]
private SegmentCommitInfo <Info>k__BackingField;
    private AtomicInt32 refCount;
    private IndexWriter writer;
    private SegmentReader reader;
    private SegmentReader mergeReader;
    private IBits liveDocs;
    private int pendingDeleteCount;
    private bool liveDocsShared;
    private bool isMerging;
    private IDictionary`2<string, DocValuesFieldUpdates> mergingDVUpdates;
    public SegmentCommitInfo Info { get; private set; }
    public int PendingDeleteCount { get; }
    public IBits LiveDocs { get; }
    public IDictionary`2<string, DocValuesFieldUpdates> MergingFieldUpdates { get; }
    public ReadersAndUpdates(IndexWriter writer, SegmentCommitInfo info);
    [CompilerGeneratedAttribute]
public SegmentCommitInfo get_Info();
    [CompilerGeneratedAttribute]
private void set_Info(SegmentCommitInfo value);
    public virtual void IncRef();
    public virtual void DecRef();
    public virtual int RefCount();
    public virtual int get_PendingDeleteCount();
    public virtual bool VerifyDocCounts();
    public virtual SegmentReader GetReader(IOContext context);
    public virtual SegmentReader GetMergeReader(IOContext context);
    public virtual void Release(SegmentReader sr);
    public virtual bool Delete(int docID);
    public virtual void DropReaders();
    public virtual SegmentReader GetReadOnlyClone(IOContext context);
    public virtual void InitWritableLiveDocs();
    public virtual IBits get_LiveDocs();
    public virtual IBits GetReadOnlyLiveDocs();
    public virtual void DropChanges();
    public virtual bool WriteLiveDocs(Directory dir);
    public virtual void WriteFieldUpdates(Directory dir, Container dvUpdates);
    [IteratorStateMachineAttribute("Lucene.Net.Index.ReadersAndUpdates/<GetInt64Enumerable>d__33")]
private IEnumerable`1<Nullable`1<long>> GetInt64Enumerable(SegmentReader reader, string field, NumericDocValuesFieldUpdates fieldUpdates);
    [IteratorStateMachineAttribute("Lucene.Net.Index.ReadersAndUpdates/<GetBytesRefEnumerable>d__34")]
private IEnumerable`1<BytesRef> GetBytesRefEnumerable(SegmentReader reader, string field, BinaryDocValuesFieldUpdates fieldUpdates);
    internal virtual SegmentReader GetReaderForMerge(IOContext context);
    public virtual void DropMergingUpdates();
    public virtual IDictionary`2<string, DocValuesFieldUpdates> get_MergingFieldUpdates();
    public virtual string ToString();
}
public class Lucene.Net.Index.ReaderSlice : object {
    public static ReaderSlice[] EMPTY_ARRAY;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReaderIndex>k__BackingField;
    public int Start { get; private set; }
    public int Length { get; private set; }
    public int ReaderIndex { get; private set; }
    public ReaderSlice(int start, int length, int readerIndex);
    private static ReaderSlice();
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
private void set_Start(int value);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(int value);
    [CompilerGeneratedAttribute]
public int get_ReaderIndex();
    [CompilerGeneratedAttribute]
private void set_ReaderIndex(int value);
    public virtual string ToString();
}
public class Lucene.Net.Index.ReaderUtil : object {
    public static IndexReaderContext GetTopLevelContext(IndexReaderContext context);
    public static int SubIndex(int n, Int32[] docStarts);
    public static int SubIndex(int n, IList`1<AtomicReaderContext> leaves);
}
public class Lucene.Net.Index.SegmentCommitInfo : object {
    [CompilerGeneratedAttribute]
private SegmentInfo <Info>k__BackingField;
    private int delCount;
    private long delGen;
    private long nextWriteDelGen;
    private long fieldInfosGen;
    private long nextWriteFieldInfosGen;
    private IDictionary`2<long, ISet`1<string>> genUpdatesFiles;
    private long sizeInBytes;
    private long bufferedDeletesGen;
    public SegmentInfo Info { get; private set; }
    public IDictionary`2<long, ISet`1<string>> UpdatesFiles { get; }
    internal long BufferedDeletesGen { get; }
    public bool HasDeletions { get; }
    public bool HasFieldUpdates { get; }
    public long NextFieldInfosGen { get; }
    public long FieldInfosGen { get; }
    public long NextDelGen { get; }
    public long DelGen { get; }
    public int DelCount { get; internal set; }
    public SegmentCommitInfo(SegmentInfo info, int delCount, long delGen, long fieldInfosGen);
    [CompilerGeneratedAttribute]
public SegmentInfo get_Info();
    [CompilerGeneratedAttribute]
private void set_Info(SegmentInfo value);
    public virtual IDictionary`2<long, ISet`1<string>> get_UpdatesFiles();
    public virtual void SetGenUpdatesFiles(IDictionary`2<long, ISet`1<string>> genUpdatesFiles);
    internal virtual void AdvanceDelGen();
    internal virtual void AdvanceNextWriteDelGen();
    internal virtual void AdvanceFieldInfosGen();
    internal virtual void AdvanceNextWriteFieldInfosGen();
    public virtual long GetSizeInBytes();
    public virtual ICollection`1<string> GetFiles();
    internal virtual long get_BufferedDeletesGen();
    internal void SetBufferedDeletesGen(long value);
    public virtual bool get_HasDeletions();
    public virtual bool get_HasFieldUpdates();
    public virtual long get_NextFieldInfosGen();
    public virtual long get_FieldInfosGen();
    public virtual long get_NextDelGen();
    public virtual long get_DelGen();
    public virtual int get_DelCount();
    internal virtual void set_DelCount(int value);
    public virtual string ToString(Directory dir, int pendingDelCount);
    public virtual string ToString();
    public virtual object Clone();
}
internal class Lucene.Net.Index.SegmentCoreReaders : object {
    private AtomicInt32 ref;
    internal FieldsProducer fields;
    internal DocValuesProducer normsProducer;
    internal int termsIndexDivisor;
    internal StoredFieldsReader fieldsReaderOrig;
    internal TermVectorsReader termVectorsReaderOrig;
    internal CompoundFileDirectory cfsReader;
    internal DisposableThreadLocal`1<StoredFieldsReader> fieldsReaderLocal;
    internal DisposableThreadLocal`1<TermVectorsReader> termVectorsLocal;
    internal DisposableThreadLocal`1<IDictionary`2<string, object>> normsLocal;
    private ISet`1<ICoreDisposedListener> coreClosedListeners;
    internal int RefCount { get; }
    internal SegmentCoreReaders(SegmentReader owner, Directory dir, SegmentCommitInfo si, IOContext context, int termsIndexDivisor);
    internal int get_RefCount();
    internal void IncRef();
    internal NumericDocValues GetNormValues(FieldInfo fi);
    internal void DecRef();
    private void NotifyCoreClosedListeners(Exception th);
    internal void AddCoreDisposedListener(ICoreDisposedListener listener);
    internal void RemoveCoreDisposedListener(ICoreDisposedListener listener);
    public long RamBytesUsed();
    [CompilerGeneratedAttribute]
private StoredFieldsReader <.ctor>b__11_0();
    [CompilerGeneratedAttribute]
private TermVectorsReader <.ctor>b__11_1();
}
internal class Lucene.Net.Index.SegmentDocValues : object {
    private IDictionary`2<long, RefCount`1<DocValuesProducer>> genDVProducers;
    private RefCount`1<DocValuesProducer> NewDocValuesProducer(SegmentCommitInfo si, IOContext context, Directory dir, DocValuesFormat dvFormat, long gen, IList`1<FieldInfo> infos, int termsIndexDivisor);
    internal DocValuesProducer GetDocValuesProducer(long gen, SegmentCommitInfo si, IOContext context, Directory dir, DocValuesFormat dvFormat, IList`1<FieldInfo> infos, int termsIndexDivisor);
    internal void DecRef(IList`1<long> dvProducersGens);
}
public class Lucene.Net.Index.SegmentInfo : object {
    public static int NO;
    public static int YES;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private int docCount;
    [CompilerGeneratedAttribute]
private Directory <Dir>k__BackingField;
    private bool isCompoundFile;
    private Codec codec;
    private IDictionary`2<string, string> diagnostics;
    [ObsoleteAttribute("not used anymore")]
private IDictionary`2<string, string> attributes;
    private string version;
    private ISet`1<string> setFiles;
    public string Name { get; private set; }
    public Directory Dir { get; private set; }
    public IDictionary`2<string, string> Diagnostics { get; public set; }
    [ObsoleteAttribute("separate norms are not supported in >= 4.0")]
internal bool HasSeparateNorms { get; }
    public bool UseCompoundFile { get; public set; }
    public Codec Codec { get; public set; }
    public int DocCount { get; internal set; }
    public string Version { get; public set; }
    [ObsoleteAttribute("no longer supported")]
public IDictionary`2<string, string> Attributes { get; }
    public SegmentInfo(Directory dir, string version, string name, int docCount, bool isCompoundFile, Codec codec, IDictionary`2<string, string> diagnostics);
    public SegmentInfo(Directory dir, string version, string name, int docCount, bool isCompoundFile, Codec codec, IDictionary`2<string, string> diagnostics, IDictionary`2<string, string> attributes);
    private static SegmentInfo();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Directory get_Dir();
    [CompilerGeneratedAttribute]
private void set_Dir(Directory value);
    public IDictionary`2<string, string> get_Diagnostics();
    public void set_Diagnostics(IDictionary`2<string, string> value);
    internal bool get_HasSeparateNorms();
    public bool get_UseCompoundFile();
    public void set_UseCompoundFile(bool value);
    public Codec get_Codec();
    public void set_Codec(Codec value);
    public int get_DocCount();
    internal void set_DocCount(int value);
    public ISet`1<string> GetFiles();
    public virtual string ToString();
    public string ToString(Directory dir, int delCount);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string get_Version();
    public void set_Version(string value);
    public void SetFiles(ISet`1<string> files);
    public void AddFiles(ICollection`1<string> files);
    public void AddFile(string file);
    private static void CheckFileNames(ICollection`1<string> files);
    [ObsoleteAttribute("no longer supported")]
public string GetAttribute(string key);
    [ObsoleteAttribute("no longer supported")]
public string PutAttribute(string key, string value);
    public IDictionary`2<string, string> get_Attributes();
}
[DefaultMemberAttribute("Item")]
public class Lucene.Net.Index.SegmentInfos : object {
    public static int VERSION_40;
    public static int VERSION_46;
    public static int VERSION_48;
    private static int FORMAT_SEGMENTS_GEN_47;
    private static int FORMAT_SEGMENTS_GEN_CHECKSUM;
    private static int FORMAT_SEGMENTS_GEN_START;
    public static int FORMAT_SEGMENTS_GEN_CURRENT;
    internal static bool useLegacySegmentNames;
    [CompilerGeneratedAttribute]
private int <Counter>k__BackingField;
    private long generation;
    private long lastGeneration;
    private IDictionary`2<string, string> userData;
    private List`1<SegmentCommitInfo> segments;
    private static TextWriter infoStream;
    internal IndexOutput pendingSegnOutput;
    private static string SEGMENT_INFO_UPGRADE_CODEC;
    private static int SEGMENT_INFO_UPGRADE_VERSION;
    [CompilerGeneratedAttribute]
private long <Version>k__BackingField;
    private static int defaultGenLookaheadCount;
    public static bool UseLegacySegmentNames { get; public set; }
    public int Counter { get; public set; }
    public SegmentCommitInfo Item { get; }
    public IList`1<SegmentCommitInfo> Segments { get; }
    public long Version { get; internal set; }
    public long Generation { get; }
    public long LastGeneration { get; }
    public static TextWriter InfoStream { get; public set; }
    public static int DefaultGenLookaheadCount { get; public set; }
    public IDictionary`2<string, string> UserData { get; internal set; }
    public int TotalDocCount { get; }
    public int Count { get; }
    private static SegmentInfos();
    public static bool get_UseLegacySegmentNames();
    public static void set_UseLegacySegmentNames(bool value);
    internal static string SegmentNumberToString(long segment, bool allowLegacyNames);
    [CompilerGeneratedAttribute]
public int get_Counter();
    [CompilerGeneratedAttribute]
public void set_Counter(int value);
    [ObsoleteAttribute("Use indexer instead. This method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public SegmentCommitInfo Info(int i);
    public SegmentCommitInfo get_Item(int index);
    public static long GetLastCommitGeneration(String[] files);
    public static long GetLastCommitGeneration(Directory directory);
    public static string GetLastCommitSegmentsFileName(String[] files);
    public static string GetLastCommitSegmentsFileName(Directory directory);
    public string GetSegmentsFileName();
    public static long GenerationFromSegmentsFileName(string fileName);
    public static void WriteSegmentsGen(Directory dir, long generation);
    public string GetNextSegmentFileName();
    public void Read(Directory directory, string segmentFileName);
    public void Read(Directory directory);
    private void Write(Directory directory);
    private static bool SegmentWasUpgraded(Directory directory, SegmentInfo si);
    [ObsoleteAttribute]
public static string Write3xInfo(Directory dir, SegmentInfo si, IOContext context);
    public object Clone();
    public IList`1<SegmentCommitInfo> get_Segments();
    [CompilerGeneratedAttribute]
public long get_Version();
    [CompilerGeneratedAttribute]
internal void set_Version(long value);
    public long get_Generation();
    public long get_LastGeneration();
    public static void set_InfoStream(TextWriter value);
    public static TextWriter get_InfoStream();
    public static int get_DefaultGenLookaheadCount();
    public static void set_DefaultGenLookaheadCount(int value);
    private static void Message(string message);
    internal void UpdateGeneration(SegmentInfos other);
    internal void RollbackCommit(Directory dir);
    internal void PrepareCommit(Directory dir);
    public ICollection`1<string> GetFiles(Directory dir, bool includeSegmentsFile);
    internal void FinishCommit(Directory dir);
    internal void Commit(Directory dir);
    public string ToString(Directory directory);
    public IDictionary`2<string, string> get_UserData();
    internal void set_UserData(IDictionary`2<string, string> value);
    internal void Replace(SegmentInfos other);
    public int get_TotalDocCount();
    public void Changed();
    internal void ApplyMergeChanges(OneMerge merge, bool dropSegment);
    internal IList`1<SegmentCommitInfo> CreateBackupSegmentInfos();
    internal void RollbackSegmentInfos(IList`1<SegmentCommitInfo> infos);
    public sealed virtual IEnumerator`1<SegmentCommitInfo> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public IList`1<SegmentCommitInfo> AsList();
    public int get_Count();
    public void Add(SegmentCommitInfo si);
    public void AddAll(IEnumerable`1<SegmentCommitInfo> sis);
    public void Clear();
    public void Remove(SegmentCommitInfo si);
    internal void Remove(int index);
    internal bool Contains(SegmentCommitInfo si);
    internal int IndexOf(SegmentCommitInfo si);
}
internal class Lucene.Net.Index.SegmentMerger : object {
    private Directory directory;
    private int termIndexInterval;
    private Codec codec;
    private IOContext context;
    private MergeState mergeState;
    private Builder fieldInfosBuilder;
    internal bool ShouldMerge { get; }
    internal SegmentMerger(IList`1<AtomicReader> readers, SegmentInfo segmentInfo, InfoStream infoStream, Directory dir, int termIndexInterval, CheckAbort checkAbort, FieldNumbers fieldNumbers, IOContext context, bool validate);
    internal bool get_ShouldMerge();
    internal MergeState Merge();
    private void MergeDocValues(SegmentWriteState segmentWriteState);
    private void MergeNorms(SegmentWriteState segmentWriteState);
    private void SetMatchingSegmentReaders();
    public void MergeFieldInfos();
    private int MergeFields();
    private int MergeVectors();
    private int SetDocMaps();
    private void MergeTerms(SegmentWriteState segmentWriteState);
}
public class Lucene.Net.Index.SegmentReader : AtomicReader {
    private SegmentCommitInfo si;
    private IBits liveDocs;
    private int numDocs;
    internal SegmentCoreReaders core;
    internal SegmentDocValues segDocValues;
    internal DisposableThreadLocal`1<IDictionary`2<string, object>> docValuesLocal;
    internal DisposableThreadLocal`1<IDictionary`2<string, IBits>> docsWithFieldLocal;
    internal IDictionary`2<string, DocValuesProducer> dvProducersByField;
    internal ISet`1<DocValuesProducer> dvProducers;
    private FieldInfos fieldInfos;
    private IList`1<long> dvGens;
    public IBits LiveDocs { get; }
    public FieldInfos FieldInfos { get; }
    public StoredFieldsReader FieldsReader { get; }
    public Fields Fields { get; }
    public int NumDocs { get; }
    public int MaxDoc { get; }
    public TermVectorsReader TermVectorsReader { get; }
    public string SegmentName { get; }
    public SegmentCommitInfo SegmentInfo { get; }
    public Directory Directory { get; }
    public object CoreCacheKey { get; }
    public object CombinedCoreAndDeletesKey { get; }
    public int TermInfosIndexDivisor { get; }
    public SegmentReader(SegmentCommitInfo si, int termInfosIndexDivisor, IOContext context);
    internal SegmentReader(SegmentCommitInfo si, SegmentReader sr);
    internal SegmentReader(SegmentCommitInfo si, SegmentReader sr, IBits liveDocs, int numDocs);
    private void InitDocValuesProducers(Codec codec);
    internal static FieldInfos ReadFieldInfos(SegmentCommitInfo info);
    private IDictionary`2<long, IList`1<FieldInfo>> GetGenInfos();
    public virtual IBits get_LiveDocs();
    protected internal virtual void DoClose();
    public virtual FieldInfos get_FieldInfos();
    public StoredFieldsReader get_FieldsReader();
    public virtual void Document(int docID, StoredFieldVisitor visitor);
    public virtual Fields get_Fields();
    public virtual int get_NumDocs();
    public virtual int get_MaxDoc();
    public TermVectorsReader get_TermVectorsReader();
    public virtual Fields GetTermVectors(int docID);
    private void CheckBounds(int docID);
    public virtual string ToString();
    public string get_SegmentName();
    public SegmentCommitInfo get_SegmentInfo();
    public Directory get_Directory();
    public virtual object get_CoreCacheKey();
    public virtual object get_CombinedCoreAndDeletesKey();
    public int get_TermInfosIndexDivisor();
    private FieldInfo GetDVField(string field, DocValuesType type);
    public virtual NumericDocValues GetNumericDocValues(string field);
    public virtual IBits GetDocsWithField(string field);
    public virtual BinaryDocValues GetBinaryDocValues(string field);
    public virtual SortedDocValues GetSortedDocValues(string field);
    public virtual SortedSetDocValues GetSortedSetDocValues(string field);
    public virtual NumericDocValues GetNormValues(string field);
    public void AddCoreDisposedListener(ICoreDisposedListener listener);
    public void RemoveCoreDisposedListener(ICoreDisposedListener listener);
    public long RamBytesUsed();
    public virtual void CheckIntegrity();
}
public class Lucene.Net.Index.SegmentReadState : object {
    [CompilerGeneratedAttribute]
private Directory <Directory>k__BackingField;
    [CompilerGeneratedAttribute]
private SegmentInfo <SegmentInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldInfos <FieldInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private IOContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TermsIndexDivisor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SegmentSuffix>k__BackingField;
    public Directory Directory { get; private set; }
    public SegmentInfo SegmentInfo { get; private set; }
    public FieldInfos FieldInfos { get; private set; }
    public IOContext Context { get; private set; }
    public int TermsIndexDivisor { get; public set; }
    public string SegmentSuffix { get; private set; }
    public SegmentReadState(Directory dir, SegmentInfo info, FieldInfos fieldInfos, IOContext context, int termsIndexDivisor);
    public SegmentReadState(Directory dir, SegmentInfo info, FieldInfos fieldInfos, IOContext context, int termsIndexDivisor, string segmentSuffix);
    public SegmentReadState(SegmentReadState other, string newSegmentSuffix);
    [CompilerGeneratedAttribute]
public Directory get_Directory();
    [CompilerGeneratedAttribute]
private void set_Directory(Directory value);
    [CompilerGeneratedAttribute]
public SegmentInfo get_SegmentInfo();
    [CompilerGeneratedAttribute]
private void set_SegmentInfo(SegmentInfo value);
    [CompilerGeneratedAttribute]
public FieldInfos get_FieldInfos();
    [CompilerGeneratedAttribute]
private void set_FieldInfos(FieldInfos value);
    [CompilerGeneratedAttribute]
public IOContext get_Context();
    [CompilerGeneratedAttribute]
private void set_Context(IOContext value);
    [CompilerGeneratedAttribute]
public int get_TermsIndexDivisor();
    [CompilerGeneratedAttribute]
public void set_TermsIndexDivisor(int value);
    [CompilerGeneratedAttribute]
public string get_SegmentSuffix();
    [CompilerGeneratedAttribute]
private void set_SegmentSuffix(string value);
}
public class Lucene.Net.Index.SegmentWriteState : object {
    [CompilerGeneratedAttribute]
private InfoStream <InfoStream>k__BackingField;
    [CompilerGeneratedAttribute]
private Directory <Directory>k__BackingField;
    [CompilerGeneratedAttribute]
private SegmentInfo <SegmentInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldInfos <FieldInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DelCountOnFlush>k__BackingField;
    [CompilerGeneratedAttribute]
private BufferedUpdates <SegUpdates>k__BackingField;
    [CompilerGeneratedAttribute]
private IMutableBits <LiveDocs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SegmentSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TermIndexInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private IOContext <Context>k__BackingField;
    public InfoStream InfoStream { get; private set; }
    public Directory Directory { get; private set; }
    public SegmentInfo SegmentInfo { get; private set; }
    public FieldInfos FieldInfos { get; private set; }
    public int DelCountOnFlush { get; public set; }
    public BufferedUpdates SegUpdates { get; private set; }
    public IMutableBits LiveDocs { get; public set; }
    public string SegmentSuffix { get; private set; }
    public int TermIndexInterval { get; public set; }
    public IOContext Context { get; private set; }
    public SegmentWriteState(InfoStream infoStream, Directory directory, SegmentInfo segmentInfo, FieldInfos fieldInfos, int termIndexInterval, BufferedUpdates segUpdates, IOContext context);
    public SegmentWriteState(InfoStream infoStream, Directory directory, SegmentInfo segmentInfo, FieldInfos fieldInfos, int termIndexInterval, BufferedUpdates segUpdates, IOContext context, string segmentSuffix);
    public SegmentWriteState(SegmentWriteState state, string segmentSuffix);
    [CompilerGeneratedAttribute]
public InfoStream get_InfoStream();
    [CompilerGeneratedAttribute]
private void set_InfoStream(InfoStream value);
    [CompilerGeneratedAttribute]
public Directory get_Directory();
    [CompilerGeneratedAttribute]
private void set_Directory(Directory value);
    [CompilerGeneratedAttribute]
public SegmentInfo get_SegmentInfo();
    [CompilerGeneratedAttribute]
private void set_SegmentInfo(SegmentInfo value);
    [CompilerGeneratedAttribute]
public FieldInfos get_FieldInfos();
    [CompilerGeneratedAttribute]
private void set_FieldInfos(FieldInfos value);
    [CompilerGeneratedAttribute]
public int get_DelCountOnFlush();
    [CompilerGeneratedAttribute]
public void set_DelCountOnFlush(int value);
    [CompilerGeneratedAttribute]
public BufferedUpdates get_SegUpdates();
    [CompilerGeneratedAttribute]
private void set_SegUpdates(BufferedUpdates value);
    [CompilerGeneratedAttribute]
public IMutableBits get_LiveDocs();
    [CompilerGeneratedAttribute]
public void set_LiveDocs(IMutableBits value);
    [CompilerGeneratedAttribute]
public string get_SegmentSuffix();
    [CompilerGeneratedAttribute]
private void set_SegmentSuffix(string value);
    [CompilerGeneratedAttribute]
public int get_TermIndexInterval();
    [CompilerGeneratedAttribute]
public void set_TermIndexInterval(int value);
    [CompilerGeneratedAttribute]
public IOContext get_Context();
    [CompilerGeneratedAttribute]
private void set_Context(IOContext value);
}
public class Lucene.Net.Index.SerialMergeScheduler : MergeScheduler {
    public virtual void Merge(IndexWriter writer, MergeTrigger trigger, bool newMergesFound);
    protected virtual void Dispose(bool disposing);
}
public class Lucene.Net.Index.SimpleMergedSegmentWarmer : IndexReaderWarmer {
    private InfoStream infoStream;
    public SimpleMergedSegmentWarmer(InfoStream infoStream);
    public virtual void Warm(AtomicReader reader);
}
public class Lucene.Net.Index.SingleTermsEnum : FilteredTermsEnum {
    private BytesRef singleRef;
    public SingleTermsEnum(TermsEnum tenum, BytesRef termText);
    protected virtual AcceptStatus Accept(BytesRef term);
}
internal class Lucene.Net.Index.SingletonSortedSetDocValues : SortedSetDocValues {
    private SortedDocValues in;
    private int docID;
    private bool set;
    public SortedDocValues SortedDocValues { get; }
    public long ValueCount { get; }
    public SingletonSortedSetDocValues(SortedDocValues in);
    public SortedDocValues get_SortedDocValues();
    public virtual long NextOrd();
    public virtual void SetDocument(int docID);
    public virtual void LookupOrd(long ord, BytesRef result);
    public virtual long get_ValueCount();
    public virtual long LookupTerm(BytesRef key);
}
public class Lucene.Net.Index.SlowCompositeReaderWrapper : AtomicReader {
    private CompositeReader in;
    private Fields fields;
    private IBits liveDocs;
    private IDictionary`2<string, OrdinalMap> cachedOrdMaps;
    public Fields Fields { get; }
    public int NumDocs { get; }
    public int MaxDoc { get; }
    public IBits LiveDocs { get; }
    public FieldInfos FieldInfos { get; }
    public object CoreCacheKey { get; }
    public object CombinedCoreAndDeletesKey { get; }
    private SlowCompositeReaderWrapper(CompositeReader reader);
    public static AtomicReader Wrap(IndexReader reader);
    public virtual string ToString();
    public virtual Fields get_Fields();
    public virtual NumericDocValues GetNumericDocValues(string field);
    public virtual IBits GetDocsWithField(string field);
    public virtual BinaryDocValues GetBinaryDocValues(string field);
    public virtual SortedDocValues GetSortedDocValues(string field);
    public virtual SortedSetDocValues GetSortedSetDocValues(string field);
    public virtual NumericDocValues GetNormValues(string field);
    public virtual Fields GetTermVectors(int docID);
    public virtual int get_NumDocs();
    public virtual int get_MaxDoc();
    public virtual void Document(int docID, StoredFieldVisitor visitor);
    public virtual IBits get_LiveDocs();
    public virtual FieldInfos get_FieldInfos();
    public virtual object get_CoreCacheKey();
    public virtual object get_CombinedCoreAndDeletesKey();
    protected internal virtual void DoClose();
    public virtual void CheckIntegrity();
}
public class Lucene.Net.Index.SnapshotDeletionPolicy : IndexDeletionPolicy {
    protected IDictionary`2<long, int> m_refCounts;
    protected IDictionary`2<long, IndexCommit> m_indexCommits;
    private IndexDeletionPolicy primary;
    protected IndexCommit m_lastCommit;
    private bool initCalled;
    public int SnapshotCount { get; }
    public SnapshotDeletionPolicy(IndexDeletionPolicy primary);
    public virtual void OnCommit(IList`1<T> commits);
    public virtual void OnInit(IList`1<T> commits);
    public virtual void Release(IndexCommit commit);
    protected internal virtual void ReleaseGen(long gen);
    protected internal virtual void IncRef(IndexCommit ic);
    public virtual IndexCommit Snapshot();
    public virtual IList`1<IndexCommit> GetSnapshots();
    public virtual int get_SnapshotCount();
    public virtual IndexCommit GetIndexCommit(long gen);
    public virtual object Clone();
    private IList`1<IndexCommit> WrapCommits(IList`1<T> commits);
}
public abstract class Lucene.Net.Index.SortedDocValues : BinaryDocValues {
    public int ValueCount { get; }
    public abstract virtual int GetOrd(int docID);
    public abstract virtual void LookupOrd(int ord, BytesRef result);
    public abstract virtual int get_ValueCount();
    public virtual void Get(int docID, BytesRef result);
    public virtual int LookupTerm(BytesRef key);
    public virtual TermsEnum GetTermsEnum();
}
internal class Lucene.Net.Index.SortedDocValuesTermsEnum : TermsEnum {
    private SortedDocValues values;
    private int currentOrd;
    private BytesRef term;
    public BytesRef Term { get; }
    public long Ord { get; }
    public int DocFreq { get; }
    public long TotalTermFreq { get; }
    public IComparer`1<BytesRef> Comparer { get; }
    public SortedDocValuesTermsEnum(SortedDocValues values);
    public virtual SeekStatus SeekCeil(BytesRef text);
    public virtual bool SeekExact(BytesRef text);
    public virtual void SeekExact(long ord);
    public virtual bool MoveNext();
    [ObsoleteAttribute("Use MoveNext() and Term instead. This method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public virtual BytesRef Next();
    public virtual BytesRef get_Term();
    public virtual long get_Ord();
    public virtual int get_DocFreq();
    public virtual long get_TotalTermFreq();
    public virtual DocsEnum Docs(IBits liveDocs, DocsEnum reuse, DocsFlags flags);
    public virtual DocsAndPositionsEnum DocsAndPositions(IBits liveDocs, DocsAndPositionsEnum reuse, DocsAndPositionsFlags flags);
    public virtual IComparer`1<BytesRef> get_Comparer();
    public virtual void SeekExact(BytesRef term, TermState state);
    public virtual TermState GetTermState();
}
internal class Lucene.Net.Index.SortedDocValuesWriter : DocValuesWriter {
    internal BytesRefHash hash;
    private AppendingDeltaPackedInt64Buffer pending;
    private Counter iwBytesUsed;
    private long bytesUsed;
    private FieldInfo fieldInfo;
    private static int EMPTY_ORD;
    public SortedDocValuesWriter(FieldInfo fieldInfo, Counter iwBytesUsed);
    public virtual void AddValue(int docID, BytesRef value);
    public virtual void Finish(int maxDoc);
    private void AddOneValue(BytesRef value);
    private void UpdateBytesUsed();
    public virtual void Flush(SegmentWriteState state, DocValuesConsumer dvConsumer);
    public virtual void Abort();
    [IteratorStateMachineAttribute("Lucene.Net.Index.SortedDocValuesWriter/<GetBytesRefEnumberable>d__13")]
private IEnumerable`1<BytesRef> GetBytesRefEnumberable(int valueCount, Int32[] sortedValues);
    [IteratorStateMachineAttribute("Lucene.Net.Index.SortedDocValuesWriter/<GetOrdsEnumberable>d__14")]
private IEnumerable`1<Nullable`1<long>> GetOrdsEnumberable(int maxDoc, Int32[] ordMap);
}
public abstract class Lucene.Net.Index.SortedSetDocValues : object {
    public static long NO_MORE_ORDS;
    public long ValueCount { get; }
    private static SortedSetDocValues();
    public abstract virtual long NextOrd();
    public abstract virtual void SetDocument(int docID);
    public abstract virtual void LookupOrd(long ord, BytesRef result);
    public abstract virtual long get_ValueCount();
    public virtual long LookupTerm(BytesRef key);
    public virtual TermsEnum GetTermsEnum();
}
internal class Lucene.Net.Index.SortedSetDocValuesTermsEnum : TermsEnum {
    private SortedSetDocValues values;
    private long currentOrd;
    private BytesRef term;
    public BytesRef Term { get; }
    public long Ord { get; }
    public int DocFreq { get; }
    public long TotalTermFreq { get; }
    public IComparer`1<BytesRef> Comparer { get; }
    public SortedSetDocValuesTermsEnum(SortedSetDocValues values);
    public virtual SeekStatus SeekCeil(BytesRef text);
    public virtual bool SeekExact(BytesRef text);
    public virtual void SeekExact(long ord);
    public virtual bool MoveNext();
    [ObsoleteAttribute("Use MoveNext() and Term instead. This method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public virtual BytesRef Next();
    public virtual BytesRef get_Term();
    public virtual long get_Ord();
    public virtual int get_DocFreq();
    public virtual long get_TotalTermFreq();
    public virtual DocsEnum Docs(IBits liveDocs, DocsEnum reuse, DocsFlags flags);
    public virtual DocsAndPositionsEnum DocsAndPositions(IBits liveDocs, DocsAndPositionsEnum reuse, DocsAndPositionsFlags flags);
    public virtual IComparer`1<BytesRef> get_Comparer();
    public virtual void SeekExact(BytesRef term, TermState state);
    public virtual TermState GetTermState();
}
internal class Lucene.Net.Index.SortedSetDocValuesWriter : DocValuesWriter {
    internal BytesRefHash hash;
    private AppendingPackedInt64Buffer pending;
    private AppendingDeltaPackedInt64Buffer pendingCounts;
    private Counter iwBytesUsed;
    private long bytesUsed;
    private FieldInfo fieldInfo;
    private int currentDoc;
    private Int32[] currentValues;
    private int currentUpto;
    private int maxCount;
    public SortedSetDocValuesWriter(FieldInfo fieldInfo, Counter iwBytesUsed);
    public virtual void AddValue(int docID, BytesRef value);
    private void FinishCurrentDoc();
    public virtual void Finish(int maxDoc);
    private void AddOneValue(BytesRef value);
    private void UpdateBytesUsed();
    public virtual void Flush(SegmentWriteState state, DocValuesConsumer dvConsumer);
    public virtual void Abort();
    [IteratorStateMachineAttribute("Lucene.Net.Index.SortedSetDocValuesWriter/<GetBytesRefEnumberable>d__18")]
private IEnumerable`1<BytesRef> GetBytesRefEnumberable(int valueCount, Int32[] sortedValues);
    [IteratorStateMachineAttribute("Lucene.Net.Index.SortedSetDocValuesWriter/<GetOrdsEnumberable>d__19")]
private IEnumerable`1<Nullable`1<long>> GetOrdsEnumberable(int maxDoc);
    [IteratorStateMachineAttribute("Lucene.Net.Index.SortedSetDocValuesWriter/<GetOrdCountEnumberable>d__20")]
private IEnumerable`1<Nullable`1<long>> GetOrdCountEnumberable(int maxCountPerDoc, Int32[] ordMap);
}
internal class Lucene.Net.Index.StandardDirectoryReader : DirectoryReader {
    private IndexWriter writer;
    private SegmentInfos segmentInfos;
    private int termInfosIndexDivisor;
    private bool applyAllDeletes;
    public long Version { get; }
    public IndexCommit IndexCommit { get; }
    internal StandardDirectoryReader(Directory directory, AtomicReader[] readers, IndexWriter writer, SegmentInfos sis, int termInfosIndexDivisor, bool applyAllDeletes);
    internal static DirectoryReader Open(Directory directory, IndexCommit commit, int termInfosIndexDivisor);
    internal static DirectoryReader Open(IndexWriter writer, SegmentInfos infos, bool applyAllDeletes);
    private static DirectoryReader Open(Directory directory, SegmentInfos infos, IList`1<IndexReader> oldReaders, int termInfosIndexDivisor);
    public virtual string ToString();
    protected internal virtual DirectoryReader DoOpenIfChanged();
    protected internal virtual DirectoryReader DoOpenIfChanged(IndexCommit commit);
    protected internal virtual DirectoryReader DoOpenIfChanged(IndexWriter writer, bool applyAllDeletes);
    private DirectoryReader DoOpenFromWriter(IndexCommit commit);
    private DirectoryReader DoOpenNoWriter(IndexCommit commit);
    private DirectoryReader DoOpenFromCommit(IndexCommit commit);
    internal DirectoryReader DoOpenIfChanged(SegmentInfos infos);
    public virtual long get_Version();
    public virtual bool IsCurrent();
    protected internal virtual void DoClose();
    public virtual IndexCommit get_IndexCommit();
}
internal abstract class Lucene.Net.Index.StoredFieldsConsumer : object {
    public abstract virtual void AddField(int docID, IIndexableField field, FieldInfo fieldInfo);
    public abstract virtual void Flush(SegmentWriteState state);
    public abstract virtual void Abort();
    public abstract virtual void StartDocument();
    internal abstract virtual void FinishDocument();
}
internal class Lucene.Net.Index.StoredFieldsProcessor : StoredFieldsConsumer {
    internal StoredFieldsWriter fieldsWriter;
    internal DocumentsWriterPerThread docWriter;
    internal int lastDocID;
    internal DocState docState;
    internal Codec codec;
    private int numStoredFields;
    private IIndexableField[] storedFields;
    private FieldInfo[] fieldInfos;
    public StoredFieldsProcessor(DocumentsWriterPerThread docWriter);
    public void Reset();
    public virtual void StartDocument();
    public virtual void Flush(SegmentWriteState state);
    private void InitFieldsWriter(IOContext context);
    public virtual void Abort();
    internal void Fill(int docID);
    internal virtual void FinishDocument();
    public virtual void AddField(int docID, IIndexableField field, FieldInfo fieldInfo);
}
public abstract class Lucene.Net.Index.StoredFieldVisitor : object {
    public virtual void BinaryField(FieldInfo fieldInfo, Byte[] value);
    public virtual void StringField(FieldInfo fieldInfo, string value);
    public virtual void Int32Field(FieldInfo fieldInfo, int value);
    public virtual void Int64Field(FieldInfo fieldInfo, long value);
    public virtual void SingleField(FieldInfo fieldInfo, float value);
    public virtual void DoubleField(FieldInfo fieldInfo, double value);
    public abstract virtual Status NeedsField(FieldInfo fieldInfo);
}
[ObsoleteAttribute("Use ConcurrentMergeScheduler instead. This class will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public class Lucene.Net.Index.TaskMergeScheduler : MergeScheduler {
    public static string COMPONENT_NAME;
    private TaskScheduler _taskScheduler;
    private ReaderWriterLockSlim _lock;
    private ManualResetEventSlim _manualResetEvent;
    private IList`1<MergeThread> _mergeThreads;
    private int _mergeThreadCount;
    private Directory _directory;
    private IndexWriter _writer;
    [CompilerGeneratedAttribute]
private int <MaxThreadCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxMergeCount>k__BackingField;
    private bool suppressExceptions;
    public int MaxThreadCount { get; private set; }
    public int MaxMergeCount { get; private set; }
    public int MergeThreadPriority { get; }
    protected bool Verbose { get; }
    private int MergeThreadCount { get; }
    public sealed virtual void SetMaxMergesAndThreads(int maxMergeCount, int maxThreadCount);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxThreadCount();
    [CompilerGeneratedAttribute]
private void set_MaxThreadCount(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxMergeCount();
    [CompilerGeneratedAttribute]
private void set_MaxMergeCount(int value);
    public sealed virtual int get_MergeThreadPriority();
    public sealed virtual void SetMergeThreadPriority(int priority);
    private void UpdateMergeThreads();
    protected bool get_Verbose();
    protected virtual void Message(string message);
    protected virtual void Dispose(bool disposing);
    public virtual void Sync();
    private int get_MergeThreadCount();
    public virtual void Merge(IndexWriter writer, MergeTrigger trigger, bool newMergesFound);
    protected virtual void DoMerge(OneMerge merge);
    private void OnMergeThreadCompleted(object sender, EventArgs e);
    private MergeThread CreateTask(IndexWriter writer, OneMerge merge);
    protected virtual void HandleMergeException(Exception exc);
    public virtual void SetSuppressExceptions();
    public virtual void ClearSuppressExceptions();
    public virtual string ToString();
    public virtual object Clone();
    [CompilerGeneratedAttribute]
private bool <Sync>b__26_0(Exception ex);
}
public class Lucene.Net.Index.Term : object {
    [CompilerGeneratedAttribute]
private string <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private BytesRef <Bytes>k__BackingField;
    public string Field { get; internal set; }
    public string Text { get; }
    public BytesRef Bytes { get; internal set; }
    public Term(string fld, BytesRef bytes);
    public Term(string fld, string text);
    public Term(string fld);
    [CompilerGeneratedAttribute]
public string get_Field();
    [CompilerGeneratedAttribute]
internal void set_Field(string value);
    public string get_Text();
    public static string ToString(BytesRef termText);
    [CompilerGeneratedAttribute]
public BytesRef get_Bytes();
    [CompilerGeneratedAttribute]
internal void set_Bytes(BytesRef value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(Term other);
    internal void Set(string fld, BytesRef bytes);
    public sealed virtual bool Equals(Term other);
    public virtual string ToString();
}
public class Lucene.Net.Index.TermContext : object {
    [CompilerGeneratedAttribute]
private IndexReaderContext <TopReaderContext>k__BackingField;
    private TermState[] states;
    private int docFreq;
    private long totalTermFreq;
    public IndexReaderContext TopReaderContext { get; private set; }
    public long TotalTermFreq { get; }
    public int DocFreq { get; internal set; }
    public TermContext(IndexReaderContext context);
    public TermContext(IndexReaderContext context, TermState state, int ord, int docFreq, long totalTermFreq);
    [CompilerGeneratedAttribute]
public IndexReaderContext get_TopReaderContext();
    [CompilerGeneratedAttribute]
private void set_TopReaderContext(IndexReaderContext value);
    public static TermContext Build(IndexReaderContext context, Term term);
    public void Clear();
    public void Register(TermState state, int ord, int docFreq, long totalTermFreq);
    public TermState Get(int ord);
    public long get_TotalTermFreq();
    public int get_DocFreq();
    internal void set_DocFreq(int value);
}
[ExtensionAttribute]
public static class Lucene.Net.Index.TermExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use Text property instead. This method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public static string Text(Term term);
}
public abstract class Lucene.Net.Index.Terms : object {
    public static Terms[] EMPTY_ARRAY;
    public IComparer`1<BytesRef> Comparer { get; }
    public long Count { get; }
    public long SumTotalTermFreq { get; }
    public long SumDocFreq { get; }
    public int DocCount { get; }
    public bool HasFreqs { get; }
    public bool HasOffsets { get; }
    public bool HasPositions { get; }
    public bool HasPayloads { get; }
    private static Terms();
    public abstract virtual TermsEnum GetEnumerator();
    public virtual TermsEnum GetEnumerator(TermsEnum reuse);
    [ObsoleteAttribute("Use GetEnumerator() or GetEnumerator(TermsEnum). This method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public virtual TermsEnum GetIterator(TermsEnum reuse);
    public virtual TermsEnum Intersect(CompiledAutomaton compiled, BytesRef startTerm);
    public abstract virtual IComparer`1<BytesRef> get_Comparer();
    public abstract virtual long get_Count();
    public abstract virtual long get_SumTotalTermFreq();
    public abstract virtual long get_SumDocFreq();
    public abstract virtual int get_DocCount();
    public abstract virtual bool get_HasFreqs();
    public abstract virtual bool get_HasOffsets();
    public abstract virtual bool get_HasPositions();
    public abstract virtual bool get_HasPayloads();
}
public abstract class Lucene.Net.Index.TermsEnum : object {
    private AttributeSource atts;
    public static TermsEnum EMPTY;
    public IComparer`1<BytesRef> Comparer { get; }
    [EditorBrowsableAttribute("1")]
public TermsEnum Current { get; }
    private BytesRef Lucene.Net.Util.IBytesRefEnumerator.Current { get; }
    public AttributeSource Attributes { get; }
    public BytesRef Term { get; }
    public long Ord { get; }
    public int DocFreq { get; }
    public long TotalTermFreq { get; }
    private static TermsEnum();
    public abstract virtual IComparer`1<BytesRef> get_Comparer();
    [ObsoleteAttribute("Use MoveNext() and Term instead. This method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public abstract virtual BytesRef Next();
    public TermsEnum get_Current();
    private sealed virtual override BytesRef Lucene.Net.Util.IBytesRefEnumerator.get_Current();
    public abstract virtual bool MoveNext();
    public virtual AttributeSource get_Attributes();
    public virtual bool SeekExact(BytesRef text);
    public abstract virtual SeekStatus SeekCeil(BytesRef text);
    public abstract virtual void SeekExact(long ord);
    public virtual void SeekExact(BytesRef term, TermState state);
    public abstract virtual BytesRef get_Term();
    public abstract virtual long get_Ord();
    public abstract virtual int get_DocFreq();
    public abstract virtual long get_TotalTermFreq();
    public DocsEnum Docs(IBits liveDocs, DocsEnum reuse);
    public abstract virtual DocsEnum Docs(IBits liveDocs, DocsEnum reuse, DocsFlags flags);
    public DocsAndPositionsEnum DocsAndPositions(IBits liveDocs, DocsAndPositionsEnum reuse);
    public abstract virtual DocsAndPositionsEnum DocsAndPositions(IBits liveDocs, DocsAndPositionsEnum reuse, DocsAndPositionsFlags flags);
    public virtual TermState GetTermState();
}
internal class Lucene.Net.Index.TermsHash : InvertedDocConsumer {
    internal TermsHashConsumer consumer;
    internal TermsHash nextTermsHash;
    internal Int32BlockPool intPool;
    internal ByteBlockPool bytePool;
    internal ByteBlockPool termBytePool;
    internal Counter bytesUsed;
    internal bool primary;
    internal DocState docState;
    internal BytesRef tr1;
    internal BytesRef tr2;
    internal BytesRef termBytesRef;
    internal bool trackAllocations;
    public TermsHash(DocumentsWriterPerThread docWriter, TermsHashConsumer consumer, bool trackAllocations, TermsHash nextTermsHash);
    public virtual void Abort();
    internal void Reset();
    internal virtual void Flush(IDictionary`2<string, InvertedDocConsumerPerField> fieldsToFlush, SegmentWriteState state);
    internal virtual InvertedDocConsumerPerField AddField(DocInverterPerField docInverterPerField, FieldInfo fieldInfo);
    internal virtual void FinishDocument();
    internal virtual void StartDocument();
}
internal abstract class Lucene.Net.Index.TermsHashConsumer : object {
    public abstract virtual void Flush(IDictionary`2<string, TermsHashConsumerPerField> fieldsToFlush, SegmentWriteState state);
    public abstract virtual void Abort();
    internal abstract virtual void StartDocument();
    internal abstract virtual void FinishDocument(TermsHash termsHash);
    public abstract virtual TermsHashConsumerPerField AddField(TermsHashPerField termsHashPerField, FieldInfo fieldInfo);
}
internal abstract class Lucene.Net.Index.TermsHashConsumerPerField : object {
    internal int StreamCount { get; }
    internal abstract virtual bool Start(IIndexableField[] fields, int count);
    internal abstract virtual void Finish();
    [ExceptionToNetNumericConventionAttribute]
internal abstract virtual void SkippingLongTerm();
    internal abstract virtual void Start(IIndexableField field);
    internal abstract virtual void NewTerm(int termID);
    internal abstract virtual void AddTerm(int termID);
    internal abstract virtual int get_StreamCount();
    internal abstract virtual ParallelPostingsArray CreatePostingsArray(int size);
}
internal class Lucene.Net.Index.TermsHashPerField : InvertedDocConsumerPerField {
    private static int HASH_INIT_SIZE;
    internal TermsHashConsumerPerField consumer;
    internal TermsHash termsHash;
    internal TermsHashPerField nextPerField;
    internal DocState docState;
    internal FieldInvertState fieldState;
    internal ITermToBytesRefAttribute termAtt;
    internal BytesRef termBytesRef;
    internal Int32BlockPool intPool;
    internal ByteBlockPool bytePool;
    internal ByteBlockPool termBytePool;
    internal int streamCount;
    internal int numPostingInt;
    internal FieldInfo fieldInfo;
    internal BytesRefHash bytesHash;
    internal ParallelPostingsArray postingsArray;
    private Counter bytesUsed;
    private bool doCall;
    private bool doNextCall;
    internal Int32[] intUptos;
    internal int intUptoStart;
    public TermsHashPerField(DocInverterPerField docInverterPerField, TermsHash termsHash, TermsHash nextTermsHash, FieldInfo fieldInfo);
    internal void ShrinkHash();
    public void Reset();
    public virtual void Abort();
    public void InitReader(ByteSliceReader reader, int termID, int stream);
    public Int32[] SortPostings(IComparer`1<BytesRef> termComp);
    internal virtual void Start(IIndexableField f);
    internal virtual bool Start(IIndexableField[] fields, int count);
    public void Add(int textStart);
    internal virtual void Add();
    internal void WriteByte(int stream, byte b);
    public void WriteBytes(int stream, Byte[] b, int offset, int len);
    internal void WriteVInt32(int stream, int i);
    internal virtual void Finish();
}
public abstract class Lucene.Net.Index.TermState : object {
    public abstract virtual void CopyFrom(TermState other);
    public virtual object Clone();
    public virtual string ToString();
}
internal class Lucene.Net.Index.TermVectorsConsumer : TermsHashConsumer {
    internal TermVectorsWriter writer;
    internal DocumentsWriterPerThread docWriter;
    internal DocState docState;
    internal BytesRef flushTerm;
    internal ByteSliceReader vectorSliceReaderPos;
    internal ByteSliceReader vectorSliceReaderOff;
    internal bool hasVectors;
    internal int numVectorFields;
    internal int lastDocID;
    private TermVectorsConsumerPerField[] perFields;
    internal string lastVectorFieldName;
    public TermVectorsConsumer(DocumentsWriterPerThread docWriter);
    public virtual void Flush(IDictionary`2<string, TermsHashConsumerPerField> fieldsToFlush, SegmentWriteState state);
    internal void Fill(int docID);
    private void InitTermVectorsWriter();
    internal virtual void FinishDocument(TermsHash termsHash);
    public virtual void Abort();
    internal void Reset();
    public virtual TermsHashConsumerPerField AddField(TermsHashPerField termsHashPerField, FieldInfo fieldInfo);
    internal void AddFieldToFlush(TermVectorsConsumerPerField fieldToFlush);
    internal virtual void StartDocument();
    internal bool ClearLastVectorFieldName();
    internal bool VectorFieldsInOrder(FieldInfo fi);
}
internal class Lucene.Net.Index.TermVectorsConsumerPerField : TermsHashConsumerPerField {
    internal TermsHashPerField termsHashPerField;
    internal TermVectorsConsumer termsWriter;
    internal FieldInfo fieldInfo;
    internal DocState docState;
    internal FieldInvertState fieldState;
    internal bool doVectors;
    internal bool doVectorPositions;
    internal bool doVectorOffsets;
    internal bool doVectorPayloads;
    internal int maxNumPostings;
    internal IOffsetAttribute offsetAttribute;
    internal IPayloadAttribute payloadAttribute;
    internal bool hasPayloads;
    internal int StreamCount { get; }
    public TermVectorsConsumerPerField(TermsHashPerField termsHashPerField, TermVectorsConsumer termsWriter, FieldInfo fieldInfo);
    internal virtual int get_StreamCount();
    internal virtual bool Start(IIndexableField[] fields, int count);
    public void Abort();
    internal virtual void Finish();
    internal void FinishDocument();
    internal void ShrinkHash();
    internal virtual void Start(IIndexableField f);
    internal void WriteProx(TermVectorsPostingsArray postings, int termID);
    internal virtual void NewTerm(int termID);
    internal virtual void AddTerm(int termID);
    [ExceptionToNetNumericConventionAttribute]
internal virtual void SkippingLongTerm();
    internal virtual ParallelPostingsArray CreatePostingsArray(int size);
}
public class Lucene.Net.Index.TieredMergePolicy : MergePolicy {
    public static double DEFAULT_NO_CFS_RATIO;
    private int maxMergeAtOnce;
    private long maxMergedSegmentBytes;
    private int maxMergeAtOnceExplicit;
    private long floorSegmentBytes;
    private double segsPerTier;
    private double forceMergeDeletesPctAllowed;
    private double reclaimDeletesWeight;
    public int MaxMergeAtOnce { get; public set; }
    public int MaxMergeAtOnceExplicit { get; public set; }
    public double MaxMergedSegmentMB { get; public set; }
    public double ReclaimDeletesWeight { get; public set; }
    public double FloorSegmentMB { get; public set; }
    public double ForceMergeDeletesPctAllowed { get; public set; }
    public double SegmentsPerTier { get; public set; }
    private static TieredMergePolicy();
    public virtual int get_MaxMergeAtOnce();
    public virtual void set_MaxMergeAtOnce(int value);
    public virtual int get_MaxMergeAtOnceExplicit();
    public virtual void set_MaxMergeAtOnceExplicit(int value);
    public virtual double get_MaxMergedSegmentMB();
    public virtual void set_MaxMergedSegmentMB(double value);
    public virtual double get_ReclaimDeletesWeight();
    public virtual void set_ReclaimDeletesWeight(double value);
    public virtual double get_FloorSegmentMB();
    public virtual void set_FloorSegmentMB(double value);
    public virtual double get_ForceMergeDeletesPctAllowed();
    public virtual void set_ForceMergeDeletesPctAllowed(double value);
    public virtual double get_SegmentsPerTier();
    public virtual void set_SegmentsPerTier(double value);
    public virtual MergeSpecification FindMerges(MergeTrigger mergeTrigger, SegmentInfos infos);
    protected virtual MergeScore Score(IList`1<SegmentCommitInfo> candidate, bool hitTooLarge, long mergingBytes);
    public virtual MergeSpecification FindForcedMerges(SegmentInfos infos, int maxSegmentCount, IDictionary`2<SegmentCommitInfo, bool> segmentsToMerge);
    public virtual MergeSpecification FindForcedDeletesMerges(SegmentInfos infos);
    protected virtual void Dispose(bool disposing);
    private long FloorSize(long bytes);
    private bool Verbose();
    private void Message(string message);
    public virtual string ToString();
}
public class Lucene.Net.Index.TrackingIndexWriter : object {
    private IndexWriter writer;
    private AtomicInt64 indexingGen;
    public long Generation { get; }
    public IndexWriter IndexWriter { get; }
    public TrackingIndexWriter(IndexWriter writer);
    public virtual long UpdateDocument(Term t, IEnumerable`1<IIndexableField> d, Analyzer a);
    public virtual long UpdateDocument(Term t, IEnumerable`1<IIndexableField> d);
    public virtual long UpdateDocuments(Term t, IEnumerable`1<IEnumerable`1<IIndexableField>> docs, Analyzer a);
    public virtual long UpdateDocuments(Term t, IEnumerable`1<IEnumerable`1<IIndexableField>> docs);
    public virtual long DeleteDocuments(Term t);
    public virtual long DeleteDocuments(Term[] terms);
    public virtual long DeleteDocuments(Query q);
    public virtual long DeleteDocuments(Query[] queries);
    public virtual long DeleteAll();
    public virtual long AddDocument(IEnumerable`1<IIndexableField> d, Analyzer a);
    public virtual long AddDocuments(IEnumerable`1<IEnumerable`1<IIndexableField>> docs, Analyzer a);
    public virtual long AddDocument(IEnumerable`1<IIndexableField> d);
    public virtual long AddDocuments(IEnumerable`1<IEnumerable`1<IIndexableField>> docs);
    public virtual long AddIndexes(Directory[] dirs);
    public virtual long AddIndexes(IndexReader[] readers);
    public virtual long get_Generation();
    public virtual IndexWriter get_IndexWriter();
    public virtual long GetAndIncrementGeneration();
    public virtual long TryDeleteDocument(IndexReader reader, int docID);
}
public class Lucene.Net.Index.TwoPhaseCommitTool : object {
    private static void Rollback(ITwoPhaseCommit[] objects);
    public static void Execute(ITwoPhaseCommit[] objects);
}
internal class Lucene.Net.Index.TwoStoredFieldsConsumers : StoredFieldsConsumer {
    private StoredFieldsConsumer first;
    private StoredFieldsConsumer second;
    public TwoStoredFieldsConsumers(StoredFieldsConsumer first, StoredFieldsConsumer second);
    public virtual void AddField(int docID, IIndexableField field, FieldInfo fieldInfo);
    public virtual void Flush(SegmentWriteState state);
    public virtual void Abort();
    public virtual void StartDocument();
    internal virtual void FinishDocument();
}
public class Lucene.Net.Index.UpgradeIndexMergePolicy : MergePolicy {
    protected MergePolicy m_base;
    public UpgradeIndexMergePolicy(MergePolicy base);
    protected virtual bool ShouldUpgradeSegment(SegmentCommitInfo si);
    public virtual void SetIndexWriter(IndexWriter writer);
    public virtual MergeSpecification FindMerges(MergeTrigger mergeTrigger, SegmentInfos segmentInfos);
    public virtual MergeSpecification FindForcedMerges(SegmentInfos segmentInfos, int maxSegmentCount, IDictionary`2<SegmentCommitInfo, bool> segmentsToMerge);
    public virtual MergeSpecification FindForcedDeletesMerges(SegmentInfos segmentInfos);
    public virtual bool UseCompoundFile(SegmentInfos segments, SegmentCommitInfo newSegment);
    protected virtual void Dispose(bool disposing);
    public virtual string ToString();
    private bool Verbose();
    private void Message(string message);
}
[ExtensionAttribute]
internal static class Lucene.Net.Runtime.CompilerServices.ConditionalWeakTableExtensions : object {
    [ExtensionAttribute]
public static void AddOrUpdate(ConditionalWeakTable`2<TKey, TValue> table, TKey key, TValue value);
}
public class Lucene.Net.Search.AutomatonQuery : MultiTermQuery {
    protected Automaton m_automaton;
    protected CompiledAutomaton m_compiled;
    protected Term m_term;
    public Automaton Automaton { get; }
    public AutomatonQuery(Term term, Automaton automaton);
    protected virtual TermsEnum GetTermsEnum(Terms terms, AttributeSource atts);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString(string field);
    public virtual Automaton get_Automaton();
}
public class Lucene.Net.Search.BitsFilteredDocIdSet : FilteredDocIdSet {
    private IBits acceptDocs;
    public BitsFilteredDocIdSet(DocIdSet innerSet, IBits acceptDocs);
    public static DocIdSet Wrap(DocIdSet set, IBits acceptDocs);
    protected virtual bool Match(int docid);
}
public class Lucene.Net.Search.BooleanClause : object {
    private Query query;
    private Occur occur;
    public Occur Occur { get; public set; }
    public Query Query { get; public set; }
    public bool IsProhibited { get; }
    public bool IsRequired { get; }
    public BooleanClause(Query query, Occur occur);
    public static string ToString(Occur occur);
    public virtual Occur get_Occur();
    public virtual void set_Occur(Occur value);
    public virtual Query get_Query();
    public virtual void set_Query(Query value);
    public virtual bool get_IsProhibited();
    public virtual bool get_IsRequired();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(BooleanClause other);
    public virtual string ToString();
}
public class Lucene.Net.Search.BooleanQuery : Query {
    private static int maxClauseCount;
    private IList`1<BooleanClause> clauses;
    private bool disableCoord;
    protected int m_minNrShouldMatch;
    public static int MaxClauseCount { get; public set; }
    public bool CoordDisabled { get; }
    public int MinimumNumberShouldMatch { get; public set; }
    public IList`1<BooleanClause> Clauses { get; }
    public BooleanQuery(bool disableCoord);
    private static BooleanQuery();
    public static int get_MaxClauseCount();
    public static void set_MaxClauseCount(int value);
    public virtual bool get_CoordDisabled();
    public virtual int get_MinimumNumberShouldMatch();
    public virtual void set_MinimumNumberShouldMatch(int value);
    public virtual void Add(Query query, Occur occur);
    public virtual void Add(BooleanClause clause);
    public virtual BooleanClause[] GetClauses();
    public virtual IList`1<BooleanClause> get_Clauses();
    public sealed virtual IEnumerator`1<BooleanClause> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual Weight CreateWeight(IndexSearcher searcher);
    public virtual Query Rewrite(IndexReader reader);
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual object Clone();
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal class Lucene.Net.Search.BooleanScorer : BulkScorer {
    private SubScorer scorers;
    private BucketTable bucketTable;
    private Single[] coordFactors;
    private int minNrShouldMatch;
    private int end;
    private Bucket current;
    private static int PROHIBITED_MASK;
    internal BooleanScorer(BooleanWeight weight, bool disableCoord, int minNrShouldMatch, IList`1<BulkScorer> optionalScorers, IList`1<BulkScorer> prohibitedScorers, int maxCoord);
    public virtual bool Score(ICollector collector, int max);
    public virtual string ToString();
}
internal class Lucene.Net.Search.BooleanScorer2 : Scorer {
    private IList`1<Scorer> requiredScorers;
    private IList`1<Scorer> optionalScorers;
    private IList`1<Scorer> prohibitedScorers;
    private Coordinator coordinator;
    private Scorer countingSumScorer;
    private int minNrShouldMatch;
    private int doc;
    public int DocID { get; }
    public int Freq { get; }
    public BooleanScorer2(BooleanWeight weight, bool disableCoord, int minNrShouldMatch, IList`1<Scorer> required, IList`1<Scorer> prohibited, IList`1<Scorer> optional, int maxCoord);
    private Scorer CountingDisjunctionSumScorer(IList`1<Scorer> scorers, int minNrShouldMatch);
    private Scorer CountingConjunctionSumScorer(IList`1<Scorer> requiredScorers);
    private Scorer DualConjunctionSumScorer(Scorer req1, Scorer req2);
    private Scorer MakeCountingSumScorer();
    private Scorer MakeCountingSumScorerNoReq();
    private Scorer MakeCountingSumScorerSomeReq();
    private Scorer AddProhibitedScorers(Scorer requiredCountingSumScorer);
    public virtual int get_DocID();
    public virtual int NextDoc();
    public virtual float GetScore();
    public virtual int get_Freq();
    public virtual int Advance(int target);
    public virtual long GetCost();
    public virtual ICollection`1<ChildScorer> GetChildren();
}
public class Lucene.Net.Search.BoostAttribute : Attribute {
    private float boost;
    public float Boost { get; public set; }
    public sealed virtual float get_Boost();
    public sealed virtual void set_Boost(float value);
    public virtual void Clear();
    public virtual void CopyTo(IAttribute target);
}
public abstract class Lucene.Net.Search.BulkScorer : object {
    public virtual void Score(ICollector collector);
    public abstract virtual bool Score(ICollector collector, int max);
}
public abstract class Lucene.Net.Search.CachingCollector : object {
    private static int MAX_ARRAY_SIZE;
    private static int INITIAL_ARRAY_SIZE;
    private static Int32[] EMPTY_INT32_ARRAY;
    protected ICollector m_other;
    protected int m_maxDocsToCache;
    private IList`1<SegStart> m_cachedSegs;
    protected IList`1<Int32[]> m_cachedDocs;
    private AtomicReaderContext lastReaderContext;
    protected Int32[] m_curDocs;
    protected int m_upto;
    protected int m_base;
    protected int m_lastDocBase;
    public bool AcceptsDocsOutOfOrder { get; }
    public bool IsCached { get; }
    private CachingCollector(ICollector other, double maxRAMMB, bool cacheScores);
    private CachingCollector(ICollector other, int maxDocsToCache);
    private static CachingCollector();
    public static CachingCollector Create(bool acceptDocsOutOfOrder, bool cacheScores, double maxRAMMB);
    public static CachingCollector Create(ICollector other, bool cacheScores, double maxRAMMB);
    public static CachingCollector Create(ICollector other, bool cacheScores, int maxDocsToCache);
    public virtual bool get_AcceptsDocsOutOfOrder();
    public virtual bool get_IsCached();
    public virtual void SetNextReader(AtomicReaderContext context);
    public abstract virtual void SetScorer(Scorer scorer);
    public abstract virtual void Collect(int doc);
    internal virtual void ReplayInit(ICollector other);
    public abstract virtual void Replay(ICollector other);
}
public class Lucene.Net.Search.CachingWrapperFilter : Filter {
    private Filter filter;
    private IEventAggregator eventAggregator;
    private ConditionalWeakTable`2<object, DocIdSet> cache;
    internal int hitCount;
    internal int missCount;
    protected static DocIdSet EMPTY_DOCIDSET;
    public Filter Filter { get; }
    public CachingWrapperFilter(Filter filter);
    private static CachingWrapperFilter();
    public virtual Filter get_Filter();
    protected virtual DocIdSet DocIdSetToCache(DocIdSet docIdSet, AtomicReader reader);
    protected virtual DocIdSet CacheImpl(DocIdSetIterator iterator, AtomicReader reader);
    public virtual DocIdSet GetDocIdSet(AtomicReaderContext context, IBits acceptDocs);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual long GetSizeInBytes();
}
public class Lucene.Net.Search.CollectionStatistics : object {
    private string field;
    private long maxDoc;
    private long docCount;
    private long sumTotalTermFreq;
    private long sumDocFreq;
    public string Field { get; }
    public long MaxDoc { get; }
    public long DocCount { get; }
    public long SumTotalTermFreq { get; }
    public long SumDocFreq { get; }
    public CollectionStatistics(string field, long maxDoc, long docCount, long sumTotalTermFreq, long sumDocFreq);
    public string get_Field();
    public long get_MaxDoc();
    public long get_DocCount();
    public long get_SumTotalTermFreq();
    public long get_SumDocFreq();
}
public class Lucene.Net.Search.CollectionTerminatedException : Exception {
    private CollectionTerminatedException(SerializationInfo info, StreamingContext context);
}
public static class Lucene.Net.Search.Collector : object {
    public static ICollector NewAnonymous(Action`1<Scorer> setScorer, Action`1<int> collect, Action`1<AtomicReaderContext> setNextReader, Func`1<bool> acceptsDocsOutOfOrder);
}
public class Lucene.Net.Search.ComplexExplanation : Explanation {
    private Nullable`1<bool> match;
    public Nullable`1<bool> Match { get; public set; }
    public bool IsMatch { get; }
    public ComplexExplanation(bool match, float value, string description);
    public virtual Nullable`1<bool> get_Match();
    public virtual void set_Match(Nullable`1<bool> value);
    public virtual bool get_IsMatch();
    protected virtual string GetSummary();
}
internal class Lucene.Net.Search.ConjunctionScorer : Scorer {
    protected int m_lastDoc;
    protected DocsAndFreqs[] m_docsAndFreqs;
    private DocsAndFreqs lead;
    private float coord;
    public int DocID { get; }
    public int Freq { get; }
    internal ConjunctionScorer(Weight weight, Scorer[] scorers);
    internal ConjunctionScorer(Weight weight, Scorer[] scorers, float coord);
    private int DoNext(int doc);
    public virtual int Advance(int target);
    public virtual int get_DocID();
    public virtual int NextDoc();
    public virtual float GetScore();
    public virtual int get_Freq();
    public virtual long GetCost();
    public virtual ICollection`1<ChildScorer> GetChildren();
}
public class Lucene.Net.Search.ConstantScoreAutoRewrite : TermCollectingRewrite`1<BooleanQuery> {
    public static int DEFAULT_TERM_COUNT_CUTOFF;
    public static double DEFAULT_DOC_COUNT_PERCENT;
    private int termCountCutoff;
    private double docCountPercent;
    public int TermCountCutoff { get; public set; }
    public double DocCountPercent { get; public set; }
    private static ConstantScoreAutoRewrite();
    public virtual int get_TermCountCutoff();
    public virtual void set_TermCountCutoff(int value);
    public virtual double get_DocCountPercent();
    public virtual void set_DocCountPercent(double value);
    protected virtual BooleanQuery GetTopLevelQuery();
    protected virtual void AddClause(BooleanQuery topLevel, Term term, int docFreq, float boost, TermContext states);
    public virtual Query Rewrite(IndexReader reader, MultiTermQuery query);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Lucene.Net.Search.ConstantScoreQuery : Query {
    protected Filter m_filter;
    protected Query m_query;
    public Filter Filter { get; }
    public Query Query { get; }
    public ConstantScoreQuery(Query query);
    public ConstantScoreQuery(Filter filter);
    public virtual Filter get_Filter();
    public virtual Query get_Query();
    public virtual Query Rewrite(IndexReader reader);
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual Weight CreateWeight(IndexSearcher searcher);
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.ControlledRealTimeReopenThread`1 : ThreadJob {
    private ReferenceManager`1<T> manager;
    private long targetMaxStaleNS;
    private long targetMinStaleNS;
    private TrackingIndexWriter writer;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) finish;
    private long waitingGen;
    private long searchingGen;
    private AtomicInt64 refreshStartGen;
    private AtomicBoolean isDisposed;
    protected EventWaitHandle m_notify;
    private EventWaitHandle reopenCond;
    public ControlledRealTimeReopenThread`1(TrackingIndexWriter writer, ReferenceManager`1<T> manager, double targetMaxStaleSec, double targetMinStaleSec);
    private void RefreshDone();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void WaitForGeneration(long targetGen);
    public virtual bool WaitForGeneration(long targetGen, int maxMS);
    public virtual void Run();
}
public class Lucene.Net.Search.DisjunctionMaxQuery : Query {
    private IList`1<Query> disjuncts;
    private float tieBreakerMultiplier;
    public IList`1<Query> Disjuncts { get; }
    public float TieBreakerMultiplier { get; }
    public DisjunctionMaxQuery(float tieBreakerMultiplier);
    public DisjunctionMaxQuery(ICollection`1<Query> disjuncts, float tieBreakerMultiplier);
    public virtual void Add(Query query);
    public virtual void Add(ICollection`1<Query> disjuncts);
    public virtual IEnumerator`1<Query> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IList`1<Query> get_Disjuncts();
    public virtual float get_TieBreakerMultiplier();
    public virtual Weight CreateWeight(IndexSearcher searcher);
    public virtual Query Rewrite(IndexReader reader);
    public virtual object Clone();
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal class Lucene.Net.Search.DisjunctionMaxScorer : DisjunctionScorer {
    private float tieBreakerMultiplier;
    private int freq;
    private float scoreSum;
    private float scoreMax;
    public int Freq { get; }
    public DisjunctionMaxScorer(Weight weight, float tieBreakerMultiplier, Scorer[] subScorers);
    public virtual float GetScore();
    protected virtual void AfterNext();
    private void ScoreAll(int root);
    public virtual int get_Freq();
}
internal abstract class Lucene.Net.Search.DisjunctionScorer : Scorer {
    protected Scorer[] m_subScorers;
    protected int m_doc;
    protected int m_numScorers;
    public int DocID { get; }
    protected DisjunctionScorer(Weight weight, Scorer[] subScorers);
    protected void Heapify();
    protected void HeapAdjust(int root);
    protected void HeapRemoveRoot();
    public sealed virtual ICollection`1<ChildScorer> GetChildren();
    public virtual long GetCost();
    public virtual int get_DocID();
    public virtual int NextDoc();
    public virtual int Advance(int target);
    protected abstract virtual void AfterNext();
}
internal class Lucene.Net.Search.DisjunctionSumScorer : DisjunctionScorer {
    protected internal int m_nrMatchers;
    protected internal double m_score;
    private Single[] coord;
    public int Freq { get; }
    internal DisjunctionSumScorer(Weight weight, Scorer[] subScorers, Single[] coord);
    protected virtual void AfterNext();
    private void CountMatches(int root);
    public virtual float GetScore();
    public virtual int get_Freq();
}
public abstract class Lucene.Net.Search.DocIdSet : object {
    public IBits Bits { get; }
    public bool IsCacheable { get; }
    public abstract virtual DocIdSetIterator GetIterator();
    public virtual IBits get_Bits();
    public virtual bool get_IsCacheable();
    public static DocIdSet NewAnonymous(Func`1<DocIdSetIterator> getIterator);
    public static DocIdSet NewAnonymous(Func`1<DocIdSetIterator> getIterator, Func`1<IBits> bits);
    public static DocIdSet NewAnonymous(Func`1<DocIdSetIterator> getIterator, Func`1<bool> isCacheable);
    public static DocIdSet NewAnonymous(Func`1<DocIdSetIterator> getIterator, Func`1<IBits> bits, Func`1<bool> isCacheable);
}
public abstract class Lucene.Net.Search.DocIdSetIterator : object {
    public static int NO_MORE_DOCS;
    public int DocID { get; }
    public static DocIdSetIterator GetEmpty();
    public abstract virtual int get_DocID();
    public abstract virtual int NextDoc();
    public abstract virtual int Advance(int target);
    protected internal int SlowAdvance(int target);
    public abstract virtual long GetCost();
}
public abstract class Lucene.Net.Search.DocTermOrdsRangeFilter : Filter {
    internal string field;
    internal BytesRef lowerVal;
    internal BytesRef upperVal;
    internal bool includeLower;
    internal bool includeUpper;
    public string Field { get; }
    public bool IncludesLower { get; }
    public bool IncludesUpper { get; }
    public BytesRef LowerVal { get; }
    public BytesRef UpperVal { get; }
    private DocTermOrdsRangeFilter(string field, BytesRef lowerVal, BytesRef upperVal, bool includeLower, bool includeUpper);
    public abstract virtual DocIdSet GetDocIdSet(AtomicReaderContext context, IBits acceptDocs);
    public static DocTermOrdsRangeFilter NewBytesRefRange(string field, BytesRef lowerVal, BytesRef upperVal, bool includeLower, bool includeUpper);
    public sealed virtual string ToString();
    public sealed virtual bool Equals(object o);
    public sealed virtual int GetHashCode();
    public virtual string get_Field();
    public virtual bool get_IncludesLower();
    public virtual bool get_IncludesUpper();
    public virtual BytesRef get_LowerVal();
    public virtual BytesRef get_UpperVal();
}
public class Lucene.Net.Search.DocTermOrdsRewriteMethod : RewriteMethod {
    public virtual Query Rewrite(IndexReader reader, MultiTermQuery query);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Lucene.Net.Search.ExactPhraseScorer : Scorer {
    private int endMinus1;
    private static int CHUNK;
    private int gen;
    private Int32[] counts;
    private Int32[] gens;
    internal bool noDocs;
    private long cost;
    private ChunkState[] chunkStates;
    private int docID;
    private int freq;
    private SimScorer docScorer;
    public int Freq { get; }
    public int DocID { get; }
    internal ExactPhraseScorer(Weight weight, PostingsAndFreq[] postings, SimScorer docScorer);
    public virtual int NextDoc();
    public virtual int Advance(int target);
    public virtual string ToString();
    public virtual int get_Freq();
    public virtual int get_DocID();
    public virtual float GetScore();
    private int PhraseFreq();
    public virtual long GetCost();
}
public class Lucene.Net.Search.Explanation : object {
    private float val;
    private string description;
    private List`1<Explanation> details;
    public bool IsMatch { get; }
    public float Value { get; public set; }
    public string Description { get; public set; }
    public Explanation(float value, string description);
    public virtual bool get_IsMatch();
    public virtual float get_Value();
    public virtual void set_Value(float value);
    public virtual string get_Description();
    public virtual void set_Description(string value);
    protected virtual string GetSummary();
    public virtual Explanation[] GetDetails();
    public virtual void AddDetail(Explanation detail);
    public virtual string ToString();
    protected internal virtual string ToString(int depth);
    public virtual string ToHtml();
}
internal class Lucene.Net.Search.FakeScorer : Scorer {
    internal float score;
    internal int doc;
    internal int freq;
    public int DocID { get; }
    public int Freq { get; }
    public Weight Weight { get; }
    public virtual int Advance(int target);
    public virtual int get_DocID();
    public virtual int get_Freq();
    public virtual int NextDoc();
    public virtual float GetScore();
    public virtual long GetCost();
    public virtual Weight get_Weight();
    public virtual ICollection`1<ChildScorer> GetChildren();
}
public static class Lucene.Net.Search.FieldCache : object {
    public static IFieldCache DEFAULT;
    [ObsoleteAttribute]
public static IByteParser DEFAULT_BYTE_PARSER;
    [ObsoleteAttribute]
public static IInt16Parser DEFAULT_INT16_PARSER;
    [ObsoleteAttribute]
public static IInt32Parser DEFAULT_INT32_PARSER;
    [ObsoleteAttribute]
public static ISingleParser DEFAULT_SINGLE_PARSER;
    [ObsoleteAttribute]
public static IInt64Parser DEFAULT_INT64_PARSER;
    [ObsoleteAttribute]
public static IDoubleParser DEFAULT_DOUBLE_PARSER;
    public static IInt32Parser NUMERIC_UTILS_INT32_PARSER;
    public static ISingleParser NUMERIC_UTILS_SINGLE_PARSER;
    public static IInt64Parser NUMERIC_UTILS_INT64_PARSER;
    public static IDoubleParser NUMERIC_UTILS_DOUBLE_PARSER;
    private static FieldCache();
}
public class Lucene.Net.Search.FieldCacheDocIdSet : DocIdSet {
    protected int m_maxDoc;
    protected IBits m_acceptDocs;
    private Predicate`1<int> matchDoc;
    private bool hasMatchDoc;
    public bool IsCacheable { get; }
    public IBits Bits { get; }
    public FieldCacheDocIdSet(int maxDoc, IBits acceptDocs, Predicate`1<int> matchDoc);
    protected FieldCacheDocIdSet(int maxDoc, IBits acceptDocs);
    protected internal virtual bool MatchDoc(int doc);
    public sealed virtual bool get_IsCacheable();
    public sealed virtual IBits get_Bits();
    public sealed virtual DocIdSetIterator GetIterator();
}
internal class Lucene.Net.Search.FieldCacheImpl : object {
    private ByteCache caches_typeof_sbyte;
    private Int16Cache caches_typeof_short;
    private Int32Cache caches_typeof_int;
    private SingleCache caches_typeof_float;
    private Int64Cache caches_typeof_long;
    private DoubleCache caches_typeof_double;
    private BinaryDocValuesCache caches_typeof_BinaryDocValues;
    private SortedDocValuesCache caches_typeof_SortedDocValues;
    private DocTermOrdsCache caches_typeof_DocTermOrds;
    private DocsWithFieldCache caches_typeof_DocsWithFieldCache;
    internal ICoreDisposedListener purgeCore;
    internal IReaderClosedListener purgeReader;
    private IEventAggregator eventAggregator;
    private TextWriter modreq(System.Runtime.CompilerServices.IsVolatile) infoStream;
    public TextWriter InfoStream { get; public set; }
    private void Init();
    public virtual void PurgeAllCaches();
    public virtual void PurgeByCacheKey(object coreCacheKey);
    public virtual CacheEntry[] GetCacheEntries();
    private void AddCacheEntries(IList`1<CacheEntry> result, Type cacheType, Cache`2<TKey, TValue> cache);
    private void InitReader(AtomicReader reader);
    internal virtual void SetDocsWithField(AtomicReader reader, string field, IBits docsWithField);
    [ObsoleteAttribute("(4.4) Index as a numeric field using Int32Field and then use GetInt32s(AtomicReader, string, bool) instead.")]
public virtual Bytes GetBytes(AtomicReader reader, string field, bool setDocsWithField);
    public virtual Bytes GetBytes(AtomicReader reader, string field, IByteParser parser, bool setDocsWithField);
    [ObsoleteAttribute("(4.4) Index as a numeric field using Int32Field and then use GetInt32s(AtomicReader, string, bool) instead.")]
public virtual Int16s GetInt16s(AtomicReader reader, string field, bool setDocsWithField);
    [ObsoleteAttribute("(4.4) Index as a numeric field using Int32Field and then use GetInt32s(AtomicReader, string, bool) instead.")]
public virtual Int16s GetInt16s(AtomicReader reader, string field, IInt16Parser parser, bool setDocsWithField);
    public virtual Int32s GetInt32s(AtomicReader reader, string field, bool setDocsWithField);
    public virtual Int32s GetInt32s(AtomicReader reader, string field, IInt32Parser parser, bool setDocsWithField);
    public virtual IBits GetDocsWithField(AtomicReader reader, string field);
    public virtual Singles GetSingles(AtomicReader reader, string field, bool setDocsWithField);
    public virtual Singles GetSingles(AtomicReader reader, string field, ISingleParser parser, bool setDocsWithField);
    public virtual Int64s GetInt64s(AtomicReader reader, string field, bool setDocsWithField);
    public virtual Int64s GetInt64s(AtomicReader reader, string field, IInt64Parser parser, bool setDocsWithField);
    public virtual Doubles GetDoubles(AtomicReader reader, string field, bool setDocsWithField);
    public virtual Doubles GetDoubles(AtomicReader reader, string field, IDoubleParser parser, bool setDocsWithField);
    public virtual SortedDocValues GetTermsIndex(AtomicReader reader, string field);
    public virtual SortedDocValues GetTermsIndex(AtomicReader reader, string field, float acceptableOverheadRatio);
    public virtual BinaryDocValues GetTerms(AtomicReader reader, string field, bool setDocsWithField);
    public virtual BinaryDocValues GetTerms(AtomicReader reader, string field, bool setDocsWithField, float acceptableOverheadRatio);
    public virtual SortedSetDocValues GetDocTermOrds(AtomicReader reader, string field);
    public virtual TextWriter get_InfoStream();
    public virtual void set_InfoStream(TextWriter value);
}
public static class Lucene.Net.Search.FieldCacheRangeFilter : object {
    public static FieldCacheRangeFilter`1<string> NewStringRange(string field, string lowerVal, string upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<BytesRef> NewBytesRefRange(string field, BytesRef lowerVal, BytesRef upperVal, bool includeLower, bool includeUpper);
    [ObsoleteAttribute]
[CLSCompliantAttribute("False")]
public static FieldCacheRangeFilter`1<Nullable`1<sbyte>> NewByteRange(string field, Nullable`1<sbyte> lowerVal, Nullable`1<sbyte> upperVal, bool includeLower, bool includeUpper);
    [ObsoleteAttribute]
[CLSCompliantAttribute("False")]
public static FieldCacheRangeFilter`1<Nullable`1<sbyte>> NewByteRange(string field, IByteParser parser, Nullable`1<sbyte> lowerVal, Nullable`1<sbyte> upperVal, bool includeLower, bool includeUpper);
    [ObsoleteAttribute]
public static FieldCacheRangeFilter`1<Nullable`1<short>> NewInt16Range(string field, Nullable`1<short> lowerVal, Nullable`1<short> upperVal, bool includeLower, bool includeUpper);
    [ObsoleteAttribute]
public static FieldCacheRangeFilter`1<Nullable`1<short>> NewInt16Range(string field, IInt16Parser parser, Nullable`1<short> lowerVal, Nullable`1<short> upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<Nullable`1<int>> NewInt32Range(string field, Nullable`1<int> lowerVal, Nullable`1<int> upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<Nullable`1<int>> NewInt32Range(string field, IInt32Parser parser, Nullable`1<int> lowerVal, Nullable`1<int> upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<Nullable`1<long>> NewInt64Range(string field, Nullable`1<long> lowerVal, Nullable`1<long> upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<Nullable`1<long>> NewInt64Range(string field, IInt64Parser parser, Nullable`1<long> lowerVal, Nullable`1<long> upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<Nullable`1<float>> NewSingleRange(string field, Nullable`1<float> lowerVal, Nullable`1<float> upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<Nullable`1<float>> NewSingleRange(string field, ISingleParser parser, Nullable`1<float> lowerVal, Nullable`1<float> upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<Nullable`1<double>> NewDoubleRange(string field, Nullable`1<double> lowerVal, Nullable`1<double> upperVal, bool includeLower, bool includeUpper);
    public static FieldCacheRangeFilter`1<Nullable`1<double>> NewDoubleRange(string field, IDoubleParser parser, Nullable`1<double> lowerVal, Nullable`1<double> upperVal, bool includeLower, bool includeUpper);
}
public abstract class Lucene.Net.Search.FieldCacheRangeFilter`1 : Filter {
    internal string field;
    internal IParser parser;
    internal T lowerVal;
    internal T upperVal;
    internal bool includeLower;
    internal bool includeUpper;
    public string Field { get; }
    public bool IncludesLower { get; }
    public bool IncludesUpper { get; }
    public T LowerVal { get; }
    public T UpperVal { get; }
    public IParser Parser { get; }
    protected internal FieldCacheRangeFilter`1(string field, IParser parser, T lowerVal, T upperVal, bool includeLower, bool includeUpper);
    public abstract virtual DocIdSet GetDocIdSet(AtomicReaderContext context, IBits acceptDocs);
    public sealed virtual string ToString();
    public sealed virtual bool Equals(object o);
    protected virtual bool Equals(T objA, T objB);
    public sealed virtual int GetHashCode();
    public virtual string get_Field();
    public virtual bool get_IncludesLower();
    public virtual bool get_IncludesUpper();
    public virtual T get_LowerVal();
    public virtual T get_UpperVal();
    public virtual IParser get_Parser();
}
public class Lucene.Net.Search.FieldCacheRewriteMethod : RewriteMethod {
    public virtual Query Rewrite(IndexReader reader, MultiTermQuery query);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.FieldCacheTermsFilter : Filter {
    private string field;
    private BytesRef[] terms;
    public IFieldCache FieldCache { get; }
    public FieldCacheTermsFilter(string field, BytesRef[] terms);
    public FieldCacheTermsFilter(string field, String[] terms);
    public virtual IFieldCache get_FieldCache();
    public virtual DocIdSet GetDocIdSet(AtomicReaderContext context, IBits acceptDocs);
}
public abstract class Lucene.Net.Search.FieldComparer : object {
    public abstract virtual int CompareValues(object first, object second);
    public abstract virtual int Compare(int slot1, int slot2);
    public abstract virtual void SetBottom(int slot);
    public abstract virtual void SetTopValue(TValue value);
    public abstract virtual int CompareBottom(int doc);
    public abstract virtual int CompareTop(int doc);
    public abstract virtual void Copy(int slot, int doc);
    public abstract virtual FieldComparer SetNextReader(AtomicReaderContext context);
    public virtual void SetScorer(Scorer scorer);
    public abstract virtual object GetValue(int slot);
}
[DefaultMemberAttribute("Item")]
public abstract class Lucene.Net.Search.FieldComparer`1 : FieldComparer {
    public T Item { get; }
    public abstract virtual int Compare(int slot1, int slot2);
    public abstract virtual void SetBottom(int slot);
    public virtual void SetTopValue(TValue value);
    public abstract virtual void SetTopValue(T value);
    public virtual object GetValue(int slot);
    public abstract virtual T get_Item(int slot);
    public abstract virtual int CompareBottom(int doc);
    public abstract virtual int CompareTop(int doc);
    public abstract virtual void Copy(int slot, int doc);
    public abstract virtual FieldComparer SetNextReader(AtomicReaderContext context);
    public virtual int CompareValues(T first, T second);
    public virtual int CompareValues(object first, object second);
}
public abstract class Lucene.Net.Search.FieldComparerSource : object {
    public abstract virtual FieldComparer NewComparer(string fieldname, int numHits, int sortPos, bool reversed);
}
public class Lucene.Net.Search.FieldDoc : ScoreDoc {
    public Object[] Fields;
    public FieldDoc(int doc, float score);
    public FieldDoc(int doc, float score, Object[] fields);
    public FieldDoc(int doc, float score, Object[] fields, int shardIndex);
    public virtual string ToString();
}
public class Lucene.Net.Search.FieldValueFilter : Filter {
    private string field;
    private bool negate;
    public string Field { get; }
    public bool Negate { get; }
    public FieldValueFilter(string field);
    public FieldValueFilter(string field, bool negate);
    public virtual string get_Field();
    public virtual bool get_Negate();
    public virtual DocIdSet GetDocIdSet(AtomicReaderContext context, IBits acceptDocs);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public static class Lucene.Net.Search.FieldValueHitQueue : object {
    public static FieldValueHitQueue`1<T> Create(SortField[] fields, int size);
}
public abstract class Lucene.Net.Search.FieldValueHitQueue`1 : PriorityQueue`1<T> {
    protected SortField[] m_fields;
    protected FieldComparer[] m_comparers;
    protected FieldComparer m_firstComparer;
    protected Int32[] m_reverseMul;
    [WritableArrayAttribute]
public FieldComparer[] Comparers { get; }
    [WritableArrayAttribute]
public Int32[] ReverseMul { get; }
    internal FieldComparer FirstComparer { get; }
    [WritableArrayAttribute]
internal SortField[] Fields { get; }
    internal FieldValueHitQueue`1(SortField[] fields, int size);
    public virtual FieldComparer[] get_Comparers();
    public virtual Int32[] get_ReverseMul();
    public virtual void SetComparer(int pos, FieldComparer comparer);
    internal FieldComparer get_FirstComparer();
    internal virtual FieldDoc FillFields(Entry entry);
    internal virtual SortField[] get_Fields();
}
public abstract class Lucene.Net.Search.Filter : object {
    public abstract virtual DocIdSet GetDocIdSet(AtomicReaderContext context, IBits acceptDocs);
    public static Filter NewAnonymous(Func`3<AtomicReaderContext, IBits, DocIdSet> getDocIdSet);
}
public abstract class Lucene.Net.Search.FilteredDocIdSet : DocIdSet {
    private DocIdSet innerSet;
    public bool IsCacheable { get; }
    public IBits Bits { get; }
    protected FilteredDocIdSet(DocIdSet innerSet);
    public virtual bool get_IsCacheable();
    public virtual IBits get_Bits();
    protected abstract virtual bool Match(int docid);
    public virtual DocIdSetIterator GetIterator();
}
public abstract class Lucene.Net.Search.FilteredDocIdSetIterator : DocIdSetIterator {
    protected DocIdSetIterator m_innerIter;
    private int doc;
    public int DocID { get; }
    protected FilteredDocIdSetIterator(DocIdSetIterator innerIter);
    protected abstract virtual bool Match(int doc);
    public virtual int get_DocID();
    public virtual int NextDoc();
    public virtual int Advance(int target);
    public virtual long GetCost();
}
public class Lucene.Net.Search.FilteredQuery : Query {
    private Query query;
    private Filter filter;
    private FilterStrategy strategy;
    public static FilterStrategy RANDOM_ACCESS_FILTER_STRATEGY;
    public static FilterStrategy LEAP_FROG_FILTER_FIRST_STRATEGY;
    public static FilterStrategy LEAP_FROG_QUERY_FIRST_STRATEGY;
    public static FilterStrategy QUERY_FIRST_FILTER_STRATEGY;
    public Query Query { get; }
    public Filter Filter { get; }
    public FilterStrategy Strategy { get; }
    public FilteredQuery(Query query, Filter filter);
    public FilteredQuery(Query query, Filter filter, FilterStrategy strategy);
    private static FilteredQuery();
    public virtual Weight CreateWeight(IndexSearcher searcher);
    public virtual Query Rewrite(IndexReader reader);
    public Query get_Query();
    public Filter get_Filter();
    public virtual FilterStrategy get_Strategy();
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual string ToString(string s);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.FuzzyQuery : MultiTermQuery {
    public static int DefaultMaxEdits;
    public static int DefaultPrefixLength;
    public static int DefaultMaxExpansions;
    public static bool DefaultTranspositions;
    private int maxEdits;
    private int maxExpansions;
    private bool transpositions;
    private int prefixLength;
    private Term term;
    [ObsoleteAttribute("pass integer edit distances instead.")]
public static float DefaultMinSimilarity;
    public int MaxEdits { get; }
    public int PrefixLength { get; }
    public bool Transpositions { get; }
    public Term Term { get; }
    public FuzzyQuery(Term term, int maxEdits, int prefixLength, int maxExpansions, bool transpositions);
    public FuzzyQuery(Term term, int maxEdits, int prefixLength);
    public FuzzyQuery(Term term, int maxEdits);
    public FuzzyQuery(Term term);
    public virtual int get_MaxEdits();
    public virtual int get_PrefixLength();
    public virtual bool get_Transpositions();
    protected virtual TermsEnum GetTermsEnum(Terms terms, AttributeSource atts);
    public virtual Term get_Term();
    public virtual string ToString(string field);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    [ObsoleteAttribute("pass integer edit distances instead.")]
public static int SingleToEdits(float minimumSimilarity, int termLen);
}
public class Lucene.Net.Search.FuzzyTermsEnum : TermsEnum {
    private TermsEnum actualEnum;
    private IBoostAttribute actualBoostAtt;
    private IBoostAttribute boostAtt;
    private IMaxNonCompetitiveBoostAttribute maxBoostAtt;
    private ILevenshteinAutomataAttribute dfaAtt;
    private float bottom;
    private BytesRef bottomTerm;
    private IComparer`1<BytesRef> termComparer;
    protected float m_minSimilarity;
    protected float m_scaleFactor;
    protected int m_termLength;
    protected int m_maxEdits;
    protected bool m_raw;
    protected Terms m_terms;
    private Term term;
    protected Int32[] m_termText;
    protected int m_realPrefixLength;
    private bool transpositions;
    private BytesRef queuedBottom;
    public int DocFreq { get; }
    public long TotalTermFreq { get; }
    public IComparer`1<BytesRef> Comparer { get; }
    public long Ord { get; }
    public BytesRef Term { get; }
    public float MinSimilarity { get; }
    public float ScaleFactor { get; }
    public FuzzyTermsEnum(Terms terms, AttributeSource atts, Term term, float minSimilarity, int prefixLength, bool transpositions);
    protected virtual TermsEnum GetAutomatonEnum(int editDistance, BytesRef lastTerm);
    private IList`1<CompiledAutomaton> InitAutomata(int maxDistance);
    protected virtual void SetEnum(TermsEnum actualEnum);
    private void BottomChanged(BytesRef lastTerm, bool init);
    protected virtual void MaxEditDistanceChanged(BytesRef lastTerm, int maxEdits, bool init);
    private int InitialMaxDistance(float minimumSimilarity, int termLen);
    private float CalculateMaxBoost(int nEdits);
    public virtual bool MoveNext();
    [ObsoleteAttribute("Use MoveNext() and Term instead. This method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public virtual BytesRef Next();
    public virtual int get_DocFreq();
    public virtual long get_TotalTermFreq();
    public virtual DocsEnum Docs(IBits liveDocs, DocsEnum reuse, DocsFlags flags);
    public virtual DocsAndPositionsEnum DocsAndPositions(IBits liveDocs, DocsAndPositionsEnum reuse, DocsAndPositionsFlags flags);
    public virtual void SeekExact(BytesRef term, TermState state);
    public virtual TermState GetTermState();
    public virtual IComparer`1<BytesRef> get_Comparer();
    public virtual long get_Ord();
    public virtual bool SeekExact(BytesRef text);
    public virtual SeekStatus SeekCeil(BytesRef text);
    public virtual void SeekExact(long ord);
    public virtual BytesRef get_Term();
    public virtual float get_MinSimilarity();
    public virtual float get_ScaleFactor();
}
internal class Lucene.Net.Search.HitQueue : PriorityQueue`1<ScoreDoc> {
    internal HitQueue(int size, bool prePopulate);
    protected virtual ScoreDoc GetSentinelObject();
    protected internal sealed virtual bool LessThan(ScoreDoc hitA, ScoreDoc hitB);
}
public interface Lucene.Net.Search.IBoostAttribute {
    public float Boost { get; public set; }
    public abstract virtual float get_Boost();
    public abstract virtual void set_Boost(float value);
}
public interface Lucene.Net.Search.ICollector {
    public bool AcceptsDocsOutOfOrder { get; }
    public abstract virtual void SetScorer(Scorer scorer);
    public abstract virtual void Collect(int doc);
    public abstract virtual void SetNextReader(AtomicReaderContext context);
    public abstract virtual bool get_AcceptsDocsOutOfOrder();
}
public interface Lucene.Net.Search.IFieldCache {
    public TextWriter InfoStream { get; public set; }
    public abstract virtual IBits GetDocsWithField(AtomicReader reader, string field);
    [ObsoleteAttribute("(4.4) Index as a numeric field using Int32Field and then use GetInt32s(AtomicReader, string, bool) instead.")]
public abstract virtual Bytes GetBytes(AtomicReader reader, string field, bool setDocsWithField);
    [ObsoleteAttribute("(4.4) Index as a numeric field using Int32Field and then use GetInt32s(AtomicReader, string, bool) instead.")]
public abstract virtual Bytes GetBytes(AtomicReader reader, string field, IByteParser parser, bool setDocsWithField);
    [ObsoleteAttribute("(4.4) Index as a numeric field using Int32Field and then use GetInt32s(AtomicReader, string, bool) instead.")]
public abstract virtual Int16s GetInt16s(AtomicReader reader, string field, bool setDocsWithField);
    [ObsoleteAttribute("(4.4) Index as a numeric field using Int32Field and then use GetInt32s(AtomicReader, string, bool) instead.")]
public abstract virtual Int16s GetInt16s(AtomicReader reader, string field, IInt16Parser parser, bool setDocsWithField);
    public abstract virtual Int32s GetInt32s(AtomicReader reader, string field, bool setDocsWithField);
    public abstract virtual Int32s GetInt32s(AtomicReader reader, string field, IInt32Parser parser, bool setDocsWithField);
    public abstract virtual Singles GetSingles(AtomicReader reader, string field, bool setDocsWithField);
    public abstract virtual Singles GetSingles(AtomicReader reader, string field, ISingleParser parser, bool setDocsWithField);
    public abstract virtual Int64s GetInt64s(AtomicReader reader, string field, bool setDocsWithField);
    public abstract virtual Int64s GetInt64s(AtomicReader reader, string field, IInt64Parser parser, bool setDocsWithField);
    public abstract virtual Doubles GetDoubles(AtomicReader reader, string field, bool setDocsWithField);
    public abstract virtual Doubles GetDoubles(AtomicReader reader, string field, IDoubleParser parser, bool setDocsWithField);
    public abstract virtual BinaryDocValues GetTerms(AtomicReader reader, string field, bool setDocsWithField);
    public abstract virtual BinaryDocValues GetTerms(AtomicReader reader, string field, bool setDocsWithField, float acceptableOverheadRatio);
    public abstract virtual SortedDocValues GetTermsIndex(AtomicReader reader, string field);
    public abstract virtual SortedDocValues GetTermsIndex(AtomicReader reader, string field, float acceptableOverheadRatio);
    public abstract virtual SortedSetDocValues GetDocTermOrds(AtomicReader reader, string field);
    public abstract virtual CacheEntry[] GetCacheEntries();
    public abstract virtual void PurgeAllCaches();
    public abstract virtual void PurgeByCacheKey(object coreCacheKey);
    public abstract virtual void set_InfoStream(TextWriter value);
    public abstract virtual TextWriter get_InfoStream();
}
public interface Lucene.Net.Search.IMaxNonCompetitiveBoostAttribute {
    public float MaxNonCompetitiveBoost { get; public set; }
    public BytesRef CompetitiveTerm { get; public set; }
    public abstract virtual void set_MaxNonCompetitiveBoost(float value);
    public abstract virtual float get_MaxNonCompetitiveBoost();
    public abstract virtual void set_CompetitiveTerm(BytesRef value);
    public abstract virtual BytesRef get_CompetitiveTerm();
}
public class Lucene.Net.Search.IndexSearcher : object {
    internal IndexReader reader;
    protected IndexReaderContext m_readerContext;
    protected internal IList`1<AtomicReaderContext> m_leafContexts;
    protected LeafSlice[] m_leafSlices;
    private TaskScheduler executor;
    private static Similarity defaultSimilarity;
    private Similarity similarity;
    public static Similarity DefaultSimilarity { get; }
    public IndexReader IndexReader { get; }
    public Similarity Similarity { get; public set; }
    public IndexReaderContext TopReaderContext { get; }
    public IndexSearcher(IndexReader r);
    public IndexSearcher(IndexReader r, TaskScheduler executor);
    public IndexSearcher(IndexReaderContext context, TaskScheduler executor);
    public IndexSearcher(IndexReaderContext context);
    private static IndexSearcher();
    public static Similarity get_DefaultSimilarity();
    protected virtual LeafSlice[] Slices(IList`1<AtomicReaderContext> leaves);
    public virtual IndexReader get_IndexReader();
    public virtual Document Doc(int docID);
    public virtual void Doc(int docID, StoredFieldVisitor fieldVisitor);
    public virtual Document Doc(int docID, ISet`1<string> fieldsToLoad);
    [ObsoleteAttribute("Use <seealso cref=#doc(int, java.util.Set)/> instead.")]
public Document Document(int docID, ISet`1<string> fieldsToLoad);
    public virtual Similarity get_Similarity();
    public virtual void set_Similarity(Similarity value);
    protected virtual Query WrapFilter(Query query, Filter filter);
    public virtual TopDocs SearchAfter(ScoreDoc after, Query query, int n);
    public virtual TopDocs SearchAfter(ScoreDoc after, Query query, Filter filter, int n);
    public virtual TopDocs Search(Query query, int n);
    public virtual TopDocs Search(Query query, Filter filter, int n);
    public virtual void Search(Query query, Filter filter, ICollector results);
    public virtual void Search(Query query, ICollector results);
    public virtual TopFieldDocs Search(Query query, Filter filter, int n, Sort sort);
    public virtual TopFieldDocs Search(Query query, Filter filter, int n, Sort sort, bool doDocScores, bool doMaxScore);
    public virtual TopDocs SearchAfter(ScoreDoc after, Query query, Filter filter, int n, Sort sort);
    public virtual TopFieldDocs Search(Query query, int n, Sort sort);
    public virtual TopDocs SearchAfter(ScoreDoc after, Query query, int n, Sort sort);
    public virtual TopDocs SearchAfter(ScoreDoc after, Query query, Filter filter, int n, Sort sort, bool doDocScores, bool doMaxScore);
    protected virtual TopDocs Search(Weight weight, ScoreDoc after, int nDocs);
    protected virtual TopDocs Search(IList`1<AtomicReaderContext> leaves, Weight weight, ScoreDoc after, int nDocs);
    protected virtual TopFieldDocs Search(Weight weight, int nDocs, Sort sort, bool doDocScores, bool doMaxScore);
    protected virtual TopFieldDocs Search(Weight weight, FieldDoc after, int nDocs, Sort sort, bool fillFields, bool doDocScores, bool doMaxScore);
    protected virtual TopFieldDocs Search(IList`1<AtomicReaderContext> leaves, Weight weight, FieldDoc after, int nDocs, Sort sort, bool fillFields, bool doDocScores, bool doMaxScore);
    protected virtual void Search(IList`1<AtomicReaderContext> leaves, Weight weight, ICollector collector);
    public virtual Query Rewrite(Query original);
    public virtual Explanation Explain(Query query, int doc);
    protected virtual Explanation Explain(Weight weight, int doc);
    public virtual Weight CreateNormalizedWeight(Query query);
    public virtual IndexReaderContext get_TopReaderContext();
    public virtual string ToString();
    public virtual TermStatistics TermStatistics(Term term, TermContext context);
    public virtual CollectionStatistics CollectionStatistics(string field);
}
public interface Lucene.Net.Search.ITopDocsCollector {
    public int TotalHits { get; }
    public abstract virtual int get_TotalHits();
    public abstract virtual TopDocs GetTopDocs();
    public abstract virtual TopDocs GetTopDocs(int start);
    public abstract virtual TopDocs GetTopDocs(int start, int howMany);
}
internal interface Lucene.Net.Search.ITopTermsRewrite {
    public int Count { get; }
    public abstract virtual int get_Count();
}
public abstract class Lucene.Net.Search.LiveFieldValues`2 : object {
    private IDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) current;
    private IDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) old;
    private ReferenceManager`1<S> mgr;
    private T missingValue;
    public int Count { get; }
    protected LiveFieldValues`2(ReferenceManager`1<S> mgr, T missingValue);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void BeforeRefresh();
    public virtual void AfterRefresh(bool didRefresh);
    public virtual void Add(string id, T value);
    public virtual void Delete(string id);
    public virtual int get_Count();
    public virtual T Get(string id);
    protected abstract virtual T LookupFromSearcher(S s, string id);
}
public class Lucene.Net.Search.MatchAllDocsQuery : Query {
    public virtual Weight CreateWeight(IndexSearcher searcher);
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.MaxNonCompetitiveBoostAttribute : Attribute {
    private float maxNonCompetitiveBoost;
    private BytesRef competitiveTerm;
    public float MaxNonCompetitiveBoost { get; public set; }
    public BytesRef CompetitiveTerm { get; public set; }
    public sealed virtual float get_MaxNonCompetitiveBoost();
    public sealed virtual void set_MaxNonCompetitiveBoost(float value);
    public sealed virtual BytesRef get_CompetitiveTerm();
    public sealed virtual void set_CompetitiveTerm(BytesRef value);
    public virtual void Clear();
    public virtual void CopyTo(IAttribute target);
}
internal class Lucene.Net.Search.MinShouldMatchSumScorer : Scorer {
    private int numScorers;
    private int mm;
    private Scorer[] sortedSubScorers;
    private int sortedSubScorersIdx;
    private Scorer[] subScorers;
    private int nrInHeap;
    private Scorer[] mmStack;
    private int doc;
    protected int m_nrMatchers;
    private double score;
    public int DocID { get; }
    public int Freq { get; }
    public MinShouldMatchSumScorer(Weight weight, IList`1<Scorer> subScorers, int minimumNrMatchers);
    public MinShouldMatchSumScorer(Weight weight, IList`1<Scorer> subScorers);
    public sealed virtual ICollection`1<ChildScorer> GetChildren();
    public virtual int NextDoc();
    private void EvaluateSmallestDocInHeap();
    private void CountMatches(int root);
    public virtual float GetScore();
    public virtual int get_DocID();
    public virtual int get_Freq();
    public virtual int Advance(int target);
    public virtual long GetCost();
    protected void MinheapHeapify();
    protected void MinheapSiftDown(int root);
    protected void MinheapSiftUp(int i);
    protected void MinheapRemoveRoot();
    protected bool MinheapRemove(Scorer scorer);
    internal virtual bool MinheapCheck();
    private bool MinheapCheck(int root);
}
public class Lucene.Net.Search.MultiCollector : object {
    private ICollector[] collectors;
    public bool AcceptsDocsOutOfOrder { get; }
    private MultiCollector(ICollector[] collectors);
    public static ICollector Wrap(ICollector[] collectors);
    public virtual bool get_AcceptsDocsOutOfOrder();
    public virtual void Collect(int doc);
    public virtual void SetNextReader(AtomicReaderContext context);
    public virtual void SetScorer(Scorer scorer);
}
public class Lucene.Net.Search.MultiPhraseQuery : Query {
    private string field;
    private IList`1<Term[]> termArrays;
    private IList`1<int> positions;
    private int slop;
    public int Slop { get; public set; }
    public virtual int get_Slop();
    public virtual void set_Slop(int value);
    public virtual void Add(Term term);
    public virtual void Add(Term[] terms);
    public virtual void Add(Term[] terms, int position);
    public virtual IList`1<Term[]> GetTermArrays();
    public virtual Int32[] GetPositions();
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual Query Rewrite(IndexReader reader);
    public virtual Weight CreateWeight(IndexSearcher searcher);
    public sealed virtual string ToString(string f);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    private int TermArraysHashCode();
    private bool TermArraysEquals(IList`1<Term[]> termArrays1, IList`1<Term[]> termArrays2);
    public sealed virtual IEnumerator`1<Term[]> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class Lucene.Net.Search.MultiTermQuery : Query {
    protected internal string m_field;
    protected RewriteMethod m_rewriteMethod;
    public static RewriteMethod CONSTANT_SCORE_FILTER_REWRITE;
    public static RewriteMethod SCORING_BOOLEAN_QUERY_REWRITE;
    public static RewriteMethod CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE;
    public static RewriteMethod CONSTANT_SCORE_AUTO_REWRITE_DEFAULT;
    public string Field { get; }
    public RewriteMethod MultiTermRewriteMethod { get; public set; }
    protected MultiTermQuery(string field);
    private static MultiTermQuery();
    public string get_Field();
    protected abstract virtual TermsEnum GetTermsEnum(Terms terms, AttributeSource atts);
    public TermsEnum GetTermsEnum(Terms terms);
    public sealed virtual Query Rewrite(IndexReader reader);
    public virtual RewriteMethod get_MultiTermRewriteMethod();
    public virtual void set_MultiTermRewriteMethod(RewriteMethod value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Lucene.Net.Search.MultiTermQueryWrapperFilter`1 : Filter {
    protected Q m_query;
    public string Field { get; }
    protected internal MultiTermQueryWrapperFilter`1(Q query);
    public virtual string ToString();
    public sealed virtual bool Equals(object o);
    public sealed virtual int GetHashCode();
    public string get_Field();
    public virtual DocIdSet GetDocIdSet(AtomicReaderContext context, IBits acceptDocs);
}
public class Lucene.Net.Search.NGramPhraseQuery : PhraseQuery {
    private int n;
    public NGramPhraseQuery(int n);
    public virtual Query Rewrite(IndexReader reader);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public static class Lucene.Net.Search.NumericRangeFilter : object {
    public static NumericRangeFilter`1<long> NewInt64Range(string field, int precisionStep, Nullable`1<long> min, Nullable`1<long> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeFilter`1<long> NewInt64Range(string field, Nullable`1<long> min, Nullable`1<long> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeFilter`1<int> NewInt32Range(string field, int precisionStep, Nullable`1<int> min, Nullable`1<int> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeFilter`1<int> NewInt32Range(string field, Nullable`1<int> min, Nullable`1<int> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeFilter`1<double> NewDoubleRange(string field, int precisionStep, Nullable`1<double> min, Nullable`1<double> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeFilter`1<double> NewDoubleRange(string field, Nullable`1<double> min, Nullable`1<double> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeFilter`1<float> NewSingleRange(string field, int precisionStep, Nullable`1<float> min, Nullable`1<float> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeFilter`1<float> NewSingleRange(string field, Nullable`1<float> min, Nullable`1<float> max, bool minInclusive, bool maxInclusive);
}
public class Lucene.Net.Search.NumericRangeFilter`1 : MultiTermQueryWrapperFilter`1<NumericRangeQuery`1<T>> {
    public bool IncludesMin { get; }
    public bool IncludesMax { get; }
    public Nullable`1<T> Min { get; }
    public Nullable`1<T> Max { get; }
    public int PrecisionStep { get; }
    internal NumericRangeFilter`1(NumericRangeQuery`1<T> query);
    public bool get_IncludesMin();
    public bool get_IncludesMax();
    public Nullable`1<T> get_Min();
    public Nullable`1<T> get_Max();
    public int get_PrecisionStep();
}
public static class Lucene.Net.Search.NumericRangeQuery : object {
    public static NumericRangeQuery`1<long> NewInt64Range(string field, int precisionStep, Nullable`1<long> min, Nullable`1<long> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeQuery`1<long> NewInt64Range(string field, Nullable`1<long> min, Nullable`1<long> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeQuery`1<int> NewInt32Range(string field, int precisionStep, Nullable`1<int> min, Nullable`1<int> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeQuery`1<int> NewInt32Range(string field, Nullable`1<int> min, Nullable`1<int> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeQuery`1<double> NewDoubleRange(string field, int precisionStep, Nullable`1<double> min, Nullable`1<double> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeQuery`1<double> NewDoubleRange(string field, Nullable`1<double> min, Nullable`1<double> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeQuery`1<float> NewSingleRange(string field, int precisionStep, Nullable`1<float> min, Nullable`1<float> max, bool minInclusive, bool maxInclusive);
    public static NumericRangeQuery`1<float> NewSingleRange(string field, Nullable`1<float> min, Nullable`1<float> max, bool minInclusive, bool maxInclusive);
}
public class Lucene.Net.Search.NumericRangeQuery`1 : MultiTermQuery {
    internal int precisionStep;
    internal NumericType dataType;
    internal Nullable`1<T> min;
    internal Nullable`1<T> max;
    internal bool minInclusive;
    internal bool maxInclusive;
    internal static long INT64_NEGATIVE_INFINITY;
    internal static long INT64_POSITIVE_INFINITY;
    internal static int INT32_NEGATIVE_INFINITY;
    internal static int INT32_POSITIVE_INFINITY;
    public bool IncludesMin { get; }
    public bool IncludesMax { get; }
    public Nullable`1<T> Min { get; }
    public Nullable`1<T> Max { get; }
    public int PrecisionStep { get; }
    internal NumericRangeQuery`1(string field, int precisionStep, NumericType dataType, Nullable`1<T> min, Nullable`1<T> max, bool minInclusive, bool maxInclusive);
    private static NumericRangeQuery`1();
    protected virtual TermsEnum GetTermsEnum(Terms terms, AttributeSource atts);
    public bool get_IncludesMin();
    public bool get_IncludesMax();
    public Nullable`1<T> get_Min();
    public Nullable`1<T> get_Max();
    public int get_PrecisionStep();
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public enum Lucene.Net.Search.Occur : Enum {
    public int value__;
    public static Occur MUST;
    public static Occur SHOULD;
    public static Occur MUST_NOT;
}
public class Lucene.Net.Search.Payloads.AveragePayloadFunction : PayloadFunction {
    public virtual float CurrentScore(int docId, string field, int start, int end, int numPayloadsSeen, float currentScore, float currentPayloadScore);
    public virtual float DocScore(int docId, string field, int numPayloadsSeen, float payloadScore);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Lucene.Net.Search.Payloads.MaxPayloadFunction : PayloadFunction {
    public virtual float CurrentScore(int docId, string field, int start, int end, int numPayloadsSeen, float currentScore, float currentPayloadScore);
    public virtual float DocScore(int docId, string field, int numPayloadsSeen, float payloadScore);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Lucene.Net.Search.Payloads.MinPayloadFunction : PayloadFunction {
    public virtual float CurrentScore(int docId, string field, int start, int end, int numPayloadsSeen, float currentScore, float currentPayloadScore);
    public virtual float DocScore(int docId, string field, int numPayloadsSeen, float payloadScore);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public abstract class Lucene.Net.Search.Payloads.PayloadFunction : object {
    public abstract virtual float CurrentScore(int docId, string field, int start, int end, int numPayloadsSeen, float currentScore, float currentPayloadScore);
    public abstract virtual float DocScore(int docId, string field, int numPayloadsSeen, float payloadScore);
    public virtual Explanation Explain(int docId, string field, int numPayloadsSeen, float payloadScore);
    public abstract virtual int GetHashCode();
    public abstract virtual bool Equals(object o);
}
public class Lucene.Net.Search.Payloads.PayloadNearQuery : SpanNearQuery {
    protected string m_fieldName;
    protected PayloadFunction m_function;
    public PayloadNearQuery(SpanQuery[] clauses, int slop, bool inOrder);
    public PayloadNearQuery(SpanQuery[] clauses, int slop, bool inOrder, PayloadFunction function);
    public virtual Weight CreateWeight(IndexSearcher searcher);
    public virtual object Clone();
    public virtual string ToString(string field);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Lucene.Net.Search.Payloads.PayloadSpanUtil : object {
    private IndexReaderContext context;
    public PayloadSpanUtil(IndexReaderContext context);
    public virtual ICollection`1<Byte[]> GetPayloadsForQuery(Query query);
    private void QueryToSpanQuery(Query query, ICollection`1<Byte[]> payloads);
    private void GetPayloads(ICollection`1<Byte[]> payloads, SpanQuery query);
}
public class Lucene.Net.Search.Payloads.PayloadTermQuery : SpanTermQuery {
    protected PayloadFunction m_function;
    private bool includeSpanScore;
    public PayloadTermQuery(Term term, PayloadFunction function);
    public PayloadTermQuery(Term term, PayloadFunction function, bool includeSpanScore);
    public virtual Weight CreateWeight(IndexSearcher searcher);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class Lucene.Net.Search.PhrasePositions : object {
    internal int doc;
    internal int position;
    internal int count;
    internal int offset;
    internal int ord;
    internal DocsAndPositionsEnum postings;
    internal PhrasePositions next;
    internal int rptGroup;
    internal int rptInd;
    internal Term[] terms;
    internal PhrasePositions(DocsAndPositionsEnum postings, int o, int ord, Term[] terms);
    internal bool Next();
    internal bool SkipTo(int target);
    internal void FirstPosition();
    internal bool NextPosition();
    public virtual string ToString();
}
public class Lucene.Net.Search.PhraseQuery : Query {
    private string field;
    private IList`1<Term> terms;
    private IList`1<int> positions;
    private int maxPosition;
    private int slop;
    public int Slop { get; public set; }
    public virtual int get_Slop();
    public virtual void set_Slop(int value);
    public virtual void Add(Term term);
    public virtual void Add(Term term, int position);
    public virtual Term[] GetTerms();
    public virtual Int32[] GetPositions();
    public virtual Query Rewrite(IndexReader reader);
    public virtual Weight CreateWeight(IndexSearcher searcher);
    public virtual void ExtractTerms(ISet`1<Term> queryTerms);
    public virtual string ToString(string f);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public sealed virtual IEnumerator`1<Term> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Lucene.Net.Search.PhraseQueue : PriorityQueue`1<PhrasePositions> {
    internal PhraseQueue(int size);
    protected internal sealed virtual bool LessThan(PhrasePositions pp1, PhrasePositions pp2);
}
public class Lucene.Net.Search.PositiveScoresOnlyCollector : object {
    private ICollector c;
    private Scorer scorer;
    public bool AcceptsDocsOutOfOrder { get; }
    public PositiveScoresOnlyCollector(ICollector c);
    public virtual void Collect(int doc);
    public virtual void SetNextReader(AtomicReaderContext context);
    public virtual void SetScorer(Scorer scorer);
    public virtual bool get_AcceptsDocsOutOfOrder();
}
public class Lucene.Net.Search.PrefixFilter : MultiTermQueryWrapperFilter`1<PrefixQuery> {
    public Term Prefix { get; }
    public PrefixFilter(Term prefix);
    public virtual Term get_Prefix();
    public virtual string ToString();
}
public class Lucene.Net.Search.PrefixQuery : MultiTermQuery {
    private Term _prefix;
    public Term Prefix { get; }
    public PrefixQuery(Term prefix);
    public virtual Term get_Prefix();
    protected virtual TermsEnum GetTermsEnum(Terms terms, AttributeSource atts);
    public virtual string ToString(string field);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Lucene.Net.Search.PrefixTermsEnum : FilteredTermsEnum {
    private BytesRef prefixRef;
    public PrefixTermsEnum(TermsEnum tenum, BytesRef prefixText);
    protected virtual AcceptStatus Accept(BytesRef term);
}
public abstract class Lucene.Net.Search.Query : object {
    private float boost;
    public float Boost { get; public set; }
    public virtual float get_Boost();
    public virtual void set_Boost(float value);
    public abstract virtual string ToString(string field);
    public virtual string ToString();
    public virtual Weight CreateWeight(IndexSearcher searcher);
    public virtual Query Rewrite(IndexReader reader);
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual object Clone();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public abstract class Lucene.Net.Search.QueryRescorer : Rescorer {
    private Query query;
    protected QueryRescorer(Query query);
    protected abstract virtual float Combine(float firstPassScore, bool secondPassMatches, float secondPassScore);
    public virtual TopDocs Rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN);
    public virtual Explanation Explain(IndexSearcher searcher, Explanation firstPassExplanation, int docID);
    public static TopDocs Rescore(IndexSearcher searcher, TopDocs topDocs, Query query, double weight, int topN);
}
public class Lucene.Net.Search.QueryWrapperFilter : Filter {
    private Query query;
    public Query Query { get; }
    public QueryWrapperFilter(Query query);
    public Query get_Query();
    public virtual DocIdSet GetDocIdSet(AtomicReaderContext context, IBits acceptDocs);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.ReferenceContext`1 : object {
    private ReferenceManager`1<T> referenceManager;
    private T reference;
    public T Reference { get; }
    internal ReferenceContext`1(ReferenceManager`1<T> referenceManager);
    public T get_Reference();
    public sealed virtual void Dispose();
}
public static class Lucene.Net.Search.ReferenceManager : object {
}
public abstract class Lucene.Net.Search.ReferenceManager`1 : object {
    private static string REFERENCE_MANAGER_IS_CLOSED_MSG;
    private G modreq(System.Runtime.CompilerServices.IsVolatile) current;
    private ReentrantLock refreshLock;
    private ISet`1<IRefreshListener> refreshListeners;
    protected G Current { get; protected set; }
    protected G get_Current();
    protected void set_Current(G value);
    private void EnsureOpen();
    private void SwapReference(G newReference);
    protected abstract virtual void DecRef(G reference);
    protected abstract virtual G RefreshIfNeeded(G referenceToRefresh);
    protected abstract virtual bool TryIncRef(G reference);
    public G Acquire();
    public sealed virtual void Dispose();
    protected abstract virtual int GetRefCount(G reference);
    protected virtual void Dispose(bool disposing);
    private void DoMaybeRefresh();
    public bool MaybeRefresh();
    public void MaybeRefreshBlocking();
    protected virtual void AfterMaybeRefresh();
    public void Release(G reference);
    private void NotifyRefreshListenersBefore();
    private void NotifyRefreshListenersRefreshed(bool didRefresh);
    public virtual void AddListener(IRefreshListener listener);
    public virtual void RemoveListener(IRefreshListener listener);
}
[ExtensionAttribute]
public static class Lucene.Net.Search.ReferenceManagerExtensions : object {
    [ExtensionAttribute]
public static ReferenceContext`1<T> GetContext(ReferenceManager`1<T> referenceManager);
}
public class Lucene.Net.Search.RegexpQuery : AutomatonQuery {
    private static IAutomatonProvider defaultProvider;
    public RegexpQuery(Term term);
    public RegexpQuery(Term term, RegExpSyntax flags);
    public RegexpQuery(Term term, RegExpSyntax flags, IAutomatonProvider provider);
    private static RegexpQuery();
    public virtual string ToString(string field);
}
internal class Lucene.Net.Search.ReqExclScorer : Scorer {
    private Scorer reqScorer;
    private DocIdSetIterator exclDisi;
    private int doc;
    public int DocID { get; }
    public int Freq { get; }
    public ReqExclScorer(Scorer reqScorer, DocIdSetIterator exclDisi);
    public virtual int NextDoc();
    private int ToNonExcluded();
    public virtual int get_DocID();
    public virtual float GetScore();
    public virtual int get_Freq();
    public virtual ICollection`1<ChildScorer> GetChildren();
    public virtual int Advance(int target);
    public virtual long GetCost();
}
internal class Lucene.Net.Search.ReqOptSumScorer : Scorer {
    private Scorer reqScorer;
    private Scorer optScorer;
    public int DocID { get; }
    public int Freq { get; }
    public ReqOptSumScorer(Scorer reqScorer, Scorer optScorer);
    public virtual int NextDoc();
    public virtual int Advance(int target);
    public virtual int get_DocID();
    public virtual float GetScore();
    public virtual int get_Freq();
    public virtual ICollection`1<ChildScorer> GetChildren();
    public virtual long GetCost();
}
public abstract class Lucene.Net.Search.Rescorer : object {
    public abstract virtual TopDocs Rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN);
    public abstract virtual Explanation Explain(IndexSearcher searcher, Explanation firstPassExplanation, int docID);
}
public class Lucene.Net.Search.ScoreCachingWrappingScorer : Scorer {
    private Scorer scorer;
    private int curDoc;
    private float curScore;
    public int Freq { get; }
    public int DocID { get; }
    public ScoreCachingWrappingScorer(Scorer scorer);
    public virtual float GetScore();
    public virtual int get_Freq();
    public virtual int get_DocID();
    public virtual int NextDoc();
    public virtual int Advance(int target);
    public virtual ICollection`1<ChildScorer> GetChildren();
    public virtual long GetCost();
}
public class Lucene.Net.Search.ScoreDoc : object {
    [CompilerGeneratedAttribute]
private float <Score>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Doc>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ShardIndex>k__BackingField;
    public float Score { get; public set; }
    public int Doc { get; public set; }
    public int ShardIndex { get; public set; }
    public ScoreDoc(int doc, float score);
    public ScoreDoc(int doc, float score, int shardIndex);
    [CompilerGeneratedAttribute]
public float get_Score();
    [CompilerGeneratedAttribute]
public void set_Score(float value);
    [CompilerGeneratedAttribute]
public int get_Doc();
    [CompilerGeneratedAttribute]
public void set_Doc(int value);
    [CompilerGeneratedAttribute]
public int get_ShardIndex();
    [CompilerGeneratedAttribute]
public void set_ShardIndex(int value);
    public virtual string ToString();
}
public abstract class Lucene.Net.Search.Scorer : DocsEnum {
    protected internal Weight m_weight;
    public Weight Weight { get; }
    protected Scorer(Weight weight);
    public abstract virtual float GetScore();
    public virtual Weight get_Weight();
    public virtual ICollection`1<ChildScorer> GetChildren();
}
public abstract class Lucene.Net.Search.ScoringRewrite`1 : TermCollectingRewrite`1<Q> {
    public static ScoringRewrite`1<BooleanQuery> SCORING_BOOLEAN_QUERY_REWRITE;
    public static RewriteMethod CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE;
    private static ScoringRewrite`1();
    protected abstract virtual void CheckMaxClauseCount(int count);
    public virtual Query Rewrite(IndexReader reader, MultiTermQuery query);
}
public class Lucene.Net.Search.SearcherFactory : object {
    public virtual IndexSearcher NewSearcher(IndexReader reader);
}
public class Lucene.Net.Search.SearcherLifetimeManager : object {
    internal static double NANOS_PER_SEC;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _closed;
    private ConcurrentDictionary`2<long, Lazy`1<SearcherTracker>> _searchers;
    private void EnsureOpen();
    public virtual long Record(IndexSearcher searcher);
    public virtual IndexSearcher Acquire(long version);
    public virtual void Release(IndexSearcher s);
    public virtual void Prune(IPruner pruner);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class Lucene.Net.Search.SearcherManager : ReferenceManager`1<IndexSearcher> {
    private SearcherFactory searcherFactory;
    public SearcherManager(IndexWriter writer, bool applyAllDeletes, SearcherFactory searcherFactory);
    public SearcherManager(Directory dir, SearcherFactory searcherFactory);
    protected virtual void DecRef(IndexSearcher reference);
    protected virtual IndexSearcher RefreshIfNeeded(IndexSearcher referenceToRefresh);
    protected virtual bool TryIncRef(IndexSearcher reference);
    protected virtual int GetRefCount(IndexSearcher reference);
    public bool IsSearcherCurrent();
    public static IndexSearcher GetSearcher(SearcherFactory searcherFactory, IndexReader reader);
}
public abstract class Lucene.Net.Search.Similarities.AfterEffect : object {
    public abstract virtual float Score(BasicStats stats, float tfn);
    public abstract virtual Explanation Explain(BasicStats stats, float tfn);
    public abstract virtual string ToString();
}
public class Lucene.Net.Search.Similarities.AfterEffectB : AfterEffect {
    public sealed virtual float Score(BasicStats stats, float tfn);
    public sealed virtual Explanation Explain(BasicStats stats, float tfn);
    public virtual string ToString();
}
public class Lucene.Net.Search.Similarities.AfterEffectL : AfterEffect {
    public sealed virtual float Score(BasicStats stats, float tfn);
    public sealed virtual Explanation Explain(BasicStats stats, float tfn);
    public virtual string ToString();
}
public abstract class Lucene.Net.Search.Similarities.BasicModel : object {
    public abstract virtual float Score(BasicStats stats, float tfn);
    public virtual Explanation Explain(BasicStats stats, float tfn);
    public abstract virtual string ToString();
}
public class Lucene.Net.Search.Similarities.BasicModelBE : BasicModel {
    public sealed virtual float Score(BasicStats stats, float tfn);
    private double F(double n, double m);
    public virtual string ToString();
}
public class Lucene.Net.Search.Similarities.BasicModelD : BasicModel {
    public sealed virtual float Score(BasicStats stats, float tfn);
    public virtual string ToString();
}
public class Lucene.Net.Search.Similarities.BasicModelG : BasicModel {
    public sealed virtual float Score(BasicStats stats, float tfn);
    public virtual string ToString();
}
public class Lucene.Net.Search.Similarities.BasicModelIF : BasicModel {
    public sealed virtual float Score(BasicStats stats, float tfn);
    public virtual string ToString();
}
public class Lucene.Net.Search.Similarities.BasicModelIn : BasicModel {
    public sealed virtual float Score(BasicStats stats, float tfn);
    public sealed virtual Explanation Explain(BasicStats stats, float tfn);
    public virtual string ToString();
}
public class Lucene.Net.Search.Similarities.BasicModelIne : BasicModel {
    public sealed virtual float Score(BasicStats stats, float tfn);
    public virtual string ToString();
}
public class Lucene.Net.Search.Similarities.BasicModelP : BasicModel {
    protected internal static double LOG2_E;
    private static BasicModelP();
    public sealed virtual float Score(BasicStats stats, float tfn);
    public virtual string ToString();
}
public class Lucene.Net.Search.Similarities.BasicStats : SimWeight {
    private string field;
    protected long m_numberOfDocuments;
    protected long m_numberOfFieldTokens;
    protected internal float m_avgFieldLength;
    protected long m_docFreq;
    protected long m_totalTermFreq;
    protected float m_queryBoost;
    protected float m_topLevelBoost;
    protected float m_totalBoost;
    public long NumberOfDocuments { get; public set; }
    public long NumberOfFieldTokens { get; public set; }
    public float AvgFieldLength { get; public set; }
    public long DocFreq { get; public set; }
    public long TotalTermFreq { get; public set; }
    public string Field { get; }
    public float TotalBoost { get; }
    public BasicStats(string field, float queryBoost);
    public virtual long get_NumberOfDocuments();
    public virtual void set_NumberOfDocuments(long value);
    public virtual long get_NumberOfFieldTokens();
    public virtual void set_NumberOfFieldTokens(long value);
    public virtual float get_AvgFieldLength();
    public virtual void set_AvgFieldLength(float value);
    public virtual long get_DocFreq();
    public virtual void set_DocFreq(long value);
    public virtual long get_TotalTermFreq();
    public virtual void set_TotalTermFreq(long value);
    public string get_Field();
    public virtual float GetValueForNormalization();
    protected internal virtual float RawNormalizationValue();
    public virtual void Normalize(float queryNorm, float topLevelBoost);
    public virtual float get_TotalBoost();
}
public class Lucene.Net.Search.Similarities.BM25Similarity : Similarity {
    private float k1;
    private float b;
    private bool discountOverlaps;
    private static Single[] NORM_TABLE;
    public bool DiscountOverlaps { get; public set; }
    public float K1 { get; }
    public float B { get; }
    public BM25Similarity(float k1, float b);
    private static BM25Similarity();
    protected internal virtual float Idf(long docFreq, long numDocs);
    protected internal virtual float SloppyFreq(int distance);
    protected internal virtual float ScorePayload(int doc, int start, int end, BytesRef payload);
    protected internal virtual float AvgFieldLength(CollectionStatistics collectionStats);
    protected internal virtual byte EncodeNormValue(float boost, int fieldLength);
    protected internal virtual float DecodeNormValue(byte b);
    public virtual bool get_DiscountOverlaps();
    public virtual void set_DiscountOverlaps(bool value);
    private static Single[] LoadNormTable();
    public sealed virtual long ComputeNorm(FieldInvertState state);
    public virtual Explanation IdfExplain(CollectionStatistics collectionStats, TermStatistics termStats);
    public virtual Explanation IdfExplain(CollectionStatistics collectionStats, TermStatistics[] termStats);
    public sealed virtual SimWeight ComputeWeight(float queryBoost, CollectionStatistics collectionStats, TermStatistics[] termStats);
    public sealed virtual SimScorer GetSimScorer(SimWeight stats, AtomicReaderContext context);
    private Explanation ExplainScore(int doc, Explanation freq, BM25Stats stats, NumericDocValues norms);
    public virtual string ToString();
    public virtual float get_K1();
    public virtual float get_B();
}
public class Lucene.Net.Search.Similarities.DefaultSimilarity : TFIDFSimilarity {
    private static Single[] NORM_TABLE;
    protected bool m_discountOverlaps;
    public bool DiscountOverlaps { get; public set; }
    private static DefaultSimilarity();
    private static Single[] LoadNormTable();
    public virtual float Coord(int overlap, int maxOverlap);
    public virtual float QueryNorm(float sumOfSquaredWeights);
    public sealed virtual long EncodeNormValue(float f);
    public sealed virtual float DecodeNormValue(long norm);
    public virtual float LengthNorm(FieldInvertState state);
    public virtual float Tf(float freq);
    public virtual float SloppyFreq(int distance);
    public virtual float ScorePayload(int doc, int start, int end, BytesRef payload);
    public virtual float Idf(long docFreq, long numDocs);
    public virtual bool get_DiscountOverlaps();
    public virtual void set_DiscountOverlaps(bool value);
    public virtual string ToString();
}
public class Lucene.Net.Search.Similarities.DFRSimilarity : SimilarityBase {
    protected internal BasicModel m_basicModel;
    protected internal AfterEffect m_afterEffect;
    protected internal Normalization m_normalization;
    public BasicModel BasicModel { get; }
    public AfterEffect AfterEffect { get; }
    public Normalization Normalization { get; }
    public DFRSimilarity(BasicModel basicModel, AfterEffect afterEffect, Normalization normalization);
    public virtual float Score(BasicStats stats, float freq, float docLen);
    protected internal virtual void Explain(Explanation expl, BasicStats stats, int doc, float freq, float docLen);
    public virtual string ToString();
    public virtual BasicModel get_BasicModel();
    public virtual AfterEffect get_AfterEffect();
    public virtual Normalization get_Normalization();
}
public abstract class Lucene.Net.Search.Similarities.Distribution : object {
    public abstract virtual float Score(BasicStats stats, float tfn, float lambda);
    public virtual Explanation Explain(BasicStats stats, float tfn, float lambda);
    public abstract virtual string ToString();
}
public class Lucene.Net.Search.Similarities.DistributionLL : Distribution {
    public sealed virtual float Score(BasicStats stats, float tfn, float lambda);
    public virtual string ToString();
}
public class Lucene.Net.Search.Similarities.DistributionSPL : Distribution {
    public sealed virtual float Score(BasicStats stats, float tfn, float lambda);
    public virtual string ToString();
}
[ExceptionToClassNameConventionAttribute]
public class Lucene.Net.Search.Similarities.IBSimilarity : SimilarityBase {
    protected internal Distribution m_distribution;
    protected internal Lambda m_lambda;
    protected internal Normalization m_normalization;
    public Distribution Distribution { get; }
    public Lambda Lambda { get; }
    public Normalization Normalization { get; }
    public IBSimilarity(Distribution distribution, Lambda lambda, Normalization normalization);
    public virtual float Score(BasicStats stats, float freq, float docLen);
    protected internal virtual void Explain(Explanation expl, BasicStats stats, int doc, float freq, float docLen);
    public virtual string ToString();
    public virtual Distribution get_Distribution();
    public virtual Lambda get_Lambda();
    public virtual Normalization get_Normalization();
}
public abstract class Lucene.Net.Search.Similarities.Lambda : object {
    public abstract virtual float CalculateLambda(BasicStats stats);
    public abstract virtual Explanation Explain(BasicStats stats);
    public abstract virtual string ToString();
}
public class Lucene.Net.Search.Similarities.LambdaDF : Lambda {
    public sealed virtual float CalculateLambda(BasicStats stats);
    public sealed virtual Explanation Explain(BasicStats stats);
    public virtual string ToString();
}
public class Lucene.Net.Search.Similarities.LambdaTTF : Lambda {
    public sealed virtual float CalculateLambda(BasicStats stats);
    public sealed virtual Explanation Explain(BasicStats stats);
    public virtual string ToString();
}
public class Lucene.Net.Search.Similarities.LMDirichletSimilarity : LMSimilarity {
    private float mu;
    public float Mu { get; }
    public LMDirichletSimilarity(ICollectionModel collectionModel, float mu);
    public LMDirichletSimilarity(float mu);
    public LMDirichletSimilarity(ICollectionModel collectionModel);
    public virtual float Score(BasicStats stats, float freq, float docLen);
    protected internal virtual void Explain(Explanation expl, BasicStats stats, int doc, float freq, float docLen);
    public virtual float get_Mu();
    public virtual string GetName();
}
public class Lucene.Net.Search.Similarities.LMJelinekMercerSimilarity : LMSimilarity {
    private float lambda;
    public float Lambda { get; }
    public LMJelinekMercerSimilarity(ICollectionModel collectionModel, float lambda);
    public LMJelinekMercerSimilarity(float lambda);
    public virtual float Score(BasicStats stats, float freq, float docLen);
    protected internal virtual void Explain(Explanation expl, BasicStats stats, int doc, float freq, float docLen);
    public virtual float get_Lambda();
    public virtual string GetName();
}
public abstract class Lucene.Net.Search.Similarities.LMSimilarity : SimilarityBase {
    protected ICollectionModel m_collectionModel;
    protected LMSimilarity(ICollectionModel collectionModel);
    protected internal virtual BasicStats NewStats(string field, float queryBoost);
    protected internal virtual void FillBasicStats(BasicStats stats, CollectionStatistics collectionStats, TermStatistics termStats);
    protected internal virtual void Explain(Explanation expl, BasicStats stats, int doc, float freq, float docLen);
    public abstract virtual string GetName();
    public virtual string ToString();
}
public class Lucene.Net.Search.Similarities.MultiSimilarity : Similarity {
    protected internal Similarity[] m_sims;
    public MultiSimilarity(Similarity[] sims);
    public virtual long ComputeNorm(FieldInvertState state);
    public virtual SimWeight ComputeWeight(float queryBoost, CollectionStatistics collectionStats, TermStatistics[] termStats);
    public virtual SimScorer GetSimScorer(SimWeight stats, AtomicReaderContext context);
}
public abstract class Lucene.Net.Search.Similarities.Normalization : object {
    public abstract virtual float Tfn(BasicStats stats, float tf, float len);
    public virtual Explanation Explain(BasicStats stats, float tf, float len);
    public abstract virtual string ToString();
}
public class Lucene.Net.Search.Similarities.NormalizationH1 : Normalization {
    private float c;
    public float C { get; }
    public NormalizationH1(float c);
    public sealed virtual float Tfn(BasicStats stats, float tf, float len);
    public virtual string ToString();
    public virtual float get_C();
}
public class Lucene.Net.Search.Similarities.NormalizationH2 : Normalization {
    private float c;
    public float C { get; }
    public NormalizationH2(float c);
    public sealed virtual float Tfn(BasicStats stats, float tf, float len);
    public virtual string ToString();
    public virtual float get_C();
}
public class Lucene.Net.Search.Similarities.NormalizationH3 : Normalization {
    private float mu;
    public float Mu { get; }
    public NormalizationH3(float mu);
    public virtual float Tfn(BasicStats stats, float tf, float len);
    public virtual string ToString();
    public virtual float get_Mu();
}
public class Lucene.Net.Search.Similarities.NormalizationZ : Normalization {
    internal float z;
    public float Z { get; }
    public NormalizationZ(float z);
    public virtual float Tfn(BasicStats stats, float tf, float len);
    public virtual string ToString();
    public virtual float get_Z();
}
public abstract class Lucene.Net.Search.Similarities.PerFieldSimilarityWrapper : Similarity {
    public sealed virtual long ComputeNorm(FieldInvertState state);
    public sealed virtual SimWeight ComputeWeight(float queryBoost, CollectionStatistics collectionStats, TermStatistics[] termStats);
    public sealed virtual SimScorer GetSimScorer(SimWeight weight, AtomicReaderContext context);
    public abstract virtual Similarity Get(string name);
}
public abstract class Lucene.Net.Search.Similarities.Similarity : object {
    public virtual float Coord(int overlap, int maxOverlap);
    public virtual float QueryNorm(float valueForNormalization);
    public abstract virtual long ComputeNorm(FieldInvertState state);
    public abstract virtual SimWeight ComputeWeight(float queryBoost, CollectionStatistics collectionStats, TermStatistics[] termStats);
    public abstract virtual SimScorer GetSimScorer(SimWeight weight, AtomicReaderContext context);
}
public abstract class Lucene.Net.Search.Similarities.SimilarityBase : Similarity {
    private static double LOG_2;
    private bool discountOverlaps;
    private static Single[] NORM_TABLE;
    public bool DiscountOverlaps { get; public set; }
    private static SimilarityBase();
    public virtual bool get_DiscountOverlaps();
    public virtual void set_DiscountOverlaps(bool value);
    public sealed virtual SimWeight ComputeWeight(float queryBoost, CollectionStatistics collectionStats, TermStatistics[] termStats);
    protected internal virtual BasicStats NewStats(string field, float queryBoost);
    protected internal virtual void FillBasicStats(BasicStats stats, CollectionStatistics collectionStats, TermStatistics termStats);
    public abstract virtual float Score(BasicStats stats, float freq, float docLen);
    protected internal virtual void Explain(Explanation expl, BasicStats stats, int doc, float freq, float docLen);
    public virtual Explanation Explain(BasicStats stats, int doc, Explanation freq, float docLen);
    public virtual SimScorer GetSimScorer(SimWeight stats, AtomicReaderContext context);
    public abstract virtual string ToString();
    private static Single[] LoadNormTable();
    public virtual long ComputeNorm(FieldInvertState state);
    protected internal virtual float DecodeNormValue(byte norm);
    protected internal virtual byte EncodeNormValue(float boost, float length);
    public static double Log2(double x);
}
public abstract class Lucene.Net.Search.Similarities.TFIDFSimilarity : Similarity {
    public abstract virtual float Coord(int overlap, int maxOverlap);
    public abstract virtual float QueryNorm(float sumOfSquaredWeights);
    public abstract virtual float Tf(float freq);
    public virtual Explanation IdfExplain(CollectionStatistics collectionStats, TermStatistics termStats);
    public virtual Explanation IdfExplain(CollectionStatistics collectionStats, TermStatistics[] termStats);
    public abstract virtual float Idf(long docFreq, long numDocs);
    public abstract virtual float LengthNorm(FieldInvertState state);
    public sealed virtual long ComputeNorm(FieldInvertState state);
    public abstract virtual float DecodeNormValue(long norm);
    public abstract virtual long EncodeNormValue(float f);
    public abstract virtual float SloppyFreq(int distance);
    public abstract virtual float ScorePayload(int doc, int start, int end, BytesRef payload);
    public sealed virtual SimWeight ComputeWeight(float queryBoost, CollectionStatistics collectionStats, TermStatistics[] termStats);
    public sealed virtual SimScorer GetSimScorer(SimWeight stats, AtomicReaderContext context);
    private Explanation ExplainScore(int doc, Explanation freq, IDFStats stats, NumericDocValues norms);
}
internal class Lucene.Net.Search.SloppyPhraseScorer : Scorer {
    private PhrasePositions min;
    private PhrasePositions max;
    private float sloppyFreq;
    private SimScorer docScorer;
    private int slop;
    private int numPostings;
    private PhraseQueue pq;
    private int end;
    private bool hasRpts;
    private bool checkedRpts;
    private bool hasMultiTermRpts;
    private PhrasePositions[][] rptGroups;
    private PhrasePositions[] rptStack;
    private int numMatches;
    private long cost;
    public int Freq { get; }
    internal float SloppyFreq { get; }
    public int DocID { get; }
    internal SloppyPhraseScorer(Weight weight, PostingsAndFreq[] postings, int slop, SimScorer docScorer);
    private float PhraseFreq();
    private bool AdvancePP(PhrasePositions pp);
    private bool AdvanceRpts(PhrasePositions pp);
    private static PhrasePositions Lesser(PhrasePositions pp, PhrasePositions pp2);
    private int Collide(PhrasePositions pp);
    private bool InitPhrasePositions();
    private void InitSimple();
    private bool InitComplex();
    private void PlaceFirstPositions();
    private void FillQueue();
    private bool AdvanceRepeatGroups();
    private bool InitFirstTime();
    private void SortRptGroups(IList`1<IList`1<PhrasePositions>> rgs);
    private IList`1<IList`1<PhrasePositions>> GatherRptGroups(LinkedDictionary`2<Term, int> rptTerms);
    private static int TpPos(PhrasePositions pp);
    private LinkedDictionary`2<Term, int> RepeatingTerms();
    private PhrasePositions[] RepeatingPPs(IDictionary`2<Term, int> rptTerms);
    private static IList`1<FixedBitSet> PpTermsBitSets(PhrasePositions[] rpp, IDictionary`2<Term, int> tord);
    private static void UnionTermGroups(IList`1<FixedBitSet> bb);
    private static IDictionary`2<Term, int> TermGroups(LinkedDictionary`2<Term, int> tord, IList`1<FixedBitSet> bb);
    public virtual int get_Freq();
    internal float get_SloppyFreq();
    private bool AdvanceMin(int target);
    public virtual int get_DocID();
    public virtual int NextDoc();
    public virtual float GetScore();
    public virtual int Advance(int target);
    public virtual long GetCost();
    public virtual string ToString();
}
public class Lucene.Net.Search.Sort : object {
    public static Sort RELEVANCE;
    public static Sort INDEXORDER;
    internal SortField[] fields;
    public bool NeedsScores { get; }
    public Sort(SortField field);
    public Sort(SortField[] fields);
    private static Sort();
    public virtual void SetSort(SortField field);
    public virtual void SetSort(SortField[] fields);
    [WritableArrayAttribute]
public virtual SortField[] GetSort();
    public virtual Sort Rewrite(IndexSearcher searcher);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual bool get_NeedsScores();
}
public class Lucene.Net.Search.SortField : object {
    public static SortField FIELD_SCORE;
    public static SortField FIELD_DOC;
    private string field;
    private SortFieldType type;
    internal bool reverse;
    private IParser parser;
    private FieldComparerSource comparerSource;
    protected object m_missingValue;
    public static object STRING_FIRST;
    public static object STRING_LAST;
    private IComparer`1<BytesRef> bytesComparer;
    public object MissingValue { get; }
    public string Field { get; }
    public SortFieldType Type { get; }
    public IParser Parser { get; }
    public bool IsReverse { get; }
    public FieldComparerSource ComparerSource { get; }
    public IComparer`1<BytesRef> BytesComparer { get; public set; }
    public bool NeedsScores { get; }
    public SortField(string field, SortFieldType type);
    public SortField(string field, SortFieldType type, bool reverse);
    public SortField(string field, IParser parser);
    public SortField(string field, IParser parser, bool reverse);
    public SortField(string field, FieldComparerSource comparer);
    public SortField(string field, FieldComparerSource comparer, bool reverse);
    private static SortField();
    public object get_MissingValue();
    public virtual void SetMissingValue(object value);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute]
public void SetMissingValue(sbyte value);
    [ObsoleteAttribute]
public void SetMissingValue(byte value);
    [ObsoleteAttribute]
public void SetMissingValue(short value);
    public void SetMissingValue(int value);
    public void SetMissingValue(long value);
    public void SetMissingValue(double value);
    public void SetMissingValue(float value);
    private void InitFieldType(string field, SortFieldType type);
    public virtual string get_Field();
    public virtual SortFieldType get_Type();
    public virtual IParser get_Parser();
    public virtual bool get_IsReverse();
    public virtual FieldComparerSource get_ComparerSource();
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual IComparer`1<BytesRef> get_BytesComparer();
    public virtual void set_BytesComparer(IComparer`1<BytesRef> value);
    public virtual FieldComparer GetComparer(int numHits, int sortPos);
    public virtual SortField Rewrite(IndexSearcher searcher);
    public virtual bool get_NeedsScores();
}
public enum Lucene.Net.Search.SortFieldType : Enum {
    public int value__;
    public static SortFieldType SCORE;
    public static SortFieldType DOC;
    public static SortFieldType STRING;
    public static SortFieldType INT32;
    public static SortFieldType SINGLE;
    public static SortFieldType INT64;
    public static SortFieldType DOUBLE;
    [ObsoleteAttribute]
public static SortFieldType INT16;
    public static SortFieldType CUSTOM;
    [ObsoleteAttribute]
public static SortFieldType BYTE;
    public static SortFieldType STRING_VAL;
    public static SortFieldType BYTES;
    public static SortFieldType REWRITEABLE;
}
public class Lucene.Net.Search.SortRescorer : Rescorer {
    private Sort sort;
    public SortRescorer(Sort sort);
    public virtual TopDocs Rescore(IndexSearcher searcher, TopDocs firstPassTopDocs, int topN);
    public virtual Explanation Explain(IndexSearcher searcher, Explanation firstPassExplanation, int docID);
}
public class Lucene.Net.Search.Spans.FieldMaskingSpanQuery : SpanQuery {
    private SpanQuery maskedQuery;
    private string field;
    public string Field { get; }
    public SpanQuery MaskedQuery { get; }
    public FieldMaskingSpanQuery(SpanQuery maskedQuery, string maskedField);
    public virtual string get_Field();
    public virtual SpanQuery get_MaskedQuery();
    public virtual Spans GetSpans(AtomicReaderContext context, IBits acceptDocs, IDictionary`2<Term, TermContext> termContexts);
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual Weight CreateWeight(IndexSearcher searcher);
    public virtual Query Rewrite(IndexReader reader);
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public interface Lucene.Net.Search.Spans.ISpanMultiTermQueryWrapper {
    public SpanRewriteMethod MultiTermRewriteMethod { get; }
    public string Field { get; }
    public Query WrappedQuery { get; }
    public abstract virtual SpanRewriteMethod get_MultiTermRewriteMethod();
    public abstract virtual Spans GetSpans(AtomicReaderContext context, IBits acceptDocs, IDictionary`2<Term, TermContext> termContexts);
    public abstract virtual string get_Field();
    public abstract virtual Query get_WrappedQuery();
    public abstract virtual Query Rewrite(IndexReader reader);
}
public class Lucene.Net.Search.Spans.NearSpansOrdered : Spans {
    private int allowedSlop;
    private bool firstTime;
    private bool more;
    private Spans[] subSpans;
    private bool inSameDoc;
    private int matchDoc;
    private int matchStart;
    private int matchEnd;
    private List`1<Byte[]> matchPayload;
    private Spans[] subSpansByDoc;
    private InPlaceMergeSorter sorter;
    private SpanNearQuery query;
    private bool collectPayloads;
    public int Doc { get; }
    public int Start { get; }
    public int End { get; }
    [WritableArrayAttribute]
public Spans[] SubSpans { get; }
    public bool IsPayloadAvailable { get; }
    public NearSpansOrdered(SpanNearQuery spanNearQuery, AtomicReaderContext context, IBits acceptDocs, IDictionary`2<Term, TermContext> termContexts);
    public NearSpansOrdered(SpanNearQuery spanNearQuery, AtomicReaderContext context, IBits acceptDocs, IDictionary`2<Term, TermContext> termContexts, bool collectPayloads);
    public virtual int get_Doc();
    public virtual int get_Start();
    public virtual int get_End();
    public virtual Spans[] get_SubSpans();
    public virtual ICollection`1<Byte[]> GetPayload();
    public virtual bool get_IsPayloadAvailable();
    public virtual long GetCost();
    public virtual bool MoveNext();
    public virtual bool SkipTo(int target);
    private bool AdvanceAfterOrdered();
    private bool ToSameDoc();
    internal static bool DocSpansOrdered(Spans spans1, Spans spans2);
    private static bool DocSpansOrdered(int start1, int end1, int start2, int end2);
    private bool StretchToOrder();
    private bool ShrinkToAfterShortestMatch();
    public virtual string ToString();
}
public class Lucene.Net.Search.Spans.NearSpansUnordered : Spans {
    private SpanNearQuery query;
    private IList`1<SpansCell> ordered;
    private Spans[] subSpans;
    private int slop;
    private SpansCell first;
    private SpansCell last;
    private int totalLength;
    private CellQueue queue;
    private SpansCell max;
    private bool more;
    private bool firstTime;
    [WritableArrayAttribute]
public Spans[] SubSpans { get; }
    private SpansCell Min { get; }
    public int Doc { get; }
    public int Start { get; }
    public int End { get; }
    public bool IsPayloadAvailable { get; }
    private bool AtMatch { get; }
    public NearSpansUnordered(SpanNearQuery query, AtomicReaderContext context, IBits acceptDocs, IDictionary`2<Term, TermContext> termContexts);
    public virtual Spans[] get_SubSpans();
    public virtual bool MoveNext();
    public virtual bool SkipTo(int target);
    private SpansCell get_Min();
    public virtual int get_Doc();
    public virtual int get_Start();
    public virtual int get_End();
    public virtual ICollection`1<Byte[]> GetPayload();
    public virtual bool get_IsPayloadAvailable();
    public virtual long GetCost();
    public virtual string ToString();
    private void InitList(bool next);
    private void AddToList(SpansCell cell);
    private void FirstToLast();
    private void QueueToList();
    private void ListToQueue();
    private bool get_AtMatch();
}
public class Lucene.Net.Search.Spans.SpanFirstQuery : SpanPositionRangeQuery {
    public SpanFirstQuery(SpanQuery match, int end);
    protected virtual AcceptStatus AcceptPosition(Spans spans);
    public virtual string ToString(string field);
    public virtual object Clone();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1 : SpanQuery {
    protected Q m_query;
    public static SpanRewriteMethod SCORING_SPAN_QUERY_REWRITE;
    public SpanRewriteMethod MultiTermRewriteMethod { get; public set; }
    public string Field { get; }
    public Query WrappedQuery { get; }
    public SpanMultiTermQueryWrapper`1(Q query);
    private static SpanMultiTermQueryWrapper`1();
    public sealed virtual SpanRewriteMethod get_MultiTermRewriteMethod();
    public void set_MultiTermRewriteMethod(SpanRewriteMethod value);
    public virtual Spans GetSpans(AtomicReaderContext context, IBits acceptDocs, IDictionary`2<Term, TermContext> termContexts);
    public virtual string get_Field();
    public virtual Query get_WrappedQuery();
    public virtual string ToString(string field);
    public virtual Query Rewrite(IndexReader reader);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Lucene.Net.Search.Spans.SpanNearPayloadCheckQuery : SpanPositionCheckQuery {
    protected ICollection`1<Byte[]> m_payloadToMatch;
    private IEqualityComparer payloadEqualityComparer;
    public SpanNearPayloadCheckQuery(SpanNearQuery match, ICollection`1<Byte[]> payloadToMatch);
    protected virtual AcceptStatus AcceptPosition(Spans spans);
    public virtual string ToString(string field);
    public virtual object Clone();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.Spans.SpanNearQuery : SpanQuery {
    protected IList`1<SpanQuery> m_clauses;
    protected int m_slop;
    protected bool m_inOrder;
    protected string m_field;
    private bool collectPayloads;
    public int Slop { get; }
    public bool IsInOrder { get; }
    public string Field { get; }
    public SpanNearQuery(SpanQuery[] clauses, int slop, bool inOrder);
    public SpanNearQuery(SpanQuery[] clauses, int slop, bool inOrder, bool collectPayloads);
    public virtual SpanQuery[] GetClauses();
    public virtual int get_Slop();
    public virtual bool get_IsInOrder();
    public virtual string get_Field();
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual string ToString(string field);
    public virtual Spans GetSpans(AtomicReaderContext context, IBits acceptDocs, IDictionary`2<Term, TermContext> termContexts);
    public virtual Query Rewrite(IndexReader reader);
    public virtual object Clone();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.Spans.SpanNotQuery : SpanQuery {
    private SpanQuery include;
    private SpanQuery exclude;
    private int pre;
    private int post;
    public SpanQuery Include { get; }
    public SpanQuery Exclude { get; }
    public string Field { get; }
    public SpanNotQuery(SpanQuery include, SpanQuery exclude);
    public SpanNotQuery(SpanQuery include, SpanQuery exclude, int dist);
    public SpanNotQuery(SpanQuery include, SpanQuery exclude, int pre, int post);
    public virtual SpanQuery get_Include();
    public virtual SpanQuery get_Exclude();
    public virtual string get_Field();
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual string ToString(string field);
    public virtual object Clone();
    public virtual Spans GetSpans(AtomicReaderContext context, IBits acceptDocs, IDictionary`2<Term, TermContext> termContexts);
    public virtual Query Rewrite(IndexReader reader);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.Spans.SpanOrQuery : SpanQuery {
    private IList`1<SpanQuery> clauses;
    private string field;
    public string Field { get; }
    public SpanOrQuery(SpanQuery[] clauses);
    internal SpanOrQuery(IList`1<SpanQuery> clauses);
    public void AddClause(SpanQuery clause);
    public virtual SpanQuery[] GetClauses();
    public virtual string get_Field();
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual object Clone();
    public virtual Query Rewrite(IndexReader reader);
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual Spans GetSpans(AtomicReaderContext context, IBits acceptDocs, IDictionary`2<Term, TermContext> termContexts);
}
public class Lucene.Net.Search.Spans.SpanPayloadCheckQuery : SpanPositionCheckQuery {
    protected ICollection`1<Byte[]> m_payloadToMatch;
    private IEqualityComparer payloadEqualityComparer;
    public SpanPayloadCheckQuery(SpanQuery match, ICollection`1<Byte[]> payloadToMatch);
    protected virtual AcceptStatus AcceptPosition(Spans spans);
    public virtual string ToString(string field);
    public virtual object Clone();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public abstract class Lucene.Net.Search.Spans.SpanPositionCheckQuery : SpanQuery {
    protected SpanQuery m_match;
    public SpanQuery Match { get; }
    public string Field { get; }
    protected SpanPositionCheckQuery(SpanQuery match);
    public virtual SpanQuery get_Match();
    public virtual string get_Field();
    public virtual void ExtractTerms(ISet`1<Term> terms);
    protected abstract virtual AcceptStatus AcceptPosition(Spans spans);
    public virtual Spans GetSpans(AtomicReaderContext context, IBits acceptDocs, IDictionary`2<Term, TermContext> termContexts);
    public virtual Query Rewrite(IndexReader reader);
}
public class Lucene.Net.Search.Spans.SpanPositionRangeQuery : SpanPositionCheckQuery {
    protected int m_start;
    protected int m_end;
    public int Start { get; }
    public int End { get; }
    public SpanPositionRangeQuery(SpanQuery match, int start, int end);
    protected virtual AcceptStatus AcceptPosition(Spans spans);
    public virtual int get_Start();
    public virtual int get_End();
    public virtual string ToString(string field);
    public virtual object Clone();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public abstract class Lucene.Net.Search.Spans.SpanQuery : Query {
    public string Field { get; }
    public abstract virtual Spans GetSpans(AtomicReaderContext context, IBits acceptDocs, IDictionary`2<Term, TermContext> termContexts);
    public abstract virtual string get_Field();
    public virtual Weight CreateWeight(IndexSearcher searcher);
}
public abstract class Lucene.Net.Search.Spans.SpanRewriteMethod : RewriteMethod {
    public abstract virtual Query Rewrite(IndexReader reader, MultiTermQuery query);
}
public abstract class Lucene.Net.Search.Spans.Spans : object {
    public int Doc { get; }
    public int Start { get; }
    public int End { get; }
    public bool IsPayloadAvailable { get; }
    public abstract virtual bool MoveNext();
    [ObsoleteAttribute("Use MoveNext() instead. This method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public virtual bool Next();
    public abstract virtual bool SkipTo(int target);
    public abstract virtual int get_Doc();
    public abstract virtual int get_Start();
    public abstract virtual int get_End();
    public abstract virtual ICollection`1<Byte[]> GetPayload();
    public abstract virtual bool get_IsPayloadAvailable();
    public abstract virtual long GetCost();
}
public class Lucene.Net.Search.Spans.SpanScorer : Scorer {
    protected Spans m_spans;
    protected bool m_more;
    protected int m_doc;
    protected float m_freq;
    protected int m_numMatches;
    protected SimScorer m_docScorer;
    public int DocID { get; }
    public int Freq { get; }
    public float SloppyFreq { get; }
    protected internal SpanScorer(Spans spans, Weight weight, SimScorer docScorer);
    public virtual int NextDoc();
    public virtual int Advance(int target);
    protected virtual bool SetFreqCurrentDoc();
    public virtual int get_DocID();
    public virtual float GetScore();
    public virtual int get_Freq();
    public virtual float get_SloppyFreq();
    public virtual long GetCost();
}
public class Lucene.Net.Search.Spans.SpanTermQuery : SpanQuery {
    protected Term m_term;
    public Term Term { get; }
    public string Field { get; }
    public SpanTermQuery(Term term);
    public virtual Term get_Term();
    public virtual string get_Field();
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual string ToString(string field);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual Spans GetSpans(AtomicReaderContext context, IBits acceptDocs, IDictionary`2<Term, TermContext> termContexts);
}
public class Lucene.Net.Search.Spans.SpanWeight : Weight {
    protected Similarity m_similarity;
    protected IDictionary`2<Term, TermContext> m_termContexts;
    protected SpanQuery m_query;
    protected SimWeight m_stats;
    public Query Query { get; }
    public SpanWeight(SpanQuery query, IndexSearcher searcher);
    public virtual Query get_Query();
    public virtual float GetValueForNormalization();
    public virtual void Normalize(float queryNorm, float topLevelBoost);
    public virtual Scorer GetScorer(AtomicReaderContext context, IBits acceptDocs);
    public virtual Explanation Explain(AtomicReaderContext context, int doc);
}
public class Lucene.Net.Search.Spans.TermSpans : Spans {
    protected DocsAndPositionsEnum m_postings;
    protected Term m_term;
    protected int m_doc;
    protected int m_freq;
    protected int m_count;
    protected int m_position;
    protected bool m_readPayload;
    public static TermSpans EMPTY_TERM_SPANS;
    public int Doc { get; }
    public int Start { get; }
    public int End { get; }
    public bool IsPayloadAvailable { get; }
    public DocsAndPositionsEnum Postings { get; }
    public TermSpans(DocsAndPositionsEnum postings, Term term);
    private static TermSpans();
    public virtual bool MoveNext();
    public virtual bool SkipTo(int target);
    public virtual int get_Doc();
    public virtual int get_Start();
    public virtual int get_End();
    public virtual long GetCost();
    public virtual ICollection`1<Byte[]> GetPayload();
    public virtual bool get_IsPayloadAvailable();
    public virtual string ToString();
    public virtual DocsAndPositionsEnum get_Postings();
}
public abstract class Lucene.Net.Search.TermCollectingRewrite`1 : RewriteMethod {
    protected abstract virtual Q GetTopLevelQuery();
    protected void AddClause(Q topLevel, Term term, int docCount, float boost);
    protected abstract virtual void AddClause(Q topLevel, Term term, int docCount, float boost, TermContext states);
    internal void CollectTerms(IndexReader reader, MultiTermQuery query, TermCollector<Q> collector);
}
public class Lucene.Net.Search.TermQuery : Query {
    private Term term;
    private int docFreq;
    private TermContext perReaderTermState;
    public Term Term { get; }
    public TermQuery(Term t);
    public TermQuery(Term t, int docFreq);
    public TermQuery(Term t, TermContext states);
    public virtual Term get_Term();
    public virtual Weight CreateWeight(IndexSearcher searcher);
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Search.TermRangeFilter : MultiTermQueryWrapperFilter`1<TermRangeQuery> {
    public BytesRef LowerTerm { get; }
    public BytesRef UpperTerm { get; }
    public bool IncludesLower { get; }
    public bool IncludesUpper { get; }
    public TermRangeFilter(string fieldName, BytesRef lowerTerm, BytesRef upperTerm, bool includeLower, bool includeUpper);
    public static TermRangeFilter NewStringRange(string field, string lowerTerm, string upperTerm, bool includeLower, bool includeUpper);
    public static TermRangeFilter Less(string fieldName, BytesRef upperTerm);
    public static TermRangeFilter More(string fieldName, BytesRef lowerTerm);
    public virtual BytesRef get_LowerTerm();
    public virtual BytesRef get_UpperTerm();
    public virtual bool get_IncludesLower();
    public virtual bool get_IncludesUpper();
}
public class Lucene.Net.Search.TermRangeQuery : MultiTermQuery {
    private BytesRef lowerTerm;
    private BytesRef upperTerm;
    private bool includeLower;
    private bool includeUpper;
    public BytesRef LowerTerm { get; }
    public BytesRef UpperTerm { get; }
    public bool IncludesLower { get; }
    public bool IncludesUpper { get; }
    public TermRangeQuery(string field, BytesRef lowerTerm, BytesRef upperTerm, bool includeLower, bool includeUpper);
    public static TermRangeQuery NewStringRange(string field, string lowerTerm, string upperTerm, bool includeLower, bool includeUpper);
    public virtual BytesRef get_LowerTerm();
    public virtual BytesRef get_UpperTerm();
    public virtual bool get_IncludesLower();
    public virtual bool get_IncludesUpper();
    protected virtual TermsEnum GetTermsEnum(Terms terms, AttributeSource atts);
    public virtual string ToString(string field);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Lucene.Net.Search.TermRangeTermsEnum : FilteredTermsEnum {
    private bool includeLower;
    private bool includeUpper;
    private BytesRef lowerBytesRef;
    private BytesRef upperBytesRef;
    private IComparer`1<BytesRef> termComp;
    public TermRangeTermsEnum(TermsEnum tenum, BytesRef lowerTerm, BytesRef upperTerm, bool includeLower, bool includeUpper);
    protected virtual AcceptStatus Accept(BytesRef term);
}
internal class Lucene.Net.Search.TermScorer : Scorer {
    private DocsEnum docsEnum;
    private SimScorer docScorer;
    public int DocID { get; }
    public int Freq { get; }
    internal TermScorer(Weight weight, DocsEnum td, SimScorer docScorer);
    public virtual int get_DocID();
    public virtual int get_Freq();
    public virtual int NextDoc();
    public virtual float GetScore();
    public virtual int Advance(int target);
    public virtual long GetCost();
    public virtual string ToString();
}
public class Lucene.Net.Search.TermStatistics : object {
    private BytesRef term;
    private long docFreq;
    private long totalTermFreq;
    public BytesRef Term { get; }
    public long DocFreq { get; }
    public long TotalTermFreq { get; }
    public TermStatistics(BytesRef term, long docFreq, long totalTermFreq);
    public BytesRef get_Term();
    public long get_DocFreq();
    public long get_TotalTermFreq();
}
public class Lucene.Net.Search.TimeLimitingCollector : object {
    private long t0;
    private long timeout;
    private ICollector collector;
    private Counter clock;
    private long ticksAllowed;
    private bool greedy;
    private int docBase;
    public bool IsGreedy { get; public set; }
    public bool AcceptsDocsOutOfOrder { get; }
    public static Counter GlobalCounter { get; }
    public static TimerThread GlobalTimerThread { get; }
    public TimeLimitingCollector(ICollector collector, Counter clock, long ticksAllowed);
    public virtual void SetBaseline(long clockTime);
    public virtual void SetBaseline();
    public virtual bool get_IsGreedy();
    public virtual void set_IsGreedy(bool value);
    public virtual void Collect(int doc);
    public virtual void SetNextReader(AtomicReaderContext context);
    public virtual void SetScorer(Scorer scorer);
    public virtual bool get_AcceptsDocsOutOfOrder();
    public virtual void SetCollector(ICollector collector);
    public static Counter get_GlobalCounter();
    public static TimerThread get_GlobalTimerThread();
}
public class Lucene.Net.Search.TopDocs : object {
    [CompilerGeneratedAttribute]
private int <TotalHits>k__BackingField;
    [CompilerGeneratedAttribute]
private ScoreDoc[] <ScoreDocs>k__BackingField;
    private float maxScore;
    public int TotalHits { get; public set; }
    [WritableArrayAttribute]
public ScoreDoc[] ScoreDocs { get; public set; }
    public float MaxScore { get; public set; }
    internal TopDocs(int totalHits, ScoreDoc[] scoreDocs);
    public TopDocs(int totalHits, ScoreDoc[] scoreDocs, float maxScore);
    [CompilerGeneratedAttribute]
public int get_TotalHits();
    [CompilerGeneratedAttribute]
public void set_TotalHits(int value);
    [CompilerGeneratedAttribute]
public ScoreDoc[] get_ScoreDocs();
    [CompilerGeneratedAttribute]
public void set_ScoreDocs(ScoreDoc[] value);
    public virtual float get_MaxScore();
    public virtual void set_MaxScore(float value);
    public static TopDocs Merge(Sort sort, int topN, TopDocs[] shardHits);
    public static TopDocs Merge(Sort sort, int start, int size, TopDocs[] shardHits);
}
public abstract class Lucene.Net.Search.TopDocsCollector`1 : object {
    protected static TopDocs EMPTY_TOPDOCS;
    protected PriorityQueue`1<T> m_pq;
    protected int m_totalHits;
    public int TotalHits { get; internal set; }
    protected int TopDocsCount { get; }
    public bool AcceptsDocsOutOfOrder { get; }
    protected TopDocsCollector`1(PriorityQueue`1<T> pq);
    private static TopDocsCollector`1();
    protected virtual void PopulateResults(ScoreDoc[] results, int howMany);
    protected virtual TopDocs NewTopDocs(ScoreDoc[] results, int start);
    public virtual int get_TotalHits();
    internal virtual void set_TotalHits(int value);
    protected virtual int get_TopDocsCount();
    public virtual TopDocs GetTopDocs();
    public virtual TopDocs GetTopDocs(int start);
    public virtual TopDocs GetTopDocs(int start, int howMany);
    public abstract virtual void SetScorer(Scorer scorer);
    public abstract virtual void Collect(int doc);
    public abstract virtual void SetNextReader(AtomicReaderContext context);
    public abstract virtual bool get_AcceptsDocsOutOfOrder();
}
public abstract class Lucene.Net.Search.TopFieldCollector : TopDocsCollector`1<Entry> {
    private static ScoreDoc[] EMPTY_SCOREDOCS;
    private bool fillFields;
    internal float maxScore;
    internal int numHits;
    internal Entry bottom;
    internal bool queueFull;
    internal int docBase;
    public bool AcceptsDocsOutOfOrder { get; }
    private TopFieldCollector(PriorityQueue`1<Entry> pq, int numHits, bool fillFields);
    private static TopFieldCollector();
    public static TopFieldCollector Create(Sort sort, int numHits, bool fillFields, bool trackDocScores, bool trackMaxScore, bool docsScoredInOrder);
    public static TopFieldCollector Create(Sort sort, int numHits, FieldDoc after, bool fillFields, bool trackDocScores, bool trackMaxScore, bool docsScoredInOrder);
    internal void Add(int slot, int doc, float score);
    protected virtual void PopulateResults(ScoreDoc[] results, int howMany);
    protected virtual TopDocs NewTopDocs(ScoreDoc[] results, int start);
    public virtual bool get_AcceptsDocsOutOfOrder();
}
public class Lucene.Net.Search.TopFieldDocs : TopDocs {
    [CompilerGeneratedAttribute]
private SortField[] <Fields>k__BackingField;
    [WritableArrayAttribute]
public SortField[] Fields { get; public set; }
    public TopFieldDocs(int totalHits, ScoreDoc[] scoreDocs, SortField[] fields, float maxScore);
    [CompilerGeneratedAttribute]
public SortField[] get_Fields();
    [CompilerGeneratedAttribute]
public void set_Fields(SortField[] value);
}
public abstract class Lucene.Net.Search.TopScoreDocCollector : TopDocsCollector`1<ScoreDoc> {
    internal ScoreDoc pqTop;
    internal int docBase;
    internal Scorer scorer;
    private TopScoreDocCollector(int numHits);
    public static TopScoreDocCollector Create(int numHits, bool docsScoredInOrder);
    public static TopScoreDocCollector Create(int numHits, ScoreDoc after, bool docsScoredInOrder);
    protected virtual TopDocs NewTopDocs(ScoreDoc[] results, int start);
    public virtual void SetNextReader(AtomicReaderContext context);
    public virtual void SetScorer(Scorer scorer);
}
public abstract class Lucene.Net.Search.TopTermsRewrite`1 : TermCollectingRewrite`1<Q> {
    private int size;
    private static IComparer`1<ScoreTerm<Q>> scoreTermSortByTermComp;
    public int Count { get; }
    protected int MaxSize { get; }
    protected TopTermsRewrite`1(int count);
    private static TopTermsRewrite`1();
    public virtual int get_Count();
    protected abstract virtual int get_MaxSize();
    public virtual Query Rewrite(IndexReader reader, MultiTermQuery query);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Lucene.Net.Search.TotalHitCountCollector : object {
    private int totalHits;
    public int TotalHits { get; }
    public bool AcceptsDocsOutOfOrder { get; }
    public virtual int get_TotalHits();
    public virtual void SetScorer(Scorer scorer);
    public virtual void Collect(int doc);
    public virtual void SetNextReader(AtomicReaderContext context);
    public virtual bool get_AcceptsDocsOutOfOrder();
}
internal class Lucene.Net.Search.UnionDocsAndPositionsEnum : DocsAndPositionsEnum {
    private int _doc;
    private int _freq;
    private DocsQueue _queue;
    private Int32Queue _posList;
    private long _cost;
    public int StartOffset { get; }
    public int EndOffset { get; }
    public int Freq { get; }
    public int DocID { get; }
    public UnionDocsAndPositionsEnum(IBits liveDocs, AtomicReaderContext context, Term[] terms, IDictionary`2<Term, TermContext> termContexts, TermsEnum termsEnum);
    public sealed virtual int NextDoc();
    public virtual int NextPosition();
    public virtual int get_StartOffset();
    public virtual int get_EndOffset();
    public virtual BytesRef GetPayload();
    public sealed virtual int Advance(int target);
    public sealed virtual int get_Freq();
    public sealed virtual int get_DocID();
    public virtual long GetCost();
}
public abstract class Lucene.Net.Search.Weight : object {
    public Query Query { get; }
    public bool ScoresDocsOutOfOrder { get; }
    public abstract virtual Explanation Explain(AtomicReaderContext context, int doc);
    public abstract virtual Query get_Query();
    public abstract virtual float GetValueForNormalization();
    public abstract virtual void Normalize(float norm, float topLevelBoost);
    public abstract virtual Scorer GetScorer(AtomicReaderContext context, IBits acceptDocs);
    public virtual BulkScorer GetBulkScorer(AtomicReaderContext context, bool scoreDocsInOrder, IBits acceptDocs);
    public virtual bool get_ScoresDocsOutOfOrder();
}
public class Lucene.Net.Search.WildcardQuery : AutomatonQuery {
    public static char WILDCARD_STRING;
    public static char WILDCARD_CHAR;
    public static char WILDCARD_ESCAPE;
    public Term Term { get; }
    public WildcardQuery(Term term);
    public static Automaton ToAutomaton(Term wildcardquery);
    public virtual Term get_Term();
    public virtual string ToString(string field);
}
public abstract class Lucene.Net.Store.BaseDirectory : Directory {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) isOpen;
    protected internal LockFactory m_lockFactory;
    protected internal bool IsOpen { get; protected internal set; }
    public LockFactory LockFactory { get; }
    protected internal virtual bool get_IsOpen();
    protected internal virtual void set_IsOpen(bool value);
    public virtual Lock MakeLock(string name);
    public virtual void ClearLock(string name);
    public virtual void SetLockFactory(LockFactory lockFactory);
    public virtual LockFactory get_LockFactory();
    protected internal sealed virtual void EnsureOpen();
}
internal class Lucene.Net.Store.BufferedChecksum : object {
    private IChecksum in;
    private Byte[] buffer;
    private int upto;
    public static int DEFAULT_BUFFERSIZE;
    public long Value { get; }
    public BufferedChecksum(IChecksum in);
    public BufferedChecksum(IChecksum in, int bufferSize);
    public virtual void Update(int b);
    public virtual void Update(Byte[] b);
    public virtual void Update(Byte[] b, int off, int len);
    public virtual long get_Value();
    public virtual void Reset();
    private void Flush();
}
public class Lucene.Net.Store.BufferedChecksumIndexInput : ChecksumIndexInput {
    internal IndexInput main;
    internal IChecksum digest;
    public long Checksum { get; }
    public long Position { get; }
    public long Length { get; }
    public BufferedChecksumIndexInput(IndexInput main);
    public virtual byte ReadByte();
    public virtual void ReadBytes(Byte[] b, int offset, int len);
    public virtual long get_Checksum();
    protected virtual void Dispose(bool disposing);
    public virtual long get_Position();
    public virtual long get_Length();
    public virtual object Clone();
}
public abstract class Lucene.Net.Store.BufferedIndexInput : IndexInput {
    public static int BUFFER_SIZE;
    public static int MERGE_BUFFER_SIZE;
    private int bufferSize;
    protected Byte[] m_buffer;
    private long bufferStart;
    private int bufferLength;
    private int bufferPosition;
    public int BufferSize { get; }
    public long Position { get; }
    protected BufferedIndexInput(string resourceDesc);
    protected BufferedIndexInput(string resourceDesc, IOContext context);
    protected BufferedIndexInput(string resourceDesc, int bufferSize);
    public sealed virtual byte ReadByte();
    public void SetBufferSize(int newSize);
    protected virtual void NewBuffer(Byte[] newBuffer);
    public int get_BufferSize();
    private static void CheckBufferSize(int bufferSize);
    public sealed virtual void ReadBytes(Byte[] b, int offset, int len);
    public sealed virtual void ReadBytes(Byte[] b, int offset, int len, bool useBuffer);
    public sealed virtual short ReadInt16();
    public sealed virtual int ReadInt32();
    public sealed virtual long ReadInt64();
    public sealed virtual int ReadVInt32();
    public sealed virtual long ReadVInt64();
    private void Refill();
    protected abstract virtual void ReadInternal(Byte[] b, int offset, int length);
    public sealed virtual long get_Position();
    public sealed virtual void Seek(long pos);
    protected abstract virtual void SeekInternal(long pos);
    public virtual object Clone();
    protected int FlushBuffer(IndexOutput out, long numBytes);
    public static int GetBufferSize(IOContext context);
}
public abstract class Lucene.Net.Store.BufferedIndexOutput : IndexOutput {
    public static int DEFAULT_BUFFER_SIZE;
    private int bufferSize;
    private Byte[] buffer;
    private long bufferStart;
    private int bufferPosition;
    private CRC32 crc;
    public long Position { get; }
    public long Length { get; }
    public int BufferSize { get; }
    public long Checksum { get; }
    protected BufferedIndexOutput(int bufferSize);
    internal BufferedIndexOutput(int bufferSize, CRC32 crc);
    public virtual void WriteByte(byte b);
    public virtual void WriteBytes(Byte[] b, int offset, int length);
    public virtual void Flush();
    private void FlushBuffer(Byte[] b, int len);
    protected internal abstract virtual void FlushBuffer(Byte[] b, int offset, int len);
    protected virtual void Dispose(bool disposing);
    public virtual long get_Position();
    [ObsoleteAttribute("(4.1) this method will be removed in Lucene 5.0")]
public virtual void Seek(long pos);
    public abstract virtual long get_Length();
    public int get_BufferSize();
    public virtual long get_Checksum();
}
public class Lucene.Net.Store.ByteArrayDataInput : DataInput {
    private Byte[] bytes;
    private int pos;
    private int limit;
    public int Position { get; public set; }
    public int Length { get; }
    public bool Eof { get; }
    public ByteArrayDataInput(Byte[] bytes);
    public ByteArrayDataInput(Byte[] bytes, int offset, int len);
    public void Reset(Byte[] bytes);
    public void Rewind();
    public int get_Position();
    public void set_Position(int value);
    public void Reset(Byte[] bytes, int offset, int len);
    public int get_Length();
    public bool get_Eof();
    public virtual void SkipBytes(long count);
    public virtual short ReadInt16();
    public virtual int ReadInt32();
    public virtual long ReadInt64();
    public virtual int ReadVInt32();
    public virtual long ReadVInt64();
    public virtual byte ReadByte();
    public virtual void ReadBytes(Byte[] b, int offset, int len);
}
public class Lucene.Net.Store.ByteArrayDataOutput : DataOutput {
    private Byte[] bytes;
    private int pos;
    private int limit;
    public int Position { get; }
    public ByteArrayDataOutput(Byte[] bytes);
    public ByteArrayDataOutput(Byte[] bytes, int offset, int len);
    public virtual void Reset(Byte[] bytes);
    public virtual void Reset(Byte[] bytes, int offset, int len);
    public virtual int get_Position();
    public virtual void WriteByte(byte b);
    public virtual void WriteBytes(Byte[] b, int offset, int length);
}
public abstract class Lucene.Net.Store.ByteBufferIndexInput : IndexInput {
    private ByteBuffer[] buffers;
    private long chunkSizeMask;
    private int chunkSizePower;
    private int offset;
    private long length;
    private string sliceDescription;
    private int curBufIndex;
    private ByteBuffer curBuf;
    private bool isClone;
    private ConditionalWeakTable`2<ByteBufferIndexInput, BoolRefWrapper> clones;
    public long Position { get; }
    public long Length { get; }
    internal ByteBufferIndexInput(string resourceDescription, ByteBuffer[] buffers, long length, int chunkSizePower, bool trackClones);
    internal void SetBuffers(ByteBuffer[] buffers);
    public sealed virtual byte ReadByte();
    public sealed virtual void ReadBytes(Byte[] b, int offset, int len);
    public sealed virtual short ReadInt16();
    public sealed virtual int ReadInt32();
    public sealed virtual long ReadInt64();
    public sealed virtual long get_Position();
    public sealed virtual void Seek(long pos);
    public sealed virtual long get_Length();
    public sealed virtual object Clone();
    public ByteBufferIndexInput Slice(string sliceDescription, long offset, long length);
    private ByteBufferIndexInput BuildSlice(long offset, long length);
    private ByteBuffer[] BuildSlice(ByteBuffer[] buffers, long offset, long length);
    private void UnsetBuffers();
    private void EnsureOpen();
    protected virtual void Dispose(bool disposing);
    protected abstract virtual void FreeBuffer(ByteBuffer b);
    public sealed virtual string ToString();
}
public abstract class Lucene.Net.Store.ChecksumIndexInput : IndexInput {
    public long Checksum { get; }
    protected ChecksumIndexInput(string resourceDescription);
    public abstract virtual long get_Checksum();
    public virtual void Seek(long pos);
}
public class Lucene.Net.Store.CompoundFileDirectory : BaseDirectory {
    private Directory directory;
    private string fileName;
    private IDictionary`2<string, FileEntry> entries;
    private bool openForWrite;
    private static IDictionary`2<string, FileEntry> SENTINEL;
    private CompoundFileWriter writer;
    private IndexInputSlicer handle;
    private static sbyte CODEC_MAGIC_BYTE1;
    private static sbyte CODEC_MAGIC_BYTE2;
    private static sbyte CODEC_MAGIC_BYTE3;
    private static sbyte CODEC_MAGIC_BYTE4;
    public Directory Directory { get; }
    public string Name { get; }
    public CompoundFileDirectory(Directory directory, string fileName, IOContext context, bool openForWrite);
    private static CompoundFileDirectory();
    private static IDictionary`2<string, FileEntry> ReadEntries(IndexInputSlicer handle, Directory dir, string name);
    private static IDictionary`2<string, FileEntry> ReadLegacyEntries(IndexInput stream, int firstInt);
    public Directory get_Directory();
    public string get_Name();
    protected virtual void Dispose(bool disposing);
    public virtual IndexInput OpenInput(string name, IOContext context);
    public virtual String[] ListAll();
    [ObsoleteAttribute("this method will be removed in 5.0")]
public virtual bool FileExists(string name);
    public virtual void DeleteFile(string name);
    public void RenameFile(string from, string to);
    public virtual long FileLength(string name);
    public virtual IndexOutput CreateOutput(string name, IOContext context);
    public virtual void Sync(ICollection`1<string> names);
    public virtual Lock MakeLock(string name);
    public virtual IndexInputSlicer CreateSlicer(string name, IOContext context);
    public virtual string ToString();
}
internal class Lucene.Net.Store.CompoundFileWriter : object {
    internal static int FORMAT_PRE_VERSION;
    internal static int FORMAT_NO_SEGMENT_PREFIX;
    internal static string DATA_CODEC;
    internal static int VERSION_START;
    internal static int VERSION_CHECKSUM;
    internal static int VERSION_CURRENT;
    internal static string ENTRY_CODEC;
    private Directory directory;
    private IDictionary`2<string, FileEntry> entries;
    private ISet`1<string> seenIDs;
    private LinkedList`1<FileEntry> pendingEntries;
    private bool closed;
    private IndexOutput dataOut;
    private AtomicBoolean outputTaken;
    internal string entryTableName;
    internal string dataFileName;
    internal Directory Directory { get; }
    internal string Name { get; }
    internal CompoundFileWriter(Directory dir, string name);
    private IndexOutput GetOutput();
    internal Directory get_Directory();
    internal string get_Name();
    public sealed virtual void Dispose();
    private void EnsureOpen();
    private static long CopyFileEntry(IndexOutput dataOut, FileEntry fileEntry);
    private void WriteEntryTable(ICollection`1<FileEntry> entries, IndexOutput entryOut);
    internal IndexOutput CreateOutput(string name, IOContext context);
    internal void ReleaseOutputLock();
    private void PrunePendingEntries();
    internal long FileLength(string name);
    internal bool FileExists(string name);
    internal String[] ListAll();
}
public abstract class Lucene.Net.Store.DataInput : object {
    private static int SKIP_BUFFER_SIZE;
    private Byte[] skipBuffer;
    public abstract virtual byte ReadByte();
    public abstract virtual void ReadBytes(Byte[] b, int offset, int len);
    public virtual void ReadBytes(Byte[] b, int offset, int len, bool useBuffer);
    public virtual short ReadInt16();
    public virtual int ReadInt32();
    public virtual int ReadVInt32();
    public virtual long ReadInt64();
    public virtual long ReadVInt64();
    public virtual string ReadString();
    public virtual object Clone();
    public virtual IDictionary`2<string, string> ReadStringStringMap();
    public virtual ISet`1<string> ReadStringSet();
    public virtual void SkipBytes(long numBytes);
}
public abstract class Lucene.Net.Store.DataOutput : object {
    private static int COPY_BUFFER_SIZE;
    private Byte[] copyBuffer;
    public abstract virtual void WriteByte(byte b);
    public virtual void WriteBytes(Byte[] b, int length);
    public abstract virtual void WriteBytes(Byte[] b, int offset, int length);
    public virtual void WriteInt32(int i);
    public virtual void WriteInt16(short i);
    public void WriteVInt32(int i);
    public virtual void WriteInt64(long i);
    public void WriteVInt64(long i);
    public virtual void WriteString(string s);
    public virtual void CopyBytes(DataInput input, long numBytes);
    public virtual void WriteStringStringMap(IDictionary`2<string, string> map);
    public virtual void WriteStringSet(ISet`1<string> set);
}
public abstract class Lucene.Net.Store.Directory : object {
    public LockFactory LockFactory { get; }
    public abstract virtual String[] ListAll();
    [ObsoleteAttribute("this method will be removed in 5.0")]
public abstract virtual bool FileExists(string name);
    public abstract virtual void DeleteFile(string name);
    public abstract virtual long FileLength(string name);
    public abstract virtual IndexOutput CreateOutput(string name, IOContext context);
    public abstract virtual void Sync(ICollection`1<string> names);
    public abstract virtual IndexInput OpenInput(string name, IOContext context);
    public virtual ChecksumIndexInput OpenChecksumInput(string name, IOContext context);
    public abstract virtual Lock MakeLock(string name);
    public abstract virtual void ClearLock(string name);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public abstract virtual void SetLockFactory(LockFactory lockFactory);
    public abstract virtual LockFactory get_LockFactory();
    public virtual string GetLockID();
    public virtual string ToString();
    public virtual void Copy(Directory to, string src, string dest, IOContext context);
    public virtual IndexInputSlicer CreateSlicer(string name, IOContext context);
    protected internal virtual void EnsureOpen();
}
internal class Lucene.Net.Store.FallbackNativeFSLock : Lock {
    private FileStream channel;
    private string path;
    private DirectoryInfo lockDir;
    public FallbackNativeFSLock(DirectoryInfo lockDir, string path);
    public virtual bool Obtain();
    protected virtual void Dispose(bool disposing);
    public virtual bool IsLocked();
    public virtual string ToString();
}
public class Lucene.Net.Store.FileSwitchDirectory : BaseDirectory {
    private Directory secondaryDir;
    private Directory primaryDir;
    private ISet`1<string> primaryExtensions;
    private bool doClose;
    public Directory PrimaryDir { get; }
    public Directory SecondaryDir { get; }
    public FileSwitchDirectory(ISet`1<string> primaryExtensions, Directory primaryDir, Directory secondaryDir, bool doClose);
    public virtual Directory get_PrimaryDir();
    public virtual Directory get_SecondaryDir();
    protected virtual void Dispose(bool disposing);
    public virtual String[] ListAll();
    public static string GetExtension(string name);
    private Directory GetDirectory(string name);
    [ObsoleteAttribute("this method will be removed in 5.0")]
public virtual bool FileExists(string name);
    public virtual void DeleteFile(string name);
    public virtual long FileLength(string name);
    public virtual IndexOutput CreateOutput(string name, IOContext context);
    public virtual void Sync(ICollection`1<string> names);
    public virtual IndexInput OpenInput(string name, IOContext context);
    public virtual IndexInputSlicer CreateSlicer(string name, IOContext context);
}
public class Lucene.Net.Store.FilterDirectory : Directory {
    protected Directory m_input;
    public Directory Delegate { get; }
    public LockFactory LockFactory { get; }
    protected FilterDirectory(Directory in);
    public Directory get_Delegate();
    public virtual String[] ListAll();
    [ObsoleteAttribute("this method will be removed in 5.0")]
public virtual bool FileExists(string name);
    public virtual void DeleteFile(string name);
    public virtual long FileLength(string name);
    public virtual IndexOutput CreateOutput(string name, IOContext context);
    public virtual void Sync(ICollection`1<string> names);
    public virtual IndexInput OpenInput(string name, IOContext context);
    public virtual Lock MakeLock(string name);
    public virtual void ClearLock(string name);
    protected virtual void Dispose(bool disposing);
    public virtual void SetLockFactory(LockFactory lockFactory);
    public virtual string GetLockID();
    public virtual LockFactory get_LockFactory();
    public virtual string ToString();
}
public class Lucene.Net.Store.FlushInfo : object {
    [CompilerGeneratedAttribute]
private int <NumDocs>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EstimatedSegmentSize>k__BackingField;
    public int NumDocs { get; private set; }
    public long EstimatedSegmentSize { get; private set; }
    public FlushInfo(int numDocs, long estimatedSegmentSize);
    [CompilerGeneratedAttribute]
public int get_NumDocs();
    [CompilerGeneratedAttribute]
private void set_NumDocs(int value);
    [CompilerGeneratedAttribute]
public long get_EstimatedSegmentSize();
    [CompilerGeneratedAttribute]
private void set_EstimatedSegmentSize(long value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public abstract class Lucene.Net.Store.FSDirectory : BaseDirectory {
    [ObsoleteAttribute("this constant is no longer used since Lucene 4.5.")]
public static int DEFAULT_READ_CHUNK_SIZE;
    protected DirectoryInfo m_directory;
    private int chunkSize;
    public DirectoryInfo Directory { get; }
    [ObsoleteAttribute("this is no longer used since Lucene 4.5.")]
public int ReadChunkSize { get; public set; }
    protected FSDirectory(DirectoryInfo dir);
    protected internal FSDirectory(DirectoryInfo path, LockFactory lockFactory);
    public static FSDirectory Open(DirectoryInfo path);
    public static FSDirectory Open(string path);
    public static FSDirectory Open(DirectoryInfo path, LockFactory lockFactory);
    public static FSDirectory Open(string path, LockFactory lockFactory);
    public virtual void SetLockFactory(LockFactory lockFactory);
    public static String[] ListAll(DirectoryInfo dir);
    public virtual String[] ListAll();
    [ObsoleteAttribute("this method will be removed in 5.0")]
public virtual bool FileExists(string name);
    public virtual long FileLength(string name);
    public virtual void DeleteFile(string name);
    public virtual IndexOutput CreateOutput(string name, IOContext context);
    protected virtual void EnsureCanWrite(string name);
    protected virtual void OnIndexOutputClosed(FSIndexOutput io);
    public virtual void Sync(ICollection`1<string> names);
    public virtual string GetLockID();
    protected virtual void Dispose(bool disposing);
    public virtual DirectoryInfo get_Directory();
    public virtual string ToString();
    public int get_ReadChunkSize();
    public void set_ReadChunkSize(int value);
}
public abstract class Lucene.Net.Store.FSLockFactory : LockFactory {
    protected internal DirectoryInfo m_lockDir;
    public DirectoryInfo LockDir { get; }
    protected internal void SetLockDir(DirectoryInfo lockDir);
    public DirectoryInfo get_LockDir();
    public virtual string ToString();
}
public abstract class Lucene.Net.Store.IndexInput : DataInput {
    private string resourceDescription;
    public long Position { get; }
    public long Length { get; }
    protected IndexInput(string resourceDescription);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public abstract virtual long get_Position();
    public abstract virtual void Seek(long pos);
    public abstract virtual long get_Length();
    public virtual string ToString();
    public virtual object Clone();
}
[ExtensionAttribute]
public static class Lucene.Net.Store.IndexInputExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use Position property instead. This extension method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public static long GetFilePointer(IndexInput indexInput);
}
public abstract class Lucene.Net.Store.IndexOutput : DataOutput {
    [CompilerGeneratedAttribute]
private long <Length>k__BackingField;
    public long Position { get; }
    public long Checksum { get; }
    public long Length { get; public set; }
    public abstract virtual void Flush();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public abstract virtual long get_Position();
    [ObsoleteAttribute("(4.1) this method will be removed in Lucene 5.0")]
public abstract virtual void Seek(long pos);
    public abstract virtual long get_Checksum();
    [CompilerGeneratedAttribute]
public virtual long get_Length();
    [CompilerGeneratedAttribute]
public virtual void set_Length(long value);
}
[ExtensionAttribute]
public static class Lucene.Net.Store.IndexOutputExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use Position property instead. This extension method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public static long GetFilePointer(IndexOutput indexOutput);
}
public class Lucene.Net.Store.InputStreamDataInput : DataInput {
    private BinaryReader _reader;
    private bool disposed;
    public InputStreamDataInput(Stream is);
    public virtual byte ReadByte();
    public virtual void ReadBytes(Byte[] b, int offset, int len);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[ExceptionToClassNameConventionAttribute]
public class Lucene.Net.Store.IOContext : object {
    [CompilerGeneratedAttribute]
private UsageContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private MergeInfo <MergeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private FlushInfo <FlushInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadOnce>k__BackingField;
    public static IOContext DEFAULT;
    public static IOContext READ_ONCE;
    public static IOContext READ;
    public UsageContext Context { get; private set; }
    public MergeInfo MergeInfo { get; private set; }
    public FlushInfo FlushInfo { get; private set; }
    public bool ReadOnce { get; private set; }
    public IOContext(FlushInfo flushInfo);
    public IOContext(UsageContext context);
    private IOContext(bool readOnce);
    public IOContext(MergeInfo mergeInfo);
    private IOContext(UsageContext context, MergeInfo mergeInfo);
    public IOContext(IOContext ctxt, bool readOnce);
    private static IOContext();
    [CompilerGeneratedAttribute]
public UsageContext get_Context();
    [CompilerGeneratedAttribute]
private void set_Context(UsageContext value);
    [CompilerGeneratedAttribute]
public MergeInfo get_MergeInfo();
    [CompilerGeneratedAttribute]
private void set_MergeInfo(MergeInfo value);
    [CompilerGeneratedAttribute]
public FlushInfo get_FlushInfo();
    [CompilerGeneratedAttribute]
private void set_FlushInfo(FlushInfo value);
    [CompilerGeneratedAttribute]
public bool get_ReadOnce();
    [CompilerGeneratedAttribute]
private void set_ReadOnce(bool value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public abstract class Lucene.Net.Store.Lock : object {
    public static long LOCK_POLL_INTERVAL;
    public static long LOCK_OBTAIN_WAIT_FOREVER;
    [CompilerGeneratedAttribute]
private Exception <FailureReason>k__BackingField;
    protected internal Exception FailureReason { get; protected internal set; }
    private static Lock();
    public static With`1<T> NewAnonymous(Lock lock, int lockWaitTimeout, Func`1<T> doBody);
    public abstract virtual bool Obtain();
    [CompilerGeneratedAttribute]
protected internal Exception get_FailureReason();
    [CompilerGeneratedAttribute]
protected internal void set_FailureReason(Exception value);
    public bool Obtain(long lockWaitTimeout);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public abstract virtual bool IsLocked();
}
public abstract class Lucene.Net.Store.LockFactory : object {
    protected string m_lockPrefix;
    public string LockPrefix { get; public set; }
    public virtual string get_LockPrefix();
    public virtual void set_LockPrefix(string value);
    public abstract virtual Lock MakeLock(string lockName);
    public abstract virtual void ClearLock(string lockName);
}
public class Lucene.Net.Store.LockObtainFailedException : IOException {
    public LockObtainFailedException(string message);
    public LockObtainFailedException(string message, Exception ex);
    protected LockObtainFailedException(SerializationInfo info, StreamingContext context);
}
public class Lucene.Net.Store.LockReleaseFailedException : IOException {
    public LockReleaseFailedException(string message);
    protected LockReleaseFailedException(SerializationInfo info, StreamingContext context);
}
public static class Lucene.Net.Store.LockStressTest : object {
    [STAThreadAttribute]
public static void Main(String[] args);
}
public static class Lucene.Net.Store.LockVerifyServer : object {
    [STAThreadAttribute]
public static void Main(String[] args);
}
public class Lucene.Net.Store.MergeInfo : object {
    [CompilerGeneratedAttribute]
private int <TotalDocCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EstimatedMergeBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExternal>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MergeMaxNumSegments>k__BackingField;
    public int TotalDocCount { get; private set; }
    public long EstimatedMergeBytes { get; private set; }
    public bool IsExternal { get; private set; }
    public int MergeMaxNumSegments { get; private set; }
    public MergeInfo(int totalDocCount, long estimatedMergeBytes, bool isExternal, int mergeMaxNumSegments);
    [CompilerGeneratedAttribute]
public int get_TotalDocCount();
    [CompilerGeneratedAttribute]
private void set_TotalDocCount(int value);
    [CompilerGeneratedAttribute]
public long get_EstimatedMergeBytes();
    [CompilerGeneratedAttribute]
private void set_EstimatedMergeBytes(long value);
    [CompilerGeneratedAttribute]
public bool get_IsExternal();
    [CompilerGeneratedAttribute]
private void set_IsExternal(bool value);
    [CompilerGeneratedAttribute]
public int get_MergeMaxNumSegments();
    [CompilerGeneratedAttribute]
private void set_MergeMaxNumSegments(int value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public class Lucene.Net.Store.MMapDirectory : FSDirectory {
    public static int DEFAULT_MAX_BUFF;
    private int chunkSizePower;
    public int MaxChunkSize { get; }
    public MMapDirectory(DirectoryInfo path, LockFactory lockFactory);
    public MMapDirectory(DirectoryInfo path);
    public MMapDirectory(DirectoryInfo path, LockFactory lockFactory, int maxChunkSize);
    public MMapDirectory(string path, LockFactory lockFactory);
    public MMapDirectory(string path);
    public MMapDirectory(string path, LockFactory lockFactory, int maxChunkSize);
    private static MMapDirectory();
    public int get_MaxChunkSize();
    public virtual IndexInput OpenInput(string name, IOContext context);
    public virtual IndexInputSlicer CreateSlicer(string name, IOContext context);
    internal virtual ByteBuffer[] Map(MMapIndexInput input, FileStream fc, long offset, long length);
}
internal class Lucene.Net.Store.NativeFSLock : Lock {
    private FileStream channel;
    private string path;
    private DirectoryInfo lockDir;
    public NativeFSLock(DirectoryInfo lockDir, string path);
    private bool IsLockViolation(IOException e);
    private FileStream GetLockFileStream(FileMode mode);
    public virtual bool Obtain();
    protected virtual void Dispose(bool disposing);
    public virtual bool IsLocked();
    public virtual string ToString();
}
public class Lucene.Net.Store.NativeFSLockFactory : FSLockFactory {
    private static bool IS_FILESTREAM_LOCKING_PLATFORM;
    private static int WIN_HRESULT_FILE_LOCK_VIOLATION;
    private static int WIN_HRESULT_FILE_SHARE_VIOLATION;
    internal static Nullable`1<int> HRESULT_FILE_LOCK_VIOLATION;
    internal static Nullable`1<int> HRESULT_FILE_SHARE_VIOLATION;
    internal static Dictionary`2<string, Lock> _locks;
    internal static FSLockingStrategy LockingStrategy { get; }
    public NativeFSLockFactory(string lockDirName);
    public NativeFSLockFactory(DirectoryInfo lockDir);
    private static NativeFSLockFactory();
    internal static FSLockingStrategy get_LockingStrategy();
    private static bool LoadIsFileStreamLockingPlatform();
    private static Nullable`1<int> LoadFileLockViolationHResult();
    private static Nullable`1<int> LoadFileShareViolationHResult();
    private string GetCanonicalPathOfLockFile(string lockName);
    public virtual Lock MakeLock(string lockName);
    internal virtual Lock NewLock(string path);
    public virtual void ClearLock(string lockName);
}
public class Lucene.Net.Store.NIOFSDirectory : FSDirectory {
    public NIOFSDirectory(DirectoryInfo path, LockFactory lockFactory);
    public NIOFSDirectory(DirectoryInfo path);
    public NIOFSDirectory(string path, LockFactory lockFactory);
    public NIOFSDirectory(string path);
    public virtual IndexInput OpenInput(string name, IOContext context);
    public virtual IndexInputSlicer CreateSlicer(string name, IOContext context);
}
internal class Lucene.Net.Store.NoLock : Lock {
    public virtual bool Obtain();
    protected virtual void Dispose(bool disposing);
    public virtual bool IsLocked();
    public virtual string ToString();
}
public class Lucene.Net.Store.NoLockFactory : LockFactory {
    private static NoLock singletonLock;
    private static NoLockFactory singleton;
    private static NoLockFactory();
    public static NoLockFactory GetNoLockFactory();
    public virtual Lock MakeLock(string lockName);
    public virtual void ClearLock(string lockName);
}
public class Lucene.Net.Store.NRTCachingDirectory : Directory {
    private RAMDirectory cache;
    private Directory delegate;
    private long maxMergeSizeBytes;
    private long maxCachedBytes;
    private static bool VERBOSE;
    private object uncacheLock;
    public Directory Delegate { get; }
    public LockFactory LockFactory { get; }
    public NRTCachingDirectory(Directory delegate, double maxMergeSizeMB, double maxCachedMB);
    public virtual Directory get_Delegate();
    public virtual LockFactory get_LockFactory();
    public virtual void SetLockFactory(LockFactory lockFactory);
    public virtual string GetLockID();
    public virtual Lock MakeLock(string name);
    public virtual void ClearLock(string name);
    public virtual string ToString();
    public virtual String[] ListAll();
    public virtual long GetSizeInBytes();
    [ObsoleteAttribute("this method will be removed in 5.0")]
public virtual bool FileExists(string name);
    public virtual void DeleteFile(string name);
    public virtual long FileLength(string name);
    public virtual String[] ListCachedFiles();
    public virtual IndexOutput CreateOutput(string name, IOContext context);
    public virtual void Sync(ICollection`1<string> fileNames);
    public virtual IndexInput OpenInput(string name, IOContext context);
    public virtual IndexInputSlicer CreateSlicer(string name, IOContext context);
    protected virtual void Dispose(bool disposing);
    protected virtual bool DoCacheWrite(string name, IOContext context);
    private void UnCache(string fileName);
}
public class Lucene.Net.Store.OutputStreamDataOutput : DataOutput {
    private BinaryWriter _writer;
    public OutputStreamDataOutput(Stream os);
    public virtual void WriteByte(byte b);
    public virtual void WriteBytes(Byte[] b, int offset, int length);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class Lucene.Net.Store.RAMDirectory : BaseDirectory {
    protected internal ConcurrentDictionary`2<string, RAMFile> m_fileMap;
    protected internal AtomicInt64 m_sizeInBytes;
    public RAMDirectory(Directory dir, IOContext context);
    private RAMDirectory(Directory dir, bool closeDir, IOContext context);
    public virtual string GetLockID();
    public sealed virtual String[] ListAll();
    [ObsoleteAttribute("this method will be removed in 5.0")]
public sealed virtual bool FileExists(string name);
    public sealed virtual long FileLength(string name);
    public long GetSizeInBytes();
    public virtual void DeleteFile(string name);
    public virtual IndexOutput CreateOutput(string name, IOContext context);
    protected virtual RAMFile NewRAMFile();
    public virtual void Sync(ICollection`1<string> names);
    public virtual IndexInput OpenInput(string name, IOContext context);
    protected virtual void Dispose(bool disposing);
}
public class Lucene.Net.Store.RAMFile : object {
    protected IList`1<Byte[]> m_buffers;
    internal long length;
    internal RAMDirectory directory;
    protected internal long m_sizeInBytes;
    public long Length { get; public set; }
    protected internal int NumBuffers { get; }
    public RAMFile(RAMDirectory directory);
    public virtual long get_Length();
    public virtual void set_Length(long value);
    protected internal Byte[] AddBuffer(int size);
    protected internal Byte[] GetBuffer(int index);
    protected internal int get_NumBuffers();
    protected virtual Byte[] NewBuffer(int size);
    public virtual long GetSizeInBytes();
}
public class Lucene.Net.Store.RAMInputStream : IndexInput {
    internal static int BUFFER_SIZE;
    private RAMFile file;
    private long length;
    private Byte[] currentBuffer;
    private int currentBufferIndex;
    private int bufferPosition;
    private long bufferStart;
    private int bufferLength;
    public long Length { get; }
    public long Position { get; }
    public RAMInputStream(string name, RAMFile f);
    protected virtual void Dispose(bool disposing);
    public virtual long get_Length();
    public virtual byte ReadByte();
    public virtual void ReadBytes(Byte[] b, int offset, int len);
    private void SwitchCurrentBuffer(bool enforceEOF);
    public virtual long get_Position();
    public virtual void Seek(long pos);
}
public class Lucene.Net.Store.RAMOutputStream : IndexOutput {
    internal static int BUFFER_SIZE;
    private RAMFile file;
    private Byte[] currentBuffer;
    private int currentBufferIndex;
    private int bufferPosition;
    private long bufferStart;
    private int bufferLength;
    private BufferedChecksum crc;
    public long Length { get; public set; }
    public long Position { get; }
    public long Checksum { get; }
    public RAMOutputStream(RAMFile f);
    public virtual void WriteTo(DataOutput out);
    public virtual void WriteTo(Byte[] bytes, int offset);
    public virtual void Reset();
    protected virtual void Dispose(bool disposing);
    [ObsoleteAttribute("(4.1) this method will be removed in Lucene 5.0")]
public virtual void Seek(long pos);
    public virtual long get_Length();
    public virtual void set_Length(long value);
    public virtual void WriteByte(byte b);
    public virtual void WriteBytes(Byte[] b, int offset, int len);
    private void SwitchCurrentBuffer();
    private void SetFileLength();
    public virtual void Flush();
    public virtual long get_Position();
    public virtual long GetSizeInBytes();
    public virtual long get_Checksum();
}
public class Lucene.Net.Store.RateLimitedDirectoryWrapper : FilterDirectory {
    private IDictionary`2<UsageContext, RateLimiter> _contextRateLimiters;
    public RateLimitedDirectoryWrapper(Directory wrapped);
    public virtual IndexOutput CreateOutput(string name, IOContext context);
    public virtual IndexInputSlicer CreateSlicer(string name, IOContext context);
    public virtual void Copy(Directory to, string src, string dest, IOContext context);
    private RateLimiter GetRateLimiter(UsageContext context);
    public void SetMaxWriteMBPerSec(Nullable`1<double> mbPerSec, UsageContext context);
    public void SetRateLimiter(RateLimiter mergeWriteRateLimiter, UsageContext context);
    public double GetMaxWriteMBPerSec(UsageContext context);
}
internal class Lucene.Net.Store.RateLimitedIndexOutput : BufferedIndexOutput {
    private IndexOutput delegate;
    private BufferedIndexOutput bufferedDelegate;
    private RateLimiter rateLimiter;
    public long Length { get; public set; }
    internal RateLimitedIndexOutput(RateLimiter rateLimiter, IndexOutput delegate);
    protected internal virtual void FlushBuffer(Byte[] b, int offset, int len);
    public virtual long get_Length();
    public virtual void set_Length(long value);
    [ObsoleteAttribute("(4.1) this method will be removed in Lucene 5.0")]
public virtual void Seek(long pos);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
}
public abstract class Lucene.Net.Store.RateLimiter : object {
    public double MbPerSec { get; }
    public abstract virtual void SetMbPerSec(double mbPerSec);
    public abstract virtual double get_MbPerSec();
    public abstract virtual long Pause(long bytes);
}
internal class Lucene.Net.Store.SharingNativeFSLock : Lock {
    private FileStream channel;
    private string path;
    private DirectoryInfo lockDir;
    public SharingNativeFSLock(DirectoryInfo lockDir, string path);
    private bool IsShareViolation(IOException e);
    private FileStream GetLockFileStream(FileMode mode);
    public virtual bool Obtain();
    protected virtual void Dispose(bool disposing);
    public virtual bool IsLocked();
    public virtual string ToString();
}
public class Lucene.Net.Store.SimpleFSDirectory : FSDirectory {
    public SimpleFSDirectory(DirectoryInfo path, LockFactory lockFactory);
    public SimpleFSDirectory(DirectoryInfo path);
    public SimpleFSDirectory(string path, LockFactory lockFactory);
    public SimpleFSDirectory(string path);
    public virtual IndexInput OpenInput(string name, IOContext context);
    public virtual IndexInputSlicer CreateSlicer(string name, IOContext context);
}
internal class Lucene.Net.Store.SimpleFSLock : Lock {
    internal FileInfo lockFile;
    internal DirectoryInfo lockDir;
    public SimpleFSLock(DirectoryInfo lockDir, string lockFileName);
    public virtual bool Obtain();
    protected virtual void Dispose(bool disposing);
    public virtual bool IsLocked();
    public virtual string ToString();
}
public class Lucene.Net.Store.SimpleFSLockFactory : FSLockFactory {
    public SimpleFSLockFactory(DirectoryInfo lockDir);
    public SimpleFSLockFactory(string lockDirName);
    public virtual Lock MakeLock(string lockName);
    public virtual void ClearLock(string lockName);
}
internal class Lucene.Net.Store.SingleInstanceLock : Lock {
    internal string lockName;
    private HashSet`1<string> locks;
    public SingleInstanceLock(HashSet`1<string> locks, string lockName);
    public virtual bool Obtain();
    protected virtual void Dispose(bool disposing);
    public virtual bool IsLocked();
    public virtual string ToString();
}
public class Lucene.Net.Store.SingleInstanceLockFactory : LockFactory {
    private HashSet`1<string> locks;
    public virtual Lock MakeLock(string lockName);
    public virtual void ClearLock(string lockName);
}
public class Lucene.Net.Store.TrackingDirectoryWrapper : FilterDirectory {
    private ISet`1<string> createdFileNames;
    public ISet`1<string> CreatedFiles { get; }
    public TrackingDirectoryWrapper(Directory in);
    public virtual void DeleteFile(string name);
    public virtual IndexOutput CreateOutput(string name, IOContext context);
    public virtual void Copy(Directory to, string src, string dest, IOContext context);
    public virtual IndexInputSlicer CreateSlicer(string name, IOContext context);
    public ISet`1<string> get_CreatedFiles();
}
public class Lucene.Net.Store.VerifyingLockFactory : LockFactory {
    internal LockFactory lf;
    internal Stream stream;
    public VerifyingLockFactory(LockFactory lf, Stream stream);
    public virtual Lock MakeLock(string lockName);
    public virtual void ClearLock(string lockName);
}
internal static class Lucene.Net.Support.Arrays : object {
    public static bool Equals(T[] a, T[] b);
    public static int GetHashCode(T[] array);
    public static void Fill(T[] a, T val);
    public static void Fill(T[] a, int fromIndex, int toIndex, T val);
    public static T[] CopyOf(T[] original, int newLength);
    public static T[] CopyOfRange(T[] original, int startIndexInc, int endIndexExc);
    public static string ToString(T[] array);
    public static string ToString(T[] array, IFormatProvider provider);
    public static T[] Empty();
}
internal class Lucene.Net.Support.AssemblyUtils : object {
    public static IEnumerable`1<Assembly> GetReferencedAssemblies();
    private static Assembly LoadAssemblyFromName(AssemblyName assemblyName);
}
[ExtensionAttribute]
internal static class Lucene.Net.Support.CollectionExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool RemoveAll(ICollection`1<T> source, ICollection`1<T> collection);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static bool RetainAll(ICollection`1<T> source, ICollection`1<T> collection);
}
internal static class Lucene.Net.Support.Collections : object {
    public static ReadOnlyList`1<T> EmptyList();
    public static ReadOnlyDictionary`2<TKey, TValue> EmptyMap();
    public static ReadOnlySet`1<T> EmptySet();
    public static void Reverse(IList`1<T> list);
    public static IComparer`1<T> ReverseOrder();
    public static IComparer`1<T> ReverseOrder(IComparer`1<T> cmp);
    public static IDictionary`2<TKey, TValue> SingletonMap(TKey key, TValue value);
    public static string ToString(ICollection`1<T> collection);
    public static string ToString(ICollection`1<T> collection, CultureInfo culture);
    public static string ToString(IDictionary`2<TKey, TValue> dictionary);
    public static string ToString(IDictionary`2<TKey, TValue> dictionary, CultureInfo culture);
    public static string ToString(object obj);
    public static string ToString(object obj, CultureInfo culture);
}
[DefaultMemberAttribute("Item")]
internal class Lucene.Net.Support.ConcurrentDictionaryWrapper`2 : object {
    private ReaderWriterLockSlim _lock;
    private IDictionary`2<TKey, TValue> _dict;
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ConcurrentDictionaryWrapper`2(IDictionary`2<TKey, TValue> wrapped);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Lucene.Net.Support.ConcurrentHashSet`1 : object {
    private static int DefaultCapacity;
    private static int MaxLockNumber;
    private IEqualityComparer`1<T> _comparer;
    private bool _growLockArray;
    private int _budget;
    private Tables modreq(System.Runtime.CompilerServices.IsVolatile) _tables;
    private static int DefaultConcurrencyLevel { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public ConcurrentHashSet`1(int concurrencyLevel, int capacity);
    public ConcurrentHashSet`1(IEnumerable`1<T> collection);
    public ConcurrentHashSet`1(IEqualityComparer`1<T> comparer);
    public ConcurrentHashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    public ConcurrentHashSet`1(int concurrencyLevel, IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    public ConcurrentHashSet`1(int concurrencyLevel, int capacity, IEqualityComparer`1<T> comparer);
    private ConcurrentHashSet`1(int concurrencyLevel, int capacity, bool growLockArray, IEqualityComparer`1<T> comparer);
    private static int get_DefaultConcurrencyLevel();
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public sealed virtual bool Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public bool TryRemove(T item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("Lucene.Net.Support.ConcurrentHashSet`1/<GetEnumerator>d__25")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private void InitializeFromCollection(IEnumerable`1<T> collection);
    private bool AddInternal(T item, int hashcode, bool acquireLock);
    private static int GetBucket(int hashcode, int bucketCount);
    private static void GetBucketAndLockNo(int hashcode, Int32& bucketNo, Int32& lockNo, int bucketCount, int lockCount);
    private void GrowTable(Tables<T> tables);
    private void AcquireAllLocks(Int32& locksAcquired);
    private void AcquireLocks(int fromInclusive, int toExclusive, Int32& locksAcquired);
    private void ReleaseLocks(int fromInclusive, int toExclusive);
    private void CopyToItems(T[] array, int index);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Lucene.Net.Support.ConcurrentSet`1 : object {
    [NullableAttribute("2")]
private object syncRoot;
    private ISet`1<T> set;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ConcurrentSet`1(ISet`1<T> set);
    public sealed virtual bool Add(T item);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Equals(object other, IEqualityComparer comparer);
    public sealed virtual int GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
    public string ToString(string format);
}
internal class Lucene.Net.Support.CRC32 : object {
    private static UInt32[] crcTable;
    private UInt32 crc;
    public long Value { get; }
    private static CRC32();
    private static UInt32[] InitializeCRCTable();
    public sealed virtual long get_Value();
    public sealed virtual void Reset();
    public sealed virtual void Update(int bval);
    public sealed virtual void Update(Byte[] buf, int off, int len);
    public sealed virtual void Update(Byte[] buf);
}
internal static class Lucene.Net.Support.DateTimeOffsetUtil : object {
    private static long UnixEpochTicks;
    private static long UnixEpochMilliseconds;
    public static long MinMilliseconds;
    public static long MaxMilliseconds;
    private static long TicksPerMillisecond;
    private static long TicksPerSecond;
    private static long TicksPerMinute;
    private static long TicksPerHour;
    private static long TicksPerDay;
    private static int DaysPerYear;
    private static int DaysPer4Years;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysTo10000;
    internal static long MinTicks;
    internal static long MaxTicks;
    public static long GetTicksFromUnixTimeMilliseconds(long milliseconds);
    public static DateTimeOffset FromUnixTimeMilliseconds(long milliseconds);
    public static long ToUnixTimeMilliseconds(DateTimeOffset offset);
    public static long ToUnixTimeMilliseconds(long ticks);
}
[ExtensionAttribute]
internal static class Lucene.Net.Support.DictionaryExtensions : object {
    [ExtensionAttribute]
public static void PutAll(IDictionary`2<TKey, TValue> dict, IEnumerable`1<KeyValuePair`2<TKey, TValue>> kvps);
    [ExtensionAttribute]
public static TValue Put(IDictionary`2<TKey, TValue> dict, TKey key, TValue value);
    [ExtensionAttribute]
internal static IDictionary`2<TKey, TValue> AsConcurrent(IDictionary`2<TKey, TValue> dictionary);
}
[ExtensionAttribute]
internal static class Lucene.Net.Support.EnumerableExtensions : object {
    [IteratorStateMachineAttribute("Lucene.Net.Support.EnumerableExtensions/<InPairs>d__0`2")]
[ExtensionAttribute]
public static IEnumerable`1<TOut> InPairs(IEnumerable`1<T> source, Func`3<T, T, TOut> join);
    [ExtensionAttribute]
public static IEnumerable`1<T> TakeAllButLast(IEnumerable`1<T> source);
    [IteratorStateMachineAttribute("Lucene.Net.Support.EnumerableExtensions/<TakeAllButLastImpl>d__2`1")]
private static IEnumerable`1<T> TakeAllButLastImpl(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> TakeAllButLast(IEnumerable`1<T> source, int n);
    [IteratorStateMachineAttribute("Lucene.Net.Support.EnumerableExtensions/<TakeAllButLastImpl>d__4`1")]
private static IEnumerable`1<T> TakeAllButLastImpl(IEnumerable`1<T> source, int n);
}
[AttributeUsageAttribute("4")]
internal class Lucene.Net.Support.ExceptionToClassNameConventionAttribute : Attribute {
}
[AttributeUsageAttribute("708")]
internal class Lucene.Net.Support.ExceptionToNetNumericConventionAttribute : Attribute {
}
[AttributeUsageAttribute("480")]
internal class Lucene.Net.Support.ExceptionToNullableEnumConventionAttribute : Attribute {
}
internal interface Lucene.Net.Support.IChecksum {
    public long Value { get; }
    public abstract virtual void Reset();
    public abstract virtual void Update(int b);
    public abstract virtual void Update(Byte[] b);
    public abstract virtual void Update(Byte[] b, int offset, int length);
    public abstract virtual long get_Value();
}
internal class Lucene.Net.Support.IO.BinaryReaderDataInput : DataInput {
    private BinaryReader br;
    public BinaryReaderDataInput(BinaryReader br);
    public virtual byte ReadByte();
    public virtual void ReadBytes(Byte[] b, int offset, int len);
    public sealed virtual void Dispose();
}
internal class Lucene.Net.Support.IO.BinaryWriterDataOutput : DataOutput {
    private BinaryWriter bw;
    public BinaryWriterDataOutput(BinaryWriter bw);
    public virtual void WriteByte(byte b);
    public virtual void WriteBytes(Byte[] b, int offset, int length);
    public sealed virtual void Dispose();
}
internal class Lucene.Net.Support.IO.ByteArrayOutputStream : MemoryStream {
    public ByteArrayOutputStream(int size);
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class Lucene.Net.Support.IO.FileSupport : object {
    private static Char[] INVALID_FILENAME_CHARS;
    private static int WIN_HRESULT_FILE_ALREADY_EXISTS;
    private static Nullable`1<int> HRESULT_FILE_ALREADY_EXISTS;
    private static ConcurrentDictionary`2<string, string> fileCanonPathCache;
    private static FileSupport();
    private static Nullable`1<int> LoadFileAlreadyExistsHResult();
    internal static Nullable`1<int> GetFileIOExceptionHResult(Action`1<string> provokeException);
    public static FileInfo CreateTempFile(string prefix, string suffix);
    public static FileInfo CreateTempFile(string prefix, string suffix, DirectoryInfo directory);
    public static bool IsFileAlreadyExistsException(Exception ex, string filePath);
    internal static string NewTempFileName(string prefix, string suffix, DirectoryInfo directory);
    [ExtensionAttribute]
public static string GetCanonicalPath(FileSystemInfo path);
}
internal class Lucene.Net.Support.IO.SafeTextWriterWrapper : TextWriter {
    private TextWriter textWriter;
    private bool isDisposed;
    public Encoding Encoding { get; }
    public IFormatProvider FormatProvider { get; }
    public string NewLine { get; public set; }
    public SafeTextWriterWrapper(TextWriter textWriter);
    public virtual Encoding get_Encoding();
    public virtual IFormatProvider get_FormatProvider();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
    public virtual void Close();
    public virtual bool Equals(object obj);
    public virtual void Flush();
    public virtual Task FlushAsync();
    public virtual int GetHashCode();
    public virtual object InitializeLifetimeService();
    public virtual string ToString();
    public virtual void Write(bool value);
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(decimal value);
    public virtual void Write(double value);
    public virtual void Write(float value);
    public virtual void Write(int value);
    public virtual void Write(long value);
    public virtual void Write(object value);
    public virtual void Write(string format, object arg0);
    public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, object arg0, object arg1, object arg2);
    public virtual void Write(string format, Object[] arg);
    public virtual void Write(string value);
    public virtual void Write(UInt32 value);
    public virtual void Write(ulong value);
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    public virtual Task WriteAsync(string value);
    public virtual void WriteLine();
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(char value);
    public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(decimal value);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(int value);
    public virtual void WriteLine(long value);
    public virtual void WriteLine(object value);
    public virtual void WriteLine(string format, object arg0);
    public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, object arg0, object arg1, object arg2);
    public virtual void WriteLine(string format, Object[] arg);
    public virtual void WriteLine(string value);
    public virtual void WriteLine(UInt32 value);
    public virtual void WriteLine(ulong value);
    public virtual Task WriteLineAsync();
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    public virtual Task WriteLineAsync(string value);
    private void Run(Action method);
    private T Run(Func`1<T> method);
    public virtual void Reset();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private Encoding <get_Encoding>b__4_0();
    [CompilerGeneratedAttribute]
private IFormatProvider <get_FormatProvider>b__6_0();
    [CompilerGeneratedAttribute]
private string <get_NewLine>b__8_0();
    [CompilerGeneratedAttribute]
private void <Close>b__10_0();
    [CompilerGeneratedAttribute]
private void <Flush>b__12_0();
    [CompilerGeneratedAttribute]
private Task <FlushAsync>b__13_0();
    [CompilerGeneratedAttribute]
private int <GetHashCode>b__14_0();
    [CompilerGeneratedAttribute]
private object <InitializeLifetimeService>b__15_0();
    [CompilerGeneratedAttribute]
private string <ToString>b__16_0();
    [CompilerGeneratedAttribute]
private void <WriteLine>b__37_0();
    [CompilerGeneratedAttribute]
private Task <WriteLineAsync>b__55_0();
}
[ExtensionAttribute]
internal static class Lucene.Net.Support.IO.StreamExtensions : object {
    private static ConditionalWeakTable`2<Stream, object> lockCache;
    private static StreamExtensions();
    [ExtensionAttribute]
public static int Read(Stream stream, ByteBuffer destination, long position);
    [ExtensionAttribute]
public static void Write(Stream stream, Char[] chars);
    [ExtensionAttribute]
public static Char[] ReadChars(Stream stream, int count);
    [ExtensionAttribute]
public static void Write(Stream stream, int value);
    [ExtensionAttribute]
public static int ReadInt32(Stream stream);
    [ExtensionAttribute]
public static void Write(Stream stream, long value);
    [ExtensionAttribute]
public static long ReadInt64(Stream stream);
}
internal static class Lucene.Net.Support.PlatformHelper : object {
    private static int ProcessorCountRefreshIntervalMs;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _processorCount;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _lastProcessorCountRefreshTicks;
    internal static int ProcessorCount { get; }
    internal static int get_ProcessorCount();
}
internal static class Lucene.Net.Support.RectangularArrays : object {
    public static T[][] ReturnRectangularArray(int size1, int size2);
}
[ExtensionAttribute]
internal static class Lucene.Net.Support.SetExtensions : object {
    [ExtensionAttribute]
internal static ISet`1<T> AsConcurrent(ISet`1<T> set);
}
[ExtensionAttribute]
internal static class Lucene.Net.Support.Text.StringExtensions : object {
    [ExtensionAttribute]
public static bool ContainsAny(string input, Char[] charsToCompare);
}
internal class Lucene.Net.Support.Threading.LimitedConcurrencyLevelTaskScheduler : TaskScheduler {
    private AtomicBoolean shutDown;
    [ThreadStaticAttribute]
private static bool _currentThreadIsProcessingItems;
    private LinkedList`1<Task> _tasks;
    private int _maxDegreeOfParallelism;
    private int _delegatesQueuedOrRunning;
    public int MaximumConcurrencyLevel { get; }
    public LimitedConcurrencyLevelTaskScheduler(int maxDegreeOfParallelism);
    protected sealed virtual void QueueTask(Task task);
    private void NotifyThreadPoolOfPendingWork();
    protected sealed virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected sealed virtual bool TryDequeue(Task task);
    public sealed virtual int get_MaximumConcurrencyLevel();
    protected sealed virtual IEnumerable`1<Task> GetScheduledTasks();
    public void Shutdown();
    [CompilerGeneratedAttribute]
private void <NotifyThreadPoolOfPendingWork>b__7_0(object _);
}
[ExtensionAttribute]
[ObsoleteAttribute("Using these extensions will allocte memory. New code should call EnterReadLock(), ExitReadLock(), EnterWriteLock() or ExitWriteLock() directly in a try/finally block. This class will be removed in 4.8.0 release candidate.")]
internal static class Lucene.Net.Support.Threading.ReaderWriterLockSlimExtensions : object {
    [ExtensionAttribute]
public static IDisposable Read(ReaderWriterLockSlim obj);
    [ExtensionAttribute]
public static IDisposable Write(ReaderWriterLockSlim obj);
}
internal class Lucene.Net.Support.Threading.ReentrantLock : object {
    private object _lock;
    private int _queueLength;
    public int QueueLength { get; }
    public bool HasQueuedThreads { get; }
    public bool IsHeldByCurrentThread { get; }
    public void Lock();
    public void Unlock();
    public bool TryLock();
    public int get_QueueLength();
    public bool get_HasQueuedThreads();
    public bool get_IsHeldByCurrentThread();
}
internal class Lucene.Net.Support.Threading.TaskSchedulerCompletionService`1 : object {
    private TaskFactory`1<T> factory;
    private Queue`1<Task`1<T>> taskQueue;
    public TaskSchedulerCompletionService`1(TaskScheduler scheduler);
    public Task`1<T> Submit(Func`1<T> task);
    public Task`1<T> Take();
}
internal static class Lucene.Net.Support.Threading.UninterruptableMonitor : object {
    public static void Enter(object obj, Boolean& lockTaken);
    private static void RetryEnter(object obj, Boolean& lockTaken);
    public static void Enter(object obj);
    private static void RetryEnter(object obj);
    public static void Exit(object obj);
    public static bool IsEntered(object obj);
    public static bool TryEnter(object obj);
    public static void TryEnter(object obj, Boolean& lockTaken);
    public static bool TryEnter(object obj, int millisecondsTimeout);
    public static bool TryEnter(object obj, TimeSpan timeout);
    public static void TryEnter(object obj, int millisecondsTimeout, Boolean& lockTaken);
    public static void TryEnter(object obj, TimeSpan timeout, Boolean& lockTaken);
    public static void Pulse(object obj);
    public static void PulseAll(object obj);
    public static void Wait(object obj);
    public static void Wait(object obj, int millisecondsTimeout);
    public static void Wait(object obj, TimeSpan timeout);
    public static void Wait(object obj, int millisecondsTimeout, bool exitContext);
    public static void Wait(object obj, TimeSpan timeout, bool exitContext);
}
[AttributeUsageAttribute("192")]
internal class Lucene.Net.Support.WritableArrayAttribute : Attribute {
}
public class Lucene.Net.Util.AlreadySetException : InvalidOperationException {
    private AlreadySetException(SerializationInfo info, StreamingContext context);
}
internal class Lucene.Net.Util.ArrayInPlaceMergeSorter`1 : InPlaceMergeSorter {
    private T[] arr;
    private IComparer`1<T> comparer;
    public ArrayInPlaceMergeSorter`1(T[] arr, IComparer`1<T> comparer);
    protected virtual int Compare(int i, int j);
    protected virtual void Swap(int i, int j);
}
internal class Lucene.Net.Util.ArrayIntroSorter`1 : IntroSorter {
    private T[] arr;
    private IComparer`1<T> comparer;
    private T pivot;
    public ArrayIntroSorter`1(T[] arr, IComparer`1<T> comparer);
    protected virtual int Compare(int i, int j);
    protected virtual void Swap(int i, int j);
    protected virtual void SetPivot(int i);
    protected virtual int ComparePivot(int i);
}
internal class Lucene.Net.Util.ArrayTimSorter`1 : TimSorter {
    private IComparer`1<T> comparer;
    private T[] arr;
    private T[] tmp;
    public ArrayTimSorter`1(T[] arr, IComparer`1<T> comparer, int maxTempSlots);
    protected virtual int Compare(int i, int j);
    protected virtual void Swap(int i, int j);
    protected virtual void Copy(int src, int dest);
    protected virtual void Save(int start, int len);
    protected virtual void Restore(int src, int dest);
    protected virtual int CompareSaved(int i, int j);
}
public static class Lucene.Net.Util.ArrayUtil : object {
    public static int MAX_ARRAY_LENGTH;
    private static ArrayUtil();
    public static int ParseInt32(Char[] chars);
    public static int ParseInt32(Char[] chars, int offset, int len);
    public static int ParseInt32(Char[] chars, int offset, int len, int radix);
    private static int Parse(Char[] chars, int offset, int len, int radix, bool negative);
    public static int Oversize(int minTargetSize, int bytesPerElement);
    public static int GetShrinkSize(int currentSize, int targetSize, int bytesPerElement);
    public static Int16[] Grow(Int16[] array, int minSize);
    public static Int16[] Grow(Int16[] array);
    public static Single[] Grow(Single[] array, int minSize);
    public static Single[] Grow(Single[] array);
    public static Double[] Grow(Double[] array, int minSize);
    public static Double[] Grow(Double[] array);
    public static Int16[] Shrink(Int16[] array, int targetSize);
    public static Int32[] Grow(Int32[] array, int minSize);
    public static Int32[] Grow(Int32[] array);
    public static Int32[] Shrink(Int32[] array, int targetSize);
    public static Int64[] Grow(Int64[] array, int minSize);
    public static Int64[] Grow(Int64[] array);
    public static Int64[] Shrink(Int64[] array, int targetSize);
    [CLSCompliantAttribute("False")]
public static SByte[] Grow(SByte[] array, int minSize);
    public static Byte[] Grow(Byte[] array, int minSize);
    public static Byte[] Grow(Byte[] array);
    public static Byte[] Shrink(Byte[] array, int targetSize);
    public static Boolean[] Grow(Boolean[] array, int minSize);
    public static Boolean[] Grow(Boolean[] array);
    public static Boolean[] Shrink(Boolean[] array, int targetSize);
    public static Char[] Grow(Char[] array, int minSize);
    public static Char[] Grow(Char[] array);
    public static Char[] Shrink(Char[] array, int targetSize);
    [CLSCompliantAttribute("False")]
public static Int32[][] Grow(Int32[][] array, int minSize);
    [CLSCompliantAttribute("False")]
public static Int32[][] Grow(Int32[][] array);
    [CLSCompliantAttribute("False")]
public static Int32[][] Shrink(Int32[][] array, int targetSize);
    [CLSCompliantAttribute("False")]
public static Single[][] Grow(Single[][] array, int minSize);
    [CLSCompliantAttribute("False")]
public static Single[][] Grow(Single[][] array);
    [CLSCompliantAttribute("False")]
public static Single[][] Shrink(Single[][] array, int targetSize);
    public static int GetHashCode(Char[] array, int start, int end);
    public static int GetHashCode(Byte[] array, int start, int end);
    public static bool Equals(Char[] left, int offsetLeft, Char[] right, int offsetRight, int length);
    public static bool Equals(Byte[] left, int offsetLeft, Byte[] right, int offsetRight, int length);
    public static bool Equals(Int32[] left, int offsetLeft, Int32[] right, int offsetRight, int length);
    [ObsoleteAttribute("This API was only to address a compatibility problem with the port and is no longer necessary. This method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public static Int32[] ToInt32Array(ICollection`1<Nullable`1<int>> ints);
    public static IComparer`1<T> GetNaturalComparer();
    public static void Swap(T[] arr, int i, int j);
    public static void IntroSort(T[] a, int fromIndex, int toIndex, IComparer`1<T> comp);
    public static void IntroSort(T[] a, IComparer`1<T> comp);
    public static void IntroSort(T[] a, int fromIndex, int toIndex);
    public static void IntroSort(T[] a);
    public static void TimSort(T[] a, int fromIndex, int toIndex, IComparer`1<T> comp);
    public static void TimSort(T[] a, IComparer`1<T> comp);
    public static void TimSort(T[] a, int fromIndex, int toIndex);
    public static void TimSort(T[] a);
}
public abstract class Lucene.Net.Util.Attribute : object {
    public abstract virtual void Clear();
    public string ReflectAsString(bool prependAttClass);
    public virtual void ReflectWith(IAttributeReflector reflector);
    public virtual string ToString();
    public abstract virtual void CopyTo(IAttribute target);
    public virtual object Clone();
}
public class Lucene.Net.Util.AttributeSource : object {
    private IDictionary`2<Type, Attribute> attributes;
    private IDictionary`2<Type, Attribute> attributeImpls;
    private State[] currentState;
    private AttributeFactory factory;
    private static ConditionalWeakTable`2<Type, LinkedList`1<WeakReference`1<Type>>> knownImplClasses;
    public bool HasAttributes { get; }
    public AttributeSource(AttributeSource input);
    public AttributeSource(AttributeFactory factory);
    private static AttributeSource();
    public AttributeFactory GetAttributeFactory();
    public IEnumerator`1<Type> GetAttributeClassesEnumerator();
    public IEnumerator`1<Attribute> GetAttributeImplsEnumerator();
    internal static LinkedList`1<WeakReference`1<Type>> GetAttributeInterfaces(Type clazz);
    public void AddAttributeImpl(Attribute att);
    public T AddAttribute();
    public bool get_HasAttributes();
    public bool HasAttribute();
    public virtual T GetAttribute();
    private State GetCurrentState();
    public void ClearAttributes();
    public virtual State CaptureState();
    public void RestoreState(State state);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public string ReflectAsString(bool prependAttClass);
    public void ReflectWith(IAttributeReflector reflector);
    public AttributeSource CloneAttributes();
    public void CopyTo(AttributeSource target);
    public virtual string ToString();
}
public class Lucene.Net.Util.Automaton.Automaton : object {
    public static int MINIMIZE_HOPCROFT;
    internal static int minimization;
    internal State initial;
    internal bool deterministic;
    internal object info;
    internal string singleton;
    internal static bool minimize_always;
    internal static bool allow_mutation;
    private State[] numberedStates;
    internal static bool AllowMutate { get; }
    internal bool IsSingleton { get; }
    public string Singleton { get; }
    public bool IsDeterministic { get; public set; }
    public object Info { get; public set; }
    public bool IsEmptyString { get; }
    public Automaton(State initial);
    private static Automaton();
    public static void SetMinimization(int algorithm);
    public static void SetMinimizeAlways(bool flag);
    public static bool SetAllowMutate(bool flag);
    internal static bool get_AllowMutate();
    internal virtual void CheckMinimizeAlways();
    internal bool get_IsSingleton();
    public virtual string get_Singleton();
    public virtual State GetInitialState();
    public virtual bool get_IsDeterministic();
    public virtual void set_IsDeterministic(bool value);
    public virtual object get_Info();
    public virtual void set_Info(object value);
    public virtual State[] GetNumberedStates();
    public virtual void SetNumberedStates(State[] states);
    public virtual void SetNumberedStates(State[] states, int count);
    public virtual void ClearNumberedStates();
    public virtual ISet`1<State> GetAcceptStates();
    internal virtual void Totalize();
    public virtual void RestoreInvariant();
    public virtual void Reduce();
    public virtual Int32[] GetStartPoints();
    private State[] GetLiveStates();
    public virtual void RemoveDeadTransitions();
    public virtual Transition[][] GetSortedTransitions();
    public virtual void ExpandSingleton();
    public virtual int GetNumberOfStates();
    public virtual int GetNumberOfTransitions();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual string ToDot();
    internal virtual Automaton CloneExpanded();
    internal virtual Automaton CloneExpandedIfRequired();
    public virtual object Clone();
    internal virtual Automaton CloneIfRequired();
    public virtual Automaton Concatenate(Automaton a);
    public static Automaton Concatenate(IList`1<Automaton> l);
    public virtual Automaton Optional();
    public virtual Automaton Repeat();
    public virtual Automaton Repeat(int min);
    public virtual Automaton Repeat(int min, int max);
    public virtual Automaton Complement();
    public virtual Automaton Minus(Automaton a);
    public virtual Automaton Intersection(Automaton a);
    public virtual bool SubsetOf(Automaton a);
    public virtual Automaton Union(Automaton a);
    public static Automaton Union(ICollection`1<Automaton> l);
    public virtual void Determinize();
    public virtual bool get_IsEmptyString();
    public static Automaton Minimize(Automaton a);
}
public static class Lucene.Net.Util.Automaton.BasicAutomata : object {
    public static Automaton MakeEmpty();
    public static Automaton MakeEmptyString();
    public static Automaton MakeAnyString();
    public static Automaton MakeAnyChar();
    public static Automaton MakeChar(int c);
    public static Automaton MakeCharRange(int min, int max);
    private static State AnyOfRightLength(string x, int n);
    private static State AtLeast(string x, int n, ICollection`1<State> initials, bool zeros);
    private static State AtMost(string x, int n);
    private static State Between(string x, string y, int n, ICollection`1<State> initials, bool zeros);
    public static Automaton MakeInterval(int min, int max, int digits);
    public static Automaton MakeString(string s);
    public static Automaton MakeString(Int32[] word, int offset, int length);
    public static Automaton MakeStringUnion(ICollection`1<BytesRef> utf8Strings);
}
public static class Lucene.Net.Util.Automaton.BasicOperations : object {
    public static Automaton Concatenate(Automaton a1, Automaton a2);
    public static Automaton Concatenate(IList`1<Automaton> l);
    public static Automaton Optional(Automaton a);
    public static Automaton Repeat(Automaton a);
    public static Automaton Repeat(Automaton a, int min);
    public static Automaton Repeat(Automaton a, int min, int max);
    public static Automaton Complement(Automaton a);
    public static Automaton Minus(Automaton a1, Automaton a2);
    public static Automaton Intersection(Automaton a1, Automaton a2);
    public static bool SameLanguage(Automaton a1, Automaton a2);
    public static bool SubsetOf(Automaton a1, Automaton a2);
    public static Automaton Union(Automaton a1, Automaton a2);
    public static Automaton Union(ICollection`1<Automaton> l);
    public static void Determinize(Automaton a);
    public static void AddEpsilons(Automaton a, ICollection`1<StatePair> pairs);
    public static bool IsEmptyString(Automaton a);
    public static bool IsEmpty(Automaton a);
    public static bool IsTotal(Automaton a);
    public static bool Run(Automaton a, string s);
}
public class Lucene.Net.Util.Automaton.ByteRunAutomaton : RunAutomaton {
    public ByteRunAutomaton(Automaton a);
    public ByteRunAutomaton(Automaton a, bool utf8);
    public virtual bool Run(Byte[] s, int offset, int length);
}
public class Lucene.Net.Util.Automaton.CharacterRunAutomaton : RunAutomaton {
    public CharacterRunAutomaton(Automaton a);
    public virtual bool Run(string s);
    public virtual bool Run(Char[] s, int offset, int length);
}
public class Lucene.Net.Util.Automaton.CompiledAutomaton : object {
    [CompilerGeneratedAttribute]
private AUTOMATON_TYPE <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private BytesRef <Term>k__BackingField;
    [CompilerGeneratedAttribute]
private ByteRunAutomaton <RunAutomaton>k__BackingField;
    private Transition[][] sortedTransitions;
    [CompilerGeneratedAttribute]
private BytesRef <CommonSuffixRef>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Finite>k__BackingField;
    public AUTOMATON_TYPE Type { get; private set; }
    public BytesRef Term { get; private set; }
    public ByteRunAutomaton RunAutomaton { get; private set; }
    [WritableArrayAttribute]
public Transition[][] SortedTransitions { get; }
    public BytesRef CommonSuffixRef { get; private set; }
    public Nullable`1<bool> Finite { get; private set; }
    public CompiledAutomaton(Automaton automaton);
    public CompiledAutomaton(Automaton automaton, Nullable`1<bool> finite, bool simplify);
    [CompilerGeneratedAttribute]
public AUTOMATON_TYPE get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(AUTOMATON_TYPE value);
    [CompilerGeneratedAttribute]
public BytesRef get_Term();
    [CompilerGeneratedAttribute]
private void set_Term(BytesRef value);
    [CompilerGeneratedAttribute]
public ByteRunAutomaton get_RunAutomaton();
    [CompilerGeneratedAttribute]
private void set_RunAutomaton(ByteRunAutomaton value);
    public Transition[][] get_SortedTransitions();
    [CompilerGeneratedAttribute]
public BytesRef get_CommonSuffixRef();
    [CompilerGeneratedAttribute]
private void set_CommonSuffixRef(BytesRef value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Finite();
    [CompilerGeneratedAttribute]
private void set_Finite(Nullable`1<bool> value);
    private BytesRef AddTail(int state, BytesRef term, int idx, int leadLabel);
    public virtual TermsEnum GetTermsEnum(Terms terms);
    public virtual BytesRef Floor(BytesRef input, BytesRef output);
    public virtual string ToDot();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder : object {
    private Dictionary`2<State, State> stateRegistry;
    private State root;
    private CharsRef previous;
    private static IComparer`1<CharsRef> comparer;
    private static DaciukMihovAutomatonBuilder();
    public void Add(CharsRef current);
    public State Complete();
    private static State Convert(State s, IDictionary`2<State, State> visited);
    public static Automaton Build(ICollection`1<BytesRef> input);
    private bool SetPrevious(CharsRef current);
    private void ReplaceOrRegister(State state);
    private static void AddSuffix(State state, ICharSequence current, int fromIndex);
}
public interface Lucene.Net.Util.Automaton.IAutomatonProvider {
    public abstract virtual Automaton GetAutomaton(string name);
}
internal class Lucene.Net.Util.Automaton.Lev1ParametricDescription : ParametricDescription {
    private static Int64[] toStates0;
    private static Int64[] offsetIncrs0;
    private static Int64[] toStates1;
    private static Int64[] offsetIncrs1;
    private static Int64[] toStates2;
    private static Int64[] offsetIncrs2;
    private static Int64[] toStates3;
    private static Int64[] offsetIncrs3;
    public Lev1ParametricDescription(int w);
    private static Lev1ParametricDescription();
    internal virtual int Transition(int absState, int position, int vector);
}
internal class Lucene.Net.Util.Automaton.Lev1TParametricDescription : ParametricDescription {
    private static Int64[] toStates0;
    private static Int64[] offsetIncrs0;
    private static Int64[] toStates1;
    private static Int64[] offsetIncrs1;
    private static Int64[] toStates2;
    private static Int64[] offsetIncrs2;
    private static Int64[] toStates3;
    private static Int64[] offsetIncrs3;
    public Lev1TParametricDescription(int w);
    private static Lev1TParametricDescription();
    internal virtual int Transition(int absState, int position, int vector);
}
internal class Lucene.Net.Util.Automaton.Lev2ParametricDescription : ParametricDescription {
    private static Int64[] toStates0;
    private static Int64[] offsetIncrs0;
    private static Int64[] toStates1;
    private static Int64[] offsetIncrs1;
    private static Int64[] toStates2;
    private static Int64[] offsetIncrs2;
    private static Int64[] toStates3;
    private static Int64[] offsetIncrs3;
    private static Int64[] toStates4;
    private static Int64[] offsetIncrs4;
    private static Int64[] toStates5;
    private static Int64[] offsetIncrs5;
    public Lev2ParametricDescription(int w);
    private static Lev2ParametricDescription();
    internal virtual int Transition(int absState, int position, int vector);
}
internal class Lucene.Net.Util.Automaton.Lev2TParametricDescription : ParametricDescription {
    private static Int64[] toStates0;
    private static Int64[] offsetIncrs0;
    private static Int64[] toStates1;
    private static Int64[] offsetIncrs1;
    private static Int64[] toStates2;
    private static Int64[] offsetIncrs2;
    private static Int64[] toStates3;
    private static Int64[] offsetIncrs3;
    private static Int64[] toStates4;
    private static Int64[] offsetIncrs4;
    private static Int64[] toStates5;
    private static Int64[] offsetIncrs5;
    public Lev2TParametricDescription(int w);
    private static Lev2TParametricDescription();
    internal virtual int Transition(int absState, int position, int vector);
}
public class Lucene.Net.Util.Automaton.LevenshteinAutomata : object {
    public static int MAXIMUM_SUPPORTED_DISTANCE;
    internal Int32[] word;
    internal Int32[] alphabet;
    internal int alphaMax;
    internal Int32[] rangeLower;
    internal Int32[] rangeUpper;
    internal int numRanges;
    internal ParametricDescription[] descriptions;
    public LevenshteinAutomata(string input, bool withTranspositions);
    public LevenshteinAutomata(Int32[] word, int alphaMax, bool withTranspositions);
    private static Int32[] CodePoints(string input);
    public virtual Automaton ToAutomaton(int n);
    internal virtual int GetVector(int x, int pos, int end);
}
public static class Lucene.Net.Util.Automaton.MinimizationOperations : object {
    public static void Minimize(Automaton a);
    public static void MinimizeHopcroft(Automaton a);
}
public class Lucene.Net.Util.Automaton.RegExp : object {
    private static bool allow_mutation;
    internal Kind kind;
    internal RegExp exp1;
    internal RegExp exp2;
    internal string s;
    internal int c;
    internal int min;
    internal int max;
    internal int digits;
    internal int from;
    internal int to;
    internal string b;
    internal RegExpSyntax flags;
    internal int pos;
    public RegExp(string s);
    public RegExp(string s, RegExpSyntax syntax_flags);
    public virtual Automaton ToAutomaton();
    public virtual Automaton ToAutomaton(IAutomatonProvider automaton_provider);
    public virtual Automaton ToAutomaton(IDictionary`2<string, Automaton> automata);
    public virtual bool SetAllowMutate(bool flag);
    private Automaton ToAutomatonAllowMutate(IDictionary`2<string, Automaton> automata, IAutomatonProvider automaton_provider);
    private Automaton ToAutomaton(IDictionary`2<string, Automaton> automata, IAutomatonProvider automaton_provider);
    private void FindLeaves(RegExp exp, Kind kind, IList`1<Automaton> list, IDictionary`2<string, Automaton> automata, IAutomatonProvider automaton_provider);
    public virtual string ToString();
    internal virtual StringBuilder ToStringBuilder(StringBuilder b);
    public virtual ISet`1<string> GetIdentifiers();
    internal virtual void GetIdentifiers(ISet`1<string> set);
    internal static RegExp MakeUnion(RegExp exp1, RegExp exp2);
    internal static RegExp MakeConcatenation(RegExp exp1, RegExp exp2);
    private static RegExp MakeString(RegExp exp1, RegExp exp2);
    internal static RegExp MakeIntersection(RegExp exp1, RegExp exp2);
    internal static RegExp MakeOptional(RegExp exp);
    internal static RegExp MakeRepeat(RegExp exp);
    internal static RegExp MakeRepeat(RegExp exp, int min);
    internal static RegExp MakeRepeat(RegExp exp, int min, int max);
    internal static RegExp MakeComplement(RegExp exp);
    internal static RegExp MakeChar(int c);
    internal static RegExp MakeCharRange(int from, int to);
    internal static RegExp MakeAnyChar();
    internal static RegExp MakeEmpty();
    internal static RegExp MakeString(string s);
    internal static RegExp MakeAnyString();
    internal static RegExp MakeAutomaton(string s);
    internal static RegExp MakeInterval(int min, int max, int digits);
    private bool Peek(string s);
    private bool Match(int c);
    private bool More();
    private int Next();
    private bool Check(RegExpSyntax flag);
    internal RegExp ParseUnionExp();
    internal RegExp ParseInterExp();
    internal RegExp ParseConcatExp();
    internal RegExp ParseRepeatExp();
    internal RegExp ParseComplExp();
    internal RegExp ParseCharClassExp();
    internal RegExp ParseCharClasses();
    internal RegExp ParseCharClass();
    internal RegExp ParseSimpleExp();
    internal int ParseCharExp();
}
[FlagsAttribute]
public enum Lucene.Net.Util.Automaton.RegExpSyntax : Enum {
    public int value__;
    public static RegExpSyntax INTERSECTION;
    public static RegExpSyntax COMPLEMENT;
    public static RegExpSyntax EMPTY;
    public static RegExpSyntax ANYSTRING;
    public static RegExpSyntax AUTOMATON;
    public static RegExpSyntax INTERVAL;
    public static RegExpSyntax ALL;
    public static RegExpSyntax NONE;
}
public abstract class Lucene.Net.Util.Automaton.RunAutomaton : object {
    private int _maxInterval;
    private int _size;
    protected Boolean[] m_accept;
    protected int m_initial;
    protected Int32[] m_transitions;
    private Int32[] _points;
    private Int32[] _classmap;
    public int Count { get; }
    public int InitialState { get; }
    protected RunAutomaton(Automaton a, int maxInterval, bool tableize);
    public virtual string ToString();
    public int get_Count();
    public bool IsAccept(int state);
    public int get_InitialState();
    public Int32[] GetCharIntervals();
    internal int GetCharClass(int c);
    public int Step(int state, int c);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal class Lucene.Net.Util.Automaton.SortedInt32Set : object {
    internal Int32[] values;
    internal Int32[] counts;
    internal int upto;
    private int hashCode;
    private static int TREE_MAP_CUTOVER;
    private IDictionary`2<int, int> map;
    private bool useTreeMap;
    internal State state;
    public SortedInt32Set(int capacity);
    public void Incr(int num);
    public void Decr(int num);
    public void ComputeHash();
    public FrozenInt32Set ToFrozenInt32Set();
    public FrozenInt32Set Freeze(State state);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
public static class Lucene.Net.Util.Automaton.SpecialOperations : object {
    internal static int FindIndex(int c, Int32[] points);
    public static bool IsFinite(Automaton a);
    private static bool IsFinite(State s, OpenBitSet path, OpenBitSet visited);
    public static string GetCommonPrefix(Automaton a);
    public static BytesRef GetCommonPrefixBytesRef(Automaton a);
    public static string GetCommonSuffix(Automaton a);
    public static BytesRef GetCommonSuffixBytesRef(Automaton a);
    private static void ReverseBytes(BytesRef ref);
    public static ISet`1<State> Reverse(Automaton a);
    public static ISet`1<Int32sRef> GetFiniteStrings(Automaton a, int limit);
    private static bool GetFiniteStrings(State s, HashSet`1<State> pathstates, HashSet`1<Int32sRef> strings, Int32sRef path, int limit);
}
public class Lucene.Net.Util.Automaton.State : object {
    internal bool accept;
    private Transition[] transitionsArray;
    internal int numTransitions;
    internal int number;
    internal int id;
    internal static int next_id;
    [WritableArrayAttribute]
public Transition[] TransitionsArray { get; }
    public int NumTransitions { get; }
    public bool Accept { get; public set; }
    public int Number { get; }
    public Transition[] get_TransitionsArray();
    internal void ResetTransitions();
    public virtual IEnumerable`1<Transition> GetTransitions();
    public virtual int get_NumTransitions();
    public virtual void SetTransitions(Transition[] transitions);
    public virtual void AddTransition(Transition t);
    public virtual bool get_Accept();
    public virtual void set_Accept(bool value);
    public virtual State Step(int c);
    public virtual void Step(int c, ICollection`1<State> dest);
    internal virtual void AddEpsilon(State to);
    public virtual void TrimTransitionsArray();
    public virtual void Reduce();
    public virtual void SortTransitions(IComparer`1<Transition> comparer);
    public virtual int get_Number();
    public virtual string ToString();
    public virtual int CompareTo(State s);
    public virtual int GetHashCode();
}
public class Lucene.Net.Util.Automaton.StatePair : object {
    internal State s;
    internal State s1;
    internal State s2;
    public State FirstState { get; }
    public State SecondState { get; }
    internal StatePair(State s, State s1, State s2);
    public StatePair(State s1, State s2);
    public virtual State get_FirstState();
    public virtual State get_SecondState();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Lucene.Net.Util.Automaton.Transition : object {
    internal int min;
    internal int max;
    internal State to;
    public static IComparer`1<Transition> COMPARE_BY_DEST_THEN_MIN_MAX;
    public static IComparer`1<Transition> COMPARE_BY_MIN_MAX_THEN_DEST;
    public int Min { get; }
    public int Max { get; }
    public State Dest { get; }
    public Transition(int c, State to);
    public Transition(int min, int max, State to);
    private static Transition();
    public virtual int get_Min();
    public virtual int get_Max();
    public virtual State get_Dest();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual object Clone();
    internal static void AppendCharString(int c, StringBuilder b);
    public virtual string ToString();
    internal virtual void AppendDot(StringBuilder b);
}
public class Lucene.Net.Util.Automaton.UTF32ToUTF8 : object {
    private static Int32[] startCodes;
    private static Int32[] endCodes;
    internal static Int32[] MASKS;
    private UTF8Sequence startUTF8;
    private UTF8Sequence endUTF8;
    private UTF8Sequence tmpUTF8a;
    private UTF8Sequence tmpUTF8b;
    private State[] utf8States;
    private int utf8StateCount;
    private static UTF32ToUTF8();
    private static Int32[] LoadMasks();
    internal void ConvertOneEdge(State start, State end, int startCodePoint, int endCodePoint);
    private void Build(State start, State end, UTF8Sequence startUTF8, UTF8Sequence endUTF8, int upto);
    private void Start(State start, State end, UTF8Sequence utf8, int upto, bool doAll);
    private void End(State start, State end, UTF8Sequence utf8, int upto, bool doAll);
    private void All(State start, State end, int startCode, int endCode, int left);
    public Automaton Convert(Automaton utf32);
    private State NewUTF8State();
}
public static class Lucene.Net.Util.Bits : object {
    public static IBits[] EMPTY_ARRAY;
    private static Bits();
}
public static class Lucene.Net.Util.BitUtil : object {
    private static SByte[] BYTE_COUNTS;
    private static Int32[] BIT_LISTS;
    private static BitUtil();
    public static int BitCount(byte b);
    public static int BitList(byte b);
    public static long Pop_Array(Int64[] arr, int wordOffset, int numWords);
    public static long Pop_Intersect(Int64[] arr1, Int64[] arr2, int wordOffset, int numWords);
    public static long Pop_Union(Int64[] arr1, Int64[] arr2, int wordOffset, int numWords);
    public static long Pop_AndNot(Int64[] arr1, Int64[] arr2, int wordOffset, int numWords);
    public static long Pop_Xor(Int64[] arr1, Int64[] arr2, int wordOffset, int numWords);
    public static int NextHighestPowerOfTwo(int v);
    public static long NextHighestPowerOfTwo(long v);
}
public static class Lucene.Net.Util.BroadWord : object {
    public static long L8_L;
    public static long L9_L;
    public static long L16_L;
    public static long H8_L;
    public static long H16_L;
    private static BroadWord();
    internal static int BitCount(long x);
    public static int Select(long x, int r);
    public static long SmallerUpTo7_8(long x, long y);
    public static long Smalleru_8(long x, long y);
    public static long NotEquals0_8(long x);
    public static long SmallerUpto15_16(long x, long y);
    public static int SelectNaive(long x, int r);
}
public class Lucene.Net.Util.ByteBlockPool : object {
    public static int BYTE_BLOCK_SHIFT;
    public static int BYTE_BLOCK_SIZE;
    public static int BYTE_BLOCK_MASK;
    private Byte[][] buffers;
    private int bufferUpto;
    [CompilerGeneratedAttribute]
private int <ByteUpto>k__BackingField;
    private Byte[] buffer;
    [CompilerGeneratedAttribute]
private int <ByteOffset>k__BackingField;
    private Allocator allocator;
    public static Int32[] NEXT_LEVEL_ARRAY;
    public static Int32[] LEVEL_SIZE_ARRAY;
    public static int FIRST_LEVEL_SIZE;
    [WritableArrayAttribute]
public Byte[][] Buffers { get; public set; }
    public int ByteUpto { get; public set; }
    [WritableArrayAttribute]
public Byte[] Buffer { get; public set; }
    public int ByteOffset { get; public set; }
    public ByteBlockPool(Allocator allocator);
    private static ByteBlockPool();
    public Byte[][] get_Buffers();
    public void set_Buffers(Byte[][] value);
    [CompilerGeneratedAttribute]
public int get_ByteUpto();
    [CompilerGeneratedAttribute]
public void set_ByteUpto(int value);
    public Byte[] get_Buffer();
    public void set_Buffer(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_ByteOffset();
    [CompilerGeneratedAttribute]
public void set_ByteOffset(int value);
    public void Reset();
    public void Reset(bool zeroFillBuffers, bool reuseFirst);
    public void NextBuffer();
    public int NewSlice(int size);
    public int AllocSlice(Byte[] slice, int upto);
    public void SetBytesRef(BytesRef term, int textStart);
    public void Append(BytesRef bytes);
    public void ReadBytes(long offset, Byte[] bytes, int off, int length);
}
[DebuggerDisplayAttribute("{ToString()} {Utf8ToString()}")]
public class Lucene.Net.Util.BytesRef : object {
    public static Byte[] EMPTY_BYTES;
    private Byte[] bytes;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    private static IComparer`1<BytesRef> utf8SortedAsUnicodeSortOrder;
    [ObsoleteAttribute("this comparer is only a transition mechanism")]
private static IComparer`1<BytesRef> utf8SortedAsUTF16SortOrder;
    [WritableArrayAttribute]
public Byte[] Bytes { get; public set; }
    public int Offset { get; public set; }
    public int Length { get; public set; }
    public static IComparer`1<BytesRef> UTF8SortedAsUnicodeComparer { get; }
    [ObsoleteAttribute("this comparer is only a transition mechanism")]
public static IComparer`1<BytesRef> UTF8SortedAsUTF16Comparer { get; }
    public BytesRef(Byte[] bytes, int offset, int length);
    public BytesRef(Byte[] bytes);
    public BytesRef(int capacity);
    public BytesRef(ICharSequence text);
    public BytesRef(string text);
    private static BytesRef();
    public Byte[] get_Bytes();
    public void set_Bytes(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(int value);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(int value);
    public void CopyChars(ICharSequence text);
    public void CopyChars(string text);
    public bool BytesEquals(BytesRef other);
    public object Clone();
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    private sealed virtual override bool System.IEquatable<Lucene.Net.Util.BytesRef>.Equals(BytesRef other);
    public string Utf8ToString();
    public virtual string ToString();
    public void CopyBytes(BytesRef other);
    public void Append(BytesRef other);
    public void Grow(int newLength);
    public sealed virtual int CompareTo(object other);
    public sealed virtual int CompareTo(BytesRef other);
    public static IComparer`1<BytesRef> get_UTF8SortedAsUnicodeComparer();
    public static IComparer`1<BytesRef> get_UTF8SortedAsUTF16Comparer();
    public static BytesRef DeepCopyOf(BytesRef other);
    public bool IsValid();
}
public class Lucene.Net.Util.BytesRefArray : object {
    private ByteBlockPool pool;
    private Int32[] offsets;
    private int lastElement;
    private int currentOffset;
    private Counter bytesUsed;
    public int Length { get; }
    public BytesRefArray(Counter bytesUsed);
    public void Clear();
    public int Append(BytesRef bytes);
    public int get_Length();
    public BytesRef Get(BytesRef spare, int index);
    private Int32[] Sort(IComparer`1<BytesRef> comp);
    [ObsoleteAttribute("Use GetEnumerator() instead. This method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public IBytesRefIterator GetIterator();
    [ObsoleteAttribute("Use GetEnumerator(IComparer<BytesRef>) instead. This method will be removed in 4.8.0 release candidate")]
[EditorBrowsableAttribute("1")]
public IBytesRefIterator GetIterator(IComparer`1<BytesRef> comp);
    public IBytesRefEnumerator GetEnumerator();
    public IBytesRefEnumerator GetEnumerator(IComparer`1<BytesRef> comparer);
}
public static class Lucene.Net.Util.BytesRefEnumerator : object {
    public static IBytesRefEnumerator EMPTY;
    private static BytesRefEnumerator();
}
internal enum Lucene.Net.Util.BytesRefFormat : Enum {
    public int value__;
    public static BytesRefFormat UTF8;
    public static BytesRefFormat UTF8AsHex;
}
internal class Lucene.Net.Util.BytesRefFormatter : ValueType {
    private BytesRef bytesRef;
    private BytesRefFormat format;
    public BytesRefFormatter(BytesRef bytesRef, BytesRefFormat format);
    public virtual string ToString();
}
public class Lucene.Net.Util.BytesRefHash : object {
    public static int DEFAULT_CAPACITY;
    internal ByteBlockPool pool;
    internal Int32[] bytesStart;
    private BytesRef scratch1;
    private int hashSize;
    private int hashHalfSize;
    private int hashMask;
    private int count;
    private int lastCount;
    private Int32[] ids;
    private BytesStartArray bytesStartArray;
    private Counter bytesUsed;
    public int Count { get; }
    public BytesRefHash(ByteBlockPool pool);
    public BytesRefHash(ByteBlockPool pool, int capacity, BytesStartArray bytesStartArray);
    public int get_Count();
    public BytesRef Get(int bytesID, BytesRef ref);
    public Int32[] Compact();
    public Int32[] Sort(IComparer`1<BytesRef> comp);
    private bool Equals(int id, BytesRef b);
    private bool Shrink(int targetSize);
    public void Clear(bool resetPool);
    public void Clear();
    public sealed virtual void Dispose();
    public int Add(BytesRef bytes);
    public int Find(BytesRef bytes);
    private int FindHash(BytesRef bytes);
    public int AddByPoolOffset(int offset);
    private void Rehash(int newSize, bool hashOnData);
    private static int DoHash(Byte[] bytes, int offset, int length);
    public void Reinit();
    public int ByteStart(int bytesID);
}
[ObsoleteAttribute("Use BytesRefEnumerator instead. This class will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public static class Lucene.Net.Util.BytesRefIterator : object {
    public static IBytesRefIterator EMPTY;
    private static BytesRefIterator();
}
internal static class Lucene.Net.Util.CastTo`1 : object {
    public static T From(TSource s);
}
[DefaultMemberAttribute("Item")]
public class Lucene.Net.Util.CharsRef : object {
    public static Char[] EMPTY_CHARS;
    private Char[] chars;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [ObsoleteAttribute("this comparer is only a transition mechanism")]
private static IComparer`1<CharsRef> utf16SortedAsUTF8SortOrder;
    private bool J2N.Text.ICharSequence.HasValue { get; }
    [WritableArrayAttribute]
public Char[] Chars { get; public set; }
    public int Offset { get; internal set; }
    public int Length { get; public set; }
    public char Item { get; }
    [ObsoleteAttribute("this comparer is only a transition mechanism")]
public static IComparer`1<CharsRef> UTF16SortedAsUTF8Comparer { get; }
    public CharsRef(int capacity);
    public CharsRef(Char[] chars, int offset, int length);
    public CharsRef(string string);
    private static CharsRef();
    private sealed virtual override bool J2N.Text.ICharSequence.get_HasValue();
    public Char[] get_Chars();
    public void set_Chars(Char[] value);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
internal void set_Offset(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(int value);
    public object Clone();
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    private sealed virtual override bool System.IEquatable<Lucene.Net.Util.CharsRef>.Equals(CharsRef other);
    public bool CharsEquals(CharsRef other);
    public sealed virtual int CompareTo(CharsRef other);
    public void CopyChars(CharsRef other);
    public void Grow(int newLength);
    public void CopyChars(Char[] otherChars, int otherOffset, int otherLength);
    public void Append(Char[] otherChars, int otherOffset, int otherLength);
    public virtual string ToString();
    public sealed virtual char get_Item(int index);
    public sealed virtual ICharSequence Subsequence(int startIndex, int length);
    public static IComparer`1<CharsRef> get_UTF16SortedAsUTF8Comparer();
    public static CharsRef DeepCopyOf(CharsRef other);
    public bool IsValid();
}
public static class Lucene.Net.Util.CollectionUtil : object {
    public static void IntroSort(IList`1<T> list, IComparer`1<T> comp);
    public static void IntroSort(IList`1<T> list);
    public static void TimSort(IList`1<T> list, IComparer`1<T> comp);
    public static void TimSort(IList`1<T> list);
}
public static class Lucene.Net.Util.CommandLineUtil : object {
    public static FSDirectory NewFSDirectory(string clazzName, DirectoryInfo dir);
    public static Type LoadDirectoryClass(string clazzName);
    public static Type LoadFSDirectoryClass(string clazzName);
    private static string AdjustDirectoryClassName(string clazzName);
    public static FSDirectory NewFSDirectory(Type clazz, DirectoryInfo dir);
}
public static class Lucene.Net.Util.Constants : object {
    private static Regex VERSION;
    public static string RUNTIME_VENDOR;
    public static string OS_NAME;
    public static bool LINUX;
    public static bool WINDOWS;
    public static bool SUN_OS;
    public static bool MAC_OS_X;
    public static bool FREE_BSD;
    public static string OS_ARCH;
    public static string OS_VERSION;
    public static string RUNTIME_VERSION;
    public static bool RUNTIME_IS_64BIT;
    public static string LUCENE_MAIN_VERSION;
    public static string LUCENE_VERSION;
    private static Regex MAIN_VERSION_WITHOUT_ALPHA_BETA;
    internal static string MainVersionWithoutAlphaBeta { get; }
    private static Constants();
    private static string LoadRuntimeVersion();
    private static bool LoadRuntimeIs64Bit();
    private static string Ident(string s);
    internal static string get_MainVersionWithoutAlphaBeta();
    private static string ExtractString(string input, Regex pattern);
}
public abstract class Lucene.Net.Util.Counter : object {
    public long Value { get; }
    public abstract virtual long AddAndGet(long delta);
    public abstract virtual long get_Value();
    [ObsoleteAttribute("Use Value instead. This method will be removed in 4.8.0 release candidate.")]
public virtual long Get();
    public static Counter NewCounter();
    public static Counter NewCounter(bool threadSafe);
    public static long op_Implicit(Counter counter);
}
public class Lucene.Net.Util.DisposableThreadLocal`1 : object {
    [ThreadStaticAttribute]
private static CurrentThreadState<T> _state;
    private WeakReferenceCompareValue`1<T, DisposableThreadLocal`1<T>> selfReference;
    private ConcurrentDictionary`2<WeakReferenceCompareValue`1<T, CurrentThreadState<T>>, T> _values;
    private Func`1<T> _valueFactory;
    private bool _disposed;
    private static int globalVersion;
    public ICollection`1<T> Values { get; }
    public bool IsValueCreated { get; }
    public T Value { get; public set; }
    public DisposableThreadLocal`1(Func`1<T> valueFactory);
    public ICollection`1<T> get_Values();
    public bool get_IsValueCreated();
    [ObsoleteAttribute("Use Value instead. This method will be removed in 4.8.0 release candidate.")]
public T Get();
    [ObsoleteAttribute("Use Value instead. This method will be removed in 4.8.0 release candidate.")]
public void Set(T value);
    public T get_Value();
    public void set_Value(T value);
    public sealed virtual void Dispose();
}
public class Lucene.Net.Util.DocIdBitSet : DocIdSet {
    private BitSet bitSet;
    public IBits Bits { get; }
    public bool IsCacheable { get; }
    public BitSet BitSet { get; }
    public int Length { get; }
    public DocIdBitSet(BitSet bitSet);
    public virtual DocIdSetIterator GetIterator();
    public virtual IBits get_Bits();
    public virtual bool get_IsCacheable();
    public virtual BitSet get_BitSet();
    public sealed virtual bool Get(int index);
    public sealed virtual int get_Length();
}
public abstract class Lucene.Net.Util.DoubleBarrelLRUCache : object {
}
public class Lucene.Net.Util.DoubleBarrelLRUCache`2 : DoubleBarrelLRUCache {
    private IDictionary`2<TKey, TValue> cache1;
    private IDictionary`2<TKey, TValue> cache2;
    private AtomicInt32 countdown;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) swapped;
    private int maxSize;
    public DoubleBarrelLRUCache`2(int maxCount);
    public TValue Get(TKey key);
    public void Put(TKey key, TValue value);
}
internal static class Lucene.Net.Util.Events : object {
}
[ExtensionAttribute]
public static class Lucene.Net.Util.ExceptionExtensions : object {
    public static string SUPPRESSED_EXCEPTIONS_KEY;
    private static ExceptionExtensions();
    [ExtensionAttribute]
public static Exception[] GetSuppressed(Exception e);
    [ExtensionAttribute]
public static IList`1<Exception> GetSuppressedAsList(Exception e);
    [ExtensionAttribute]
public static void AddSuppressed(Exception e, Exception exception);
}
[AttributeUsageAttribute("256")]
public class Lucene.Net.Util.ExcludeFromRamUsageEstimationAttribute : Attribute {
}
public abstract class Lucene.Net.Util.ExcludeServiceAttribute : Attribute {
}
public class Lucene.Net.Util.FieldCacheSanityChecker : object {
    private bool estimateRam;
    public FieldCacheSanityChecker(bool estimateRam);
    public static Insanity[] CheckSanity(IFieldCache cache);
    public static Insanity[] CheckSanity(CacheEntry[] cacheEntries);
    public Insanity[] Check(CacheEntry[] cacheEntries);
    private static ICollection`1<Insanity> CheckValueMismatch(MapOfSets`2<int, CacheEntry> valIdToItems, MapOfSets`2<ReaderField, int> readerFieldToValIds, ISet`1<ReaderField> valMismatchKeys);
    private static ICollection`1<Insanity> CheckSubreaders(MapOfSets`2<int, CacheEntry> valIdToItems, MapOfSets`2<ReaderField, int> readerFieldToValIds);
    private static IList`1<object> GetAllDescendantReaderKeys(object seed);
}
public class Lucene.Net.Util.FilterEnumerator`1 : object {
    private IEnumerator`1<T> iter;
    private Predicate`1<T> predicateFunction;
    private T current;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public FilterEnumerator`1(IEnumerator`1<T> baseEnumerator, Predicate`1<T> predicateFunction);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
}
[ObsoleteAttribute("Use FilterEnumerator<T> instead. This class will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public abstract class Lucene.Net.Util.FilterIterator`1 : object {
    private IEnumerator`1<T> iter;
    private T next;
    private bool nextIsSet;
    private T current;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    protected FilterIterator`1(IEnumerator`1<T> baseIterator);
    protected abstract virtual bool PredicateFunction(T object);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private bool SetNext();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class Lucene.Net.Util.FixedBitSet : DocIdSet {
    internal Int64[] bits;
    internal int numBits;
    internal int numWords;
    public IBits Bits { get; }
    public int Length { get; }
    public bool IsCacheable { get; }
    public int Cardinality { get; }
    public FixedBitSet(int numBits);
    public FixedBitSet(Int64[] storedBits, int numBits);
    public static FixedBitSet EnsureCapacity(FixedBitSet bits, int numBits);
    public static int Bits2words(int numBits);
    public static long IntersectionCount(FixedBitSet a, FixedBitSet b);
    public static long UnionCount(FixedBitSet a, FixedBitSet b);
    public static long AndNotCount(FixedBitSet a, FixedBitSet b);
    public virtual DocIdSetIterator GetIterator();
    public virtual IBits get_Bits();
    public sealed virtual int get_Length();
    public virtual bool get_IsCacheable();
    [WritableArrayAttribute]
public Int64[] GetBits();
    public int get_Cardinality();
    public sealed virtual bool Get(int index);
    public void Set(int index);
    public bool GetAndSet(int index);
    public void Clear(int index);
    public bool GetAndClear(int index);
    public int NextSetBit(int index);
    public int PrevSetBit(int index);
    public void Or(DocIdSetIterator iter);
    public void Or(FixedBitSet other);
    private void Or(Int64[] otherArr, int otherNumWords);
    public void Xor(FixedBitSet other);
    public void Xor(DocIdSetIterator iter);
    public void And(DocIdSetIterator iter);
    public bool Intersects(FixedBitSet other);
    public void And(FixedBitSet other);
    private void And(Int64[] otherArr, int otherNumWords);
    public void AndNot(DocIdSetIterator iter);
    public void AndNot(FixedBitSet other);
    private void AndNot(Int64[] otherArr, int otherNumWords);
    public void Flip(int startIndex, int endIndex);
    public void Set(int startIndex, int endIndex);
    public void Clear(int startIndex, int endIndex);
    public FixedBitSet Clone();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class Lucene.Net.Util.FixedBitSetExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use Cardinality property instead. This extension method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public static int Cardinality(FixedBitSet set);
}
public abstract class Lucene.Net.Util.Fst.Builder : object {
}
public class Lucene.Net.Util.Fst.Builder`1 : Builder {
    private NodeHash`1<T> dedupHash;
    private FST`1<T> fst;
    private T NO_OUTPUT;
    private int minSuffixCount1;
    private int minSuffixCount2;
    private bool doShareNonSingletonNodes;
    private int shareMaxTailLength;
    private Int32sRef lastInput;
    private bool doPackFST;
    private float acceptableOverheadRatio;
    private UnCompiledNode`1[] frontier;
    private FreezeTail`1<T> freezeTail;
    internal FST`1<T> Fst { get; }
    internal T NoOutput { get; }
    public long TotStateCount { get; }
    public long TermCount { get; }
    public long MappedStateCount { get; }
    public Builder`1(INPUT_TYPE inputType, Outputs`1<T> outputs);
    public Builder`1(INPUT_TYPE inputType, int minSuffixCount1, int minSuffixCount2, bool doShareSuffix, bool doShareNonSingletonNodes, int shareMaxTailLength, Outputs`1<T> outputs, FreezeTail`1<T> freezeTail, bool doPackFST, float acceptableOverheadRatio, bool allowArrayArcs, int bytesPageBits);
    internal FST`1<T> get_Fst();
    internal T get_NoOutput();
    public virtual long get_TotStateCount();
    public virtual long get_TermCount();
    public virtual long get_MappedStateCount();
    private CompiledNode CompileNode(UnCompiledNode`1<T> nodeIn, int tailLength);
    private void DoFreezeTail(int prefixLenPlus1);
    public virtual void Add(Int32sRef input, T output);
    internal bool ValidOutput(T output);
    public virtual FST`1<T> Finish();
    private void CompileAllTargets(UnCompiledNode`1<T> node, int tailLength);
    public virtual long GetFstSizeInBytes();
}
public class Lucene.Net.Util.Fst.ByteSequenceOutputs : Outputs`1<BytesRef> {
    private static BytesRef NO_OUTPUT;
    private static ByteSequenceOutputs singleton;
    public static ByteSequenceOutputs Singleton { get; }
    public BytesRef NoOutput { get; }
    private static ByteSequenceOutputs();
    public static ByteSequenceOutputs get_Singleton();
    public virtual BytesRef Common(BytesRef output1, BytesRef output2);
    public virtual BytesRef Subtract(BytesRef output, BytesRef inc);
    public virtual BytesRef Add(BytesRef prefix, BytesRef output);
    public virtual void Write(BytesRef prefix, DataOutput out);
    public virtual BytesRef Read(DataInput in);
    public virtual BytesRef get_NoOutput();
    public virtual string OutputToString(BytesRef output);
}
public class Lucene.Net.Util.Fst.BytesRefFSTEnum : object {
}
public class Lucene.Net.Util.Fst.BytesRefFSTEnum`1 : FSTEnum`1<T> {
    private BytesRef current;
    private InputOutput`1<T> result;
    private BytesRef target;
    public InputOutput`1<T> Current { get; }
    protected int TargetLabel { get; }
    protected int CurrentLabel { get; protected set; }
    public BytesRefFSTEnum`1(FST`1<T> fst);
    public InputOutput`1<T> get_Current();
    public bool MoveNext();
    [ObsoleteAttribute("Use MoveNext() and Current instead. This method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public InputOutput`1<T> Next();
    public InputOutput`1<T> SeekCeil(BytesRef target);
    public InputOutput`1<T> SeekFloor(BytesRef target);
    public InputOutput`1<T> SeekExact(BytesRef target);
    protected virtual int get_TargetLabel();
    protected virtual int get_CurrentLabel();
    protected virtual void set_CurrentLabel(int value);
    protected virtual void Grow();
    private InputOutput`1<T> SetResult();
}
internal class Lucene.Net.Util.Fst.BytesStore : DataOutput {
    private List`1<Byte[]> blocks;
    private int blockSize;
    private int blockBits;
    private int blockMask;
    private Byte[] current;
    private int nextWrite;
    internal int BlockBits { get; }
    public long Position { get; }
    public BytesStore(int blockBits);
    public BytesStore(DataInput in, long numBytes, int maxBlockSize);
    public virtual void WriteByte(int dest, byte b);
    public virtual void WriteByte(byte b);
    public virtual void WriteBytes(Byte[] b, int offset, int len);
    internal virtual int get_BlockBits();
    internal virtual void WriteBytes(long dest, Byte[] b, int offset, int len);
    public virtual void CopyBytes(long src, long dest, int len);
    public virtual void WriteInt32(long pos, int value);
    public virtual void Reverse(long srcPos, long destPos);
    public virtual void SkipBytes(int len);
    public virtual long get_Position();
    public virtual void Truncate(long newLen);
    public virtual void Finish();
    public virtual void WriteTo(DataOutput out);
    public virtual BytesReader GetForwardReader();
    public virtual BytesReader GetReverseReader();
    internal virtual BytesReader GetReverseReader(bool allowSingle);
}
public class Lucene.Net.Util.Fst.CharSequenceOutputs : Outputs`1<CharsRef> {
    private static CharsRef NO_OUTPUT;
    private static CharSequenceOutputs singleton;
    public static CharSequenceOutputs Singleton { get; }
    public CharsRef NoOutput { get; }
    private static CharSequenceOutputs();
    public static CharSequenceOutputs get_Singleton();
    public virtual CharsRef Common(CharsRef output1, CharsRef output2);
    public virtual CharsRef Subtract(CharsRef output, CharsRef inc);
    public virtual CharsRef Add(CharsRef prefix, CharsRef output);
    public virtual void Write(CharsRef prefix, DataOutput out);
    public virtual CharsRef Read(DataInput in);
    public virtual CharsRef get_NoOutput();
    public virtual string OutputToString(CharsRef output);
}
internal class Lucene.Net.Util.Fst.ForwardBytesReader : BytesReader {
    private Byte[] bytes;
    private int pos;
    public long Position { get; public set; }
    public bool IsReversed { get; }
    public ForwardBytesReader(Byte[] bytes);
    public virtual byte ReadByte();
    public virtual void ReadBytes(Byte[] b, int offset, int len);
    public virtual void SkipBytes(int count);
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_IsReversed();
}
public class Lucene.Net.Util.Fst.FST : object {
    public static int DEFAULT_MAX_BLOCK_BITS;
    internal static int BIT_FINAL_ARC;
    internal static int BIT_LAST_ARC;
    internal static int BIT_TARGET_NEXT;
    internal static int BIT_STOP_NODE;
    internal static int BIT_ARC_HAS_OUTPUT;
    internal static int BIT_ARC_HAS_FINAL_OUTPUT;
    internal static int BIT_TARGET_DELTA;
    internal static sbyte ARCS_AS_FIXED_ARRAY;
    public static int FIXED_ARRAY_SHALLOW_DISTANCE;
    public static int FIXED_ARRAY_NUM_ARCS_SHALLOW;
    public static int FIXED_ARRAY_NUM_ARCS_DEEP;
    internal static string FILE_FORMAT_NAME;
    internal static int VERSION_START;
    internal static int VERSION_INT32_NUM_BYTES_PER_ARC;
    internal static int VERSION_INT16_BYTE2_LABELS;
    internal static int VERSION_PACKED;
    internal static int VERSION_VINT32_TARGET;
    internal static int VERSION_CURRENT;
    internal static long FINAL_END_NODE;
    internal static long NON_FINAL_END_NODE;
    public static int END_LABEL;
    private static FST();
    public static bool TargetHasArcs(Arc`1<T> arc);
    public static FST`1<T> Read(FileInfo file, Outputs`1<T> outputs);
}
public class Lucene.Net.Util.Fst.FST`1 : object {
    private INPUT_TYPE inputType;
    private Int32[] bytesPerArc;
    internal T emptyOutput;
    internal BytesStore bytes;
    private long startNode;
    [CompilerGeneratedAttribute]
private Outputs`1<T> <Outputs>k__BackingField;
    private long lastFrozenNode;
    private T NO_OUTPUT;
    internal long nodeCount;
    private long arcCount;
    private long arcWithOutputCount;
    private bool packed;
    private Reader nodeRefToAddress;
    private bool allowArrayArcs;
    private Arc`1[] cachedRootArcs;
    private Arc`1[] assertingCachedRootArcs;
    private GrowableWriter nodeAddress;
    private GrowableWriter inCounts;
    private int version;
    public Outputs`1<T> Outputs { get; private set; }
    public INPUT_TYPE InputType { get; }
    public T EmptyOutput { get; public set; }
    public long NodeCount { get; }
    public long ArcCount { get; }
    public long ArcWithOutputCount { get; }
    internal FST`1(INPUT_TYPE inputType, Outputs`1<T> outputs, bool willPackFST, float acceptableOverheadRatio, bool allowArrayArcs, int bytesPageBits);
    public FST`1(DataInput in, Outputs`1<T> outputs);
    public FST`1(DataInput in, Outputs`1<T> outputs, int maxBlockBits);
    private FST`1(INPUT_TYPE inputType, Outputs`1<T> outputs, int bytesPageBits);
    [CompilerGeneratedAttribute]
public Outputs`1<T> get_Outputs();
    [CompilerGeneratedAttribute]
private void set_Outputs(Outputs`1<T> value);
    internal static bool Flag(int flags, int bit);
    public INPUT_TYPE get_InputType();
    public long GetSizeInBytes();
    internal void Finish(long newStartNode);
    private long GetNodeAddress(long node);
    private void CacheRootArcs();
    public void ReadRootArcs(Arc`1[] arcs);
    private bool SetAssertingRootArcs(Arc`1[] arcs);
    private bool AssertRootArcs();
    public T get_EmptyOutput();
    public void set_EmptyOutput(T value);
    public void Save(DataOutput out);
    public void Save(FileInfo file);
    private void WriteLabel(DataOutput out, int v);
    internal int ReadLabel(DataInput in);
    public static bool TargetHasArcs(Arc`1<T> arc);
    internal long AddNode(UnCompiledNode`1<T> nodeIn);
    public Arc`1<T> GetFirstArc(Arc`1<T> arc);
    public Arc`1<T> ReadLastTargetArc(Arc`1<T> follow, Arc`1<T> arc, BytesReader in);
    private long ReadUnpackedNodeTarget(BytesReader in);
    public Arc`1<T> ReadFirstTargetArc(Arc`1<T> follow, Arc`1<T> arc, BytesReader in);
    public Arc`1<T> ReadFirstRealTargetArc(long node, Arc`1<T> arc, BytesReader in);
    internal bool IsExpandedTarget(Arc`1<T> follow, BytesReader in);
    public Arc`1<T> ReadNextArc(Arc`1<T> arc, BytesReader in);
    public int ReadNextArcLabel(Arc`1<T> arc, BytesReader in);
    public Arc`1<T> ReadNextRealArc(Arc`1<T> arc, BytesReader in);
    public Arc`1<T> FindTargetArc(int labelToMatch, Arc`1<T> follow, Arc`1<T> arc, BytesReader in);
    private void SeekToNextNode(BytesReader in);
    public long get_NodeCount();
    public long get_ArcCount();
    public long get_ArcWithOutputCount();
    private bool ShouldExpand(UnCompiledNode`1<T> node);
    public BytesReader GetBytesReader();
    internal FST`1<T> Pack(int minInCountDeref, int maxDerefNodes, float acceptableOverheadRatio);
}
public abstract class Lucene.Net.Util.Fst.FSTEnum`1 : object {
    protected FST`1<T> m_fst;
    protected Arc`1[] m_arcs;
    protected T[] m_output;
    protected T NO_OUTPUT;
    protected BytesReader m_fstReader;
    protected Arc`1<T> m_scratchArc;
    protected int m_upto;
    protected int m_targetLength;
    protected int TargetLabel { get; }
    protected int CurrentLabel { get; protected set; }
    protected FSTEnum`1(FST`1<T> fst);
    protected abstract virtual int get_TargetLabel();
    protected abstract virtual int get_CurrentLabel();
    protected abstract virtual void set_CurrentLabel(int value);
    protected abstract virtual void Grow();
    protected void RewindPrefix();
    protected virtual void DoNext();
    protected virtual void DoSeekCeil();
    protected virtual void DoSeekFloor();
    protected virtual bool DoSeekExact();
    private void Incr();
    private void PushFirst();
    private void PushLast();
    private Arc`1<T> GetArc(int idx);
}
public class Lucene.Net.Util.Fst.Int32SequenceOutputs : Outputs`1<Int32sRef> {
    private static Int32sRef NO_OUTPUT;
    private static Int32SequenceOutputs singleton;
    public static Int32SequenceOutputs Singleton { get; }
    public Int32sRef NoOutput { get; }
    private static Int32SequenceOutputs();
    public static Int32SequenceOutputs get_Singleton();
    public virtual Int32sRef Common(Int32sRef output1, Int32sRef output2);
    public virtual Int32sRef Subtract(Int32sRef output, Int32sRef inc);
    public virtual Int32sRef Add(Int32sRef prefix, Int32sRef output);
    public virtual void Write(Int32sRef prefix, DataOutput out);
    public virtual Int32sRef Read(DataInput in);
    public virtual Int32sRef get_NoOutput();
    public virtual string OutputToString(Int32sRef output);
}
public class Lucene.Net.Util.Fst.Int32sRefFSTEnum : object {
}
public class Lucene.Net.Util.Fst.Int32sRefFSTEnum`1 : FSTEnum`1<T> {
    private Int32sRef current;
    private InputOutput`1<T> result;
    private Int32sRef target;
    public InputOutput`1<T> Current { get; }
    protected int TargetLabel { get; }
    protected int CurrentLabel { get; protected set; }
    public Int32sRefFSTEnum`1(FST`1<T> fst);
    public InputOutput`1<T> get_Current();
    public bool MoveNext();
    [ObsoleteAttribute("Use MoveNext() and Current instead. This method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public InputOutput`1<T> Next();
    public InputOutput`1<T> SeekCeil(Int32sRef target);
    public InputOutput`1<T> SeekFloor(Int32sRef target);
    public InputOutput`1<T> SeekExact(Int32sRef target);
    protected virtual int get_TargetLabel();
    protected virtual int get_CurrentLabel();
    protected virtual void set_CurrentLabel(int value);
    protected virtual void Grow();
    private InputOutput`1<T> SetResult();
}
internal class Lucene.Net.Util.Fst.NodeHash`1 : object {
    private PagedGrowableWriter table;
    private long count;
    private long mask;
    private FST`1<T> fst;
    private Arc`1<T> scratchArc;
    private BytesReader input;
    private static bool tIsValueType;
    public NodeHash`1(FST`1<T> fst, BytesReader input);
    private static NodeHash`1();
    private bool NodesEqual(UnCompiledNode`1<T> node, long address);
    private static long Hash(UnCompiledNode`1<T> node);
    private long Hash(long node);
    public long Add(UnCompiledNode`1<T> nodeIn);
    private void AddNew(long address);
    private void Rehash();
}
public class Lucene.Net.Util.Fst.NoOutputs : Outputs`1<object> {
    internal static object NO_OUTPUT;
    private static NoOutputs singleton;
    public static NoOutputs Singleton { get; }
    public object NoOutput { get; }
    private static NoOutputs();
    public static NoOutputs get_Singleton();
    public virtual object Common(object output1, object output2);
    public virtual object Subtract(object output, object inc);
    public virtual object Add(object prefix, object output);
    public virtual object Merge(object first, object second);
    public virtual void Write(object prefix, DataOutput out);
    public virtual object Read(DataInput in);
    public virtual object get_NoOutput();
    public virtual string OutputToString(object output);
}
public abstract class Lucene.Net.Util.Fst.Outputs`1 : object {
    public T NoOutput { get; }
    public abstract virtual T Common(T output1, T output2);
    public abstract virtual T Subtract(T output, T inc);
    public abstract virtual T Add(T prefix, T output);
    public abstract virtual void Write(T output, DataOutput out);
    public virtual void WriteFinalOutput(T output, DataOutput out);
    public abstract virtual T Read(DataInput in);
    public virtual T ReadFinalOutput(DataInput in);
    public abstract virtual T get_NoOutput();
    public abstract virtual string OutputToString(T output);
    public virtual T Merge(T first, T second);
}
public class Lucene.Net.Util.Fst.PairOutputs`2 : Outputs`1<Pair<A, B>> {
    private Pair<A, B> NO_OUTPUT;
    private Outputs`1<A> outputs1;
    private Outputs`1<B> outputs2;
    public Pair<A, B> NoOutput { get; }
    public PairOutputs`2(Outputs`1<A> outputs1, Outputs`1<B> outputs2);
    public virtual Pair<A, B> NewPair(A a, B b);
    private bool Valid(Pair<A, B> pair);
    public virtual Pair<A, B> Common(Pair<A, B> pair1, Pair<A, B> pair2);
    public virtual Pair<A, B> Subtract(Pair<A, B> output, Pair<A, B> inc);
    public virtual Pair<A, B> Add(Pair<A, B> prefix, Pair<A, B> output);
    public virtual void Write(Pair<A, B> output, DataOutput writer);
    public virtual Pair<A, B> Read(DataInput in);
    public virtual Pair<A, B> get_NoOutput();
    public virtual string OutputToString(Pair<A, B> output);
    public virtual string ToString();
}
public class Lucene.Net.Util.Fst.PositiveInt32Outputs : Outputs`1<Int64> {
    private static Int64 NO_OUTPUT;
    private static PositiveInt32Outputs singleton;
    public static PositiveInt32Outputs Singleton { get; }
    public Int64 NoOutput { get; }
    private static PositiveInt32Outputs();
    public static PositiveInt32Outputs get_Singleton();
    public virtual Int64 Common(Int64 output1, Int64 output2);
    public virtual Int64 Subtract(Int64 output, Int64 inc);
    public virtual Int64 Add(Int64 prefix, Int64 output);
    public virtual void Write(Int64 output, DataOutput out);
    public virtual Int64 Read(DataInput in);
    private bool Valid(Int64 o);
    public virtual Int64 get_NoOutput();
    public virtual string OutputToString(Int64 output);
    public virtual string ToString();
}
internal class Lucene.Net.Util.Fst.ReverseBytesReader : BytesReader {
    private Byte[] bytes;
    private int pos;
    public long Position { get; public set; }
    public bool IsReversed { get; }
    public ReverseBytesReader(Byte[] bytes);
    public virtual byte ReadByte();
    public virtual void ReadBytes(Byte[] b, int offset, int len);
    public virtual void SkipBytes(int count);
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_IsReversed();
}
public static class Lucene.Net.Util.Fst.Util : object {
    public static T Get(FST`1<T> fst, Int32sRef input);
    public static T Get(FST`1<T> fst, BytesRef input);
    public static Int32sRef GetByOutput(FST`1<Int64> fst, long targetOutput);
    public static Int32sRef GetByOutput(FST`1<Int64> fst, long targetOutput, BytesReader in, Arc`1<Int64> arc, Arc`1<Int64> scratchArc, Int32sRef result);
    public static TopResults`1<T> ShortestPaths(FST`1<T> fst, Arc`1<T> fromNode, T startOutput, IComparer`1<T> comparer, int topN, bool allowEmptyString);
    public static void ToDot(FST`1<T> fst, TextWriter out, bool sameRank, bool labelStates);
    private static void EmitDotState(TextWriter out, string name, string shape, string color, string label);
    private static string PrintableLabel(int label);
    public static Int32sRef ToUTF16(string s, Int32sRef scratch);
    public static Int32sRef ToUTF32(string s, Int32sRef scratch);
    public static Int32sRef ToUTF32(Char[] s, int offset, int length, Int32sRef scratch);
    public static Int32sRef ToInt32sRef(BytesRef input, Int32sRef scratch);
    public static BytesRef ToBytesRef(Int32sRef input, BytesRef scratch);
    public static Arc`1<T> ReadCeilArc(int label, FST`1<T> fst, Arc`1<T> follow, Arc`1<T> arc, BytesReader in);
}
public class Lucene.Net.Util.GrowableByteArrayDataOutput : DataOutput {
    private Byte[] bytes;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [WritableArrayAttribute]
public Byte[] Bytes { get; public set; }
    public int Length { get; public set; }
    public GrowableByteArrayDataOutput(int cp);
    public Byte[] get_Bytes();
    public void set_Bytes(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(int value);
    public virtual void WriteByte(byte b);
    public virtual void WriteBytes(Byte[] b, int off, int len);
}
public interface Lucene.Net.Util.IAccountable {
    public abstract virtual long RamBytesUsed();
}
public interface Lucene.Net.Util.IAttribute {
    public abstract virtual void CopyTo(IAttribute target);
}
public interface Lucene.Net.Util.IAttributeReflector {
    public abstract virtual void Reflect(string key, object value);
    public abstract virtual void Reflect(Type type, string key, object value);
}
public interface Lucene.Net.Util.IBits {
    public int Length { get; }
    public abstract virtual bool Get(int index);
    public abstract virtual int get_Length();
}
public interface Lucene.Net.Util.IBytesRefEnumerator {
    public BytesRef Current { get; }
    public IComparer`1<BytesRef> Comparer { get; }
    public abstract virtual bool MoveNext();
    public abstract virtual BytesRef get_Current();
    public abstract virtual IComparer`1<BytesRef> get_Comparer();
}
[ObsoleteAttribute("Use IBytesRefEnumerator instead. This interface will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public interface Lucene.Net.Util.IBytesRefIterator {
    public IComparer`1<BytesRef> Comparer { get; }
    public abstract virtual BytesRef Next();
    public abstract virtual IComparer`1<BytesRef> get_Comparer();
}
public interface Lucene.Net.Util.IMutableBits {
    public abstract virtual void Clear(int index);
}
[ObsoleteAttribute("Implement Analysis.TokenAttributes.ITermToBytesRefAttribute and store bytes directly instead. this class will be removed in Lucene 5.0")]
public static class Lucene.Net.Util.IndexableBinaryStringTools : object {
    private static CodingCase[] CODING_CASES;
    private static IndexableBinaryStringTools();
    public static int GetEncodedLength(Byte[] inputArray, int inputOffset, int inputLength);
    [CLSCompliantAttribute("False")]
public static int GetEncodedLength(SByte[] inputArray, int inputOffset, int inputLength);
    public static int GetDecodedLength(Char[] encoded, int offset, int length);
    public static void Encode(Byte[] inputArray, int inputOffset, int inputLength, Char[] outputArray, int outputOffset, int outputLength);
    [CLSCompliantAttribute("False")]
public static void Encode(SByte[] inputArray, int inputOffset, int inputLength, Char[] outputArray, int outputOffset, int outputLength);
    public static void Decode(Char[] inputArray, int inputOffset, int inputLength, Byte[] outputArray, int outputOffset, int outputLength);
    [CLSCompliantAttribute("False")]
public static void Decode(Char[] inputArray, int inputOffset, int inputLength, SByte[] outputArray, int outputOffset, int outputLength);
}
public abstract class Lucene.Net.Util.InfoStream : object {
    public static InfoStream NO_OUTPUT;
    private static InfoStream defaultInfoStream;
    public static InfoStream Default { get; public set; }
    private static InfoStream();
    public abstract virtual void Message(string component, string message);
    public abstract virtual bool IsEnabled(string component);
    public static InfoStream get_Default();
    public static void set_Default(InfoStream value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual object Clone();
}
public abstract class Lucene.Net.Util.InPlaceMergeSorter : Sorter {
    public sealed virtual void Sort(int from, int to);
    internal virtual void MergeSort(int from, int to);
}
public class Lucene.Net.Util.Int32BlockPool : object {
    public static int INT32_BLOCK_SHIFT;
    public static int INT32_BLOCK_SIZE;
    public static int INT32_BLOCK_MASK;
    private Int32[][] buffers;
    private int bufferUpto;
    [CompilerGeneratedAttribute]
private int <Int32Upto>k__BackingField;
    private Int32[] buffer;
    [CompilerGeneratedAttribute]
private int <Int32Offset>k__BackingField;
    private Allocator allocator;
    private static Int32[] NEXT_LEVEL_ARRAY;
    private static Int32[] LEVEL_SIZE_ARRAY;
    private static int FIRST_LEVEL_SIZE;
    [WritableArrayAttribute]
public Int32[][] Buffers { get; public set; }
    public int Int32Upto { get; public set; }
    [WritableArrayAttribute]
public Int32[] Buffer { get; public set; }
    public int Int32Offset { get; public set; }
    public Int32BlockPool(Allocator allocator);
    private static Int32BlockPool();
    public Int32[][] get_Buffers();
    public void set_Buffers(Int32[][] value);
    [CompilerGeneratedAttribute]
public int get_Int32Upto();
    [CompilerGeneratedAttribute]
public void set_Int32Upto(int value);
    public Int32[] get_Buffer();
    public void set_Buffer(Int32[] value);
    [CompilerGeneratedAttribute]
public int get_Int32Offset();
    [CompilerGeneratedAttribute]
public void set_Int32Offset(int value);
    public void Reset();
    public void Reset(bool zeroFillBuffers, bool reuseFirst);
    public void NextBuffer();
    private int NewSlice(int size);
    private static bool AssertSliceBuffer(Int32[] buffer);
    private int AllocSlice(Int32[] slice, int sliceOffset);
}
public class Lucene.Net.Util.Int32sRef : object {
    public static Int32[] EMPTY_INT32S;
    private Int32[] ints;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [WritableArrayAttribute]
public Int32[] Int32s { get; public set; }
    public int Offset { get; public set; }
    public int Length { get; public set; }
    public Int32sRef(int capacity);
    public Int32sRef(Int32[] ints, int offset, int length);
    private static Int32sRef();
    public Int32[] get_Int32s();
    public void set_Int32s(Int32[] value);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(int value);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(int value);
    public object Clone();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Int32sEquals(Int32sRef other);
    public sealed virtual int CompareTo(Int32sRef other);
    public void CopyInt32s(Int32sRef other);
    public void Grow(int newLength);
    public virtual string ToString();
    public static Int32sRef DeepCopyOf(Int32sRef other);
    public bool IsValid();
}
public class Lucene.Net.Util.Int64BitSet : object {
    internal Int64[] bits;
    private long numBits;
    internal int numWords;
    public long Length { get; }
    public long Cardinality { get; }
    public Int64BitSet(long numBits);
    public Int64BitSet(Int64[] storedBits, long numBits);
    public static Int64BitSet EnsureCapacity(Int64BitSet bits, long numBits);
    public static int Bits2words(long numBits);
    public long get_Length();
    [WritableArrayAttribute]
public Int64[] GetBits();
    public long get_Cardinality();
    public bool Get(long index);
    public void Set(long index);
    public bool GetAndSet(long index);
    public void Clear(long index);
    public bool GetAndClear(long index);
    public long NextSetBit(long index);
    public long PrevSetBit(long index);
    public void Or(Int64BitSet other);
    public void Xor(Int64BitSet other);
    public bool Intersects(Int64BitSet other);
    public void And(Int64BitSet other);
    public void AndNot(Int64BitSet other);
    public void Flip(long startIndex, long endIndex);
    public void Set(long startIndex, long endIndex);
    public void Clear(long startIndex, long endIndex);
    public Int64BitSet Clone();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class Lucene.Net.Util.Int64BitSetExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use Cardinality property instead. This extension method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public static long Cardinality(Int64BitSet set);
}
public class Lucene.Net.Util.Int64sRef : object {
    public static Int64[] EMPTY_INT64S;
    private Int64[] longs;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [WritableArrayAttribute]
public Int64[] Int64s { get; public set; }
    public int Offset { get; public set; }
    public int Length { get; public set; }
    public Int64sRef(int capacity);
    public Int64sRef(Int64[] longs, int offset, int length);
    private static Int64sRef();
    public Int64[] get_Int64s();
    public void set_Int64s(Int64[] value);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(int value);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(int value);
    public object Clone();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Int64sEquals(Int64sRef other);
    public sealed virtual int CompareTo(Int64sRef other);
    public void CopyInt64s(Int64sRef other);
    public void Grow(int newLength);
    public virtual string ToString();
    public static Int64sRef DeepCopyOf(Int64sRef other);
    public bool IsValid();
}
public abstract class Lucene.Net.Util.Int64Values : NumericDocValues {
    public abstract virtual long Get(long index);
    public virtual long Get(int idx);
}
public abstract class Lucene.Net.Util.IntroSorter : Sorter {
    internal static int CeilLog2(int n);
    public sealed virtual void Sort(int from, int to);
    internal virtual void Quicksort(int from, int to, int maxDepth);
    protected abstract virtual void SetPivot(int i);
    protected abstract virtual int ComparePivot(int j);
}
[ExceptionToClassNameConventionAttribute]
public static class Lucene.Net.Util.IOUtils : object {
    [ObsoleteAttribute("Use Encoding.UTF8 instead.")]
public static Encoding CHARSET_UTF_8;
    public static string UTF_8;
    private static IOUtils();
    [ObsoleteAttribute("Use DisposeWhileHandlingException(Exception, params IDisposable[]) instead.")]
public static void CloseWhileHandlingException(Exception priorException, IDisposable[] objects);
    [ObsoleteAttribute("Use DisposeWhileHandlingException(Exception, IEnumerable<IDisposable>) instead.")]
public static void CloseWhileHandlingException(Exception priorException, IEnumerable`1<IDisposable> objects);
    [ObsoleteAttribute("Use Dispose(params IDisposable[]) instead.")]
public static void Close(IDisposable[] objects);
    [ObsoleteAttribute("Use Dispose(IEnumerable<IDisposable>) instead.")]
public static void Close(IEnumerable`1<IDisposable> objects);
    [ObsoleteAttribute("Use DisposeWhileHandlingException(params IDisposable[]) instead.")]
public static void CloseWhileHandlingException(IDisposable[] objects);
    [ObsoleteAttribute("Use DisposeWhileHandlingException(IEnumerable<IDisposable>) instead.")]
public static void CloseWhileHandlingException(IEnumerable`1<IDisposable> objects);
    public static void DisposeWhileHandlingException(Exception priorException, IDisposable[] objects);
    public static void DisposeWhileHandlingException(Exception priorException, IEnumerable`1<IDisposable> objects);
    public static void Dispose(IDisposable[] objects);
    public static void Dispose(IEnumerable`1<IDisposable> objects);
    public static void DisposeWhileHandlingException(IDisposable[] objects);
    public static void DisposeWhileHandlingException(IEnumerable`1<IDisposable> objects);
    private static void AddSuppressed(Exception exception, Exception suppressed);
    public static TextReader GetDecodingReader(Stream stream, Encoding charSet);
    public static TextReader GetDecodingReader(FileInfo file, Encoding charSet);
    public static TextReader GetDecodingReader(Type clazz, string resource, Encoding charSet);
    public static void DeleteFilesIgnoringExceptions(Directory dir, String[] files);
    public static void Copy(FileInfo source, FileInfo target);
    public static void ReThrow(Exception th);
    public static void ReThrowUnchecked(Exception th);
}
internal interface Lucene.Net.Util.IProperties {
    public abstract virtual string GetProperty(string key);
    public abstract virtual string GetProperty(string key, string defaultValue);
    public abstract virtual bool GetPropertyAsBoolean(string key);
    public abstract virtual bool GetPropertyAsBoolean(string key, bool defaultValue);
    public abstract virtual int GetPropertyAsInt32(string key);
    public abstract virtual int GetPropertyAsInt32(string key, int defaultValue);
}
[NullableContextAttribute("2")]
public interface Lucene.Net.Util.IResourceProvider {
    public abstract virtual string GetString(string name, CultureInfo culture);
    public abstract virtual object GetObject(string name, CultureInfo culture);
    public abstract virtual Stream GetStream(string name, CultureInfo culture);
}
public interface Lucene.Net.Util.IServiceListable {
    public ICollection`1<string> AvailableServices { get; }
    public abstract virtual ICollection`1<string> get_AvailableServices();
}
[ExtensionAttribute]
public static class Lucene.Net.Util.ListExtensions : object {
    [ExtensionAttribute]
public static void AddRange(IList`1<T> list, IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static void Sort(IList`1<T> list);
    [ExtensionAttribute]
public static void Sort(IList`1<T> list, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static void Sort(IList`1<T> list, Comparison`1<T> comparison);
    [ExtensionAttribute]
public static void TimSort(IList`1<T> list);
    [ExtensionAttribute]
public static void TimSort(IList`1<T> list, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static void IntroSort(IList`1<T> list);
    [ExtensionAttribute]
public static void IntroSort(IList`1<T> list, IComparer`1<T> comparer);
}
internal class Lucene.Net.Util.LuceneSystemException : SystemException {
    public LuceneSystemException(string message);
    public LuceneSystemException(string message, Exception innerException);
    public LuceneSystemException(Exception cause);
    protected LuceneSystemException(SerializationInfo info, StreamingContext context);
}
public enum Lucene.Net.Util.LuceneVersion : Enum {
    public int value__;
    [ObsoleteAttribute("(4.0) Use latest")]
public static LuceneVersion LUCENE_30;
    [ObsoleteAttribute("(4.0) Use latest")]
public static LuceneVersion LUCENE_31;
    [ObsoleteAttribute("(4.0) Use latest")]
public static LuceneVersion LUCENE_32;
    [ObsoleteAttribute("(4.0) Use latest")]
public static LuceneVersion LUCENE_33;
    [ObsoleteAttribute("(4.0) Use latest")]
public static LuceneVersion LUCENE_34;
    [ObsoleteAttribute("(4.0) Use latest")]
public static LuceneVersion LUCENE_35;
    [ObsoleteAttribute("(4.0) Use latest")]
public static LuceneVersion LUCENE_36;
    [ObsoleteAttribute("(4.1) Use latest")]
public static LuceneVersion LUCENE_40;
    [ObsoleteAttribute("(4.2) Use latest")]
public static LuceneVersion LUCENE_41;
    [ObsoleteAttribute("(4.3) Use latest")]
public static LuceneVersion LUCENE_42;
    [ObsoleteAttribute("(4.4) Use latest")]
public static LuceneVersion LUCENE_43;
    [ObsoleteAttribute("(4.5) Use latest")]
public static LuceneVersion LUCENE_44;
    [ObsoleteAttribute("(4.6) Use latest")]
public static LuceneVersion LUCENE_45;
    [ObsoleteAttribute("(4.7) Use latest")]
public static LuceneVersion LUCENE_46;
    [ObsoleteAttribute("(4.8) Use latest")]
public static LuceneVersion LUCENE_47;
    public static LuceneVersion LUCENE_48;
    [ObsoleteAttribute("Use an actual version instead.")]
public static LuceneVersion LUCENE_CURRENT;
}
[ExtensionAttribute]
public static class Lucene.Net.Util.LuceneVersionExtensions : object {
    private static Regex NUMERIC_VERSION;
    private static LuceneVersionExtensions();
    [ExtensionAttribute]
public static bool OnOrAfter(LuceneVersion instance, LuceneVersion other);
    public static LuceneVersion ParseLeniently(string version);
}
public class Lucene.Net.Util.MapOfSets`2 : object {
    private IDictionary`2<TKey, ISet`1<TValue>> theMap;
    public IDictionary`2<TKey, ISet`1<TValue>> Map { get; }
    public MapOfSets`2(IDictionary`2<TKey, ISet`1<TValue>> m);
    public virtual IDictionary`2<TKey, ISet`1<TValue>> get_Map();
    public virtual int Put(TKey key, TValue val);
    public virtual int PutAll(TKey key, IEnumerable`1<TValue> vals);
}
public static class Lucene.Net.Util.MathUtil : object {
    public static int Log(long x, int base);
    public static double Log(double base, double x);
    public static long Gcd(long a, long b);
    public static double Asinh(double a);
    public static double Acosh(double a);
    public static double Atanh(double a);
}
public class Lucene.Net.Util.MergedEnumerator`1 : object {
    private TermMergeQueue`1<T, T> queue;
    private SubEnumerator`1[] top;
    private bool removeDuplicates;
    private int numTop;
    private T current;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public MergedEnumerator`1(IEnumerator`1[] enumerators);
    public MergedEnumerator`1(bool removeDuplicates, IEnumerator`1[] enumerators);
    public MergedEnumerator`1(IList`1<IEnumerator`1<T>> enumerators);
    public MergedEnumerator`1(bool removeDuplicates, IList`1<IEnumerator`1<T>> enumerators);
    public sealed virtual bool MoveNext();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
    private void PullTop();
    private void PushTop();
}
[ObsoleteAttribute("Use MergedEnumerator instead. This class will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public class Lucene.Net.Util.MergedIterator`1 : object {
    private TermMergeQueue`1<T, T> queue;
    private SubIterator`1[] top;
    private bool removeDuplicates;
    private int numTop;
    private T current;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public MergedIterator`1(IEnumerator`1[] iterators);
    public MergedIterator`1(bool removeDuplicates, IEnumerator`1[] iterators);
    public sealed virtual bool MoveNext();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
    private void PullTop();
    private void PushTop();
}
public abstract class Lucene.Net.Util.Mutable.MutableValue : object {
    [CompilerGeneratedAttribute]
private bool <Exists>k__BackingField;
    public bool Exists { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Exists();
    [CompilerGeneratedAttribute]
public void set_Exists(bool value);
    public abstract virtual void Copy(MutableValue source);
    public abstract virtual MutableValue Duplicate();
    public abstract virtual bool EqualsSameType(object other);
    public abstract virtual int CompareSameType(object other);
    public abstract virtual object ToObject();
    public virtual int CompareTo(MutableValue other);
    public virtual int CompareTo(object other);
    public virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public virtual string ToString();
}
public class Lucene.Net.Util.Mutable.MutableValueBool : MutableValue {
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(bool value);
    public virtual object ToObject();
    public virtual void Copy(MutableValue source);
    public virtual MutableValue Duplicate();
    public virtual bool EqualsSameType(object other);
    public virtual int CompareSameType(object other);
    public virtual int GetHashCode();
}
public class Lucene.Net.Util.Mutable.MutableValueDate : MutableValueInt64 {
    public virtual object ToObject();
    public virtual MutableValue Duplicate();
}
public class Lucene.Net.Util.Mutable.MutableValueDouble : MutableValue {
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    public double Value { get; public set; }
    [CompilerGeneratedAttribute]
public double get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(double value);
    public virtual object ToObject();
    public virtual void Copy(MutableValue source);
    public virtual MutableValue Duplicate();
    public virtual bool EqualsSameType(object other);
    public virtual int CompareSameType(object other);
    public virtual int GetHashCode();
}
public class Lucene.Net.Util.Mutable.MutableValueInt32 : MutableValue {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(int value);
    public virtual object ToObject();
    public virtual void Copy(MutableValue source);
    public virtual MutableValue Duplicate();
    public virtual bool EqualsSameType(object other);
    public virtual int CompareSameType(object other);
    public virtual int GetHashCode();
}
public class Lucene.Net.Util.Mutable.MutableValueInt64 : MutableValue {
    [CompilerGeneratedAttribute]
private long <Value>k__BackingField;
    public long Value { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(long value);
    public virtual object ToObject();
    public virtual void Copy(MutableValue source);
    public virtual MutableValue Duplicate();
    public virtual bool EqualsSameType(object other);
    public virtual int CompareSameType(object other);
    public virtual int GetHashCode();
}
public class Lucene.Net.Util.Mutable.MutableValueSingle : MutableValue {
    [CompilerGeneratedAttribute]
private float <Value>k__BackingField;
    public float Value { get; public set; }
    [CompilerGeneratedAttribute]
public float get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(float value);
    public virtual object ToObject();
    public virtual void Copy(MutableValue source);
    public virtual MutableValue Duplicate();
    public virtual bool EqualsSameType(object other);
    public virtual int CompareSameType(object other);
    public virtual int GetHashCode();
}
public class Lucene.Net.Util.Mutable.MutableValueStr : MutableValue {
    [CompilerGeneratedAttribute]
private BytesRef <Value>k__BackingField;
    public BytesRef Value { get; public set; }
    [CompilerGeneratedAttribute]
public BytesRef get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(BytesRef value);
    public virtual object ToObject();
    public virtual void Copy(MutableValue source);
    public virtual MutableValue Duplicate();
    public virtual bool EqualsSameType(object other);
    public virtual int CompareSameType(object other);
    public virtual int GetHashCode();
}
public abstract class Lucene.Net.Util.NamedServiceFactory`1 : object {
    private static Assembly codecsAssembly;
    private bool initialized;
    protected object m_initializationLock;
    private object initializationTarget;
    protected Assembly CodecsAssembly { get; }
    protected bool IsFullyTrusted { get; }
    protected void EnsureInitialized();
    protected abstract virtual void Initialize();
    protected Assembly get_CodecsAssembly();
    protected virtual bool IsServiceType(Type type);
    public static string GetServiceName(Type type);
    protected static string GetCanonicalName(Type type);
    private static void CheckServiceName(string name);
    private static bool IsLetterOrDigit(char c);
    protected bool get_IsFullyTrusted();
    [CompilerGeneratedAttribute]
private object <EnsureInitialized>b__4_0();
}
public abstract class Lucene.Net.Util.NumberFormat : object {
    private IFormatProvider formatProvider;
    public IFormatProvider FormatProvider { get; }
    public NumberFormat(IFormatProvider formatProvider);
    public IFormatProvider get_FormatProvider();
    public virtual string Format(object number);
    public virtual string Format(double number);
    public virtual string Format(long number);
    protected virtual string GetNumberFormat();
    public abstract virtual Number Parse(string source);
    public virtual string ToString();
}
public static class Lucene.Net.Util.NumericUtils : object {
    public static int PRECISION_STEP_DEFAULT;
    public static char SHIFT_START_INT64;
    public static int BUF_SIZE_INT64;
    public static byte SHIFT_START_INT32;
    public static int BUF_SIZE_INT32;
    public static void Int64ToPrefixCoded(long val, int shift, BytesRef bytes);
    public static void Int32ToPrefixCoded(int val, int shift, BytesRef bytes);
    public static void Int64ToPrefixCodedBytes(long val, int shift, BytesRef bytes);
    public static void Int32ToPrefixCodedBytes(int val, int shift, BytesRef bytes);
    public static int GetPrefixCodedInt64Shift(BytesRef val);
    public static int GetPrefixCodedInt32Shift(BytesRef val);
    public static long PrefixCodedToInt64(BytesRef val);
    public static int PrefixCodedToInt32(BytesRef val);
    public static long DoubleToSortableInt64(double val);
    public static double SortableInt64ToDouble(long val);
    public static int SingleToSortableInt32(float val);
    public static float SortableInt32ToSingle(int val);
    public static void SplitInt64Range(Int64RangeBuilder builder, int precisionStep, long minBound, long maxBound);
    public static void SplitInt32Range(Int32RangeBuilder builder, int precisionStep, int minBound, int maxBound);
    private static void SplitRange(object builder, int valSize, int precisionStep, long minBound, long maxBound);
    private static void AddRange(object builder, int valSize, long minBound, long maxBound, int shift);
    public static TermsEnum FilterPrefixCodedInt64s(TermsEnum termsEnum);
    public static TermsEnum FilterPrefixCodedInt32s(TermsEnum termsEnum);
}
public class Lucene.Net.Util.OfflineSorter : object {
    public static long MB;
    public static long GB;
    public static long MIN_BUFFER_SIZE_MB;
    public static long ABSOLUTE_MIN_SORT_BUFFER_SIZE;
    private static string MIN_BUFFER_SIZE_MSG;
    public static int MAX_TEMPFILES;
    private BufferSize ramBufferSize;
    private Counter bufferBytesUsed;
    private BytesRefArray buffer;
    private SortInfo sortInfo;
    private int maxTempFiles;
    private IComparer`1<BytesRef> comparer;
    public static IComparer`1<BytesRef> DEFAULT_COMPARER;
    public IComparer`1<BytesRef> Comparer { get; }
    public OfflineSorter(IComparer`1<BytesRef> comparer);
    public OfflineSorter(IComparer`1<BytesRef> comparer, BufferSize ramBufferSize, DirectoryInfo tempDirectory, int maxTempfiles);
    private static OfflineSorter();
    public SortInfo Sort(FileInfo input, FileInfo output);
    public static DirectoryInfo DefaultTempDir();
    private static void Copy(FileInfo file, FileInfo output);
    private FileInfo SortPartition();
    internal void MergePartitions(IList`1<FileInfo> merges, FileInfo outputFile);
    internal int ReadPartition(ByteSequencesReader reader);
    public IComparer`1<BytesRef> get_Comparer();
}
public class Lucene.Net.Util.OpenBitSet : DocIdSet {
    protected internal Int64[] m_bits;
    protected internal int m_wlen;
    private long numBits;
    public IBits Bits { get; }
    public bool IsCacheable { get; }
    public long Capacity { get; }
    public int Length { get; }
    private int Lucene.Net.Util.IBits.Length { get; }
    public bool IsEmpty { get; }
    public int NumWords { get; }
    public long Cardinality { get; }
    public OpenBitSet(long numBits);
    public OpenBitSet(Int64[] bits, int numWords);
    public virtual DocIdSetIterator GetIterator();
    public virtual IBits get_Bits();
    public virtual bool get_IsCacheable();
    public virtual long get_Capacity();
    public virtual int get_Length();
    private sealed virtual override int Lucene.Net.Util.IBits.get_Length();
    public virtual bool get_IsEmpty();
    [WritableArrayAttribute]
public virtual Int64[] GetBits();
    public virtual int get_NumWords();
    public virtual bool Get(int index);
    public virtual bool FastGet(int index);
    public virtual bool Get(long index);
    public virtual bool FastGet(long index);
    public virtual int GetBit(int index);
    public virtual void Set(long index);
    public virtual void FastSet(int index);
    public virtual void FastSet(long index);
    public virtual void Set(long startIndex, long endIndex);
    protected virtual int ExpandingWordNum(long index);
    public virtual void FastClear(int index);
    public virtual void FastClear(long index);
    public virtual void Clear(long index);
    public virtual void Clear(int startIndex, int endIndex);
    public virtual void Clear(long startIndex, long endIndex);
    public virtual bool GetAndSet(int index);
    public virtual bool GetAndSet(long index);
    public virtual void FastFlip(int index);
    public virtual void FastFlip(long index);
    public virtual void Flip(long index);
    public virtual bool FlipAndGet(int index);
    public virtual bool FlipAndGet(long index);
    public virtual void Flip(long startIndex, long endIndex);
    public virtual long get_Cardinality();
    public static long IntersectionCount(OpenBitSet a, OpenBitSet b);
    public static long UnionCount(OpenBitSet a, OpenBitSet b);
    public static long AndNotCount(OpenBitSet a, OpenBitSet b);
    public static long XorCount(OpenBitSet a, OpenBitSet b);
    public virtual int NextSetBit(int index);
    public virtual long NextSetBit(long index);
    public virtual int PrevSetBit(int index);
    public virtual long PrevSetBit(long index);
    public object Clone();
    public virtual void Intersect(OpenBitSet other);
    public virtual void Union(OpenBitSet other);
    public virtual void Remove(OpenBitSet other);
    public virtual void Xor(OpenBitSet other);
    public virtual void And(OpenBitSet other);
    public virtual void Or(OpenBitSet other);
    public virtual void AndNot(OpenBitSet other);
    public virtual bool Intersects(OpenBitSet other);
    public virtual void EnsureCapacityWords(int numWords);
    public virtual void EnsureCapacity(long numBits);
    public virtual void TrimTrailingZeros();
    public static int Bits2words(long numBits);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Util.OpenBitSetDISI : OpenBitSet {
    public OpenBitSetDISI(DocIdSetIterator disi, int maxSize);
    public OpenBitSetDISI(int maxSize);
    public virtual void InPlaceOr(DocIdSetIterator disi);
    public virtual void InPlaceAnd(DocIdSetIterator disi);
    public virtual void InPlaceNot(DocIdSetIterator disi);
    public virtual void InPlaceXor(DocIdSetIterator disi);
}
[ExtensionAttribute]
public static class Lucene.Net.Util.OpenBitSetExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use Cardinality property instead. This extension method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public static long Cardinality(OpenBitSet set);
}
public class Lucene.Net.Util.OpenBitSetIterator : DocIdSetIterator {
    internal Int64[] arr;
    internal int words;
    private int i;
    private long word;
    private int wordShift;
    private int indexArray;
    private int curDocId;
    public int DocID { get; }
    public OpenBitSetIterator(OpenBitSet obs);
    public OpenBitSetIterator(Int64[] bits, int numWords);
    private void Shift();
    public virtual int NextDoc();
    public virtual int Advance(int target);
    public virtual int get_DocID();
    public virtual long GetCost();
}
public abstract class Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer : Int64Values {
    internal static int MIN_PAGE_SIZE;
    internal static int MAX_PAGE_SIZE;
    internal int pageShift;
    internal int pageMask;
    internal Reader[] values;
    private long valuesBytes;
    internal int valuesOff;
    internal Int64[] pending;
    internal int pendingOff;
    internal float acceptableOverheadRatio;
    public int PageSize { get; }
    public long Count { get; }
    internal AbstractAppendingInt64Buffer(int initialBlockCount, int pageSize, float acceptableOverheadRatio);
    public int get_PageSize();
    public long get_Count();
    public void Add(long l);
    internal virtual void Grow(int newBlockCount);
    internal abstract virtual void PackPendingValues();
    public sealed virtual long Get(long index);
    public int Get(long index, Int64[] arr, int off, int len);
    internal abstract virtual long Get(int block, int element);
    internal abstract virtual int Get(int block, int element, Int64[] arr, int off, int len);
    public virtual Iterator GetIterator();
    internal virtual long BaseRamBytesUsed();
    public virtual long RamBytesUsed();
    public virtual void Freeze();
}
public abstract class Lucene.Net.Util.Packed.AbstractBlockPackedWriter : object {
    internal static int MIN_BLOCK_SIZE;
    internal static int MAX_BLOCK_SIZE;
    internal static int MIN_VALUE_EQUALS_0;
    internal static int BPV_SHIFT;
    protected DataOutput m_out;
    protected Int64[] m_values;
    protected Byte[] m_blocks;
    protected int m_off;
    protected long m_ord;
    protected bool m_finished;
    public long Ord { get; }
    protected AbstractBlockPackedWriter(DataOutput out, int blockSize);
    internal static long ZigZagEncode(long n);
    internal static void WriteVInt64(DataOutput out, long i);
    public virtual void Reset(DataOutput out);
    private void CheckNotFinished();
    public virtual void Add(long l);
    internal virtual void AddBlockOfZeros();
    public virtual void Finish();
    public virtual long get_Ord();
    protected abstract virtual void Flush();
    protected void WriteValues(int bitsRequired);
}
public abstract class Lucene.Net.Util.Packed.AbstractPagedMutable`1 : Int64Values {
    internal static int MIN_BLOCK_SIZE;
    internal static int MAX_BLOCK_SIZE;
    internal long size;
    internal int pageShift;
    internal int pageMask;
    internal Mutable[] subMutables;
    internal int bitsPerValue;
    internal int PageSize { get; }
    public long Count { get; }
    internal AbstractPagedMutable`1(int bitsPerValue, long size, int pageSize);
    protected void FillPages();
    protected abstract virtual Mutable NewMutable(int valueCount, int bitsPerValue);
    internal int LastPageSize(long size);
    internal int get_PageSize();
    public long get_Count();
    internal int PageIndex(long index);
    internal int IndexInPage(long index);
    public sealed virtual long Get(long index);
    public void Set(long index, long value);
    protected virtual long BaseRamBytesUsed();
    public virtual long RamBytesUsed();
    protected abstract virtual T NewUnfilledCopy(long newSize);
    public T Resize(long newSize);
    public T Grow(long minSize);
    public T Grow();
    public sealed virtual string ToString();
}
public class Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer : AbstractAppendingInt64Buffer {
    internal Int64[] minValues;
    public AppendingDeltaPackedInt64Buffer(int initialPageCount, int pageSize, float acceptableOverheadRatio);
    public AppendingDeltaPackedInt64Buffer(float acceptableOverheadRatio);
    internal virtual long Get(int block, int element);
    internal virtual int Get(int block, int element, Int64[] arr, int off, int len);
    internal virtual void PackPendingValues();
    internal virtual void Grow(int newBlockCount);
    internal virtual long BaseRamBytesUsed();
    public virtual long RamBytesUsed();
}
public class Lucene.Net.Util.Packed.AppendingPackedInt64Buffer : AbstractAppendingInt64Buffer {
    public AppendingPackedInt64Buffer(int initialPageCount, int pageSize, float acceptableOverheadRatio);
    public AppendingPackedInt64Buffer(float acceptableOverheadRatio);
    internal virtual long Get(int block, int element);
    internal virtual int Get(int block, int element, Int64[] arr, int off, int len);
    internal virtual void PackPendingValues();
}
public class Lucene.Net.Util.Packed.BlockPackedReader : Int64Values {
    private int blockShift;
    private int blockMask;
    private long valueCount;
    private Int64[] minValues;
    private Reader[] subReaders;
    public BlockPackedReader(IndexInput in, int packedIntsVersion, int blockSize, long valueCount, bool direct);
    public virtual long Get(long index);
    public long RamBytesUsed();
}
public class Lucene.Net.Util.Packed.BlockPackedReaderIterator : object {
    internal DataInput in;
    internal int packedIntsVersion;
    internal long valueCount;
    internal int blockSize;
    internal Int64[] values;
    internal Int64sRef valuesRef;
    internal Byte[] blocks;
    internal int off;
    internal long ord;
    public long Ord { get; }
    public BlockPackedReaderIterator(DataInput in, int packedIntsVersion, int blockSize, long valueCount);
    internal static long ZigZagDecode(long n);
    internal static long ReadVInt64(DataInput in);
    public void Reset(DataInput in, long valueCount);
    public void Skip(long count);
    private void SkipBytes(long count);
    public long Next();
    public Int64sRef Next(int count);
    private void Refill();
    public long get_Ord();
}
public class Lucene.Net.Util.Packed.BlockPackedWriter : AbstractBlockPackedWriter {
    public BlockPackedWriter(DataOutput out, int blockSize);
    protected virtual void Flush();
}
internal abstract class Lucene.Net.Util.Packed.BulkOperation : object {
    private static BulkOperation[] packedBulkOps;
    private static BulkOperation[] packedSingleBlockBulkOps;
    public int ByteValueCount { get; }
    public int ByteBlockCount { get; }
    public int Int64ValueCount { get; }
    public int Int64BlockCount { get; }
    private static BulkOperation();
    public abstract virtual void Encode(Int32[] values, int valuesOffset, Byte[] blocks, int blocksOffset, int iterations);
    public abstract virtual void Encode(Int32[] values, int valuesOffset, Int64[] blocks, int blocksOffset, int iterations);
    public abstract virtual void Encode(Int64[] values, int valuesOffset, Byte[] blocks, int blocksOffset, int iterations);
    public abstract virtual void Encode(Int64[] values, int valuesOffset, Int64[] blocks, int blocksOffset, int iterations);
    public abstract virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public abstract virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public abstract virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public abstract virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public abstract virtual int get_ByteValueCount();
    public abstract virtual int get_ByteBlockCount();
    public abstract virtual int get_Int64ValueCount();
    public abstract virtual int get_Int64BlockCount();
    public static BulkOperation Of(Format format, int bitsPerValue);
    protected virtual int WriteInt64(long block, Byte[] blocks, int blocksOffset);
    public int ComputeIterations(int valueCount, int ramBudget);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked : BulkOperation {
    private int bitsPerValue;
    private int longBlockCount;
    private int longValueCount;
    private int byteBlockCount;
    private int byteValueCount;
    private long mask;
    private int intMask;
    public int Int64BlockCount { get; }
    public int Int64ValueCount { get; }
    public int ByteBlockCount { get; }
    public int ByteValueCount { get; }
    public BulkOperationPacked(int bitsPerValue);
    public virtual int get_Int64BlockCount();
    public virtual int get_Int64ValueCount();
    public virtual int get_ByteBlockCount();
    public virtual int get_ByteValueCount();
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Encode(Int64[] values, int valuesOffset, Int64[] blocks, int blocksOffset, int iterations);
    public virtual void Encode(Int32[] values, int valuesOffset, Int64[] blocks, int blocksOffset, int iterations);
    public virtual void Encode(Int64[] values, int valuesOffset, Byte[] blocks, int blocksOffset, int iterations);
    public virtual void Encode(Int32[] values, int valuesOffset, Byte[] blocks, int blocksOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked1 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked10 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked11 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked12 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked13 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked14 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked15 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked16 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked17 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked18 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked19 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked2 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked20 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked21 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked22 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked23 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked24 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked3 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked4 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked5 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked6 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked7 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked8 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPacked9 : BulkOperationPacked {
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.BulkOperationPackedSingleBlock : BulkOperation {
    private static int BLOCK_COUNT;
    private int bitsPerValue;
    private int valueCount;
    private long mask;
    public int Int64BlockCount { get; }
    public int ByteBlockCount { get; }
    public int Int64ValueCount { get; }
    public int ByteValueCount { get; }
    public BulkOperationPackedSingleBlock(int bitsPerValue);
    public sealed virtual int get_Int64BlockCount();
    public sealed virtual int get_ByteBlockCount();
    public virtual int get_Int64ValueCount();
    public sealed virtual int get_ByteValueCount();
    private static long ReadInt64(Byte[] blocks, int blocksOffset);
    private int Decode(long block, Int64[] values, int valuesOffset);
    private int Decode(long block, Int32[] values, int valuesOffset);
    private long Encode(Int64[] values, int valuesOffset);
    private long Encode(Int32[] values, int valuesOffset);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int64[] values, int valuesOffset, int iterations);
    public virtual void Decode(Int64[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Decode(Byte[] blocks, int blocksOffset, Int32[] values, int valuesOffset, int iterations);
    public virtual void Encode(Int64[] values, int valuesOffset, Int64[] blocks, int blocksOffset, int iterations);
    public virtual void Encode(Int32[] values, int valuesOffset, Int64[] blocks, int blocksOffset, int iterations);
    public virtual void Encode(Int64[] values, int valuesOffset, Byte[] blocks, int blocksOffset, int iterations);
    public virtual void Encode(Int32[] values, int valuesOffset, Byte[] blocks, int blocksOffset, int iterations);
}
internal class Lucene.Net.Util.Packed.Direct16 : MutableImpl {
    internal Int16[] values;
    public bool HasArray { get; }
    internal Direct16(int valueCount);
    internal Direct16(int packedIntsVersion, DataInput in, int valueCount);
    public virtual long Get(int index);
    public virtual void Set(int index, long value);
    public virtual long RamBytesUsed();
    public virtual void Clear();
    public virtual object GetArray();
    public virtual bool get_HasArray();
    public virtual int Get(int index, Int64[] arr, int off, int len);
    public virtual int Set(int index, Int64[] arr, int off, int len);
    public virtual void Fill(int fromIndex, int toIndex, long val);
}
internal class Lucene.Net.Util.Packed.Direct32 : MutableImpl {
    internal Int32[] values;
    public bool HasArray { get; }
    internal Direct32(int valueCount);
    internal Direct32(int packedIntsVersion, DataInput in, int valueCount);
    public virtual long Get(int index);
    public virtual void Set(int index, long value);
    public virtual long RamBytesUsed();
    public virtual void Clear();
    public virtual object GetArray();
    public virtual bool get_HasArray();
    public virtual int Get(int index, Int64[] arr, int off, int len);
    public virtual int Set(int index, Int64[] arr, int off, int len);
    public virtual void Fill(int fromIndex, int toIndex, long val);
}
internal class Lucene.Net.Util.Packed.Direct64 : MutableImpl {
    internal Int64[] values;
    public bool HasArray { get; }
    internal Direct64(int valueCount);
    internal Direct64(DataInput in, int valueCount);
    public virtual long Get(int index);
    public virtual void Set(int index, long value);
    public virtual long RamBytesUsed();
    public virtual void Clear();
    public virtual object GetArray();
    public virtual bool get_HasArray();
    public virtual int Get(int index, Int64[] arr, int off, int len);
    public virtual int Set(int index, Int64[] arr, int off, int len);
    public virtual void Fill(int fromIndex, int toIndex, long val);
}
internal class Lucene.Net.Util.Packed.Direct8 : MutableImpl {
    private Byte[] values;
    public bool HasArray { get; }
    internal Direct8(int valueCount);
    internal Direct8(int packedIntsVersion, DataInput in, int valueCount);
    public virtual long Get(int index);
    public virtual void Set(int index, long value);
    public virtual long RamBytesUsed();
    public virtual void Clear();
    public virtual object GetArray();
    public virtual bool get_HasArray();
    public virtual int Get(int index, Int64[] arr, int off, int len);
    public virtual int Set(int index, Int64[] arr, int off, int len);
    public virtual void Fill(int fromIndex, int toIndex, long val);
}
internal class Lucene.Net.Util.Packed.DirectPacked64SingleBlockReader : ReaderImpl {
    private IndexInput in;
    private long startPointer;
    private int valuesPerBlock;
    private long mask;
    internal DirectPacked64SingleBlockReader(int bitsPerValue, int valueCount, IndexInput in);
    public virtual long Get(int index);
    public virtual long RamBytesUsed();
}
internal class Lucene.Net.Util.Packed.DirectPackedReader : ReaderImpl {
    private IndexInput in;
    private long startPointer;
    private long valueMask;
    public DirectPackedReader(int bitsPerValue, int valueCount, IndexInput in);
    public virtual long Get(int index);
    public virtual long RamBytesUsed();
}
public class Lucene.Net.Util.Packed.EliasFanoDecoder : object {
    private static int LOG2_INT64_SIZE;
    private EliasFanoEncoder efEncoder;
    private long numEncoded;
    private long efIndex;
    private long setBitForIndex;
    public static long NO_MORE_VALUES;
    private long numIndexEntries;
    private long indexMask;
    private long curHighLong;
    public EliasFanoEncoder EliasFanoEncoder { get; }
    public long NumEncoded { get; }
    private int CurrentRightShift { get; }
    private int CurrentLeftShift { get; }
    public EliasFanoDecoder(EliasFanoEncoder efEncoder);
    private static EliasFanoDecoder();
    public virtual EliasFanoEncoder get_EliasFanoEncoder();
    public virtual long get_NumEncoded();
    public virtual long CurrentIndex();
    public virtual long CurrentValue();
    private long CurrentHighValue();
    private static long UnPackValue(Int64[] longArray, int numBits, long packIndex, long bitsMask);
    private long CurrentLowValue();
    private long CombineHighLowValues(long highValue, long lowValue);
    public virtual void ToBeforeSequence();
    private int get_CurrentRightShift();
    private bool ToAfterCurrentHighBit();
    private void ToNextHighInt64();
    private void ToNextHighValue();
    private long NextHighValue();
    public virtual long NextValue();
    public virtual bool AdvanceToIndex(long index);
    public virtual long AdvanceToValue(long target);
    public virtual void ToAfterSequence();
    private int get_CurrentLeftShift();
    private bool ToBeforeCurrentHighBit();
    private void ToPreviousHighInt64();
    private long PreviousHighValue();
    public virtual long PreviousValue();
    private long BackToHighValue(long highTarget);
    public virtual long BackToValue(long target);
}
public class Lucene.Net.Util.Packed.EliasFanoDocIdSet : DocIdSet {
    internal EliasFanoEncoder efEncoder;
    public bool IsCacheable { get; }
    public EliasFanoDocIdSet(int numValues, int upperBound);
    public static bool SufficientlySmallerThanBitSet(long numValues, long upperBound);
    public virtual void EncodeFromDisi(DocIdSetIterator disi);
    public virtual DocIdSetIterator GetIterator();
    public virtual bool get_IsCacheable();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class Lucene.Net.Util.Packed.EliasFanoEncoder : object {
    internal long numValues;
    private long upperBound;
    internal int numLowBits;
    internal long lowerBitsMask;
    internal Int64[] upperLongs;
    internal Int64[] lowerLongs;
    private static int LOG2_INT64_SIZE;
    internal long numEncoded;
    internal long lastEncoded;
    public static long DEFAULT_INDEX_INTERVAL;
    internal long numIndexEntries;
    internal long indexInterval;
    internal int nIndexEntryBits;
    internal Int64[] upperZeroBitPositionIndex;
    internal long currentEntryIndex;
    [WritableArrayAttribute]
public Int64[] LowerBits { get; }
    [WritableArrayAttribute]
public Int64[] UpperBits { get; }
    [WritableArrayAttribute]
public Int64[] IndexBits { get; }
    public EliasFanoEncoder(long numValues, long upperBound, long indexInterval);
    public EliasFanoEncoder(long numValues, long upperBound);
    private static EliasFanoEncoder();
    private static long NumInt64sForBits(long numBits);
    public virtual void EncodeNext(long x);
    private void EncodeUpperBits(long highValue);
    private void EncodeLowerBits(long lowValue);
    private static void PackValue(long value, Int64[] longArray, int numBits, long packIndex);
    public static bool SufficientlySmallerThanBitSet(long numValues, long upperBound);
    public virtual EliasFanoDecoder GetDecoder();
    public virtual Int64[] get_LowerBits();
    public virtual Int64[] get_UpperBits();
    public virtual Int64[] get_IndexBits();
    public virtual string ToString();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class Lucene.Net.Util.Packed.GrowableWriter : Mutable {
    private long currentMask;
    private Mutable current;
    private float acceptableOverheadRatio;
    public int Count { get; }
    public int BitsPerValue { get; }
    public Mutable Mutable { get; }
    public bool HasArray { get; }
    public GrowableWriter(int startBitsPerValue, int valueCount, float acceptableOverheadRatio);
    private static long Mask(int bitsPerValue);
    public virtual long Get(int index);
    public virtual int get_Count();
    public virtual int get_BitsPerValue();
    public virtual Mutable get_Mutable();
    public virtual object GetArray();
    public virtual bool get_HasArray();
    private void EnsureCapacity(long value);
    public virtual void Set(int index, long value);
    public virtual void Clear();
    public virtual GrowableWriter Resize(int newSize);
    public virtual int Get(int index, Int64[] arr, int off, int len);
    public virtual int Set(int index, Int64[] arr, int off, int len);
    public virtual void Fill(int fromIndex, int toIndex, long val);
    public virtual long RamBytesUsed();
    public virtual void Save(DataOutput out);
}
public class Lucene.Net.Util.Packed.MonotonicAppendingInt64Buffer : AbstractAppendingInt64Buffer {
    internal Single[] averages;
    internal Int64[] minValues;
    public MonotonicAppendingInt64Buffer(int initialPageCount, int pageSize, float acceptableOverheadRatio);
    public MonotonicAppendingInt64Buffer(float acceptableOverheadRatio);
    internal static long ZigZagDecode(long n);
    internal static long ZigZagEncode(long n);
    internal virtual long Get(int block, int element);
    internal virtual int Get(int block, int element, Int64[] arr, int off, int len);
    internal virtual void Grow(int newBlockCount);
    internal virtual void PackPendingValues();
    internal virtual long BaseRamBytesUsed();
    public virtual long RamBytesUsed();
}
public class Lucene.Net.Util.Packed.MonotonicBlockPackedReader : Int64Values {
    private int blockShift;
    private int blockMask;
    private long valueCount;
    private Int64[] minValues;
    private Single[] averages;
    private Reader[] subReaders;
    public long Count { get; }
    public MonotonicBlockPackedReader(IndexInput in, int packedIntsVersion, int blockSize, long valueCount, bool direct);
    public virtual long Get(long index);
    public long get_Count();
    public long RamBytesUsed();
}
public class Lucene.Net.Util.Packed.MonotonicBlockPackedWriter : AbstractBlockPackedWriter {
    public MonotonicBlockPackedWriter(DataOutput out, int blockSize);
    public virtual void Add(long l);
    protected virtual void Flush();
}
internal class Lucene.Net.Util.Packed.Packed16ThreeBlocks : MutableImpl {
    internal Int16[] blocks;
    public static int MAX_SIZE;
    internal Packed16ThreeBlocks(int valueCount);
    internal Packed16ThreeBlocks(int packedIntsVersion, DataInput in, int valueCount);
    public virtual long Get(int index);
    public virtual int Get(int index, Int64[] arr, int off, int len);
    public virtual void Set(int index, long value);
    public virtual int Set(int index, Int64[] arr, int off, int len);
    public virtual void Fill(int fromIndex, int toIndex, long val);
    public virtual void Clear();
    public virtual long RamBytesUsed();
    public virtual string ToString();
}
public class Lucene.Net.Util.Packed.Packed64 : MutableImpl {
    internal static int BLOCK_SIZE;
    internal static int BLOCK_BITS;
    internal static int MOD_MASK;
    private Int64[] blocks;
    private long maskRight;
    private int bpvMinusBlockSize;
    public Packed64(int valueCount, int bitsPerValue);
    public Packed64(int packedIntsVersion, DataInput in, int valueCount, int bitsPerValue);
    public virtual long Get(int index);
    public virtual int Get(int index, Int64[] arr, int off, int len);
    public virtual void Set(int index, long value);
    public virtual int Set(int index, Int64[] arr, int off, int len);
    public virtual string ToString();
    public virtual long RamBytesUsed();
    public virtual void Fill(int fromIndex, int toIndex, long val);
    private static int Gcd(int a, int b);
    public virtual void Clear();
}
internal abstract class Lucene.Net.Util.Packed.Packed64SingleBlock : MutableImpl {
    public static int MAX_SUPPORTED_BITS_PER_VALUE;
    private static Int32[] SUPPORTED_BITS_PER_VALUE;
    internal Int64[] blocks;
    internal Format Format { get; }
    internal Packed64SingleBlock(int valueCount, int bitsPerValue);
    private static Packed64SingleBlock();
    public static bool IsSupported(int bitsPerValue);
    private static int RequiredCapacity(int valueCount, int valuesPerBlock);
    public virtual void Clear();
    public virtual long RamBytesUsed();
    public virtual int Get(int index, Int64[] arr, int off, int len);
    public virtual int Set(int index, Int64[] arr, int off, int len);
    public virtual void Fill(int fromIndex, int toIndex, long val);
    internal virtual Format get_Format();
    public virtual string ToString();
    public static Packed64SingleBlock Create(DataInput in, int valueCount, int bitsPerValue);
    public static Packed64SingleBlock Create(int valueCount, int bitsPerValue);
}
internal class Lucene.Net.Util.Packed.Packed8ThreeBlocks : MutableImpl {
    private Byte[] blocks;
    public static int MAX_SIZE;
    internal Packed8ThreeBlocks(int valueCount);
    internal Packed8ThreeBlocks(int packedIntsVersion, DataInput in, int valueCount);
    public virtual long Get(int index);
    public virtual int Get(int index, Int64[] arr, int off, int len);
    public virtual void Set(int index, long value);
    public virtual int Set(int index, Int64[] arr, int off, int len);
    public virtual void Fill(int fromIndex, int toIndex, long val);
    public virtual void Clear();
    public virtual long RamBytesUsed();
    public virtual string ToString();
}
public class Lucene.Net.Util.Packed.PackedDataInput : object {
    internal DataInput in;
    internal long current;
    internal int remainingBits;
    public PackedDataInput(DataInput in);
    public long ReadInt64(int bitsPerValue);
    public void SkipToNextByte();
}
public class Lucene.Net.Util.Packed.PackedDataOutput : object {
    internal DataOutput out;
    internal long current;
    internal int remainingBits;
    public PackedDataOutput(DataOutput out);
    public void WriteInt64(long value, int bitsPerValue);
    public void Flush();
}
public static class Lucene.Net.Util.Packed.PackedInt32s : object {
    public static float FASTEST;
    public static float FAST;
    public static float DEFAULT;
    public static float COMPACT;
    public static int DEFAULT_BUFFER_SIZE;
    public static string CODEC_NAME;
    public static int VERSION_START;
    public static int VERSION_BYTE_ALIGNED;
    public static int VERSION_CURRENT;
    private static PackedInt32s();
    public static void CheckVersion(int version);
    public static FormatAndBits FastestFormatAndBits(int valueCount, int bitsPerValue, float acceptableOverheadRatio);
    public static IDecoder GetDecoder(Format format, int version, int bitsPerValue);
    public static IEncoder GetEncoder(Format format, int version, int bitsPerValue);
    public static Reader GetReaderNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue);
    public static Reader GetReaderNoHeader(DataInput in, Header header);
    public static Reader GetReader(DataInput in);
    public static IReaderIterator GetReaderIteratorNoHeader(DataInput in, Format format, int version, int valueCount, int bitsPerValue, int mem);
    public static IReaderIterator GetReaderIterator(DataInput in, int mem);
    public static Reader GetDirectReaderNoHeader(IndexInput in, Format format, int version, int valueCount, int bitsPerValue);
    public static Reader GetDirectReaderNoHeader(IndexInput in, Header header);
    public static Reader GetDirectReader(IndexInput in);
    public static Mutable GetMutable(int valueCount, int bitsPerValue, float acceptableOverheadRatio);
    public static Mutable GetMutable(int valueCount, int bitsPerValue, Format format);
    public static Writer GetWriterNoHeader(DataOutput out, Format format, int valueCount, int bitsPerValue, int mem);
    public static Writer GetWriter(DataOutput out, int valueCount, int bitsPerValue, float acceptableOverheadRatio);
    public static int BitsRequired(long maxValue);
    public static long MaxValue(int bitsPerValue);
    public static void Copy(Reader src, int srcPos, Mutable dest, int destPos, int len, int mem);
    internal static void Copy(Reader src, int srcPos, Mutable dest, int destPos, int len, Int64[] buf);
    public static Header ReadHeader(DataInput in);
    internal static int CheckBlockSize(int blockSize, int minBlockSize, int maxBlockSize);
    internal static int NumBlocks(long size, int blockSize);
}
internal class Lucene.Net.Util.Packed.PackedReaderIterator : ReaderIterator {
    internal int packedIntsVersion;
    internal Format format;
    internal BulkOperation bulkOperation;
    internal Byte[] nextBlocks;
    internal Int64sRef nextValues;
    internal int iterations;
    internal int position;
    public int Ord { get; }
    internal PackedReaderIterator(Format format, int packedIntsVersion, int valueCount, int bitsPerValue, DataInput in, int mem);
    private int Iterations(int mem);
    public virtual Int64sRef Next(int count);
    public virtual int get_Ord();
}
internal class Lucene.Net.Util.Packed.PackedWriter : Writer {
    internal bool finished;
    internal Format format;
    internal BulkOperation encoder;
    internal Byte[] nextBlocks;
    internal Int64[] nextValues;
    internal int iterations;
    internal int off;
    internal int written;
    protected internal Format Format { get; }
    public int Ord { get; }
    internal PackedWriter(Format format, DataOutput out, int valueCount, int bitsPerValue, int mem);
    protected internal virtual Format get_Format();
    public virtual void Add(long v);
    public virtual void Finish();
    private void Flush();
    public virtual int get_Ord();
}
public class Lucene.Net.Util.Packed.PagedGrowableWriter : AbstractPagedMutable`1<PagedGrowableWriter> {
    internal float acceptableOverheadRatio;
    public PagedGrowableWriter(long size, int pageSize, int startBitsPerValue, float acceptableOverheadRatio);
    internal PagedGrowableWriter(long size, int pageSize, int startBitsPerValue, float acceptableOverheadRatio, bool fillPages);
    protected virtual Mutable NewMutable(int valueCount, int bitsPerValue);
    protected virtual PagedGrowableWriter NewUnfilledCopy(long newSize);
    protected virtual long BaseRamBytesUsed();
}
public class Lucene.Net.Util.Packed.PagedMutable : AbstractPagedMutable`1<PagedMutable> {
    internal Format format;
    public PagedMutable(long size, int pageSize, int bitsPerValue, float acceptableOverheadRatio);
    internal PagedMutable(long size, int pageSize, FormatAndBits formatAndBits);
    internal PagedMutable(long size, int pageSize, int bitsPerValue, Format format);
    protected virtual Mutable NewMutable(int valueCount, int bitsPerValue);
    protected virtual PagedMutable NewUnfilledCopy(long newSize);
    protected virtual long BaseRamBytesUsed();
}
public class Lucene.Net.Util.PagedBytes : object {
    private IList`1<Byte[]> blocks;
    private IList`1<int> blockEnd;
    private int blockSize;
    private int blockBits;
    private int blockMask;
    private bool didSkipBytes;
    private bool frozen;
    private int upto;
    private Byte[] currentBlock;
    private long bytesUsedPerBlock;
    private static Byte[] EMPTY_BYTES;
    public PagedBytes(int blockBits);
    private static PagedBytes();
    public void Copy(IndexInput in, long byteCount);
    public void Copy(BytesRef bytes, BytesRef out);
    public Reader Freeze(bool trim);
    public long GetPointer();
    public long RamBytesUsed();
    public long CopyUsingLengthPrefix(BytesRef bytes);
    public PagedBytesDataInput GetDataInput();
    public PagedBytesDataOutput GetDataOutput();
}
public class Lucene.Net.Util.PForDeltaDocIdSet : DocIdSet {
    internal static int BLOCK_SIZE;
    internal static int MAX_EXCEPTIONS;
    internal static IDecoder[] DECODERS;
    internal static Int32[] ITERATIONS;
    internal static Int32[] BYTE_BLOCK_COUNTS;
    internal static int MAX_BYTE_BLOCK_COUNT;
    internal static MonotonicAppendingInt64Buffer SINGLE_ZERO_BUFFER;
    internal static PForDeltaDocIdSet EMPTY;
    internal static int LAST_BLOCK;
    internal static int HAS_EXCEPTIONS;
    internal static int UNARY;
    internal Byte[] data;
    internal MonotonicAppendingInt64Buffer docIDs;
    internal MonotonicAppendingInt64Buffer offsets;
    internal int cardinality;
    internal int indexInterval;
    public bool IsCacheable { get; }
    public int Cardinality { get; }
    private static PForDeltaDocIdSet();
    internal PForDeltaDocIdSet(Byte[] data, int cardinality, int indexInterval, MonotonicAppendingInt64Buffer docIDs, MonotonicAppendingInt64Buffer offsets);
    private static MonotonicAppendingInt64Buffer LoadSingleZeroBuffer();
    public virtual bool get_IsCacheable();
    public virtual DocIdSetIterator GetIterator();
    public int get_Cardinality();
    public long RamBytesUsed();
}
[ExtensionAttribute]
public static class Lucene.Net.Util.PForDeltaDocIdSetExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use Cardinality property instead. This extension method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public static int Cardinality(PForDeltaDocIdSet set);
}
[ObsoleteAttribute("Use TextWriterInfoStream in .NET. This class is provided only to assist with the transition.")]
public class Lucene.Net.Util.PrintStreamInfoStream : TextWriterInfoStream {
    public PrintStreamInfoStream(TextWriter stream);
    public PrintStreamInfoStream(TextWriter stream, int messageID);
}
public abstract class Lucene.Net.Util.PriorityQueue`1 : object {
    private int size;
    internal int maxSize;
    internal T[] heap;
    public T Top { get; }
    public int Count { get; }
    [WritableArrayAttribute]
protected T[] HeapArray { get; }
    protected PriorityQueue`1(int maxSize);
    protected PriorityQueue`1(int maxSize, bool prepopulate);
    protected internal abstract virtual bool LessThan(T a, T b);
    protected virtual T GetSentinelObject();
    public T Add(T element);
    public virtual void Insert(T element);
    public virtual T InsertWithOverflow(T element);
    public T get_Top();
    public T Pop();
    public T UpdateTop();
    public int get_Count();
    public void Clear();
    private void UpHeap();
    private void DownHeap();
    protected T[] get_HeapArray();
}
internal class Lucene.Net.Util.Properties : object {
    private Func`1<IConfigurationFactory> getConfigurationFactory;
    public Properties(Func`1<IConfigurationFactory> getConfigurationFactory);
    public sealed virtual string GetProperty(string key);
    public sealed virtual string GetProperty(string key, string defaultValue);
    public sealed virtual bool GetPropertyAsBoolean(string key);
    public sealed virtual bool GetPropertyAsBoolean(string key, bool defaultValue);
    public sealed virtual int GetPropertyAsInt32(string key);
    public sealed virtual int GetPropertyAsInt32(string key, int defaultValue);
    private T GetProperty(string key, T defaultValue, Func`2<string, T> conversionFunction);
}
public class Lucene.Net.Util.QueryBuilder : object {
    private Analyzer analyzer;
    private bool enablePositionIncrements;
    public Analyzer Analyzer { get; public set; }
    public bool EnablePositionIncrements { get; public set; }
    public QueryBuilder(Analyzer analyzer);
    public virtual Query CreateBooleanQuery(string field, string queryText);
    public virtual Query CreateBooleanQuery(string field, string queryText, Occur operator);
    public virtual Query CreatePhraseQuery(string field, string queryText);
    public virtual Query CreatePhraseQuery(string field, string queryText, int phraseSlop);
    public virtual Query CreateMinShouldMatchQuery(string field, string queryText, float fraction);
    public virtual Analyzer get_Analyzer();
    public virtual void set_Analyzer(Analyzer value);
    public virtual bool get_EnablePositionIncrements();
    public virtual void set_EnablePositionIncrements(bool value);
    protected Query CreateFieldQuery(Analyzer analyzer, Occur operator, string field, string queryText, bool quoted, int phraseSlop);
    protected virtual BooleanQuery NewBooleanQuery(bool disableCoord);
    protected virtual Query NewTermQuery(Term term);
    protected virtual PhraseQuery NewPhraseQuery();
    protected virtual MultiPhraseQuery NewMultiPhraseQuery();
}
public class Lucene.Net.Util.RamUsageEstimator : object {
    public static long ONE_KB;
    public static long ONE_MB;
    public static long ONE_GB;
    public static int NUM_BYTES_BOOLEAN;
    public static int NUM_BYTES_BYTE;
    public static int NUM_BYTES_CHAR;
    public static int NUM_BYTES_INT16;
    public static int NUM_BYTES_INT32;
    public static int NUM_BYTES_SINGLE;
    public static int NUM_BYTES_INT64;
    public static int NUM_BYTES_DOUBLE;
    public static int NUM_BYTES_OBJECT_REF;
    public static int NUM_BYTES_OBJECT_HEADER;
    public static int NUM_BYTES_ARRAY_HEADER;
    public static int NUM_BYTES_OBJECT_ALIGNMENT;
    private static IDictionary`2<Type, int> primitiveSizes;
    private static RamUsageEstimator();
    public static long AlignObjectSize(long size);
    public static long SizeOf(Byte[] arr);
    [CLSCompliantAttribute("False")]
public static long SizeOf(SByte[] arr);
    public static long SizeOf(Boolean[] arr);
    public static long SizeOf(Char[] arr);
    public static long SizeOf(Int16[] arr);
    public static long SizeOf(Int32[] arr);
    public static long SizeOf(Single[] arr);
    public static long SizeOf(Int64[] arr);
    public static long SizeOf(Double[] arr);
    [CLSCompliantAttribute("False")]
public static long SizeOf(UInt64[] arr);
    [CLSCompliantAttribute("False")]
public static long SizeOf(UInt32[] arr);
    [CLSCompliantAttribute("False")]
public static long SizeOf(UInt16[] arr);
    public static long SizeOf(object obj);
    public static long ShallowSizeOf(object obj);
    public static long ShallowSizeOfInstance(Type clazz);
    private static long ShallowSizeOfArray(Array array);
    private static long MeasureObjectSize(object root);
    private static ClassCache CreateCacheEntry(Type clazz);
    private static long AdjustForField(long sizeSoFar, FieldInfo f);
    public static string HumanReadableUnits(long bytes);
    public static string HumanReadableUnits(long bytes, IFormatProvider df);
    public static string HumanSizeOf(object object);
    public static string HumanSizeOf(object object, IFormatProvider df);
}
public class Lucene.Net.Util.RecyclingByteBlockAllocator : Allocator {
    private Byte[][] freeByteBlocks;
    private int maxBufferedBlocks;
    private int freeBlocks;
    private Counter bytesUsed;
    public static int DEFAULT_BUFFERED_BLOCKS;
    public int NumBufferedBlocks { get; }
    public long BytesUsed { get; }
    public int MaxBufferedBlocks { get; }
    public RecyclingByteBlockAllocator(int blockSize, int maxBufferedBlocks, Counter bytesUsed);
    public RecyclingByteBlockAllocator(int blockSize, int maxBufferedBlocks);
    public virtual Byte[] GetByteBlock();
    public virtual void RecycleByteBlocks(Byte[][] blocks, int start, int end);
    public int get_NumBufferedBlocks();
    public long get_BytesUsed();
    public int get_MaxBufferedBlocks();
    public int FreeBlocks(int num);
}
public class Lucene.Net.Util.RecyclingInt32BlockAllocator : Allocator {
    private Int32[][] freeByteBlocks;
    private int maxBufferedBlocks;
    private int freeBlocks;
    private Counter bytesUsed;
    public static int DEFAULT_BUFFERED_BLOCKS;
    public int NumBufferedBlocks { get; }
    public long BytesUsed { get; }
    public int MaxBufferedBlocks { get; }
    public RecyclingInt32BlockAllocator(int blockSize, int maxBufferedBlocks, Counter bytesUsed);
    public RecyclingInt32BlockAllocator(int blockSize, int maxBufferedBlocks);
    public virtual Int32[] GetInt32Block();
    public virtual void RecycleInt32Blocks(Int32[][] blocks, int start, int end);
    public int get_NumBufferedBlocks();
    public long get_BytesUsed();
    public int get_MaxBufferedBlocks();
    public int FreeBlocks(int num);
}
public class Lucene.Net.Util.RefCount`1 : object {
    private AtomicInt32 refCount;
    protected internal T m_object;
    public RefCount`1(T object);
    protected virtual void Release();
    public void DecRef();
    public T Get();
    public int GetRefCount();
    public void IncRef();
}
public static class Lucene.Net.Util.RollingBuffer : object {
}
public abstract class Lucene.Net.Util.RollingBuffer`1 : object {
    private T[] buffer;
    private int nextWrite;
    private int nextPos;
    private int count;
    public int MaxPos { get; }
    protected RollingBuffer`1(Func`1<T> factory);
    protected abstract virtual T NewInstance();
    public virtual void Reset();
    private bool InBounds(int pos);
    private int GetIndex(int pos);
    public virtual T Get(int pos);
    public virtual int get_MaxPos();
    public virtual void FreeBefore(int pos);
}
public class Lucene.Net.Util.SentinelInt32Set : object {
    private Int32[] keys;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EmptyVal>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RehashCount>k__BackingField;
    [WritableArrayAttribute]
public Int32[] Keys { get; public set; }
    public int Count { get; private set; }
    public int EmptyVal { get; private set; }
    public int RehashCount { get; public set; }
    public SentinelInt32Set(int size, int emptyVal);
    public Int32[] get_Keys();
    public void set_Keys(Int32[] value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    [CompilerGeneratedAttribute]
public int get_EmptyVal();
    [CompilerGeneratedAttribute]
private void set_EmptyVal(int value);
    [CompilerGeneratedAttribute]
public int get_RehashCount();
    [CompilerGeneratedAttribute]
public void set_RehashCount(int value);
    public virtual void Clear();
    public virtual int Hash(int key);
    public virtual int GetSlot(int key);
    public virtual int Find(int key);
    public virtual bool Exists(int key);
    public virtual int Put(int key);
    public virtual void Rehash();
}
public abstract class Lucene.Net.Util.ServiceNameAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    protected ServiceNameAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
public class Lucene.Net.Util.SetOnce`1 : object {
    private T modreq(System.Runtime.CompilerServices.IsVolatile) obj;
    private AtomicBoolean set;
    public SetOnce`1(T obj);
    public void Set(T obj);
    public T Get();
    public object Clone();
}
public static class Lucene.Net.Util.SloppyMath : object {
    private static double TO_RADIANS;
    private static double ONE_DIV_F2;
    private static double ONE_DIV_F3;
    private static double ONE_DIV_F4;
    private static double PIO2_HI;
    private static double PIO2_LO;
    private static double TWOPI_HI;
    private static double TWOPI_LO;
    private static int SIN_COS_TABS_SIZE;
    private static double SIN_COS_DELTA_HI;
    private static double SIN_COS_DELTA_LO;
    private static double SIN_COS_INDEXER;
    private static Double[] sinTab;
    private static Double[] cosTab;
    internal static double SIN_COS_MAX_VALUE_FOR_INT_MODULO;
    private static double ASIN_MAX_VALUE_FOR_TABS;
    private static int ASIN_TABS_SIZE;
    private static double ASIN_DELTA;
    private static double ASIN_INDEXER;
    private static Double[] asinTab;
    private static Double[] asinDer1DivF1Tab;
    private static Double[] asinDer2DivF2Tab;
    private static Double[] asinDer3DivF3Tab;
    private static Double[] asinDer4DivF4Tab;
    private static double ASIN_PIO2_HI;
    private static double ASIN_PIO2_LO;
    private static double ASIN_PS0;
    private static double ASIN_PS1;
    private static double ASIN_PS2;
    private static double ASIN_PS3;
    private static double ASIN_PS4;
    private static double ASIN_PS5;
    private static double ASIN_QS1;
    private static double ASIN_QS2;
    private static double ASIN_QS3;
    private static double ASIN_QS4;
    private static int RADIUS_TABS_SIZE;
    private static double RADIUS_DELTA;
    private static double RADIUS_INDEXER;
    private static Double[] earthDiameterPerLatitude;
    private static SloppyMath();
    public static double Haversin(double lat1, double lon1, double lat2, double lon2);
    public static double Cos(double a);
    public static double Asin(double a);
    public static double EarthDiameter(double latitude);
}
public static class Lucene.Net.Util.SmallSingle : object {
    public static byte SingleToByte(float f, int numMantissaBits, int zeroExp);
    [CLSCompliantAttribute("False")]
public static sbyte SingleToSByte(float f, int numMantissaBits, int zeroExp);
    public static float ByteToSingle(byte b, int numMantissaBits, int zeroExp);
    [CLSCompliantAttribute("False")]
public static float SByteToSingle(sbyte b, int numMantissaBits, int zeroExp);
    public static byte SingleToByte315(float f);
    [CLSCompliantAttribute("False")]
public static sbyte SingleToSByte315(float f);
    public static float Byte315ToSingle(byte b);
    [CLSCompliantAttribute("False")]
public static float SByte315ToSingle(sbyte b);
    public static byte SingleToByte52(float f);
    [CLSCompliantAttribute("False")]
public static sbyte SingleToSByte52(float f);
    public static float Byte52ToSingle(byte b);
    [CLSCompliantAttribute("False")]
public static float SByte52ToSingle(sbyte b);
}
public abstract class Lucene.Net.Util.Sorter : object {
    internal static int THRESHOLD;
    protected abstract virtual int Compare(int i, int j);
    protected abstract virtual void Swap(int i, int j);
    public abstract virtual void Sort(int from, int to);
    internal virtual void CheckRange(int from, int to);
    internal virtual void MergeInPlace(int from, int mid, int to);
    internal virtual int Lower(int from, int to, int val);
    internal virtual int Upper(int from, int to, int val);
    internal virtual int Lower2(int from, int to, int val);
    internal virtual int Upper2(int from, int to, int val);
    internal void Reverse(int from, int to);
    internal void Rotate(int lo, int mid, int hi);
    internal virtual void DoRotate(int lo, int mid, int hi);
    internal virtual void InsertionSort(int from, int to);
    internal virtual void BinarySort(int from, int to);
    internal virtual void BinarySort(int from, int to, int i);
    internal virtual void HeapSort(int from, int to);
    internal virtual void Heapify(int from, int to);
    internal virtual void SiftDown(int i, int from, int to);
    internal static int HeapParent(int from, int i);
    internal static int HeapChild(int from, int i);
}
public class Lucene.Net.Util.SPIClassIterator`1 : object {
    private static HashSet`1<Type> types;
    private static SPIClassIterator`1();
    private static HashSet`1<Type> LoadTypes();
    internal static bool IsInvokableSubclassOf(Type type);
    public static SPIClassIterator`1<S> Get();
    public sealed virtual IEnumerator`1<Type> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class Lucene.Net.Util.StringHelper : object {
    internal static int goodFastHashSeed;
    [CompilerGeneratedAttribute]
private static IComparer`1<string> <VersionComparer>k__BackingField;
    public static int GoodFastHashSeed { get; }
    [ObsoleteAttribute("Use GoodFastHashSeed instead. This field will be removed in 4.8.0 release candidate.")]
public static int GOOD_FAST_HASH_SEED { get; }
    public static IComparer`1<string> VersionComparer { get; }
    private static StringHelper();
    public static int get_GoodFastHashSeed();
    public static int get_GOOD_FAST_HASH_SEED();
    [ExtensionAttribute]
public static int BytesDifference(BytesRef left, BytesRef right);
    [CompilerGeneratedAttribute]
public static IComparer`1<string> get_VersionComparer();
    public static bool Equals(string s1, string s2);
    [ExtensionAttribute]
public static bool StartsWith(BytesRef ref, BytesRef prefix);
    [ExtensionAttribute]
public static bool EndsWith(BytesRef ref, BytesRef suffix);
    [ExtensionAttribute]
private static bool SliceEquals(BytesRef sliceToTest, BytesRef other, int pos);
    public static int Murmurhash3_x86_32(Byte[] data, int offset, int len, int seed);
    public static int Murmurhash3_x86_32(BytesRef bytes, int seed);
}
public static class Lucene.Net.Util.SystemConsole : object {
    [CompilerGeneratedAttribute]
private static TextWriter <Out>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextWriter <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private static TextReader <In>k__BackingField;
    public static TextWriter Out { get; public set; }
    public static TextWriter Error { get; public set; }
    public static TextReader In { get; public set; }
    private static SystemConsole();
    [CompilerGeneratedAttribute]
public static TextWriter get_Out();
    [CompilerGeneratedAttribute]
public static void set_Out(TextWriter value);
    [CompilerGeneratedAttribute]
public static TextWriter get_Error();
    [CompilerGeneratedAttribute]
public static void set_Error(TextWriter value);
    [CompilerGeneratedAttribute]
public static TextReader get_In();
    [CompilerGeneratedAttribute]
public static void set_In(TextReader value);
    public static void Write(bool value);
    public static void Write(char value);
    public static void Write(Char[] buffer);
    public static void Write(decimal value);
    public static void Write(double value);
    public static void Write(int value);
    public static void Write(long value);
    public static void Write(object value);
    public static void Write(float value);
    public static void Write(string value);
    [CLSCompliantAttribute("False")]
public static void Write(UInt32 value);
    [CLSCompliantAttribute("False")]
public static void Write(ulong value);
    public static void Write(string format, object arg0);
    public static void Write(string format, Object[] arg);
    public static void Write(Char[] buffer, int index, int count);
    public static void Write(string format, object arg0, object arg1);
    public static void Write(string format, object arg0, object arg1, object arg2);
    public static void WriteLine();
    public static void WriteLine(bool value);
    public static void WriteLine(char value);
    public static void WriteLine(Char[] buffer);
    public static void WriteLine(decimal value);
    public static void WriteLine(double value);
    public static void WriteLine(int value);
    public static void WriteLine(long value);
    public static void WriteLine(object value);
    public static void WriteLine(float value);
    public static void WriteLine(string value);
    [CLSCompliantAttribute("False")]
public static void WriteLine(UInt32 value);
    [CLSCompliantAttribute("False")]
public static void WriteLine(ulong value);
    public static void WriteLine(string format, object arg0);
    public static void WriteLine(string format, Object[] arg);
    public static void WriteLine(Char[] buffer, int index, int count);
    public static void WriteLine(string format, object arg0, object arg1);
    public static void WriteLine(string format, object arg0, object arg1, object arg2);
}
internal static class Lucene.Net.Util.SystemProperties : object {
    private static IProperties properties;
    private static SystemProperties();
    public static string GetProperty(string key);
    public static string GetProperty(string key, string defaultValue);
    public static bool GetPropertyAsBoolean(string key);
    public static bool GetPropertyAsBoolean(string key, bool defaultValue);
    public static int GetPropertyAsInt32(string key);
    public static int GetPropertyAsInt32(string key, int defaultValue);
}
public class Lucene.Net.Util.TextWriterInfoStream : InfoStream {
    private static AtomicInt32 MESSAGE_ID;
    protected int m_messageID;
    protected TextWriter m_stream;
    private bool isSystemStream;
    public bool IsSystemStream { get; }
    public TextWriterInfoStream(TextWriter stream);
    public TextWriterInfoStream(TextWriter stream, int messageID);
    private static TextWriterInfoStream();
    public virtual void Message(string component, string message);
    public virtual bool IsEnabled(string component);
    protected virtual void Dispose(bool disposing);
    public virtual bool get_IsSystemStream();
}
public class Lucene.Net.Util.ThreadInterruptedException : Exception {
    public ThreadInterruptedException(Exception interruptedException);
    public ThreadInterruptedException(string message);
    public ThreadInterruptedException(string message, Exception innerException);
    protected ThreadInterruptedException(SerializationInfo info, StreamingContext context);
}
public abstract class Lucene.Net.Util.TimSorter : Sorter {
    internal static int MINRUN;
    internal static int THRESHOLD;
    internal static int STACKSIZE;
    internal static int MIN_GALLOP;
    internal int maxTempSlots;
    internal int minRun;
    internal int to;
    internal int stackSize;
    internal Int32[] runEnds;
    protected TimSorter(int maxTempSlots);
    internal static int MinRun(int length);
    internal virtual int RunLen(int i);
    internal virtual int RunBase(int i);
    internal virtual int RunEnd(int i);
    internal virtual void SetRunEnd(int i, int runEnd);
    internal virtual void PushRunLen(int len);
    internal virtual int NextRun();
    internal virtual void EnsureInvariants();
    internal virtual void ExhaustStack();
    internal virtual void Reset(int from, int to);
    internal virtual void MergeAt(int n);
    internal virtual void Merge(int lo, int mid, int hi);
    public virtual void Sort(int from, int to);
    internal virtual void DoRotate(int lo, int mid, int hi);
    internal virtual void MergeLo(int lo, int mid, int hi);
    internal virtual void MergeHi(int lo, int mid, int hi);
    internal virtual int LowerSaved(int from, int to, int val);
    internal virtual int UpperSaved(int from, int to, int val);
    internal virtual int LowerSaved3(int from, int to, int val);
    internal virtual int UpperSaved3(int from, int to, int val);
    protected abstract virtual void Copy(int src, int dest);
    protected abstract virtual void Save(int i, int len);
    protected abstract virtual void Restore(int i, int j);
    protected abstract virtual int CompareSaved(int i, int j);
}
public static class Lucene.Net.Util.ToStringUtils : object {
    private static Char[] HEX;
    private static ToStringUtils();
    public static string Boost(float boost);
    public static void ByteArray(StringBuilder buffer, Byte[] bytes);
    public static string Int64Hex(long x);
}
public static class Lucene.Net.Util.UnicodeUtil : object {
    public static BytesRef BIG_TERM;
    public static int UNI_SUR_HIGH_START;
    public static int UNI_SUR_HIGH_END;
    public static int UNI_SUR_LOW_START;
    public static int UNI_SUR_LOW_END;
    public static int UNI_REPLACEMENT_CHAR;
    private static long UNI_MAX_BMP;
    private static long HALF_SHIFT;
    private static long HALF_MASK;
    private static int SURROGATE_OFFSET;
    internal static Int32[] utf8CodeLength;
    private static int LEAD_SURROGATE_SHIFT_;
    private static int TRAIL_SURROGATE_MASK_;
    private static int TRAIL_SURROGATE_MIN_VALUE;
    private static int LEAD_SURROGATE_MIN_VALUE;
    private static int SUPPLEMENTARY_MIN_VALUE;
    private static int LEAD_SURROGATE_OFFSET_;
    private static UnicodeUtil();
    public static void UTF16toUTF8(Char[] source, int offset, int length, BytesRef result);
    public static void UTF16toUTF8(ICharSequence s, int offset, int length, BytesRef result);
    public static void UTF16toUTF8(string s, int offset, int length, BytesRef result);
    public static bool ValidUTF16String(ICharSequence s);
    public static bool ValidUTF16String(string s);
    public static bool ValidUTF16String(StringBuilder s);
    public static bool ValidUTF16String(Char[] s, int size);
    private static Int32[] LoadUTF8CodeLength();
    public static int CodePointCount(BytesRef utf8);
    public static void UTF8toUTF32(BytesRef utf8, Int32sRef utf32);
    public static string NewString(Int32[] codePoints, int offset, int count);
    public static Char[] ToCharArray(Int32[] codePoints, int offset, int count);
    public static string ToHexString(string s);
    public static void UTF8toUTF16(Byte[] utf8, int offset, int length, CharsRef chars);
    public static void UTF8toUTF16(BytesRef bytesRef, CharsRef chars);
}
internal class Lucene.Net.Util.Utf8SortedAsUnicodeComparer : object {
    public static Utf8SortedAsUnicodeComparer Instance;
    private static Utf8SortedAsUnicodeComparer();
    public virtual int Compare(BytesRef a, BytesRef b);
}
[ObsoleteAttribute("this comparer is only a transition mechanism")]
internal class Lucene.Net.Util.Utf8SortedAsUtf16Comparer : object {
    public virtual int Compare(BytesRef a, BytesRef b);
}
public class Lucene.Net.Util.VirtualMethod : object {
    private static ISet`1<MethodInfo> singletonSet;
    private Type baseClass;
    private string method;
    private Type[] parameters;
    private ConditionalWeakTable`2<Type, Int32Ref> cache;
    public VirtualMethod(Type baseClass, string method, Type[] parameters);
    private static VirtualMethod();
    public int GetImplementationDistance(Type subclazz);
    public bool IsOverriddenAsOf(Type subclazz);
    private int ReflectImplementationDistance(Type subclazz);
    public static int CompareImplementationDistance(Type clazz, VirtualMethod m1, VirtualMethod m2);
    private static MethodInfo GetMethod(Type clazz, string methodName, BindingFlags bindingFlags, Type[] methodParameters);
    [CompilerGeneratedAttribute]
private Int32Ref <GetImplementationDistance>b__7_0(Type key);
}
public class Lucene.Net.Util.WAH8DocIdSet : DocIdSet {
    private static int MIN_INDEX_INTERVAL;
    public static int DEFAULT_INDEX_INTERVAL;
    private static MonotonicAppendingInt64Buffer SINGLE_ZERO_BUFFER;
    private static WAH8DocIdSet EMPTY;
    private static IComparer`1<Iterator> SERIALIZED_LENGTH_COMPARER;
    private Byte[] data;
    private int cardinality;
    private int indexInterval;
    private MonotonicAppendingInt64Buffer positions;
    private MonotonicAppendingInt64Buffer wordNums;
    public bool IsCacheable { get; }
    public int Cardinality { get; }
    internal WAH8DocIdSet(Byte[] data, int cardinality, int indexInterval, MonotonicAppendingInt64Buffer positions, MonotonicAppendingInt64Buffer wordNums);
    private static WAH8DocIdSet();
    private static MonotonicAppendingInt64Buffer LoadSingleZeroBuffer();
    public static WAH8DocIdSet Intersect(ICollection`1<WAH8DocIdSet> docIdSets);
    public static WAH8DocIdSet Intersect(ICollection`1<WAH8DocIdSet> docIdSets, int indexInterval);
    public static WAH8DocIdSet Union(ICollection`1<WAH8DocIdSet> docIdSets);
    public static WAH8DocIdSet Union(ICollection`1<WAH8DocIdSet> docIdSets, int indexInterval);
    internal static int WordNum(int docID);
    public virtual bool get_IsCacheable();
    public virtual DocIdSetIterator GetIterator();
    internal static int ReadCleanLength(ByteArrayDataInput in, int token);
    internal static int ReadDirtyLength(ByteArrayDataInput in, int token);
    public int get_Cardinality();
    public long RamBytesUsed();
}
[ExtensionAttribute]
public static class Lucene.Net.Util.WAH8DocIdSetExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use Cardinality property instead. This extension method will be removed in 4.8.0 release candidate.")]
[EditorBrowsableAttribute("1")]
public static int Cardinality(WAH8DocIdSet set);
}
internal class Lucene.NoClassDefFoundError : Exception {
    [ObsoleteAttribute("Use NoClassDefFoundError.Create() instead.", "True")]
public NoClassDefFoundError(string message);
    [ObsoleteAttribute("Use NoClassDefFoundError.Create() instead.", "True")]
public NoClassDefFoundError(string message, Exception innerException);
    [ObsoleteAttribute("Use NoClassDefFoundError.Create() instead.", "True")]
public NoClassDefFoundError(Exception cause);
    protected NoClassDefFoundError(SerializationInfo info, StreamingContext context);
    public static Exception Create();
    public static Exception Create(string message);
    public static Exception Create(string message, Exception innerException);
    public static Exception Create(Exception cause);
}
[ObsoleteAttribute(".NET enumerators do not throw when there are no more elements. It is recommended to convert iterators into enumerators and use a MoveNext() method that returns false.")]
internal class Lucene.NoSuchElementException : object {
}
internal class Lucene.NoSuchMethodException : MissingMethodException {
    [ObsoleteAttribute("Use NoSuchMethodException.Create() instead.", "True")]
public NoSuchMethodException(string message);
    [ObsoleteAttribute("Use NoSuchMethodException.Create() instead.", "True")]
public NoSuchMethodException(string message, Exception innerException);
    [ObsoleteAttribute("Use NoSuchMethodException.Create() instead.", "True")]
public NoSuchMethodException(Exception cause);
    protected NoSuchMethodException(SerializationInfo info, StreamingContext context);
    public static Exception Create();
    public static Exception Create(string message);
    public static Exception Create(string message, Exception innerException);
    public static Exception Create(Exception cause);
}
internal class Lucene.NullPointerException : ArgumentNullException {
    [ObsoleteAttribute("Use NullPointerException.Create() instead.", "True")]
public NullPointerException(string message);
    [ObsoleteAttribute("Use NullPointerException.Create() instead.", "True")]
public NullPointerException(string message, Exception innerException);
    [ObsoleteAttribute("Use NullPointerException.Create() instead.", "True")]
public NullPointerException(Exception cause);
    protected NullPointerException(SerializationInfo info, StreamingContext context);
    public static Exception Create();
    public static Exception Create(string message);
    public static Exception Create(string paramName, string message);
    public static Exception Create(string message, Exception innerException);
    public static Exception Create(Exception cause);
}
internal class Lucene.NumberFormatException : FormatException {
    [ObsoleteAttribute("Use NumberFormatException.Create() instead.", "True")]
public NumberFormatException(string message);
    [ObsoleteAttribute("Use NumberFormatException.Create() instead.", "True")]
public NumberFormatException(string message, Exception innerException);
    [ObsoleteAttribute("Use NumberFormatException.Create() instead.", "True")]
public NumberFormatException(Exception cause);
    protected NumberFormatException(SerializationInfo info, StreamingContext context);
    public static Exception Create();
    public static Exception Create(string message);
    public static Exception Create(string message, Exception innerException);
    public static Exception Create(Exception cause);
}
internal class Lucene.OutOfMemoryError : OutOfMemoryException {
    [ObsoleteAttribute("Use OutOfMemoryError.Create() instead.", "True")]
public OutOfMemoryError(string message);
    [ObsoleteAttribute("Use OutOfMemoryError.Create() instead.", "True")]
public OutOfMemoryError(string message, Exception innerException);
    [ObsoleteAttribute("Use OutOfMemoryError.Create() instead.", "True")]
public OutOfMemoryError(Exception cause);
    protected OutOfMemoryError(SerializationInfo info, StreamingContext context);
    public static Exception Create();
    public static Exception Create(string message);
    public static Exception Create(string message, Exception innerException);
    public static Exception Create(Exception cause);
}
internal class Lucene.RuntimeException : Exception {
    [ObsoleteAttribute("Use RuntimeException.Create() instead.", "True")]
public RuntimeException(string message);
    [ObsoleteAttribute("Use RuntimeException.Create() instead.", "True")]
public RuntimeException(string message, Exception innerException);
    [ObsoleteAttribute("Use RuntimeException.Create() instead.", "True")]
public RuntimeException(Exception cause);
    protected RuntimeException(SerializationInfo info, StreamingContext context);
    public static Exception Create();
    public static Exception Create(string message);
    public static Exception Create(string message, Exception innerException);
    public static Exception Create(Exception cause);
}
internal class Lucene.ServiceConfigurationError : InvalidOperationException {
    [ObsoleteAttribute("Use ServiceConfigurationError.Create() instead.", "True")]
public ServiceConfigurationError(string message);
    [ObsoleteAttribute("Use ServiceConfigurationError.Create() instead.", "True")]
public ServiceConfigurationError(string message, Exception innerException);
    [ObsoleteAttribute("Use ServiceConfigurationError.Create() instead.", "True")]
public ServiceConfigurationError(Exception cause);
    private ServiceConfigurationError(bool privateOverload);
    private ServiceConfigurationError(string message, bool privateOverload);
    private ServiceConfigurationError(string message, Exception innerException, bool privateOverload);
    private ServiceConfigurationError(Exception cause, bool privateOverload);
    protected ServiceConfigurationError(SerializationInfo info, StreamingContext context);
    public static Exception Create();
    public static Exception Create(string message);
    public static Exception Create(string message, Exception innerException);
    public static Exception Create(Exception cause);
}
internal class Lucene.ServletException : Exception {
    [ObsoleteAttribute("Use ServletException.Create() instead.", "True")]
public ServletException(string message);
    [ObsoleteAttribute("Use ServletException.Create() instead.", "True")]
public ServletException(string message, Exception innerException);
    [ObsoleteAttribute("Use ServletException.Create() instead.", "True")]
public ServletException(Exception cause);
    protected ServletException(SerializationInfo info, StreamingContext context);
    public static Exception Create();
    public static Exception Create(string message);
    public static Exception Create(string message, Exception innerException);
    public static Exception Create(Exception cause);
}
internal class Lucene.StackOverflowError : Exception {
    [ObsoleteAttribute("Use NoClassDefFoundError.Create() instead.", "True")]
public StackOverflowError(string message);
    [ObsoleteAttribute("Use NoClassDefFoundError.Create() instead.", "True")]
public StackOverflowError(string message, Exception innerException);
    [ObsoleteAttribute("Use NoClassDefFoundError.Create() instead.", "True")]
public StackOverflowError(Exception cause);
    protected StackOverflowError(SerializationInfo info, StreamingContext context);
    public static Exception Create();
    public static Exception Create(string message);
    public static Exception Create(string message, Exception innerException);
    public static Exception Create(Exception cause);
}
internal class Lucene.StringIndexOutOfBoundsException : ArgumentOutOfRangeException {
    [ObsoleteAttribute("Use StringIndexOutOfBoundsException.Create() instead.", "True")]
public StringIndexOutOfBoundsException(string message);
    [ObsoleteAttribute("Use StringIndexOutOfBoundsException.Create() instead.", "True")]
public StringIndexOutOfBoundsException(string message, Exception innerException);
    [ObsoleteAttribute("Use StringIndexOutOfBoundsException.Create() instead.", "True")]
public StringIndexOutOfBoundsException(Exception cause);
    protected StringIndexOutOfBoundsException(SerializationInfo info, StreamingContext context);
    public static Exception Create();
    public static Exception Create(string message);
    public static Exception Create(string paramName, string message);
    public static Exception Create(string paramName, object actualValue, string message);
    public static Exception Create(string message, Exception innerException);
    public static Exception Create(Exception cause);
}
internal class Lucene.UnsupportedOperationException : NotSupportedException {
    [ObsoleteAttribute("Use UnsupportedOperationException.Create() instead.", "True")]
public UnsupportedOperationException(string message);
    [ObsoleteAttribute("Use UnsupportedOperationException.Create() instead.", "True")]
public UnsupportedOperationException(string message, Exception innerException);
    [ObsoleteAttribute("Use UnsupportedOperationException.Create() instead.", "True")]
public UnsupportedOperationException(Exception cause);
    protected UnsupportedOperationException(SerializationInfo info, StreamingContext context);
    public static Exception Create();
    public static Exception Create(string message);
    public static Exception Create(string message, Exception innerException);
    public static Exception Create(Exception cause);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
