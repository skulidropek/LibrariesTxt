public class Lucene.Net.Analysis.Ar.ArabicAnalyzer : StopwordAnalyzerBase {
    public static string DEFAULT_STOPWORD_FILE;
    private CharArraySet stemExclusionSet;
    public static CharArraySet DefaultStopSet { get; }
    public ArabicAnalyzer(LuceneVersion matchVersion);
    public ArabicAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public ArabicAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
[ObsoleteAttribute("(3.1) Use StandardTokenizer instead.")]
public class Lucene.Net.Analysis.Ar.ArabicLetterTokenizer : LetterTokenizer {
    public ArabicLetterTokenizer(LuceneVersion matchVersion, TextReader in);
    public ArabicLetterTokenizer(LuceneVersion matchVersion, AttributeFactory factory, TextReader in);
    protected virtual bool IsTokenChar(int c);
}
[ObsoleteAttribute("(3.1) Use StandardTokenizerFactory instead.")]
public class Lucene.Net.Analysis.Ar.ArabicLetterTokenizerFactory : TokenizerFactory {
    public ArabicLetterTokenizerFactory(IDictionary`2<string, string> args);
    public virtual Tokenizer Create(AttributeFactory factory, TextReader input);
}
public class Lucene.Net.Analysis.Ar.ArabicNormalizationFilter : TokenFilter {
    private ArabicNormalizer normalizer;
    private ICharTermAttribute termAtt;
    public ArabicNormalizationFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Ar.ArabicNormalizationFilterFactory : TokenFilterFactory {
    public ArabicNormalizationFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
    public virtual AbstractAnalysisFactory GetMultiTermComponent();
}
public class Lucene.Net.Analysis.Ar.ArabicNormalizer : object {
    public static char ALEF;
    public static char ALEF_MADDA;
    public static char ALEF_HAMZA_ABOVE;
    public static char ALEF_HAMZA_BELOW;
    public static char YEH;
    public static char DOTLESS_YEH;
    public static char TEH_MARBUTA;
    public static char HEH;
    public static char TATWEEL;
    public static char FATHATAN;
    public static char DAMMATAN;
    public static char KASRATAN;
    public static char FATHA;
    public static char DAMMA;
    public static char KASRA;
    public static char SHADDA;
    public static char SUKUN;
    public virtual int Normalize(Char[] s, int len);
}
public class Lucene.Net.Analysis.Ar.ArabicStemFilter : TokenFilter {
    private ArabicStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public ArabicStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Ar.ArabicStemFilterFactory : TokenFilterFactory {
    public ArabicStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Ar.ArabicStemmer : object {
    public static char ALEF;
    public static char BEH;
    public static char TEH_MARBUTA;
    public static char TEH;
    public static char FEH;
    public static char KAF;
    public static char LAM;
    public static char NOON;
    public static char HEH;
    public static char WAW;
    public static char YEH;
    [CompilerGeneratedAttribute]
private static IList`1<Char[]> <Prefixes>k__BackingField;
    [CompilerGeneratedAttribute]
private static IList`1<Char[]> <Suffixes>k__BackingField;
    public static IList`1<Char[]> Prefixes { get; }
    public static IList`1<Char[]> Suffixes { get; }
    private static ArabicStemmer();
    [CompilerGeneratedAttribute]
public static IList`1<Char[]> get_Prefixes();
    [CompilerGeneratedAttribute]
public static IList`1<Char[]> get_Suffixes();
    private static IList`1<Char[]> InitializePrefix();
    private static IList`1<Char[]> InitializeSuffix();
    public virtual int Stem(Char[] s, int len);
    public virtual int StemPrefix(Char[] s, int len);
    public virtual int StemSuffix(Char[] s, int len);
    internal virtual bool StartsWithCheckLength(Char[] s, int len, Char[] prefix);
    internal virtual bool EndsWithCheckLength(Char[] s, int len, Char[] suffix);
}
public class Lucene.Net.Analysis.Bg.BulgarianAnalyzer : StopwordAnalyzerBase {
    public static string DEFAULT_STOPWORD_FILE;
    private CharArraySet stemExclusionSet;
    public static CharArraySet DefaultStopSet { get; }
    public BulgarianAnalyzer(LuceneVersion matchVersion);
    public BulgarianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public BulgarianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Bg.BulgarianStemFilter : TokenFilter {
    private BulgarianStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public BulgarianStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Bg.BulgarianStemFilterFactory : TokenFilterFactory {
    public BulgarianStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Bg.BulgarianStemmer : object {
    public virtual int Stem(Char[] s, int len);
    private int RemoveArticle(Char[] s, int len);
    private int RemovePlural(Char[] s, int len);
}
public class Lucene.Net.Analysis.Br.BrazilianAnalyzer : StopwordAnalyzerBase {
    public static string DEFAULT_STOPWORD_FILE;
    private CharArraySet excltable;
    public static CharArraySet DefaultStopSet { get; }
    public BrazilianAnalyzer(LuceneVersion matchVersion);
    public BrazilianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public BrazilianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Br.BrazilianStemFilter : TokenFilter {
    private BrazilianStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public BrazilianStemFilter(TokenStream in);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Br.BrazilianStemFilterFactory : TokenFilterFactory {
    public BrazilianStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream in);
}
public class Lucene.Net.Analysis.Br.BrazilianStemmer : object {
    private static CultureInfo locale;
    private string TERM;
    private string CT;
    private string R1;
    private string R2;
    private string RV;
    private static BrazilianStemmer();
    protected internal virtual string Stem(string term);
    private bool IsStemmable(string term);
    private bool IsIndexable(string term);
    private bool IsVowel(char value);
    private string GetR1(string value);
    private string GetRV(string value);
    private string ChangeTerm(string value);
    private bool Suffix(string value, string suffix);
    private string ReplaceSuffix(string value, string toReplace, string changeTo);
    private string RemoveSuffix(string value, string toRemove);
    private bool SuffixPreceded(string value, string suffix, string preceded);
    private void CreateCT(string term);
    private bool Step1();
    private bool Step2();
    private void Step3();
    private void Step4();
    private void Step5();
    public virtual string Log();
}
public class Lucene.Net.Analysis.Ca.CatalanAnalyzer : StopwordAnalyzerBase {
    private CharArraySet stemExclusionSet;
    public static string DEFAULT_STOPWORD_FILE;
    private static CharArraySet DEFAULT_ARTICLES;
    public static CharArraySet DefaultStopSet { get; }
    public CatalanAnalyzer(LuceneVersion matchVersion);
    public CatalanAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public CatalanAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    private static CatalanAnalyzer();
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public abstract class Lucene.Net.Analysis.CharFilters.BaseCharFilter : CharFilter {
    private Int32[] offsets;
    private Int32[] diffs;
    private int size;
    protected int LastCumulativeDiff { get; }
    public BaseCharFilter(TextReader in);
    protected virtual int Correct(int currentOff);
    protected virtual int get_LastCumulativeDiff();
    protected virtual void AddOffCorrectMap(int off, int cumulativeDiff);
}
public class Lucene.Net.Analysis.CharFilters.HTMLStripCharFilter : BaseCharFilter {
    private static int YYEOF;
    private static int ZZ_BUFFERSIZE;
    private static int YYINITIAL;
    private static int AMPERSAND;
    private static int NUMERIC_CHARACTER;
    private static int CHARACTER_REFERENCE_TAIL;
    private static int LEFT_ANGLE_BRACKET;
    private static int BANG;
    private static int COMMENT;
    private static int SCRIPT;
    private static int SCRIPT_COMMENT;
    private static int LEFT_ANGLE_BRACKET_SLASH;
    private static int LEFT_ANGLE_BRACKET_SPACE;
    private static int CDATA;
    private static int SERVER_SIDE_INCLUDE;
    private static int SINGLE_QUOTED_STRING;
    private static int DOUBLE_QUOTED_STRING;
    private static int END_TAG_TAIL_INCLUDE;
    private static int END_TAG_TAIL_EXCLUDE;
    private static int END_TAG_TAIL_SUBSTITUTE;
    private static int START_TAG_TAIL_INCLUDE;
    private static int START_TAG_TAIL_EXCLUDE;
    private static int START_TAG_TAIL_SUBSTITUTE;
    private static int STYLE;
    private static int STYLE_COMMENT;
    private static Int32[] ZZ_LEXSTATE;
    private static string ZZ_CMAP_PACKED;
    private static Char[] ZZ_CMAP;
    private static Int32[] ZZ_ACTION;
    private static string ZZ_ACTION_PACKED_0;
    private static Int32[] ZZ_ROWMAP;
    private static string ZZ_ROWMAP_PACKED_0;
    private static Int32[] ZZ_TRANS;
    private static string ZZ_TRANS_PACKED_0;
    private static string ZZ_TRANS_PACKED_1;
    private static string ZZ_TRANS_PACKED_2;
    private static string ZZ_TRANS_PACKED_3;
    private static string ZZ_TRANS_PACKED_4;
    private static string ZZ_TRANS_PACKED_5;
    private static string ZZ_TRANS_PACKED_6;
    private static string ZZ_TRANS_PACKED_7;
    private static string ZZ_TRANS_PACKED_8;
    private static string ZZ_TRANS_PACKED_9;
    private static string ZZ_TRANS_PACKED_10;
    private static string ZZ_TRANS_PACKED_11;
    private static string ZZ_TRANS_PACKED_12;
    private static string ZZ_TRANS_PACKED_13;
    private static int ZZ_UNKNOWN_ERROR;
    private static int ZZ_NO_MATCH;
    private static int ZZ_PUSHBACK_2BIG;
    private static String[] ZZ_ERROR_MSG;
    private static Int32[] ZZ_ATTRIBUTE;
    private static string ZZ_ATTRIBUTE_PACKED_0;
    private BufferedCharFilter zzReader;
    private int zzState;
    private int zzLexicalState;
    private Char[] zzBuffer;
    private int zzMarkedPos;
    private int zzCurrentPos;
    private int zzStartRead;
    private int zzEndRead;
    private int yychar;
    private bool zzAtEOF;
    private bool zzEOFDone;
    private static IDictionary`2<string, string> upperCaseVariantsAccepted;
    private static CharArrayMap`1<char> entityValues;
    private static int INITIAL_INPUT_SEGMENT_SIZE;
    private static char BLOCK_LEVEL_START_TAG_REPLACEMENT;
    private static char BLOCK_LEVEL_END_TAG_REPLACEMENT;
    private static char BR_START_TAG_REPLACEMENT;
    private static char BR_END_TAG_REPLACEMENT;
    private static char SCRIPT_REPLACEMENT;
    private static char STYLE_REPLACEMENT;
    private static char REPLACEMENT_CHARACTER;
    private CharArraySet escapedTags;
    private int inputStart;
    private int cumulativeDiff;
    private bool escapeBR;
    private bool escapeSCRIPT;
    private bool escapeSTYLE;
    private int restoreState;
    private int previousRestoreState;
    private int outputCharCount;
    private int eofReturnValue;
    private TextSegment inputSegment;
    private TextSegment outputSegment;
    private TextSegment entitySegment;
    internal static int InitialBufferSize { get; }
    private int YyState { get; }
    private int YyLength { get; }
    public HTMLStripCharFilter(TextReader source);
    public HTMLStripCharFilter(TextReader source, ICollection`1<string> escapedTags);
    private static HTMLStripCharFilter();
    private static Int32[] ZzUnpackAction();
    private static int ZzUnpackAction(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackRowMap();
    private static int ZzUnpackRowMap(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackTrans();
    private static int ZzUnpackTrans(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackAttribute();
    private static int ZzUnpackAttribute(string packed, int offset, Int32[] result);
    private static CharArrayMap`1<char> LoadEntityValues();
    private static BufferedCharFilter GetBufferedReader(TextReader reader);
    public virtual int Read();
    public virtual int Read(Char[] cbuf, int off, int len);
    protected virtual void Dispose(bool disposing);
    internal static int get_InitialBufferSize();
    private static Char[] ZzUnpackCMap(string packed);
    private bool ZzRefill();
    private void YyClose();
    private void YyReset(BufferedCharFilter reader);
    private int get_YyState();
    private void YyBegin(int newState);
    private string YyText();
    private char YyCharAt(int pos);
    private int get_YyLength();
    private void ZzScanError(int errorCode);
    private void YyPushBack(int number);
    private void ZzDoEOF();
    private int NextChar();
}
public class Lucene.Net.Analysis.CharFilters.HTMLStripCharFilterFactory : CharFilterFactory {
    private ICollection`1<string> escapedTags;
    public HTMLStripCharFilterFactory(IDictionary`2<string, string> args);
    public virtual TextReader Create(TextReader input);
}
public class Lucene.Net.Analysis.CharFilters.MappingCharFilter : BaseCharFilter {
    private Outputs`1<CharsRef> outputs;
    private FST`1<CharsRef> map;
    private BytesReader fstReader;
    private RollingCharBuffer buffer;
    private Arc`1<CharsRef> scratchArc;
    private IDictionary`2<Nullable`1<char>, Arc`1<CharsRef>> cachedRootArcs;
    private CharsRef replacement;
    private int replacementPointer;
    private int inputOff;
    private BufferedCharFilter _input;
    public MappingCharFilter(NormalizeCharMap normMap, TextReader in);
    private static BufferedCharFilter GetBufferedReader(TextReader reader);
    public virtual void Reset();
    public virtual int Read();
    public virtual int Read(Char[] cbuf, int off, int len);
}
public class Lucene.Net.Analysis.CharFilters.MappingCharFilterFactory : CharFilterFactory {
    protected internal NormalizeCharMap m_normMap;
    private string mapping;
    private static Regex p;
    private Char[] out;
    public MappingCharFilterFactory(IDictionary`2<string, string> args);
    private static MappingCharFilterFactory();
    public virtual void Inform(IResourceLoader loader);
    public virtual TextReader Create(TextReader input);
    protected virtual void ParseRules(IList`1<string> rules, Builder builder);
    protected internal virtual string ParseString(string s);
    public virtual AbstractAnalysisFactory GetMultiTermComponent();
}
public class Lucene.Net.Analysis.CharFilters.NormalizeCharMap : object {
    internal FST`1<CharsRef> map;
    internal IDictionary`2<Nullable`1<char>, Arc`1<CharsRef>> cachedRootArcs;
    private NormalizeCharMap(FST`1<CharsRef> map);
}
public class Lucene.Net.Analysis.Cjk.CJKAnalyzer : StopwordAnalyzerBase {
    public static string DEFAULT_STOPWORD_FILE;
    public static CharArraySet DefaultStopSet { get; }
    public CJKAnalyzer(LuceneVersion matchVersion);
    public CJKAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Cjk.CJKBigramFilter : TokenFilter {
    public static string DOUBLE_TYPE;
    public static string SINGLE_TYPE;
    private static string HAN_TYPE;
    private static string HIRAGANA_TYPE;
    private static string KATAKANA_TYPE;
    private static string HANGUL_TYPE;
    private static string NO;
    private string doHan;
    private string doHiragana;
    private string doKatakana;
    private string doHangul;
    private bool outputUnigrams;
    private bool ngramState;
    private ICharTermAttribute termAtt;
    private ITypeAttribute typeAtt;
    private IOffsetAttribute offsetAtt;
    private IPositionIncrementAttribute posIncAtt;
    private IPositionLengthAttribute posLengthAtt;
    private Int32[] buffer;
    private Int32[] startOffset;
    private Int32[] endOffset;
    private int bufferLen;
    private int index;
    private int lastEndOffset;
    private bool exhausted;
    private State loneState;
    private bool HasBufferedBigram { get; }
    private bool HasBufferedUnigram { get; }
    public CJKBigramFilter(TokenStream in);
    public CJKBigramFilter(TokenStream in, CJKScript flags);
    public CJKBigramFilter(TokenStream in, CJKScript flags, bool outputUnigrams);
    private static CJKBigramFilter();
    public virtual bool IncrementToken();
    private bool DoNext();
    private void Refill();
    private void FlushBigram();
    private void FlushUnigram();
    private bool get_HasBufferedBigram();
    private bool get_HasBufferedUnigram();
    public virtual void Reset();
}
public class Lucene.Net.Analysis.Cjk.CJKBigramFilterFactory : TokenFilterFactory {
    private CJKScript flags;
    private bool outputUnigrams;
    public CJKBigramFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
[FlagsAttribute]
public enum Lucene.Net.Analysis.Cjk.CJKScript : Enum {
    public int value__;
    public static CJKScript HAN;
    public static CJKScript HIRAGANA;
    public static CJKScript KATAKANA;
    public static CJKScript HANGUL;
    public static CJKScript ALL;
}
[ObsoleteAttribute("Use StandardTokenizer, CJKWidthFilter, CJKBigramFilter, and LowerCaseFilter instead.")]
public class Lucene.Net.Analysis.Cjk.CJKTokenizer : Tokenizer {
    internal static int WORD_TYPE;
    internal static int SINGLE_TOKEN_TYPE;
    internal static int DOUBLE_TOKEN_TYPE;
    internal static String[] TOKEN_TYPE_NAMES;
    private static int MAX_WORD_LEN;
    private static int IO_BUFFER_SIZE;
    private static Regex HALFWIDTH_AND_FULLWIDTH_FORMS;
    private static Regex BASIC_LATIN;
    private int offset;
    private int bufferIndex;
    private int dataLen;
    private Char[] buffer;
    private Char[] ioBuffer;
    private int tokenType;
    private bool preIsTokened;
    private ICharTermAttribute termAtt;
    private IOffsetAttribute offsetAtt;
    private ITypeAttribute typeAtt;
    public CJKTokenizer(TextReader in);
    public CJKTokenizer(AttributeFactory factory, TextReader in);
    private static CJKTokenizer();
    private void Init();
    public virtual bool IncrementToken();
    public sealed virtual void End();
    public virtual void Reset();
}
[ObsoleteAttribute("Use CJKBigramFilterFactory instead.")]
public class Lucene.Net.Analysis.Cjk.CJKTokenizerFactory : TokenizerFactory {
    public CJKTokenizerFactory(IDictionary`2<string, string> args);
    public virtual Tokenizer Create(AttributeFactory factory, TextReader in);
}
public class Lucene.Net.Analysis.Cjk.CJKWidthFilter : TokenFilter {
    private ICharTermAttribute termAtt;
    private static Char[] KANA_NORM;
    private static SByte[] KANA_COMBINE_VOICED;
    private static SByte[] KANA_COMBINE_HALF_VOICED;
    public CJKWidthFilter(TokenStream input);
    private static CJKWidthFilter();
    public virtual bool IncrementToken();
    private static bool Combine(Char[] text, int pos, char ch);
}
public class Lucene.Net.Analysis.Cjk.CJKWidthFilterFactory : TokenFilterFactory {
    public CJKWidthFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
    public virtual AbstractAnalysisFactory GetMultiTermComponent();
}
public class Lucene.Net.Analysis.Ckb.SoraniAnalyzer : StopwordAnalyzerBase {
    private CharArraySet stemExclusionSet;
    public static string DEFAULT_STOPWORD_FILE;
    public static CharArraySet DefaultStopSet { get; }
    public SoraniAnalyzer(LuceneVersion matchVersion);
    public SoraniAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public SoraniAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Ckb.SoraniNormalizationFilter : TokenFilter {
    private SoraniNormalizer normalizer;
    private ICharTermAttribute termAtt;
    public SoraniNormalizationFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Ckb.SoraniNormalizationFilterFactory : TokenFilterFactory {
    public SoraniNormalizationFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
    public virtual AbstractAnalysisFactory GetMultiTermComponent();
}
public class Lucene.Net.Analysis.Ckb.SoraniNormalizer : object {
    internal static char YEH;
    internal static char DOTLESS_YEH;
    internal static char FARSI_YEH;
    internal static char KAF;
    internal static char KEHEH;
    internal static char HEH;
    internal static char AE;
    internal static char ZWNJ;
    internal static char HEH_DOACHASHMEE;
    internal static char TEH_MARBUTA;
    internal static char REH;
    internal static char RREH;
    internal static char RREH_ABOVE;
    internal static char TATWEEL;
    internal static char FATHATAN;
    internal static char DAMMATAN;
    internal static char KASRATAN;
    internal static char FATHA;
    internal static char DAMMA;
    internal static char KASRA;
    internal static char SHADDA;
    internal static char SUKUN;
    public virtual int Normalize(Char[] s, int len);
}
public class Lucene.Net.Analysis.Ckb.SoraniStemFilter : TokenFilter {
    private SoraniStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public SoraniStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Ckb.SoraniStemFilterFactory : TokenFilterFactory {
    public SoraniStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Ckb.SoraniStemmer : object {
    public virtual int Stem(Char[] s, int len);
}
[ObsoleteAttribute("(3.1) Use StandardAnalyzer instead, which has the same functionality.")]
public class Lucene.Net.Analysis.Cn.ChineseAnalyzer : Analyzer {
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
[ObsoleteAttribute("(3.1) Use StopFilter instead, which has the same functionality.")]
public class Lucene.Net.Analysis.Cn.ChineseFilter : TokenFilter {
    public static String[] STOP_WORDS;
    private CharArraySet stopTable;
    private ICharTermAttribute termAtt;
    public ChineseFilter(TokenStream in);
    private static ChineseFilter();
    public virtual bool IncrementToken();
}
[ObsoleteAttribute("Use StopFilterFactory instead.")]
public class Lucene.Net.Analysis.Cn.ChineseFilterFactory : TokenFilterFactory {
    public ChineseFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream in);
}
[ObsoleteAttribute("(3.1) Use StandardTokenizer instead, which has the same functionality.")]
public class Lucene.Net.Analysis.Cn.ChineseTokenizer : Tokenizer {
    private int offset;
    private int bufferIndex;
    private int dataLen;
    private static int MAX_WORD_LEN;
    private static int IO_BUFFER_SIZE;
    private Char[] buffer;
    private Char[] ioBuffer;
    private int length;
    private int start;
    private ICharTermAttribute termAtt;
    private IOffsetAttribute offsetAtt;
    public ChineseTokenizer(TextReader in);
    public ChineseTokenizer(AttributeFactory factory, TextReader in);
    private void Init();
    private void Push(char c);
    private bool Flush();
    public virtual bool IncrementToken();
    public sealed virtual void End();
    public virtual void Reset();
}
[ObsoleteAttribute("Use StandardTokenizerFactory instead.")]
public class Lucene.Net.Analysis.Cn.ChineseTokenizerFactory : TokenizerFactory {
    public ChineseTokenizerFactory(IDictionary`2<string, string> args);
    public virtual Tokenizer Create(AttributeFactory factory, TextReader input);
}
public class Lucene.Net.Analysis.CommonGrams.CommonGramsFilter : TokenFilter {
    public static string GRAM_TYPE;
    private static char SEPARATOR;
    private CharArraySet commonWords;
    private StringBuilder buffer;
    private ICharTermAttribute termAttribute;
    private IOffsetAttribute offsetAttribute;
    private ITypeAttribute typeAttribute;
    private IPositionIncrementAttribute posIncAttribute;
    private IPositionLengthAttribute posLenAttribute;
    private int lastStartOffset;
    private bool lastWasCommon;
    private State savedState;
    private bool IsCommon { get; }
    public CommonGramsFilter(LuceneVersion matchVersion, TokenStream input, CharArraySet commonWords);
    public virtual bool IncrementToken();
    public virtual void Reset();
    private bool get_IsCommon();
    private void SaveTermBuffer();
    private void GramToken();
}
public class Lucene.Net.Analysis.CommonGrams.CommonGramsFilterFactory : TokenFilterFactory {
    private CharArraySet commonWords;
    private string commonWordFiles;
    private string format;
    private bool ignoreCase;
    public bool IgnoreCase { get; }
    public CharArraySet CommonWords { get; }
    public CommonGramsFilterFactory(IDictionary`2<string, string> args);
    public virtual void Inform(IResourceLoader loader);
    public virtual bool get_IgnoreCase();
    public virtual CharArraySet get_CommonWords();
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.CommonGrams.CommonGramsQueryFilter : TokenFilter {
    private ITypeAttribute typeAttribute;
    private IPositionIncrementAttribute posIncAttribute;
    private State previous;
    private string previousType;
    private bool exhausted;
    public bool IsGramType { get; }
    public CommonGramsQueryFilter(CommonGramsFilter input);
    public virtual void Reset();
    public virtual bool IncrementToken();
    public bool get_IsGramType();
}
public class Lucene.Net.Analysis.CommonGrams.CommonGramsQueryFilterFactory : CommonGramsFilterFactory {
    public CommonGramsQueryFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public abstract class Lucene.Net.Analysis.Compound.CompoundWordTokenFilterBase : TokenFilter {
    public static int DEFAULT_MIN_WORD_SIZE;
    public static int DEFAULT_MIN_SUBWORD_SIZE;
    public static int DEFAULT_MAX_SUBWORD_SIZE;
    protected LuceneVersion m_matchVersion;
    protected CharArraySet m_dictionary;
    protected Queue`1<CompoundToken> m_tokens;
    protected int m_minWordSize;
    protected int m_minSubwordSize;
    protected int m_maxSubwordSize;
    protected bool m_onlyLongestMatch;
    protected ICharTermAttribute m_termAtt;
    protected IOffsetAttribute m_offsetAtt;
    private IPositionIncrementAttribute posIncAtt;
    private State current;
    protected CompoundWordTokenFilterBase(LuceneVersion matchVersion, TokenStream input, CharArraySet dictionary, bool onlyLongestMatch);
    protected CompoundWordTokenFilterBase(LuceneVersion matchVersion, TokenStream input, CharArraySet dictionary);
    protected CompoundWordTokenFilterBase(LuceneVersion matchVersion, TokenStream input, CharArraySet dictionary, int minWordSize, int minSubwordSize, int maxSubwordSize, bool onlyLongestMatch);
    public sealed virtual bool IncrementToken();
    protected abstract virtual void Decompose();
    public virtual void Reset();
}
public class Lucene.Net.Analysis.Compound.DictionaryCompoundWordTokenFilter : CompoundWordTokenFilterBase {
    public DictionaryCompoundWordTokenFilter(LuceneVersion matchVersion, TokenStream input, CharArraySet dictionary);
    public DictionaryCompoundWordTokenFilter(LuceneVersion matchVersion, TokenStream input, CharArraySet dictionary, int minWordSize, int minSubwordSize, int maxSubwordSize, bool onlyLongestMatch);
    protected virtual void Decompose();
}
public class Lucene.Net.Analysis.Compound.DictionaryCompoundWordTokenFilterFactory : TokenFilterFactory {
    private CharArraySet dictionary;
    private string dictFile;
    private int minWordSize;
    private int minSubwordSize;
    private int maxSubwordSize;
    private bool onlyLongestMatch;
    public DictionaryCompoundWordTokenFilterFactory(IDictionary`2<string, string> args);
    public virtual void Inform(IResourceLoader loader);
    public virtual TokenStream Create(TokenStream input);
}
[DefaultMemberAttribute("Item")]
public class Lucene.Net.Analysis.Compound.Hyphenation.ByteVector : object {
    private static int DEFAULT_BLOCK_SIZE;
    private int blockSize;
    private Byte[] array;
    private int n;
    [WritableArrayAttribute]
public Byte[] Array { get; }
    public byte Item { get; public set; }
    public int Length { get; }
    public int Capacity { get; }
    public ByteVector(int capacity);
    public ByteVector(Byte[] a);
    public ByteVector(Byte[] a, int capacity);
    public virtual Byte[] get_Array();
    public virtual byte get_Item(int index);
    public virtual void set_Item(int index, byte value);
    public virtual int get_Length();
    public virtual int get_Capacity();
    public virtual int Alloc(int size);
    public virtual void TrimToSize();
}
[DefaultMemberAttribute("Item")]
public class Lucene.Net.Analysis.Compound.Hyphenation.CharVector : object {
    private static int DEFAULT_BLOCK_SIZE;
    private int blockSize;
    private Char[] array;
    private int n;
    [WritableArrayAttribute]
public Char[] Array { get; }
    public char Item { get; public set; }
    public int Length { get; }
    public int Capacity { get; }
    public CharVector(int capacity);
    public CharVector(Char[] a);
    public CharVector(Char[] a, int capacity);
    public virtual void Clear();
    public virtual object Clone();
    public virtual Char[] get_Array();
    public virtual char get_Item(int index);
    public virtual void set_Item(int index, char value);
    public virtual int get_Length();
    public virtual int get_Capacity();
    public virtual int Alloc(int size);
    public virtual void TrimToSize();
}
public class Lucene.Net.Analysis.Compound.Hyphenation.Hyphen : object {
    [CompilerGeneratedAttribute]
private string <PreBreak>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NoBreak>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PostBreak>k__BackingField;
    public string PreBreak { get; public set; }
    public string NoBreak { get; public set; }
    public string PostBreak { get; public set; }
    internal Hyphen(string pre, string no, string post);
    internal Hyphen(string pre);
    [CompilerGeneratedAttribute]
public string get_PreBreak();
    [CompilerGeneratedAttribute]
public void set_PreBreak(string value);
    [CompilerGeneratedAttribute]
public string get_NoBreak();
    [CompilerGeneratedAttribute]
public void set_NoBreak(string value);
    [CompilerGeneratedAttribute]
public string get_PostBreak();
    [CompilerGeneratedAttribute]
public void set_PostBreak(string value);
    public virtual string ToString();
}
public class Lucene.Net.Analysis.Compound.Hyphenation.Hyphenation : object {
    private Int32[] hyphenPoints;
    public int Length { get; }
    [WritableArrayAttribute]
public Int32[] HyphenationPoints { get; }
    internal Hyphenation(Int32[] points);
    public virtual int get_Length();
    public virtual Int32[] get_HyphenationPoints();
}
public class Lucene.Net.Analysis.Compound.Hyphenation.HyphenationTree : TernaryTree {
    protected ByteVector m_vspace;
    protected IDictionary`2<string, IList`1<object>> m_stoplist;
    protected TernaryTree m_classmap;
    private TernaryTree ivalues;
    protected virtual int PackValues(string values);
    protected virtual string UnpackValues(int k);
    public virtual void LoadPatterns(string filename);
    public virtual void LoadPatterns(string filename, Encoding encoding);
    public virtual void LoadPatterns(FileInfo f);
    public virtual void LoadPatterns(FileInfo f, Encoding encoding);
    public virtual void LoadPatterns(Stream source);
    public virtual void LoadPatterns(Stream source, Encoding encoding);
    public virtual void LoadPatterns(XmlReader source);
    public virtual string FindPattern(string pat);
    protected virtual int HStrCmp(Char[] s, int si, Char[] t, int ti);
    protected virtual Byte[] GetValues(int k);
    protected virtual void SearchPatterns(Char[] word, int index, Byte[] il);
    public virtual Hyphenation Hyphenate(string word, int remainCharCount, int pushCharCount);
    public virtual Hyphenation Hyphenate(Char[] w, int offset, int len, int remainCharCount, int pushCharCount);
    public virtual void AddClass(string chargroup);
    public virtual void AddException(string word, IList`1<object> hyphenatedword);
    public virtual void AddPattern(string pattern, string ivalue);
}
public interface Lucene.Net.Analysis.Compound.Hyphenation.IPatternConsumer {
    public abstract virtual void AddClass(string chargroup);
    public abstract virtual void AddException(string word, IList`1<object> hyphenatedword);
    public abstract virtual void AddPattern(string pattern, string values);
}
public class Lucene.Net.Analysis.Compound.Hyphenation.PatternParser : object {
    internal int currElement;
    internal IPatternConsumer consumer;
    internal StringBuilder token;
    internal IList`1<object> exception;
    internal char hyphenChar;
    internal string errMsg;
    internal static int ELEM_CLASSES;
    internal static int ELEM_EXCEPTIONS;
    internal static int ELEM_PATTERNS;
    internal static int ELEM_HYPHEN;
    public IPatternConsumer Consumer { get; public set; }
    public PatternParser(IPatternConsumer consumer);
    public virtual IPatternConsumer get_Consumer();
    public virtual void set_Consumer(IPatternConsumer value);
    public virtual void Parse(string path);
    public virtual void Parse(string path, Encoding encoding);
    public virtual void Parse(FileInfo file);
    public virtual void Parse(FileInfo file, Encoding encoding);
    public virtual void Parse(Stream xmlStream);
    public virtual void Parse(XmlReader source);
    private void ParseNode(XmlReader node);
    private XmlReaderSettings GetXmlReaderSettings();
    private IDictionary`2<string, string> GetAttributes(XmlReader node);
    protected virtual string ReadToken(StringBuilder chars);
    protected static string GetPattern(string word);
    protected virtual IList`1<object> NormalizeException(IList`1<T1> ex);
    protected virtual string GetExceptionWord(IList`1<T1> ex);
    protected static string GetInterletterValues(string pat);
    public virtual void StartElement(string uri, string local, string raw, IDictionary`2<string, string> attrs);
    public virtual void EndElement(string uri, string local, string raw);
    public virtual void Characters(Char[] ch, int start, int length);
}
public class Lucene.Net.Analysis.Compound.Hyphenation.TernaryTree : object {
    protected Char[] m_lo;
    protected Char[] m_hi;
    protected Char[] m_eq;
    protected Char[] m_sc;
    protected CharVector m_kv;
    protected char m_root;
    protected char m_freenode;
    protected int m_length;
    protected static int BLOCK_SIZE;
    public int Length { get; }
    protected virtual void Init();
    public virtual void Insert(string key, char val);
    public virtual void Insert(Char[] key, int start, char val);
    private char Insert(char p, Char[] key, int start, char val);
    public static int StrCmp(Char[] a, int startA, Char[] b, int startB);
    public static int StrCmp(string str, Char[] a, int start);
    public static void StrCpy(Char[] dst, int di, Char[] src, int si);
    public static int StrLen(Char[] a, int start);
    public static int StrLen(Char[] a);
    public virtual int Find(string key);
    public virtual int Find(Char[] key, int start);
    public virtual bool Knows(string key);
    private void RedimNodeArrays(int newsize);
    public virtual int get_Length();
    public virtual object Clone();
    protected virtual void InsertBalanced(String[] k, Char[] v, int offset, int n);
    public virtual void Balance();
    public virtual void TrimToSize();
    private void Compact(CharVector kx, TernaryTree map, char p);
    public virtual IEnumerator`1<string> GetEnumerator();
    public virtual void PrintStats(TextWriter out);
}
public class Lucene.Net.Analysis.Compound.HyphenationCompoundWordTokenFilter : CompoundWordTokenFilterBase {
    private HyphenationTree hyphenator;
    public HyphenationCompoundWordTokenFilter(LuceneVersion matchVersion, TokenStream input, HyphenationTree hyphenator, CharArraySet dictionary);
    public HyphenationCompoundWordTokenFilter(LuceneVersion matchVersion, TokenStream input, HyphenationTree hyphenator, CharArraySet dictionary, int minWordSize, int minSubwordSize, int maxSubwordSize, bool onlyLongestMatch);
    public HyphenationCompoundWordTokenFilter(LuceneVersion matchVersion, TokenStream input, HyphenationTree hyphenator, int minWordSize, int minSubwordSize, int maxSubwordSize);
    public HyphenationCompoundWordTokenFilter(LuceneVersion matchVersion, TokenStream input, HyphenationTree hyphenator);
    public static HyphenationTree GetHyphenationTree(string hyphenationFilename);
    public static HyphenationTree GetHyphenationTree(string hyphenationFilename, Encoding encoding);
    public static HyphenationTree GetHyphenationTree(FileInfo hyphenationFile);
    public static HyphenationTree GetHyphenationTree(FileInfo hyphenationFile, Encoding encoding);
    public static HyphenationTree GetHyphenationTree(Stream hyphenationSource);
    public static HyphenationTree GetHyphenationTree(Stream hyphenationSource, Encoding encoding);
    protected virtual void Decompose();
}
public class Lucene.Net.Analysis.Compound.HyphenationCompoundWordTokenFilterFactory : TokenFilterFactory {
    private CharArraySet dictionary;
    private HyphenationTree hyphenator;
    private string dictFile;
    private string hypFile;
    private string encoding;
    private int minWordSize;
    private int minSubwordSize;
    private int maxSubwordSize;
    private bool onlyLongestMatch;
    public HyphenationCompoundWordTokenFilterFactory(IDictionary`2<string, string> args);
    public virtual void Inform(IResourceLoader loader);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Core.KeywordAnalyzer : Analyzer {
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Core.KeywordTokenizer : Tokenizer {
    public static int DEFAULT_BUFFER_SIZE;
    private bool done;
    private int finalOffset;
    private ICharTermAttribute termAtt;
    private IOffsetAttribute offsetAtt;
    public KeywordTokenizer(TextReader input);
    public KeywordTokenizer(TextReader input, int bufferSize);
    public KeywordTokenizer(AttributeFactory factory, TextReader input, int bufferSize);
    public sealed virtual bool IncrementToken();
    public sealed virtual void End();
    public virtual void Reset();
}
public class Lucene.Net.Analysis.Core.KeywordTokenizerFactory : TokenizerFactory {
    public KeywordTokenizerFactory(IDictionary`2<string, string> args);
    public virtual Tokenizer Create(AttributeFactory factory, TextReader input);
}
public class Lucene.Net.Analysis.Core.LetterTokenizer : CharTokenizer {
    public LetterTokenizer(LuceneVersion matchVersion, TextReader in);
    public LetterTokenizer(LuceneVersion matchVersion, AttributeFactory factory, TextReader in);
    protected virtual bool IsTokenChar(int c);
}
public class Lucene.Net.Analysis.Core.LetterTokenizerFactory : TokenizerFactory {
    public LetterTokenizerFactory(IDictionary`2<string, string> args);
    public virtual Tokenizer Create(AttributeFactory factory, TextReader input);
}
public class Lucene.Net.Analysis.Core.LowerCaseFilter : TokenFilter {
    private CharacterUtils charUtils;
    private ICharTermAttribute termAtt;
    public LowerCaseFilter(LuceneVersion matchVersion, TokenStream in);
    public sealed virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Core.LowerCaseFilterFactory : TokenFilterFactory {
    public LowerCaseFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
    public virtual AbstractAnalysisFactory GetMultiTermComponent();
}
public class Lucene.Net.Analysis.Core.LowerCaseTokenizer : LetterTokenizer {
    public LowerCaseTokenizer(LuceneVersion matchVersion, TextReader in);
    public LowerCaseTokenizer(LuceneVersion matchVersion, AttributeFactory factory, TextReader in);
    protected virtual int Normalize(int c);
}
public class Lucene.Net.Analysis.Core.LowerCaseTokenizerFactory : TokenizerFactory {
    public LowerCaseTokenizerFactory(IDictionary`2<string, string> args);
    public virtual Tokenizer Create(AttributeFactory factory, TextReader input);
    public virtual AbstractAnalysisFactory GetMultiTermComponent();
}
public class Lucene.Net.Analysis.Core.SimpleAnalyzer : Analyzer {
    private LuceneVersion matchVersion;
    public SimpleAnalyzer(LuceneVersion matchVersion);
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Core.StopAnalyzer : StopwordAnalyzerBase {
    public static CharArraySet ENGLISH_STOP_WORDS_SET;
    public StopAnalyzer(LuceneVersion matchVersion);
    public StopAnalyzer(LuceneVersion matchVersion, CharArraySet stopWords);
    public StopAnalyzer(LuceneVersion matchVersion, FileInfo stopwordsFile);
    public StopAnalyzer(LuceneVersion matchVersion, TextReader stopwords);
    private static StopAnalyzer();
    private static CharArraySet LoadEnglishStopWordsSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Core.StopFilter : FilteringTokenFilter {
    private CharArraySet stopWords;
    private ICharTermAttribute termAtt;
    public StopFilter(LuceneVersion matchVersion, TokenStream in, CharArraySet stopWords);
    public static CharArraySet MakeStopSet(LuceneVersion matchVersion, String[] stopWords);
    public static CharArraySet MakeStopSet(LuceneVersion matchVersion, IList`1<T1> stopWords);
    public static CharArraySet MakeStopSet(LuceneVersion matchVersion, String[] stopWords, bool ignoreCase);
    public static CharArraySet MakeStopSet(LuceneVersion matchVersion, IList`1<T1> stopWords, bool ignoreCase);
    protected virtual bool Accept();
}
public class Lucene.Net.Analysis.Core.StopFilterFactory : TokenFilterFactory {
    public static string FORMAT_WORDSET;
    public static string FORMAT_SNOWBALL;
    private CharArraySet stopWords;
    private string stopWordFiles;
    private string format;
    private bool ignoreCase;
    private bool enablePositionIncrements;
    public bool EnablePositionIncrements { get; }
    public bool IgnoreCase { get; }
    public CharArraySet StopWords { get; }
    public StopFilterFactory(IDictionary`2<string, string> args);
    public virtual void Inform(IResourceLoader loader);
    public virtual bool get_EnablePositionIncrements();
    public virtual bool get_IgnoreCase();
    public virtual CharArraySet get_StopWords();
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Core.TypeTokenFilter : FilteringTokenFilter {
    private ICollection`1<string> stopTypes;
    private ITypeAttribute typeAttribute;
    private bool useWhiteList;
    [ObsoleteAttribute("enablePositionIncrements=false is not supported anymore as of Lucene 4.4.")]
public TypeTokenFilter(LuceneVersion version, bool enablePositionIncrements, TokenStream input, ICollection`1<string> stopTypes, bool useWhiteList);
    [ObsoleteAttribute("enablePositionIncrements=false is not supported anymore as of Lucene 4.4.")]
public TypeTokenFilter(LuceneVersion version, bool enablePositionIncrements, TokenStream input, ICollection`1<string> stopTypes);
    public TypeTokenFilter(LuceneVersion version, TokenStream input, ICollection`1<string> stopTypes, bool useWhiteList);
    public TypeTokenFilter(LuceneVersion version, TokenStream input, ICollection`1<string> stopTypes);
    protected virtual bool Accept();
}
public class Lucene.Net.Analysis.Core.TypeTokenFilterFactory : TokenFilterFactory {
    private bool useWhitelist;
    private bool enablePositionIncrements;
    private string stopTypesFiles;
    private HashSet`1<string> stopTypes;
    public bool EnablePositionIncrements { get; }
    public ICollection`1<string> StopTypes { get; }
    public TypeTokenFilterFactory(IDictionary`2<string, string> args);
    public virtual void Inform(IResourceLoader loader);
    public virtual bool get_EnablePositionIncrements();
    public virtual ICollection`1<string> get_StopTypes();
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Core.UpperCaseFilter : TokenFilter {
    private CharacterUtils charUtils;
    private ICharTermAttribute termAtt;
    public UpperCaseFilter(LuceneVersion matchVersion, TokenStream in);
    public sealed virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Core.UpperCaseFilterFactory : TokenFilterFactory {
    public UpperCaseFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
    public virtual AbstractAnalysisFactory GetMultiTermComponent();
}
public class Lucene.Net.Analysis.Core.WhitespaceAnalyzer : Analyzer {
    private LuceneVersion matchVersion;
    public WhitespaceAnalyzer(LuceneVersion matchVersion);
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Core.WhitespaceTokenizer : CharTokenizer {
    public WhitespaceTokenizer(LuceneVersion matchVersion, TextReader in);
    public WhitespaceTokenizer(LuceneVersion matchVersion, AttributeFactory factory, TextReader in);
    protected virtual bool IsTokenChar(int c);
}
public class Lucene.Net.Analysis.Core.WhitespaceTokenizerFactory : TokenizerFactory {
    public WhitespaceTokenizerFactory(IDictionary`2<string, string> args);
    public virtual Tokenizer Create(AttributeFactory factory, TextReader input);
}
public class Lucene.Net.Analysis.Cz.CzechAnalyzer : StopwordAnalyzerBase {
    public static string DEFAULT_STOPWORD_FILE;
    private CharArraySet stemExclusionTable;
    public static CharArraySet DefaultStopSet { get; }
    public CzechAnalyzer(LuceneVersion matchVersion);
    public CzechAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public CzechAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionTable);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Cz.CzechStemFilter : TokenFilter {
    private CzechStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public CzechStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Cz.CzechStemFilterFactory : TokenFilterFactory {
    public CzechStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Cz.CzechStemmer : object {
    public virtual int Stem(Char[] s, int len);
    private int RemoveCase(Char[] s, int len);
    private int RemovePossessives(Char[] s, int len);
    private int Normalize(Char[] s, int len);
}
public class Lucene.Net.Analysis.Da.DanishAnalyzer : StopwordAnalyzerBase {
    private CharArraySet stemExclusionSet;
    public static string DEFAULT_STOPWORD_FILE;
    public static CharArraySet DefaultStopSet { get; }
    public DanishAnalyzer(LuceneVersion matchVersion);
    public DanishAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public DanishAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.De.GermanAnalyzer : StopwordAnalyzerBase {
    [ObsoleteAttribute("in 3.1, remove in Lucene 5.0 (index bw compat)")]
private static String[] GERMAN_STOP_WORDS;
    public static string DEFAULT_STOPWORD_FILE;
    private CharArraySet exclusionSet;
    public static CharArraySet DefaultStopSet { get; }
    public GermanAnalyzer(LuceneVersion matchVersion);
    public GermanAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public GermanAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    private static GermanAnalyzer();
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.De.GermanLightStemFilter : TokenFilter {
    private GermanLightStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public GermanLightStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.De.GermanLightStemFilterFactory : TokenFilterFactory {
    public GermanLightStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.De.GermanLightStemmer : object {
    public virtual int Stem(Char[] s, int len);
    private bool StEnding(char ch);
    private int Step1(Char[] s, int len);
    private int Step2(Char[] s, int len);
}
public class Lucene.Net.Analysis.De.GermanMinimalStemFilter : TokenFilter {
    private GermanMinimalStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public GermanMinimalStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.De.GermanMinimalStemFilterFactory : TokenFilterFactory {
    public GermanMinimalStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.De.GermanMinimalStemmer : object {
    public virtual int Stem(Char[] s, int len);
}
public class Lucene.Net.Analysis.De.GermanNormalizationFilter : TokenFilter {
    private static int N;
    private static int V;
    private static int U;
    private ICharTermAttribute termAtt;
    public GermanNormalizationFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.De.GermanNormalizationFilterFactory : TokenFilterFactory {
    public GermanNormalizationFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
    public virtual AbstractAnalysisFactory GetMultiTermComponent();
}
public class Lucene.Net.Analysis.De.GermanStemFilter : TokenFilter {
    private GermanStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public GermanStemmer Stemmer { get; public set; }
    public GermanStemFilter(TokenStream in);
    public virtual bool IncrementToken();
    public GermanStemmer get_Stemmer();
    public void set_Stemmer(GermanStemmer value);
}
public class Lucene.Net.Analysis.De.GermanStemFilterFactory : TokenFilterFactory {
    public GermanStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream in);
}
public class Lucene.Net.Analysis.De.GermanStemmer : object {
    private StringBuilder sb;
    private int substCount;
    private static CultureInfo locale;
    private static GermanStemmer();
    protected internal virtual string Stem(string term);
    private bool IsStemmable(string term);
    private void Strip(StringBuilder buffer);
    private void Optimize(StringBuilder buffer);
    private void RemoveParticleDenotion(StringBuilder buffer);
    private void Substitute(StringBuilder buffer);
    private void Resubstitute(StringBuilder buffer);
}
public class Lucene.Net.Analysis.El.GreekAnalyzer : StopwordAnalyzerBase {
    public static string DEFAULT_STOPWORD_FILE;
    public static CharArraySet DefaultStopSet { get; }
    public GreekAnalyzer(LuceneVersion matchVersion);
    public GreekAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.El.GreekLowerCaseFilter : TokenFilter {
    private ICharTermAttribute termAtt;
    private CharacterUtils charUtils;
    private static CultureInfo culture;
    public GreekLowerCaseFilter(LuceneVersion matchVersion, TokenStream in);
    private static GreekLowerCaseFilter();
    public virtual bool IncrementToken();
    private int LowerCase(int codepoint);
}
public class Lucene.Net.Analysis.El.GreekLowerCaseFilterFactory : TokenFilterFactory {
    public GreekLowerCaseFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream in);
    public virtual AbstractAnalysisFactory GetMultiTermComponent();
}
public class Lucene.Net.Analysis.El.GreekStemFilter : TokenFilter {
    private GreekStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public GreekStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.El.GreekStemFilterFactory : TokenFilterFactory {
    public GreekStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.El.GreekStemmer : object {
    private static CharArraySet exc4;
    private static CharArraySet exc6;
    private static CharArraySet exc7;
    private static CharArraySet exc8a;
    private static CharArraySet exc8b;
    private static CharArraySet exc9;
    private static CharArraySet exc12a;
    private static CharArraySet exc12b;
    private static CharArraySet exc13;
    private static CharArraySet exc14;
    private static CharArraySet exc15a;
    private static CharArraySet exc15b;
    private static CharArraySet exc16;
    private static CharArraySet exc17;
    private static CharArraySet exc18;
    private static CharArraySet exc19;
    private static GreekStemmer();
    public virtual int Stem(Char[] s, int len);
    private int Rule0(Char[] s, int len);
    private int Rule1(Char[] s, int len);
    private int Rule2(Char[] s, int len);
    private int Rule3(Char[] s, int len);
    private int Rule4(Char[] s, int len);
    private int Rule5(Char[] s, int len);
    private int Rule6(Char[] s, int len);
    private int Rule7(Char[] s, int len);
    private int Rule8(Char[] s, int len);
    private int Rule9(Char[] s, int len);
    private int Rule10(Char[] s, int len);
    private int Rule11(Char[] s, int len);
    private int Rule12(Char[] s, int len);
    private int Rule13(Char[] s, int len);
    private int Rule14(Char[] s, int len);
    private int Rule15(Char[] s, int len);
    private int Rule16(Char[] s, int len);
    private int Rule17(Char[] s, int len);
    private int Rule18(Char[] s, int len);
    private int Rule19(Char[] s, int len);
    private int Rule20(Char[] s, int len);
    private int Rule21(Char[] s, int len);
    private int Rule22(Char[] s, int len);
    private bool EndsWith(Char[] s, int len, string suffix);
    private bool EndsWithVowel(Char[] s, int len);
    private bool EndsWithVowelNoY(Char[] s, int len);
}
public class Lucene.Net.Analysis.En.EnglishAnalyzer : StopwordAnalyzerBase {
    private CharArraySet stemExclusionSet;
    public static CharArraySet DefaultStopSet { get; }
    public EnglishAnalyzer(LuceneVersion matchVersion);
    public EnglishAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public EnglishAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.En.EnglishMinimalStemFilter : TokenFilter {
    private EnglishMinimalStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public EnglishMinimalStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.En.EnglishMinimalStemFilterFactory : TokenFilterFactory {
    public EnglishMinimalStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.En.EnglishMinimalStemmer : object {
    public virtual int Stem(Char[] s, int len);
}
public class Lucene.Net.Analysis.En.EnglishPossessiveFilter : TokenFilter {
    private ICharTermAttribute termAtt;
    private LuceneVersion matchVersion;
    [ObsoleteAttribute("Use <see cref="#EnglishPossessiveFilter(org.apache.lucene.util.Version, org.apache.lucene.analysis.TokenStream)"/> instead.")]
public EnglishPossessiveFilter(TokenStream input);
    public EnglishPossessiveFilter(LuceneVersion version, TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.En.EnglishPossessiveFilterFactory : TokenFilterFactory {
    public EnglishPossessiveFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
internal class Lucene.Net.Analysis.En.KStemData1 : object {
    internal static String[] data;
    private static KStemData1();
}
internal class Lucene.Net.Analysis.En.KStemData2 : object {
    internal static String[] data;
    private static KStemData2();
}
internal class Lucene.Net.Analysis.En.KStemData3 : object {
    internal static String[] data;
    private static KStemData3();
}
internal class Lucene.Net.Analysis.En.KStemData4 : object {
    internal static String[] data;
    private static KStemData4();
}
internal class Lucene.Net.Analysis.En.KStemData5 : object {
    internal static String[] data;
    private static KStemData5();
}
internal class Lucene.Net.Analysis.En.KStemData6 : object {
    internal static String[] data;
    private static KStemData6();
}
internal class Lucene.Net.Analysis.En.KStemData7 : object {
    internal static String[] data;
    private static KStemData7();
}
internal class Lucene.Net.Analysis.En.KStemData8 : object {
    internal static String[] data;
    private static KStemData8();
}
public class Lucene.Net.Analysis.En.KStemFilter : TokenFilter {
    private KStemmer stemmer;
    private ICharTermAttribute termAttribute;
    private IKeywordAttribute keywordAtt;
    public KStemFilter(TokenStream in);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.En.KStemFilterFactory : TokenFilterFactory {
    public KStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.En.KStemmer : object {
    private static int MaxWordLen;
    private static String[] exceptionWords;
    private static String[][] directConflations;
    private static String[][] countryNationality;
    private static String[] supplementDict;
    private static String[] properNouns;
    private static CharArrayMap`1<DictEntry> dict_ht;
    private OpenStringBuilder word;
    private int j;
    private int k;
    internal DictEntry matchedEntry;
    private static Char[] ization;
    private static Char[] ition;
    private static Char[] ation;
    private static Char[] ication;
    internal string result;
    private char FinalChar { get; }
    private char PenultChar { get; }
    private int StemLength { get; }
    internal string String { get; }
    internal Char[] Chars { get; }
    internal int Length { get; }
    private bool IsMatched { get; }
    private static KStemmer();
    private char get_FinalChar();
    private char get_PenultChar();
    private bool IsVowel(int index);
    private bool IsCons(int index);
    private static CharArrayMap`1<DictEntry> InitializeDictHash();
    private bool IsAlpha(char ch);
    private int get_StemLength();
    private bool EndsIn(Char[] s);
    private bool EndsIn(char a, char b);
    private bool EndsIn(char a, char b, char c);
    private bool EndsIn(char a, char b, char c, char d);
    private DictEntry WordInDict();
    private void Plural();
    private void SetSuffix(string s);
    private void SetSuff(string s, int len);
    private bool Lookup();
    private void PastTense();
    private bool DoubleC(int i);
    private bool VowelInStem();
    private void Aspect();
    private void ItyEndings();
    private void NceEndings();
    private void NessEndings();
    private void IsmEndings();
    private void MentEndings();
    private void IzeEndings();
    private void NcyEndings();
    private void BleEndings();
    private void IcEndings();
    private void IonEndings();
    private void ErAndOrEndings();
    private void LyEndings();
    private void AlEndings();
    private void IveEndings();
    internal virtual string Stem(string term);
    internal virtual string AsString();
    internal virtual ICharSequence AsCharSequence();
    internal virtual string get_String();
    internal virtual Char[] get_Chars();
    internal virtual int get_Length();
    private bool get_IsMatched();
    internal virtual bool Stem(Char[] term, int len);
}
public class Lucene.Net.Analysis.En.PorterStemFilter : TokenFilter {
    private PorterStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public PorterStemFilter(TokenStream in);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.En.PorterStemFilterFactory : TokenFilterFactory {
    public PorterStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
internal class Lucene.Net.Analysis.En.PorterStemmer : object {
    private Char[] b;
    private int i;
    private int j;
    private int k;
    private int k0;
    private bool dirty;
    private static int INITIAL_SIZE;
    public int ResultLength { get; }
    [WritableArrayAttribute]
public Char[] ResultBuffer { get; }
    public virtual void Reset();
    public virtual void Add(char ch);
    public virtual string ToString();
    public virtual int get_ResultLength();
    public virtual Char[] get_ResultBuffer();
    private bool Cons(int i);
    private int M();
    private bool VowelInStem();
    private bool DoubleC(int j);
    private bool Cvc(int i);
    private bool Ends(string s);
    internal virtual void SetTo(string s);
    internal virtual void r(string s);
    private void Step1();
    private void Step2();
    private void Step3();
    private void Step4();
    private void Step5();
    private void Step6();
    public virtual string Stem(string s);
    public virtual bool Stem(Char[] word);
    public virtual bool Stem(Char[] wordBuffer, int offset, int wordLen);
    public virtual bool Stem(Char[] word, int wordLen);
    public virtual bool Stem();
    public virtual bool Stem(int i0);
}
public class Lucene.Net.Analysis.Es.SpanishAnalyzer : StopwordAnalyzerBase {
    private CharArraySet stemExclusionSet;
    public static string DEFAULT_STOPWORD_FILE;
    public static CharArraySet DefaultStopSet { get; }
    public SpanishAnalyzer(LuceneVersion matchVersion);
    public SpanishAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public SpanishAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Es.SpanishLightStemFilter : TokenFilter {
    private SpanishLightStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public SpanishLightStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Es.SpanishLightStemFilterFactory : TokenFilterFactory {
    public SpanishLightStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Es.SpanishLightStemmer : object {
    public virtual int Stem(Char[] s, int len);
}
public class Lucene.Net.Analysis.Eu.BasqueAnalyzer : StopwordAnalyzerBase {
    private CharArraySet stemExclusionSet;
    public static string DEFAULT_STOPWORD_FILE;
    public static CharArraySet DefaultStopSet { get; }
    public BasqueAnalyzer(LuceneVersion matchVersion);
    public BasqueAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public BasqueAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Fa.PersianAnalyzer : StopwordAnalyzerBase {
    public static string DEFAULT_STOPWORD_FILE;
    public static string STOPWORDS_COMMENT;
    public static CharArraySet DefaultStopSet { get; }
    public PersianAnalyzer(LuceneVersion matchVersion);
    public PersianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
    protected internal virtual TextReader InitReader(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Fa.PersianCharFilter : CharFilter {
    public PersianCharFilter(TextReader in);
    public virtual int Read(Char[] cbuf, int off, int len);
    public virtual int Read();
    protected virtual int Correct(int currentOff);
}
public class Lucene.Net.Analysis.Fa.PersianCharFilterFactory : CharFilterFactory {
    public PersianCharFilterFactory(IDictionary`2<string, string> args);
    public virtual TextReader Create(TextReader input);
    public virtual AbstractAnalysisFactory GetMultiTermComponent();
}
public class Lucene.Net.Analysis.Fa.PersianNormalizationFilter : TokenFilter {
    private PersianNormalizer normalizer;
    private ICharTermAttribute termAtt;
    public PersianNormalizationFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Fa.PersianNormalizationFilterFactory : TokenFilterFactory {
    public PersianNormalizationFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
    public virtual AbstractAnalysisFactory GetMultiTermComponent();
}
public class Lucene.Net.Analysis.Fa.PersianNormalizer : object {
    public static char YEH;
    public static char FARSI_YEH;
    public static char YEH_BARREE;
    public static char KEHEH;
    public static char KAF;
    public static char HAMZA_ABOVE;
    public static char HEH_YEH;
    public static char HEH_GOAL;
    public static char HEH;
    public virtual int Normalize(Char[] s, int len);
}
public class Lucene.Net.Analysis.Fi.FinnishAnalyzer : StopwordAnalyzerBase {
    private CharArraySet stemExclusionSet;
    public static string DEFAULT_STOPWORD_FILE;
    public static CharArraySet DefaultStopSet { get; }
    public FinnishAnalyzer(LuceneVersion matchVersion);
    public FinnishAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public FinnishAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Fi.FinnishLightStemFilter : TokenFilter {
    private FinnishLightStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public FinnishLightStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Fi.FinnishLightStemFilterFactory : TokenFilterFactory {
    public FinnishLightStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Fi.FinnishLightStemmer : object {
    public virtual int Stem(Char[] s, int len);
    private int Step1(Char[] s, int len);
    private int Step2(Char[] s, int len);
    private int Step3(Char[] s, int len);
    private int Norm1(Char[] s, int len);
    private int Norm2(Char[] s, int len);
    private bool IsVowel(char ch);
}
public class Lucene.Net.Analysis.Fr.FrenchAnalyzer : StopwordAnalyzerBase {
    [ObsoleteAttribute("(3.1) remove in Lucene 5.0 (index bw compat)")]
private static String[] FRENCH_STOP_WORDS;
    public static string DEFAULT_STOPWORD_FILE;
    public static CharArraySet DEFAULT_ARTICLES;
    private CharArraySet excltable;
    public static CharArraySet DefaultStopSet { get; }
    public FrenchAnalyzer(LuceneVersion matchVersion);
    public FrenchAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public FrenchAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclutionSet);
    private static FrenchAnalyzer();
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Fr.FrenchLightStemFilter : TokenFilter {
    private FrenchLightStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public FrenchLightStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Fr.FrenchLightStemFilterFactory : TokenFilterFactory {
    public FrenchLightStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Fr.FrenchLightStemmer : object {
    public virtual int Stem(Char[] s, int len);
    private int Norm(Char[] s, int len);
}
public class Lucene.Net.Analysis.Fr.FrenchMinimalStemFilter : TokenFilter {
    private FrenchMinimalStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public FrenchMinimalStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Fr.FrenchMinimalStemFilterFactory : TokenFilterFactory {
    public FrenchMinimalStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Fr.FrenchMinimalStemmer : object {
    public virtual int Stem(Char[] s, int len);
}
[ObsoleteAttribute("(3.1) Use SnowballFilter with FrenchStemmer instead, which has the same functionality. This filter will be removed in Lucene 5.0")]
public class Lucene.Net.Analysis.Fr.FrenchStemFilter : TokenFilter {
    private FrenchStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public FrenchStemmer Stemmer { get; public set; }
    public FrenchStemFilter(TokenStream in);
    public virtual bool IncrementToken();
    public FrenchStemmer get_Stemmer();
    public void set_Stemmer(FrenchStemmer value);
}
[ObsoleteAttribute("Use FrenchStemmer instead, which has the same functionality.")]
public class Lucene.Net.Analysis.Fr.FrenchStemmer : object {
    private static CultureInfo locale;
    private StringBuilder sb;
    private StringBuilder tb;
    private string R0;
    private string RV;
    private string R1;
    private string R2;
    private bool suite;
    private bool modified;
    private static FrenchStemmer();
    protected internal virtual string Stem(string term);
    private void SetStrings();
    private void Step1();
    private bool Step2a();
    private void Step2b();
    private void Step3();
    private void Step4();
    private void Step5();
    private void Step6();
    private bool DeleteFromIfPrecededIn(string source, String[] search, string from, string prefix);
    private bool DeleteFromIfTestVowelBeforeIn(string source, String[] search, bool vowel, string from);
    private void DeleteButSuffixFrom(string source, String[] search, string prefix, bool without);
    private void DeleteButSuffixFromElseReplace(string source, String[] search, string prefix, bool without, string from, string replace);
    private bool ReplaceFrom(string source, String[] search, string replace);
    private void DeleteFrom(string source, String[] suffix);
    private bool IsVowel(char ch);
    private string RetrieveR(StringBuilder buffer);
    private string RetrieveRV(StringBuilder buffer);
    private StringBuilder TreatVowels(StringBuilder buffer);
    private bool IsStemmable(string term);
}
public class Lucene.Net.Analysis.Ga.IrishAnalyzer : StopwordAnalyzerBase {
    private CharArraySet stemExclusionSet;
    public static string DEFAULT_STOPWORD_FILE;
    private static CharArraySet DEFAULT_ARTICLES;
    private static CharArraySet HYPHENATIONS;
    public static CharArraySet DefaultStopSet { get; }
    public IrishAnalyzer(LuceneVersion matchVersion);
    public IrishAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public IrishAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    private static IrishAnalyzer();
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Ga.IrishLowerCaseFilter : TokenFilter {
    private ICharTermAttribute termAtt;
    private static CultureInfo culture;
    public IrishLowerCaseFilter(TokenStream in);
    private static IrishLowerCaseFilter();
    public virtual bool IncrementToken();
    private bool IsUpperVowel(int v);
}
public class Lucene.Net.Analysis.Ga.IrishLowerCaseFilterFactory : TokenFilterFactory {
    public IrishLowerCaseFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
    public virtual AbstractAnalysisFactory GetMultiTermComponent();
}
public class Lucene.Net.Analysis.Gl.GalicianAnalyzer : StopwordAnalyzerBase {
    private CharArraySet stemExclusionSet;
    public static string DEFAULT_STOPWORD_FILE;
    public static CharArraySet DefaultStopSet { get; }
    public GalicianAnalyzer(LuceneVersion matchVersion);
    public GalicianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public GalicianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Gl.GalicianMinimalStemFilter : TokenFilter {
    private GalicianMinimalStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public GalicianMinimalStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Gl.GalicianMinimalStemFilterFactory : TokenFilterFactory {
    public GalicianMinimalStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Gl.GalicianMinimalStemmer : RSLPStemmerBase {
    private static Step pluralStep;
    private static GalicianMinimalStemmer();
    public virtual int Stem(Char[] s, int len);
}
public class Lucene.Net.Analysis.Gl.GalicianStemFilter : TokenFilter {
    private GalicianStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public GalicianStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Gl.GalicianStemFilterFactory : TokenFilterFactory {
    public GalicianStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Gl.GalicianStemmer : RSLPStemmerBase {
    private static Step plural;
    private static Step unification;
    private static Step adverb;
    private static Step augmentative;
    private static Step noun;
    private static Step verb;
    private static Step vowel;
    private static GalicianStemmer();
    public virtual int Stem(Char[] s, int len);
}
public class Lucene.Net.Analysis.Hi.HindiAnalyzer : StopwordAnalyzerBase {
    private CharArraySet stemExclusionSet;
    public static string DEFAULT_STOPWORD_FILE;
    private static string STOPWORDS_COMMENT;
    public static CharArraySet DefaultStopSet { get; }
    public HindiAnalyzer(LuceneVersion version, CharArraySet stopwords, CharArraySet stemExclusionSet);
    public HindiAnalyzer(LuceneVersion version, CharArraySet stopwords);
    public HindiAnalyzer(LuceneVersion version);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Hi.HindiNormalizationFilter : TokenFilter {
    private HindiNormalizer normalizer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAtt;
    public HindiNormalizationFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Hi.HindiNormalizationFilterFactory : TokenFilterFactory {
    public HindiNormalizationFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
    public virtual AbstractAnalysisFactory GetMultiTermComponent();
}
public class Lucene.Net.Analysis.Hi.HindiNormalizer : object {
    public virtual int Normalize(Char[] s, int len);
}
public class Lucene.Net.Analysis.Hi.HindiStemFilter : TokenFilter {
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAtt;
    private HindiStemmer stemmer;
    public HindiStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Hi.HindiStemFilterFactory : TokenFilterFactory {
    public HindiStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Hi.HindiStemmer : object {
    public virtual int Stem(Char[] buffer, int len);
}
public class Lucene.Net.Analysis.Hu.HungarianAnalyzer : StopwordAnalyzerBase {
    private CharArraySet stemExclusionSet;
    public static string DEFAULT_STOPWORD_FILE;
    public static CharArraySet DefaultStopSet { get; }
    public HungarianAnalyzer(LuceneVersion matchVersion);
    public HungarianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public HungarianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Hu.HungarianLightStemFilter : TokenFilter {
    private HungarianLightStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public HungarianLightStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Hu.HungarianLightStemFilterFactory : TokenFilterFactory {
    public HungarianLightStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Hu.HungarianLightStemmer : object {
    public virtual int Stem(Char[] s, int len);
    private int RemoveCase(Char[] s, int len);
    private int RemovePossessive(Char[] s, int len);
    private int RemovePlural(Char[] s, int len);
    private int Normalize(Char[] s, int len);
    private bool IsVowel(char ch);
}
public class Lucene.Net.Analysis.Hunspell.Dictionary : object {
    private static Char[] NOFLAGS;
    private static string ALIAS_KEY;
    private static string MORPH_ALIAS_KEY;
    private static string PREFIX_KEY;
    private static string SUFFIX_KEY;
    private static string FLAG_KEY;
    private static string COMPLEXPREFIXES_KEY;
    private static string CIRCUMFIX_KEY;
    private static string IGNORE_KEY;
    private static string ICONV_KEY;
    private static string OCONV_KEY;
    private static string FULLSTRIP_KEY;
    private static string LANG_KEY;
    private static string KEEPCASE_KEY;
    private static string NEEDAFFIX_KEY;
    private static string PSEUDOROOT_KEY;
    private static string ONLYINCOMPOUND_KEY;
    private static string NUM_FLAG_TYPE;
    private static string UTF8_FLAG_TYPE;
    private static string LONG_FLAG_TYPE;
    private static string PREFIX_CONDITION_REGEX_PATTERN;
    private static string SUFFIX_CONDITION_REGEX_PATTERN;
    internal FST`1<Int32sRef> prefixes;
    internal FST`1<Int32sRef> suffixes;
    internal IList`1<CharacterRunAutomaton> patterns;
    internal FST`1<Int32sRef> words;
    internal BytesRefHash flagLookup;
    internal Char[] stripData;
    internal Int32[] stripOffsets;
    internal Byte[] affixData;
    private int currentAffix;
    private FlagParsingStrategy flagParsingStrategy;
    private String[] aliases;
    private int aliasCount;
    private String[] morphAliases;
    private int morphAliasCount;
    private String[] stemExceptions;
    private int stemExceptionCount;
    internal bool hasStemExceptions;
    private DirectoryInfo tempDir;
    internal bool ignoreCase;
    internal bool complexPrefixes;
    internal bool twoStageAffix;
    internal int circumfix;
    internal int keepcase;
    internal int needaffix;
    internal int onlyincompound;
    private Char[] ignore;
    internal FST`1<CharsRef> iconv;
    internal FST`1<CharsRef> oconv;
    internal bool needsInputCleaning;
    internal bool needsOutputCleaning;
    internal bool fullStrip;
    internal string language;
    internal bool alternateCasing;
    private static Regex whitespacePattern;
    private static Regex leadingDigitPattern;
    internal static Regex ENCODING_PATTERN;
    internal static IDictionary`2<string, string> CHARSET_ALIASES;
    private static Regex windowsCodePagePattern;
    private static Regex thaiCodePagePattern;
    internal static char FLAG_SEPARATOR;
    internal static char MORPH_SEPARATOR;
    public Dictionary(Stream affix, Stream dictionary);
    public Dictionary(Stream affix, IList`1<Stream> dictionaries, bool ignoreCase);
    private static Dictionary();
    internal virtual Int32sRef LookupWord(Char[] word, int offset, int length);
    internal virtual Int32sRef LookupPrefix(Char[] word, int offset, int length);
    internal virtual Int32sRef LookupSuffix(Char[] word, int offset, int length);
    internal virtual Int32sRef Lookup(FST`1<Int32sRef> fst, Char[] word, int offset, int length);
    private void ReadAffixFile(Stream affixStream, Encoding decoder);
    private FST`1<Int32sRef> AffixFST(SortedDictionary`2<string, IList`1<int>> affixes);
    internal static string EscapeDash(string re);
    private void ParseAffix(SortedDictionary`2<string, IList`1<int>> affixes, string header, TextReader reader, string conditionPattern, IDictionary`2<string, int> seenPatterns, IDictionary`2<string, int> seenStrips);
    private FST`1<CharsRef> ParseConversions(TextReader reader, int num, int lineNumber);
    internal static string GetDictionaryEncoding(Stream affix);
    private static IDictionary`2<string, string> LoadCharsetAliases();
    private Encoding GetSystemEncoding(string encoding);
    internal static FlagParsingStrategy GetFlagParsingStrategy(string flagLine);
    internal virtual string UnescapeEntry(string entry);
    internal static int MorphBoundary(string line);
    internal static int IndexOfSpaceOrTab(string text, int start);
    private void ReadDictionaryFiles(IList`1<Stream> dictionaries, Encoding decoder, Builder`1<Int32sRef> words);
    internal static Char[] DecodeFlags(BytesRef b);
    internal static void EncodeFlags(BytesRef b, Char[] flags);
    private void ParseAlias(string line);
    private string GetAliasValue(int id);
    internal string GetStemException(int id);
    private void ParseMorphAlias(string line);
    private string ParseStemException(string morphData);
    internal static bool HasFlag(Char[] flags, char flag);
    internal virtual string CleanInput(string input, StringBuilder reuse);
    internal char CaseFold(char c);
    internal static void ApplyMappings(FST`1<CharsRef> fst, StringBuilder sb);
}
public class Lucene.Net.Analysis.Hunspell.HunspellStemFilter : TokenFilter {
    private ICharTermAttribute termAtt;
    private IPositionIncrementAttribute posIncAtt;
    private IKeywordAttribute keywordAtt;
    private Stemmer stemmer;
    private List`1<CharsRef> buffer;
    private State savedState;
    private bool dedup;
    private bool longestOnly;
    internal static IComparer`1<CharsRef> lengthComparer;
    public HunspellStemFilter(TokenStream input, Dictionary dictionary);
    public HunspellStemFilter(TokenStream input, Dictionary dictionary, bool dedup);
    public HunspellStemFilter(TokenStream input, Dictionary dictionary, bool dedup, bool longestOnly);
    private static HunspellStemFilter();
    public virtual bool IncrementToken();
    public virtual void Reset();
}
public class Lucene.Net.Analysis.Hunspell.HunspellStemFilterFactory : TokenFilterFactory {
    private static string PARAM_DICTIONARY;
    private static string PARAM_AFFIX;
    private static string PARAM_RECURSION_CAP;
    private static string PARAM_IGNORE_CASE;
    private static string PARAM_LONGEST_ONLY;
    private string dictionaryFiles;
    private string affixFile;
    private bool ignoreCase;
    private bool longestOnly;
    private Dictionary dictionary;
    public HunspellStemFilterFactory(IDictionary`2<string, string> args);
    public virtual void Inform(IResourceLoader loader);
    public virtual TokenStream Create(TokenStream tokenStream);
}
[ExceptionToClassNameConventionAttribute]
internal class Lucene.Net.Analysis.Hunspell.ISO8859_14Decoder : Decoder {
    internal static Char[] TABLE;
    private static ISO8859_14Decoder();
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetChars(Byte[] bytesIn, int byteIndex, int byteCount, Char[] charsOut, int charIndex);
}
[ExceptionToClassNameConventionAttribute]
internal class Lucene.Net.Analysis.Hunspell.ISO8859_14Encoding : Encoding {
    private static Decoder decoder;
    public string EncodingName { get; }
    public int CodePage { get; }
    private static ISO8859_14Encoding();
    public virtual Decoder GetDecoder();
    public virtual string get_EncodingName();
    public virtual int get_CodePage();
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetMaxByteCount(int charCount);
}
internal class Lucene.Net.Analysis.Hunspell.Stemmer : object {
    private Dictionary dictionary;
    private BytesRef scratch;
    private StringBuilder segment;
    private ByteArrayDataInput affixReader;
    private StringBuilder scratchSegment;
    private Char[] scratchBuffer;
    private int formStep;
    private Char[] lowerBuffer;
    private Char[] titleBuffer;
    private static int EXACT_CASE;
    private static int TITLE_CASE;
    private static int UPPER_CASE;
    private BytesReader[] prefixReaders;
    private Arc`1[] prefixArcs;
    private BytesReader[] suffixReaders;
    private Arc`1[] suffixArcs;
    public Stemmer(Dictionary dictionary);
    public IList`1<CharsRef> Stem(string word);
    public IList`1<CharsRef> Stem(Char[] word, int length);
    private int CaseOf(Char[] word, int length);
    private void CaseFoldTitle(Char[] word, int length);
    private void CaseFoldLower(Char[] word, int length);
    private IList`1<CharsRef> DoStem(Char[] word, int length, bool caseVariant);
    public IList`1<CharsRef> UniqueStems(Char[] word, int length);
    private CharsRef NewStem(Char[] buffer, int length, Int32sRef forms, int formID);
    private IList`1<CharsRef> Stem(Char[] word, int length, int previous, int prevFlag, int prefixFlag, int recursionDepth, bool doPrefix, bool doSuffix, bool previousWasPrefix, bool circumfix, bool caseVariant);
    private bool CheckCondition(int condition, Char[] c1, int c1off, int c1len, Char[] c2, int c2off, int c2len);
    internal IList`1<CharsRef> ApplyAffix(Char[] strippedWord, int length, int affix, int prefixFlag, int recursionDepth, bool prefix, bool circumfix, bool caseVariant);
    private bool HasCrossCheckedFlag(char flag, Char[] flags, bool matchEmpty);
}
public class Lucene.Net.Analysis.Hy.ArmenianAnalyzer : StopwordAnalyzerBase {
    private CharArraySet stemExclusionSet;
    public static string DEFAULT_STOPWORD_FILE;
    public static CharArraySet DefaultStopSet { get; }
    public ArmenianAnalyzer(LuceneVersion matchVersion);
    public ArmenianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public ArmenianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Id.IndonesianAnalyzer : StopwordAnalyzerBase {
    public static string DEFAULT_STOPWORD_FILE;
    private CharArraySet stemExclusionSet;
    public static CharArraySet DefaultStopSet { get; }
    public IndonesianAnalyzer(LuceneVersion matchVersion);
    public IndonesianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public IndonesianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Id.IndonesianStemFilter : TokenFilter {
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAtt;
    private IndonesianStemmer stemmer;
    private bool stemDerivational;
    public IndonesianStemFilter(TokenStream input);
    public IndonesianStemFilter(TokenStream input, bool stemDerivational);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Id.IndonesianStemFilterFactory : TokenFilterFactory {
    private bool stemDerivational;
    public IndonesianStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Id.IndonesianStemmer : object {
    private int numSyllables;
    private int flags;
    private static int REMOVED_KE;
    private static int REMOVED_PENG;
    private static int REMOVED_DI;
    private static int REMOVED_MENG;
    private static int REMOVED_TER;
    private static int REMOVED_BER;
    private static int REMOVED_PE;
    public virtual int Stem(Char[] text, int length, bool stemDerivational);
    private int StemDerivational(Char[] text, int length);
    private bool IsVowel(char ch);
    private int RemoveParticle(Char[] text, int length);
    private int RemovePossessivePronoun(Char[] text, int length);
    private int RemoveFirstOrderPrefix(Char[] text, int length);
    private int RemoveSecondOrderPrefix(Char[] text, int length);
    private int RemoveSuffix(Char[] text, int length);
}
public class Lucene.Net.Analysis.In.IndicNormalizationFilter : TokenFilter {
    private ICharTermAttribute termAtt;
    private IndicNormalizer normalizer;
    public IndicNormalizationFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.In.IndicNormalizationFilterFactory : TokenFilterFactory {
    public IndicNormalizationFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
    public virtual AbstractAnalysisFactory GetMultiTermComponent();
}
public class Lucene.Net.Analysis.In.IndicNormalizer : object {
    private static IDictionary`2<Regex, ScriptData> scripts;
    private static Int32[][] decompositions;
    private static IndicNormalizer();
    public virtual int Normalize(Char[] text, int len);
    private int Compose(int ch0, Regex block0, ScriptData sd, Char[] text, int pos, int len);
    private Regex GetBlockForChar(char c);
}
[ObsoleteAttribute("(3.6) Use StandardTokenizer instead.")]
public class Lucene.Net.Analysis.In.IndicTokenizer : CharTokenizer {
    public IndicTokenizer(LuceneVersion matchVersion, AttributeFactory factory, TextReader input);
    public IndicTokenizer(LuceneVersion matchVersion, TextReader input);
    protected virtual bool IsTokenChar(int c);
}
public class Lucene.Net.Analysis.It.ItalianAnalyzer : StopwordAnalyzerBase {
    private CharArraySet stemExclusionSet;
    public static string DEFAULT_STOPWORD_FILE;
    private static CharArraySet DEFAULT_ARTICLES;
    public static CharArraySet DefaultStopSet { get; }
    public ItalianAnalyzer(LuceneVersion matchVersion);
    public ItalianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public ItalianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    private static ItalianAnalyzer();
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.It.ItalianLightStemFilter : TokenFilter {
    private ItalianLightStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public ItalianLightStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.It.ItalianLightStemFilterFactory : TokenFilterFactory {
    public ItalianLightStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.It.ItalianLightStemmer : object {
    public virtual int Stem(Char[] s, int len);
}
public class Lucene.Net.Analysis.Lv.LatvianAnalyzer : StopwordAnalyzerBase {
    private CharArraySet stemExclusionSet;
    public static string DEFAULT_STOPWORD_FILE;
    public static CharArraySet DefaultStopSet { get; }
    public LatvianAnalyzer(LuceneVersion matchVersion);
    public LatvianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public LatvianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Lv.LatvianStemFilter : TokenFilter {
    private LatvianStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public LatvianStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Lv.LatvianStemFilterFactory : TokenFilterFactory {
    public LatvianStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Lv.LatvianStemmer : object {
    internal static Affix[] affixes;
    private static LatvianStemmer();
    public virtual int Stem(Char[] s, int len);
    private int Unpalatalize(Char[] s, int len);
    private int NumVowels(Char[] s, int len);
}
public class Lucene.Net.Analysis.Miscellaneous.ASCIIFoldingFilter : TokenFilter {
    private ICharTermAttribute termAtt;
    private IPositionIncrementAttribute posIncAttr;
    private bool preserveOriginal;
    private Char[] output;
    private int outputPos;
    private State state;
    public bool PreserveOriginal { get; }
    public ASCIIFoldingFilter(TokenStream input);
    public ASCIIFoldingFilter(TokenStream input, bool preserveOriginal);
    public bool get_PreserveOriginal();
    public virtual bool IncrementToken();
    public virtual void Reset();
    public void FoldToASCII(Char[] input, int length);
    public static int FoldToASCII(Char[] input, int inputPos, Char[] output, int outputPos, int length);
}
public class Lucene.Net.Analysis.Miscellaneous.ASCIIFoldingFilterFactory : TokenFilterFactory {
    private bool preserveOriginal;
    public ASCIIFoldingFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
    public virtual AbstractAnalysisFactory GetMultiTermComponent();
}
public class Lucene.Net.Analysis.Miscellaneous.CapitalizationFilter : TokenFilter {
    public static int DEFAULT_MAX_WORD_COUNT;
    public static int DEFAULT_MAX_TOKEN_LENGTH;
    private bool onlyFirstWord;
    private CharArraySet keep;
    private bool forceFirstLetter;
    private ICollection`1<Char[]> okPrefix;
    private int minWordLength;
    private int maxWordCount;
    private int maxTokenLength;
    private ICharTermAttribute termAtt;
    private CultureInfo culture;
    public CapitalizationFilter(TokenStream in);
    public CapitalizationFilter(TokenStream in, CultureInfo culture);
    public CapitalizationFilter(TokenStream in, bool onlyFirstWord, CharArraySet keep, bool forceFirstLetter, ICollection`1<Char[]> okPrefix, int minWordLength, int maxWordCount, int maxTokenLength);
    public CapitalizationFilter(TokenStream in, bool onlyFirstWord, CharArraySet keep, bool forceFirstLetter, ICollection`1<Char[]> okPrefix, int minWordLength, int maxWordCount, int maxTokenLength, CultureInfo culture);
    private static CapitalizationFilter();
    public virtual bool IncrementToken();
    private void ProcessWord(Char[] buffer, int offset, int length, int wordCount);
}
public class Lucene.Net.Analysis.Miscellaneous.CapitalizationFilterFactory : TokenFilterFactory {
    public static string KEEP;
    public static string KEEP_IGNORE_CASE;
    public static string OK_PREFIX;
    public static string MIN_WORD_LENGTH;
    public static string MAX_WORD_COUNT;
    public static string MAX_TOKEN_LENGTH;
    public static string ONLY_FIRST_WORD;
    public static string FORCE_FIRST_LETTER;
    public static string CULTURE;
    internal CharArraySet keep;
    internal ICollection`1<Char[]> okPrefix;
    internal int minWordLength;
    internal int maxWordCount;
    internal int maxTokenLength;
    internal bool onlyFirstWord;
    internal bool forceFirstLetter;
    private CultureInfo culture;
    public CapitalizationFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Miscellaneous.CodepointCountFilter : FilteringTokenFilter {
    private int min;
    private int max;
    private ICharTermAttribute termAtt;
    public CodepointCountFilter(LuceneVersion version, TokenStream in, int min, int max);
    protected virtual bool Accept();
}
public class Lucene.Net.Analysis.Miscellaneous.CodepointCountFilterFactory : TokenFilterFactory {
    private int min;
    private int max;
    public static string MIN_KEY;
    public static string MAX_KEY;
    public CodepointCountFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Miscellaneous.EmptyTokenStream : TokenStream {
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Miscellaneous.HyphenatedWordsFilter : TokenFilter {
    private ICharTermAttribute termAttribute;
    private IOffsetAttribute offsetAttribute;
    private StringBuilder hyphenated;
    private State savedState;
    private bool exhausted;
    private int lastEndOffset;
    public HyphenatedWordsFilter(TokenStream in);
    public virtual bool IncrementToken();
    public virtual void Reset();
    private void Unhyphenate();
}
public class Lucene.Net.Analysis.Miscellaneous.HyphenatedWordsFilterFactory : TokenFilterFactory {
    public HyphenatedWordsFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Miscellaneous.KeepWordFilter : FilteringTokenFilter {
    private CharArraySet words;
    private ICharTermAttribute termAtt;
    [ObsoleteAttribute("enablePositionIncrements=false is not supported anymore as of Lucene 4.4.")]
public KeepWordFilter(LuceneVersion version, bool enablePositionIncrements, TokenStream in, CharArraySet words);
    public KeepWordFilter(LuceneVersion version, TokenStream in, CharArraySet words);
    protected virtual bool Accept();
}
public class Lucene.Net.Analysis.Miscellaneous.KeepWordFilterFactory : TokenFilterFactory {
    private bool ignoreCase;
    private bool enablePositionIncrements;
    private string wordFiles;
    private CharArraySet words;
    public bool EnablePositionIncrements { get; }
    public bool IgnoreCase { get; }
    public CharArraySet Words { get; }
    public KeepWordFilterFactory(IDictionary`2<string, string> args);
    public virtual void Inform(IResourceLoader loader);
    public virtual bool get_EnablePositionIncrements();
    public virtual bool get_IgnoreCase();
    public virtual CharArraySet get_Words();
    public virtual TokenStream Create(TokenStream input);
}
public abstract class Lucene.Net.Analysis.Miscellaneous.KeywordMarkerFilter : TokenFilter {
    private IKeywordAttribute keywordAttr;
    protected KeywordMarkerFilter(TokenStream in);
    public sealed virtual bool IncrementToken();
    protected abstract virtual bool IsKeyword();
}
public class Lucene.Net.Analysis.Miscellaneous.KeywordMarkerFilterFactory : TokenFilterFactory {
    public static string PROTECTED_TOKENS;
    public static string PATTERN;
    private string wordFiles;
    private string stringPattern;
    private bool ignoreCase;
    private Regex pattern;
    private CharArraySet protectedWords;
    public bool IgnoreCase { get; }
    public KeywordMarkerFilterFactory(IDictionary`2<string, string> args);
    public virtual void Inform(IResourceLoader loader);
    public virtual bool get_IgnoreCase();
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Miscellaneous.KeywordRepeatFilter : TokenFilter {
    private IKeywordAttribute keywordAttribute;
    private IPositionIncrementAttribute posIncAttr;
    private State state;
    public KeywordRepeatFilter(TokenStream input);
    public virtual bool IncrementToken();
    public virtual void Reset();
}
public class Lucene.Net.Analysis.Miscellaneous.KeywordRepeatFilterFactory : TokenFilterFactory {
    public KeywordRepeatFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Miscellaneous.LengthFilter : FilteringTokenFilter {
    private int min;
    private int max;
    private ICharTermAttribute termAtt;
    [ObsoleteAttribute("enablePositionIncrements=false is not supported anymore as of Lucene 4.4.")]
public LengthFilter(LuceneVersion version, bool enablePositionIncrements, TokenStream in, int min, int max);
    public LengthFilter(LuceneVersion version, TokenStream in, int min, int max);
    protected virtual bool Accept();
}
public class Lucene.Net.Analysis.Miscellaneous.LengthFilterFactory : TokenFilterFactory {
    private int min;
    private int max;
    private bool enablePositionIncrements;
    public static string MIN_KEY;
    public static string MAX_KEY;
    public LengthFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Miscellaneous.LimitTokenCountAnalyzer : AnalyzerWrapper {
    private Analyzer delegate;
    private int maxTokenCount;
    private bool consumeAllTokens;
    public LimitTokenCountAnalyzer(Analyzer delegate, int maxTokenCount);
    public LimitTokenCountAnalyzer(Analyzer delegate, int maxTokenCount, bool consumeAllTokens);
    protected virtual Analyzer GetWrappedAnalyzer(string fieldName);
    protected virtual TokenStreamComponents WrapComponents(string fieldName, TokenStreamComponents components);
    public virtual string ToString();
}
public class Lucene.Net.Analysis.Miscellaneous.LimitTokenCountFilter : TokenFilter {
    private int maxTokenCount;
    private bool consumeAllTokens;
    private int tokenCount;
    private bool exhausted;
    public LimitTokenCountFilter(TokenStream in, int maxTokenCount);
    public LimitTokenCountFilter(TokenStream in, int maxTokenCount, bool consumeAllTokens);
    public virtual bool IncrementToken();
    public virtual void Reset();
}
public class Lucene.Net.Analysis.Miscellaneous.LimitTokenCountFilterFactory : TokenFilterFactory {
    public static string MAX_TOKEN_COUNT_KEY;
    public static string CONSUME_ALL_TOKENS_KEY;
    private int maxTokenCount;
    private bool consumeAllTokens;
    public LimitTokenCountFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Miscellaneous.LimitTokenPositionFilter : TokenFilter {
    private int maxTokenPosition;
    private bool consumeAllTokens;
    private int tokenPosition;
    private bool exhausted;
    private IPositionIncrementAttribute posIncAtt;
    public LimitTokenPositionFilter(TokenStream in, int maxTokenPosition);
    public LimitTokenPositionFilter(TokenStream in, int maxTokenPosition, bool consumeAllTokens);
    public virtual bool IncrementToken();
    public virtual void Reset();
}
public class Lucene.Net.Analysis.Miscellaneous.LimitTokenPositionFilterFactory : TokenFilterFactory {
    public static string MAX_TOKEN_POSITION_KEY;
    public static string CONSUME_ALL_TOKENS_KEY;
    private int maxTokenPosition;
    private bool consumeAllTokens;
    public LimitTokenPositionFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
[ObsoleteAttribute]
public class Lucene.Net.Analysis.Miscellaneous.Lucene47WordDelimiterFilter : TokenFilter {
    public static int LOWER;
    public static int UPPER;
    public static int DIGIT;
    public static int SUBWORD_DELIM;
    public static int ALPHA;
    public static int ALPHANUM;
    private CharArraySet protWords;
    private WordDelimiterFlags flags;
    private ICharTermAttribute termAttribute;
    private IOffsetAttribute offsetAttribute;
    private IPositionIncrementAttribute posIncAttribute;
    private ITypeAttribute typeAttribute;
    private WordDelimiterIterator iterator;
    private WordDelimiterConcatenation concat;
    private int lastConcatCount;
    private WordDelimiterConcatenation concatAll;
    private int accumPosInc;
    private Char[] savedBuffer;
    private int savedStartOffset;
    private int savedEndOffset;
    private string savedType;
    private bool hasSavedState;
    private bool hasIllegalOffsets;
    private bool hasOutputToken;
    private bool hasOutputFollowingOriginal;
    public Lucene47WordDelimiterFilter(TokenStream in, Byte[] charTypeTable, WordDelimiterFlags configurationFlags, CharArraySet protWords);
    public Lucene47WordDelimiterFilter(TokenStream in, WordDelimiterFlags configurationFlags, CharArraySet protWords);
    public virtual bool IncrementToken();
    public virtual void Reset();
    private void SaveState();
    private bool FlushConcatenation(WordDelimiterConcatenation concatenation);
    private bool ShouldConcatenate(int wordType);
    private bool ShouldGenerateParts(int wordType);
    private void Concatenate(WordDelimiterConcatenation concatenation);
    private void GeneratePart(bool isSingleWord);
    private int Position(bool inject);
    private static bool IsAlpha(int type);
    private static bool IsDigit(int type);
    private static bool IsSubwordDelim(int type);
    private static bool IsUpper(int type);
    private bool Has(WordDelimiterFlags flag);
}
[ObsoleteAttribute("(4.0) use the pattern-based analysis in the analysis/pattern package instead.")]
public class Lucene.Net.Analysis.Miscellaneous.PatternAnalyzer : Analyzer {
    public static Regex NON_WORD_PATTERN;
    public static Regex WHITESPACE_PATTERN;
    private static CharArraySet EXTENDED_ENGLISH_STOP_WORDS;
    public static PatternAnalyzer DEFAULT_ANALYZER;
    public static PatternAnalyzer EXTENDED_ANALYZER;
    private Regex pattern;
    private bool toLowerCase;
    private CharArraySet stopWords;
    private LuceneVersion matchVersion;
    public PatternAnalyzer(LuceneVersion matchVersion, Regex pattern, bool toLowerCase, CharArraySet stopWords);
    private static PatternAnalyzer();
    public TokenStreamComponents CreateComponents(string fieldName, TextReader reader, string text);
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    private static bool Eq(object o1, object o2);
    private static bool EqPattern(Regex p1, Regex p2);
    private static string ToString(TextReader input);
}
public class Lucene.Net.Analysis.Miscellaneous.PatternKeywordMarkerFilter : KeywordMarkerFilter {
    private ICharTermAttribute termAtt;
    private Match matcher;
    private Regex pattern;
    public PatternKeywordMarkerFilter(TokenStream in, Regex pattern);
    protected virtual bool IsKeyword();
}
public class Lucene.Net.Analysis.Miscellaneous.PerFieldAnalyzerWrapper : AnalyzerWrapper {
    private Analyzer defaultAnalyzer;
    private IDictionary`2<string, Analyzer> fieldAnalyzers;
    public PerFieldAnalyzerWrapper(Analyzer defaultAnalyzer);
    public PerFieldAnalyzerWrapper(Analyzer defaultAnalyzer, IDictionary`2<string, Analyzer> fieldAnalyzers);
    protected virtual Analyzer GetWrappedAnalyzer(string fieldName);
    public virtual string ToString();
}
public class Lucene.Net.Analysis.Miscellaneous.PrefixAndSuffixAwareTokenFilter : TokenStream {
    private PrefixAwareTokenFilter suffix;
    public PrefixAndSuffixAwareTokenFilter(TokenStream prefix, TokenStream input, TokenStream suffix);
    public virtual Token UpdateInputToken(Token inputToken, Token lastPrefixToken);
    public virtual Token UpdateSuffixToken(Token suffixToken, Token lastInputToken);
    public sealed virtual bool IncrementToken();
    public virtual void Reset();
    protected virtual void Dispose(bool disposing);
    public virtual void End();
}
public class Lucene.Net.Analysis.Miscellaneous.PrefixAwareTokenFilter : TokenStream {
    private TokenStream prefix;
    private TokenStream suffix;
    private ICharTermAttribute termAtt;
    private IPositionIncrementAttribute posIncrAtt;
    private IPayloadAttribute payloadAtt;
    private IOffsetAttribute offsetAtt;
    private ITypeAttribute typeAtt;
    private IFlagsAttribute flagsAtt;
    private ICharTermAttribute p_termAtt;
    private IPositionIncrementAttribute p_posIncrAtt;
    private IPayloadAttribute p_payloadAtt;
    private IOffsetAttribute p_offsetAtt;
    private ITypeAttribute p_typeAtt;
    private IFlagsAttribute p_flagsAtt;
    private Token previousPrefixToken;
    private Token reusableToken;
    private bool prefixExhausted;
    public TokenStream Prefix { get; public set; }
    public TokenStream Suffix { get; public set; }
    public PrefixAwareTokenFilter(TokenStream prefix, TokenStream suffix);
    public sealed virtual bool IncrementToken();
    private void SetCurrentToken(Token token);
    private Token GetNextPrefixInputToken(Token token);
    private Token GetNextSuffixInputToken(Token token);
    public virtual Token UpdateSuffixToken(Token suffixToken, Token lastPrefixToken);
    public virtual void End();
    protected virtual void Dispose(bool disposing);
    public virtual void Reset();
    public virtual TokenStream get_Prefix();
    public virtual void set_Prefix(TokenStream value);
    public virtual TokenStream get_Suffix();
    public virtual void set_Suffix(TokenStream value);
}
public class Lucene.Net.Analysis.Miscellaneous.RemoveDuplicatesTokenFilter : TokenFilter {
    private ICharTermAttribute termAttribute;
    private IPositionIncrementAttribute posIncAttribute;
    private CharArraySet previous;
    public RemoveDuplicatesTokenFilter(TokenStream in);
    public sealed virtual bool IncrementToken();
    public virtual void Reset();
}
public class Lucene.Net.Analysis.Miscellaneous.RemoveDuplicatesTokenFilterFactory : TokenFilterFactory {
    public RemoveDuplicatesTokenFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Miscellaneous.ScandinavianFoldingFilter : TokenFilter {
    private ICharTermAttribute charTermAttribute;
    private static char AA;
    private static char aa;
    private static char AE;
    private static char ae;
    private static char AE_se;
    private static char ae_se;
    private static char OE;
    private static char oe;
    private static char OE_se;
    private static char oe_se;
    public ScandinavianFoldingFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Miscellaneous.ScandinavianFoldingFilterFactory : TokenFilterFactory {
    public ScandinavianFoldingFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Miscellaneous.ScandinavianNormalizationFilter : TokenFilter {
    private ICharTermAttribute charTermAttribute;
    private static char AA;
    private static char aa;
    private static char AE;
    private static char ae;
    private static char AE_se;
    private static char ae_se;
    private static char OE;
    private static char oe;
    private static char OE_se;
    private static char oe_se;
    public ScandinavianNormalizationFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Miscellaneous.ScandinavianNormalizationFilterFactory : TokenFilterFactory {
    public ScandinavianNormalizationFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Miscellaneous.SetKeywordMarkerFilter : KeywordMarkerFilter {
    private ICharTermAttribute termAtt;
    private CharArraySet keywordSet;
    public SetKeywordMarkerFilter(TokenStream in, CharArraySet keywordSet);
    protected virtual bool IsKeyword();
}
public class Lucene.Net.Analysis.Miscellaneous.SingleTokenTokenStream : TokenStream {
    private bool exhausted;
    private Token singleToken;
    private ICharTermAttribute tokenAtt;
    public SingleTokenTokenStream(Token token);
    public sealed virtual bool IncrementToken();
    public virtual void Reset();
    public Token GetToken();
    public void SetToken(Token token);
}
public class Lucene.Net.Analysis.Miscellaneous.StemmerOverrideFilter : TokenFilter {
    private StemmerOverrideMap stemmerOverrideMap;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAtt;
    private BytesReader fstReader;
    private Arc`1<BytesRef> scratchArc;
    private CharsRef spare;
    public StemmerOverrideFilter(TokenStream input, StemmerOverrideMap stemmerOverrideMap);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Miscellaneous.StemmerOverrideFilterFactory : TokenFilterFactory {
    private StemmerOverrideMap dictionary;
    private string dictionaryFiles;
    private bool ignoreCase;
    public bool IgnoreCase { get; }
    public StemmerOverrideFilterFactory(IDictionary`2<string, string> args);
    public virtual void Inform(IResourceLoader loader);
    public virtual bool get_IgnoreCase();
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Miscellaneous.TrimFilter : TokenFilter {
    private bool updateOffsets;
    private ICharTermAttribute termAtt;
    private IOffsetAttribute offsetAtt;
    [ObsoleteAttribute("Offset updates are not supported anymore as of Lucene 4.4.")]
public TrimFilter(LuceneVersion version, TokenStream in, bool updateOffsets);
    public TrimFilter(LuceneVersion version, TokenStream in);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Miscellaneous.TrimFilterFactory : TokenFilterFactory {
    protected bool m_updateOffsets;
    public TrimFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Miscellaneous.TruncateTokenFilter : TokenFilter {
    private ICharTermAttribute termAttribute;
    private IKeywordAttribute keywordAttr;
    private int length;
    public TruncateTokenFilter(TokenStream input, int length);
    public sealed virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Miscellaneous.TruncateTokenFilterFactory : TokenFilterFactory {
    public static string PREFIX_LENGTH_KEY;
    private sbyte prefixLength;
    public TruncateTokenFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Miscellaneous.WordDelimiterFilter : TokenFilter {
    internal static int NOT_SET;
    public static int LOWER;
    public static int UPPER;
    public static int DIGIT;
    public static int SUBWORD_DELIM;
    public static int ALPHA;
    public static int ALPHANUM;
    private CharArraySet protWords;
    private WordDelimiterFlags flags;
    private ICharTermAttribute termAttribute;
    private IOffsetAttribute offsetAttribute;
    private IPositionIncrementAttribute posIncAttribute;
    private ITypeAttribute typeAttribute;
    private WordDelimiterIterator iterator;
    private WordDelimiterConcatenation concat;
    private int lastConcatCount;
    private WordDelimiterConcatenation concatAll;
    private int accumPosInc;
    private Char[] savedBuffer;
    private int savedStartOffset;
    private int savedEndOffset;
    private string savedType;
    private bool hasSavedState;
    private bool hasIllegalOffsets;
    private bool hasOutputToken;
    private bool hasOutputFollowingOriginal;
    private State[] buffered;
    private Int32[] startOff;
    private Int32[] posInc;
    private int bufferedLen;
    private int bufferedPos;
    private bool first;
    private OffsetSorter sorter;
    public WordDelimiterFilter(LuceneVersion matchVersion, TokenStream in, Byte[] charTypeTable, WordDelimiterFlags configurationFlags, CharArraySet protWords);
    public WordDelimiterFilter(LuceneVersion matchVersion, TokenStream in, WordDelimiterFlags configurationFlags, CharArraySet protWords);
    public virtual bool IncrementToken();
    public virtual void Reset();
    private void Buffer();
    private void SaveState();
    private bool FlushConcatenation(WordDelimiterConcatenation concatenation);
    private bool ShouldConcatenate(int wordType);
    private bool ShouldGenerateParts(int wordType);
    private void Concatenate(WordDelimiterConcatenation concatenation);
    private void GeneratePart(bool isSingleWord);
    private int Position(bool inject);
    internal static bool IsAlpha(int type);
    internal static bool IsDigit(int type);
    internal static bool IsSubwordDelim(int type);
    internal static bool IsUpper(int type);
    private bool Has(WordDelimiterFlags flag);
}
public class Lucene.Net.Analysis.Miscellaneous.WordDelimiterFilterFactory : TokenFilterFactory {
    public static string PROTECTED_TOKENS;
    public static string TYPES;
    private string wordFiles;
    private string types;
    private WordDelimiterFlags flags;
    private Byte[] typeTable;
    private CharArraySet protectedWords;
    private static Regex typePattern;
    internal Char[] out;
    public WordDelimiterFilterFactory(IDictionary`2<string, string> args);
    private static WordDelimiterFilterFactory();
    public virtual void Inform(IResourceLoader loader);
    public virtual TokenStream Create(TokenStream input);
    private Byte[] ParseTypes(IList`1<string> rules);
    private byte ParseType(string s);
    private string ParseString(string s);
}
[FlagsAttribute]
public enum Lucene.Net.Analysis.Miscellaneous.WordDelimiterFlags : Enum {
    public int value__;
    public static WordDelimiterFlags GENERATE_WORD_PARTS;
    public static WordDelimiterFlags GENERATE_NUMBER_PARTS;
    public static WordDelimiterFlags CATENATE_WORDS;
    public static WordDelimiterFlags CATENATE_NUMBERS;
    public static WordDelimiterFlags CATENATE_ALL;
    public static WordDelimiterFlags PRESERVE_ORIGINAL;
    public static WordDelimiterFlags SPLIT_ON_CASE_CHANGE;
    public static WordDelimiterFlags SPLIT_ON_NUMERICS;
    public static WordDelimiterFlags STEM_ENGLISH_POSSESSIVE;
}
public class Lucene.Net.Analysis.Miscellaneous.WordDelimiterIterator : object {
    public static int DONE;
    public static Byte[] DEFAULT_WORD_DELIM_TABLE;
    internal Char[] text;
    private int length;
    private int startBounds;
    private int endBounds;
    internal int current;
    internal int end;
    private bool hasFinalPossessive;
    private bool splitOnCaseChange;
    private bool splitOnNumerics;
    private bool stemEnglishPossessive;
    private Byte[] charTypeTable;
    private bool skipPossessive;
    internal int Type { get; }
    internal WordDelimiterIterator(Byte[] charTypeTable, bool splitOnCaseChange, bool splitOnNumerics, bool stemEnglishPossessive);
    private static WordDelimiterIterator();
    private static Byte[] LoadDefaultWordDelimTable();
    internal int Next();
    internal int get_Type();
    internal void SetText(Char[] text, int length);
    private bool IsBreak(int lastType, int type);
    internal bool IsSingleWord();
    private void SetBounds();
    private bool EndsWithPossessive(int pos);
    private int CharType(int ch);
    public static byte GetType(int ch);
}
public class Lucene.Net.Analysis.NGram.EdgeNGramFilterFactory : TokenFilterFactory {
    private int maxGramSize;
    private int minGramSize;
    private string side;
    public EdgeNGramFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.NGram.EdgeNGramTokenFilter : TokenFilter {
    public static Side DEFAULT_SIDE;
    public static int DEFAULT_MAX_GRAM_SIZE;
    public static int DEFAULT_MIN_GRAM_SIZE;
    private LuceneVersion version;
    private CharacterUtils charUtils;
    private int minGram;
    private int maxGram;
    private Side side;
    private Char[] curTermBuffer;
    private int curTermLength;
    private int curCodePointCount;
    private int curGramSize;
    private int tokStart;
    private int tokEnd;
    private bool updateOffsets;
    private int savePosIncr;
    private int savePosLen;
    private ICharTermAttribute termAtt;
    private IOffsetAttribute offsetAtt;
    private IPositionIncrementAttribute posIncrAtt;
    private IPositionLengthAttribute posLenAtt;
    [ObsoleteAttribute]
public EdgeNGramTokenFilter(LuceneVersion version, TokenStream input, Side side, int minGram, int maxGram);
    [ObsoleteAttribute]
public EdgeNGramTokenFilter(LuceneVersion version, TokenStream input, string sideLabel, int minGram, int maxGram);
    public EdgeNGramTokenFilter(LuceneVersion version, TokenStream input, int minGram, int maxGram);
    public static Side GetSide(string sideName);
    public sealed virtual bool IncrementToken();
    public virtual void Reset();
}
public class Lucene.Net.Analysis.NGram.EdgeNGramTokenizer : NGramTokenizer {
    public static int DEFAULT_MAX_GRAM_SIZE;
    public static int DEFAULT_MIN_GRAM_SIZE;
    public EdgeNGramTokenizer(LuceneVersion version, TextReader input, int minGram, int maxGram);
    public EdgeNGramTokenizer(LuceneVersion version, AttributeFactory factory, TextReader input, int minGram, int maxGram);
}
public class Lucene.Net.Analysis.NGram.EdgeNGramTokenizerFactory : TokenizerFactory {
    private int maxGramSize;
    private int minGramSize;
    private string side;
    public EdgeNGramTokenizerFactory(IDictionary`2<string, string> args);
    public virtual Tokenizer Create(AttributeFactory factory, TextReader input);
}
[ObsoleteAttribute]
public class Lucene.Net.Analysis.NGram.Lucene43EdgeNGramTokenizer : Tokenizer {
    public static Side DEFAULT_SIDE;
    public static int DEFAULT_MAX_GRAM_SIZE;
    public static int DEFAULT_MIN_GRAM_SIZE;
    private ICharTermAttribute termAtt;
    private IOffsetAttribute offsetAtt;
    private IPositionIncrementAttribute posIncrAtt;
    private int minGram;
    private int maxGram;
    private int gramSize;
    private Side side;
    private bool started;
    private int inLen;
    private int charsRead;
    private string inStr;
    [ObsoleteAttribute]
public Lucene43EdgeNGramTokenizer(LuceneVersion version, TextReader input, Side side, int minGram, int maxGram);
    [ObsoleteAttribute]
public Lucene43EdgeNGramTokenizer(LuceneVersion version, AttributeFactory factory, TextReader input, Side side, int minGram, int maxGram);
    [ObsoleteAttribute]
public Lucene43EdgeNGramTokenizer(LuceneVersion version, TextReader input, string sideLabel, int minGram, int maxGram);
    [ObsoleteAttribute]
public Lucene43EdgeNGramTokenizer(LuceneVersion version, AttributeFactory factory, TextReader input, string sideLabel, int minGram, int maxGram);
    public Lucene43EdgeNGramTokenizer(LuceneVersion version, TextReader input, int minGram, int maxGram);
    public Lucene43EdgeNGramTokenizer(LuceneVersion version, AttributeFactory factory, TextReader input, int minGram, int maxGram);
    public static Side GetSide(string sideName);
    private void Init(LuceneVersion version, Side side, int minGram, int maxGram);
    public virtual bool IncrementToken();
    public virtual void End();
    public virtual void Reset();
}
[ObsoleteAttribute]
public class Lucene.Net.Analysis.NGram.Lucene43NGramTokenizer : Tokenizer {
    public static int DEFAULT_MIN_NGRAM_SIZE;
    public static int DEFAULT_MAX_NGRAM_SIZE;
    private int minGram;
    private int maxGram;
    private int gramSize;
    private int pos;
    private int inLen;
    private int charsRead;
    private string inStr;
    private bool started;
    private ICharTermAttribute termAtt;
    private IOffsetAttribute offsetAtt;
    public Lucene43NGramTokenizer(TextReader input, int minGram, int maxGram);
    public Lucene43NGramTokenizer(AttributeFactory factory, TextReader input, int minGram, int maxGram);
    public Lucene43NGramTokenizer(TextReader input);
    private void Init(int minGram, int maxGram);
    public virtual bool IncrementToken();
    public virtual void End();
    public virtual void Reset();
}
public class Lucene.Net.Analysis.NGram.NGramFilterFactory : TokenFilterFactory {
    private int maxGramSize;
    private int minGramSize;
    public NGramFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.NGram.NGramTokenFilter : TokenFilter {
    public static int DEFAULT_MIN_NGRAM_SIZE;
    public static int DEFAULT_MAX_NGRAM_SIZE;
    private int minGram;
    private int maxGram;
    private Char[] curTermBuffer;
    private int curTermLength;
    private int curCodePointCount;
    private int curGramSize;
    private int curPos;
    private int curPosInc;
    private int curPosLen;
    private int tokStart;
    private int tokEnd;
    private bool hasIllegalOffsets;
    private LuceneVersion version;
    private CharacterUtils charUtils;
    private ICharTermAttribute termAtt;
    private IPositionIncrementAttribute posIncAtt;
    private IPositionLengthAttribute posLenAtt;
    private IOffsetAttribute offsetAtt;
    public NGramTokenFilter(LuceneVersion version, TokenStream input, int minGram, int maxGram);
    public NGramTokenFilter(LuceneVersion version, TokenStream input);
    public sealed virtual bool IncrementToken();
    public virtual void Reset();
}
public class Lucene.Net.Analysis.NGram.NGramTokenizer : Tokenizer {
    public static int DEFAULT_MIN_NGRAM_SIZE;
    public static int DEFAULT_MAX_NGRAM_SIZE;
    private CharacterUtils charUtils;
    private CharacterBuffer charBuffer;
    private Int32[] buffer;
    private int bufferStart;
    private int bufferEnd;
    private int offset;
    private int gramSize;
    private int minGram;
    private int maxGram;
    private bool exhausted;
    private int lastCheckedChar;
    private int lastNonTokenChar;
    private bool edgesOnly;
    private ICharTermAttribute termAtt;
    private IPositionIncrementAttribute posIncAtt;
    private IPositionLengthAttribute posLenAtt;
    private IOffsetAttribute offsetAtt;
    internal NGramTokenizer(LuceneVersion version, TextReader input, int minGram, int maxGram, bool edgesOnly);
    public NGramTokenizer(LuceneVersion version, TextReader input, int minGram, int maxGram);
    internal NGramTokenizer(LuceneVersion version, AttributeFactory factory, TextReader input, int minGram, int maxGram, bool edgesOnly);
    public NGramTokenizer(LuceneVersion version, AttributeFactory factory, TextReader input, int minGram, int maxGram);
    public NGramTokenizer(LuceneVersion version, TextReader input);
    private void Init(LuceneVersion version, int minGram, int maxGram, bool edgesOnly);
    public sealed virtual bool IncrementToken();
    private void UpdateLastNonTokenChar();
    private void Consume();
    protected virtual bool IsTokenChar(int chr);
    public sealed virtual void End();
    public sealed virtual void Reset();
}
public class Lucene.Net.Analysis.NGram.NGramTokenizerFactory : TokenizerFactory {
    private int maxGramSize;
    private int minGramSize;
    public NGramTokenizerFactory(IDictionary`2<string, string> args);
    public virtual Tokenizer Create(AttributeFactory factory, TextReader input);
}
[ExtensionAttribute]
internal static class Lucene.Net.Analysis.NGram.SideExtensions : object {
    [ExtensionAttribute]
internal static bool IsDefined(Side side);
    [ExtensionAttribute]
internal static bool IsDefined(Side side);
}
public class Lucene.Net.Analysis.Nl.DutchAnalyzer : Analyzer {
    public static string DEFAULT_STOPWORD_FILE;
    private CharArraySet stoptable;
    private CharArraySet excltable;
    private StemmerOverrideMap stemdict;
    private CharArrayMap`1<string> origStemdict;
    private LuceneVersion matchVersion;
    public static CharArraySet DefaultStopSet { get; }
    public DutchAnalyzer(LuceneVersion matchVersion);
    public DutchAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public DutchAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionTable);
    public DutchAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionTable, CharArrayMap`1<string> stemOverrideDict);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader aReader);
}
[ObsoleteAttribute("(3.1) Use Snowball.SnowballFilter with Tartarus.Snowball.Ext.DutchStemmer instead, which has the same functionality. This filter will be removed in Lucene 5.0")]
public class Lucene.Net.Analysis.Nl.DutchStemFilter : TokenFilter {
    private DutchStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public DutchStemmer Stemmer { get; public set; }
    public CharArrayMap`1<string> StemDictionary { get; public set; }
    public DutchStemFilter(TokenStream in);
    public DutchStemFilter(TokenStream in, IDictionary`2<string, string> stemdictionary);
    public virtual bool IncrementToken();
    public DutchStemmer get_Stemmer();
    public void set_Stemmer(DutchStemmer value);
    public CharArrayMap`1<string> get_StemDictionary();
    public void set_StemDictionary(CharArrayMap`1<string> value);
}
[ObsoleteAttribute("(3.1) Use Tartarus.Snowball.Ext.DutchStemmer instead, which has the same functionality. This filter will be removed in Lucene 5.0")]
public class Lucene.Net.Analysis.Nl.DutchStemmer : object {
    private static CultureInfo locale;
    private StringBuilder sb;
    private bool _removedE;
    private IDictionary`2<string, string> _stemDict;
    private int _R1;
    private int _R2;
    internal IDictionary`2<string, string> StemDictionary { get; internal set; }
    private static DutchStemmer();
    public virtual string Stem(string term);
    private bool EnEnding(StringBuilder sb);
    private void Step1(StringBuilder sb);
    private void Step2(StringBuilder sb);
    private void Step3a(StringBuilder sb);
    private void Step3b(StringBuilder sb);
    private void Step4(StringBuilder sb);
    private bool IsStemmable(string term);
    private void Substitute(StringBuilder buffer);
    private bool IsValidSEnding(StringBuilder sb, int index);
    private bool IsValidEnEnding(StringBuilder sb, int index);
    private void UnDouble(StringBuilder sb);
    private void UnDouble(StringBuilder sb, int endIndex);
    private int GetRIndex(StringBuilder sb, int start);
    private void StoreYandI(StringBuilder sb);
    private void ReStoreYandI(StringBuilder sb);
    private bool IsVowel(char c);
    internal virtual IDictionary`2<string, string> get_StemDictionary();
    internal virtual void set_StemDictionary(IDictionary`2<string, string> value);
}
public class Lucene.Net.Analysis.No.NorwegianAnalyzer : StopwordAnalyzerBase {
    private CharArraySet stemExclusionSet;
    public static string DEFAULT_STOPWORD_FILE;
    public static CharArraySet DefaultStopSet { get; }
    public NorwegianAnalyzer(LuceneVersion matchVersion);
    public NorwegianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public NorwegianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.No.NorwegianLightStemFilter : TokenFilter {
    private NorwegianLightStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public NorwegianLightStemFilter(TokenStream input);
    public NorwegianLightStemFilter(TokenStream input, NorwegianStandard flags);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.No.NorwegianLightStemFilterFactory : TokenFilterFactory {
    private NorwegianStandard flags;
    public NorwegianLightStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.No.NorwegianLightStemmer : object {
    private bool useBokmaal;
    private bool useNynorsk;
    public NorwegianLightStemmer(NorwegianStandard flags);
    public virtual int Stem(Char[] s, int len);
}
public class Lucene.Net.Analysis.No.NorwegianMinimalStemFilter : TokenFilter {
    private NorwegianMinimalStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public NorwegianMinimalStemFilter(TokenStream input);
    public NorwegianMinimalStemFilter(TokenStream input, NorwegianStandard flags);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.No.NorwegianMinimalStemFilterFactory : TokenFilterFactory {
    private NorwegianStandard flags;
    public NorwegianMinimalStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.No.NorwegianMinimalStemmer : object {
    private bool useNynorsk;
    public NorwegianMinimalStemmer(NorwegianStandard flags);
    public virtual int Stem(Char[] s, int len);
}
[FlagsAttribute]
public enum Lucene.Net.Analysis.No.NorwegianStandard : Enum {
    public int value__;
    public static NorwegianStandard BOKMAAL;
    public static NorwegianStandard NYNORSK;
}
public class Lucene.Net.Analysis.Path.PathHierarchyTokenizer : Tokenizer {
    private static int DEFAULT_BUFFER_SIZE;
    public static char DEFAULT_DELIMITER;
    public static int DEFAULT_SKIP;
    private char delimiter;
    private char replacement;
    private int skip;
    private ICharTermAttribute termAtt;
    private IOffsetAttribute offsetAtt;
    private IPositionIncrementAttribute posAtt;
    private int startPosition;
    private int skipped;
    private bool endDelimiter;
    private StringBuilder resultToken;
    private int charsRead;
    public PathHierarchyTokenizer(TextReader input);
    public PathHierarchyTokenizer(TextReader input, int skip);
    public PathHierarchyTokenizer(TextReader input, int bufferSize, char delimiter);
    public PathHierarchyTokenizer(TextReader input, char delimiter, char replacement);
    public PathHierarchyTokenizer(TextReader input, char delimiter, char replacement, int skip);
    public PathHierarchyTokenizer(AttributeFactory factory, TextReader input, char delimiter, char replacement, int skip);
    public PathHierarchyTokenizer(TextReader input, int bufferSize, char delimiter, char replacement, int skip);
    public PathHierarchyTokenizer(AttributeFactory factory, TextReader input, int bufferSize, char delimiter, char replacement, int skip);
    public sealed virtual bool IncrementToken();
    public sealed virtual void End();
    public virtual void Reset();
}
public class Lucene.Net.Analysis.Path.PathHierarchyTokenizerFactory : TokenizerFactory {
    private char delimiter;
    private char replacement;
    private bool reverse;
    private int skip;
    public PathHierarchyTokenizerFactory(IDictionary`2<string, string> args);
    public virtual Tokenizer Create(AttributeFactory factory, TextReader input);
}
public class Lucene.Net.Analysis.Path.ReversePathHierarchyTokenizer : Tokenizer {
    private static int DEFAULT_BUFFER_SIZE;
    public static char DEFAULT_DELIMITER;
    public static int DEFAULT_SKIP;
    private char delimiter;
    private char replacement;
    private int skip;
    private ICharTermAttribute termAtt;
    private IOffsetAttribute offsetAtt;
    private IPositionIncrementAttribute posAtt;
    private int endPosition;
    private int finalOffset;
    private int skipped;
    private StringBuilder resultToken;
    private IList`1<int> delimiterPositions;
    private int delimitersCount;
    private Char[] resultTokenBuffer;
    public ReversePathHierarchyTokenizer(TextReader input);
    public ReversePathHierarchyTokenizer(TextReader input, int skip);
    public ReversePathHierarchyTokenizer(TextReader input, int bufferSize, char delimiter);
    public ReversePathHierarchyTokenizer(TextReader input, char delimiter, char replacement);
    public ReversePathHierarchyTokenizer(TextReader input, int bufferSize, char delimiter, char replacement);
    public ReversePathHierarchyTokenizer(TextReader input, char delimiter, int skip);
    public ReversePathHierarchyTokenizer(TextReader input, char delimiter, char replacement, int skip);
    public ReversePathHierarchyTokenizer(AttributeFactory factory, TextReader input, char delimiter, char replacement, int skip);
    public ReversePathHierarchyTokenizer(TextReader input, int bufferSize, char delimiter, char replacement, int skip);
    public ReversePathHierarchyTokenizer(AttributeFactory factory, TextReader input, int bufferSize, char delimiter, char replacement, int skip);
    public sealed virtual bool IncrementToken();
    public sealed virtual void End();
    public virtual void Reset();
}
public class Lucene.Net.Analysis.Pattern.PatternCaptureGroupFilterFactory : TokenFilterFactory {
    private Regex pattern;
    private bool preserveOriginal;
    public PatternCaptureGroupFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Pattern.PatternCaptureGroupTokenFilter : TokenFilter {
    private ICharTermAttribute charTermAttr;
    private IPositionIncrementAttribute posAttr;
    private State state;
    private Match[] matchers;
    private Regex[] patterns;
    private CharsRef spare;
    private Int32[] groupCounts;
    private bool preserveOriginal;
    private Int32[] currentGroup;
    private int currentMatcher;
    public PatternCaptureGroupTokenFilter(TokenStream input, bool preserveOriginal, Regex[] patterns);
    private bool NextCapture();
    public virtual bool IncrementToken();
    public virtual void Reset();
}
public class Lucene.Net.Analysis.Pattern.PatternReplaceCharFilter : BaseCharFilter {
    [ObsoleteAttribute]
public static int DEFAULT_MAX_BLOCK_CHARS;
    private Regex pattern;
    private string replacement;
    private TextReader transformedInput;
    public PatternReplaceCharFilter(Regex pattern, string replacement, TextReader in);
    [ObsoleteAttribute]
public PatternReplaceCharFilter(Regex pattern, string replacement, int maxBlockChars, string blockDelimiter, TextReader in);
    public virtual int Read(Char[] cbuf, int off, int len);
    private void Fill();
    public virtual int Read();
    protected virtual int Correct(int currentOff);
    private string ProcessPattern(StringBuilder input);
}
public class Lucene.Net.Analysis.Pattern.PatternReplaceCharFilterFactory : CharFilterFactory {
    private Regex pattern;
    private string replacement;
    private int maxBlockChars;
    private string blockDelimiters;
    public PatternReplaceCharFilterFactory(IDictionary`2<string, string> args);
    public virtual TextReader Create(TextReader input);
}
public class Lucene.Net.Analysis.Pattern.PatternReplaceFilter : TokenFilter {
    private string replacement;
    private bool all;
    private ICharTermAttribute termAtt;
    private Regex pattern;
    public PatternReplaceFilter(TokenStream in, Regex pattern, string replacement, bool all);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Pattern.PatternReplaceFilterFactory : TokenFilterFactory {
    private Regex pattern;
    private string replacement;
    private bool replaceAll;
    public PatternReplaceFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Pattern.PatternTokenizer : Tokenizer {
    private ICharTermAttribute termAtt;
    private IOffsetAttribute offsetAtt;
    private StringBuilder str;
    private int index;
    private bool isReset;
    private int group;
    private Match matcher;
    private Regex pattern;
    private Char[] buffer;
    public PatternTokenizer(TextReader input, Regex pattern, int group);
    public PatternTokenizer(AttributeFactory factory, TextReader input, Regex pattern, int group);
    public virtual bool IncrementToken();
    public virtual void End();
    public virtual void Reset();
    private void FillBuffer(StringBuilder sb, TextReader input);
}
public class Lucene.Net.Analysis.Pattern.PatternTokenizerFactory : TokenizerFactory {
    public static string PATTERN;
    public static string GROUP;
    protected Regex m_pattern;
    protected int m_group;
    public PatternTokenizerFactory(IDictionary`2<string, string> args);
    public virtual Tokenizer Create(AttributeFactory factory, TextReader input);
}
public abstract class Lucene.Net.Analysis.Payloads.AbstractEncoder : object {
    public abstract virtual BytesRef Encode(Char[] buffer, int offset, int length);
    public virtual BytesRef Encode(Char[] buffer);
}
public class Lucene.Net.Analysis.Payloads.DelimitedPayloadTokenFilter : TokenFilter {
    public static char DEFAULT_DELIMITER;
    private char delimiter;
    private ICharTermAttribute termAtt;
    private IPayloadAttribute payAtt;
    private IPayloadEncoder encoder;
    public DelimitedPayloadTokenFilter(TokenStream input, char delimiter, IPayloadEncoder encoder);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Payloads.DelimitedPayloadTokenFilterFactory : TokenFilterFactory {
    public static string ENCODER_ATTR;
    public static string DELIMITER_ATTR;
    private string encoderClass;
    private char delimiter;
    private IPayloadEncoder encoder;
    public DelimitedPayloadTokenFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
    public virtual void Inform(IResourceLoader loader);
}
public class Lucene.Net.Analysis.Payloads.IdentityEncoder : AbstractEncoder {
    protected internal Encoding m_charset;
    public IdentityEncoder(Encoding charset);
    public virtual BytesRef Encode(Char[] buffer, int offset, int length);
}
public class Lucene.Net.Analysis.Payloads.IntegerEncoder : AbstractEncoder {
    public virtual BytesRef Encode(Char[] buffer, int offset, int length);
}
public interface Lucene.Net.Analysis.Payloads.IPayloadEncoder {
    public abstract virtual BytesRef Encode(Char[] buffer);
    public abstract virtual BytesRef Encode(Char[] buffer, int offset, int length);
}
public class Lucene.Net.Analysis.Payloads.NumericPayloadTokenFilter : TokenFilter {
    private string typeMatch;
    private BytesRef thePayload;
    private IPayloadAttribute payloadAtt;
    private ITypeAttribute typeAtt;
    public NumericPayloadTokenFilter(TokenStream input, float payload, string typeMatch);
    public sealed virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Payloads.NumericPayloadTokenFilterFactory : TokenFilterFactory {
    private float payload;
    private string typeMatch;
    public NumericPayloadTokenFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public static class Lucene.Net.Analysis.Payloads.PayloadHelper : object {
    public static Byte[] EncodeSingle(float payload);
    public static Byte[] EncodeSingle(float payload, Byte[] data, int offset);
    public static Byte[] EncodeInt32(int payload);
    public static Byte[] EncodeInt32(int payload, Byte[] data, int offset);
    public static float DecodeSingle(Byte[] bytes);
    public static float DecodeSingle(Byte[] bytes, int offset);
    public static int DecodeInt32(Byte[] bytes, int offset);
}
public class Lucene.Net.Analysis.Payloads.SingleEncoder : AbstractEncoder {
    public virtual BytesRef Encode(Char[] buffer, int offset, int length);
}
public class Lucene.Net.Analysis.Payloads.TokenOffsetPayloadTokenFilter : TokenFilter {
    private IOffsetAttribute offsetAtt;
    private IPayloadAttribute payAtt;
    public TokenOffsetPayloadTokenFilter(TokenStream input);
    public sealed virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Payloads.TokenOffsetPayloadTokenFilterFactory : TokenFilterFactory {
    public TokenOffsetPayloadTokenFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Payloads.TypeAsPayloadTokenFilter : TokenFilter {
    private IPayloadAttribute payloadAtt;
    private ITypeAttribute typeAtt;
    public TypeAsPayloadTokenFilter(TokenStream input);
    public sealed virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Payloads.TypeAsPayloadTokenFilterFactory : TokenFilterFactory {
    public TypeAsPayloadTokenFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
[ObsoleteAttribute("(4.4) PositionFilter makes TokenStream graphs inconsistent")]
public class Lucene.Net.Analysis.Position.PositionFilter : TokenFilter {
    private int positionIncrement;
    private bool firstTokenPositioned;
    private IPositionIncrementAttribute posIncrAtt;
    public PositionFilter(TokenStream input);
    public PositionFilter(TokenStream input, int positionIncrement);
    public virtual bool IncrementToken();
    public virtual void Reset();
}
[ObsoleteAttribute("(4.4)")]
public class Lucene.Net.Analysis.Position.PositionFilterFactory : TokenFilterFactory {
    private int positionIncrement;
    public PositionFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Pt.PortugueseAnalyzer : StopwordAnalyzerBase {
    private CharArraySet stemExclusionSet;
    public static string DEFAULT_STOPWORD_FILE;
    public static CharArraySet DefaultStopSet { get; }
    public PortugueseAnalyzer(LuceneVersion matchVersion);
    public PortugueseAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public PortugueseAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Pt.PortugueseLightStemFilter : TokenFilter {
    private PortugueseLightStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public PortugueseLightStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Pt.PortugueseLightStemFilterFactory : TokenFilterFactory {
    public PortugueseLightStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Pt.PortugueseLightStemmer : object {
    public virtual int Stem(Char[] s, int len);
    private int RemoveSuffix(Char[] s, int len);
    private int NormFeminine(Char[] s, int len);
}
public class Lucene.Net.Analysis.Pt.PortugueseMinimalStemFilter : TokenFilter {
    private PortugueseMinimalStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public PortugueseMinimalStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Pt.PortugueseMinimalStemFilterFactory : TokenFilterFactory {
    public PortugueseMinimalStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Pt.PortugueseMinimalStemmer : RSLPStemmerBase {
    private static Step pluralStep;
    private static PortugueseMinimalStemmer();
    public virtual int Stem(Char[] s, int len);
}
public class Lucene.Net.Analysis.Pt.PortugueseStemFilter : TokenFilter {
    private PortugueseStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public PortugueseStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Pt.PortugueseStemFilterFactory : TokenFilterFactory {
    public PortugueseStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Pt.PortugueseStemmer : RSLPStemmerBase {
    private static Step plural;
    private static Step feminine;
    private static Step adverb;
    private static Step augmentative;
    private static Step noun;
    private static Step verb;
    private static Step vowel;
    private static PortugueseStemmer();
    public virtual int Stem(Char[] s, int len);
}
public abstract class Lucene.Net.Analysis.Pt.RSLPStemmerBase : object {
    private static Regex headerPattern;
    private static Regex stripPattern;
    private static Regex repPattern;
    private static Regex excPattern;
    private static RSLPStemmerBase();
    protected static IDictionary`2<string, Step> Parse(Type clazz, string resource);
    private static Step ParseStep(TextReader r, string header);
    private static Rule[] ParseRules(TextReader r, int type);
    private static String[] ParseList(string s);
    private static string ParseString(string s);
    private static string ReadLine(TextReader r);
}
public class Lucene.Net.Analysis.Query.QueryAutoStopWordAnalyzer : AnalyzerWrapper {
    private Analyzer delegate;
    private IDictionary`2<string, ISet`1<string>> stopWordsPerField;
    public static float defaultMaxDocFreqPercent;
    private LuceneVersion matchVersion;
    public QueryAutoStopWordAnalyzer(LuceneVersion matchVersion, Analyzer delegate, IndexReader indexReader);
    public QueryAutoStopWordAnalyzer(LuceneVersion matchVersion, Analyzer delegate, IndexReader indexReader, int maxDocFreq);
    public QueryAutoStopWordAnalyzer(LuceneVersion matchVersion, Analyzer delegate, IndexReader indexReader, float maxPercentDocs);
    public QueryAutoStopWordAnalyzer(LuceneVersion matchVersion, Analyzer delegate, IndexReader indexReader, ICollection`1<string> fields, float maxPercentDocs);
    public QueryAutoStopWordAnalyzer(LuceneVersion matchVersion, Analyzer delegate, IndexReader indexReader, ICollection`1<string> fields, int maxDocFreq);
    protected virtual Analyzer GetWrappedAnalyzer(string fieldName);
    protected virtual TokenStreamComponents WrapComponents(string fieldName, TokenStreamComponents components);
    public String[] GetStopWords(string fieldName);
    public Term[] GetStopWords();
}
public class Lucene.Net.Analysis.Reverse.ReverseStringFilter : TokenFilter {
    private ICharTermAttribute termAtt;
    private char marker;
    private LuceneVersion matchVersion;
    private static char NOMARKER;
    public static char START_OF_HEADING_MARKER;
    public static char INFORMATION_SEPARATOR_MARKER;
    public static char PUA_EC00_MARKER;
    public static char RTL_DIRECTION_MARKER;
    public ReverseStringFilter(LuceneVersion matchVersion, TokenStream in);
    public ReverseStringFilter(LuceneVersion matchVersion, TokenStream in, char marker);
    public virtual bool IncrementToken();
    public static string Reverse(LuceneVersion matchVersion, string input);
    public static void Reverse(LuceneVersion matchVersion, Char[] buffer);
    public static void Reverse(LuceneVersion matchVersion, Char[] buffer, int len);
    [ObsoleteAttribute("(3.1) Remove this when support for 3.0 indexes is no longer needed.")]
private static void ReverseUnicode3(Char[] buffer, int start, int len);
    public static void Reverse(LuceneVersion matchVersion, Char[] buffer, int start, int len);
}
public class Lucene.Net.Analysis.Reverse.ReverseStringFilterFactory : TokenFilterFactory {
    public ReverseStringFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Ro.RomanianAnalyzer : StopwordAnalyzerBase {
    private CharArraySet stemExclusionSet;
    public static string DEFAULT_STOPWORD_FILE;
    private static string STOPWORDS_COMMENT;
    public static CharArraySet DefaultStopSet { get; }
    public RomanianAnalyzer(LuceneVersion matchVersion);
    public RomanianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public RomanianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Ru.RussianAnalyzer : StopwordAnalyzerBase {
    [ObsoleteAttribute("(3.1) Remove this for LUCENE 5.0")]
private static String[] RUSSIAN_STOP_WORDS_30;
    public static string DEFAULT_STOPWORD_FILE;
    private CharArraySet stemExclusionSet;
    public static CharArraySet DefaultStopSet { get; }
    public RussianAnalyzer(LuceneVersion matchVersion);
    public RussianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public RussianAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    private static RussianAnalyzer();
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
[ObsoleteAttribute("(3.1) Use StandardTokenizer instead, which has the same functionality.")]
public class Lucene.Net.Analysis.Ru.RussianLetterTokenizer : CharTokenizer {
    private static int DIGIT_0;
    private static int DIGIT_9;
    public RussianLetterTokenizer(LuceneVersion matchVersion, TextReader in);
    public RussianLetterTokenizer(LuceneVersion matchVersion, AttributeFactory factory, TextReader in);
    protected virtual bool IsTokenChar(int c);
}
[ObsoleteAttribute("Use Standard.StandardTokenizerFactory instead.")]
public class Lucene.Net.Analysis.Ru.RussianLetterTokenizerFactory : TokenizerFactory {
    public RussianLetterTokenizerFactory(IDictionary`2<string, string> args);
    public virtual Tokenizer Create(AttributeFactory factory, TextReader input);
}
public class Lucene.Net.Analysis.Ru.RussianLightStemFilter : TokenFilter {
    private RussianLightStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public RussianLightStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Ru.RussianLightStemFilterFactory : TokenFilterFactory {
    public RussianLightStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Ru.RussianLightStemmer : object {
    public virtual int Stem(Char[] s, int len);
    private int Normalize(Char[] s, int len);
    private int RemoveCase(Char[] s, int len);
}
public class Lucene.Net.Analysis.Shingle.ShingleAnalyzerWrapper : AnalyzerWrapper {
    private Analyzer delegate;
    private int maxShingleSize;
    private int minShingleSize;
    private string tokenSeparator;
    private bool outputUnigrams;
    private bool outputUnigramsIfNoShingles;
    private string fillerToken;
    public int MaxShingleSize { get; }
    public int MinShingleSize { get; }
    public string TokenSeparator { get; }
    public bool OutputUnigrams { get; }
    public bool OutputUnigramsIfNoShingles { get; }
    public string FillerToken { get; }
    public ShingleAnalyzerWrapper(Analyzer defaultAnalyzer);
    public ShingleAnalyzerWrapper(Analyzer defaultAnalyzer, int maxShingleSize);
    public ShingleAnalyzerWrapper(Analyzer defaultAnalyzer, int minShingleSize, int maxShingleSize);
    public ShingleAnalyzerWrapper(Analyzer delegate, int minShingleSize, int maxShingleSize, string tokenSeparator, bool outputUnigrams, bool outputUnigramsIfNoShingles, string fillerToken);
    public ShingleAnalyzerWrapper(LuceneVersion matchVersion);
    public ShingleAnalyzerWrapper(LuceneVersion matchVersion, int minShingleSize, int maxShingleSize);
    public int get_MaxShingleSize();
    public int get_MinShingleSize();
    public string get_TokenSeparator();
    public bool get_OutputUnigrams();
    public bool get_OutputUnigramsIfNoShingles();
    public string get_FillerToken();
    protected sealed virtual Analyzer GetWrappedAnalyzer(string fieldName);
    protected virtual TokenStreamComponents WrapComponents(string fieldName, TokenStreamComponents components);
}
public class Lucene.Net.Analysis.Shingle.ShingleFilter : TokenFilter {
    public static string DEFAULT_FILLER_TOKEN;
    public static int DEFAULT_MAX_SHINGLE_SIZE;
    public static int DEFAULT_MIN_SHINGLE_SIZE;
    public static string DEFAULT_TOKEN_TYPE;
    public static string DEFAULT_TOKEN_SEPARATOR;
    private Queue`1<InputWindowToken> inputWindow;
    private CircularSequence gramSize;
    private StringBuilder gramBuilder;
    private string tokenType;
    private string tokenSeparator;
    private Char[] fillerToken;
    private bool outputUnigrams;
    private bool outputUnigramsIfNoShingles;
    private int maxShingleSize;
    private int minShingleSize;
    private int numFillerTokensToInsert;
    private AttributeSource nextInputStreamToken;
    private bool isNextInputStreamToken;
    private bool isOutputHere;
    private bool noShingleOutput;
    private State endState;
    private ICharTermAttribute termAtt;
    private IOffsetAttribute offsetAtt;
    private IPositionIncrementAttribute posIncrAtt;
    private IPositionLengthAttribute posLenAtt;
    private ITypeAttribute typeAtt;
    private bool exhausted;
    public ShingleFilter(TokenStream input, int minShingleSize, int maxShingleSize);
    public ShingleFilter(TokenStream input, int maxShingleSize);
    public ShingleFilter(TokenStream input);
    public ShingleFilter(TokenStream input, string tokenType);
    public void SetTokenType(string tokenType);
    public void SetOutputUnigrams(bool outputUnigrams);
    public void SetOutputUnigramsIfNoShingles(bool outputUnigramsIfNoShingles);
    public void SetMaxShingleSize(int maxShingleSize);
    public void SetMinShingleSize(int minShingleSize);
    public void SetTokenSeparator(string tokenSeparator);
    public void SetFillerToken(string fillerToken);
    public virtual bool IncrementToken();
    private InputWindowToken GetNextToken(InputWindowToken target);
    public virtual void End();
    private void ShiftInputWindow();
    public virtual void Reset();
}
public class Lucene.Net.Analysis.Shingle.ShingleFilterFactory : TokenFilterFactory {
    private int minShingleSize;
    private int maxShingleSize;
    private bool outputUnigrams;
    private bool outputUnigramsIfNoShingles;
    private string tokenSeparator;
    private string fillerToken;
    public ShingleFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Sinks.DateRecognizerSinkFilter : SinkFilter {
    protected DateTimeStyles m_style;
    protected ICharTermAttribute m_termAtt;
    protected IFormatProvider m_culture;
    protected String[] m_formats;
    public DateRecognizerSinkFilter(IFormatProvider culture);
    public DateRecognizerSinkFilter(string format);
    public DateRecognizerSinkFilter(String[] formats);
    public DateRecognizerSinkFilter(IFormatProvider culture, DateTimeStyles style);
    public DateRecognizerSinkFilter(string format, IFormatProvider culture);
    public DateRecognizerSinkFilter(String[] formats, IFormatProvider culture);
    public DateRecognizerSinkFilter(string format, IFormatProvider culture, DateTimeStyles style);
    public DateRecognizerSinkFilter(String[] formats, IFormatProvider culture, DateTimeStyles style);
    public virtual bool Accept(AttributeSource source);
}
public class Lucene.Net.Analysis.Sinks.TeeSinkTokenFilter : TokenFilter {
    private ICollection`1<WeakReference`1<SinkTokenStream>> sinks;
    private static SinkFilter ACCEPT_ALL_FILTER;
    public TeeSinkTokenFilter(TokenStream input);
    private static TeeSinkTokenFilter();
    public SinkTokenStream NewSinkTokenStream();
    public SinkTokenStream NewSinkTokenStream(SinkFilter filter);
    public void AddSinkTokenStream(SinkTokenStream sink);
    public void ConsumeAllTokens();
    public virtual bool IncrementToken();
    public sealed virtual void End();
}
public class Lucene.Net.Analysis.Sinks.TokenRangeSinkFilter : SinkFilter {
    private int lower;
    private int upper;
    private int count;
    public TokenRangeSinkFilter(int lower, int upper);
    public virtual bool Accept(AttributeSource source);
    public virtual void Reset();
}
public class Lucene.Net.Analysis.Sinks.TokenTypeSinkFilter : SinkFilter {
    private string typeToMatch;
    private ITypeAttribute typeAtt;
    public TokenTypeSinkFilter(string typeToMatch);
    public virtual bool Accept(AttributeSource source);
}
[ObsoleteAttribute("(3.1) Use the language-specific analyzer in modules/analysis instead. This analyzer will be removed in Lucene 5.0.")]
public class Lucene.Net.Analysis.Snowball.SnowballAnalyzer : Analyzer {
    private string name;
    private CharArraySet stopSet;
    private LuceneVersion matchVersion;
    public SnowballAnalyzer(LuceneVersion matchVersion, string name);
    public SnowballAnalyzer(LuceneVersion matchVersion, string name, CharArraySet stopWords);
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Snowball.SnowballFilter : TokenFilter {
    private SnowballProgram stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public SnowballFilter(TokenStream input, SnowballProgram stemmer);
    public SnowballFilter(TokenStream in, string name);
    public sealed virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Snowball.SnowballPorterFilterFactory : TokenFilterFactory {
    public static string PROTECTED_TOKENS;
    private string language;
    private string wordFiles;
    private Type stemClass;
    private CharArraySet protectedWords;
    public SnowballPorterFilterFactory(IDictionary`2<string, string> args);
    public virtual void Inform(IResourceLoader loader);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Standard.ClassicAnalyzer : StopwordAnalyzerBase {
    public static int DEFAULT_MAX_TOKEN_LENGTH;
    private int maxTokenLength;
    public static CharArraySet STOP_WORDS_SET;
    public int MaxTokenLength { get; public set; }
    public ClassicAnalyzer(LuceneVersion matchVersion, CharArraySet stopWords);
    public ClassicAnalyzer(LuceneVersion matchVersion);
    public ClassicAnalyzer(LuceneVersion matchVersion, TextReader stopwords);
    private static ClassicAnalyzer();
    public void set_MaxTokenLength(int value);
    public int get_MaxTokenLength();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Standard.ClassicFilter : TokenFilter {
    private static string APOSTROPHE_TYPE;
    private static string ACRONYM_TYPE;
    private ITypeAttribute typeAtt;
    private ICharTermAttribute termAtt;
    public ClassicFilter(TokenStream in);
    private static ClassicFilter();
    public sealed virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Standard.ClassicFilterFactory : TokenFilterFactory {
    public ClassicFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Standard.ClassicTokenizer : Tokenizer {
    private IStandardTokenizerInterface scanner;
    public static int ALPHANUM;
    public static int APOSTROPHE;
    public static int ACRONYM;
    public static int COMPANY;
    public static int EMAIL;
    public static int HOST;
    public static int NUM;
    public static int CJ;
    public static int ACRONYM_DEP;
    public static String[] TOKEN_TYPES;
    private int skippedPositions;
    private int maxTokenLength;
    private ICharTermAttribute termAtt;
    private IOffsetAttribute offsetAtt;
    private IPositionIncrementAttribute posIncrAtt;
    private ITypeAttribute typeAtt;
    public int MaxTokenLength { get; public set; }
    public ClassicTokenizer(LuceneVersion matchVersion, TextReader input);
    public ClassicTokenizer(LuceneVersion matchVersion, AttributeFactory factory, TextReader input);
    private static ClassicTokenizer();
    public int get_MaxTokenLength();
    public void set_MaxTokenLength(int value);
    private void Init(LuceneVersion matchVersion);
    public sealed virtual bool IncrementToken();
    public sealed virtual void End();
    protected virtual void Dispose(bool disposing);
    public virtual void Reset();
}
public class Lucene.Net.Analysis.Standard.ClassicTokenizerFactory : TokenizerFactory {
    private int maxTokenLength;
    public ClassicTokenizerFactory(IDictionary`2<string, string> args);
    public virtual Tokenizer Create(AttributeFactory factory, TextReader input);
}
internal class Lucene.Net.Analysis.Standard.ClassicTokenizerImpl : object {
    public static int YYEOF;
    private static int ZZ_BUFFERSIZE;
    public static int YYINITIAL;
    private static Int32[] ZZ_LEXSTATE;
    private static string ZZ_CMAP_PACKED;
    private static Char[] ZZ_CMAP;
    private static Int32[] ZZ_ACTION;
    private static string ZZ_ACTION_PACKED_0;
    private static Int32[] ZZ_ROWMAP;
    private static string ZZ_ROWMAP_PACKED_0;
    private static Int32[] ZZ_TRANS;
    private static string ZZ_TRANS_PACKED_0;
    private static int ZZ_UNKNOWN_ERROR;
    private static int ZZ_NO_MATCH;
    private static int ZZ_PUSHBACK_2BIG;
    private static String[] ZZ_ERROR_MSG;
    private static Int32[] ZZ_ATTRIBUTE;
    private static string ZZ_ATTRIBUTE_PACKED_0;
    private TextReader zzReader;
    private int zzState;
    private int zzLexicalState;
    private Char[] zzBuffer;
    private int zzMarkedPos;
    private int zzCurrentPos;
    private int zzStartRead;
    private int zzEndRead;
    private int yyChar;
    private bool zzAtEOF;
    public static int ALPHANUM;
    public static int APOSTROPHE;
    public static int ACRONYM;
    public static int COMPANY;
    public static int EMAIL;
    public static int HOST;
    public static int NUM;
    public static int CJ;
    public static int ACRONYM_DEP;
    public static String[] TOKEN_TYPES;
    public int YyChar { get; }
    public int YyState { get; }
    public string YyText { get; }
    public int YyLength { get; }
    internal ClassicTokenizerImpl(TextReader in);
    private static ClassicTokenizerImpl();
    private static Int32[] ZzUnpackAction();
    private static int ZzUnpackAction(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackRowMap();
    private static int ZzUnpackRowMap(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackTrans();
    private static int ZzUnpackTrans(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackAttribute();
    private static int ZzUnpackAttribute(string packed, int offset, Int32[] result);
    public sealed virtual int get_YyChar();
    public sealed virtual void GetText(ICharTermAttribute t);
    private static Char[] ZzUnpackCMap(string packed);
    private bool ZzRefill();
    public void YyClose();
    public sealed virtual void YyReset(TextReader reader);
    public int get_YyState();
    public void YyBegin(int newState);
    public string get_YyText();
    public char YyCharAt(int pos);
    public sealed virtual int get_YyLength();
    private void ZzScanError(int errorCode);
    public virtual void YyPushBack(int number);
    public virtual int GetNextToken();
}
public interface Lucene.Net.Analysis.Standard.IStandardTokenizerInterface {
    public int YyChar { get; }
    public int YyLength { get; }
    public abstract virtual void GetText(ICharTermAttribute t);
    public abstract virtual int get_YyChar();
    public abstract virtual void YyReset(TextReader reader);
    public abstract virtual int get_YyLength();
    public abstract virtual int GetNextToken();
}
public class Lucene.Net.Analysis.Standard.StandardAnalyzer : StopwordAnalyzerBase {
    public static int DEFAULT_MAX_TOKEN_LENGTH;
    private int maxTokenLength;
    public static CharArraySet STOP_WORDS_SET;
    public int MaxTokenLength { get; public set; }
    public StandardAnalyzer(LuceneVersion matchVersion, CharArraySet stopWords);
    public StandardAnalyzer(LuceneVersion matchVersion);
    public StandardAnalyzer(LuceneVersion matchVersion, TextReader stopwords);
    private static StandardAnalyzer();
    public int get_MaxTokenLength();
    public void set_MaxTokenLength(int value);
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Standard.StandardFilter : TokenFilter {
    private LuceneVersion matchVersion;
    private static string APOSTROPHE_TYPE;
    private static string ACRONYM_TYPE;
    private ITypeAttribute typeAtt;
    private ICharTermAttribute termAtt;
    public StandardFilter(LuceneVersion matchVersion, TokenStream in);
    private static StandardFilter();
    public sealed virtual bool IncrementToken();
    public bool IncrementTokenClassic();
}
public class Lucene.Net.Analysis.Standard.StandardFilterFactory : TokenFilterFactory {
    public StandardFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Standard.StandardTokenizer : Tokenizer {
    private IStandardTokenizerInterface scanner;
    public static int ALPHANUM;
    [ObsoleteAttribute("(3.1)")]
public static int APOSTROPHE;
    [ObsoleteAttribute("(3.1)")]
public static int ACRONYM;
    [ObsoleteAttribute("(3.1)")]
public static int COMPANY;
    public static int EMAIL;
    [ObsoleteAttribute("(3.1)")]
public static int HOST;
    public static int NUM;
    [ObsoleteAttribute("(3.1)")]
public static int CJ;
    [ObsoleteAttribute("(3.1)")]
public static int ACRONYM_DEP;
    public static int SOUTHEAST_ASIAN;
    public static int IDEOGRAPHIC;
    public static int HIRAGANA;
    public static int KATAKANA;
    public static int HANGUL;
    public static String[] TOKEN_TYPES;
    private int skippedPositions;
    private int maxTokenLength;
    private ICharTermAttribute termAtt;
    private IOffsetAttribute offsetAtt;
    private IPositionIncrementAttribute posIncrAtt;
    private ITypeAttribute typeAtt;
    public int MaxTokenLength { get; public set; }
    public StandardTokenizer(LuceneVersion matchVersion, TextReader input);
    public StandardTokenizer(LuceneVersion matchVersion, AttributeFactory factory, TextReader input);
    private static StandardTokenizer();
    public int get_MaxTokenLength();
    public void set_MaxTokenLength(int value);
    private void Init(LuceneVersion matchVersion);
    public sealed virtual bool IncrementToken();
    public sealed virtual void End();
    protected virtual void Dispose(bool disposing);
    public virtual void Reset();
}
public class Lucene.Net.Analysis.Standard.StandardTokenizerFactory : TokenizerFactory {
    private int maxTokenLength;
    public StandardTokenizerFactory(IDictionary`2<string, string> args);
    public virtual Tokenizer Create(AttributeFactory factory, TextReader input);
}
public class Lucene.Net.Analysis.Standard.StandardTokenizerImpl : object {
    public static int YYEOF;
    private static int ZZ_BUFFERSIZE;
    public static int YYINITIAL;
    private static Int32[] ZZ_LEXSTATE;
    private static string ZZ_CMAP_PACKED;
    private static Char[] ZZ_CMAP;
    private static Int32[] ZZ_ACTION;
    private static string ZZ_ACTION_PACKED_0;
    private static Int32[] ZZ_ROWMAP;
    private static string ZZ_ROWMAP_PACKED_0;
    private static Int32[] ZZ_TRANS;
    private static string ZZ_TRANS_PACKED_0;
    private static int ZZ_UNKNOWN_ERROR;
    private static int ZZ_NO_MATCH;
    private static int ZZ_PUSHBACK_2BIG;
    private static String[] ZZ_ERROR_MSG;
    private static Int32[] ZZ_ATTRIBUTE;
    private static string ZZ_ATTRIBUTE_PACKED_0;
    private TextReader zzReader;
    private int zzState;
    private int zzLexicalState;
    private Char[] zzBuffer;
    private int zzMarkedPos;
    private int zzCurrentPos;
    private int zzStartRead;
    private int zzEndRead;
    private int yyChar;
    private bool zzAtEOF;
    public static int WORD_TYPE;
    public static int NUMERIC_TYPE;
    public static int SOUTH_EAST_ASIAN_TYPE;
    public static int IDEOGRAPHIC_TYPE;
    public static int HIRAGANA_TYPE;
    public static int KATAKANA_TYPE;
    public static int HANGUL_TYPE;
    public int YyChar { get; }
    public int YyState { get; }
    public string YyText { get; }
    public int YyLength { get; }
    public StandardTokenizerImpl(TextReader in);
    private static StandardTokenizerImpl();
    private static Int32[] ZzUnpackAction();
    private static int ZzUnpackAction(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackRowMap();
    private static int ZzUnpackRowMap(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackTrans();
    private static int ZzUnpackTrans(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackAttribute();
    private static int ZzUnpackAttribute(string packed, int offset, Int32[] result);
    public sealed virtual int get_YyChar();
    public sealed virtual void GetText(ICharTermAttribute t);
    private static Char[] ZzUnpackCMap(string packed);
    private bool ZzRefill();
    public void YyClose();
    public sealed virtual void YyReset(TextReader reader);
    public int get_YyState();
    public void YyBegin(int newState);
    public string get_YyText();
    public char YyCharAt(int pos);
    public sealed virtual int get_YyLength();
    private void ZzScanError(int errorCode);
    public void YyPushBack(int number);
    public sealed virtual int GetNextToken();
}
public static class Lucene.Net.Analysis.Standard.StandardTokenizerInterface : object {
    public static int YYEOF;
}
[ObsoleteAttribute("This class is only for exact backwards compatibility")]
public class Lucene.Net.Analysis.Standard.Std31.StandardTokenizerImpl31 : object {
    public static int YYEOF;
    private static int ZZ_BUFFERSIZE;
    public static int YYINITIAL;
    private static Int32[] ZZ_LEXSTATE;
    private static string ZZ_CMAP_PACKED;
    private static Char[] ZZ_CMAP;
    private static Int32[] ZZ_ACTION;
    private static string ZZ_ACTION_PACKED_0;
    private static Int32[] ZZ_ROWMAP;
    private static string ZZ_ROWMAP_PACKED_0;
    private static Int32[] ZZ_TRANS;
    private static string ZZ_TRANS_PACKED_0;
    private static int ZZ_UNKNOWN_ERROR;
    private static int ZZ_NO_MATCH;
    private static int ZZ_PUSHBACK_2BIG;
    private static String[] ZZ_ERROR_MSG;
    private static Int32[] ZZ_ATTRIBUTE;
    private static string ZZ_ATTRIBUTE_PACKED_0;
    private TextReader zzReader;
    private int zzState;
    private int zzLexicalState;
    private Char[] zzBuffer;
    private int zzMarkedPos;
    private int zzCurrentPos;
    private int zzStartRead;
    private int zzEndRead;
    private int yyChar;
    private bool zzAtEOF;
    public static int WORD_TYPE;
    public static int NUMERIC_TYPE;
    public static int SOUTH_EAST_ASIAN_TYPE;
    public static int IDEOGRAPHIC_TYPE;
    public static int HIRAGANA_TYPE;
    public static int KATAKANA_TYPE;
    public static int HANGUL_TYPE;
    public int YyChar { get; }
    public int YyState { get; }
    public string YyText { get; }
    public int YyLength { get; }
    public StandardTokenizerImpl31(TextReader in);
    private static StandardTokenizerImpl31();
    private static Int32[] ZzUnpackAction();
    private static int ZzUnpackAction(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackRowMap();
    private static int ZzUnpackRowMap(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackTrans();
    private static int ZzUnpackTrans(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackAttribute();
    private static int ZzUnpackAttribute(string packed, int offset, Int32[] result);
    public sealed virtual int get_YyChar();
    public sealed virtual void GetText(ICharTermAttribute t);
    private static Char[] ZzUnpackCMap(string packed);
    private bool ZzRefill();
    public void YyClose();
    public sealed virtual void YyReset(TextReader reader);
    public int get_YyState();
    public void YyBegin(int newState);
    public string get_YyText();
    public char YyCharAt(int pos);
    public sealed virtual int get_YyLength();
    private void ZzScanError(int errorCode);
    public void YyPushBack(int number);
    public sealed virtual int GetNextToken();
}
[ObsoleteAttribute("This class is only for exact backwards compatibility")]
public class Lucene.Net.Analysis.Standard.Std31.UAX29URLEmailTokenizerImpl31 : object {
    public static int YYEOF;
    private static int ZZ_BUFFERSIZE;
    public static int YYINITIAL;
    private static Int32[] ZZ_LEXSTATE;
    private static string ZZ_CMAP_PACKED;
    private static Char[] ZZ_CMAP;
    private static Int32[] ZZ_ACTION;
    private static string ZZ_ACTION_PACKED_0;
    private static Int32[] ZZ_ROWMAP;
    private static string ZZ_ROWMAP_PACKED_0;
    private static Int32[] ZZ_TRANS;
    private static string ZZ_TRANS_PACKED_0;
    private static int ZZ_UNKNOWN_ERROR;
    private static int ZZ_NO_MATCH;
    private static int ZZ_PUSHBACK_2BIG;
    private static String[] ZZ_ERROR_MSG;
    private static Int32[] ZZ_ATTRIBUTE;
    private static string ZZ_ATTRIBUTE_PACKED_0;
    private TextReader zzReader;
    private int zzState;
    private int zzLexicalState;
    private Char[] zzBuffer;
    private int zzMarkedPos;
    private int zzCurrentPos;
    private int zzStartRead;
    private int zzEndRead;
    private int yychar;
    private bool zzAtEOF;
    public static int WORD_TYPE;
    public static int NUMERIC_TYPE;
    public static int SOUTH_EAST_ASIAN_TYPE;
    public static int IDEOGRAPHIC_TYPE;
    public static int HIRAGANA_TYPE;
    public static int KATAKANA_TYPE;
    public static int HANGUL_TYPE;
    public static int EMAIL_TYPE;
    public static int URL_TYPE;
    public int YyChar { get; }
    public int YyState { get; }
    public string YyText { get; }
    public int YyLength { get; }
    public UAX29URLEmailTokenizerImpl31(TextReader in);
    private static UAX29URLEmailTokenizerImpl31();
    private static Int32[] ZzUnpackAction();
    private static int ZzUnpackAction(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackRowMap();
    private static int ZzUnpackRowMap(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackTrans();
    private static int ZzUnpackTrans(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackAttribute();
    private static int ZzUnpackAttribute(string packed, int offset, Int32[] result);
    public sealed virtual int get_YyChar();
    public sealed virtual void GetText(ICharTermAttribute t);
    private static Char[] ZzUnpackCMap(string packed);
    private bool ZzRefill();
    public void YyClose();
    public sealed virtual void YyReset(TextReader reader);
    public int get_YyState();
    public void YyBegin(int newState);
    public string get_YyText();
    public char YyCharAt(int pos);
    public sealed virtual int get_YyLength();
    private void ZzScanError(int errorCode);
    public void YyPushBack(int number);
    public sealed virtual int GetNextToken();
}
[ObsoleteAttribute("This class is only for exact backwards compatibility")]
public class Lucene.Net.Analysis.Standard.Std34.StandardTokenizerImpl34 : object {
    public static int YYEOF;
    private static int ZZ_BUFFERSIZE;
    public static int YYINITIAL;
    private static Int32[] ZZ_LEXSTATE;
    private static string ZZ_CMAP_PACKED;
    private static Char[] ZZ_CMAP;
    private static Int32[] ZZ_ACTION;
    private static string ZZ_ACTION_PACKED_0;
    private static Int32[] ZZ_ROWMAP;
    private static string ZZ_ROWMAP_PACKED_0;
    private static Int32[] ZZ_TRANS;
    private static string ZZ_TRANS_PACKED_0;
    private static int ZZ_UNKNOWN_ERROR;
    private static int ZZ_NO_MATCH;
    private static int ZZ_PUSHBACK_2BIG;
    private static String[] ZZ_ERROR_MSG;
    private static Int32[] ZZ_ATTRIBUTE;
    private static string ZZ_ATTRIBUTE_PACKED_0;
    private TextReader zzReader;
    private int zzState;
    private int zzLexicalState;
    private Char[] zzBuffer;
    private int zzMarkedPos;
    private int zzCurrentPos;
    private int zzStartRead;
    private int zzEndRead;
    private int yyChar;
    private bool zzAtEOF;
    public static int WORD_TYPE;
    public static int NUMERIC_TYPE;
    public static int SOUTH_EAST_ASIAN_TYPE;
    public static int IDEOGRAPHIC_TYPE;
    public static int HIRAGANA_TYPE;
    public static int KATAKANA_TYPE;
    public static int HANGUL_TYPE;
    public int YyChar { get; }
    public int YyState { get; }
    public string YyText { get; }
    public int YyLength { get; }
    public StandardTokenizerImpl34(TextReader in);
    private static StandardTokenizerImpl34();
    private static Int32[] ZzUnpackAction();
    private static int ZzUnpackAction(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackRowMap();
    private static int ZzUnpackRowMap(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackTrans();
    private static int ZzUnpackTrans(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackAttribute();
    private static int ZzUnpackAttribute(string packed, int offset, Int32[] result);
    public sealed virtual int get_YyChar();
    public sealed virtual void GetText(ICharTermAttribute t);
    private static Char[] ZzUnpackCMap(string packed);
    private bool ZzRefill();
    public void YyClose();
    public sealed virtual void YyReset(TextReader reader);
    public int get_YyState();
    public void YyBegin(int newState);
    public string get_YyText();
    public char YyCharAt(int pos);
    public sealed virtual int get_YyLength();
    private void ZzScanError(int errorCode);
    public void YyPushBack(int number);
    public sealed virtual int GetNextToken();
}
[ObsoleteAttribute("This class is only for exact backwards compatibility")]
public class Lucene.Net.Analysis.Standard.Std34.UAX29URLEmailTokenizerImpl34 : object {
    public static int YYEOF;
    private static int ZZ_BUFFERSIZE;
    public static int YYINITIAL;
    private static Int32[] ZZ_LEXSTATE;
    private static string ZZ_CMAP_PACKED;
    private static Char[] ZZ_CMAP;
    private static Int32[] ZZ_ACTION;
    private static string ZZ_ACTION_PACKED_0;
    private static Int32[] ZZ_ROWMAP;
    private static string ZZ_ROWMAP_PACKED_0;
    private static Int32[] ZZ_TRANS;
    private static string ZZ_TRANS_PACKED_0;
    private static int ZZ_UNKNOWN_ERROR;
    private static int ZZ_NO_MATCH;
    private static int ZZ_PUSHBACK_2BIG;
    private static String[] ZZ_ERROR_MSG;
    private static Int32[] ZZ_ATTRIBUTE;
    private static string ZZ_ATTRIBUTE_PACKED_0;
    private TextReader zzReader;
    private int zzState;
    private int zzLexicalState;
    private Char[] zzBuffer;
    private int zzMarkedPos;
    private int zzCurrentPos;
    private int zzStartRead;
    private int zzEndRead;
    private int yychar;
    private bool zzAtEOF;
    public static int WORD_TYPE;
    public static int NUMERIC_TYPE;
    public static int SOUTH_EAST_ASIAN_TYPE;
    public static int IDEOGRAPHIC_TYPE;
    public static int HIRAGANA_TYPE;
    public static int KATAKANA_TYPE;
    public static int HANGUL_TYPE;
    public static int EMAIL_TYPE;
    public static int URL_TYPE;
    public int YyChar { get; }
    public int YyState { get; }
    public string YyText { get; }
    public int YyLength { get; }
    public UAX29URLEmailTokenizerImpl34(TextReader in);
    private static UAX29URLEmailTokenizerImpl34();
    private static Int32[] ZzUnpackAction();
    private static int ZzUnpackAction(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackRowMap();
    private static int ZzUnpackRowMap(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackTrans();
    private static int ZzUnpackTrans(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackAttribute();
    private static int ZzUnpackAttribute(string packed, int offset, Int32[] result);
    public sealed virtual int get_YyChar();
    public sealed virtual void GetText(ICharTermAttribute t);
    private static Char[] ZzUnpackCMap(string packed);
    private bool ZzRefill();
    public void YyClose();
    public sealed virtual void YyReset(TextReader reader);
    public int get_YyState();
    public void YyBegin(int newState);
    public string get_YyText();
    public char YyCharAt(int pos);
    public sealed virtual int get_YyLength();
    private void ZzScanError(int errorCode);
    public void YyPushBack(int number);
    public sealed virtual int GetNextToken();
}
[ObsoleteAttribute("This class is only for exact backwards compatibility")]
public class Lucene.Net.Analysis.Standard.Std36.UAX29URLEmailTokenizerImpl36 : object {
    public static int YYEOF;
    private static int ZZ_BUFFERSIZE;
    public static int YYINITIAL;
    private static Int32[] ZZ_LEXSTATE;
    private static string ZZ_CMAP_PACKED;
    private static Char[] ZZ_CMAP;
    private static Int32[] ZZ_ACTION;
    private static string ZZ_ACTION_PACKED_0;
    private static Int32[] ZZ_ROWMAP;
    private static string ZZ_ROWMAP_PACKED_0;
    private static Int32[] ZZ_TRANS;
    private static string ZZ_TRANS_PACKED_0;
    private static string ZZ_TRANS_PACKED_1;
    private static int ZZ_UNKNOWN_ERROR;
    private static int ZZ_NO_MATCH;
    private static int ZZ_PUSHBACK_2BIG;
    private static String[] ZZ_ERROR_MSG;
    private static Int32[] ZZ_ATTRIBUTE;
    private static string ZZ_ATTRIBUTE_PACKED_0;
    private TextReader zzReader;
    private int zzState;
    private int zzLexicalState;
    private Char[] zzBuffer;
    private int zzMarkedPos;
    private int zzCurrentPos;
    private int zzStartRead;
    private int zzEndRead;
    private int yychar;
    private bool zzAtEOF;
    public static int WORD_TYPE;
    public static int NUMERIC_TYPE;
    public static int SOUTH_EAST_ASIAN_TYPE;
    public static int IDEOGRAPHIC_TYPE;
    public static int HIRAGANA_TYPE;
    public static int KATAKANA_TYPE;
    public static int HANGUL_TYPE;
    public static int EMAIL_TYPE;
    public static int URL_TYPE;
    public int YyChar { get; }
    public int YyState { get; }
    public string YyText { get; }
    public int YyLength { get; }
    public UAX29URLEmailTokenizerImpl36(TextReader in);
    private static UAX29URLEmailTokenizerImpl36();
    private static Int32[] ZzUnpackAction();
    private static int ZzUnpackAction(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackRowMap();
    private static int ZzUnpackRowMap(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackTrans();
    private static int ZzUnpackTrans(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackAttribute();
    private static int ZzUnpackAttribute(string packed, int offset, Int32[] result);
    public sealed virtual int get_YyChar();
    public sealed virtual void GetText(ICharTermAttribute t);
    private static Char[] ZzUnpackCMap(string packed);
    private bool ZzRefill();
    public void YyClose();
    public sealed virtual void YyReset(TextReader reader);
    public int get_YyState();
    public void YyBegin(int newState);
    public string get_YyText();
    public char YyCharAt(int pos);
    public sealed virtual int get_YyLength();
    private void ZzScanError(int errorCode);
    public void YyPushBack(int number);
    public sealed virtual int GetNextToken();
}
[ObsoleteAttribute("This class is only for exact backwards compatibility")]
public class Lucene.Net.Analysis.Standard.Std40.StandardTokenizerImpl40 : object {
    public static int YYEOF;
    private static int ZZ_BUFFERSIZE;
    public static int YYINITIAL;
    private static Int32[] ZZ_LEXSTATE;
    private static string ZZ_CMAP_PACKED;
    private static Char[] ZZ_CMAP;
    private static Int32[] ZZ_ACTION;
    private static string ZZ_ACTION_PACKED_0;
    private static Int32[] ZZ_ROWMAP;
    private static string ZZ_ROWMAP_PACKED_0;
    private static Int32[] ZZ_TRANS;
    private static string ZZ_TRANS_PACKED_0;
    private static int ZZ_UNKNOWN_ERROR;
    private static int ZZ_NO_MATCH;
    private static int ZZ_PUSHBACK_2BIG;
    private static String[] ZZ_ERROR_MSG;
    private static Int32[] ZZ_ATTRIBUTE;
    private static string ZZ_ATTRIBUTE_PACKED_0;
    private TextReader zzReader;
    private int zzState;
    private int zzLexicalState;
    private Char[] zzBuffer;
    private int zzMarkedPos;
    private int zzCurrentPos;
    private int zzStartRead;
    private int zzEndRead;
    private int yyChar;
    private bool zzAtEOF;
    public static int WORD_TYPE;
    public static int NUMERIC_TYPE;
    public static int SOUTH_EAST_ASIAN_TYPE;
    public static int IDEOGRAPHIC_TYPE;
    public static int HIRAGANA_TYPE;
    public static int KATAKANA_TYPE;
    public static int HANGUL_TYPE;
    public int YyChar { get; }
    public int YyState { get; }
    public string YyText { get; }
    public int YyLength { get; }
    public StandardTokenizerImpl40(TextReader in);
    private static StandardTokenizerImpl40();
    private static Int32[] ZzUnpackAction();
    private static int ZzUnpackAction(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackRowMap();
    private static int ZzUnpackRowMap(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackTrans();
    private static int ZzUnpackTrans(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackAttribute();
    private static int ZzUnpackAttribute(string packed, int offset, Int32[] result);
    public sealed virtual int get_YyChar();
    public sealed virtual void GetText(ICharTermAttribute t);
    private static Char[] ZzUnpackCMap(string packed);
    private bool ZzRefill();
    public void YyClose();
    public sealed virtual void YyReset(TextReader reader);
    public int get_YyState();
    public void YyBegin(int newState);
    public string get_YyText();
    public char YyCharAt(int pos);
    public sealed virtual int get_YyLength();
    private void ZzScanError(int errorCode);
    public void YyPushBack(int number);
    public sealed virtual int GetNextToken();
}
[ObsoleteAttribute("This class is only for exact backwards compatibility")]
public class Lucene.Net.Analysis.Standard.Std40.UAX29URLEmailTokenizerImpl40 : object {
    public static int YYEOF;
    private static int ZZ_BUFFERSIZE;
    public static int YYINITIAL;
    private static Int32[] ZZ_LEXSTATE;
    private static string ZZ_CMAP_PACKED;
    private static Char[] ZZ_CMAP;
    private static Int32[] ZZ_ACTION;
    private static string ZZ_ACTION_PACKED_0;
    private static Int32[] ZZ_ROWMAP;
    private static string ZZ_ROWMAP_PACKED_0;
    private static Int32[] ZZ_TRANS;
    private static string ZZ_TRANS_PACKED_0;
    private static string ZZ_TRANS_PACKED_1;
    private static int ZZ_UNKNOWN_ERROR;
    private static int ZZ_NO_MATCH;
    private static int ZZ_PUSHBACK_2BIG;
    private static String[] ZZ_ERROR_MSG;
    private static Int32[] ZZ_ATTRIBUTE;
    private static string ZZ_ATTRIBUTE_PACKED_0;
    private TextReader zzReader;
    private int zzState;
    private int zzLexicalState;
    private Char[] zzBuffer;
    private int zzMarkedPos;
    private int zzCurrentPos;
    private int zzStartRead;
    private int zzEndRead;
    private int yychar;
    private bool zzAtEOF;
    public static int WORD_TYPE;
    public static int NUMERIC_TYPE;
    public static int SOUTH_EAST_ASIAN_TYPE;
    public static int IDEOGRAPHIC_TYPE;
    public static int HIRAGANA_TYPE;
    public static int KATAKANA_TYPE;
    public static int HANGUL_TYPE;
    public static int EMAIL_TYPE;
    public static int URL_TYPE;
    public int YyChar { get; }
    public int YyState { get; }
    public string YyText { get; }
    public int YyLength { get; }
    public UAX29URLEmailTokenizerImpl40(TextReader in);
    private static UAX29URLEmailTokenizerImpl40();
    private static Int32[] ZzUnpackAction();
    private static int ZzUnpackAction(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackRowMap();
    private static int ZzUnpackRowMap(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackTrans();
    private static int ZzUnpackTrans(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackAttribute();
    private static int ZzUnpackAttribute(string packed, int offset, Int32[] result);
    public sealed virtual int get_YyChar();
    public sealed virtual void GetText(ICharTermAttribute t);
    private static Char[] ZzUnpackCMap(string packed);
    private bool ZzRefill();
    public void YyClose();
    public sealed virtual void YyReset(TextReader reader);
    public int get_YyState();
    public void YyBegin(int newState);
    public string get_YyText();
    public char YyCharAt(int pos);
    public sealed virtual int get_YyLength();
    private void ZzScanError(int errorCode);
    public void YyPushBack(int number);
    public sealed virtual int GetNextToken();
}
public class Lucene.Net.Analysis.Standard.UAX29URLEmailAnalyzer : StopwordAnalyzerBase {
    public static int DEFAULT_MAX_TOKEN_LENGTH;
    private int maxTokenLength;
    public static CharArraySet STOP_WORDS_SET;
    public int MaxTokenLength { get; public set; }
    public UAX29URLEmailAnalyzer(LuceneVersion matchVersion, CharArraySet stopWords);
    public UAX29URLEmailAnalyzer(LuceneVersion matchVersion);
    public UAX29URLEmailAnalyzer(LuceneVersion matchVersion, TextReader stopwords);
    private static UAX29URLEmailAnalyzer();
    public void set_MaxTokenLength(int value);
    public int get_MaxTokenLength();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Standard.UAX29URLEmailTokenizer : Tokenizer {
    private IStandardTokenizerInterface scanner;
    public static int ALPHANUM;
    public static int NUM;
    public static int SOUTHEAST_ASIAN;
    public static int IDEOGRAPHIC;
    public static int HIRAGANA;
    public static int KATAKANA;
    public static int HANGUL;
    public static int URL;
    public static int EMAIL;
    public static String[] TOKEN_TYPES;
    private int skippedPositions;
    private int maxTokenLength;
    private ICharTermAttribute termAtt;
    private IOffsetAttribute offsetAtt;
    private IPositionIncrementAttribute posIncrAtt;
    private ITypeAttribute typeAtt;
    public int MaxTokenLength { get; public set; }
    public UAX29URLEmailTokenizer(LuceneVersion matchVersion, TextReader input);
    public UAX29URLEmailTokenizer(LuceneVersion matchVersion, AttributeFactory factory, TextReader input);
    private static UAX29URLEmailTokenizer();
    public int get_MaxTokenLength();
    public void set_MaxTokenLength(int value);
    private void Init(LuceneVersion matchVersion);
    private IStandardTokenizerInterface GetScannerFor(LuceneVersion matchVersion);
    public sealed virtual bool IncrementToken();
    public sealed virtual void End();
    protected virtual void Dispose(bool disposing);
    public virtual void Reset();
}
public class Lucene.Net.Analysis.Standard.UAX29URLEmailTokenizerFactory : TokenizerFactory {
    private int maxTokenLength;
    public UAX29URLEmailTokenizerFactory(IDictionary`2<string, string> args);
    public virtual Tokenizer Create(AttributeFactory factory, TextReader input);
}
public class Lucene.Net.Analysis.Standard.UAX29URLEmailTokenizerImpl : object {
    public static int YYEOF;
    private static int ZZ_BUFFERSIZE;
    public static int YYINITIAL;
    public static int AVOID_BAD_URL;
    private static Int32[] ZZ_LEXSTATE;
    private static string ZZ_CMAP_PACKED;
    private static Char[] ZZ_CMAP;
    private static Int32[] ZZ_ACTION;
    private static string ZZ_ACTION_PACKED_0;
    private static Int32[] ZZ_ROWMAP;
    private static string ZZ_ROWMAP_PACKED_0;
    private static Int32[] ZZ_TRANS;
    private static string ZZ_TRANS_PACKED_0;
    private static string ZZ_TRANS_PACKED_1;
    private static string ZZ_TRANS_PACKED_2;
    private static int ZZ_UNKNOWN_ERROR;
    private static int ZZ_NO_MATCH;
    private static int ZZ_PUSHBACK_2BIG;
    private static String[] ZZ_ERROR_MSG;
    private static Int32[] ZZ_ATTRIBUTE;
    private static string ZZ_ATTRIBUTE_PACKED_0;
    private TextReader zzReader;
    private int zzState;
    private int zzLexicalState;
    private Char[] zzBuffer;
    private int zzMarkedPos;
    private int zzCurrentPos;
    private int zzStartRead;
    private int zzEndRead;
    private int yychar;
    private bool zzAtEOF;
    public static int WORD_TYPE;
    public static int NUMERIC_TYPE;
    public static int SOUTH_EAST_ASIAN_TYPE;
    public static int IDEOGRAPHIC_TYPE;
    public static int HIRAGANA_TYPE;
    public static int KATAKANA_TYPE;
    public static int HANGUL_TYPE;
    public static int EMAIL_TYPE;
    public static int URL_TYPE;
    public int YyChar { get; }
    public int YyState { get; }
    public string YyText { get; }
    public int YyLength { get; }
    public UAX29URLEmailTokenizerImpl(TextReader in);
    private static UAX29URLEmailTokenizerImpl();
    private static Int32[] ZzUnpackAction();
    private static int ZzUnpackAction(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackRowMap();
    private static int ZzUnpackRowMap(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackTrans();
    private static int ZzUnpackTrans(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackAttribute();
    private static int ZzUnpackAttribute(string packed, int offset, Int32[] result);
    public sealed virtual int get_YyChar();
    public sealed virtual void GetText(ICharTermAttribute t);
    private static Char[] ZzUnpackCMap(string packed);
    private bool ZzRefill();
    public void YyClose();
    public sealed virtual void YyReset(TextReader reader);
    public int get_YyState();
    public void YyBegin(int newState);
    public string get_YyText();
    public char YyCharAt(int pos);
    public sealed virtual int get_YyLength();
    private void ZzScanError(int errorCode);
    public void YyPushBack(int number);
    public sealed virtual int GetNextToken();
}
public class Lucene.Net.Analysis.Sv.SwedishAnalyzer : StopwordAnalyzerBase {
    private CharArraySet stemExclusionSet;
    public static string DEFAULT_STOPWORD_FILE;
    public static CharArraySet DefaultStopSet { get; }
    public SwedishAnalyzer(LuceneVersion matchVersion);
    public SwedishAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public SwedishAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Sv.SwedishLightStemFilter : TokenFilter {
    private SwedishLightStemmer stemmer;
    private ICharTermAttribute termAtt;
    private IKeywordAttribute keywordAttr;
    public SwedishLightStemFilter(TokenStream input);
    public virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Sv.SwedishLightStemFilterFactory : TokenFilterFactory {
    public SwedishLightStemFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Sv.SwedishLightStemmer : object {
    public virtual int Stem(Char[] s, int len);
}
internal class Lucene.Net.Analysis.Synonym.FSTSynonymFilterFactory : TokenFilterFactory {
    private bool ignoreCase;
    private string tokenizerFactory;
    private string synonyms;
    private string format;
    private bool expand;
    private IDictionary`2<string, string> tokArgs;
    private SynonymMap map;
    [ObsoleteAttribute("(3.4) use SynonymFilterFactory instead. this is only a backwards compatibility")]
public FSTSynonymFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
    public sealed virtual void Inform(IResourceLoader loader);
    private SynonymMap LoadSynonyms(IResourceLoader loader, string cname, bool dedup, Analyzer analyzer);
    private TokenizerFactory LoadTokenizerFactory(IResourceLoader loader, string cname);
}
[ObsoleteAttribute("(3.4) use SynonymFilterFactory instead. only for precise index backwards compatibility. this factory will be removed in Lucene 5.0")]
internal class Lucene.Net.Analysis.Synonym.SlowSynonymFilter : TokenFilter {
    private SlowSynonymMap map;
    private IEnumerator`1<AttributeSource> replacement;
    private LinkedList`1<AttributeSource> buffer;
    private LinkedList`1<AttributeSource> matched;
    private bool exhausted;
    public SlowSynonymFilter(TokenStream in, SlowSynonymMap map);
    public virtual bool IncrementToken();
    private AttributeSource NextTok();
    private void PushTok(AttributeSource t);
    private SlowSynonymMap Match(SlowSynonymMap map);
    private void Copy(AttributeSource target, AttributeSource source);
    public virtual void Reset();
}
[ObsoleteAttribute("(3.4) use SynonymFilterFactory instead. only for precise index backwards compatibility. this factory will be removed in Lucene 5.0")]
internal class Lucene.Net.Analysis.Synonym.SlowSynonymFilterFactory : TokenFilterFactory {
    private string synonyms;
    private bool ignoreCase;
    private bool expand;
    private string tf;
    private IDictionary`2<string, string> tokArgs;
    private SlowSynonymMap synMap;
    public SlowSynonymMap SynonymMap { get; }
    public SlowSynonymFilterFactory(IDictionary`2<string, string> args);
    public sealed virtual void Inform(IResourceLoader loader);
    private IEnumerable`1<string> LoadRules(string synonyms, IResourceLoader loader);
    internal static void ParseRules(IEnumerable`1<string> rules, SlowSynonymMap map, string mappingSep, string synSep, bool expansion, TokenizerFactory tokFactory);
    private static IList`1<IList`1<string>> GetSynList(string str, string separator, TokenizerFactory tokFactory);
    private static IList`1<string> SplitByTokenizer(string source, TokenizerFactory tokFactory);
    private TokenizerFactory LoadTokenizerFactory(IResourceLoader loader, string cname);
    private static TokenStream LoadTokenizer(TokenizerFactory tokFactory, TextReader reader);
    public SlowSynonymMap get_SynonymMap();
    public virtual TokenStream Create(TokenStream input);
    public static IList`1<string> SplitWS(string s, bool decode);
    public static IList`1<string> SplitSmart(string s, string separator, bool decode);
}
[ObsoleteAttribute("(3.4) use SynonymFilterFactory instead. only for precise index backwards compatibility. this factory will be removed in Lucene 5.0")]
internal class Lucene.Net.Analysis.Synonym.SlowSynonymMap : object {
    private CharArrayMap`1<SlowSynonymMap> submap;
    private Token[] synonyms;
    internal int flags;
    internal static int INCLUDE_ORIG;
    internal static int IGNORE_CASE;
    public CharArrayMap`1<SlowSynonymMap> Submap { get; public set; }
    [WritableArrayAttribute]
public Token[] Synonyms { get; public set; }
    public bool IncludeOrig { get; }
    public bool IgnoreCase { get; }
    public SlowSynonymMap(bool ignoreCase);
    public CharArrayMap`1<SlowSynonymMap> get_Submap();
    public void set_Submap(CharArrayMap`1<SlowSynonymMap> value);
    public Token[] get_Synonyms();
    public void set_Synonyms(Token[] value);
    public virtual bool get_IncludeOrig();
    public virtual bool get_IgnoreCase();
    public virtual void Add(IList`1<string> singleMatch, IList`1<Token> replacement, bool includeOrig, bool mergeExisting);
    public virtual string ToString();
    public static IList`1<Token> MakeTokens(IList`1<string> strings);
    public static IList`1<Token> MergeTokens(IList`1<Token> lst1, IList`1<Token> lst2);
}
public class Lucene.Net.Analysis.Synonym.SolrSynonymParser : Parser {
    private bool expand;
    public SolrSynonymParser(bool dedup, bool expand, Analyzer analyzer);
    public virtual void Parse(TextReader in);
    private static String[] Split(string s, string separator);
    private string Unescape(string s);
}
public class Lucene.Net.Analysis.Synonym.SynonymFilter : TokenFilter {
    public static string TYPE_SYNONYM;
    private SynonymMap synonyms;
    private bool ignoreCase;
    private int rollBufferSize;
    private int captureCount;
    private ICharTermAttribute termAtt;
    private IPositionIncrementAttribute posIncrAtt;
    private IPositionLengthAttribute posLenAtt;
    private ITypeAttribute typeAtt;
    private IOffsetAttribute offsetAtt;
    private int inputSkipCount;
    private PendingInput[] futureInputs;
    private ByteArrayDataInput bytesReader;
    private PendingOutputs[] futureOutputs;
    private int nextWrite;
    private int nextRead;
    private bool finished;
    private Arc`1<BytesRef> scratchArc;
    private FST`1<BytesRef> fst;
    private BytesReader fstReader;
    private BytesRef scratchBytes;
    private CharsRef scratchChars;
    private int lastStartOffset;
    private int lastEndOffset;
    internal int CaptureCount { get; }
    public SynonymFilter(TokenStream input, SynonymMap synonyms, bool ignoreCase);
    private void Capture();
    private void Parse();
    private void AddOutput(BytesRef bytes, int matchInputLength, int matchEndOffset);
    private int RollIncr(int count);
    internal int get_CaptureCount();
    public virtual bool IncrementToken();
    public virtual void Reset();
}
public class Lucene.Net.Analysis.Synonym.SynonymFilterFactory : TokenFilterFactory {
    private TokenFilterFactory delegator;
    [ObsoleteAttribute("Method exists only for testing 4x, will be removed in 5.0")]
internal TokenFilterFactory Delegator { get; }
    public SynonymFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
    public virtual void Inform(IResourceLoader loader);
    internal virtual TokenFilterFactory get_Delegator();
}
public class Lucene.Net.Analysis.Synonym.SynonymMap : object {
    public static char WORD_SEPARATOR;
    private FST`1<BytesRef> fst;
    private BytesRefHash words;
    private int maxHorizontalContext;
    public FST`1<BytesRef> Fst { get; }
    public BytesRefHash Words { get; }
    public int MaxHorizontalContext { get; }
    public SynonymMap(FST`1<BytesRef> fst, BytesRefHash words, int maxHorizontalContext);
    public FST`1<BytesRef> get_Fst();
    public BytesRefHash get_Words();
    public int get_MaxHorizontalContext();
}
public class Lucene.Net.Analysis.Synonym.WordnetSynonymParser : Parser {
    private bool expand;
    public WordnetSynonymParser(bool dedup, bool expand, Analyzer analyzer);
    public virtual void Parse(TextReader in);
    private CharsRef ParseSynonym(string line, CharsRef reuse);
    private void AddInternal(CharsRef[] synset, int size);
}
public class Lucene.Net.Analysis.Tr.ApostropheFilter : TokenFilter {
    private ICharTermAttribute termAtt;
    public ApostropheFilter(TokenStream in);
    public sealed virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Tr.ApostropheFilterFactory : TokenFilterFactory {
    public ApostropheFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
}
public class Lucene.Net.Analysis.Tr.TurkishAnalyzer : StopwordAnalyzerBase {
    private CharArraySet stemExclusionSet;
    public static string DEFAULT_STOPWORD_FILE;
    private static string STOPWORDS_COMMENT;
    public static CharArraySet DefaultStopSet { get; }
    public TurkishAnalyzer(LuceneVersion matchVersion);
    public TurkishAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords);
    public TurkishAnalyzer(LuceneVersion matchVersion, CharArraySet stopwords, CharArraySet stemExclusionSet);
    public static CharArraySet get_DefaultStopSet();
    protected internal virtual TokenStreamComponents CreateComponents(string fieldName, TextReader reader);
}
public class Lucene.Net.Analysis.Tr.TurkishLowerCaseFilter : TokenFilter {
    private static int LATIN_CAPITAL_LETTER_I;
    private static int LATIN_SMALL_LETTER_I;
    private static int LATIN_SMALL_LETTER_DOTLESS_I;
    private static int COMBINING_DOT_ABOVE;
    private ICharTermAttribute termAtt;
    private static CultureInfo culture;
    public TurkishLowerCaseFilter(TokenStream in);
    private static TurkishLowerCaseFilter();
    public sealed virtual bool IncrementToken();
    private bool IsBeforeDot(Char[] s, int pos, int len);
    private int Delete(Char[] s, int pos, int len);
}
public class Lucene.Net.Analysis.Tr.TurkishLowerCaseFilterFactory : TokenFilterFactory {
    public TurkishLowerCaseFilterFactory(IDictionary`2<string, string> args);
    public virtual TokenStream Create(TokenStream input);
    public virtual AbstractAnalysisFactory GetMultiTermComponent();
}
public abstract class Lucene.Net.Analysis.Util.AbstractAnalysisFactory : object {
    public static string LUCENE_MATCH_VERSION_PARAM;
    private IDictionary`2<string, string> originalArgs;
    protected LuceneVersion m_luceneMatchVersion;
    private static Regex ITEM_PATTERN;
    private static string CLASS_NAME;
    [CompilerGeneratedAttribute]
private bool <IsExplicitLuceneMatchVersion>k__BackingField;
    public IDictionary`2<string, string> OriginalArgs { get; }
    public LuceneVersion LuceneMatchVersion { get; }
    public bool IsExplicitLuceneMatchVersion { get; public set; }
    protected AbstractAnalysisFactory(IDictionary`2<string, string> args);
    private static AbstractAnalysisFactory();
    public IDictionary`2<string, string> get_OriginalArgs();
    protected void AssureMatchVersion();
    public LuceneVersion get_LuceneMatchVersion();
    public virtual string Require(IDictionary`2<string, string> args, string name);
    public virtual string Require(IDictionary`2<string, string> args, string name, ICollection`1<string> allowedValues);
    public virtual string Require(IDictionary`2<string, string> args, string name, ICollection`1<string> allowedValues, bool caseSensitive);
    public virtual string Get(IDictionary`2<string, string> args, string name, string defaultVal);
    public virtual string Get(IDictionary`2<string, string> args, string name, ICollection`1<string> allowedValues);
    public virtual string Get(IDictionary`2<string, string> args, string name, ICollection`1<string> allowedValues, string defaultVal);
    public virtual string Get(IDictionary`2<string, string> args, string name, ICollection`1<string> allowedValues, string defaultVal, bool caseSensitive);
    protected int RequireInt32(IDictionary`2<string, string> args, string name);
    protected int GetInt32(IDictionary`2<string, string> args, string name, int defaultVal);
    protected bool RequireBoolean(IDictionary`2<string, string> args, string name);
    protected bool GetBoolean(IDictionary`2<string, string> args, string name, bool defaultVal);
    protected float RequireSingle(IDictionary`2<string, string> args, string name);
    protected float GetSingle(IDictionary`2<string, string> args, string name, float defaultVal);
    public virtual char RequireChar(IDictionary`2<string, string> args, string name);
    public virtual char GetChar(IDictionary`2<string, string> args, string name, char defaultVal);
    public virtual ISet`1<string> GetSet(IDictionary`2<string, string> args, string name);
    protected Regex GetPattern(IDictionary`2<string, string> args, string name);
    protected CultureInfo GetCulture(IDictionary`2<string, string> args, string name, CultureInfo defaultVal);
    protected CharArraySet GetWordSet(IResourceLoader loader, string wordFiles, bool ignoreCase);
    protected IList`1<string> GetLines(IResourceLoader loader, string resource);
    protected CharArraySet GetSnowballWordSet(IResourceLoader loader, string wordFiles, bool ignoreCase);
    protected IList`1<string> SplitFileNames(string fileNames);
    public virtual string GetClassArg();
    [CompilerGeneratedAttribute]
public virtual bool get_IsExplicitLuceneMatchVersion();
    [CompilerGeneratedAttribute]
public virtual void set_IsExplicitLuceneMatchVersion(bool value);
}
internal class Lucene.Net.Analysis.Util.AnalysisSPILoader`1 : object {
    private IDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) services;
    private Type clazz;
    private String[] suffixes;
    public ICollection`1<string> AvailableServices { get; }
    public AnalysisSPILoader`1(String[] suffixes);
    public void Reload();
    public S NewInstance(string name, IDictionary`2<string, string> args);
    public Type LookupClass(string name);
    public ICollection`1<string> get_AvailableServices();
}
public class Lucene.Net.Analysis.Util.BufferedCharFilter : BaseCharFilter {
    public static int DEFAULT_CHAR_BUFFER_SIZE;
    protected object m_lock;
    private TextReader in;
    private Char[] buf;
    private int pos;
    private int end;
    private int mark;
    private int markLimit;
    private bool isDisposing;
    private bool IsClosed { get; }
    public bool IsMarkSupported { get; }
    public bool IsReady { get; }
    public BufferedCharFilter(TextReader in);
    public BufferedCharFilter(TextReader in, int size);
    protected virtual void Dispose(bool disposing);
    private int FillBuf();
    private void EnsureOpen();
    private bool get_IsClosed();
    public virtual void Mark(int markLimit);
    public virtual bool get_IsMarkSupported();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int offset, int length);
    public virtual string ReadLine();
    public virtual bool get_IsReady();
    public virtual void Reset();
    public virtual long Skip(int amount);
    public virtual int Peek();
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    public virtual Task`1<string> ReadLineAsync();
    public virtual string ReadToEnd();
    public virtual Task`1<string> ReadToEndAsync();
    public virtual object InitializeLifetimeService();
    public virtual void Close();
}
public abstract class Lucene.Net.Analysis.Util.CharacterUtils : object {
    private static CharacterUtils JAVA_4_BW_COMPAT;
    private static CharacterUtils JAVA_4;
    private static CharacterUtils JAVA_5;
    private static CharacterUtils();
    public static CharacterUtils GetInstance(LuceneVersion matchVersion);
    public static CharacterUtils GetJava4Instance(LuceneVersion matchVersion);
    public abstract virtual int CodePointAt(string seq, int offset);
    public abstract virtual int CodePointAt(ICharSequence seq, int offset);
    public abstract virtual int CodePointAt(Char[] chars, int offset, int limit);
    public abstract virtual int CodePointCount(string seq);
    public abstract virtual int CodePointCount(ICharSequence seq);
    public abstract virtual int CodePointCount(Char[] seq);
    public abstract virtual int CodePointCount(StringBuilder seq);
    public static CharacterBuffer NewCharacterBuffer(int bufferSize);
    public virtual void ToLower(Char[] buffer, int offset, int length);
    public virtual void ToUpper(Char[] buffer, int offset, int length);
    public int ToCodePoints(Char[] src, int srcOff, int srcLen, Int32[] dest, int destOff);
    public int ToChars(Int32[] src, int srcOff, int srcLen, Char[] dest, int destOff);
    public abstract virtual bool Fill(CharacterBuffer buffer, TextReader reader, int numChars);
    public virtual bool Fill(CharacterBuffer buffer, TextReader reader);
    public abstract virtual int OffsetByCodePoints(Char[] buf, int start, int count, int index, int offset);
    private static int ReadFully(TextReader reader, Char[] dest, int offset, int len);
}
public static class Lucene.Net.Analysis.Util.CharArrayMap : object {
    public static CharArrayMap`1<TValue> Copy(LuceneVersion matchVersion, IDictionary`2<string, TValue> map);
    internal static CharArrayMap`1<TValue> Copy(LuceneVersion matchVersion, ICharArrayMap map);
    public static CharArrayMap`1<TValue> UnmodifiableMap(CharArrayMap`1<TValue> map);
    internal static ICharArrayMap UnmodifiableMap(ICharArrayMap map);
}
[DefaultMemberAttribute("Item")]
public class Lucene.Net.Analysis.Util.CharArrayMap`1 : object {
    private static CharArrayMap`1<TValue> EMPTY_MAP;
    private static int INIT_SIZE;
    private CharacterUtils charUtils;
    private bool ignoreCase;
    private int count;
    private LuceneVersion matchVersion;
    internal Char[][] keys;
    internal MapValue[] values;
    internal static MapValue<TValue> PLACEHOLDER;
    private ICollection`1 modreq(System.Runtime.CompilerServices.IsVolatile) valueSet;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    private EntrySet_<TValue> entrySet;
    private CharArraySet keySet;
    private KeyCollection<TValue> originalKeySet;
    public LuceneVersion MatchVersion { get; }
    public TValue Item { get; public set; }
    public TValue Item { get; public set; }
    public TValue Item { get; public set; }
    public TValue Item { get; public set; }
    public TValue Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public bool IsReadOnly { get; private set; }
    public int Count { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public ICollection`1<string> OriginalKeySet { get; }
    private CharArraySet KeySet { get; }
    public CharArrayMap`1(LuceneVersion matchVersion, int startSize, bool ignoreCase);
    public CharArrayMap`1(LuceneVersion matchVersion, IDictionary`2<string, TValue> c, bool ignoreCase);
    internal CharArrayMap`1(CharArrayMap`1<TValue> toCopy);
    private static CharArrayMap`1();
    public virtual void Add(KeyValuePair`2<string, TValue> item);
    public virtual void Add(string key, TValue value);
    public virtual void Clear();
    [ObsoleteAttribute("Not applicable in this class.")]
[DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public virtual bool Contains(KeyValuePair`2<string, TValue> item);
    public virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public virtual void CopyTo(CharArrayMap`1<TValue> map);
    public virtual bool ContainsKey(Char[] text, int offset, int length);
    public virtual bool ContainsKey(Char[] text);
    public virtual bool ContainsKey(string text);
    public virtual bool ContainsKey(ICharSequence text);
    public virtual bool ContainsKey(object o);
    public virtual TValue Get(Char[] text, int offset, int length);
    public virtual TValue Get(Char[] text);
    public virtual TValue Get(ICharSequence text);
    public virtual TValue Get(string text);
    public virtual TValue Get(object o);
    private int GetSlot(Char[] text, int offset, int length);
    private int GetSlot(ICharSequence text);
    private int GetSlot(string text);
    public virtual TValue Put(ICharSequence text, TValue value);
    public virtual TValue Put(object o, TValue value);
    public virtual TValue Put(string text, TValue value);
    public virtual TValue Put(Char[] text, TValue value);
    private MapValue<TValue> PutImpl(ICharSequence text, MapValue<TValue> value);
    private MapValue<TValue> PutImpl(object o, MapValue<TValue> value);
    private MapValue<TValue> PutImpl(string text, MapValue<TValue> value);
    private MapValue<TValue> PutImpl(Char[] text, MapValue<TValue> value);
    public virtual void PutAll(IDictionary`2<Char[], TValue> collection);
    public virtual void PutAll(IDictionary`2<string, TValue> collection);
    public virtual void PutAll(IDictionary`2<ICharSequence, TValue> collection);
    public virtual void PutAll(IDictionary`2<object, TValue> collection);
    public virtual void PutAll(IEnumerable`1<KeyValuePair`2<Char[], TValue>> collection);
    public virtual void PutAll(IEnumerable`1<KeyValuePair`2<string, TValue>> collection);
    public virtual void PutAll(IEnumerable`1<KeyValuePair`2<ICharSequence, TValue>> collection);
    public virtual void PutAll(IEnumerable`1<KeyValuePair`2<object, TValue>> collection);
    private void Rehash();
    private bool Equals(Char[] text1, int offset, int length, Char[] text2);
    private bool Equals(ICharSequence text1, Char[] text2);
    private bool Equals(string text1, Char[] text2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private int GetHashCode(Char[] text, int offset, int length);
    private int GetHashCode(ICharSequence text);
    private int GetHashCode(string text);
    public virtual LuceneVersion get_MatchVersion();
    public virtual bool Put(Char[] text);
    public virtual bool Put(ICharSequence text);
    public virtual bool Put(string text);
    public virtual bool Put(object o);
    public virtual bool TryGetValue(Char[] key, int offset, int length, TValue& value);
    public virtual bool TryGetValue(Char[] key, TValue& value);
    public virtual bool TryGetValue(ICharSequence key, TValue& value);
    public virtual bool TryGetValue(string key, TValue& value);
    public virtual bool TryGetValue(object key, TValue& value);
    public virtual TValue get_Item(Char[] key, int offset, int length);
    public virtual void set_Item(Char[] key, int offset, int length, TValue value);
    public virtual TValue get_Item(Char[] key);
    public virtual void set_Item(Char[] key, TValue value);
    public virtual TValue get_Item(ICharSequence key);
    public virtual void set_Item(ICharSequence key, TValue value);
    public virtual TValue get_Item(string key);
    public virtual void set_Item(string key, TValue value);
    public virtual TValue get_Item(object key);
    public virtual void set_Item(object key, TValue value);
    public virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    [CompilerGeneratedAttribute]
public virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
private void set_IsReadOnly(bool value);
    public virtual IEnumerator`1<KeyValuePair`2<string, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [ObsoleteAttribute("Not applicable in this class.")]
[DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public virtual bool Remove(string key);
    [ObsoleteAttribute("Not applicable in this class.")]
[DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public virtual bool Remove(KeyValuePair`2<string, TValue> item);
    public virtual int get_Count();
    public virtual string ToString();
    internal virtual EntrySet_<TValue> CreateEntrySet();
    public EntrySet_<TValue> EntrySet();
    public sealed virtual ICollection`1<string> get_OriginalKeySet();
    private CharArraySet get_KeySet();
    public static CharArrayMap`1<TValue> EmptyMap();
}
[ExtensionAttribute]
public static class Lucene.Net.Analysis.Util.CharArrayMapExtensions : object {
    [ExtensionAttribute]
public static bool ContainsKey(CharArrayMap`1<TValue> map, bool key);
    [ExtensionAttribute]
public static bool ContainsKey(CharArrayMap`1<TValue> map, byte key);
    [ExtensionAttribute]
public static bool ContainsKey(CharArrayMap`1<TValue> map, char key);
    [ExtensionAttribute]
public static bool ContainsKey(CharArrayMap`1<TValue> map, int key);
    [ExtensionAttribute]
public static bool ContainsKey(CharArrayMap`1<TValue> map, long key);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool ContainsKey(CharArrayMap`1<TValue> map, sbyte key);
    [ExtensionAttribute]
public static bool ContainsKey(CharArrayMap`1<TValue> map, short key);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool ContainsKey(CharArrayMap`1<TValue> map, UInt32 key);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool ContainsKey(CharArrayMap`1<TValue> map, ulong key);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool ContainsKey(CharArrayMap`1<TValue> map, ushort key);
    [ExtensionAttribute]
public static TValue Get(CharArrayMap`1<TValue> map, bool text);
    [ExtensionAttribute]
public static TValue Get(CharArrayMap`1<TValue> map, byte text);
    [ExtensionAttribute]
public static TValue Get(CharArrayMap`1<TValue> map, char text);
    [ExtensionAttribute]
public static TValue Get(CharArrayMap`1<TValue> map, decimal text);
    [ExtensionAttribute]
public static TValue Get(CharArrayMap`1<TValue> map, double text);
    [ExtensionAttribute]
public static TValue Get(CharArrayMap`1<TValue> map, float text);
    [ExtensionAttribute]
public static TValue Get(CharArrayMap`1<TValue> map, int text);
    [ExtensionAttribute]
public static TValue Get(CharArrayMap`1<TValue> map, long text);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static TValue Get(CharArrayMap`1<TValue> map, sbyte text);
    [ExtensionAttribute]
public static TValue Get(CharArrayMap`1<TValue> map, short text);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static TValue Get(CharArrayMap`1<TValue> map, UInt32 text);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static TValue Get(CharArrayMap`1<TValue> map, ulong text);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static TValue Get(CharArrayMap`1<TValue> map, ushort text);
    [ExtensionAttribute]
public static TValue Put(CharArrayMap`1<TValue> map, bool text, TValue value);
    [ExtensionAttribute]
public static TValue Put(CharArrayMap`1<TValue> map, byte text, TValue value);
    [ExtensionAttribute]
public static TValue Put(CharArrayMap`1<TValue> map, char text, TValue value);
    [ExtensionAttribute]
public static TValue Put(CharArrayMap`1<TValue> map, int text, TValue value);
    [ExtensionAttribute]
public static TValue Put(CharArrayMap`1<TValue> map, long text, TValue value);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static TValue Put(CharArrayMap`1<TValue> map, sbyte text, TValue value);
    [ExtensionAttribute]
public static TValue Put(CharArrayMap`1<TValue> map, short text, TValue value);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static TValue Put(CharArrayMap`1<TValue> map, UInt32 text, TValue value);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static TValue Put(CharArrayMap`1<TValue> map, ulong text, TValue value);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static TValue Put(CharArrayMap`1<TValue> map, ushort text, TValue value);
    [ExtensionAttribute]
public static void PutAll(CharArrayMap`1<TValue> map, IDictionary`2<bool, TValue> dictionary);
    [ExtensionAttribute]
public static void PutAll(CharArrayMap`1<TValue> map, IDictionary`2<byte, TValue> dictionary);
    [ExtensionAttribute]
public static void PutAll(CharArrayMap`1<TValue> map, IDictionary`2<char, TValue> dictionary);
    [ExtensionAttribute]
public static void PutAll(CharArrayMap`1<TValue> map, IDictionary`2<int, TValue> dictionary);
    [ExtensionAttribute]
public static void PutAll(CharArrayMap`1<TValue> map, IDictionary`2<long, TValue> dictionary);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static void PutAll(CharArrayMap`1<TValue> map, IDictionary`2<sbyte, TValue> dictionary);
    [ExtensionAttribute]
public static void PutAll(CharArrayMap`1<TValue> map, IDictionary`2<short, TValue> dictionary);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static void PutAll(CharArrayMap`1<TValue> map, IDictionary`2<UInt32, TValue> dictionary);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static void PutAll(CharArrayMap`1<TValue> map, IDictionary`2<ulong, TValue> dictionary);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static void PutAll(CharArrayMap`1<TValue> map, IDictionary`2<ushort, TValue> dictionary);
    [ExtensionAttribute]
public static void PutAll(CharArrayMap`1<TValue> map, IEnumerable`1<KeyValuePair`2<bool, TValue>> collection);
    [ExtensionAttribute]
public static void PutAll(CharArrayMap`1<TValue> map, IEnumerable`1<KeyValuePair`2<byte, TValue>> collection);
    [ExtensionAttribute]
public static void PutAll(CharArrayMap`1<TValue> map, IEnumerable`1<KeyValuePair`2<char, TValue>> collection);
    [ExtensionAttribute]
public static void PutAll(CharArrayMap`1<TValue> map, IEnumerable`1<KeyValuePair`2<int, TValue>> collection);
    [ExtensionAttribute]
public static void PutAll(CharArrayMap`1<TValue> map, IEnumerable`1<KeyValuePair`2<long, TValue>> collection);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static void PutAll(CharArrayMap`1<TValue> map, IEnumerable`1<KeyValuePair`2<sbyte, TValue>> collection);
    [ExtensionAttribute]
public static void PutAll(CharArrayMap`1<TValue> map, IEnumerable`1<KeyValuePair`2<short, TValue>> collection);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static void PutAll(CharArrayMap`1<TValue> map, IEnumerable`1<KeyValuePair`2<UInt32, TValue>> collection);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static void PutAll(CharArrayMap`1<TValue> map, IEnumerable`1<KeyValuePair`2<ulong, TValue>> collection);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static void PutAll(CharArrayMap`1<TValue> map, IEnumerable`1<KeyValuePair`2<ushort, TValue>> collection);
    [ExtensionAttribute]
public static bool TryGetValue(CharArrayMap`1<TValue> map, bool key, TValue& value);
    [ExtensionAttribute]
public static bool TryGetValue(CharArrayMap`1<TValue> map, byte key, TValue& value);
    [ExtensionAttribute]
public static bool TryGetValue(CharArrayMap`1<TValue> map, char key, TValue& value);
    [ExtensionAttribute]
public static bool TryGetValue(CharArrayMap`1<TValue> map, int key, TValue& value);
    [ExtensionAttribute]
public static bool TryGetValue(CharArrayMap`1<TValue> map, long key, TValue& value);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool TryGetValue(CharArrayMap`1<TValue> map, sbyte key, TValue& value);
    [ExtensionAttribute]
public static bool TryGetValue(CharArrayMap`1<TValue> map, short key, TValue& value);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool TryGetValue(CharArrayMap`1<TValue> map, UInt32 key, TValue& value);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool TryGetValue(CharArrayMap`1<TValue> map, ulong key, TValue& value);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool TryGetValue(CharArrayMap`1<TValue> map, ushort key, TValue& value);
}
public class Lucene.Net.Analysis.Util.CharArraySet : object {
    public static CharArraySet EMPTY_SET;
    internal ICharArrayMap map;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    public int Count { get; }
    public bool IsReadOnly { get; private set; }
    public CharArraySet(LuceneVersion matchVersion, int startSize, bool ignoreCase);
    public CharArraySet(LuceneVersion matchVersion, ICollection`1<string> c, bool ignoreCase);
    internal CharArraySet(ICharArrayMap map);
    private static CharArraySet();
    public virtual void Clear();
    public virtual bool Contains(Char[] text, int offset, int length);
    public virtual bool Contains(Char[] text);
    public virtual bool Contains(ICharSequence cs);
    public virtual bool Contains(string cs);
    public virtual bool Contains(object o);
    public virtual bool Add(object o);
    public virtual bool Add(ICharSequence text);
    public virtual bool Add(string text);
    public virtual bool Add(Char[] text);
    private sealed virtual override void System.Collections.Generic.ICollection<System.String>.Add(string item);
    public virtual int get_Count();
    [CompilerGeneratedAttribute]
public virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
private void set_IsReadOnly(bool value);
    public static CharArraySet UnmodifiableSet(CharArraySet set);
    public static CharArraySet Copy(LuceneVersion matchVersion, ICollection`1<T> set);
    public virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void CopyTo(String[] array, int arrayIndex);
    [ObsoleteAttribute("Not applicable in this class.")]
[DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public virtual bool Remove(string item);
    public virtual bool SetEquals(IEnumerable`1<string> other);
    public virtual bool UnionWith(IEnumerable`1<Char[]> other);
    public virtual bool UnionWith(IEnumerable`1<ICharSequence> other);
    public virtual void UnionWith(IEnumerable`1<string> other);
    public virtual bool UnionWith(IEnumerable`1<T> other);
    [ObsoleteAttribute("Not applicable in this class.")]
[DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public sealed virtual void IntersectWith(IEnumerable`1<string> other);
    [ObsoleteAttribute("Not applicable in this class.")]
[DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public sealed virtual void ExceptWith(IEnumerable`1<string> other);
    [ObsoleteAttribute("Not applicable in this class.")]
[DesignerSerializationVisibilityAttribute("0")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
public sealed virtual void SymmetricExceptWith(IEnumerable`1<string> other);
    public virtual bool IsSubsetOf(IEnumerable`1<string> other);
    public virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public virtual bool IsSupersetOf(IEnumerable`1<string> other);
    public virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public virtual bool IsProperSubsetOf(IEnumerable`1<string> other);
    public virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public virtual bool IsProperSupersetOf(IEnumerable`1<string> other);
    public virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public virtual bool Overlaps(IEnumerable`1<string> other);
    public virtual bool Overlaps(IEnumerable`1<T> other);
    public virtual bool ContainsAll(IEnumerable`1<string> other);
    public virtual bool ContainsAll(IEnumerable`1<T> other);
    private bool IsSubsetOfCharArraySet(CharArraySet other);
    private void GetFoundAndUnfoundCounts(IEnumerable`1<T> other, Int32& foundCount, Int32& unfoundCount);
}
[ExtensionAttribute]
public static class Lucene.Net.Analysis.Util.CharArraySetExtensions : object {
    [ExtensionAttribute]
public static bool Add(CharArraySet set, bool text);
    [ExtensionAttribute]
public static bool Add(CharArraySet set, byte text);
    [ExtensionAttribute]
public static bool Add(CharArraySet set, char text);
    [ExtensionAttribute]
public static bool Add(CharArraySet set, int text);
    [ExtensionAttribute]
public static bool Add(CharArraySet set, long text);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool Add(CharArraySet set, sbyte text);
    [ExtensionAttribute]
public static bool Add(CharArraySet set, short text);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool Add(CharArraySet set, UInt32 text);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool Add(CharArraySet set, ulong text);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool Add(CharArraySet set, ushort text);
    [ExtensionAttribute]
public static bool Contains(CharArraySet set, bool text);
    [ExtensionAttribute]
public static bool Contains(CharArraySet set, byte text);
    [ExtensionAttribute]
public static bool Contains(CharArraySet set, char text);
    [ExtensionAttribute]
public static bool Contains(CharArraySet set, int text);
    [ExtensionAttribute]
public static bool Contains(CharArraySet set, long text);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool Contains(CharArraySet set, sbyte text);
    [ExtensionAttribute]
public static bool Contains(CharArraySet set, short text);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool Contains(CharArraySet set, UInt32 text);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool Contains(CharArraySet set, ulong text);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool Contains(CharArraySet set, ushort text);
    [ExtensionAttribute]
public static bool UnionWith(CharArraySet set, IEnumerable`1<byte> other);
    [ExtensionAttribute]
public static bool UnionWith(CharArraySet set, IEnumerable`1<char> other);
    [ExtensionAttribute]
public static bool UnionWith(CharArraySet set, IEnumerable`1<int> other);
    [ExtensionAttribute]
public static bool UnionWith(CharArraySet set, IEnumerable`1<long> other);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool UnionWith(CharArraySet set, IEnumerable`1<sbyte> other);
    [ExtensionAttribute]
public static bool UnionWith(CharArraySet set, IEnumerable`1<short> other);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool UnionWith(CharArraySet set, IEnumerable`1<UInt32> other);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool UnionWith(CharArraySet set, IEnumerable`1<ulong> other);
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool UnionWith(CharArraySet set, IEnumerable`1<ushort> other);
}
public abstract class Lucene.Net.Analysis.Util.CharFilterFactory : AbstractAnalysisFactory {
    private static AnalysisSPILoader`1<CharFilterFactory> loader;
    public static ICollection`1<string> AvailableCharFilters { get; }
    protected CharFilterFactory(IDictionary`2<string, string> args);
    private static CharFilterFactory();
    public static CharFilterFactory ForName(string name, IDictionary`2<string, string> args);
    public static Type LookupClass(string name);
    public static ICollection`1<string> get_AvailableCharFilters();
    public static void ReloadCharFilters();
    public abstract virtual TextReader Create(TextReader input);
}
public abstract class Lucene.Net.Analysis.Util.CharTokenizer : Tokenizer {
    private int offset;
    private int bufferIndex;
    private int dataLen;
    private int finalOffset;
    private static int MAX_WORD_LEN;
    private static int IO_BUFFER_SIZE;
    private ICharTermAttribute termAtt;
    private IOffsetAttribute offsetAtt;
    private CharacterUtils charUtils;
    private CharacterBuffer ioBuffer;
    public CharTokenizer(LuceneVersion matchVersion, TextReader input);
    public CharTokenizer(LuceneVersion matchVersion, AttributeFactory factory, TextReader input);
    private void Init(LuceneVersion matchVersion);
    protected abstract virtual bool IsTokenChar(int c);
    protected virtual int Normalize(int c);
    public sealed virtual bool IncrementToken();
    public sealed virtual void End();
    public virtual void Reset();
}
public class Lucene.Net.Analysis.Util.ClasspathResourceLoader : object {
    private Type clazz;
    public ClasspathResourceLoader(Type clazz);
    public sealed virtual Stream OpenResource(string resource);
    public sealed virtual Type FindType(string cname);
    public sealed virtual T NewInstance(string cname);
}
public class Lucene.Net.Analysis.Util.ElisionFilter : TokenFilter {
    private CharArraySet articles;
    private ICharTermAttribute termAtt;
    public ElisionFilter(TokenStream input, CharArraySet articles);
    public sealed virtual bool IncrementToken();
}
public class Lucene.Net.Analysis.Util.ElisionFilterFactory : TokenFilterFactory {
    private string articlesFile;
    private bool ignoreCase;
    private CharArraySet articles;
    public ElisionFilterFactory(IDictionary`2<string, string> args);
    public virtual void Inform(IResourceLoader loader);
    public virtual TokenStream Create(TokenStream input);
    public virtual AbstractAnalysisFactory GetMultiTermComponent();
}
public class Lucene.Net.Analysis.Util.FilesystemResourceLoader : object {
    private DirectoryInfo baseDirectory;
    private IResourceLoader delegate;
    public FilesystemResourceLoader(DirectoryInfo baseDirectory);
    public FilesystemResourceLoader(DirectoryInfo baseDirectory, IResourceLoader delegate);
    public sealed virtual Stream OpenResource(string resource);
    public sealed virtual T NewInstance(string cname);
    public sealed virtual Type FindType(string cname);
}
public abstract class Lucene.Net.Analysis.Util.FilteringTokenFilter : TokenFilter {
    protected LuceneVersion m_version;
    private IPositionIncrementAttribute posIncrAtt;
    private bool enablePositionIncrements;
    private bool first;
    private int skippedPositions;
    public bool EnablePositionIncrements { get; }
    [ObsoleteAttribute("enablePositionIncrements=false is not supported anymore as of Lucene 4.4")]
public FilteringTokenFilter(LuceneVersion version, bool enablePositionIncrements, TokenStream input);
    public FilteringTokenFilter(LuceneVersion version, TokenStream in);
    private static void CheckPositionIncrement(LuceneVersion version, bool enablePositionIncrements);
    protected abstract virtual bool Accept();
    public sealed virtual bool IncrementToken();
    public virtual void Reset();
    public virtual bool get_EnablePositionIncrements();
    [ObsoleteAttribute("enablePositionIncrements=false is not supported anymore as of Lucene 4.4")]
public virtual void SetEnablePositionIncrements(bool enable);
    public virtual void End();
}
internal interface Lucene.Net.Analysis.Util.ICharArrayMap {
    public int Count { get; }
    public LuceneVersion MatchVersion { get; }
    public ICollection`1<string> OriginalKeySet { get; }
    public abstract virtual void Clear();
    public abstract virtual bool ContainsKey(Char[] text, int offset, int length);
    public abstract virtual bool ContainsKey(Char[] text);
    public abstract virtual bool ContainsKey(object o);
    public abstract virtual bool ContainsKey(string text);
    public abstract virtual bool ContainsKey(ICharSequence text);
    public abstract virtual int get_Count();
    public abstract virtual LuceneVersion get_MatchVersion();
    public abstract virtual ICollection`1<string> get_OriginalKeySet();
    public abstract virtual bool Put(Char[] text);
    public abstract virtual bool Put(ICharSequence text);
    public abstract virtual bool Put(object o);
    public abstract virtual bool Put(string text);
}
public interface Lucene.Net.Analysis.Util.IMultiTermAwareComponent {
    public abstract virtual AbstractAnalysisFactory GetMultiTermComponent();
}
public interface Lucene.Net.Analysis.Util.IResourceLoader {
    public abstract virtual Stream OpenResource(string resource);
    public abstract virtual Type FindType(string cname);
    public abstract virtual T NewInstance(string cname);
}
public interface Lucene.Net.Analysis.Util.IResourceLoaderAware {
    public abstract virtual void Inform(IResourceLoader loader);
}
[DefaultMemberAttribute("Item")]
public class Lucene.Net.Analysis.Util.OpenStringBuilder : object {
    protected Char[] m_buf;
    protected int m_len;
    private bool J2N.Text.ICharSequence.HasValue { get; }
    public int Length { get; public set; }
    [WritableArrayAttribute]
public Char[] Array { get; }
    public int Capacity { get; }
    public char Item { get; public set; }
    public OpenStringBuilder(int size);
    public OpenStringBuilder(Char[] arr, int len);
    private sealed virtual override bool J2N.Text.ICharSequence.get_HasValue();
    public virtual int get_Length();
    public virtual void set_Length(int value);
    public virtual void Set(Char[] arr, int end);
    public virtual Char[] get_Array();
    public virtual int get_Capacity();
    public virtual OpenStringBuilder Append(ICharSequence csq);
    public virtual OpenStringBuilder Append(ICharSequence csq, int startIndex, int count);
    public virtual OpenStringBuilder Append(string csq);
    public virtual OpenStringBuilder Append(string csq, int startIndex, int count);
    public virtual OpenStringBuilder Append(StringBuilder csq);
    public virtual OpenStringBuilder Append(StringBuilder csq, int startIndex, int count);
    public virtual OpenStringBuilder Append(Char[] value);
    public virtual OpenStringBuilder Append(Char[] value, int startIndex, int count);
    public virtual OpenStringBuilder Append(char c);
    public virtual char get_Item(int index);
    public virtual void set_Item(int index, char value);
    public virtual ICharSequence Subsequence(int startIndex, int length);
    public virtual void UnsafeWrite(char b);
    public virtual void UnsafeWrite(int b);
    public virtual void UnsafeWrite(Char[] b, int off, int len);
    public virtual void UnsafeWrite(StringBuilder b, int off, int len);
    protected virtual void Resize(int len);
    public virtual void EnsureCapacity(int capacity);
    public virtual void Write(char b);
    public virtual void Write(int b);
    public void Write(Char[] b);
    public virtual void Write(Char[] b, int off, int len);
    public void Write(OpenStringBuilder arr);
    public void Write(StringBuilder arr);
    public virtual void Write(string s);
    public void Reset();
    public virtual Char[] ToCharArray();
    public virtual string ToString();
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(char value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(string value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(string value, int startIndex, int count);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(StringBuilder value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(StringBuilder value, int startIndex, int count);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(Char[] value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(Char[] value, int startIndex, int count);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(ICharSequence value);
    private sealed virtual override IAppendable J2N.Text.IAppendable.Append(ICharSequence value, int startIndex, int count);
}
public class Lucene.Net.Analysis.Util.RollingCharBuffer : object {
    private TextReader reader;
    private Char[] buffer;
    private int nextWrite;
    private int nextPos;
    private int count;
    private bool end;
    public void Reset(TextReader reader);
    public int Get(int pos);
    private bool InBounds(int pos);
    private int GetIndex(int pos);
    public Char[] Get(int posStart, int length);
    public void FreeBefore(int pos);
}
public static class Lucene.Net.Analysis.Util.StemmerUtil : object {
    public static bool StartsWith(Char[] s, int len, string prefix);
    public static bool EndsWith(Char[] s, int len, string suffix);
    public static bool EndsWith(Char[] s, int len, Char[] suffix);
    public static int Delete(Char[] s, int pos, int len);
    public static int DeleteN(Char[] s, int pos, int len, int nChars);
}
public abstract class Lucene.Net.Analysis.Util.StopwordAnalyzerBase : Analyzer {
    protected CharArraySet m_stopwords;
    protected LuceneVersion m_matchVersion;
    public CharArraySet StopwordSet { get; }
    protected StopwordAnalyzerBase(LuceneVersion version, CharArraySet stopwords);
    protected StopwordAnalyzerBase(LuceneVersion version);
    public virtual CharArraySet get_StopwordSet();
    protected static CharArraySet LoadStopwordSet(bool ignoreCase, Type aClass, string resource, string comment);
    protected static CharArraySet LoadStopwordSet(FileInfo stopwords, LuceneVersion matchVersion);
    protected static CharArraySet LoadStopwordSet(TextReader stopwords, LuceneVersion matchVersion);
}
public abstract class Lucene.Net.Analysis.Util.TokenFilterFactory : AbstractAnalysisFactory {
    private static AnalysisSPILoader`1<TokenFilterFactory> loader;
    public static ICollection`1<string> AvailableTokenFilters { get; }
    protected TokenFilterFactory(IDictionary`2<string, string> args);
    private static TokenFilterFactory();
    public static TokenFilterFactory ForName(string name, IDictionary`2<string, string> args);
    public static Type LookupClass(string name);
    public static ICollection`1<string> get_AvailableTokenFilters();
    public static void ReloadTokenFilters();
    public abstract virtual TokenStream Create(TokenStream input);
}
public abstract class Lucene.Net.Analysis.Util.TokenizerFactory : AbstractAnalysisFactory {
    private static AnalysisSPILoader`1<TokenizerFactory> loader;
    public static ICollection`1<string> AvailableTokenizers { get; }
    protected TokenizerFactory(IDictionary`2<string, string> args);
    private static TokenizerFactory();
    public static TokenizerFactory ForName(string name, IDictionary`2<string, string> args);
    public static Type LookupClass(string name);
    public static ICollection`1<string> get_AvailableTokenizers();
    public static void ReloadTokenizers();
    public Tokenizer Create(TextReader input);
    public abstract virtual Tokenizer Create(AttributeFactory factory, TextReader input);
}
public static class Lucene.Net.Analysis.Util.WordlistLoader : object {
    private static int INITIAL_CAPACITY;
    private static Regex WHITESPACE;
    private static WordlistLoader();
    public static CharArraySet GetWordSet(TextReader reader, CharArraySet result);
    public static CharArraySet GetWordSet(TextReader reader, LuceneVersion matchVersion);
    public static CharArraySet GetWordSet(TextReader reader, string comment, LuceneVersion matchVersion);
    public static CharArraySet GetWordSet(TextReader reader, string comment, CharArraySet result);
    public static CharArraySet GetSnowballWordSet(TextReader reader, CharArraySet result);
    public static CharArraySet GetSnowballWordSet(TextReader reader, LuceneVersion matchVersion);
    public static CharArrayMap`1<string> GetStemDict(TextReader reader, CharArrayMap`1<string> result);
    public static IList`1<string> GetLines(Stream stream, Encoding encoding);
}
public class Lucene.Net.Analysis.Wikipedia.WikipediaTokenizer : Tokenizer {
    public static string INTERNAL_LINK;
    public static string EXTERNAL_LINK;
    public static string EXTERNAL_LINK_URL;
    public static string CITATION;
    public static string CATEGORY;
    public static string BOLD;
    public static string ITALICS;
    public static string BOLD_ITALICS;
    public static string HEADING;
    public static string SUB_HEADING;
    public static int ALPHANUM_ID;
    public static int APOSTROPHE_ID;
    public static int ACRONYM_ID;
    public static int COMPANY_ID;
    public static int EMAIL_ID;
    public static int HOST_ID;
    public static int NUM_ID;
    public static int CJ_ID;
    public static int INTERNAL_LINK_ID;
    public static int EXTERNAL_LINK_ID;
    public static int CITATION_ID;
    public static int CATEGORY_ID;
    public static int BOLD_ID;
    public static int ITALICS_ID;
    public static int BOLD_ITALICS_ID;
    public static int HEADING_ID;
    public static int SUB_HEADING_ID;
    public static int EXTERNAL_LINK_URL_ID;
    public static String[] TOKEN_TYPES;
    public static int TOKENS_ONLY;
    public static int UNTOKENIZED_ONLY;
    public static int BOTH;
    public static int UNTOKENIZED_TOKEN_FLAG;
    private WikipediaTokenizerImpl scanner;
    private int tokenOutput;
    private ICollection`1<string> untokenizedTypes;
    private IEnumerator`1<State> tokens;
    private IOffsetAttribute offsetAtt;
    private ITypeAttribute typeAtt;
    private IPositionIncrementAttribute posIncrAtt;
    private ICharTermAttribute termAtt;
    private IFlagsAttribute flagsAtt;
    private bool first;
    public WikipediaTokenizer(TextReader input);
    public WikipediaTokenizer(TextReader input, int tokenOutput, ICollection`1<string> untokenizedTypes);
    public WikipediaTokenizer(AttributeFactory factory, TextReader input, int tokenOutput, ICollection`1<string> untokenizedTypes);
    private static WikipediaTokenizer();
    private void Init(int tokenOutput, ICollection`1<string> untokenizedTypes);
    public sealed virtual bool IncrementToken();
    private void CollapseAndSaveTokens(int tokenType, string type);
    private void SetupSavedToken(int positionInc, string type);
    private void CollapseTokens(int tokenType);
    private void SetupToken();
    protected virtual void Dispose(bool disposing);
    public virtual void Reset();
    public virtual void End();
}
public class Lucene.Net.Analysis.Wikipedia.WikipediaTokenizerFactory : TokenizerFactory {
    public WikipediaTokenizerFactory(IDictionary`2<string, string> args);
    public virtual Tokenizer Create(AttributeFactory factory, TextReader input);
}
internal class Lucene.Net.Analysis.Wikipedia.WikipediaTokenizerImpl : object {
    public static int YYEOF;
    private static int ZZ_BUFFERSIZE;
    public static int YYINITIAL;
    public static int CATEGORY_STATE;
    public static int INTERNAL_LINK_STATE;
    public static int EXTERNAL_LINK_STATE;
    public static int TWO_SINGLE_QUOTES_STATE;
    public static int THREE_SINGLE_QUOTES_STATE;
    public static int FIVE_SINGLE_QUOTES_STATE;
    public static int DOUBLE_EQUALS_STATE;
    public static int DOUBLE_BRACE_STATE;
    public static int STRING;
    private static Int32[] ZZ_LEXSTATE;
    private static string ZZ_CMAP_PACKED;
    private static Char[] ZZ_CMAP;
    private static Int32[] ZZ_ACTION;
    private static string ZZ_ACTION_PACKED_0;
    private static Int32[] ZZ_ROWMAP;
    private static string ZZ_ROWMAP_PACKED_0;
    private static Int32[] ZZ_TRANS;
    private static string ZZ_TRANS_PACKED_0;
    private static int ZZ_UNKNOWN_ERROR;
    private static int ZZ_NO_MATCH;
    private static int ZZ_PUSHBACK_2BIG;
    private static String[] ZZ_ERROR_MSG;
    private static Int32[] ZZ_ATTRIBUTE;
    private static string ZZ_ATTRIBUTE_PACKED_0;
    private TextReader zzReader;
    private int zzState;
    private int zzLexicalState;
    private Char[] zzBuffer;
    private int zzMarkedPos;
    private int zzCurrentPos;
    private int zzStartRead;
    private int zzEndRead;
    private int yychar;
    private bool zzAtEOF;
    public static int ALPHANUM;
    public static int APOSTROPHE;
    public static int ACRONYM;
    public static int COMPANY;
    public static int EMAIL;
    public static int HOST;
    public static int NUM;
    public static int CJ;
    public static int INTERNAL_LINK;
    public static int EXTERNAL_LINK;
    public static int CITATION;
    public static int CATEGORY;
    public static int BOLD;
    public static int ITALICS;
    public static int BOLD_ITALICS;
    public static int HEADING;
    public static int SUB_HEADING;
    public static int EXTERNAL_LINK_URL;
    private int currentTokType;
    private int numBalanced;
    private int positionInc;
    private int numLinkToks;
    private int numWikiTokensSeen;
    public static String[] TOKEN_TYPES;
    public int NumWikiTokensSeen { get; }
    public int YyChar { get; }
    public int PositionIncrement { get; }
    public int YyState { get; }
    public string YyText { get; }
    public int YyLength { get; }
    internal WikipediaTokenizerImpl(TextReader in);
    private static WikipediaTokenizerImpl();
    private static Int32[] ZzUnpackAction();
    private static int ZzUnpackAction(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackRowMap();
    private static int ZzUnpackRowMap(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackTrans();
    private static int ZzUnpackTrans(string packed, int offset, Int32[] result);
    private static Int32[] ZzUnpackAttribute();
    private static int ZzUnpackAttribute(string packed, int offset, Int32[] result);
    public int get_NumWikiTokensSeen();
    public int get_YyChar();
    public int get_PositionIncrement();
    internal void GetText(ICharTermAttribute t);
    internal int SetText(StringBuilder buffer);
    internal void Reset();
    private static Char[] ZzUnpackCMap(string packed);
    private bool ZzRefill();
    public void YyClose();
    public void YyReset(TextReader reader);
    public int get_YyState();
    public void YyBegin(int newState);
    public string get_YyText();
    public char YyCharAt(int pos);
    public int get_YyLength();
    private void ZzScanError(int errorCode);
    public void YyPushBack(int number);
    public int GetNextToken();
}
public class Lucene.Net.Tartarus.Snowball.Among : object {
    [CompilerGeneratedAttribute]
private string <SearchString>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MatchIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<bool> <Action>k__BackingField;
    public string SearchString { get; private set; }
    public int MatchIndex { get; private set; }
    public int Result { get; private set; }
    public Func`1<bool> Action { get; private set; }
    public Among(string str, int index, int result);
    public Among(string str, int index, int result, Func`1<bool> action);
    [CompilerGeneratedAttribute]
public string get_SearchString();
    [CompilerGeneratedAttribute]
private void set_SearchString(string value);
    [CompilerGeneratedAttribute]
public int get_MatchIndex();
    [CompilerGeneratedAttribute]
private void set_MatchIndex(int value);
    [CompilerGeneratedAttribute]
public int get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(int value);
    [CompilerGeneratedAttribute]
public Func`1<bool> get_Action();
    [CompilerGeneratedAttribute]
private void set_Action(Func`1<bool> value);
    public virtual string ToString();
}
public class Lucene.Net.Tartarus.Snowball.Ext.ArmenianStemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Among[] a_3;
    private static Char[] g_v;
    private int I_p2;
    private int I_pV;
    private static ArmenianStemmer();
    private void copy_from(ArmenianStemmer other);
    private bool r_mark_regions();
    private bool r_R2();
    private bool r_adjective();
    private bool r_verb();
    private bool r_noun();
    private bool r_ending();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.BasqueStemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Char[] g_v;
    private int I_p2;
    private int I_p1;
    private int I_pV;
    private static BasqueStemmer();
    private void copy_from(BasqueStemmer other);
    private bool r_mark_regions();
    private bool r_RV();
    private bool r_R2();
    private bool r_R1();
    private bool r_aditzak();
    private bool r_izenak();
    private bool r_adjetiboak();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.CatalanStemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Among[] a_3;
    private static Among[] a_4;
    private static Char[] g_v;
    private int I_p2;
    private int I_p1;
    private static CatalanStemmer();
    private void copy_from(CatalanStemmer other);
    private bool r_mark_regions();
    private bool r_cleaning();
    private bool r_R1();
    private bool r_R2();
    private bool r_attached_pronoun();
    private bool r_standard_suffix();
    private bool r_verb_suffix();
    private bool r_residual_suffix();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.DanishStemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Char[] g_v;
    private static Char[] g_s_ending;
    private int I_x;
    private int I_p1;
    private StringBuilder S_ch;
    private static DanishStemmer();
    private void copy_from(DanishStemmer other);
    private bool r_mark_regions();
    private bool r_main_suffix();
    private bool r_consonant_pair();
    private bool r_other_suffix();
    private bool r_undouble();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.DutchStemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Among[] a_3;
    private static Among[] a_4;
    private static Among[] a_5;
    private static Char[] g_v;
    private static Char[] g_v_I;
    private static Char[] g_v_j;
    private int I_p2;
    private int I_p1;
    private bool B_e_found;
    private static DutchStemmer();
    private void copy_from(DutchStemmer other);
    private bool r_prelude();
    private bool r_mark_regions();
    private bool r_postlude();
    private bool r_R1();
    private bool r_R2();
    private bool r_undouble();
    private bool r_e_ending();
    private bool r_en_ending();
    private bool r_standard_suffix();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.EnglishStemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Among[] a_3;
    private static Among[] a_4;
    private static Among[] a_5;
    private static Among[] a_6;
    private static Among[] a_7;
    private static Among[] a_8;
    private static Among[] a_9;
    private static Among[] a_10;
    private static Char[] g_v;
    private static Char[] g_v_WXY;
    private static Char[] g_valid_LI;
    private bool B_Y_found;
    private int I_p2;
    private int I_p1;
    private static EnglishStemmer();
    private void copy_from(EnglishStemmer other);
    private bool r_prelude();
    private bool r_mark_regions();
    [ExceptionToNetNumericConventionAttribute]
private bool r_shortv();
    private bool r_R1();
    private bool r_R2();
    private bool r_Step_1a();
    private bool r_Step_1b();
    private bool r_Step_1c();
    private bool r_Step_2();
    private bool r_Step_3();
    private bool r_Step_4();
    private bool r_Step_5();
    private bool r_exception2();
    private bool r_exception1();
    private bool r_postlude();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.FinnishStemmer : SnowballProgram {
    private static FinnishStemmer methodObject;
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Among[] a_3;
    private static Among[] a_4;
    private static Among[] a_5;
    private static Among[] a_6;
    private static Among[] a_7;
    private static Among[] a_8;
    private static Among[] a_9;
    private static Char[] g_AEI;
    private static Char[] g_V1;
    private static Char[] g_V2;
    private static Char[] g_particle_end;
    private bool B_ending_removed;
    private StringBuilder S_x;
    private int I_p2;
    private int I_p1;
    private static FinnishStemmer();
    private void copy_from(FinnishStemmer other);
    private bool r_mark_regions();
    private bool r_R2();
    private bool r_particle_etc();
    private bool r_possessive();
    private bool r_LONG();
    private bool r_VI();
    private bool r_case_ending();
    private bool r_other_endings();
    private bool r_i_plural();
    private bool r_t_plural();
    private bool r_tidy();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.FrenchStemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Among[] a_3;
    private static Among[] a_4;
    private static Among[] a_5;
    private static Among[] a_6;
    private static Among[] a_7;
    private static Among[] a_8;
    private static Char[] g_v;
    private static Char[] g_keep_with_s;
    private int I_p2;
    private int I_p1;
    private int I_pV;
    private static FrenchStemmer();
    private void copy_from(FrenchStemmer other);
    private bool r_prelude();
    private bool r_mark_regions();
    private bool r_postlude();
    private bool r_RV();
    private bool r_R1();
    private bool r_R2();
    private bool r_standard_suffix();
    private bool r_i_verb_suffix();
    private bool r_verb_suffix();
    private bool r_residual_suffix();
    private bool r_un_double();
    private bool r_un_accent();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.German2Stemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Among[] a_3;
    private static Among[] a_4;
    private static Among[] a_5;
    private static Char[] g_v;
    private static Char[] g_s_ending;
    private static Char[] g_st_ending;
    private int I_x;
    private int I_p2;
    private int I_p1;
    private static German2Stemmer();
    private void copy_from(German2Stemmer other);
    private bool r_prelude();
    private bool r_mark_regions();
    private bool r_postlude();
    private bool r_R1();
    private bool r_R2();
    private bool r_standard_suffix();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.GermanStemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Among[] a_3;
    private static Among[] a_4;
    private static Char[] g_v;
    private static Char[] g_s_ending;
    private static Char[] g_st_ending;
    private int I_x;
    private int I_p2;
    private int I_p1;
    private static GermanStemmer();
    private void copy_from(GermanStemmer other);
    private bool r_prelude();
    private bool r_mark_regions();
    private bool r_postlude();
    private bool r_R1();
    private bool r_R2();
    private bool r_standard_suffix();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.HungarianStemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Among[] a_3;
    private static Among[] a_4;
    private static Among[] a_5;
    private static Among[] a_6;
    private static Among[] a_7;
    private static Among[] a_8;
    private static Among[] a_9;
    private static Among[] a_10;
    private static Among[] a_11;
    private static Char[] g_v;
    private int I_p1;
    private static HungarianStemmer();
    private void copy_from(HungarianStemmer other);
    private bool r_mark_regions();
    private bool r_R1();
    private bool r_v_ending();
    private bool r_double();
    private bool r_undouble();
    private bool r_instrum();
    private bool r_case();
    private bool r_case_special();
    private bool r_case_other();
    private bool r_factive();
    private bool r_plural();
    private bool r_owned();
    private bool r_sing_owner();
    private bool r_plur_owner();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.IrishStemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Among[] a_3;
    private static Char[] g_v;
    private int I_p2;
    private int I_p1;
    private int I_pV;
    private static IrishStemmer();
    private void copy_from(IrishStemmer other);
    private bool r_mark_regions();
    private bool r_initial_morph();
    private bool r_RV();
    private bool r_R1();
    private bool r_R2();
    private bool r_noun_sfx();
    private bool r_deriv();
    private bool r_verb_sfx();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.ItalianStemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Among[] a_3;
    private static Among[] a_4;
    private static Among[] a_5;
    private static Among[] a_6;
    private static Among[] a_7;
    private static Char[] g_v;
    private static Char[] g_AEIO;
    private static Char[] g_CG;
    private int I_p2;
    private int I_p1;
    private int I_pV;
    private static ItalianStemmer();
    private void copy_from(ItalianStemmer other);
    private bool r_prelude();
    private bool r_mark_regions();
    private bool r_postlude();
    private bool r_RV();
    private bool r_R1();
    private bool r_R2();
    private bool r_attached_pronoun();
    private bool r_standard_suffix();
    private bool r_verb_suffix();
    private bool r_vowel_suffix();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.KpStemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Among[] a_3;
    private static Among[] a_4;
    private static Among[] a_5;
    private static Among[] a_6;
    private static Among[] a_7;
    private static Char[] g_v;
    private static Char[] g_v_WX;
    private static Char[] g_AOU;
    private static Char[] g_AIOU;
    private bool B_GE_removed;
    private bool B_stemmed;
    private bool B_Y_found;
    private int I_p2;
    private int I_p1;
    private int I_x;
    private StringBuilder S_ch;
    private static KpStemmer();
    private void copy_from(KpStemmer other);
    private bool r_R1();
    private bool r_R2();
    private bool r_V();
    private bool r_VX();
    private bool r_C();
    private bool r_lengthen_V();
    private bool r_Step_1();
    private bool r_Step_2();
    private bool r_Step_3();
    private bool r_Step_4();
    private bool r_Step_7();
    private bool r_Step_6();
    private bool r_Step_1c();
    private bool r_Lose_prefix();
    private bool r_Lose_infix();
    private bool r_measure();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.LovinsStemmer : SnowballProgram {
    private static LovinsStemmer methodObject;
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Among[] a_3;
    private static LovinsStemmer();
    private void copy_from(LovinsStemmer other);
    private bool r_A();
    private bool r_B();
    private bool r_C();
    private bool r_D();
    private bool r_E();
    private bool r_F();
    private bool r_G();
    private bool r_H();
    private bool r_I();
    private bool r_J();
    private bool r_K();
    private bool r_L();
    private bool r_M();
    private bool r_N();
    private bool r_O();
    private bool r_P();
    private bool r_Q();
    private bool r_R();
    private bool r_S();
    private bool r_T();
    private bool r_U();
    private bool r_V();
    private bool r_W();
    private bool r_X();
    private bool r_Y();
    private bool r_Z();
    private bool r_AA();
    private bool r_BB();
    private bool r_CC();
    private bool r_endings();
    private bool r_undouble();
    private bool r_respell();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.NorwegianStemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Char[] g_v;
    private static Char[] g_s_ending;
    private int I_x;
    private int I_p1;
    private static NorwegianStemmer();
    private void copy_from(NorwegianStemmer other);
    private bool r_mark_regions();
    private bool r_main_suffix();
    private bool r_consonant_pair();
    private bool r_other_suffix();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.PorterStemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Among[] a_3;
    private static Among[] a_4;
    private static Among[] a_5;
    private static Char[] g_v;
    private static Char[] g_v_WXY;
    private bool B_Y_found;
    private int I_p2;
    private int I_p1;
    private static PorterStemmer();
    private void copy_from(PorterStemmer other);
    [ExceptionToNetNumericConventionAttribute]
private bool r_shortv();
    private bool r_R1();
    private bool r_R2();
    private bool r_Step_1a();
    private bool r_Step_1b();
    private bool r_Step_1c();
    private bool r_Step_2();
    private bool r_Step_3();
    private bool r_Step_4();
    private bool r_Step_5a();
    private bool r_Step_5b();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.PortugueseStemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Among[] a_3;
    private static Among[] a_4;
    private static Among[] a_5;
    private static Among[] a_6;
    private static Among[] a_7;
    private static Among[] a_8;
    private static Char[] g_v;
    private int I_p2;
    private int I_p1;
    private int I_pV;
    private static PortugueseStemmer();
    private void copy_from(PortugueseStemmer other);
    private bool r_prelude();
    private bool r_mark_regions();
    private bool r_postlude();
    private bool r_RV();
    private bool r_R1();
    private bool r_R2();
    private bool r_standard_suffix();
    private bool r_verb_suffix();
    private bool r_residual_suffix();
    private bool r_residual_form();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.RomanianStemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Among[] a_3;
    private static Among[] a_4;
    private static Among[] a_5;
    private static Char[] g_v;
    private bool B_standard_suffix_removed;
    private int I_p2;
    private int I_p1;
    private int I_pV;
    private static RomanianStemmer();
    private void copy_from(RomanianStemmer other);
    private bool r_prelude();
    private bool r_mark_regions();
    private bool r_postlude();
    private bool r_RV();
    private bool r_R1();
    private bool r_R2();
    private bool r_step_0();
    private bool r_combo_suffix();
    private bool r_standard_suffix();
    private bool r_verb_suffix();
    private bool r_vowel_suffix();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.RussianStemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Among[] a_3;
    private static Among[] a_4;
    private static Among[] a_5;
    private static Among[] a_6;
    private static Among[] a_7;
    private static Char[] g_v;
    private int I_p2;
    private int I_pV;
    private static RussianStemmer();
    private void copy_from(RussianStemmer other);
    private bool r_mark_regions();
    private bool r_R2();
    private bool r_perfective_gerund();
    private bool r_adjective();
    private bool r_adjectival();
    private bool r_reflexive();
    private bool r_verb();
    private bool r_noun();
    private bool r_derivational();
    private bool r_tidy_up();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.SpanishStemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Among[] a_3;
    private static Among[] a_4;
    private static Among[] a_5;
    private static Among[] a_6;
    private static Among[] a_7;
    private static Among[] a_8;
    private static Among[] a_9;
    private static Char[] g_v;
    private int I_p2;
    private int I_p1;
    private int I_pV;
    private static SpanishStemmer();
    private void copy_from(SpanishStemmer other);
    private bool r_mark_regions();
    private bool r_postlude();
    private bool r_RV();
    private bool r_R1();
    private bool r_R2();
    private bool r_attached_pronoun();
    private bool r_standard_suffix();
    private bool r_y_verb_suffix();
    private bool r_verb_suffix();
    private bool r_residual_suffix();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.SwedishStemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Char[] g_v;
    private static Char[] g_s_ending;
    private int I_x;
    private int I_p1;
    private static SwedishStemmer();
    private void copy_from(SwedishStemmer other);
    private bool r_mark_regions();
    private bool r_main_suffix();
    private bool r_consonant_pair();
    private bool r_other_suffix();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Tartarus.Snowball.Ext.TurkishStemmer : SnowballProgram {
    private static Among[] a_0;
    private static Among[] a_1;
    private static Among[] a_2;
    private static Among[] a_3;
    private static Among[] a_4;
    private static Among[] a_5;
    private static Among[] a_6;
    private static Among[] a_7;
    private static Among[] a_8;
    private static Among[] a_9;
    private static Among[] a_10;
    private static Among[] a_11;
    private static Among[] a_12;
    private static Among[] a_13;
    private static Among[] a_14;
    private static Among[] a_15;
    private static Among[] a_16;
    private static Among[] a_17;
    private static Among[] a_18;
    private static Among[] a_19;
    private static Among[] a_20;
    private static Among[] a_21;
    private static Among[] a_22;
    private static Among[] a_23;
    private static Char[] g_vowel;
    private static Char[] g_U;
    private static Char[] g_vowel1;
    private static Char[] g_vowel2;
    private static Char[] g_vowel3;
    private static Char[] g_vowel4;
    private static Char[] g_vowel5;
    private static Char[] g_vowel6;
    private bool B_continue_stemming_noun_suffixes;
    private int I_strlen;
    private static TurkishStemmer();
    private void copy_from(TurkishStemmer other);
    private bool r_check_vowel_harmony();
    private bool r_mark_suffix_with_optional_n_consonant();
    private bool r_mark_suffix_with_optional_s_consonant();
    private bool r_mark_suffix_with_optional_y_consonant();
    private bool r_mark_suffix_with_optional_U_vowel();
    private bool r_mark_possessives();
    private bool r_mark_sU();
    private bool r_mark_lArI();
    private bool r_mark_yU();
    private bool r_mark_nU();
    private bool r_mark_nUn();
    private bool r_mark_yA();
    private bool r_mark_nA();
    private bool r_mark_DA();
    private bool r_mark_ndA();
    private bool r_mark_DAn();
    private bool r_mark_ndAn();
    private bool r_mark_ylA();
    private bool r_mark_ki();
    private bool r_mark_ncA();
    private bool r_mark_yUm();
    private bool r_mark_sUn();
    private bool r_mark_yUz();
    private bool r_mark_sUnUz();
    private bool r_mark_lAr();
    private bool r_mark_nUz();
    private bool r_mark_DUr();
    private bool r_mark_cAsInA();
    private bool r_mark_yDU();
    private bool r_mark_ysA();
    private bool r_mark_ymUs_();
    private bool r_mark_yken();
    private bool r_stem_nominal_verb_suffixes();
    private bool r_stem_suffix_chain_before_ki();
    private bool r_stem_noun_suffixes();
    private bool r_post_process_last_consonants();
    private bool r_append_U_to_stems_ending_with_d_or_g();
    private bool r_more_than_one_syllable_word();
    private bool r_is_reserved_word();
    private bool r_postlude();
    public virtual bool Stem();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public abstract class Lucene.Net.Tartarus.Snowball.SnowballProgram : object {
    protected Char[] m_current;
    protected int m_cursor;
    protected int m_limit;
    protected int m_limit_backward;
    protected int m_bra;
    protected int m_ket;
    public string Current { get; }
    [WritableArrayAttribute]
public Char[] CurrentBuffer { get; }
    public int CurrentBufferLength { get; }
    public abstract virtual bool Stem();
    public virtual void SetCurrent(string value);
    public virtual string get_Current();
    public virtual void SetCurrent(Char[] text, int length);
    public virtual Char[] get_CurrentBuffer();
    public virtual int get_CurrentBufferLength();
    protected virtual void CopyFrom(SnowballProgram other);
    protected virtual bool InGrouping(Char[] s, int min, int max);
    protected virtual bool InGroupingB(Char[] s, int min, int max);
    protected virtual bool OutGrouping(Char[] s, int min, int max);
    protected virtual bool OutGroupingB(Char[] s, int min, int max);
    protected virtual bool InRange(int min, int max);
    protected virtual bool InRangeB(int min, int max);
    protected virtual bool OutRange(int min, int max);
    protected virtual bool OutRangeB(int min, int max);
    protected virtual bool Eq_S(int s_size, string s);
    protected virtual bool Eq_S_B(int s_size, string s);
    protected virtual bool Eq_V(string s);
    protected virtual bool Eq_V_B(string s);
    protected virtual int FindAmong(Among[] v, int v_size);
    protected virtual int FindAmongB(Among[] v, int v_size);
    protected virtual int ReplaceS(int c_bra, int c_ket, string s);
    protected virtual void SliceCheck();
    protected virtual void SliceFrom(string s);
    protected virtual void SliceDel();
    protected virtual void Insert(int c_bra, int c_ket, string s);
    protected virtual StringBuilder SliceTo(StringBuilder s);
    protected virtual StringBuilder AssignTo(StringBuilder s);
}
