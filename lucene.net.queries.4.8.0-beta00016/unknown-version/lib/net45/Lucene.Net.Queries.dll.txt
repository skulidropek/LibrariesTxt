public class Lucene.Net.Queries.BooleanFilter : Filter {
    private IList`1<FilterClause> clauses;
    public IList`1<FilterClause> Clauses { get; }
    public virtual DocIdSet GetDocIdSet(AtomicReaderContext context, IBits acceptDocs);
    private static DocIdSetIterator GetDISI(Filter filter, AtomicReaderContext context);
    public virtual void Add(FilterClause filterClause);
    public void Add(Filter filter, Occur occur);
    public virtual IList`1<FilterClause> get_Clauses();
    public sealed virtual IEnumerator`1<FilterClause> GetEnumerator();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Lucene.Net.Queries.BoostingQuery : Query {
    private float boost;
    private Query match;
    private Query context;
    public BoostingQuery(Query match, Query context, float boost);
    public virtual Query Rewrite(IndexReader reader);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString(string field);
}
public class Lucene.Net.Queries.ChainedFilter : Filter {
    public static int OR;
    public static int AND;
    public static int ANDNOT;
    public static int XOR;
    public static int DEFAULT;
    private Filter[] chain;
    private Int32[] logicArray;
    private int logic;
    public ChainedFilter(Filter[] chain);
    public ChainedFilter(Filter[] chain, Int32[] logicArray);
    public ChainedFilter(Filter[] chain, int logic);
    public virtual DocIdSet GetDocIdSet(AtomicReaderContext context, IBits acceptDocs);
    private static DocIdSetIterator GetDISI(Filter filter, AtomicReaderContext context);
    private FixedBitSet InitialResult(AtomicReaderContext context, int logic, Int32[] index);
    private DocIdSet GetDocIdSet(AtomicReaderContext context, int logic, Int32[] index);
    private DocIdSet GetDocIdSet(AtomicReaderContext context, Int32[] logic, Int32[] index);
    public virtual string ToString();
    private void DoChain(FixedBitSet result, int logic, DocIdSet dis);
}
public class Lucene.Net.Queries.CommonTermsQuery : Query {
    protected IList`1<Term> m_terms;
    protected bool m_disableCoord;
    protected float m_maxTermFrequency;
    protected Occur m_lowFreqOccur;
    protected Occur m_highFreqOccur;
    protected float m_lowFreqBoost;
    protected float m_highFreqBoost;
    protected float m_lowFreqMinNrShouldMatch;
    protected float m_highFreqMinNrShouldMatch;
    public bool IsCoordDisabled { get; }
    public float LowFreqMinimumNumberShouldMatch { get; public set; }
    public float HighFreqMinimumNumberShouldMatch { get; public set; }
    public CommonTermsQuery(Occur highFreqOccur, Occur lowFreqOccur, float maxTermFrequency);
    public CommonTermsQuery(Occur highFreqOccur, Occur lowFreqOccur, float maxTermFrequency, bool disableCoord);
    public virtual void Add(Term term);
    public virtual Query Rewrite(IndexReader reader);
    protected virtual int CalcLowFreqMinimumNumberShouldMatch(int numOptional);
    protected virtual int CalcHighFreqMinimumNumberShouldMatch(int numOptional);
    private int MinNrShouldMatch(float minNrShouldMatch, int numOptional);
    protected virtual Query BuildQuery(int maxDoc, TermContext[] contextArray, Term[] queryTerms);
    public virtual void CollectTermContext(IndexReader reader, IList`1<AtomicReaderContext> leaves, TermContext[] contextArray, Term[] queryTerms);
    public virtual bool get_IsCoordDisabled();
    public virtual float get_LowFreqMinimumNumberShouldMatch();
    public virtual void set_LowFreqMinimumNumberShouldMatch(float value);
    public virtual float get_HighFreqMinimumNumberShouldMatch();
    public virtual void set_HighFreqMinimumNumberShouldMatch(float value);
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual string ToString(string field);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    protected virtual Query NewTermQuery(Term term, TermContext context);
    public sealed virtual IEnumerator`1<Term> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Lucene.Net.Queries.CustomScoreProvider : object {
    protected AtomicReaderContext m_context;
    public CustomScoreProvider(AtomicReaderContext context);
    public virtual float CustomScore(int doc, float subQueryScore, Single[] valSrcScores);
    public virtual float CustomScore(int doc, float subQueryScore, float valSrcScore);
    public virtual Explanation CustomExplain(int doc, Explanation subQueryExpl, Explanation[] valSrcExpls);
    public virtual Explanation CustomExplain(int doc, Explanation subQueryExpl, Explanation valSrcExpl);
}
public class Lucene.Net.Queries.CustomScoreQuery : Query {
    private Query subQuery;
    private Query[] scoringQueries;
    private bool strict;
    public bool IsStrict { get; public set; }
    public Query SubQuery { get; }
    [WritableArrayAttribute]
public Query[] ScoringQueries { get; }
    public string Name { get; }
    public CustomScoreQuery(Query subQuery);
    public CustomScoreQuery(Query subQuery, FunctionQuery scoringQuery);
    public CustomScoreQuery(Query subQuery, FunctionQuery[] scoringQueries);
    public virtual Query Rewrite(IndexReader reader);
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual object Clone();
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    protected internal virtual CustomScoreProvider GetCustomScoreProvider(AtomicReaderContext context);
    public virtual Weight CreateWeight(IndexSearcher searcher);
    public virtual bool get_IsStrict();
    public virtual void set_IsStrict(bool value);
    public virtual Query get_SubQuery();
    public virtual Query[] get_ScoringQueries();
    public virtual string get_Name();
}
public class Lucene.Net.Queries.FilterClause : object {
    private Occur occur;
    private Filter filter;
    public Filter Filter { get; }
    public Occur Occur { get; }
    public FilterClause(Filter filter, Occur occur);
    public Filter get_Filter();
    public Occur get_Occur();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Lucene.Net.Queries.Function.BoostedQuery : Query {
    private Query q;
    private ValueSource boostVal;
    public Query Query { get; }
    public ValueSource ValueSource { get; }
    public BoostedQuery(Query subQuery, ValueSource boostVal);
    public virtual Query get_Query();
    public virtual ValueSource get_ValueSource();
    public virtual Query Rewrite(IndexReader reader);
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual Weight CreateWeight(IndexSearcher searcher);
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public abstract class Lucene.Net.Queries.Function.DocValues.BoolDocValues : FunctionValues {
    protected ValueSource m_vs;
    protected BoolDocValues(ValueSource vs);
    public abstract virtual bool BoolVal(int doc);
    public virtual byte ByteVal(int doc);
    public virtual short Int16Val(int doc);
    public virtual float SingleVal(int doc);
    public virtual int Int32Val(int doc);
    public virtual long Int64Val(int doc);
    public virtual double DoubleVal(int doc);
    public virtual string StrVal(int doc);
    public virtual object ObjectVal(int doc);
    public virtual string ToString(int doc);
    public virtual ValueFiller GetValueFiller();
    [CompilerGeneratedAttribute]
private void <GetValueFiller>b__12_0(int doc, MutableValueBool mutableValue);
}
public abstract class Lucene.Net.Queries.Function.DocValues.DocTermsIndexDocValues : FunctionValues {
    protected SortedDocValues m_termsIndex;
    protected ValueSource m_vs;
    protected MutableValueStr m_val;
    protected BytesRef m_spare;
    protected CharsRef m_spareChars;
    public int NumOrd { get; }
    protected DocTermsIndexDocValues(ValueSource vs, AtomicReaderContext context, string field);
    protected abstract virtual string ToTerm(string readableValue);
    public virtual bool Exists(int doc);
    public virtual int OrdVal(int doc);
    public virtual int get_NumOrd();
    public virtual bool BytesVal(int doc, BytesRef target);
    public virtual string StrVal(int doc);
    public virtual bool BoolVal(int doc);
    public abstract virtual object ObjectVal(int doc);
    public virtual ValueSourceScorer GetRangeScorer(IndexReader reader, string lowerVal, string upperVal, bool includeLower, bool includeUpper);
    public virtual string ToString(int doc);
    public virtual ValueFiller GetValueFiller();
    [CompilerGeneratedAttribute]
private void <GetValueFiller>b__17_0(int doc, MutableValueStr mutableValue);
}
public abstract class Lucene.Net.Queries.Function.DocValues.DoubleDocValues : FunctionValues {
    protected ValueSource m_vs;
    protected DoubleDocValues(ValueSource vs);
    public virtual byte ByteVal(int doc);
    public virtual short Int16Val(int doc);
    public virtual float SingleVal(int doc);
    public virtual int Int32Val(int doc);
    public virtual long Int64Val(int doc);
    public virtual bool BoolVal(int doc);
    public abstract virtual double DoubleVal(int doc);
    public virtual string StrVal(int doc);
    public virtual object ObjectVal(int doc);
    public virtual string ToString(int doc);
    public virtual ValueSourceScorer GetRangeScorer(IndexReader reader, string lowerVal, string upperVal, bool includeLower, bool includeUpper);
    public virtual ValueFiller GetValueFiller();
    [CompilerGeneratedAttribute]
private void <GetValueFiller>b__13_0(int doc, MutableValueDouble mutableValue);
}
public abstract class Lucene.Net.Queries.Function.DocValues.Int32DocValues : FunctionValues {
    protected ValueSource m_vs;
    protected Int32DocValues(ValueSource vs);
    public virtual byte ByteVal(int doc);
    public virtual short Int16Val(int doc);
    public virtual float SingleVal(int doc);
    public abstract virtual int Int32Val(int doc);
    public virtual long Int64Val(int doc);
    public virtual double DoubleVal(int doc);
    public virtual string StrVal(int doc);
    public virtual object ObjectVal(int doc);
    public virtual string ToString(int doc);
    public virtual ValueSourceScorer GetRangeScorer(IndexReader reader, string lowerVal, string upperVal, bool includeLower, bool includeUpper);
    public virtual ValueFiller GetValueFiller();
    [CompilerGeneratedAttribute]
private void <GetValueFiller>b__12_0(int doc, MutableValueInt32 mutableValue);
}
public abstract class Lucene.Net.Queries.Function.DocValues.Int64DocValues : FunctionValues {
    protected ValueSource m_vs;
    protected Int64DocValues(ValueSource vs);
    public virtual byte ByteVal(int doc);
    public virtual short Int16Val(int doc);
    public virtual float SingleVal(int doc);
    public virtual int Int32Val(int doc);
    public abstract virtual long Int64Val(int doc);
    public virtual double DoubleVal(int doc);
    public virtual bool BoolVal(int doc);
    public virtual string StrVal(int doc);
    public virtual object ObjectVal(int doc);
    public virtual string ToString(int doc);
    protected virtual long ExternalToInt64(string extVal);
    public virtual ValueSourceScorer GetRangeScorer(IndexReader reader, string lowerVal, string upperVal, bool includeLower, bool includeUpper);
    public virtual ValueFiller GetValueFiller();
    [CompilerGeneratedAttribute]
private void <GetValueFiller>b__14_0(int doc, MutableValueInt64 mutableValue);
}
public abstract class Lucene.Net.Queries.Function.DocValues.SingleDocValues : FunctionValues {
    protected ValueSource m_vs;
    protected SingleDocValues(ValueSource vs);
    public virtual byte ByteVal(int doc);
    public virtual short Int16Val(int doc);
    public abstract virtual float SingleVal(int doc);
    public virtual int Int32Val(int doc);
    public virtual long Int64Val(int doc);
    public virtual double DoubleVal(int doc);
    public virtual string StrVal(int doc);
    public virtual object ObjectVal(int doc);
    public virtual string ToString(int doc);
    public virtual ValueFiller GetValueFiller();
    [CompilerGeneratedAttribute]
private void <GetValueFiller>b__11_0(int doc, MutableValueSingle mutableValue);
}
public abstract class Lucene.Net.Queries.Function.DocValues.StrDocValues : FunctionValues {
    protected ValueSource m_vs;
    protected StrDocValues(ValueSource vs);
    public abstract virtual string StrVal(int doc);
    public virtual object ObjectVal(int doc);
    public virtual bool BoolVal(int doc);
    public virtual string ToString(int doc);
    public virtual ValueFiller GetValueFiller();
    [CompilerGeneratedAttribute]
private void <GetValueFiller>b__6_0(int doc, MutableValueStr mutableValue);
}
public class Lucene.Net.Queries.Function.FunctionQuery : Query {
    private ValueSource func;
    public ValueSource ValueSource { get; }
    public FunctionQuery(ValueSource func);
    public virtual ValueSource get_ValueSource();
    public virtual Query Rewrite(IndexReader reader);
    public virtual void ExtractTerms(ISet`1<Term> terms);
    public virtual Weight CreateWeight(IndexSearcher searcher);
    public virtual string ToString(string field);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public abstract class Lucene.Net.Queries.Function.FunctionValues : object {
    public int NumOrd { get; }
    public virtual byte ByteVal(int doc);
    public virtual short Int16Val(int doc);
    public virtual float SingleVal(int doc);
    public virtual int Int32Val(int doc);
    public virtual long Int64Val(int doc);
    public virtual double DoubleVal(int doc);
    public virtual string StrVal(int doc);
    public virtual bool BoolVal(int doc);
    public virtual bool BytesVal(int doc, BytesRef target);
    public virtual object ObjectVal(int doc);
    public virtual bool Exists(int doc);
    public virtual int OrdVal(int doc);
    public virtual int get_NumOrd();
    public abstract virtual string ToString(int doc);
    public virtual ValueFiller GetValueFiller();
    public virtual void ByteVal(int doc, Byte[] vals);
    public virtual void Int16Val(int doc, Int16[] vals);
    public virtual void SingleVal(int doc, Single[] vals);
    public virtual void Int32Val(int doc, Int32[] vals);
    public virtual void Int64Val(int doc, Int64[] vals);
    public virtual void DoubleVal(int doc, Double[] vals);
    public virtual void StrVal(int doc, String[] vals);
    public virtual Explanation Explain(int doc);
    public virtual ValueSourceScorer GetScorer(IndexReader reader);
    public virtual ValueSourceScorer GetRangeScorer(IndexReader reader, string lowerVal, string upperVal, bool includeLower, bool includeUpper);
    [CompilerGeneratedAttribute]
private void <GetValueFiller>b__16_0(int doc, MutableValueSingle mutableValue);
}
public abstract class Lucene.Net.Queries.Function.ValueSource : object {
    public abstract virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public abstract virtual bool Equals(object o);
    public abstract virtual int GetHashCode();
    public abstract virtual string GetDescription();
    public virtual string ToString();
    public virtual void CreateWeight(IDictionary context, IndexSearcher searcher);
    public static IDictionary NewContext(IndexSearcher searcher);
    public virtual SortField GetSortField(bool reverse);
}
public abstract class Lucene.Net.Queries.Function.ValueSources.BoolFunction : ValueSource {
}
[ObsoleteAttribute]
public class Lucene.Net.Queries.Function.ValueSources.ByteFieldSource : FieldCacheSource {
    private IByteParser parser;
    public ByteFieldSource(string field);
    public ByteFieldSource(string field, IByteParser parser);
    public virtual string GetDescription();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Queries.Function.ValueSources.BytesRefFieldSource : FieldCacheSource {
    public BytesRefFieldSource(string field);
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
}
internal class Lucene.Net.Queries.Function.ValueSources.ConstDoubleDocValues : DoubleDocValues {
    internal int ival;
    internal float fval;
    internal double dval;
    internal long lval;
    internal string sval;
    internal ValueSource parent;
    internal ConstDoubleDocValues(double val, ValueSource parent);
    public virtual float SingleVal(int doc);
    public virtual int Int32Val(int doc);
    public virtual long Int64Val(int doc);
    public virtual double DoubleVal(int doc);
    public virtual string StrVal(int doc);
    public virtual string ToString(int doc);
}
internal class Lucene.Net.Queries.Function.ValueSources.ConstInt32DocValues : Int32DocValues {
    internal int ival;
    internal float fval;
    internal double dval;
    internal long lval;
    internal string sval;
    internal ValueSource parent;
    internal ConstInt32DocValues(int val, ValueSource parent);
    public virtual float SingleVal(int doc);
    public virtual int Int32Val(int doc);
    public virtual long Int64Val(int doc);
    public virtual double DoubleVal(int doc);
    public virtual string StrVal(int doc);
    public virtual string ToString(int doc);
}
public abstract class Lucene.Net.Queries.Function.ValueSources.ConstNumberSource : ValueSource {
    public int Int32 { get; }
    public long Int64 { get; }
    public float Single { get; }
    public double Double { get; }
    public bool Bool { get; }
    public abstract virtual int get_Int32();
    public abstract virtual long get_Int64();
    public abstract virtual float get_Single();
    public abstract virtual double get_Double();
    public abstract virtual bool get_Bool();
}
public class Lucene.Net.Queries.Function.ValueSources.ConstValueSource : ConstNumberSource {
    private float constant;
    private double dv;
    public int Int32 { get; }
    public long Int64 { get; }
    public float Single { get; }
    public double Double { get; }
    public bool Bool { get; }
    public ConstValueSource(float constant);
    public virtual string GetDescription();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual int get_Int32();
    public virtual long get_Int64();
    public virtual float get_Single();
    public virtual double get_Double();
    public virtual bool get_Bool();
}
public class Lucene.Net.Queries.Function.ValueSources.DefFunction : MultiFunction {
    protected string Name { get; }
    public DefFunction(IList`1<ValueSource> sources);
    protected virtual string get_Name();
    public virtual FunctionValues GetValues(IDictionary fcontext, AtomicReaderContext readerContext);
}
public class Lucene.Net.Queries.Function.ValueSources.DivSingleFunction : DualSingleFunction {
    protected string Name { get; }
    public DivSingleFunction(ValueSource a, ValueSource b);
    protected virtual string get_Name();
    protected virtual float Func(int doc, FunctionValues aVals, FunctionValues bVals);
}
public class Lucene.Net.Queries.Function.ValueSources.DocFreqValueSource : ValueSource {
    protected string m_field;
    protected string m_indexedField;
    protected string m_val;
    protected BytesRef m_indexedBytes;
    public string Name { get; }
    public DocFreqValueSource(string field, string val, string indexedField, BytesRef indexedBytes);
    public virtual string get_Name();
    public virtual string GetDescription();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual void CreateWeight(IDictionary context, IndexSearcher searcher);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
public class Lucene.Net.Queries.Function.ValueSources.DoubleConstValueSource : ConstNumberSource {
    private double constant;
    private float fv;
    private long lv;
    public int Int32 { get; }
    public long Int64 { get; }
    public float Single { get; }
    public double Double { get; }
    public bool Bool { get; }
    public DoubleConstValueSource(double constant);
    public virtual string GetDescription();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual int get_Int32();
    public virtual long get_Int64();
    public virtual float get_Single();
    public virtual double get_Double();
    public virtual bool get_Bool();
}
public class Lucene.Net.Queries.Function.ValueSources.DoubleFieldSource : FieldCacheSource {
    protected IDoubleParser m_parser;
    public DoubleFieldSource(string field);
    public DoubleFieldSource(string field, IDoubleParser parser);
    public virtual string GetDescription();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public abstract class Lucene.Net.Queries.Function.ValueSources.DualSingleFunction : ValueSource {
    protected ValueSource m_a;
    protected ValueSource m_b;
    protected string Name { get; }
    protected DualSingleFunction(ValueSource a, ValueSource b);
    protected abstract virtual string get_Name();
    protected abstract virtual float Func(int doc, FunctionValues aVals, FunctionValues bVals);
    public virtual string GetDescription();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual void CreateWeight(IDictionary context, IndexSearcher searcher);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
public class Lucene.Net.Queries.Function.ValueSources.EnumFieldSource : FieldCacheSource {
    private static int DEFAULT_VALUE;
    private IInt32Parser parser;
    private IDictionary`2<int, string> enumIntToStringMap;
    private IDictionary`2<string, int> enumStringToIntMap;
    public EnumFieldSource(string field, IInt32Parser parser, IDictionary`2<int, string> enumIntToStringMap, IDictionary`2<string, int> enumStringToIntMap);
    private string Int32ValueToStringValue(int intVal);
    private Nullable`1<int> StringValueToInt32Value(string stringVal);
    public virtual string GetDescription();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public abstract class Lucene.Net.Queries.Function.ValueSources.FieldCacheSource : ValueSource {
    protected string m_field;
    protected IFieldCache m_cache;
    public IFieldCache FieldCache { get; }
    public string Field { get; }
    protected FieldCacheSource(string field);
    public virtual IFieldCache get_FieldCache();
    public virtual string get_Field();
    public virtual string GetDescription();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[ExceptionToClassNameConventionAttribute]
public class Lucene.Net.Queries.Function.ValueSources.IDFValueSource : DocFreqValueSource {
    public string Name { get; }
    public IDFValueSource(string field, string val, string indexedField, BytesRef indexedBytes);
    public virtual string get_Name();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    internal static TFIDFSimilarity AsTFIDF(Similarity sim, string field);
}
public class Lucene.Net.Queries.Function.ValueSources.IfFunction : BoolFunction {
    private ValueSource ifSource;
    private ValueSource trueSource;
    private ValueSource falseSource;
    public IfFunction(ValueSource ifSource, ValueSource trueSource, ValueSource falseSource);
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual string GetDescription();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual void CreateWeight(IDictionary context, IndexSearcher searcher);
}
[ObsoleteAttribute]
public class Lucene.Net.Queries.Function.ValueSources.Int16FieldSource : FieldCacheSource {
    private IInt16Parser parser;
    public Int16FieldSource(string field);
    public Int16FieldSource(string field, IInt16Parser parser);
    public virtual string GetDescription();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Queries.Function.ValueSources.Int32FieldSource : FieldCacheSource {
    private IInt32Parser parser;
    public Int32FieldSource(string field);
    public Int32FieldSource(string field, IInt32Parser parser);
    public virtual string GetDescription();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Queries.Function.ValueSources.Int64FieldSource : FieldCacheSource {
    protected IInt64Parser m_parser;
    public Int64FieldSource(string field);
    public Int64FieldSource(string field, IInt64Parser parser);
    public virtual string GetDescription();
    public virtual long ExternalToInt64(string extVal);
    public virtual object Int64ToObject(long val);
    public virtual string Int64ToString(long val);
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    protected virtual MutableValueInt64 NewMutableValueInt64();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Queries.Function.ValueSources.JoinDocFreqValueSource : FieldCacheSource {
    public static string NAME;
    protected string m_qfield;
    public JoinDocFreqValueSource(string field, string qfield);
    public virtual string GetDescription();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Queries.Function.ValueSources.LinearSingleFunction : ValueSource {
    protected ValueSource m_source;
    protected float m_slope;
    protected float m_intercept;
    public LinearSingleFunction(ValueSource source, float slope, float intercept);
    public virtual string GetDescription();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual void CreateWeight(IDictionary context, IndexSearcher searcher);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
public class Lucene.Net.Queries.Function.ValueSources.LiteralValueSource : ValueSource {
    protected string m_str;
    protected BytesRef m_bytesRef;
    public static int hash;
    public string Value { get; }
    public LiteralValueSource(string str);
    private static LiteralValueSource();
    public virtual string get_Value();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual string GetDescription();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Queries.Function.ValueSources.MaxDocValueSource : ValueSource {
    public string Name { get; }
    public virtual string get_Name();
    public virtual string GetDescription();
    public virtual void CreateWeight(IDictionary context, IndexSearcher searcher);
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Queries.Function.ValueSources.MaxSingleFunction : MultiSingleFunction {
    protected string Name { get; }
    public MaxSingleFunction(ValueSource[] sources);
    protected virtual string get_Name();
    protected virtual float Func(int doc, FunctionValues[] valsArr);
}
public class Lucene.Net.Queries.Function.ValueSources.MinSingleFunction : MultiSingleFunction {
    protected string Name { get; }
    public MinSingleFunction(ValueSource[] sources);
    protected virtual string get_Name();
    protected virtual float Func(int doc, FunctionValues[] valsArr);
}
public abstract class Lucene.Net.Queries.Function.ValueSources.MultiBoolFunction : BoolFunction {
    protected IList`1<ValueSource> m_sources;
    protected string Name { get; }
    protected MultiBoolFunction(IList`1<ValueSource> sources);
    protected abstract virtual string get_Name();
    protected abstract virtual bool Func(int doc, FunctionValues[] vals);
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual string GetDescription();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual void CreateWeight(IDictionary context, IndexSearcher searcher);
}
public abstract class Lucene.Net.Queries.Function.ValueSources.MultiFunction : ValueSource {
    protected IList`1<ValueSource> m_sources;
    protected string Name { get; }
    protected MultiFunction(IList`1<ValueSource> sources);
    protected abstract virtual string get_Name();
    public virtual string GetDescription();
    public static string GetDescription(string name, IList`1<ValueSource> sources);
    public static FunctionValues[] ValsArr(IList`1<ValueSource> sources, IDictionary fcontext, AtomicReaderContext readerContext);
    public static string ToString(string name, FunctionValues[] valsArr, int doc);
    public virtual void CreateWeight(IDictionary context, IndexSearcher searcher);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
public abstract class Lucene.Net.Queries.Function.ValueSources.MultiSingleFunction : ValueSource {
    protected ValueSource[] m_sources;
    protected string Name { get; }
    protected MultiSingleFunction(ValueSource[] sources);
    protected abstract virtual string get_Name();
    protected abstract virtual float Func(int doc, FunctionValues[] valsArr);
    public virtual string GetDescription();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual void CreateWeight(IDictionary context, IndexSearcher searcher);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
public abstract class Lucene.Net.Queries.Function.ValueSources.MultiValueSource : ValueSource {
    public int Dimension { get; }
    public abstract virtual int get_Dimension();
}
public class Lucene.Net.Queries.Function.ValueSources.NormValueSource : ValueSource {
    protected string m_field;
    public string Name { get; }
    public NormValueSource(string field);
    public virtual string get_Name();
    public virtual string GetDescription();
    public virtual void CreateWeight(IDictionary context, IndexSearcher searcher);
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Queries.Function.ValueSources.NumDocsValueSource : ValueSource {
    public string Name { get; }
    public virtual string get_Name();
    public virtual string GetDescription();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Queries.Function.ValueSources.OrdFieldSource : ValueSource {
    protected string m_field;
    private static int hcode;
    public OrdFieldSource(string field);
    private static OrdFieldSource();
    public virtual string GetDescription();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Queries.Function.ValueSources.PowSingleFunction : DualSingleFunction {
    protected string Name { get; }
    public PowSingleFunction(ValueSource a, ValueSource b);
    protected virtual string get_Name();
    protected virtual float Func(int doc, FunctionValues aVals, FunctionValues bVals);
}
public class Lucene.Net.Queries.Function.ValueSources.ProductSingleFunction : MultiSingleFunction {
    protected string Name { get; }
    public ProductSingleFunction(ValueSource[] sources);
    protected virtual string get_Name();
    protected virtual float Func(int doc, FunctionValues[] valsArr);
}
internal class Lucene.Net.Queries.Function.ValueSources.QueryDocValues : SingleDocValues {
    internal AtomicReaderContext readerContext;
    internal IBits acceptDocs;
    internal Weight weight;
    internal float defVal;
    internal IDictionary fcontext;
    internal Query q;
    internal Scorer scorer;
    internal int scorerDoc;
    internal bool noMatches;
    internal int lastDocRequested;
    public QueryDocValues(QueryValueSource vs, AtomicReaderContext readerContext, IDictionary fcontext);
    public virtual float SingleVal(int doc);
    public virtual bool Exists(int doc);
    public virtual object ObjectVal(int doc);
    public virtual ValueFiller GetValueFiller();
    public virtual string ToString(int doc);
    [CompilerGeneratedAttribute]
private void <GetValueFiller>b__14_0(int doc, MutableValueSingle mutableValue);
}
public class Lucene.Net.Queries.Function.ValueSources.QueryValueSource : ValueSource {
    internal Query q;
    internal float defVal;
    public Query Query { get; }
    public float DefaultValue { get; }
    public QueryValueSource(Query q, float defVal);
    public virtual Query get_Query();
    public virtual float get_DefaultValue();
    public virtual string GetDescription();
    public virtual FunctionValues GetValues(IDictionary fcontext, AtomicReaderContext readerContext);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual void CreateWeight(IDictionary context, IndexSearcher searcher);
}
public class Lucene.Net.Queries.Function.ValueSources.RangeMapSingleFunction : ValueSource {
    protected ValueSource m_source;
    protected float m_min;
    protected float m_max;
    protected ValueSource m_target;
    protected ValueSource m_defaultVal;
    public RangeMapSingleFunction(ValueSource source, float min, float max, float target, Nullable`1<float> def);
    public RangeMapSingleFunction(ValueSource source, float min, float max, ValueSource target, ValueSource def);
    public virtual string GetDescription();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual void CreateWeight(IDictionary context, IndexSearcher searcher);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
public class Lucene.Net.Queries.Function.ValueSources.ReciprocalSingleFunction : ValueSource {
    protected ValueSource m_source;
    protected float m_m;
    protected float m_a;
    protected float m_b;
    public ReciprocalSingleFunction(ValueSource source, float m, float a, float b);
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual void CreateWeight(IDictionary context, IndexSearcher searcher);
    public virtual string GetDescription();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
public class Lucene.Net.Queries.Function.ValueSources.ReverseOrdFieldSource : ValueSource {
    private string field;
    private static int hcode;
    public string Field { get; }
    public ReverseOrdFieldSource(string field);
    private static ReverseOrdFieldSource();
    public string get_Field();
    public virtual string GetDescription();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Queries.Function.ValueSources.ScaleSingleFunction : ValueSource {
    protected ValueSource m_source;
    protected float m_min;
    protected float m_max;
    public ScaleSingleFunction(ValueSource source, float min, float max);
    public virtual string GetDescription();
    private ScaleInfo CreateScaleInfo(IDictionary context, AtomicReaderContext readerContext);
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual void CreateWeight(IDictionary context, IndexSearcher searcher);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
public abstract class Lucene.Net.Queries.Function.ValueSources.SimpleBoolFunction : BoolFunction {
    protected ValueSource m_source;
    protected string Name { get; }
    protected SimpleBoolFunction(ValueSource source);
    protected abstract virtual string get_Name();
    protected abstract virtual bool Func(int doc, FunctionValues vals);
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual string GetDescription();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual void CreateWeight(IDictionary context, IndexSearcher searcher);
}
public abstract class Lucene.Net.Queries.Function.ValueSources.SimpleSingleFunction : SingularFunction {
    protected SimpleSingleFunction(ValueSource source);
    protected abstract virtual float Func(int doc, FunctionValues vals);
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
}
public class Lucene.Net.Queries.Function.ValueSources.SingleFieldSource : FieldCacheSource {
    protected ISingleParser m_parser;
    public SingleFieldSource(string field);
    public SingleFieldSource(string field, ISingleParser parser);
    public virtual string GetDescription();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public abstract class Lucene.Net.Queries.Function.ValueSources.SingularFunction : ValueSource {
    protected ValueSource m_source;
    protected string Name { get; }
    protected SingularFunction(ValueSource source);
    protected abstract virtual string get_Name();
    public virtual string GetDescription();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual void CreateWeight(IDictionary context, IndexSearcher searcher);
}
public class Lucene.Net.Queries.Function.ValueSources.SumSingleFunction : MultiSingleFunction {
    protected string Name { get; }
    public SumSingleFunction(ValueSource[] sources);
    protected virtual string get_Name();
    protected virtual float Func(int doc, FunctionValues[] valsArr);
}
public class Lucene.Net.Queries.Function.ValueSources.SumTotalTermFreqValueSource : ValueSource {
    protected string m_indexedField;
    public string Name { get; }
    public SumTotalTermFreqValueSource(string indexedField);
    public virtual string get_Name();
    public virtual string GetDescription();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual void CreateWeight(IDictionary context, IndexSearcher searcher);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
public class Lucene.Net.Queries.Function.ValueSources.TermFreqValueSource : DocFreqValueSource {
    public string Name { get; }
    public TermFreqValueSource(string field, string val, string indexedField, BytesRef indexedBytes);
    public virtual string get_Name();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
}
public class Lucene.Net.Queries.Function.ValueSources.TFValueSource : TermFreqValueSource {
    public string Name { get; }
    public TFValueSource(string field, string val, string indexedField, BytesRef indexedBytes);
    public virtual string get_Name();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
}
public class Lucene.Net.Queries.Function.ValueSources.TotalTermFreqValueSource : ValueSource {
    protected string m_field;
    protected string m_indexedField;
    protected string m_val;
    protected BytesRef m_indexedBytes;
    public string Name { get; }
    public TotalTermFreqValueSource(string field, string val, string indexedField, BytesRef indexedBytes);
    public virtual string get_Name();
    public virtual string GetDescription();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual void CreateWeight(IDictionary context, IndexSearcher searcher);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
public class Lucene.Net.Queries.Function.ValueSources.VectorValueSource : MultiValueSource {
    protected IList`1<ValueSource> m_sources;
    public IList`1<ValueSource> Sources { get; }
    public int Dimension { get; }
    public string Name { get; }
    public VectorValueSource(IList`1<ValueSource> sources);
    public virtual IList`1<ValueSource> get_Sources();
    public virtual int get_Dimension();
    public virtual string get_Name();
    public virtual FunctionValues GetValues(IDictionary context, AtomicReaderContext readerContext);
    public virtual void CreateWeight(IDictionary context, IndexSearcher searcher);
    public virtual string GetDescription();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class Lucene.Net.Queries.Function.ValueSourceScorer : Scorer {
    protected IndexReader m_reader;
    private int doc;
    protected int m_maxDoc;
    protected FunctionValues m_values;
    protected bool m_checkDeletes;
    private IBits liveDocs;
    public IndexReader Reader { get; }
    public int DocID { get; }
    public int Freq { get; }
    protected internal ValueSourceScorer(IndexReader reader, FunctionValues values);
    public virtual IndexReader get_Reader();
    public virtual void SetCheckDeletes(bool checkDeletes);
    public virtual bool Matches(int doc);
    public virtual bool MatchesValue(int doc);
    public virtual int get_DocID();
    public virtual int NextDoc();
    public virtual int Advance(int target);
    public virtual float GetScore();
    public virtual int get_Freq();
    public virtual long GetCost();
}
public class Lucene.Net.Queries.Mlt.MoreLikeThis : object {
    public static int DEFAULT_MAX_NUM_TOKENS_PARSED;
    public static int DEFAULT_MIN_TERM_FREQ;
    public static int DEFAULT_MIN_DOC_FREQ;
    public static int DEFAULT_MAX_DOC_FREQ;
    public static bool DEFAULT_BOOST;
    public static String[] DEFAULT_FIELD_NAMES;
    public static int DEFAULT_MIN_WORD_LENGTH;
    public static int DEFAULT_MAX_WORD_LENGTH;
    public static ISet`1<string> DEFAULT_STOP_WORDS;
    public static int DEFAULT_MAX_QUERY_TERMS;
    private IndexReader ir;
    private float boostFactor;
    [CompilerGeneratedAttribute]
private TFIDFSimilarity <Similarity>k__BackingField;
    [CompilerGeneratedAttribute]
private Analyzer <Analyzer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinTermFreq>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinDocFreq>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDocFreq>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyBoost>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <FieldNames>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinWordLen>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxWordLen>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <StopWords>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxQueryTerms>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumTokensParsed>k__BackingField;
    public float BoostFactor { get; public set; }
    public TFIDFSimilarity Similarity { get; public set; }
    public Analyzer Analyzer { get; public set; }
    public int MinTermFreq { get; public set; }
    public int MinDocFreq { get; public set; }
    public int MaxDocFreq { get; public set; }
    public bool ApplyBoost { get; public set; }
    [WritableArrayAttribute]
public String[] FieldNames { get; public set; }
    public int MinWordLen { get; public set; }
    public int MaxWordLen { get; public set; }
    public ISet`1<string> StopWords { get; public set; }
    public int MaxQueryTerms { get; public set; }
    public int MaxNumTokensParsed { get; public set; }
    public MoreLikeThis(IndexReader ir);
    public MoreLikeThis(IndexReader ir, TFIDFSimilarity sim);
    private static MoreLikeThis();
    public float get_BoostFactor();
    public void set_BoostFactor(float value);
    [CompilerGeneratedAttribute]
public TFIDFSimilarity get_Similarity();
    [CompilerGeneratedAttribute]
public void set_Similarity(TFIDFSimilarity value);
    [CompilerGeneratedAttribute]
public Analyzer get_Analyzer();
    [CompilerGeneratedAttribute]
public void set_Analyzer(Analyzer value);
    [CompilerGeneratedAttribute]
public int get_MinTermFreq();
    [CompilerGeneratedAttribute]
public void set_MinTermFreq(int value);
    [CompilerGeneratedAttribute]
public int get_MinDocFreq();
    [CompilerGeneratedAttribute]
public void set_MinDocFreq(int value);
    [CompilerGeneratedAttribute]
public int get_MaxDocFreq();
    [CompilerGeneratedAttribute]
public void set_MaxDocFreq(int value);
    public void SetMaxDocFreqPct(int maxPercentage);
    [CompilerGeneratedAttribute]
public bool get_ApplyBoost();
    [CompilerGeneratedAttribute]
public void set_ApplyBoost(bool value);
    [CompilerGeneratedAttribute]
public String[] get_FieldNames();
    [CompilerGeneratedAttribute]
public void set_FieldNames(String[] value);
    [CompilerGeneratedAttribute]
public int get_MinWordLen();
    [CompilerGeneratedAttribute]
public void set_MinWordLen(int value);
    [CompilerGeneratedAttribute]
public int get_MaxWordLen();
    [CompilerGeneratedAttribute]
public void set_MaxWordLen(int value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_StopWords();
    [CompilerGeneratedAttribute]
public void set_StopWords(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public int get_MaxQueryTerms();
    [CompilerGeneratedAttribute]
public void set_MaxQueryTerms(int value);
    [CompilerGeneratedAttribute]
public int get_MaxNumTokensParsed();
    [CompilerGeneratedAttribute]
public void set_MaxNumTokensParsed(int value);
    public Query Like(int docNum);
    public Query Like(TextReader r, string fieldName);
    private Query CreateQuery(PriorityQueue`1<ScoreTerm> q);
    private PriorityQueue`1<ScoreTerm> CreateQueue(IDictionary`2<string, Int32> words);
    public string DescribeParams();
    public PriorityQueue`1<ScoreTerm> RetrieveTerms(int docNum);
    private void AddTermFrequencies(IDictionary`2<string, Int32> termFreqMap, Terms vector);
    private void AddTermFrequencies(TextReader r, IDictionary`2<string, Int32> termFreqMap, string fieldName);
    private bool IsNoiseWord(string term);
    public PriorityQueue`1<ScoreTerm> RetrieveTerms(TextReader r, string fieldName);
    public String[] RetrieveInterestingTerms(int docNum);
    public String[] RetrieveInterestingTerms(TextReader r, string fieldName);
}
public class Lucene.Net.Queries.Mlt.MoreLikeThisQuery : Query {
    private string likeText;
    private String[] moreLikeFields;
    private Analyzer analyzer;
    private string fieldName;
    private float percentTermsToMatch;
    private int minTermFrequency;
    private int maxQueryTerms;
    private ISet`1<string> stopWords;
    private int minDocFreq;
    public float PercentTermsToMatch { get; public set; }
    public Analyzer Analyzer { get; public set; }
    public string LikeText { get; public set; }
    public int MaxQueryTerms { get; public set; }
    public int MinTermFrequency { get; public set; }
    [WritableArrayAttribute]
public String[] MoreLikeFields { get; public set; }
    public ISet`1<string> StopWords { get; public set; }
    public int MinDocFreq { get; public set; }
    public MoreLikeThisQuery(string likeText, String[] moreLikeFields, Analyzer analyzer, string fieldName);
    public virtual Query Rewrite(IndexReader reader);
    public virtual string ToString(string field);
    public virtual float get_PercentTermsToMatch();
    public virtual void set_PercentTermsToMatch(float value);
    public virtual Analyzer get_Analyzer();
    public virtual void set_Analyzer(Analyzer value);
    public virtual string get_LikeText();
    public virtual void set_LikeText(string value);
    public virtual int get_MaxQueryTerms();
    public virtual void set_MaxQueryTerms(int value);
    public virtual int get_MinTermFrequency();
    public virtual void set_MinTermFrequency(int value);
    public virtual String[] get_MoreLikeFields();
    public virtual void set_MoreLikeFields(String[] value);
    public virtual ISet`1<string> get_StopWords();
    public virtual void set_StopWords(ISet`1<string> value);
    public virtual int get_MinDocFreq();
    public virtual void set_MinDocFreq(int value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Lucene.Net.Queries.Mlt.ScoreTerm : object {
    [CompilerGeneratedAttribute]
private string <Word>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TopField>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Score>k__BackingField;
    [CompilerGeneratedAttribute]
private float <Idf>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DocFreq>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Tf>k__BackingField;
    public string Word { get; private set; }
    public string TopField { get; private set; }
    public float Score { get; private set; }
    public float Idf { get; private set; }
    public int DocFreq { get; private set; }
    public int Tf { get; private set; }
    internal ScoreTerm(string word, string topField, float score, float idf, int docFreq, int tf);
    [CompilerGeneratedAttribute]
public string get_Word();
    [CompilerGeneratedAttribute]
private void set_Word(string value);
    [CompilerGeneratedAttribute]
public string get_TopField();
    [CompilerGeneratedAttribute]
private void set_TopField(string value);
    [CompilerGeneratedAttribute]
public float get_Score();
    [CompilerGeneratedAttribute]
private void set_Score(float value);
    [CompilerGeneratedAttribute]
public float get_Idf();
    [CompilerGeneratedAttribute]
private void set_Idf(float value);
    [CompilerGeneratedAttribute]
public int get_DocFreq();
    [CompilerGeneratedAttribute]
private void set_DocFreq(int value);
    [CompilerGeneratedAttribute]
public int get_Tf();
    [CompilerGeneratedAttribute]
private void set_Tf(int value);
}
public class Lucene.Net.Queries.TermFilter : Filter {
    private Term term;
    public Term Term { get; }
    public TermFilter(Term term);
    public Term get_Term();
    public virtual DocIdSet GetDocIdSet(AtomicReaderContext context, IBits acceptDocs);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Lucene.Net.Queries.TermsFilter : Filter {
    private Int32[] offsets;
    private Byte[] termsBytes;
    private TermsAndField[] termsAndFields;
    private int hashCode;
    private static int PRIME;
    public TermsFilter(IList`1<Term> terms);
    public TermsFilter(string field, IList`1<BytesRef> terms);
    public TermsFilter(string field, BytesRef[] terms);
    public TermsFilter(Term[] terms);
    private TermsFilter(FieldAndTermEnum iter, int length);
    public virtual DocIdSet GetDocIdSet(AtomicReaderContext context, IBits acceptDocs);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
