public class Lucene.Net.QueryParsers.Analyzing.AnalyzingQueryParser : QueryParser {
    private Regex wildcardPattern;
    public AnalyzingQueryParser(LuceneVersion matchVersion, string field, Analyzer analyzer);
    protected internal virtual Query GetWildcardQuery(string field, string termStr);
    protected internal virtual Query GetPrefixQuery(string field, string termStr);
    protected internal virtual Query GetFuzzyQuery(string field, string termStr, float minSimilarity);
    protected internal virtual string AnalyzeSingleChunk(string field, string termStr, string chunk);
}
public class Lucene.Net.QueryParsers.Classic.FastCharStream : object {
    internal Char[] buffer;
    internal int bufferLength;
    internal int bufferPosition;
    internal int tokenStart;
    internal int bufferStart;
    internal TextReader input;
    public string Image { get; }
    public int Column { get; }
    public int Line { get; }
    public int EndColumn { get; }
    public int EndLine { get; }
    public int BeginColumn { get; }
    public int BeginLine { get; }
    public FastCharStream(TextReader r);
    public sealed virtual char ReadChar();
    private void Refill();
    public sealed virtual char BeginToken();
    public sealed virtual void BackUp(int amount);
    public sealed virtual string get_Image();
    public sealed virtual Char[] GetSuffix(int len);
    public sealed virtual void Done();
    public sealed virtual int get_Column();
    public sealed virtual int get_Line();
    public sealed virtual int get_EndColumn();
    public sealed virtual int get_EndLine();
    public sealed virtual int get_BeginColumn();
    public sealed virtual int get_BeginLine();
}
public interface Lucene.Net.QueryParsers.Classic.ICharStream {
    [ObsoleteAttribute]
public int Column { get; }
    [ObsoleteAttribute]
public int Line { get; }
    public int EndColumn { get; }
    public int EndLine { get; }
    public int BeginColumn { get; }
    public int BeginLine { get; }
    public string Image { get; }
    public abstract virtual char ReadChar();
    public abstract virtual int get_Column();
    public abstract virtual int get_Line();
    public abstract virtual int get_EndColumn();
    public abstract virtual int get_EndLine();
    public abstract virtual int get_BeginColumn();
    public abstract virtual int get_BeginLine();
    public abstract virtual void BackUp(int amount);
    public abstract virtual char BeginToken();
    public abstract virtual string get_Image();
    public abstract virtual Char[] GetSuffix(int len);
    public abstract virtual void Done();
}
public static class Lucene.Net.QueryParsers.Classic.LexicalToken : object {
    public static int Boost;
    public static int Range;
    public static int DEFAULT;
}
public class Lucene.Net.QueryParsers.Classic.MultiFieldQueryParser : QueryParser {
    protected String[] m_fields;
    protected IDictionary`2<string, float> m_boosts;
    public MultiFieldQueryParser(LuceneVersion matchVersion, String[] fields, Analyzer analyzer, IDictionary`2<string, float> boosts);
    public MultiFieldQueryParser(LuceneVersion matchVersion, String[] fields, Analyzer analyzer);
    protected internal virtual Query GetFieldQuery(string field, string queryText, int slop);
    private void ApplySlop(Query q, int slop);
    protected internal virtual Query GetFieldQuery(string field, string queryText, bool quoted);
    protected internal virtual Query GetFuzzyQuery(string field, string termStr, float minSimilarity);
    protected internal virtual Query GetPrefixQuery(string field, string termStr);
    protected internal virtual Query GetWildcardQuery(string field, string termStr);
    protected internal virtual Query GetRangeQuery(string field, string part1, string part2, bool startInclusive, bool endInclusive);
    protected internal virtual Query GetRegexpQuery(string field, string termStr);
    public static Query Parse(LuceneVersion matchVersion, String[] queries, String[] fields, Analyzer analyzer);
    public static Query Parse(LuceneVersion matchVersion, string query, String[] fields, Occur[] flags, Analyzer analyzer);
    public static Query Parse(LuceneVersion matchVersion, String[] queries, String[] fields, Occur[] flags, Analyzer analyzer);
}
public enum Lucene.Net.QueryParsers.Classic.Operator : Enum {
    public int value__;
    public static Operator OR;
    public static Operator AND;
}
public class Lucene.Net.QueryParsers.Classic.ParseException : Exception {
    [CompilerGeneratedAttribute]
private Token <CurrentToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[][] <ExpectedTokenSequences>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TokenImage>k__BackingField;
    protected static string eol;
    public Token CurrentToken { get; public set; }
    [WritableArrayAttribute]
public Int32[][] ExpectedTokenSequences { get; public set; }
    [WritableArrayAttribute]
public String[] TokenImage { get; public set; }
    public ParseException(Token currentToken, Int32[][] expectedTokenSequences, String[] tokenImage);
    public ParseException(string message);
    public ParseException(string message, Exception innerException);
    protected ParseException(SerializationInfo info, StreamingContext context);
    private static ParseException();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Token get_CurrentToken();
    [CompilerGeneratedAttribute]
public void set_CurrentToken(Token value);
    [CompilerGeneratedAttribute]
public Int32[][] get_ExpectedTokenSequences();
    [CompilerGeneratedAttribute]
public void set_ExpectedTokenSequences(Int32[][] value);
    [CompilerGeneratedAttribute]
public String[] get_TokenImage();
    [CompilerGeneratedAttribute]
public void set_TokenImage(String[] value);
    private static string Initialize(Token currentToken, Int32[][] expectedTokenSequences, String[] tokenImage);
    internal static string AddEscapes(string str);
}
public class Lucene.Net.QueryParsers.Classic.QueryParser : QueryParserBase {
    [CompilerGeneratedAttribute]
private QueryParserTokenManager <TokenSource>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <Jj_nt>k__BackingField;
    private int jj_ntk;
    private Token jj_scanpos;
    private Token jj_lastpos;
    private int jj_la;
    private int jj_gen;
    private Int32[] jj_la1;
    private static UInt32[] jj_la1_0;
    private static Int32[] jj_la1_1;
    private JJCalls[] jj_2_rtns;
    private bool jj_rescan;
    private int jj_gc;
    private LookaheadSuccess jj_ls;
    private IList`1<Int32[]> jj_expentries;
    private Int32[] jj_expentry;
    private int jj_kind;
    private Int32[] jj_lasttokens;
    private int jj_endpos;
    public QueryParserTokenManager TokenSource { get; public set; }
    public Token Token { get; public set; }
    public Token Jj_nt { get; public set; }
    public QueryParser(LuceneVersion matchVersion, string f, Analyzer a);
    protected internal QueryParser(ICharStream stream);
    protected QueryParser(QueryParserTokenManager tm);
    private static QueryParser();
    public int Conjunction();
    public int Modifiers();
    public sealed virtual Query TopLevelQuery(string field);
    public Query Query(string field);
    public Query Clause(string field);
    public Query Term(string field);
    private bool Jj_2_1(int xla);
    private bool Jj_3R_2();
    private bool Jj_3_1();
    private bool Jj_3R_3();
    [CompilerGeneratedAttribute]
public QueryParserTokenManager get_TokenSource();
    [CompilerGeneratedAttribute]
public void set_TokenSource(QueryParserTokenManager value);
    [CompilerGeneratedAttribute]
public Token get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(Token value);
    [CompilerGeneratedAttribute]
public Token get_Jj_nt();
    [CompilerGeneratedAttribute]
public void set_Jj_nt(Token value);
    public virtual void ReInit(ICharStream stream);
    public virtual void ReInit(QueryParserTokenManager tm);
    private Token Jj_consume_token(int kind);
    private bool Jj_scan_token(int kind);
    public Token GetNextToken();
    public Token GetToken(int index);
    private int Jj_ntk();
    private void Jj_add_error_token(int kind, int pos);
    public virtual ParseException GenerateParseException();
    public void Enable_tracing();
    public void Disable_tracing();
    private void Jj_rescan_token();
    private void Jj_save(int index, int xla);
}
public abstract class Lucene.Net.QueryParsers.Classic.QueryParserBase : QueryBuilder {
    protected static int CONJ_NONE;
    protected static int CONJ_AND;
    protected static int CONJ_OR;
    protected static int MOD_NONE;
    protected static int MOD_NOT;
    protected static int MOD_REQ;
    public static Operator AND_OPERATOR;
    public static Operator OR_OPERATOR;
    protected string m_field;
    private CultureInfo locale;
    private TimeZoneInfo timeZone;
    private DateResolution dateResolution;
    private IDictionary`2<string, DateResolution> fieldToDateResolution;
    private bool analyzeRangeTerms;
    [CompilerGeneratedAttribute]
private bool <AutoGeneratePhraseQueries>k__BackingField;
    [CompilerGeneratedAttribute]
private float <FuzzyMinSim>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FuzzyPrefixLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PhraseSlop>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowLeadingWildcard>k__BackingField;
    [CompilerGeneratedAttribute]
private Operator <DefaultOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LowercaseExpandedTerms>k__BackingField;
    [CompilerGeneratedAttribute]
private RewriteMethod <MultiTermRewriteMethod>k__BackingField;
    public string Field { get; }
    public bool AutoGeneratePhraseQueries { get; public set; }
    public float FuzzyMinSim { get; public set; }
    public int FuzzyPrefixLength { get; public set; }
    public int PhraseSlop { get; public set; }
    public bool AllowLeadingWildcard { get; public set; }
    public Operator DefaultOperator { get; public set; }
    public bool LowercaseExpandedTerms { get; public set; }
    public RewriteMethod MultiTermRewriteMethod { get; public set; }
    public CultureInfo Locale { get; public set; }
    public TimeZoneInfo TimeZone { get; public set; }
    public bool AnalyzeRangeTerms { get; public set; }
    public virtual void Init(LuceneVersion matchVersion, string f, Analyzer a);
    public abstract virtual void ReInit(ICharStream stream);
    public abstract virtual Query TopLevelQuery(string field);
    public virtual Query Parse(string query);
    public virtual string get_Field();
    [CompilerGeneratedAttribute]
public bool get_AutoGeneratePhraseQueries();
    [CompilerGeneratedAttribute]
public void set_AutoGeneratePhraseQueries(bool value);
    [CompilerGeneratedAttribute]
public virtual float get_FuzzyMinSim();
    [CompilerGeneratedAttribute]
public virtual void set_FuzzyMinSim(float value);
    [CompilerGeneratedAttribute]
public virtual int get_FuzzyPrefixLength();
    [CompilerGeneratedAttribute]
public virtual void set_FuzzyPrefixLength(int value);
    [CompilerGeneratedAttribute]
public virtual int get_PhraseSlop();
    [CompilerGeneratedAttribute]
public virtual void set_PhraseSlop(int value);
    [CompilerGeneratedAttribute]
public virtual bool get_AllowLeadingWildcard();
    [CompilerGeneratedAttribute]
public virtual void set_AllowLeadingWildcard(bool value);
    [CompilerGeneratedAttribute]
public virtual Operator get_DefaultOperator();
    [CompilerGeneratedAttribute]
public virtual void set_DefaultOperator(Operator value);
    [CompilerGeneratedAttribute]
public virtual bool get_LowercaseExpandedTerms();
    [CompilerGeneratedAttribute]
public virtual void set_LowercaseExpandedTerms(bool value);
    [CompilerGeneratedAttribute]
public virtual RewriteMethod get_MultiTermRewriteMethod();
    [CompilerGeneratedAttribute]
public virtual void set_MultiTermRewriteMethod(RewriteMethod value);
    public virtual CultureInfo get_Locale();
    public virtual void set_Locale(CultureInfo value);
    public virtual TimeZoneInfo get_TimeZone();
    public virtual void set_TimeZone(TimeZoneInfo value);
    public virtual void SetDateResolution(DateResolution dateResolution);
    public virtual void SetDateResolution(string fieldName, DateResolution dateResolution);
    public virtual DateResolution GetDateResolution(string fieldName);
    public virtual bool get_AnalyzeRangeTerms();
    public virtual void set_AnalyzeRangeTerms(bool value);
    protected internal virtual void AddClause(IList`1<BooleanClause> clauses, int conj, int mods, Query q);
    protected internal virtual Query GetFieldQuery(string field, string queryText, bool quoted);
    protected internal virtual Query NewFieldQuery(Analyzer analyzer, string field, string queryText, bool quoted);
    protected internal virtual Query GetFieldQuery(string field, string queryText, int slop);
    protected internal virtual Query GetRangeQuery(string field, string part1, string part2, bool startInclusive, bool endInclusive);
    protected internal virtual BooleanClause NewBooleanClause(Query q, Occur occur);
    protected internal virtual Query NewPrefixQuery(Term prefix);
    protected internal virtual Query NewRegexpQuery(Term regexp);
    protected internal virtual Query NewFuzzyQuery(Term term, float minimumSimilarity, int prefixLength);
    private BytesRef AnalyzeMultitermTerm(string field, string part);
    protected internal virtual BytesRef AnalyzeMultitermTerm(string field, string part, Analyzer analyzerIn);
    protected internal virtual Query NewRangeQuery(string field, string part1, string part2, bool startInclusive, bool endInclusive);
    protected internal virtual Query NewMatchAllDocsQuery();
    protected internal virtual Query NewWildcardQuery(Term t);
    protected internal virtual Query GetBooleanQuery(IList`1<BooleanClause> clauses);
    protected internal virtual Query GetBooleanQuery(IList`1<BooleanClause> clauses, bool disableCoord);
    protected internal virtual Query GetWildcardQuery(string field, string termStr);
    protected internal virtual Query GetRegexpQuery(string field, string termStr);
    protected internal virtual Query GetPrefixQuery(string field, string termStr);
    protected internal virtual Query GetFuzzyQuery(string field, string termStr, float minSimilarity);
    internal virtual Query HandleBareTokenQuery(string qfield, Token term, Token fuzzySlop, bool prefix, bool wildcard, bool fuzzy, bool regexp);
    internal virtual Query HandleBareFuzzy(string qfield, Token fuzzySlop, string termImage);
    internal virtual Query HandleQuotedTerm(string qfield, Token term, Token fuzzySlop);
    internal virtual Query HandleBoost(Query q, Token boost);
    internal virtual string DiscardEscapeChar(string input);
    private static int HexToInt32(char c);
    public static string Escape(string s);
}
public static class Lucene.Net.QueryParsers.Classic.QueryParserConstants : object {
    public static String[] TokenImage;
    private static QueryParserConstants();
}
public class Lucene.Net.QueryParsers.Classic.QueryParserTokenManager : object {
    private TextWriter debugStream;
    internal static UInt64[] jjbitVec0;
    internal static UInt64[] jjbitVec1;
    internal static UInt64[] jjbitVec3;
    internal static UInt64[] jjbitVec4;
    internal static Int32[] jjnextStates;
    public static String[] jjstrLiteralImages;
    public static String[] lexStateNames;
    public static Int32[] jjnewLexState;
    internal static UInt64[] jjtoToken;
    internal static Int64[] jjtoSkip;
    protected ICharStream m_input_stream;
    private UInt32[] jjrounds;
    private Int32[] jjstateSet;
    protected char m_curChar;
    internal int curLexState;
    internal int defaultLexState;
    internal int jjnewStateCnt;
    internal UInt32 jjround;
    internal int jjmatchedPos;
    internal int jjmatchedKind;
    public QueryParserTokenManager(ICharStream stream);
    public QueryParserTokenManager(ICharStream stream, int lexState);
    private static QueryParserTokenManager();
    private void InitBlock();
    public virtual void SetDebugStream(TextWriter ds);
    private int JjStopStringLiteralDfa_2(int pos, long active0);
    private int JjStartNfa_2(int pos, long active0);
    private int JjStopAtPos(int pos, int kind);
    private int JjMoveStringLiteralDfa0_2();
    private int JjStartNfaWithStates_2(int pos, int kind, int state);
    private int JjMoveNfa_2(int startState, int curPos);
    private int JjMoveStringLiteralDfa0_0();
    private int JjMoveNfa_0(int startState, int curPos);
    private int JjStopStringLiteralDfa_1(int pos, long active0);
    private int JjStartNfa_1(int pos, long active0);
    private int JjMoveStringLiteralDfa0_1();
    private int JjMoveStringLiteralDfa1_1(long active0);
    private int JjStartNfaWithStates_1(int pos, int kind, int state);
    private int JjMoveNfa_1(int startState, int curPos);
    private static bool JjCanMove_0(int hiByte, int i1, int i2, ulong l1, ulong l2);
    private static bool JjCanMove_1(int hiByte, int i1, int i2, ulong l1, ulong l2);
    private static bool JjCanMove_2(int hiByte, int i1, int i2, ulong l1, ulong l2);
    public virtual void ReInit(ICharStream stream);
    private void ReInitRounds();
    public virtual void ReInit(ICharStream stream, int lexState);
    public virtual void SwitchTo(int lexState);
    protected internal virtual Token JjFillToken();
    public virtual Token GetNextToken();
    private void JjCheckNAdd(int state);
    private void JjAddStates(int start, int end);
    private void JjCheckNAddTwoStates(int state1, int state2);
    private void JjCheckNAddStates(int start, int end);
}
public static class Lucene.Net.QueryParsers.Classic.RegexpToken : object {
    public static int EOF;
    public static int NUM_CHAR;
    public static int ESCAPED_CHAR;
    public static int TERM_START_CHAR;
    public static int TERM_CHAR;
    public static int WHITESPACE;
    public static int QUOTED_CHAR;
    public static int AND;
    public static int OR;
    public static int NOT;
    public static int PLUS;
    public static int MINUS;
    public static int BAREOPER;
    public static int LPAREN;
    public static int RPAREN;
    public static int COLON;
    public static int STAR;
    public static int CARAT;
    public static int QUOTED;
    public static int TERM;
    public static int FUZZY_SLOP;
    public static int PREFIXTERM;
    public static int WILDTERM;
    public static int REGEXPTERM;
    public static int RANGEIN_START;
    public static int RANGEEX_START;
    public static int NUMBER;
    public static int RANGE_TO;
    public static int RANGEIN_END;
    public static int RANGEEX_END;
    public static int RANGE_QUOTED;
    public static int RANGE_GOOP;
}
public class Lucene.Net.QueryParsers.Classic.Token : object {
    [CompilerGeneratedAttribute]
private int <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BeginLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BeginColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Image>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <Next>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <SpecialToken>k__BackingField;
    public int Kind { get; public set; }
    public int BeginLine { get; public set; }
    public int BeginColumn { get; public set; }
    public int EndLine { get; public set; }
    public int EndColumn { get; public set; }
    public string Image { get; public set; }
    public Token Next { get; public set; }
    public Token SpecialToken { get; public set; }
    public object Value { get; }
    public Token(int kind);
    public Token(int kind, string image);
    [CompilerGeneratedAttribute]
public int get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(int value);
    [CompilerGeneratedAttribute]
public int get_BeginLine();
    [CompilerGeneratedAttribute]
public void set_BeginLine(int value);
    [CompilerGeneratedAttribute]
public int get_BeginColumn();
    [CompilerGeneratedAttribute]
public void set_BeginColumn(int value);
    [CompilerGeneratedAttribute]
public int get_EndLine();
    [CompilerGeneratedAttribute]
public void set_EndLine(int value);
    [CompilerGeneratedAttribute]
public int get_EndColumn();
    [CompilerGeneratedAttribute]
public void set_EndColumn(int value);
    [CompilerGeneratedAttribute]
public string get_Image();
    [CompilerGeneratedAttribute]
public void set_Image(string value);
    [CompilerGeneratedAttribute]
public Token get_Next();
    [CompilerGeneratedAttribute]
public void set_Next(Token value);
    [CompilerGeneratedAttribute]
public Token get_SpecialToken();
    [CompilerGeneratedAttribute]
public void set_SpecialToken(Token value);
    public virtual object get_Value();
    public virtual string ToString();
    public static Token NewToken(int ofKind, string image);
    public static Token NewToken(int ofKind);
}
public class Lucene.Net.QueryParsers.Classic.TokenMgrError : Exception {
    internal static int LEXICAL_ERROR;
    internal static int STATIC_LEXER_ERROR;
    internal static int INVALID_LEXICAL_STATE;
    internal static int LOOP_DETECTED;
    internal int errorCode;
    public string Message { get; }
    public TokenMgrError(string message, int reason);
    public TokenMgrError(bool eofSeen, int lexState, int errorLine, int errorColumn, string errorAfter, char curChar, int reason);
    protected TokenMgrError(SerializationInfo info, StreamingContext context);
    protected static string AddEscapes(string str);
    protected internal static string LexicalError(bool eofSeen, int lexState, int errorLine, int errorColumn, string errorAfter, char curChar);
    public virtual string get_Message();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Lucene.Net.QueryParsers.ComplexPhrase.ComplexPhraseQueryParser : QueryParser {
    private IList`1<ComplexPhraseQuery> complexPhrases;
    private bool isPass2ResolvingPhrases;
    [CompilerGeneratedAttribute]
private bool <InOrder>k__BackingField;
    private ComplexPhraseQuery currentPhraseQuery;
    public bool InOrder { get; internal set; }
    public ComplexPhraseQueryParser(LuceneVersion matchVersion, string f, Analyzer a);
    [CompilerGeneratedAttribute]
public virtual bool get_InOrder();
    [CompilerGeneratedAttribute]
internal virtual void set_InOrder(bool value);
    protected internal virtual Query GetFieldQuery(string field, string queryText, int slop);
    public virtual Query Parse(string query);
    protected virtual Query NewTermQuery(Term term);
    private void CheckPhraseClauseIsForSameField(string field);
    protected internal virtual Query GetWildcardQuery(string field, string termStr);
    protected internal virtual Query GetRangeQuery(string field, string part1, string part2, bool startInclusive, bool endInclusive);
    protected internal virtual Query NewRangeQuery(string field, string part1, string part2, bool startInclusive, bool endInclusive);
    protected internal virtual Query GetFuzzyQuery(string field, string termStr, float minSimilarity);
}
public class Lucene.Net.QueryParsers.Ext.ExtendableQueryParser : QueryParser {
    private string defaultField;
    private Extensions extensions;
    private static Extensions DEFAULT_EXTENSION;
    public char ExtensionFieldDelimiter { get; }
    public ExtendableQueryParser(LuceneVersion matchVersion, string f, Analyzer a);
    public ExtendableQueryParser(LuceneVersion matchVersion, string f, Analyzer a, Extensions ext);
    private static ExtendableQueryParser();
    public virtual char get_ExtensionFieldDelimiter();
    protected internal virtual Query GetFieldQuery(string field, string queryText, bool quoted);
}
public class Lucene.Net.QueryParsers.Ext.ExtensionQuery : object {
    [CompilerGeneratedAttribute]
private string <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawQueryString>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryParser <TopLevelParser>k__BackingField;
    public string Field { get; protected set; }
    public string RawQueryString { get; protected set; }
    public QueryParser TopLevelParser { get; protected set; }
    public ExtensionQuery(QueryParser topLevelParser, string field, string rawQueryString);
    [CompilerGeneratedAttribute]
public virtual string get_Field();
    [CompilerGeneratedAttribute]
protected virtual void set_Field(string value);
    [CompilerGeneratedAttribute]
public virtual string get_RawQueryString();
    [CompilerGeneratedAttribute]
protected virtual void set_RawQueryString(string value);
    [CompilerGeneratedAttribute]
public virtual QueryParser get_TopLevelParser();
    [CompilerGeneratedAttribute]
protected virtual void set_TopLevelParser(QueryParser value);
}
public class Lucene.Net.QueryParsers.Ext.Extensions : object {
    private IDictionary`2<string, ParserExtension> extensions;
    private char extensionFieldDelimiter;
    public static char DEFAULT_EXTENSION_FIELD_DELIMITER;
    public char ExtensionFieldDelimiter { get; }
    public Extensions(char extensionFieldDelimiter);
    private static Extensions();
    public virtual void Add(string key, ParserExtension extension);
    public ParserExtension GetExtension(string key);
    public virtual char get_ExtensionFieldDelimiter();
    public virtual Tuple`2<string, string> SplitExtensionField(string defaultField, string field);
    public virtual string EscapeExtensionField(string extfield);
    public virtual string BuildExtensionField(string extensionKey);
    public virtual string BuildExtensionField(string extensionKey, string field);
}
public abstract class Lucene.Net.QueryParsers.Ext.ParserExtension : object {
    public abstract virtual Query Parse(ExtensionQuery query);
}
public interface Lucene.Net.QueryParsers.Flexible.Core.Builders.IQueryBuilder`1 {
    public abstract virtual TQuery Build(IQueryNode queryNode);
}
public abstract class Lucene.Net.QueryParsers.Flexible.Core.Builders.QueryTreeBuilder : object {
    public static string QUERY_TREE_BUILDER_TAGID;
    private static QueryTreeBuilder();
}
public class Lucene.Net.QueryParsers.Flexible.Core.Builders.QueryTreeBuilder`1 : QueryTreeBuilder {
    private IDictionary`2<Type, IQueryBuilder`1<TQuery>> queryNodeBuilders;
    private IDictionary`2<string, IQueryBuilder`1<TQuery>> fieldNameBuilders;
    public virtual void SetBuilder(string fieldName, IQueryBuilder`1<TQuery> builder);
    public virtual void SetBuilder(Type queryNodeClass, IQueryBuilder`1<TQuery> builder);
    private void Process(IQueryNode node);
    private IQueryBuilder`1<TQuery> GetBuilder(IQueryNode node);
    private static void ProcessNode(IQueryNode node, IQueryBuilder`1<TQuery> builder);
    private IQueryBuilder`1<TQuery> GetQueryBuilder(Type clazz);
    public virtual TQuery Build(IQueryNode queryNode);
}
public abstract class Lucene.Net.QueryParsers.Flexible.Core.Config.AbstractQueryConfig : object {
    private IDictionary`2<ConfigurationKey, object> configMap;
    public virtual bool TryGetValue(ConfigurationKey`1<T> key, T& value);
    public virtual T Get(ConfigurationKey`1<T> key);
    public virtual bool Has(ConfigurationKey`1<T> key);
    public virtual void Set(ConfigurationKey`1<T> key, T value);
    public virtual bool Unset(ConfigurationKey`1<T> key);
}
public abstract class Lucene.Net.QueryParsers.Flexible.Core.Config.ConfigurationKey : object {
    public static ConfigurationKey`1<T> NewInstance();
}
public class Lucene.Net.QueryParsers.Flexible.Core.Config.ConfigurationKey`1 : ConfigurationKey {
}
public class Lucene.Net.QueryParsers.Flexible.Core.Config.FieldConfig : AbstractQueryConfig {
    private string fieldName;
    public string Field { get; }
    public FieldConfig(string fieldName);
    public virtual string get_Field();
    public virtual string ToString();
}
public interface Lucene.Net.QueryParsers.Flexible.Core.Config.IFieldConfigListener {
    public abstract virtual void BuildFieldConfig(FieldConfig fieldConfig);
}
public abstract class Lucene.Net.QueryParsers.Flexible.Core.Config.QueryConfigHandler : AbstractQueryConfig {
    private LinkedList`1<IFieldConfigListener> listeners;
    public virtual FieldConfig GetFieldConfig(string fieldName);
    public virtual void AddFieldConfigListener(IFieldConfigListener listener);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class Lucene.Net.QueryParsers.Flexible.Core.Messages.QueryParserMessages : object {
    private static CultureInfo resourceCulture;
    [NullableAttribute("1")]
private static IResourceProvider resourceProvider;
    [EditorBrowsableAttribute("2")]
public static CultureInfo Culture { get; public set; }
    public static string ARGUMENT_CANNOT_BE_NULL { get; }
    public static string COULD_NOT_PARSE_NUMBER { get; }
    public static string EMPTY_MESSAGE { get; }
    public static string INVALID_SYNTAX { get; }
    public static string INVALID_SYNTAX_CANNOT_PARSE { get; }
    public static string INVALID_SYNTAX_ESCAPE_CHARACTER { get; }
    public static string INVALID_SYNTAX_ESCAPE_NONE_HEX_UNICODE { get; }
    public static string INVALID_SYNTAX_ESCAPE_UNICODE_TRUNCATION { get; }
    public static string INVALID_SYNTAX_FUZZY_EDITS { get; }
    public static string INVALID_SYNTAX_FUZZY_LIMITS { get; }
    public static string LEADING_WILDCARD_NOT_ALLOWED { get; }
    public static string LUCENE_QUERY_CONVERSION_ERROR { get; }
    public static string NODE_ACTION_NOT_SUPPORTED { get; }
    public static string NUMBER_CANNOT_BE_NEGATIVE { get; }
    public static string NUMBER_CLASS_NOT_SUPPORTED_BY_NUMERIC_RANGE_QUERY { get; }
    public static string NUMERIC_CANNOT_BE_EMPTY { get; }
    public static string PARAMETER_VALUE_NOT_SUPPORTED { get; }
    public static string TOO_MANY_BOOLEAN_CLAUSES { get; }
    public static string UNSUPPORTED_NUMERIC_DATA_TYPE { get; }
    public static string WILDCARD_NOT_SUPPORTED { get; }
    private static QueryParserMessages();
    [NullableContextAttribute("1")]
public static IResourceProvider GetResourceProvider();
    [NullableContextAttribute("1")]
public static void SetResourceProvider(IResourceProvider provider);
    private static string GetString(string name, CultureInfo culture);
    public static CultureInfo get_Culture();
    public static void set_Culture(CultureInfo value);
    public static string get_ARGUMENT_CANNOT_BE_NULL();
    public static string get_COULD_NOT_PARSE_NUMBER();
    public static string get_EMPTY_MESSAGE();
    public static string get_INVALID_SYNTAX();
    public static string get_INVALID_SYNTAX_CANNOT_PARSE();
    public static string get_INVALID_SYNTAX_ESCAPE_CHARACTER();
    public static string get_INVALID_SYNTAX_ESCAPE_NONE_HEX_UNICODE();
    public static string get_INVALID_SYNTAX_ESCAPE_UNICODE_TRUNCATION();
    public static string get_INVALID_SYNTAX_FUZZY_EDITS();
    public static string get_INVALID_SYNTAX_FUZZY_LIMITS();
    public static string get_LEADING_WILDCARD_NOT_ALLOWED();
    public static string get_LUCENE_QUERY_CONVERSION_ERROR();
    public static string get_NODE_ACTION_NOT_SUPPORTED();
    public static string get_NUMBER_CANNOT_BE_NEGATIVE();
    public static string get_NUMBER_CLASS_NOT_SUPPORTED_BY_NUMERIC_RANGE_QUERY();
    public static string get_NUMERIC_CANNOT_BE_EMPTY();
    public static string get_PARAMETER_VALUE_NOT_SUPPORTED();
    public static string get_TOO_MANY_BOOLEAN_CLAUSES();
    public static string get_UNSUPPORTED_NUMERIC_DATA_TYPE();
    public static string get_WILDCARD_NOT_SUPPORTED();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Lucene.Net.QueryParsers.Flexible.Core.Messages.QueryParserResourceProvider : object {
    [NullableAttribute("2")]
private ResourceManager fallbackResourceManager;
    private IList`1<ResourceManager> resourceManagers;
    [EditorBrowsableAttribute("2")]
public ResourceManager FallbackResourceManager { get; }
    public QueryParserResourceProvider(ResourceManager[] resourceManagers);
    public QueryParserResourceProvider(IList`1<ResourceManager> resourceManagers);
    public virtual ResourceManager get_FallbackResourceManager();
    [NullableContextAttribute("2")]
public virtual string GetString(string name, CultureInfo culture);
    [NullableContextAttribute("2")]
public virtual object GetObject(string name, CultureInfo culture);
    [NullableContextAttribute("2")]
public sealed virtual Stream GetStream(string name, CultureInfo culture);
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.AndQueryNode : BooleanQueryNode {
    public AndQueryNode(IList`1<IQueryNode> clauses);
    public virtual string ToString();
    public virtual string ToQueryString(IEscapeQuerySyntax escapeSyntaxParser);
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.AnyQueryNode : AndQueryNode {
    private string field;
    private int minimumMatchingmElements;
    public int MinimumMatchingElements { get; }
    public string Field { get; public set; }
    public AnyQueryNode(IList`1<IQueryNode> clauses, string field, int minimumMatchingElements);
    public virtual int get_MinimumMatchingElements();
    public virtual string get_Field();
    public virtual void set_Field(string value);
    public virtual string GetFieldAsString();
    public virtual IQueryNode CloneTree();
    public virtual string ToString();
    public virtual string ToQueryString(IEscapeQuerySyntax escapeSyntaxParser);
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.BooleanQueryNode : QueryNode {
    public BooleanQueryNode(IList`1<IQueryNode> clauses);
    public virtual string ToString();
    public virtual string ToQueryString(IEscapeQuerySyntax escapeSyntaxParser);
    public virtual IQueryNode CloneTree();
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.BoostQueryNode : QueryNode {
    private float value;
    public IQueryNode Child { get; }
    public float Value { get; }
    public BoostQueryNode(IQueryNode query, float value);
    public virtual IQueryNode get_Child();
    public virtual float get_Value();
    private string GetValueString();
    public virtual string ToString();
    public virtual string ToQueryString(IEscapeQuerySyntax escapeSyntaxParser);
    public virtual IQueryNode CloneTree();
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.DeletedQueryNode : QueryNode {
    public virtual string ToQueryString(IEscapeQuerySyntax escaper);
    public virtual string ToString();
    public virtual IQueryNode CloneTree();
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.FieldQueryNode : QueryNode {
    protected string m_field;
    protected ICharSequence m_text;
    protected int m_begin;
    protected int m_end;
    protected int m_positionIncrement;
    public int Begin { get; public set; }
    public int End { get; public set; }
    public string Field { get; public set; }
    public int PositionIncrement { get; public set; }
    public ICharSequence Text { get; public set; }
    public string Value { get; public set; }
    public FieldQueryNode(string field, string text, int begin, int end);
    public FieldQueryNode(string field, StringBuilder text, int begin, int end);
    public FieldQueryNode(string field, ICharSequence text, int begin, int end);
    protected virtual string GetTermEscaped(IEscapeQuerySyntax escaper);
    protected virtual string GetTermEscapeQuoted(IEscapeQuerySyntax escaper);
    public virtual string ToQueryString(IEscapeQuerySyntax escaper);
    public virtual string ToString();
    public virtual string GetTextAsString();
    public virtual string GetFieldAsString();
    public virtual int get_Begin();
    public virtual void set_Begin(int value);
    public virtual int get_End();
    public virtual void set_End(int value);
    public virtual string get_Field();
    public virtual void set_Field(string value);
    public virtual int get_PositionIncrement();
    public virtual void set_PositionIncrement(int value);
    public virtual ICharSequence get_Text();
    public virtual void set_Text(ICharSequence value);
    public virtual IQueryNode CloneTree();
    public virtual string get_Value();
    public virtual void set_Value(string value);
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.FuzzyQueryNode : FieldQueryNode {
    private float similarity;
    private int prefixLength;
    public int PrefixLength { get; public set; }
    public float Similarity { get; public set; }
    public FuzzyQueryNode(string field, string term, float minSimilarity, int begin, int end);
    public FuzzyQueryNode(string field, StringBuilder term, float minSimilarity, int begin, int end);
    public FuzzyQueryNode(string field, ICharSequence term, float minSimilarity, int begin, int end);
    public virtual int get_PrefixLength();
    public virtual void set_PrefixLength(int value);
    public virtual string ToQueryString(IEscapeQuerySyntax escaper);
    public virtual string ToString();
    public virtual float get_Similarity();
    public virtual void set_Similarity(float value);
    public virtual IQueryNode CloneTree();
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.GroupQueryNode : QueryNode {
    public GroupQueryNode(IQueryNode query);
    public virtual IQueryNode GetChild();
    public virtual string ToString();
    public virtual string ToQueryString(IEscapeQuerySyntax escapeSyntaxParser);
    public virtual IQueryNode CloneTree();
    public virtual void SetChild(IQueryNode child);
}
public interface Lucene.Net.QueryParsers.Flexible.Core.Nodes.IFieldableNode {
    public string Field { get; public set; }
    public abstract virtual string get_Field();
    public abstract virtual void set_Field(string value);
}
public interface Lucene.Net.QueryParsers.Flexible.Core.Nodes.IFieldValuePairQueryNode`1 {
}
public interface Lucene.Net.QueryParsers.Flexible.Core.Nodes.IQueryNode {
    public bool IsLeaf { get; }
    public IQueryNode Parent { get; }
    public IDictionary`2<string, object> TagMap { get; }
    public abstract virtual string ToQueryString(IEscapeQuerySyntax escapeSyntaxParser);
    public abstract virtual string ToString();
    public abstract virtual IList`1<IQueryNode> GetChildren();
    public abstract virtual bool get_IsLeaf();
    public abstract virtual bool ContainsTag(string tagName);
    public abstract virtual object GetTag(string tagName);
    public abstract virtual bool TryGetTag(string tagName, Object& tag);
    public abstract virtual IQueryNode get_Parent();
    public abstract virtual IQueryNode CloneTree();
    public abstract virtual void Add(IQueryNode child);
    public abstract virtual void Add(IList`1<IQueryNode> children);
    public abstract virtual void Set(IList`1<IQueryNode> children);
    public abstract virtual void SetTag(string tagName, object value);
    public abstract virtual void UnsetTag(string tagName);
    public abstract virtual IDictionary`2<string, object> get_TagMap();
    public abstract virtual void RemoveFromParent();
    public abstract virtual void RemoveChildren(IQueryNode childNode);
}
public interface Lucene.Net.QueryParsers.Flexible.Core.Nodes.IRangeQueryNode {
    public bool IsLowerInclusive { get; }
    public bool IsUpperInclusive { get; }
    public abstract virtual bool get_IsLowerInclusive();
    public abstract virtual bool get_IsUpperInclusive();
}
public interface Lucene.Net.QueryParsers.Flexible.Core.Nodes.IRangeQueryNode`1 {
    public T LowerBound { get; }
    public T UpperBound { get; }
    public abstract virtual T get_LowerBound();
    public abstract virtual T get_UpperBound();
}
public interface Lucene.Net.QueryParsers.Flexible.Core.Nodes.ITextableQueryNode {
    public ICharSequence Text { get; public set; }
    public abstract virtual ICharSequence get_Text();
    public abstract virtual void set_Text(ICharSequence value);
}
public interface Lucene.Net.QueryParsers.Flexible.Core.Nodes.IValueQueryNode`1 {
    public T Value { get; public set; }
    public abstract virtual T get_Value();
    public abstract virtual void set_Value(T value);
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.MatchAllDocsQueryNode : QueryNode {
    public virtual string ToString();
    public virtual string ToQueryString(IEscapeQuerySyntax escapeSyntaxParser);
    public virtual IQueryNode CloneTree();
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.MatchNoDocsQueryNode : DeletedQueryNode {
    public virtual string ToString();
}
public enum Lucene.Net.QueryParsers.Flexible.Core.Nodes.Modifier : Enum {
    public int value__;
    public static Modifier MOD_NONE;
    public static Modifier MOD_NOT;
    public static Modifier MOD_REQ;
}
[ExtensionAttribute]
public static class Lucene.Net.QueryParsers.Flexible.Core.Nodes.ModifierExtensions : object {
    [ExtensionAttribute]
public static string ToDigitString(Modifier modifier);
    [ExtensionAttribute]
public static string ToLargeString(Modifier modifier);
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.ModifierQueryNode : QueryNode {
    private Modifier modifier;
    public Modifier Modifier { get; }
    public ModifierQueryNode(IQueryNode query, Modifier mod);
    public virtual IQueryNode GetChild();
    public virtual Modifier get_Modifier();
    public virtual string ToString();
    public virtual string ToQueryString(IEscapeQuerySyntax escapeSyntaxParser);
    public virtual IQueryNode CloneTree();
    public virtual void SetChild(IQueryNode child);
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.NoTokenFoundQueryNode : DeletedQueryNode {
    public virtual string ToQueryString(IEscapeQuerySyntax escaper);
    public virtual string ToString();
    public virtual IQueryNode CloneTree();
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.OpaqueQueryNode : QueryNode {
    private string schema;
    private string value;
    public string Schema { get; }
    public string Value { get; }
    public OpaqueQueryNode(string schema, string value);
    public virtual string ToString();
    public virtual string ToQueryString(IEscapeQuerySyntax escapeSyntaxParser);
    public virtual IQueryNode CloneTree();
    public virtual string get_Schema();
    public virtual string get_Value();
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.OrQueryNode : BooleanQueryNode {
    public OrQueryNode(IList`1<IQueryNode> clauses);
    public virtual string ToString();
    public virtual string ToQueryString(IEscapeQuerySyntax escapeSyntaxParser);
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.PathQueryNode : QueryNode {
    private IList`1<QueryText> values;
    public IList`1<QueryText> PathElements { get; public set; }
    public PathQueryNode(IList`1<QueryText> pathElements);
    public virtual IList`1<QueryText> get_PathElements();
    public virtual void set_PathElements(IList`1<QueryText> value);
    public virtual QueryText GetPathElement(int index);
    public virtual string GetFirstPathElement();
    public virtual IList`1<QueryText> GetPathElements(int startIndex);
    private string GetPathString();
    public virtual string ToQueryString(IEscapeQuerySyntax escaper);
    public virtual string ToString();
    public virtual IQueryNode CloneTree();
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.PhraseSlopQueryNode : QueryNode {
    private int value;
    public int Value { get; }
    public string Field { get; public set; }
    public PhraseSlopQueryNode(IQueryNode query, int value);
    public virtual IQueryNode GetChild();
    public virtual int get_Value();
    private string GetValueString();
    public virtual string ToString();
    public virtual string ToQueryString(IEscapeQuerySyntax escapeSyntaxParser);
    public virtual IQueryNode CloneTree();
    public virtual string get_Field();
    public virtual void set_Field(string value);
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.ProximityQueryNode : BooleanQueryNode {
    private Type proximityType;
    private int distance;
    private bool inorder;
    private string field;
    public Type ProximityType { get; }
    public int Distance { get; }
    public string Field { get; public set; }
    public bool IsInOrder { get; }
    public ProximityQueryNode(IList`1<IQueryNode> clauses, string field, Type type, int distance, bool inorder);
    public ProximityQueryNode(IList`1<IQueryNode> clauses, string field, Type type, bool inorder);
    private static void ClearFields(IList`1<IQueryNode> nodes, string field);
    public virtual Type get_ProximityType();
    public virtual string ToString();
    public virtual string ToQueryString(IEscapeQuerySyntax escapeSyntaxParser);
    public virtual IQueryNode CloneTree();
    public virtual int get_Distance();
    public virtual string get_Field();
    public virtual void set_Field(string value);
    public virtual string GetFieldAsString();
    public virtual bool get_IsInOrder();
}
[ExtensionAttribute]
public static class Lucene.Net.QueryParsers.Flexible.Core.Nodes.ProximityQueryNode_TypeExtensions : object {
    [ExtensionAttribute]
public static string ToQueryString(Type type);
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.ProximityType : object {
    internal int pDistance;
    internal Type pType;
    public ProximityType(Type type);
    public ProximityType(Type type, int distance);
}
public abstract class Lucene.Net.QueryParsers.Flexible.Core.Nodes.QueryNode : object {
    public static string PLAINTEXT_FIELD_NAME;
    private bool isLeaf;
    private Dictionary`2<string, object> tags;
    private List`1<IQueryNode> clauses;
    private IQueryNode parent;
    protected internal bool m_toQueryStringIgnoreFields;
    public bool IsLeaf { get; protected set; }
    public IQueryNode Parent { get; }
    protected bool IsRoot { get; }
    public IDictionary`2<string, object> TagMap { get; }
    private static QueryNode();
    protected virtual void Allocate();
    public sealed virtual void Add(IQueryNode child);
    public sealed virtual void Add(IList`1<IQueryNode> children);
    public virtual bool get_IsLeaf();
    protected virtual void set_IsLeaf(bool value);
    public sealed virtual void Set(IList`1<IQueryNode> children);
    public virtual IQueryNode CloneTree();
    public virtual object Clone();
    public sealed virtual IList`1<IQueryNode> GetChildren();
    public virtual void SetTag(string tagName, object value);
    public virtual void UnsetTag(string tagName);
    public virtual bool ContainsTag(string tagName);
    public virtual object GetTag(string tagName);
    public virtual bool TryGetTag(string tagName, Object& tag);
    private void SetParent(IQueryNode parent);
    public virtual IQueryNode get_Parent();
    protected virtual bool get_IsRoot();
    protected virtual bool IsDefaultField(string fld);
    public virtual string ToString();
    public virtual IDictionary`2<string, object> get_TagMap();
    public virtual void RemoveChildren(IQueryNode childNode);
    public virtual void RemoveFromParent();
    public abstract virtual string ToQueryString(IEscapeQuerySyntax escapeSyntaxParser);
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.QuotedFieldQueryNode : FieldQueryNode {
    public QuotedFieldQueryNode(string field, string text, int begin, int end);
    public QuotedFieldQueryNode(string field, StringBuilder text, int begin, int end);
    public QuotedFieldQueryNode(string field, ICharSequence text, int begin, int end);
    public virtual string ToQueryString(IEscapeQuerySyntax escaper);
    public virtual string ToString();
    public virtual IQueryNode CloneTree();
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.SlopQueryNode : QueryNode {
    private int value;
    public int Value { get; }
    public string Field { get; public set; }
    public SlopQueryNode(IQueryNode query, int value);
    public virtual IQueryNode GetChild();
    public virtual int get_Value();
    private string GetValueString();
    public virtual string ToString();
    public virtual string ToQueryString(IEscapeQuerySyntax escapeSyntaxParser);
    public virtual IQueryNode CloneTree();
    public virtual string get_Field();
    public virtual void set_Field(string value);
}
public class Lucene.Net.QueryParsers.Flexible.Core.Nodes.TokenizedPhraseQueryNode : QueryNode {
    public string Field { get; public set; }
    public virtual string ToString();
    public virtual string ToQueryString(IEscapeQuerySyntax escapeSyntaxParser);
    public virtual IQueryNode CloneTree();
    public virtual string get_Field();
    public virtual void set_Field(string value);
}
public enum Lucene.Net.QueryParsers.Flexible.Core.Parser.EscapeQuerySyntaxType : Enum {
    public int value__;
    public static EscapeQuerySyntaxType STRING;
    public static EscapeQuerySyntaxType NORMAL;
}
public interface Lucene.Net.QueryParsers.Flexible.Core.Parser.IEscapeQuerySyntax {
    public abstract virtual string Escape(string text, CultureInfo locale, EscapeQuerySyntaxType type);
    public abstract virtual ICharSequence Escape(ICharSequence text, CultureInfo locale, EscapeQuerySyntaxType type);
}
public interface Lucene.Net.QueryParsers.Flexible.Core.Parser.ISyntaxParser {
    public abstract virtual IQueryNode Parse(string query, string field);
}
public interface Lucene.Net.QueryParsers.Flexible.Core.Processors.IQueryNodeProcessor {
    public abstract virtual IQueryNode Process(IQueryNode queryTree);
    public abstract virtual void SetQueryConfigHandler(QueryConfigHandler queryConfigHandler);
    public abstract virtual QueryConfigHandler GetQueryConfigHandler();
}
public class Lucene.Net.QueryParsers.Flexible.Core.Processors.NoChildOptimizationQueryNodeProcessor : QueryNodeProcessor {
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
    protected virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
}
public abstract class Lucene.Net.QueryParsers.Flexible.Core.Processors.QueryNodeProcessor : object {
    private IList`1<ChildrenList> childrenListPool;
    private QueryConfigHandler queryConfig;
    protected QueryNodeProcessor(QueryConfigHandler queryConfigHandler);
    public virtual IQueryNode Process(IQueryNode queryTree);
    private IQueryNode ProcessIteration(IQueryNode queryTree);
    protected virtual void ProcessChildren(IQueryNode queryTree);
    private ChildrenList AllocateChildrenList();
    public virtual void SetQueryConfigHandler(QueryConfigHandler queryConfigHandler);
    public virtual QueryConfigHandler GetQueryConfigHandler();
    protected abstract virtual IQueryNode PreProcessNode(IQueryNode node);
    protected abstract virtual IQueryNode PostProcessNode(IQueryNode node);
    protected abstract virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
}
[DefaultMemberAttribute("Item")]
public class Lucene.Net.QueryParsers.Flexible.Core.Processors.QueryNodeProcessorPipeline : object {
    private List`1<IQueryNodeProcessor> processors;
    private QueryConfigHandler queryConfig;
    public IQueryNodeProcessor Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public QueryNodeProcessorPipeline(QueryConfigHandler queryConfigHandler);
    public virtual QueryConfigHandler GetQueryConfigHandler();
    public virtual IQueryNode Process(IQueryNode queryTree);
    public virtual void SetQueryConfigHandler(QueryConfigHandler queryConfigHandler);
    public virtual bool Add(IQueryNodeProcessor processor);
    public virtual void Clear();
    public virtual bool Contains(object o);
    public virtual IQueryNodeProcessor get_Item(int index);
    public virtual void set_Item(int index, IQueryNodeProcessor value);
    public virtual int IndexOf(IQueryNodeProcessor o);
    public virtual IEnumerator`1<IQueryNodeProcessor> GetEnumerator();
    public virtual bool Remove(IQueryNodeProcessor o);
    public virtual void RemoveAt(int index);
    public virtual void RemoveRange(int index, int count);
    public virtual IQueryNodeProcessor Set(int index, IQueryNodeProcessor processor);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual IList`1<IQueryNodeProcessor> GetRange(int index, int count);
    public virtual IList`1<IQueryNodeProcessor> GetView(int index, int count);
    public virtual void Insert(int index, IQueryNodeProcessor item);
    private sealed virtual override void System.Collections.Generic.ICollection<Lucene.Net.QueryParsers.Flexible.Core.Processors.IQueryNodeProcessor>.Add(IQueryNodeProcessor item);
    public virtual bool Contains(IQueryNodeProcessor item);
    public virtual void CopyTo(IQueryNodeProcessor[] array, int arrayIndex);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Lucene.Net.QueryParsers.Flexible.Core.Processors.RemoveDeletedQueryNodesProcessor : QueryNodeProcessor {
    public virtual IQueryNode Process(IQueryNode queryTree);
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    protected virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Lucene.Net.QueryParsers.Flexible.Core.QueryNodeError : ArgumentException {
    public QueryNodeError(string message, string paramName);
    public QueryNodeError(string message, string paramName, Exception innerException);
    public QueryNodeError(string message);
    public QueryNodeError(Exception innerException);
    public QueryNodeError(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected QueryNodeError(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Lucene.Net.QueryParsers.Flexible.Core.QueryNodeException : Exception {
    public QueryNodeException(string message);
    public QueryNodeException(Exception cause);
    public QueryNodeException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected QueryNodeException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Lucene.Net.QueryParsers.Flexible.Core.QueryNodeParseException : QueryNodeException {
    private string query;
    private int beginColumn;
    private int beginLine;
    [NullableAttribute("1")]
private string errorToken;
    public string Query { get; public set; }
    [NullableAttribute("1")]
public string ErrorToken { get; protected set; }
    public int BeginLine { get; protected set; }
    public int BeginColumn { get; protected set; }
    public QueryNodeParseException(string message);
    public QueryNodeParseException(Exception cause);
    public QueryNodeParseException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected QueryNodeParseException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Query();
    public virtual void set_Query(string value);
    [NullableContextAttribute("1")]
public virtual string get_ErrorToken();
    [NullableContextAttribute("1")]
protected virtual void set_ErrorToken(string value);
    public virtual int get_BeginLine();
    protected virtual void set_BeginLine(int value);
    public virtual int get_BeginColumn();
    protected virtual void set_BeginColumn(int value);
}
public class Lucene.Net.QueryParsers.Flexible.Core.QueryParserHelper`1 : object {
    private IQueryNodeProcessor processor;
    private ISyntaxParser syntaxParser;
    private IQueryBuilder`1<TQuery> builder;
    private QueryConfigHandler config;
    public IQueryNodeProcessor QueryNodeProcessor { get; }
    public QueryConfigHandler QueryConfigHandler { get; }
    public IQueryBuilder`1<TQuery> QueryBuilder { get; }
    public ISyntaxParser SyntaxParser { get; }
    public QueryParserHelper`1(QueryConfigHandler queryConfigHandler, ISyntaxParser syntaxParser, IQueryNodeProcessor processor, IQueryBuilder`1<TQuery> builder);
    public virtual IQueryNodeProcessor get_QueryNodeProcessor();
    public virtual void SetQueryNodeProcessor(IQueryNodeProcessor processor);
    public virtual void SetSyntaxParser(ISyntaxParser syntaxParser);
    public virtual void SetQueryBuilder(IQueryBuilder`1<TQuery> queryBuilder);
    public virtual QueryConfigHandler get_QueryConfigHandler();
    public virtual IQueryBuilder`1<TQuery> get_QueryBuilder();
    public virtual ISyntaxParser get_SyntaxParser();
    public virtual void SetQueryConfigHandler(QueryConfigHandler config);
    public virtual TQuery Parse(string query, string defaultField);
}
public class Lucene.Net.QueryParsers.Flexible.Core.Util.QueryNodeOperation : object {
    public static IQueryNode LogicalAnd(IQueryNode q1, IQueryNode q2);
}
public class Lucene.Net.QueryParsers.Flexible.Core.Util.StringUtils : object {
    public static string ToString(object obj);
}
[DefaultMemberAttribute("Item")]
public class Lucene.Net.QueryParsers.Flexible.Core.Util.UnescapedCharSequence : object {
    private Char[] chars;
    private Boolean[] wasEscaped;
    private bool J2N.Text.ICharSequence.HasValue { get; }
    public int Length { get; }
    public char Item { get; }
    public UnescapedCharSequence(Char[] chars, Boolean[] wasEscaped, int offset, int length);
    public UnescapedCharSequence(ICharSequence text);
    public UnescapedCharSequence(string text);
    public UnescapedCharSequence(StringBuilder text);
    private sealed virtual override bool J2N.Text.ICharSequence.get_HasValue();
    public sealed virtual int get_Length();
    public sealed virtual char get_Item(int index);
    public sealed virtual ICharSequence Subsequence(int startIndex, int length);
    public virtual string ToString();
    public string ToStringEscaped();
    public ICharSequence ToStringEscaped(Char[] enabledChars);
    public bool WasEscaped(int index);
    public static bool WasEscaped(ICharSequence text, int index);
    public static ICharSequence ToLower(ICharSequence text, CultureInfo locale);
}
public class Lucene.Net.QueryParsers.Flexible.Precedence.PrecedenceQueryParser : StandardQueryParser {
    public PrecedenceQueryParser(Analyzer analyer);
}
public class Lucene.Net.QueryParsers.Flexible.Precedence.Processors.BooleanModifiersQueryNodeProcessor : QueryNodeProcessor {
    private IList`1<IQueryNode> childrenBuffer;
    private bool usingAnd;
    public virtual IQueryNode Process(IQueryNode queryTree);
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    private IQueryNode ApplyModifier(IQueryNode node, Modifier mod);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
    protected virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
}
public class Lucene.Net.QueryParsers.Flexible.Precedence.Processors.PrecedenceQueryNodeProcessorPipeline : StandardQueryNodeProcessorPipeline {
    public PrecedenceQueryNodeProcessorPipeline(QueryConfigHandler queryConfig);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Builders.AnyQueryNodeBuilder : object {
    public virtual Query Build(IQueryNode queryNode);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Builders.BooleanQueryNodeBuilder : object {
    public virtual Query Build(IQueryNode queryNode);
    private static Occur GetModifierValue(IQueryNode node);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Builders.BoostQueryNodeBuilder : object {
    public virtual Query Build(IQueryNode queryNode);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Builders.DummyQueryNodeBuilder : object {
    public virtual Query Build(IQueryNode queryNode);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Builders.FieldQueryNodeBuilder : object {
    public virtual Query Build(IQueryNode queryNode);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Builders.FuzzyQueryNodeBuilder : object {
    public virtual Query Build(IQueryNode queryNode);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Builders.GroupQueryNodeBuilder : object {
    public virtual Query Build(IQueryNode queryNode);
}
public interface Lucene.Net.QueryParsers.Flexible.Standard.Builders.IStandardQueryBuilder {
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Builders.MatchAllDocsQueryNodeBuilder : object {
    public virtual Query Build(IQueryNode queryNode);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Builders.MatchNoDocsQueryNodeBuilder : object {
    public virtual Query Build(IQueryNode queryNode);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Builders.ModifierQueryNodeBuilder : object {
    public virtual Query Build(IQueryNode queryNode);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Builders.MultiPhraseQueryNodeBuilder : object {
    public virtual Query Build(IQueryNode queryNode);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Builders.NumericRangeQueryNodeBuilder : object {
    public virtual Query Build(IQueryNode queryNode);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Builders.PhraseQueryNodeBuilder : object {
    public virtual Query Build(IQueryNode queryNode);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Builders.PrefixWildcardQueryNodeBuilder : object {
    public virtual Query Build(IQueryNode queryNode);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Builders.RegexpQueryNodeBuilder : object {
    public virtual Query Build(IQueryNode queryNode);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Builders.SlopQueryNodeBuilder : object {
    public virtual Query Build(IQueryNode queryNode);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Builders.StandardBooleanQueryNodeBuilder : object {
    public virtual Query Build(IQueryNode queryNode);
    private static Occur GetModifierValue(IQueryNode node);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Builders.StandardQueryTreeBuilder : QueryTreeBuilder`1<Query> {
    public virtual Query Build(IQueryNode queryNode);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Builders.TermRangeQueryNodeBuilder : object {
    public virtual Query Build(IQueryNode queryNode);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Builders.WildcardQueryNodeBuilder : object {
    public virtual Query Build(IQueryNode queryNode);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Config.ConfigurationKeys : object {
    public static ConfigurationKey`1<bool> ENABLE_POSITION_INCREMENTS;
    public static ConfigurationKey`1<bool> LOWERCASE_EXPANDED_TERMS;
    public static ConfigurationKey`1<bool> ALLOW_LEADING_WILDCARD;
    public static ConfigurationKey`1<Analyzer> ANALYZER;
    public static ConfigurationKey`1<Operator> DEFAULT_OPERATOR;
    public static ConfigurationKey`1<int> PHRASE_SLOP;
    public static ConfigurationKey`1<CultureInfo> LOCALE;
    public static ConfigurationKey`1<TimeZoneInfo> TIMEZONE;
    public static ConfigurationKey`1<RewriteMethod> MULTI_TERM_REWRITE_METHOD;
    public static ConfigurationKey`1<String[]> MULTI_FIELDS;
    public static ConfigurationKey`1<IDictionary`2<string, float>> FIELD_BOOST_MAP;
    public static ConfigurationKey`1<IDictionary`2<string, DateResolution>> FIELD_DATE_RESOLUTION_MAP;
    public static ConfigurationKey`1<FuzzyConfig> FUZZY_CONFIG;
    public static ConfigurationKey`1<DateResolution> DATE_RESOLUTION;
    public static ConfigurationKey`1<float> BOOST;
    public static ConfigurationKey`1<NumericConfig> NUMERIC_CONFIG;
    public static ConfigurationKey`1<IDictionary`2<string, NumericConfig>> NUMERIC_CONFIG_MAP;
    private static ConfigurationKeys();
}
public enum Lucene.Net.QueryParsers.Flexible.Standard.Config.DateFormat : Enum {
    public int value__;
    public static DateFormat FULL;
    public static DateFormat LONG;
    public static DateFormat MEDIUM;
    public static DateFormat SHORT;
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Config.FieldBoostMapFCListener : object {
    private QueryConfigHandler config;
    public FieldBoostMapFCListener(QueryConfigHandler config);
    public virtual void BuildFieldConfig(FieldConfig fieldConfig);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Config.FieldDateResolutionFCListener : object {
    private QueryConfigHandler config;
    public FieldDateResolutionFCListener(QueryConfigHandler config);
    public virtual void BuildFieldConfig(FieldConfig fieldConfig);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Config.FuzzyConfig : object {
    private int prefixLength;
    private float minSimilarity;
    public int PrefixLength { get; public set; }
    public float MinSimilarity { get; public set; }
    public virtual int get_PrefixLength();
    public virtual void set_PrefixLength(int value);
    public virtual float get_MinSimilarity();
    public virtual void set_MinSimilarity(float value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Lucene.Net.QueryParsers.Flexible.Standard.Config.NumberDateFormat : NumberFormat {
    [NullableAttribute("2")]
private string dateFormat;
    private DateFormat dateStyle;
    private Nullable`1<DateFormat> timeStyle;
    private TimeZoneInfo timeZone;
    [CompilerGeneratedAttribute]
private NumericRepresentation <NumericRepresentation>k__BackingField;
    public NumericRepresentation NumericRepresentation { get; public set; }
    public TimeZoneInfo TimeZone { get; public set; }
    [NullableContextAttribute("2")]
public NumberDateFormat(string dateFormat, IFormatProvider provider);
    [NullableContextAttribute("2")]
public NumberDateFormat(DateFormat dateStyle, IFormatProvider provider);
    [NullableContextAttribute("2")]
public NumberDateFormat(DateFormat dateStyle, DateFormat timeStyle, IFormatProvider provider);
    [CompilerGeneratedAttribute]
public NumericRepresentation get_NumericRepresentation();
    [CompilerGeneratedAttribute]
public void set_NumericRepresentation(NumericRepresentation value);
    public virtual TimeZoneInfo get_TimeZone();
    public virtual void set_TimeZone(TimeZoneInfo value);
    public virtual string Format(double number);
    public virtual string Format(long number);
    public virtual Number Parse(string source);
    public virtual string Format(object number);
    public void SetDateFormat(string dateFormat);
    public string GetDateFormat();
    public static string GetDateFormat(DateFormat dateStyle, DateFormat timeStyle, IFormatProvider provider);
    public static string GetDateFormat(DateFormat dateStyle, IFormatProvider provider);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Config.NumericConfig : object {
    private int precisionStep;
    private NumberFormat format;
    private NumericType type;
    public int PrecisionStep { get; public set; }
    public NumberFormat NumberFormat { get; public set; }
    public NumericType Type { get; public set; }
    public NumericConfig(int precisionStep, NumberFormat format, NumericType type);
    public virtual int get_PrecisionStep();
    public virtual void set_PrecisionStep(int value);
    public virtual NumberFormat get_NumberFormat();
    public virtual void set_NumberFormat(NumberFormat value);
    public virtual NumericType get_Type();
    public virtual void set_Type(NumericType value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Config.NumericFieldConfigListener : object {
    private QueryConfigHandler config;
    public NumericFieldConfigListener(QueryConfigHandler config);
    public virtual void BuildFieldConfig(FieldConfig fieldConfig);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Config.StandardQueryConfigHandler : QueryConfigHandler {
}
public interface Lucene.Net.QueryParsers.Flexible.Standard.ICommonQueryParserConfiguration {
    public bool LowercaseExpandedTerms { get; public set; }
    public bool AllowLeadingWildcard { get; public set; }
    public bool EnablePositionIncrements { get; public set; }
    public RewriteMethod MultiTermRewriteMethod { get; public set; }
    public int FuzzyPrefixLength { get; public set; }
    public CultureInfo Locale { get; public set; }
    public TimeZoneInfo TimeZone { get; public set; }
    public int PhraseSlop { get; public set; }
    public Analyzer Analyzer { get; }
    public float FuzzyMinSim { get; public set; }
    public abstract virtual bool get_LowercaseExpandedTerms();
    public abstract virtual void set_LowercaseExpandedTerms(bool value);
    public abstract virtual bool get_AllowLeadingWildcard();
    public abstract virtual void set_AllowLeadingWildcard(bool value);
    public abstract virtual bool get_EnablePositionIncrements();
    public abstract virtual void set_EnablePositionIncrements(bool value);
    public abstract virtual RewriteMethod get_MultiTermRewriteMethod();
    public abstract virtual void set_MultiTermRewriteMethod(RewriteMethod value);
    public abstract virtual int get_FuzzyPrefixLength();
    public abstract virtual void set_FuzzyPrefixLength(int value);
    public abstract virtual CultureInfo get_Locale();
    public abstract virtual void set_Locale(CultureInfo value);
    public abstract virtual TimeZoneInfo get_TimeZone();
    public abstract virtual void set_TimeZone(TimeZoneInfo value);
    public abstract virtual int get_PhraseSlop();
    public abstract virtual void set_PhraseSlop(int value);
    public abstract virtual Analyzer get_Analyzer();
    public abstract virtual float get_FuzzyMinSim();
    public abstract virtual void set_FuzzyMinSim(float value);
    public abstract virtual void SetDateResolution(DateResolution dateResolution);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Nodes.AbstractRangeQueryNode`1 : QueryNode {
    private bool lowerInclusive;
    private bool upperInclusive;
    public string Field { get; public set; }
    public IFieldableNode LowerBound { get; }
    public IFieldableNode UpperBound { get; }
    public bool IsLowerInclusive { get; }
    public bool IsUpperInclusive { get; }
    public virtual string get_Field();
    public virtual void set_Field(string value);
    public virtual IFieldableNode get_LowerBound();
    public virtual IFieldableNode get_UpperBound();
    public virtual bool get_IsLowerInclusive();
    public virtual bool get_IsUpperInclusive();
    public virtual void SetBounds(T lower, T upper, bool lowerInclusive, bool upperInclusive);
    public virtual string ToQueryString(IEscapeQuerySyntax escapeSyntaxParser);
    public virtual string ToString();
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Nodes.BooleanModifierNode : ModifierQueryNode {
    public BooleanModifierNode(IQueryNode node, Modifier mod);
}
public interface Lucene.Net.QueryParsers.Flexible.Standard.Nodes.IAbstractRangeQueryNode {
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Nodes.MultiPhraseQueryNode : QueryNode {
    public string Field { get; public set; }
    public virtual string ToString();
    public virtual string ToQueryString(IEscapeQuerySyntax escapeSyntaxParser);
    public virtual IQueryNode CloneTree();
    public virtual string get_Field();
    public virtual void set_Field(string value);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Nodes.NumericQueryNode : QueryNode {
    private NumberFormat numberFormat;
    private string field;
    private Number value;
    public string Field { get; public set; }
    public NumberFormat NumberFormat { get; public set; }
    public Number Value { get; public set; }
    public NumericQueryNode(string field, Number value, NumberFormat numberFormat);
    public virtual string get_Field();
    public virtual void set_Field(string value);
    protected string GetTermEscaped(IEscapeQuerySyntax escaper);
    public virtual string ToQueryString(IEscapeQuerySyntax escapeSyntaxParser);
    public virtual NumberFormat get_NumberFormat();
    public virtual void set_NumberFormat(NumberFormat value);
    public virtual Number get_Value();
    public virtual void set_Value(Number value);
    public virtual string ToString();
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Nodes.NumericRangeQueryNode : AbstractRangeQueryNode`1<NumericQueryNode> {
    private NumericConfig numericConfig;
    public NumericConfig NumericConfig { get; public set; }
    public NumericRangeQueryNode(NumericQueryNode lower, NumericQueryNode upper, bool lowerInclusive, bool upperInclusive, NumericConfig numericConfig);
    private static NumericType GetNumericDataType(Number number);
    public virtual void SetBounds(NumericQueryNode lower, NumericQueryNode upper, bool lowerInclusive, bool upperInclusive, NumericConfig numericConfig);
    public virtual NumericConfig get_NumericConfig();
    public virtual void set_NumericConfig(NumericConfig value);
    public virtual string ToString();
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Nodes.PrefixWildcardQueryNode : WildcardQueryNode {
    public PrefixWildcardQueryNode(string field, string text, int begin, int end);
    public PrefixWildcardQueryNode(string field, StringBuilder text, int begin, int end);
    public PrefixWildcardQueryNode(string field, ICharSequence text, int begin, int end);
    public PrefixWildcardQueryNode(FieldQueryNode fqn);
    public virtual string ToString();
    public virtual IQueryNode CloneTree();
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Nodes.RegexpQueryNode : QueryNode {
    private ICharSequence text;
    private string field;
    public ICharSequence Text { get; public set; }
    public string Field { get; public set; }
    public RegexpQueryNode(string field, string text, int begin, int end);
    public RegexpQueryNode(string field, StringBuilder text, int begin, int end);
    public RegexpQueryNode(string field, ICharSequence text, int begin, int end);
    public virtual BytesRef TextToBytesRef();
    public virtual string ToString();
    public virtual IQueryNode CloneTree();
    public virtual ICharSequence get_Text();
    public virtual void set_Text(ICharSequence value);
    public virtual string get_Field();
    public virtual void set_Field(string value);
    public virtual string GetFieldAsString();
    public virtual string ToQueryString(IEscapeQuerySyntax escapeSyntaxParser);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Nodes.StandardBooleanQueryNode : BooleanQueryNode {
    private bool disableCoord;
    public bool DisableCoord { get; }
    public StandardBooleanQueryNode(IList`1<IQueryNode> clauses, bool disableCoord);
    public virtual bool get_DisableCoord();
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Nodes.TermRangeQueryNode : AbstractRangeQueryNode`1<FieldQueryNode> {
    public TermRangeQueryNode(FieldQueryNode lower, FieldQueryNode upper, bool lowerInclusive, bool upperInclusive);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Nodes.WildcardQueryNode : FieldQueryNode {
    public WildcardQueryNode(string field, string text, int begin, int end);
    public WildcardQueryNode(string field, StringBuilder text, int begin, int end);
    public WildcardQueryNode(string field, ICharSequence text, int begin, int end);
    public WildcardQueryNode(FieldQueryNode fqn);
    public virtual string ToQueryString(IEscapeQuerySyntax escaper);
    public virtual string ToString();
    public virtual IQueryNode CloneTree();
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Parser.EscapeQuerySyntax : object {
    private static Char[] wildcardChars;
    private static String[] escapableTermExtraFirstChars;
    private static String[] escapableTermChars;
    private static String[] escapableQuotedChars;
    private static String[] escapableWhiteChars;
    private static String[] escapableWordTokens;
    private static EscapeQuerySyntax();
    private static ICharSequence EscapeChar(ICharSequence str, CultureInfo locale);
    private ICharSequence EscapeQuoted(ICharSequence str, CultureInfo locale);
    private static ICharSequence EscapeTerm(ICharSequence term, CultureInfo locale);
    private static ICharSequence ReplaceIgnoreCase(ICharSequence string, string sequence1, string escapeChar, CultureInfo locale);
    private static ICharSequence EscapeWhiteChar(ICharSequence str, CultureInfo locale);
    public virtual string Escape(string text, CultureInfo locale, EscapeQuerySyntaxType type);
    public virtual ICharSequence Escape(ICharSequence text, CultureInfo locale, EscapeQuerySyntaxType type);
    public static UnescapedCharSequence DiscardEscapeChar(string input);
    private static int HexToInt32(char c);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Parser.FastCharStream : object {
    private Char[] buffer;
    private int bufferLength;
    private int bufferPosition;
    private int tokenStart;
    private int bufferStart;
    private TextReader input;
    public int Column { get; }
    public int Line { get; }
    public int EndColumn { get; }
    public int EndLine { get; }
    public int BeginColumn { get; }
    public int BeginLine { get; }
    public FastCharStream(TextReader r);
    public sealed virtual char ReadChar();
    private void Refill();
    public sealed virtual char BeginToken();
    public sealed virtual void BackUp(int amount);
    public sealed virtual string GetImage();
    public sealed virtual Char[] GetSuffix(int len);
    public sealed virtual void Done();
    public sealed virtual int get_Column();
    public sealed virtual int get_Line();
    public sealed virtual int get_EndColumn();
    public sealed virtual int get_EndLine();
    public sealed virtual int get_BeginColumn();
    public sealed virtual int get_BeginLine();
}
public interface Lucene.Net.QueryParsers.Flexible.Standard.Parser.ICharStream {
    [ObsoleteAttribute]
public int Column { get; }
    [ObsoleteAttribute]
public int Line { get; }
    public int EndColumn { get; }
    public int EndLine { get; }
    public int BeginColumn { get; }
    public int BeginLine { get; }
    public abstract virtual char ReadChar();
    public abstract virtual int get_Column();
    public abstract virtual int get_Line();
    public abstract virtual int get_EndColumn();
    public abstract virtual int get_EndLine();
    public abstract virtual int get_BeginColumn();
    public abstract virtual int get_BeginLine();
    public abstract virtual void BackUp(int amount);
    public abstract virtual char BeginToken();
    public abstract virtual string GetImage();
    public abstract virtual Char[] GetSuffix(int len);
    public abstract virtual void Done();
}
public static class Lucene.Net.QueryParsers.Flexible.Standard.Parser.LexicalToken : object {
    public static int Boost;
    public static int Range;
    public static int DEFAULT;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Lucene.Net.QueryParsers.Flexible.Standard.Parser.ParseException : QueryNodeParseException {
    [CompilerGeneratedAttribute]
private Token <CurrentToken>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Int32[][] <ExpectedTokenSequences>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <TokenImage>k__BackingField;
    public Token CurrentToken { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[WritableArrayAttribute]
public Int32[][] ExpectedTokenSequences { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[WritableArrayAttribute]
public String[] TokenImage { get; private set; }
    [NullableContextAttribute("1")]
public ParseException(Token currentToken, Int32[][] expectedTokenSequences, String[] tokenImage);
    public ParseException(string message);
    public ParseException(string message, Exception innerException);
    [NullableContextAttribute("1")]
protected ParseException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Token get_CurrentToken();
    [CompilerGeneratedAttribute]
private void set_CurrentToken(Token value);
    [CompilerGeneratedAttribute]
public Int32[][] get_ExpectedTokenSequences();
    [CompilerGeneratedAttribute]
private void set_ExpectedTokenSequences(Int32[][] value);
    [CompilerGeneratedAttribute]
public String[] get_TokenImage();
    [CompilerGeneratedAttribute]
private void set_TokenImage(String[] value);
    [NullableContextAttribute("1")]
private static string Initialize(Token currentToken, IList`1<Int32[]> expectedTokenSequences, String[] tokenImage);
    [NullableContextAttribute("1")]
private static string AddEscapes(string str);
}
public static class Lucene.Net.QueryParsers.Flexible.Standard.Parser.RegexpToken : object {
    public static int EOF;
    public static int NUM_CHAR;
    public static int ESCAPED_CHAR;
    public static int TERM_START_CHAR;
    public static int TERM_CHAR;
    public static int WHITESPACE;
    public static int QUOTED_CHAR;
    public static int AND;
    public static int OR;
    public static int NOT;
    public static int PLUS;
    public static int MINUS;
    public static int LPAREN;
    public static int RPAREN;
    public static int OP_COLON;
    public static int OP_EQUAL;
    public static int OP_LESSTHAN;
    public static int OP_LESSTHANEQ;
    public static int OP_MORETHAN;
    public static int OP_MORETHANEQ;
    public static int CARAT;
    public static int QUOTED;
    public static int TERM;
    public static int FUZZY_SLOP;
    public static int REGEXPTERM;
    public static int RANGEIN_START;
    public static int RANGEEX_START;
    public static int NUMBER;
    public static int RANGE_TO;
    public static int RANGEIN_END;
    public static int RANGEEX_END;
    public static int RANGE_QUOTED;
    public static int RANGE_GOOP;
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Parser.StandardSyntaxParser : object {
    private static int CONJ_NONE;
    private static int CONJ_AND;
    private static int CONJ_OR;
    [CompilerGeneratedAttribute]
private StandardSyntaxParserTokenManager <TokenSource>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <Jj_nt>k__BackingField;
    private int jj_ntk;
    private Token jj_scanpos;
    private Token jj_lastpos;
    private int jj_la;
    private int jj_gen;
    private Int32[] jj_la1;
    private static UInt32[] jj_la1_0;
    private static Int32[] jj_la1_1;
    private JJCalls[] jj_2_rtns;
    private bool jj_rescan;
    private int jj_gc;
    private LookaheadSuccess jj_ls;
    private IList`1<Int32[]> jj_expentries;
    private Int32[] jj_expentry;
    private int jj_kind;
    private Int32[] jj_lasttokens;
    private int jj_endpos;
    public StandardSyntaxParserTokenManager TokenSource { get; public set; }
    public Token Token { get; public set; }
    public Token Jj_nt { get; public set; }
    private static StandardSyntaxParser();
    public StandardSyntaxParser(ICharStream stream);
    public StandardSyntaxParser(StandardSyntaxParserTokenManager tm);
    public sealed virtual IQueryNode Parse(string query, string field);
    public int Conjunction();
    public Modifier Modifiers();
    public IQueryNode TopLevelQuery(string field);
    public IQueryNode Query(string field);
    public IQueryNode DisjQuery(string field);
    public IQueryNode ConjQuery(string field);
    public IQueryNode ModClause(string field);
    public IQueryNode Clause(string field);
    public IQueryNode Term(string field);
    private bool Jj_2_1(int xla);
    private bool Jj_2_2(int xla);
    private bool Jj_3_2();
    private bool Jj_3R_12();
    private bool Jj_3R_11();
    private bool Jj_3_1();
    private bool Jj_3R_8();
    private bool Jj_3R_10();
    private bool Jj_3R_7();
    private bool Jj_3R_9();
    private bool Jj_3R_5();
    private bool Jj_3R_4();
    private bool Jj_3R_6();
    [CompilerGeneratedAttribute]
public StandardSyntaxParserTokenManager get_TokenSource();
    [CompilerGeneratedAttribute]
public void set_TokenSource(StandardSyntaxParserTokenManager value);
    [CompilerGeneratedAttribute]
public Token get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(Token value);
    [CompilerGeneratedAttribute]
public Token get_Jj_nt();
    [CompilerGeneratedAttribute]
public void set_Jj_nt(Token value);
    private static void Jj_la1_init_0();
    private static void Jj_la1_init_1();
    public void ReInit(ICharStream stream);
    public void ReInit(StandardSyntaxParserTokenManager tm);
    private Token Jj_consume_token(int kind);
    private bool Jj_scan_token(int kind);
    public Token GetNextToken();
    public Token GetToken(int index);
    private int Jj_ntk();
    private void Jj_add_error_token(int kind, int pos);
    public virtual ParseException GenerateParseException();
    public void Enable_tracing();
    public void Disable_tracing();
    private void Jj_rescan_token();
    private void Jj_save(int index, int xla);
}
public static class Lucene.Net.QueryParsers.Flexible.Standard.Parser.StandardSyntaxParserConstants : object {
    public static String[] TokenImage;
    private static StandardSyntaxParserConstants();
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Parser.StandardSyntaxParserTokenManager : object {
    private TextWriter debugStream;
    internal static UInt64[] jjbitVec0;
    internal static UInt64[] jjbitVec1;
    internal static UInt64[] jjbitVec3;
    internal static UInt64[] jjbitVec4;
    internal static Int32[] jjnextStates;
    public static String[] jjstrLiteralImages;
    public static String[] lexStateNames;
    public static Int32[] jjnewLexState;
    private static Int64[] jjtoToken;
    protected ICharStream m_input_stream;
    private UInt32[] jjrounds;
    private Int32[] jjstateSet;
    protected char m_curChar;
    internal int curLexState;
    internal int defaultLexState;
    internal int jjnewStateCnt;
    internal UInt32 jjround;
    internal int jjmatchedPos;
    internal int jjmatchedKind;
    public StandardSyntaxParserTokenManager(ICharStream stream);
    public StandardSyntaxParserTokenManager(ICharStream stream, int lexState);
    private static StandardSyntaxParserTokenManager();
    public void SetDebugStream(TextWriter ds);
    private int JjStopStringLiteralDfa_2(int pos, long active0);
    private int JjStartNfa_2(int pos, long active0);
    private int JjStopAtPos(int pos, int kind);
    private int JjMoveStringLiteralDfa0_2();
    private int JjMoveStringLiteralDfa1_2(long active0);
    private int JjMoveNfa_2(int startState, int curPos);
    private int JjMoveStringLiteralDfa0_0();
    private int JjMoveNfa_0(int startState, int curPos);
    private int JjStopStringLiteralDfa_1(int pos, long active0);
    private int JjStartNfa_1(int pos, long active0);
    private int JjMoveStringLiteralDfa0_1();
    private int JjMoveStringLiteralDfa1_1(long active0);
    private int JjStartNfaWithStates_1(int pos, int kind, int state);
    private int JjMoveNfa_1(int startState, int curPos);
    private static bool JjCanMove_0(int hiByte, int i1, int i2, ulong l1, ulong l2);
    private static bool JjCanMove_1(int hiByte, int i1, int i2, ulong l1, ulong l2);
    private static bool JjCanMove_2(int hiByte, int i1, int i2, ulong l1, ulong l2);
    public void ReInit(ICharStream stream);
    private void ReInitRounds();
    public void ReInit(ICharStream stream, int lexState);
    public void SwitchTo(int lexState);
    protected Token JjFillToken();
    public virtual Token GetNextToken();
    private void JjCheckNAdd(int state);
    private void JjAddStates(int start, int end);
    private void JjCheckNAddTwoStates(int state1, int state2);
    private void JjCheckNAddStates(int start, int end);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Parser.Token : object {
    [CompilerGeneratedAttribute]
private int <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BeginLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BeginColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Image>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <Next>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <SpecialToken>k__BackingField;
    public int Kind { get; public set; }
    public int BeginLine { get; public set; }
    public int BeginColumn { get; public set; }
    public int EndLine { get; public set; }
    public int EndColumn { get; public set; }
    public string Image { get; public set; }
    public Token Next { get; public set; }
    public Token SpecialToken { get; public set; }
    public object Value { get; }
    public Token(int kind);
    public Token(int kind, string image);
    [CompilerGeneratedAttribute]
public int get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(int value);
    [CompilerGeneratedAttribute]
public int get_BeginLine();
    [CompilerGeneratedAttribute]
public void set_BeginLine(int value);
    [CompilerGeneratedAttribute]
public int get_BeginColumn();
    [CompilerGeneratedAttribute]
public void set_BeginColumn(int value);
    [CompilerGeneratedAttribute]
public int get_EndLine();
    [CompilerGeneratedAttribute]
public void set_EndLine(int value);
    [CompilerGeneratedAttribute]
public int get_EndColumn();
    [CompilerGeneratedAttribute]
public void set_EndColumn(int value);
    [CompilerGeneratedAttribute]
public string get_Image();
    [CompilerGeneratedAttribute]
public void set_Image(string value);
    [CompilerGeneratedAttribute]
public Token get_Next();
    [CompilerGeneratedAttribute]
public void set_Next(Token value);
    [CompilerGeneratedAttribute]
public Token get_SpecialToken();
    [CompilerGeneratedAttribute]
public void set_SpecialToken(Token value);
    public virtual object get_Value();
    public virtual string ToString();
    public static Token NewToken(int ofKind, string image);
    public static Token NewToken(int ofKind);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Parser.TokenMgrError : Exception {
    internal static int LEXICAL_ERROR;
    internal static int STATIC_LEXER_ERROR;
    internal static int INVALID_LEXICAL_STATE;
    internal static int LOOP_DETECTED;
    internal int errorCode;
    public string Message { get; }
    public TokenMgrError(string message, int reason);
    public TokenMgrError(bool eofSeen, int lexState, int errorLine, int errorColumn, string errorAfter, char curChar, int reason);
    protected TokenMgrError(SerializationInfo info, StreamingContext context);
    protected static string AddEscapes(string str);
    protected static string LexicalError(bool eofSeen, int lexState, int errorLine, int errorColumn, string errorAfter, char curChar);
    public virtual string get_Message();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Processors.AllowLeadingWildcardProcessor : QueryNodeProcessor {
    public virtual IQueryNode Process(IQueryNode queryTree);
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
    protected virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Processors.AnalyzerQueryNodeProcessor : QueryNodeProcessor {
    private Analyzer analyzer;
    private bool positionIncrementsEnabled;
    private Operator defaultOperator;
    public virtual IQueryNode Process(IQueryNode queryTree);
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
    protected virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Processors.BooleanQuery2ModifierNodeProcessor : object {
    internal static string TAG_REMOVE;
    internal static string TAG_MODIFIER;
    internal static string TAG_BOOLEAN_ROOT;
    private QueryConfigHandler queryConfigHandler;
    private IList`1<IQueryNode> childrenBuffer;
    private bool usingAnd;
    public virtual IQueryNode Process(IQueryNode queryTree);
    protected virtual void ProcessChildren(IQueryNode queryTree);
    private IQueryNode ProcessIteration(IQueryNode queryTree);
    protected virtual void FillChildrenBufferAndApplyModifiery(IQueryNode parent);
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
    protected virtual bool IsDefaultBooleanQueryNode(IQueryNode toTest);
    private IQueryNode ApplyModifier(IQueryNode node, Modifier mod);
    protected virtual void TagModifierButDoNotOverride(IQueryNode node, Modifier mod);
    public virtual void SetQueryConfigHandler(QueryConfigHandler queryConfigHandler);
    public virtual QueryConfigHandler GetQueryConfigHandler();
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Processors.BooleanSingleChildOptimizationQueryNodeProcessor : QueryNodeProcessor {
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
    protected virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Processors.BoostQueryNodeProcessor : QueryNodeProcessor {
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
    protected virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Processors.DefaultPhraseSlopQueryNodeProcessor : QueryNodeProcessor {
    private bool processChildren;
    private int defaultPhraseSlop;
    public virtual IQueryNode Process(IQueryNode queryTree);
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
    protected virtual void ProcessChildren(IQueryNode queryTree);
    protected virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Processors.FuzzyQueryNodeProcessor : QueryNodeProcessor {
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
    protected virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
}
[ObsoleteAttribute("Use BooleanQuery2ModifierNodeProcessor instead")]
public class Lucene.Net.QueryParsers.Flexible.Standard.Processors.GroupQueryNodeProcessor : object {
    private IList`1<IQueryNode> queryNodeList;
    private bool latestNodeVerified;
    private QueryConfigHandler queryConfig;
    private bool usingAnd;
    public virtual IQueryNode Process(IQueryNode queryTree);
    private IQueryNode ApplyModifier(IQueryNode node, IQueryNode parent);
    private void ReadTree(IQueryNode node);
    private void ProcessNode(IQueryNode node);
    public virtual QueryConfigHandler GetQueryConfigHandler();
    public virtual void SetQueryConfigHandler(QueryConfigHandler queryConfigHandler);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Processors.LowercaseExpandedTermsQueryNodeProcessor : QueryNodeProcessor {
    public virtual IQueryNode Process(IQueryNode queryTree);
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
    protected virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Processors.MatchAllDocsQueryNodeProcessor : QueryNodeProcessor {
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
    protected virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Processors.MultiFieldQueryNodeProcessor : QueryNodeProcessor {
    private bool processChildren;
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    protected virtual void ProcessChildren(IQueryNode queryTree);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
    protected virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Processors.MultiTermRewriteMethodProcessor : QueryNodeProcessor {
    public static string TAG_ID;
    private static MultiTermRewriteMethodProcessor();
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
    protected virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Processors.NumericQueryNodeProcessor : QueryNodeProcessor {
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
    protected virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Processors.NumericRangeQueryNodeProcessor : QueryNodeProcessor {
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
    protected virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Processors.OpenRangeQueryNodeProcessor : QueryNodeProcessor {
    public static string OPEN_RANGE_TOKEN;
    private static OpenRangeQueryNodeProcessor();
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
    protected virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Processors.PhraseSlopQueryNodeProcessor : QueryNodeProcessor {
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
    protected virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Processors.RemoveEmptyNonLeafQueryNodeProcessor : QueryNodeProcessor {
    private List`1<IQueryNode> childrenBuffer;
    public virtual IQueryNode Process(IQueryNode queryTree);
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
    protected virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Processors.StandardQueryNodeProcessorPipeline : QueryNodeProcessorPipeline {
    public StandardQueryNodeProcessorPipeline(QueryConfigHandler queryConfig);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Processors.TermRangeQueryNodeProcessor : QueryNodeProcessor {
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
    protected virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.Processors.WildcardQueryNodeProcessor : QueryNodeProcessor {
    protected virtual IQueryNode PostProcessNode(IQueryNode node);
    private static bool IsWildcard(string text);
    private bool IsPrefixWildcard(string text);
    protected virtual IQueryNode PreProcessNode(IQueryNode node);
    protected virtual IList`1<IQueryNode> SetChildrenOrder(IList`1<IQueryNode> children);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.QueryParserUtil : object {
    public static Query Parse(String[] queries, String[] fields, Analyzer analyzer);
    public static Query Parse(string query, String[] fields, Occur[] flags, Analyzer analyzer);
    public static Query Parse(String[] queries, String[] fields, Occur[] flags, Analyzer analyzer);
    public static string Escape(string s);
}
public class Lucene.Net.QueryParsers.Flexible.Standard.StandardQueryParser : QueryParserHelper`1<Query> {
    public Operator DefaultOperator { get; public set; }
    public bool LowercaseExpandedTerms { get; public set; }
    public bool AllowLeadingWildcard { get; public set; }
    public bool EnablePositionIncrements { get; public set; }
    public RewriteMethod MultiTermRewriteMethod { get; public set; }
    public int FuzzyPrefixLength { get; public set; }
    public IDictionary`2<string, NumericConfig> NumericConfigMap { get; public set; }
    public CultureInfo Locale { get; public set; }
    public TimeZoneInfo TimeZone { get; public set; }
    public Analyzer Analyzer { get; public set; }
    public int PhraseSlop { get; public set; }
    public float FuzzyMinSim { get; public set; }
    public IDictionary`2<string, float> FieldsBoost { get; public set; }
    [ExceptionToNullableEnumConventionAttribute]
public Nullable`1<DateResolution> DateResolution { get; }
    public IDictionary`2<string, DateResolution> DateResolutionMap { get; public set; }
    public StandardQueryParser(Analyzer analyzer);
    public virtual string ToString();
    public virtual Query Parse(string query, string defaultField);
    public virtual Operator get_DefaultOperator();
    public virtual void set_DefaultOperator(Operator value);
    public virtual bool get_LowercaseExpandedTerms();
    public virtual void set_LowercaseExpandedTerms(bool value);
    public virtual bool get_AllowLeadingWildcard();
    public virtual void set_AllowLeadingWildcard(bool value);
    public virtual bool get_EnablePositionIncrements();
    public virtual void set_EnablePositionIncrements(bool value);
    public virtual RewriteMethod get_MultiTermRewriteMethod();
    public virtual void set_MultiTermRewriteMethod(RewriteMethod value);
    public virtual void SetMultiFields(String[] fields);
    public virtual String[] GetMultiFields();
    public virtual int get_FuzzyPrefixLength();
    public virtual void set_FuzzyPrefixLength(int value);
    public virtual IDictionary`2<string, NumericConfig> get_NumericConfigMap();
    public virtual void set_NumericConfigMap(IDictionary`2<string, NumericConfig> value);
    public virtual CultureInfo get_Locale();
    public virtual void set_Locale(CultureInfo value);
    public virtual TimeZoneInfo get_TimeZone();
    public virtual void set_TimeZone(TimeZoneInfo value);
    [ObsoleteAttribute("Use PhraseSlop property setter instead.")]
public virtual void SetDefaultPhraseSlop(int defaultPhraseSlop);
    public virtual Analyzer get_Analyzer();
    public virtual void set_Analyzer(Analyzer value);
    public virtual int get_PhraseSlop();
    public virtual void set_PhraseSlop(int value);
    public virtual float get_FuzzyMinSim();
    public virtual void set_FuzzyMinSim(float value);
    public virtual IDictionary`2<string, float> get_FieldsBoost();
    public virtual void set_FieldsBoost(IDictionary`2<string, float> value);
    public virtual void SetDateResolution(DateResolution dateResolution);
    public virtual Nullable`1<DateResolution> get_DateResolution();
    [ObsoleteAttribute("Use DateResolutionMap property instead.")]
public virtual void SetDateResolution(IDictionary`2<string, DateResolution> dateRes);
    public virtual IDictionary`2<string, DateResolution> get_DateResolutionMap();
    public virtual void set_DateResolutionMap(IDictionary`2<string, DateResolution> value);
}
[FlagsAttribute]
public enum Lucene.Net.QueryParsers.Simple.Operator : Enum {
    public int value__;
    public static Operator AND_OPERATOR;
    public static Operator NOT_OPERATOR;
    public static Operator OR_OPERATOR;
    public static Operator PREFIX_OPERATOR;
    public static Operator PHRASE_OPERATOR;
    public static Operator PRECEDENCE_OPERATORS;
    public static Operator ESCAPE_OPERATOR;
    public static Operator WHITESPACE_OPERATOR;
    public static Operator FUZZY_OPERATOR;
    public static Operator NEAR_OPERATOR;
}
public class Lucene.Net.QueryParsers.Simple.SimpleQueryParser : QueryBuilder {
    protected IDictionary`2<string, float> m_weights;
    protected Operator m_flags;
    private Occur defaultOperator;
    public Occur DefaultOperator { get; public set; }
    public SimpleQueryParser(Analyzer analyzer, string field);
    public SimpleQueryParser(Analyzer analyzer, IDictionary`2<string, float> weights);
    public SimpleQueryParser(Analyzer analyzer, IDictionary`2<string, float> weights, Operator flags);
    public Query Parse(string queryText);
    private void ParseSubQuery(State state);
    private void ConsumeSubQuery(State state);
    private void ConsumePhrase(State state);
    private void ConsumeToken(State state);
    private void BuildQueryTree(State state, Query branch);
    private int ParseFuzziness(State state);
    private bool TokenFinished(State state);
    protected virtual Query NewDefaultQuery(string text);
    protected virtual Query NewFuzzyQuery(string text, int fuzziness);
    protected virtual Query NewPhraseQuery(string text, int slop);
    protected virtual Query NewPrefixQuery(string text);
    protected virtual Query Simplify(BooleanQuery bq);
    public virtual Occur get_DefaultOperator();
    public virtual void set_DefaultOperator(Occur value);
}
public class Lucene.Net.QueryParsers.Surround.Parser.FastCharStream : object {
    internal Char[] buffer;
    internal int bufferLength;
    internal int bufferPosition;
    internal int tokenStart;
    internal int bufferStart;
    internal TextReader input;
    public string Image { get; }
    public int Column { get; }
    public int Line { get; }
    public int EndColumn { get; }
    public int EndLine { get; }
    public int BeginColumn { get; }
    public int BeginLine { get; }
    public FastCharStream(TextReader r);
    public sealed virtual char ReadChar();
    private void Refill();
    public sealed virtual char BeginToken();
    public sealed virtual void BackUp(int amount);
    public sealed virtual string get_Image();
    public sealed virtual Char[] GetSuffix(int len);
    public sealed virtual void Done();
    public sealed virtual int get_Column();
    public sealed virtual int get_Line();
    public sealed virtual int get_EndColumn();
    public sealed virtual int get_EndLine();
    public sealed virtual int get_BeginColumn();
    public sealed virtual int get_BeginLine();
}
public interface Lucene.Net.QueryParsers.Surround.Parser.ICharStream {
    [ObsoleteAttribute]
public int Column { get; }
    [ObsoleteAttribute]
public int Line { get; }
    public int EndColumn { get; }
    public int EndLine { get; }
    public int BeginColumn { get; }
    public int BeginLine { get; }
    public string Image { get; }
    public abstract virtual char ReadChar();
    public abstract virtual int get_Column();
    public abstract virtual int get_Line();
    public abstract virtual int get_EndColumn();
    public abstract virtual int get_EndLine();
    public abstract virtual int get_BeginColumn();
    public abstract virtual int get_BeginLine();
    public abstract virtual void BackUp(int amount);
    public abstract virtual char BeginToken();
    public abstract virtual string get_Image();
    public abstract virtual Char[] GetSuffix(int len);
    public abstract virtual void Done();
}
public static class Lucene.Net.QueryParsers.Surround.Parser.LexicalToken : object {
    public static int Boost;
    public static int DEFAULT;
}
public class Lucene.Net.QueryParsers.Surround.Parser.ParseException : Exception {
    [CompilerGeneratedAttribute]
private Token <CurrentToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[][] <ExpectedTokenSequences>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TokenImage>k__BackingField;
    protected static string eol;
    public Token CurrentToken { get; public set; }
    [WritableArrayAttribute]
public Int32[][] ExpectedTokenSequences { get; public set; }
    [WritableArrayAttribute]
public String[] TokenImage { get; public set; }
    public ParseException(Token currentToken, Int32[][] expectedTokenSequences, String[] tokenImage);
    public ParseException(string message);
    public ParseException(string message, Exception innerException);
    protected ParseException(SerializationInfo info, StreamingContext context);
    private static ParseException();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Token get_CurrentToken();
    [CompilerGeneratedAttribute]
public void set_CurrentToken(Token value);
    [CompilerGeneratedAttribute]
public Int32[][] get_ExpectedTokenSequences();
    [CompilerGeneratedAttribute]
public void set_ExpectedTokenSequences(Int32[][] value);
    [CompilerGeneratedAttribute]
public String[] get_TokenImage();
    [CompilerGeneratedAttribute]
public void set_TokenImage(String[] value);
    private static string Initialize(Token currentToken, Int32[][] expectedTokenSequences, String[] tokenImage);
    internal static string AddEscapes(string str);
}
public class Lucene.Net.QueryParsers.Surround.Parser.QueryParser : object {
    internal int minimumPrefixLength;
    internal int minimumCharsInTrunc;
    internal string truncationErrorMessage;
    internal string boostErrorMessage;
    internal char truncator;
    internal char anyChar;
    internal char quote;
    internal char fieldOperator;
    internal char comma;
    internal char carat;
    [CompilerGeneratedAttribute]
private QueryParserTokenManager <TokenSource>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <Jj_nt>k__BackingField;
    private int jj_ntk;
    private Token jj_scanpos;
    private Token jj_lastpos;
    private int jj_la;
    private int jj_gen;
    private Int32[] jj_la1;
    private static Int32[] jj_la1_0;
    private JJCalls[] jj_2_rtns;
    private bool jj_rescan;
    private int jj_gc;
    private LookaheadSuccess jj_ls;
    private IList`1<Int32[]> jj_expentries;
    private Int32[] jj_expentry;
    private int jj_kind;
    private Int32[] jj_lasttokens;
    private int jj_endpos;
    public QueryParserTokenManager TokenSource { get; public set; }
    public Token Token { get; public set; }
    public Token Jj_nt { get; public set; }
    public QueryParser(ICharStream stream);
    public QueryParser(QueryParserTokenManager tm);
    private static QueryParser();
    public static SrndQuery Parse(string query);
    public virtual SrndQuery Parse2(string query);
    protected virtual SrndQuery GetFieldsQuery(SrndQuery q, IList`1<string> fieldNames);
    protected virtual SrndQuery GetOrQuery(IList`1<SrndQuery> queries, bool infix, Token orToken);
    protected virtual SrndQuery GetAndQuery(IList`1<SrndQuery> queries, bool infix, Token andToken);
    protected virtual SrndQuery GetNotQuery(IList`1<SrndQuery> queries, Token notToken);
    protected static int GetOpDistance(string distanceOp);
    protected static void CheckDistanceSubQueries(DistanceQuery distq, string opName);
    protected virtual SrndQuery GetDistanceQuery(IList`1<SrndQuery> queries, bool infix, Token dToken, bool ordered);
    protected virtual SrndQuery GetTermQuery(string term, bool quoted);
    protected virtual bool AllowedSuffix(string suffixed);
    protected virtual SrndQuery GetPrefixQuery(string prefix, bool quoted);
    protected virtual bool AllowedTruncation(string truncated);
    protected virtual SrndQuery GetTruncQuery(string truncated);
    public SrndQuery TopSrndQuery();
    public SrndQuery FieldsQuery();
    public IList`1<string> OptionalFields();
    public SrndQuery OrQuery();
    public SrndQuery AndQuery();
    public SrndQuery NotQuery();
    public SrndQuery NQuery();
    public SrndQuery WQuery();
    public SrndQuery PrimaryQuery();
    public SrndQuery PrefixOperatorQuery();
    public IList`1<SrndQuery> FieldsQueryList();
    public SrndQuery SimpleTerm();
    public void OptionalWeights(SrndQuery q);
    private bool Jj_2_1(int xla);
    private bool Jj_3_1();
    [CompilerGeneratedAttribute]
public QueryParserTokenManager get_TokenSource();
    [CompilerGeneratedAttribute]
public void set_TokenSource(QueryParserTokenManager value);
    [CompilerGeneratedAttribute]
public Token get_Token();
    [CompilerGeneratedAttribute]
public void set_Token(Token value);
    [CompilerGeneratedAttribute]
public Token get_Jj_nt();
    [CompilerGeneratedAttribute]
public void set_Jj_nt(Token value);
    public virtual void ReInit(ICharStream stream);
    public virtual void ReInit(QueryParserTokenManager tm);
    private Token Jj_consume_token(int kind);
    private bool Jj_scan_token(int kind);
    public Token GetNextToken();
    public Token GetToken(int index);
    private int Jj_ntk();
    private void Jj_add_error_token(int kind, int pos);
    public virtual ParseException GenerateParseException();
    public void Enable_tracing();
    public void Disable_tracing();
    private void Jj_rescan_token();
    private void Jj_save(int index, int xla);
}
public static class Lucene.Net.QueryParsers.Surround.Parser.QueryParserConstants : object {
    public static String[] TokenImage;
    private static QueryParserConstants();
}
public class Lucene.Net.QueryParsers.Surround.Parser.QueryParserTokenManager : object {
    private TextWriter debugStream;
    internal static UInt64[] jjbitVec0;
    internal static UInt64[] jjbitVec2;
    internal static Int32[] jjnextStates;
    public static String[] jjstrLiteralImages;
    public static String[] lexStateNames;
    public static Int32[] jjnewLexState;
    internal static Int64[] jjtoToken;
    internal static Int64[] jjtoSkip;
    protected ICharStream m_input_stream;
    private UInt32[] jjrounds;
    private Int32[] jjstateSet;
    protected char m_curChar;
    internal int curLexState;
    internal int defaultLexState;
    internal int jjnewStateCnt;
    internal UInt32 jjround;
    internal int jjmatchedPos;
    internal int jjmatchedKind;
    public QueryParserTokenManager(ICharStream stream);
    public QueryParserTokenManager(ICharStream stream, int lexState);
    private static QueryParserTokenManager();
    public virtual void SetDebugStream(TextWriter ds);
    private int JjStopStringLiteralDfa_1(int pos, long active0);
    private int JjStartNfa_1(int pos, long active0);
    private int JjStopAtPos(int pos, int kind);
    private int jjMoveStringLiteralDfa0_1();
    private int JjMoveNfa_1(int startState, int curPos);
    private int JjMoveStringLiteralDfa0_0();
    private int JjMoveNfa_0(int startState, int curPos);
    private static bool JjCanMove_0(int hiByte, int i1, int i2, ulong l1, ulong l2);
    public void ReInit(ICharStream stream);
    private void ReInitRounds();
    public void ReInit(ICharStream stream, int lexState);
    public void SwitchTo(int lexState);
    protected Token JjFillToken();
    public virtual Token GetNextToken();
    private void JjCheckNAdd(int state);
    private void JjAddStates(int start, int end);
    private void JjCheckNAddTwoStates(int state1, int state2);
    private void JjCheckNAddStates(int start, int end);
}
public static class Lucene.Net.QueryParsers.Surround.Parser.RegexpToken : object {
    public static int EOF;
    public static int NUM_CHAR;
    public static int TERM_CHAR;
    public static int WHITESPACE;
    public static int STAR;
    public static int ONE_CHAR;
    public static int DISTOP_NUM;
    public static int OR;
    public static int AND;
    public static int NOT;
    public static int W;
    public static int N;
    public static int LPAREN;
    public static int RPAREN;
    public static int COMMA;
    public static int COLON;
    public static int CARAT;
    public static int TRUNCQUOTED;
    public static int QUOTED;
    public static int SUFFIXTERM;
    public static int TRUNCTERM;
    public static int TERM;
    public static int NUMBER;
}
public class Lucene.Net.QueryParsers.Surround.Parser.Token : object {
    [CompilerGeneratedAttribute]
private int <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BeginLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BeginColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Image>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <Next>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <SpecialToken>k__BackingField;
    public int Kind { get; public set; }
    public int BeginLine { get; public set; }
    public int BeginColumn { get; public set; }
    public int EndLine { get; public set; }
    public int EndColumn { get; public set; }
    public string Image { get; public set; }
    public Token Next { get; public set; }
    public Token SpecialToken { get; public set; }
    public object Value { get; }
    public Token(int kind);
    public Token(int kind, string image);
    [CompilerGeneratedAttribute]
public int get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(int value);
    [CompilerGeneratedAttribute]
public int get_BeginLine();
    [CompilerGeneratedAttribute]
public void set_BeginLine(int value);
    [CompilerGeneratedAttribute]
public int get_BeginColumn();
    [CompilerGeneratedAttribute]
public void set_BeginColumn(int value);
    [CompilerGeneratedAttribute]
public int get_EndLine();
    [CompilerGeneratedAttribute]
public void set_EndLine(int value);
    [CompilerGeneratedAttribute]
public int get_EndColumn();
    [CompilerGeneratedAttribute]
public void set_EndColumn(int value);
    [CompilerGeneratedAttribute]
public string get_Image();
    [CompilerGeneratedAttribute]
public void set_Image(string value);
    [CompilerGeneratedAttribute]
public Token get_Next();
    [CompilerGeneratedAttribute]
public void set_Next(Token value);
    [CompilerGeneratedAttribute]
public Token get_SpecialToken();
    [CompilerGeneratedAttribute]
public void set_SpecialToken(Token value);
    public virtual object get_Value();
    public virtual string ToString();
    public static Token NewToken(int ofKind, string image);
    public static Token NewToken(int ofKind);
}
public class Lucene.Net.QueryParsers.Surround.Parser.TokenMgrError : Exception {
    internal static int LEXICAL_ERROR;
    internal static int STATIC_LEXER_ERROR;
    internal static int INVALID_LEXICAL_STATE;
    internal static int LOOP_DETECTED;
    internal int errorCode;
    public string Message { get; }
    public TokenMgrError(string message, int reason);
    public TokenMgrError(bool EOFSeen, int lexState, int errorLine, int errorColumn, string errorAfter, char curChar, int reason);
    protected TokenMgrError(SerializationInfo info, StreamingContext context);
    protected internal static string AddEscapes(string str);
    protected internal static string LexicalError(bool eofSeen, int lexState, int errorLine, int errorColumn, string errorAfter, char curChar);
    public virtual string get_Message();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Lucene.Net.QueryParsers.Surround.Query.AndQuery : ComposedQuery {
    public AndQuery(IList`1<SrndQuery> queries, bool inf, string opName);
    public virtual Query MakeLuceneQueryFieldNoBoost(string fieldName, BasicQueryFactory qf);
}
public class Lucene.Net.QueryParsers.Surround.Query.BasicQueryFactory : object {
    private static object _lock;
    private int maxBasicQueries;
    private int queriesMade;
    public int NrQueriesMade { get; }
    public int MaxBasicQueries { get; }
    private bool AtMax { get; }
    public BasicQueryFactory(int maxBasicQueries);
    private static BasicQueryFactory();
    public virtual int get_NrQueriesMade();
    public virtual int get_MaxBasicQueries();
    public virtual string ToString();
    private bool get_AtMax();
    protected virtual void CheckMax();
    public virtual TermQuery NewTermQuery(Term term);
    public virtual SpanTermQuery NewSpanTermQuery(Term term);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public abstract class Lucene.Net.QueryParsers.Surround.Query.ComposedQuery : SrndQuery {
    protected string m_opName;
    protected IList`1<SrndQuery> m_queries;
    private bool operatorInfix;
    public string OperatorName { get; }
    public int NrSubQueries { get; }
    public bool IsOperatorInfix { get; }
    protected string PrefixSeparator { get; }
    protected string BracketOpen { get; }
    protected string BracketClose { get; }
    public bool IsFieldsSubQueryAcceptable { get; }
    protected ComposedQuery(IList`1<SrndQuery> qs, bool operatorInfix, string opName);
    protected virtual void Recompose(IList`1<SrndQuery> queries);
    public virtual string get_OperatorName();
    public virtual IEnumerator`1<SrndQuery> GetSubQueriesEnumerator();
    public virtual int get_NrSubQueries();
    public virtual SrndQuery GetSubQuery(int qn);
    public virtual bool get_IsOperatorInfix();
    public virtual IList`1<Query> MakeLuceneSubQueriesField(string fn, BasicQueryFactory qf);
    public virtual string ToString();
    protected virtual string get_PrefixSeparator();
    protected virtual string get_BracketOpen();
    protected virtual string get_BracketClose();
    protected virtual void InfixToString(StringBuilder r);
    protected virtual void PrefixToString(StringBuilder r);
    public virtual bool get_IsFieldsSubQueryAcceptable();
}
public class Lucene.Net.QueryParsers.Surround.Query.DistanceQuery : ComposedQuery {
    private int opDistance;
    private bool ordered;
    public int OpDistance { get; }
    public bool QueriesOrdered { get; }
    public DistanceQuery(IList`1<SrndQuery> queries, bool infix, int opDistance, string opName, bool ordered);
    public virtual int get_OpDistance();
    public virtual bool get_QueriesOrdered();
    public virtual string DistanceSubQueryNotAllowed();
    public virtual void AddSpanQueries(SpanNearClauseFactory sncf);
    public virtual Query GetSpanNearQuery(IndexReader reader, string fieldName, float boost, BasicQueryFactory qf);
    public virtual Query MakeLuceneQueryFieldNoBoost(string fieldName, BasicQueryFactory qf);
}
internal class Lucene.Net.QueryParsers.Surround.Query.DistanceRewriteQuery : RewriteQuery`1<DistanceQuery> {
    public DistanceRewriteQuery(DistanceQuery srndQuery, string fieldName, BasicQueryFactory qf);
    public virtual Query Rewrite(IndexReader reader);
}
public class Lucene.Net.QueryParsers.Surround.Query.FieldsQuery : SrndQuery {
    private SrndQuery q;
    private IList`1<string> fieldNames;
    private char fieldOp;
    private string orOperatorName;
    public bool IsFieldsSubQueryAcceptable { get; }
    public IList`1<string> FieldNames { get; }
    public char FieldOperator { get; }
    public FieldsQuery(SrndQuery q, IList`1<string> fieldNames, char fieldOp);
    public FieldsQuery(SrndQuery q, string fieldName, char fieldOp);
    public virtual bool get_IsFieldsSubQueryAcceptable();
    public virtual Query MakeLuceneQueryNoBoost(BasicQueryFactory qf);
    public virtual Query MakeLuceneQueryFieldNoBoost(string fieldName, BasicQueryFactory qf);
    public virtual IList`1<string> get_FieldNames();
    public virtual char get_FieldOperator();
    public virtual string ToString();
    protected virtual void FieldNamesToString(StringBuilder r);
}
public interface Lucene.Net.QueryParsers.Surround.Query.IDistanceSubQuery {
    public abstract virtual string DistanceSubQueryNotAllowed();
    public abstract virtual void AddSpanQueries(SpanNearClauseFactory sncf);
}
public class Lucene.Net.QueryParsers.Surround.Query.NotQuery : ComposedQuery {
    public NotQuery(IList`1<SrndQuery> queries, string opName);
    public virtual Query MakeLuceneQueryFieldNoBoost(string fieldName, BasicQueryFactory qf);
}
public class Lucene.Net.QueryParsers.Surround.Query.OrQuery : ComposedQuery {
    public OrQuery(IList`1<SrndQuery> queries, bool infix, string opName);
    public virtual Query MakeLuceneQueryFieldNoBoost(string fieldName, BasicQueryFactory qf);
    public virtual string DistanceSubQueryNotAllowed();
    public virtual void AddSpanQueries(SpanNearClauseFactory sncf);
}
internal abstract class Lucene.Net.QueryParsers.Surround.Query.RewriteQuery`1 : Query {
    protected SQ m_srndQuery;
    protected string m_fieldName;
    protected BasicQueryFactory m_qf;
    public RewriteQuery`1(SQ srndQuery, string fieldName, BasicQueryFactory qf);
    public abstract virtual Query Rewrite(IndexReader reader);
    public virtual string ToString();
    public virtual string ToString(string field);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual object Clone();
}
public abstract class Lucene.Net.QueryParsers.Surround.Query.SimpleTerm : SrndQuery {
    private bool quoted;
    internal bool IsQuoted { get; }
    public string Quote { get; }
    public string FieldOperator { get; }
    protected SimpleTerm(bool q);
    internal bool get_IsQuoted();
    public virtual string get_Quote();
    public virtual string get_FieldOperator();
    public abstract virtual string ToStringUnquoted();
    [ObsoleteAttribute("deprecated (March 2011) Not normally used, to be removed from Lucene 4.0. This class implementing Comparable is to be removed at the same time.")]
public sealed virtual int CompareTo(SimpleTerm ost);
    protected virtual void SuffixToString(StringBuilder r);
    public virtual string ToString();
    public abstract virtual void VisitMatchingTerms(IndexReader reader, string fieldName, IMatchingTermVisitor mtv);
    public virtual string DistanceSubQueryNotAllowed();
    public virtual void AddSpanQueries(SpanNearClauseFactory sncf);
    public virtual Query MakeLuceneQueryFieldNoBoost(string fieldName, BasicQueryFactory qf);
}
internal class Lucene.Net.QueryParsers.Surround.Query.SimpleTermRewriteQuery : RewriteQuery`1<SimpleTerm> {
    public SimpleTermRewriteQuery(SimpleTerm srndQuery, string fieldName, BasicQueryFactory qf);
    public virtual Query Rewrite(IndexReader reader);
}
public class Lucene.Net.QueryParsers.Surround.Query.SpanNearClauseFactory : object {
    private IndexReader reader;
    private string fieldName;
    private IDictionary`2<SpanQuery, float> weightBySpanQuery;
    private BasicQueryFactory qf;
    public IndexReader IndexReader { get; }
    public string FieldName { get; }
    public BasicQueryFactory BasicQueryFactory { get; }
    public int Count { get; }
    public SpanNearClauseFactory(IndexReader reader, string fieldName, BasicQueryFactory qf);
    public virtual IndexReader get_IndexReader();
    public virtual string get_FieldName();
    public virtual BasicQueryFactory get_BasicQueryFactory();
    public virtual int get_Count();
    public virtual void Clear();
    protected virtual void AddSpanQueryWeighted(SpanQuery sq, float weight);
    public virtual void AddTermWeighted(Term t, float weight);
    public virtual void AddSpanQuery(Query q);
    public virtual SpanQuery MakeSpanClause();
}
internal class Lucene.Net.QueryParsers.Surround.Query.SrndBooleanQuery : object {
    public static void AddQueriesToBoolean(BooleanQuery bq, IList`1<Query> queries, Occur occur);
    public static Query MakeBooleanQuery(IList`1<Query> queries, Occur occur);
}
public class Lucene.Net.QueryParsers.Surround.Query.SrndPrefixQuery : SimpleTerm {
    private BytesRef prefixRef;
    private string prefix;
    private char truncator;
    public string Prefix { get; }
    public char SuffixOperator { get; }
    public SrndPrefixQuery(string prefix, bool quoted, char truncator);
    public virtual string get_Prefix();
    public virtual char get_SuffixOperator();
    public virtual Term GetLucenePrefixTerm(string fieldName);
    public virtual string ToStringUnquoted();
    protected virtual void SuffixToString(StringBuilder r);
    public virtual void VisitMatchingTerms(IndexReader reader, string fieldName, IMatchingTermVisitor mtv);
}
public abstract class Lucene.Net.QueryParsers.Surround.Query.SrndQuery : object {
    private float weight;
    private bool weighted;
    public static Query TheEmptyLcnQuery;
    public bool IsWeighted { get; }
    public float Weight { get; public set; }
    public string WeightString { get; }
    public string WeightOperator { get; }
    public bool IsFieldsSubQueryAcceptable { get; }
    private static SrndQuery();
    public virtual bool get_IsWeighted();
    public virtual float get_Weight();
    public virtual void set_Weight(float value);
    public virtual string get_WeightString();
    public virtual string get_WeightOperator();
    protected virtual void WeightToString(StringBuilder r);
    public virtual Query MakeLuceneQueryField(string fieldName, BasicQueryFactory qf);
    public abstract virtual Query MakeLuceneQueryFieldNoBoost(string fieldName, BasicQueryFactory qf);
    public abstract virtual string ToString();
    public virtual bool get_IsFieldsSubQueryAcceptable();
    public virtual object Clone();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class Lucene.Net.QueryParsers.Surround.Query.SrndTermQuery : SimpleTerm {
    private string termText;
    public string TermText { get; }
    public SrndTermQuery(string termText, bool quoted);
    public virtual string get_TermText();
    public virtual Term GetLuceneTerm(string fieldName);
    public virtual string ToStringUnquoted();
    public virtual void VisitMatchingTerms(IndexReader reader, string fieldName, IMatchingTermVisitor mtv);
}
public class Lucene.Net.QueryParsers.Surround.Query.SrndTruncQuery : SimpleTerm {
    private string truncated;
    private char unlimited;
    private char mask;
    private string prefix;
    private BytesRef prefixRef;
    private Regex pattern;
    public string Truncated { get; }
    public SrndTruncQuery(string truncated, char unlimited, char mask);
    public virtual string get_Truncated();
    public virtual string ToStringUnquoted();
    protected virtual bool MatchingChar(char c);
    protected virtual void AppendRegExpForChar(char c, StringBuilder re);
    protected virtual void TruncatedToPrefixAndPattern();
    public virtual void VisitMatchingTerms(IndexReader reader, string fieldName, IMatchingTermVisitor mtv);
}
public class Lucene.Net.QueryParsers.Surround.Query.TooManyBasicQueries : IOException {
    public TooManyBasicQueries(int maxBasicQueries);
    internal TooManyBasicQueries(string message);
    protected TooManyBasicQueries(SerializationInfo info, StreamingContext context);
}
public class Lucene.Net.QueryParsers.Xml.Builders.BooleanFilterBuilder : object {
    private IFilterBuilder factory;
    public BooleanFilterBuilder(IFilterBuilder factory);
    public virtual Filter GetFilter(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.BooleanQueryBuilder : object {
    private IQueryBuilder factory;
    public BooleanQueryBuilder(IQueryBuilder factory);
    public virtual Query GetQuery(XmlElement e);
    internal static Occur GetOccursValue(XmlElement clauseElem);
}
public class Lucene.Net.QueryParsers.Xml.Builders.BoostingQueryBuilder : object {
    private static float DEFAULT_BOOST;
    private IQueryBuilder factory;
    public BoostingQueryBuilder(IQueryBuilder factory);
    public virtual Query GetQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.BoostingTermBuilder : SpanBuilderBase {
    public virtual SpanQuery GetSpanQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.CachedFilterBuilder : object {
    private QueryBuilderFactory queryFactory;
    private FilterBuilderFactory filterFactory;
    private LurchTable`2<object, Filter> filterCache;
    private int cacheSize;
    public CachedFilterBuilder(QueryBuilderFactory queryFactory, FilterBuilderFactory filterFactory, int cacheSize);
    public virtual Filter GetFilter(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.ConstantScoreQueryBuilder : object {
    private FilterBuilderFactory filterFactory;
    public ConstantScoreQueryBuilder(FilterBuilderFactory filterFactory);
    public virtual Query GetQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.DisjunctionMaxQueryBuilder : object {
    private IQueryBuilder factory;
    public DisjunctionMaxQueryBuilder(IQueryBuilder factory);
    public virtual Query GetQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.DuplicateFilterBuilder : object {
    public virtual Filter GetFilter(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.FilteredQueryBuilder : object {
    private IFilterBuilder filterFactory;
    private IQueryBuilder queryFactory;
    public FilteredQueryBuilder(IFilterBuilder filterFactory, IQueryBuilder queryFactory);
    public virtual Query GetQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.FuzzyLikeThisQueryBuilder : object {
    private static int DEFAULT_MAX_NUM_TERMS;
    private static float DEFAULT_MIN_SIMILARITY;
    private static int DEFAULT_PREFIX_LENGTH;
    private static bool DEFAULT_IGNORE_TF;
    private Analyzer analyzer;
    public FuzzyLikeThisQueryBuilder(Analyzer analyzer);
    public virtual Query GetQuery(XmlElement e);
}
public interface Lucene.Net.QueryParsers.Xml.Builders.ISpanQueryBuilder {
    public abstract virtual SpanQuery GetSpanQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.LikeThisQueryBuilder : object {
    private static int DEFAULT_MAX_QUERY_TERMS;
    private static int DEFAULT_MIN_TERM_FREQUENCY;
    private static float DEFAULT_PERCENT_TERMS_TO_MATCH;
    private Analyzer analyzer;
    private String[] defaultFieldNames;
    public LikeThisQueryBuilder(Analyzer analyzer, String[] defaultFieldNames);
    public virtual Query GetQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.MatchAllDocsQueryBuilder : object {
    public virtual Query GetQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.NumericRangeFilterBuilder : object {
    private static NoMatchFilter NO_MATCH_FILTER;
    private bool strictMode;
    private static NumericRangeFilterBuilder();
    public void SetStrictMode(bool strictMode);
    public virtual Filter GetFilter(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.NumericRangeQueryBuilder : object {
    public virtual Query GetQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.RangeFilterBuilder : object {
    public virtual Filter GetFilter(XmlElement e);
}
public abstract class Lucene.Net.QueryParsers.Xml.Builders.SpanBuilderBase : object {
    public virtual Query GetQuery(XmlElement e);
    public abstract virtual SpanQuery GetSpanQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.SpanFirstBuilder : SpanBuilderBase {
    private ISpanQueryBuilder factory;
    public SpanFirstBuilder(ISpanQueryBuilder factory);
    public virtual SpanQuery GetSpanQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.SpanNearBuilder : SpanBuilderBase {
    private ISpanQueryBuilder factory;
    public SpanNearBuilder(ISpanQueryBuilder factory);
    public virtual SpanQuery GetSpanQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.SpanNotBuilder : SpanBuilderBase {
    private ISpanQueryBuilder factory;
    public SpanNotBuilder(ISpanQueryBuilder factory);
    public virtual SpanQuery GetSpanQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.SpanOrBuilder : SpanBuilderBase {
    private ISpanQueryBuilder factory;
    public SpanOrBuilder(ISpanQueryBuilder factory);
    public virtual SpanQuery GetSpanQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.SpanOrTermsBuilder : SpanBuilderBase {
    private Analyzer analyzer;
    public SpanOrTermsBuilder(Analyzer analyzer);
    public virtual SpanQuery GetSpanQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.SpanQueryBuilderFactory : object {
    private IDictionary`2<string, ISpanQueryBuilder> builders;
    public virtual Query GetQuery(XmlElement e);
    public virtual void AddBuilder(string nodeName, ISpanQueryBuilder builder);
    public virtual SpanQuery GetSpanQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.SpanTermBuilder : SpanBuilderBase {
    public virtual SpanQuery GetSpanQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.TermQueryBuilder : object {
    public virtual Query GetQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.TermsFilterBuilder : object {
    private Analyzer analyzer;
    public TermsFilterBuilder(Analyzer analyzer);
    public virtual Filter GetFilter(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.TermsQueryBuilder : object {
    private Analyzer analyzer;
    public TermsQueryBuilder(Analyzer analyzer);
    public virtual Query GetQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.Builders.UserInputQueryBuilder : object {
    private QueryParser unSafeParser;
    private Analyzer analyzer;
    private string defaultField;
    public UserInputQueryBuilder(QueryParser parser);
    public UserInputQueryBuilder(string defaultField, Analyzer analyzer);
    public virtual Query GetQuery(XmlElement e);
    protected virtual QueryParser CreateQueryParser(string fieldName, Analyzer analyzer);
}
public class Lucene.Net.QueryParsers.Xml.CoreParser : object {
    protected Analyzer m_analyzer;
    protected QueryParser m_parser;
    protected QueryBuilderFactory m_queryFactory;
    protected FilterBuilderFactory m_filterFactory;
    public static int maxNumCachedFilters;
    public CoreParser(Analyzer analyzer, QueryParser parser);
    public CoreParser(string defaultField, Analyzer analyzer);
    protected CoreParser(string defaultField, Analyzer analyzer, QueryParser parser);
    private static CoreParser();
    public virtual Query Parse(Stream xmlStream);
    public virtual Query Parse(TextReader xmlTextReader);
    public virtual Query Parse(XmlReader xmlReader);
    public virtual Query Parse(XmlDocument xmlDocument);
    public virtual void AddQueryBuilder(string nodeName, IQueryBuilder builder);
    public virtual void AddFilterBuilder(string nodeName, IFilterBuilder builder);
    private static XmlDocument ParseXML(Stream pXmlFile);
    private static XmlDocument ParseXML(TextReader pXmlFile);
    private static XmlDocument ParseXML(XmlReader pXmlFile);
    public virtual Query GetQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.CorePlusExtensionsParser : CoreParser {
    public CorePlusExtensionsParser(Analyzer analyzer, QueryParser parser);
    public CorePlusExtensionsParser(string defaultField, Analyzer analyzer);
    private CorePlusExtensionsParser(string defaultField, Analyzer analyzer, QueryParser parser);
}
public static class Lucene.Net.QueryParsers.Xml.DOMUtils : object {
    public static XmlElement GetChildByTagOrFail(XmlElement e, string name);
    public static XmlElement GetFirstChildOrFail(XmlElement e);
    public static string GetAttributeOrFail(XmlElement e, string name);
    public static string GetAttributeWithInheritanceOrFail(XmlElement e, string name);
    public static string GetNonBlankTextOrFail(XmlElement e);
    public static XmlElement GetChildByTagName(XmlElement e, string name);
    public static string GetAttributeWithInheritance(XmlElement element, string attributeName);
    public static string GetChildTextByTagName(XmlElement e, string tagName);
    public static XmlElement InsertChild(XmlElement parent, string tagName, string text);
    public static string GetAttribute(XmlElement element, string attributeName, string deflt);
    public static float GetAttribute(XmlElement element, string attributeName, float deflt);
    public static int GetAttribute(XmlElement element, string attributeName, int deflt);
    public static bool GetAttribute(XmlElement element, string attributeName, bool deflt);
    public static string GetText(XmlNode e);
    public static XmlElement GetFirstChildElement(XmlElement element);
    private static void GetTextBuffer(XmlNode e, StringBuilder sb);
    public static XmlDocument LoadXML(TextReader input);
    public static XmlDocument LoadXML(Stream input);
    public static XmlDocument LoadXML(XmlReader input);
}
public class Lucene.Net.QueryParsers.Xml.FilterBuilderFactory : object {
    private IDictionary`2<string, IFilterBuilder> builders;
    public virtual Filter GetFilter(XmlElement n);
    public virtual void AddBuilder(string nodeName, IFilterBuilder builder);
    public virtual IFilterBuilder GetFilterBuilder(string nodeName);
}
public interface Lucene.Net.QueryParsers.Xml.IFilterBuilder {
    public abstract virtual Filter GetFilter(XmlElement e);
}
public interface Lucene.Net.QueryParsers.Xml.IQueryBuilder {
    public abstract virtual Query GetQuery(XmlElement e);
}
public class Lucene.Net.QueryParsers.Xml.ParserException : Exception {
    public ParserException(string message);
    public ParserException(string message, Exception cause);
    public ParserException(Exception cause);
    protected ParserException(SerializationInfo info, StreamingContext context);
}
public class Lucene.Net.QueryParsers.Xml.QueryBuilderFactory : object {
    private IDictionary`2<string, IQueryBuilder> builders;
    public virtual Query GetQuery(XmlElement n);
    public virtual void AddBuilder(string nodeName, IQueryBuilder builder);
    public virtual IQueryBuilder GetQueryBuilder(string nodeName);
}
public class Lucene.Net.QueryParsers.Xml.QueryTemplateManager : object {
    private IDictionary`2<string, XslCompiledTransform> compiledTemplatesCache;
    private XslCompiledTransform defaultCompiledTemplates;
    public QueryTemplateManager(Stream xslIs);
    public virtual void AddDefaultQueryTemplate(Stream xslIs);
    public virtual void AddQueryTemplate(string name, Stream xslIs);
    public virtual string GetQueryAsXmlString(IDictionary`2<string, string> formProperties, string queryTemplateName);
    public virtual XmlDocument GetQueryAsDOM(IDictionary`2<string, string> formProperties, string queryTemplateName);
    public virtual string GetQueryAsXmlString(IDictionary`2<string, string> formProperties);
    public virtual XmlDocument GetQueryAsDOM(IDictionary`2<string, string> formProperties);
    public static string GetQueryAsXmlString(IDictionary`2<string, string> formProperties, XslCompiledTransform template);
    public static string GetQueryAsXmlString(IDictionary`2<string, string> formProperties, Stream xslIs);
    public static XmlDocument GetQueryAsDOM(IDictionary`2<string, string> formProperties, XslCompiledTransform template);
    public static XmlDocument GetQueryAsDOM(IDictionary`2<string, string> formProperties, Stream xslIs);
    public static void TransformCriteria(IDictionary`2<string, string> formProperties, Stream xslIs, Stream result);
    public static void TransformCriteria(IDictionary`2<string, string> formProperties, XslCompiledTransform transformer, Stream result);
    public static XslCompiledTransform GetTemplates(Stream xslIs);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
