[DebuggerDisplayAttribute("Abbr {Label} => {Text}")]
public class Markdig.Extensions.Abbreviations.Abbreviation : LeafBlock {
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    public StringSlice Text;
    public SourceSpan LabelSpan;
    public string Label { get; public set; }
    public Abbreviation(BlockParser parser);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(string value);
}
public class Markdig.Extensions.Abbreviations.AbbreviationExtension : object {
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
[ExtensionAttribute]
public static class Markdig.Extensions.Abbreviations.AbbreviationHelper : object {
    private static object DocumentKey;
    private static AbbreviationHelper();
    [ExtensionAttribute]
public static bool HasAbbreviations(MarkdownDocument document);
    [ExtensionAttribute]
public static void AddAbbreviation(MarkdownDocument document, string label, Abbreviation abbr);
    [ExtensionAttribute]
public static Dictionary`2<string, Abbreviation> GetAbbreviations(MarkdownDocument document);
}
[DebuggerDisplayAttribute("{Abbreviation}")]
public class Markdig.Extensions.Abbreviations.AbbreviationInline : LeafInline {
    [CompilerGeneratedAttribute]
private Abbreviation <Abbreviation>k__BackingField;
    public Abbreviation Abbreviation { get; public set; }
    public AbbreviationInline(Abbreviation abbreviation);
    [CompilerGeneratedAttribute]
public Abbreviation get_Abbreviation();
    [CompilerGeneratedAttribute]
public void set_Abbreviation(Abbreviation value);
}
public class Markdig.Extensions.Abbreviations.AbbreviationParser : BlockParser {
    public virtual BlockState TryOpen(BlockProcessor processor);
    private void DocumentOnProcessInlinesBegin(InlineProcessor inlineProcessor, Inline inline);
    private static bool IsValidAbbreviation(string match, StringSlice content, int matchIndex);
}
public class Markdig.Extensions.Abbreviations.HtmlAbbreviationRenderer : HtmlObjectRenderer`1<AbbreviationInline> {
    protected virtual void Write(HtmlRenderer renderer, AbbreviationInline obj);
}
public class Markdig.Extensions.AutoIdentifiers.AutoIdentifierExtension : object {
    private static string AutoIdentifierKey;
    private HtmlRenderer stripRenderer;
    private StringWriter headingWriter;
    private AutoIdentifierOptions options;
    public AutoIdentifierExtension(AutoIdentifierOptions options);
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
    private void HeadingBlockParser_Closed(BlockProcessor processor, Block block);
    private void DocumentOnProcessInlinesBegin(InlineProcessor processor, Inline inline);
    private Inline CreateLinkInlineForHeading(InlineProcessor inlineState, LinkReferenceDefinition linkRef, Inline child);
    private void HeadingBlock_ProcessInlinesEnd(InlineProcessor processor, Inline inline);
}
[FlagsAttribute]
public enum Markdig.Extensions.AutoIdentifiers.AutoIdentifierOptions : Enum {
    public int value__;
    public static AutoIdentifierOptions None;
    public static AutoIdentifierOptions Default;
    public static AutoIdentifierOptions AutoLink;
    public static AutoIdentifierOptions AllowOnlyAscii;
    public static AutoIdentifierOptions GitHub;
}
public class Markdig.Extensions.AutoIdentifiers.HeadingLinkReferenceDefinition : LinkReferenceDefinition {
    [CompilerGeneratedAttribute]
private HeadingBlock <Heading>k__BackingField;
    public HeadingBlock Heading { get; public set; }
    [CompilerGeneratedAttribute]
public HeadingBlock get_Heading();
    [CompilerGeneratedAttribute]
public void set_Heading(HeadingBlock value);
}
public class Markdig.Extensions.AutoLinks.AutoLinkExtension : object {
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
public class Markdig.Extensions.AutoLinks.AutoLinkParser : InlineParser {
    private static bool IsValidPreviousCharacter(char c);
    public virtual bool Match(InlineProcessor processor, StringSlice& slice);
    private bool IsAutoLinkValidInCurrentContext(InlineProcessor processor, List`1& pendingEmphasis);
}
public class Markdig.Extensions.AutoLinks.NormalizeAutoLinkRenderer : NormalizeObjectRenderer`1<LinkInline> {
    public virtual bool Accept(RendererBase renderer, MarkdownObject obj);
    protected virtual void Write(NormalizeRenderer renderer, LinkInline obj);
}
public class Markdig.Extensions.Bootstrap.BootstrapExtension : object {
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
    private static void PipelineOnDocumentProcessed(MarkdownDocument document);
}
public class Markdig.Extensions.Citations.CitationExtension : object {
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
    private static string GetTag(EmphasisInline emphasisInline);
}
public class Markdig.Extensions.CustomContainers.CustomContainer : ContainerBlock {
    [CompilerGeneratedAttribute]
private string <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FencedCharCount>k__BackingField;
    [CompilerGeneratedAttribute]
private char <FencedChar>k__BackingField;
    public string Info { get; public set; }
    public string Arguments { get; public set; }
    public int FencedCharCount { get; public set; }
    public char FencedChar { get; public set; }
    public CustomContainer(BlockParser parser);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Info();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Info(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Arguments();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Arguments(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_FencedCharCount();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FencedCharCount(int value);
    [CompilerGeneratedAttribute]
public sealed virtual char get_FencedChar();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FencedChar(char value);
}
public class Markdig.Extensions.CustomContainers.CustomContainerExtension : object {
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
public class Markdig.Extensions.CustomContainers.CustomContainerInline : EmphasisInline {
}
public class Markdig.Extensions.CustomContainers.CustomContainerParser : FencedBlockParserBase`1<CustomContainer> {
    protected virtual CustomContainer CreateFencedBlock(BlockProcessor processor);
}
public class Markdig.Extensions.CustomContainers.HtmlCustomContainerInlineRenderer : HtmlObjectRenderer`1<CustomContainerInline> {
    protected virtual void Write(HtmlRenderer renderer, CustomContainerInline obj);
}
public class Markdig.Extensions.CustomContainers.HtmlCustomContainerRenderer : HtmlObjectRenderer`1<CustomContainer> {
    protected virtual void Write(HtmlRenderer renderer, CustomContainer obj);
}
public class Markdig.Extensions.DefinitionLists.DefinitionItem : ContainerBlock {
    [CompilerGeneratedAttribute]
private char <OpeningCharacter>k__BackingField;
    public char OpeningCharacter { get; public set; }
    public DefinitionItem(BlockParser parser);
    [CompilerGeneratedAttribute]
public char get_OpeningCharacter();
    [CompilerGeneratedAttribute]
public void set_OpeningCharacter(char value);
}
public class Markdig.Extensions.DefinitionLists.DefinitionList : ContainerBlock {
    public DefinitionList(BlockParser parser);
}
public class Markdig.Extensions.DefinitionLists.DefinitionListExtension : object {
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
public class Markdig.Extensions.DefinitionLists.DefinitionListParser : BlockParser {
    public virtual BlockState TryOpen(BlockProcessor processor);
    private static DefinitionList GetCurrentDefinitionList(ParagraphBlock paragraphBlock, ContainerBlock previousParent);
    public virtual BlockState TryContinue(BlockProcessor processor, Block block);
}
public class Markdig.Extensions.DefinitionLists.DefinitionTerm : LeafBlock {
    public DefinitionTerm(BlockParser parser);
}
public class Markdig.Extensions.DefinitionLists.HtmlDefinitionListRenderer : HtmlObjectRenderer`1<DefinitionList> {
    protected virtual void Write(HtmlRenderer renderer, DefinitionList list);
}
public class Markdig.Extensions.Diagrams.DiagramExtension : object {
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
public class Markdig.Extensions.Emoji.EmojiExtension : object {
    [CompilerGeneratedAttribute]
private bool <EnableSmiley>k__BackingField;
    public bool EnableSmiley { get; public set; }
    public EmojiExtension(bool enableSmiley);
    [CompilerGeneratedAttribute]
public bool get_EnableSmiley();
    [CompilerGeneratedAttribute]
public void set_EnableSmiley(bool value);
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
public class Markdig.Extensions.Emoji.EmojiInline : LiteralInline {
    [CompilerGeneratedAttribute]
private string <Match>k__BackingField;
    public string Match { get; public set; }
    public EmojiInline(string content);
    [CompilerGeneratedAttribute]
public string get_Match();
    [CompilerGeneratedAttribute]
public void set_Match(string value);
}
public class Markdig.Extensions.Emoji.EmojiParser : InlineParser {
    private static Dictionary`2<string, string> EmojiToUnicodeDefault;
    private static Dictionary`2<string, string> SmileyToEmojiDefault;
    private TextMatchHelper textMatchHelper;
    [CompilerGeneratedAttribute]
private bool <EnableSmiley>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <EmojiToUnicode>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <SmileyToEmoji>k__BackingField;
    public bool EnableSmiley { get; public set; }
    public Dictionary`2<string, string> EmojiToUnicode { get; }
    public Dictionary`2<string, string> SmileyToEmoji { get; }
    public EmojiParser(bool enableSmiley);
    private static EmojiParser();
    [CompilerGeneratedAttribute]
public bool get_EnableSmiley();
    [CompilerGeneratedAttribute]
public void set_EnableSmiley(bool value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_EmojiToUnicode();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_SmileyToEmoji();
    public virtual void Initialize();
    public virtual bool Match(InlineProcessor processor, StringSlice& slice);
}
public class Markdig.Extensions.EmphasisExtras.EmphasisExtraExtension : object {
    [CompilerGeneratedAttribute]
private EmphasisExtraOptions <Options>k__BackingField;
    public EmphasisExtraOptions Options { get; }
    public EmphasisExtraExtension(EmphasisExtraOptions options);
    [CompilerGeneratedAttribute]
public EmphasisExtraOptions get_Options();
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
    private string GetTag(EmphasisInline emphasisInline);
}
[FlagsAttribute]
public enum Markdig.Extensions.EmphasisExtras.EmphasisExtraOptions : Enum {
    public int value__;
    public static EmphasisExtraOptions Default;
    public static EmphasisExtraOptions Strikethrough;
    public static EmphasisExtraOptions Subscript;
    public static EmphasisExtraOptions Superscript;
    public static EmphasisExtraOptions Inserted;
    public static EmphasisExtraOptions Marked;
}
public class Markdig.Extensions.Figures.Figure : ContainerBlock {
    [CompilerGeneratedAttribute]
private int <OpeningCharacterCount>k__BackingField;
    [CompilerGeneratedAttribute]
private char <OpeningCharacter>k__BackingField;
    public int OpeningCharacterCount { get; public set; }
    public char OpeningCharacter { get; public set; }
    public Figure(BlockParser parser);
    [CompilerGeneratedAttribute]
public int get_OpeningCharacterCount();
    [CompilerGeneratedAttribute]
public void set_OpeningCharacterCount(int value);
    [CompilerGeneratedAttribute]
public char get_OpeningCharacter();
    [CompilerGeneratedAttribute]
public void set_OpeningCharacter(char value);
}
public class Markdig.Extensions.Figures.FigureBlockParser : BlockParser {
    public virtual BlockState TryOpen(BlockProcessor processor);
    public virtual BlockState TryContinue(BlockProcessor processor, Block block);
}
public class Markdig.Extensions.Figures.FigureCaption : LeafBlock {
    public FigureCaption(BlockParser parser);
}
public class Markdig.Extensions.Figures.FigureExtension : object {
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
public class Markdig.Extensions.Figures.HtmlFigureCaptionRenderer : HtmlObjectRenderer`1<FigureCaption> {
    protected virtual void Write(HtmlRenderer renderer, FigureCaption obj);
}
public class Markdig.Extensions.Figures.HtmlFigureRenderer : HtmlObjectRenderer`1<Figure> {
    protected virtual void Write(HtmlRenderer renderer, Figure obj);
}
public class Markdig.Extensions.Footers.FooterBlock : ContainerBlock {
    [CompilerGeneratedAttribute]
private char <OpeningCharacter>k__BackingField;
    public char OpeningCharacter { get; public set; }
    public FooterBlock(BlockParser parser);
    [CompilerGeneratedAttribute]
public char get_OpeningCharacter();
    [CompilerGeneratedAttribute]
public void set_OpeningCharacter(char value);
}
public class Markdig.Extensions.Footers.FooterBlockParser : BlockParser {
    public virtual BlockState TryOpen(BlockProcessor processor);
    public virtual BlockState TryContinue(BlockProcessor processor, Block block);
}
public class Markdig.Extensions.Footers.FooterExtension : object {
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
public class Markdig.Extensions.Footers.HtmlFooterBlockRenderer : HtmlObjectRenderer`1<FooterBlock> {
    protected virtual void Write(HtmlRenderer renderer, FooterBlock footer);
}
public class Markdig.Extensions.Footnotes.Footnote : ContainerBlock {
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<FootnoteLink> <Links>k__BackingField;
    public SourceSpan LabelSpan;
    [CompilerGeneratedAttribute]
private bool <IsLastLineEmpty>k__BackingField;
    public string Label { get; public set; }
    public int Order { get; public set; }
    public List`1<FootnoteLink> Links { get; private set; }
    internal bool IsLastLineEmpty { get; internal set; }
    public Footnote(BlockParser parser);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(string value);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(int value);
    [CompilerGeneratedAttribute]
public List`1<FootnoteLink> get_Links();
    [CompilerGeneratedAttribute]
private void set_Links(List`1<FootnoteLink> value);
    [CompilerGeneratedAttribute]
internal bool get_IsLastLineEmpty();
    [CompilerGeneratedAttribute]
internal void set_IsLastLineEmpty(bool value);
}
public class Markdig.Extensions.Footnotes.FootnoteExtension : object {
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
public class Markdig.Extensions.Footnotes.FootnoteGroup : ContainerBlock {
    [CompilerGeneratedAttribute]
private int <CurrentOrder>k__BackingField;
    internal int CurrentOrder { get; internal set; }
    public FootnoteGroup(BlockParser parser);
    [CompilerGeneratedAttribute]
internal int get_CurrentOrder();
    [CompilerGeneratedAttribute]
internal void set_CurrentOrder(int value);
}
public class Markdig.Extensions.Footnotes.FootnoteLink : Inline {
    [CompilerGeneratedAttribute]
private bool <IsBackLink>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private Footnote <Footnote>k__BackingField;
    public bool IsBackLink { get; public set; }
    public int Index { get; public set; }
    public Footnote Footnote { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsBackLink();
    [CompilerGeneratedAttribute]
public void set_IsBackLink(bool value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
public Footnote get_Footnote();
    [CompilerGeneratedAttribute]
public void set_Footnote(Footnote value);
}
public class Markdig.Extensions.Footnotes.FootnoteLinkReferenceDefinition : LinkReferenceDefinition {
    [CompilerGeneratedAttribute]
private Footnote <Footnote>k__BackingField;
    public Footnote Footnote { get; public set; }
    [CompilerGeneratedAttribute]
public Footnote get_Footnote();
    [CompilerGeneratedAttribute]
public void set_Footnote(Footnote value);
}
public class Markdig.Extensions.Footnotes.FootnoteParser : BlockParser {
    private static object DocumentKey;
    private static FootnoteParser();
    public virtual BlockState TryOpen(BlockProcessor processor);
    private BlockState TryOpen(BlockProcessor processor, bool isContinue);
    public virtual BlockState TryContinue(BlockProcessor processor, Block block);
    private void Document_ProcessInlinesEnd(InlineProcessor state, Inline inline);
    private static Inline CreateLinkToFootnote(InlineProcessor state, LinkReferenceDefinition linkRef, Inline child);
}
public class Markdig.Extensions.Footnotes.HtmlFootnoteGroupRenderer : HtmlObjectRenderer`1<FootnoteGroup> {
    [CompilerGeneratedAttribute]
private string <GroupClass>k__BackingField;
    public string GroupClass { get; public set; }
    [CompilerGeneratedAttribute]
public string get_GroupClass();
    [CompilerGeneratedAttribute]
public void set_GroupClass(string value);
    protected virtual void Write(HtmlRenderer renderer, FootnoteGroup footnotes);
}
public class Markdig.Extensions.Footnotes.HtmlFootnoteLinkRenderer : HtmlObjectRenderer`1<FootnoteLink> {
    [CompilerGeneratedAttribute]
private string <BackLinkString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FootnoteLinkClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FootnoteBackLinkClass>k__BackingField;
    public string BackLinkString { get; public set; }
    public string FootnoteLinkClass { get; public set; }
    public string FootnoteBackLinkClass { get; public set; }
    [CompilerGeneratedAttribute]
public string get_BackLinkString();
    [CompilerGeneratedAttribute]
public void set_BackLinkString(string value);
    [CompilerGeneratedAttribute]
public string get_FootnoteLinkClass();
    [CompilerGeneratedAttribute]
public void set_FootnoteLinkClass(string value);
    [CompilerGeneratedAttribute]
public string get_FootnoteBackLinkClass();
    [CompilerGeneratedAttribute]
public void set_FootnoteBackLinkClass(string value);
    protected virtual void Write(HtmlRenderer renderer, FootnoteLink link);
}
public class Markdig.Extensions.GenericAttributes.GenericAttributesExtension : object {
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
    private bool TryProcessAttributesForHeading(BlockProcessor processor, StringSlice& line, IBlock block);
}
public class Markdig.Extensions.GenericAttributes.GenericAttributesParser : InlineParser {
    public virtual bool Match(InlineProcessor processor, StringSlice& slice);
    public static bool TryParse(StringSlice& slice, HtmlAttributes& attributes);
    private static bool IsStartAttributeName(char c);
}
public class Markdig.Extensions.Hardlines.SoftlineBreakAsHardlineExtension : object {
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
[DebuggerDisplayAttribute("{ProjectKey}-{Issue}")]
public class Markdig.Extensions.JiraLinks.JiraLink : LinkInline {
    [CompilerGeneratedAttribute]
private StringSlice <ProjectKey>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSlice <Issue>k__BackingField;
    public StringSlice ProjectKey { get; public set; }
    public StringSlice Issue { get; public set; }
    [CompilerGeneratedAttribute]
public StringSlice get_ProjectKey();
    [CompilerGeneratedAttribute]
public void set_ProjectKey(StringSlice value);
    [CompilerGeneratedAttribute]
public StringSlice get_Issue();
    [CompilerGeneratedAttribute]
public void set_Issue(StringSlice value);
}
public class Markdig.Extensions.JiraLinks.JiraLinkExtension : object {
    private JiraLinkOptions _options;
    public JiraLinkExtension(JiraLinkOptions options);
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
public class Markdig.Extensions.JiraLinks.JiraLinkInlineParser : InlineParser {
    private JiraLinkOptions _options;
    private string _baseUrl;
    public JiraLinkInlineParser(JiraLinkOptions options);
    public virtual bool Match(InlineProcessor processor, StringSlice& slice);
}
public class Markdig.Extensions.JiraLinks.JiraLinkOptions : object {
    [CompilerGeneratedAttribute]
private string <BaseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BasePath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OpenInNewWindow>k__BackingField;
    public string BaseUrl { get; public set; }
    public string BasePath { get; public set; }
    public bool OpenInNewWindow { get; public set; }
    public JiraLinkOptions(string baseUrl);
    [CompilerGeneratedAttribute]
public string get_BaseUrl();
    [CompilerGeneratedAttribute]
public void set_BaseUrl(string value);
    [CompilerGeneratedAttribute]
public string get_BasePath();
    [CompilerGeneratedAttribute]
public void set_BasePath(string value);
    [CompilerGeneratedAttribute]
public bool get_OpenInNewWindow();
    [CompilerGeneratedAttribute]
public void set_OpenInNewWindow(bool value);
    public virtual string GetUrl();
}
public class Markdig.Extensions.JiraLinks.NormalizeJiraLinksRenderer : NormalizeObjectRenderer`1<JiraLink> {
    protected virtual void Write(NormalizeRenderer renderer, JiraLink obj);
}
public class Markdig.Extensions.ListExtras.ListExtraExtension : object {
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
public class Markdig.Extensions.ListExtras.ListExtraItemParser : OrderedListItemParser {
    public virtual bool TryParse(BlockProcessor state, char pendingBulletType, ListInfo& result);
}
public class Markdig.Extensions.Mathematics.HtmlMathBlockRenderer : HtmlObjectRenderer`1<MathBlock> {
    protected virtual void Write(HtmlRenderer renderer, MathBlock obj);
}
public class Markdig.Extensions.Mathematics.HtmlMathInlineRenderer : HtmlObjectRenderer`1<MathInline> {
    protected virtual void Write(HtmlRenderer renderer, MathInline obj);
}
public class Markdig.Extensions.Mathematics.MathBlock : FencedCodeBlock {
    public MathBlock(BlockParser parser);
}
public class Markdig.Extensions.Mathematics.MathBlockParser : FencedBlockParserBase`1<MathBlock> {
    [CompilerGeneratedAttribute]
private string <DefaultClass>k__BackingField;
    public string DefaultClass { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DefaultClass();
    [CompilerGeneratedAttribute]
public void set_DefaultClass(string value);
    protected virtual MathBlock CreateFencedBlock(BlockProcessor processor);
    private static bool NoInfoParser(BlockProcessor state, StringSlice& line, IFencedBlock fenced);
}
public class Markdig.Extensions.Mathematics.MathExtension : object {
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
public class Markdig.Extensions.Mathematics.MathInline : LeafInline {
    [CompilerGeneratedAttribute]
private char <Delimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DelimiterCount>k__BackingField;
    public StringSlice Content;
    public char Delimiter { get; public set; }
    public int DelimiterCount { get; public set; }
    [CompilerGeneratedAttribute]
public char get_Delimiter();
    [CompilerGeneratedAttribute]
public void set_Delimiter(char value);
    [CompilerGeneratedAttribute]
public int get_DelimiterCount();
    [CompilerGeneratedAttribute]
public void set_DelimiterCount(int value);
}
public class Markdig.Extensions.Mathematics.MathInlineParser : InlineParser {
    [CompilerGeneratedAttribute]
private string <DefaultClass>k__BackingField;
    public string DefaultClass { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DefaultClass();
    [CompilerGeneratedAttribute]
public void set_DefaultClass(string value);
    public virtual bool Match(InlineProcessor processor, StringSlice& slice);
}
public class Markdig.Extensions.MediaLinks.MediaLinkExtension : object {
    [CompilerGeneratedAttribute]
private MediaOptions <Options>k__BackingField;
    private static List`1<KnownProvider> KnownHosts;
    private static String[] SplitAnd;
    public MediaOptions Options { get; }
    public MediaLinkExtension(MediaOptions options);
    private static MediaLinkExtension();
    [CompilerGeneratedAttribute]
public MediaOptions get_Options();
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
    private bool TryLinkInlineRenderer(HtmlRenderer renderer, LinkInline linkInline);
    private static HtmlAttributes GetHtmlAttributes(LinkInline linkInline);
    private bool TryGuessAudioVideoFile(Uri uri, HtmlRenderer renderer, LinkInline linkInline);
    private bool TryRenderIframeFromKnownProviders(Uri uri, HtmlRenderer renderer, LinkInline linkInline);
    private static String[] SplitQuery(Uri uri);
    private static string YouTube(Uri uri);
    private static string Vimeo(Uri uri);
    private static string Odnoklassniki(Uri uri);
    private static string Yandex(Uri uri);
}
public class Markdig.Extensions.MediaLinks.MediaOptions : object {
    [CompilerGeneratedAttribute]
private string <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Class>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <ExtensionToMimeType>k__BackingField;
    public string Width { get; public set; }
    public string Height { get; public set; }
    public string Class { get; public set; }
    public Dictionary`2<string, string> ExtensionToMimeType { get; }
    [CompilerGeneratedAttribute]
public string get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(string value);
    [CompilerGeneratedAttribute]
public string get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(string value);
    [CompilerGeneratedAttribute]
public string get_Class();
    [CompilerGeneratedAttribute]
public void set_Class(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_ExtensionToMimeType();
}
public class Markdig.Extensions.NonAsciiNoEscape.NonAsciiNoEscapeExtension : object {
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
public class Markdig.Extensions.NoRefLinks.NoFollowLinksExtension : object {
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
public class Markdig.Extensions.PragmaLines.PragmaLineExtension : object {
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
    private static void PipelineOnDocumentProcessed(MarkdownDocument document);
    private static void AddPragmas(Block block, Int32& index);
    private static string GetPragmaId(Block block);
}
public class Markdig.Extensions.SelfPipeline.SelfPipelineExtension : object {
    public static string DefaultTag;
    [CompilerGeneratedAttribute]
private string <DefaultExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SelfPipelineHintTagStart>k__BackingField;
    public string DefaultExtensions { get; }
    public string SelfPipelineHintTagStart { get; }
    public SelfPipelineExtension(string tag, string defaultExtensions);
    [CompilerGeneratedAttribute]
public string get_DefaultExtensions();
    [CompilerGeneratedAttribute]
public string get_SelfPipelineHintTagStart();
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
    public MarkdownPipeline CreatePipelineFromInput(string inputText);
}
public class Markdig.Extensions.SmartyPants.HtmlSmartyPantRenderer : HtmlObjectRenderer`1<SmartyPant> {
    private static SmartyPantOptions DefaultOptions;
    private SmartyPantOptions options;
    public HtmlSmartyPantRenderer(SmartyPantOptions options);
    private static HtmlSmartyPantRenderer();
    protected virtual void Write(HtmlRenderer renderer, SmartyPant obj);
}
[DebuggerDisplayAttribute("SmartyPant {ToString()}")]
public class Markdig.Extensions.SmartyPants.SmartyPant : LeafInline {
    [CompilerGeneratedAttribute]
private char <OpeningCharacter>k__BackingField;
    [CompilerGeneratedAttribute]
private SmartyPantType <Type>k__BackingField;
    public char OpeningCharacter { get; public set; }
    public SmartyPantType Type { get; public set; }
    [CompilerGeneratedAttribute]
public char get_OpeningCharacter();
    [CompilerGeneratedAttribute]
public void set_OpeningCharacter(char value);
    [CompilerGeneratedAttribute]
public SmartyPantType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(SmartyPantType value);
    public virtual string ToString();
}
public class Markdig.Extensions.SmartyPants.SmartyPantOptions : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<SmartyPantType, string> <Mapping>k__BackingField;
    public Dictionary`2<SmartyPantType, string> Mapping { get; }
    [CompilerGeneratedAttribute]
public Dictionary`2<SmartyPantType, string> get_Mapping();
}
public class Markdig.Extensions.SmartyPants.SmartyPantsExtension : object {
    [CompilerGeneratedAttribute]
private SmartyPantOptions <Options>k__BackingField;
    public SmartyPantOptions Options { get; }
    public SmartyPantsExtension(SmartyPantOptions options);
    [CompilerGeneratedAttribute]
public SmartyPantOptions get_Options();
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
public class Markdig.Extensions.SmartyPants.SmartyPantsInlineParser : InlineParser {
    public virtual bool Match(InlineProcessor processor, StringSlice& slice);
    private ListSmartyPants GetOrCreateState(InlineProcessor processor);
    private void BlockOnProcessInlinesEnd(InlineProcessor processor, Inline inline);
    private sealed virtual override bool Markdig.Parsers.IPostInlineProcessor.PostProcess(InlineProcessor state, Inline root, Inline lastChild, int postInlineProcessorIndex, bool isFinalProcessing);
}
public enum Markdig.Extensions.SmartyPants.SmartyPantType : Enum {
    public int value__;
    public static SmartyPantType Quote;
    public static SmartyPantType LeftQuote;
    public static SmartyPantType RightQuote;
    public static SmartyPantType DoubleQuote;
    public static SmartyPantType LeftDoubleQuote;
    public static SmartyPantType RightDoubleQuote;
    public static SmartyPantType LeftAngleQuote;
    public static SmartyPantType RightAngleQuote;
    public static SmartyPantType Ellipsis;
    public static SmartyPantType Dash2;
    public static SmartyPantType Dash3;
}
public class Markdig.Extensions.Tables.GridTableExtension : object {
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
public class Markdig.Extensions.Tables.GridTableParser : BlockParser {
    public virtual BlockState TryOpen(BlockProcessor processor);
    public virtual BlockState TryContinue(BlockProcessor processor, Block block);
    private BlockState HandleNewRow(BlockProcessor processor, GridTableState tableState, Table gridTable);
    private static void SetRowSpanState(List`1<ColumnSlice> columns, StringSlice line, Boolean& isHeaderRow, Boolean& hasRowSpan);
    private static bool IsRowSeperator(StringSlice slice);
    private static void TerminateCurrentRow(BlockProcessor processor, GridTableState tableState, Table gridTable, bool isLastRow);
    private BlockState HandleContents(BlockProcessor processor, GridTableState tableState, Table gridTable);
    private static void SetColumnSpanState(List`1<ColumnSlice> columns, StringSlice line);
    private static bool CanContinueRow(List`1<ColumnSlice> columns);
    private static void Undo(BlockProcessor processor, GridTableState tableState, Table gridTable);
    public virtual bool Close(BlockProcessor processor, Block block);
}
internal class Markdig.Extensions.Tables.GridTableState : object {
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    public StringLineGroup Lines;
    [CompilerGeneratedAttribute]
private List`1<ColumnSlice> <ColumnSlices>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExpectRow>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartRowGroup>k__BackingField;
    public int Start { get; public set; }
    public List`1<ColumnSlice> ColumnSlices { get; private set; }
    public bool ExpectRow { get; public set; }
    public int StartRowGroup { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(int value);
    [CompilerGeneratedAttribute]
public List`1<ColumnSlice> get_ColumnSlices();
    [CompilerGeneratedAttribute]
private void set_ColumnSlices(List`1<ColumnSlice> value);
    [CompilerGeneratedAttribute]
public bool get_ExpectRow();
    [CompilerGeneratedAttribute]
public void set_ExpectRow(bool value);
    [CompilerGeneratedAttribute]
public int get_StartRowGroup();
    [CompilerGeneratedAttribute]
public void set_StartRowGroup(int value);
    public void AddLine(StringSlice& line);
    public void AddColumn(int start, int end, Nullable`1<TableColumnAlign> align);
}
public class Markdig.Extensions.Tables.HtmlTableRenderer : HtmlObjectRenderer`1<Table> {
    protected virtual void Write(HtmlRenderer renderer, Table table);
}
public class Markdig.Extensions.Tables.PipeTableBlockParser : BlockParser {
    public virtual BlockState TryOpen(BlockProcessor processor);
}
public class Markdig.Extensions.Tables.PipeTableDelimiterInline : DelimiterInline {
    [CompilerGeneratedAttribute]
private int <LocalLineIndex>k__BackingField;
    public int LocalLineIndex { get; public set; }
    public PipeTableDelimiterInline(InlineParser parser);
    [CompilerGeneratedAttribute]
public int get_LocalLineIndex();
    [CompilerGeneratedAttribute]
public void set_LocalLineIndex(int value);
    public virtual string ToLiteral();
}
public class Markdig.Extensions.Tables.PipeTableExtension : object {
    [CompilerGeneratedAttribute]
private PipeTableOptions <Options>k__BackingField;
    public PipeTableOptions Options { get; }
    public PipeTableExtension(PipeTableOptions options);
    [CompilerGeneratedAttribute]
public PipeTableOptions get_Options();
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
public class Markdig.Extensions.Tables.PipeTableOptions : object {
    [CompilerGeneratedAttribute]
private bool <RequireHeaderSeparator>k__BackingField;
    public bool RequireHeaderSeparator { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_RequireHeaderSeparator();
    [CompilerGeneratedAttribute]
public void set_RequireHeaderSeparator(bool value);
}
public class Markdig.Extensions.Tables.PipeTableParser : InlineParser {
    private LineBreakInlineParser lineBreakParser;
    [CompilerGeneratedAttribute]
private PipeTableOptions <Options>k__BackingField;
    public PipeTableOptions Options { get; }
    public PipeTableParser(LineBreakInlineParser lineBreakParser, PipeTableOptions options);
    [CompilerGeneratedAttribute]
public PipeTableOptions get_Options();
    public virtual bool Match(InlineProcessor processor, StringSlice& slice);
    public sealed virtual bool PostProcess(InlineProcessor state, Inline root, Inline lastChild, int postInlineProcessorIndex, bool isFinalProcessing);
    private static bool ParseHeaderString(Inline inline, Nullable`1& align);
    private List`1<TableColumnDefinition> FindHeaderRow(List`1<Inline> delimiters);
    private static bool IsLine(Inline inline);
    private static bool IsStartOfLineColumnDelimiter(Inline inline);
    private static void TrimStart(Inline inline);
    private static void TrimEnd(Inline inline);
    private static bool IsNullOrSpace(Inline inline);
}
public class Markdig.Extensions.Tables.Table : ContainerBlock {
    [CompilerGeneratedAttribute]
private List`1<TableColumnDefinition> <ColumnDefinitions>k__BackingField;
    public List`1<TableColumnDefinition> ColumnDefinitions { get; }
    public Table(BlockParser parser);
    [CompilerGeneratedAttribute]
public List`1<TableColumnDefinition> get_ColumnDefinitions();
    public bool IsValid();
    public void Normalize();
}
public class Markdig.Extensions.Tables.TableCell : ContainerBlock {
    [CompilerGeneratedAttribute]
private int <ColumnIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RowSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowClose>k__BackingField;
    public int ColumnIndex { get; public set; }
    public int ColumnSpan { get; public set; }
    public int RowSpan { get; public set; }
    public bool AllowClose { get; public set; }
    public TableCell(BlockParser parser);
    [CompilerGeneratedAttribute]
public int get_ColumnIndex();
    [CompilerGeneratedAttribute]
public void set_ColumnIndex(int value);
    [CompilerGeneratedAttribute]
public int get_ColumnSpan();
    [CompilerGeneratedAttribute]
public void set_ColumnSpan(int value);
    [CompilerGeneratedAttribute]
public int get_RowSpan();
    [CompilerGeneratedAttribute]
public void set_RowSpan(int value);
    [CompilerGeneratedAttribute]
public bool get_AllowClose();
    [CompilerGeneratedAttribute]
public void set_AllowClose(bool value);
}
public enum Markdig.Extensions.Tables.TableColumnAlign : Enum {
    public int value__;
    public static TableColumnAlign Left;
    public static TableColumnAlign Center;
    public static TableColumnAlign Right;
}
public class Markdig.Extensions.Tables.TableColumnDefinition : object {
    [CompilerGeneratedAttribute]
private float <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TableColumnAlign> <Alignment>k__BackingField;
    public float Width { get; public set; }
    public Nullable`1<TableColumnAlign> Alignment { get; public set; }
    [CompilerGeneratedAttribute]
public float get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(float value);
    [CompilerGeneratedAttribute]
public Nullable`1<TableColumnAlign> get_Alignment();
    [CompilerGeneratedAttribute]
public void set_Alignment(Nullable`1<TableColumnAlign> value);
}
public static class Markdig.Extensions.Tables.TableHelper : object {
    public static bool ParseColumnHeader(StringSlice& slice, char delimiterChar, Nullable`1& align);
    public static bool ParseColumnHeaderAuto(StringSlice& slice, Char& delimiterChar, Nullable`1& align);
    public static bool ParseColumnHeaderDetect(StringSlice& slice, Char& delimiterChar, Nullable`1& align);
}
public class Markdig.Extensions.Tables.TableRow : ContainerBlock {
    [CompilerGeneratedAttribute]
private bool <IsHeader>k__BackingField;
    public bool IsHeader { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsHeader();
    [CompilerGeneratedAttribute]
public void set_IsHeader(bool value);
}
public class Markdig.Extensions.TaskLists.HtmlTaskListRenderer : HtmlObjectRenderer`1<TaskList> {
    protected virtual void Write(HtmlRenderer renderer, TaskList obj);
}
public class Markdig.Extensions.TaskLists.NormalizeTaskListRenderer : NormalizeObjectRenderer`1<TaskList> {
    protected virtual void Write(NormalizeRenderer renderer, TaskList obj);
}
[DebuggerDisplayAttribute("TaskList {Checked}")]
public class Markdig.Extensions.TaskLists.TaskList : LeafInline {
    [CompilerGeneratedAttribute]
private bool <Checked>k__BackingField;
    public bool Checked { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Checked();
    [CompilerGeneratedAttribute]
public void set_Checked(bool value);
}
public class Markdig.Extensions.TaskLists.TaskListExtension : object {
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
public class Markdig.Extensions.TaskLists.TaskListInlineParser : InlineParser {
    [CompilerGeneratedAttribute]
private string <ListClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ListItemClass>k__BackingField;
    public string ListClass { get; public set; }
    public string ListItemClass { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ListClass();
    [CompilerGeneratedAttribute]
public void set_ListClass(string value);
    [CompilerGeneratedAttribute]
public string get_ListItemClass();
    [CompilerGeneratedAttribute]
public void set_ListItemClass(string value);
    public virtual bool Match(InlineProcessor processor, StringSlice& slice);
}
public class Markdig.Extensions.TextRenderer.ConfigureNewLineExtension : object {
    private string newLine;
    public ConfigureNewLineExtension(string newLine);
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
public class Markdig.Extensions.Yaml.YamlFrontMatterBlock : CodeBlock {
    public YamlFrontMatterBlock(BlockParser parser);
}
public class Markdig.Extensions.Yaml.YamlFrontMatterExtension : object {
    public sealed virtual void Setup(MarkdownPipelineBuilder pipeline);
    public sealed virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
public class Markdig.Extensions.Yaml.YamlFrontMatterParser : BlockParser {
    protected virtual YamlFrontMatterBlock CreateFrontMatterBlock(BlockProcessor processor);
    public virtual BlockState TryOpen(BlockProcessor processor);
    public virtual BlockState TryContinue(BlockProcessor processor, Block block);
}
public class Markdig.Extensions.Yaml.YamlFrontMatterRenderer : HtmlObjectRenderer`1<YamlFrontMatterBlock> {
    protected virtual void Write(HtmlRenderer renderer, YamlFrontMatterBlock obj);
}
public static class Markdig.Helpers.ArrayHelper`1 : object {
    public static T[] Empty;
    private static ArrayHelper`1();
}
[DefaultMemberAttribute("Item")]
public class Markdig.Helpers.CharacterMap`1 : object {
    private T[] asciiMap;
    private Dictionary`2<char, T> nonAsciiMap;
    private Boolean[] isOpeningCharacter;
    [CompilerGeneratedAttribute]
private Char[] <OpeningCharacters>k__BackingField;
    public Char[] OpeningCharacters { get; }
    public T Item { get; }
    public CharacterMap`1(IEnumerable`1<KeyValuePair`2<char, T>> maps);
    [CompilerGeneratedAttribute]
public Char[] get_OpeningCharacters();
    public T get_Item(char openingChar);
    public int IndexOfOpeningCharacter(string text, int start, int end);
}
[ExtensionAttribute]
public static class Markdig.Helpers.CharHelper : object {
    public static int TabSize;
    public static char ZeroSafeChar;
    public static string ZeroSafeString;
    private static IDictionary`2<char, int> romanMap;
    private static Char[] punctuationExceptions;
    private static CharHelper();
    public static void CheckOpenCloseDelimiter(char pc, char c, bool enableWithinWord, Boolean& canOpen, Boolean& canClose);
    public static bool IsRomanLetterPartial(char c);
    public static bool IsRomanLetterLowerPartial(char c);
    public static bool IsRomanLetterUpperPartial(char c);
    public static int RomanToArabic(string text);
    public static int AddTab(int column);
    public static bool IsAcrossTab(int column);
    [ExtensionAttribute]
public static bool Contains(Char[] charList, char c);
    [ExtensionAttribute]
public static bool IsWhitespace(char c);
    [ExtensionAttribute]
public static bool IsControl(char c);
    [ExtensionAttribute]
public static bool IsEscapableSymbol(char c);
    [ExtensionAttribute]
public static bool IsWhiteSpaceOrZero(char c);
    [ExtensionAttribute]
public static void CheckUnicodeCategory(char c, Boolean& space, Boolean& punctuation);
    [ExtensionAttribute]
public static bool IsNewLine(char c);
    [ExtensionAttribute]
public static bool IsZero(char c);
    [ExtensionAttribute]
public static bool IsSpace(char c);
    [ExtensionAttribute]
public static bool IsTab(char c);
    [ExtensionAttribute]
public static bool IsSpaceOrTab(char c);
    [ExtensionAttribute]
public static char EscapeInsecure(char c);
    [ExtensionAttribute]
public static bool IsAlphaUpper(char c);
    [ExtensionAttribute]
public static bool IsAlpha(char c);
    [ExtensionAttribute]
public static bool IsAlphaNumeric(char c);
    [ExtensionAttribute]
public static bool IsDigit(char c);
    [ExtensionAttribute]
public static bool IsAsciiPunctuation(char c);
    public static bool IsEmailUsernameSpecialChar(char c);
}
public static class Markdig.Helpers.CharNormalizer : object {
    private static Dictionary`2<char, string> CodeToAscii;
    private static CharNormalizer();
    public static string ConvertToAscii(char c);
}
public abstract class Markdig.Helpers.DefaultObjectCache`1 : ObjectCache`1<T> {
    protected virtual T NewInstance();
}
public static class Markdig.Helpers.EntityHelper : object {
    private static Dictionary`2<string, string> EntityMap;
    private static EntityHelper();
    public static string DecodeEntity(string entity);
    public static string DecodeEntity(int utf32);
}
public static class Markdig.Helpers.HtmlHelper : object {
    private static Char[] SearchBackAndAmp;
    private static Char[] SearchAmp;
    private static String[] EscapeUrlsForAscii;
    private static HtmlHelper();
    public static string EscapeUrlCharacter(char c);
    public static bool TryParseHtmlTag(StringSlice text, String& htmlTag);
    public static bool TryParseHtmlTag(StringSlice& text, String& htmlTag);
    public static bool TryParseHtmlTag(StringSlice& text, StringBuilder builder);
    internal static bool TryParseHtmlTagOpenTag(StringSlice& text, StringBuilder builder);
    private static bool TryParseHtmlTagDeclaration(StringSlice& text, StringBuilder builder);
    private static bool TryParseHtmlTagCData(StringSlice& text, StringBuilder builder);
    internal static bool TryParseHtmlCloseTag(StringSlice& text, StringBuilder builder);
    private static bool TryParseHtmlTagHtmlComment(StringSlice& text, StringBuilder builder);
    private static bool TryParseHtmlTagProcessingInstruction(StringSlice& text, StringBuilder builder);
    public static string Unescape(string text, bool removeBackSlash);
    public static int ScanEntity(T slice, Int32& numericEntity, Int32& namedEntityStart, Int32& namedEntityLength);
}
public interface Markdig.Helpers.ICharIterator {
    public int Start { get; }
    public char CurrentChar { get; }
    public int End { get; }
    public bool IsEmpty { get; }
    public abstract virtual int get_Start();
    public abstract virtual char get_CurrentChar();
    public abstract virtual int get_End();
    public abstract virtual char NextChar();
    public abstract virtual char PeekChar(int offset);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool TrimStart();
}
public class Markdig.Helpers.LineReader : ValueType {
    private string text;
    [CompilerGeneratedAttribute]
private int <SourcePosition>k__BackingField;
    public int SourcePosition { get; private set; }
    public LineReader(string text);
    [CompilerGeneratedAttribute]
public int get_SourcePosition();
    [CompilerGeneratedAttribute]
private void set_SourcePosition(int value);
    public Nullable`1<StringSlice> ReadLine();
}
public static class Markdig.Helpers.LinkHelper : object {
    public static bool TryParseAutolink(StringSlice text, String& link, Boolean& isEmail);
    public static string Urilize(string headingText, bool allowOnlyAscii, bool keepOpeningDigits);
    public static string UrilizeAsGfm(string headingText);
    private static bool IsReservedPunctuation(char c);
    public static bool TryParseAutolink(StringSlice& text, String& link, Boolean& isEmail);
    public static bool TryParseInlineLink(StringSlice text, String& link, String& title);
    public static bool TryParseInlineLink(StringSlice text, String& link, String& title, SourceSpan& linkSpan, SourceSpan& titleSpan);
    public static bool TryParseInlineLink(StringSlice& text, String& link, String& title);
    public static bool TryParseInlineLink(StringSlice& text, String& link, String& title, SourceSpan& linkSpan, SourceSpan& titleSpan);
    public static bool TryParseTitle(T text, String& title);
    public static bool TryParseTitle(T& text, String& title);
    public static bool TryParseUrl(T text, String& link);
    public static bool TryParseUrl(T& text, String& link, bool isAutoLink);
    private static bool IsTrailingUrlStopCharacter(char c);
    private static bool IsEndOfUri(char c, bool isAutoLink);
    public static bool TryParseLinkReferenceDefinition(T text, String& label, String& url, String& title);
    public static bool TryParseLinkReferenceDefinition(T& text, String& label, String& url, String& title);
    public static bool TryParseLinkReferenceDefinition(T& text, String& label, String& url, String& title, SourceSpan& labelSpan, SourceSpan& urlSpan, SourceSpan& titleSpan);
    public static bool TryParseLabel(T lines, String& label);
    public static bool TryParseLabel(T lines, String& label, SourceSpan& labelSpan);
    public static bool TryParseLabel(T& lines, String& label);
    public static bool TryParseLabel(T& lines, String& label, SourceSpan& labelSpan);
    public static bool TryParseLabel(T& lines, bool allowEmpty, String& label, SourceSpan& labelSpan);
}
internal static class Markdig.Helpers.MethodImplOptionPortable : object {
    public static MethodImplOptions AggressiveInlining;
}
public abstract class Markdig.Helpers.ObjectCache`1 : object {
    private Stack`1<T> builders;
    public void Clear();
    public T Get();
    public void Release(T instance);
    protected abstract virtual T NewInstance();
    protected abstract virtual void Reset(T instance);
}
public class Markdig.Helpers.OrderedList`1 : List`1<T> {
    public OrderedList`1(IEnumerable`1<T> collection);
    public bool InsertBefore(T element);
    public TElement Find();
    public TElement FindExact();
    public void AddIfNotAlready();
    public void AddIfNotAlready(TElement telement);
    public bool InsertAfter(T element);
    public bool Contains();
    public bool Replace(T replacement);
}
public class Markdig.Helpers.StringBuilderCache : DefaultObjectCache`1<StringBuilder> {
    [ThreadStaticAttribute]
private static StringBuilder local;
    public static StringBuilder Local();
    protected virtual void Reset(StringBuilder instance);
}
[ExtensionAttribute]
public static class Markdig.Helpers.StringBuilderExtensions : object {
    [ExtensionAttribute]
public static StringBuilder Append(StringBuilder builder, StringSlice slice);
}
public class Markdig.Helpers.StringLine : ValueType {
    public StringSlice Slice;
    public int Line;
    public int Position;
    public int Column;
    public StringLine(StringSlice& slice);
    public StringLine(StringSlice slice, int line, int column, int position);
    public StringLine(StringSlice& slice, int line, int column, int position);
    public static StringSlice op_Implicit(StringLine line);
    public virtual string ToString();
}
public class Markdig.Helpers.StringLineGroup : ValueType {
    [CompilerGeneratedAttribute]
private StringLine[] <Lines>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public StringLine[] Lines { get; private set; }
    public int Count { get; private set; }
    public StringLineGroup(int capacity);
    public StringLineGroup(string text);
    [CompilerGeneratedAttribute]
public StringLine[] get_Lines();
    [CompilerGeneratedAttribute]
private void set_Lines(StringLine[] value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public void Clear();
    public void RemoveAt(int index);
    public void Add(StringLine& line);
    public void Add(StringSlice slice);
    public virtual string ToString();
    public StringSlice ToSlice(List`1<LineOffset> lineOffsets);
    public Iterator ToCharIterator();
    public void Trim();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void IncreaseCapacity();
}
[DefaultMemberAttribute("Item")]
public class Markdig.Helpers.StringSlice : ValueType {
    public static StringSlice Empty;
    public string Text;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <End>k__BackingField;
    public int Start { get; public set; }
    public int End { get; public set; }
    public int Length { get; }
    public char CurrentChar { get; }
    public bool IsEmpty { get; }
    public char Item { get; }
    public StringSlice(string text);
    public StringSlice(string text, int start, int end);
    private static StringSlice();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_End();
    [CompilerGeneratedAttribute]
public void set_End(int value);
    public int get_Length();
    public sealed virtual char get_CurrentChar();
    public sealed virtual bool get_IsEmpty();
    public char get_Item(int index);
    public sealed virtual char NextChar();
    public sealed virtual char PeekChar(int offset);
    public char PeekCharAbsolute(int index);
    public char PeekCharExtra(int offset);
    public bool Match(string text, int offset);
    public bool Match(string text, int end, int offset);
    public bool SkipSpacesToEndOfLineOrEndOfDocument();
    public bool MatchLowercase(string text, int offset);
    public bool MatchLowercase(string text, int end, int offset);
    public int IndexOf(string text, int offset, bool ignoreCase);
    public int IndexOf(char c);
    public sealed virtual bool TrimStart();
    public void TrimStart(Int32& spaceCount);
    public bool TrimEnd();
    public void Trim();
    public virtual string ToString();
    public bool IsEmptyOrWhitespace();
}
public class Markdig.Helpers.TextMatchHelper : object {
    private CharNode root;
    private ListCache listCache;
    public TextMatchHelper(HashSet`1<string> matches);
    public bool TryMatch(string text, int offset, int length, String& match);
    private void BuildMap(CharNode node, int index, List`1<string> list);
}
public interface Markdig.IMarkdownExtension {
    public abstract virtual void Setup(MarkdownPipelineBuilder pipeline);
    public abstract virtual void Setup(MarkdownPipeline pipeline, IMarkdownRenderer renderer);
}
public static class Markdig.Markdown : object {
    public static string Version;
    private static Markdown();
    public static string Normalize(string markdown, NormalizeOptions options, MarkdownPipeline pipeline);
    public static MarkdownDocument Normalize(string markdown, TextWriter writer, NormalizeOptions options, MarkdownPipeline pipeline);
    public static string ToHtml(string markdown, MarkdownPipeline pipeline);
    public static MarkdownDocument ToHtml(string markdown, TextWriter writer, MarkdownPipeline pipeline);
    public static object Convert(string markdown, IMarkdownRenderer renderer, MarkdownPipeline pipeline);
    public static MarkdownDocument Parse(string markdown);
    public static MarkdownDocument Parse(string markdown, MarkdownPipeline pipeline);
    private static MarkdownPipeline CheckForSelfPipeline(MarkdownPipeline pipeline, string markdown);
    public static MarkdownDocument ToPlainText(string markdown, TextWriter writer, MarkdownPipeline pipeline);
    public static string ToPlainText(string markdown, MarkdownPipeline pipeline);
}
[ExtensionAttribute]
public static class Markdig.MarkdownExtensions : object {
    [ExtensionAttribute]
public static MarkdownPipelineBuilder Use(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder Use(MarkdownPipelineBuilder pipeline, TExtension extension);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseAdvancedExtensions(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseAutoLinks(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseNonAsciiNoEscape(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseYamlFrontMatter(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseSelfPipeline(MarkdownPipelineBuilder pipeline, string defaultTag, string defaultExtensions);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UsePragmaLines(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseDiagrams(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UsePreciseSourceLocation(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseTaskLists(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseCustomContainers(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseMediaLinks(MarkdownPipelineBuilder pipeline, MediaOptions options);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseAutoIdentifiers(MarkdownPipelineBuilder pipeline, AutoIdentifierOptions options);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseSmartyPants(MarkdownPipelineBuilder pipeline, SmartyPantOptions options);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseBootstrap(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseMathematics(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseFigures(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseAbbreviations(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseDefinitionLists(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UsePipeTables(MarkdownPipelineBuilder pipeline, PipeTableOptions options);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseGridTables(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseCitations(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseFooters(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseFootnotes(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseSoftlineBreakAsHardlineBreak(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseEmphasisExtras(MarkdownPipelineBuilder pipeline, EmphasisExtraOptions options);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseListExtras(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseGenericAttributes(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseEmojiAndSmiley(MarkdownPipelineBuilder pipeline, bool enableSmiley);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseNoFollowLinks(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder UseJiraLinks(MarkdownPipelineBuilder pipeline, JiraLinkOptions options);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder DisableHtml(MarkdownPipelineBuilder pipeline);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder Configure(MarkdownPipelineBuilder pipeline, string extensions);
    [ExtensionAttribute]
public static MarkdownPipelineBuilder ConfigureNewLine(MarkdownPipelineBuilder pipeline, string newLine);
}
public class Markdig.MarkdownPipeline : object {
    [CompilerGeneratedAttribute]
private bool <PreciseSourceLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedList`1<IMarkdownExtension> <Extensions>k__BackingField;
    [CompilerGeneratedAttribute]
private BlockParserList <BlockParsers>k__BackingField;
    [CompilerGeneratedAttribute]
private InlineParserList <InlineParsers>k__BackingField;
    [CompilerGeneratedAttribute]
private StringBuilderCache <StringBuilderCache>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <DebugLog>k__BackingField;
    internal ProcessDocumentDelegate DocumentProcessed;
    internal bool PreciseSourceLocation { get; internal set; }
    public OrderedList`1<IMarkdownExtension> Extensions { get; }
    internal BlockParserList BlockParsers { get; }
    internal InlineParserList InlineParsers { get; }
    internal StringBuilderCache StringBuilderCache { get; }
    internal TextWriter DebugLog { get; }
    internal MarkdownPipeline(OrderedList`1<IMarkdownExtension> extensions, BlockParserList blockParsers, InlineParserList inlineParsers, StringBuilderCache cache, TextWriter debugLog, ProcessDocumentDelegate documentProcessed);
    [CompilerGeneratedAttribute]
internal bool get_PreciseSourceLocation();
    [CompilerGeneratedAttribute]
internal void set_PreciseSourceLocation(bool value);
    [CompilerGeneratedAttribute]
public OrderedList`1<IMarkdownExtension> get_Extensions();
    [CompilerGeneratedAttribute]
internal BlockParserList get_BlockParsers();
    [CompilerGeneratedAttribute]
internal InlineParserList get_InlineParsers();
    [CompilerGeneratedAttribute]
internal StringBuilderCache get_StringBuilderCache();
    [CompilerGeneratedAttribute]
internal TextWriter get_DebugLog();
    public void Setup(IMarkdownRenderer renderer);
}
public class Markdig.MarkdownPipelineBuilder : object {
    private MarkdownPipeline pipeline;
    [CompilerGeneratedAttribute]
private OrderedList`1<BlockParser> <BlockParsers>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedList`1<InlineParser> <InlineParsers>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderedList`1<IMarkdownExtension> <Extensions>k__BackingField;
    [CompilerGeneratedAttribute]
private StringBuilderCache <StringBuilderCache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreciseSourceLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <DebugLog>k__BackingField;
    [CompilerGeneratedAttribute]
private ProcessDocumentDelegate DocumentProcessed;
    public OrderedList`1<BlockParser> BlockParsers { get; private set; }
    public OrderedList`1<InlineParser> InlineParsers { get; private set; }
    public OrderedList`1<IMarkdownExtension> Extensions { get; }
    public StringBuilderCache StringBuilderCache { get; public set; }
    public bool PreciseSourceLocation { get; public set; }
    public TextWriter DebugLog { get; public set; }
    internal ProcessDocumentDelegate GetDocumentProcessed { get; }
    [CompilerGeneratedAttribute]
public OrderedList`1<BlockParser> get_BlockParsers();
    [CompilerGeneratedAttribute]
private void set_BlockParsers(OrderedList`1<BlockParser> value);
    [CompilerGeneratedAttribute]
public OrderedList`1<InlineParser> get_InlineParsers();
    [CompilerGeneratedAttribute]
private void set_InlineParsers(OrderedList`1<InlineParser> value);
    [CompilerGeneratedAttribute]
public OrderedList`1<IMarkdownExtension> get_Extensions();
    [CompilerGeneratedAttribute]
public StringBuilderCache get_StringBuilderCache();
    [CompilerGeneratedAttribute]
public void set_StringBuilderCache(StringBuilderCache value);
    [CompilerGeneratedAttribute]
public bool get_PreciseSourceLocation();
    [CompilerGeneratedAttribute]
public void set_PreciseSourceLocation(bool value);
    [CompilerGeneratedAttribute]
public TextWriter get_DebugLog();
    [CompilerGeneratedAttribute]
public void set_DebugLog(TextWriter value);
    [CompilerGeneratedAttribute]
public void add_DocumentProcessed(ProcessDocumentDelegate value);
    [CompilerGeneratedAttribute]
public void remove_DocumentProcessed(ProcessDocumentDelegate value);
    internal ProcessDocumentDelegate get_GetDocumentProcessed();
    public MarkdownPipeline Build();
}
public abstract class Markdig.Parsers.BlockParser : ParserBase`1<BlockProcessor> {
    [CompilerGeneratedAttribute]
private ProcessBlockDelegate Closed;
    internal ProcessBlockDelegate GetClosedEvent { get; }
    public bool HasOpeningCharacter(char c);
    [CompilerGeneratedAttribute]
public void add_Closed(ProcessBlockDelegate value);
    [CompilerGeneratedAttribute]
public void remove_Closed(ProcessBlockDelegate value);
    internal ProcessBlockDelegate get_GetClosedEvent();
    public virtual bool CanInterrupt(BlockProcessor processor, Block block);
    public abstract virtual BlockState TryOpen(BlockProcessor processor);
    public virtual BlockState TryContinue(BlockProcessor processor, Block block);
    public virtual bool Close(BlockProcessor processor, Block block);
}
public class Markdig.Parsers.BlockParserList : ParserList`2<BlockParser, BlockProcessor> {
    public BlockParserList(IEnumerable`1<BlockParser> parsers);
}
public class Markdig.Parsers.BlockProcessor : object {
    private BlockProcessor root;
    private int currentStackIndex;
    private BlockParserStateCache parserStateCache;
    private int originalLineStart;
    [CompilerGeneratedAttribute]
private Stack`1<Block> <NewBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private BlockParserList <Parsers>k__BackingField;
    [CompilerGeneratedAttribute]
private ContainerBlock <CurrentContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private Block <CurrentBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private Block <LastBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private MarkdownDocument <Document>k__BackingField;
    public StringSlice Line;
    [CompilerGeneratedAttribute]
private int <CurrentLineStartPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnBeforeIndent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartBeforeIndent>k__BackingField;
    [CompilerGeneratedAttribute]
private StringBuilderCache <StringBuilders>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Block> <OpenedBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContinueProcessingLine>k__BackingField;
    public Stack`1<Block> NewBlocks { get; }
    public BlockParserList Parsers { get; }
    public ContainerBlock CurrentContainer { get; private set; }
    public Block CurrentBlock { get; private set; }
    public Block LastBlock { get; private set; }
    public Block NextContinue { get; }
    public MarkdownDocument Document { get; }
    public int CurrentLineStartPosition { get; private set; }
    public int LineIndex { get; public set; }
    public bool IsBlankLine { get; }
    public char CurrentChar { get; }
    public int Column { get; public set; }
    public int Start { get; }
    public int Indent { get; }
    public bool IsCodeIndent { get; }
    public int ColumnBeforeIndent { get; private set; }
    public int StartBeforeIndent { get; private set; }
    public StringBuilderCache StringBuilders { get; }
    private List`1<Block> OpenedBlocks { get; }
    private bool ContinueProcessingLine { get; private set; }
    private BlockProcessor(BlockProcessor root);
    public BlockProcessor(StringBuilderCache stringBuilders, MarkdownDocument document, BlockParserList parsers);
    [CompilerGeneratedAttribute]
public Stack`1<Block> get_NewBlocks();
    [CompilerGeneratedAttribute]
public BlockParserList get_Parsers();
    [CompilerGeneratedAttribute]
public ContainerBlock get_CurrentContainer();
    [CompilerGeneratedAttribute]
private void set_CurrentContainer(ContainerBlock value);
    [CompilerGeneratedAttribute]
public Block get_CurrentBlock();
    [CompilerGeneratedAttribute]
private void set_CurrentBlock(Block value);
    [CompilerGeneratedAttribute]
public Block get_LastBlock();
    [CompilerGeneratedAttribute]
private void set_LastBlock(Block value);
    public Block get_NextContinue();
    [CompilerGeneratedAttribute]
public MarkdownDocument get_Document();
    [CompilerGeneratedAttribute]
public int get_CurrentLineStartPosition();
    [CompilerGeneratedAttribute]
private void set_CurrentLineStartPosition(int value);
    [CompilerGeneratedAttribute]
public int get_LineIndex();
    [CompilerGeneratedAttribute]
public void set_LineIndex(int value);
    public bool get_IsBlankLine();
    public char get_CurrentChar();
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
public void set_Column(int value);
    public int get_Start();
    public int get_Indent();
    public bool get_IsCodeIndent();
    [CompilerGeneratedAttribute]
public int get_ColumnBeforeIndent();
    [CompilerGeneratedAttribute]
private void set_ColumnBeforeIndent(int value);
    [CompilerGeneratedAttribute]
public int get_StartBeforeIndent();
    [CompilerGeneratedAttribute]
private void set_StartBeforeIndent(int value);
    [CompilerGeneratedAttribute]
public StringBuilderCache get_StringBuilders();
    [CompilerGeneratedAttribute]
private List`1<Block> get_OpenedBlocks();
    [CompilerGeneratedAttribute]
private bool get_ContinueProcessingLine();
    [CompilerGeneratedAttribute]
private void set_ContinueProcessingLine(bool value);
    public char NextChar();
    public void NextColumn();
    public char PeekChar(int offset);
    public void RestartIndent();
    public void ParseIndent();
    public void GoToColumn(int newColumn);
    public void UnwindAllIndents();
    public void GoToCodeIndent(int columnOffset);
    public void Open(Block block);
    public void Close(Block block);
    public void Discard(Block block);
    public void ProcessLine(StringSlice newLine);
    public BlockProcessor CreateChild();
    public void ReleaseChild();
    internal bool IsOpen(Block block);
    private void Close(int index);
    internal void CloseAll(bool force);
    private void OpenAll();
    private void UpdateLastBlockAndContainer(int stackIndex);
    private void TryContinueBlocks();
    private void TryOpenBlocks();
    private bool TryOpenBlocks(BlockParser[] parsers);
    private void ProcessNewBlocks(BlockState result, bool allowClosing);
    private void ResetLine(StringSlice newLine);
    private void Reset();
}
public enum Markdig.Parsers.BlockState : Enum {
    public int value__;
    public static BlockState None;
    public static BlockState Skip;
    public static BlockState Continue;
    public static BlockState ContinueDiscard;
    public static BlockState Break;
    public static BlockState BreakDiscard;
}
[ExtensionAttribute]
public static class Markdig.Parsers.BlockStateExtensions : object {
    [ExtensionAttribute]
public static bool IsDiscard(BlockState blockState);
    [ExtensionAttribute]
public static bool IsContinue(BlockState blockState);
    [ExtensionAttribute]
public static bool IsBreak(BlockState blockState);
}
public abstract class Markdig.Parsers.FencedBlockParserBase : BlockParser {
    [CompilerGeneratedAttribute]
private InfoParserDelegate <InfoParser>k__BackingField;
    [CompilerGeneratedAttribute]
private TryParseAttributesDelegate <TryParseAttributes>k__BackingField;
    public InfoParserDelegate InfoParser { get; public set; }
    public TryParseAttributesDelegate TryParseAttributes { get; public set; }
    [CompilerGeneratedAttribute]
public InfoParserDelegate get_InfoParser();
    [CompilerGeneratedAttribute]
public void set_InfoParser(InfoParserDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual TryParseAttributesDelegate get_TryParseAttributes();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TryParseAttributes(TryParseAttributesDelegate value);
}
public abstract class Markdig.Parsers.FencedBlockParserBase`1 : FencedBlockParserBase {
    [CompilerGeneratedAttribute]
private string <InfoPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumMatchCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumMatchCount>k__BackingField;
    public string InfoPrefix { get; public set; }
    public int MinimumMatchCount { get; public set; }
    public int MaximumMatchCount { get; public set; }
    [CompilerGeneratedAttribute]
public string get_InfoPrefix();
    [CompilerGeneratedAttribute]
public void set_InfoPrefix(string value);
    [CompilerGeneratedAttribute]
public int get_MinimumMatchCount();
    [CompilerGeneratedAttribute]
public void set_MinimumMatchCount(int value);
    [CompilerGeneratedAttribute]
public int get_MaximumMatchCount();
    [CompilerGeneratedAttribute]
public void set_MaximumMatchCount(int value);
    public static bool DefaultInfoParser(BlockProcessor state, StringSlice& line, IFencedBlock fenced);
    public virtual BlockState TryOpen(BlockProcessor processor);
    protected abstract virtual T CreateFencedBlock(BlockProcessor processor);
    public virtual BlockState TryContinue(BlockProcessor processor, Block block);
}
public class Markdig.Parsers.FencedCodeBlockParser : FencedBlockParserBase`1<FencedCodeBlock> {
    public static string DefaultInfoPrefix;
    protected virtual FencedCodeBlock CreateFencedBlock(BlockProcessor processor);
    public virtual BlockState TryContinue(BlockProcessor processor, Block block);
}
public class Markdig.Parsers.HeadingBlockParser : BlockParser {
    [CompilerGeneratedAttribute]
private TryParseAttributesDelegate <TryParseAttributes>k__BackingField;
    public TryParseAttributesDelegate TryParseAttributes { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual TryParseAttributesDelegate get_TryParseAttributes();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TryParseAttributes(TryParseAttributesDelegate value);
    public virtual BlockState TryOpen(BlockProcessor processor);
    public virtual bool Close(BlockProcessor processor, Block block);
}
public class Markdig.Parsers.HtmlBlockParser : BlockParser {
    private static string EndOfComment;
    private static string EndOfCDATA;
    private static string EndOfProcessingInstruction;
    private static String[] HtmlTags;
    private static HtmlBlockParser();
    public virtual BlockState TryOpen(BlockProcessor processor);
    public virtual BlockState TryContinue(BlockProcessor processor, Block block);
    private BlockState MatchStart(BlockProcessor state);
    private BlockState TryParseTagType7(BlockProcessor state, StringSlice line, int startColumn, int startPosition);
    private BlockState TryParseTagType16(BlockProcessor state, StringSlice line, int startColumn, int startPosition);
    private BlockState MatchEnd(BlockProcessor state, HtmlBlock htmlBlock);
    private BlockState CreateHtmlBlock(BlockProcessor state, HtmlBlockType type, int startColumn, int startPosition);
}
public interface Markdig.Parsers.IAttributesParseable {
    public TryParseAttributesDelegate TryParseAttributes { get; public set; }
    public abstract virtual TryParseAttributesDelegate get_TryParseAttributes();
    public abstract virtual void set_TryParseAttributes(TryParseAttributesDelegate value);
}
public interface Markdig.Parsers.IBlockParser`1 {
    public abstract virtual bool CanInterrupt(TProcessor processor, Block block);
    public abstract virtual BlockState TryOpen(TProcessor processor);
    public abstract virtual BlockState TryContinue(TProcessor processor, Block block);
    public abstract virtual bool Close(TProcessor processor, Block block);
}
public interface Markdig.Parsers.IInlineParser`1 {
    public abstract virtual bool Match(InlineProcessor processor, StringSlice& slice);
}
public interface Markdig.Parsers.IMarkdownParser`1 {
    public Char[] OpeningCharacters { get; }
    public int Index { get; }
    public abstract virtual Char[] get_OpeningCharacters();
    public abstract virtual void Initialize();
    public abstract virtual int get_Index();
}
public class Markdig.Parsers.IndentedCodeBlockParser : BlockParser {
    public virtual bool CanInterrupt(BlockProcessor processor, Block block);
    public virtual BlockState TryOpen(BlockProcessor processor);
    public virtual BlockState TryContinue(BlockProcessor processor, Block block);
    public virtual bool Close(BlockProcessor processor, Block block);
}
public abstract class Markdig.Parsers.InlineParser : ParserBase`1<InlineProcessor> {
    public abstract virtual bool Match(InlineProcessor processor, StringSlice& slice);
}
public class Markdig.Parsers.InlineParserList : ParserList`2<InlineParser, InlineProcessor> {
    [CompilerGeneratedAttribute]
private IPostInlineProcessor[] <PostInlineProcessors>k__BackingField;
    public IPostInlineProcessor[] PostInlineProcessors { get; private set; }
    public InlineParserList(IEnumerable`1<InlineParser> parsers);
    [CompilerGeneratedAttribute]
public IPostInlineProcessor[] get_PostInlineProcessors();
    [CompilerGeneratedAttribute]
private void set_PostInlineProcessors(IPostInlineProcessor[] value);
}
public class Markdig.Parsers.InlineProcessor : object {
    private List`1<LineOffset> lineOffsets;
    private int previousSliceOffset;
    private int previousLineIndexForSliceOffset;
    [CompilerGeneratedAttribute]
private LeafBlock <Block>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreciseSourceLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Block <BlockNew>k__BackingField;
    [CompilerGeneratedAttribute]
private Inline <Inline>k__BackingField;
    [CompilerGeneratedAttribute]
private ContainerInline <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private InlineParserList <Parsers>k__BackingField;
    [CompilerGeneratedAttribute]
private MarkdownDocument <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private StringBuilderCache <StringBuilders>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <ParserStates>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <DebugLog>k__BackingField;
    [CompilerGeneratedAttribute]
private LiteralInlineParser <LiteralInlineParser>k__BackingField;
    public LeafBlock Block { get; private set; }
    public bool PreciseSourceLocation { get; }
    public Block BlockNew { get; public set; }
    public Inline Inline { get; public set; }
    public ContainerInline Root { get; internal set; }
    public InlineParserList Parsers { get; }
    public MarkdownDocument Document { get; }
    public StringBuilderCache StringBuilders { get; }
    public int LineIndex { get; private set; }
    public Object[] ParserStates { get; }
    public TextWriter DebugLog { get; public set; }
    public LiteralInlineParser LiteralInlineParser { get; }
    public InlineProcessor(StringBuilderCache stringBuilders, MarkdownDocument document, InlineParserList parsers, bool preciseSourcelocation);
    [CompilerGeneratedAttribute]
public LeafBlock get_Block();
    [CompilerGeneratedAttribute]
private void set_Block(LeafBlock value);
    [CompilerGeneratedAttribute]
public bool get_PreciseSourceLocation();
    [CompilerGeneratedAttribute]
public Block get_BlockNew();
    [CompilerGeneratedAttribute]
public void set_BlockNew(Block value);
    [CompilerGeneratedAttribute]
public Inline get_Inline();
    [CompilerGeneratedAttribute]
public void set_Inline(Inline value);
    [CompilerGeneratedAttribute]
public ContainerInline get_Root();
    [CompilerGeneratedAttribute]
internal void set_Root(ContainerInline value);
    [CompilerGeneratedAttribute]
public InlineParserList get_Parsers();
    [CompilerGeneratedAttribute]
public MarkdownDocument get_Document();
    [CompilerGeneratedAttribute]
public StringBuilderCache get_StringBuilders();
    [CompilerGeneratedAttribute]
public int get_LineIndex();
    [CompilerGeneratedAttribute]
private void set_LineIndex(int value);
    [CompilerGeneratedAttribute]
public Object[] get_ParserStates();
    [CompilerGeneratedAttribute]
public TextWriter get_DebugLog();
    [CompilerGeneratedAttribute]
public void set_DebugLog(TextWriter value);
    [CompilerGeneratedAttribute]
public LiteralInlineParser get_LiteralInlineParser();
    public int GetSourcePosition(int sliceOffset);
    public SourceSpan GetSourcePositionFromLocalSpan(SourceSpan span);
    public int GetSourcePosition(int sliceOffset, Int32& lineIndex, Int32& column);
    public void ProcessInlineLeaf(LeafBlock leafBlock);
    public void PostProcessInlines(int startingIndex, Inline root, Inline lastChild, bool isFinalProcessing);
    private ContainerInline FindLastContainer();
}
public class Markdig.Parsers.Inlines.AutolineInlineParser : InlineParser {
    [CompilerGeneratedAttribute]
private bool <EnableHtmlParsing>k__BackingField;
    public bool EnableHtmlParsing { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_EnableHtmlParsing();
    [CompilerGeneratedAttribute]
public void set_EnableHtmlParsing(bool value);
    public virtual bool Match(InlineProcessor processor, StringSlice& slice);
}
public class Markdig.Parsers.Inlines.CodeInlineParser : InlineParser {
    public virtual bool Match(InlineProcessor processor, StringSlice& slice);
}
public class Markdig.Parsers.Inlines.EmphasisDescriptor : object {
    public char Character;
    public int MinimumCount;
    public int MaximumCount;
    public bool EnableWithinWord;
    public EmphasisDescriptor(char character, int minimumCount, int maximumCount, bool enableWithinWord);
}
public class Markdig.Parsers.Inlines.EmphasisInlineParser : InlineParser {
    private CharacterMap`1<EmphasisDescriptor> emphasisMap;
    private DelimitersObjectCache inlinesCache;
    [CompilerGeneratedAttribute]
private List`1<EmphasisDescriptor> <EmphasisDescriptors>k__BackingField;
    [CompilerGeneratedAttribute]
private CreateEmphasisInlineDelegate <CreateEmphasisInline>k__BackingField;
    public List`1<EmphasisDescriptor> EmphasisDescriptors { get; }
    public CreateEmphasisInlineDelegate CreateEmphasisInline { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<EmphasisDescriptor> get_EmphasisDescriptors();
    public bool HasEmphasisChar(char c);
    [CompilerGeneratedAttribute]
public CreateEmphasisInlineDelegate get_CreateEmphasisInline();
    [CompilerGeneratedAttribute]
public void set_CreateEmphasisInline(CreateEmphasisInlineDelegate value);
    public virtual void Initialize();
    public sealed virtual bool PostProcess(InlineProcessor state, Inline root, Inline lastChild, int postInlineProcessorIndex, bool isFinalProcessing);
    public virtual bool Match(InlineProcessor processor, StringSlice& slice);
    private void ProcessEmphasis(InlineProcessor processor, List`1<EmphasisDelimiterInline> delimiters);
}
public class Markdig.Parsers.Inlines.EscapeInlineParser : InlineParser {
    public virtual bool Match(InlineProcessor processor, StringSlice& slice);
}
public class Markdig.Parsers.Inlines.HtmlEntityParser : InlineParser {
    public static bool TryParse(StringSlice& slice, String& literal, Int32& match);
    public virtual bool Match(InlineProcessor processor, StringSlice& slice);
}
public class Markdig.Parsers.Inlines.LineBreakInlineParser : InlineParser {
    [CompilerGeneratedAttribute]
private bool <EnableSoftAsHard>k__BackingField;
    public bool EnableSoftAsHard { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_EnableSoftAsHard();
    [CompilerGeneratedAttribute]
public void set_EnableSoftAsHard(bool value);
    public virtual bool Match(InlineProcessor processor, StringSlice& slice);
}
public class Markdig.Parsers.Inlines.LinkInlineParser : InlineParser {
    public virtual bool Match(InlineProcessor processor, StringSlice& slice);
    private bool ProcessLinkReference(InlineProcessor state, string label, bool isShortcut, SourceSpan labelSpan, LinkDelimiterInline parent, int endPosition);
    private bool TryProcessLinkOrImage(InlineProcessor inlineState, StringSlice& text);
    private void MarkParentAsInactive(Inline inline);
}
public class Markdig.Parsers.Inlines.LiteralInlineParser : InlineParser {
    [CompilerGeneratedAttribute]
private PostMatchDelegate <PostMatch>k__BackingField;
    public PostMatchDelegate PostMatch { get; public set; }
    [CompilerGeneratedAttribute]
public PostMatchDelegate get_PostMatch();
    [CompilerGeneratedAttribute]
public void set_PostMatch(PostMatchDelegate value);
    public virtual bool Match(InlineProcessor processor, StringSlice& slice);
}
public interface Markdig.Parsers.IPostInlineProcessor {
    public abstract virtual bool PostProcess(InlineProcessor state, Inline root, Inline lastChild, int postInlineProcessorIndex, bool isFinalProcessing);
}
public class Markdig.Parsers.ListBlockParser : BlockParser {
    private CharacterMap`1<ListItemParser> mapItemParsers;
    [CompilerGeneratedAttribute]
private OrderedList`1<ListItemParser> <ItemParsers>k__BackingField;
    public OrderedList`1<ListItemParser> ItemParsers { get; }
    [CompilerGeneratedAttribute]
public OrderedList`1<ListItemParser> get_ItemParsers();
    public virtual void Initialize();
    public virtual BlockState TryOpen(BlockProcessor processor);
    public virtual BlockState TryContinue(BlockProcessor processor, Block block);
    private BlockState TryContinueListItem(BlockProcessor state, ListItemBlock listItem);
    private BlockState TryParseListItem(BlockProcessor state, Block block);
    public virtual bool Close(BlockProcessor processor, Block blockToClose);
}
public class Markdig.Parsers.ListInfo : ValueType {
    [CompilerGeneratedAttribute]
private char <BulletType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OrderedStart>k__BackingField;
    [CompilerGeneratedAttribute]
private char <OrderedDelimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultOrderedStart>k__BackingField;
    public char BulletType { get; public set; }
    public string OrderedStart { get; public set; }
    public char OrderedDelimiter { get; public set; }
    public string DefaultOrderedStart { get; public set; }
    public ListInfo(char bulletType);
    public ListInfo(char bulletType, string orderedStart, char orderedDelimiter, string defaultOrderedStart);
    [CompilerGeneratedAttribute]
public char get_BulletType();
    [CompilerGeneratedAttribute]
public void set_BulletType(char value);
    [CompilerGeneratedAttribute]
public string get_OrderedStart();
    [CompilerGeneratedAttribute]
public void set_OrderedStart(string value);
    [CompilerGeneratedAttribute]
public char get_OrderedDelimiter();
    [CompilerGeneratedAttribute]
public void set_OrderedDelimiter(char value);
    [CompilerGeneratedAttribute]
public string get_DefaultOrderedStart();
    [CompilerGeneratedAttribute]
public void set_DefaultOrderedStart(string value);
}
public abstract class Markdig.Parsers.ListItemParser : object {
    [CompilerGeneratedAttribute]
private Char[] <OpeningCharacters>k__BackingField;
    public Char[] OpeningCharacters { get; protected set; }
    [CompilerGeneratedAttribute]
public Char[] get_OpeningCharacters();
    [CompilerGeneratedAttribute]
protected void set_OpeningCharacters(Char[] value);
    public abstract virtual bool TryParse(BlockProcessor state, char pendingBulletType, ListInfo& result);
}
public class Markdig.Parsers.MarkdownParser : object {
    private BlockProcessor blockProcessor;
    private InlineProcessor inlineProcessor;
    private MarkdownDocument document;
    private ProcessDocumentDelegate documentProcessed;
    private bool preciseSourceLocation;
    private LineReader lineReader;
    private MarkdownParser(string text, MarkdownPipeline pipeline);
    public static MarkdownDocument Parse(string text, MarkdownPipeline pipeline);
    private MarkdownDocument Parse();
    private void ProcessBlocks();
    private string FixupZero(string text);
    private void ProcessInlines();
}
public class Markdig.Parsers.NumberedListItemParser : OrderedListItemParser {
    public virtual bool TryParse(BlockProcessor state, char pendingBulletType, ListInfo& result);
}
public abstract class Markdig.Parsers.OrderedListItemParser : ListItemParser {
    [CompilerGeneratedAttribute]
private Char[] <OrderedDelimiters>k__BackingField;
    public Char[] OrderedDelimiters { get; public set; }
    [CompilerGeneratedAttribute]
public Char[] get_OrderedDelimiters();
    [CompilerGeneratedAttribute]
public void set_OrderedDelimiters(Char[] value);
    protected bool TryParseDelimiter(BlockProcessor state, Char& orderedDelimiter);
}
public class Markdig.Parsers.ParagraphBlockParser : BlockParser {
    public virtual BlockState TryOpen(BlockProcessor processor);
    public virtual BlockState TryContinue(BlockProcessor processor, Block block);
    public virtual bool Close(BlockProcessor processor, Block block);
    private BlockState TryParseSetexHeading(BlockProcessor state, Block block);
    private bool TryMatchLinkReferenceDefinition(StringLineGroup& lines, BlockProcessor state);
}
public abstract class Markdig.Parsers.ParserBase`1 : object {
    [CompilerGeneratedAttribute]
private Char[] <OpeningCharacters>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public Char[] OpeningCharacters { get; public set; }
    public int Index { get; internal set; }
    [CompilerGeneratedAttribute]
public sealed virtual Char[] get_OpeningCharacters();
    [CompilerGeneratedAttribute]
public void set_OpeningCharacters(Char[] value);
    public virtual void Initialize();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Index();
    [CompilerGeneratedAttribute]
internal void set_Index(int value);
}
public abstract class Markdig.Parsers.ParserList`2 : OrderedList`1<T> {
    private CharacterMap`1<T[]> charMap;
    private T[] globalParsers;
    public T[] GlobalParsers { get; }
    public Char[] OpeningCharacters { get; }
    protected ParserList`2(IEnumerable`1<T> parsersArg);
    public T[] get_GlobalParsers();
    public Char[] get_OpeningCharacters();
    public T[] GetParsersForOpeningCharacter(char openingChar);
    public int IndexOfOpeningCharacter(string text, int start, int end);
    private void Initialize();
}
public class Markdig.Parsers.ProcessBlockDelegate : MulticastDelegate {
    public ProcessBlockDelegate(object object, IntPtr method);
    public virtual void Invoke(BlockProcessor processor, Block block);
    public virtual IAsyncResult BeginInvoke(BlockProcessor processor, Block block, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Markdig.Parsers.ProcessDocumentDelegate : MulticastDelegate {
    public ProcessDocumentDelegate(object object, IntPtr method);
    public virtual void Invoke(MarkdownDocument document);
    public virtual IAsyncResult BeginInvoke(MarkdownDocument document, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Markdig.Parsers.ProcessInlineDelegate : MulticastDelegate {
    public ProcessInlineDelegate(object object, IntPtr method);
    public virtual void Invoke(InlineProcessor processor, Inline inline);
    public virtual IAsyncResult BeginInvoke(InlineProcessor processor, Inline inline, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Markdig.Parsers.QuoteBlockParser : BlockParser {
    public virtual BlockState TryOpen(BlockProcessor processor);
    public virtual BlockState TryContinue(BlockProcessor processor, Block block);
}
public class Markdig.Parsers.ThematicBreakParser : BlockParser {
    public static ThematicBreakParser Default;
    private static ThematicBreakParser();
    public virtual BlockState TryOpen(BlockProcessor processor);
}
public class Markdig.Parsers.TryParseAttributesDelegate : MulticastDelegate {
    public TryParseAttributesDelegate(object object, IntPtr method);
    public virtual bool Invoke(BlockProcessor processor, StringSlice& slice, IBlock block);
    public virtual IAsyncResult BeginInvoke(BlockProcessor processor, StringSlice& slice, IBlock block, AsyncCallback callback, object object);
    public virtual bool EndInvoke(StringSlice& slice, IAsyncResult result);
}
public class Markdig.Parsers.UnorderedListItemParser : ListItemParser {
    public virtual bool TryParse(BlockProcessor state, char pendingBulletType, ListInfo& result);
}
public class Markdig.Renderers.Html.CodeBlockRenderer : HtmlObjectRenderer`1<CodeBlock> {
    [CompilerGeneratedAttribute]
private bool <OutputAttributesOnPre>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <BlocksAsDiv>k__BackingField;
    public bool OutputAttributesOnPre { get; public set; }
    public HashSet`1<string> BlocksAsDiv { get; }
    [CompilerGeneratedAttribute]
public bool get_OutputAttributesOnPre();
    [CompilerGeneratedAttribute]
public void set_OutputAttributesOnPre(bool value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_BlocksAsDiv();
    protected virtual void Write(HtmlRenderer renderer, CodeBlock obj);
}
public class Markdig.Renderers.Html.HeadingRenderer : HtmlObjectRenderer`1<HeadingBlock> {
    private static String[] HeadingTexts;
    private static HeadingRenderer();
    protected virtual void Write(HtmlRenderer renderer, HeadingBlock obj);
}
public class Markdig.Renderers.Html.HtmlAttributes : MarkdownObject {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Classes>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyValuePair`2<string, string>> <Properties>k__BackingField;
    public string Id { get; public set; }
    public List`1<string> Classes { get; public set; }
    public List`1<KeyValuePair`2<string, string>> Properties { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Classes();
    [CompilerGeneratedAttribute]
public void set_Classes(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<KeyValuePair`2<string, string>> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(List`1<KeyValuePair`2<string, string>> value);
    public void AddClass(string name);
    public void AddProperty(string name, string value);
    public void AddPropertyIfNotExist(string name, object value);
    public void CopyTo(HtmlAttributes htmlAttributes, bool mergeIdAndProperties, bool shared);
}
[ExtensionAttribute]
public static class Markdig.Renderers.Html.HtmlAttributesExtensions : object {
    private static object Key;
    private static HtmlAttributesExtensions();
    [ExtensionAttribute]
public static HtmlAttributes TryGetAttributes(IMarkdownObject obj);
    [ExtensionAttribute]
public static HtmlAttributes GetAttributes(IMarkdownObject obj);
    [ExtensionAttribute]
public static void SetAttributes(IMarkdownObject obj, HtmlAttributes attributes);
}
public class Markdig.Renderers.Html.HtmlBlockRenderer : HtmlObjectRenderer`1<HtmlBlock> {
    protected virtual void Write(HtmlRenderer renderer, HtmlBlock obj);
}
public abstract class Markdig.Renderers.Html.HtmlObjectRenderer`1 : MarkdownObjectRenderer`2<HtmlRenderer, TObject> {
}
public class Markdig.Renderers.Html.Inlines.AutolinkInlineRenderer : HtmlObjectRenderer`1<AutolinkInline> {
    [CompilerGeneratedAttribute]
private bool <AutoRelNoFollow>k__BackingField;
    public bool AutoRelNoFollow { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AutoRelNoFollow();
    [CompilerGeneratedAttribute]
public void set_AutoRelNoFollow(bool value);
    protected virtual void Write(HtmlRenderer renderer, AutolinkInline obj);
}
public class Markdig.Renderers.Html.Inlines.CodeInlineRenderer : HtmlObjectRenderer`1<CodeInline> {
    protected virtual void Write(HtmlRenderer renderer, CodeInline obj);
}
public class Markdig.Renderers.Html.Inlines.DelimiterInlineRenderer : HtmlObjectRenderer`1<DelimiterInline> {
    protected virtual void Write(HtmlRenderer renderer, DelimiterInline obj);
}
public class Markdig.Renderers.Html.Inlines.EmphasisInlineRenderer : HtmlObjectRenderer`1<EmphasisInline> {
    [CompilerGeneratedAttribute]
private GetTagDelegate <GetTag>k__BackingField;
    public GetTagDelegate GetTag { get; public set; }
    [CompilerGeneratedAttribute]
public GetTagDelegate get_GetTag();
    [CompilerGeneratedAttribute]
public void set_GetTag(GetTagDelegate value);
    protected virtual void Write(HtmlRenderer renderer, EmphasisInline obj);
    public string GetDefaultTag(EmphasisInline obj);
}
public class Markdig.Renderers.Html.Inlines.HtmlEntityInlineRenderer : HtmlObjectRenderer`1<HtmlEntityInline> {
    protected virtual void Write(HtmlRenderer renderer, HtmlEntityInline obj);
}
public class Markdig.Renderers.Html.Inlines.HtmlInlineRenderer : HtmlObjectRenderer`1<HtmlInline> {
    protected virtual void Write(HtmlRenderer renderer, HtmlInline obj);
}
public class Markdig.Renderers.Html.Inlines.LineBreakInlineRenderer : HtmlObjectRenderer`1<LineBreakInline> {
    [CompilerGeneratedAttribute]
private bool <RenderAsHardlineBreak>k__BackingField;
    public bool RenderAsHardlineBreak { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_RenderAsHardlineBreak();
    [CompilerGeneratedAttribute]
public void set_RenderAsHardlineBreak(bool value);
    protected virtual void Write(HtmlRenderer renderer, LineBreakInline obj);
}
public class Markdig.Renderers.Html.Inlines.LinkInlineRenderer : HtmlObjectRenderer`1<LinkInline> {
    [CompilerGeneratedAttribute]
private bool <AutoRelNoFollow>k__BackingField;
    public bool AutoRelNoFollow { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AutoRelNoFollow();
    [CompilerGeneratedAttribute]
public void set_AutoRelNoFollow(bool value);
    protected virtual void Write(HtmlRenderer renderer, LinkInline link);
}
public class Markdig.Renderers.Html.Inlines.LiteralInlineRenderer : HtmlObjectRenderer`1<LiteralInline> {
    protected virtual void Write(HtmlRenderer renderer, LiteralInline obj);
}
public class Markdig.Renderers.Html.ListRenderer : HtmlObjectRenderer`1<ListBlock> {
    protected virtual void Write(HtmlRenderer renderer, ListBlock listBlock);
}
public class Markdig.Renderers.Html.ParagraphRenderer : HtmlObjectRenderer`1<ParagraphBlock> {
    protected virtual void Write(HtmlRenderer renderer, ParagraphBlock obj);
}
public class Markdig.Renderers.Html.QuoteBlockRenderer : HtmlObjectRenderer`1<QuoteBlock> {
    protected virtual void Write(HtmlRenderer renderer, QuoteBlock obj);
}
public class Markdig.Renderers.Html.ThematicBreakRenderer : HtmlObjectRenderer`1<ThematicBreakBlock> {
    protected virtual void Write(HtmlRenderer renderer, ThematicBreakBlock obj);
}
public class Markdig.Renderers.HtmlRenderer : TextRendererBase`1<HtmlRenderer> {
    [CompilerGeneratedAttribute]
private bool <EnableHtmlForInline>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableHtmlForBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableHtmlEscape>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ImplicitParagraph>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseNonAsciiNoEscape>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <BaseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, string> <LinkRewriter>k__BackingField;
    public bool EnableHtmlForInline { get; public set; }
    public bool EnableHtmlForBlock { get; public set; }
    public bool EnableHtmlEscape { get; public set; }
    public bool ImplicitParagraph { get; public set; }
    public bool UseNonAsciiNoEscape { get; public set; }
    public Uri BaseUrl { get; public set; }
    public Func`2<string, string> LinkRewriter { get; public set; }
    public HtmlRenderer(TextWriter writer);
    [CompilerGeneratedAttribute]
public bool get_EnableHtmlForInline();
    [CompilerGeneratedAttribute]
public void set_EnableHtmlForInline(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableHtmlForBlock();
    [CompilerGeneratedAttribute]
public void set_EnableHtmlForBlock(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableHtmlEscape();
    [CompilerGeneratedAttribute]
public void set_EnableHtmlEscape(bool value);
    [CompilerGeneratedAttribute]
public bool get_ImplicitParagraph();
    [CompilerGeneratedAttribute]
public void set_ImplicitParagraph(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseNonAsciiNoEscape();
    [CompilerGeneratedAttribute]
public void set_UseNonAsciiNoEscape(bool value);
    [CompilerGeneratedAttribute]
public Uri get_BaseUrl();
    [CompilerGeneratedAttribute]
public void set_BaseUrl(Uri value);
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_LinkRewriter();
    [CompilerGeneratedAttribute]
public void set_LinkRewriter(Func`2<string, string> value);
    public HtmlRenderer WriteEscape(string content);
    public HtmlRenderer WriteEscape(StringSlice& slice, bool softEscape);
    public HtmlRenderer WriteEscape(StringSlice slice, bool softEscape);
    public HtmlRenderer WriteEscape(string content, int offset, int length, bool softEscape);
    public HtmlRenderer WriteEscapeUrl(string content);
    public HtmlRenderer WriteAttributes(MarkdownObject obj);
    public HtmlRenderer WriteAttributes(HtmlAttributes attributes, Func`2<string, string> classFilter);
    public HtmlRenderer WriteLeafRawLines(LeafBlock leafBlock, bool writeEndOfLines, bool escape, bool softEscape);
}
public interface Markdig.Renderers.IMarkdownObjectRenderer {
    public abstract virtual bool Accept(RendererBase renderer, MarkdownObject obj);
    public abstract virtual void Write(RendererBase renderer, MarkdownObject objectToRender);
}
public interface Markdig.Renderers.IMarkdownRenderer {
    public ObjectRendererCollection ObjectRenderers { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_ObjectWriteBefore(Action`2<IMarkdownRenderer, MarkdownObject> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ObjectWriteBefore(Action`2<IMarkdownRenderer, MarkdownObject> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ObjectWriteAfter(Action`2<IMarkdownRenderer, MarkdownObject> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ObjectWriteAfter(Action`2<IMarkdownRenderer, MarkdownObject> value);
    public abstract virtual ObjectRendererCollection get_ObjectRenderers();
    public abstract virtual object Render(MarkdownObject markdownObject);
}
public abstract class Markdig.Renderers.MarkdownObjectRenderer`2 : object {
    [CompilerGeneratedAttribute]
private OrderedList`1<TryWriteDelegate<TRenderer, TObject>> <TryWriters>k__BackingField;
    public OrderedList`1<TryWriteDelegate<TRenderer, TObject>> TryWriters { get; }
    public virtual bool Accept(RendererBase renderer, MarkdownObject obj);
    public virtual void Write(RendererBase renderer, MarkdownObject obj);
    [CompilerGeneratedAttribute]
public OrderedList`1<TryWriteDelegate<TRenderer, TObject>> get_TryWriters();
    protected abstract virtual void Write(TRenderer renderer, TObject obj);
}
public class Markdig.Renderers.Normalize.CodeBlockRenderer : NormalizeObjectRenderer`1<CodeBlock> {
    [CompilerGeneratedAttribute]
private bool <OutputAttributesOnPre>k__BackingField;
    public bool OutputAttributesOnPre { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_OutputAttributesOnPre();
    [CompilerGeneratedAttribute]
public void set_OutputAttributesOnPre(bool value);
    protected virtual void Write(NormalizeRenderer renderer, CodeBlock obj);
}
public class Markdig.Renderers.Normalize.HeadingRenderer : NormalizeObjectRenderer`1<HeadingBlock> {
    private static String[] HeadingTexts;
    private static HeadingRenderer();
    protected virtual void Write(NormalizeRenderer renderer, HeadingBlock obj);
}
public class Markdig.Renderers.Normalize.HtmlBlockRenderer : NormalizeObjectRenderer`1<HtmlBlock> {
    protected virtual void Write(NormalizeRenderer renderer, HtmlBlock obj);
}
public class Markdig.Renderers.Normalize.Inlines.AutolinkInlineRenderer : NormalizeObjectRenderer`1<AutolinkInline> {
    protected virtual void Write(NormalizeRenderer renderer, AutolinkInline obj);
}
public class Markdig.Renderers.Normalize.Inlines.CodeInlineRenderer : NormalizeObjectRenderer`1<CodeInline> {
    protected virtual void Write(NormalizeRenderer renderer, CodeInline obj);
}
public class Markdig.Renderers.Normalize.Inlines.DelimiterInlineRenderer : NormalizeObjectRenderer`1<DelimiterInline> {
    protected virtual void Write(NormalizeRenderer renderer, DelimiterInline obj);
}
public class Markdig.Renderers.Normalize.Inlines.EmphasisInlineRenderer : NormalizeObjectRenderer`1<EmphasisInline> {
    protected virtual void Write(NormalizeRenderer renderer, EmphasisInline obj);
}
public class Markdig.Renderers.Normalize.Inlines.LineBreakInlineRenderer : NormalizeObjectRenderer`1<LineBreakInline> {
    [CompilerGeneratedAttribute]
private bool <RenderAsHardlineBreak>k__BackingField;
    public bool RenderAsHardlineBreak { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_RenderAsHardlineBreak();
    [CompilerGeneratedAttribute]
public void set_RenderAsHardlineBreak(bool value);
    protected virtual void Write(NormalizeRenderer renderer, LineBreakInline obj);
}
public class Markdig.Renderers.Normalize.Inlines.LinkInlineRenderer : NormalizeObjectRenderer`1<LinkInline> {
    protected virtual void Write(NormalizeRenderer renderer, LinkInline link);
}
public class Markdig.Renderers.Normalize.Inlines.LiteralInlineRenderer : NormalizeObjectRenderer`1<LiteralInline> {
    protected virtual void Write(NormalizeRenderer renderer, LiteralInline obj);
}
public class Markdig.Renderers.Normalize.Inlines.NormalizeHtmlEntityInlineRenderer : NormalizeObjectRenderer`1<HtmlEntityInline> {
    protected virtual void Write(NormalizeRenderer renderer, HtmlEntityInline obj);
}
public class Markdig.Renderers.Normalize.Inlines.NormalizeHtmlInlineRenderer : NormalizeObjectRenderer`1<HtmlInline> {
    protected virtual void Write(NormalizeRenderer renderer, HtmlInline obj);
}
public class Markdig.Renderers.Normalize.LinkReferenceDefinitionGroupRenderer : NormalizeObjectRenderer`1<LinkReferenceDefinitionGroup> {
    protected virtual void Write(NormalizeRenderer renderer, LinkReferenceDefinitionGroup obj);
}
public class Markdig.Renderers.Normalize.LinkReferenceDefinitionRenderer : NormalizeObjectRenderer`1<LinkReferenceDefinition> {
    protected virtual void Write(NormalizeRenderer renderer, LinkReferenceDefinition linkDef);
}
public class Markdig.Renderers.Normalize.ListRenderer : NormalizeObjectRenderer`1<ListBlock> {
    protected virtual void Write(NormalizeRenderer renderer, ListBlock listBlock);
    private static int IntLog10Fast(int input);
}
public abstract class Markdig.Renderers.Normalize.NormalizeObjectRenderer`1 : MarkdownObjectRenderer`2<NormalizeRenderer, TObject> {
}
public class Markdig.Renderers.Normalize.NormalizeOptions : object {
    [CompilerGeneratedAttribute]
private bool <SpaceAfterQuoteBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmptyLineAfterCodeBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmptyLineAfterHeading>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmptyLineAfterThematicBreak>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<char> <ListItemCharacter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExpandAutoLinks>k__BackingField;
    public bool SpaceAfterQuoteBlock { get; public set; }
    public bool EmptyLineAfterCodeBlock { get; public set; }
    public bool EmptyLineAfterHeading { get; public set; }
    public bool EmptyLineAfterThematicBreak { get; public set; }
    public Nullable`1<char> ListItemCharacter { get; public set; }
    public bool ExpandAutoLinks { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_SpaceAfterQuoteBlock();
    [CompilerGeneratedAttribute]
public void set_SpaceAfterQuoteBlock(bool value);
    [CompilerGeneratedAttribute]
public bool get_EmptyLineAfterCodeBlock();
    [CompilerGeneratedAttribute]
public void set_EmptyLineAfterCodeBlock(bool value);
    [CompilerGeneratedAttribute]
public bool get_EmptyLineAfterHeading();
    [CompilerGeneratedAttribute]
public void set_EmptyLineAfterHeading(bool value);
    [CompilerGeneratedAttribute]
public bool get_EmptyLineAfterThematicBreak();
    [CompilerGeneratedAttribute]
public void set_EmptyLineAfterThematicBreak(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<char> get_ListItemCharacter();
    [CompilerGeneratedAttribute]
public void set_ListItemCharacter(Nullable`1<char> value);
    [CompilerGeneratedAttribute]
public bool get_ExpandAutoLinks();
    [CompilerGeneratedAttribute]
public void set_ExpandAutoLinks(bool value);
}
public class Markdig.Renderers.Normalize.NormalizeRenderer : TextRendererBase`1<NormalizeRenderer> {
    [CompilerGeneratedAttribute]
private NormalizeOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CompactParagraph>k__BackingField;
    public NormalizeOptions Options { get; }
    public bool CompactParagraph { get; public set; }
    public NormalizeRenderer(TextWriter writer, NormalizeOptions options);
    [CompilerGeneratedAttribute]
public NormalizeOptions get_Options();
    [CompilerGeneratedAttribute]
public bool get_CompactParagraph();
    [CompilerGeneratedAttribute]
public void set_CompactParagraph(bool value);
    public void FinishBlock(bool emptyLine);
    public NormalizeRenderer WriteLeafRawLines(LeafBlock leafBlock, bool writeEndOfLines, bool indent);
}
public class Markdig.Renderers.Normalize.ParagraphRenderer : NormalizeObjectRenderer`1<ParagraphBlock> {
    protected virtual void Write(NormalizeRenderer renderer, ParagraphBlock obj);
}
public class Markdig.Renderers.Normalize.QuoteBlockRenderer : NormalizeObjectRenderer`1<QuoteBlock> {
    protected virtual void Write(NormalizeRenderer renderer, QuoteBlock obj);
}
public class Markdig.Renderers.Normalize.ThematicBreakRenderer : NormalizeObjectRenderer`1<ThematicBreakBlock> {
    protected virtual void Write(NormalizeRenderer renderer, ThematicBreakBlock obj);
}
public class Markdig.Renderers.ObjectRendererCollection : OrderedList`1<IMarkdownObjectRenderer> {
}
public abstract class Markdig.Renderers.RendererBase : object {
    private Dictionary`2<Type, IMarkdownObjectRenderer> renderersPerType;
    private IMarkdownObjectRenderer previousRenderer;
    private Type previousObjectType;
    [CompilerGeneratedAttribute]
private ObjectRendererCollection <ObjectRenderers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFirstInContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastInContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<IMarkdownRenderer, MarkdownObject> ObjectWriteBefore;
    [CompilerGeneratedAttribute]
private Action`2<IMarkdownRenderer, MarkdownObject> ObjectWriteAfter;
    public ObjectRendererCollection ObjectRenderers { get; }
    public bool IsFirstInContainer { get; private set; }
    public bool IsLastInContainer { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual ObjectRendererCollection get_ObjectRenderers();
    public abstract virtual object Render(MarkdownObject markdownObject);
    [CompilerGeneratedAttribute]
public bool get_IsFirstInContainer();
    [CompilerGeneratedAttribute]
private void set_IsFirstInContainer(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLastInContainer();
    [CompilerGeneratedAttribute]
private void set_IsLastInContainer(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ObjectWriteBefore(Action`2<IMarkdownRenderer, MarkdownObject> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ObjectWriteBefore(Action`2<IMarkdownRenderer, MarkdownObject> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ObjectWriteAfter(Action`2<IMarkdownRenderer, MarkdownObject> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ObjectWriteAfter(Action`2<IMarkdownRenderer, MarkdownObject> value);
    public void WriteChildren(ContainerBlock containerBlock);
    public void WriteChildren(ContainerInline containerInline);
    public void Write(T obj);
}
public abstract class Markdig.Renderers.TextRendererBase : RendererBase {
    private TextWriter writer;
    public TextWriter Writer { get; public set; }
    protected TextRendererBase(TextWriter writer);
    public TextWriter get_Writer();
    public void set_Writer(TextWriter value);
    public virtual object Render(MarkdownObject markdownObject);
}
public abstract class Markdig.Renderers.TextRendererBase`1 : TextRendererBase {
    private bool previousWasLine;
    private Char[] buffer;
    private List`1<string> indents;
    protected TextRendererBase`1(TextWriter writer);
    public T EnsureLine();
    public void PushIndent(string indent);
    public void PopIndent();
    private void WriteIndent();
    public T Write(string content);
    public T Write(StringSlice& slice);
    public T Write(StringSlice slice);
    public T Write(char content);
    public T Write(string content, int offset, int length);
    public T WriteLine();
    public T WriteLine(string content);
    public T WriteLeafInline(LeafBlock leafBlock);
}
public class Markdig.Syntax.BlankLineBlock : Block {
}
public abstract class Markdig.Syntax.Block : MarkdownObject {
    [CompilerGeneratedAttribute]
private ContainerBlock <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private BlockParser <Parser>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOpen>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBreakable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveAfterProcessInlines>k__BackingField;
    [CompilerGeneratedAttribute]
private ProcessInlineDelegate ProcessInlinesBegin;
    [CompilerGeneratedAttribute]
private ProcessInlineDelegate ProcessInlinesEnd;
    public ContainerBlock Parent { get; internal set; }
    public BlockParser Parser { get; }
    public bool IsOpen { get; public set; }
    public bool IsBreakable { get; public set; }
    public bool RemoveAfterProcessInlines { get; public set; }
    protected Block(BlockParser parser);
    [CompilerGeneratedAttribute]
public sealed virtual ContainerBlock get_Parent();
    [CompilerGeneratedAttribute]
internal void set_Parent(ContainerBlock value);
    [CompilerGeneratedAttribute]
public sealed virtual BlockParser get_Parser();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsOpen();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsOpen(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsBreakable();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsBreakable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RemoveAfterProcessInlines();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RemoveAfterProcessInlines(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ProcessInlinesBegin(ProcessInlineDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ProcessInlinesBegin(ProcessInlineDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ProcessInlinesEnd(ProcessInlineDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ProcessInlinesEnd(ProcessInlineDelegate value);
    internal void OnProcessInlinesBegin(InlineProcessor state);
    internal void OnProcessInlinesEnd(InlineProcessor state);
    public void UpdateSpanEnd(int spanEnd);
}
[ExtensionAttribute]
public static class Markdig.Syntax.BlockExtensions : object {
    [ExtensionAttribute]
public static Block FindBlockAtPosition(Block rootBlock, int position);
    [ExtensionAttribute]
public static int FindClosestLine(MarkdownDocument root, int line);
    [ExtensionAttribute]
public static Block FindClosestBlock(Block rootBlock, int line);
    [ExtensionAttribute]
public static bool ContainsPosition(Block block, int position);
    [ExtensionAttribute]
public static int CompareToPosition(Block block, int position);
}
public static class Markdig.Syntax.CharIteratorHelper : object {
    public static bool TrimStartAndCountNewLines(T& iterator, Int32& countNewLines);
}
public class Markdig.Syntax.CodeBlock : LeafBlock {
    public CodeBlock(BlockParser parser);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{GetType().Name} Count = {Count}")]
public abstract class Markdig.Syntax.ContainerBlock : Block {
    private Block[] children;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public Block LastChild { get; }
    public int Count { get; private set; }
    public bool IsReadOnly { get; }
    public Block Item { get; public set; }
    protected ContainerBlock(BlockParser parser);
    public Block get_LastChild();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Block> System.Collections.Generic.IEnumerable<Markdig.Syntax.Block>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(Block item);
    private void EnsureCapacity(int min);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Block item);
    public sealed virtual void CopyTo(Block[] array, int arrayIndex);
    public sealed virtual bool Remove(Block item);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int IndexOf(Block item);
    public sealed virtual void Insert(int index, Block item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual Block get_Item(int index);
    public sealed virtual void set_Item(int index, Block value);
    public void Sort(IComparer`1<Block> comparer);
    public void Sort(Comparison`1<Block> comparison);
}
public class Markdig.Syntax.FencedCodeBlock : CodeBlock {
    [CompilerGeneratedAttribute]
private string <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FencedCharCount>k__BackingField;
    [CompilerGeneratedAttribute]
private char <FencedChar>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndentCount>k__BackingField;
    public string Info { get; public set; }
    public string Arguments { get; public set; }
    public int FencedCharCount { get; public set; }
    public char FencedChar { get; public set; }
    internal int IndentCount { get; internal set; }
    public FencedCodeBlock(BlockParser parser);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Info();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Info(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Arguments();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Arguments(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_FencedCharCount();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FencedCharCount(int value);
    [CompilerGeneratedAttribute]
public sealed virtual char get_FencedChar();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FencedChar(char value);
    [CompilerGeneratedAttribute]
internal int get_IndentCount();
    [CompilerGeneratedAttribute]
internal void set_IndentCount(int value);
}
[DebuggerDisplayAttribute("{GetType().Name} Line: {Line}, {Lines} Level: {Level}")]
public class Markdig.Syntax.HeadingBlock : LeafBlock {
    [CompilerGeneratedAttribute]
private char <HeaderChar>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Level>k__BackingField;
    public char HeaderChar { get; public set; }
    public int Level { get; public set; }
    public HeadingBlock(BlockParser parser);
    [CompilerGeneratedAttribute]
public char get_HeaderChar();
    [CompilerGeneratedAttribute]
public void set_HeaderChar(char value);
    [CompilerGeneratedAttribute]
public int get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(int value);
}
public class Markdig.Syntax.HtmlBlock : LeafBlock {
    [CompilerGeneratedAttribute]
private HtmlBlockType <Type>k__BackingField;
    public HtmlBlockType Type { get; public set; }
    public HtmlBlock(BlockParser parser);
    [CompilerGeneratedAttribute]
public HtmlBlockType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(HtmlBlockType value);
}
public enum Markdig.Syntax.HtmlBlockType : Enum {
    public int value__;
    public static HtmlBlockType DocumentType;
    public static HtmlBlockType CData;
    public static HtmlBlockType Comment;
    public static HtmlBlockType ProcessingInstruction;
    public static HtmlBlockType ScriptPreOrStyle;
    public static HtmlBlockType InterruptingBlock;
    public static HtmlBlockType NonInterruptingBlock;
}
public interface Markdig.Syntax.IBlock {
    public int Column { get; public set; }
    public int Line { get; public set; }
    public ContainerBlock Parent { get; }
    public BlockParser Parser { get; }
    public bool IsOpen { get; public set; }
    public bool IsBreakable { get; public set; }
    public bool RemoveAfterProcessInlines { get; public set; }
    public abstract virtual int get_Column();
    public abstract virtual void set_Column(int value);
    public abstract virtual int get_Line();
    public abstract virtual void set_Line(int value);
    public abstract virtual ContainerBlock get_Parent();
    public abstract virtual BlockParser get_Parser();
    public abstract virtual bool get_IsOpen();
    public abstract virtual void set_IsOpen(bool value);
    public abstract virtual bool get_IsBreakable();
    public abstract virtual void set_IsBreakable(bool value);
    public abstract virtual bool get_RemoveAfterProcessInlines();
    public abstract virtual void set_RemoveAfterProcessInlines(bool value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProcessInlinesBegin(ProcessInlineDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProcessInlinesBegin(ProcessInlineDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProcessInlinesEnd(ProcessInlineDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProcessInlinesEnd(ProcessInlineDelegate value);
}
public interface Markdig.Syntax.IFencedBlock {
    public string Info { get; public set; }
    public string Arguments { get; public set; }
    public int FencedCharCount { get; public set; }
    public char FencedChar { get; public set; }
    public abstract virtual string get_Info();
    public abstract virtual void set_Info(string value);
    public abstract virtual string get_Arguments();
    public abstract virtual void set_Arguments(string value);
    public abstract virtual int get_FencedCharCount();
    public abstract virtual void set_FencedCharCount(int value);
    public abstract virtual char get_FencedChar();
    public abstract virtual void set_FencedChar(char value);
}
public interface Markdig.Syntax.IMarkdownObject {
    public abstract virtual void SetData(object key, object value);
    public abstract virtual bool ContainsData(object key);
    public abstract virtual object GetData(object key);
    public abstract virtual bool RemoveData(object key);
}
[DebuggerDisplayAttribute("<{Url}>")]
public class Markdig.Syntax.Inlines.AutolinkInline : LeafInline {
    [CompilerGeneratedAttribute]
private bool <IsEmail>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public bool IsEmail { get; public set; }
    public string Url { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsEmail();
    [CompilerGeneratedAttribute]
public void set_IsEmail(bool value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    public virtual string ToString();
}
[DebuggerDisplayAttribute("`{Content}`")]
public class Markdig.Syntax.Inlines.CodeInline : LeafInline {
    [CompilerGeneratedAttribute]
private char <Delimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    public char Delimiter { get; public set; }
    public string Content { get; public set; }
    [CompilerGeneratedAttribute]
public char get_Delimiter();
    [CompilerGeneratedAttribute]
public void set_Delimiter(char value);
    [CompilerGeneratedAttribute]
public string get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(string value);
}
public class Markdig.Syntax.Inlines.ContainerInline : Inline {
    [CompilerGeneratedAttribute]
private Inline <FirstChild>k__BackingField;
    [CompilerGeneratedAttribute]
private Inline <LastChild>k__BackingField;
    public Inline FirstChild { get; private set; }
    public Inline LastChild { get; private set; }
    [CompilerGeneratedAttribute]
public Inline get_FirstChild();
    [CompilerGeneratedAttribute]
private void set_FirstChild(Inline value);
    [CompilerGeneratedAttribute]
public Inline get_LastChild();
    [CompilerGeneratedAttribute]
private void set_LastChild(Inline value);
    public void Clear();
    public virtual ContainerInline AppendChild(Inline child);
    public bool ContainsChild(Inline childToFind);
    public IEnumerable`1<T> FindDescendants();
    public void MoveChildrenAfter(Inline parent);
    public void EmbraceChildrenBy(ContainerInline container);
    protected virtual void OnChildInsert(Inline child);
    protected virtual void OnChildRemove(Inline child);
    protected virtual void DumpChildTo(TextWriter writer, int level);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<Inline> System.Collections.Generic.IEnumerable<Markdig.Syntax.Inlines.Inline>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DebuggerDisplayAttribute("{ToLiteral()} {Type}")]
public abstract class Markdig.Syntax.Inlines.DelimiterInline : ContainerInline {
    [CompilerGeneratedAttribute]
private InlineParser <Parser>k__BackingField;
    [CompilerGeneratedAttribute]
private DelimiterType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsActive>k__BackingField;
    public InlineParser Parser { get; }
    public DelimiterType Type { get; public set; }
    public bool IsActive { get; public set; }
    protected DelimiterInline(InlineParser parser);
    [CompilerGeneratedAttribute]
public InlineParser get_Parser();
    [CompilerGeneratedAttribute]
public DelimiterType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(DelimiterType value);
    [CompilerGeneratedAttribute]
public bool get_IsActive();
    [CompilerGeneratedAttribute]
public void set_IsActive(bool value);
    public abstract virtual string ToLiteral();
    public void ReplaceByLiteral();
}
[FlagsAttribute]
public enum Markdig.Syntax.Inlines.DelimiterType : Enum {
    public int value__;
    public static DelimiterType Undefined;
    public static DelimiterType Open;
    public static DelimiterType Close;
}
public class Markdig.Syntax.Inlines.EmphasisDelimiterInline : DelimiterInline {
    [CompilerGeneratedAttribute]
private EmphasisDescriptor <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private char <DelimiterChar>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DelimiterCount>k__BackingField;
    public EmphasisDescriptor Descriptor { get; }
    public char DelimiterChar { get; }
    public int DelimiterCount { get; public set; }
    public EmphasisDelimiterInline(InlineParser parser, EmphasisDescriptor descriptor);
    [CompilerGeneratedAttribute]
public EmphasisDescriptor get_Descriptor();
    [CompilerGeneratedAttribute]
public char get_DelimiterChar();
    [CompilerGeneratedAttribute]
public int get_DelimiterCount();
    [CompilerGeneratedAttribute]
public void set_DelimiterCount(int value);
    public virtual string ToLiteral();
}
[DebuggerDisplayAttribute("{DelimiterChar} Strong: {IsDouble}")]
public class Markdig.Syntax.Inlines.EmphasisInline : ContainerInline {
    [CompilerGeneratedAttribute]
private char <DelimiterChar>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDouble>k__BackingField;
    public char DelimiterChar { get; public set; }
    public bool IsDouble { get; public set; }
    [CompilerGeneratedAttribute]
public char get_DelimiterChar();
    [CompilerGeneratedAttribute]
public void set_DelimiterChar(char value);
    [CompilerGeneratedAttribute]
public bool get_IsDouble();
    [CompilerGeneratedAttribute]
public void set_IsDouble(bool value);
}
[DebuggerDisplayAttribute("{Original} -> {Transcoded}")]
public class Markdig.Syntax.Inlines.HtmlEntityInline : LeafInline {
    [CompilerGeneratedAttribute]
private StringSlice <Original>k__BackingField;
    [CompilerGeneratedAttribute]
private StringSlice <Transcoded>k__BackingField;
    public StringSlice Original { get; public set; }
    public StringSlice Transcoded { get; public set; }
    [CompilerGeneratedAttribute]
public StringSlice get_Original();
    [CompilerGeneratedAttribute]
public void set_Original(StringSlice value);
    [CompilerGeneratedAttribute]
public StringSlice get_Transcoded();
    [CompilerGeneratedAttribute]
public void set_Transcoded(StringSlice value);
}
[DebuggerDisplayAttribute("{Tag}")]
public class Markdig.Syntax.Inlines.HtmlInline : LeafInline {
    [CompilerGeneratedAttribute]
private string <Tag>k__BackingField;
    public string Tag { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(string value);
}
public interface Markdig.Syntax.Inlines.IInline {
    public ContainerInline Parent { get; }
    public Inline PreviousSibling { get; }
    public Inline NextSibling { get; }
    public bool IsClosed { get; public set; }
    public abstract virtual ContainerInline get_Parent();
    public abstract virtual Inline get_PreviousSibling();
    public abstract virtual Inline get_NextSibling();
    public abstract virtual bool get_IsClosed();
    public abstract virtual void set_IsClosed(bool value);
}
public abstract class Markdig.Syntax.Inlines.Inline : MarkdownObject {
    [CompilerGeneratedAttribute]
private ContainerInline <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private Inline <PreviousSibling>k__BackingField;
    [CompilerGeneratedAttribute]
private Inline <NextSibling>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsClosed>k__BackingField;
    public ContainerInline Parent { get; internal set; }
    public Inline PreviousSibling { get; private set; }
    public Inline NextSibling { get; internal set; }
    public bool IsClosed { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual ContainerInline get_Parent();
    [CompilerGeneratedAttribute]
internal void set_Parent(ContainerInline value);
    [CompilerGeneratedAttribute]
public sealed virtual Inline get_PreviousSibling();
    [CompilerGeneratedAttribute]
private void set_PreviousSibling(Inline value);
    [CompilerGeneratedAttribute]
public sealed virtual Inline get_NextSibling();
    [CompilerGeneratedAttribute]
internal void set_NextSibling(Inline value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsClosed();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsClosed(bool value);
    public void InsertAfter(Inline next);
    public void InsertBefore(Inline previous);
    public void Remove();
    public Inline ReplaceBy(Inline inline, bool copyChildren);
    public bool ContainsParentOfType();
    public IEnumerable`1<T> FindParentOfType();
    public Inline FindBestParent();
    protected virtual void OnChildRemove(Inline child);
    protected virtual void OnChildInsert(Inline child);
    public void DumpTo(TextWriter writer);
    public void DumpTo(TextWriter writer, int level);
    protected virtual void DumpChildTo(TextWriter writer, int level);
}
public abstract class Markdig.Syntax.Inlines.LeafInline : Inline {
}
public class Markdig.Syntax.Inlines.LineBreakInline : LeafInline {
    [CompilerGeneratedAttribute]
private bool <IsHard>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBackslash>k__BackingField;
    public bool IsHard { get; public set; }
    public bool IsBackslash { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsHard();
    [CompilerGeneratedAttribute]
public void set_IsHard(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsBackslash();
    [CompilerGeneratedAttribute]
public void set_IsBackslash(bool value);
}
public class Markdig.Syntax.Inlines.LinkDelimiterInline : DelimiterInline {
    [CompilerGeneratedAttribute]
private bool <IsImage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    public SourceSpan LabelSpan;
    public bool IsImage { get; public set; }
    public string Label { get; public set; }
    public LinkDelimiterInline(InlineParser parser);
    [CompilerGeneratedAttribute]
public bool get_IsImage();
    [CompilerGeneratedAttribute]
public void set_IsImage(bool value);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(string value);
    public virtual string ToLiteral();
}
[DebuggerDisplayAttribute("Url: {Url} Title: {Title} Image: {IsImage}")]
public class Markdig.Syntax.Inlines.LinkInline : ContainerInline {
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private GetUrlDelegate <GetDynamicUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsImage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsShortcut>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAutoLink>k__BackingField;
    [CompilerGeneratedAttribute]
private LinkReferenceDefinition <Reference>k__BackingField;
    public Nullable`1<SourceSpan> UrlSpan;
    public Nullable`1<SourceSpan> TitleSpan;
    public Nullable`1<SourceSpan> LabelSpan;
    public string Url { get; public set; }
    public GetUrlDelegate GetDynamicUrl { get; public set; }
    public string Title { get; public set; }
    public string Label { get; public set; }
    public bool IsImage { get; public set; }
    public bool IsShortcut { get; public set; }
    public bool IsAutoLink { get; public set; }
    public LinkReferenceDefinition Reference { get; public set; }
    public LinkInline(string url, string title);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public GetUrlDelegate get_GetDynamicUrl();
    [CompilerGeneratedAttribute]
public void set_GetDynamicUrl(GetUrlDelegate value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(string value);
    [CompilerGeneratedAttribute]
public bool get_IsImage();
    [CompilerGeneratedAttribute]
public void set_IsImage(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsShortcut();
    [CompilerGeneratedAttribute]
public void set_IsShortcut(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAutoLink();
    [CompilerGeneratedAttribute]
public void set_IsAutoLink(bool value);
    [CompilerGeneratedAttribute]
public LinkReferenceDefinition get_Reference();
    [CompilerGeneratedAttribute]
public void set_Reference(LinkReferenceDefinition value);
}
[DebuggerDisplayAttribute("{Content}")]
public class Markdig.Syntax.Inlines.LiteralInline : LeafInline {
    public StringSlice Content;
    [CompilerGeneratedAttribute]
private bool <IsFirstCharacterEscaped>k__BackingField;
    public bool IsFirstCharacterEscaped { get; public set; }
    public LiteralInline(StringSlice content);
    public LiteralInline(string text);
    [CompilerGeneratedAttribute]
public bool get_IsFirstCharacterEscaped();
    [CompilerGeneratedAttribute]
public void set_IsFirstCharacterEscaped(bool value);
    public virtual string ToString();
}
[DebuggerDisplayAttribute("{GetType().Name} Line: {Line}, {Lines}")]
public abstract class Markdig.Syntax.LeafBlock : Block {
    public StringLineGroup Lines;
    [CompilerGeneratedAttribute]
private ContainerInline <Inline>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProcessInlines>k__BackingField;
    public ContainerInline Inline { get; public set; }
    public bool ProcessInlines { get; public set; }
    protected LeafBlock(BlockParser parser);
    [CompilerGeneratedAttribute]
public ContainerInline get_Inline();
    [CompilerGeneratedAttribute]
public void set_Inline(ContainerInline value);
    [CompilerGeneratedAttribute]
public bool get_ProcessInlines();
    [CompilerGeneratedAttribute]
public void set_ProcessInlines(bool value);
    public void AppendLine(StringSlice& slice, int column, int line, int sourceLinePosition);
}
public class Markdig.Syntax.LinkReferenceDefinition : LeafBlock {
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public SourceSpan LabelSpan;
    public SourceSpan UrlSpan;
    public SourceSpan TitleSpan;
    [CompilerGeneratedAttribute]
private CreateLinkInlineDelegate <CreateLinkInline>k__BackingField;
    public string Label { get; public set; }
    public string Url { get; public set; }
    public string Title { get; public set; }
    public CreateLinkInlineDelegate CreateLinkInline { get; public set; }
    public LinkReferenceDefinition(string label, string url, string title);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public CreateLinkInlineDelegate get_CreateLinkInline();
    [CompilerGeneratedAttribute]
public void set_CreateLinkInline(CreateLinkInlineDelegate value);
    public static bool TryParse(T& text, LinkReferenceDefinition& block);
}
[ExtensionAttribute]
public static class Markdig.Syntax.LinkReferenceDefinitionExtensions : object {
    private static object DocumentKey;
    private static LinkReferenceDefinitionExtensions();
    [ExtensionAttribute]
public static bool ContainsLinkReferenceDefinition(MarkdownDocument document, string label);
    [ExtensionAttribute]
public static void SetLinkReferenceDefinition(MarkdownDocument document, string label, LinkReferenceDefinition linkReferenceDefinition);
    [ExtensionAttribute]
public static bool TryGetLinkReferenceDefinition(MarkdownDocument document, string label, LinkReferenceDefinition& linkReferenceDefinition);
    [ExtensionAttribute]
public static LinkReferenceDefinitionGroup GetLinkReferenceDefinitions(MarkdownDocument document);
}
public class Markdig.Syntax.LinkReferenceDefinitionGroup : ContainerBlock {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, LinkReferenceDefinition> <Links>k__BackingField;
    public Dictionary`2<string, LinkReferenceDefinition> Links { get; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, LinkReferenceDefinition> get_Links();
    public void Set(string label, LinkReferenceDefinition link);
    public bool TryGet(string label, LinkReferenceDefinition& link);
}
public class Markdig.Syntax.ListBlock : ContainerBlock {
    [CompilerGeneratedAttribute]
private bool <IsOrdered>k__BackingField;
    [CompilerGeneratedAttribute]
private char <BulletType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OrderedStart>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultOrderedStart>k__BackingField;
    [CompilerGeneratedAttribute]
private char <OrderedDelimiter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLoose>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CountAllBlankLines>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CountBlankLinesReset>k__BackingField;
    public bool IsOrdered { get; public set; }
    public char BulletType { get; public set; }
    public string OrderedStart { get; public set; }
    public string DefaultOrderedStart { get; public set; }
    public char OrderedDelimiter { get; public set; }
    public bool IsLoose { get; public set; }
    internal int CountAllBlankLines { get; internal set; }
    internal int CountBlankLinesReset { get; internal set; }
    public ListBlock(BlockParser parser);
    [CompilerGeneratedAttribute]
public bool get_IsOrdered();
    [CompilerGeneratedAttribute]
public void set_IsOrdered(bool value);
    [CompilerGeneratedAttribute]
public char get_BulletType();
    [CompilerGeneratedAttribute]
public void set_BulletType(char value);
    [CompilerGeneratedAttribute]
public string get_OrderedStart();
    [CompilerGeneratedAttribute]
public void set_OrderedStart(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultOrderedStart();
    [CompilerGeneratedAttribute]
public void set_DefaultOrderedStart(string value);
    [CompilerGeneratedAttribute]
public char get_OrderedDelimiter();
    [CompilerGeneratedAttribute]
public void set_OrderedDelimiter(char value);
    [CompilerGeneratedAttribute]
public bool get_IsLoose();
    [CompilerGeneratedAttribute]
public void set_IsLoose(bool value);
    [CompilerGeneratedAttribute]
internal int get_CountAllBlankLines();
    [CompilerGeneratedAttribute]
internal void set_CountAllBlankLines(int value);
    [CompilerGeneratedAttribute]
internal int get_CountBlankLinesReset();
    [CompilerGeneratedAttribute]
internal void set_CountBlankLinesReset(int value);
}
public class Markdig.Syntax.ListItemBlock : ContainerBlock {
    [CompilerGeneratedAttribute]
private int <ColumnWidth>k__BackingField;
    internal int ColumnWidth { get; internal set; }
    public ListItemBlock(BlockParser parser);
    [CompilerGeneratedAttribute]
internal int get_ColumnWidth();
    [CompilerGeneratedAttribute]
internal void set_ColumnWidth(int value);
}
public class Markdig.Syntax.MarkdownDocument : ContainerBlock {
}
public abstract class Markdig.Syntax.MarkdownObject : object {
    private DataEntry[] attachedDatas;
    private int count;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    public SourceSpan Span;
    public int Column { get; public set; }
    public int Line { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_Column();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Column(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Line();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Line(int value);
    public string ToPositionText();
    public sealed virtual void SetData(object key, object value);
    public sealed virtual bool ContainsData(object key);
    public sealed virtual object GetData(object key);
    public sealed virtual bool RemoveData(object key);
}
[ExtensionAttribute]
public static class Markdig.Syntax.MarkdownObjectExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<MarkdownObject> Descendants(MarkdownObject markdownObject);
    [ExtensionAttribute]
public static IEnumerable`1<T> Descendants(ContainerInline inline);
    [ExtensionAttribute]
public static IEnumerable`1<T> Descendants(ContainerBlock block);
}
public class Markdig.Syntax.ParagraphBlock : LeafBlock {
    public int LastLine { get; }
    public ParagraphBlock(BlockParser parser);
    public int get_LastLine();
}
public class Markdig.Syntax.QuoteBlock : ContainerBlock {
    [CompilerGeneratedAttribute]
private char <QuoteChar>k__BackingField;
    public char QuoteChar { get; public set; }
    public QuoteBlock(BlockParser parser);
    [CompilerGeneratedAttribute]
public char get_QuoteChar();
    [CompilerGeneratedAttribute]
public void set_QuoteChar(char value);
}
public class Markdig.Syntax.SourceSpan : ValueType {
    public static SourceSpan Empty;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <End>k__BackingField;
    public int Start { get; public set; }
    public int End { get; public set; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public SourceSpan(int start, int end);
    private static SourceSpan();
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(int value);
    [CompilerGeneratedAttribute]
public int get_End();
    [CompilerGeneratedAttribute]
public void set_End(int value);
    public int get_Length();
    public bool get_IsEmpty();
    public sealed virtual bool Equals(SourceSpan other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(SourceSpan left, SourceSpan right);
    public static bool op_Inequality(SourceSpan left, SourceSpan right);
    public virtual string ToString();
}
public class Markdig.Syntax.ThematicBreakBlock : LeafBlock {
    [CompilerGeneratedAttribute]
private char <ThematicChar>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThematicCharCount>k__BackingField;
    public char ThematicChar { get; public set; }
    public int ThematicCharCount { get; public set; }
    public ThematicBreakBlock(BlockParser parser);
    [CompilerGeneratedAttribute]
public char get_ThematicChar();
    [CompilerGeneratedAttribute]
public void set_ThematicChar(char value);
    [CompilerGeneratedAttribute]
public int get_ThematicCharCount();
    [CompilerGeneratedAttribute]
public void set_ThematicCharCount(int value);
}
