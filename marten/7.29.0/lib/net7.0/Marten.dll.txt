[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class EventStoreOptionsExtensions : object {
    [ExtensionAttribute]
public static IEventStoreOptions MapEventTypeWithNameSuffix(IEventStoreOptions options, string eventTypeName, string suffix);
    [ExtensionAttribute]
public static IEventStoreOptions MapEventTypeWithNameSuffix(IEventStoreOptions options, string suffix);
    [ExtensionAttribute]
public static IEventStoreOptions MapEventTypeWithSchemaVersion(IEventStoreOptions options, UInt32 schemaVersion);
    [ExtensionAttribute]
public static IEventStoreOptions MapEventTypeWithSchemaVersion(IEventStoreOptions options, string eventTypeName, UInt32 schemaVersion);
    [ExtensionAttribute]
public static IEventStoreOptions Upcast(IEventStoreOptions options, JsonTransformation jsonTransformation);
    [ExtensionAttribute]
public static IEventStoreOptions Upcast(IEventStoreOptions options, Type eventType, JsonTransformation jsonTransformation);
    [ExtensionAttribute]
public static IEventStoreOptions Upcast(IEventStoreOptions options, UInt32 schemaVersion, JsonTransformation jsonTransformation);
    [ExtensionAttribute]
public static IEventStoreOptions Upcast(IEventStoreOptions options, Type eventType, UInt32 schemaVersion, JsonTransformation jsonTransformation);
    [ExtensionAttribute]
public static IEventStoreOptions Upcast(IEventStoreOptions options, UInt32 schemaVersion, Func`2<TOldEvent, TEvent> upcast);
    [ExtensionAttribute]
public static IEventStoreOptions Upcast(IEventStoreOptions options, UInt32 schemaVersion, Func`3<TOldEvent, CancellationToken, Task`1<TEvent>> upcastAsync);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.AdvancedOperations : object {
    private DocumentStore _store;
    public IDocumentCleaner Clean { get; }
    public ISerializer Serializer { get; }
    public List`1<IInitialData> InitialDataCollection { get; }
    internal AdvancedOperations(DocumentStore store);
    public IDocumentCleaner get_Clean();
    public ISerializer get_Serializer();
    [AsyncStateMachineAttribute("Marten.AdvancedOperations/<AdvanceHighWaterMarkToLatestAsync>d__6")]
public Task AdvanceHighWaterMarkToLatestAsync(CancellationToken token);
    public List`1<IInitialData> get_InitialDataCollection();
    [AsyncStateMachineAttribute("Marten.AdvancedOperations/<ResetAllData>d__9")]
public Task ResetAllData(CancellationToken cancellation);
    [AsyncStateMachineAttribute("Marten.AdvancedOperations/<ResetHiloSequenceFloor>d__10`1")]
public Task ResetHiloSequenceFloor(long floor);
    [AsyncStateMachineAttribute("Marten.AdvancedOperations/<ResetHiloSequenceFloor>d__11`1")]
public Task ResetHiloSequenceFloor(string tenantId, long floor);
    [AsyncStateMachineAttribute("Marten.AdvancedOperations/<FetchEventStoreStatistics>d__12")]
public Task`1<EventStoreStatistics> FetchEventStoreStatistics(string tenantId, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.AdvancedOperations/<AllProjectionProgress>d__13")]
public Task`1<IReadOnlyList`1<ShardState>> AllProjectionProgress(string tenantId, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.AdvancedOperations/<ProjectionProgressFor>d__14")]
public Task`1<long> ProjectionProgressFor(ShardName name, string tenantId, CancellationToken token);
    public Task EventProjectionScenario(Action`1<ProjectionScenario> configuration, CancellationToken ct);
    public IReadOnlyList`1<ShardName> AllAsyncProjectionShardNames();
    [AsyncStateMachineAttribute("Marten.AdvancedOperations/<RebuildSingleStreamAsync>d__17`1")]
public Task RebuildSingleStreamAsync(string id, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.AdvancedOperations/<RebuildSingleStreamAsync>d__18`1")]
public Task RebuildSingleStreamAsync(Guid id, CancellationToken token);
    public Task AddMartenManagedTenantsAsync(CancellationToken token, String[] tenantIds);
    [AsyncStateMachineAttribute("Marten.AdvancedOperations/<AddMartenManagedTenantsAsync>d__20")]
public Task`1<TablePartitionStatus[]> AddMartenManagedTenantsAsync(CancellationToken token, Dictionary`2<string, string> tenantIdToPartitionMapping);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IEnumerable`1<AsyncProjectionShard> <AllAsyncProjectionShardNames>b__16_1(IProjectionSource x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.AdvancedOptions : object {
    private StoreOptions _storeOptions;
    private Nullable`1<EnumStorage> _duplicatedFieldEnumStorage;
    [CompilerGeneratedAttribute]
private HiloSettings <HiloSequenceDefaults>k__BackingField;
    [CompilerGeneratedAttribute]
private PostgresqlMigrator <Migrator>k__BackingField;
    [CompilerGeneratedAttribute]
private MultiHostSettings <MultiHostSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DuplicatedFieldUseTimestampWithoutTimeZoneForDateTime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DefaultTenantUsageEnabled>k__BackingField;
    public HiloSettings HiloSequenceDefaults { get; }
    public PostgresqlMigrator Migrator { get; }
    public MultiHostSettings MultiHostSettings { get; }
    public bool DuplicatedFieldUseTimestampWithoutTimeZoneForDateTime { get; public set; }
    public EnumStorage DuplicatedFieldEnumStorage { get; public set; }
    private IReadOnlyHiloSettings Marten.IReadOnlyAdvancedOptions.HiloSequenceDefaults { get; }
    public bool DefaultTenantUsageEnabled { get; public set; }
    internal AdvancedOptions(StoreOptions storeOptions);
    public void ModifySerializer(Action`1<ISerializer> configure);
    [CompilerGeneratedAttribute]
public HiloSettings get_HiloSequenceDefaults();
    [CompilerGeneratedAttribute]
public PostgresqlMigrator get_Migrator();
    [CompilerGeneratedAttribute]
public MultiHostSettings get_MultiHostSettings();
    [CompilerGeneratedAttribute]
public bool get_DuplicatedFieldUseTimestampWithoutTimeZoneForDateTime();
    [CompilerGeneratedAttribute]
public void set_DuplicatedFieldUseTimestampWithoutTimeZoneForDateTime(bool value);
    public sealed virtual EnumStorage get_DuplicatedFieldEnumStorage();
    public void set_DuplicatedFieldEnumStorage(EnumStorage value);
    private sealed virtual override IReadOnlyHiloSettings Marten.IReadOnlyAdvancedOptions.get_HiloSequenceDefaults();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DefaultTenantUsageEnabled();
    [CompilerGeneratedAttribute]
public void set_DefaultTenantUsageEnabled(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.AsyncConfigureMartenApplication : object {
    private IList`1<IAsyncConfigureMarten> _configures;
    private StoreOptions _options;
    public AsyncConfigureMartenApplication(IEnumerable`1<IAsyncConfigureMarten> configures, StoreOptions options);
    [AsyncStateMachineAttribute("Marten.AsyncConfigureMartenApplication/<StartAsync>d__3")]
public sealed virtual Task StartAsync(CancellationToken cancellationToken);
    public sealed virtual Task StopAsync(CancellationToken cancellationToken);
}
public enum Marten.BulkInsertMode : Enum {
    public int value__;
    public static BulkInsertMode InsertsOnly;
    public static BulkInsertMode IgnoreDuplicates;
    public static BulkInsertMode OverwriteExisting;
}
public enum Marten.Casing : Enum {
    public int value__;
    public static Casing Default;
    public static Casing CamelCase;
    public static Casing SnakeCase;
}
public enum Marten.CollectionStorage : Enum {
    public int value__;
    public static CollectionStorage Default;
    public static CollectionStorage AsArray;
}
internal class Marten.CompiledQueryCollection : object {
    private DocumentStore _store;
    private DocumentTracking _tracking;
    private ImHashMap`2<Type, ICompiledQuerySource> _querySources;
    public CompiledQueryCollection(DocumentTracking tracking, DocumentStore store);
    internal ICompiledQuerySource GetCompiledQuerySourceFor(ICompiledQuery`2<TDoc, TOut> query, QuerySession session);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("This will be removed in Marten 8. Prefer NpgsqlDataSource instead")]
public class Marten.ConnectionFactory : object {
    private INpgsqlDataSourceFactory _npgsqlDataSourceFactory;
    private Lazy`1<string> _connectionString;
    public ConnectionFactory(INpgsqlDataSourceFactory npgsqlDataSourceFactory, Func`1<string> connectionSource);
    public ConnectionFactory(INpgsqlDataSourceFactory npgsqlDataSourceFactory, string connectionString);
    public sealed virtual NpgsqlConnection Create();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.ConsoleMartenLogger : object {
    [NullableAttribute("2")]
private Stopwatch _stopwatch;
    public sealed virtual IMartenSessionLogger StartSession(IQuerySession session);
    public sealed virtual void SchemaChange(string sql);
    public sealed virtual void LogSuccess(NpgsqlCommand command);
    public sealed virtual void LogSuccess(NpgsqlBatch batch);
    private static object GetParameterValue(NpgsqlParameter p);
    public sealed virtual void LogFailure(NpgsqlCommand command, Exception ex);
    public sealed virtual void LogFailure(NpgsqlBatch batch, Exception ex);
    public sealed virtual void LogFailure(Exception ex, string message);
    public sealed virtual void RecordSavedChanges(IDocumentSession session, IChangeSet commit);
    public sealed virtual void OnBeforeExecute(NpgsqlCommand command);
    public sealed virtual void OnBeforeExecute(NpgsqlBatch batch);
}
internal class Marten.DefaultMartenLogger : object {
    private Stopwatch _stopwatch;
    [CompilerGeneratedAttribute]
private ILogger <Inner>k__BackingField;
    public ILogger Inner { get; }
    public DefaultMartenLogger(ILogger inner);
    [CompilerGeneratedAttribute]
public ILogger get_Inner();
    public sealed virtual IMartenSessionLogger StartSession(IQuerySession session);
    public sealed virtual void SchemaChange(string sql);
    public sealed virtual void LogSuccess(NpgsqlCommand command);
    public sealed virtual void LogSuccess(NpgsqlBatch batch);
    public sealed virtual void LogFailure(NpgsqlCommand command, Exception ex);
    public sealed virtual void LogFailure(NpgsqlBatch batch, Exception ex);
    public sealed virtual void RecordSavedChanges(IDocumentSession session, IChangeSet commit);
    public sealed virtual void OnBeforeExecute(NpgsqlCommand command);
    public sealed virtual void LogFailure(Exception ex, string message);
    public sealed virtual void OnBeforeExecute(NpgsqlBatch batch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.DocumentMappingBuilder`1 : object {
    private IList`1<Action`1<DocumentMapping`1<T>>> _alterations;
    unknown Action`1<DocumentMapping`1<T>> AlterFirst {internal set; }
    unknown Action`1<DocumentMapping`1<T>> Alter {internal set; }
    public Type DocumentType { get; }
    internal void set_AlterFirst(Action`1<DocumentMapping`1<T>> value);
    internal void set_Alter(Action`1<DocumentMapping`1<T>> value);
    public sealed virtual DocumentMapping Build(StoreOptions options);
    public sealed virtual Type get_DocumentType();
    public sealed virtual void Include(IDocumentMappingBuilder include);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Marten.DocumentSessionListenerBase : object {
    public virtual void BeforeSaveChanges(IDocumentSession session);
    public virtual Task BeforeSaveChangesAsync(IDocumentSession session, CancellationToken token);
    public virtual void AfterCommit(IDocumentSession session, IChangeSet commit);
    public virtual Task AfterCommitAsync(IDocumentSession session, IChangeSet commit, CancellationToken token);
    public virtual void DocumentLoaded(object id, object document);
    public virtual void DocumentAddedForStorage(object id, object document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.DocumentStore : object {
    [NullableAttribute("0")]
private CompiledQueryCollection _dirtyTrackedCompiledQueries;
    [NullableAttribute("0")]
private CompiledQueryCollection _identityMapCompiledQueries;
    [NullableAttribute("0")]
private CompiledQueryCollection _lightweightCompiledQueries;
    [NullableAttribute("0")]
private CompiledQueryCollection _queryOnlyCompiledQueries;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private string <JasperFx.CodeGeneration.ICodeFileCollection.ChildNamespace>k__BackingField;
    private IMartenLogger _logger;
    private INpgsqlDataSourceFactory dataSourceFactory;
    [CompilerGeneratedAttribute]
private ISerializer <Serializer>k__BackingField;
    [CompilerGeneratedAttribute]
private StoreOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private AdvancedOperations <Advanced>k__BackingField;
    [CompilerGeneratedAttribute]
private IDiagnostics <Diagnostics>k__BackingField;
    [NullableAttribute("0")]
public GenerationRules Rules { get; }
    [NullableAttribute("0")]
private string JasperFx.CodeGeneration.ICodeFileCollection.ChildNamespace { get; }
    public ITenancy Tenancy { get; }
    public EventGraph Events { get; }
    public StorageFeatures StorageFeatures { get; }
    public ISerializer Serializer { get; }
    public StoreOptions Options { get; }
    private IReadOnlyStoreOptions Marten.IDocumentStore.Options { get; }
    public AdvancedOperations Advanced { get; }
    public IDiagnostics Diagnostics { get; }
    [NullableAttribute("0")]
public IMartenStorage Storage { get; }
    [NullableAttribute("0")]
private IMartenDatabase Marten.IMartenStorage.Database { get; }
    public DocumentStore(StoreOptions options);
    [NullableContextAttribute("0")]
public sealed virtual GenerationRules get_Rules();
    [NullableContextAttribute("0")]
private sealed virtual override IReadOnlyList`1<ICodeFile> JasperFx.CodeGeneration.ICodeFileCollection.BuildFiles();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private sealed virtual override string JasperFx.CodeGeneration.ICodeFileCollection.get_ChildNamespace();
    [NullableContextAttribute("0")]
internal ICompiledQuerySource GetCompiledQuerySourceFor(ICompiledQuery`2<TDoc, TOut> query, QuerySession session);
    private void warnIfAsyncDaemonIsDisabledWithAsyncProjections();
    public ITenancy get_Tenancy();
    public EventGraph get_Events();
    public StorageFeatures get_StorageFeatures();
    [CompilerGeneratedAttribute]
public ISerializer get_Serializer();
    [CompilerGeneratedAttribute]
public StoreOptions get_Options();
    private sealed virtual override IReadOnlyStoreOptions Marten.IDocumentStore.get_Options();
    public virtual void Dispose();
    public sealed virtual ValueTask DisposeAsync();
    [CompilerGeneratedAttribute]
public sealed virtual AdvancedOperations get_Advanced();
    public sealed virtual void BulkInsert(IReadOnlyCollection`1<T> documents, BulkInsertMode mode, int batchSize);
    public sealed virtual void BulkInsertEnlistTransaction(IReadOnlyCollection`1<T> documents, Transaction transaction, BulkInsertMode mode, int batchSize);
    public sealed virtual void BulkInsertDocuments(IEnumerable`1<object> documents, BulkInsertMode mode, int batchSize);
    public sealed virtual void BulkInsert(string tenantId, IReadOnlyCollection`1<T> documents, BulkInsertMode mode, int batchSize);
    public sealed virtual void BulkInsertDocuments(string tenantId, IEnumerable`1<object> documents, BulkInsertMode mode, int batchSize);
    public sealed virtual Task BulkInsertAsync(IReadOnlyCollection`1<T> documents, BulkInsertMode mode, int batchSize, CancellationToken cancellation);
    public sealed virtual Task BulkInsertEnlistTransactionAsync(IReadOnlyCollection`1<T> documents, Transaction transaction, BulkInsertMode mode, int batchSize, CancellationToken cancellation);
    [AsyncStateMachineAttribute("Marten.DocumentStore/<BulkInsertAsync>d__41`1")]
public sealed virtual Task BulkInsertAsync(string tenantId, IReadOnlyCollection`1<T> documents, BulkInsertMode mode, int batchSize, CancellationToken cancellation);
    public sealed virtual Task BulkInsertDocumentsAsync(IEnumerable`1<object> documents, BulkInsertMode mode, int batchSize, CancellationToken cancellation);
    [AsyncStateMachineAttribute("Marten.DocumentStore/<BulkInsertDocumentsAsync>d__43")]
public sealed virtual Task BulkInsertDocumentsAsync(string tenantId, IEnumerable`1<object> documents, BulkInsertMode mode, int batchSize, CancellationToken cancellation);
    [CompilerGeneratedAttribute]
public sealed virtual IDiagnostics get_Diagnostics();
    [ObsoleteAttribute("Opening a session without explicitly providing desired type may be dropped in next Marten version.
Use explicit method like `LightweightSession`, `IdentitySession` or `DirtyTrackedSession`.
We recommend using lightweight session by default. Read more in documentation: https://martendb.io/documents/sessions.html.")]
public sealed virtual IDocumentSession OpenSession(SessionOptions options);
    [ObsoleteAttribute("Opening a session without explicitly providing desired type may be dropped in next Marten version.
Use explicit method like `LightweightSession`, `IdentitySession` or `DirtyTrackedSession`.
We recommend using lightweight session by default. Read more in documentation: https://martendb.io/documents/sessions.html.")]
public sealed virtual IDocumentSession OpenSession(DocumentTracking tracking, IsolationLevel isolationLevel);
    [ObsoleteAttribute("Opening a session without explicitly providing desired type may be dropped in next Marten version.
Use explicit method like `LightweightSession`, `IdentitySession` or `DirtyTrackedSession`.
We recommend using lightweight session by default. Read more in documentation: https://martendb.io/documents/sessions.html.")]
public sealed virtual IDocumentSession OpenSession(string tenantId, DocumentTracking tracking, IsolationLevel isolationLevel);
    public sealed virtual IDocumentSession IdentitySession(IsolationLevel isolationLevel);
    public sealed virtual IDocumentSession IdentitySession(string tenantId, IsolationLevel isolationLevel);
    public sealed virtual IDocumentSession IdentitySession(SessionOptions options);
    public sealed virtual Task`1<IDocumentSession> IdentitySerializableSessionAsync(CancellationToken cancellation);
    public sealed virtual Task`1<IDocumentSession> IdentitySerializableSessionAsync(string tenantId, CancellationToken cancellation);
    public sealed virtual Task`1<IDocumentSession> IdentitySerializableSessionAsync(SessionOptions options, CancellationToken cancellation);
    public sealed virtual IDocumentSession DirtyTrackedSession(IsolationLevel isolationLevel);
    public sealed virtual IDocumentSession DirtyTrackedSession(string tenantId, IsolationLevel isolationLevel);
    public sealed virtual IDocumentSession DirtyTrackedSession(SessionOptions options);
    public sealed virtual Task`1<IDocumentSession> DirtyTrackedSerializableSessionAsync(CancellationToken cancellation);
    public sealed virtual Task`1<IDocumentSession> DirtyTrackedSerializableSessionAsync(string tenantId, CancellationToken cancellation);
    public sealed virtual Task`1<IDocumentSession> DirtyTrackedSerializableSessionAsync(SessionOptions options, CancellationToken cancellation);
    public sealed virtual IDocumentSession LightweightSession(IsolationLevel isolationLevel);
    public sealed virtual IDocumentSession LightweightSession(string tenantId, IsolationLevel isolationLevel);
    public sealed virtual IDocumentSession LightweightSession(SessionOptions options);
    public sealed virtual Task`1<IDocumentSession> LightweightSerializableSessionAsync(CancellationToken cancellation);
    public sealed virtual Task`1<IDocumentSession> LightweightSerializableSessionAsync(string tenantId, CancellationToken cancellation);
    public sealed virtual Task`1<IDocumentSession> LightweightSerializableSessionAsync(SessionOptions options, CancellationToken cancellation);
    public sealed virtual IQuerySession QuerySession(SessionOptions options);
    public sealed virtual IQuerySession QuerySession();
    public sealed virtual IQuerySession QuerySession(string tenantId);
    [AsyncStateMachineAttribute("Marten.DocumentStore/<QuerySerializableSessionAsync>d__71")]
public sealed virtual Task`1<IQuerySession> QuerySerializableSessionAsync(SessionOptions options, CancellationToken cancellation);
    public sealed virtual Task`1<IQuerySession> QuerySerializableSessionAsync(CancellationToken cancellation);
    public sealed virtual Task`1<IQuerySession> QuerySerializableSessionAsync(string tenantId, CancellationToken cancellation);
    [NullableContextAttribute("2")]
public IProjectionDaemon BuildProjectionDaemon(string tenantIdOrDatabaseIdentifier, ILogger logger);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Marten.DocumentStore/<BuildProjectionDaemonAsync>d__75")]
public sealed virtual ValueTask`1<IProjectionDaemon> BuildProjectionDaemonAsync(string tenantIdOrDatabaseIdentifier, ILogger logger);
    [AsyncStateMachineAttribute("Marten.DocumentStore/<OpenSerializableSessionAsync>d__76")]
[ObsoleteAttribute("Opening a session without explicitly providing desired type may be dropped in next Marten version.
Use explicit method like `LightweightSession`, `IdentitySession` or `DirtyTrackedSession`.
We recommend using lightweight session by default. Read more in documentation: https://martendb.io/documents/sessions.html.")]
public sealed virtual Task`1<IDocumentSession> OpenSerializableSessionAsync(SessionOptions options, CancellationToken token);
    [ObsoleteAttribute("Opening a session without explicitly providing desired type may be dropped in next Marten version.
Use explicit method like `LightweightSession`, `IdentitySession` or `DirtyTrackedSession`.
We recommend using lightweight session by default. Read more in documentation: https://martendb.io/documents/sessions.html.")]
public Task`1<IDocumentSession> OpenSessionAsync(DocumentTracking tracking, IsolationLevel isolationLevel, CancellationToken token);
    [ObsoleteAttribute("Opening a session without explicitly providing desired type may be dropped in next Marten version.
Use explicit method like `LightweightSession`, `IdentitySession` or `DirtyTrackedSession`.
We recommend using lightweight session by default. Read more in documentation: https://martendb.io/documents/sessions.html.")]
public Task`1<IDocumentSession> OpenSessionAsync(string tenantId, DocumentTracking tracking, IsolationLevel isolationLevel, CancellationToken token);
    public static DocumentStore For(string connectionString);
    public static DocumentStore For();
    public static DocumentStore For(Action`1<StoreOptions> configure);
    private IDocumentSession openSession(SessionOptions options);
    [NullableContextAttribute("2")]
private void AssertTenantOrDatabaseIdentifierIsValid(string tenantIdOrDatabaseIdentifier);
    [NullableContextAttribute("0")]
public sealed virtual IMartenStorage get_Storage();
    [NullableContextAttribute("0")]
private sealed virtual override String[] Marten.IMartenStorage.AllSchemaNames();
    [NullableContextAttribute("0")]
private sealed virtual override IEnumerable`1<ISchemaObject> Marten.IMartenStorage.AllObjects();
    [NullableContextAttribute("0")]
private sealed virtual override string Marten.IMartenStorage.ToDatabaseScript();
    [NullableContextAttribute("0")]
private sealed virtual override Task Marten.IMartenStorage.WriteCreationScriptToFile(string filename);
    [NullableContextAttribute("0")]
private sealed virtual override Task Marten.IMartenStorage.WriteScriptsByType(string directory);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.DocumentStore/<Marten-IMartenStorage-ApplyAllConfiguredChangesToDatabaseAsync>d__91")]
private sealed virtual override Task Marten.IMartenStorage.ApplyAllConfiguredChangesToDatabaseAsync(Nullable`1<AutoCreate> override);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.DocumentStore/<Marten-IMartenStorage-AllDatabases>d__92")]
private sealed virtual override ValueTask`1<IReadOnlyList`1<IMartenDatabase>> Marten.IMartenStorage.AllDatabases();
    [NullableContextAttribute("0")]
private sealed virtual override Task`1<SchemaMigration> Marten.IMartenStorage.CreateMigrationAsync();
    [NullableContextAttribute("0")]
private sealed virtual override IMartenDatabase Marten.IMartenStorage.get_Database();
    [NullableContextAttribute("0")]
private sealed virtual override ValueTask`1<IMartenDatabase> Marten.IMartenStorage.FindOrCreateDatabase(string tenantIdOrDatabaseIdentifier);
    [NullableContextAttribute("0")]
private MartenDatabase nulloDatabase();
}
internal class Marten.DocumentStoreSource`1 : object {
    [NullableContextAttribute("1")]
public sealed virtual IDocumentStore Resolve(IServiceProvider services);
}
public enum Marten.DocumentTracking : Enum {
    public int value__;
    public static DocumentTracking None;
    public static DocumentTracking IdentityOnly;
    public static DocumentTracking DirtyTracking;
    public static DocumentTracking QueryOnly;
}
[ExtensionAttribute]
public static class Marten.Events.AggregateToExtensions : object {
    [ExtensionAttribute]
public static T AggregateTo(IMartenQueryable`1<IEvent> queryable, T state);
    private static void setIdentity(QuerySession session, T aggregate, IEnumerable`1<IEvent> events);
    [AsyncStateMachineAttribute("Marten.Events.AggregateToExtensions/<AggregateToAsync>d__2`1")]
[ExtensionAttribute]
public static Task`1<T> AggregateToAsync(IMartenQueryable`1<IEvent> queryable, T state, CancellationToken token);
    [ExtensionAttribute]
public static T AggregateTo(IQueryable`1<IEvent> queryable, T state);
    [AsyncStateMachineAttribute("Marten.Events.AggregateToExtensions/<AggregateToAsync>d__4`1")]
[ExtensionAttribute]
public static Task`1<T> AggregateToAsync(IQueryable`1<IEvent> queryable, T state, CancellationToken token);
}
internal class Marten.Events.Aggregation.AggregateVersioning`1 : object {
    private AggregationScope _scope;
    private Lazy`1<Action`2<T, IEvent>> _setValue;
    [CompilerGeneratedAttribute]
private ILiveAggregator`1<T> <Inner>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <VersionMember>k__BackingField;
    public ILiveAggregator`1<T> Inner { get; public set; }
    public MemberInfo VersionMember { get; private set; }
    public AggregateVersioning`1(AggregationScope scope);
    [CompilerGeneratedAttribute]
public ILiveAggregator`1<T> get_Inner();
    [CompilerGeneratedAttribute]
public void set_Inner(ILiveAggregator`1<T> value);
    [CompilerGeneratedAttribute]
public sealed virtual MemberInfo get_VersionMember();
    [CompilerGeneratedAttribute]
private void set_VersionMember(MemberInfo value);
    private sealed virtual override void Marten.Events.Aggregation.IAggregateVersioning.TrySetVersion(object aggregate, IEvent lastEvent);
    private sealed virtual override long Marten.Events.Aggregation.IAggregateVersioning.GetVersion(object aggregate);
    public sealed virtual void TrySetVersion(T aggregate, IEvent lastEvent);
    public sealed virtual T Build(IReadOnlyList`1<IEvent> events, IQuerySession session, T snapshot);
    [AsyncStateMachineAttribute("Marten.Events.Aggregation.AggregateVersioning`1/<BuildAsync>d__15")]
public sealed virtual ValueTask`1<T> BuildAsync(IReadOnlyList`1<IEvent> events, IQuerySession session, T snapshot, CancellationToken cancellation);
    private Action`2<T, IEvent> buildAction();
    private Expression determineBody(ParameterExpression aggregate, MethodCallExpression accessVersion);
    public void Override(Expression`1<Func`2<T, int>> expression);
    public void Override(Expression`1<Func`2<T, long>> expression);
    public long GetVersion(T aggregate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Marten.Events.Aggregation.AggregationRuntime`2 : object {
    [CompilerGeneratedAttribute]
private StoreOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private IAggregateProjection <Projection>k__BackingField;
    [CompilerGeneratedAttribute]
private IEventSlicer`2<TDoc, TId> <Slicer>k__BackingField;
    [CompilerGeneratedAttribute]
private IDocumentStorage`2<TDoc, TId> <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private IAggregateVersioning <Versioning>k__BackingField;
    internal StoreOptions Options { get; }
    public IAggregateProjection Projection { get; }
    public IEventSlicer`2<TDoc, TId> Slicer { get; }
    public IDocumentStorage`2<TDoc, TId> Storage { get; }
    public IAggregateVersioning Versioning { get; public set; }
    public AggregationRuntime`2(IDocumentStore store, IAggregateProjection projection, IEventSlicer`2<TDoc, TId> slicer, IDocumentStorage`2<TDoc, TId> storage);
    [CompilerGeneratedAttribute]
internal StoreOptions get_Options();
    [CompilerGeneratedAttribute]
public IAggregateProjection get_Projection();
    [CompilerGeneratedAttribute]
public sealed virtual IEventSlicer`2<TDoc, TId> get_Slicer();
    [CompilerGeneratedAttribute]
public sealed virtual IDocumentStorage`2<TDoc, TId> get_Storage();
    [AsyncStateMachineAttribute("Marten.Events.Aggregation.AggregationRuntime`2/<ApplyChangesAsync>d__13")]
public sealed virtual ValueTask ApplyChangesAsync(DocumentSessionBase session, EventSlice`2<TDoc, TId> slice, CancellationToken cancellation, ProjectionLifecycle lifecycle);
    [AsyncStateMachineAttribute("Marten.Events.Aggregation.AggregationRuntime`2/<processPossibleSideEffects>d__14")]
private Task processPossibleSideEffects(DocumentSessionBase session, EventSlice`2<TDoc, TId> slice);
    [CompilerGeneratedAttribute]
public sealed virtual IAggregateVersioning get_Versioning();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Versioning(IAggregateVersioning value);
    public virtual bool IsNew(EventSlice`2<TDoc, TId> slice);
    public sealed virtual void Apply(IDocumentOperations operations, IReadOnlyList`1<StreamAction> streams);
    [AsyncStateMachineAttribute("Marten.Events.Aggregation.AggregationRuntime`2/<ApplyAsync>d__21")]
public sealed virtual Task ApplyAsync(IDocumentOperations operations, IReadOnlyList`1<StreamAction> streams, CancellationToken cancellation);
    [AsyncStateMachineAttribute("Marten.Events.Aggregation.AggregationRuntime`2/<GroupEvents>d__22")]
public sealed virtual ValueTask`1<EventRangeGroup> GroupEvents(DocumentStore store, IMartenDatabase database, EventRange range, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<TDoc> ApplyEvent(IQuerySession session, EventSlice`2<TDoc, TId> slice, IEvent evt, TDoc aggregate, CancellationToken cancellationToken);
    public TDoc CreateDefault(IEvent event);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ApplyAsync>b__21_0(StreamAction x);
}
public enum Marten.Events.Aggregation.AggregationScope : Enum {
    public int value__;
    public static AggregationScope SingleStream;
    public static AggregationScope MultiStream;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Marten.Events.Aggregation.AsyncLiveAggregatorBase`1 : object {
    public abstract virtual ValueTask`1<T> BuildAsync(IReadOnlyList`1<IEvent> events, IQuerySession session, T snapshot, CancellationToken cancellation);
    public sealed virtual T Build(IReadOnlyList`1<IEvent> events, IQuerySession session, T snapshot);
    public T CreateDefault(IEvent event);
}
public class Marten.Events.Aggregation.ByStreamId`1 : object {
    [NullableContextAttribute("1")]
public sealed virtual ValueTask`1<IReadOnlyList`1<EventSlice`2<TDoc, Guid>>> SliceInlineActions(IQuerySession querySession, IEnumerable`1<StreamAction> streams);
    [NullableContextAttribute("1")]
public sealed virtual ValueTask`1<IReadOnlyList`1<TenantSliceGroup`2<TDoc, Guid>>> SliceAsyncEvents(IQuerySession querySession, List`1<IEvent> events);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Events.Aggregation.ByStreamId`2 : object {
    private Func`2<Guid, TId> _converter;
    public ByStreamId`2(ValueTypeInfo valueType);
    public sealed virtual ValueTask`1<IReadOnlyList`1<EventSlice`2<TDoc, TId>>> SliceInlineActions(IQuerySession querySession, IEnumerable`1<StreamAction> streams);
    public sealed virtual ValueTask`1<IReadOnlyList`1<TenantSliceGroup`2<TDoc, TId>>> SliceAsyncEvents(IQuerySession querySession, List`1<IEvent> events);
}
public class Marten.Events.Aggregation.ByStreamKey`1 : object {
    [NullableContextAttribute("1")]
public sealed virtual ValueTask`1<IReadOnlyList`1<EventSlice`2<TDoc, string>>> SliceInlineActions(IQuerySession querySession, IEnumerable`1<StreamAction> streams);
    [NullableContextAttribute("1")]
public sealed virtual ValueTask`1<IReadOnlyList`1<TenantSliceGroup`2<TDoc, string>>> SliceAsyncEvents(IQuerySession querySession, List`1<IEvent> events);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Events.Aggregation.ByStreamKey`2 : object {
    private Func`2<string, TId> _converter;
    public ByStreamKey`2(ValueTypeInfo valueType);
    public sealed virtual ValueTask`1<IReadOnlyList`1<EventSlice`2<TDoc, TId>>> SliceInlineActions(IQuerySession querySession, IEnumerable`1<StreamAction> streams);
    public sealed virtual ValueTask`1<IReadOnlyList`1<TenantSliceGroup`2<TDoc, TId>>> SliceAsyncEvents(IQuerySession querySession, List`1<IEvent> events);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Marten.Events.Aggregation.CrossStreamAggregationRuntime`2 : AggregationRuntime`2<TDoc, TId> {
    public CrossStreamAggregationRuntime`2(IDocumentStore store, IAggregateProjection projection, IEventSlicer`2<TDoc, TId> slicer, IDocumentStorage`2<TDoc, TId> storage);
    public virtual bool IsNew(EventSlice`2<TDoc, TId> slice);
}
public abstract class Marten.Events.Aggregation.CustomProjection`2 : ProjectionBase {
    private IDocumentStorage`2<TDoc, TId> _storage;
    [CompilerGeneratedAttribute]
private IEventSlicer`2<TDoc, TId> <Slicer>k__BackingField;
    [CompilerGeneratedAttribute]
private IAggregateVersioning <Versioning>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <AllEventTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncOptions <Options>k__BackingField;
    public IEventSlicer`2<TDoc, TId> Slicer { get; protected internal set; }
    public IAggregateVersioning Versioning { get; public set; }
    private IDocumentStorage`2<TDoc, TId> Marten.Events.Aggregation.IAggregationRuntime<TDoc,TId>.Storage { get; }
    private Type Marten.Events.Projections.IReadOnlyProjectionData.ProjectionType { get; }
    public Type AggregateType { get; }
    public Type[] AllEventTypes { get; public set; }
    public AsyncOptions Options { get; }
    public sealed virtual bool IsSingleStream();
    public virtual ValueTask RaiseSideEffects(IDocumentOperations operations, IEventSlice`1<TDoc> slice);
    [CompilerGeneratedAttribute]
public sealed virtual IEventSlicer`2<TDoc, TId> get_Slicer();
    [CompilerGeneratedAttribute]
protected internal void set_Slicer(IEventSlicer`2<TDoc, TId> value);
    private sealed virtual override void Marten.Events.Projections.IProjection.Apply(IDocumentOperations operations, IReadOnlyList`1<StreamAction> streams);
    [AsyncStateMachineAttribute("Marten.Events.Aggregation.CustomProjection`2/<Marten-Events-Projections-IProjection-ApplyAsync>d__9")]
private sealed virtual override Task Marten.Events.Projections.IProjection.ApplyAsync(IDocumentOperations operations, IReadOnlyList`1<StreamAction> streams, CancellationToken cancellation);
    [AsyncStateMachineAttribute("Marten.Events.Aggregation.CustomProjection`2/<Marten-Events-Aggregation-IAggregationRuntime-GroupEvents>d__10")]
private sealed virtual override ValueTask`1<EventRangeGroup> Marten.Events.Aggregation.IAggregationRuntime.GroupEvents(DocumentStore store, IMartenDatabase database, EventRange range, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Marten.Events.Aggregation.CustomProjection`2/<ApplyChangesAsync>d__11")]
public virtual ValueTask ApplyChangesAsync(DocumentSessionBase session, EventSlice`2<TDoc, TId> slice, CancellationToken cancellation, ProjectionLifecycle lifecycle);
    public virtual ValueTask`1<TDoc> BuildAsync(IQuerySession session, TDoc snapshot, IReadOnlyList`1<IEvent> events);
    public virtual TDoc Apply(TDoc snapshot, IReadOnlyList`1<IEvent> events);
    [CompilerGeneratedAttribute]
public sealed virtual IAggregateVersioning get_Versioning();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Versioning(IAggregateVersioning value);
    public virtual bool IsNew(EventSlice`2<TDoc, TId> slice);
    private sealed virtual override IDocumentStorage`2<TDoc, TId> Marten.Events.Aggregation.IAggregationRuntime<TDoc,TId>.get_Storage();
    public ValueTask`1<IReadOnlyList`1<TenantSliceGroup`2<TDoc, TId>>> GroupEventRange(DocumentStore store, IMartenDatabase database, EventRange range, CancellationToken cancellation);
    private sealed virtual override Type Marten.Events.Projections.IReadOnlyProjectionData.get_ProjectionType();
    [IteratorStateMachineAttribute("Marten.Events.Aggregation.CustomProjection`2/<Marten-Events-Projections-IProjectionSource-PublishedTypes>d__24")]
private sealed virtual override IEnumerable`1<Type> Marten.Events.Projections.IProjectionSource.PublishedTypes();
    private sealed virtual override IReadOnlyList`1<AsyncProjectionShard> Marten.Events.Projections.IProjectionSource.AsyncProjectionShards(DocumentStore store);
    [AsyncStateMachineAttribute("Marten.Events.Aggregation.CustomProjection`2/<Marten-Events-Projections-IProjectionSource-GroupEvents>d__26")]
private sealed virtual override ValueTask`1<EventRangeGroup> Marten.Events.Projections.IProjectionSource.GroupEvents(DocumentStore store, IMartenDatabase daemonDatabase, EventRange range, CancellationToken cancellationToken);
    private sealed virtual override IProjection Marten.Events.Projections.IProjectionSource.Build(DocumentStore store);
    internal virtual void AssembleAndAssertValidity();
    public void UseCustomSlicer(IEventSlicer`2<TDoc, TId> custom);
    private void readDocumentStorage(DocumentStore store);
    public void AggregateEvents(Action`1<EventSlicer`2<TDoc, TId>> configure);
    public void AggregateByStream();
    public sealed virtual Type get_AggregateType();
    [CompilerGeneratedAttribute]
public sealed virtual Type[] get_AllEventTypes();
    [CompilerGeneratedAttribute]
public void set_AllEventTypes(Type[] value);
    public sealed virtual bool MatchesAnyDeleteType(StreamAction action);
    public sealed virtual bool MatchesAnyDeleteType(IEventSlice slice);
    public sealed virtual bool AppliesTo(IEnumerable`1<Type> eventTypes);
    [CompilerGeneratedAttribute]
public sealed virtual AsyncOptions get_Options();
    public sealed virtual object ApplyMetadata(object aggregate, IEvent lastEvent);
    public virtual TDoc ApplyMetadata(TDoc aggregate, IEvent lastEvent);
    public sealed virtual void ConfigureAggregateMapping(DocumentMapping mapping, StoreOptions storeOptions);
    private sealed virtual override TDoc Marten.Events.Projections.ILiveAggregator<TDoc>.Build(IReadOnlyList`1<IEvent> events, IQuerySession session, TDoc snapshot);
    [AsyncStateMachineAttribute("Marten.Events.Aggregation.CustomProjection`2/<Marten-Events-Projections-ILiveAggregator<TDoc>-BuildAsync>d__49")]
private sealed virtual override ValueTask`1<TDoc> Marten.Events.Projections.ILiveAggregator<TDoc>.BuildAsync(IReadOnlyList`1<IEvent> events, IQuerySession session, TDoc snapshot, CancellationToken cancellation);
}
[ExtensionAttribute]
public static class Marten.Events.Aggregation.EventListExtensions : object {
    [ExtensionAttribute]
public static void FanOut(List`1<IEvent> events, Func`2<TSource, IEnumerable`1<TChild>> fanOutFunc);
    [ExtensionAttribute]
public static void FanOut(List`1<IEvent> events, Func`2<IEvent`1<TSource>, IEnumerable`1<TChild>> fanOutFunc);
}
public class Marten.Events.Aggregation.EventSlicer`2 : object {
    private List`1<IFanOutRule> _afterGroupingFanoutRules;
    private List`1<IFanOutRule> _beforeGroupingFanoutRules;
    private IList`1<IGrouper`1<TId>> _groupers;
    private IList`1<IAggregateGrouper`1<TId>> _lookupGroupers;
    private bool _groupByTenant;
    [AsyncStateMachineAttribute("Marten.Events.Aggregation.EventSlicer`2/<SliceInlineActions>d__5")]
public sealed virtual ValueTask`1<IReadOnlyList`1<EventSlice`2<TDoc, TId>>> SliceInlineActions(IQuerySession querySession, IEnumerable`1<StreamAction> streams);
    [AsyncStateMachineAttribute("Marten.Events.Aggregation.EventSlicer`2/<SliceAsyncEvents>d__6")]
public sealed virtual ValueTask`1<IReadOnlyList`1<TenantSliceGroup`2<TDoc, TId>>> SliceAsyncEvents(IQuerySession querySession, List`1<IEvent> events);
    public EventSlicer`2<TDoc, TId> GroupByTenant();
    internal bool HasAnyRules();
    [IteratorStateMachineAttribute("Marten.Events.Aggregation.EventSlicer`2/<DetermineEventTypes>d__9")]
internal IEnumerable`1<Type> DetermineEventTypes();
    public EventSlicer`2<TDoc, TId> Identity(Func`2<TEvent, TId> identityFunc);
    public EventSlicer`2<TDoc, TId> Identities(Func`2<TEvent, IReadOnlyList`1<TId>> identitiesFunc);
    public EventSlicer`2<TDoc, TId> CustomGrouping(IAggregateGrouper`1<TId> grouper);
    public EventSlicer`2<TDoc, TId> FanOut(Func`2<TEvent, IEnumerable`1<TChild>> fanOutFunc, FanoutMode mode);
    public EventSlicer`2<TDoc, TId> FanOut(Func`2<IEvent`1<TEvent>, IEnumerable`1<TChild>> fanOutFunc, FanoutMode mode);
    private EventSlicer`2<TDoc, TId> FanOut(IFanOutRule fanout, FanoutMode mode);
    [AsyncStateMachineAttribute("Marten.Events.Aggregation.EventSlicer`2/<groupSingleTenant>d__16")]
private Task`1<TenantSliceGroup`2<TDoc, TId>> groupSingleTenant(Tenant tenant, IQuerySession querySession, IList`1<IEvent> events);
}
internal class Marten.Events.Aggregation.FanOutEventDataOperator`2 : FanOutOperator`1<TSource> {
    private Func`2<TSource, IEnumerable`1<TTarget>> _fanOutFunc;
    public FanOutEventDataOperator`2(Func`2<TSource, IEnumerable`1<TTarget>> fanOutFunc);
    public virtual void Apply(List`1<IEvent> events);
}
internal class Marten.Events.Aggregation.FanOutEventOperator`2 : FanOutOperator`1<TSource> {
    private Func`2<IEvent`1<TSource>, IEnumerable`1<TTarget>> _fanOutFunc;
    public FanOutEventOperator`2(Func`2<IEvent`1<TSource>, IEnumerable`1<TTarget>> fanOutFunc);
    public virtual void Apply(List`1<IEvent> events);
}
internal abstract class Marten.Events.Aggregation.FanOutOperator`1 : object {
    [CompilerGeneratedAttribute]
private FanoutMode <Mode>k__BackingField;
    public FanoutMode Mode { get; public set; }
    public Type OriginatingType { get; }
    [CompilerGeneratedAttribute]
public sealed virtual FanoutMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(FanoutMode value);
    public sealed virtual Type get_OriginatingType();
    public abstract virtual void Apply(List`1<IEvent> events);
}
public abstract class Marten.Events.Aggregation.GeneratedAggregateProjectionBase`1 : GeneratedProjection {
    private Lazy`1<Type[]> _allEventTypes;
    internal ApplyMethodCollection _applyMethods;
    internal CreateMethodCollection _createMethods;
    private string _inlineAggregationHandlerType;
    private string _liveAggregationTypeName;
    internal ShouldDeleteMethodCollection _shouldDeleteMethods;
    private AggregateVersioning`1<T> _versioning;
    internal IDocumentMapping _aggregateMapping;
    private GeneratedType _inlineGeneratedType;
    private Type _inlineType;
    private bool _isAsync;
    private GeneratedType _liveGeneratedType;
    private Type _liveType;
    private IAggregationRuntime _runtime;
    [CompilerGeneratedAttribute]
private IList`1<Type> <DeleteEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Type> <TransformedEvents>k__BackingField;
    internal IList`1<Type> DeleteEvents { get; }
    internal IList`1<Type> TransformedEvents { get; }
    private Type Marten.Events.Aggregation.IAggregateProjection.AggregateType { get; }
    public Type[] AllEventTypes { get; }
    protected GeneratedAggregateProjectionBase`1(AggregationScope scope);
    public sealed virtual ILiveAggregator`1<T> Build(StoreOptions options);
    internal string SourceCode();
    internal void Compile(StoreOptions options);
    internal void Compile(StoreOptions options, GenerationRules rules);
    protected virtual bool tryAttachTypes(Assembly assembly, StoreOptions options);
    protected virtual void assembleTypes(GeneratedAssembly assembly, StoreOptions options);
    private void referenceAssembliesAndTypes(GeneratedAssembly assembly);
    private static void addUsingNamespaces(GeneratedAssembly assembly);
    private void checkAndSetAsyncFlag();
    private void validateAndSetAggregateMapping(StoreOptions options);
    private void buildAggregationTypes(GeneratedAssembly assembly);
    protected virtual IProjection buildProjectionObject(DocumentStore store);
    internal ILiveAggregator`1<T> BuildLiveAggregator();
    internal IAggregationRuntime BuildRuntime(DocumentStore store);
    protected virtual bool needsSettersGenerated();
    private void buildInlineAggregationType(GeneratedAssembly assembly);
    private GeneratedMethod buildApplyEventMethod();
    private void buildLiveAggregationType(GeneratedAssembly assembly);
    public virtual ValueTask RaiseSideEffects(IDocumentOperations operations, IEventSlice`1<T> slice);
    public abstract virtual bool IsSingleStream();
    [CompilerGeneratedAttribute]
internal IList`1<Type> get_DeleteEvents();
    [CompilerGeneratedAttribute]
internal IList`1<Type> get_TransformedEvents();
    private sealed virtual override Type Marten.Events.Aggregation.IAggregateProjection.get_AggregateType();
    public virtual T ApplyMetadata(T aggregate, IEvent lastEvent);
    private sealed virtual override object Marten.Events.Aggregation.IAggregateProjection.ApplyMetadata(object aggregate, IEvent lastEvent);
    public sealed virtual bool AppliesTo(IEnumerable`1<Type> eventTypes);
    public sealed virtual Type[] get_AllEventTypes();
    public sealed virtual bool MatchesAnyDeleteType(IEventSlice slice);
    public sealed virtual bool MatchesAnyDeleteType(StreamAction action);
    public void VersionIdentity(Expression`1<Func`2<T, int>> expression);
    public void VersionIdentity(Expression`1<Func`2<T, long>> expression);
    protected abstract virtual object buildEventSlicer(StoreOptions options);
    protected abstract virtual Type baseTypeForAggregationRuntime();
    [MartenIgnoreAttribute]
public void FilterIncomingEventsOnStreamType();
    protected sealed virtual ValueTask`1<EventRangeGroup> groupEvents(DocumentStore store, IMartenDatabase daemonDatabase, EventRange range, CancellationToken cancellationToken);
    protected virtual Type[] determineEventTypes();
    public virtual void ConfigureAggregateMapping(DocumentMapping mapping, StoreOptions storeOptions);
    public sealed virtual IAggregationSteps`1<T> CreateEvent(Func`2<TEvent, T> creator);
    public sealed virtual IAggregationSteps`1<T> CreateEvent(Func`3<TEvent, IQuerySession, Task`1<T>> creator);
    public sealed virtual IAggregationSteps`1<T> DeleteEvent();
    public sealed virtual IAggregationSteps`1<T> DeleteEvent(Func`2<TEvent, bool> shouldDelete);
    public sealed virtual IAggregationSteps`1<T> DeleteEvent(Func`3<T, TEvent, bool> shouldDelete);
    public sealed virtual IAggregationSteps`1<T> DeleteEventAsync(Func`4<IQuerySession, T, TEvent, Task`1<bool>> shouldDelete);
    public sealed virtual IAggregationSteps`1<T> ProjectEvent(Action`1<T> handler);
    public sealed virtual IAggregationSteps`1<T> ProjectEvent(Action`2<T, TEvent> handler);
    public sealed virtual IAggregationSteps`1<T> ProjectEvent(Func`3<T, TEvent, T> handler);
    public sealed virtual IAggregationSteps`1<T> ProjectEvent(Func`2<T, T> handler);
    public sealed virtual IAggregationSteps`1<T> ProjectEvent(Action`3<IQuerySession, T, TEvent> handler);
    public sealed virtual IAggregationSteps`1<T> ProjectEventAsync(Func`4<IQuerySession, T, TEvent, Task> handler);
    public sealed virtual IAggregationSteps`1<T> ProjectEventAsync(Func`4<IQuerySession, T, TEvent, Task`1<T>> handler);
    public sealed virtual IAggregationSteps`1<T> TransformsEvent();
    protected virtual void specialAssertValid();
    protected abstract virtual IEnumerable`1<string> validateDocumentIdentity(StoreOptions options, DocumentMapping mapping);
    [IteratorStateMachineAttribute("Marten.Events.Aggregation.GeneratedAggregateProjectionBase`1/<ValidateConfiguration>d__74")]
internal virtual IEnumerable`1<string> ValidateConfiguration(StoreOptions options);
    internal virtual void AssembleAndAssertValidity();
    [CompilerGeneratedAttribute]
private bool <tryAttachTypes>b__4_0(Type x);
    [CompilerGeneratedAttribute]
private bool <tryAttachTypes>b__4_1(Type x);
    [CompilerGeneratedAttribute]
private Type[] <.ctor>b__32_0();
    [CompilerGeneratedAttribute]
private bool <AppliesTo>b__45_0(Type type);
}
[NullableContextAttribute("1")]
public interface Marten.Events.Aggregation.IAggregateProjection {
    public Type AggregateType { get; }
    public string ProjectionName { get; }
    public Type[] AllEventTypes { get; }
    public ProjectionLifecycle Lifecycle { get; public set; }
    public AsyncOptions Options { get; }
    public UInt32 ProjectionVersion { get; public set; }
    public abstract virtual Type get_AggregateType();
    public abstract virtual string get_ProjectionName();
    public abstract virtual Type[] get_AllEventTypes();
    public abstract virtual ProjectionLifecycle get_Lifecycle();
    public abstract virtual void set_Lifecycle(ProjectionLifecycle value);
    public abstract virtual bool MatchesAnyDeleteType(StreamAction action);
    public abstract virtual bool MatchesAnyDeleteType(IEventSlice slice);
    public abstract virtual bool AppliesTo(IEnumerable`1<Type> eventTypes);
    public abstract virtual AsyncOptions get_Options();
    public abstract virtual UInt32 get_ProjectionVersion();
    public abstract virtual void set_ProjectionVersion(UInt32 value);
    public abstract virtual object ApplyMetadata(object aggregate, IEvent lastEvent);
    public abstract virtual void ConfigureAggregateMapping(DocumentMapping mapping, StoreOptions storeOptions);
}
[NullableContextAttribute("1")]
public interface Marten.Events.Aggregation.IAggregateProjectionWithSideEffects`1 {
    public abstract virtual ValueTask RaiseSideEffects(IDocumentOperations operations, IEventSlice`1<T> slice);
    public abstract virtual bool IsSingleStream();
}
public interface Marten.Events.Aggregation.IAggregateVersioning {
    public MemberInfo VersionMember { get; }
    public abstract virtual MemberInfo get_VersionMember();
    public abstract virtual void TrySetVersion(object aggregate, IEvent lastEvent);
    public abstract virtual long GetVersion(object aggregate);
}
public interface Marten.Events.Aggregation.IAggregateVersioning`1 {
    public abstract virtual void TrySetVersion(T aggregate, IEvent lastEvent);
}
public interface Marten.Events.Aggregation.IAggregationRuntime {
    public IAggregateVersioning Versioning { get; public set; }
    public abstract virtual IAggregateVersioning get_Versioning();
    public abstract virtual void set_Versioning(IAggregateVersioning value);
    public abstract virtual ValueTask`1<EventRangeGroup> GroupEvents(DocumentStore store, IMartenDatabase database, EventRange range, CancellationToken cancellationToken);
}
public interface Marten.Events.Aggregation.IAggregationRuntime`2 {
    public IDocumentStorage`2<TDoc, TId> Storage { get; }
    public IEventSlicer`2<TDoc, TId> Slicer { get; }
    public abstract virtual IDocumentStorage`2<TDoc, TId> get_Storage();
    public abstract virtual ValueTask ApplyChangesAsync(DocumentSessionBase session, EventSlice`2<TDoc, TId> slice, CancellationToken cancellation, ProjectionLifecycle lifecycle);
    public abstract virtual bool IsNew(EventSlice`2<TDoc, TId> slice);
    public abstract virtual IEventSlicer`2<TDoc, TId> get_Slicer();
}
public interface Marten.Events.Aggregation.IAggregationSteps`1 {
    public abstract virtual IAggregationSteps`1<T> CreateEvent(Func`2<TEvent, T> creator);
    public abstract virtual IAggregationSteps`1<T> CreateEvent(Func`3<TEvent, IQuerySession, Task`1<T>> creator);
    public abstract virtual IAggregationSteps`1<T> DeleteEvent();
    public abstract virtual IAggregationSteps`1<T> DeleteEvent(Func`2<TEvent, bool> shouldDelete);
    public abstract virtual IAggregationSteps`1<T> DeleteEvent(Func`3<T, TEvent, bool> shouldDelete);
    public abstract virtual IAggregationSteps`1<T> DeleteEventAsync(Func`4<IQuerySession, T, TEvent, Task`1<bool>> shouldDelete);
    public abstract virtual IAggregationSteps`1<T> ProjectEvent(Action`1<T> handler);
    public abstract virtual IAggregationSteps`1<T> ProjectEvent(Action`2<T, TEvent> handler);
    public abstract virtual IAggregationSteps`1<T> ProjectEvent(Func`3<T, TEvent, T> handler);
    public abstract virtual IAggregationSteps`1<T> ProjectEvent(Func`2<T, T> handler);
    public abstract virtual IAggregationSteps`1<T> ProjectEvent(Action`3<IQuerySession, T, TEvent> handler);
    public abstract virtual IAggregationSteps`1<T> ProjectEventAsync(Func`4<IQuerySession, T, TEvent, Task> handler);
    public abstract virtual IAggregationSteps`1<T> ProjectEventAsync(Func`4<IQuerySession, T, TEvent, Task`1<T>> handler);
    public abstract virtual IAggregationSteps`1<T> TransformsEvent();
}
public interface Marten.Events.Aggregation.IEventGrouping`1 {
    public abstract virtual void AddEvent(TId id, IEvent event);
    public abstract virtual void AddEvents(TId id, IEnumerable`1<IEvent> events);
    public abstract virtual void AddEvents(Func`2<TEvent, TId> singleIdSource, IEnumerable`1<IEvent> events);
    public abstract virtual void AddEvents(Func`2<TEvent, IEnumerable`1<TId>> multipleIdSource, IEnumerable`1<IEvent> events);
    public abstract virtual void AddEventsWithMetadata(Func`2<IEvent`1<TEvent>, TId> singleIdSource, IEnumerable`1<IEvent> events);
    public abstract virtual void FanOutOnEach(Func`2<TSource, IEnumerable`1<TChild>> fanOutFunc);
    public abstract virtual void AddEventsWithMetadata(Func`2<IEvent`1<TEvent>, IEnumerable`1<TId>> multipleIdSource, IEnumerable`1<IEvent> events);
}
[NullableContextAttribute("1")]
public interface Marten.Events.Aggregation.IEventSlicer`2 {
    public abstract virtual ValueTask`1<IReadOnlyList`1<EventSlice`2<TDoc, TId>>> SliceInlineActions(IQuerySession querySession, IEnumerable`1<StreamAction> streams);
    public abstract virtual ValueTask`1<IReadOnlyList`1<TenantSliceGroup`2<TDoc, TId>>> SliceAsyncEvents(IQuerySession querySession, List`1<IEvent> events);
}
public interface Marten.Events.Aggregation.IMessageBatch {
}
public interface Marten.Events.Aggregation.IMessageOutbox {
    public abstract virtual ValueTask`1<IMessageBatch> CreateBatch(DocumentSessionBase session);
}
public interface Marten.Events.Aggregation.IMessageSink {
    public abstract virtual ValueTask PublishAsync(T message);
}
public interface Marten.Events.Aggregation.ISingleStreamSlicer {
}
public interface Marten.Events.Aggregation.ITenantSliceGroup`1 {
}
internal class Marten.Events.Aggregation.NulloMessageOutbox : object {
    public sealed virtual ValueTask PublishAsync(T message);
    public sealed virtual ValueTask`1<IMessageBatch> CreateBatch(DocumentSessionBase session);
    public sealed virtual Task AfterCommitAsync(IDocumentSession session, IChangeSet commit, CancellationToken token);
    public sealed virtual Task BeforeCommitAsync(IDocumentSession session, IChangeSet commit, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Marten.Events.Aggregation.SingleStreamProjection`1 : GeneratedAggregateProjectionBase`1<T> {
    public virtual bool IsSingleStream();
    protected sealed virtual object buildEventSlicer(StoreOptions options);
    public virtual void ConfigureAggregateMapping(DocumentMapping mapping, StoreOptions storeOptions);
    protected sealed virtual Type baseTypeForAggregationRuntime();
    internal bool IsIdTypeValidForStream(Type idType, StoreOptions options, Type& expectedType, ValueTypeInfo& valueType);
    [IteratorStateMachineAttribute("Marten.Events.Aggregation.SingleStreamProjection`1/<validateDocumentIdentity>d__6")]
protected sealed virtual IEnumerable`1<string> validateDocumentIdentity(StoreOptions options, DocumentMapping mapping);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Marten.Events.Aggregation.SyncLiveAggregatorBase`1 : object {
    public abstract virtual T Build(IReadOnlyList`1<IEvent> events, IQuerySession session, T snapshot);
    public sealed virtual ValueTask`1<T> BuildAsync(IReadOnlyList`1<IEvent> events, IQuerySession session, T snapshot, CancellationToken cancellation);
    public T CreateDefault(IEvent event);
}
public class Marten.Events.Aggregation.TenantSliceGroup`2 : object {
    private ActionBlock`1<EventSlice`2<TDoc, TId>> _builder;
    private ProjectionDocumentSession _session;
    [CompilerGeneratedAttribute]
private Tenant <Tenant>k__BackingField;
    [CompilerGeneratedAttribute]
private LightweightCache`2<TId, EventSlice`2<TDoc, TId>> <Slices>k__BackingField;
    public Tenant Tenant { get; }
    public LightweightCache`2<TId, EventSlice`2<TDoc, TId>> Slices { get; }
    public TenantSliceGroup`2(IQuerySession session, string tenantId);
    public TenantSliceGroup`2(Tenant tenant);
    public TenantSliceGroup`2(Tenant tenant, IEnumerable`1<EventSlice`2<TDoc, TId>> slices);
    [CompilerGeneratedAttribute]
public Tenant get_Tenant();
    [CompilerGeneratedAttribute]
public LightweightCache`2<TId, EventSlice`2<TDoc, TId>> get_Slices();
    public sealed virtual void AddEvents(Func`2<TEvent, TId> singleIdSource, IEnumerable`1<IEvent> events);
    public sealed virtual void AddEventsWithMetadata(Func`2<IEvent`1<TEvent>, TId> singleIdSource, IEnumerable`1<IEvent> events);
    public sealed virtual void FanOutOnEach(Func`2<TSource, IEnumerable`1<TChild>> fanOutFunc);
    public sealed virtual void AddEvents(Func`2<TEvent, IEnumerable`1<TId>> multipleIdSource, IEnumerable`1<IEvent> events);
    public sealed virtual void AddEventsWithMetadata(Func`2<IEvent`1<TEvent>, IEnumerable`1<TId>> multipleIdSource, IEnumerable`1<IEvent> events);
    public sealed virtual void AddEvent(TId id, IEvent event);
    public sealed virtual void AddEvents(TId id, IEnumerable`1<IEvent> events);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Marten.Events.Aggregation.TenantSliceGroup`2/<Start>d__19")]
internal Task Start(ProjectionUpdateBatch updateBatch, IAggregationRuntime`2<TDoc, TId> runtime, DocumentStore store, EventRangeGroup parent);
    [AsyncStateMachineAttribute("Marten.Events.Aggregation.TenantSliceGroup`2/<processEventSlices>d__20")]
private Task processEventSlices(IAggregationRuntime`2<TDoc, TId> runtime, IDocumentStore store, CancellationToken token);
    internal void ApplyFanOutRules(IReadOnlyList`1<IFanOutRule> rules);
    public void Reset();
    [CompilerGeneratedAttribute]
private EventSlice`2<TDoc, TId> <.ctor>b__3_0(TId id);
}
internal class Marten.Events.Aggregation.TenantSliceRange`2 : EventRangeGroup {
    private IAggregationRuntime`2<TDoc, TId> _runtime;
    private DocumentStore _store;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<TenantSliceGroup`2<TDoc, TId>> <Groups>k__BackingField;
    public IReadOnlyList`1<TenantSliceGroup`2<TDoc, TId>> Groups { get; private set; }
    public TenantSliceRange`2(DocumentStore store, IAggregationRuntime`2<TDoc, TId> runtime, EventRange range, IReadOnlyList`1<TenantSliceGroup`2<TDoc, TId>> groups, CancellationToken projectionCancellation);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<TenantSliceGroup`2<TDoc, TId>> get_Groups();
    [CompilerGeneratedAttribute]
private void set_Groups(IReadOnlyList`1<TenantSliceGroup`2<TDoc, TId>> value);
    protected virtual void reset();
    public virtual void Dispose();
    public virtual string ToString();
    [AsyncStateMachineAttribute("Marten.Events.Aggregation.TenantSliceRange`2/<ConfigureUpdateBatch>d__10")]
public virtual Task ConfigureUpdateBatch(ProjectionUpdateBatch batch);
    [AsyncStateMachineAttribute("Marten.Events.Aggregation.TenantSliceRange`2/<SkipEventSequence>d__11")]
public virtual ValueTask SkipEventSequence(long eventSequence, IMartenDatabase database);
}
internal class Marten.Events.Archiving.AllEventsFilter : object {
    public sealed virtual void Apply(ICommandBuilder builder);
}
[ExtensionAttribute]
public static class Marten.Events.Archiving.ArchivedEventExtensions : object {
    [ExtensionAttribute]
public static bool MaybeArchived(IEvent event);
}
internal class Marten.Events.Archiving.ArchiveStreamFunction : Function {
    internal static string Name;
    private EventGraph _events;
    public ArchiveStreamFunction(EventGraph events);
    public virtual void WriteCreateStatement(Migrator rules, TextWriter writer);
    private void writeWithPartitioning(TextWriter writer, string argList, string tenantWhere);
    private void writeSimple(TextWriter writer, string argList, string tenantWhere);
}
internal class Marten.Events.Archiving.ArchiveStreamOperation : object {
    private EventGraph _events;
    private object _streamId;
    public Type DocumentType { get; }
    public ArchiveStreamOperation(EventGraph events, object streamId);
    public sealed virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual Type get_DocumentType();
    public sealed virtual void Postprocess(DbDataReader reader, IList`1<Exception> exceptions);
    public sealed virtual Task PostprocessAsync(DbDataReader reader, IList`1<Exception> exceptions, CancellationToken token);
    public sealed virtual OperationRole Role();
}
internal interface Marten.Events.Archiving.IArchiveFilter {
}
internal class Marten.Events.Archiving.IsArchivedColumn : TableColumn {
    internal static string ColumnName;
    public sealed virtual void GenerateSelectorCodeSync(GeneratedMethod method, EventGraph graph, int index);
    public sealed virtual void GenerateSelectorCodeAsync(GeneratedMethod method, EventGraph graph, int index);
    public sealed virtual void GenerateAppendCode(GeneratedMethod method, EventGraph graph, int index, AppendMode full);
    public sealed virtual string ValueSql(EventGraph graph, AppendMode mode);
}
internal class Marten.Events.Archiving.IsArchivedFilter : object {
    private static string _sql;
    public static IsArchivedFilter Instance;
    private static IsArchivedFilter();
    public sealed virtual ISqlFragment Reverse();
    public sealed virtual void Apply(ICommandBuilder builder);
}
internal class Marten.Events.Archiving.IsNotArchivedFilter : object {
    private static string _sql;
    public static IsNotArchivedFilter Instance;
    private static IsNotArchivedFilter();
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual ISqlFragment Reverse();
}
internal class Marten.Events.Archiving.MaybeArchivedMethodCallParser : object {
    private static MethodInfo _method;
    private static ISqlFragment _whereFragment;
    private static MaybeArchivedMethodCallParser();
    public sealed virtual bool Matches(MethodCallExpression expression);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
internal class Marten.Events.CodeGeneration.AggregateConstructorFrame : SyncFrame {
    private Type _argType;
    private MethodSlot _slot;
    private Variable _aggregate;
    private Variable _arg;
    public Type EventType { get; }
    public AggregateConstructorFrame(MethodSlot slot);
    public sealed virtual void Configure(EventProcessingFrame parent);
    public sealed virtual Type get_EventType();
    [IteratorStateMachineAttribute("Marten.Events.CodeGeneration.AggregateConstructorFrame/<FindVariables>d__8")]
public virtual IEnumerable`1<Variable> FindVariables(IMethodVariables chain);
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
}
internal class Marten.Events.CodeGeneration.AggregateEventProcessingFrame : EventProcessingFrame {
    private ApplyMethodCall _apply;
    private Frame _creation;
    private ShouldDeleteFrame _deletion;
    [CompilerGeneratedAttribute]
private bool <AlwaysDeletes>k__BackingField;
    public bool AlwaysDeletes { get; public set; }
    public Frame CreationFrame { get; public set; }
    public ShouldDeleteFrame Deletion { get; public set; }
    public ApplyMethodCall Apply { get; public set; }
    public AggregateEventProcessingFrame(Type aggregateType, Type eventType);
    [CompilerGeneratedAttribute]
public bool get_AlwaysDeletes();
    [CompilerGeneratedAttribute]
public void set_AlwaysDeletes(bool value);
    public Frame get_CreationFrame();
    public void set_CreationFrame(Frame value);
    public ShouldDeleteFrame get_Deletion();
    public void set_Deletion(ShouldDeleteFrame value);
    public ApplyMethodCall get_Apply();
    public void set_Apply(ApplyMethodCall value);
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
}
internal class Marten.Events.CodeGeneration.ApplyMethodCall : MethodCall {
    [CompilerGeneratedAttribute]
private Type <EventType>k__BackingField;
    public Type EventType { get; }
    public ApplyMethodCall(Type handlerType, string methodName, Type aggregateType);
    public ApplyMethodCall(MethodSlot slot);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_EventType();
    public sealed virtual void Configure(EventProcessingFrame parent);
}
internal class Marten.Events.CodeGeneration.ApplyMethodCollection : MethodCollection {
    public static string MethodName;
    public ApplyMethodCollection(Type projectionType, Type aggregateType);
    private static ApplyMethodCollection();
    internal virtual void validateMethod(MethodSlot method);
    public virtual IEventHandlingFrame CreateEventTypeHandler(Type aggregateType, IDocumentMapping aggregateMapping, MethodSlot slot);
    public void BuildApplyMethod(GeneratedType generatedType, IDocumentMapping aggregateMapping);
    [CompilerGeneratedAttribute]
private bool <validateMethod>b__2_0(ParameterInfo x);
}
internal class Marten.Events.CodeGeneration.CallApplyAggregateFrame : Frame {
    private Variable _aggregate;
    private Variable _cancellation;
    private Variable _session;
    private Variable _usedEventOnCreate;
    [CompilerGeneratedAttribute]
private Type <AggregateType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InsideForEach>k__BackingField;
    public Type AggregateType { get; }
    public bool InsideForEach { get; public set; }
    public CallApplyAggregateFrame(ApplyMethodCollection methods);
    [CompilerGeneratedAttribute]
public Type get_AggregateType();
    [CompilerGeneratedAttribute]
public bool get_InsideForEach();
    [CompilerGeneratedAttribute]
public void set_InsideForEach(bool value);
    [IteratorStateMachineAttribute("Marten.Events.CodeGeneration.CallApplyAggregateFrame/<FindVariables>d__12")]
public virtual IEnumerable`1<Variable> FindVariables(IMethodVariables chain);
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
}
internal class Marten.Events.CodeGeneration.CallCreateAggregateFrame : Frame {
    private Variable _cancellation;
    private Variable _session;
    [CompilerGeneratedAttribute]
private CreateAggregateAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private Variable <Aggregate>k__BackingField;
    [CompilerGeneratedAttribute]
private Variable <UsedEventOnCreate>k__BackingField;
    public static string UsedEventOnCreateName;
    [CompilerGeneratedAttribute]
private string <FirstEventExpression>k__BackingField;
    public CreateAggregateAction Action { get; public set; }
    public Variable Aggregate { get; private set; }
    public Variable UsedEventOnCreate { get; private set; }
    public string FirstEventExpression { get; public set; }
    public CallCreateAggregateFrame(CreateMethodCollection methods);
    public CallCreateAggregateFrame(CreateMethodCollection methods, Variable aggregate);
    [CompilerGeneratedAttribute]
public CreateAggregateAction get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(CreateAggregateAction value);
    [CompilerGeneratedAttribute]
public Variable get_Aggregate();
    [CompilerGeneratedAttribute]
private void set_Aggregate(Variable value);
    [CompilerGeneratedAttribute]
public Variable get_UsedEventOnCreate();
    [CompilerGeneratedAttribute]
private void set_UsedEventOnCreate(Variable value);
    [CompilerGeneratedAttribute]
public string get_FirstEventExpression();
    [CompilerGeneratedAttribute]
public void set_FirstEventExpression(string value);
    public void CoalesceAssignTo(Variable aggregate);
    [IteratorStateMachineAttribute("Marten.Events.CodeGeneration.CallCreateAggregateFrame/<FindVariables>d__22")]
public virtual IEnumerable`1<Variable> FindVariables(IMethodVariables chain);
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
}
[ExtensionAttribute]
public static class Marten.Events.CodeGeneration.CodeGenerationExtensions : object {
    [ExtensionAttribute]
public static Type GetEventType(MethodInfo method, Type aggregateType);
    [ExtensionAttribute]
public static void AppendSql(FramesCollection collection, string sql);
    [ExtensionAttribute]
public static void AppendSql(FramesCollection collection, char sql);
}
public enum Marten.Events.CodeGeneration.CreateAggregateAction : Enum {
    public int value__;
    public static CreateAggregateAction Initialize;
    public static CreateAggregateAction Assign;
    public static CreateAggregateAction NullCoalesce;
}
internal class Marten.Events.CodeGeneration.CreateAggregateFrame : MethodCall {
    [CompilerGeneratedAttribute]
private Type <EventType>k__BackingField;
    public Type EventType { get; }
    public CreateAggregateFrame(Type handlerType, string methodName, Type aggregateType);
    public CreateAggregateFrame(MethodSlot slot);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_EventType();
    public sealed virtual void Configure(EventProcessingFrame parent);
}
internal class Marten.Events.CodeGeneration.CreateDefaultMethod : MethodCollection {
    public static string MethodName;
    public CreateDefaultMethod(Type projectionType, Type aggregateType);
    private static CreateDefaultMethod();
    internal virtual void validateMethod(MethodSlot method);
    protected virtual BindingFlags flags();
    public void BuildCreateDefaultMethod(GeneratedType generatedType, IDocumentMapping aggregateMapping);
    public virtual IEventHandlingFrame CreateEventTypeHandler(Type aggregateType, IDocumentMapping aggregateMapping, MethodSlot slot);
}
internal class Marten.Events.CodeGeneration.CreateMethodCollection : MethodCollection {
    public static string MethodName;
    public CreateMethodCollection(Type projectionType, Type aggregateType);
    private static CreateMethodCollection();
    internal virtual void validateMethod(MethodSlot method);
    protected virtual BindingFlags flags();
    public void BuildCreateMethod(GeneratedType generatedType, IDocumentMapping aggregateMapping);
    public virtual IEventHandlingFrame CreateEventTypeHandler(Type aggregateType, IDocumentMapping aggregateMapping, MethodSlot slot);
}
internal class Marten.Events.CodeGeneration.DeclareAggregateFrame : SyncFrame {
    [CompilerGeneratedAttribute]
private Variable <Variable>k__BackingField;
    public Variable Variable { get; }
    public DeclareAggregateFrame(Type aggregateType);
    [CompilerGeneratedAttribute]
public Variable get_Variable();
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
}
internal class Marten.Events.CodeGeneration.DefaultAggregateConstruction : SyncFrame {
    private ConstructorInfo _constructor;
    private Type _returnType;
    private Variable _event;
    [CompilerGeneratedAttribute]
private IfStyle <IfStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdditionalNoConstructorExceptionDetails>k__BackingField;
    public IfStyle IfStyle { get; public set; }
    public string AdditionalNoConstructorExceptionDetails { get; public set; }
    public DefaultAggregateConstruction(Type returnType, GeneratedType generatedType);
    [CompilerGeneratedAttribute]
public IfStyle get_IfStyle();
    [CompilerGeneratedAttribute]
public void set_IfStyle(IfStyle value);
    [CompilerGeneratedAttribute]
public string get_AdditionalNoConstructorExceptionDetails();
    [CompilerGeneratedAttribute]
public void set_AdditionalNoConstructorExceptionDetails(string value);
    [IteratorStateMachineAttribute("Marten.Events.CodeGeneration.DefaultAggregateConstruction/<FindVariables>d__12")]
public virtual IEnumerable`1<Variable> FindVariables(IMethodVariables chain);
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
}
internal static class Marten.Events.CodeGeneration.EventDocumentStorageGenerator : object {
    private static string StreamStateSelectorTypeName;
    private static string InsertStreamOperationName;
    private static string UpdateStreamVersionOperationName;
    internal static string EventDocumentStorageTypeName;
    public static EventDocumentStorage GenerateStorage(StoreOptions options);
    public static GeneratedType AssembleTypes(StoreOptions options, GeneratedAssembly assembly);
    private static void buildAppendEventOperations(StoreOptions options, GeneratedAssembly assembly, GeneratedType builderType);
    private static void buildSelectorMethods(StoreOptions options, GeneratedType builderType);
    private static GeneratedType buildUpdateStreamVersion(GeneratedType builderType, GeneratedAssembly assembly, EventGraph graph);
    private static void buildQueryForStreamMethod(EventGraph graph, GeneratedType builderType);
    private static GeneratedType buildStreamQueryHandlerType(EventGraph graph, GeneratedAssembly assembly);
    private static void buildConfigureCommandMethodForStreamState(EventGraph graph, GeneratedType streamQueryHandlerType);
    private static GeneratedType buildAppendEventOperation(EventGraph graph, GeneratedAssembly assembly, AppendMode mode);
    private static GeneratedType buildQuickAppendOperation(EventGraph graph, GeneratedAssembly assembly);
    private static GeneratedType buildInsertStream(GeneratedType builderType, GeneratedAssembly generatedAssembly, EventGraph graph);
}
internal class Marten.Events.CodeGeneration.EventProcessingFrame : Frame {
    private static int _counter;
    protected IList`1<Frame> _inner;
    private Variable _event;
    [CompilerGeneratedAttribute]
private Type <AggregateType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <EventType>k__BackingField;
    [CompilerGeneratedAttribute]
private Variable <SpecificEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private Variable <Aggregate>k__BackingField;
    [CompilerGeneratedAttribute]
private Variable <DataOnly>k__BackingField;
    public Type AggregateType { get; }
    public Type EventType { get; }
    public Variable SpecificEvent { get; }
    public Variable Aggregate { get; private set; }
    public Variable DataOnly { get; }
    public EventProcessingFrame(bool isAsync, Type aggregateType, Type eventType);
    public EventProcessingFrame(Type aggregateType, IEventHandlingFrame inner);
    [CompilerGeneratedAttribute]
public Type get_AggregateType();
    [CompilerGeneratedAttribute]
public Type get_EventType();
    [CompilerGeneratedAttribute]
public Variable get_SpecificEvent();
    [CompilerGeneratedAttribute]
public Variable get_Aggregate();
    [CompilerGeneratedAttribute]
private void set_Aggregate(Variable value);
    [CompilerGeneratedAttribute]
public Variable get_DataOnly();
    public void Add(Frame inner);
    [IteratorStateMachineAttribute("Marten.Events.CodeGeneration.EventProcessingFrame/<FindVariables>d__22")]
public virtual IEnumerable`1<Variable> FindVariables(IMethodVariables chain);
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
}
internal class Marten.Events.CodeGeneration.EventTypePatternMatchFrame : Frame {
    private List`1<EventProcessingFrame> _inner;
    private Variable _event;
    public EventTypePatternMatchFrame(List`1<EventProcessingFrame> frames);
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
    [IteratorStateMachineAttribute("Marten.Events.CodeGeneration.EventTypePatternMatchFrame/<FindVariables>d__4")]
public virtual IEnumerable`1<Variable> FindVariables(IMethodVariables chain);
    internal static IEnumerable`1<EventProcessingFrame> SortByEventTypeHierarchy(IEnumerable`1<EventProcessingFrame> frames);
}
internal interface Marten.Events.CodeGeneration.IEventHandlingFrame {
    public Type EventType { get; }
    public abstract virtual Type get_EventType();
    public abstract virtual void Configure(EventProcessingFrame parent);
}
[AttributeUsageAttribute("448")]
public class Marten.Events.CodeGeneration.MartenIgnoreAttribute : Attribute {
}
internal abstract class Marten.Events.CodeGeneration.MethodCollection : object {
    private static Dictionary`2<int, Type> _funcBaseTypes;
    private static Dictionary`2<int, Type> _actionBaseTypes;
    protected List`1<Type> _validArgumentTypes;
    protected List`1<Type> _validReturnTypes;
    private int _lambdaNumber;
    [CompilerGeneratedAttribute]
private Type <ProjectionType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <AggregateType>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <MethodNames>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LambdaName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<MethodSlot> <Methods>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    public Type ProjectionType { get; }
    internal IReadOnlyList`1<Type> ValidArgumentTypes { get; }
    public IReadOnlyList`1<Type> ValidReturnTypes { get; }
    public Type AggregateType { get; }
    public List`1<string> MethodNames { get; }
    public string LambdaName { get; protected set; }
    public List`1<MethodSlot> Methods { get; }
    public bool IsAsync { get; private set; }
    protected MethodCollection(string methodName, Type projectionType, Type aggregateType);
    protected MethodCollection(String[] methodNames, Type projectionType, Type aggregateType);
    private static MethodCollection();
    [CompilerGeneratedAttribute]
public Type get_ProjectionType();
    internal IReadOnlyList`1<Type> get_ValidArgumentTypes();
    public IReadOnlyList`1<Type> get_ValidReturnTypes();
    [CompilerGeneratedAttribute]
public Type get_AggregateType();
    [CompilerGeneratedAttribute]
public List`1<string> get_MethodNames();
    [CompilerGeneratedAttribute]
public string get_LambdaName();
    [CompilerGeneratedAttribute]
protected void set_LambdaName(string value);
    [CompilerGeneratedAttribute]
public List`1<MethodSlot> get_Methods();
    [CompilerGeneratedAttribute]
public bool get_IsAsync();
    [CompilerGeneratedAttribute]
private void set_IsAsync(bool value);
    internal IEnumerable`1<Assembly> ReferencedAssemblies();
    internal IEnumerable`1<Type> ReferencedTypes();
    protected virtual BindingFlags flags();
    internal static Type[] AllEventTypes(MethodCollection[] methods);
    internal IEnumerable`1<Type> EventTypes();
    internal abstract virtual void validateMethod(MethodSlot method);
    public IEnumerable`1<Setter> Setters();
    public void AddLambda(T lambda, Type eventType);
    private void addMethodSlot(MethodInfo method, bool declaredByAggregate);
    public abstract virtual IEventHandlingFrame CreateEventTypeHandler(Type aggregateType, IDocumentMapping aggregateMapping, MethodSlot slot);
    public static EventTypePatternMatchFrame AddEventHandling(Type aggregateType, IDocumentMapping mapping, MethodCollection[] collections);
    public static MethodSlot[] FindInvalidMethods(Type projectionType, MethodCollection[] collections);
    public bool IsEmpty();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__6_0(MethodInfo x);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_2(MethodInfo method);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__6_3(MethodInfo x);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_5(MethodInfo method);
}
public class Marten.Events.CodeGeneration.MethodSlot : object {
    public static string NoEventType;
    private List`1<string> _errors;
    [CompilerGeneratedAttribute]
private Setter <Setter>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodBase <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <HandlerType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <EventType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeclaredByAggregate>k__BackingField;
    public Setter Setter { get; }
    public MethodBase Method { get; }
    public Type DeclaringType { get; }
    public Type ReturnType { get; }
    public Type HandlerType { get; public set; }
    public Type EventType { get; }
    public IReadOnlyList`1<string> Errors { get; }
    public bool DeclaredByAggregate { get; public set; }
    public MethodSlot(MethodInfo method, Type aggregateType);
    public MethodSlot(Setter setter, MethodInfo method, Type eventType);
    public MethodSlot(ConstructorInfo constructor, Type projectionType, Type aggregateType);
    private static MethodSlot();
    [CompilerGeneratedAttribute]
public Setter get_Setter();
    [CompilerGeneratedAttribute]
public MethodBase get_Method();
    [CompilerGeneratedAttribute]
public Type get_DeclaringType();
    [CompilerGeneratedAttribute]
public Type get_ReturnType();
    [CompilerGeneratedAttribute]
public Type get_HandlerType();
    [CompilerGeneratedAttribute]
public void set_HandlerType(Type value);
    [CompilerGeneratedAttribute]
public Type get_EventType();
    public IReadOnlyList`1<string> get_Errors();
    [CompilerGeneratedAttribute]
public bool get_DeclaredByAggregate();
    [CompilerGeneratedAttribute]
public void set_DeclaredByAggregate(bool value);
    [IteratorStateMachineAttribute("Marten.Events.CodeGeneration.MethodSlot/<ReferencedTypes>d__30")]
public IEnumerable`1<Type> ReferencedTypes();
    public string Signature();
    internal void Validate(MethodCollection collection);
    internal void AddError(string error);
    private void validateArguments(MethodCollection collection);
    public static MethodSlot InvalidMethodName(MethodInfo methodInfo, String[] methodNames);
}
public class Marten.Events.CodeGeneration.ReturnValueTask : SyncFrame {
    private Type _variableType;
    private Variable _returnValue;
    public ReturnValueTask(Type variableType);
    [IteratorStateMachineAttribute("Marten.Events.CodeGeneration.ReturnValueTask/<FindVariables>d__3")]
public virtual IEnumerable`1<Variable> FindVariables(IMethodVariables chain);
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
}
internal class Marten.Events.CodeGeneration.ShouldDeleteFrame : Frame {
    private static int _number;
    private Variable _aggregate;
    [CompilerGeneratedAttribute]
private MethodCall <Maybe>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <EventType>k__BackingField;
    public MethodCall Maybe { get; }
    public Type EventType { get; }
    public ShouldDeleteFrame(MethodSlot slot);
    [CompilerGeneratedAttribute]
public MethodCall get_Maybe();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_EventType();
    public sealed virtual void Configure(EventProcessingFrame parent);
    [IteratorStateMachineAttribute("Marten.Events.CodeGeneration.ShouldDeleteFrame/<FindVariables>d__10")]
public virtual IEnumerable`1<Variable> FindVariables(IMethodVariables chain);
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
}
internal class Marten.Events.CodeGeneration.ShouldDeleteMethodCollection : MethodCollection {
    public static string MethodName;
    public ShouldDeleteMethodCollection(Type projectionType, Type aggregateType);
    private static ShouldDeleteMethodCollection();
    public virtual IEventHandlingFrame CreateEventTypeHandler(Type aggregateType, IDocumentMapping aggregateMapping, MethodSlot slot);
    internal virtual void validateMethod(MethodSlot method);
}
public enum Marten.Events.Daemon.AgentStatus : Enum {
    public int value__;
    public static AgentStatus Running;
    public static AgentStatus Stopped;
    public static AgentStatus Paused;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Events.Daemon.AsyncOptions : object {
    private List`1<Action`1<IDocumentOperations>> _actions;
    [CompilerGeneratedAttribute]
private int <BatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumHopperSize>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Type> <StorageTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableDocumentTrackingByIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TeardownDataOnRebuild>k__BackingField;
    private List`1<IPositionStrategy> _strategies;
    public int BatchSize { get; public set; }
    public int MaximumHopperSize { get; public set; }
    public List`1<Type> StorageTypes { get; }
    public bool EnableDocumentTrackingByIdentity { get; public set; }
    public bool TeardownDataOnRebuild { get; public set; }
    [CompilerGeneratedAttribute]
public int get_BatchSize();
    [CompilerGeneratedAttribute]
public void set_BatchSize(int value);
    [CompilerGeneratedAttribute]
public int get_MaximumHopperSize();
    [CompilerGeneratedAttribute]
public void set_MaximumHopperSize(int value);
    [CompilerGeneratedAttribute]
public List`1<Type> get_StorageTypes();
    [CompilerGeneratedAttribute]
public bool get_EnableDocumentTrackingByIdentity();
    [CompilerGeneratedAttribute]
public void set_EnableDocumentTrackingByIdentity(bool value);
    [CompilerGeneratedAttribute]
public bool get_TeardownDataOnRebuild();
    [CompilerGeneratedAttribute]
public void set_TeardownDataOnRebuild(bool value);
    [NullableContextAttribute("2")]
public void DeleteViewTypeOnTeardown();
    public void DeleteViewTypeOnTeardown(Type type);
    public void DeleteDataInTableOnTeardown(DbObjectName name);
    public void DeleteDataInTableOnTeardown(string tableIdentifier);
    internal void Teardown(IDocumentOperations operations);
    internal Task`1<Position> DetermineStartingPositionAsync(long highWaterMark, ShardName name, ShardExecutionMode mode, IMartenDatabase database, CancellationToken token);
    private IPositionStrategy matchStrategy(IMartenDatabase database);
    public AsyncOptions SubscribeFromPresent(string databaseIdentifier);
    public AsyncOptions SubscribeFromTime(DateTimeOffset eventTimestampFloor, string databaseIdentifier);
    public AsyncOptions SubscribeFromSequence(long sequenceFloor, string databaseIdentifier);
}
public class Marten.Events.Daemon.AsyncProjectionShard : object {
    [CompilerGeneratedAttribute]
private ISubscriptionSource <SubscriptionSource>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectionSource <Source>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Type <StreamType>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Type> <EventTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeArchivedEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private ShardName <Name>k__BackingField;
    public ShardRole Role { get; }
    public ISubscriptionSource SubscriptionSource { get; }
    public IProjectionSource Source { get; }
    [NullableAttribute("2")]
public Type StreamType { get; public set; }
    public IReadOnlyList`1<Type> EventTypes { get; public set; }
    public bool IncludeArchivedEvents { get; public set; }
    public ShardName Name { get; private set; }
    public AsyncProjectionShard(string shardName, IProjectionSource source);
    public AsyncProjectionShard(string shardName, ISubscriptionSource source);
    public AsyncProjectionShard(IProjectionSource source);
    public ShardRole get_Role();
    [CompilerGeneratedAttribute]
public ISubscriptionSource get_SubscriptionSource();
    internal void OverrideProjectionName(string projectionName);
    [CompilerGeneratedAttribute]
public IProjectionSource get_Source();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Type get_StreamType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_StreamType(Type value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Type> get_EventTypes();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EventTypes(IReadOnlyList`1<Type> value);
    [CompilerGeneratedAttribute]
public bool get_IncludeArchivedEvents();
    [CompilerGeneratedAttribute]
public void set_IncludeArchivedEvents(bool value);
    [IteratorStateMachineAttribute("Marten.Events.Daemon.AsyncProjectionShard/<BuildFilters>d__24")]
public IEnumerable`1<ISqlFragment> BuildFilters(DocumentStore store);
    [CompilerGeneratedAttribute]
public ShardName get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(ShardName value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Marten.Events.Daemon.CatchUp : object {
    [NullableAttribute("1")]
internal static CatchUp Instance;
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    public string DatabaseName { get; public set; }
    private static CatchUp();
    [CompilerGeneratedAttribute]
public sealed virtual string get_DatabaseName();
    [CompilerGeneratedAttribute]
public void set_DatabaseName(string value);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Marten.Events.Daemon.CatchUp/<DetermineStartingPositionAsync>d__6")]
public sealed virtual Task`1<Position> DetermineStartingPositionAsync(long highWaterMark, ShardName name, ShardExecutionMode mode, IMartenDatabase database, CancellationToken token);
}
internal class Marten.Events.Daemon.Coordination.AdvisoryLock : object {
    private IMartenDatabase _database;
    private ILogger _logger;
    private NpgsqlConnection _conn;
    private List`1<int> _locks;
    public AdvisoryLock(IMartenDatabase database, ILogger logger);
    public bool HasLock(int lockId);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Coordination.AdvisoryLock/<TryAttainLockAsync>d__6")]
public Task`1<bool> TryAttainLockAsync(int lockId, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Coordination.AdvisoryLock/<ReleaseLockAsync>d__7")]
public Task ReleaseLockAsync(int lockId);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Coordination.AdvisoryLock/<DisposeAsync>d__8")]
public sealed virtual ValueTask DisposeAsync();
}
public interface Marten.Events.Daemon.Coordination.IProjectionCoordinator {
    public abstract virtual IProjectionDaemon DaemonForMainDatabase();
    public abstract virtual ValueTask`1<IProjectionDaemon> DaemonForDatabase(string databaseIdentifier);
    public abstract virtual Task PauseAsync();
    public abstract virtual Task ResumeAsync();
}
public interface Marten.Events.Daemon.Coordination.IProjectionCoordinator`1 {
}
public interface Marten.Events.Daemon.Coordination.IProjectionDistributor {
    public abstract virtual ValueTask`1<IReadOnlyList`1<IProjectionSet>> BuildDistributionAsync();
    public abstract virtual Task RandomWait(CancellationToken token);
    public abstract virtual bool HasLock(IProjectionSet set);
    public abstract virtual Task`1<bool> TryAttainLockAsync(IProjectionSet set, CancellationToken token);
    public abstract virtual Task ReleaseLockAsync(IProjectionSet set);
    public abstract virtual Task ReleaseAllLocks();
}
public interface Marten.Events.Daemon.Coordination.IProjectionSet {
    public int LockId { get; }
    public IMartenDatabase Database { get; }
    public IReadOnlyList`1<ShardName> Names { get; }
    public abstract virtual int get_LockId();
    public abstract virtual IMartenDatabase get_Database();
    public abstract virtual IProjectionDaemon BuildDaemon();
    public abstract virtual IReadOnlyList`1<ShardName> get_Names();
}
public class Marten.Events.Daemon.Coordination.MultiTenantedProjectionDistributor : object {
    private DocumentStore _store;
    private Cache`2<IMartenDatabase, AdvisoryLock> _locks;
    public MultiTenantedProjectionDistributor(DocumentStore store);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Coordination.MultiTenantedProjectionDistributor/<DisposeAsync>d__3")]
public sealed virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Coordination.MultiTenantedProjectionDistributor/<BuildDistributionAsync>d__4")]
public sealed virtual ValueTask`1<IReadOnlyList`1<IProjectionSet>> BuildDistributionAsync();
    public virtual Task RandomWait(CancellationToken token);
    public sealed virtual bool HasLock(IProjectionSet set);
    public sealed virtual Task`1<bool> TryAttainLockAsync(IProjectionSet set, CancellationToken token);
    public sealed virtual Task ReleaseLockAsync(IProjectionSet set);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Coordination.MultiTenantedProjectionDistributor/<ReleaseAllLocks>d__9")]
public sealed virtual Task ReleaseAllLocks();
    [CompilerGeneratedAttribute]
private ProjectionSet <BuildDistributionAsync>b__4_0(MartenDatabase db);
}
public class Marten.Events.Daemon.Coordination.ProjectionCoordinator : object {
    private StoreOptions _options;
    private ILogger`1<ProjectionCoordinator> _logger;
    private ImHashMap`2<string, IProjectionDaemon> _daemons;
    private object _daemonLock;
    private ResiliencePipeline _resilience;
    private CancellationTokenSource _cancellation;
    private Task _runner;
    private TimeProvider _timeProvider;
    [CompilerGeneratedAttribute]
private DocumentStore <Store>k__BackingField;
    [CompilerGeneratedAttribute]
private IProjectionDistributor <Distributor>k__BackingField;
    public DocumentStore Store { get; }
    public IProjectionDistributor Distributor { get; }
    public ProjectionCoordinator(IDocumentStore documentStore, ILogger`1<ProjectionCoordinator> logger);
    public sealed virtual IProjectionDaemon DaemonForMainDatabase();
    private IProjectionDaemon findDaemonForDatabase(MartenDatabase database);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Coordination.ProjectionCoordinator/<DaemonForDatabase>d__11")]
public sealed virtual ValueTask`1<IProjectionDaemon> DaemonForDatabase(string databaseIdentifier);
    [CompilerGeneratedAttribute]
public DocumentStore get_Store();
    [CompilerGeneratedAttribute]
public IProjectionDistributor get_Distributor();
    public sealed virtual Task StartAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Coordination.ProjectionCoordinator/<PauseAsync>d__20")]
public sealed virtual Task PauseAsync();
    public sealed virtual Task ResumeAsync();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Coordination.ProjectionCoordinator/<StopAsync>d__22")]
public sealed virtual Task StopAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Coordination.ProjectionCoordinator/<executeAsync>d__23")]
private Task executeAsync(CancellationToken stoppingToken);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Coordination.ProjectionCoordinator/<startAgentsIfNecessaryAsync>d__24")]
private Task startAgentsIfNecessaryAsync(IProjectionSet set, IProjectionDaemon daemon, CancellationToken stoppingToken);
    private IProjectionDaemon resolveDaemon(IProjectionSet set);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Coordination.ProjectionCoordinator/<tryStartAgent>d__26")]
private Task tryStartAgent(CancellationToken stoppingToken, IProjectionDaemon daemon, ShardName name, IProjectionSet set);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private Task <StartAsync>b__19_0();
}
public class Marten.Events.Daemon.Coordination.ProjectionCoordinator`1 : ProjectionCoordinator {
    public ProjectionCoordinator`1(T documentStore, ILogger`1<ProjectionCoordinator> logger);
}
public class Marten.Events.Daemon.Coordination.ProjectionSet : object {
    private DocumentStore _store;
    private MartenDatabase _database;
    [CompilerGeneratedAttribute]
private int <LockId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ShardName> <Names>k__BackingField;
    public int LockId { get; }
    public IMartenDatabase Database { get; }
    public IReadOnlyList`1<ShardName> Names { get; }
    public ProjectionSet(int lockId, DocumentStore store, MartenDatabase database, IReadOnlyList`1<ShardName> names);
    [CompilerGeneratedAttribute]
public sealed virtual int get_LockId();
    public sealed virtual IMartenDatabase get_Database();
    public sealed virtual IProjectionDaemon BuildDaemon();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<ShardName> get_Names();
}
public class Marten.Events.Daemon.Coordination.SingleTenantProjectionDistributor : object {
    private DocumentStore _store;
    private Cache`2<IMartenDatabase, AdvisoryLock> _locks;
    public SingleTenantProjectionDistributor(DocumentStore store);
    public sealed virtual ValueTask`1<IReadOnlyList`1<IProjectionSet>> BuildDistributionAsync();
    public virtual Task RandomWait(CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Coordination.SingleTenantProjectionDistributor/<DisposeAsync>d__5")]
public sealed virtual ValueTask DisposeAsync();
    public sealed virtual bool HasLock(IProjectionSet set);
    public sealed virtual Task`1<bool> TryAttainLockAsync(IProjectionSet set, CancellationToken token);
    public sealed virtual Task ReleaseLockAsync(IProjectionSet set);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Coordination.SingleTenantProjectionDistributor/<ReleaseAllLocks>d__9")]
public sealed virtual Task ReleaseAllLocks();
}
public class Marten.Events.Daemon.Coordination.SoloProjectionDistributor : object {
    private DocumentStore _store;
    public SoloProjectionDistributor(DocumentStore store);
    public sealed virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Coordination.SoloProjectionDistributor/<BuildDistributionAsync>d__3")]
public sealed virtual ValueTask`1<IReadOnlyList`1<IProjectionSet>> BuildDistributionAsync();
    public sealed virtual Task RandomWait(CancellationToken token);
    public sealed virtual bool HasLock(IProjectionSet set);
    public sealed virtual Task`1<bool> TryAttainLockAsync(IProjectionSet set, CancellationToken token);
    public sealed virtual Task ReleaseLockAsync(IProjectionSet set);
    public sealed virtual Task ReleaseAllLocks();
    [CompilerGeneratedAttribute]
private ProjectionSet <BuildDistributionAsync>b__3_0(MartenDatabase db);
}
public class Marten.Events.Daemon.DaemonSettings : object {
    public List`1<IChangeListener> AsyncListeners;
    [CompilerGeneratedAttribute]
private int <DaemonLockId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LeadershipPollingTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <StaleSequenceThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <SlowPollingTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <FastPollingTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <HealthCheckPollingTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <AgentPauseTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DaemonMode <AsyncMode>k__BackingField;
    public int DaemonLockId { get; public set; }
    public int LeadershipPollingTime { get; public set; }
    public TimeSpan StaleSequenceThreshold { get; public set; }
    public TimeSpan SlowPollingTime { get; public set; }
    public TimeSpan FastPollingTime { get; public set; }
    public TimeSpan HealthCheckPollingTime { get; public set; }
    public TimeSpan AgentPauseTime { get; public set; }
    public DaemonMode AsyncMode { get; internal set; }
    [CompilerGeneratedAttribute]
public int get_DaemonLockId();
    [CompilerGeneratedAttribute]
public void set_DaemonLockId(int value);
    [CompilerGeneratedAttribute]
public int get_LeadershipPollingTime();
    [CompilerGeneratedAttribute]
public void set_LeadershipPollingTime(int value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_StaleSequenceThreshold();
    [CompilerGeneratedAttribute]
public void set_StaleSequenceThreshold(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_SlowPollingTime();
    [CompilerGeneratedAttribute]
public void set_SlowPollingTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_FastPollingTime();
    [CompilerGeneratedAttribute]
public void set_FastPollingTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_HealthCheckPollingTime();
    [CompilerGeneratedAttribute]
public void set_HealthCheckPollingTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_AgentPauseTime();
    [CompilerGeneratedAttribute]
public void set_AgentPauseTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual DaemonMode get_AsyncMode();
    [CompilerGeneratedAttribute]
internal void set_AsyncMode(DaemonMode value);
}
[SingleTenantedAttribute]
public class Marten.Events.Daemon.DeadLetterEvent : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectionName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShardName>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionType>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EventSequence>k__BackingField;
    public Guid Id { get; public set; }
    public string ProjectionName { get; public set; }
    public string ShardName { get; public set; }
    public DateTimeOffset Timestamp { get; public set; }
    public string ExceptionMessage { get; public set; }
    public string ExceptionType { get; public set; }
    public long EventSequence { get; public set; }
    public DeadLetterEvent(IEvent e, ShardName shardName, ApplyEventException ex);
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Guid value);
    [CompilerGeneratedAttribute]
public string get_ProjectionName();
    [CompilerGeneratedAttribute]
public void set_ProjectionName(string value);
    [CompilerGeneratedAttribute]
public string get_ShardName();
    [CompilerGeneratedAttribute]
public void set_ShardName(string value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_ExceptionMessage();
    [CompilerGeneratedAttribute]
public void set_ExceptionMessage(string value);
    [CompilerGeneratedAttribute]
public string get_ExceptionType();
    [CompilerGeneratedAttribute]
public void set_ExceptionType(string value);
    [CompilerGeneratedAttribute]
public long get_EventSequence();
    [CompilerGeneratedAttribute]
public void set_EventSequence(long value);
    public virtual string ToString();
}
public abstract class Marten.Events.Daemon.EventRangeGroup : object {
    private CancellationToken _parent;
    private CancellationTokenSource _cancellationTokenSource;
    [CompilerGeneratedAttribute]
private ISubscriptionAgent <Agent>k__BackingField;
    [CompilerGeneratedAttribute]
private EventRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WasAborted>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <Cancellation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Attempts>k__BackingField;
    public ISubscriptionAgent Agent { get; }
    public EventRange Range { get; }
    public bool WasAborted { get; private set; }
    public CancellationToken Cancellation { get; private set; }
    public int Attempts { get; private set; }
    protected EventRangeGroup(EventRange range, CancellationToken parent);
    [CompilerGeneratedAttribute]
public ISubscriptionAgent get_Agent();
    [CompilerGeneratedAttribute]
public EventRange get_Range();
    [CompilerGeneratedAttribute]
public bool get_WasAborted();
    [CompilerGeneratedAttribute]
private void set_WasAborted(bool value);
    [CompilerGeneratedAttribute]
public CancellationToken get_Cancellation();
    [CompilerGeneratedAttribute]
private void set_Cancellation(CancellationToken value);
    [CompilerGeneratedAttribute]
public int get_Attempts();
    [CompilerGeneratedAttribute]
private void set_Attempts(int value);
    public abstract virtual void Dispose();
    public void Reset();
    protected abstract virtual void reset();
    public abstract virtual Task ConfigureUpdateBatch(ProjectionUpdateBatch batch);
    public abstract virtual ValueTask SkipEventSequence(long eventSequence, IMartenDatabase database);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Marten.Events.Daemon.FromPresent : object {
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    public string DatabaseName { get; }
    public FromPresent(string databaseName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DatabaseName();
    [NullableContextAttribute("1")]
public sealed virtual Task`1<Position> DetermineStartingPositionAsync(long highWaterMark, ShardName name, ShardExecutionMode mode, IMartenDatabase database, CancellationToken token);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Marten.Events.Daemon.FromSequence : object {
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Sequence>k__BackingField;
    public string DatabaseName { get; }
    public long Sequence { get; }
    public FromSequence(string databaseName, long sequence);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DatabaseName();
    [CompilerGeneratedAttribute]
public long get_Sequence();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Marten.Events.Daemon.FromSequence/<DetermineStartingPositionAsync>d__7")]
public sealed virtual Task`1<Position> DetermineStartingPositionAsync(long highWaterMark, ShardName name, ShardExecutionMode mode, IMartenDatabase database, CancellationToken token);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Marten.Events.Daemon.FromTime : object {
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <EventFloorTime>k__BackingField;
    public string DatabaseName { get; }
    public DateTimeOffset EventFloorTime { get; }
    public FromTime(string databaseName, DateTimeOffset time);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DatabaseName();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_EventFloorTime();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Marten.Events.Daemon.FromTime/<DetermineStartingPositionAsync>d__7")]
public sealed virtual Task`1<Position> DetermineStartingPositionAsync(long highWaterMark, ShardName name, ShardExecutionMode mode, IMartenDatabase database, CancellationToken token);
}
internal class Marten.Events.Daemon.HighWater.GapDetector : object {
    private EventGraph _graph;
    [CompilerGeneratedAttribute]
private long <Start>k__BackingField;
    public long Start { get; public set; }
    public GapDetector(EventGraph graph);
    [CompilerGeneratedAttribute]
public long get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(long value);
    public sealed virtual NpgsqlCommand BuildCommand();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.HighWater.GapDetector/<HandleAsync>d__7")]
public sealed virtual Task`1<Nullable`1<long>> HandleAsync(DbDataReader reader, CancellationToken token);
}
internal class Marten.Events.Daemon.HighWater.HighWaterAgent : object {
    private IHighWaterDetector _detector;
    private ILogger _logger;
    private DaemonSettings _settings;
    private Timer _timer;
    private ShardStateTracker _tracker;
    private HighWaterStatistics _current;
    private Task`1<Task> _loop;
    private CancellationToken _token;
    [CompilerGeneratedAttribute]
private bool <IsRunning>k__BackingField;
    public bool IsRunning { get; private set; }
    public HighWaterAgent(IHighWaterDetector detector, ShardStateTracker tracker, ILogger logger, DaemonSettings settings, CancellationToken token);
    [CompilerGeneratedAttribute]
public bool get_IsRunning();
    [CompilerGeneratedAttribute]
private void set_IsRunning(bool value);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.HighWater.HighWaterAgent/<StartAsync>d__14")]
public Task StartAsync();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.HighWater.HighWaterAgent/<detectChanges>d__15")]
private Task detectChanges();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.HighWater.HighWaterAgent/<markProgressAsync>d__16")]
private Task markProgressAsync(HighWaterStatistics statistics, TimeSpan delayTime, HighWaterStatus status);
    private void TimerOnElapsed(object sender, ElapsedEventArgs e);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.HighWater.HighWaterAgent/<checkState>d__18")]
private Task checkState();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.HighWater.HighWaterAgent/<CheckNowAsync>d__19")]
public Task CheckNowAsync();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.HighWater.HighWaterAgent/<StopAsync>d__20")]
public Task StopAsync();
}
internal class Marten.Events.Daemon.HighWater.HighWaterDetector : object {
    private GapDetector _gapDetector;
    private HighWaterStatisticsDetector _highWaterStatisticsDetector;
    private ILogger _logger;
    private ISingleQueryRunner _runner;
    private EventGraph _graph;
    private ProjectionOptions _settings;
    [CompilerGeneratedAttribute]
private string <DatabaseName>k__BackingField;
    public string DatabaseName { get; }
    public HighWaterDetector(MartenDatabase runner, EventGraph graph, ILogger logger);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.HighWater.HighWaterDetector/<AdvanceHighWaterMarkToLatest>d__7")]
public Task AdvanceHighWaterMarkToLatest(CancellationToken token);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DatabaseName();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.HighWater.HighWaterDetector/<DetectInSafeZone>d__11")]
public sealed virtual Task`1<HighWaterStatistics> DetectInSafeZone(CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.HighWater.HighWaterDetector/<Detect>d__12")]
public sealed virtual Task`1<HighWaterStatistics> Detect(CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.HighWater.HighWaterDetector/<calculateHighWaterMark>d__13")]
private Task calculateHighWaterMark(HighWaterStatistics statistics, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.HighWater.HighWaterDetector/<markHighWaterMarkInDatabaseAsync>d__14")]
private Task markHighWaterMarkInDatabaseAsync(CancellationToken token, long currentMark);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.HighWater.HighWaterDetector/<loadCurrentStatistics>d__15")]
private Task`1<HighWaterStatistics> loadCurrentStatistics(CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.HighWater.HighWaterDetector/<findCurrentMark>d__16")]
private Task`1<long> findCurrentMark(HighWaterStatistics statistics, CancellationToken token);
}
public class Marten.Events.Daemon.HighWater.HighWaterStatistics : object {
    [CompilerGeneratedAttribute]
private long <LastMark>k__BackingField;
    [CompilerGeneratedAttribute]
private long <HighestSequence>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CurrentMark>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <LastUpdated>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SafeStartMark>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    public long LastMark { get; public set; }
    public long HighestSequence { get; public set; }
    public long CurrentMark { get; public set; }
    public bool HasChanged { get; }
    public Nullable`1<DateTimeOffset> LastUpdated { get; public set; }
    public long SafeStartMark { get; public set; }
    public DateTimeOffset Timestamp { get; public set; }
    [CompilerGeneratedAttribute]
public long get_LastMark();
    [CompilerGeneratedAttribute]
public void set_LastMark(long value);
    [CompilerGeneratedAttribute]
public long get_HighestSequence();
    [CompilerGeneratedAttribute]
public void set_HighestSequence(long value);
    [CompilerGeneratedAttribute]
public long get_CurrentMark();
    [CompilerGeneratedAttribute]
public void set_CurrentMark(long value);
    public bool get_HasChanged();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_LastUpdated();
    [CompilerGeneratedAttribute]
public void set_LastUpdated(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public long get_SafeStartMark();
    [CompilerGeneratedAttribute]
public void set_SafeStartMark(long value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTimeOffset value);
    public HighWaterStatus InterpretStatus(HighWaterStatistics previous);
    public bool TryGetStaleAge(TimeSpan& timeSinceUpdate);
}
internal class Marten.Events.Daemon.HighWater.HighWaterStatisticsDetector : object {
    private string _commandText;
    public HighWaterStatisticsDetector(EventGraph graph);
    public sealed virtual NpgsqlCommand BuildCommand();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.HighWater.HighWaterStatisticsDetector/<HandleAsync>d__3")]
public sealed virtual Task`1<HighWaterStatistics> HandleAsync(DbDataReader reader, CancellationToken token);
}
public enum Marten.Events.Daemon.HighWater.HighWaterStatus : Enum {
    public int value__;
    public static HighWaterStatus CaughtUp;
    public static HighWaterStatus Changed;
    public static HighWaterStatus Stale;
}
public interface Marten.Events.Daemon.HighWater.IHighWaterDetector {
    public string DatabaseName { get; }
    public abstract virtual Task`1<HighWaterStatistics> DetectInSafeZone(CancellationToken token);
    public abstract virtual Task`1<HighWaterStatistics> Detect(CancellationToken token);
    public abstract virtual string get_DatabaseName();
}
public class Marten.Events.Daemon.Internals.AgentFactory : object {
    private DocumentStore _store;
    public AgentFactory(DocumentStore store);
    public sealed virtual IReadOnlyList`1<ISubscriptionAgent> BuildAgents(string projectionOrSubscriptionName, MartenDatabase database);
    private SubscriptionAgent buildAgentForShard(MartenDatabase database, AsyncProjectionShard shard);
    public sealed virtual IReadOnlyList`1<ISubscriptionAgent> BuildAllProjectionAgents(MartenDatabase database);
    public sealed virtual ISubscriptionAgent BuildProjectionAgentForShard(string shardName, MartenDatabase database);
}
internal class Marten.Events.Daemon.Internals.AggregateTypeFilter : object {
    [CompilerGeneratedAttribute]
private Type <AggregateType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    public Type AggregateType { get; }
    public string Alias { get; }
    public AggregateTypeFilter(Type aggregateType, EventGraph events);
    [CompilerGeneratedAttribute]
public Type get_AggregateType();
    [CompilerGeneratedAttribute]
public string get_Alias();
    public sealed virtual void Apply(ICommandBuilder builder);
}
[ExtensionAttribute]
internal static class Marten.Events.Daemon.Internals.BlockExtensions : object {
    [ExtensionAttribute]
public static ExecutionDataflowBlockOptions SequentialOptions(CancellationToken token);
}
internal class Marten.Events.Daemon.Internals.Command : object {
    internal long HighWaterMark;
    internal long LastCommitted;
    internal EventRange Range;
    internal CommandType Type;
    internal static Command Completed(long ceiling);
    internal static Command HighWaterMarkUpdated(long sequence);
    internal static Command Started(long highWater, long lastCommitted);
}
internal enum Marten.Events.Daemon.Internals.CommandType : Enum {
    public int value__;
    public static CommandType Start;
    public static CommandType HighWater;
    public static CommandType RangeCompleted;
}
internal class Marten.Events.Daemon.Internals.EventLoader : object {
    private int _aggregateIndex;
    private int _batchSize;
    private NpgsqlParameter _ceiling;
    private NpgsqlCommand _command;
    private NpgsqlParameter _floor;
    private IEventStorage _storage;
    private IDocumentStore _store;
    [CompilerGeneratedAttribute]
private IMartenDatabase <Database>k__BackingField;
    public IMartenDatabase Database { get; }
    public EventLoader(DocumentStore store, MartenDatabase database, AsyncProjectionShard shard, AsyncOptions options);
    public EventLoader(DocumentStore store, MartenDatabase database, AsyncOptions options, ISqlFragment[] filters);
    [CompilerGeneratedAttribute]
public IMartenDatabase get_Database();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.EventLoader/<LoadAsync>d__12")]
public sealed virtual Task`1<EventPage> LoadAsync(EventRequest request, CancellationToken token);
}
public class Marten.Events.Daemon.Internals.EventLoaderException : MartenException {
    public EventLoaderException(ShardName name, IMartenDatabase martenDatabase, Exception innerException);
}
public class Marten.Events.Daemon.Internals.EventPage : List`1<IEvent> {
    [CompilerGeneratedAttribute]
private long <Floor>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Ceiling>k__BackingField;
    public long Floor { get; }
    public long Ceiling { get; private set; }
    public EventPage(long floor);
    [CompilerGeneratedAttribute]
public long get_Floor();
    [CompilerGeneratedAttribute]
public long get_Ceiling();
    [CompilerGeneratedAttribute]
private void set_Ceiling(long value);
    public void CalculateCeiling(int batchSize, long highWaterMark, int skippedEvents);
}
public class Marten.Events.Daemon.Internals.EventRange : object {
    [CompilerGeneratedAttribute]
private ShardName <ShardName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SequenceFloor>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SequenceCeiling>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IEvent> <Events>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubscriptionAgent <Agent>k__BackingField;
    public ShardName ShardName { get; }
    public long SequenceFloor { get; }
    public long SequenceCeiling { get; }
    public List`1<IEvent> Events { get; public set; }
    public int Size { get; }
    [ObsoleteAttribute("This property will be removed in Marten 8 in favor of passing in the ISubscriptionController")]
public ISubscriptionAgent Agent { get; public set; }
    public EventRange(ShardName shardName, long floor, long ceiling);
    public EventRange(ShardName shardName, long ceiling);
    [CompilerGeneratedAttribute]
public ShardName get_ShardName();
    [CompilerGeneratedAttribute]
public long get_SequenceFloor();
    [CompilerGeneratedAttribute]
public long get_SequenceCeiling();
    [CompilerGeneratedAttribute]
public List`1<IEvent> get_Events();
    [CompilerGeneratedAttribute]
public void set_Events(List`1<IEvent> value);
    public int get_Size();
    [CompilerGeneratedAttribute]
public ISubscriptionAgent get_Agent();
    [CompilerGeneratedAttribute]
public void set_Agent(ISubscriptionAgent value);
    protected bool Equals(EventRange other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal IStorageOperation BuildProgressionOperation(EventGraph events);
    public void SkipEventSequence(long eventSequence);
}
public class Marten.Events.Daemon.Internals.EventRequest : object {
    [CompilerGeneratedAttribute]
private long <Floor>k__BackingField;
    [CompilerGeneratedAttribute]
private long <HighWater>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private ShardName <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorHandlingOptions <ErrorOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IDaemonRuntime <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubscriptionMetrics <Metrics>k__BackingField;
    public long Floor { get; public set; }
    public long HighWater { get; public set; }
    public int BatchSize { get; public set; }
    public ShardName Name { get; public set; }
    public ErrorHandlingOptions ErrorOptions { get; public set; }
    public IDaemonRuntime Runtime { get; public set; }
    public ISubscriptionMetrics Metrics { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Floor();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Floor(long value);
    [CompilerGeneratedAttribute]
public long get_HighWater();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HighWater(long value);
    [CompilerGeneratedAttribute]
public int get_BatchSize();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_BatchSize(int value);
    [CompilerGeneratedAttribute]
public ShardName get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(ShardName value);
    [CompilerGeneratedAttribute]
public ErrorHandlingOptions get_ErrorOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ErrorOptions(ErrorHandlingOptions value);
    [CompilerGeneratedAttribute]
public IDaemonRuntime get_Runtime();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Runtime(IDaemonRuntime value);
    [CompilerGeneratedAttribute]
public ISubscriptionMetrics get_Metrics();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Metrics(ISubscriptionMetrics value);
    public virtual string ToString();
    protected bool Equals(EventRequest other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Events.Daemon.Internals.EventTypeFilter : object {
    private String[] _typeNames;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<Type> <EventTypes>k__BackingField;
    public IReadOnlyCollection`1<Type> EventTypes { get; }
    public EventTypeFilter(EventGraph graph, IReadOnlyCollection`1<Type> eventTypes);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<Type> get_EventTypes();
    public sealed virtual void Apply(ICommandBuilder builder);
}
public class Marten.Events.Daemon.Internals.GroupedProjectionExecution : object {
    private IProjectionSource _source;
    private DocumentStore _store;
    private IMartenDatabase _database;
    private ILogger _logger;
    private CancellationTokenSource _cancellation;
    private TransformBlock`2<EventRange, EventRangeGroup> _grouping;
    private ActionBlock`1<EventRangeGroup> _building;
    private SessionOptions _sessionOptions;
    [CompilerGeneratedAttribute]
private ShardExecutionMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectionShardIdentity>k__BackingField;
    public ShardExecutionMode Mode { get; public set; }
    public string ProjectionShardIdentity { get; }
    public string DatabaseName { get; }
    public GroupedProjectionExecution(AsyncProjectionShard shard, DocumentStore store, IMartenDatabase database, ILogger logger);
    [CompilerGeneratedAttribute]
public sealed virtual ShardExecutionMode get_Mode();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Mode(ShardExecutionMode value);
    [CompilerGeneratedAttribute]
public string get_ProjectionShardIdentity();
    public sealed virtual string get_DatabaseName();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.GroupedProjectionExecution/<EnsureStorageExists>d__18")]
public sealed virtual Task EnsureStorageExists();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.GroupedProjectionExecution/<groupEventRange>d__19")]
private Task`1<EventRangeGroup> groupEventRange(EventRange range);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.GroupedProjectionExecution/<processRange>d__20")]
private Task processRange(EventRangeGroup group);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.GroupedProjectionExecution/<applyBatchOperationsToDatabaseAsync>d__21")]
private Task applyBatchOperationsToDatabaseAsync(EventRangeGroup group, DocumentSessionBase session, ProjectionUpdateBatch batch);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.GroupedProjectionExecution/<buildBatchWithSkipping>d__22")]
private Task`1<ProjectionUpdateBatch> buildBatchWithSkipping(EventRangeGroup group, DocumentSessionBase session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.GroupedProjectionExecution/<buildBatchAsync>d__23")]
private Task`1<ProjectionUpdateBatch> buildBatchAsync(EventRangeGroup group, DocumentSessionBase session);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.GroupedProjectionExecution/<DisposeAsync>d__24")]
public sealed virtual ValueTask DisposeAsync();
    public sealed virtual void Enqueue(EventPage page, ISubscriptionAgent subscriptionAgent);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.GroupedProjectionExecution/<StopAndDrainAsync>d__26")]
public sealed virtual Task StopAndDrainAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.GroupedProjectionExecution/<HardStopAsync>d__27")]
public sealed virtual Task HardStopAsync();
}
internal class Marten.Events.Daemon.Internals.GroupExecution : object {
    [CompilerGeneratedAttribute]
private IProjectionSource <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private EventRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private IMartenDatabase <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentStore <Store>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IProjectionSource Source { get; public set; }
    public EventRange Range { get; public set; }
    public IMartenDatabase Database { get; public set; }
    public DocumentStore Store { get; public set; }
    public GroupExecution(IProjectionSource Source, EventRange Range, IMartenDatabase Database, DocumentStore Store);
    [CompilerGeneratedAttribute]
protected GroupExecution(GroupExecution original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IProjectionSource get_Source();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Source(IProjectionSource value);
    [CompilerGeneratedAttribute]
public EventRange get_Range();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Range(EventRange value);
    [CompilerGeneratedAttribute]
public IMartenDatabase get_Database();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Database(IMartenDatabase value);
    [CompilerGeneratedAttribute]
public DocumentStore get_Store();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Store(DocumentStore value);
    public ValueTask`1<EventRangeGroup> GroupAsync(CancellationToken token);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(GroupExecution left, GroupExecution right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(GroupExecution left, GroupExecution right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(GroupExecution other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual GroupExecution <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(IProjectionSource& Source, EventRange& Range, IMartenDatabase& Database, DocumentStore& Store);
}
public interface Marten.Events.Daemon.Internals.IAgentFactory {
    public abstract virtual IReadOnlyList`1<ISubscriptionAgent> BuildAgents(string projectionOrSubscriptionName, MartenDatabase database);
    public abstract virtual IReadOnlyList`1<ISubscriptionAgent> BuildAllProjectionAgents(MartenDatabase database);
    public abstract virtual ISubscriptionAgent BuildProjectionAgentForShard(string shardName, MartenDatabase database);
}
public interface Marten.Events.Daemon.Internals.IDaemonRuntime {
    public ILogger Logger { get; }
    public abstract virtual Task RecordDeadLetterEventAsync(DeadLetterEvent event);
    public abstract virtual ILogger get_Logger();
}
public interface Marten.Events.Daemon.Internals.IEventLoader {
    public abstract virtual Task`1<EventPage> LoadAsync(EventRequest request, CancellationToken token);
}
[NullableContextAttribute("1")]
public interface Marten.Events.Daemon.Internals.ISubscriptionMetrics {
    public abstract virtual Activity TrackExecution(EventRange page);
    public abstract virtual Activity TrackLoading(EventRequest request);
    public abstract virtual void UpdateGap(long highWaterMark, long lastCeiling);
    public abstract virtual void UpdateProcessed(long count);
    public abstract virtual Activity TrackGrouping(EventRange page);
}
[ExtensionAttribute]
internal static class Marten.Events.Daemon.Internals.Log : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.9.3103")]
private static Action`3<ILogger, string, Exception> __EventUnknownCallback;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.9.3103")]
private static Action`4<ILogger, string, long, Exception> __EventDeserializationExceptionCallback;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.9.3103")]
private static Action`2<ILogger, Exception> __EventDeserializationExceptionDebugCallback;
    private static Log();
    [ExtensionAttribute]
[LoggerMessageAttribute]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.9.3103")]
public static void EventUnknown(ILogger logger, string eventTypeName);
    [ExtensionAttribute]
[LoggerMessageAttribute]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.9.3103")]
public static void EventDeserializationException(ILogger logger, string exceptionName, long sequence);
    [ExtensionAttribute]
[LoggerMessageAttribute]
[GeneratedCodeAttribute("Microsoft.Extensions.Logging.Generators", "8.0.9.3103")]
public static void EventDeserializationExceptionDebug(ILogger logger, Exception exception);
}
public class Marten.Events.Daemon.Internals.NulloDaemonRuntime : object {
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    public ILogger Logger { get; }
    public sealed virtual Task RecordDeadLetterEventAsync(DeadLetterEvent event);
    [CompilerGeneratedAttribute]
public sealed virtual ILogger get_Logger();
}
internal class Marten.Events.Daemon.Internals.ProjectionDocumentSession : DocumentSessionBase {
    [CompilerGeneratedAttribute]
private ShardExecutionMode <Mode>k__BackingField;
    public ShardExecutionMode Mode { get; }
    internal DocumentTracking TrackingMode { get; }
    public ProjectionDocumentSession(DocumentStore store, ISessionWorkTracker workTracker, SessionOptions sessionOptions, ShardExecutionMode mode);
    [CompilerGeneratedAttribute]
public ShardExecutionMode get_Mode();
    internal virtual DocumentTracking get_TrackingMode();
    protected internal virtual IDocumentStorage`1<T> selectStorage(DocumentProvider`1<T> provider);
    protected virtual Task tryApplyTombstoneEventsAsync(CancellationToken token);
    [NullableContextAttribute("1")]
protected internal virtual void ejectById(long id);
    [NullableContextAttribute("1")]
protected internal virtual void ejectById(int id);
    [NullableContextAttribute("1")]
protected internal virtual void ejectById(Guid id);
    protected internal virtual void ejectById(string id);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Events.Daemon.Internals.ProjectionUpdateBatch : object {
    private List`1<Type> _documentTypes;
    private List`1<OperationPage> _pages;
    private DaemonSettings _settings;
    private CancellationToken _token;
    [NullableAttribute("2")]
private OperationPage _current;
    [NullableAttribute("2")]
private DocumentSessionBase _session;
    [CompilerGeneratedAttribute]
private List`1<IChangeListener> <Listeners>k__BackingField;
    [CompilerGeneratedAttribute]
private ShardExecutionMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private EventRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private ActionBlock`1<IStorageOperation> <Queue>k__BackingField;
    [NullableAttribute("2")]
private IMessageBatch _batch;
    private SemaphoreSlim _semaphore;
    private IMartenSession Session { get; }
    public List`1<IChangeListener> Listeners { get; }
    public ShardExecutionMode Mode { get; }
    public EventRange Range { get; }
    public ActionBlock`1<IStorageOperation> Queue { get; }
    private IEnumerable`1<object> Marten.Services.IChangeSet.Updated { get; }
    private IEnumerable`1<object> Marten.Services.IChangeSet.Inserted { get; }
    private IEnumerable`1<IDeletion> Marten.Services.IChangeSet.Deleted { get; }
    private List`1<StreamAction> Marten.Services.ISessionWorkTracker.Streams { get; }
    private IReadOnlyList`1<IStorageOperation> Marten.Services.ISessionWorkTracker.AllOperations { get; }
    internal ProjectionUpdateBatch(EventGraph events, DaemonSettings settings, DocumentSessionBase session, EventRange range, CancellationToken token, ShardExecutionMode mode);
    private IMartenSession get_Session();
    [CompilerGeneratedAttribute]
public List`1<IChangeListener> get_Listeners();
    [CompilerGeneratedAttribute]
public ShardExecutionMode get_Mode();
    public bool IsDisposed();
    [CompilerGeneratedAttribute]
public EventRange get_Range();
    public Task WaitForCompletion();
    [CompilerGeneratedAttribute]
public ActionBlock`1<IStorageOperation> get_Queue();
    private sealed virtual override IEnumerable`1<IDeletion> Marten.Services.IUnitOfWork.Deletions();
    private sealed virtual override IEnumerable`1<IDeletion> Marten.Services.IUnitOfWork.DeletionsFor();
    private sealed virtual override IEnumerable`1<IDeletion> Marten.Services.IUnitOfWork.DeletionsFor(Type documentType);
    private sealed virtual override IEnumerable`1<object> Marten.Services.IUnitOfWork.Updates();
    private sealed virtual override IEnumerable`1<object> Marten.Services.IUnitOfWork.Inserts();
    private sealed virtual override IEnumerable`1<T> Marten.Services.IUnitOfWork.UpdatesFor();
    private sealed virtual override IEnumerable`1<T> Marten.Services.IUnitOfWork.InsertsFor();
    private sealed virtual override IEnumerable`1<T> Marten.Services.IUnitOfWork.AllChangedFor();
    private sealed virtual override IList`1<StreamAction> Marten.Services.IUnitOfWork.Streams();
    private sealed virtual override IEnumerable`1<IStorageOperation> Marten.Services.IUnitOfWork.Operations();
    private sealed virtual override IEnumerable`1<IStorageOperation> Marten.Services.IUnitOfWork.OperationsFor();
    private sealed virtual override IEnumerable`1<IStorageOperation> Marten.Services.IUnitOfWork.OperationsFor(Type documentType);
    private sealed virtual override IEnumerable`1<object> Marten.Services.IChangeSet.get_Updated();
    private sealed virtual override IEnumerable`1<object> Marten.Services.IChangeSet.get_Inserted();
    private sealed virtual override IEnumerable`1<IDeletion> Marten.Services.IChangeSet.get_Deleted();
    private sealed virtual override IEnumerable`1<IEvent> Marten.Services.IChangeSet.GetEvents();
    private sealed virtual override IEnumerable`1<StreamAction> Marten.Services.IChangeSet.GetStreams();
    private sealed virtual override IChangeSet Marten.Services.IChangeSet.Clone();
    private sealed virtual override void Marten.Services.ISessionWorkTracker.Reset();
    private sealed virtual override void Marten.Services.ISessionWorkTracker.Add(IStorageOperation operation);
    private sealed virtual override void Marten.Services.ISessionWorkTracker.Sort(StoreOptions options);
    private sealed virtual override List`1<StreamAction> Marten.Services.ISessionWorkTracker.get_Streams();
    private sealed virtual override IReadOnlyList`1<IStorageOperation> Marten.Services.ISessionWorkTracker.get_AllOperations();
    [NullableContextAttribute("0")]
private sealed virtual override void Marten.Services.ISessionWorkTracker.Eject(T document);
    private sealed virtual override void Marten.Services.ISessionWorkTracker.EjectAllOfType(Type type);
    private sealed virtual override bool Marten.Services.ISessionWorkTracker.TryFindStream(string streamKey, StreamAction& stream);
    private sealed virtual override bool Marten.Services.ISessionWorkTracker.TryFindStream(Guid streamId, StreamAction& stream);
    private sealed virtual override bool Marten.Services.ISessionWorkTracker.HasOutstandingWork();
    public sealed virtual void EjectAll();
    public sealed virtual void PurgeOperations(TId id);
    public sealed virtual IReadOnlyList`1<Type> DocumentTypes();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.ProjectionUpdateBatch/<PostUpdateAsync>d__59")]
public sealed virtual Task PostUpdateAsync(IMartenSession session);
    private bool shouldApplyListeners();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.ProjectionUpdateBatch/<PreUpdateAsync>d__61")]
public sealed virtual Task PreUpdateAsync(IMartenSession session);
    private void startNewPage(IMartenSession session);
    private void processOperation(IStorageOperation operation);
    public sealed virtual IReadOnlyList`1<OperationPage> BuildPages(IMartenSession session);
    public ValueTask CloseSession();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.ProjectionUpdateBatch/<DisposeAsync>d__67")]
public sealed virtual ValueTask DisposeAsync();
    protected void Dispose(bool disposing);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.ProjectionUpdateBatch/<CurrentMessageBatch>d__71")]
public ValueTask`1<IMessageBatch> CurrentMessageBatch(DocumentSessionBase session);
}
internal class Marten.Events.Daemon.Internals.ResilientEventLoader : object {
    private ResiliencePipeline _pipeline;
    private EventLoader _inner;
    public ResilientEventLoader(ResiliencePipeline pipeline, EventLoader inner);
    public sealed virtual Task`1<EventPage> LoadAsync(EventRequest request, CancellationToken token);
}
public class Marten.Events.Daemon.Internals.SubscriptionAgent : object {
    private TimeProvider _timeProvider;
    private IEventLoader _loader;
    private ISubscriptionExecution _execution;
    private ShardStateTracker _tracker;
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private ShardName <Name>k__BackingField;
    private CancellationTokenSource _cancellation;
    private ActionBlock`1<Command> _commandBlock;
    private IDaemonRuntime _runtime;
    [CompilerGeneratedAttribute]
private AsyncOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectionShardIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorHandlingOptions <ErrorOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastEnqueued>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastCommitted>k__BackingField;
    [CompilerGeneratedAttribute]
private long <HighWaterMark>k__BackingField;
    [CompilerGeneratedAttribute]
private AgentStatus <Status>k__BackingField;
    [NullableAttribute("2")]
private TaskCompletionSource _rebuild;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <PausedTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ISubscriptionMetrics <Metrics>k__BackingField;
    [CompilerGeneratedAttribute]
private ShardExecutionMode <Mode>k__BackingField;
    public ShardName Name { get; }
    public AsyncOptions Options { get; }
    public string ProjectionShardIdentity { get; private set; }
    public CancellationToken CancellationToken { get; }
    public ErrorHandlingOptions ErrorOptions { get; private set; }
    public long LastEnqueued { get; internal set; }
    public long LastCommitted { get; internal set; }
    public long HighWaterMark { get; internal set; }
    private long Marten.Events.Daemon.ISubscriptionAgent.Position { get; }
    public AgentStatus Status { get; private set; }
    public Nullable`1<DateTimeOffset> PausedTime { get; private set; }
    public ISubscriptionMetrics Metrics { get; }
    public ShardExecutionMode Mode { get; private set; }
    public SubscriptionAgent(ShardName name, AsyncOptions options, TimeProvider timeProvider, IEventLoader loader, ISubscriptionExecution execution, ShardStateTracker tracker, ISubscriptionMetrics metrics, ILogger logger);
    [CompilerGeneratedAttribute]
public sealed virtual ShardName get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual AsyncOptions get_Options();
    [CompilerGeneratedAttribute]
public string get_ProjectionShardIdentity();
    [CompilerGeneratedAttribute]
private void set_ProjectionShardIdentity(string value);
    public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public sealed virtual ErrorHandlingOptions get_ErrorOptions();
    [CompilerGeneratedAttribute]
private void set_ErrorOptions(ErrorHandlingOptions value);
    [CompilerGeneratedAttribute]
public long get_LastEnqueued();
    [CompilerGeneratedAttribute]
internal void set_LastEnqueued(long value);
    [CompilerGeneratedAttribute]
public long get_LastCommitted();
    [CompilerGeneratedAttribute]
internal void set_LastCommitted(long value);
    [CompilerGeneratedAttribute]
public long get_HighWaterMark();
    [CompilerGeneratedAttribute]
internal void set_HighWaterMark(long value);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.SubscriptionAgent/<ReportCriticalFailureAsync>d__37")]
public sealed virtual Task ReportCriticalFailureAsync(Exception ex, long lastProcessed);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.SubscriptionAgent/<ReportCriticalFailureAsync>d__38")]
public sealed virtual Task ReportCriticalFailureAsync(Exception ex);
    private sealed virtual override long Marten.Events.Daemon.ISubscriptionAgent.get_Position();
    [CompilerGeneratedAttribute]
public sealed virtual AgentStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(AgentStatus value);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.SubscriptionAgent/<StopAndDrainAsync>d__45")]
public sealed virtual Task StopAndDrainAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.SubscriptionAgent/<HardStopAsync>d__46")]
public sealed virtual Task HardStopAsync();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.SubscriptionAgent/<StartAsync>d__47")]
public sealed virtual Task StartAsync(SubscriptionExecutionRequest request);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.SubscriptionAgent/<ReplayAsync>d__49")]
public sealed virtual Task ReplayAsync(SubscriptionExecutionRequest request, long highWaterMark, TimeSpan timeout);
    public sealed virtual Task RecordDeadLetterEventAsync(DeadLetterEvent event);
    public sealed virtual Task RecordDeadLetterEventAsync(IEvent event, Exception ex);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTimeOffset> get_PausedTime();
    [CompilerGeneratedAttribute]
private void set_PausedTime(Nullable`1<DateTimeOffset> value);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.SubscriptionAgent/<DisposeAsync>d__56")]
public sealed virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.SubscriptionAgent/<Apply>d__57")]
internal Task Apply(Command command);
    [CompilerGeneratedAttribute]
public sealed virtual ISubscriptionMetrics get_Metrics();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Internals.SubscriptionAgent/<loadNextAsync>d__61")]
private Task loadNextAsync();
    public sealed virtual void MarkSuccess(long processedCeiling);
    public sealed virtual void MarkHighWater(long sequence);
    [CompilerGeneratedAttribute]
public sealed virtual ShardExecutionMode get_Mode();
    [CompilerGeneratedAttribute]
private void set_Mode(ShardExecutionMode value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Events.Daemon.Internals.SubscriptionMetrics : object {
    private Meter _meter;
    private string _databaseName;
    private Counter`1<long> _processed;
    private Histogram`1<long> _gap;
    [CompilerGeneratedAttribute]
private string <LoadingSpanName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GroupingSpanName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExecutionSpanName>k__BackingField;
    [CompilerGeneratedAttribute]
private ShardName <Name>k__BackingField;
    public string LoadingSpanName { get; }
    public string GroupingSpanName { get; }
    public string ExecutionSpanName { get; }
    public ShardName Name { get; }
    public SubscriptionMetrics(Meter meter, ShardName name, string databaseName);
    [CompilerGeneratedAttribute]
public string get_LoadingSpanName();
    [CompilerGeneratedAttribute]
public string get_GroupingSpanName();
    public sealed virtual Activity TrackExecution(EventRange page);
    public sealed virtual Activity TrackGrouping(EventRange page);
    public sealed virtual Activity TrackLoading(EventRequest request);
    public sealed virtual void UpdateGap(long highWaterMark, long lastCeiling);
    public sealed virtual void UpdateProcessed(long count);
    [CompilerGeneratedAttribute]
public string get_ExecutionSpanName();
    [CompilerGeneratedAttribute]
public ShardName get_Name();
}
[NullableContextAttribute("2")]
internal interface Marten.Events.Daemon.IPositionStrategy {
    public string DatabaseName { get; }
    public abstract virtual string get_DatabaseName();
    [NullableContextAttribute("1")]
public abstract virtual Task`1<Position> DetermineStartingPositionAsync(long highWaterMark, ShardName name, ShardExecutionMode mode, IMartenDatabase database, CancellationToken token);
}
[NullableContextAttribute("1")]
public interface Marten.Events.Daemon.IProjectionDaemon {
    public ShardStateTracker Tracker { get; }
    public bool IsRunning { get; }
    public abstract virtual ShardStateTracker get_Tracker();
    public abstract virtual bool get_IsRunning();
    public abstract virtual Task RebuildProjectionAsync(string projectionName, CancellationToken token);
    public abstract virtual Task RebuildProjectionAsync(CancellationToken token);
    public abstract virtual Task RebuildProjectionAsync(Type projectionType, CancellationToken token);
    public abstract virtual Task RebuildProjectionAsync(Type projectionType, TimeSpan shardTimeout, CancellationToken token);
    public abstract virtual Task RebuildProjectionAsync(string projectionName, TimeSpan shardTimeout, CancellationToken token);
    public abstract virtual Task RebuildProjectionAsync(TimeSpan shardTimeout, CancellationToken token);
    public abstract virtual Task StartAgentAsync(string shardName, CancellationToken token);
    public abstract virtual Task StopAgentAsync(string shardName, Exception ex);
    public abstract virtual Task StartAllAsync();
    public abstract virtual Task StopAllAsync();
    public abstract virtual Task WaitForNonStaleData(TimeSpan timeout);
    public abstract virtual long HighWaterMark();
    public abstract virtual AgentStatus StatusFor(string shardName);
    public abstract virtual IReadOnlyList`1<ISubscriptionAgent> CurrentAgents();
    public abstract virtual bool HasAnyPaused();
    public abstract virtual void EjectPausedShard(string shardName);
    [ObsoleteAttribute("Will be removed in 8.0. Prefer RebuildProjectionAsync() overloads")]
public abstract virtual Task RebuildProjection(string projectionName, CancellationToken token);
    [ObsoleteAttribute("Will be removed in 8.0. Prefer RebuildProjectionAsync() overloads")]
public abstract virtual Task RebuildProjection(CancellationToken token);
    [ObsoleteAttribute("Will be removed in 8.0. Prefer RebuildProjectionAsync() overloads")]
public abstract virtual Task RebuildProjection(Type projectionType, CancellationToken token);
    [ObsoleteAttribute("Will be removed in 8.0. Prefer RebuildProjectionAsync() overloads")]
public abstract virtual Task RebuildProjection(Type projectionType, TimeSpan shardTimeout, CancellationToken token);
    [ObsoleteAttribute("Will be removed in 8.0. Prefer RebuildProjectionAsync() overloads")]
public abstract virtual Task RebuildProjection(string projectionName, TimeSpan shardTimeout, CancellationToken token);
    [ObsoleteAttribute("Will be removed in 8.0. Prefer RebuildProjectionAsync() overloads")]
public abstract virtual Task RebuildProjection(TimeSpan shardTimeout, CancellationToken token);
    [ObsoleteAttribute("Will be removed in 8.0. Prefer StartAgentAsync() instead")]
public abstract virtual Task StartShard(string shardName, CancellationToken token);
    [ObsoleteAttribute("Will be removed in 8.0. Prefer StopAgentAsync() instead")]
public abstract virtual Task StopShard(string shardName, Exception ex);
    [ObsoleteAttribute("Will be removed in 8.0. Prefer StartAllAsync() instead")]
public abstract virtual Task StartAllShards();
    [ObsoleteAttribute("Will be removed in 8.0. Prefer StopAllAsync() instead")]
public abstract virtual Task StopAll();
    [ObsoleteAttribute("Will be removed in 8.0. Prefer StartHighWaterDetectionAsync() instead")]
public abstract virtual Task StartDaemon();
    [ObsoleteAttribute("Will be removed in 8.0. Prefer PauseHighWaterAgentAsync()")]
public abstract virtual Task PauseHighWaterAgent();
    public abstract virtual Task StartHighWaterDetectionAsync();
    public abstract virtual Task PauseHighWaterAgentAsync();
    public abstract virtual Task WaitForShardToBeRunning(string shardName, TimeSpan timeout);
    public abstract virtual Task RewindSubscriptionAsync(string subscriptionName, CancellationToken token, Nullable`1<long> sequenceFloor, Nullable`1<DateTimeOffset> timestamp);
}
public interface Marten.Events.Daemon.IReadOnlyDaemonSettings {
    public TimeSpan StaleSequenceThreshold { get; }
    public TimeSpan SlowPollingTime { get; }
    public TimeSpan FastPollingTime { get; }
    public TimeSpan HealthCheckPollingTime { get; }
    public DaemonMode AsyncMode { get; }
    public abstract virtual TimeSpan get_StaleSequenceThreshold();
    public abstract virtual TimeSpan get_SlowPollingTime();
    public abstract virtual TimeSpan get_FastPollingTime();
    public abstract virtual TimeSpan get_HealthCheckPollingTime();
    public abstract virtual DaemonMode get_AsyncMode();
}
public interface Marten.Events.Daemon.ISubscriptionAgent {
    public ShardName Name { get; }
    public long Position { get; }
    public AgentStatus Status { get; }
    public Nullable`1<DateTimeOffset> PausedTime { get; }
    public AsyncOptions Options { get; }
    public ISubscriptionMetrics Metrics { get; }
    public abstract virtual ShardName get_Name();
    public abstract virtual void MarkHighWater(long sequence);
    public abstract virtual long get_Position();
    public abstract virtual AgentStatus get_Status();
    public abstract virtual Task StopAndDrainAsync(CancellationToken token);
    public abstract virtual Task HardStopAsync();
    public abstract virtual Task StartAsync(SubscriptionExecutionRequest request);
    public abstract virtual Task RecordDeadLetterEventAsync(DeadLetterEvent event);
    public abstract virtual Nullable`1<DateTimeOffset> get_PausedTime();
    public abstract virtual AsyncOptions get_Options();
    public abstract virtual ISubscriptionMetrics get_Metrics();
    public abstract virtual Task ReplayAsync(SubscriptionExecutionRequest request, long highWaterMark, TimeSpan timeout);
}
public interface Marten.Events.Daemon.ISubscriptionController {
    public ShardExecutionMode Mode { get; }
    public ErrorHandlingOptions ErrorOptions { get; }
    public abstract virtual ShardExecutionMode get_Mode();
    public abstract virtual ErrorHandlingOptions get_ErrorOptions();
    public abstract virtual void MarkSuccess(long processedCeiling);
    public abstract virtual Task ReportCriticalFailureAsync(Exception ex);
    public abstract virtual Task ReportCriticalFailureAsync(Exception ex, long lastProcessed);
    public abstract virtual Task RecordDeadLetterEventAsync(IEvent event, Exception ex);
}
public interface Marten.Events.Daemon.ISubscriptionExecution {
    public string DatabaseName { get; }
    public ShardExecutionMode Mode { get; public set; }
    public abstract virtual void Enqueue(EventPage page, ISubscriptionAgent subscriptionAgent);
    public abstract virtual Task StopAndDrainAsync(CancellationToken token);
    public abstract virtual Task HardStopAsync();
    public abstract virtual Task EnsureStorageExists();
    public abstract virtual string get_DatabaseName();
    public abstract virtual ShardExecutionMode get_Mode();
    public abstract virtual void set_Mode(ShardExecutionMode value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Events.Daemon.Position : object {
    [CompilerGeneratedAttribute]
private long <Floor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldUpdateProgressFirst>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public long Floor { get; public set; }
    public bool ShouldUpdateProgressFirst { get; public set; }
    public Position(long Floor, bool ShouldUpdateProgressFirst);
    [CompilerGeneratedAttribute]
protected Position(Position original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public long get_Floor();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Floor(long value);
    [CompilerGeneratedAttribute]
public bool get_ShouldUpdateProgressFirst();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ShouldUpdateProgressFirst(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(Position left, Position right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(Position left, Position right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(Position other);
    [CompilerGeneratedAttribute]
public virtual Position <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Int64& Floor, Boolean& ShouldUpdateProgressFirst);
}
internal class Marten.Events.Daemon.Progress.DeleteProjectionProgress : object {
    private EventGraph _events;
    private string _shardName;
    public Type DocumentType { get; }
    public DeleteProjectionProgress(EventGraph events, string shardName);
    public sealed virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual Type get_DocumentType();
    public sealed virtual void Postprocess(DbDataReader reader, IList`1<Exception> exceptions);
    public sealed virtual Task PostprocessAsync(DbDataReader reader, IList`1<Exception> exceptions, CancellationToken token);
    public sealed virtual OperationRole Role();
}
internal class Marten.Events.Daemon.Progress.InsertProjectionProgress : object {
    private EventGraph _events;
    private EventRange _progress;
    public Type DocumentType { get; }
    public InsertProjectionProgress(EventGraph events, EventRange progress);
    public sealed virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual Type get_DocumentType();
    public sealed virtual void Postprocess(DbDataReader reader, IList`1<Exception> exceptions);
    public sealed virtual Task PostprocessAsync(DbDataReader reader, IList`1<Exception> exceptions, CancellationToken token);
    public sealed virtual OperationRole Role();
}
internal class Marten.Events.Daemon.Progress.ProjectionProgressStatement : Statement {
    private EventGraph _events;
    [CompilerGeneratedAttribute]
private ShardName <Name>k__BackingField;
    public ShardName Name { get; public set; }
    public ProjectionProgressStatement(EventGraph events);
    [CompilerGeneratedAttribute]
public ShardName get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(ShardName value);
    protected virtual void configure(ICommandBuilder builder);
}
internal class Marten.Events.Daemon.Progress.ShardStateSelector : object {
    public sealed virtual ShardState Resolve(DbDataReader reader);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Progress.ShardStateSelector/<ResolveAsync>d__1")]
public sealed virtual Task`1<ShardState> ResolveAsync(DbDataReader reader, CancellationToken token);
}
internal class Marten.Events.Daemon.Progress.UpdateProjectionProgress : object {
    private EventGraph _events;
    [CompilerGeneratedAttribute]
private EventRange <Range>k__BackingField;
    public EventRange Range { get; }
    public Type DocumentType { get; }
    public UpdateProjectionProgress(EventGraph events, EventRange range);
    [CompilerGeneratedAttribute]
public EventRange get_Range();
    public sealed virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual Type get_DocumentType();
    public sealed virtual void Postprocess(DbDataReader reader, IList`1<Exception> exceptions);
    public sealed virtual Task PostprocessAsync(DbDataReader reader, IList`1<Exception> exceptions, CancellationToken token);
    public sealed virtual OperationRole Role();
}
public class Marten.Events.Daemon.ProjectionDaemon : object {
    private DocumentStore _store;
    private IAgentFactory _factory;
    private ImHashMap`2<string, ISubscriptionAgent> _agents;
    private CancellationTokenSource _cancellation;
    private HighWaterAgent _highWater;
    private IDisposable _breakSubscription;
    private RetryBlock`1<DeadLetterEvent> _deadLetterBlock;
    private SemaphoreSlim _semaphore;
    [CompilerGeneratedAttribute]
private MartenDatabase <Database>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private ShardStateTracker <Tracker>k__BackingField;
    internal MartenDatabase Database { get; }
    public ILogger Logger { get; }
    public ShardStateTracker Tracker { get; }
    public bool IsRunning { get; }
    public ProjectionDaemon(DocumentStore store, MartenDatabase database, ILogger logger, IHighWaterDetector detector, IAgentFactory factory);
    private RetryBlock`1<DeadLetterEvent> buildDeadLetterBlock();
    [CompilerGeneratedAttribute]
internal MartenDatabase get_Database();
    [CompilerGeneratedAttribute]
public sealed virtual ILogger get_Logger();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual ShardStateTracker get_Tracker();
    public sealed virtual bool get_IsRunning();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.ProjectionDaemon/<tryStartAgentAsync>d__22")]
private Task`1<bool> tryStartAgentAsync(ISubscriptionAgent agent, ShardExecutionMode mode);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.ProjectionDaemon/<rebuildAgent>d__23")]
private Task rebuildAgent(ISubscriptionAgent agent, long highWaterMark, TimeSpan shardTimeout);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.ProjectionDaemon/<StartAgentAsync>d__24")]
public sealed virtual Task StartAgentAsync(string shardName, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.ProjectionDaemon/<stopIfRunningAsync>d__25")]
private Task stopIfRunningAsync(string shardIdentity);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.ProjectionDaemon/<StopAgentAsync>d__26")]
public sealed virtual Task StopAgentAsync(string shardName, Exception ex);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.ProjectionDaemon/<StartAllAsync>d__27")]
public sealed virtual Task StartAllAsync();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.ProjectionDaemon/<StopAllAsync>d__28")]
public sealed virtual Task StopAllAsync();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.ProjectionDaemon/<StartHighWaterDetectionAsync>d__29")]
public sealed virtual Task StartHighWaterDetectionAsync();
    public sealed virtual Task WaitForNonStaleData(TimeSpan timeout);
    public sealed virtual Task WaitForShardToBeRunning(string shardName, TimeSpan timeout);
    public sealed virtual AgentStatus StatusFor(string shardName);
    public sealed virtual IReadOnlyList`1<ISubscriptionAgent> CurrentAgents();
    public sealed virtual bool HasAnyPaused();
    public sealed virtual void EjectPausedShard(string shardName);
    public sealed virtual Task PauseHighWaterAgentAsync();
    public sealed virtual long HighWaterMark();
    private sealed virtual override void System.IObserver<Marten.Events.Daemon.ShardState>.OnCompleted();
    private sealed virtual override void System.IObserver<Marten.Events.Daemon.ShardState>.OnError(Exception error);
    private sealed virtual override void System.IObserver<Marten.Events.Daemon.ShardState>.OnNext(ShardState value);
    public sealed virtual Task RecordDeadLetterEventAsync(DeadLetterEvent event);
    public sealed virtual Task RebuildProjection(string projectionName, CancellationToken token);
    public sealed virtual Task RebuildProjection(CancellationToken token);
    public sealed virtual Task RebuildProjection(Type projectionType, CancellationToken token);
    public sealed virtual Task RebuildProjection(Type projectionType, TimeSpan shardTimeout, CancellationToken token);
    public sealed virtual Task RebuildProjection(string projectionName, TimeSpan shardTimeout, CancellationToken token);
    public sealed virtual Task RebuildProjection(TimeSpan shardTimeout, CancellationToken token);
    public sealed virtual Task StartShard(string shardName, CancellationToken token);
    public sealed virtual Task StopShard(string shardName, Exception ex);
    public sealed virtual Task StartAllShards();
    public sealed virtual Task StopAll();
    public sealed virtual Task StartDaemon();
    public sealed virtual Task PauseHighWaterAgent();
    public sealed virtual Task RebuildProjectionAsync(string projectionName, CancellationToken token);
    public sealed virtual Task RebuildProjectionAsync(CancellationToken token);
    public sealed virtual Task RebuildProjectionAsync(Type projectionType, CancellationToken token);
    public sealed virtual Task RebuildProjectionAsync(Type projectionType, TimeSpan shardTimeout, CancellationToken token);
    public sealed virtual Task RebuildProjectionAsync(string projectionName, TimeSpan shardTimeout, CancellationToken token);
    public sealed virtual Task RebuildProjectionAsync(TimeSpan shardTimeout, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.ProjectionDaemon/<rebuildProjection>d__60")]
private Task rebuildProjection(IProjectionSource source, TimeSpan shardTimeout, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.ProjectionDaemon/<stopRunningAgents>d__61")]
private Task stopRunningAgents(string subscriptionName);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.ProjectionDaemon/<teardownExistingProjectionProgress>d__62")]
private Task teardownExistingProjectionProgress(IProjectionSource source, CancellationToken token, IReadOnlyList`1<ISubscriptionAgent> agents);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.ProjectionDaemon/<PrepareForRebuildsAsync>d__63")]
public Task PrepareForRebuildsAsync();
    [AsyncStateMachineAttribute("Marten.Events.Daemon.ProjectionDaemon/<RewindSubscriptionAsync>d__64")]
public sealed virtual Task RewindSubscriptionAsync(string subscriptionName, CancellationToken token, Nullable`1<long> sequenceFloor, Nullable`1<DateTimeOffset> timestamp);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.ProjectionDaemon/<rewindAgentProgress>d__65")]
private Task rewindAgentProgress(string shardName, CancellationToken token, long sequenceFloor);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.ProjectionDaemon/<rewindSubscriptionProgress>d__66")]
private Task rewindSubscriptionProgress(string subscriptionName, CancellationToken token, Nullable`1<long> sequenceFloor, IReadOnlyList`1<ISubscriptionAgent> agents);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.ProjectionDaemon/<<buildDeadLetterBlock>b__9_0>d")]
[CompilerGeneratedAttribute]
private Task <buildDeadLetterBlock>b__9_0(DeadLetterEvent deadLetterEvent, CancellationToken token);
}
public enum Marten.Events.Daemon.Resiliency.DaemonMode : Enum {
    public int value__;
    public static DaemonMode Disabled;
    public static DaemonMode Solo;
    public static DaemonMode HotCold;
}
internal interface Marten.Events.Daemon.Resiliency.IItemHandler`1 {
    public abstract virtual Task ExecuteAsync(T message, CancellationToken cancellation);
}
internal class Marten.Events.Daemon.Resiliency.LambdaItemHandler`1 : object {
    private Func`3<T, CancellationToken, Task> _handler;
    public LambdaItemHandler`1(Func`3<T, CancellationToken, Task> handler);
    public sealed virtual Task ExecuteAsync(T message, CancellationToken cancellation);
}
internal class Marten.Events.Daemon.Resiliency.RetryBlock`1 : object {
    private ActionBlock`1<Item<T>> _block;
    private CancellationToken _cancellationToken;
    private IItemHandler`1<T> _handler;
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private int <MaximumAttempts>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan[] <Pauses>k__BackingField;
    public int MaximumAttempts { get; public set; }
    public TimeSpan[] Pauses { get; public set; }
    public RetryBlock`1(Func`3<T, CancellationToken, Task> handler, ILogger logger, CancellationToken cancellationToken, Action`1<ExecutionDataflowBlockOptions> configure);
    public RetryBlock`1(Func`3<T, CancellationToken, Task> handler, ILogger logger, CancellationToken cancellationToken, ExecutionDataflowBlockOptions options);
    public RetryBlock`1(IItemHandler`1<T> handler, ILogger logger, CancellationToken cancellationToken, Action`1<ExecutionDataflowBlockOptions> configure);
    [CompilerGeneratedAttribute]
public int get_MaximumAttempts();
    [CompilerGeneratedAttribute]
public void set_MaximumAttempts(int value);
    [CompilerGeneratedAttribute]
public TimeSpan[] get_Pauses();
    [CompilerGeneratedAttribute]
public void set_Pauses(TimeSpan[] value);
    public sealed virtual void Dispose();
    public void Post(T message);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Resiliency.RetryBlock`1/<PostAsync>d__17")]
public Task PostAsync(T message);
    public TimeSpan DeterminePauseTime(int attempt);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.Resiliency.RetryBlock`1/<executeAsync>d__19")]
private Task executeAsync(Item<T> item);
    public Task DrainAsync();
}
public enum Marten.Events.Daemon.ShardAction : Enum {
    public int value__;
    public static ShardAction Updated;
    public static ShardAction Started;
    public static ShardAction Stopped;
    public static ShardAction Paused;
}
public enum Marten.Events.Daemon.ShardExecutionMode : Enum {
    public int value__;
    public static ShardExecutionMode Continuous;
    public static ShardExecutionMode Rebuild;
}
public class Marten.Events.Daemon.ShardName : object {
    public static string All;
    [CompilerGeneratedAttribute]
private string <ProjectionName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Version>k__BackingField;
    public string ProjectionName { get; }
    public string Key { get; }
    public string Identity { get; }
    public UInt32 Version { get; }
    public ShardName(string projectionName, string key, UInt32 version);
    public ShardName(string projectionName, string key);
    public ShardName(string projectionName);
    [CompilerGeneratedAttribute]
public string get_ProjectionName();
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public string get_Identity();
    [CompilerGeneratedAttribute]
public UInt32 get_Version();
    public virtual string ToString();
    protected bool Equals(ShardName other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum Marten.Events.Daemon.ShardRole : Enum {
    public int value__;
    public static ShardRole Subscription;
    public static ShardRole Projection;
}
public class Marten.Events.Daemon.ShardStartException : MartenException {
    internal ShardStartException(string projectionIdentity, Exception innerException);
    internal ShardStartException(AsyncProjectionShard shard, Exception innerException);
}
public class Marten.Events.Daemon.ShardState : object {
    public static string HighWaterMark;
    public static string AllProjections;
    [CompilerGeneratedAttribute]
private ShardAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShardName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public ShardAction Action { get; public set; }
    public DateTimeOffset Timestamp { get; }
    public string ShardName { get; }
    public long Sequence { get; }
    public Exception Exception { get; public set; }
    public ShardState(string shardName, long sequence);
    public ShardState(ShardName shardName, long sequence);
    internal ShardState(AsyncProjectionShard shard, long sequenceNumber);
    internal ShardState(AsyncProjectionShard shard, ShardAction action);
    [CompilerGeneratedAttribute]
public ShardAction get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(ShardAction value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public string get_ShardName();
    [CompilerGeneratedAttribute]
public long get_Sequence();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(Exception value);
    public virtual string ToString();
    protected bool Equals(ShardState other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Marten.Events.Daemon.ShardStateTracker : object {
    private ActionBlock`1<ShardState> _block;
    private ILogger _logger;
    private IDisposable _subscription;
    private ImmutableList`1<IObserver`1<ShardState>> _listeners;
    private ImHashMap`2<string, ShardState> _states;
    [CompilerGeneratedAttribute]
private long <HighWaterMark>k__BackingField;
    public long HighWaterMark { get; private set; }
    public ShardStateTracker(ILogger logger);
    [CompilerGeneratedAttribute]
public long get_HighWaterMark();
    [CompilerGeneratedAttribute]
private void set_HighWaterMark(long value);
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual IDisposable Subscribe(IObserver`1<ShardState> observer);
    private sealed virtual override void System.IObserver<Marten.Events.Daemon.ShardState>.OnCompleted();
    private sealed virtual override void System.IObserver<Marten.Events.Daemon.ShardState>.OnError(Exception error);
    private sealed virtual override void System.IObserver<Marten.Events.Daemon.ShardState>.OnNext(ShardState value);
    internal void Publish(ShardState state);
    internal void MarkHighWater(long sequence);
    public Task`1<ShardState> WaitForShardState(ShardState expected, Nullable`1<TimeSpan> timeout);
    public Task`1<ShardState> WaitForShardState(string shardName, long sequence, Nullable`1<TimeSpan> timeout);
    public Task`1<ShardState> WaitForShardState(ShardName name, long sequence, Nullable`1<TimeSpan> timeout);
    public Task`1<ShardState> WaitForShardCondition(Func`2<ShardState, bool> condition, string description, Nullable`1<TimeSpan> timeout);
    public Task`1<ShardState> WaitForHighWaterMark(long sequence, Nullable`1<TimeSpan> timeout);
    internal Task Complete();
    private void publish(ShardState state);
    internal void Finish();
    internal void MarkAsRestarted(ShardName name);
}
internal class Marten.Events.Daemon.ShardStatusWatcher : object {
    private TaskCompletionSource`1<ShardState> _completion;
    private Func`2<ShardState, bool> _condition;
    private IDisposable _unsubscribe;
    public Task`1<ShardState> Task { get; }
    public ShardStatusWatcher(ShardStateTracker tracker, ShardState expected, TimeSpan timeout);
    public ShardStatusWatcher(string description, Func`2<ShardState, bool> condition, ShardStateTracker tracker, TimeSpan timeout);
    public Task`1<ShardState> get_Task();
    public sealed virtual void OnCompleted();
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnNext(ShardState value);
}
public class Marten.Events.Daemon.ShardStopException : MartenException {
    public ShardStopException(string projectionIdentity, Exception innerException);
}
public class Marten.Events.Daemon.SubscriptionExecutionRequest : object {
    [CompilerGeneratedAttribute]
private long <Floor>k__BackingField;
    [CompilerGeneratedAttribute]
private ShardExecutionMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorHandlingOptions <ErrorHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private IDaemonRuntime <Runtime>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public long Floor { get; public set; }
    public ShardExecutionMode Mode { get; public set; }
    public ErrorHandlingOptions ErrorHandling { get; public set; }
    public IDaemonRuntime Runtime { get; public set; }
    public SubscriptionExecutionRequest(long Floor, ShardExecutionMode Mode, ErrorHandlingOptions ErrorHandling, IDaemonRuntime Runtime);
    [CompilerGeneratedAttribute]
protected SubscriptionExecutionRequest(SubscriptionExecutionRequest original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public long get_Floor();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Floor(long value);
    [CompilerGeneratedAttribute]
public ShardExecutionMode get_Mode();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Mode(ShardExecutionMode value);
    [CompilerGeneratedAttribute]
public ErrorHandlingOptions get_ErrorHandling();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ErrorHandling(ErrorHandlingOptions value);
    [CompilerGeneratedAttribute]
public IDaemonRuntime get_Runtime();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Runtime(IDaemonRuntime value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SubscriptionExecutionRequest left, SubscriptionExecutionRequest right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SubscriptionExecutionRequest left, SubscriptionExecutionRequest right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SubscriptionExecutionRequest other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual SubscriptionExecutionRequest <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Int64& Floor, ShardExecutionMode& Mode, ErrorHandlingOptions& ErrorHandling, IDaemonRuntime& Runtime);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Events.Daemon.TenantActionGroup : object {
    private List`1<StreamAction> _actions;
    private Tenant _tenant;
    public TenantActionGroup(Tenant tenant, IEnumerable`1<StreamAction> actions);
    [AsyncStateMachineAttribute("Marten.Events.Daemon.TenantActionGroup/<ApplyEvents>d__3")]
public Task ApplyEvents(ProjectionUpdateBatch batch, IProjection projection, AsyncOptions asyncOptions, DocumentStore store, CancellationToken cancellationToken);
}
internal class Marten.Events.Daemon.TenantedEventRangeGroup : EventRangeGroup {
    private IMartenDatabase _daemonDatabase;
    private IProjection _projection;
    private AsyncOptions _asyncOptions;
    private DocumentStore _store;
    [CompilerGeneratedAttribute]
private IList`1<TenantActionGroup> <Groups>k__BackingField;
    public IList`1<TenantActionGroup> Groups { get; }
    public TenantedEventRangeGroup(IDocumentStore store, IMartenDatabase daemonDatabase, IProjection projection, AsyncOptions asyncOptions, EventRange range, CancellationToken shardCancellation);
    [CompilerGeneratedAttribute]
public IList`1<TenantActionGroup> get_Groups();
    private void buildGroups();
    public virtual ValueTask SkipEventSequence(long eventSequence, IMartenDatabase database);
    protected virtual void reset();
    public virtual void Dispose();
    public virtual string ToString();
    public virtual Task ConfigureUpdateBatch(ProjectionUpdateBatch batch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Events.Event`1 : object {
    [CompilerGeneratedAttribute]
private T <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DotNetTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsArchived>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <AggregateTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <StreamId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <StreamKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <CausationId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <CorrelationId>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Headers>k__BackingField;
    public T Data { get; public set; }
    private object Marten.Events.IEvent.Data { get; }
    public Type EventType { get; }
    public string EventTypeName { get; public set; }
    public string DotNetTypeName { get; public set; }
    public bool IsArchived { get; public set; }
    [NullableAttribute("2")]
public string AggregateTypeName { get; public set; }
    public Guid StreamId { get; public set; }
    [NullableAttribute("2")]
public string StreamKey { get; public set; }
    public Guid Id { get; public set; }
    public long Version { get; public set; }
    public long Sequence { get; public set; }
    public DateTimeOffset Timestamp { get; public set; }
    public string TenantId { get; public set; }
    [NullableAttribute("2")]
public string CausationId { get; public set; }
    [NullableAttribute("2")]
public string CorrelationId { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, object> Headers { get; public set; }
    public Event`1(T data);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(T value);
    private sealed virtual override object Marten.Events.IEvent.get_Data();
    public sealed virtual Type get_EventType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_EventTypeName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EventTypeName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DotNetTypeName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DotNetTypeName(string value);
    public sealed virtual void SetHeader(string key, object value);
    public sealed virtual object GetHeader(string key);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsArchived();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsArchived(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_AggregateTypeName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_AggregateTypeName(string value);
    protected bool Equals(Event`1<T> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_StreamId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StreamId(Guid value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_StreamKey();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_StreamKey(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Id(Guid value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_Version();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Version(long value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_Sequence();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Sequence(long value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TenantId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TenantId(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_CausationId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_CausationId(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_CorrelationId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_CorrelationId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, object> get_Headers();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Headers(Dictionary`2<string, object> value);
}
public enum Marten.Events.EventAppendMode : Enum {
    public int value__;
    public static EventAppendMode Rich;
    public static EventAppendMode Quick;
}
public abstract class Marten.Events.EventDocumentStorage : object {
    private ISqlFragment _defaultWhere;
    private String[] _fields;
    private EventQueryMapping _mapping;
    private string _selectClause;
    private ISerializer _serializer;
    [CompilerGeneratedAttribute]
private bool <UseNumericRevisions>k__BackingField;
    [CompilerGeneratedAttribute]
private EventGraph <Events>k__BackingField;
    [CompilerGeneratedAttribute]
private TenancyStyle <TenancyStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FromObject>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseOptimisticConcurrency>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<DuplicatedField> <DuplicatedFields>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <IdType>k__BackingField;
    public IQueryableMemberCollection QueryMembers { get; }
    public ISelectClause SelectClauseWithDuplicatedFields { get; }
    public bool UseNumericRevisions { get; }
    public EventGraph Events { get; }
    public TenancyStyle TenancyStyle { get; }
    public string FromObject { get; }
    public Type SelectedType { get; }
    public Type SourceType { get; }
    public bool UseOptimisticConcurrency { get; }
    public IOperationFragment DeleteFragment { get; }
    public IOperationFragment HardDeleteFragment { get; }
    public IReadOnlyList`1<DuplicatedField> DuplicatedFields { get; }
    public DbObjectName TableName { get; }
    public Type DocumentType { get; }
    public Type IdType { get; }
    public EventDocumentStorage(StoreOptions options);
    public sealed virtual IQueryableMemberCollection get_QueryMembers();
    public sealed virtual ISelectClause get_SelectClauseWithDuplicatedFields();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseNumericRevisions();
    public sealed virtual object RawIdentityValue(object id);
    [CompilerGeneratedAttribute]
public EventGraph get_Events();
    public sealed virtual void TruncateDocumentStorage(IMartenDatabase database);
    public sealed virtual Task TruncateDocumentStorageAsync(IMartenDatabase database, CancellationToken ct);
    [CompilerGeneratedAttribute]
public sealed virtual TenancyStyle get_TenancyStyle();
    public sealed virtual IDeletion DeleteForDocument(IEvent document, string tenant);
    public sealed virtual void EjectById(IMartenSession session, object id);
    public sealed virtual void RemoveDirtyTracker(IMartenSession session, object id);
    public sealed virtual IDeletion HardDeleteForDocument(IEvent document, string tenantId);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FromObject();
    public sealed virtual Type get_SelectedType();
    public sealed virtual void Apply(ICommandBuilder sql);
    public sealed virtual String[] SelectFields();
    public sealed virtual ISelector BuildSelector(IMartenSession session);
    public sealed virtual IQueryHandler`1<T> BuildHandler(IMartenSession session, ISqlFragment topStatement, ISqlFragment currentStatement);
    public sealed virtual ISelectClause UseStatistics(QueryStatistics statistics);
    public sealed virtual Type get_SourceType();
    public sealed virtual ISqlFragment FilterDocuments(ISqlFragment query, IMartenSession session);
    public sealed virtual ISqlFragment DefaultWhereFragment();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseOptimisticConcurrency();
    public sealed virtual IOperationFragment get_DeleteFragment();
    public sealed virtual IOperationFragment get_HardDeleteFragment();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<DuplicatedField> get_DuplicatedFields();
    public sealed virtual DbObjectName get_TableName();
    public sealed virtual Type get_DocumentType();
    public sealed virtual object IdentityFor(IEvent document);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_IdType();
    public sealed virtual Nullable`1<Guid> VersionFor(IEvent document, IMartenSession session);
    public sealed virtual void Store(IMartenSession session, IEvent document);
    public sealed virtual void Store(IMartenSession session, IEvent document, Nullable`1<Guid> version);
    public sealed virtual void Store(IMartenSession session, IEvent document, int revision);
    public sealed virtual void Eject(IMartenSession session, IEvent document);
    public sealed virtual IStorageOperation Update(IEvent document, IMartenSession session, string tenant);
    public sealed virtual IStorageOperation Insert(IEvent document, IMartenSession session, string tenant);
    public sealed virtual IStorageOperation Upsert(IEvent document, IMartenSession session, string tenant);
    public sealed virtual IStorageOperation Overwrite(IEvent document, IMartenSession session, string tenant);
    public abstract virtual IStorageOperation AppendEvent(EventGraph events, IMartenSession session, StreamAction stream, IEvent e);
    public abstract virtual IStorageOperation InsertStream(StreamAction stream);
    public abstract virtual IQueryHandler`1<StreamState> QueryForStream(StreamAction stream);
    public abstract virtual IStorageOperation UpdateStreamVersion(StreamAction stream);
    public sealed virtual IStorageOperation IncrementStreamVersion(StreamAction stream);
    public sealed virtual IEvent Resolve(DbDataReader reader);
    [AsyncStateMachineAttribute("Marten.Events.EventDocumentStorage/<ResolveAsync>d__73")]
public sealed virtual Task`1<IEvent> ResolveAsync(DbDataReader reader, CancellationToken token);
    public abstract virtual void ApplyReaderDataToEvent(DbDataReader reader, IEvent e);
    public abstract virtual Task ApplyReaderDataToEventAsync(DbDataReader reader, IEvent e, CancellationToken token);
    private EventMapping eventMappingForDotNetTypeName(string dotnetTypeName, string eventTypeName);
    public virtual IStorageOperation QuickAppendEventWithVersion(EventGraph events, IMartenSession session, StreamAction stream, IEvent e);
    public virtual IStorageOperation QuickAppendEvents(StreamAction stream);
}
[ExtensionAttribute]
public static class Marten.Events.EventExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IEvent`1<T> WithData(IEvent event, T eventData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Events.EventGraph : object {
    private Cache`2<Type, string> _aggregateNameByType;
    private Cache`2<string, Type> _aggregateTypeByName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Cache`2<string, EventMapping> _byEventName;
    private Cache`2<Type, EventMapping> _events;
    private Lazy`1<IProjection[]> _inlineProjections;
    private Ref`1<ImHashMap`2<string, Type>> _nameToType;
    [NullableAttribute("2")]
private string _databaseSchemaName;
    private DocumentStore _store;
    private StreamIdentity _streamIdentity;
    private CancellationTokenSource _cancellation;
    [CompilerGeneratedAttribute]
private bool <UseArchivedStreamPartitioning>k__BackingField;
    [CompilerGeneratedAttribute]
private NpgsqlDbType <StreamIdDbType>k__BackingField;
    [CompilerGeneratedAttribute]
private StoreOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private EventMetadataCollection <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IMessageOutbox <MessageOutbox>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeProvider <TimeProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableUniqueIndexOnEventId>k__BackingField;
    [CompilerGeneratedAttribute]
private TenancyStyle <TenancyStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableGlobalProjectionsForConjoinedTenancy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseIdentityMapForInlineAggregates>k__BackingField;
    private bool _isDisposed;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private string <Weasel.Core.Migrations.IFeatureSchema.Identifier>k__BackingField;
    private Type _storageType;
    [CompilerGeneratedAttribute]
private DocumentProvider`1<IEvent> <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JasperFx.CodeGeneration.ICodeFileCollection.ChildNamespace>k__BackingField;
    [NullableAttribute("0")]
private RetryBlock`1<UpdateBatch> _tombstones;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private IEventAppender <EventAppender>k__BackingField;
    public bool UseArchivedStreamPartitioning { get; public set; }
    internal NpgsqlDbType StreamIdDbType { get; private set; }
    internal StoreOptions Options { get; }
    internal DbObjectName Table { get; }
    internal EventMetadataCollection Metadata { get; }
    public IMessageOutbox MessageOutbox { get; public set; }
    public TimeProvider TimeProvider { get; public set; }
    public bool EnableUniqueIndexOnEventId { get; public set; }
    public StreamIdentity StreamIdentity { get; public set; }
    public TenancyStyle TenancyStyle { get; public set; }
    public bool EnableGlobalProjectionsForConjoinedTenancy { get; public set; }
    public bool UseIdentityMapForInlineAggregates { get; public set; }
    public MetadataConfig MetadataConfig { get; }
    public string DatabaseSchemaName { get; public set; }
    private IReadOnlyDaemonSettings Marten.Events.IReadOnlyEventStoreOptions.Daemon { get; }
    private IReadonlyMetadataConfig Marten.Events.IReadOnlyEventStoreOptions.MetadataConfig { get; }
    [NullableAttribute("0")]
internal DbObjectName ProgressionTable { get; }
    [NullableAttribute("0")]
internal DbObjectName StreamsTable { get; }
    [NullableAttribute("0")]
private ISchemaObject[] Weasel.Core.Migrations.IFeatureSchema.Objects { get; }
    [NullableAttribute("0")]
private Type Weasel.Core.Migrations.IFeatureSchema.StorageType { get; }
    [NullableAttribute("0")]
private string Weasel.Core.Migrations.IFeatureSchema.Identifier { get; }
    [NullableAttribute("0")]
private Migrator Weasel.Core.Migrations.IFeatureSchema.Migrator { get; }
    internal DocumentProvider`1<IEvent> Provider { get; private set; }
    private string JasperFx.CodeGeneration.ICodeFile.FileName { get; }
    public GenerationRules Rules { get; }
    private string JasperFx.CodeGeneration.ICodeFileCollection.ChildNamespace { get; }
    [NullableAttribute("0")]
internal IEventAppender EventAppender { get; internal set; }
    public EventAppendMode AppendMode { get; public set; }
    internal EventGraph(StoreOptions options);
    [NullableContextAttribute("0")]
internal StreamAction Append(DocumentSessionBase session, Guid stream, Object[] events);
    [NullableContextAttribute("0")]
internal StreamAction Append(DocumentSessionBase session, string stream, Object[] events);
    [NullableContextAttribute("0")]
internal StreamAction StartStream(DocumentSessionBase session, Guid id, Object[] events);
    [NullableContextAttribute("0")]
internal StreamAction StartEmptyStream(DocumentSessionBase session, Guid id, Object[] events);
    [NullableContextAttribute("0")]
internal StreamAction StartEmptyStream(DocumentSessionBase session, string key, Object[] events);
    [NullableContextAttribute("0")]
internal StreamAction StartStream(DocumentSessionBase session, string streamKey, Object[] events);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseArchivedStreamPartitioning();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UseArchivedStreamPartitioning(bool value);
    [CompilerGeneratedAttribute]
internal NpgsqlDbType get_StreamIdDbType();
    [CompilerGeneratedAttribute]
private void set_StreamIdDbType(NpgsqlDbType value);
    [CompilerGeneratedAttribute]
internal StoreOptions get_Options();
    internal DbObjectName get_Table();
    [CompilerGeneratedAttribute]
internal EventMetadataCollection get_Metadata();
    [CompilerGeneratedAttribute]
public sealed virtual IMessageOutbox get_MessageOutbox();
    [CompilerGeneratedAttribute]
public sealed virtual void set_MessageOutbox(IMessageOutbox value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeProvider get_TimeProvider();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TimeProvider(TimeProvider value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnableUniqueIndexOnEventId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EnableUniqueIndexOnEventId(bool value);
    public sealed virtual StreamIdentity get_StreamIdentity();
    public sealed virtual void set_StreamIdentity(StreamIdentity value);
    [CompilerGeneratedAttribute]
public sealed virtual TenancyStyle get_TenancyStyle();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TenancyStyle(TenancyStyle value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnableGlobalProjectionsForConjoinedTenancy();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EnableGlobalProjectionsForConjoinedTenancy(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseIdentityMapForInlineAggregates();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UseIdentityMapForInlineAggregates(bool value);
    public sealed virtual MetadataConfig get_MetadataConfig();
    public sealed virtual IEventStoreOptions AddEventType();
    public sealed virtual void AddEventType(Type eventType);
    public sealed virtual void AddEventTypes(IEnumerable`1<Type> types);
    public sealed virtual void MapEventType(string eventTypeName);
    public sealed virtual void MapEventType(Type eventType, string eventTypeName);
    public sealed virtual IEventStoreOptions Upcast(string eventTypeName, JsonTransformation jsonTransformation);
    public sealed virtual IEventStoreOptions Upcast(Type eventType, string eventTypeName, JsonTransformation jsonTransformation);
    public sealed virtual IEventStoreOptions Upcast(string eventTypeName, Func`2<TOldEvent, TEvent> upcast);
    public sealed virtual IEventStoreOptions Upcast(Func`2<TOldEvent, TEvent> upcast);
    public sealed virtual IEventStoreOptions Upcast(string eventTypeName, Func`3<TOldEvent, CancellationToken, Task`1<TEvent>> upcastAsync);
    public sealed virtual IEventStoreOptions Upcast(Func`3<TOldEvent, CancellationToken, Task`1<TEvent>> upcastAsync);
    public sealed virtual IEventStoreOptions Upcast(IEventUpcaster[] upcasters);
    public sealed virtual IEventStoreOptions Upcast();
    public sealed virtual string get_DatabaseSchemaName();
    public sealed virtual void set_DatabaseSchemaName(string value);
    private sealed virtual override IReadOnlyDaemonSettings Marten.Events.IReadOnlyEventStoreOptions.get_Daemon();
    private sealed virtual override IReadOnlyList`1<IReadOnlyProjectionData> Marten.Events.IReadOnlyEventStoreOptions.Projections();
    public sealed virtual IReadOnlyList`1<IEventType> AllKnownEventTypes();
    private sealed virtual override IReadonlyMetadataConfig Marten.Events.IReadOnlyEventStoreOptions.get_MetadataConfig();
    private sealed virtual override void Marten.Events.IEventStoreOptions.Subscribe(ISubscription subscription);
    private sealed virtual override void Marten.Events.IEventStoreOptions.Subscribe(ISubscription subscription, Action`1<ISubscriptionOptions> configure);
    private Type findAggregateType(string name);
    internal EventMapping EventMappingFor(Type eventType);
    internal EventMapping EventMappingFor();
    internal IEnumerable`1<EventMapping> AllEvents();
    internal EventMapping EventMappingFor(string eventType);
    internal IReadOnlySet`1<string> AliasesForEvents(IReadOnlyCollection`1<Type> types);
    internal bool IsActive(StoreOptions options);
    internal Type AggregateTypeFor(string aggregateTypeName);
    internal string AggregateAliasFor(Type aggregateType);
    internal string GetStreamIdDBType();
    internal Type GetStreamIdType();
    internal Type TypeForDotNetName(string assemblyQualifiedName);
    internal IEventStorage EnsureAsStringStorage(IMartenSession session);
    internal IEventStorage EnsureAsGuidStorage(IMartenSession session);
    internal IEvent BuildEvent(object eventData);
    internal void Initialize(DocumentStore store);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Marten.Events.EventGraph/<DisposeAsync>d__104")]
public sealed virtual ValueTask DisposeAsync();
    [NullableContextAttribute("0")]
internal DbObjectName get_ProgressionTable();
    [NullableContextAttribute("0")]
internal DbObjectName get_StreamsTable();
    [NullableContextAttribute("0")]
[IteratorStateMachineAttribute("Marten.Events.EventGraph/<Weasel-Core-Migrations-IFeatureSchema-DependentTypes>d__109")]
private sealed virtual override IEnumerable`1<Type> Weasel.Core.Migrations.IFeatureSchema.DependentTypes();
    [NullableContextAttribute("0")]
private sealed virtual override ISchemaObject[] Weasel.Core.Migrations.IFeatureSchema.get_Objects();
    [NullableContextAttribute("0")]
private sealed virtual override Type Weasel.Core.Migrations.IFeatureSchema.get_StorageType();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private sealed virtual override string Weasel.Core.Migrations.IFeatureSchema.get_Identifier();
    [NullableContextAttribute("0")]
private sealed virtual override Migrator Weasel.Core.Migrations.IFeatureSchema.get_Migrator();
    [NullableContextAttribute("0")]
private sealed virtual override void Weasel.Core.Migrations.IFeatureSchema.WritePermissions(Migrator rules, TextWriter writer);
    [NullableContextAttribute("0")]
[IteratorStateMachineAttribute("Marten.Events.EventGraph/<createAllSchemaObjects>d__120")]
private IEnumerable`1<ISchemaObject> createAllSchemaObjects();
    [CompilerGeneratedAttribute]
internal DocumentProvider`1<IEvent> get_Provider();
    [CompilerGeneratedAttribute]
private void set_Provider(DocumentProvider`1<IEvent> value);
    private sealed virtual override void JasperFx.CodeGeneration.ICodeFile.AssembleTypes(GeneratedAssembly assembly);
    public sealed virtual bool AttachTypesSynchronously(GenerationRules rules, Assembly assembly, IServiceProvider services, string containingNamespace);
    private sealed virtual override Task`1<bool> JasperFx.CodeGeneration.ICodeFile.AttachTypes(GenerationRules rules, Assembly assembly, IServiceProvider services, string containingNamespace);
    private sealed virtual override string JasperFx.CodeGeneration.ICodeFile.get_FileName();
    public sealed virtual GenerationRules get_Rules();
    private sealed virtual override IReadOnlyList`1<ICodeFile> JasperFx.CodeGeneration.ICodeFileCollection.BuildFiles();
    [CompilerGeneratedAttribute]
private sealed virtual override string JasperFx.CodeGeneration.ICodeFileCollection.get_ChildNamespace();
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.Events.EventGraph/<executeTombstoneBlock>d__138")]
private Task executeTombstoneBlock(UpdateBatch batch, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal IEventAppender get_EventAppender();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal void set_EventAppender(IEventAppender value);
    public sealed virtual EventAppendMode get_AppendMode();
    public sealed virtual void set_AppendMode(EventAppendMode value);
    [NullableContextAttribute("0")]
internal void ProcessEvents(DocumentSessionBase session);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.Events.EventGraph/<ProcessEventsAsync>d__147")]
internal Task ProcessEventsAsync(DocumentSessionBase session, CancellationToken token);
    [NullableContextAttribute("0")]
internal bool TryCreateTombstoneBatch(DocumentSessionBase session, UpdateBatch& batch);
    [NullableContextAttribute("0")]
internal void PostTombstones(UpdateBatch tombstoneBatch);
    [NullableContextAttribute("0")]
public Task PostTombstonesAsync(UpdateBatch tombstoneBatch);
}
public abstract class Marten.Events.EventMapping : object {
    protected DocumentMapping _inner;
    protected EventGraph _parent;
    private ISqlFragment _defaultWhereFragment;
    [CompilerGeneratedAttribute]
private Func`3<ISerializer, DbDataReader, IEvent> <ReadEventData>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`4<ISerializer, DbDataReader, CancellationToken, Task`1<IEvent>> <ReadEventDataAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private NpgsqlDbType <IdType>k__BackingField;
    [CompilerGeneratedAttribute]
private TenancyStyle <TenancyStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<DuplicatedField> <DuplicatedFields>k__BackingField;
    [CompilerGeneratedAttribute]
private DeleteStyle <DeleteStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseVersionFromMatchingStream>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertySearching <PropertySearching>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DocumentType>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <IdMember>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DotNetTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventTypeName>k__BackingField;
    public Func`3<ISerializer, DbDataReader, IEvent> ReadEventData { get; private set; }
    public Func`4<ISerializer, DbDataReader, CancellationToken, Task`1<IEvent>> ReadEventDataAsync { get; private set; }
    public NpgsqlDbType IdType { get; }
    public TenancyStyle TenancyStyle { get; }
    public IReadOnlyList`1<DuplicatedField> DuplicatedFields { get; }
    public DeleteStyle DeleteStyle { get; }
    public bool UseVersionFromMatchingStream { get; public set; }
    public PropertySearching PropertySearching { get; }
    private IDocumentMapping Marten.Schema.IDocumentMapping.Root { get; }
    public Type DocumentType { get; }
    public MemberInfo IdMember { get; }
    private Type Marten.Schema.IDocumentMapping.IdType { get; }
    public DbObjectName TableName { get; }
    private Type Marten.Events.IEventType.EventType { get; }
    public string DotNetTypeName { get; public set; }
    public string EventTypeName { get; public set; }
    public string Alias { get; }
    protected EventMapping(EventGraph parent, Type eventType);
    [CompilerGeneratedAttribute]
public Func`3<ISerializer, DbDataReader, IEvent> get_ReadEventData();
    [CompilerGeneratedAttribute]
private void set_ReadEventData(Func`3<ISerializer, DbDataReader, IEvent> value);
    [CompilerGeneratedAttribute]
public Func`4<ISerializer, DbDataReader, CancellationToken, Task`1<IEvent>> get_ReadEventDataAsync();
    [CompilerGeneratedAttribute]
private void set_ReadEventDataAsync(Func`4<ISerializer, DbDataReader, CancellationToken, Task`1<IEvent>> value);
    [CompilerGeneratedAttribute]
public NpgsqlDbType get_IdType();
    [CompilerGeneratedAttribute]
public sealed virtual TenancyStyle get_TenancyStyle();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<DuplicatedField> get_DuplicatedFields();
    [CompilerGeneratedAttribute]
public sealed virtual DeleteStyle get_DeleteStyle();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseVersionFromMatchingStream();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UseVersionFromMatchingStream(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual PropertySearching get_PropertySearching();
    private sealed virtual override IDocumentMapping Marten.Schema.IDocumentMapping.get_Root();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_DocumentType();
    [CompilerGeneratedAttribute]
public sealed virtual MemberInfo get_IdMember();
    private sealed virtual override Type Marten.Schema.IDocumentMapping.get_IdType();
    public sealed virtual DbObjectName get_TableName();
    private sealed virtual override Type Marten.Events.IEventType.get_EventType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_DotNetTypeName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DotNetTypeName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_EventTypeName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EventTypeName(string value);
    public sealed virtual string get_Alias();
    public sealed virtual String[] SelectFields();
    public sealed virtual ISqlFragment FilterDocuments(ISqlFragment query, IMartenSession martenSession);
    [IteratorStateMachineAttribute("Marten.Events.EventMapping/<extraFilters>d__57")]
private IEnumerable`1<ISqlFragment> extraFilters(ISqlFragment query);
    public sealed virtual ISqlFragment DefaultWhereFragment();
    public abstract virtual IEvent Wrap(object data);
    [NullableContextAttribute("2")]
public void JsonTransformation(JsonTransformation jsonTransformation);
}
public class Marten.Events.EventMapping`1 : EventMapping {
    private string _tableName;
    private Type _idType;
    [CompilerGeneratedAttribute]
private IQueryableMemberCollection <QueryMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseNumericRevisions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseOptimisticConcurrency>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperationFragment <HardDeleteFragment>k__BackingField;
    public IQueryableMemberCollection QueryMembers { get; }
    public ISelectClause SelectClauseWithDuplicatedFields { get; }
    public bool UseNumericRevisions { get; }
    public bool UseOptimisticConcurrency { get; }
    public IOperationFragment DeleteFragment { get; }
    public IOperationFragment HardDeleteFragment { get; }
    private string Marten.Linq.SqlGeneration.ISelectClause.FromObject { get; }
    private Type Marten.Linq.SqlGeneration.ISelectClause.SelectedType { get; }
    private Type Marten.Internal.Storage.IDocumentStorage.SourceType { get; }
    private Type Marten.Internal.Storage.IDocumentStorage.IdType { get; }
    public EventMapping`1(EventGraph parent);
    [CompilerGeneratedAttribute]
public sealed virtual IQueryableMemberCollection get_QueryMembers();
    public sealed virtual ISelectClause get_SelectClauseWithDuplicatedFields();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseNumericRevisions();
    public sealed virtual object RawIdentityValue(object id);
    public sealed virtual void TruncateDocumentStorage(IMartenDatabase database);
    public sealed virtual Task TruncateDocumentStorageAsync(IMartenDatabase database, CancellationToken ct);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseOptimisticConcurrency();
    public sealed virtual IOperationFragment get_DeleteFragment();
    [CompilerGeneratedAttribute]
public sealed virtual IOperationFragment get_HardDeleteFragment();
    private sealed virtual override string Marten.Linq.SqlGeneration.ISelectClause.get_FromObject();
    private sealed virtual override Type Marten.Linq.SqlGeneration.ISelectClause.get_SelectedType();
    private sealed virtual override void Weasel.Postgresql.SqlGeneration.ISqlFragment.Apply(ICommandBuilder sql);
    private sealed virtual override ISelector Marten.Linq.SqlGeneration.ISelectClause.BuildSelector(IMartenSession session);
    private sealed virtual override IQueryHandler`1<TResult> Marten.Linq.SqlGeneration.ISelectClause.BuildHandler(IMartenSession session, ISqlFragment topStatement, ISqlFragment currentStatement);
    private sealed virtual override ISelectClause Marten.Linq.SqlGeneration.ISelectClause.UseStatistics(QueryStatistics statistics);
    private sealed virtual override Type Marten.Internal.Storage.IDocumentStorage.get_SourceType();
    private sealed virtual override object Marten.Internal.Storage.IDocumentStorage<T>.IdentityFor(T document);
    private sealed virtual override Type Marten.Internal.Storage.IDocumentStorage.get_IdType();
    private sealed virtual override Nullable`1<Guid> Marten.Internal.Storage.IDocumentStorage<T>.VersionFor(T document, IMartenSession session);
    private sealed virtual override void Marten.Internal.Storage.IDocumentStorage<T>.Store(IMartenSession session, T document);
    private sealed virtual override void Marten.Internal.Storage.IDocumentStorage<T>.Store(IMartenSession session, T document, Nullable`1<Guid> version);
    public sealed virtual void Store(IMartenSession session, T document, int revision);
    private sealed virtual override void Marten.Internal.Storage.IDocumentStorage<T>.Eject(IMartenSession session, T document);
    private sealed virtual override IStorageOperation Marten.Internal.Storage.IDocumentStorage<T>.Update(T document, IMartenSession session, string tenant);
    private sealed virtual override IStorageOperation Marten.Internal.Storage.IDocumentStorage<T>.Insert(T document, IMartenSession session, string tenant);
    private sealed virtual override IStorageOperation Marten.Internal.Storage.IDocumentStorage<T>.Upsert(T document, IMartenSession session, string tenant);
    private sealed virtual override IStorageOperation Marten.Internal.Storage.IDocumentStorage<T>.Overwrite(T document, IMartenSession session, string tenant);
    public sealed virtual IDeletion DeleteForDocument(T document, string tenant);
    private sealed virtual override void Marten.Internal.Storage.IDocumentStorage<T>.EjectById(IMartenSession session, object id);
    private sealed virtual override void Marten.Internal.Storage.IDocumentStorage<T>.RemoveDirtyTracker(IMartenSession session, object id);
    public sealed virtual IDeletion HardDeleteForDocument(T document, string tenantId);
    public virtual IEvent Wrap(object data);
}
public static class Marten.Events.EventMappingExtensions : object {
    public static string GetEventTypeName(Type eventType);
    public static string GetEventTypeName();
    public static string GetEventTypeNameWithSuffix(string eventTypeName, string suffix);
    public static string GetEventTypeNameWithSuffix(Type eventType, string suffix);
    public static string GetEventTypeNameWithSuffix(string suffix);
    public static string GetEventTypeNameWithSchemaVersion(Type eventType, UInt32 schemaVersion);
    public static string GetEventTypeNameWithSchemaVersion(UInt32 schemaVersion);
    public static string GetEventTypeNameWithSchemaVersion(string eventTypeName, UInt32 schemaVersion);
}
public class Marten.Events.EventQueryMapping : DocumentMapping {
    [CompilerGeneratedAttribute]
private DbObjectName <TableName>k__BackingField;
    public DbObjectName TableName { get; }
    public EventQueryMapping(StoreOptions storeOptions);
    [CompilerGeneratedAttribute]
public virtual DbObjectName get_TableName();
    private void registerQueryableMember(Expression`1<Func`2<IEvent, object>> property, string columnName);
}
internal class Marten.Events.EventSequenceFetcher : object {
    private string _sql;
    public EventSequenceFetcher(EventGraph graph, int number);
    public sealed virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual Queue`1<long> Handle(DbDataReader reader, IMartenSession session);
    [AsyncStateMachineAttribute("Marten.Events.EventSequenceFetcher/<HandleAsync>d__4")]
public sealed virtual Task`1<Queue`1<long>> HandleAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
    public sealed virtual Task`1<int> StreamJson(Stream stream, DbDataReader reader, CancellationToken token);
}
internal class Marten.Events.EventStatement : SelectorStatement {
    private static string ALL_TENANTS;
    private IEventStorage _storage;
    [CompilerGeneratedAttribute]
private ISqlFragment[] <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private EventRange <Range>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StreamKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <StreamId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FromVersion>k__BackingField;
    public ISqlFragment[] Filters { get; public set; }
    public EventRange Range { get; public set; }
    public long Version { get; public set; }
    public Nullable`1<DateTimeOffset> Timestamp { get; public set; }
    public string TenantId { get; public set; }
    public string StreamKey { get; public set; }
    public Guid StreamId { get; public set; }
    public long FromVersion { get; public set; }
    public EventStatement(IEventStorage storage);
    [CompilerGeneratedAttribute]
public ISqlFragment[] get_Filters();
    [CompilerGeneratedAttribute]
public void set_Filters(ISqlFragment[] value);
    [CompilerGeneratedAttribute]
public EventRange get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(EventRange value);
    [CompilerGeneratedAttribute]
public long get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
public void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public string get_StreamKey();
    [CompilerGeneratedAttribute]
public void set_StreamKey(string value);
    [CompilerGeneratedAttribute]
public Guid get_StreamId();
    [CompilerGeneratedAttribute]
public void set_StreamId(Guid value);
    [CompilerGeneratedAttribute]
public long get_FromVersion();
    [CompilerGeneratedAttribute]
public void set_FromVersion(long value);
    protected virtual void configure(ICommandBuilder builder);
    [IteratorStateMachineAttribute("Marten.Events.EventStatement/<filters>d__36")]
private IEnumerable`1<ISqlFragment> filters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Events.EventStore : QueryEventStore {
    private DocumentSessionBase _session;
    private DocumentStore _store;
    [NullableAttribute("0")]
private ImHashMap`2<Type, object> _fetchStrategies;
    public EventStore(DocumentSessionBase session, DocumentStore store, Tenant tenant);
    public sealed virtual StreamAction Append(Guid stream, IEnumerable`1<object> events);
    public sealed virtual StreamAction Append(Guid stream, Object[] events);
    public sealed virtual StreamAction Append(string stream, IEnumerable`1<object> events);
    public sealed virtual StreamAction Append(string stream, Object[] events);
    public sealed virtual StreamAction Append(Guid stream, long expectedVersion, IEnumerable`1<object> events);
    public sealed virtual StreamAction Append(Guid stream, long expectedVersion, Object[] events);
    public sealed virtual StreamAction Append(string stream, long expectedVersion, IEnumerable`1<object> events);
    public sealed virtual StreamAction Append(string stream, long expectedVersion, Object[] events);
    public sealed virtual void ArchiveStream(Guid streamId);
    public sealed virtual void ArchiveStream(string streamKey);
    public sealed virtual void BuildCommandForReadingVersionForStream(ICommandBuilder builder, Guid streamId, bool forUpdate);
    public sealed virtual void BuildCommandForReadingVersionForStream(ICommandBuilder builder, string streamKey, bool forUpdate);
    [AsyncStateMachineAttribute("Marten.Events.EventStore/<AppendOptimistic>d__12")]
public sealed virtual Task AppendOptimistic(string streamKey, CancellationToken token, Object[] events);
    public sealed virtual Task AppendOptimistic(string streamKey, Object[] events);
    [AsyncStateMachineAttribute("Marten.Events.EventStore/<AppendOptimistic>d__14")]
public sealed virtual Task AppendOptimistic(Guid streamId, CancellationToken token, Object[] events);
    public sealed virtual Task AppendOptimistic(Guid streamId, Object[] events);
    [AsyncStateMachineAttribute("Marten.Events.EventStore/<AppendExclusive>d__16")]
public sealed virtual Task AppendExclusive(string streamKey, CancellationToken token, Object[] events);
    public sealed virtual Task AppendExclusive(string streamKey, Object[] events);
    [AsyncStateMachineAttribute("Marten.Events.EventStore/<AppendExclusive>d__18")]
public sealed virtual Task AppendExclusive(Guid streamId, CancellationToken token, Object[] events);
    public sealed virtual Task AppendExclusive(Guid streamId, Object[] events);
    [AsyncStateMachineAttribute("Marten.Events.EventStore/<readVersionFromExistingStream>d__20")]
private Task`1<long> readVersionFromExistingStream(Guid streamId, bool forUpdate, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Events.EventStore/<readVersionFromExistingStream>d__21")]
private Task`1<long> readVersionFromExistingStream(string streamKey, bool forUpdate, CancellationToken token);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.Events.EventStore/<Marten-Events-IEventIdentityStrategy<System-Guid>-EnsureEventStorageExists>d__26`1")]
private sealed virtual override Task`1<IEventStorage> Marten.Events.IEventIdentityStrategy<System.Guid>.EnsureEventStorageExists(DocumentSessionBase session, CancellationToken cancellation);
    [NullableContextAttribute("0")]
private sealed virtual override IEventStream`1<TDoc> Marten.Events.IEventIdentityStrategy<System.Guid>.StartStream(TDoc document, DocumentSessionBase session, Guid id, CancellationToken cancellation);
    [NullableContextAttribute("0")]
private sealed virtual override IEventStream`1<TDoc> Marten.Events.IEventIdentityStrategy<System.Guid>.AppendToStream(TDoc document, DocumentSessionBase session, Guid id, long version, CancellationToken cancellation);
    [NullableContextAttribute("0")]
private sealed virtual override IQueryHandler`1<IReadOnlyList`1<IEvent>> Marten.Events.IEventIdentityStrategy<System.Guid>.BuildEventQueryHandler(Guid id, IEventStorage selector, ISqlFragment filter);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.Events.EventStore/<Marten-Events-IEventIdentityStrategy<System-String>-EnsureEventStorageExists>d__30`1")]
private sealed virtual override Task`1<IEventStorage> Marten.Events.IEventIdentityStrategy<System.String>.EnsureEventStorageExists(DocumentSessionBase session, CancellationToken cancellation);
    [NullableContextAttribute("0")]
private sealed virtual override IEventStream`1<TDoc> Marten.Events.IEventIdentityStrategy<System.String>.StartStream(TDoc document, DocumentSessionBase session, string id, CancellationToken cancellation);
    [NullableContextAttribute("0")]
private sealed virtual override IEventStream`1<TDoc> Marten.Events.IEventIdentityStrategy<System.String>.AppendToStream(TDoc document, DocumentSessionBase session, string id, long version, CancellationToken cancellation);
    [NullableContextAttribute("0")]
private sealed virtual override IQueryHandler`1<IReadOnlyList`1<IEvent>> Marten.Events.IEventIdentityStrategy<System.String>.BuildEventQueryHandler(string id, IEventStorage selector, ISqlFragment filter);
    [NullableContextAttribute("0")]
public sealed virtual Task`1<IEventStream`1<T>> FetchForWriting(Guid id, CancellationToken cancellation);
    [NullableContextAttribute("0")]
public sealed virtual Task`1<IEventStream`1<T>> FetchForWriting(string key, CancellationToken cancellation);
    [NullableContextAttribute("0")]
public sealed virtual Task`1<IEventStream`1<T>> FetchForWriting(Guid id, long initialVersion, CancellationToken cancellation);
    [NullableContextAttribute("0")]
public sealed virtual Task`1<IEventStream`1<T>> FetchForWriting(string key, long initialVersion, CancellationToken cancellation);
    [NullableContextAttribute("0")]
public sealed virtual Task`1<IEventStream`1<T>> FetchForExclusiveWriting(Guid id, CancellationToken cancellation);
    [NullableContextAttribute("0")]
public sealed virtual Task`1<IEventStream`1<T>> FetchForExclusiveWriting(string key, CancellationToken cancellation);
    [NullableContextAttribute("0")]
private IAggregateFetchPlan`2<TDoc, TId> findFetchPlan();
    [NullableContextAttribute("0")]
private IAggregateFetchPlan`2<TDoc, TId> determineFetchPlan(IDocumentStorage`2<TDoc, TId> storage, StoreOptions options);
    public sealed virtual StreamAction StartStream(Guid id, IEnumerable`1<object> events);
    public sealed virtual StreamAction StartStream(Guid id, Object[] events);
    public sealed virtual StreamAction StartStream(Type aggregateType, Guid id, IEnumerable`1<object> events);
    public sealed virtual StreamAction StartStream(Type aggregateType, Guid id, Object[] events);
    public sealed virtual StreamAction StartStream(string streamKey, IEnumerable`1<object> events);
    public sealed virtual StreamAction StartStream(string streamKey, Object[] events);
    public sealed virtual StreamAction StartStream(Type aggregateType, string streamKey, IEnumerable`1<object> events);
    public sealed virtual StreamAction StartStream(Type aggregateType, string streamKey, Object[] events);
    public sealed virtual StreamAction StartStream(Guid id, IEnumerable`1<object> events);
    public sealed virtual StreamAction StartStream(Guid id, Object[] events);
    public sealed virtual StreamAction StartStream(string streamKey, IEnumerable`1<object> events);
    public sealed virtual StreamAction StartStream(string streamKey, Object[] events);
    public sealed virtual StreamAction StartStream(IEnumerable`1<object> events);
    public sealed virtual StreamAction StartStream(Object[] events);
    public sealed virtual StreamAction StartStream(Type aggregateType, IEnumerable`1<object> events);
    public sealed virtual StreamAction StartStream(Type aggregateType, Object[] events);
    public sealed virtual StreamAction StartStream(IEnumerable`1<object> events);
    public sealed virtual StreamAction StartStream(Object[] events);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.Events.EventStore/<WriteToAggregate>d__60`1")]
public sealed virtual Task WriteToAggregate(Guid id, Action`1<IEventStream`1<T>> writing, CancellationToken cancellation);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.Events.EventStore/<WriteToAggregate>d__61`1")]
public sealed virtual Task WriteToAggregate(Guid id, Func`2<IEventStream`1<T>, Task> writing, CancellationToken cancellation);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.Events.EventStore/<WriteToAggregate>d__62`1")]
public sealed virtual Task WriteToAggregate(string id, Action`1<IEventStream`1<T>> writing, CancellationToken cancellation);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.Events.EventStore/<WriteToAggregate>d__63`1")]
public sealed virtual Task WriteToAggregate(string id, Func`2<IEventStream`1<T>, Task> writing, CancellationToken cancellation);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.Events.EventStore/<WriteToAggregate>d__64`1")]
public sealed virtual Task WriteToAggregate(Guid id, int initialVersion, Action`1<IEventStream`1<T>> writing, CancellationToken cancellation);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.Events.EventStore/<WriteToAggregate>d__65`1")]
public sealed virtual Task WriteToAggregate(Guid id, int initialVersion, Func`2<IEventStream`1<T>, Task> writing, CancellationToken cancellation);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.Events.EventStore/<WriteToAggregate>d__66`1")]
public sealed virtual Task WriteToAggregate(string id, int initialVersion, Action`1<IEventStream`1<T>> writing, CancellationToken cancellation);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.Events.EventStore/<WriteToAggregate>d__67`1")]
public sealed virtual Task WriteToAggregate(string id, int initialVersion, Func`2<IEventStream`1<T>, Task> writing, CancellationToken cancellation);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.Events.EventStore/<WriteExclusivelyToAggregate>d__68`1")]
public sealed virtual Task WriteExclusivelyToAggregate(Guid id, Action`1<IEventStream`1<T>> writing, CancellationToken cancellation);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.Events.EventStore/<WriteExclusivelyToAggregate>d__69`1")]
public sealed virtual Task WriteExclusivelyToAggregate(string id, Action`1<IEventStream`1<T>> writing, CancellationToken cancellation);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.Events.EventStore/<WriteExclusivelyToAggregate>d__70`1")]
public sealed virtual Task WriteExclusivelyToAggregate(Guid id, Func`2<IEventStream`1<T>, Task> writing, CancellationToken cancellation);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.Events.EventStore/<WriteExclusivelyToAggregate>d__71`1")]
public sealed virtual Task WriteExclusivelyToAggregate(string id, Func`2<IEventStream`1<T>, Task> writing, CancellationToken cancellation);
}
public class Marten.Events.EventStoreStatistics : object {
    [CompilerGeneratedAttribute]
private long <EventCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StreamCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EventSequenceNumber>k__BackingField;
    public long EventCount { get; public set; }
    public long StreamCount { get; public set; }
    public long EventSequenceNumber { get; public set; }
    [CompilerGeneratedAttribute]
public long get_EventCount();
    [CompilerGeneratedAttribute]
public void set_EventCount(long value);
    [CompilerGeneratedAttribute]
public long get_StreamCount();
    [CompilerGeneratedAttribute]
public void set_StreamCount(long value);
    [CompilerGeneratedAttribute]
public long get_EventSequenceNumber();
    [CompilerGeneratedAttribute]
public void set_EventSequenceNumber(long value);
}
internal class Marten.Events.EventStream`1 : object {
    private StreamAction _stream;
    private Func`2<object, IEvent> _wrapper;
    [CompilerGeneratedAttribute]
private T <Aggregate>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <Cancellation>k__BackingField;
    public Guid Id { get; }
    public string Key { get; }
    public T Aggregate { get; }
    public Nullable`1<long> StartingVersion { get; }
    public Nullable`1<long> CurrentVersion { get; }
    public CancellationToken Cancellation { get; }
    public IReadOnlyList`1<IEvent> Events { get; }
    public EventStream`1(EventGraph events, Guid streamId, T aggregate, CancellationToken cancellation, StreamAction stream);
    public EventStream`1(EventGraph events, string streamKey, T aggregate, CancellationToken cancellation, StreamAction stream);
    public sealed virtual Guid get_Id();
    public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual T get_Aggregate();
    public sealed virtual Nullable`1<long> get_StartingVersion();
    public sealed virtual Nullable`1<long> get_CurrentVersion();
    public sealed virtual void AppendOne(object event);
    public sealed virtual void AppendMany(Object[] events);
    public sealed virtual void AppendMany(IEnumerable`1<object> events);
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_Cancellation();
    public sealed virtual IReadOnlyList`1<IEvent> get_Events();
    [CompilerGeneratedAttribute]
private IEvent <AppendMany>b__16_0(object e);
    [CompilerGeneratedAttribute]
private IEvent <AppendMany>b__17_0(object e);
}
internal class Marten.Events.EventTypesAreParser : object {
    public sealed virtual bool Matches(MethodCallExpression expression);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
internal class Marten.Events.Fetching.AggregateEventFloor`1 : object {
    private DbObjectName _tableName;
    private TId _id;
    public AggregateEventFloor`1(DbObjectName tableName, TId id);
    public sealed virtual void Apply(ICommandBuilder builder);
}
internal class Marten.Events.Fetching.AsyncFetchPlanner : object {
    public sealed virtual bool TryMatch(IDocumentStorage`2<TDoc, TId> storage, IEventIdentityStrategy`1<TId> identity, StoreOptions options, IAggregateFetchPlan`2& plan);
}
internal class Marten.Events.Fetching.FetchAsyncPlan`2 : object {
    private EventGraph _events;
    private IEventIdentityStrategy`1<TId> _identityStrategy;
    private IDocumentStorage`2<TDoc, TId> _storage;
    private ILiveAggregator`1<TDoc> _aggregator;
    private string _versionSelectionSql;
    private string _initialSql;
    public FetchAsyncPlan`2(EventGraph events, IEventIdentityStrategy`1<TId> identityStrategy, IDocumentStorage`2<TDoc, TId> storage);
    [AsyncStateMachineAttribute("Marten.Events.Fetching.FetchAsyncPlan`2/<FetchForWriting>d__7")]
public sealed virtual Task`1<IEventStream`1<TDoc>> FetchForWriting(DocumentSessionBase session, TId id, bool forUpdate, CancellationToken cancellation);
    private void writeEventFetchStatement(TId id, BatchBuilder builder);
    [AsyncStateMachineAttribute("Marten.Events.Fetching.FetchAsyncPlan`2/<FetchForWriting>d__9")]
public sealed virtual Task`1<IEventStream`1<TDoc>> FetchForWriting(DocumentSessionBase session, TId id, long expectedStartingVersion, CancellationToken cancellation);
}
internal class Marten.Events.Fetching.FetchInlinedPlan`2 : object {
    private EventGraph _events;
    private IEventIdentityStrategy`1<TId> _identityStrategy;
    internal FetchInlinedPlan`2(EventGraph events, IEventIdentityStrategy`1<TId> identityStrategy);
    [AsyncStateMachineAttribute("Marten.Events.Fetching.FetchInlinedPlan`2/<FetchForWriting>d__3")]
public sealed virtual Task`1<IEventStream`1<TDoc>> FetchForWriting(DocumentSessionBase session, TId id, bool forUpdate, CancellationToken cancellation);
    [AsyncStateMachineAttribute("Marten.Events.Fetching.FetchInlinedPlan`2/<FetchForWriting>d__4")]
public sealed virtual Task`1<IEventStream`1<TDoc>> FetchForWriting(DocumentSessionBase session, TId id, long expectedStartingVersion, CancellationToken cancellation);
}
internal class Marten.Events.Fetching.FetchLivePlan`2 : object {
    private ILiveAggregator`1<TDoc> _aggregator;
    private IDocumentStorage`2<TDoc, TId> _documentStorage;
    private EventGraph _events;
    private IEventIdentityStrategy`1<TId> _identityStrategy;
    public FetchLivePlan`2(EventGraph events, IEventIdentityStrategy`1<TId> identityStrategy, IDocumentStorage`2<TDoc, TId> documentStorage);
    [AsyncStateMachineAttribute("Marten.Events.Fetching.FetchLivePlan`2/<FetchForWriting>d__5")]
public sealed virtual Task`1<IEventStream`1<TDoc>> FetchForWriting(DocumentSessionBase session, TId id, bool forUpdate, CancellationToken cancellation);
    [AsyncStateMachineAttribute("Marten.Events.Fetching.FetchLivePlan`2/<FetchForWriting>d__6")]
public sealed virtual Task`1<IEventStream`1<TDoc>> FetchForWriting(DocumentSessionBase session, TId id, long expectedStartingVersion, CancellationToken cancellation);
}
public interface Marten.Events.Fetching.IFetchPlanner {
    public abstract virtual bool TryMatch(IDocumentStorage`2<TDoc, TId> storage, IEventIdentityStrategy`1<TId> identity, StoreOptions options, IAggregateFetchPlan`2& plan);
}
internal class Marten.Events.Fetching.InlineFetchPlanner : object {
    public sealed virtual bool TryMatch(IDocumentStorage`2<TDoc, TId> storage, IEventIdentityStrategy`1<TId> identity, StoreOptions options, IAggregateFetchPlan`2& plan);
}
internal class Marten.Events.Fetching.LiveFetchPlanner : object {
    public sealed virtual bool TryMatch(IDocumentStorage`2<TDoc, TId> storage, IEventIdentityStrategy`1<TId> identity, StoreOptions options, IAggregateFetchPlan`2& plan);
}
public interface Marten.Events.IAggregateFetchPlan`2 {
    public abstract virtual Task`1<IEventStream`1<TDoc>> FetchForWriting(DocumentSessionBase session, TId id, bool forUpdate, CancellationToken cancellation);
    public abstract virtual Task`1<IEventStream`1<TDoc>> FetchForWriting(DocumentSessionBase session, TId id, long expectedStartingVersion, CancellationToken cancellation);
}
[NullableContextAttribute("1")]
public interface Marten.Events.IEvent {
    public Guid Id { get; public set; }
    public long Version { get; public set; }
    public long Sequence { get; public set; }
    public object Data { get; }
    public Guid StreamId { get; public set; }
    [NullableAttribute("2")]
public string StreamKey { get; public set; }
    public DateTimeOffset Timestamp { get; public set; }
    public string TenantId { get; public set; }
    public Type EventType { get; }
    public string EventTypeName { get; public set; }
    public string DotNetTypeName { get; public set; }
    [NullableAttribute("2")]
public string CausationId { get; public set; }
    [NullableAttribute("2")]
public string CorrelationId { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, object> Headers { get; public set; }
    public bool IsArchived { get; public set; }
    [NullableAttribute("2")]
public string AggregateTypeName { get; public set; }
    public abstract virtual Guid get_Id();
    public abstract virtual void set_Id(Guid value);
    public abstract virtual long get_Version();
    public abstract virtual void set_Version(long value);
    public abstract virtual long get_Sequence();
    public abstract virtual void set_Sequence(long value);
    public abstract virtual object get_Data();
    public abstract virtual Guid get_StreamId();
    public abstract virtual void set_StreamId(Guid value);
    [NullableContextAttribute("2")]
public abstract virtual string get_StreamKey();
    [NullableContextAttribute("2")]
public abstract virtual void set_StreamKey(string value);
    public abstract virtual DateTimeOffset get_Timestamp();
    public abstract virtual void set_Timestamp(DateTimeOffset value);
    public abstract virtual string get_TenantId();
    public abstract virtual void set_TenantId(string value);
    public abstract virtual Type get_EventType();
    public abstract virtual string get_EventTypeName();
    public abstract virtual void set_EventTypeName(string value);
    public abstract virtual string get_DotNetTypeName();
    public abstract virtual void set_DotNetTypeName(string value);
    [NullableContextAttribute("2")]
public abstract virtual string get_CausationId();
    [NullableContextAttribute("2")]
public abstract virtual void set_CausationId(string value);
    [NullableContextAttribute("2")]
public abstract virtual string get_CorrelationId();
    [NullableContextAttribute("2")]
public abstract virtual void set_CorrelationId(string value);
    public abstract virtual Dictionary`2<string, object> get_Headers();
    public abstract virtual void set_Headers(Dictionary`2<string, object> value);
    public abstract virtual bool get_IsArchived();
    public abstract virtual void set_IsArchived(bool value);
    [NullableContextAttribute("2")]
public abstract virtual string get_AggregateTypeName();
    [NullableContextAttribute("2")]
public abstract virtual void set_AggregateTypeName(string value);
    public abstract virtual void SetHeader(string key, object value);
    public abstract virtual object GetHeader(string key);
}
[NullableContextAttribute("1")]
public interface Marten.Events.IEvent`1 {
    public T Data { get; }
    public abstract virtual T get_Data();
}
internal interface Marten.Events.IEventAppender {
    public abstract virtual void ProcessEvents(EventGraph eventGraph, DocumentSessionBase session, IProjection[] inlineProjectionsValue);
    public abstract virtual Task ProcessEventsAsync(EventGraph eventGraph, DocumentSessionBase session, IProjection[] inlineProjections, CancellationToken token);
}
public interface Marten.Events.IEventAppendingStep {
    public abstract virtual ValueTask ApplyAsync(DocumentSessionBase session, EventGraph eventGraph, Queue`1<long> sequences, IEventStorage storage, CancellationToken cancellationToken);
}
public interface Marten.Events.IEventIdentityStrategy`1 {
    public abstract virtual Task`1<IEventStorage> EnsureEventStorageExists(DocumentSessionBase session, CancellationToken cancellation);
    public abstract virtual void BuildCommandForReadingVersionForStream(ICommandBuilder builder, TId id, bool forUpdate);
    public abstract virtual IEventStream`1<TDoc> StartStream(TDoc document, DocumentSessionBase session, TId id, CancellationToken cancellation);
    public abstract virtual IEventStream`1<TDoc> AppendToStream(TDoc document, DocumentSessionBase session, TId id, long version, CancellationToken cancellation);
    public abstract virtual IQueryHandler`1<IReadOnlyList`1<IEvent>> BuildEventQueryHandler(TId id, IEventStorage eventStorage, ISqlFragment filter);
}
public interface Marten.Events.IEventOperations {
    public abstract virtual StreamAction Append(Guid stream, IEnumerable`1<object> events);
    public abstract virtual StreamAction Append(Guid stream, Object[] events);
    public abstract virtual StreamAction Append(string stream, IEnumerable`1<object> events);
    public abstract virtual StreamAction Append(string stream, Object[] events);
    public abstract virtual StreamAction Append(Guid stream, long expectedVersion, Object[] events);
    public abstract virtual StreamAction Append(string stream, long expectedVersion, IEnumerable`1<object> events);
    public abstract virtual StreamAction Append(string stream, long expectedVersion, Object[] events);
    public abstract virtual StreamAction StartStream(Guid id, Object[] events);
    public abstract virtual StreamAction StartStream(Type aggregateType, Guid id, IEnumerable`1<object> events);
    public abstract virtual StreamAction StartStream(Type aggregateType, Guid id, Object[] events);
    public abstract virtual StreamAction StartStream(string streamKey, IEnumerable`1<object> events);
    public abstract virtual StreamAction StartStream(string streamKey, Object[] events);
    public abstract virtual StreamAction StartStream(Type aggregateType, string streamKey, IEnumerable`1<object> events);
    public abstract virtual StreamAction StartStream(Type aggregateType, string streamKey, Object[] events);
    public abstract virtual StreamAction StartStream(Guid id, IEnumerable`1<object> events);
    public abstract virtual StreamAction StartStream(Guid id, Object[] events);
    public abstract virtual StreamAction StartStream(string streamKey, IEnumerable`1<object> events);
    public abstract virtual StreamAction StartStream(string streamKey, Object[] events);
    public abstract virtual StreamAction StartStream(IEnumerable`1<object> events);
    public abstract virtual StreamAction StartStream(Object[] events);
    public abstract virtual StreamAction StartStream(Type aggregateType, IEnumerable`1<object> events);
    public abstract virtual StreamAction StartStream(Type aggregateType, Object[] events);
    public abstract virtual StreamAction StartStream(IEnumerable`1<object> events);
    public abstract virtual StreamAction StartStream(Object[] events);
}
public interface Marten.Events.IEventStorage {
    public abstract virtual IStorageOperation AppendEvent(EventGraph events, IMartenSession session, StreamAction stream, IEvent e);
    public abstract virtual IStorageOperation InsertStream(StreamAction stream);
    public abstract virtual IQueryHandler`1<StreamState> QueryForStream(StreamAction stream);
    public abstract virtual IStorageOperation UpdateStreamVersion(StreamAction stream);
    public abstract virtual IStorageOperation IncrementStreamVersion(StreamAction stream);
    public abstract virtual IStorageOperation QuickAppendEvents(StreamAction stream);
    public abstract virtual IStorageOperation QuickAppendEventWithVersion(EventGraph events, IMartenSession session, StreamAction stream, IEvent e);
}
[NullableContextAttribute("1")]
public interface Marten.Events.IEventStore {
    public abstract virtual StreamAction Append(Guid stream, long expectedVersion, IEnumerable`1<object> events);
    public abstract virtual StreamAction StartStream(Guid id, IEnumerable`1<object> events);
    public abstract virtual Task AppendOptimistic(string streamKey, CancellationToken token, Object[] events);
    public abstract virtual Task AppendOptimistic(string streamKey, Object[] events);
    public abstract virtual Task AppendOptimistic(Guid streamId, CancellationToken token, Object[] events);
    public abstract virtual Task AppendOptimistic(Guid streamId, Object[] events);
    public abstract virtual Task AppendExclusive(string streamKey, CancellationToken token, Object[] events);
    public abstract virtual Task AppendExclusive(string streamKey, Object[] events);
    public abstract virtual Task AppendExclusive(Guid streamId, CancellationToken token, Object[] events);
    public abstract virtual Task AppendExclusive(Guid streamId, Object[] events);
    public abstract virtual void ArchiveStream(Guid streamId);
    public abstract virtual void ArchiveStream(string streamKey);
    public abstract virtual Task`1<IEventStream`1<T>> FetchForWriting(Guid id, CancellationToken cancellation);
    public abstract virtual Task WriteToAggregate(Guid id, Action`1<IEventStream`1<T>> writing, CancellationToken cancellation);
    public abstract virtual Task WriteToAggregate(Guid id, Func`2<IEventStream`1<T>, Task> writing, CancellationToken cancellation);
    public abstract virtual Task WriteToAggregate(string id, Action`1<IEventStream`1<T>> writing, CancellationToken cancellation);
    public abstract virtual Task WriteToAggregate(string id, Func`2<IEventStream`1<T>, Task> writing, CancellationToken cancellation);
    public abstract virtual Task`1<IEventStream`1<T>> FetchForWriting(string key, CancellationToken cancellation);
    public abstract virtual Task`1<IEventStream`1<T>> FetchForWriting(Guid id, long expectedVersion, CancellationToken cancellation);
    public abstract virtual Task`1<IEventStream`1<T>> FetchForWriting(string key, long expectedVersion, CancellationToken cancellation);
    public abstract virtual Task WriteToAggregate(Guid id, int expectedVersion, Action`1<IEventStream`1<T>> writing, CancellationToken cancellation);
    public abstract virtual Task WriteToAggregate(Guid id, int expectedVersion, Func`2<IEventStream`1<T>, Task> writing, CancellationToken cancellation);
    public abstract virtual Task WriteToAggregate(string id, int expectedVersion, Action`1<IEventStream`1<T>> writing, CancellationToken cancellation);
    public abstract virtual Task WriteToAggregate(string id, int expectedVersion, Func`2<IEventStream`1<T>, Task> writing, CancellationToken cancellation);
    public abstract virtual Task`1<IEventStream`1<T>> FetchForExclusiveWriting(Guid id, CancellationToken cancellation);
    public abstract virtual Task`1<IEventStream`1<T>> FetchForExclusiveWriting(string key, CancellationToken cancellation);
    public abstract virtual Task WriteExclusivelyToAggregate(Guid id, Action`1<IEventStream`1<T>> writing, CancellationToken cancellation);
    public abstract virtual Task WriteExclusivelyToAggregate(string id, Action`1<IEventStream`1<T>> writing, CancellationToken cancellation);
    public abstract virtual Task WriteExclusivelyToAggregate(Guid id, Func`2<IEventStream`1<T>, Task> writing, CancellationToken cancellation);
    public abstract virtual Task WriteExclusivelyToAggregate(string id, Func`2<IEventStream`1<T>, Task> writing, CancellationToken cancellation);
}
[NullableContextAttribute("1")]
public interface Marten.Events.IEventStoreOptions {
    public StreamIdentity StreamIdentity { get; public set; }
    public TenancyStyle TenancyStyle { get; public set; }
    public bool EnableGlobalProjectionsForConjoinedTenancy { get; public set; }
    public bool UseIdentityMapForInlineAggregates { get; public set; }
    public string DatabaseSchemaName { get; public set; }
    public MetadataConfig MetadataConfig { get; }
    public TimeProvider TimeProvider { get; public set; }
    public bool EnableUniqueIndexOnEventId { get; public set; }
    public EventAppendMode AppendMode { get; public set; }
    public bool UseArchivedStreamPartitioning { get; public set; }
    public IMessageOutbox MessageOutbox { get; public set; }
    public abstract virtual StreamIdentity get_StreamIdentity();
    public abstract virtual void set_StreamIdentity(StreamIdentity value);
    public abstract virtual TenancyStyle get_TenancyStyle();
    public abstract virtual void set_TenancyStyle(TenancyStyle value);
    public abstract virtual bool get_EnableGlobalProjectionsForConjoinedTenancy();
    public abstract virtual void set_EnableGlobalProjectionsForConjoinedTenancy(bool value);
    public abstract virtual bool get_UseIdentityMapForInlineAggregates();
    public abstract virtual void set_UseIdentityMapForInlineAggregates(bool value);
    public abstract virtual string get_DatabaseSchemaName();
    public abstract virtual void set_DatabaseSchemaName(string value);
    public abstract virtual MetadataConfig get_MetadataConfig();
    public abstract virtual TimeProvider get_TimeProvider();
    public abstract virtual void set_TimeProvider(TimeProvider value);
    public abstract virtual bool get_EnableUniqueIndexOnEventId();
    public abstract virtual void set_EnableUniqueIndexOnEventId(bool value);
    public abstract virtual EventAppendMode get_AppendMode();
    public abstract virtual void set_AppendMode(EventAppendMode value);
    public abstract virtual bool get_UseArchivedStreamPartitioning();
    public abstract virtual void set_UseArchivedStreamPartitioning(bool value);
    public abstract virtual IMessageOutbox get_MessageOutbox();
    public abstract virtual void set_MessageOutbox(IMessageOutbox value);
    public abstract virtual IEventStoreOptions AddEventType();
    public abstract virtual void AddEventType(Type eventType);
    public abstract virtual void AddEventTypes(IEnumerable`1<Type> types);
    public abstract virtual void MapEventType(string eventTypeName);
    public abstract virtual void MapEventType(Type eventType, string eventTypeName);
    public abstract virtual void Subscribe(ISubscription subscription);
    public abstract virtual void Subscribe(ISubscription subscription, Action`1<ISubscriptionOptions> configure);
    public abstract virtual IEventStoreOptions Upcast(string eventTypeName, JsonTransformation jsonTransformation);
    public abstract virtual IEventStoreOptions Upcast(Type eventType, string eventTypeName, JsonTransformation jsonTransformation);
    public abstract virtual IEventStoreOptions Upcast(string eventTypeName, Func`2<TOldEvent, TEvent> upcast);
    public abstract virtual IEventStoreOptions Upcast(Func`2<TOldEvent, TEvent> upcast);
    public abstract virtual IEventStoreOptions Upcast(string eventTypeName, Func`3<TOldEvent, CancellationToken, Task`1<TEvent>> upcastAsync);
    public abstract virtual IEventStoreOptions Upcast(Func`3<TOldEvent, CancellationToken, Task`1<TEvent>> upcastAsync);
    public abstract virtual IEventStoreOptions Upcast(IEventUpcaster[] upcasters);
    public abstract virtual IEventStoreOptions Upcast();
}
public interface Marten.Events.IEventStream`1 {
    public T Aggregate { get; }
    public Nullable`1<long> StartingVersion { get; }
    public Nullable`1<long> CurrentVersion { get; }
    public CancellationToken Cancellation { get; }
    public Guid Id { get; }
    public string Key { get; }
    public IReadOnlyList`1<IEvent> Events { get; }
    public abstract virtual T get_Aggregate();
    public abstract virtual Nullable`1<long> get_StartingVersion();
    public abstract virtual Nullable`1<long> get_CurrentVersion();
    public abstract virtual CancellationToken get_Cancellation();
    public abstract virtual Guid get_Id();
    public abstract virtual string get_Key();
    public abstract virtual IReadOnlyList`1<IEvent> get_Events();
    public abstract virtual void AppendOne(object event);
    public abstract virtual void AppendMany(Object[] events);
    public abstract virtual void AppendMany(IEnumerable`1<object> events);
}
public interface Marten.Events.IEventType {
    public Type EventType { get; }
    public string DotNetTypeName { get; public set; }
    public string EventTypeName { get; public set; }
    public string Alias { get; }
    public abstract virtual Type get_EventType();
    public abstract virtual string get_DotNetTypeName();
    public abstract virtual void set_DotNetTypeName(string value);
    public abstract virtual string get_EventTypeName();
    public abstract virtual void set_EventTypeName(string value);
    public abstract virtual string get_Alias();
}
[NullableContextAttribute("1")]
public interface Marten.Events.IQueryEventStore {
    public abstract virtual IReadOnlyList`1<IEvent> FetchStream(Guid streamId, long version, Nullable`1<DateTimeOffset> timestamp, long fromVersion);
    public abstract virtual Task`1<IReadOnlyList`1<IEvent>> FetchStreamAsync(Guid streamId, long version, Nullable`1<DateTimeOffset> timestamp, long fromVersion, CancellationToken token);
    public abstract virtual IReadOnlyList`1<IEvent> FetchStream(string streamKey, long version, Nullable`1<DateTimeOffset> timestamp, long fromVersion);
    public abstract virtual Task`1<IReadOnlyList`1<IEvent>> FetchStreamAsync(string streamKey, long version, Nullable`1<DateTimeOffset> timestamp, long fromVersion, CancellationToken token);
    [NullableContextAttribute("2")]
public abstract virtual T AggregateStream(Guid streamId, long version, Nullable`1<DateTimeOffset> timestamp, T state, long fromVersion);
    public abstract virtual Task`1<T> AggregateStreamAsync(Guid streamId, long version, Nullable`1<DateTimeOffset> timestamp, T state, long fromVersion, CancellationToken token);
    public abstract virtual T AggregateStream(string streamKey, long version, Nullable`1<DateTimeOffset> timestamp, T state, long fromVersion);
    public abstract virtual Task`1<T> AggregateStreamAsync(string streamKey, long version, Nullable`1<DateTimeOffset> timestamp, T state, long fromVersion, CancellationToken token);
    public abstract virtual IMartenQueryable`1<T> QueryRawEventDataOnly();
    public abstract virtual IMartenQueryable`1<IEvent> QueryAllRawEvents();
    public abstract virtual IEvent`1<T> Load(Guid id);
    public abstract virtual Task`1<IEvent`1<T>> LoadAsync(Guid id, CancellationToken token);
    [NullableContextAttribute("2")]
public abstract virtual IEvent Load(Guid id);
    public abstract virtual Task`1<IEvent> LoadAsync(Guid id, CancellationToken token);
    [NullableContextAttribute("2")]
public abstract virtual StreamState FetchStreamState(Guid streamId);
    public abstract virtual Task`1<StreamState> FetchStreamStateAsync(Guid streamId, CancellationToken token);
    public abstract virtual StreamState FetchStreamState(string streamKey);
    public abstract virtual Task`1<StreamState> FetchStreamStateAsync(string streamKey, CancellationToken token);
}
[NullableContextAttribute("1")]
public interface Marten.Events.IReadOnlyEventStoreOptions {
    public IReadOnlyDaemonSettings Daemon { get; }
    public StreamIdentity StreamIdentity { get; }
    public TenancyStyle TenancyStyle { get; }
    public string DatabaseSchemaName { get; }
    public IReadonlyMetadataConfig MetadataConfig { get; }
    public bool EnableUniqueIndexOnEventId { get; public set; }
    public EventAppendMode AppendMode { get; public set; }
    public bool UseIdentityMapForInlineAggregates { get; public set; }
    public bool UseArchivedStreamPartitioning { get; public set; }
    public IMessageOutbox MessageOutbox { get; public set; }
    public abstract virtual IReadOnlyDaemonSettings get_Daemon();
    public abstract virtual StreamIdentity get_StreamIdentity();
    public abstract virtual TenancyStyle get_TenancyStyle();
    public abstract virtual string get_DatabaseSchemaName();
    public abstract virtual IReadonlyMetadataConfig get_MetadataConfig();
    public abstract virtual bool get_EnableUniqueIndexOnEventId();
    public abstract virtual void set_EnableUniqueIndexOnEventId(bool value);
    public abstract virtual EventAppendMode get_AppendMode();
    public abstract virtual void set_AppendMode(EventAppendMode value);
    public abstract virtual IReadOnlyList`1<IReadOnlyProjectionData> Projections();
    public abstract virtual IReadOnlyList`1<IEventType> AllKnownEventTypes();
    public abstract virtual bool get_UseIdentityMapForInlineAggregates();
    public abstract virtual void set_UseIdentityMapForInlineAggregates(bool value);
    public abstract virtual bool get_UseArchivedStreamPartitioning();
    public abstract virtual void set_UseArchivedStreamPartitioning(bool value);
    public abstract virtual IMessageOutbox get_MessageOutbox();
    public abstract virtual void set_MessageOutbox(IMessageOutbox value);
}
public interface Marten.Events.IReadonlyMetadataConfig {
    public bool CorrelationIdEnabled { get; }
    public bool CausationIdEnabled { get; }
    public bool HeadersEnabled { get; }
    public abstract virtual bool get_CorrelationIdEnabled();
    public abstract virtual bool get_CausationIdEnabled();
    public abstract virtual bool get_HeadersEnabled();
}
internal class Marten.Events.IsArchivedMember : object {
    private static string _locator;
    public Type MemberType { get; }
    public string JsonPathSegment { get; }
    public string MemberName { get; }
    public string TypedLocator { get; }
    public string RawLocator { get; }
    public string JSONBLocator { get; }
    public IQueryableMember[] Ancestors { get; }
    public string LocatorForIncludedDocumentId { get; }
    public string NullTestLocator { get; }
    private static IsArchivedMember();
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual ISqlFragment CreateComparison(string op, ConstantExpression constant);
    public sealed virtual Type get_MemberType();
    public sealed virtual string get_JsonPathSegment();
    public sealed virtual string get_MemberName();
    public sealed virtual string get_TypedLocator();
    public sealed virtual string get_RawLocator();
    public sealed virtual string get_JSONBLocator();
    public sealed virtual IQueryableMember[] get_Ancestors();
    public sealed virtual string get_LocatorForIncludedDocumentId();
    public sealed virtual string get_NullTestLocator();
    public sealed virtual string BuildOrderingExpression(Ordering ordering, CasingRule casingRule);
    public sealed virtual Dictionary`2<string, object> FindOrPlaceChildDictionaryForContainment(Dictionary`2<string, object> dict);
    public sealed virtual void PlaceValueInDictionaryForContainment(Dictionary`2<string, object> dict, ConstantExpression constant);
    public sealed virtual string SelectorForDuplication(string pgType);
    public sealed virtual ISqlFragment BuildIsTrueFragment();
}
[ExtensionAttribute]
public static class Marten.Events.LinqExtensions : object {
    [ExtensionAttribute]
public static bool EventTypesAre(IEvent e, Type[] types);
}
public class Marten.Events.MetadataConfig : object {
    private EventMetadataCollection _parent;
    public bool CorrelationIdEnabled { get; public set; }
    public bool CausationIdEnabled { get; public set; }
    public bool HeadersEnabled { get; public set; }
    internal MetadataConfig(EventMetadataCollection parent);
    public sealed virtual bool get_CorrelationIdEnabled();
    public void set_CorrelationIdEnabled(bool value);
    public sealed virtual bool get_CausationIdEnabled();
    public void set_CausationIdEnabled(bool value);
    public sealed virtual bool get_HeadersEnabled();
    public void set_HeadersEnabled(bool value);
    public void EnableAll();
}
public class Marten.Events.NulloEventAppendStep : object {
    public sealed virtual ValueTask ApplyAsync(DocumentSessionBase session, EventGraph eventGraph, Queue`1<long> sequences, IEventStorage storage, CancellationToken cancellationToken);
}
public abstract class Marten.Events.Operations.AppendEventOperationBase : object {
    [CompilerGeneratedAttribute]
private StreamAction <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private IEvent <Event>k__BackingField;
    public StreamAction Stream { get; }
    public IEvent Event { get; }
    public Type DocumentType { get; }
    public AppendEventOperationBase(StreamAction stream, IEvent e);
    [CompilerGeneratedAttribute]
public StreamAction get_Stream();
    [CompilerGeneratedAttribute]
public IEvent get_Event();
    public abstract virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual Type get_DocumentType();
    public sealed virtual void Postprocess(DbDataReader reader, IList`1<Exception> exceptions);
    public sealed virtual Task PostprocessAsync(DbDataReader reader, IList`1<Exception> exceptions, CancellationToken token);
    public sealed virtual OperationRole Role();
    public virtual string ToString();
}
internal class Marten.Events.Operations.EstablishTombstoneStream : object {
    public static string StreamKey;
    public static Guid StreamId;
    private Action`1<NpgsqlParameter> _configureParameter;
    private string _sessionTenantId;
    private string _sql;
    public Type DocumentType { get; }
    public EstablishTombstoneStream(EventGraph events, string sessionTenantId);
    private static EstablishTombstoneStream();
    public sealed virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual Type get_DocumentType();
    public sealed virtual void Postprocess(DbDataReader reader, IList`1<Exception> exceptions);
    public sealed virtual Task PostprocessAsync(DbDataReader reader, IList`1<Exception> exceptions, CancellationToken token);
    public sealed virtual OperationRole Role();
}
internal class Marten.Events.Operations.IncrementStreamVersionById : object {
    private EventGraph _events;
    [CompilerGeneratedAttribute]
private StreamAction <Stream>k__BackingField;
    public StreamAction Stream { get; }
    public Type DocumentType { get; }
    public IncrementStreamVersionById(EventGraph events, StreamAction stream);
    [CompilerGeneratedAttribute]
public StreamAction get_Stream();
    public sealed virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual Type get_DocumentType();
    public sealed virtual void Postprocess(DbDataReader reader, IList`1<Exception> exceptions);
    public sealed virtual Task PostprocessAsync(DbDataReader reader, IList`1<Exception> exceptions, CancellationToken token);
    public sealed virtual OperationRole Role();
}
internal class Marten.Events.Operations.IncrementStreamVersionByKey : object {
    private EventGraph _events;
    [CompilerGeneratedAttribute]
private StreamAction <Stream>k__BackingField;
    public StreamAction Stream { get; }
    public Type DocumentType { get; }
    public IncrementStreamVersionByKey(EventGraph events, StreamAction stream);
    [CompilerGeneratedAttribute]
public StreamAction get_Stream();
    public sealed virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual Type get_DocumentType();
    public sealed virtual void Postprocess(DbDataReader reader, IList`1<Exception> exceptions);
    public sealed virtual Task PostprocessAsync(DbDataReader reader, IList`1<Exception> exceptions, CancellationToken token);
    public sealed virtual OperationRole Role();
}
public abstract class Marten.Events.Operations.InsertStreamBase : object {
    [CompilerGeneratedAttribute]
private StreamAction <Stream>k__BackingField;
    public StreamAction Stream { get; }
    public Type DocumentType { get; }
    public InsertStreamBase(StreamAction stream);
    [CompilerGeneratedAttribute]
public StreamAction get_Stream();
    public abstract virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual Type get_DocumentType();
    public sealed virtual void Postprocess(DbDataReader reader, IList`1<Exception> exceptions);
    public sealed virtual Task PostprocessAsync(DbDataReader reader, IList`1<Exception> exceptions, CancellationToken token);
    public sealed virtual OperationRole Role();
    public virtual string ToString();
    private static bool matches(Exception e);
    public sealed virtual bool TryTransform(Exception original, Exception& transformed);
}
public abstract class Marten.Events.Operations.QuickAppendEventsOperationBase : object {
    [CompilerGeneratedAttribute]
private StreamAction <Stream>k__BackingField;
    public StreamAction Stream { get; }
    public Type DocumentType { get; }
    public QuickAppendEventsOperationBase(StreamAction stream);
    [CompilerGeneratedAttribute]
public StreamAction get_Stream();
    public sealed virtual OperationRole Role();
    public sealed virtual Type get_DocumentType();
    public virtual string ToString();
    public abstract virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual void Postprocess(DbDataReader reader, IList`1<Exception> exceptions);
    protected void writeId(IGroupedParameterBuilder builder);
    protected void writeKey(IGroupedParameterBuilder builder);
    protected void writeBasicParameters(IGroupedParameterBuilder builder, IMartenSession session);
    protected void writeCausationIds(IGroupedParameterBuilder builder);
    protected void writeCorrelationIds(IGroupedParameterBuilder builder);
    protected void writeHeaders(IGroupedParameterBuilder builder, IMartenSession session);
    [AsyncStateMachineAttribute("Marten.Events.Operations.QuickAppendEventsOperationBase/<PostprocessAsync>d__16")]
public sealed virtual Task PostprocessAsync(DbDataReader reader, IList`1<Exception> exceptions, CancellationToken token);
}
[DocumentAliasAttribute("tombstone")]
internal class Marten.Events.Operations.Tombstone : object {
    public static string Name;
    private static Tombstone();
}
public abstract class Marten.Events.Operations.UpdateStreamVersion : object {
    [CompilerGeneratedAttribute]
private StreamAction <Stream>k__BackingField;
    public StreamAction Stream { get; }
    public Type DocumentType { get; }
    public UpdateStreamVersion(StreamAction stream);
    [CompilerGeneratedAttribute]
public StreamAction get_Stream();
    public abstract virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual Type get_DocumentType();
    public sealed virtual void Postprocess(DbDataReader reader, IList`1<Exception> exceptions);
    public sealed virtual Task PostprocessAsync(DbDataReader reader, IList`1<Exception> exceptions, CancellationToken token);
    public sealed virtual OperationRole Role();
}
public abstract class Marten.Events.Projections.AsyncEventProjection`1 : AsyncEventProjectionBase {
    [CompilerGeneratedAttribute]
private T <Projection>k__BackingField;
    public T Projection { get; }
    public AsyncEventProjection`1(T projection);
    [CompilerGeneratedAttribute]
public T get_Projection();
}
public abstract class Marten.Events.Projections.AsyncEventProjectionBase : AsyncProjectionBase {
    [AsyncStateMachineAttribute("Marten.Events.Projections.AsyncEventProjectionBase/<ApplyAsync>d__0")]
public virtual Task ApplyAsync(IDocumentOperations operations, IReadOnlyList`1<StreamAction> streams, CancellationToken cancellation);
    public abstract virtual Task ApplyEvent(IDocumentOperations operations, StreamAction streamAction, IEvent e, CancellationToken cancellationToken);
}
public abstract class Marten.Events.Projections.AsyncProjectionBase : object {
    public sealed virtual void Apply(IDocumentOperations operations, IReadOnlyList`1<StreamAction> streams);
    public abstract virtual Task ApplyAsync(IDocumentOperations operations, IReadOnlyList`1<StreamAction> streams, CancellationToken cancellation);
}
public class Marten.Events.Projections.DocumentAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <DocumentType>k__BackingField;
    public Type DocumentType { get; }
    public DocumentAttribute(Type documentType);
    [CompilerGeneratedAttribute]
public Type get_DocumentType();
}
public class Marten.Events.Projections.DuplicateSubscriptionNamesException : MartenException {
    public DuplicateSubscriptionNamesException(string message);
}
public class Marten.Events.Projections.ErrorHandlingOptions : object {
    [CompilerGeneratedAttribute]
private bool <SkipApplyErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipUnknownEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipSerializationErrors>k__BackingField;
    public bool SkipApplyErrors { get; public set; }
    public bool SkipUnknownEvents { get; public set; }
    public bool SkipSerializationErrors { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_SkipApplyErrors();
    [CompilerGeneratedAttribute]
public void set_SkipApplyErrors(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipUnknownEvents();
    [CompilerGeneratedAttribute]
public void set_SkipUnknownEvents(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipSerializationErrors();
    [CompilerGeneratedAttribute]
public void set_SkipSerializationErrors(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Marten.Events.Projections.EventFilterable : object {
    [CompilerGeneratedAttribute]
private List`1<Type> <IncludedEventTypes>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Type <StreamType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeArchivedEvents>k__BackingField;
    public List`1<Type> IncludedEventTypes { get; }
    [NullableAttribute("2")]
internal Type StreamType { get; internal set; }
    public bool IncludeArchivedEvents { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<Type> get_IncludedEventTypes();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal Type get_StreamType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_StreamType(Type value);
    [NullableContextAttribute("2")]
public sealed virtual void IncludeType();
    public sealed virtual void IncludeType(Type type);
    public sealed virtual void FilterIncomingEventsOnStreamType(Type streamType);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeArchivedEvents();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IncludeArchivedEvents(bool value);
}
public abstract class Marten.Events.Projections.EventProjection : GeneratedProjection {
    private CreateMethodCollection _createMethods;
    private Lazy`1<IProjection> _generatedProjection;
    private string _inlineTypeName;
    private ProjectMethodCollection _projectMethods;
    private Type _generatedType;
    private GeneratedType _inlineType;
    private bool _isAsync;
    [CompilerGeneratedAttribute]
private IList`1<ISchemaObject> <SchemaObjects>k__BackingField;
    public IList`1<ISchemaObject> SchemaObjects { get; }
    protected virtual void assembleTypes(GeneratedAssembly assembly, StoreOptions options);
    protected virtual bool tryAttachTypes(Assembly assembly, StoreOptions options);
    internal virtual void AssembleAndAssertValidity();
    protected virtual IProjection buildProjectionObject(DocumentStore store);
    [CompilerGeneratedAttribute]
public IList`1<ISchemaObject> get_SchemaObjects();
    private sealed virtual override IEnumerable`1<ISchemaObject> Marten.Events.Projections.IProjectionSchemaSource.CreateSchemaObjects(EventGraph events);
    protected virtual bool needsSettersGenerated();
    protected virtual ValueTask`1<EventRangeGroup> groupEvents(DocumentStore store, IMartenDatabase daemonDatabase, EventRange range, CancellationToken cancellationToken);
    [MartenIgnoreAttribute]
public void Project(Action`2<TEvent, IDocumentOperations> project);
    [MartenIgnoreAttribute]
public void ProjectAsync(Func`3<TEvent, IDocumentOperations, Task> project);
    [CompilerGeneratedAttribute]
private bool <tryAttachTypes>b__1_0(Type x);
    [CompilerGeneratedAttribute]
private IProjection <.ctor>b__15_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Events.Projections.EventSlice`2 : object {
    private List`1<IEvent> _events;
    private Nullable`1<StreamActionType> _actionType;
    [CompilerGeneratedAttribute]
private TId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Tenant <Tenant>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<IEvent> <RaisedEvents>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<object> <PublishedMessages>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TDoc <Aggregate>k__BackingField;
    public StreamActionType ActionType { get; public set; }
    public TId Id { get; }
    public Tenant Tenant { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<IEvent> RaisedEvents { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<object> PublishedMessages { get; private set; }
    [NullableAttribute("2")]
public TDoc Aggregate { get; public set; }
    private string Marten.Events.Projections.IEventSlice<TDoc>.TenantId { get; }
    public int Count { get; }
    public EventSlice`2(TId id, Tenant tenant, IEnumerable`1<IEvent> events);
    public EventSlice`2(TId id, IQuerySession querySession, IEnumerable`1<IEvent> events);
    public StreamActionType get_ActionType();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ActionType(StreamActionType value);
    [CompilerGeneratedAttribute]
public TId get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual Tenant get_Tenant();
    [CompilerGeneratedAttribute]
internal List`1<IEvent> get_RaisedEvents();
    [CompilerGeneratedAttribute]
private void set_RaisedEvents(List`1<IEvent> value);
    [CompilerGeneratedAttribute]
internal List`1<object> get_PublishedMessages();
    [CompilerGeneratedAttribute]
private void set_PublishedMessages(List`1<object> value);
    private sealed virtual override void Marten.Events.Projections.IEventSlice<TDoc>.AppendEvent(Guid streamId, TEvent event);
    private sealed virtual override void Marten.Events.Projections.IEventSlice<TDoc>.AppendEvent(string streamKey, TEvent event);
    private sealed virtual override void Marten.Events.Projections.IEventSlice<TDoc>.AppendEvent(TEvent event);
    private sealed virtual override void Marten.Events.Projections.IEventSlice<TDoc>.PublishMessage(object message);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual TDoc get_Aggregate();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Aggregate(TDoc value);
    private sealed virtual override string Marten.Events.Projections.IEventSlice<TDoc>.get_TenantId();
    [IteratorStateMachineAttribute("Marten.Events.Projections.EventSlice`2/<Marten-Events-Projections-IEventSlice<TDoc>-RaisedEvents>d__31")]
private sealed virtual override IEnumerable`1<IEvent> Marten.Events.Projections.IEventSlice<TDoc>.RaisedEvents();
    private sealed virtual override IEnumerable`1<object> Marten.Events.Projections.IEventSlice<TDoc>.PublishedMessages();
    public int get_Count();
    private sealed virtual override int System.Collections.Generic.IComparer<Marten.Events.IEvent>.Compare(IEvent x, IEvent y);
    public sealed virtual IReadOnlyList`1<IEvent> Events();
    public void AddEvent(IEvent e);
    public void AddEvents(IEnumerable`1<IEvent> events);
    [IteratorStateMachineAttribute("Marten.Events.Projections.EventSlice`2/<AllData>d__39")]
public IEnumerable`1<object> AllData();
    [NullableContextAttribute("2")]
internal void FanOut(Func`2<TSource, IEnumerable`1<TChild>> fanOutFunc);
    internal void ApplyFanOutRules(IEnumerable`1<IFanOutRule> rules);
    private void reorderEvents();
    [IteratorStateMachineAttribute("Marten.Events.Projections.EventSlice`2/<BuildOperations>d__43")]
public IEnumerable`1<IStorageOperation> BuildOperations(EventGraph eventGraph, DocumentSessionBase session, IEventStorage storage, bool isSingleStream);
}
public abstract class Marten.Events.Projections.ExperimentalMultiStreamProjection`2 : GeneratedAggregateProjectionBase`1<TDoc> {
    private TenancyStyle _tenancyStyle;
    public virtual bool IsSingleStream();
    public virtual ValueTask`1<IReadOnlyList`1<EventSlice`2<TDoc, TId>>> SliceInlineActions(IQuerySession querySession, IEnumerable`1<StreamAction> streams);
    public sealed virtual ValueTask`1<IReadOnlyList`1<TenantSliceGroup`2<TDoc, TId>>> SliceAsyncEvents(IQuerySession querySession, List`1<IEvent> events);
    [IteratorStateMachineAttribute("Marten.Events.Projections.ExperimentalMultiStreamProjection`2/<validateDocumentIdentity>d__5")]
protected virtual IEnumerable`1<string> validateDocumentIdentity(StoreOptions options, DocumentMapping mapping);
    [AsyncStateMachineAttribute("Marten.Events.Projections.ExperimentalMultiStreamProjection`2/<groupByConjoinedTenancy>d__6")]
private ValueTask`1<IReadOnlyList`1<TenantSliceGroup`2<TDoc, TId>>> groupByConjoinedTenancy(IQuerySession querySession, List`1<IEvent> events);
    [AsyncStateMachineAttribute("Marten.Events.Projections.ExperimentalMultiStreamProjection`2/<groupBySingleTenant>d__7")]
private ValueTask`1<IReadOnlyList`1<TenantSliceGroup`2<TDoc, TId>>> groupBySingleTenant(IQuerySession querySession, List`1<IEvent> events);
    protected abstract virtual ValueTask GroupEvents(IEventGrouping`1<TId> grouping, IQuerySession session, List`1<IEvent> events);
    protected virtual object buildEventSlicer(StoreOptions options);
    protected virtual Type baseTypeForAggregationRuntime();
}
public enum Marten.Events.Projections.FanoutMode : Enum {
    public int value__;
    public static FanoutMode BeforeGrouping;
    public static FanoutMode AfterGrouping;
}
internal class Marten.Events.Projections.Flattened.CallUpsertFunctionFrame : MethodCall {
    private List`1<IColumnMap> _columnMaps;
    private DbObjectName _functionIdentifier;
    private MemberInfo[] _members;
    [CompilerGeneratedAttribute]
private Type <EventType>k__BackingField;
    public Type EventType { get; }
    public CallUpsertFunctionFrame(Type eventType, DbObjectName functionIdentifier, List`1<IColumnMap> columnMaps, MemberInfo[] members);
    public sealed virtual void Configure(EventProcessingFrame parent);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_EventType();
}
internal enum Marten.Events.Projections.Flattened.ColumnMapType : Enum {
    public int value__;
    public static ColumnMapType Value;
    public static ColumnMapType Increment;
    public static ColumnMapType Decrement;
}
internal class Marten.Events.Projections.Flattened.DecrementMap : object {
    [NullableAttribute("2")]
private TableColumn _column;
    [CompilerGeneratedAttribute]
private bool <RequiresInput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ColumnName>k__BackingField;
    public bool RequiresInput { get; }
    public string ColumnName { get; }
    public DecrementMap(string columnName);
    public sealed virtual ColumnExpression ResolveColumn(Table table);
    public sealed virtual string UpdateFieldSql(Table table);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequiresInput();
    public sealed virtual string ToInsertExpression(Table table);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ColumnName();
    public sealed virtual string ToValueAccessorCode(Variable eventVariable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Events.Projections.Flattened.DeleteRowFrame : MethodCall {
    private MemberInfo[] _members;
    private Table _table;
    [NullableAttribute("2")]
private Variable _event;
    [CompilerGeneratedAttribute]
private Type <EventType>k__BackingField;
    public Type EventType { get; }
    public DeleteRowFrame(Table table, Type eventType, MemberInfo[] members);
    public sealed virtual void Configure(EventProcessingFrame parent);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_EventType();
}
internal class Marten.Events.Projections.Flattened.EventDeleter : object {
    private MemberInfo[] _members;
    [CompilerGeneratedAttribute]
private Type <EventType>k__BackingField;
    public Type EventType { get; }
    public EventDeleter(Type eventType, MemberInfo[] members);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_EventType();
    public sealed virtual IEventHandlingFrame BuildFrame(EventGraph events, Table table);
    public sealed virtual bool AssertValid(EventGraph events, String& message);
    [IteratorStateMachineAttribute("Marten.Events.Projections.Flattened.EventDeleter/<BuildObjects>d__7")]
public sealed virtual IEnumerable`1<ISchemaObject> BuildObjects(EventGraph events, Table table);
    [IteratorStateMachineAttribute("Marten.Events.Projections.Flattened.EventDeleter/<determinePkMembers>d__8")]
private IEnumerable`1<MemberInfo> determinePkMembers(EventGraph events);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Events.Projections.Flattened.FlatTableProjection : GeneratedProjection {
    [NullableAttribute("0")]
private Lazy`1<IProjection> _generatedProjection;
    [NullableAttribute("2")]
private Type _generatedType;
    [NullableAttribute("0")]
private GeneratedType _projectionType;
    private List`1<IEventHandler> _handlers;
    private string _inlineTypeName;
    [CompilerGeneratedAttribute]
private SchemaNameSource <SchemaNameSource>k__BackingField;
    [CompilerGeneratedAttribute]
private Table <Table>k__BackingField;
    [NullableAttribute("0")]
private static string SingleColumnPkRequired;
    [NullableAttribute("0")]
private static string EmptyProjection;
    public SchemaNameSource SchemaNameSource { get; }
    public Table Table { get; }
    public FlatTableProjection(string tableName, SchemaNameSource schemaNameSource);
    public FlatTableProjection(DbObjectName tableName);
    private FlatTableProjection(DbObjectName tableName, SchemaNameSource schemaNameSource);
    [NullableContextAttribute("0")]
protected virtual void assembleTypes(GeneratedAssembly assembly, StoreOptions options);
    [NullableContextAttribute("0")]
protected virtual bool tryAttachTypes(Assembly assembly, StoreOptions options);
    [NullableContextAttribute("0")]
protected virtual IProjection buildProjectionObject(DocumentStore store);
    protected virtual bool needsSettersGenerated();
    [CompilerGeneratedAttribute]
public SchemaNameSource get_SchemaNameSource();
    [CompilerGeneratedAttribute]
public Table get_Table();
    [IteratorStateMachineAttribute("Marten.Events.Projections.Flattened.FlatTableProjection/<Marten-Events-Projections-IProjectionSchemaSource-CreateSchemaObjects>d__18")]
private sealed virtual override IEnumerable`1<ISchemaObject> Marten.Events.Projections.IProjectionSchemaSource.CreateSchemaObjects(EventGraph events);
    public void Project(Action`1<StatementMap`1<T>> configure, Expression`1<Func`2<T, object>> tablePrimaryKeySource);
    [NullableContextAttribute("2")]
private static void assertReceivedEventType();
    [NullableContextAttribute("2")]
public void Delete(Expression`1<Func`2<T, object>> tablePrimaryKeySource);
    protected virtual ValueTask`1<EventRangeGroup> groupEvents(DocumentStore store, IMartenDatabase daemonDatabase, EventRange range, CancellationToken cancellationToken);
    private void readSchema(EventGraph events);
    [NullableContextAttribute("0")]
[IteratorStateMachineAttribute("Marten.Events.Projections.Flattened.FlatTableProjection/<ValidateConfiguration>d__26")]
internal virtual IEnumerable`1<string> ValidateConfiguration(StoreOptions options);
    [NullableContextAttribute("0")]
[IteratorStateMachineAttribute("Marten.Events.Projections.Flattened.FlatTableProjection/<quickValidations>d__27")]
private IEnumerable`1<string> quickValidations();
    internal virtual void AssembleAndAssertValidity();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <tryAttachTypes>b__4_0(Type x);
    [CompilerGeneratedAttribute]
private IProjection <.ctor>b__11_0();
}
internal class Marten.Events.Projections.Flattened.FlatTableUpsertFunction : Function {
    private List`1<IColumnMap> _columns;
    private DbObjectName _identifier;
    private Table _table;
    public FlatTableUpsertFunction(DbObjectName identifier, Table table, List`1<IColumnMap> columns);
    public virtual void WriteCreateStatement(Migrator migrator, TextWriter writer);
    [IteratorStateMachineAttribute("Marten.Events.Projections.Flattened.FlatTableUpsertFunction/<insertValues>d__5")]
private IEnumerable`1<string> insertValues(TableColumn[] pkColumns);
    [IteratorStateMachineAttribute("Marten.Events.Projections.Flattened.FlatTableUpsertFunction/<arguments>d__6")]
private IEnumerable`1<string> arguments(TableColumn[] pkColumns);
    [CompilerGeneratedAttribute]
private TableColumn <WriteCreateStatement>b__4_0(string x);
    [CompilerGeneratedAttribute]
private string <WriteCreateStatement>b__4_2(IColumnMap x);
}
internal interface Marten.Events.Projections.Flattened.IColumnMap {
    public string ColumnName { get; }
    public bool RequiresInput { get; }
    public abstract virtual string get_ColumnName();
    public abstract virtual bool get_RequiresInput();
    public abstract virtual ColumnExpression ResolveColumn(Table table);
    public abstract virtual string UpdateFieldSql(Table table);
    public abstract virtual string ToInsertExpression(Table table);
    public abstract virtual string ToValueAccessorCode(Variable eventVariable);
}
internal interface Marten.Events.Projections.Flattened.IEventHandler {
    public Type EventType { get; }
    public abstract virtual Type get_EventType();
    public abstract virtual IEventHandlingFrame BuildFrame(EventGraph events, Table table);
    public abstract virtual bool AssertValid(EventGraph events, String& message);
    public abstract virtual IEnumerable`1<ISchemaObject> BuildObjects(EventGraph events, Table table);
}
internal class Marten.Events.Projections.Flattened.IncrementMap : object {
    [NullableAttribute("2")]
private TableColumn _column;
    [CompilerGeneratedAttribute]
private string <ColumnName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresInput>k__BackingField;
    public string ColumnName { get; }
    public bool RequiresInput { get; }
    public IncrementMap(string columnName);
    public sealed virtual ColumnExpression ResolveColumn(Table table);
    public sealed virtual string UpdateFieldSql(Table table);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ColumnName();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequiresInput();
    public sealed virtual string ToInsertExpression(Table table);
    public sealed virtual string ToValueAccessorCode(Variable eventVariable);
}
[ExtensionAttribute]
internal static class Marten.Events.Projections.Flattened.KebabConverter : object {
    [ExtensionAttribute]
public static string ToKebabCase(string str);
}
internal class Marten.Events.Projections.Flattened.MemberMap`2 : object {
    private ColumnMapType _mapType;
    private MemberInfo[] _members;
    [NullableAttribute("2")]
private TableColumn _tableColumn;
    [CompilerGeneratedAttribute]
private string <ColumnName>k__BackingField;
    public string ColumnName { get; }
    public bool RequiresInput { get; }
    public MemberMap`2(Expression`1<Func`2<TEvent, TMember>> members, string tableColumn, ColumnMapType columnMapType);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ColumnName();
    public sealed virtual ColumnExpression ResolveColumn(Table table);
    public sealed virtual string UpdateFieldSql(Table table);
    public sealed virtual bool get_RequiresInput();
    public sealed virtual string ToInsertExpression(Table table);
    public sealed virtual string ToValueAccessorCode(Variable eventVariable);
}
public enum Marten.Events.Projections.Flattened.SchemaNameSource : Enum {
    public int value__;
    public static SchemaNameSource Explicit;
    public static SchemaNameSource DocumentSchema;
    public static SchemaNameSource EventSchema;
}
internal class Marten.Events.Projections.Flattened.SetIntValueMap : object {
    private int _value;
    [NullableAttribute("2")]
private TableColumn _column;
    [CompilerGeneratedAttribute]
private string <ColumnName>k__BackingField;
    public string ColumnName { get; }
    public bool RequiresInput { get; }
    public SetIntValueMap(string columnName, int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ColumnName();
    public sealed virtual ColumnExpression ResolveColumn(Table table);
    public sealed virtual string UpdateFieldSql(Table table);
    public sealed virtual bool get_RequiresInput();
    public sealed virtual string ToInsertExpression(Table table);
    public sealed virtual string ToValueAccessorCode(Variable eventVariable);
}
internal class Marten.Events.Projections.Flattened.SetStringValueMap : object {
    private string _value;
    [NullableAttribute("2")]
private TableColumn _column;
    [CompilerGeneratedAttribute]
private string <ColumnName>k__BackingField;
    public string ColumnName { get; }
    public bool RequiresInput { get; }
    public SetStringValueMap(string columnName, string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ColumnName();
    public sealed virtual ColumnExpression ResolveColumn(Table table);
    public sealed virtual string UpdateFieldSql(Table table);
    public sealed virtual bool get_RequiresInput();
    public sealed virtual string ToInsertExpression(Table table);
    public sealed virtual string ToValueAccessorCode(Variable eventVariable);
}
public class Marten.Events.Projections.Flattened.StatementMap`1 : object {
    private List`1<IColumnMap> _columnMaps;
    private FlatTableProjection _parent;
    private MemberInfo[] _pkMembers;
    private DbObjectName _functionIdentifier;
    private Type Marten.Events.Projections.Flattened.IEventHandler.EventType { get; }
    public StatementMap`1(FlatTableProjection parent, MemberInfo[] pkMembers);
    private sealed virtual override Type Marten.Events.Projections.Flattened.IEventHandler.get_EventType();
    private sealed virtual override IEventHandlingFrame Marten.Events.Projections.Flattened.IEventHandler.BuildFrame(EventGraph events, Table table);
    private sealed virtual override bool Marten.Events.Projections.Flattened.IEventHandler.AssertValid(EventGraph events, String& message);
    [IteratorStateMachineAttribute("Marten.Events.Projections.Flattened.StatementMap`1/<Marten-Events-Projections-Flattened-IEventHandler-BuildObjects>d__9")]
private sealed virtual override IEnumerable`1<ISchemaObject> Marten.Events.Projections.Flattened.IEventHandler.BuildObjects(EventGraph events, Table table);
    private void createFunctionName(Table table);
    [IteratorStateMachineAttribute("Marten.Events.Projections.Flattened.StatementMap`1/<determinePkMembers>d__11")]
private IEnumerable`1<MemberInfo> determinePkMembers(EventGraph events);
    public ColumnExpression Map(Expression`1<Func`2<T, TValue>> members, string columnName);
    public ColumnExpression Increment(Expression`1<Func`2<T, TValue>> members, string columnName);
    public ColumnExpression Increment(string columnName);
    public ColumnExpression Decrement(Expression`1<Func`2<T, TValue>> members, string columnName);
    public ColumnExpression Decrement(string columnName);
    public ColumnExpression SetValue(string columnName, string value);
    public ColumnExpression SetValue(string columnName, int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Marten.Events.Projections.GeneratedProjection : ProjectionBase {
    protected bool _hasGenerated;
    [CompilerGeneratedAttribute]
private StoreOptions <StoreOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncOptions <Options>k__BackingField;
    protected static object _assembleLocker;
    internal StoreOptions StoreOptions { get; internal set; }
    public string FileName { get; }
    public Type ProjectionType { get; }
    [ObsoleteAttribute("Use AsyncOptions.TeardownDataOnRebuild instead")]
public bool TeardownDataOnRebuild { get; public set; }
    public AsyncOptions Options { get; }
    protected GeneratedProjection(string projectionName);
    private static GeneratedProjection();
    [CompilerGeneratedAttribute]
internal StoreOptions get_StoreOptions();
    [CompilerGeneratedAttribute]
internal void set_StoreOptions(StoreOptions value);
    private sealed virtual override bool JasperFx.CodeGeneration.ICodeFile.AttachTypesSynchronously(GenerationRules rules, Assembly assembly, IServiceProvider services, string containingNamespace);
    public sealed virtual string get_FileName();
    private sealed virtual override void JasperFx.CodeGeneration.ICodeFile.AssembleTypes(GeneratedAssembly assembly);
    private sealed virtual override Task`1<bool> JasperFx.CodeGeneration.ICodeFile.AttachTypes(GenerationRules rules, Assembly assembly, IServiceProvider services, string containingNamespace);
    public sealed virtual Type get_ProjectionType();
    private sealed virtual override IProjection Marten.Events.Projections.IProjectionSource.Build(DocumentStore store);
    private sealed virtual override IReadOnlyList`1<AsyncProjectionShard> Marten.Events.Projections.IProjectionSource.AsyncProjectionShards(DocumentStore store);
    public virtual bool get_TeardownDataOnRebuild();
    public virtual void set_TeardownDataOnRebuild(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual AsyncOptions get_Options();
    private sealed virtual override ValueTask`1<EventRangeGroup> Marten.Events.Projections.IProjectionSource.GroupEvents(DocumentStore store, IMartenDatabase daemonDatabase, EventRange range, CancellationToken cancellationToken);
    protected abstract virtual void assembleTypes(GeneratedAssembly assembly, StoreOptions options);
    protected abstract virtual bool tryAttachTypes(Assembly assembly, StoreOptions options);
    private void generateIfNecessary(DocumentStore store);
    protected abstract virtual IProjection buildProjectionObject(DocumentStore store);
    protected abstract virtual bool needsSettersGenerated();
    [IteratorStateMachineAttribute("Marten.Events.Projections.GeneratedProjection/<ValidateConfiguration>d__28")]
internal virtual IEnumerable`1<string> ValidateConfiguration(StoreOptions options);
    protected abstract virtual ValueTask`1<EventRangeGroup> groupEvents(DocumentStore store, IMartenDatabase daemonDatabase, EventRange range, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <generateIfNecessary>g__generateIfNecessaryLocked|24_0(<>c__DisplayClass24_0& );
}
public interface Marten.Events.Projections.IAggregateGrouper`1 {
    public abstract virtual Task Group(IQuerySession session, IEnumerable`1<IEvent> events, ITenantSliceGroup`1<TId> grouping);
}
[NullableContextAttribute("1")]
public interface Marten.Events.Projections.IEventFilterable {
    public bool IncludeArchivedEvents { get; public set; }
    [NullableContextAttribute("2")]
public abstract virtual void IncludeType();
    public abstract virtual void IncludeType(Type type);
    public abstract virtual void FilterIncomingEventsOnStreamType(Type streamType);
    public abstract virtual bool get_IncludeArchivedEvents();
    public abstract virtual void set_IncludeArchivedEvents(bool value);
}
[NullableContextAttribute("1")]
public interface Marten.Events.Projections.IEventSlice {
    public Tenant Tenant { get; }
    public abstract virtual Tenant get_Tenant();
    public abstract virtual IReadOnlyList`1<IEvent> Events();
}
[NullableContextAttribute("1")]
public interface Marten.Events.Projections.IEventSlice`1 {
    [NullableAttribute("2")]
public T Aggregate { get; }
    public string TenantId { get; }
    public abstract virtual void AppendEvent(Guid streamId, TEvent event);
    public abstract virtual void AppendEvent(string streamKey, TEvent event);
    public abstract virtual void AppendEvent(TEvent event);
    public abstract virtual void PublishMessage(object message);
    [NullableContextAttribute("2")]
public abstract virtual T get_Aggregate();
    public abstract virtual string get_TenantId();
    public abstract virtual IEnumerable`1<IEvent> RaisedEvents();
    public abstract virtual IEnumerable`1<object> PublishedMessages();
}
public interface Marten.Events.Projections.IFanOutRule {
    public Type OriginatingType { get; }
    public FanoutMode Mode { get; }
    public abstract virtual Type get_OriginatingType();
    public abstract virtual FanoutMode get_Mode();
    public abstract virtual void Apply(List`1<IEvent> events);
}
internal interface Marten.Events.Projections.IGrouper`1 {
    public abstract virtual void Apply(IEnumerable`1<IEvent> events, ITenantSliceGroup`1<TId> grouping);
}
[NullableContextAttribute("1")]
public interface Marten.Events.Projections.ILiveAggregator`1 {
    public abstract virtual T Build(IReadOnlyList`1<IEvent> events, IQuerySession session, T snapshot);
    public abstract virtual ValueTask`1<T> BuildAsync(IReadOnlyList`1<IEvent> events, IQuerySession session, T snapshot, CancellationToken cancellation);
}
internal interface Marten.Events.Projections.ILiveAggregatorSource`1 {
    public abstract virtual ILiveAggregator`1<T> Build(StoreOptions options);
}
[NullableContextAttribute("1")]
public interface Marten.Events.Projections.IProjection {
    public abstract virtual void Apply(IDocumentOperations operations, IReadOnlyList`1<StreamAction> streams);
    public abstract virtual Task ApplyAsync(IDocumentOperations operations, IReadOnlyList`1<StreamAction> streams, CancellationToken cancellation);
}
public interface Marten.Events.Projections.IProjectionSchemaSource {
    public abstract virtual IEnumerable`1<ISchemaObject> CreateSchemaObjects(EventGraph events);
}
public interface Marten.Events.Projections.IProjectionSource {
    public AsyncOptions Options { get; }
    public UInt32 ProjectionVersion { get; public set; }
    public abstract virtual AsyncOptions get_Options();
    public abstract virtual IEnumerable`1<Type> PublishedTypes();
    public abstract virtual IReadOnlyList`1<AsyncProjectionShard> AsyncProjectionShards(DocumentStore store);
    public abstract virtual ValueTask`1<EventRangeGroup> GroupEvents(DocumentStore store, IMartenDatabase daemonDatabase, EventRange range, CancellationToken cancellationToken);
    public abstract virtual IProjection Build(DocumentStore store);
    public abstract virtual UInt32 get_ProjectionVersion();
    public abstract virtual void set_ProjectionVersion(UInt32 value);
}
public interface Marten.Events.Projections.IReadOnlyProjectionData {
    public string ProjectionName { get; }
    public ProjectionLifecycle Lifecycle { get; }
    public Type ProjectionType { get; }
    public abstract virtual string get_ProjectionName();
    public abstract virtual ProjectionLifecycle get_Lifecycle();
    public abstract virtual Type get_ProjectionType();
}
internal class Marten.Events.Projections.MultiStreamGrouper`2 : object {
    private Func`2<TEvent, IReadOnlyList`1<TId>> _func;
    public MultiStreamGrouper`2(Func`2<TEvent, IReadOnlyList`1<TId>> expression);
    public sealed virtual void Apply(IEnumerable`1<IEvent> events, ITenantSliceGroup`1<TId> grouping);
}
internal class Marten.Events.Projections.MultiStreamGrouperWithMetadata`2 : object {
    private Func`2<IEvent`1<TEvent>, IReadOnlyList`1<TId>> _func;
    public MultiStreamGrouperWithMetadata`2(Func`2<IEvent`1<TEvent>, IReadOnlyList`1<TId>> expression);
    public sealed virtual void Apply(IEnumerable`1<IEvent> events, ITenantSliceGroup`1<TId> grouping);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Marten.Events.Projections.MultiStreamProjection`2 : GeneratedAggregateProjectionBase`1<TDoc> {
    private EventSlicer`2<TDoc, TId> _defaultSlicer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEventSlicer`2<TDoc, TId> _customSlicer;
    internal IEventSlicer`2<TDoc, TId> Slicer { get; }
    public virtual bool IsSingleStream();
    public void RollUpByTenant();
    internal IEventSlicer`2<TDoc, TId> get_Slicer();
    protected virtual Type[] determineEventTypes();
    public void Identity(Func`2<TEvent, TId> identityFunc);
    public void Identities(Func`2<TEvent, IReadOnlyList`1<TId>> identitiesFunc);
    public void CustomGrouping(IAggregateGrouper`1<TId> grouper);
    public void CustomGrouping(IEventSlicer`2<TDoc, TId> slicer);
    protected virtual void specialAssertValid();
    [NullableContextAttribute("2")]
public void FanOut(Func`2<TEvent, IEnumerable`1<TChild>> fanOutFunc, FanoutMode mode);
    public void FanOut(Func`2<IEvent`1<TEvent>, IEnumerable`1<TChild>> fanOutFunc, FanoutMode mode);
    protected virtual object buildEventSlicer(StoreOptions options);
    [IteratorStateMachineAttribute("Marten.Events.Projections.MultiStreamProjection`2/<validateDocumentIdentity>d__16")]
protected virtual IEnumerable`1<string> validateDocumentIdentity(StoreOptions options, DocumentMapping mapping);
    protected virtual Type baseTypeForAggregationRuntime();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class Marten.Events.Projections.ProjectionBase : EventFilterable {
    [NullableAttribute("1")]
private List`1<Type> _publishedTypes;
    [CompilerGeneratedAttribute]
private string <ProjectionName>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ProjectionVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectionLifecycle <Lifecycle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TeardownDataOnRebuild>k__BackingField;
    public string ProjectionName { get; public set; }
    public UInt32 ProjectionVersion { get; public set; }
    public ProjectionLifecycle Lifecycle { get; public set; }
    [ObsoleteAttribute("Use AsyncOptions.TeardownDataOnRebuild instead")]
public bool TeardownDataOnRebuild { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProjectionName();
    [CompilerGeneratedAttribute]
public void set_ProjectionName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_ProjectionVersion();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProjectionVersion(UInt32 value);
    [CompilerGeneratedAttribute]
public sealed virtual ProjectionLifecycle get_Lifecycle();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Lifecycle(ProjectionLifecycle value);
    [CompilerGeneratedAttribute]
public virtual bool get_TeardownDataOnRebuild();
    [CompilerGeneratedAttribute]
public virtual void set_TeardownDataOnRebuild(bool value);
    internal virtual void AssembleAndAssertValidity();
    [NullableContextAttribute("1")]
protected void RegisterPublishedType(Type publishedType);
    [NullableContextAttribute("1")]
public sealed virtual IEnumerable`1<Type> PublishedTypes();
}
internal class Marten.Events.Projections.ProjectionDocumentPolicy : object {
    public sealed virtual void Apply(DocumentMapping mapping);
}
public enum Marten.Events.Projections.ProjectionLifecycle : Enum {
    public int value__;
    public static ProjectionLifecycle Inline;
    public static ProjectionLifecycle Async;
    public static ProjectionLifecycle Live;
}
public class Marten.Events.Projections.ProjectionOptions : DaemonSettings {
    private Dictionary`2<Type, object> _liveAggregateSources;
    private StoreOptions _options;
    private Lazy`1<Dictionary`2<string, AsyncProjectionShard>> _asyncShards;
    private ImHashMap`2<Type, object> _liveAggregators;
    internal IFetchPlanner[] _builtInPlanners;
    private List`1<ISubscriptionSource> _subscriptions;
    [CompilerGeneratedAttribute]
private ErrorHandlingOptions <RebuildErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorHandlingOptions <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IFetchPlanner> <FetchPlanners>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IProjectionSource> <All>k__BackingField;
    public ErrorHandlingOptions RebuildErrors { get; }
    public ErrorHandlingOptions Errors { get; }
    public List`1<IFetchPlanner> FetchPlanners { get; }
    internal IList`1<IProjectionSource> All { get; }
    public bool UseIdentityMapForInlineAggregates { get; public set; }
    internal ProjectionOptions(StoreOptions options);
    [CompilerGeneratedAttribute]
public ErrorHandlingOptions get_RebuildErrors();
    [CompilerGeneratedAttribute]
public ErrorHandlingOptions get_Errors();
    [IteratorStateMachineAttribute("Marten.Events.Projections.ProjectionOptions/<allPlanners>d__13")]
internal IEnumerable`1<IFetchPlanner> allPlanners();
    [CompilerGeneratedAttribute]
public List`1<IFetchPlanner> get_FetchPlanners();
    [CompilerGeneratedAttribute]
internal IList`1<IProjectionSource> get_All();
    public bool get_UseIdentityMapForInlineAggregates();
    public void set_UseIdentityMapForInlineAggregates(bool value);
    internal bool HasAnyAsyncProjections();
    [IteratorStateMachineAttribute("Marten.Events.Projections.ProjectionOptions/<AllAggregateTypes>d__24")]
internal IEnumerable`1<Type> AllAggregateTypes();
    public bool TryFindAggregate(Type documentType, IAggregateProjection& projection);
    internal IProjection[] BuildInlineProjections(DocumentStore store);
    public void Add(IProjection projection, ProjectionLifecycle lifecycle, string projectionName, Action`1<AsyncOptions> asyncConfiguration);
    public void Register(IProjectionSource source, ProjectionLifecycle lifecycle, Action`1<AsyncOptions> asyncConfiguration);
    public void Add(EventProjection projection, ProjectionLifecycle lifecycle, Action`1<AsyncOptions> asyncConfiguration);
    public DocumentMappingExpression`1<T> LiveStreamAggregation(Action`1<AsyncOptions> asyncConfiguration);
    public DocumentMappingExpression`1<T> Snapshot(SnapshotLifecycle lifecycle, Action`1<AsyncOptions> asyncConfiguration);
    public DocumentMappingExpression`1<T> Snapshot(SnapshotLifecycle lifecycle, Action`1<SingleStreamProjection`1<T>> configureProjection, Action`1<AsyncOptions> asyncConfiguration);
    private DocumentMappingExpression`1<T> singleStreamProjection(ProjectionLifecycle lifecycle, Action`1<SingleStreamProjection`1<T>> configureProjection, Action`1<AsyncOptions> asyncConfiguration);
    public void Add(ProjectionLifecycle lifecycle, Action`1<AsyncOptions> asyncConfiguration);
    public void Add(GeneratedAggregateProjectionBase`1<T> projection, ProjectionLifecycle lifecycle, Action`1<AsyncOptions> asyncConfiguration);
    public void Subscribe(ISubscriptionSource subscription);
    public void Subscribe(ISubscription subscription, Action`1<ISubscriptionOptions> configure);
    internal bool Any();
    internal ILiveAggregator`1<T> AggregatorFor();
    private SingleStreamProjection`1<T> tryFindProjectionSourceForAggregateType();
    internal void AssertValidity(DocumentStore store);
    public IReadOnlyList`1<AsyncProjectionShard> AllShards();
    internal bool TryFindAsyncShard(string projectionOrShardName, AsyncProjectionShard& shard);
    internal bool TryFindProjection(string projectionName, IProjectionSource& source);
    internal bool TryFindSubscription(string projectionName, ISubscriptionSource& source);
    internal String[] AllProjectionNames();
    internal IEnumerable`1<Type> AllPublishedTypes();
}
internal class Marten.Events.Projections.ProjectionWrapper : object {
    private IProjection _projection;
    [CompilerGeneratedAttribute]
private string <ProjectionName>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectionLifecycle <Lifecycle>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ProjectionVersion>k__BackingField;
    public string ProjectionName { get; public set; }
    public AsyncOptions Options { get; }
    public ProjectionLifecycle Lifecycle { get; public set; }
    public Type ProjectionType { get; }
    public UInt32 ProjectionVersion { get; public set; }
    public ProjectionWrapper(IProjection projection, ProjectionLifecycle lifecycle);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProjectionName();
    [CompilerGeneratedAttribute]
public void set_ProjectionName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual AsyncOptions get_Options();
    [IteratorStateMachineAttribute("Marten.Events.Projections.ProjectionWrapper/<PublishedTypes>d__9")]
public sealed virtual IEnumerable`1<Type> PublishedTypes();
    [CompilerGeneratedAttribute]
public sealed virtual ProjectionLifecycle get_Lifecycle();
    [CompilerGeneratedAttribute]
public void set_Lifecycle(ProjectionLifecycle value);
    public sealed virtual Type get_ProjectionType();
    private sealed virtual override IProjection Marten.Events.Projections.IProjectionSource.Build(DocumentStore store);
    private sealed virtual override IReadOnlyList`1<AsyncProjectionShard> Marten.Events.Projections.IProjectionSource.AsyncProjectionShards(DocumentStore store);
    public sealed virtual ValueTask`1<EventRangeGroup> GroupEvents(DocumentStore store, IMartenDatabase daemonDatabase, EventRange range, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_ProjectionVersion();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProjectionVersion(UInt32 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Events.Projections.ScopedProjectionWrapper`1 : object {
    private IServiceProvider _serviceProvider;
    private string _projectionName;
    [CompilerGeneratedAttribute]
private ProjectionLifecycle <Lifecycle>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ProjectionType>k__BackingField;
    private AsyncOptions _asyncOptions;
    [CompilerGeneratedAttribute]
private UInt32 <ProjectionVersion>k__BackingField;
    public string ProjectionName { get; public set; }
    public ProjectionLifecycle Lifecycle { get; public set; }
    public Type ProjectionType { get; public set; }
    public AsyncOptions Options { get; }
    public UInt32 ProjectionVersion { get; public set; }
    public ScopedProjectionWrapper`1(IServiceProvider serviceProvider);
    public sealed virtual void Apply(IDocumentOperations operations, IReadOnlyList`1<StreamAction> streams);
    [AsyncStateMachineAttribute("Marten.Events.Projections.ScopedProjectionWrapper`1/<ApplyAsync>d__3")]
public sealed virtual Task ApplyAsync(IDocumentOperations operations, IReadOnlyList`1<StreamAction> streams, CancellationToken cancellation);
    public sealed virtual string get_ProjectionName();
    public void set_ProjectionName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ProjectionLifecycle get_Lifecycle();
    [CompilerGeneratedAttribute]
public void set_Lifecycle(ProjectionLifecycle value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ProjectionType();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ProjectionType(Type value);
    public sealed virtual AsyncOptions get_Options();
    public sealed virtual IEnumerable`1<Type> PublishedTypes();
    public sealed virtual IReadOnlyList`1<AsyncProjectionShard> AsyncProjectionShards(DocumentStore store);
    public sealed virtual ValueTask`1<EventRangeGroup> GroupEvents(DocumentStore store, IMartenDatabase daemonDatabase, EventRange range, CancellationToken cancellationToken);
    public sealed virtual IProjection Build(DocumentStore store);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_ProjectionVersion();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProjectionVersion(UInt32 value);
}
internal class Marten.Events.Projections.SingleStreamEventGrouper`2 : object {
    private Func`2<IEvent`1<TEvent>, TId> _func;
    public SingleStreamEventGrouper`2(Func`2<IEvent`1<TEvent>, TId> expression);
    public sealed virtual void Apply(IEnumerable`1<IEvent> events, ITenantSliceGroup`1<TId> grouping);
}
internal class Marten.Events.Projections.SingleStreamGrouper`2 : object {
    private Func`2<TEvent, TId> _func;
    public SingleStreamGrouper`2(Func`2<TEvent, TId> expression);
    public sealed virtual void Apply(IEnumerable`1<IEvent> events, ITenantSliceGroup`1<TId> grouping);
}
public enum Marten.Events.Projections.SnapshotLifecycle : Enum {
    public int value__;
    public static SnapshotLifecycle Inline;
    public static SnapshotLifecycle Async;
}
[ExtensionAttribute]
public static class Marten.Events.Projections.SnapshotLifecycleExtensions : object {
    [ExtensionAttribute]
public static SnapshotLifecycle Map(ProjectionLifecycle projectionLifecycle);
    [ExtensionAttribute]
public static ProjectionLifecycle Map(SnapshotLifecycle projectionLifecycle);
}
public class Marten.Events.Projections.SomeAggregate : object {
}
public class Marten.Events.Projections.SomeDocument1 : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    public Guid Id { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Guid value);
}
public class Marten.Events.Projections.SomeDocument1Projector : object {
    public SomeDocument1 Create(SomeEvent1 event1);
    public SomeDocument2 Create(IEvent`1<SomeEvent2> event);
    [DocumentAttribute("Marten.Events.Projections.SomeDocument2")]
public Guid DeleteOn(SomeEvent3 event);
    [DocumentAttribute("Marten.Events.Projections.SomeDocument3")]
public bool MaybeDelete(SomeEvent4 event, Guid& id);
    public SomeDocument3[] CreateMany(SomeEvent4 event);
    [DocumentAttribute("Marten.Events.Projections.SomeDocument3")]
public IEnumerable`1<Guid> DeleteMany(SomeEvent5 event);
}
public class Marten.Events.Projections.SomeDocument2 : object {
}
public class Marten.Events.Projections.SomeDocument3 : object {
}
public class Marten.Events.Projections.SomeEvent1 : object {
}
public class Marten.Events.Projections.SomeEvent2 : object {
}
public class Marten.Events.Projections.SomeEvent3 : object {
    [CompilerGeneratedAttribute]
private Guid <IdToDelete>k__BackingField;
    public Guid IdToDelete { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_IdToDelete();
    [CompilerGeneratedAttribute]
public void set_IdToDelete(Guid value);
}
public class Marten.Events.Projections.SomeEvent4 : object {
}
public class Marten.Events.Projections.SomeEvent5 : object {
}
public abstract class Marten.Events.Projections.SyncEventProjection`1 : SyncEventProjectionBase {
    [CompilerGeneratedAttribute]
private T <Projection>k__BackingField;
    public T Projection { get; }
    public SyncEventProjection`1(T projection);
    [CompilerGeneratedAttribute]
public T get_Projection();
}
public abstract class Marten.Events.Projections.SyncEventProjectionBase : SyncProjectionBase {
    public virtual void Apply(IDocumentOperations operations, IReadOnlyList`1<StreamAction> streams);
    public abstract virtual void ApplyEvent(IDocumentOperations operations, StreamAction streamAction, IEvent e);
}
public abstract class Marten.Events.Projections.SyncProjectionBase : object {
    public abstract virtual void Apply(IDocumentOperations operations, IReadOnlyList`1<StreamAction> streams);
    public sealed virtual Task ApplyAsync(IDocumentOperations operations, IReadOnlyList`1<StreamAction> streams, CancellationToken cancellation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Events.Projections.TenantRollupSlicer`1 : object {
    public sealed virtual ValueTask`1<IReadOnlyList`1<EventSlice`2<TDoc, string>>> SliceInlineActions(IQuerySession querySession, IEnumerable`1<StreamAction> streams);
    public sealed virtual ValueTask`1<IReadOnlyList`1<TenantSliceGroup`2<TDoc, string>>> SliceAsyncEvents(IQuerySession querySession, List`1<IEvent> events);
}
[AttributeUsageAttribute("4")]
public class Marten.Events.ProjectionVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private UInt32 <Version>k__BackingField;
    public UInt32 Version { get; }
    public ProjectionVersionAttribute(UInt32 version);
    [CompilerGeneratedAttribute]
public UInt32 get_Version();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Events.QueryEventStore : object {
    private QuerySession _session;
    private DocumentStore _store;
    protected Tenant _tenant;
    public QueryEventStore(QuerySession session, DocumentStore store, Tenant tenant);
    public sealed virtual IReadOnlyList`1<IEvent> FetchStream(Guid streamId, long version, Nullable`1<DateTimeOffset> timestamp, long fromVersion);
    [AsyncStateMachineAttribute("Marten.Events.QueryEventStore/<FetchStreamAsync>d__5")]
public sealed virtual Task`1<IReadOnlyList`1<IEvent>> FetchStreamAsync(Guid streamId, long version, Nullable`1<DateTimeOffset> timestamp, long fromVersion, CancellationToken token);
    public sealed virtual IReadOnlyList`1<IEvent> FetchStream(string streamKey, long version, Nullable`1<DateTimeOffset> timestamp, long fromVersion);
    [AsyncStateMachineAttribute("Marten.Events.QueryEventStore/<FetchStreamAsync>d__7")]
public sealed virtual Task`1<IReadOnlyList`1<IEvent>> FetchStreamAsync(string streamKey, long version, Nullable`1<DateTimeOffset> timestamp, long fromVersion, CancellationToken token);
    [NullableContextAttribute("2")]
public sealed virtual T AggregateStream(Guid streamId, long version, Nullable`1<DateTimeOffset> timestamp, T state, long fromVersion);
    [AsyncStateMachineAttribute("Marten.Events.QueryEventStore/<AggregateStreamAsync>d__9`1")]
public sealed virtual Task`1<T> AggregateStreamAsync(Guid streamId, long version, Nullable`1<DateTimeOffset> timestamp, T state, long fromVersion, CancellationToken token);
    public sealed virtual T AggregateStream(string streamKey, long version, Nullable`1<DateTimeOffset> timestamp, T state, long fromVersion);
    [AsyncStateMachineAttribute("Marten.Events.QueryEventStore/<AggregateStreamAsync>d__11`1")]
public sealed virtual Task`1<T> AggregateStreamAsync(string streamKey, long version, Nullable`1<DateTimeOffset> timestamp, T state, long fromVersion, CancellationToken token);
    public sealed virtual IMartenQueryable`1<T> QueryRawEventDataOnly();
    public sealed virtual IMartenQueryable`1<IEvent> QueryAllRawEvents();
    public sealed virtual IEvent`1<T> Load(Guid id);
    [AsyncStateMachineAttribute("Marten.Events.QueryEventStore/<LoadAsync>d__15`1")]
public sealed virtual Task`1<IEvent`1<T>> LoadAsync(Guid id, CancellationToken token);
    [NullableContextAttribute("2")]
public sealed virtual IEvent Load(Guid id);
    [AsyncStateMachineAttribute("Marten.Events.QueryEventStore/<LoadAsync>d__17")]
public sealed virtual Task`1<IEvent> LoadAsync(Guid id, CancellationToken token);
    [NullableContextAttribute("2")]
public sealed virtual StreamState FetchStreamState(Guid streamId);
    [AsyncStateMachineAttribute("Marten.Events.QueryEventStore/<FetchStreamStateAsync>d__19")]
public sealed virtual Task`1<StreamState> FetchStreamStateAsync(Guid streamId, CancellationToken token);
    public sealed virtual StreamState FetchStreamState(string streamKey);
    [AsyncStateMachineAttribute("Marten.Events.QueryEventStore/<FetchStreamStateAsync>d__21")]
public sealed virtual Task`1<StreamState> FetchStreamStateAsync(string streamKey, CancellationToken token);
    private IEventStorage eventStorage();
}
internal class Marten.Events.Querying.SingleEventQueryHandler : object {
    private Guid _id;
    private IEventStorage _selector;
    public SingleEventQueryHandler(Guid id, IEventStorage selector);
    public sealed virtual void ConfigureCommand(ICommandBuilder sql, IMartenSession session);
    public sealed virtual IEvent Handle(DbDataReader reader, IMartenSession session);
    [AsyncStateMachineAttribute("Marten.Events.Querying.SingleEventQueryHandler/<HandleAsync>d__5")]
public sealed virtual Task`1<IEvent> HandleAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
    public sealed virtual Task`1<int> StreamJson(Stream stream, DbDataReader reader, CancellationToken token);
}
public abstract class Marten.Events.Querying.StreamStateQueryHandler : object {
    public abstract virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual StreamState Handle(DbDataReader reader, IMartenSession session);
    [AsyncStateMachineAttribute("Marten.Events.Querying.StreamStateQueryHandler/<HandleAsync>d__2")]
public sealed virtual Task`1<StreamState> HandleAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
    public sealed virtual Task`1<int> StreamJson(Stream stream, DbDataReader reader, CancellationToken token);
    public abstract virtual StreamState Resolve(IMartenSession session, DbDataReader reader);
    public abstract virtual Task`1<StreamState> ResolveAsync(IMartenSession session, DbDataReader reader, CancellationToken token);
    public void SetAggregateType(StreamState state, DbDataReader reader, IMartenSession session);
    [AsyncStateMachineAttribute("Marten.Events.Querying.StreamStateQueryHandler/<SetAggregateTypeAsync>d__7")]
public Task SetAggregateTypeAsync(StreamState state, DbDataReader reader, IMartenSession session, CancellationToken token);
}
internal class Marten.Events.QuickEventAppender : object {
    public sealed virtual void ProcessEvents(EventGraph eventGraph, DocumentSessionBase session, IProjection[] inlineProjections);
    private static void registerOperationsForStreams(EventGraph eventGraph, DocumentSessionBase session);
    [AsyncStateMachineAttribute("Marten.Events.QuickEventAppender/<ProcessEventsAsync>d__2")]
public sealed virtual Task ProcessEventsAsync(EventGraph eventGraph, DocumentSessionBase session, IProjection[] inlineProjections, CancellationToken token);
}
internal class Marten.Events.RichEventAppender : object {
    public sealed virtual void ProcessEvents(EventGraph eventGraph, DocumentSessionBase session, IProjection[] inlineProjections);
    [AsyncStateMachineAttribute("Marten.Events.RichEventAppender/<ProcessEventsAsync>d__1")]
public sealed virtual Task ProcessEventsAsync(EventGraph eventGraph, DocumentSessionBase session, IProjection[] inlineProjections, CancellationToken token);
}
internal class Marten.Events.RichStreamAppendingStep : object {
    private StreamAction _stream;
    private Task`1<StreamState> _fetcher;
    public RichStreamAppendingStep(StreamAction stream, IBatchedQuery query, IEventStorage storage);
    [AsyncStateMachineAttribute("Marten.Events.RichStreamAppendingStep/<ApplyAsync>d__3")]
public sealed virtual ValueTask ApplyAsync(DocumentSessionBase session, EventGraph eventGraph, Queue`1<long> sequences, IEventStorage storage, CancellationToken cancellationToken);
}
public enum Marten.Events.Schema.AppendMode : Enum {
    public int value__;
    public static AppendMode Full;
    public static AppendMode QuickWithVersion;
}
internal class Marten.Events.Schema.EventJsonDataColumn : TableColumn {
    public sealed virtual void GenerateSelectorCodeSync(GeneratedMethod method, EventGraph graph, int index);
    public sealed virtual void GenerateSelectorCodeAsync(GeneratedMethod method, EventGraph graph, int index);
    public sealed virtual void GenerateAppendCode(GeneratedMethod method, EventGraph graph, int index, AppendMode full);
    public sealed virtual string ValueSql(EventGraph graph, AppendMode mode);
}
public class Marten.Events.Schema.EventMetadataCollection : object {
    [CompilerGeneratedAttribute]
private MetadataColumn <CausationId>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataColumn <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataColumn <Headers>k__BackingField;
    public MetadataColumn CausationId { get; }
    public MetadataColumn CorrelationId { get; }
    public MetadataColumn Headers { get; }
    [CompilerGeneratedAttribute]
public MetadataColumn get_CausationId();
    [CompilerGeneratedAttribute]
public MetadataColumn get_CorrelationId();
    [CompilerGeneratedAttribute]
public MetadataColumn get_Headers();
}
internal class Marten.Events.Schema.EventProgressionTable : Table {
    public EventProgressionTable(string schemaName);
}
internal class Marten.Events.Schema.EventsTable : Table {
    public EventsTable(EventGraph events);
    internal IList`1<IEventTableColumn> SelectColumns();
    private void AddIfActive(MetadataColumn column);
}
internal class Marten.Events.Schema.EventTableColumn : TableColumn {
    private Expression`1<Func`2<IEvent, object>> _eventMemberExpression;
    [CompilerGeneratedAttribute]
private MemberInfo <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private NpgsqlDbType <NpgsqlDbType>k__BackingField;
    public MemberInfo Member { get; }
    public NpgsqlDbType NpgsqlDbType { get; public set; }
    public EventTableColumn(string name, Expression`1<Func`2<IEvent, object>> eventMemberExpression);
    [CompilerGeneratedAttribute]
public MemberInfo get_Member();
    [CompilerGeneratedAttribute]
public NpgsqlDbType get_NpgsqlDbType();
    [CompilerGeneratedAttribute]
public void set_NpgsqlDbType(NpgsqlDbType value);
    public sealed virtual void GenerateSelectorCodeSync(GeneratedMethod method, EventGraph graph, int index);
    public sealed virtual void GenerateSelectorCodeAsync(GeneratedMethod method, EventGraph graph, int index);
    public virtual void GenerateAppendCode(GeneratedMethod method, EventGraph graph, int index, AppendMode full);
    public virtual string ValueSql(EventGraph graph, AppendMode mode);
}
internal class Marten.Events.Schema.EventTypeColumn : TableColumn {
    public sealed virtual void GenerateSelectorCodeSync(GeneratedMethod method, EventGraph graph, int index);
    public sealed virtual void GenerateSelectorCodeAsync(GeneratedMethod method, EventGraph graph, int index);
    public sealed virtual void GenerateAppendCode(GeneratedMethod method, EventGraph graph, int index, AppendMode full);
    public sealed virtual string ValueSql(EventGraph graph, AppendMode mode);
}
internal interface Marten.Events.Schema.IEventTableColumn {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual void GenerateSelectorCodeSync(GeneratedMethod method, EventGraph graph, int index);
    public abstract virtual void GenerateSelectorCodeAsync(GeneratedMethod method, EventGraph graph, int index);
    public abstract virtual void GenerateAppendCode(GeneratedMethod method, EventGraph graph, int index, AppendMode full);
    public abstract virtual string ValueSql(EventGraph graph, AppendMode mode);
}
internal interface Marten.Events.Schema.IStreamTableColumn {
    public bool Reads { get; }
    public bool Writes { get; }
    public string Name { get; }
    public abstract virtual bool get_Reads();
    public abstract virtual bool get_Writes();
    public abstract virtual string get_Name();
    public abstract virtual void GenerateAppendCode(GeneratedMethod method, int index);
    public abstract virtual void GenerateSelectorCodeAsync(GeneratedMethod method, int index);
    public abstract virtual void GenerateSelectorCodeSync(GeneratedMethod method, int index);
}
public class Marten.Events.Schema.QuickAppendEventFunction : Function {
    private EventGraph _events;
    public QuickAppendEventFunction(EventGraph events);
    public virtual void WriteCreateStatement(Migrator migrator, TextWriter writer);
}
internal class Marten.Events.Schema.SequenceColumn : EventTableColumn {
    public virtual string ValueSql(EventGraph graph, AppendMode mode);
    public virtual void GenerateAppendCode(GeneratedMethod method, EventGraph graph, int index, AppendMode mode);
}
internal class Marten.Events.Schema.StreamIdColumn : TableColumn {
    public StreamIdColumn(EventGraph graph);
    public sealed virtual void GenerateSelectorCodeSync(GeneratedMethod method, EventGraph graph, int index);
    public sealed virtual void GenerateSelectorCodeAsync(GeneratedMethod method, EventGraph graph, int index);
    public sealed virtual void GenerateAppendCode(GeneratedMethod method, EventGraph graph, int index, AppendMode full);
    public sealed virtual string ValueSql(EventGraph graph, AppendMode mode);
}
internal class Marten.Events.Schema.StreamsTable : Table {
    public static string TableName;
    public StreamsTable(EventGraph events);
}
internal class Marten.Events.Schema.StreamTableColumn : TableColumn {
    private MemberInfo _member;
    private Expression`1<Func`2<StreamAction, object>> _memberExpression;
    [CompilerGeneratedAttribute]
private NpgsqlDbType <NpgsqlDbType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Reads>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Writes>k__BackingField;
    public NpgsqlDbType NpgsqlDbType { get; public set; }
    public bool Reads { get; public set; }
    public bool Writes { get; public set; }
    public StreamTableColumn(string name, Expression`1<Func`2<StreamAction, object>> memberExpression);
    [CompilerGeneratedAttribute]
public NpgsqlDbType get_NpgsqlDbType();
    [CompilerGeneratedAttribute]
public void set_NpgsqlDbType(NpgsqlDbType value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Reads();
    [CompilerGeneratedAttribute]
public void set_Reads(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Writes();
    [CompilerGeneratedAttribute]
public void set_Writes(bool value);
    public sealed virtual void GenerateAppendCode(GeneratedMethod method, int index);
    public sealed virtual void GenerateSelectorCodeAsync(GeneratedMethod method, int index);
    public sealed virtual void GenerateSelectorCodeSync(GeneratedMethod method, int index);
}
internal class Marten.Events.Schema.VersionColumn : EventTableColumn {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Events.StreamAction : object {
    private List`1<IEvent> _events;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamActionType <ActionType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Type <AggregateType>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <AggregateTypeName>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ExpectedVersionOnServer>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Created>k__BackingField;
    public Guid Id { get; internal set; }
    [NullableAttribute("2")]
public string Key { get; }
    public StreamActionType ActionType { get; }
    [NullableAttribute("2")]
public Type AggregateType { get; internal set; }
    [NullableAttribute("2")]
public string AggregateTypeName { get; internal set; }
    [NullableAttribute("2")]
public string TenantId { get; internal set; }
    public IReadOnlyList`1<IEvent> Events { get; }
    public Nullable`1<long> ExpectedVersionOnServer { get; internal set; }
    public long Version { get; internal set; }
    public Nullable`1<DateTimeOffset> Timestamp { get; internal set; }
    public Nullable`1<DateTimeOffset> Created { get; internal set; }
    internal StreamAction(Guid stream, StreamActionType actionType);
    internal StreamAction(string stream, StreamActionType actionType);
    protected StreamAction(Guid id, string key, StreamActionType actionType);
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(Guid value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public StreamActionType get_ActionType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Type get_AggregateType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_AggregateType(Type value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_AggregateTypeName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_AggregateTypeName(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_TenantId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_TenantId(string value);
    public IReadOnlyList`1<IEvent> get_Events();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ExpectedVersionOnServer();
    [CompilerGeneratedAttribute]
internal void set_ExpectedVersionOnServer(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public long get_Version();
    [CompilerGeneratedAttribute]
internal void set_Version(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_Timestamp();
    [CompilerGeneratedAttribute]
internal void set_Timestamp(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_Created();
    [CompilerGeneratedAttribute]
internal void set_Created(Nullable`1<DateTimeOffset> value);
    internal StreamAction AddEvents(IReadOnlyList`1<IEvent> events);
    internal StreamAction AddEvent(IEvent event);
    public static StreamAction Start(EventGraph graph, Guid streamId, Object[] events);
    public static StreamAction Start(Guid streamId, IEvent[] events);
    public static StreamAction Start(EventGraph graph, string streamKey, Object[] events);
    public static StreamAction Start(string streamKey, IEvent[] events);
    public static StreamAction Append(EventGraph graph, Guid streamId, Object[] events);
    public static StreamAction Append(Guid streamId, IEvent[] events);
    public static StreamAction Append(EventGraph graph, string streamKey, Object[] events);
    public static StreamAction Append(string streamKey, IEvent[] events);
    internal void PrepareEvents(long currentVersion, EventGraph graph, Queue`1<long> sequences, IMartenSession session);
    private void applyQuickMetadata(EventGraph graph, IMartenSession session, DateTimeOffset timestamp);
    private void applyRichMetadata(long currentVersion, EventGraph graph, Queue`1<long> sequences, IMartenSession session, DateTimeOffset timestamp);
    internal static StreamAction ForReference(Guid streamId, string tenantId);
    internal static StreamAction ForReference(string streamKey, string tenantId);
    internal static StreamAction ForTombstone(DocumentSessionBase documentSessionBase);
    private static void ProcessMetadata(IEvent event, EventGraph graph, IMartenSession session);
    internal static StreamAction For(Guid streamId, IReadOnlyList`1<IEvent> events);
    internal static StreamAction For(string streamKey, IReadOnlyList`1<IEvent> events);
    internal IEnumerable`1<Event`1<Tombstone>> ToTombstoneEvents(EventMapping mapping, Tombstone tombstone);
}
public enum Marten.Events.StreamActionType : Enum {
    public int value__;
    public static StreamActionType Start;
    public static StreamActionType Append;
}
public enum Marten.Events.StreamIdentity : Enum {
    public int value__;
    public static StreamIdentity AsGuid;
    public static StreamIdentity AsString;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Events.StreamState : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <AggregateType>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastTimestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Created>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsArchived>k__BackingField;
    public Guid Id { get; public set; }
    public long Version { get; public set; }
    public Type AggregateType { get; public set; }
    public DateTimeOffset LastTimestamp { get; public set; }
    public DateTimeOffset Created { get; public set; }
    [NullableAttribute("2")]
public string Key { get; public set; }
    public bool IsArchived { get; public set; }
    public StreamState(Guid id, long version, Type aggregateType, DateTimeOffset lastTimestamp, DateTimeOffset created);
    public StreamState(string key, long version, Type aggregateType, DateTimeOffset lastTimestamp, DateTimeOffset created);
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Guid value);
    [CompilerGeneratedAttribute]
public long get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(long value);
    [CompilerGeneratedAttribute]
public Type get_AggregateType();
    [CompilerGeneratedAttribute]
public void set_AggregateType(Type value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastTimestamp();
    [CompilerGeneratedAttribute]
public void set_LastTimestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Created();
    [CompilerGeneratedAttribute]
public void set_Created(DateTimeOffset value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Key();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public bool get_IsArchived();
    [CompilerGeneratedAttribute]
public void set_IsArchived(bool value);
}
[ExtensionAttribute]
public static class Marten.Events.TestingExtensions : object {
    [ExtensionAttribute]
public static Task WaitForNonStaleProjectionDataAsync(IHost host, TimeSpan timeout);
    [AsyncStateMachineAttribute("Marten.Events.TestingExtensions/<WaitForNonStaleProjectionDataAsync>d__1")]
[ExtensionAttribute]
public static Task WaitForNonStaleProjectionDataAsync(IHost host, string tenantIdOrDatabaseName, TimeSpan timeout);
    [ExtensionAttribute]
public static Task WaitForNonStaleProjectionDataAsync(IDocumentStore store, TimeSpan timeout);
    [AsyncStateMachineAttribute("Marten.Events.TestingExtensions/<WaitForNonStaleProjectionDataAsync>d__3")]
[ExtensionAttribute]
public static Task WaitForNonStaleProjectionDataAsync(IDocumentStore store, string tenantIdOrDatabaseName, TimeSpan timeout);
    [AsyncStateMachineAttribute("Marten.Events.TestingExtensions/<WaitForNonStaleProjectionDataAsync>d__4")]
[ExtensionAttribute]
public static Task WaitForNonStaleProjectionDataAsync(IMartenDatabase database, TimeSpan timeout);
}
public class Marten.Events.TestSupport.ProjectionScenario : object {
    private Queue`1<ScenarioStep> _steps;
    private DocumentStore _store;
    [CompilerGeneratedAttribute]
private IProjectionDaemon <Daemon>k__BackingField;
    [CompilerGeneratedAttribute]
private IDocumentSession <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DoNotDeleteExistingData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    internal IProjectionDaemon Daemon { get; private set; }
    internal ScenarioStep NextStep { get; }
    internal IDocumentSession Session { get; private set; }
    public bool DoNotDeleteExistingData { get; public set; }
    public string TenantId { get; public set; }
    public ProjectionScenario(DocumentStore store);
    public void AssertAgainstProjectedData(string description, Func`3<IQuerySession, CancellationToken, Task> assertions);
    public void DocumentShouldExist(string id, Action`1<T> assertions);
    public void DocumentShouldExist(long id, Action`1<T> assertions);
    public void DocumentShouldExist(int id, Action`1<T> assertions);
    public void DocumentShouldExist(Guid id, Action`1<T> assertions);
    public void DocumentShouldNotExist(string id);
    public void DocumentShouldNotExist(long id);
    public void DocumentShouldNotExist(int id);
    public void DocumentShouldNotExist(Guid id);
    [CompilerGeneratedAttribute]
internal IProjectionDaemon get_Daemon();
    [CompilerGeneratedAttribute]
private void set_Daemon(IProjectionDaemon value);
    internal ScenarioStep get_NextStep();
    [CompilerGeneratedAttribute]
internal IDocumentSession get_Session();
    [CompilerGeneratedAttribute]
private void set_Session(IDocumentSession value);
    [CompilerGeneratedAttribute]
public bool get_DoNotDeleteExistingData();
    [CompilerGeneratedAttribute]
public void set_DoNotDeleteExistingData(bool value);
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
public void set_TenantId(string value);
    internal Task WaitForNonStaleData();
    private ScenarioStep action(Action`1<IEventOperations> action);
    private ScenarioStep assertion(Func`3<IQuerySession, CancellationToken, Task> check);
    [AsyncStateMachineAttribute("Marten.Events.TestSupport.ProjectionScenario/<Execute>d__33")]
internal Task Execute(CancellationToken ct);
    public sealed virtual StreamAction Append(Guid stream, IEnumerable`1<object> events);
    public sealed virtual StreamAction Append(Guid stream, Object[] events);
    public sealed virtual StreamAction Append(string stream, IEnumerable`1<object> events);
    public sealed virtual StreamAction Append(string stream, Object[] events);
    public sealed virtual StreamAction Append(Guid stream, long expectedVersion, Object[] events);
    public sealed virtual StreamAction Append(string stream, long expectedVersion, IEnumerable`1<object> events);
    public sealed virtual StreamAction Append(string stream, long expectedVersion, Object[] events);
    public sealed virtual StreamAction StartStream(Guid id, Object[] events);
    public sealed virtual StreamAction StartStream(Type aggregateType, Guid id, IEnumerable`1<object> events);
    public sealed virtual StreamAction StartStream(Type aggregateType, Guid id, Object[] events);
    public sealed virtual StreamAction StartStream(string streamKey, IEnumerable`1<object> events);
    public sealed virtual StreamAction StartStream(string streamKey, Object[] events);
    public sealed virtual StreamAction StartStream(Type aggregateType, string streamKey, IEnumerable`1<object> events);
    public sealed virtual StreamAction StartStream(Type aggregateType, string streamKey, Object[] events);
    public sealed virtual StreamAction StartStream(Guid id, IEnumerable`1<object> events);
    public sealed virtual StreamAction StartStream(Guid id, Object[] events);
    public sealed virtual StreamAction StartStream(string streamKey, IEnumerable`1<object> events);
    public sealed virtual StreamAction StartStream(string streamKey, Object[] events);
    public sealed virtual StreamAction StartStream(IEnumerable`1<object> events);
    public sealed virtual StreamAction StartStream(Object[] events);
    public sealed virtual StreamAction StartStream(Type aggregateType, IEnumerable`1<object> events);
    public sealed virtual StreamAction StartStream(Type aggregateType, Object[] events);
    public sealed virtual StreamAction StartStream(IEnumerable`1<object> events);
    public sealed virtual StreamAction StartStream(Object[] events);
    public void AppendEvents(string description, Action`1<IEventOperations> appendAction);
    public void AppendEvents(Action`1<IEventOperations> appendAction);
}
public class Marten.Events.TestSupport.ProjectionScenarioException : AggregateException {
    public ProjectionScenarioException(List`1<string> descriptions, List`1<Exception> exceptions);
}
internal class Marten.Events.TestSupport.ScenarioAction : ScenarioStep {
    private Action`1<IEventOperations> _action;
    public ScenarioAction(Action`1<IEventOperations> action);
    [AsyncStateMachineAttribute("Marten.Events.TestSupport.ScenarioAction/<Execute>d__2")]
public virtual Task Execute(ProjectionScenario scenario, CancellationToken ct);
}
internal class Marten.Events.TestSupport.ScenarioAssertion : ScenarioStep {
    private Func`3<IQuerySession, CancellationToken, Task> _check;
    public ScenarioAssertion(Func`3<IQuerySession, CancellationToken, Task> check);
    public virtual Task Execute(ProjectionScenario scenario, CancellationToken ct);
}
internal abstract class Marten.Events.TestSupport.ScenarioStep : object {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Description { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    public abstract virtual Task Execute(ProjectionScenario scenario, CancellationToken ct);
}
public class Marten.Exceptions.AmbiguousDocumentTypeAliasesException : MartenException {
    public AmbiguousDocumentTypeAliasesException(string message);
}
public class Marten.Exceptions.ApplyEventException : MartenException {
    [CompilerGeneratedAttribute]
private IEvent <Event>k__BackingField;
    public IEvent Event { get; }
    public ApplyEventException(IEvent event, Exception innerException);
    [CompilerGeneratedAttribute]
public IEvent get_Event();
}
public class Marten.Exceptions.BadLinqExpressionException : MartenException {
    public BadLinqExpressionException(string message, Exception innerException);
    public BadLinqExpressionException(string message);
    public BadLinqExpressionException(Expression expression);
}
public class Marten.Exceptions.ConcurrencyException : MartenException {
    [CompilerGeneratedAttribute]
private string <DocType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Id>k__BackingField;
    public string DocType { get; public set; }
    public object Id { get; public set; }
    public ConcurrencyException(Type docType, object id);
    public ConcurrencyException(string message, Type docType, object id);
    protected ConcurrencyException(SerializationInfo info, StreamingContext context);
    public static string ToMessage(Type docType, object id);
    [CompilerGeneratedAttribute]
public string get_DocType();
    [CompilerGeneratedAttribute]
public void set_DocType(string value);
    [CompilerGeneratedAttribute]
public object get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(object value);
}
public class Marten.Exceptions.ConcurrentUpdateException : MartenException {
    public ConcurrentUpdateException(Exception innerException);
    protected ConcurrentUpdateException(SerializationInfo info, StreamingContext context);
}
internal class Marten.Exceptions.DateTimeUsageExceptionTransform : object {
    [NullableContextAttribute("1")]
public sealed virtual bool TryTransform(Exception original, Exception& transformed);
}
public class Marten.Exceptions.DefaultTenantUsageDisabledException : MartenException {
    public DefaultTenantUsageDisabledException(string message);
    protected DefaultTenantUsageDisabledException(SerializationInfo info, StreamingContext context);
}
public class Marten.Exceptions.DocumentAlreadyExistsException : MartenException {
    [CompilerGeneratedAttribute]
private Type <DocType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Id>k__BackingField;
    public Type DocType { get; }
    public object Id { get; }
    public DocumentAlreadyExistsException(Exception inner, Type docType, object id);
    public DocumentAlreadyExistsException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Type get_DocType();
    [CompilerGeneratedAttribute]
public object get_Id();
}
public class Marten.Exceptions.DocumentIdTypeMismatchException : MartenException {
    public DocumentIdTypeMismatchException(IDocumentStorage storage, Type actualIdType);
    public DocumentIdTypeMismatchException(Type documentType, Type idType);
    public DocumentIdTypeMismatchException(string message);
    protected DocumentIdTypeMismatchException(SerializationInfo info, StreamingContext context);
}
public class Marten.Exceptions.EmptyEventStreamException : MartenException {
    public static string MessageTemplate;
    public EmptyEventStreamException(string key);
    public EmptyEventStreamException(Guid id);
    private static EmptyEventStreamException();
}
public class Marten.Exceptions.EventDeserializationFailureException : MartenException {
    [CompilerGeneratedAttribute]
private long <Sequence>k__BackingField;
    public long Sequence { get; }
    public EventDeserializationFailureException(long sequence, Exception innerException);
    [CompilerGeneratedAttribute]
public long get_Sequence();
    internal DeadLetterEvent ToDeadLetterEvent(ShardName name);
}
public class Marten.Exceptions.EventStreamUnexpectedMaxEventIdException : ConcurrencyException {
    [CompilerGeneratedAttribute]
private Type <AggregateType>k__BackingField;
    public Type AggregateType { get; }
    public EventStreamUnexpectedMaxEventIdException(object id, Type aggregateType, long expected, long actual);
    protected EventStreamUnexpectedMaxEventIdException(SerializationInfo info, StreamingContext context);
    public EventStreamUnexpectedMaxEventIdException(string message);
    [CompilerGeneratedAttribute]
public Type get_AggregateType();
}
public class Marten.Exceptions.ExistingStreamIdCollisionException : MartenException {
    [CompilerGeneratedAttribute]
private object <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <AggregateType>k__BackingField;
    public object Id { get; }
    public Type AggregateType { get; }
    public ExistingStreamIdCollisionException(object id, Type aggregateType);
    protected ExistingStreamIdCollisionException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public object get_Id();
    [CompilerGeneratedAttribute]
public Type get_AggregateType();
}
public class Marten.Exceptions.HiloSequenceAdvanceToNextHiAttemptsExceededException : MartenException {
    private static string message;
    protected HiloSequenceAdvanceToNextHiAttemptsExceededException(SerializationInfo info, StreamingContext context);
}
public class Marten.Exceptions.InvalidCompiledQueryException : MartenException {
    public static string CompiledQueryTypeCannotBeAsyncMessage;
    public InvalidCompiledQueryException(string message);
    public InvalidCompiledQueryException(string message, Exception innerException);
    protected InvalidCompiledQueryException(SerializationInfo info, StreamingContext context);
    private static InvalidCompiledQueryException();
    public static InvalidCompiledQueryException ForCannotBeAsync(Type compiledQueryType);
}
internal class Marten.Exceptions.InvalidConnectionStreamExceptionTransform : object {
    [NullableContextAttribute("1")]
public sealed virtual bool TryTransform(Exception original, Exception& transformed);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Exceptions.InvalidConnectionStringException : MartenCommandException {
    public InvalidConnectionStringException(NpgsqlCommand command, ArgumentException innerException);
    public InvalidConnectionStringException(NpgsqlCommand command, ArgumentException innerException, string prefix);
}
public class Marten.Exceptions.InvalidDateTimeUsageException : MartenException {
    [NullableContextAttribute("1")]
public InvalidDateTimeUsageException(string message, Exception innerException);
}
public class Marten.Exceptions.InvalidDocumentException : MartenException {
    public InvalidDocumentException(string message);
}
public class Marten.Exceptions.InvalidProjectionException : MartenException {
    [CompilerGeneratedAttribute]
private MethodSlot[] <InvalidMethods>k__BackingField;
    public MethodSlot[] InvalidMethods { get; }
    public InvalidProjectionException(string message);
    internal InvalidProjectionException(GeneratedProjection projection, IEnumerable`1<MethodSlot> invalidMethods);
    public InvalidProjectionException(String[] messages);
    [CompilerGeneratedAttribute]
public MethodSlot[] get_InvalidMethods();
    private static string ToMessage(GeneratedProjection projection, IEnumerable`1<MethodSlot> invalidMethods);
}
public class Marten.Exceptions.InvalidStreamOperationException : MartenException {
    public InvalidStreamOperationException(string message);
}
public class Marten.Exceptions.InvalidTenantForDatabaseException : MartenException {
    public InvalidTenantForDatabaseException(string tenantId, IMartenDatabase database);
}
public class Marten.Exceptions.InvalidUtcDateTimeUsageException : MartenException {
    [NullableContextAttribute("1")]
public InvalidUtcDateTimeUsageException(Exception inner);
}
public class Marten.Exceptions.InvalidValueTypeException : MartenException {
    public InvalidValueTypeException(Type type, string message);
}
internal class Marten.Exceptions.KnownNotSupportedExceptionCause : object {
    internal static KnownNotSupportedExceptionCause ToTsvectorOnJsonb;
    internal static KnownNotSupportedExceptionCause WebStyleSearch;
    internal static KnownNotSupportedExceptionCause[] KnownCauses;
    private Func`2<Exception, bool> match;
    [CompilerGeneratedAttribute]
private NotSupportedReason <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    internal NotSupportedReason Reason { get; }
    internal string Description { get; }
    internal KnownNotSupportedExceptionCause(string description, NotSupportedReason reason, Func`2<Exception, bool> match);
    private static KnownNotSupportedExceptionCause();
    [CompilerGeneratedAttribute]
internal NotSupportedReason get_Reason();
    [CompilerGeneratedAttribute]
internal string get_Description();
    internal bool Matches(Exception e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Exceptions.MartenCommandException : MartenException {
    public static string MaybeLockedRowsMessage;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private NpgsqlCommand <Command>k__BackingField;
    [NullableAttribute("2")]
public NpgsqlCommand Command { get; }
    public MartenCommandException(NpgsqlCommand command, Exception innerException);
    public MartenCommandException(NpgsqlCommand command, Exception innerException, string prefix);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public NpgsqlCommand get_Command();
    protected static string ToMessage(NpgsqlCommand command, Exception innerException, string prefix);
}
public class Marten.Exceptions.MartenCommandNotSupportedException : MartenCommandException {
    [CompilerGeneratedAttribute]
private NotSupportedReason <Reason>k__BackingField;
    public NotSupportedReason Reason { get; }
    public MartenCommandNotSupportedException(NotSupportedReason reason, NpgsqlCommand command, Exception innerException, string message);
    [CompilerGeneratedAttribute]
public NotSupportedReason get_Reason();
}
internal class Marten.Exceptions.MartenCommandNotSupportedExceptionTransform : object {
    public sealed virtual bool TryTransform(Exception original, Exception& transformed);
}
public class Marten.Exceptions.MartenException : Exception {
    protected MartenException(SerializationInfo info, StreamingContext context);
    public MartenException(string message);
    public MartenException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Marten.Exceptions.MartenExceptionTransformer : object {
    [CompilerGeneratedAttribute]
private static ExceptionTransforms <Transforms>k__BackingField;
    public static ExceptionTransforms Transforms { get; }
    private static MartenExceptionTransformer();
    [CompilerGeneratedAttribute]
public static ExceptionTransforms get_Transforms();
    [ExtensionAttribute]
internal static NpgsqlCommand ReadNpgsqlCommand(Exception ex);
    internal static void WrapAndThrow(NpgsqlCommand command, Exception exception);
    internal static void WrapAndThrow(Exception exception);
    public static void WrapAndThrow(NpgsqlBatch batch, Exception exception);
}
public class Marten.Exceptions.MartenSchemaException : MartenException {
    public MartenSchemaException(object subject, string ddl, Exception inner);
}
public class Marten.Exceptions.MissingGinExtensionException : MartenException {
    [NullableContextAttribute("2")]
public MissingGinExtensionException(Exception innerException);
}
public class Marten.Exceptions.NonExistentDocumentException : MartenException {
    [CompilerGeneratedAttribute]
private Type <DocType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Id>k__BackingField;
    public Type DocType { get; }
    public object Id { get; }
    public NonExistentDocumentException(Type docType, object id);
    protected NonExistentDocumentException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Type get_DocType();
    [CompilerGeneratedAttribute]
public object get_Id();
}
public class Marten.Exceptions.NonExistentStreamException : MartenException {
    [CompilerGeneratedAttribute]
private object <Id>k__BackingField;
    public object Id { get; }
    public NonExistentStreamException(object id);
    [CompilerGeneratedAttribute]
public object get_Id();
}
public enum Marten.Exceptions.NotSupportedReason : Enum {
    public int value__;
    public static NotSupportedReason FullTextSearchNeedsAtLeastPostgresVersion10;
    public static NotSupportedReason WebStyleSearchNeedsAtLeastPostgresVersion11;
}
public class Marten.Exceptions.ProgressionProgressOutOfOrderException : MartenException {
    public ProgressionProgressOutOfOrderException(ShardName progressionOrShardName);
}
public class Marten.Exceptions.RollbackException : MartenException {
    public RollbackException(Exception innerException);
    protected RollbackException(SerializationInfo info, StreamingContext context);
}
public class Marten.Exceptions.StreamLockedException : MartenException {
    public StreamLockedException(object streamId, Exception innerException);
}
public class Marten.Exceptions.UnknownEventTypeException : MartenException {
    [CompilerGeneratedAttribute]
private string <EventTypeName>k__BackingField;
    public string EventTypeName { get; }
    public UnknownEventTypeException(string eventTypeName);
    protected UnknownEventTypeException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_EventTypeName();
}
internal class Marten.Exceptions.UtcDateTimeUsageExceptionTransform : object {
    [NullableContextAttribute("1")]
public sealed virtual bool TryTransform(Exception original, Exception& transformed);
}
[ExtensionAttribute]
public static class Marten.HostExtensions : object {
    [ExtensionAttribute]
public static Task PauseAllDaemonsAsync(IHost host);
    [ExtensionAttribute]
public static Task ResumeAllDaemonsAsync(IHost host);
    [ExtensionAttribute]
public static IDocumentStore DocumentStore(IHost host);
    [ExtensionAttribute]
public static T DocumentStore(IHost host);
    [AsyncStateMachineAttribute("Marten.HostExtensions/<CleanAllMartenDataAsync>d__4")]
[ExtensionAttribute]
public static Task CleanAllMartenDataAsync(IHost host);
    [AsyncStateMachineAttribute("Marten.HostExtensions/<CleanAllMartenDataAsync>d__5`1")]
[ExtensionAttribute]
public static Task CleanAllMartenDataAsync(IHost host);
    [AsyncStateMachineAttribute("Marten.HostExtensions/<ResetAllMartenDataAsync>d__6")]
[ExtensionAttribute]
public static Task ResetAllMartenDataAsync(IHost host);
    [AsyncStateMachineAttribute("Marten.HostExtensions/<ResetAllMartenDataAsync>d__7`1")]
[ExtensionAttribute]
public static Task ResetAllMartenDataAsync(IHost host);
}
[NullableContextAttribute("1")]
public interface Marten.IAdvancedSql {
    public abstract virtual Task`1<IReadOnlyList`1<T>> QueryAsync(string sql, CancellationToken token, Object[] parameters);
    public abstract virtual Task`1<IReadOnlyList`1<ValueTuple`2<T1, T2>>> QueryAsync(string sql, CancellationToken token, Object[] parameters);
    [NullableContextAttribute("2")]
public abstract virtual Task`1<IReadOnlyList`1<ValueTuple`3<T1, T2, T3>>> QueryAsync(string sql, CancellationToken token, Object[] parameters);
    public abstract virtual IReadOnlyList`1<T> Query(string sql, Object[] parameters);
    public abstract virtual IReadOnlyList`1<ValueTuple`2<T1, T2>> Query(string sql, Object[] parameters);
    [NullableContextAttribute("2")]
public abstract virtual IReadOnlyList`1<ValueTuple`3<T1, T2, T3>> Query(string sql, Object[] parameters);
    public abstract virtual IAsyncEnumerable`1<T> StreamAsync(string sql, CancellationToken token, Object[] parameters);
    public abstract virtual IAsyncEnumerable`1<ValueTuple`2<T1, T2>> StreamAsync(string sql, CancellationToken token, Object[] parameters);
    [NullableContextAttribute("2")]
public abstract virtual IAsyncEnumerable`1<ValueTuple`3<T1, T2, T3>> StreamAsync(string sql, CancellationToken token, Object[] parameters);
}
[NullableContextAttribute("1")]
public interface Marten.IAsyncConfigureMarten {
    public abstract virtual ValueTask Configure(StoreOptions options, CancellationToken cancellationToken);
}
public interface Marten.IBatchQueryPlan`1 {
    public abstract virtual Task`1<T> Fetch(IBatchedQuery query);
}
[NullableContextAttribute("1")]
public interface Marten.IChangeListener {
    public abstract virtual Task AfterCommitAsync(IDocumentSession session, IChangeSet commit, CancellationToken token);
    public abstract virtual Task BeforeCommitAsync(IDocumentSession session, IChangeSet commit, CancellationToken token);
}
[NullableContextAttribute("1")]
public interface Marten.IConfigureMarten {
    public abstract virtual void Configure(IServiceProvider services, StoreOptions options);
}
[NullableContextAttribute("1")]
[ObsoleteAttribute("This will be removed in Marten 8, please prefer NpgsqlDataSource usage")]
public interface Marten.IConnectionFactory {
    public abstract virtual NpgsqlConnection Create();
}
[NullableContextAttribute("1")]
public interface Marten.IDiagnostics {
    public abstract virtual NpgsqlCommand PreviewCommand(ICompiledQuery`2<TDoc, TReturn> query, DocumentTracking trackingMode);
    public abstract virtual QueryPlan ExplainPlan(ICompiledQuery`2<TDoc, TReturn> query);
    public abstract virtual Version GetPostgresVersion();
}
[NullableContextAttribute("1")]
internal interface Marten.IDocumentMappingBuilder {
    public Type DocumentType { get; }
    public abstract virtual Type get_DocumentType();
    public abstract virtual DocumentMapping Build(StoreOptions options);
    public abstract virtual void Include(IDocumentMappingBuilder include);
}
[NullableContextAttribute("1")]
public interface Marten.IDocumentOperations {
    public IEventStore Events { get; }
    public abstract virtual IEventStore get_Events();
    public abstract virtual void Delete(T entity);
    public abstract virtual void Delete(int id);
    public abstract virtual void Delete(long id);
    public abstract virtual void Delete(object id);
    public abstract virtual void Delete(Guid id);
    public abstract virtual void Delete(string id);
    public abstract virtual void DeleteWhere(Expression`1<Func`2<T, bool>> expression);
    public abstract virtual void DeleteObjects(IEnumerable`1<object> documents);
    public abstract virtual void Store(IEnumerable`1<T> entities);
    public abstract virtual void Store(T[] entities);
    public abstract virtual void UpdateExpectedVersion(T entity, Guid version);
    public abstract virtual void UpdateRevision(T entity, int revision);
    public abstract virtual void TryUpdateRevision(T entity, int revision);
    public abstract virtual void StoreObjects(IEnumerable`1<object> documents);
    public abstract virtual void QueueOperation(IStorageOperation storageOperation);
    public abstract virtual void Insert(IEnumerable`1<T> entities);
    public abstract virtual void Insert(T[] entities);
    public abstract virtual void Update(IEnumerable`1<T> entities);
    public abstract virtual void Update(T[] entities);
    public abstract virtual void InsertObjects(IEnumerable`1<object> documents);
    public abstract virtual void HardDelete(T entity);
    public abstract virtual void HardDelete(int id);
    public abstract virtual void HardDelete(long id);
    public abstract virtual void HardDelete(Guid id);
    public abstract virtual void HardDelete(string id);
    public abstract virtual void HardDeleteWhere(Expression`1<Func`2<T, bool>> expression);
    public abstract virtual void UndoDeleteWhere(Expression`1<Func`2<T, bool>> expression);
    public abstract virtual void QueueSqlCommand(string sql, Object[] parameterValues);
    [NullableContextAttribute("2")]
public abstract virtual void UseIdentityMapFor();
}
public interface Marten.IDocumentPolicy {
    public abstract virtual void Apply(DocumentMapping mapping);
}
[NullableContextAttribute("1")]
public interface Marten.IDocumentSchemaResolver {
    public string DatabaseSchemaName { get; }
    public string EventsSchemaName { get; }
    public abstract virtual string get_DatabaseSchemaName();
    public abstract virtual string get_EventsSchemaName();
    public abstract virtual string For(bool qualified);
    public abstract virtual string For(Type documentType, bool qualified);
    public abstract virtual string ForEvents(bool qualified);
    public abstract virtual string ForStreams(bool qualified);
    public abstract virtual string ForEventProgression(bool qualified);
}
[NullableContextAttribute("1")]
public interface Marten.IDocumentSession {
    public IUnitOfWork PendingChanges { get; }
    public IEventStore Events { get; }
    public ConcurrencyChecks Concurrency { get; }
    public IList`1<IDocumentSessionListener> Listeners { get; }
    [NullableAttribute("2")]
public string LastModifiedBy { get; public set; }
    public abstract virtual void BeginTransaction();
    public abstract virtual ValueTask BeginTransactionAsync(CancellationToken token);
    public abstract virtual IUnitOfWork get_PendingChanges();
    public abstract virtual IEventStore get_Events();
    public abstract virtual ConcurrencyChecks get_Concurrency();
    public abstract virtual IList`1<IDocumentSessionListener> get_Listeners();
    [NullableContextAttribute("2")]
public abstract virtual string get_LastModifiedBy();
    [NullableContextAttribute("2")]
public abstract virtual void set_LastModifiedBy(string value);
    public abstract virtual void SaveChanges();
    public abstract virtual Task SaveChangesAsync(CancellationToken token);
    public abstract virtual void Eject(T document);
    public abstract virtual void EjectAllOfType(Type type);
    public abstract virtual void SetHeader(string key, object value);
    public abstract virtual object GetHeader(string key);
    public abstract virtual ITenantOperations ForTenant(string tenantId);
    public abstract virtual void EjectAllPendingChanges();
}
[NullableContextAttribute("1")]
public interface Marten.IDocumentSessionListener {
    public abstract virtual Task AfterCommitAsync(IDocumentSession session, IChangeSet commit, CancellationToken token);
    public abstract virtual void BeforeSaveChanges(IDocumentSession session);
    public abstract virtual Task BeforeSaveChangesAsync(IDocumentSession session, CancellationToken token);
    public abstract virtual void AfterCommit(IDocumentSession session, IChangeSet commit);
    public abstract virtual void DocumentLoaded(object id, object document);
    public abstract virtual void DocumentAddedForStorage(object id, object document);
}
[NullableContextAttribute("1")]
public interface Marten.IDocumentStore {
    public IReadOnlyStoreOptions Options { get; }
    public IMartenStorage Storage { get; }
    public AdvancedOperations Advanced { get; }
    public IDiagnostics Diagnostics { get; }
    public abstract virtual IReadOnlyStoreOptions get_Options();
    public abstract virtual IMartenStorage get_Storage();
    public abstract virtual AdvancedOperations get_Advanced();
    public abstract virtual IDiagnostics get_Diagnostics();
    public abstract virtual void BulkInsert(IReadOnlyCollection`1<T> documents, BulkInsertMode mode, int batchSize);
    public abstract virtual void BulkInsertEnlistTransaction(IReadOnlyCollection`1<T> documents, Transaction transaction, BulkInsertMode mode, int batchSize);
    public abstract virtual void BulkInsert(string tenantId, IReadOnlyCollection`1<T> documents, BulkInsertMode mode, int batchSize);
    public abstract virtual Task BulkInsertAsync(IReadOnlyCollection`1<T> documents, BulkInsertMode mode, int batchSize, CancellationToken cancellation);
    public abstract virtual Task BulkInsertEnlistTransactionAsync(IReadOnlyCollection`1<T> documents, Transaction transaction, BulkInsertMode mode, int batchSize, CancellationToken cancellation);
    public abstract virtual Task BulkInsertAsync(string tenantId, IReadOnlyCollection`1<T> documents, BulkInsertMode mode, int batchSize, CancellationToken cancellation);
    [ObsoleteAttribute("Opening a session without explicitly providing desired type may be dropped in next Marten version.
Use explicit method like `LightweightSession`, `IdentitySession` or `DirtyTrackedSession`.
We recommend using lightweight session by default. Read more in documentation: https://martendb.io/documents/sessions.html.")]
public abstract virtual IDocumentSession OpenSession(DocumentTracking tracking, IsolationLevel isolationLevel);
    [ObsoleteAttribute("Opening a session without explicitly providing desired type may be dropped in next Marten version.
Use explicit method like `LightweightSession`, `IdentitySession` or `DirtyTrackedSession`.
We recommend using lightweight session by default. Read more in documentation: https://martendb.io/documents/sessions.html.")]
public abstract virtual IDocumentSession OpenSession(string tenantId, DocumentTracking tracking, IsolationLevel isolationLevel);
    public abstract virtual IDocumentSession OpenSession(SessionOptions options);
    public abstract virtual Task`1<IDocumentSession> OpenSerializableSessionAsync(SessionOptions options, CancellationToken token);
    public abstract virtual IDocumentSession LightweightSession(IsolationLevel isolationLevel);
    public abstract virtual IDocumentSession LightweightSession(string tenantId, IsolationLevel isolationLevel);
    public abstract virtual IDocumentSession LightweightSession(SessionOptions options);
    public abstract virtual Task`1<IDocumentSession> LightweightSerializableSessionAsync(CancellationToken token);
    public abstract virtual Task`1<IDocumentSession> LightweightSerializableSessionAsync(string tenantId, CancellationToken token);
    public abstract virtual Task`1<IDocumentSession> LightweightSerializableSessionAsync(SessionOptions options, CancellationToken token);
    public abstract virtual IDocumentSession IdentitySession(IsolationLevel isolationLevel);
    public abstract virtual IDocumentSession IdentitySession(string tenantId, IsolationLevel isolationLevel);
    public abstract virtual IDocumentSession IdentitySession(SessionOptions options);
    public abstract virtual Task`1<IDocumentSession> IdentitySerializableSessionAsync(CancellationToken token);
    public abstract virtual Task`1<IDocumentSession> IdentitySerializableSessionAsync(string tenantId, CancellationToken token);
    public abstract virtual Task`1<IDocumentSession> IdentitySerializableSessionAsync(SessionOptions options, CancellationToken token);
    public abstract virtual IDocumentSession DirtyTrackedSession(IsolationLevel isolationLevel);
    public abstract virtual IDocumentSession DirtyTrackedSession(string tenantId, IsolationLevel isolationLevel);
    public abstract virtual IDocumentSession DirtyTrackedSession(SessionOptions options);
    public abstract virtual Task`1<IDocumentSession> DirtyTrackedSerializableSessionAsync(CancellationToken token);
    public abstract virtual Task`1<IDocumentSession> DirtyTrackedSerializableSessionAsync(string tenantId, CancellationToken token);
    public abstract virtual Task`1<IDocumentSession> DirtyTrackedSerializableSessionAsync(SessionOptions options, CancellationToken token);
    public abstract virtual IQuerySession QuerySession();
    public abstract virtual IQuerySession QuerySession(string tenantId);
    public abstract virtual IQuerySession QuerySession(SessionOptions options);
    public abstract virtual Task`1<IQuerySession> QuerySerializableSessionAsync(CancellationToken token);
    public abstract virtual Task`1<IQuerySession> QuerySerializableSessionAsync(string tenantId, CancellationToken token);
    public abstract virtual Task`1<IQuerySession> QuerySerializableSessionAsync(SessionOptions options, CancellationToken token);
    public abstract virtual void BulkInsertDocuments(IEnumerable`1<object> documents, BulkInsertMode mode, int batchSize);
    public abstract virtual void BulkInsertDocuments(string tenantId, IEnumerable`1<object> documents, BulkInsertMode mode, int batchSize);
    public abstract virtual Task BulkInsertDocumentsAsync(IEnumerable`1<object> documents, BulkInsertMode mode, int batchSize, CancellationToken cancellation);
    public abstract virtual Task BulkInsertDocumentsAsync(string tenantId, IEnumerable`1<object> documents, BulkInsertMode mode, int batchSize, CancellationToken cancellation);
    [NullableContextAttribute("2")]
public abstract virtual ValueTask`1<IProjectionDaemon> BuildProjectionDaemonAsync(string tenantIdOrDatabaseIdentifier, ILogger logger);
}
[NullableContextAttribute("1")]
internal interface Marten.IDocumentStoreSource {
    public abstract virtual IDocumentStore Resolve(IServiceProvider serviceProvider);
}
[NullableContextAttribute("1")]
public interface Marten.IJsonLoader {
    public abstract virtual string FindById(string id);
    public abstract virtual string FindById(int id);
    public abstract virtual string FindById(long id);
    public abstract virtual string FindById(Guid id);
    public abstract virtual Task`1<string> FindByIdAsync(string id, CancellationToken token);
    public abstract virtual Task`1<string> FindByIdAsync(int id, CancellationToken token);
    public abstract virtual Task`1<string> FindByIdAsync(long id, CancellationToken token);
    public abstract virtual Task`1<string> FindByIdAsync(Guid id, CancellationToken token);
    public abstract virtual Task`1<bool> StreamById(int id, Stream destination, CancellationToken token);
    public abstract virtual Task`1<bool> StreamById(long id, Stream destination, CancellationToken token);
    public abstract virtual Task`1<bool> StreamById(string id, Stream destination, CancellationToken token);
    public abstract virtual Task`1<bool> StreamById(Guid id, Stream destination, CancellationToken token);
}
[NullableContextAttribute("1")]
public interface Marten.ILoadByKeys`1 {
    public abstract virtual IReadOnlyList`1<TDoc> ById(TKey[] keys);
    public abstract virtual Task`1<IReadOnlyList`1<TDoc>> ByIdAsync(TKey[] keys);
    public abstract virtual IReadOnlyList`1<TDoc> ById(IEnumerable`1<TKey> keys);
    public abstract virtual Task`1<IReadOnlyList`1<TDoc>> ByIdAsync(IEnumerable`1<TKey> keys, CancellationToken token);
}
[NullableContextAttribute("1")]
public interface Marten.IMartenLogger {
    public abstract virtual IMartenSessionLogger StartSession(IQuerySession session);
    public abstract virtual void SchemaChange(string sql);
}
[NullableContextAttribute("1")]
public interface Marten.IMartenSessionLogger {
    public abstract virtual void LogSuccess(NpgsqlCommand command);
    public abstract virtual void LogFailure(NpgsqlCommand command, Exception ex);
    public abstract virtual void LogSuccess(NpgsqlBatch batch);
    public abstract virtual void LogFailure(NpgsqlBatch batch, Exception ex);
    public abstract virtual void LogFailure(Exception ex, string message);
    public abstract virtual void RecordSavedChanges(IDocumentSession session, IChangeSet commit);
    public abstract virtual void OnBeforeExecute(NpgsqlCommand command);
    public abstract virtual void OnBeforeExecute(NpgsqlBatch batch);
}
public interface Marten.IMartenStorage {
    public IMartenDatabase Database { get; }
    public abstract virtual IMartenDatabase get_Database();
    public abstract virtual String[] AllSchemaNames();
    public abstract virtual IEnumerable`1<ISchemaObject> AllObjects();
    public abstract virtual string ToDatabaseScript();
    public abstract virtual Task WriteCreationScriptToFile(string filename);
    public abstract virtual Task WriteScriptsByType(string directory);
    public abstract virtual Task ApplyAllConfiguredChangesToDatabaseAsync(Nullable`1<AutoCreate> override);
    public abstract virtual Task`1<SchemaMigration> CreateMigrationAsync();
    public abstract virtual ValueTask`1<IMartenDatabase> FindOrCreateDatabase(string tenantIdOrDatabaseIdentifier);
    public abstract virtual ValueTask`1<IReadOnlyList`1<IMartenDatabase>> AllDatabases();
}
public abstract class Marten.Internal.CodeGeneration.BulkLoader`2 : object {
    private IDocumentStorage`2<T, TId> _storage;
    public BulkLoader`2(IDocumentStorage`2<T, TId> storage);
    public sealed virtual void Load(Tenant tenant, ISerializer serializer, NpgsqlConnection conn, IEnumerable`1<T> documents);
    [AsyncStateMachineAttribute("Marten.Internal.CodeGeneration.BulkLoader`2/<LoadAsync>d__3")]
public sealed virtual Task LoadAsync(Tenant tenant, ISerializer serializer, NpgsqlConnection conn, IEnumerable`1<T> documents, CancellationToken cancellation);
    public abstract virtual string CreateTempTableForCopying();
    public sealed virtual void LoadIntoTempTable(Tenant tenant, ISerializer serializer, NpgsqlConnection conn, IEnumerable`1<T> documents);
    [AsyncStateMachineAttribute("Marten.Internal.CodeGeneration.BulkLoader`2/<LoadIntoTempTableAsync>d__6")]
public sealed virtual Task LoadIntoTempTableAsync(Tenant tenant, ISerializer serializer, NpgsqlConnection conn, IEnumerable`1<T> documents, CancellationToken cancellation);
    public abstract virtual string CopyNewDocumentsFromTempTable();
    public abstract virtual string OverwriteDuplicatesFromTempTable();
    public object GetNullable(Nullable`1<TValue> value);
    public int GetEnumIntValue(Nullable`1<TEnum> value);
    public string GetEnumStringValue(Nullable`1<TEnum> value);
    public abstract virtual void LoadRow(NpgsqlBinaryImporter writer, T document, Tenant tenant, ISerializer serializer);
    public abstract virtual Task LoadRowAsync(NpgsqlBinaryImporter writer, T document, Tenant tenant, ISerializer serializer, CancellationToken cancellation);
    public abstract virtual string MainLoaderSql();
    public abstract virtual string TempLoaderSql();
}
public class Marten.Internal.CodeGeneration.BulkLoaderBuilder : object {
    private DocumentMapping _mapping;
    private string _tempTable;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    public string TypeName { get; }
    public BulkLoaderBuilder(DocumentMapping mapping);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    public GeneratedType BuildType(GeneratedAssembly assembly);
    private static List`1<UpsertArgument> orderArgumentsForBulkWriting(UpsertFunction upsertFunction);
    public string CopyNewDocumentsFromTempTable();
    public string OverwriteDuplicatesFromTempTable();
    public string CreateTempTableForCopying();
    [CompilerGeneratedAttribute]
private string <CopyNewDocumentsFromTempTable>b__8_3(TableColumn x);
}
internal class Marten.Internal.CodeGeneration.DocumentFunctionOperationBuilder : object {
    private UpsertFunction _function;
    private DocumentMapping _mapping;
    private StoreOptions _options;
    private OperationRole _role;
    [CompilerGeneratedAttribute]
private string <ClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandText>k__BackingField;
    public string ClassName { get; }
    public string CommandText { get; }
    public DocumentFunctionOperationBuilder(DocumentMapping mapping, UpsertFunction function, OperationRole role, StoreOptions options);
    [CompilerGeneratedAttribute]
public string get_ClassName();
    [CompilerGeneratedAttribute]
public string get_CommandText();
    public GeneratedType BuildType(GeneratedAssembly assembly);
    private void buildPostprocessingMethods(GeneratedType type);
    private void buildConfigureMethod(GeneratedType type);
    [CompilerGeneratedAttribute]
private void <buildPostprocessingMethods>g__applyVersionToDocument|12_0(<>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
private void <buildPostprocessingMethods>g__applyRevisionToDocument|12_1(<>c__DisplayClass12_0& );
}
internal class Marten.Internal.CodeGeneration.DocumentOperations : object {
    [CompilerGeneratedAttribute]
private GeneratedType <Upsert>k__BackingField;
    [CompilerGeneratedAttribute]
private GeneratedType <Insert>k__BackingField;
    [CompilerGeneratedAttribute]
private GeneratedType <Update>k__BackingField;
    [CompilerGeneratedAttribute]
private GeneratedType <Overwrite>k__BackingField;
    [CompilerGeneratedAttribute]
private GeneratedType <QueryOnlySelector>k__BackingField;
    [CompilerGeneratedAttribute]
private GeneratedType <LightweightSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private GeneratedType <IdentityMapSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private GeneratedType <DirtyCheckingSelector>k__BackingField;
    public GeneratedType Upsert { get; public set; }
    public GeneratedType Insert { get; public set; }
    public GeneratedType Update { get; public set; }
    public GeneratedType Overwrite { get; public set; }
    public GeneratedType QueryOnlySelector { get; public set; }
    public GeneratedType LightweightSelector { get; public set; }
    public GeneratedType IdentityMapSelector { get; public set; }
    public GeneratedType DirtyCheckingSelector { get; public set; }
    public DocumentOperations(GeneratedAssembly assembly, DocumentMapping mapping, StoreOptions options);
    [CompilerGeneratedAttribute]
public GeneratedType get_Upsert();
    [CompilerGeneratedAttribute]
public void set_Upsert(GeneratedType value);
    [CompilerGeneratedAttribute]
public GeneratedType get_Insert();
    [CompilerGeneratedAttribute]
public void set_Insert(GeneratedType value);
    [CompilerGeneratedAttribute]
public GeneratedType get_Update();
    [CompilerGeneratedAttribute]
public void set_Update(GeneratedType value);
    [CompilerGeneratedAttribute]
public GeneratedType get_Overwrite();
    [CompilerGeneratedAttribute]
public void set_Overwrite(GeneratedType value);
    [CompilerGeneratedAttribute]
public GeneratedType get_QueryOnlySelector();
    [CompilerGeneratedAttribute]
public void set_QueryOnlySelector(GeneratedType value);
    [CompilerGeneratedAttribute]
public GeneratedType get_LightweightSelector();
    [CompilerGeneratedAttribute]
public void set_LightweightSelector(GeneratedType value);
    [CompilerGeneratedAttribute]
public GeneratedType get_IdentityMapSelector();
    [CompilerGeneratedAttribute]
public void set_IdentityMapSelector(GeneratedType value);
    [CompilerGeneratedAttribute]
public GeneratedType get_DirtyCheckingSelector();
    [CompilerGeneratedAttribute]
public void set_DirtyCheckingSelector(GeneratedType value);
}
public class Marten.Internal.CodeGeneration.DocumentProviderBuilder : object {
    private DocumentMapping _mapping;
    private StoreOptions _options;
    private Type _providerType;
    [CompilerGeneratedAttribute]
private string <ProviderName>k__BackingField;
    public string ProviderName { get; }
    public string FileName { get; }
    public DocumentProviderBuilder(DocumentMapping mapping, StoreOptions options);
    [CompilerGeneratedAttribute]
public string get_ProviderName();
    public sealed virtual Task`1<bool> AttachTypes(GenerationRules rules, Assembly assembly, IServiceProvider services, string containingNamespace);
    public sealed virtual bool AttachTypesSynchronously(GenerationRules rules, Assembly assembly, IServiceProvider services, string containingNamespace);
    public sealed virtual string get_FileName();
    public sealed virtual void AssembleTypes(GeneratedAssembly assembly);
    public DocumentProvider`1<T> BuildProvider();
    private GeneratedType buildProviderType(GeneratedAssembly assembly, GeneratedType queryOnly, GeneratedType bulkWriterType, GeneratedType lightweight, GeneratedType identityMap, GeneratedType dirtyTracking);
}
public abstract class Marten.Internal.CodeGeneration.DocumentSelectorWithDirtyChecking`2 : object {
    protected Dictionary`2<TId, T> _identityMap;
    protected DocumentMapping _mapping;
    protected ISerializer _serializer;
    protected IMartenSession _session;
    protected Dictionary`2<TId, Guid> _versions;
    public DocumentSelectorWithDirtyChecking`2(IMartenSession session, DocumentMapping mapping);
    public void StoreTracker(IMartenSession session, T document);
}
public abstract class Marten.Internal.CodeGeneration.DocumentSelectorWithIdentityMap`2 : object {
    protected Dictionary`2<TId, T> _identityMap;
    protected DocumentMapping _mapping;
    protected ISerializer _serializer;
    protected Dictionary`2<TId, Guid> _versions;
    public DocumentSelectorWithIdentityMap`2(IMartenSession session, DocumentMapping mapping);
}
public abstract class Marten.Internal.CodeGeneration.DocumentSelectorWithOnlySerializer : object {
    protected DocumentMapping _mapping;
    protected ISerializer _serializer;
    public DocumentSelectorWithOnlySerializer(IMartenSession session, DocumentMapping mapping);
}
public abstract class Marten.Internal.CodeGeneration.DocumentSelectorWithVersions`2 : object {
    protected DocumentMapping _mapping;
    protected ISerializer _serializer;
    protected Dictionary`2<TId, Guid> _versions;
    public DocumentSelectorWithVersions`2(IMartenSession session, DocumentMapping mapping);
}
internal class Marten.Internal.CodeGeneration.DocumentStorageBuilder : object {
    private Type _baseType;
    private DocumentMapping _mapping;
    private Func`2<DocumentOperations, GeneratedType> _selectorTypeSource;
    private string _typeName;
    public DocumentStorageBuilder(DocumentMapping mapping, StorageStyle style, Func`2<DocumentOperations, GeneratedType> selectorTypeSource);
    public static string DeriveTypeName(DocumentMapping mapping, StorageStyle style);
    private Type determineOpenDocumentStorageType(StorageStyle style);
    public GeneratedType Build(GeneratedAssembly assembly, DocumentOperations operations);
    private GeneratedType buildDocumentStorageType(GeneratedAssembly assembly, DocumentOperations operations, string typeName, Type baseType, GeneratedType selectorType);
    private void writeParameterForIdArray(GeneratedType type);
    private void writeParameterForId(GeneratedType type);
    private void writeIdentityMethod(GeneratedType type);
    private static void writeNotImplementedStubs(GeneratedType type);
    private void buildStorageOperationMethods(DocumentOperations operations, GeneratedType type);
    private void buildConditionalOperationBasedOnConcurrencyChecks(GeneratedType type, DocumentOperations operations, string methodName);
    private void buildOperationMethod(GeneratedType type, DocumentOperations operations, string methodName);
    private void writeReturnOfOperation(GeneratedMethod method, GeneratedType operationType);
}
[ExtensionAttribute]
internal static class Marten.Internal.CodeGeneration.FrameCollectionExtensions : object {
    public static string DocumentVariableName;
    [ExtensionAttribute]
public static void StoreInIdentityMap(FramesCollection frames, DocumentMapping mapping);
    [ExtensionAttribute]
public static void StoreTracker(FramesCollection frames);
    [ExtensionAttribute]
public static void DeserializeDocument(FramesCollection frames, DocumentMapping mapping, int index);
    [ExtensionAttribute]
public static void MarkAsLoaded(FramesCollection frames);
    [ExtensionAttribute]
public static void DeserializeDocumentAsync(FramesCollection frames, DocumentMapping mapping, int index);
    [ExtensionAttribute]
public static void SetMemberValue(FramesCollection frames, MemberInfo member, string variableName, Type documentType, GeneratedType generatedType);
    [ExtensionAttribute]
public static string InitializeLambdaSetterProperty(GeneratedType generatedType, MemberInfo member, Type documentType);
    [ExtensionAttribute]
private static void SetPublicMemberValue(FramesCollection frames, MemberInfo member, string variableName, Type documentType);
    [ExtensionAttribute]
public static void AssignMemberFromReader(GeneratedMethod method, GeneratedType generatedType, int index, Expression`1<Func`2<T, object>> memberExpression);
    [ExtensionAttribute]
public static void AssignMemberFromReader(GeneratedMethod method, GeneratedType generatedType, int index, Type documentType, string memberName);
    [ExtensionAttribute]
public static void AssignMemberFromReader(GeneratedMethod method, GeneratedType generatedType, int index, Expression`1<Func`2<T, Dictionary`2<string, object>>> memberExpression);
    [ExtensionAttribute]
public static void AssignMemberFromReaderAsync(GeneratedMethod method, GeneratedType generatedType, int index, Expression`1<Func`2<T, object>> memberExpression);
    [ExtensionAttribute]
public static void AssignMemberFromReaderAsync(GeneratedMethod method, GeneratedType generatedType, int index, Expression`1<Func`2<T, Dictionary`2<string, object>>> memberExpression);
    [ExtensionAttribute]
public static void AssignMemberFromReaderAsync(GeneratedMethod method, GeneratedType generatedType, int index, Type documentType, string memberName);
    [ExtensionAttribute]
public static void IfDbReaderValueIsNotNull(GeneratedMethod method, int index, Action action);
    [ExtensionAttribute]
public static void IfDbReaderValueIsNotNullAsync(GeneratedMethod method, int index, Action action);
    [ExtensionAttribute]
public static void SetParameterFromMemberNonNullableString(GeneratedMethod method, int index, Expression`1<Func`2<T, string>> memberExpression);
    [ExtensionAttribute]
public static void SetParameterFromMember(GeneratedMethod method, int index, Expression`1<Func`2<T, object>> memberExpression);
}
internal interface Marten.Internal.CodeGeneration.IDocumentSelector {
}
public abstract class Marten.Internal.CodeGeneration.RevisionedDocumentSelectorWithDirtyChecking`2 : object {
    protected Dictionary`2<TId, T> _identityMap;
    protected DocumentMapping _mapping;
    protected ISerializer _serializer;
    protected IMartenSession _session;
    protected Dictionary`2<TId, int> _versions;
    public RevisionedDocumentSelectorWithDirtyChecking`2(IMartenSession session, DocumentMapping mapping);
    public void StoreTracker(IMartenSession session, T document);
}
public abstract class Marten.Internal.CodeGeneration.RevisionedDocumentSelectorWithIdentityMap`2 : object {
    protected Dictionary`2<TId, T> _identityMap;
    protected DocumentMapping _mapping;
    protected ISerializer _serializer;
    protected Dictionary`2<TId, int> _versions;
    public RevisionedDocumentSelectorWithIdentityMap`2(IMartenSession session, DocumentMapping mapping);
}
public class Marten.Internal.CodeGeneration.SelectorBuilder : object {
    private DocumentMapping _mapping;
    private StorageStyle _style;
    public SelectorBuilder(DocumentMapping mapping, StorageStyle style);
    public GeneratedType BuildType(GeneratedAssembly assembly);
    private void generateIdentityMapAndTrackingCode(GeneratedMethod sync, GeneratedMethod async, StorageStyle storageStyle);
    private Type determineBaseType();
}
public enum Marten.Internal.CodeGeneration.StorageStyle : Enum {
    public int value__;
    public static StorageStyle QueryOnly;
    public static StorageStyle Lightweight;
    public static StorageStyle IdentityMap;
    public static StorageStyle DirtyTracking;
}
[ExtensionAttribute]
public static class Marten.Internal.CodeGeneration.StringExtensions : object {
    [ExtensionAttribute]
public static string Sanitize(string value);
    [ExtensionAttribute]
public static string ToTypeNamePart(Type type);
}
public class Marten.Internal.CodeGeneration.SubClassBulkLoader`2 : object {
    private IBulkLoader`1<TRoot> _inner;
    public SubClassBulkLoader`2(IBulkLoader`1<TRoot> inner);
    public sealed virtual void Load(Tenant tenant, ISerializer serializer, NpgsqlConnection conn, IEnumerable`1<T> documents);
    public sealed virtual Task LoadAsync(Tenant tenant, ISerializer serializer, NpgsqlConnection conn, IEnumerable`1<T> documents, CancellationToken cancellation);
    public sealed virtual string CreateTempTableForCopying();
    public sealed virtual void LoadIntoTempTable(Tenant tenant, ISerializer serializer, NpgsqlConnection conn, IEnumerable`1<T> documents);
    public sealed virtual Task LoadIntoTempTableAsync(Tenant tenant, ISerializer serializer, NpgsqlConnection conn, IEnumerable`1<T> documents, CancellationToken cancellation);
    public sealed virtual string CopyNewDocumentsFromTempTable();
    public sealed virtual string OverwriteDuplicatesFromTempTable();
}
public abstract class Marten.Internal.CompiledQueries.ClonedCompiledQuery`2 : object {
    private IMaybeStatefulHandler _inner;
    protected TQuery _query;
    private QueryStatistics _statistics;
    public ClonedCompiledQuery`2(IMaybeStatefulHandler inner, TQuery query, QueryStatistics statistics);
    public abstract virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual Task`1<int> StreamJson(Stream stream, DbDataReader reader, CancellationToken token);
    public sealed virtual TOut Handle(DbDataReader reader, IMartenSession session);
    public sealed virtual Task`1<TOut> HandleAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
    protected string StartsWith(string value);
    protected string ContainsString(string value);
    protected string EndsWith(string value);
}
internal class Marten.Internal.CompiledQueries.CommandPlan : object {
    [CompilerGeneratedAttribute]
private string <CommandText>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ParameterUsage> <Parameters>k__BackingField;
    public string CommandText { get; public set; }
    public List`1<ParameterUsage> Parameters { get; }
    [CompilerGeneratedAttribute]
public string get_CommandText();
    [CompilerGeneratedAttribute]
public void set_CommandText(string value);
    [CompilerGeneratedAttribute]
public List`1<ParameterUsage> get_Parameters();
}
internal class Marten.Internal.CompiledQueries.CompiledQueryCodeFile : object {
    private Type _compiledQueryType;
    private DocumentTracking _documentTracking;
    private CompiledQueryPlan _plan;
    private DocumentStore _store;
    private CompiledQuerySourceBuilder _builder;
    private Type _sourceType;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    public string FileName { get; }
    public CompiledQueryCodeFile(Type compiledQueryType, DocumentStore store, CompiledQueryPlan plan, DocumentTracking documentTracking);
    public sealed virtual void AssembleTypes(GeneratedAssembly assembly);
    public sealed virtual Task`1<bool> AttachTypes(GenerationRules rules, Assembly assembly, IServiceProvider services, string containingNamespace);
    public sealed virtual bool AttachTypesSynchronously(GenerationRules rules, Assembly assembly, IServiceProvider services, string containingNamespace);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FileName();
    public ICompiledQuerySource Build(GenerationRules generationRules);
    [CompilerGeneratedAttribute]
private bool <AttachTypes>b__8_0(Type x);
}
public class Marten.Internal.CompiledQueries.CompiledQueryPlan : object {
    [CompilerGeneratedAttribute]
private Type <QueryType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <OutputType>k__BackingField;
    public static string ParameterPlaceholder;
    [CompilerGeneratedAttribute]
private List`1<MemberInfo> <InvalidMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IQueryMember> <QueryMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<MemberInfo> <IncludeMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IIncludePlan> <IncludePlans>k__BackingField;
    private List`1<CommandPlan> _commands;
    [CompilerGeneratedAttribute]
private IQueryHandler <HandlerPrototype>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MemberInfo <StatisticsMember>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    private CommandPlan _current;
    private int _parameterIndex;
    public Type QueryType { get; }
    public Type OutputType { get; }
    public List`1<MemberInfo> InvalidMembers { get; }
    public List`1<IQueryMember> QueryMembers { get; }
    public List`1<MemberInfo> IncludeMembers { get; }
    internal List`1<IIncludePlan> IncludePlans { get; }
    public IQueryHandler HandlerPrototype { get; public set; }
    [NullableAttribute("2")]
public MemberInfo StatisticsMember { get; public set; }
    public string TenantId { get; public set; }
    private string Weasel.Postgresql.ICommandBuilder.LastParameterName { get; }
    public CompiledQueryPlan(Type queryType, Type outputType);
    [CompilerGeneratedAttribute]
public Type get_QueryType();
    [CompilerGeneratedAttribute]
public Type get_OutputType();
    [CompilerGeneratedAttribute]
public List`1<MemberInfo> get_InvalidMembers();
    [CompilerGeneratedAttribute]
public List`1<IQueryMember> get_QueryMembers();
    [CompilerGeneratedAttribute]
public List`1<MemberInfo> get_IncludeMembers();
    [CompilerGeneratedAttribute]
internal List`1<IIncludePlan> get_IncludePlans();
    [CompilerGeneratedAttribute]
public IQueryHandler get_HandlerPrototype();
    [CompilerGeneratedAttribute]
public void set_HandlerPrototype(IQueryHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MemberInfo get_StatisticsMember();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_StatisticsMember(MemberInfo value);
    private void sortMembers();
    [IteratorStateMachineAttribute("Marten.Internal.CompiledQueries.CompiledQueryPlan/<findMembers>d__30")]
private IEnumerable`1<MemberInfo> findMembers();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TenantId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TenantId(string value);
    private sealed virtual override string Weasel.Postgresql.ICommandBuilder.get_LastParameterName();
    private CommandPlan appendCommand();
    private sealed virtual override void Weasel.Postgresql.ICommandBuilder.Append(string sql);
    private sealed virtual override void Weasel.Postgresql.ICommandBuilder.Append(char character);
    private sealed virtual override NpgsqlParameter Weasel.Postgresql.ICommandBuilder.AppendParameter(T value);
    private sealed virtual override NpgsqlParameter Weasel.Postgresql.ICommandBuilder.AppendParameter(T value, NpgsqlDbType dbType);
    private sealed virtual override NpgsqlParameter Weasel.Postgresql.ICommandBuilder.AppendParameter(object value);
    private sealed virtual override NpgsqlParameter Weasel.Postgresql.ICommandBuilder.AppendParameter(object value, Nullable`1<NpgsqlDbType> dbType);
    private NpgsqlParameter appendParameter(object value, Nullable`1<NpgsqlDbType> dbType);
    private sealed virtual override void Weasel.Postgresql.ICommandBuilder.AppendParameters(Object[] parameters);
    public sealed virtual IGroupedParameterBuilder CreateGroupedParameterBuilder(Nullable`1<char> seperator);
    private sealed virtual override NpgsqlParameter[] Weasel.Postgresql.ICommandBuilder.AppendWithParameters(string text);
    private sealed virtual override NpgsqlParameter[] Weasel.Postgresql.ICommandBuilder.AppendWithParameters(string text, char placeholder);
    private sealed virtual override void Weasel.Postgresql.ICommandBuilder.StartNewCommand();
    private sealed virtual override void Weasel.Postgresql.ICommandBuilder.AddParameters(object parameters);
    public QueryStatistics GetStatisticsIfAny(object query);
    public ICompiledQuery`2<TDoc, TOut> CreateQueryTemplate(ICompiledQuery`2<TDoc, TOut> query);
    public object TryCreateUniqueTemplate(Type type);
    private bool areAllMemberValuesUnique(object query);
    public void MatchParameters(StoreOptions options, ICompiledQueryAwareFilter[] filters);
    public void GenerateCode(GeneratedMethod method, StoreOptions storeOptions);
}
public abstract class Marten.Internal.CompiledQueries.CompiledQuerySource`2 : object {
    public Type QueryType { get; }
    public sealed virtual Type get_QueryType();
    public sealed virtual IQueryHandler Build(object query, IMartenSession session);
    public abstract virtual IQueryHandler`1<TOut> BuildHandler(TQuery query, IMartenSession session);
}
internal class Marten.Internal.CompiledQueries.CompiledQuerySourceBuilder : object {
    private DocumentTracking _documentTracking;
    private CompiledQueryPlan _plan;
    private StoreOptions _storeOptions;
    private string _typeName;
    public CompiledQuerySourceBuilder(CompiledQueryPlan plan, StoreOptions storeOptions, DocumentTracking documentTracking);
    public void AssembleTypes(GeneratedAssembly assembly);
    public ICompiledQuerySource Build(Type sourceType);
    private void buildSourceType(GeneratedAssembly assembly, CompiledSourceType handlerType, GeneratedType compiledHandlerType);
    private GeneratedType buildHandlerType(GeneratedAssembly assembly, CompiledSourceType handlerType);
    private void buildHandlerMethod(GeneratedType compiledType);
    private string buildIncludeReader(MemberInfo member);
    private void configureCommandMethod(GeneratedType compiledType);
    private Type determineBaseType(CompiledSourceType sourceType);
    private CompiledSourceType determineHandlerType();
}
internal enum Marten.Internal.CompiledQueries.CompiledSourceType : Enum {
    public int value__;
    public static CompiledSourceType Stateless;
    public static CompiledSourceType Complex;
    public static CompiledSourceType Cloneable;
}
public abstract class Marten.Internal.CompiledQueries.ComplexCompiledQuery`2 : object {
    private IMaybeStatefulHandler _inner;
    protected TQuery _query;
    public ComplexCompiledQuery`2(IMaybeStatefulHandler inner, TQuery query);
    public abstract virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual Task`1<int> StreamJson(Stream stream, DbDataReader reader, CancellationToken token);
    public sealed virtual TOut Handle(DbDataReader reader, IMartenSession session);
    public sealed virtual Task`1<TOut> HandleAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
    public abstract virtual IQueryHandler`1<TOut> BuildHandler(IMartenSession session);
    protected string StartsWith(string value);
    protected string ContainsString(string value);
    protected string EndsWith(string value);
}
internal class Marten.Internal.CompiledQueries.EnumParameterFinder : object {
    public sealed virtual bool Matches(Type memberType);
    public sealed virtual bool AreValuesUnique(object query, CompiledQueryPlan plan);
    public sealed virtual Queue`1<object> UniqueValueQueue(Type type);
}
internal class Marten.Internal.CompiledQueries.FieldQueryMember`1 : QueryMember`1<T> {
    private FieldInfo _field;
    public FieldQueryMember`1(FieldInfo field);
    public virtual T GetValue(object query);
    public virtual void SetValue(object query, T value);
    public virtual bool CanWrite();
    public virtual string ToString();
}
public interface Marten.Internal.CompiledQueries.ICompiledQueryAwareFilter {
    public string ParameterName { get; }
    public abstract virtual bool TryMatchValue(object value, MemberInfo member);
    public abstract virtual void GenerateCode(GeneratedMethod method, int parameterIndex, string parametersVariableName);
    public abstract virtual string get_ParameterName();
}
public interface Marten.Internal.CompiledQueries.ICompiledQuerySource {
    public Type QueryType { get; }
    public abstract virtual Type get_QueryType();
    public abstract virtual IQueryHandler Build(object query, IMartenSession session);
}
internal interface Marten.Internal.CompiledQueries.IParameterFinder {
    public abstract virtual bool Matches(Type memberType);
    public abstract virtual bool AreValuesUnique(object query, CompiledQueryPlan plan);
    public abstract virtual Queue`1<object> UniqueValueQueue(Type type);
}
public interface Marten.Internal.CompiledQueries.IQueryMember {
    public Type Type { get; }
    public MemberInfo Member { get; }
    public abstract virtual Type get_Type();
    public abstract virtual MemberInfo get_Member();
    public abstract virtual bool CanWrite();
    public abstract virtual void StoreValue(object query);
    public abstract virtual bool TryMatch(NpgsqlParameter parameter, StoreOptions options, ICompiledQueryAwareFilter[] filters, ICompiledQueryAwareFilter& filter);
    public abstract virtual void TryWriteValue(UniqueValueSource valueSource, object query);
    public abstract virtual object GetValueAsObject(object query);
}
internal interface Marten.Internal.CompiledQueries.IQueryMember`1 {
    public T Value { get; }
    public abstract virtual T get_Value();
    public abstract virtual T GetValue(object query);
    public abstract virtual void SetValue(object query, T value);
}
internal class Marten.Internal.CompiledQueries.ParameterUsage : object {
    [CompilerGeneratedAttribute]
private bool <IsTenant>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private NpgsqlParameter <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryMember <Member>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ICompiledQueryAwareFilter <Filter>k__BackingField;
    public bool IsTenant { get; public set; }
    public int Index { get; }
    public NpgsqlParameter Parameter { get; }
    public string Name { get; }
    public IQueryMember Member { get; public set; }
    [NullableAttribute("2")]
public ICompiledQueryAwareFilter Filter { get; public set; }
    public ParameterUsage(int index, string name, object value, Nullable`1<NpgsqlDbType> dbType);
    [CompilerGeneratedAttribute]
public bool get_IsTenant();
    [CompilerGeneratedAttribute]
public void set_IsTenant(bool value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public NpgsqlParameter get_Parameter();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IQueryMember get_Member();
    [CompilerGeneratedAttribute]
public void set_Member(IQueryMember value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ICompiledQueryAwareFilter get_Filter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Filter(ICompiledQueryAwareFilter value);
    public void GenerateCode(GeneratedMethod method, string parametersVariableName, StoreOptions storeOptions);
    private void generateSimpleCode(GeneratedMethod method, MemberInfo member, Type memberType, string parametersVariableName);
    private void generateEnumCode(GeneratedMethod method, StoreOptions storeOptions, MemberInfo member, string parametersVariableName);
}
internal class Marten.Internal.CompiledQueries.PropertyQueryMember`1 : QueryMember`1<T> {
    private PropertyInfo _property;
    public PropertyQueryMember`1(PropertyInfo property);
    public virtual bool CanWrite();
    public virtual T GetValue(object query);
    public virtual void SetValue(object query, T value);
    public virtual string ToString();
}
internal class Marten.Internal.CompiledQueries.QueryCompiler : object {
    internal static IList`1<IParameterFinder> Finders;
    private static QueryCompiler();
    private static void forType(Func`2<int, T[]> uniqueValues);
    public static CompiledQueryPlan BuildQueryPlan(QuerySession session, Type queryType, StoreOptions storeOptions);
    public static CompiledQueryPlan BuildQueryPlan(QuerySession session, ICompiledQuery`2<TDoc, TOut> query);
    internal static LinqQueryParser BuildDatabaseCommand(QuerySession session, ICompiledQuery`2<TDoc, TOut> queryTemplate, QueryStatistics statistics, CompiledQueryPlan queryPlan);
    private static void eliminateStringNulls(object query);
    private static void assertValidityOfQueryType(CompiledQueryPlan plan, Type type);
}
internal abstract class Marten.Internal.CompiledQueries.QueryMember`1 : object {
    [CompilerGeneratedAttribute]
private string <Mask>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <Member>k__BackingField;
    public string Mask { get; public set; }
    public Type Type { get; }
    public T Value { get; private set; }
    public MemberInfo Member { get; }
    protected QueryMember`1(MemberInfo member);
    [CompilerGeneratedAttribute]
public string get_Mask();
    [CompilerGeneratedAttribute]
public void set_Mask(string value);
    public sealed virtual Type get_Type();
    public sealed virtual object GetValueAsObject(object query);
    public abstract virtual T GetValue(object query);
    public abstract virtual void SetValue(object query, T value);
    public sealed virtual void StoreValue(object query);
    public sealed virtual bool TryMatch(NpgsqlParameter parameter, StoreOptions options, ICompiledQueryAwareFilter[] filters, ICompiledQueryAwareFilter& filter);
    public sealed virtual void TryWriteValue(UniqueValueSource valueSource, object query);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(T value);
    public abstract virtual bool CanWrite();
    [CompilerGeneratedAttribute]
public sealed virtual MemberInfo get_Member();
    private bool tryToFind(NpgsqlParameter parameter, ICompiledQueryAwareFilter[] filters, object value, ICompiledQueryAwareFilter& filterUsed);
}
internal class Marten.Internal.CompiledQueries.SimpleParameterFinder`1 : object {
    private Func`2<int, T[]> _uniqueValues;
    public Type DotNetType { get; }
    public SimpleParameterFinder`1(Func`2<int, T[]> uniqueValues);
    public Type get_DotNetType();
    public sealed virtual Queue`1<object> UniqueValueQueue(Type type);
    public sealed virtual bool Matches(Type memberType);
    public sealed virtual bool AreValuesUnique(object query, CompiledQueryPlan plan);
    private static IQueryMember`1[] findMembers(CompiledQueryPlan plan);
}
public abstract class Marten.Internal.CompiledQueries.StatelessCompiledQuery`2 : object {
    private IQueryHandler`1<TOut> _inner;
    protected TQuery _query;
    public StatelessCompiledQuery`2(IQueryHandler`1<TOut> inner, TQuery query);
    public abstract virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual Task`1<int> StreamJson(Stream stream, DbDataReader reader, CancellationToken token);
    public sealed virtual TOut Handle(DbDataReader reader, IMartenSession session);
    public sealed virtual Task`1<TOut> HandleAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
    protected string StartsWith(string value);
    protected string ContainsString(string value);
    protected string EndsWith(string value);
}
public class Marten.Internal.CompiledQueries.UniqueValueSource : object {
    private Dictionary`2<Type, Queue`1<object>> _values;
    public object GetValue(Type type);
    public Object[] ArgsFor(ConstructorInfo constructor);
    [CompilerGeneratedAttribute]
private object <ArgsFor>b__2_0(ParameterInfo parameter);
}
public class Marten.Internal.DirtyTracking.ChangeTracker`1 : object {
    private T _document;
    private string _json;
    public object Document { get; }
    public ChangeTracker`1(IMartenSession session, T document);
    public sealed virtual object get_Document();
    public sealed virtual bool DetectChanges(IMartenSession session, IStorageOperation& operation);
    public sealed virtual void Reset(IMartenSession session);
}
public interface Marten.Internal.DirtyTracking.IChangeTracker {
    public object Document { get; }
    public abstract virtual object get_Document();
    public abstract virtual bool DetectChanges(IMartenSession session, IStorageOperation& operation);
    public abstract virtual void Reset(IMartenSession session);
}
public interface Marten.Internal.IConfigureMarten`1 {
}
[NullableContextAttribute("1")]
public interface Marten.Internal.IMartenSession {
    public ISerializer Serializer { get; }
    public Dictionary`2<Type, object> ItemMap { get; }
    public string TenantId { get; }
    public IMartenDatabase Database { get; }
    public VersionTracker Versions { get; }
    public StoreOptions Options { get; }
    public IList`1<IChangeTracker> ChangeTrackers { get; }
    public ConcurrencyChecks Concurrency { get; }
    [NullableAttribute("2")]
public string CausationId { get; public set; }
    [NullableAttribute("2")]
public string CorrelationId { get; public set; }
    [NullableAttribute("2")]
public string LastModifiedBy { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, object> Headers { get; }
    public abstract virtual ISerializer get_Serializer();
    public abstract virtual Dictionary`2<Type, object> get_ItemMap();
    public abstract virtual string get_TenantId();
    public abstract virtual IMartenDatabase get_Database();
    public abstract virtual VersionTracker get_Versions();
    public abstract virtual StoreOptions get_Options();
    public abstract virtual IList`1<IChangeTracker> get_ChangeTrackers();
    public abstract virtual ConcurrencyChecks get_Concurrency();
    [NullableContextAttribute("2")]
public abstract virtual string get_CausationId();
    [NullableContextAttribute("2")]
public abstract virtual void set_CausationId(string value);
    [NullableContextAttribute("2")]
public abstract virtual string get_CorrelationId();
    [NullableContextAttribute("2")]
public abstract virtual void set_CorrelationId(string value);
    [NullableContextAttribute("2")]
public abstract virtual string get_LastModifiedBy();
    [NullableContextAttribute("2")]
public abstract virtual void set_LastModifiedBy(string value);
    public abstract virtual Dictionary`2<string, object> get_Headers();
    public abstract virtual IDocumentStorage StorageFor(Type documentType);
    public abstract virtual void MarkAsAddedForStorage(object id, object document);
    public abstract virtual void MarkAsDocumentLoaded(object id, object document);
    public abstract virtual IDocumentStorage`1<T> StorageFor();
    public abstract virtual IEventStorage EventStorage();
    public abstract virtual string NextTempTableName();
    public abstract virtual DbDataReader ExecuteReader(NpgsqlCommand command);
    public abstract virtual Task`1<DbDataReader> ExecuteReaderAsync(NpgsqlCommand command, CancellationToken token);
}
[NullableContextAttribute("1")]
public interface Marten.Internal.IProviderGraph {
    public abstract virtual DocumentProvider`1<T> StorageFor();
    public abstract virtual void Append(DocumentProvider`1<T> provider);
}
internal interface Marten.Internal.IStoreConfig {
    public SecondaryDocumentStores Parent { get; public set; }
    public abstract virtual SecondaryDocumentStores get_Parent();
    public abstract virtual void set_Parent(SecondaryDocumentStores value);
    public abstract virtual StoreOptions BuildStoreOptions(IServiceProvider provider);
}
[NullableContextAttribute("1")]
public interface Marten.Internal.IUpdateBatch {
    public abstract virtual IReadOnlyList`1<OperationPage> BuildPages(IMartenSession session);
    public abstract virtual IReadOnlyList`1<Type> DocumentTypes();
    public abstract virtual Task PostUpdateAsync(IMartenSession session);
    public abstract virtual Task PreUpdateAsync(IMartenSession session);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Marten.Internal.OpenTelemetry.MartenTracing : object {
    public static string TenantId;
    public static string EventType;
    [CompilerGeneratedAttribute]
private static ActivitySource <ActivitySource>k__BackingField;
    internal static ActivitySource ActivitySource { get; }
    private static MartenTracing();
    [CompilerGeneratedAttribute]
internal static ActivitySource get_ActivitySource();
    [NullableContextAttribute("2")]
public static Activity StartConnectionActivity(Activity parentActivity, ActivityTagsCollection tags);
    [NullableContextAttribute("2")]
public static Activity StartActivity(string spanName, Activity parentActivity, ActivityTagsCollection tags, ActivityKind activityKind);
}
internal class Marten.Internal.Operations.ExecuteSqlStorageOperation : object {
    private string _commandText;
    private Object[] _parameterValues;
    public Type DocumentType { get; }
    public ExecuteSqlStorageOperation(string commandText, Object[] parameterValues);
    public sealed virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual Type get_DocumentType();
    public sealed virtual void Postprocess(DbDataReader reader, IList`1<Exception> exceptions);
    public sealed virtual Task PostprocessAsync(DbDataReader reader, IList`1<Exception> exceptions, CancellationToken token);
    public sealed virtual OperationRole Role();
}
[NullableContextAttribute("1")]
public interface Marten.Internal.Operations.IDocumentStorageOperation {
    public object Document { get; }
    public abstract virtual object get_Document();
    public abstract virtual IChangeTracker ToTracker(IMartenSession session);
}
public interface Marten.Internal.Operations.IRevisionedOperation {
    public int Revision { get; public set; }
    public bool IgnoreConcurrencyViolation { get; public set; }
    public abstract virtual int get_Revision();
    public abstract virtual void set_Revision(int value);
    public abstract virtual bool get_IgnoreConcurrencyViolation();
    public abstract virtual void set_IgnoreConcurrencyViolation(bool value);
}
[NullableContextAttribute("1")]
public interface Marten.Internal.Operations.IStorageOperation {
    public Type DocumentType { get; }
    public abstract virtual Type get_DocumentType();
    public abstract virtual void Postprocess(DbDataReader reader, IList`1<Exception> exceptions);
    public abstract virtual Task PostprocessAsync(DbDataReader reader, IList`1<Exception> exceptions, CancellationToken token);
    public abstract virtual OperationRole Role();
}
public enum Marten.Internal.Operations.OperationRole : Enum {
    public int value__;
    public static OperationRole Upsert;
    public static OperationRole Insert;
    public static OperationRole Update;
    public static OperationRole Deletion;
    public static OperationRole Patch;
    public static OperationRole Other;
    public static OperationRole Events;
}
public abstract class Marten.Internal.Operations.StorageOperation`2 : object {
    private static string ExpectedMessage;
    private T _document;
    protected TId _id;
    private string _tableName;
    private Dictionary`2<TId, Guid> _versions;
    protected Guid _version;
    [CompilerGeneratedAttribute]
private int <Revision>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreConcurrencyViolation>k__BackingField;
    public int Revision { get; public set; }
    public bool IgnoreConcurrencyViolation { get; public set; }
    public TId Id { get; }
    public object Document { get; }
    public Type DocumentType { get; }
    public StorageOperation`2(T document, TId id, Dictionary`2<TId, Guid> versions, DocumentMapping mapping);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Revision();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Revision(int value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IgnoreConcurrencyViolation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IgnoreConcurrencyViolation(bool value);
    public TId get_Id();
    public sealed virtual object get_Document();
    public sealed virtual IChangeTracker ToTracker(IMartenSession session);
    public sealed virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual Type get_DocumentType();
    public virtual void Postprocess(DbDataReader reader, IList`1<Exception> exceptions);
    public virtual Task PostprocessAsync(DbDataReader reader, IList`1<Exception> exceptions, CancellationToken token);
    public abstract virtual OperationRole Role();
    public abstract virtual NpgsqlDbType DbType();
    public abstract virtual void ConfigureParameters(IGroupedParameterBuilder parameterBuilder, ICommandBuilder builder, T document, IMartenSession session);
    protected void setVersionParameter(IGroupedParameterBuilder builder);
    protected void storeVersion();
    protected void setCurrentVersionParameter(IGroupedParameterBuilder builder);
    protected void setCurrentRevisionParameter(IGroupedParameterBuilder builder);
    protected bool postprocessConcurrency(DbDataReader reader, IList`1<Exception> exceptions);
    protected bool postprocessRevision(DbDataReader reader, IList`1<Exception> exceptions);
    [AsyncStateMachineAttribute("Marten.Internal.Operations.StorageOperation`2/<postprocessRevisionAsync>d__34")]
protected Task`1<bool> postprocessRevisionAsync(DbDataReader reader, IList`1<Exception> exceptions, CancellationToken token);
    protected void postprocessUpdate(DbDataReader reader, IList`1<Exception> exceptions);
    [AsyncStateMachineAttribute("Marten.Internal.Operations.StorageOperation`2/<postprocessUpdateAsync>d__36")]
protected Task postprocessUpdateAsync(DbDataReader reader, IList`1<Exception> exceptions, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Internal.Operations.StorageOperation`2/<postprocessConcurrencyAsync>d__37")]
protected Task`1<bool> postprocessConcurrencyAsync(DbDataReader reader, IList`1<Exception> exceptions, CancellationToken token);
    private void checkVersions(IList`1<Exception> exceptions, bool success);
    public sealed virtual bool TryTransform(Exception original, Exception& transformed);
    protected void setStringParameter(IGroupedParameterBuilder builder, string value);
    protected void setHeaderParameter(IGroupedParameterBuilder builder, IMartenSession session);
}
internal class Marten.Internal.Operations.TruncateTable : object {
    private DbObjectName _name;
    [CompilerGeneratedAttribute]
private Type <DocumentType>k__BackingField;
    public Type DocumentType { get; }
    public TruncateTable(DbObjectName name);
    public TruncateTable(Type documentType);
    public sealed virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_DocumentType();
    public sealed virtual void Postprocess(DbDataReader reader, IList`1<Exception> exceptions);
    public sealed virtual Task PostprocessAsync(DbDataReader reader, IList`1<Exception> exceptions, CancellationToken token);
    public sealed virtual OperationRole Role();
    protected bool Equals(TruncateTable other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Internal.ProviderGraph : object {
    private StoreOptions _options;
    private object _storageLock;
    private ImHashMap`2<Type, object> _storage;
    public ProviderGraph(StoreOptions options);
    public sealed virtual void Append(DocumentProvider`1<T> provider);
    public sealed virtual DocumentProvider`1<T> StorageFor();
    internal DocumentProvider`1<T> CreateDocumentProvider();
}
[ExtensionAttribute]
internal static class Marten.Internal.ProviderGraphExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static IDocumentStorage StorageFor(IProviderGraph providers, Type documentType);
}
internal class Marten.Internal.SecondaryDocumentStores : object {
    private List`1<IStoreConfig> _files;
    [CompilerGeneratedAttribute]
private IServiceProvider <Services>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChildNamespace>k__BackingField;
    public IServiceProvider Services { get; public set; }
    public string ChildNamespace { get; }
    public GenerationRules Rules { get; }
    [CompilerGeneratedAttribute]
public IServiceProvider get_Services();
    [CompilerGeneratedAttribute]
public void set_Services(IServiceProvider value);
    public sealed virtual IReadOnlyList`1<ICodeFile> BuildFiles();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ChildNamespace();
    public sealed virtual GenerationRules get_Rules();
    public void Add(IStoreConfig config);
}
internal class Marten.Internal.SecondaryStoreConfig`1 : object {
    private Func`2<IServiceProvider, StoreOptions> _configuration;
    private Type _storeType;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private SecondaryDocumentStores <Parent>k__BackingField;
    public string FileName { get; }
    public SecondaryDocumentStores Parent { get; public set; }
    public SecondaryStoreConfig`1(Func`2<IServiceProvider, StoreOptions> configuration);
    public sealed virtual void AssembleTypes(GeneratedAssembly assembly);
    public sealed virtual Task`1<bool> AttachTypes(GenerationRules rules, Assembly assembly, IServiceProvider services, string containingNamespace);
    public sealed virtual bool AttachTypesSynchronously(GenerationRules rules, Assembly assembly, IServiceProvider services, string containingNamespace);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FileName();
    [CompilerGeneratedAttribute]
public sealed virtual SecondaryDocumentStores get_Parent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Parent(SecondaryDocumentStores value);
    public sealed virtual StoreOptions BuildStoreOptions(IServiceProvider provider);
    public T Build(IServiceProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Internal.Sessions.AmbientTransactionLifetime : ConnectionLifetimeBase {
    private SessionOptions _options;
    [NullableAttribute("2")]
private NpgsqlConnection _connection;
    [CompilerGeneratedAttribute]
private bool <OwnsConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CommandTimeout>k__BackingField;
    public NpgsqlConnection Connection { get; }
    public bool OwnsConnection { get; }
    public int CommandTimeout { get; public set; }
    public AmbientTransactionLifetime(SessionOptions options);
    public sealed virtual NpgsqlConnection get_Connection();
    [CompilerGeneratedAttribute]
public bool get_OwnsConnection();
    [CompilerGeneratedAttribute]
public sealed virtual int get_CommandTimeout();
    [CompilerGeneratedAttribute]
public void set_CommandTimeout(int value);
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual void Dispose();
    public void Apply(NpgsqlCommand command);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.AmbientTransactionLifetime/<ApplyAsync>d__15")]
public Task ApplyAsync(NpgsqlCommand command, CancellationToken token);
    public void Apply(NpgsqlBatch batch);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.AmbientTransactionLifetime/<ApplyAsync>d__17")]
public Task ApplyAsync(NpgsqlBatch batch, CancellationToken token);
    public sealed virtual void BeginTransaction();
    public void EnsureConnected();
    public ValueTask EnsureConnectedAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.AmbientTransactionLifetime/<BeginTransactionAsync>d__21")]
public sealed virtual ValueTask BeginTransactionAsync(CancellationToken token);
    public sealed virtual int Execute(NpgsqlCommand cmd);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.AmbientTransactionLifetime/<ExecuteAsync>d__23")]
public sealed virtual Task`1<int> ExecuteAsync(NpgsqlCommand command, CancellationToken token);
    public sealed virtual DbDataReader ExecuteReader(NpgsqlCommand command);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.AmbientTransactionLifetime/<ExecuteReaderAsync>d__25")]
public sealed virtual Task`1<DbDataReader> ExecuteReaderAsync(NpgsqlCommand command, CancellationToken token);
    public sealed virtual DbDataReader ExecuteReader(NpgsqlBatch batch);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.AmbientTransactionLifetime/<ExecuteReaderAsync>d__27")]
public sealed virtual Task`1<DbDataReader> ExecuteReaderAsync(NpgsqlBatch batch, CancellationToken token);
    public sealed virtual void ExecuteBatchPages(IReadOnlyList`1<OperationPage> pages, List`1<Exception> exceptions);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.AmbientTransactionLifetime/<ExecuteBatchPagesAsync>d__29")]
public sealed virtual Task ExecuteBatchPagesAsync(IReadOnlyList`1<OperationPage> pages, List`1<Exception> exceptions, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Internal.Sessions.AutoClosingLifetime : ConnectionLifetimeBase {
    private SessionOptions _options;
    private IMartenDatabase _database;
    [CompilerGeneratedAttribute]
private int <CommandTimeout>k__BackingField;
    public int CommandTimeout { get; }
    public AutoClosingLifetime(SessionOptions options, StoreOptions storeOptions);
    [CompilerGeneratedAttribute]
public sealed virtual int get_CommandTimeout();
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual void Dispose();
    public sealed virtual int Execute(NpgsqlCommand cmd);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.AutoClosingLifetime/<ExecuteAsync>d__9")]
public sealed virtual Task`1<int> ExecuteAsync(NpgsqlCommand command, CancellationToken token);
    public sealed virtual DbDataReader ExecuteReader(NpgsqlCommand command);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.AutoClosingLifetime/<ExecuteReaderAsync>d__11")]
public sealed virtual Task`1<DbDataReader> ExecuteReaderAsync(NpgsqlCommand command, CancellationToken token);
    public sealed virtual DbDataReader ExecuteReader(NpgsqlBatch batch);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.AutoClosingLifetime/<ExecuteReaderAsync>d__13")]
public sealed virtual Task`1<DbDataReader> ExecuteReaderAsync(NpgsqlBatch batch, CancellationToken token);
    public sealed virtual void ExecuteBatchPages(IReadOnlyList`1<OperationPage> pages, List`1<Exception> exceptions);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.AutoClosingLifetime/<ExecuteBatchPagesAsync>d__15")]
public sealed virtual Task ExecuteBatchPagesAsync(IReadOnlyList`1<OperationPage> pages, List`1<Exception> exceptions, CancellationToken token);
    public sealed virtual IAlwaysConnectedLifetime Start();
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.AutoClosingLifetime/<StartAsync>d__17")]
public sealed virtual Task`1<IAlwaysConnectedLifetime> StartAsync(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Internal.Sessions.ConnectionLifetimeBase : object {
    [CompilerGeneratedAttribute]
private IMartenSessionLogger <Logger>k__BackingField;
    public IMartenSessionLogger Logger { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IMartenSessionLogger get_Logger();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Logger(IMartenSessionLogger value);
    protected void handleCommandException(NpgsqlCommand cmd, Exception e);
    protected void handleCommandException(NpgsqlBatch batch, Exception e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Internal.Sessions.DirtyCheckingDocumentSession : DocumentSessionBase {
    internal DocumentTracking TrackingMode { get; }
    internal DirtyCheckingDocumentSession(DocumentStore store, SessionOptions sessionOptions, IConnectionLifetime connection);
    internal virtual DocumentTracking get_TrackingMode();
    protected internal virtual IDocumentStorage`1<T> selectStorage(DocumentProvider`1<T> provider);
    protected internal virtual void processChangeTrackers();
    protected internal virtual void resetDirtyChecking();
    private void removeTrackerFor(T document);
    protected internal virtual void ejectById(long id);
    protected internal virtual void ejectById(int id);
    protected internal virtual void ejectById(Guid id);
    protected internal virtual void ejectById(string id);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Marten.Internal.Sessions.DocumentSessionBase : QuerySession {
    internal ISessionWorkTracker _workTracker;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, NestedTenantSession> _byTenant;
    internal ITenancy Tenancy { get; }
    internal ISessionWorkTracker WorkTracker { get; }
    public IUnitOfWork PendingChanges { get; }
    public IEventStore Events { get; }
    internal DocumentSessionBase(DocumentStore store, SessionOptions sessionOptions, IConnectionLifetime connection);
    internal DocumentSessionBase(DocumentStore store, SessionOptions sessionOptions, IConnectionLifetime connection, ISessionWorkTracker workTracker, Tenant tenant);
    internal ValueTask`1<IMessageBatch> CurrentMessageBatch();
    internal ITenancy get_Tenancy();
    internal ISessionWorkTracker get_WorkTracker();
    public sealed virtual void EjectAllPendingChanges();
    public sealed virtual void Store(IEnumerable`1<T> entities);
    public sealed virtual void Store(T[] entities);
    public sealed virtual void UpdateExpectedVersion(T entity, Guid version);
    public sealed virtual void UpdateRevision(T entity, int revision);
    public sealed virtual void TryUpdateRevision(T entity, int revision);
    public sealed virtual void Insert(IEnumerable`1<T> entities);
    public sealed virtual void Insert(T[] entities);
    public sealed virtual void Update(IEnumerable`1<T> entities);
    public sealed virtual void Update(T[] entities);
    public sealed virtual void InsertObjects(IEnumerable`1<object> documents);
    public sealed virtual void QueueSqlCommand(string sql, Object[] parameterValues);
    public sealed virtual IUnitOfWork get_PendingChanges();
    public sealed virtual void StoreObjects(IEnumerable`1<object> documents);
    public sealed virtual IEventStore get_Events();
    public sealed virtual void QueueOperation(IStorageOperation storageOperation);
    public virtual void Eject(T document);
    public virtual void EjectAllOfType(Type type);
    public sealed virtual void SetHeader(string key, object value);
    public sealed virtual object GetHeader(string key);
    public sealed virtual ITenantOperations ForTenant(string tenantId);
    protected virtual IQueryEventStore CreateEventStore(DocumentStore store, Tenant tenant);
    protected internal abstract virtual void ejectById(long id);
    protected internal abstract virtual void ejectById(int id);
    protected internal abstract virtual void ejectById(Guid id);
    protected internal abstract virtual void ejectById(string id);
    protected internal virtual void processChangeTrackers();
    protected internal virtual void resetDirtyChecking();
    private void store(IEnumerable`1<T> entities);
    private void storeEntity(T entity, IDocumentStorage`1<T> storage);
    public void EjectPatchedTypes(IUnitOfWork changes);
    public sealed virtual void Delete(T entity);
    public sealed virtual void Delete(int id);
    public sealed virtual void Delete(long id);
    public sealed virtual void Delete(object id);
    public sealed virtual void Delete(Guid id);
    public sealed virtual void Delete(string id);
    public sealed virtual void DeleteWhere(Expression`1<Func`2<T, bool>> expression);
    public sealed virtual void DeleteObjects(IEnumerable`1<object> documents);
    public sealed virtual void HardDelete(T entity);
    public sealed virtual void HardDelete(int id);
    public sealed virtual void HardDelete(long id);
    public sealed virtual void HardDelete(Guid id);
    public sealed virtual void HardDelete(string id);
    public sealed virtual void HardDeleteWhere(Expression`1<Func`2<T, bool>> expression);
    public sealed virtual void UndoDeleteWhere(Expression`1<Func`2<T, bool>> expression);
    public sealed virtual void SaveChanges();
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.DocumentSessionBase/<SaveChangesAsync>d__64")]
public sealed virtual Task SaveChangesAsync(CancellationToken token);
    private IEnumerable`1<Type> operationDocumentTypes();
    internal void ExecuteBatch(IUpdateBatch batch);
    private void tryApplyTombstoneBatch();
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.DocumentSessionBase/<ExecuteBatchAsync>d__69")]
internal Task ExecuteBatchAsync(IUpdateBatch batch, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.DocumentSessionBase/<executeAfterCommitListeners>d__70")]
private Task executeAfterCommitListeners(IUpdateBatch batch);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.DocumentSessionBase/<executeBeforeCommitListeners>d__71")]
private Task executeBeforeCommitListeners(IUpdateBatch batch);
    protected virtual Task tryApplyTombstoneEventsAsync(CancellationToken token);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <InsertObjects>b__19_2(IGrouping`2<Type, object> group);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Internal.Sessions.EventTracingConnectionLifetime : object {
    private static string MartenCommandExecutionStarted;
    private static string MartenBatchExecutionStarted;
    private static string MartenBatchPagesExecutionStarted;
    private IConnectionLifetime _innerConnectionLifetime;
    private OpenTelemetryOptions _telemetryOptions;
    [NullableAttribute("2")]
private Activity _databaseActivity;
    [CompilerGeneratedAttribute]
private IMartenSessionLogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CommandTimeout>k__BackingField;
    public IMartenSessionLogger Logger { get; public set; }
    public int CommandTimeout { get; }
    public EventTracingConnectionLifetime(IConnectionLifetime innerConnectionLifetime, string tenantId, OpenTelemetryOptions telemetryOptions);
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual IMartenSessionLogger get_Logger();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Logger(IMartenSessionLogger value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_CommandTimeout();
    public sealed virtual int Execute(NpgsqlCommand cmd);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.EventTracingConnectionLifetime/<ExecuteAsync>d__17")]
public sealed virtual Task`1<int> ExecuteAsync(NpgsqlCommand command, CancellationToken token);
    public sealed virtual DbDataReader ExecuteReader(NpgsqlCommand command);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.EventTracingConnectionLifetime/<ExecuteReaderAsync>d__19")]
public sealed virtual Task`1<DbDataReader> ExecuteReaderAsync(NpgsqlCommand command, CancellationToken token);
    public sealed virtual DbDataReader ExecuteReader(NpgsqlBatch batch);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.EventTracingConnectionLifetime/<ExecuteReaderAsync>d__21")]
public sealed virtual Task`1<DbDataReader> ExecuteReaderAsync(NpgsqlBatch batch, CancellationToken token);
    public sealed virtual void ExecuteBatchPages(IReadOnlyList`1<OperationPage> pages, List`1<Exception> exceptions);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.EventTracingConnectionLifetime/<ExecuteBatchPagesAsync>d__23")]
public sealed virtual Task ExecuteBatchPagesAsync(IReadOnlyList`1<OperationPage> pages, List`1<Exception> exceptions, CancellationToken token);
    private void writeVerboseEvents(IReadOnlyList`1<OperationPage> pages);
}
internal class Marten.Internal.Sessions.ExternalTransaction : ConnectionLifetimeBase {
    private SessionOptions _options;
    [CompilerGeneratedAttribute]
private int <CommandTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private NpgsqlTransaction <Transaction>k__BackingField;
    [CompilerGeneratedAttribute]
private NpgsqlConnection <Connection>k__BackingField;
    public int CommandTimeout { get; public set; }
    public NpgsqlTransaction Transaction { get; }
    public NpgsqlConnection Connection { get; }
    public ExternalTransaction(SessionOptions options);
    [CompilerGeneratedAttribute]
public sealed virtual int get_CommandTimeout();
    [CompilerGeneratedAttribute]
public void set_CommandTimeout(int value);
    [CompilerGeneratedAttribute]
public NpgsqlTransaction get_Transaction();
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual void Dispose();
    public void Apply(NpgsqlCommand command);
    public Task ApplyAsync(NpgsqlCommand command, CancellationToken token);
    public void Apply(NpgsqlBatch batch);
    public Task ApplyAsync(NpgsqlBatch batch, CancellationToken token);
    public void Commit();
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.ExternalTransaction/<CommitAsync>d__16")]
public Task CommitAsync(CancellationToken token);
    public void Rollback();
    public Task RollbackAsync(CancellationToken token);
    [CompilerGeneratedAttribute]
public sealed virtual NpgsqlConnection get_Connection();
    public sealed virtual void BeginTransaction();
    public sealed virtual ValueTask BeginTransactionAsync(CancellationToken token);
    public void EnsureConnected();
    public sealed virtual int Execute(NpgsqlCommand cmd);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.ExternalTransaction/<ExecuteAsync>d__26")]
public sealed virtual Task`1<int> ExecuteAsync(NpgsqlCommand command, CancellationToken token);
    public sealed virtual DbDataReader ExecuteReader(NpgsqlCommand command);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.ExternalTransaction/<ExecuteReaderAsync>d__28")]
public sealed virtual Task`1<DbDataReader> ExecuteReaderAsync(NpgsqlCommand command, CancellationToken token);
    public sealed virtual DbDataReader ExecuteReader(NpgsqlBatch batch);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.ExternalTransaction/<ExecuteReaderAsync>d__30")]
public sealed virtual Task`1<DbDataReader> ExecuteReaderAsync(NpgsqlBatch batch, CancellationToken token);
    public sealed virtual void ExecuteBatchPages(IReadOnlyList`1<OperationPage> pages, List`1<Exception> exceptions);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.ExternalTransaction/<ExecuteBatchPagesAsync>d__32")]
public sealed virtual Task ExecuteBatchPagesAsync(IReadOnlyList`1<OperationPage> pages, List`1<Exception> exceptions, CancellationToken token);
}
public interface Marten.Internal.Sessions.IAlwaysConnectedLifetime {
    [NullableAttribute("1")]
public NpgsqlConnection Connection { get; }
    [NullableContextAttribute("1")]
public abstract virtual NpgsqlConnection get_Connection();
    public abstract virtual void BeginTransaction();
    public abstract virtual ValueTask BeginTransactionAsync(CancellationToken token);
}
[NullableContextAttribute("1")]
public interface Marten.Internal.Sessions.IConnectionLifetime {
    public IMartenSessionLogger Logger { get; public set; }
    public int CommandTimeout { get; }
    public abstract virtual IMartenSessionLogger get_Logger();
    public abstract virtual void set_Logger(IMartenSessionLogger value);
    public abstract virtual int get_CommandTimeout();
    public abstract virtual int Execute(NpgsqlCommand cmd);
    public abstract virtual Task`1<int> ExecuteAsync(NpgsqlCommand command, CancellationToken token);
    public abstract virtual DbDataReader ExecuteReader(NpgsqlCommand command);
    public abstract virtual Task`1<DbDataReader> ExecuteReaderAsync(NpgsqlCommand command, CancellationToken token);
    public abstract virtual DbDataReader ExecuteReader(NpgsqlBatch batch);
    public abstract virtual Task`1<DbDataReader> ExecuteReaderAsync(NpgsqlBatch batch, CancellationToken token);
    public abstract virtual void ExecuteBatchPages(IReadOnlyList`1<OperationPage> pages, List`1<Exception> exceptions);
    public abstract virtual Task ExecuteBatchPagesAsync(IReadOnlyList`1<OperationPage> pages, List`1<Exception> exceptions, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Internal.Sessions.IdentityMapDocumentSession : DocumentSessionBase {
    internal DocumentTracking TrackingMode { get; }
    internal IdentityMapDocumentSession(DocumentStore store, SessionOptions sessionOptions, IConnectionLifetime connection);
    internal virtual DocumentTracking get_TrackingMode();
    protected internal virtual IDocumentStorage`1<T> selectStorage(DocumentProvider`1<T> provider);
    protected internal virtual void ejectById(long id);
    protected internal virtual void ejectById(int id);
    protected internal virtual void ejectById(Guid id);
    protected internal virtual void ejectById(string id);
}
[NullableContextAttribute("1")]
public interface Marten.Internal.Sessions.ITransactionStarter {
    public abstract virtual IAlwaysConnectedLifetime Start();
    public abstract virtual Task`1<IAlwaysConnectedLifetime> StartAsync(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Internal.Sessions.LightweightSession : DocumentSessionBase {
    internal DocumentTracking TrackingMode { get; }
    internal LightweightSession(DocumentStore store, SessionOptions sessionOptions, IConnectionLifetime connection);
    internal virtual DocumentTracking get_TrackingMode();
    protected internal virtual IDocumentStorage`1<T> selectStorage(DocumentProvider`1<T> provider);
    public virtual void Eject(T document);
    public virtual void EjectAllOfType(Type type);
    protected internal virtual void ejectById(long id);
    protected internal virtual void ejectById(int id);
    protected internal virtual void ejectById(Guid id);
    protected internal virtual void ejectById(string id);
    [NullableContextAttribute("2")]
public virtual void UseIdentityMapFor();
}
internal class Marten.Internal.Sessions.NestedTenantQuerySession : QuerySession {
    private QuerySession _parent;
    public IQuerySession Parent { get; }
    internal NestedTenantQuerySession(QuerySession parent, Tenant tenant);
    public sealed virtual IQuerySession get_Parent();
    protected internal virtual IDocumentStorage`1<T> selectStorage(DocumentProvider`1<T> provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Internal.Sessions.NestedTenantSession : DocumentSessionBase {
    private DocumentSessionBase _parent;
    public IDocumentSession Parent { get; }
    internal NestedTenantSession(DocumentSessionBase parent, Tenant tenant);
    public sealed virtual IDocumentSession get_Parent();
    protected internal virtual void ejectById(long id);
    protected internal virtual void ejectById(int id);
    protected internal virtual void ejectById(Guid id);
    protected internal virtual void ejectById(string id);
    protected internal virtual void processChangeTrackers();
    protected internal virtual void resetDirtyChecking();
    protected internal virtual IDocumentStorage`1<T> selectStorage(DocumentProvider`1<T> provider);
    public virtual void Dispose();
    public virtual ValueTask DisposeAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Internal.Sessions.OperationPage : object {
    private IMartenSession _session;
    private BatchBuilder _builder;
    private List`1<IStorageOperation> _operations;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; private set; }
    public IReadOnlyList`1<IStorageOperation> Operations { get; }
    public OperationPage(IMartenSession session);
    public OperationPage(IMartenSession session, IReadOnlyList`1<IStorageOperation> operations);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public IReadOnlyList`1<IStorageOperation> get_Operations();
    public void Append(IStorageOperation operation);
    public NpgsqlBatch Compile();
    public void ReleaseSession();
    public void ApplyCallbacks(DbDataReader reader, IList`1<Exception> exceptions);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.OperationPage/<ApplyCallbacksAsync>d__15")]
public Task ApplyCallbacksAsync(DbDataReader reader, IList`1<Exception> exceptions, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Internal.Sessions.QuerySession : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<Type, object> <ItemMap>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IChangeTracker> <ChangeTrackers>k__BackingField;
    private DocumentStore _store;
    private ResiliencePipeline _resilience;
    [CompilerGeneratedAttribute]
private ISerializer <Serializer>k__BackingField;
    [CompilerGeneratedAttribute]
private StoreOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryEventStore <Events>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IDocumentSessionListener> <Listeners>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionOptions <SessionOptions>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private IMartenDatabase <Database>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrencyChecks <Concurrency>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RequestCount>k__BackingField;
    private bool _disposed;
    internal IConnectionLifetime _connection;
    [CompilerGeneratedAttribute]
private VersionTracker <Versions>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <CausationId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <CorrelationId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <LastModifiedBy>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Headers>k__BackingField;
    private int _tableNumber;
    protected IProviderGraph _providers;
    private ImHashMap`2<Type, IDocumentStorage> _byType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, NestedTenantQuerySession> _byTenant;
    public Dictionary`2<Type, object> ItemMap { get; internal set; }
    public IList`1<IChangeTracker> ChangeTrackers { get; }
    internal DocumentTracking TrackingMode { get; }
    public ISerializer Serializer { get; }
    public StoreOptions Options { get; }
    public IQueryEventStore Events { get; }
    public IList`1<IDocumentSessionListener> Listeners { get; }
    internal SessionOptions SessionOptions { get; }
    [NullableAttribute("0")]
public IMartenDatabase Database { get; protected set; }
    [NullableAttribute("0")]
public string TenantId { get; protected set; }
    public ConcurrencyChecks Concurrency { get; protected set; }
    public NpgsqlConnection Connection { get; }
    public IMartenSessionLogger Logger { get; public set; }
    public int RequestCount { get; public set; }
    public IDocumentStore DocumentStore { get; }
    public IAdvancedSql AdvancedSql { get; }
    public IJsonLoader Json { get; }
    public VersionTracker Versions { get; internal set; }
    [NullableAttribute("2")]
public string CausationId { get; public set; }
    [NullableAttribute("2")]
public string CorrelationId { get; public set; }
    [NullableAttribute("2")]
public string LastModifiedBy { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, object> Headers { get; protected set; }
    internal QuerySession(DocumentStore store, SessionOptions sessionOptions, IConnectionLifetime connection, Tenant tenant);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<Marten-IAdvancedSql-QueryAsync>d__0`1")]
private sealed virtual override Task`1<IReadOnlyList`1<T>> Marten.IAdvancedSql.QueryAsync(string sql, CancellationToken token, Object[] parameters);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<Marten-IAdvancedSql-QueryAsync>d__1`2")]
private sealed virtual override Task`1<IReadOnlyList`1<ValueTuple`2<T1, T2>>> Marten.IAdvancedSql.QueryAsync(string sql, CancellationToken token, Object[] parameters);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<Marten-IAdvancedSql-QueryAsync>d__2`3")]
private sealed virtual override Task`1<IReadOnlyList`1<ValueTuple`3<T1, T2, T3>>> Marten.IAdvancedSql.QueryAsync(string sql, CancellationToken token, Object[] parameters);
    [NullableContextAttribute("0")]
private sealed virtual override IReadOnlyList`1<T> Marten.IAdvancedSql.Query(string sql, Object[] parameters);
    [NullableContextAttribute("0")]
private sealed virtual override IReadOnlyList`1<ValueTuple`2<T1, T2>> Marten.IAdvancedSql.Query(string sql, Object[] parameters);
    [NullableContextAttribute("0")]
private sealed virtual override IReadOnlyList`1<ValueTuple`3<T1, T2, T3>> Marten.IAdvancedSql.Query(string sql, Object[] parameters);
    [NullableContextAttribute("0")]
[AsyncIteratorStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<Marten-IAdvancedSql-StreamAsync>d__6`1")]
private sealed virtual override IAsyncEnumerable`1<T> Marten.IAdvancedSql.StreamAsync(string sql, CancellationToken token, Object[] parameters);
    [NullableContextAttribute("0")]
[AsyncIteratorStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<Marten-IAdvancedSql-StreamAsync>d__7`2")]
private sealed virtual override IAsyncEnumerable`1<ValueTuple`2<T1, T2>> Marten.IAdvancedSql.StreamAsync(string sql, CancellationToken token, Object[] parameters);
    [NullableContextAttribute("0")]
[AsyncIteratorStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<Marten-IAdvancedSql-StreamAsync>d__8`3")]
private sealed virtual override IAsyncEnumerable`1<ValueTuple`3<T1, T2, T3>> Marten.IAdvancedSql.StreamAsync(string sql, CancellationToken token, Object[] parameters);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<Type, object> get_ItemMap();
    [CompilerGeneratedAttribute]
internal void set_ItemMap(Dictionary`2<Type, object> value);
    public sealed virtual void MarkAsAddedForStorage(object id, object document);
    public sealed virtual void MarkAsDocumentLoaded(object id, object document);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IChangeTracker> get_ChangeTrackers();
    internal virtual DocumentTracking get_TrackingMode();
    [CompilerGeneratedAttribute]
public sealed virtual ISerializer get_Serializer();
    [CompilerGeneratedAttribute]
public sealed virtual StoreOptions get_Options();
    [CompilerGeneratedAttribute]
public sealed virtual IQueryEventStore get_Events();
    protected virtual IQueryEventStore CreateEventStore(DocumentStore store, Tenant tenant);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IDocumentSessionListener> get_Listeners();
    [CompilerGeneratedAttribute]
internal SessionOptions get_SessionOptions();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public sealed virtual IMartenDatabase get_Database();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
protected void set_Database(IMartenDatabase value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public sealed virtual string get_TenantId();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
protected void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ConcurrencyChecks get_Concurrency();
    [CompilerGeneratedAttribute]
protected void set_Concurrency(ConcurrencyChecks value);
    public sealed virtual NpgsqlConnection get_Connection();
    public sealed virtual IMartenSessionLogger get_Logger();
    public sealed virtual void set_Logger(IMartenSessionLogger value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_RequestCount();
    [CompilerGeneratedAttribute]
public void set_RequestCount(int value);
    public sealed virtual IDocumentStore get_DocumentStore();
    public sealed virtual IAdvancedSql get_AdvancedSql();
    public sealed virtual Task`1<T> QueryByPlanAsync(IQueryPlan`1<T> plan, CancellationToken token);
    public virtual void Dispose();
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<DisposeAsync>d__67")]
public virtual ValueTask DisposeAsync();
    protected void assertNotDisposed();
    public sealed virtual int Execute(NpgsqlCommand cmd);
    public sealed virtual Task`1<int> ExecuteAsync(NpgsqlCommand command, CancellationToken token);
    public sealed virtual DbDataReader ExecuteReader(NpgsqlCommand command);
    public sealed virtual Task`1<DbDataReader> ExecuteReaderAsync(NpgsqlCommand command, CancellationToken token);
    public DbDataReader ExecuteReader(NpgsqlBatch batch);
    public Task`1<DbDataReader> ExecuteReaderAsync(NpgsqlBatch batch, CancellationToken token);
    internal T LoadOne(NpgsqlCommand command, ISelector`1<T> selector);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<LoadOneAsync>d__79`1")]
internal Task`1<T> LoadOneAsync(NpgsqlCommand command, ISelector`1<T> selector, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<StreamOne>d__80")]
internal Task`1<bool> StreamOne(NpgsqlCommand command, Stream stream, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<StreamMany>d__81")]
internal Task`1<int> StreamMany(NpgsqlCommand command, Stream stream, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<ExecuteHandlerAsync>d__82`1")]
public Task`1<T> ExecuteHandlerAsync(IQueryHandler`1<T> handler, CancellationToken token);
    public T ExecuteHandler(IQueryHandler`1<T> handler);
    public sealed virtual void BeginTransaction();
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<BeginTransactionAsync>d__85")]
public sealed virtual ValueTask BeginTransactionAsync(CancellationToken token);
    public sealed virtual IReadOnlyList`1<TDoc> Search(string searchTerm, string regConfig);
    public sealed virtual Task`1<IReadOnlyList`1<TDoc>> SearchAsync(string searchTerm, string regConfig, CancellationToken token);
    public sealed virtual IReadOnlyList`1<TDoc> PlainTextSearch(string searchTerm, string regConfig);
    public sealed virtual Task`1<IReadOnlyList`1<TDoc>> PlainTextSearchAsync(string searchTerm, string regConfig, CancellationToken token);
    public sealed virtual IReadOnlyList`1<TDoc> PhraseSearch(string searchTerm, string regConfig);
    public sealed virtual Task`1<IReadOnlyList`1<TDoc>> PhraseSearchAsync(string searchTerm, string regConfig, CancellationToken token);
    public sealed virtual IReadOnlyList`1<TDoc> WebStyleSearch(string searchTerm, string regConfig);
    public sealed virtual Task`1<IReadOnlyList`1<TDoc>> WebStyleSearchAsync(string searchTerm, string regConfig, CancellationToken token);
    public sealed virtual IJsonLoader get_Json();
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<StreamJsonOne>d__96`2")]
public sealed virtual Task`1<bool> StreamJsonOne(ICompiledQuery`2<TDoc, TOut> query, Stream destination, CancellationToken token);
    public sealed virtual Task`1<int> StreamJsonMany(ICompiledQuery`2<TDoc, TOut> query, Stream destination, CancellationToken token);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<ToJsonOne>d__98`2")]
public sealed virtual Task`1<string> ToJsonOne(ICompiledQuery`2<TDoc, TOut> query, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<ToJsonMany>d__99`2")]
public sealed virtual Task`1<string> ToJsonMany(ICompiledQuery`2<TDoc, TOut> query, CancellationToken token);
    public sealed virtual Task`1<int> StreamJson(Stream destination, CancellationToken token, string sql, Object[] parameters);
    public sealed virtual Task`1<int> StreamJson(Stream destination, string sql, Object[] parameters);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<StreamJson>d__102`1")]
public Task`1<int> StreamJson(IQueryHandler`1<T> handler, Stream destination, CancellationToken token);
    public sealed virtual T Load(string id);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<LoadAsync>d__104`1")]
public sealed virtual Task`1<T> LoadAsync(string id, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<LoadAsync>d__105`1")]
public sealed virtual Task`1<T> LoadAsync(object id, CancellationToken token);
    public sealed virtual T Load(int id);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<LoadAsync>d__109`1")]
public sealed virtual Task`1<T> LoadAsync(int id, CancellationToken token);
    public sealed virtual T Load(long id);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<LoadAsync>d__111`1")]
public sealed virtual Task`1<T> LoadAsync(long id, CancellationToken token);
    public sealed virtual T Load(Guid id);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<LoadAsync>d__113`1")]
public sealed virtual Task`1<T> LoadAsync(Guid id, CancellationToken token);
    public sealed virtual IReadOnlyList`1<T> LoadMany(String[] ids);
    public sealed virtual IReadOnlyList`1<T> LoadMany(IEnumerable`1<string> ids);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<LoadManyAsync>d__116`1")]
public sealed virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(String[] ids);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<LoadManyAsync>d__117`1")]
public sealed virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(IEnumerable`1<string> ids);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<LoadManyAsync>d__118`1")]
public sealed virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(CancellationToken token, String[] ids);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<LoadManyAsync>d__119`1")]
public sealed virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(CancellationToken token, IEnumerable`1<string> ids);
    public sealed virtual IReadOnlyList`1<T> LoadMany(Int32[] ids);
    public sealed virtual IReadOnlyList`1<T> LoadMany(IEnumerable`1<int> ids);
    public sealed virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(Int32[] ids);
    public sealed virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(IEnumerable`1<int> ids);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<LoadManyAsync>d__124`1")]
public sealed virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(CancellationToken token, Int32[] ids);
    public sealed virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(CancellationToken token, IEnumerable`1<int> ids);
    public sealed virtual IReadOnlyList`1<T> LoadMany(Int64[] ids);
    public sealed virtual IReadOnlyList`1<T> LoadMany(IEnumerable`1<long> ids);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<LoadManyAsync>d__128`1")]
public sealed virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(Int64[] ids);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<LoadManyAsync>d__129`1")]
public sealed virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(IEnumerable`1<long> ids);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<LoadManyAsync>d__130`1")]
public sealed virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(CancellationToken token, Int64[] ids);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<LoadManyAsync>d__131`1")]
public sealed virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(CancellationToken token, IEnumerable`1<long> ids);
    public sealed virtual IReadOnlyList`1<T> LoadMany(Guid[] ids);
    public sealed virtual IReadOnlyList`1<T> LoadMany(IEnumerable`1<Guid> ids);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<LoadManyAsync>d__134`1")]
public sealed virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(Guid[] ids);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<LoadManyAsync>d__135`1")]
public sealed virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(IEnumerable`1<Guid> ids);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<LoadManyAsync>d__136`1")]
public sealed virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(CancellationToken token, Guid[] ids);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<LoadManyAsync>d__137`1")]
public sealed virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(CancellationToken token, IEnumerable`1<Guid> ids);
    [CompilerGeneratedAttribute]
public sealed virtual VersionTracker get_Versions();
    [CompilerGeneratedAttribute]
internal void set_Versions(VersionTracker value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_CausationId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_CausationId(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_CorrelationId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_CorrelationId(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_LastModifiedBy();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_LastModifiedBy(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, object> get_Headers();
    [CompilerGeneratedAttribute]
protected void set_Headers(Dictionary`2<string, object> value);
    public sealed virtual Nullable`1<Guid> VersionFor(TDoc entity);
    public sealed virtual DocumentMetadata MetadataFor(T entity);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<MetadataForAsync>d__160`1")]
public sealed virtual Task`1<DocumentMetadata> MetadataForAsync(T entity, CancellationToken token);
    public sealed virtual string NextTempTableName();
    public sealed virtual IMartenQueryable`1<T> Query();
    public sealed virtual IReadOnlyList`1<T> Query(string sql, Object[] parameters);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<QueryAsync>d__165`1")]
public sealed virtual Task`1<IReadOnlyList`1<T>> QueryAsync(string sql, CancellationToken token, Object[] parameters);
    public sealed virtual Task`1<IReadOnlyList`1<T>> QueryAsync(string sql, Object[] parameters);
    public sealed virtual Task`1<IReadOnlyList`1<T>> AdvancedSqlQueryAsync(string sql, CancellationToken token, Object[] parameters);
    public sealed virtual Task`1<IReadOnlyList`1<ValueTuple`2<T1, T2>>> AdvancedSqlQueryAsync(string sql, CancellationToken token, Object[] parameters);
    [NullableContextAttribute("2")]
public sealed virtual Task`1<IReadOnlyList`1<ValueTuple`3<T1, T2, T3>>> AdvancedSqlQueryAsync(string sql, CancellationToken token, Object[] parameters);
    public sealed virtual IReadOnlyList`1<T> AdvancedSqlQuery(string sql, Object[] parameters);
    public sealed virtual IReadOnlyList`1<ValueTuple`2<T1, T2>> AdvancedSqlQuery(string sql, Object[] parameters);
    [NullableContextAttribute("2")]
public sealed virtual IReadOnlyList`1<ValueTuple`3<T1, T2, T3>> AdvancedSqlQuery(string sql, Object[] parameters);
    public sealed virtual IBatchedQuery CreateBatchQuery();
    public sealed virtual TOut Query(ICompiledQuery`2<TDoc, TOut> query);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.QuerySession/<QueryAsync>d__175`2")]
public sealed virtual Task`1<TOut> QueryAsync(ICompiledQuery`2<TDoc, TOut> query, CancellationToken token);
    public sealed virtual IDocumentStorage StorageFor(Type documentType);
    public sealed virtual IDocumentStorage`1<T> StorageFor();
    public sealed virtual IEventStorage EventStorage();
    protected internal virtual IDocumentStorage`1<T> selectStorage(DocumentProvider`1<T> provider);
    internal IDocumentStorage`2<T, TId> StorageFor();
    internal IDocumentStorage`2<T, TId> QueryStorageFor();
    protected void overrideStorage(Type type, IDocumentStorage storage);
    [NullableContextAttribute("2")]
public virtual void UseIdentityMapFor();
    public sealed virtual ITenantQueryOperations ForTenant(string tenantId);
}
internal class Marten.Internal.Sessions.ReadOnlyTransactionalConnection : TransactionalConnection {
    private static string SetTransactionReadOnly;
    public ReadOnlyTransactionalConnection(SessionOptions options);
    public virtual void Apply(NpgsqlCommand command);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.ReadOnlyTransactionalConnection/<ApplyAsync>d__3")]
public virtual Task ApplyAsync(NpgsqlCommand command, CancellationToken token);
    public virtual void BeginTransaction();
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.ReadOnlyTransactionalConnection/<BeginTransactionAsync>d__5")]
public virtual ValueTask BeginTransactionAsync(CancellationToken token);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask <>n__0(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Internal.Sessions.TransactionalConnection : ConnectionLifetimeBase {
    protected SessionOptions _options;
    [NullableAttribute("2")]
protected NpgsqlConnection _connection;
    [CompilerGeneratedAttribute]
private int <CommandTimeout>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private NpgsqlTransaction <Transaction>k__BackingField;
    public NpgsqlConnection Connection { get; }
    public int CommandTimeout { get; public set; }
    [NullableAttribute("2")]
public NpgsqlTransaction Transaction { get; protected set; }
    public TransactionalConnection(SessionOptions options);
    public sealed virtual NpgsqlConnection get_Connection();
    [CompilerGeneratedAttribute]
public sealed virtual int get_CommandTimeout();
    [CompilerGeneratedAttribute]
public void set_CommandTimeout(int value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public NpgsqlTransaction get_Transaction();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected void set_Transaction(NpgsqlTransaction value);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.TransactionalConnection/<DisposeAsync>d__13")]
public sealed virtual ValueTask DisposeAsync();
    public sealed virtual void Dispose();
    public virtual void Apply(NpgsqlCommand command);
    public void Apply(NpgsqlBatch batch);
    public virtual void BeginTransaction();
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.TransactionalConnection/<ApplyAsync>d__18")]
public virtual Task ApplyAsync(NpgsqlCommand command, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.TransactionalConnection/<ApplyAsync>d__19")]
public Task ApplyAsync(NpgsqlBatch batch, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.TransactionalConnection/<BeginTransactionAsync>d__20")]
public virtual ValueTask BeginTransactionAsync(CancellationToken token);
    public void Commit();
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.TransactionalConnection/<CommitAsync>d__22")]
public Task CommitAsync(CancellationToken token);
    public void Rollback();
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.TransactionalConnection/<RollbackAsync>d__24")]
public Task RollbackAsync(CancellationToken token);
    public void EnsureConnected();
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.TransactionalConnection/<EnsureConnectedAsync>d__26")]
public ValueTask EnsureConnectedAsync(CancellationToken token);
    public sealed virtual int Execute(NpgsqlCommand cmd);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.TransactionalConnection/<ExecuteAsync>d__28")]
public sealed virtual Task`1<int> ExecuteAsync(NpgsqlCommand command, CancellationToken token);
    public sealed virtual DbDataReader ExecuteReader(NpgsqlCommand command);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.TransactionalConnection/<ExecuteReaderAsync>d__30")]
public sealed virtual Task`1<DbDataReader> ExecuteReaderAsync(NpgsqlCommand command, CancellationToken token);
    public sealed virtual DbDataReader ExecuteReader(NpgsqlBatch batch);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.TransactionalConnection/<ExecuteReaderAsync>d__32")]
public sealed virtual Task`1<DbDataReader> ExecuteReaderAsync(NpgsqlBatch batch, CancellationToken token);
    public sealed virtual void ExecuteBatchPages(IReadOnlyList`1<OperationPage> pages, List`1<Exception> exceptions);
    [AsyncStateMachineAttribute("Marten.Internal.Sessions.TransactionalConnection/<ExecuteBatchPagesAsync>d__34")]
public sealed virtual Task ExecuteBatchPagesAsync(IReadOnlyList`1<OperationPage> pages, List`1<Exception> exceptions, CancellationToken token);
}
internal class Marten.Internal.Storage.CreateFromDocumentMapping : Variable {
    [NullableContextAttribute("1")]
public CreateFromDocumentMapping(DocumentMapping mapping, Type openType, GeneratedType type);
}
internal class Marten.Internal.Storage.DataAndIdSelectClause`1 : object {
    private IDocumentStorage`1<T> _inner;
    [CompilerGeneratedAttribute]
private string <FromObject>k__BackingField;
    public string FromObject { get; public set; }
    public Type SelectedType { get; }
    public DataAndIdSelectClause`1(IDocumentStorage`1<T> inner);
    public sealed virtual void Apply(ICommandBuilder builder);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FromObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FromObject(string value);
    public sealed virtual Type get_SelectedType();
    public sealed virtual String[] SelectFields();
    public sealed virtual ISelector BuildSelector(IMartenSession session);
    public sealed virtual IQueryHandler`1<T1> BuildHandler(IMartenSession session, ISqlFragment topStatement, ISqlFragment currentStatement);
    public sealed virtual ISelectClause UseStatistics(QueryStatistics statistics);
}
public abstract class Marten.Internal.Storage.DirtyCheckedDocumentStorage`2 : IdentityMapDocumentStorage`2<T, TId> {
    public DirtyCheckedDocumentStorage`2(DocumentMapping document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Internal.Storage.DocumentProvider`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IBulkLoader`1<T> <BulkLoader>k__BackingField;
    [CompilerGeneratedAttribute]
private IDocumentStorage`1<T> <QueryOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private IDocumentStorage`1<T> <Lightweight>k__BackingField;
    [CompilerGeneratedAttribute]
private IDocumentStorage`1<T> <IdentityMap>k__BackingField;
    [CompilerGeneratedAttribute]
private IDocumentStorage`1<T> <DirtyTracking>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IBulkLoader`1<T> BulkLoader { get; }
    public IDocumentStorage`1<T> QueryOnly { get; }
    public IDocumentStorage`1<T> Lightweight { get; }
    public IDocumentStorage`1<T> IdentityMap { get; }
    public IDocumentStorage`1<T> DirtyTracking { get; }
    public DocumentProvider`1(IBulkLoader`1<T> bulkLoader, IDocumentStorage`1<T> queryOnly, IDocumentStorage`1<T> lightweight, IDocumentStorage`1<T> identityMap, IDocumentStorage`1<T> dirtyTracking);
    [CompilerGeneratedAttribute]
public IBulkLoader`1<T> get_BulkLoader();
    [CompilerGeneratedAttribute]
public IDocumentStorage`1<T> get_QueryOnly();
    [CompilerGeneratedAttribute]
public IDocumentStorage`1<T> get_Lightweight();
    [CompilerGeneratedAttribute]
public IDocumentStorage`1<T> get_IdentityMap();
    [CompilerGeneratedAttribute]
public IDocumentStorage`1<T> get_DirtyTracking();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Marten.Internal.Storage.DocumentStorage`2 : object {
    private NpgsqlDbType _idType;
    protected string _loadArraySql;
    protected string _loaderSql;
    protected DocumentMapping _mapping;
    private string _selectClause;
    private String[] _selectFields;
    [NullableAttribute("2")]
private ISqlFragment _defaultWhere;
    protected Action`2<T, TId> _setter;
    private DocumentMapping _document;
    [CompilerGeneratedAttribute]
private bool <UseNumericRevisions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<DuplicatedField> <DuplicatedFields>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseOptimisticConcurrency>k__BackingField;
    [CompilerGeneratedAttribute]
private DbObjectName <TableName>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperationFragment <DeleteFragment>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperationFragment <HardDeleteFragment>k__BackingField;
    public bool UseNumericRevisions { get; }
    public ISelectClause SelectClauseWithDuplicatedFields { get; }
    public IQueryableMemberCollection QueryMembers { get; }
    public TenancyStyle TenancyStyle { get; }
    public Type DocumentType { get; }
    public IReadOnlyList`1<DuplicatedField> DuplicatedFields { get; }
    public bool UseOptimisticConcurrency { get; }
    public Type SelectedType { get; }
    public Type SourceType { get; }
    public DbObjectName TableName { get; }
    private string Marten.Linq.SqlGeneration.ISelectClause.FromObject { get; }
    public Type IdType { get; }
    public IOperationFragment DeleteFragment { get; }
    public IOperationFragment HardDeleteFragment { get; }
    public DocumentStorage`2(StorageStyle storageStyle, DocumentMapping document);
    private sealed virtual override object Marten.Internal.Storage.IDocumentStorage.RawIdentityValue(object id);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseNumericRevisions();
    public sealed virtual ISelectClause get_SelectClauseWithDuplicatedFields();
    private sealed virtual override MetadataColumn[] Marten.Internal.Storage.IHaveMetadataColumns.MetadataColumns();
    public sealed virtual IQueryableMemberCollection get_QueryMembers();
    public sealed virtual void TruncateDocumentStorage(IMartenDatabase database);
    [AsyncStateMachineAttribute("Marten.Internal.Storage.DocumentStorage`2/<TruncateDocumentStorageAsync>d__20")]
public sealed virtual Task TruncateDocumentStorageAsync(IMartenDatabase database, CancellationToken ct);
    public sealed virtual void SetIdentity(T document, TId identity);
    public sealed virtual TenancyStyle get_TenancyStyle();
    public sealed virtual Type get_DocumentType();
    [CompilerGeneratedAttribute]
public sealed virtual IReadOnlyList`1<DuplicatedField> get_DuplicatedFields();
    public sealed virtual ISqlFragment ByIdFilter(TId id);
    public sealed virtual IDeletion HardDeleteForId(TId id, string tenant);
    public sealed virtual void EjectById(IMartenSession session, object id);
    public sealed virtual void RemoveDirtyTracker(IMartenSession session, object id);
    public sealed virtual IDeletion HardDeleteForDocument(T document, string tenantId);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseOptimisticConcurrency();
    private sealed virtual override object Marten.Internal.Storage.IDocumentStorage<T>.IdentityFor(T document);
    public sealed virtual Type get_SelectedType();
    public sealed virtual Type get_SourceType();
    public abstract virtual TId AssignIdentity(T document, string tenantId, IMartenDatabase database);
    [CompilerGeneratedAttribute]
public sealed virtual DbObjectName get_TableName();
    private sealed virtual override string Marten.Linq.SqlGeneration.ISelectClause.get_FromObject();
    public sealed virtual Type get_IdType();
    public sealed virtual Nullable`1<Guid> VersionFor(T document, IMartenSession session);
    public abstract virtual void Store(IMartenSession session, T document);
    public abstract virtual void Store(IMartenSession session, T document, Nullable`1<Guid> version);
    public abstract virtual void Store(IMartenSession session, T document, int revision);
    public abstract virtual void Eject(IMartenSession session, T document);
    public abstract virtual IStorageOperation Update(T document, IMartenSession session, string tenant);
    public abstract virtual IStorageOperation Insert(T document, IMartenSession session, string tenant);
    public abstract virtual IStorageOperation Upsert(T document, IMartenSession session, string tenant);
    public abstract virtual IStorageOperation Overwrite(T document, IMartenSession session, string tenant);
    public sealed virtual IDeletion DeleteForDocument(T document, string tenant);
    public sealed virtual IDeletion DeleteForId(TId id, string tenant);
    [CompilerGeneratedAttribute]
public sealed virtual IOperationFragment get_DeleteFragment();
    [CompilerGeneratedAttribute]
public sealed virtual IOperationFragment get_HardDeleteFragment();
    public sealed virtual ISqlFragment FilterDocuments(ISqlFragment query, IMartenSession session);
    [NullableContextAttribute("2")]
public sealed virtual ISqlFragment DefaultWhereFragment();
    public abstract virtual T Load(TId id, IMartenSession session);
    public abstract virtual Task`1<T> LoadAsync(TId id, IMartenSession session, CancellationToken token);
    public abstract virtual IReadOnlyList`1<T> LoadMany(TId[] ids, IMartenSession session);
    public abstract virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(TId[] ids, IMartenSession session, CancellationToken token);
    public abstract virtual TId Identity(T document);
    public sealed virtual void Apply(ICommandBuilder sql);
    public sealed virtual String[] SelectFields();
    public abstract virtual ISelector BuildSelector(IMartenSession session);
    public sealed virtual IQueryHandler`1<TResult> BuildHandler(IMartenSession session, ISqlFragment statement, ISqlFragment currentStatement);
    public sealed virtual ISelectClause UseStatistics(QueryStatistics statistics);
    public virtual object RawIdentityValue(TId id);
    public NpgsqlParameter ParameterForId(TId id);
    public sealed virtual NpgsqlCommand BuildLoadCommand(TId id, string tenant);
    public virtual NpgsqlParameter BuildManyIdParameter(TId[] ids);
    public sealed virtual NpgsqlCommand BuildLoadManyCommand(TId[] ids, string tenant);
    private void determineDefaultWhereFragment();
    [IteratorStateMachineAttribute("Marten.Internal.Storage.DocumentStorage`2/<extraFilters>d__85")]
private IEnumerable`1<ISqlFragment> extraFilters(ISqlFragment query, IMartenSession session);
    [IteratorStateMachineAttribute("Marten.Internal.Storage.DocumentStorage`2/<defaultFilters>d__86")]
private IEnumerable`1<ISqlFragment> defaultFilters();
    protected T load(TId id, IMartenSession session);
    protected Task`1<T> loadAsync(TId id, IMartenSession session, CancellationToken token);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <get_SelectClauseWithDuplicatedFields>b__15_1(string x);
}
[ExtensionAttribute]
internal static class Marten.Internal.Storage.DocumentStoreExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void AddTenancyFilter(IDocumentStorage storage, ICommandBuilder sql, string tenantId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Internal.Storage.DuplicatedFieldSelectClause : object {
    private String[] _selectFields;
    private IDocumentStorage _parent;
    [CompilerGeneratedAttribute]
private string <FromObject>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SelectedType>k__BackingField;
    public string FromObject { get; public set; }
    public Type SelectedType { get; }
    public DuplicatedFieldSelectClause(string fromObject, string selector, String[] selectFields, Type selectedType, IDocumentStorage parent);
    public sealed virtual void Apply(ICommandBuilder builder);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FromObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FromObject(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_SelectedType();
    public sealed virtual String[] SelectFields();
    public sealed virtual ISelector BuildSelector(IMartenSession session);
    public sealed virtual IQueryHandler`1<T> BuildHandler(IMartenSession session, ISqlFragment topStatement, ISqlFragment currentStatement);
    public sealed virtual ISelectClause UseStatistics(QueryStatistics statistics);
}
public abstract class Marten.Internal.Storage.IdentityMapDocumentStorage`2 : DocumentStorage`2<T, TId> {
    public IdentityMapDocumentStorage`2(DocumentMapping document);
    protected IdentityMapDocumentStorage`2(StorageStyle storageStyle, DocumentMapping document);
    public sealed virtual void Eject(IMartenSession session, T document);
    public sealed virtual void Store(IMartenSession session, T document);
    private void store(IMartenSession session, T document, TId& id);
    public sealed virtual void Store(IMartenSession session, T document, Nullable`1<Guid> version);
    public sealed virtual void Store(IMartenSession session, T document, int revision);
    public sealed virtual IReadOnlyList`1<T> LoadMany(TId[] ids, IMartenSession session);
    private List`1<T> preselectLoadedDocuments(TId[] ids, IMartenSession session, NpgsqlCommand& command);
    [AsyncStateMachineAttribute("Marten.Internal.Storage.IdentityMapDocumentStorage`2/<LoadManyAsync>d__9")]
public sealed virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(TId[] ids, IMartenSession session, CancellationToken token);
    public sealed virtual T Load(TId id, IMartenSession session);
    public sealed virtual Task`1<T> LoadAsync(TId id, IMartenSession session, CancellationToken token);
}
[NullableContextAttribute("1")]
public interface Marten.Internal.Storage.IDocumentStorage {
    public Type SourceType { get; }
    public Type IdType { get; }
    public bool UseOptimisticConcurrency { get; }
    public IOperationFragment DeleteFragment { get; }
    public IOperationFragment HardDeleteFragment { get; }
    public IReadOnlyList`1<DuplicatedField> DuplicatedFields { get; }
    public DbObjectName TableName { get; }
    public Type DocumentType { get; }
    public TenancyStyle TenancyStyle { get; }
    public IQueryableMemberCollection QueryMembers { get; }
    public ISelectClause SelectClauseWithDuplicatedFields { get; }
    public bool UseNumericRevisions { get; }
    public abstract virtual Type get_SourceType();
    public abstract virtual Type get_IdType();
    public abstract virtual bool get_UseOptimisticConcurrency();
    public abstract virtual IOperationFragment get_DeleteFragment();
    public abstract virtual IOperationFragment get_HardDeleteFragment();
    public abstract virtual IReadOnlyList`1<DuplicatedField> get_DuplicatedFields();
    public abstract virtual DbObjectName get_TableName();
    public abstract virtual Type get_DocumentType();
    public abstract virtual TenancyStyle get_TenancyStyle();
    public abstract virtual Task TruncateDocumentStorageAsync(IMartenDatabase database, CancellationToken ct);
    [ObsoleteAttribute("Use async method instead.")]
public abstract virtual void TruncateDocumentStorage(IMartenDatabase database);
    public abstract virtual ISqlFragment FilterDocuments(ISqlFragment query, IMartenSession session);
    [NullableContextAttribute("2")]
public abstract virtual ISqlFragment DefaultWhereFragment();
    public abstract virtual IQueryableMemberCollection get_QueryMembers();
    public abstract virtual ISelectClause get_SelectClauseWithDuplicatedFields();
    public abstract virtual bool get_UseNumericRevisions();
    public abstract virtual object RawIdentityValue(object id);
}
[NullableContextAttribute("1")]
public interface Marten.Internal.Storage.IDocumentStorage`1 {
    public abstract virtual object IdentityFor(T document);
    public abstract virtual Nullable`1<Guid> VersionFor(T document, IMartenSession session);
    public abstract virtual void Store(IMartenSession session, T document);
    public abstract virtual void Store(IMartenSession session, T document, Nullable`1<Guid> version);
    public abstract virtual void Store(IMartenSession session, T document, int revision);
    public abstract virtual void Eject(IMartenSession session, T document);
    public abstract virtual IStorageOperation Update(T document, IMartenSession session, string tenantId);
    public abstract virtual IStorageOperation Insert(T document, IMartenSession session, string tenantId);
    public abstract virtual IStorageOperation Upsert(T document, IMartenSession session, string tenantId);
    public abstract virtual IStorageOperation Overwrite(T document, IMartenSession session, string tenantId);
    public abstract virtual IDeletion DeleteForDocument(T document, string tenantId);
    public abstract virtual void EjectById(IMartenSession session, object id);
    public abstract virtual void RemoveDirtyTracker(IMartenSession session, object id);
    public abstract virtual IDeletion HardDeleteForDocument(T document, string tenantId);
}
[NullableContextAttribute("1")]
public interface Marten.Internal.Storage.IDocumentStorage`2 {
    public abstract virtual void SetIdentity(T document, TId identity);
    public abstract virtual IDeletion DeleteForId(TId id, string tenantId);
    public abstract virtual T Load(TId id, IMartenSession session);
    public abstract virtual Task`1<T> LoadAsync(TId id, IMartenSession session, CancellationToken token);
    public abstract virtual IReadOnlyList`1<T> LoadMany(TId[] ids, IMartenSession session);
    public abstract virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(TId[] ids, IMartenSession session, CancellationToken token);
    public abstract virtual TId AssignIdentity(T document, string tenantId, IMartenDatabase database);
    public abstract virtual TId Identity(T document);
    public abstract virtual ISqlFragment ByIdFilter(TId id);
    public abstract virtual IDeletion HardDeleteForId(TId id, string tenantId);
    public abstract virtual NpgsqlCommand BuildLoadCommand(TId id, string tenantId);
    public abstract virtual NpgsqlCommand BuildLoadManyCommand(TId[] ids, string tenantId);
    public abstract virtual object RawIdentityValue(TId id);
}
[NullableContextAttribute("1")]
internal interface Marten.Internal.Storage.IHaveMetadataColumns {
    public abstract virtual MetadataColumn[] MetadataColumns();
}
internal interface Marten.Internal.Storage.IQueryOnlyDocumentStorage {
    public abstract virtual ISelectClause SelectClauseForIncludes();
}
public abstract class Marten.Internal.Storage.LightweightDocumentStorage`2 : DocumentStorage`2<T, TId> {
    public LightweightDocumentStorage`2(DocumentMapping document);
    public sealed virtual void Store(IMartenSession session, T document);
    public sealed virtual void Store(IMartenSession session, T document, Nullable`1<Guid> version);
    public sealed virtual void Store(IMartenSession session, T document, int revision);
    public sealed virtual void Eject(IMartenSession session, T document);
    public sealed virtual IReadOnlyList`1<T> LoadMany(TId[] ids, IMartenSession session);
    [AsyncStateMachineAttribute("Marten.Internal.Storage.LightweightDocumentStorage`2/<LoadManyAsync>d__6")]
public sealed virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(TId[] ids, IMartenSession session, CancellationToken token);
    public sealed virtual T Load(TId id, IMartenSession session);
    public sealed virtual Task`1<T> LoadAsync(TId id, IMartenSession session, CancellationToken token);
}
public abstract class Marten.Internal.Storage.QueryOnlyDocumentStorage`2 : DocumentStorage`2<T, TId> {
    public QueryOnlyDocumentStorage`2(DocumentMapping document);
    public sealed virtual ISelectClause SelectClauseForIncludes();
    public sealed virtual void Store(IMartenSession session, T document);
    public sealed virtual void Store(IMartenSession session, T document, Nullable`1<Guid> version);
    public sealed virtual void Store(IMartenSession session, T document, int revision);
    public sealed virtual void Eject(IMartenSession session, T document);
    public sealed virtual IReadOnlyList`1<T> LoadMany(TId[] ids, IMartenSession session);
    [AsyncStateMachineAttribute("Marten.Internal.Storage.QueryOnlyDocumentStorage`2/<LoadManyAsync>d__7")]
public sealed virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(TId[] ids, IMartenSession session, CancellationToken token);
    public sealed virtual T Load(TId id, IMartenSession session);
    public sealed virtual Task`1<T> LoadAsync(TId id, IMartenSession session, CancellationToken token);
}
internal class Marten.Internal.Storage.SubClassDocumentStorage`3 : object {
    private ISqlFragment _defaultWhere;
    private String[] _fields;
    private SubClassMapping _mapping;
    private IDocumentStorage`2<TRoot, TId> _parent;
    [CompilerGeneratedAttribute]
private bool <UseNumericRevisions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FromObject>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperationFragment <HardDeleteFragment>k__BackingField;
    public IQueryableMemberCollection QueryMembers { get; }
    public ISelectClause SelectClauseWithDuplicatedFields { get; }
    public bool UseNumericRevisions { get; }
    public TenancyStyle TenancyStyle { get; }
    public string FromObject { get; }
    public Type SelectedType { get; }
    public Type SourceType { get; }
    public bool UseOptimisticConcurrency { get; }
    public IOperationFragment DeleteFragment { get; }
    public IOperationFragment HardDeleteFragment { get; }
    public IReadOnlyList`1<DuplicatedField> DuplicatedFields { get; }
    public DbObjectName TableName { get; }
    public Type DocumentType { get; }
    public Type IdType { get; }
    public SubClassDocumentStorage`3(IDocumentStorage`2<TRoot, TId> parent, SubClassMapping mapping);
    public sealed virtual IQueryableMemberCollection get_QueryMembers();
    public sealed virtual ISelectClause get_SelectClauseWithDuplicatedFields();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseNumericRevisions();
    public sealed virtual object RawIdentityValue(object id);
    public sealed virtual void TruncateDocumentStorage(IMartenDatabase database);
    public sealed virtual Task TruncateDocumentStorageAsync(IMartenDatabase database, CancellationToken ct);
    public sealed virtual TenancyStyle get_TenancyStyle();
    private sealed virtual override object Marten.Internal.Storage.IDocumentStorage<T>.IdentityFor(T document);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FromObject();
    public sealed virtual Type get_SelectedType();
    public sealed virtual void Apply(ICommandBuilder sql);
    public sealed virtual String[] SelectFields();
    public sealed virtual ISelector BuildSelector(IMartenSession session);
    public sealed virtual IQueryHandler`1<TResult> BuildHandler(IMartenSession session, ISqlFragment statement, ISqlFragment currentStatement);
    public sealed virtual ISelectClause UseStatistics(QueryStatistics statistics);
    public sealed virtual Type get_SourceType();
    public sealed virtual ISqlFragment FilterDocuments(ISqlFragment query, IMartenSession session);
    public sealed virtual ISqlFragment DefaultWhereFragment();
    public sealed virtual bool get_UseOptimisticConcurrency();
    public sealed virtual IOperationFragment get_DeleteFragment();
    [CompilerGeneratedAttribute]
public sealed virtual IOperationFragment get_HardDeleteFragment();
    public sealed virtual IReadOnlyList`1<DuplicatedField> get_DuplicatedFields();
    public sealed virtual DbObjectName get_TableName();
    public sealed virtual Type get_DocumentType();
    public sealed virtual Type get_IdType();
    public sealed virtual Nullable`1<Guid> VersionFor(T document, IMartenSession session);
    public sealed virtual void Store(IMartenSession session, T document);
    public sealed virtual void Store(IMartenSession session, T document, Nullable`1<Guid> version);
    public sealed virtual void Store(IMartenSession session, T document, int revision);
    public sealed virtual void Eject(IMartenSession session, T document);
    public sealed virtual IStorageOperation Update(T document, IMartenSession session, string tenant);
    public sealed virtual IStorageOperation Insert(T document, IMartenSession session, string tenant);
    public sealed virtual IStorageOperation Upsert(T document, IMartenSession session, string tenant);
    public sealed virtual IStorageOperation Overwrite(T document, IMartenSession session, string tenant);
    public sealed virtual IDeletion DeleteForDocument(T document, string tenant);
    public sealed virtual void SetIdentity(T document, TId identity);
    public sealed virtual IDeletion DeleteForId(TId id, string tenant);
    public sealed virtual T Load(TId id, IMartenSession session);
    [AsyncStateMachineAttribute("Marten.Internal.Storage.SubClassDocumentStorage`3/<LoadAsync>d__60")]
public sealed virtual Task`1<T> LoadAsync(TId id, IMartenSession session, CancellationToken token);
    public sealed virtual IReadOnlyList`1<T> LoadMany(TId[] ids, IMartenSession session);
    [AsyncStateMachineAttribute("Marten.Internal.Storage.SubClassDocumentStorage`3/<LoadManyAsync>d__62")]
public sealed virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(TId[] ids, IMartenSession session, CancellationToken token);
    public sealed virtual TId AssignIdentity(T document, string tenantId, IMartenDatabase database);
    public sealed virtual TId Identity(T document);
    public sealed virtual ISqlFragment ByIdFilter(TId id);
    public sealed virtual IDeletion HardDeleteForId(TId id, string tenant);
    public sealed virtual NpgsqlCommand BuildLoadCommand(TId id, string tenant);
    public sealed virtual NpgsqlCommand BuildLoadManyCommand(TId[] ids, string tenant);
    public sealed virtual object RawIdentityValue(TId id);
    public sealed virtual void EjectById(IMartenSession session, object id);
    public sealed virtual void RemoveDirtyTracker(IMartenSession session, object id);
    public sealed virtual IDeletion HardDeleteForDocument(T document, string tenantId);
    [IteratorStateMachineAttribute("Marten.Internal.Storage.SubClassDocumentStorage`3/<extraFilters>d__73")]
private IEnumerable`1<ISqlFragment> extraFilters(ISqlFragment query, IMartenSession session);
    [IteratorStateMachineAttribute("Marten.Internal.Storage.SubClassDocumentStorage`3/<defaultFilters>d__74")]
private IEnumerable`1<ISqlFragment> defaultFilters();
    public ISqlFragment determineWhereFragment();
    private WhereFragment toBasicWhere();
    public sealed virtual MetadataColumn[] MetadataColumns();
}
internal class Marten.Internal.UnitOfWork : object {
    private List`1<IStorageOperation> _eventOperations;
    private List`1<IStorageOperation> _operations;
    private IMartenSession _parent;
    [CompilerGeneratedAttribute]
private List`1<StreamAction> <Streams>k__BackingField;
    public IReadOnlyList`1<IStorageOperation> AllOperations { get; }
    public List`1<StreamAction> Streams { get; }
    private IEnumerable`1<object> Marten.Services.IChangeSet.Updated { get; }
    private IEnumerable`1<object> Marten.Services.IChangeSet.Inserted { get; }
    private IEnumerable`1<IDeletion> Marten.Services.IChangeSet.Deleted { get; }
    public UnitOfWork(IMartenSession parent);
    internal UnitOfWork(IEnumerable`1<IStorageOperation> operations);
    public sealed virtual void Reset();
    public sealed virtual void Add(IStorageOperation operation);
    public sealed virtual IReadOnlyList`1<IStorageOperation> get_AllOperations();
    public sealed virtual void Sort(StoreOptions options);
    private sealed virtual override IEnumerable`1<IDeletion> Marten.Services.IUnitOfWork.Deletions();
    private sealed virtual override IEnumerable`1<IDeletion> Marten.Services.IUnitOfWork.DeletionsFor();
    private sealed virtual override IEnumerable`1<IDeletion> Marten.Services.IUnitOfWork.DeletionsFor(Type documentType);
    private sealed virtual override IEnumerable`1<object> Marten.Services.IUnitOfWork.Updates();
    private sealed virtual override IEnumerable`1<object> Marten.Services.IUnitOfWork.Inserts();
    private sealed virtual override IEnumerable`1<T> Marten.Services.IUnitOfWork.UpdatesFor();
    private sealed virtual override IEnumerable`1<T> Marten.Services.IUnitOfWork.InsertsFor();
    private sealed virtual override IEnumerable`1<T> Marten.Services.IUnitOfWork.AllChangedFor();
    [CompilerGeneratedAttribute]
public sealed virtual List`1<StreamAction> get_Streams();
    private sealed virtual override IList`1<StreamAction> Marten.Services.IUnitOfWork.Streams();
    private sealed virtual override IEnumerable`1<IStorageOperation> Marten.Services.IUnitOfWork.Operations();
    private sealed virtual override IEnumerable`1<IStorageOperation> Marten.Services.IUnitOfWork.OperationsFor();
    private sealed virtual override IEnumerable`1<IStorageOperation> Marten.Services.IUnitOfWork.OperationsFor(Type documentType);
    private sealed virtual override IEnumerable`1<object> Marten.Services.IChangeSet.get_Updated();
    private sealed virtual override IEnumerable`1<object> Marten.Services.IChangeSet.get_Inserted();
    private sealed virtual override IEnumerable`1<IDeletion> Marten.Services.IChangeSet.get_Deleted();
    private sealed virtual override IEnumerable`1<IEvent> Marten.Services.IChangeSet.GetEvents();
    private sealed virtual override IEnumerable`1<StreamAction> Marten.Services.IChangeSet.GetStreams();
    public sealed virtual IChangeSet Clone();
    public sealed virtual void Eject(T document);
    public sealed virtual void EjectAllOfType(Type type);
    public sealed virtual bool HasOutstandingWork();
    public sealed virtual void EjectAll();
    public sealed virtual void PurgeOperations(TId id);
    public sealed virtual bool TryFindStream(string streamKey, StreamAction& stream);
    public sealed virtual bool TryFindStream(Guid streamId, StreamAction& stream);
    private bool shouldSort(StoreOptions options, IComparer`1& comparer);
    private IEnumerable`1<IStorageOperation> operationsFor(Type documentType);
    [CompilerGeneratedAttribute]
private bool <Marten.Services.IUnitOfWork.Updates>b__13_0(IChangeTracker x);
    [CompilerGeneratedAttribute]
private bool <Marten.Services.IUnitOfWork.UpdatesFor>b__15_1(IChangeTracker x);
    [CompilerGeneratedAttribute]
private bool <Marten.Services.IUnitOfWork.AllChangedFor>b__17_1(IChangeTracker x);
}
public class Marten.Internal.UpdateBatch : object {
    private IList`1<Exception> _exceptions;
    private IReadOnlyList`1<IStorageOperation> _operations;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [NullableAttribute("2")]
public string TenantId { get; public set; }
    public UpdateBatch(IReadOnlyList`1<IStorageOperation> operations);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_TenantId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_TenantId(string value);
    public sealed virtual IReadOnlyList`1<Type> DocumentTypes();
    public sealed virtual Task PostUpdateAsync(IMartenSession session);
    public sealed virtual Task PreUpdateAsync(IMartenSession session);
    public sealed virtual IReadOnlyList`1<OperationPage> BuildPages(IMartenSession session);
    [IteratorStateMachineAttribute("Marten.Internal.UpdateBatch/<buildPages>d__11")]
private IEnumerable`1<OperationPage> buildPages(IMartenSession session);
}
internal class Marten.Internal.ValueTypeElementMember : ElementMember {
    public ValueTypeElementMember(Type declaringType, Type reflectedType);
}
public class Marten.Internal.ValueTypeInfo : object {
    [CompilerGeneratedAttribute]
private Type <OuterType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SimpleType>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyInfo <ValueProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Builder>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo <Ctor>k__BackingField;
    public Type OuterType { get; }
    public Type SimpleType { get; }
    public PropertyInfo ValueProperty { get; }
    public MethodInfo Builder { get; }
    public ConstructorInfo Ctor { get; }
    public ValueTypeInfo(Type outerType, Type simpleType, PropertyInfo valueProperty, ConstructorInfo ctor);
    public ValueTypeInfo(Type outerType, Type simpleType, PropertyInfo valueProperty, MethodInfo builder);
    [CompilerGeneratedAttribute]
public Type get_OuterType();
    [CompilerGeneratedAttribute]
public Type get_SimpleType();
    [CompilerGeneratedAttribute]
public PropertyInfo get_ValueProperty();
    [CompilerGeneratedAttribute]
public MethodInfo get_Builder();
    [CompilerGeneratedAttribute]
public ConstructorInfo get_Ctor();
    public Func`2<TInner, TOuter> CreateConverter();
    public Func`2<TOuter, TInner> ValueAccessor();
}
public class Marten.Internal.VersionTracker : object {
    private Dictionary`2<Type, object> _byType;
    public Dictionary`2<TId, int> RevisionsFor();
    public Dictionary`2<TId, Guid> ForType();
    public Nullable`1<Guid> VersionFor(TId id);
    public Nullable`1<int> RevisionFor(TId id);
    public void StoreVersion(TId id, Guid guid);
    public void StoreRevision(TId id, int revision);
    public void ClearVersion(TId id);
    public void ClearRevision(TId id);
}
public static class Marten.Internal.WalkReferencedAssemblies : object {
    [IteratorStateMachineAttribute("Marten.Internal.WalkReferencedAssemblies/<ForTypes>d__0")]
public static IEnumerable`1<Assembly> ForTypes(Type[] types);
}
public interface Marten.IQueryPlan`1 {
    public abstract virtual Task`1<T> Fetch(IQuerySession session, CancellationToken token);
}
[NullableContextAttribute("1")]
public interface Marten.IQuerySession {
    public IMartenDatabase Database { get; }
    public NpgsqlConnection Connection { get; }
    public IMartenSessionLogger Logger { get; public set; }
    public int RequestCount { get; }
    public IDocumentStore DocumentStore { get; }
    public IQueryEventStore Events { get; }
    public IJsonLoader Json { get; }
    [NullableAttribute("2")]
public string CausationId { get; public set; }
    [NullableAttribute("2")]
public string CorrelationId { get; public set; }
    public string TenantId { get; }
    public IAdvancedSql AdvancedSql { get; }
    public abstract virtual IMartenDatabase get_Database();
    public abstract virtual NpgsqlConnection get_Connection();
    public abstract virtual IMartenSessionLogger get_Logger();
    public abstract virtual void set_Logger(IMartenSessionLogger value);
    public abstract virtual int get_RequestCount();
    public abstract virtual IDocumentStore get_DocumentStore();
    public abstract virtual IQueryEventStore get_Events();
    public abstract virtual IJsonLoader get_Json();
    [NullableContextAttribute("2")]
public abstract virtual string get_CausationId();
    [NullableContextAttribute("2")]
public abstract virtual void set_CausationId(string value);
    [NullableContextAttribute("2")]
public abstract virtual string get_CorrelationId();
    [NullableContextAttribute("2")]
public abstract virtual void set_CorrelationId(string value);
    public abstract virtual string get_TenantId();
    public abstract virtual T Load(string id);
    public abstract virtual Task`1<T> LoadAsync(string id, CancellationToken token);
    public abstract virtual Task`1<T> LoadAsync(object id, CancellationToken token);
    public abstract virtual T Load(int id);
    public abstract virtual T Load(long id);
    public abstract virtual T Load(Guid id);
    public abstract virtual Task`1<T> LoadAsync(int id, CancellationToken token);
    public abstract virtual Task`1<T> LoadAsync(long id, CancellationToken token);
    public abstract virtual Task`1<T> LoadAsync(Guid id, CancellationToken token);
    public abstract virtual IMartenQueryable`1<T> Query();
    public abstract virtual IReadOnlyList`1<T> Query(string sql, Object[] parameters);
    public abstract virtual Task`1<int> StreamJson(Stream destination, CancellationToken token, string sql, Object[] parameters);
    public abstract virtual Task`1<int> StreamJson(Stream destination, string sql, Object[] parameters);
    public abstract virtual Task`1<IReadOnlyList`1<T>> QueryAsync(string sql, CancellationToken token, Object[] parameters);
    public abstract virtual Task`1<IReadOnlyList`1<T>> QueryAsync(string sql, Object[] parameters);
    [ObsoleteAttribute("Will be removed in 8.0. Use AdvancedSql.QueryAsync<T>(...) instead.")]
public abstract virtual Task`1<IReadOnlyList`1<T>> AdvancedSqlQueryAsync(string sql, CancellationToken token, Object[] parameters);
    [ObsoleteAttribute("Will be removed in 8.0. Use AdvancedSql.QueryAsync<T1, T2>(...) instead.")]
public abstract virtual Task`1<IReadOnlyList`1<ValueTuple`2<T1, T2>>> AdvancedSqlQueryAsync(string sql, CancellationToken token, Object[] parameters);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Will be removed in 8.0. Use AdvancedSql.QueryAsync<T1, T2, T3>(...) instead.")]
public abstract virtual Task`1<IReadOnlyList`1<ValueTuple`3<T1, T2, T3>>> AdvancedSqlQueryAsync(string sql, CancellationToken token, Object[] parameters);
    [ObsoleteAttribute("Will be removed in 8.0. Use AdvancedSql.QueryAsync<T>(...) instead.")]
public abstract virtual IReadOnlyList`1<T> AdvancedSqlQuery(string sql, Object[] parameters);
    [ObsoleteAttribute("Will be removed in 8.0. Use AdvancedSql.QueryAsync<T1, T2>(...) instead.")]
public abstract virtual IReadOnlyList`1<ValueTuple`2<T1, T2>> AdvancedSqlQuery(string sql, Object[] parameters);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Will be removed in 8.0. Use AdvancedSql.QueryAsync<T1, T2, T3>(...) instead.")]
public abstract virtual IReadOnlyList`1<ValueTuple`3<T1, T2, T3>> AdvancedSqlQuery(string sql, Object[] parameters);
    public abstract virtual IBatchedQuery CreateBatchQuery();
    public abstract virtual TOut Query(ICompiledQuery`2<TDoc, TOut> query);
    public abstract virtual Task`1<TOut> QueryAsync(ICompiledQuery`2<TDoc, TOut> query, CancellationToken token);
    public abstract virtual Task`1<bool> StreamJsonOne(ICompiledQuery`2<TDoc, TOut> query, Stream destination, CancellationToken token);
    public abstract virtual Task`1<int> StreamJsonMany(ICompiledQuery`2<TDoc, TOut> query, Stream destination, CancellationToken token);
    [NullableContextAttribute("2")]
public abstract virtual Task`1<string> ToJsonOne(ICompiledQuery`2<TDoc, TOut> query, CancellationToken token);
    public abstract virtual Task`1<string> ToJsonMany(ICompiledQuery`2<TDoc, TOut> query, CancellationToken token);
    public abstract virtual IReadOnlyList`1<T> LoadMany(String[] ids);
    public abstract virtual IReadOnlyList`1<T> LoadMany(IEnumerable`1<string> ids);
    public abstract virtual IReadOnlyList`1<T> LoadMany(Guid[] ids);
    public abstract virtual IReadOnlyList`1<T> LoadMany(IEnumerable`1<Guid> ids);
    public abstract virtual IReadOnlyList`1<T> LoadMany(Int32[] ids);
    public abstract virtual IReadOnlyList`1<T> LoadMany(IEnumerable`1<int> ids);
    public abstract virtual IReadOnlyList`1<T> LoadMany(Int64[] ids);
    public abstract virtual IReadOnlyList`1<T> LoadMany(IEnumerable`1<long> ids);
    public abstract virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(String[] ids);
    public abstract virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(IEnumerable`1<string> ids);
    public abstract virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(Guid[] ids);
    public abstract virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(IEnumerable`1<Guid> ids);
    public abstract virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(Int32[] ids);
    public abstract virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(IEnumerable`1<int> ids);
    public abstract virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(Int64[] ids);
    public abstract virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(IEnumerable`1<long> ids);
    public abstract virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(CancellationToken token, String[] ids);
    public abstract virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(CancellationToken token, IEnumerable`1<string> ids);
    public abstract virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(CancellationToken token, Guid[] ids);
    public abstract virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(CancellationToken token, IEnumerable`1<Guid> ids);
    public abstract virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(CancellationToken token, Int32[] ids);
    public abstract virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(CancellationToken token, IEnumerable`1<int> ids);
    public abstract virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(CancellationToken token, Int64[] ids);
    public abstract virtual Task`1<IReadOnlyList`1<T>> LoadManyAsync(CancellationToken token, IEnumerable`1<long> ids);
    public abstract virtual Nullable`1<Guid> VersionFor(TDoc entity);
    public abstract virtual IReadOnlyList`1<TDoc> Search(string queryText, string regConfig);
    public abstract virtual Task`1<IReadOnlyList`1<TDoc>> SearchAsync(string queryText, string regConfig, CancellationToken token);
    public abstract virtual IReadOnlyList`1<TDoc> PlainTextSearch(string searchTerm, string regConfig);
    public abstract virtual Task`1<IReadOnlyList`1<TDoc>> PlainTextSearchAsync(string searchTerm, string regConfig, CancellationToken token);
    public abstract virtual IReadOnlyList`1<TDoc> PhraseSearch(string searchTerm, string regConfig);
    public abstract virtual Task`1<IReadOnlyList`1<TDoc>> PhraseSearchAsync(string searchTerm, string regConfig, CancellationToken token);
    public abstract virtual IReadOnlyList`1<TDoc> WebStyleSearch(string searchTerm, string regConfig);
    public abstract virtual Task`1<IReadOnlyList`1<TDoc>> WebStyleSearchAsync(string searchTerm, string regConfig, CancellationToken token);
    public abstract virtual DocumentMetadata MetadataFor(T entity);
    public abstract virtual Task`1<DocumentMetadata> MetadataForAsync(T entity, CancellationToken token);
    public abstract virtual ITenantQueryOperations ForTenant(string tenantId);
    public abstract virtual int Execute(NpgsqlCommand cmd);
    public abstract virtual Task`1<int> ExecuteAsync(NpgsqlCommand command, CancellationToken token);
    public abstract virtual DbDataReader ExecuteReader(NpgsqlCommand command);
    public abstract virtual Task`1<DbDataReader> ExecuteReaderAsync(NpgsqlCommand command, CancellationToken token);
    public abstract virtual IAdvancedSql get_AdvancedSql();
    public abstract virtual Task`1<T> QueryByPlanAsync(IQueryPlan`1<T> plan, CancellationToken token);
}
[NullableContextAttribute("1")]
public interface Marten.IReadOnlyAdvancedOptions {
    public EnumStorage DuplicatedFieldEnumStorage { get; }
    public IReadOnlyHiloSettings HiloSequenceDefaults { get; }
    public bool DefaultTenantUsageEnabled { get; }
    public abstract virtual EnumStorage get_DuplicatedFieldEnumStorage();
    public abstract virtual IReadOnlyHiloSettings get_HiloSequenceDefaults();
    public abstract virtual bool get_DefaultTenantUsageEnabled();
}
public interface Marten.IReadOnlyLinqParsing {
    public IReadOnlyList`1<IMemberSource> FieldSources { get; }
    public IReadOnlyList`1<IMethodCallParser> MethodCallParsers { get; }
    public abstract virtual IReadOnlyList`1<IMemberSource> get_FieldSources();
    public abstract virtual IReadOnlyList`1<IMethodCallParser> get_MethodCallParsers();
}
[NullableContextAttribute("1")]
public interface Marten.IReadOnlyStoreOptions {
    public IReadOnlyAdvancedOptions Advanced { get; }
    public string DatabaseSchemaName { get; public set; }
    public IReadOnlyEventStoreOptions Events { get; }
    public IReadOnlyLinqParsing Linq { get; }
    public int NameDataLength { get; }
    public EnumStorage EnumStorage { get; }
    public int UpdateBatchSize { get; }
    public ITenancy Tenancy { get; }
    public IDocumentSchemaResolver Schema { get; }
    public abstract virtual IReadOnlyAdvancedOptions get_Advanced();
    public abstract virtual string get_DatabaseSchemaName();
    public abstract virtual void set_DatabaseSchemaName(string value);
    public abstract virtual IReadOnlyEventStoreOptions get_Events();
    public abstract virtual IReadOnlyLinqParsing get_Linq();
    public abstract virtual int get_NameDataLength();
    public abstract virtual EnumStorage get_EnumStorage();
    public abstract virtual int get_UpdateBatchSize();
    public abstract virtual ITenancy get_Tenancy();
    public abstract virtual ISerializer Serializer();
    public abstract virtual IMartenLogger Logger();
    public abstract virtual IReadOnlyList`1<IDocumentType> AllKnownDocumentTypes();
    public abstract virtual IDocumentType FindOrResolveDocumentType(Type documentType);
    public abstract virtual void AssertDocumentTypeIsSoftDeleted(Type documentType);
    public abstract virtual IDocumentSchemaResolver get_Schema();
    public abstract virtual string MaybeCorrectTenantId(string tenantId);
}
[NullableContextAttribute("1")]
public interface Marten.ISerializer {
    public EnumStorage EnumStorage { get; }
    public Casing Casing { get; }
    public ValueCasting ValueCasting { get; }
    public abstract virtual EnumStorage get_EnumStorage();
    public abstract virtual Casing get_Casing();
    public abstract virtual ValueCasting get_ValueCasting();
    public abstract virtual string ToJson(object document);
    public abstract virtual T FromJson(Stream stream);
    public abstract virtual T FromJson(DbDataReader reader, int index);
    public abstract virtual ValueTask`1<T> FromJsonAsync(Stream stream, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<T> FromJsonAsync(DbDataReader reader, int index, CancellationToken cancellationToken);
    public abstract virtual object FromJson(Type type, Stream stream);
    public abstract virtual object FromJson(Type type, DbDataReader reader, int index);
    public abstract virtual ValueTask`1<object> FromJsonAsync(Type type, Stream stream, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<object> FromJsonAsync(Type type, DbDataReader reader, int index, CancellationToken cancellationToken);
    public abstract virtual string ToCleanJson(object document);
    public abstract virtual string ToJsonWithTypes(object document);
}
public interface Marten.ISessionFactory {
    public abstract virtual IQuerySession QuerySession();
    public abstract virtual IDocumentSession OpenSession();
}
public interface Marten.ITenantOperations {
    [NullableAttribute("1")]
public string TenantId { get; }
    [NullableAttribute("1")]
public IDocumentSession Parent { get; }
    [NullableContextAttribute("1")]
public abstract virtual string get_TenantId();
    [NullableContextAttribute("1")]
public abstract virtual IDocumentSession get_Parent();
}
public interface Marten.ITenantQueryOperations {
    public string TenantId { get; }
    public IQuerySession Parent { get; }
    public abstract virtual string get_TenantId();
    public abstract virtual IQuerySession get_Parent();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.JsonLoader : object {
    private QuerySession _session;
    public JsonLoader(QuerySession session);
    public sealed virtual string FindById(string id);
    public sealed virtual Task`1<string> FindByIdAsync(string id, CancellationToken token);
    public sealed virtual string FindById(int id);
    public sealed virtual string FindById(long id);
    public sealed virtual string FindById(Guid id);
    public sealed virtual Task`1<string> FindByIdAsync(int id, CancellationToken token);
    public sealed virtual Task`1<string> FindByIdAsync(long id, CancellationToken token);
    public sealed virtual Task`1<string> FindByIdAsync(Guid id, CancellationToken token);
    public sealed virtual Task`1<bool> StreamById(int id, Stream destination, CancellationToken token);
    public sealed virtual Task`1<bool> StreamById(long id, Stream destination, CancellationToken token);
    public sealed virtual Task`1<bool> StreamById(string id, Stream destination, CancellationToken token);
    public sealed virtual Task`1<bool> StreamById(Guid id, Stream destination, CancellationToken token);
    public Task`1<string> FindJsonByIdAsync(int id, CancellationToken token);
    private string findJsonById(TId id);
    [AsyncStateMachineAttribute("Marten.JsonLoader/<findJsonByIdAsync>d__16`2")]
private Task`1<string> findJsonByIdAsync(TId id, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.JsonLoader/<streamJsonById>d__17`2")]
private Task`1<bool> streamJsonById(TId id, Stream destination, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.LambdaConfigureMarten : object {
    private Action`2<IServiceProvider, StoreOptions> _configure;
    public LambdaConfigureMarten(Action`2<IServiceProvider, StoreOptions> configure);
    public sealed virtual void Configure(IServiceProvider services, StoreOptions options);
}
internal class Marten.LambdaConfigureMarten`1 : LambdaConfigureMarten {
    [NullableContextAttribute("1")]
public LambdaConfigureMarten`1(Action`2<IServiceProvider, StoreOptions> configure);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.LambdaDocumentPolicy : object {
    private Action`1<DocumentMapping> _modify;
    public LambdaDocumentPolicy(Action`1<DocumentMapping> modify);
    public sealed virtual void Apply(DocumentMapping mapping);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.CollectionUsage : object {
    private bool _hasCompiledMany;
    private StoreOptions _options;
    private Nullable`1<int> _limit;
    private Nullable`1<int> _offset;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SingleValueMode> <SingleValueMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAny>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDistinct>k__BackingField;
    [CompilerGeneratedAttribute]
private CollectionUsage <Inner>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <SelectMany>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<MethodCallExpression> <IncludeExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IIncludePlan> <Includes>k__BackingField;
    private bool _hasParsedIncludes;
    [CompilerGeneratedAttribute]
private List`1<Ordering> <OrderingExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Expression> <WhereExpressions>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Expression <SelectExpression>k__BackingField;
    public Type ElementType { get; }
    public Nullable`1<SingleValueMode> SingleValueMode { get; public set; }
    public bool IsAny { get; public set; }
    public bool IsDistinct { get; public set; }
    public CollectionUsage Inner { get; internal set; }
    public Expression SelectMany { get; public set; }
    public List`1<MethodCallExpression> IncludeExpressions { get; }
    public List`1<IIncludePlan> Includes { get; }
    public List`1<Ordering> OrderingExpressions { get; }
    public List`1<Expression> WhereExpressions { get; }
    [NullableAttribute("2")]
public Expression SelectExpression { get; public set; }
    public CollectionUsage(StoreOptions options, Type elementType);
    public Statement BuildTopStatement(IMartenSession session, IQueryableMemberCollection collection, IDocumentStorage storage, QueryStatistics statistics);
    public Statement BuildSelectManyStatement(IMartenSession session, IQueryableMemberCollection collection, ISelectClause selectClause, QueryStatistics statistics, SelectorStatement parentStatement);
    internal Statement ConfigureSelectManyStatement(IMartenSession session, IQueryableMemberCollection collection, SelectorStatement statement, QueryStatistics statistics);
    private Statement compileNext(IMartenSession session, IQueryableMemberCollection collection, SelectorStatement statement, QueryStatistics statistics);
    public Statement CompileSelectMany(IMartenSession session, SelectorStatement parentStatement, ICollectionMember collectionMember, QueryStatistics statistics);
    public void CompileAsChild(CollectionUsage parent);
    internal void ProcessSingleValueModeIfAny(SelectorStatement statement, IMartenSession session, IQueryableMemberCollection members, QueryStatistics statistics);
    [CompilerGeneratedAttribute]
public Type get_ElementType();
    [CompilerGeneratedAttribute]
public Nullable`1<SingleValueMode> get_SingleValueMode();
    [CompilerGeneratedAttribute]
public void set_SingleValueMode(Nullable`1<SingleValueMode> value);
    [CompilerGeneratedAttribute]
public bool get_IsAny();
    [CompilerGeneratedAttribute]
public void set_IsAny(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDistinct();
    [CompilerGeneratedAttribute]
public void set_IsDistinct(bool value);
    [CompilerGeneratedAttribute]
public CollectionUsage get_Inner();
    [CompilerGeneratedAttribute]
internal void set_Inner(CollectionUsage value);
    [CompilerGeneratedAttribute]
public Expression get_SelectMany();
    [CompilerGeneratedAttribute]
public void set_SelectMany(Expression value);
    public void WriteLimit(int limit);
    public void WriteOffset(int offset);
    [CompilerGeneratedAttribute]
public List`1<MethodCallExpression> get_IncludeExpressions();
    [CompilerGeneratedAttribute]
public List`1<IIncludePlan> get_Includes();
    public void ParseIncludes(IQueryableMemberCollection collection, IMartenSession session);
    [CompilerGeneratedAttribute]
public List`1<Ordering> get_OrderingExpressions();
    [CompilerGeneratedAttribute]
public List`1<Expression> get_WhereExpressions();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Expression get_SelectExpression();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_SelectExpression(Expression value);
    public void AddWhereClause(MethodCallExpression expression);
    public void AddSelectClause(MethodCallExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.ConfigureExplainExpressions : object {
    private StringBuilder toOptions;
    public sealed virtual IConfigureExplainExpressions Analyze();
    public sealed virtual IConfigureExplainExpressions Verbose();
    public sealed virtual IConfigureExplainExpressions Costs();
    public sealed virtual IConfigureExplainExpressions Buffers();
    public sealed virtual IConfigureExplainExpressions Timing();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Marten.Linq.CreatedAt.CreatedAtExtensions : object {
    [ExtensionAttribute]
public static bool CreatedSince(object doc, DateTimeOffset time);
    [ExtensionAttribute]
public static bool CreatedBefore(object doc, DateTimeOffset time);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.CreatedAt.CreatedBeforeParser : object {
    private static MethodInfo _method;
    private static CreatedBeforeParser();
    public sealed virtual bool Matches(MethodCallExpression expression);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.CreatedAt.CreatedSinceParser : object {
    private static MethodInfo _method;
    private static CreatedSinceParser();
    public sealed virtual bool Matches(MethodCallExpression expression);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
public enum Marten.Linq.FetchType : Enum {
    public int value__;
    public static FetchType FetchOne;
    public static FetchType FetchMany;
    public static FetchType Count;
    public static FetchType Any;
}
public interface Marten.Linq.ICompiledListQuery`1 {
}
[NullableContextAttribute("2")]
public interface Marten.Linq.ICompiledListQuery`2 {
}
public interface Marten.Linq.ICompiledQuery`1 {
}
[NullableContextAttribute("1")]
public interface Marten.Linq.ICompiledQuery`2 {
    public abstract virtual Expression`1<Func`2<IMartenQueryable`1<TDoc>, TOut>> QueryIs();
}
public interface Marten.Linq.ICompiledQueryMarker {
}
[NullableContextAttribute("1")]
public interface Marten.Linq.IConfigureExplainExpressions {
    public abstract virtual IConfigureExplainExpressions Analyze();
    public abstract virtual IConfigureExplainExpressions Verbose();
    public abstract virtual IConfigureExplainExpressions Costs();
    public abstract virtual IConfigureExplainExpressions Buffers();
    public abstract virtual IConfigureExplainExpressions Timing();
}
[NullableContextAttribute("1")]
public interface Marten.Linq.ILinqQuery {
    public CollectionUsage CurrentUsage { get; }
    public abstract virtual CollectionUsage get_CurrentUsage();
    public abstract virtual CollectionUsage CollectionUsageFor(MethodCallExpression expression);
    public abstract virtual CollectionUsage CollectionUsageForArgument(Expression argument);
    public abstract virtual CollectionUsage StartNewCollectionUsageFor(MethodCallExpression expression);
    public abstract virtual CollectionUsage CollectionUsageFor(Type elementType);
}
[NullableContextAttribute("1")]
internal interface Marten.Linq.IMartenLinqQueryable {
    public MartenLinqQueryProvider MartenProvider { get; }
    public QuerySession Session { get; }
    public Expression Expression { get; }
    public abstract virtual MartenLinqQueryProvider get_MartenProvider();
    public abstract virtual QuerySession get_Session();
    public abstract virtual Expression get_Expression();
    public abstract virtual LinqQueryParser BuildLinqParser();
}
[NullableContextAttribute("1")]
public interface Marten.Linq.IMartenQueryable`1 {
    public abstract virtual IMartenQueryable`1<T> Include(Expression`1<Func`2<T, object>> idSource, Action`1<TInclude> callback);
    public abstract virtual IMartenQueryable`1<T> Include(Expression`1<Func`2<T, object>> idSource, Action`1<TInclude> callback, Expression`1<Func`2<TInclude, bool>> filter);
    public abstract virtual IMartenQueryable`1<T> Include(Expression`1<Func`2<T, object>> idSource, IList`1<TInclude> list);
    public abstract virtual IMartenQueryable`1<T> Include(Expression`1<Func`2<T, object>> idSource, IList`1<TInclude> list, Expression`1<Func`2<TInclude, bool>> filter);
    public abstract virtual IMartenQueryable`1<T> Include(Expression`1<Func`2<T, object>> idSource, IDictionary`2<TKey, TInclude> dictionary);
    public abstract virtual IMartenQueryable`1<T> Include(Expression`1<Func`2<T, object>> idSource, IDictionary`2<TKey, TInclude> dictionary, Expression`1<Func`2<TInclude, bool>> filter);
    public abstract virtual IMartenQueryableIncludeBuilder`2<T, TInclude> Include(Action`1<TInclude> callback);
    public abstract virtual IMartenQueryableIncludeBuilder`2<T, TInclude> Include(IList`1<TInclude> list);
    public abstract virtual IMartenQueryableIncludeBuilder`3<T, TKey, TInclude> Include(IDictionary`2<TKey, TInclude> dictionary);
    public abstract virtual IMartenQueryableIncludeBuilder`3<T, TKey, TInclude> Include(IDictionary`2<TKey, IList`1<TInclude>> dictionary);
    public abstract virtual IMartenQueryableIncludeBuilder`3<T, TKey, TInclude> Include(IDictionary`2<TKey, List`1<TInclude>> dictionary);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Marten.Linq.Includes.DictionaryIncludePlan`2 : IncludePlan`1<T> {
    public DictionaryIncludePlan`2(IDocumentStorage`1<T> storage, IQueryableMember connectingMember, IDictionary`2<TId, T> dictionary);
    public static Action`1<T> BuildAction(IDocumentStorage`1<T> storage, IDictionary`2<TId, T> dictionary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Includes.IdInIncludedDocumentIdentifierFilter : object {
    private IQueryableMember _connectingMember;
    [NullableAttribute("2")]
private IQueryableMember _identifyingMember;
    private string _fromObject;
    public IdInIncludedDocumentIdentifierFilter(string fromObject, IQueryableMember connectingMember, IQueryableMember identifyingMember);
    public sealed virtual void Apply(ICommandBuilder builder);
}
[NullableContextAttribute("1")]
public interface Marten.Linq.Includes.IIncludePlan {
    public Type DocumentType { get; }
    public Expression Where { get; public set; }
    public abstract virtual Type get_DocumentType();
    public abstract virtual Expression get_Where();
    public abstract virtual void set_Where(Expression value);
    public abstract virtual IIncludeReader BuildReader(IMartenSession session);
    public abstract virtual void AppendStatement(TemporaryTableStatement tempTable, IMartenSession martenSession, ITenantFilter tenantFilter);
}
[NullableContextAttribute("1")]
internal interface Marten.Linq.Includes.IIncludeQueryHandler`1 {
    public IQueryHandler`1<T> Inner { get; }
    public abstract virtual IQueryHandler`1<T> get_Inner();
}
[NullableContextAttribute("1")]
public interface Marten.Linq.Includes.IIncludeReader {
    public abstract virtual void Read(DbDataReader reader);
    public abstract virtual Task ReadAsync(DbDataReader reader, CancellationToken token);
}
[NullableContextAttribute("1")]
public interface Marten.Linq.Includes.IMartenQueryableIncludeBuilder`2 {
    public abstract virtual IMartenQueryable`1<T> On(Expression`1<Func`2<T, object>> idSource);
    public abstract virtual IMartenQueryable`1<T> On(Expression`1<Func`2<T, object>> idSource, Expression`1<Func`2<TInclude, bool>> filter);
    public abstract virtual IMartenQueryable`1<T> On(Expression`1<Func`2<T, TId>> idSource, Expression`1<Func`2<TInclude, TId>> idMapping);
    public abstract virtual IMartenQueryable`1<T> On(Expression`1<Func`2<T, TId>> idSource, Expression`1<Func`2<TInclude, TId>> idMapping, Expression`1<Func`2<TInclude, bool>> filter);
}
[NullableContextAttribute("1")]
public interface Marten.Linq.Includes.IMartenQueryableIncludeBuilder`3 {
    public abstract virtual IMartenQueryable`1<T> On(Expression`1<Func`2<T, object>> idSource);
    public abstract virtual IMartenQueryable`1<T> On(Expression`1<Func`2<T, object>> idSource, Expression`1<Func`2<TInclude, bool>> filter);
    public abstract virtual IMartenQueryable`1<T> On(Expression`1<Func`2<T, TKey>> idSource, Expression`1<Func`2<TInclude, TKey>> idMapping);
    public abstract virtual IMartenQueryable`1<T> On(Expression`1<Func`2<T, TKey>> idSource, Expression`1<Func`2<TInclude, TKey>> idMapping, Expression`1<Func`2<TInclude, bool>> filter);
    public abstract virtual IMartenQueryable`1<T> On(Expression`1<Func`2<T, Nullable`1<TId>>> idSource, Expression`1<Func`2<TInclude, Nullable`1<TId>>> idMapping);
    public abstract virtual IMartenQueryable`1<T> On(Expression`1<Func`2<T, Nullable`1<TId>>> idSource, Expression`1<Func`2<TInclude, Nullable`1<TId>>> idMapping, Expression`1<Func`2<TInclude, bool>> filter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Marten.Linq.Includes.Include : object {
    public static IIncludeReader ReaderToAction(IMartenSession session, Action`1<T> action);
    public static IIncludeReader ReaderToList(IMartenSession session, IList`1<T> list);
    public static IIncludeReader ReaderToDictionary(IMartenSession session, IDictionary`2<TId, T> dictionary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Includes.IncludePlan`1 : object {
    private Action`1<T> _callback;
    private IQueryableMember _connectingMember;
    [NullableAttribute("2")]
private IQueryableMember _mappingMember;
    private IDocumentStorage`1<T> _storage;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Expression <Where>k__BackingField;
    public Type DocumentType { get; }
    [NullableAttribute("2")]
public Expression Where { get; public set; }
    public IncludePlan`1(IDocumentStorage`1<T> storage, IQueryableMember connectingMember, Action`1<T> callback);
    public IncludePlan`1(IDocumentStorage`1<T> storage, IQueryableMember connectingMember, IQueryableMember mappingMember, Action`1<T> callback);
    public sealed virtual Type get_DocumentType();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Expression get_Where();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_Where(Expression value);
    public sealed virtual IIncludeReader BuildReader(IMartenSession session);
    public sealed virtual void AppendStatement(TemporaryTableStatement tempTable, IMartenSession martenSession, ITenantFilter tenantFilter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.Includes.IncludeQueryHandler`1 : object {
    private IIncludeReader[] _readers;
    [CompilerGeneratedAttribute]
private IQueryHandler`1<T> <Inner>k__BackingField;
    public IQueryHandler`1<T> Inner { get; }
    public IncludeQueryHandler`1(IQueryHandler`1<T> inner, IIncludeReader[] readers);
    [CompilerGeneratedAttribute]
public sealed virtual IQueryHandler`1<T> get_Inner();
    public sealed virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual Task`1<int> StreamJson(Stream stream, DbDataReader reader, CancellationToken token);
    public sealed virtual T Handle(DbDataReader reader, IMartenSession session);
    [AsyncStateMachineAttribute("Marten.Linq.Includes.IncludeQueryHandler`1/<HandleAsync>d__8")]
public sealed virtual Task`1<T> HandleAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Includes.IncludeReader`1 : object {
    private Action`1<T> _callback;
    private ISelector`1<T> _selector;
    public IncludeReader`1(Action`1<T> callback, ISelector`1<T> selector);
    public sealed virtual void Read(DbDataReader reader);
    [AsyncStateMachineAttribute("Marten.Linq.Includes.IncludeReader`1/<ReadAsync>d__4")]
public sealed virtual Task ReadAsync(DbDataReader reader, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Marten.Linq.Includes.ListIncludePlan`1 : IncludePlan`1<T> {
    public ListIncludePlan`1(IDocumentStorage`1<T> storage, IQueryableMember connectingMember, IList`1<T> list);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Includes.MartenQueryableIncludeBuilder`2 : object {
    private MartenLinqQueryable`1<T> _martenLinqQueryable;
    private Action`1<TInclude> _callback;
    public MartenQueryableIncludeBuilder`2(MartenLinqQueryable`1<T> martenLinqQueryable, Action`1<TInclude> callback);
    public sealed virtual IMartenQueryable`1<T> On(Expression`1<Func`2<T, object>> idSource);
    public sealed virtual IMartenQueryable`1<T> On(Expression`1<Func`2<T, object>> idSource, Expression`1<Func`2<TInclude, bool>> filter);
    public sealed virtual IMartenQueryable`1<T> On(Expression`1<Func`2<T, TId>> idSource, Expression`1<Func`2<TInclude, TId>> idMapping);
    public sealed virtual IMartenQueryable`1<T> On(Expression`1<Func`2<T, TId>> idSource, Expression`1<Func`2<TInclude, TId>> idMapping, Expression`1<Func`2<TInclude, bool>> filter);
    internal IIncludePlan BuildInclude(Expression`1<Func`2<T, object>> idSource, Expression where);
    internal IIncludePlan BuildInclude(Expression`1<Func`2<T, TId>> idSource, Expression`1<Func`2<TInclude, TId>> idMapping, Expression where);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Includes.MartenQueryableIncludeBuilder`3 : object {
    private MartenLinqQueryable`1<T> _martenLinqQueryable;
    private Action`2<TKey, TInclude> _dictionaryCallback;
    public MartenQueryableIncludeBuilder`3(MartenLinqQueryable`1<T> martenLinqQueryable, IDictionary`2<TKey, TInclude> dictionary);
    public MartenQueryableIncludeBuilder`3(MartenLinqQueryable`1<T> martenLinqQueryable, IDictionary`2<TKey, IList`1<TInclude>> dictionary);
    public MartenQueryableIncludeBuilder`3(MartenLinqQueryable`1<T> martenLinqQueryable, IDictionary`2<TKey, List`1<TInclude>> dictionary);
    public sealed virtual IMartenQueryable`1<T> On(Expression`1<Func`2<T, object>> idSource);
    public sealed virtual IMartenQueryable`1<T> On(Expression`1<Func`2<T, object>> idSource, Expression`1<Func`2<TInclude, bool>> filter);
    public sealed virtual IMartenQueryable`1<T> On(Expression`1<Func`2<T, TKey>> idSource, Expression`1<Func`2<TInclude, TKey>> idMapping);
    public sealed virtual IMartenQueryable`1<T> On(Expression`1<Func`2<T, TKey>> idSource, Expression`1<Func`2<TInclude, TKey>> idMapping, Expression`1<Func`2<TInclude, bool>> filter);
    public sealed virtual IMartenQueryable`1<T> On(Expression`1<Func`2<T, Nullable`1<TId>>> idSource, Expression`1<Func`2<TInclude, Nullable`1<TId>>> idMapping);
    public sealed virtual IMartenQueryable`1<T> On(Expression`1<Func`2<T, Nullable`1<TId>>> idSource, Expression`1<Func`2<TInclude, Nullable`1<TId>>> idMapping, Expression`1<Func`2<TInclude, bool>> filter);
    internal IIncludePlan BuildInclude(Expression`1<Func`2<T, object>> idSource);
    internal IIncludePlan BuildInclude(Expression`1<Func`2<T, TKey>> idSource, Expression`1<Func`2<TInclude, TKey>> idMapping);
    internal IIncludePlan BuildInclude(Expression`1<Func`2<T, Nullable`1<TId>>> idSource, Expression`1<Func`2<TInclude, Nullable`1<TId>>> idMapping);
}
internal class Marten.Linq.Includes.PassthroughSelectStatement : SelectorStatement {
    [CompilerGeneratedAttribute]
private string <TableName>k__BackingField;
    public string FromObject { get; }
    public string TableName { get; public set; }
    public PassthroughSelectStatement(string tableName, ISelectClause innerSelectClause);
    public virtual string get_FromObject();
    [CompilerGeneratedAttribute]
public string get_TableName();
    [CompilerGeneratedAttribute]
public void set_TableName(string value);
    protected virtual void configure(ICommandBuilder sql);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.Includes.TemporaryTableStatement : Statement {
    [CompilerGeneratedAttribute]
private Statement <Inner>k__BackingField;
    public Statement Inner { get; }
    public TemporaryTableStatement(Statement inner, IMartenSession session);
    [CompilerGeneratedAttribute]
public Statement get_Inner();
    protected virtual void configure(ICommandBuilder sql);
}
public interface Marten.Linq.IQueryPlanning {
    public abstract virtual void SetUniqueValuesForQueryPlanning();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Marten.Linq.LastModified.LastModifiedExtensions : object {
    [ExtensionAttribute]
public static bool ModifiedSince(object doc, DateTimeOffset time);
    [ExtensionAttribute]
public static bool ModifiedBefore(object doc, DateTimeOffset time);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.LastModified.ModifiedBeforeParser : object {
    private static MethodInfo _method;
    private static ModifiedBeforeParser();
    public sealed virtual bool Matches(MethodCallExpression expression);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.LastModified.ModifiedSinceParser : object {
    private static MethodInfo _method;
    private static ModifiedSinceParser();
    public sealed virtual bool Matches(MethodCallExpression expression);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.MartenLinqQueryable`1 : object {
    [CompilerGeneratedAttribute]
private MartenLinqQueryProvider <MartenProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private QuerySession <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryProvider <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    public QueryStatistics Statistics { get; public set; }
    public MartenLinqQueryProvider MartenProvider { get; }
    public QuerySession Session { get; }
    public Type ElementType { get; }
    public IQueryProvider Provider { get; }
    public Expression Expression { get; }
    public MartenLinqQueryable`1(QuerySession session, MartenLinqQueryProvider provider, Expression expression);
    public MartenLinqQueryable`1(QuerySession session);
    public MartenLinqQueryable`1(QuerySession session, Expression expression);
    public QueryStatistics get_Statistics();
    public void set_Statistics(QueryStatistics value);
    [CompilerGeneratedAttribute]
public sealed virtual MartenLinqQueryProvider get_MartenProvider();
    [CompilerGeneratedAttribute]
public sealed virtual QuerySession get_Session();
    public sealed virtual LinqQueryParser BuildLinqParser();
    public sealed virtual IMartenQueryable`1<T> Include(Expression`1<Func`2<T, object>> idSource, Action`1<TInclude> callback);
    public sealed virtual IMartenQueryable`1<T> Include(Expression`1<Func`2<T, object>> idSource, IList`1<TInclude> list);
    public sealed virtual IMartenQueryable`1<T> Include(Expression`1<Func`2<T, object>> idSource, IList`1<TInclude> list, Expression`1<Func`2<TInclude, bool>> filter);
    public sealed virtual IMartenQueryable`1<T> Include(Expression`1<Func`2<T, object>> idSource, Action`1<TInclude> callback, Expression`1<Func`2<TInclude, bool>> filter);
    public sealed virtual IMartenQueryable`1<T> Include(Expression`1<Func`2<T, object>> idSource, IDictionary`2<TKey, TInclude> dictionary);
    public sealed virtual IMartenQueryable`1<T> Include(Expression`1<Func`2<T, object>> idSource, IDictionary`2<TKey, TInclude> dictionary, Expression`1<Func`2<TInclude, bool>> filter);
    public sealed virtual IMartenQueryableIncludeBuilder`2<T, TInclude> Include(Action`1<TInclude> callback);
    public sealed virtual IMartenQueryableIncludeBuilder`2<T, TInclude> Include(IList`1<TInclude> list);
    public sealed virtual IMartenQueryableIncludeBuilder`3<T, TKey, TInclude> Include(IDictionary`2<TKey, TInclude> dictionary);
    public sealed virtual IMartenQueryableIncludeBuilder`3<T, TKey, TInclude> Include(IDictionary`2<TKey, IList`1<TInclude>> dictionary);
    public sealed virtual IMartenQueryableIncludeBuilder`3<T, TKey, TInclude> Include(IDictionary`2<TKey, List`1<TInclude>> dictionary);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual Type get_ElementType();
    [CompilerGeneratedAttribute]
public sealed virtual IQueryProvider get_Provider();
    [CompilerGeneratedAttribute]
public sealed virtual Expression get_Expression();
    internal IQueryHandler`1<IReadOnlyList`1<T>> BuilderListHandler();
    [AsyncStateMachineAttribute("Marten.Linq.MartenLinqQueryable`1/<ToListAsync>d__35`1")]
public Task`1<IReadOnlyList`1<TResult>> ToListAsync(CancellationToken token);
    public IAsyncEnumerable`1<T> ToAsyncEnumerable(CancellationToken token);
    public Task`1<bool> AnyAsync(CancellationToken token);
    public Task`1<int> CountAsync(CancellationToken token);
    public Task`1<long> CountLongAsync(CancellationToken token);
    public Task`1<TResult> FirstAsync(CancellationToken token);
    [NullableContextAttribute("2")]
public Task`1<TResult> FirstOrDefaultAsync(CancellationToken token);
    public Task`1<TResult> SingleAsync(CancellationToken token);
    [NullableContextAttribute("2")]
public Task`1<TResult> SingleOrDefaultAsync(CancellationToken token);
    public Task`1<TResult> SumAsync(CancellationToken token);
    public Task`1<TResult> MinAsync(CancellationToken token);
    public Task`1<TResult> MaxAsync(CancellationToken token);
    public Task`1<double> AverageAsync(CancellationToken token);
    public QueryPlan Explain(FetchType fetchType, Action`1<IConfigureExplainExpressions> configureExplain);
    public IMartenQueryable`1<T> Stats(QueryStatistics& stats);
    internal IQueryHandler`1<TResult> BuildHandler(Nullable`1<SingleValueMode> mode);
    public Task`1<int> StreamJsonArray(Stream destination, CancellationToken token);
    public NpgsqlCommand ToPreviewCommand(FetchType fetchType);
    [AsyncStateMachineAttribute("Marten.Linq.MartenLinqQueryable`1/<ToJsonArray>d__53")]
public Task`1<string> ToJsonArray(CancellationToken token);
    public Task StreamJsonFirst(Stream destination, CancellationToken token);
    public Task`1<int> StreamJsonFirstOrDefault(Stream destination, CancellationToken token);
    public Task StreamJsonSingle(Stream destination, CancellationToken token);
    public Task`1<int> StreamJsonSingleOrDefault(Stream destination, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Linq.MartenLinqQueryable`1/<ToJsonFirst>d__58")]
public Task`1<string> ToJsonFirst(CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Linq.MartenLinqQueryable`1/<ToJsonFirstOrDefault>d__59")]
public Task`1<string> ToJsonFirstOrDefault(CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Linq.MartenLinqQueryable`1/<ToJsonSingle>d__60")]
public Task`1<string> ToJsonSingle(CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Linq.MartenLinqQueryable`1/<ToJsonSingleOrDefault>d__61")]
public Task`1<string> ToJsonSingleOrDefault(CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.MartenLinqQueryProvider : object {
    private QuerySession _session;
    [CompilerGeneratedAttribute]
private Type <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryStatistics <Statistics>k__BackingField;
    public Type SourceType { get; }
    internal QueryStatistics Statistics { get; internal set; }
    public MartenLinqQueryProvider(QuerySession session, Type type);
    [CompilerGeneratedAttribute]
public Type get_SourceType();
    [CompilerGeneratedAttribute]
internal QueryStatistics get_Statistics();
    [CompilerGeneratedAttribute]
internal void set_Statistics(QueryStatistics value);
    public sealed virtual IQueryable CreateQuery(Expression expression);
    public sealed virtual IQueryable`1<TElement> CreateQuery(Expression expression);
    public sealed virtual object Execute(Expression expression);
    public sealed virtual TResult Execute(Expression expression);
    private void ensureStorageExists(LinqQueryParser parser);
    [AsyncStateMachineAttribute("Marten.Linq.MartenLinqQueryProvider/<EnsureStorageExistsAsync>d__14")]
internal ValueTask EnsureStorageExistsAsync(LinqQueryParser parser, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Marten.Linq.MartenLinqQueryProvider/<ExecuteAsync>d__15`1")]
public Task`1<TResult> ExecuteAsync(Expression expression, CancellationToken token, SingleValueMode valueMode);
    [AsyncStateMachineAttribute("Marten.Linq.MartenLinqQueryProvider/<StreamJson>d__16`1")]
public Task`1<int> StreamJson(Stream stream, Expression expression, CancellationToken token, SingleValueMode mode);
    [AsyncStateMachineAttribute("Marten.Linq.MartenLinqQueryProvider/<ExecuteHandlerAsync>d__17`1")]
public Task`1<T> ExecuteHandlerAsync(IQueryHandler`1<T> handler, CancellationToken token);
    [NullableContextAttribute("2")]
public T ExecuteHandler(IQueryHandler`1<T> handler);
    [AsyncIteratorStateMachineAttribute("Marten.Linq.MartenLinqQueryProvider/<ExecuteAsyncEnumerable>d__19`1")]
public IAsyncEnumerable`1<T> ExecuteAsyncEnumerable(Expression expression, MartenLinqQueryProvider martenProvider, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Linq.MartenLinqQueryProvider/<StreamMany>d__20")]
public Task`1<int> StreamMany(Expression expression, Stream destination, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Linq.MartenLinqQueryProvider/<StreamOne>d__21")]
public Task`1<bool> StreamOne(Expression expression, Stream destination, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.MatchesSql.LiteralSqlWithJsonPath : object {
    private string _sql;
    private Object[] _parameters;
    public LiteralSqlWithJsonPath(string sql, Object[] parameters);
    public sealed virtual void Apply(ICommandBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.MatchesSql.MatchesJsonPathParser : object {
    private static MethodInfo _sqlMethod;
    private static MatchesJsonPathParser();
    public sealed virtual bool Matches(MethodCallExpression expression);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Marten.Linq.MatchesSql.MatchesSqlExtensions : object {
    [ExtensionAttribute]
public static bool MatchesSql(object doc, ISqlFragment whereFragment);
    [ExtensionAttribute]
public static bool MatchesSql(object doc, string sql, Object[] parameters);
    [ExtensionAttribute]
public static bool MatchesJsonPath(object doc, string sql, Object[] parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.MatchesSql.MatchesSqlParser : object {
    private static MethodInfo _sqlMethod;
    private static MethodInfo _fragmentMethod;
    private static MatchesSqlParser();
    public sealed virtual bool Matches(MethodCallExpression expression);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.AllCollectionConditionFilter : object {
    private ISqlFragment _filter;
    private string _exportName;
    [CompilerGeneratedAttribute]
private ICollectionMember <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ISqlFragment> <Wheres>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Not>k__BackingField;
    public ICollectionMember Member { get; }
    public List`1<ISqlFragment> Wheres { get; }
    public bool Not { get; public set; }
    public AllCollectionConditionFilter(ICollectionMember member);
    [CompilerGeneratedAttribute]
public ICollectionMember get_Member();
    [CompilerGeneratedAttribute]
public List`1<ISqlFragment> get_Wheres();
    public sealed virtual void Apply(ICommandBuilder builder);
    [CompilerGeneratedAttribute]
public bool get_Not();
    [CompilerGeneratedAttribute]
public void set_Not(bool value);
    public sealed virtual ISqlFragment Reverse();
    public sealed virtual void PlaceUnnestAbove(IMartenSession session, SelectorStatement statement, ISqlFragment topLevelWhere);
    public sealed virtual void Register(ISqlFragment fragment);
    public void Compile(MethodCallExpression methodCallExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.AllMembersAreNotNullFilter : object {
    private IQueryableMember _member;
    public AllMembersAreNotNullFilter(IQueryableMember member);
    public sealed virtual void Apply(ICommandBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.AllMembersAreNullFilter : object {
    private IQueryableMember _member;
    public AllMembersAreNullFilter(IQueryableMember member);
    public sealed virtual void Apply(ICommandBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.ArrayIsEmptyFilter : object {
    private DuplicatedArrayField _member;
    private string _text;
    public ArrayIsEmptyFilter(DuplicatedArrayField member);
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual ISqlFragment Reverse();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.ArrayIsNotEmptyFilter : object {
    private string _text;
    private DuplicatedArrayField _member;
    public ArrayIsNotEmptyFilter(DuplicatedArrayField member);
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual ISqlFragment Reverse();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.ArrayLengthMember : QueryableMember {
    [CompilerGeneratedAttribute]
private ICollectionMember <Parent>k__BackingField;
    public ICollectionMember Parent { get; }
    public ArrayLengthMember(DuplicatedArrayField parent);
    [CompilerGeneratedAttribute]
public ICollectionMember get_Parent();
    public virtual ISqlFragment CreateComparison(string op, ConstantExpression constant);
}
internal class Marten.Linq.Members.BooleanMember : QueryableMember {
    [NullableContextAttribute("1")]
public BooleanMember(IQueryableMember parent, Casing casing, MemberInfo member, string pgType);
    [NullableContextAttribute("1")]
public sealed virtual ISqlFragment BuildIsTrueFragment();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.ChildCollectionCount : object {
    private ICollectionMember _collection;
    private ISerializer _serializer;
    [CompilerGeneratedAttribute]
private List`1<ISqlFragment> <Wheres>k__BackingField;
    public List`1<ISqlFragment> Wheres { get; }
    public ChildCollectionCount(ICollectionMember collection, ISerializer serializer);
    [CompilerGeneratedAttribute]
public List`1<ISqlFragment> get_Wheres();
    public sealed virtual ISqlFragment CreateComparison(string op, ConstantExpression constant);
    private sealed virtual override void Weasel.Postgresql.SqlGeneration.IWhereFragmentHolder.Register(ISqlFragment fragment);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.ChildCollectionJsonPathCountFilter : object {
    private ConstantExpression _constant;
    private ICollectionAware[] _filters;
    private ICollectionMember _member;
    private string _op;
    private ISerializer _serializer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<DictionaryValueUsage> _usages;
    private bool _hasGenerated;
    private Dictionary`2<string, object> _dict;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    [NullableAttribute("2")]
public string ParameterName { get; private set; }
    public ChildCollectionJsonPathCountFilter(ICollectionMember member, ISerializer serializer, IEnumerable`1<ICollectionAware> filters, string op, ConstantExpression constant);
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual bool TryMatchValue(object value, MemberInfo member);
    public sealed virtual void GenerateCode(GeneratedMethod method, int parameterIndex, string parametersVariableName);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ParameterName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_ParameterName(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.ChildCollectionMember : QueryableMember {
    private IQueryableMember _count;
    private StoreOptions _options;
    private RootMember _root;
    private ImHashMap`2<string, IQueryableMember> _members;
    private string _arraySelector;
    [CompilerGeneratedAttribute]
private ISqlFragment <IsEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private ISqlFragment <NotEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ArrayLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExplodeLocator>k__BackingField;
    public ISqlFragment IsEmpty { get; }
    public ISqlFragment NotEmpty { get; }
    public string ArrayLocator { get; public set; }
    public Type ElementType { get; }
    public string ExplodeLocator { get; }
    public ChildCollectionMember(StoreOptions options, IQueryableMember parent, Casing casing, MemberInfo member, Type memberType);
    [CompilerGeneratedAttribute]
public sealed virtual ISqlFragment get_IsEmpty();
    [CompilerGeneratedAttribute]
public sealed virtual ISqlFragment get_NotEmpty();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ArrayLocator();
    [CompilerGeneratedAttribute]
public void set_ArrayLocator(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ElementType();
    public sealed virtual ISqlFragment ParseWhereForAny(Expression body, IReadOnlyStoreOptions options);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExplodeLocator();
    public virtual void PlaceValueInDictionaryForContainment(Dictionary`2<string, object> dict, ConstantExpression constant);
    public sealed virtual Statement AttachSelectManyStatement(CollectionUsage collectionUsage, IMartenSession session, SelectorStatement parentStatement, QueryStatistics statistics);
    public sealed virtual ISelectClause BuildSelectClauseForExplosion(string fromObject);
    public sealed virtual IComparableMember ParseComparableForCount(Expression body);
    public sealed virtual ISqlFragment ParseWhereForAll(MethodCallExpression method, IReadOnlyStoreOptions options);
    public sealed virtual ISqlFragment ParseWhereForContains(MethodCallExpression body, IReadOnlyStoreOptions options);
    public virtual IQueryableMember FindMember(MemberInfo member);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<IQueryableMember> GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.ChildCollectionWhereClause : object {
    private ISqlFragment _fragment;
    public ISqlFragment Fragment { get; }
    public sealed virtual void Register(ISqlFragment fragment);
    public ISqlFragment get_Fragment();
    public static bool TryBuildInlineFragment(ISqlFragment fragment, ICollectionMember collectionMember, ISerializer serializer, ICollectionAwareFilter& filter);
    public ISqlFragment CompileFragment(ICollectionMember collectionMember, ISerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.ChildDocument : QueryableMember {
    private StoreOptions _options;
    private ImHashMap`2<string, IQueryableMember> _members;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    public Type ElementType { get; }
    public ChildDocument(StoreOptions options, IQueryableMember parent, Casing casing, MemberInfo member);
    public virtual ISqlFragment CreateComparison(string op, ConstantExpression constant);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ElementType();
    public virtual IQueryableMember FindMember(MemberInfo member);
    public virtual void ReplaceMember(MemberInfo member, IQueryableMember queryableMember);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<IQueryableMember> GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.CollectionLengthMember : QueryableMember {
    [CompilerGeneratedAttribute]
private ICollectionMember <Parent>k__BackingField;
    public ICollectionMember Parent { get; }
    public CollectionLengthMember(ICollectionMember parent);
    [CompilerGeneratedAttribute]
public ICollectionMember get_Parent();
    public virtual ISqlFragment CreateComparison(string op, ConstantExpression constant);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.CompareAllWithinCollectionFilter : object {
    private MemberComparisonFilter _inner;
    public CompareAllWithinCollectionFilter(MemberComparisonFilter inner);
    public sealed virtual void Apply(ICommandBuilder builder);
}
public class Marten.Linq.Members.DateTimeMember : QueryableMember {
    [NullableContextAttribute("1")]
public DateTimeMember(StoreOptions options, IQueryableMember parent, Casing casing, MemberInfo member);
    [NullableContextAttribute("1")]
public virtual string SelectorForDuplication(string pgType);
}
public class Marten.Linq.Members.DateTimeOffsetMember : QueryableMember {
    [NullableContextAttribute("1")]
public DateTimeOffsetMember(StoreOptions options, IQueryableMember parent, Casing casing, MemberInfo member);
    [NullableContextAttribute("1")]
public virtual string SelectorForDuplication(string pgType);
}
internal class Marten.Linq.Members.Dictionaries.DictionaryContainsKey : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Matches(MethodCallExpression expression);
    [NullableContextAttribute("1")]
public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.Dictionaries.DictionaryContainsKeyFilter : object {
    private string _keyText;
    private IDictionaryMember _member;
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public DictionaryContainsKeyFilter(IDictionaryMember member, ISerializer serializer, ConstantExpression constant);
    public DictionaryContainsKeyFilter(IDictionaryMember member, ISerializer serializer, object value);
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual bool TryMatchValue(object value, MemberInfo member);
    public sealed virtual void GenerateCode(GeneratedMethod method, int parameterIndex, string parametersVariableName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ParameterName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.Dictionaries.DictionaryCountMember : QueryableMember {
    [CompilerGeneratedAttribute]
private ICollectionMember <Parent>k__BackingField;
    public ICollectionMember Parent { get; }
    public DictionaryCountMember(IDictionaryMember parent);
    [CompilerGeneratedAttribute]
public ICollectionMember get_Parent();
    public virtual ISqlFragment CreateComparison(string op, ConstantExpression constant);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.Dictionaries.DictionaryIsEmpty : object {
    private IDictionaryMember _parent;
    private string _text;
    public DictionaryIsEmpty(IDictionaryMember parent);
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual ISqlFragment Reverse();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.Dictionaries.DictionaryIsNotEmpty : object {
    private IDictionaryMember _parent;
    private string _text;
    public DictionaryIsNotEmpty(IDictionaryMember parent);
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual ISqlFragment Reverse();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.Dictionaries.DictionaryItemMember`2 : QueryableMember {
    [CompilerGeneratedAttribute]
private DictionaryMember`2<TKey, TValue> <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    public DictionaryMember`2<TKey, TValue> Parent { get; }
    public TKey Key { get; }
    public DictionaryItemMember`2(DictionaryMember`2<TKey, TValue> parent, TKey key);
    [CompilerGeneratedAttribute]
public DictionaryMember`2<TKey, TValue> get_Parent();
    [CompilerGeneratedAttribute]
public TKey get_Key();
    public virtual ISqlFragment CreateComparison(string op, ConstantExpression constant);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.Dictionaries.DictionaryKeysMember : QueryableMember {
    private IDictionaryMember _parent;
    [CompilerGeneratedAttribute]
private SelectManyValueCollection <SelectManyUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExplodeLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ArrayLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocatorForIncludedDocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryableMember <Element>k__BackingField;
    public SelectManyValueCollection SelectManyUsage { get; }
    public Type ElementType { get; }
    public string ExplodeLocator { get; }
    public string ArrayLocator { get; }
    public string LocatorForIncludedDocumentId { get; }
    public IQueryableMember Element { get; }
    public ISqlFragment IsEmpty { get; }
    public ISqlFragment NotEmpty { get; }
    public DictionaryKeysMember(IDictionaryMember parent, StoreOptions options);
    [CompilerGeneratedAttribute]
public SelectManyValueCollection get_SelectManyUsage();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ElementType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExplodeLocator();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ArrayLocator();
    [CompilerGeneratedAttribute]
public virtual string get_LocatorForIncludedDocumentId();
    public sealed virtual Statement AttachSelectManyStatement(CollectionUsage collectionUsage, IMartenSession session, SelectorStatement parentStatement, QueryStatistics statistics);
    public sealed virtual ISelectClause BuildSelectClauseForExplosion(string fromObject);
    public sealed virtual ISqlFragment ParseWhereForAny(Expression body, IReadOnlyStoreOptions options);
    public sealed virtual IComparableMember ParseComparableForCount(Expression body);
    public sealed virtual ISqlFragment ParseWhereForAll(MethodCallExpression body, IReadOnlyStoreOptions options);
    public sealed virtual ISqlFragment ParseWhereForContains(MethodCallExpression body, IReadOnlyStoreOptions options);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<IQueryableMember> GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual IQueryableMember get_Element();
    public sealed virtual ISqlFragment get_IsEmpty();
    public sealed virtual ISqlFragment get_NotEmpty();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.Dictionaries.DictionaryMember`2 : QueryableMember {
    private StoreOptions _options;
    private DictionaryKeysMember _keys;
    private DictionaryValuesMember _values;
    private KeyValuePairMemberCollection`2<TKey, TValue> _members;
    [CompilerGeneratedAttribute]
private DictionaryCountMember <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private ISqlFragment <IsEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private ISqlFragment <NotEmpty>k__BackingField;
    public DictionaryCountMember Count { get; }
    public Type ValueType { get; }
    public Type KeyType { get; }
    public IQueryableMember Element { get; }
    public ISqlFragment IsEmpty { get; }
    public ISqlFragment NotEmpty { get; }
    private Type Marten.Linq.Members.ICollectionMember.ElementType { get; }
    private string Marten.Linq.Members.ICollectionMember.ExplodeLocator { get; }
    private string Marten.Linq.Members.ICollectionMember.ArrayLocator { get; }
    public DictionaryMember`2(StoreOptions options, IQueryableMember parent, Casing casing, MemberInfo member);
    [CompilerGeneratedAttribute]
public sealed virtual DictionaryCountMember get_Count();
    public sealed virtual Type get_ValueType();
    public sealed virtual Type get_KeyType();
    public IQueryableMember get_Element();
    [CompilerGeneratedAttribute]
public sealed virtual ISqlFragment get_IsEmpty();
    [CompilerGeneratedAttribute]
public sealed virtual ISqlFragment get_NotEmpty();
    public virtual IQueryableMember FindMember(MemberInfo member);
    public sealed virtual IQueryableMember MemberForKey(object keyValue);
    public virtual void PlaceValueInDictionaryForContainment(Dictionary`2<string, object> dict, ConstantExpression constant);
    private sealed virtual override Type Marten.Linq.Members.ICollectionMember.get_ElementType();
    private sealed virtual override string Marten.Linq.Members.ICollectionMember.get_ExplodeLocator();
    private sealed virtual override string Marten.Linq.Members.ICollectionMember.get_ArrayLocator();
    private sealed virtual override Statement Marten.Linq.Members.ICollectionMember.AttachSelectManyStatement(CollectionUsage collectionUsage, IMartenSession session, SelectorStatement parentStatement, QueryStatistics statistics);
    private sealed virtual override ISelectClause Marten.Linq.Members.ICollectionMember.BuildSelectClauseForExplosion(string fromObject);
    private sealed virtual override ISqlFragment Marten.Linq.Members.ICollectionMember.ParseWhereForAny(Expression body, IReadOnlyStoreOptions options);
    private sealed virtual override IComparableMember Marten.Linq.Members.ICollectionMember.ParseComparableForCount(Expression body);
    private sealed virtual override ISqlFragment Marten.Linq.Members.ICollectionMember.ParseWhereForAll(MethodCallExpression body, IReadOnlyStoreOptions options);
    private sealed virtual override ISqlFragment Marten.Linq.Members.ICollectionMember.ParseWhereForContains(MethodCallExpression body, IReadOnlyStoreOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.Dictionaries.DictionaryValuesContainFilter : object {
    private IDictionaryMember _member;
    private string _text;
    public ICollectionMember CollectionMember { get; }
    public DictionaryValuesContainFilter(IDictionaryMember member, ISerializer serializer, ConstantExpression constant);
    public DictionaryValuesContainFilter(IDictionaryMember member, ISerializer serializer, object value);
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual bool CanReduceInChildCollection();
    public sealed virtual ICollectionAwareFilter BuildFragment(ICollectionMember member, ISerializer serializer);
    public sealed virtual bool SupportsContainment();
    public sealed virtual void PlaceIntoContainmentFilter(ContainmentWhereFilter filter);
    public sealed virtual bool CanBeJsonPathFilter();
    public sealed virtual void BuildJsonPathFilter(ICommandBuilder builder, Dictionary`2<string, object> parameters);
    public sealed virtual IEnumerable`1<DictionaryValueUsage> Values();
    public sealed virtual ICollectionMember get_CollectionMember();
    public sealed virtual ISqlFragment MoveUnder(ICollectionMember ancestorCollection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.Dictionaries.DictionaryValuesMember : QueryableMember {
    private IDictionaryMember _parent;
    private StoreOptions _options;
    private ImHashMap`2<string, IQueryableMember> _members;
    private RootMember _root;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private SelectManyValueCollection <SelectManyUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExplodeLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ArrayLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryableMember <Element>k__BackingField;
    public Type ElementType { get; }
    public SelectManyValueCollection SelectManyUsage { get; }
    public string ExplodeLocator { get; }
    public string ArrayLocator { get; }
    public ISqlFragment IsEmpty { get; }
    public ISqlFragment NotEmpty { get; }
    public IQueryableMember Element { get; }
    public DictionaryValuesMember(IDictionaryMember parent, StoreOptions options);
    public virtual void PlaceValueInDictionaryForContainment(Dictionary`2<string, object> dict, ConstantExpression constant);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ElementType();
    [CompilerGeneratedAttribute]
public SelectManyValueCollection get_SelectManyUsage();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExplodeLocator();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ArrayLocator();
    public virtual IQueryableMember FindMember(MemberInfo member);
    private SelectorStatement createSelectManySelectorStatement(IMartenSession session, SelectorStatement parentStatement, CollectionUsage collectionUsage, QueryStatistics statistics);
    public sealed virtual Statement AttachSelectManyStatement(CollectionUsage collectionUsage, IMartenSession session, SelectorStatement parentStatement, QueryStatistics statistics);
    public sealed virtual ISelectClause BuildSelectClauseForExplosion(string fromObject);
    public sealed virtual ISqlFragment ParseWhereForAny(Expression body, IReadOnlyStoreOptions options);
    public sealed virtual IComparableMember ParseComparableForCount(Expression body);
    public sealed virtual ISqlFragment ParseWhereForAll(MethodCallExpression body, IReadOnlyStoreOptions options);
    public sealed virtual ISqlFragment ParseWhereForContains(MethodCallExpression body, IReadOnlyStoreOptions options);
    public sealed virtual ISqlFragment get_IsEmpty();
    public sealed virtual ISqlFragment get_NotEmpty();
    public sealed virtual IEnumerator`1<IQueryableMember> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual IQueryableMember get_Element();
}
[NullableContextAttribute("1")]
internal interface Marten.Linq.Members.Dictionaries.IDictionaryMember {
    public Type ValueType { get; }
    public Type KeyType { get; }
    public DictionaryCountMember Count { get; }
    public abstract virtual IQueryableMember MemberForKey(object keyValue);
    public abstract virtual Type get_ValueType();
    public abstract virtual Type get_KeyType();
    public abstract virtual DictionaryCountMember get_Count();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.Dictionaries.KeyValuePairMemberCollection`2 : object {
    private IQueryableMember _key;
    private IQueryableMember _value;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    public Type ElementType { get; }
    public KeyValuePairMemberCollection`2(StoreOptions options);
    public sealed virtual IQueryableMember FindMember(MemberInfo member);
    public sealed virtual void ReplaceMember(MemberInfo member, IQueryableMember queryableMember);
    public sealed virtual IEnumerator`1<IQueryableMember> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ElementType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.DocumentQueryableMemberCollection : object {
    private StoreOptions _options;
    private ImHashMap`2<string, IQueryableMember> _members;
    [CompilerGeneratedAttribute]
private string <NullTestLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    public string MemberName { get; }
    public string JsonPathSegment { get; }
    private Type Marten.Linq.Members.IQueryableMember.MemberType { get; }
    private string Marten.Linq.Members.IQueryableMember.TypedLocator { get; }
    private string Marten.Linq.Members.IQueryableMember.RawLocator { get; }
    private string Marten.Linq.Members.IQueryableMember.JSONBLocator { get; }
    private IQueryableMember[] Marten.Linq.Members.IQueryableMember.Ancestors { get; }
    private string Marten.Linq.Members.IQueryableMember.LocatorForIncludedDocumentId { get; }
    public string NullTestLocator { get; }
    public Type ElementType { get; }
    public DocumentQueryableMemberCollection(IDocumentMapping mapping, StoreOptions options);
    public sealed virtual string get_MemberName();
    public sealed virtual string get_JsonPathSegment();
    private sealed virtual override void Weasel.Postgresql.SqlGeneration.ISqlFragment.Apply(ICommandBuilder builder);
    private sealed virtual override Type Marten.Linq.Members.IQueryableMember.get_MemberType();
    private sealed virtual override string Marten.Linq.Members.IQueryableMember.get_TypedLocator();
    private sealed virtual override string Marten.Linq.Members.IQueryableMember.get_RawLocator();
    private sealed virtual override string Marten.Linq.Members.IQueryableMember.get_JSONBLocator();
    private sealed virtual override string Marten.Linq.Members.IQueryableMember.BuildOrderingExpression(Ordering ordering, CasingRule casingRule);
    private sealed virtual override IQueryableMember[] Marten.Linq.Members.IQueryableMember.get_Ancestors();
    private sealed virtual override Dictionary`2<string, object> Marten.Linq.Members.IQueryableMember.FindOrPlaceChildDictionaryForContainment(Dictionary`2<string, object> dict);
    private sealed virtual override void Marten.Linq.Members.IQueryableMember.PlaceValueInDictionaryForContainment(Dictionary`2<string, object> dict, ConstantExpression constant);
    private sealed virtual override string Marten.Linq.Members.IQueryableMember.get_LocatorForIncludedDocumentId();
    [CompilerGeneratedAttribute]
public sealed virtual string get_NullTestLocator();
    public sealed virtual string SelectorForDuplication(string pgType);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ElementType();
    public sealed virtual IQueryableMember FindMember(MemberInfo member);
    public sealed virtual void ReplaceMember(MemberInfo member, IQueryableMember queryableMember);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<IQueryableMember> GetEnumerator();
    public void RemoveAnyIdentityMember();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.DuplicatedArrayField : DuplicatedField {
    private WholeDataMember _wholeDataMember;
    private ArrayLengthMember _count;
    private string _innerPgType;
    [CompilerGeneratedAttribute]
private ISqlFragment <IsEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private ISqlFragment <NotEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExplodeLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryableMember <Element>k__BackingField;
    public ISqlFragment IsEmpty { get; }
    public ISqlFragment NotEmpty { get; }
    public Type ElementType { get; }
    public string ExplodeLocator { get; }
    public string ArrayLocator { get; }
    public IQueryableMember Element { get; }
    public DuplicatedArrayField(EnumStorage enumStorage, QueryableMember innerMember, bool useTimestampWithoutTimeZoneForDateTime, bool notNull);
    [CompilerGeneratedAttribute]
public sealed virtual ISqlFragment get_IsEmpty();
    [CompilerGeneratedAttribute]
public sealed virtual ISqlFragment get_NotEmpty();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ElementType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExplodeLocator();
    public sealed virtual string get_ArrayLocator();
    [CompilerGeneratedAttribute]
public IQueryableMember get_Element();
    public sealed virtual Statement AttachSelectManyStatement(CollectionUsage collectionUsage, IMartenSession session, SelectorStatement parentStatement, QueryStatistics statistics);
    public sealed virtual ISelectClause BuildSelectClauseForExplosion(string fromObject);
    public sealed virtual ISqlFragment ParseWhereForAny(Expression body, IReadOnlyStoreOptions options);
    public sealed virtual IComparableMember ParseComparableForCount(Expression body);
    public sealed virtual ISqlFragment ParseWhereForAll(MethodCallExpression body, IReadOnlyStoreOptions options);
    public sealed virtual ISqlFragment ParseWhereForContains(MethodCallExpression body, IReadOnlyStoreOptions options);
    public sealed virtual IQueryableMember FindMember(MemberInfo member);
    public sealed virtual void ReplaceMember(MemberInfo member, IQueryableMember queryableMember);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<IQueryableMember> GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.Members.DuplicatedField : object {
    private Func`2<object, object> _parseObject;
    private bool useTimestampWithoutTimeZoneForDateTime;
    private string _columnName;
    [CompilerGeneratedAttribute]
private MemberInfo[] <Members>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NotNull>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OnlyForSearching>k__BackingField;
    [CompilerGeneratedAttribute]
private NpgsqlDbType <DbType>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryableMember <InnerMember>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PgType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JSONBLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypedLocator>k__BackingField;
    public MemberInfo[] Members { get; }
    public string JsonPathSegment { get; }
    public IQueryableMember[] Ancestors { get; }
    public string NullTestLocator { get; }
    public bool NotNull { get; internal set; }
    public bool OnlyForSearching { get; public set; }
    public NpgsqlDbType DbType { get; public set; }
    internal UpsertArgument UpsertArgument { get; }
    public string ColumnName { get; public set; }
    internal QueryableMember InnerMember { get; }
    public string MemberName { get; }
    public string PgType { get; public set; }
    public string RawLocator { get; }
    public string JSONBLocator { get; public set; }
    public string LocatorForIncludedDocumentId { get; }
    public string TypedLocator { get; public set; }
    public Type MemberType { get; }
    public DuplicatedField(EnumStorage enumStorage, QueryableMember innerMember, bool useTimestampWithoutTimeZoneForDateTime, bool notNull);
    [CompilerGeneratedAttribute]
public MemberInfo[] get_Members();
    public sealed virtual string get_JsonPathSegment();
    public sealed virtual string BuildOrderingExpression(Ordering ordering, CasingRule casingRule);
    public sealed virtual IQueryableMember[] get_Ancestors();
    public sealed virtual Dictionary`2<string, object> FindOrPlaceChildDictionaryForContainment(Dictionary`2<string, object> dict);
    public sealed virtual void PlaceValueInDictionaryForContainment(Dictionary`2<string, object> dict, ConstantExpression constant);
    public sealed virtual string get_NullTestLocator();
    [CompilerGeneratedAttribute]
public bool get_NotNull();
    [CompilerGeneratedAttribute]
internal void set_NotNull(bool value);
    [CompilerGeneratedAttribute]
public bool get_OnlyForSearching();
    [CompilerGeneratedAttribute]
public void set_OnlyForSearching(bool value);
    [CompilerGeneratedAttribute]
public NpgsqlDbType get_DbType();
    [CompilerGeneratedAttribute]
public void set_DbType(NpgsqlDbType value);
    internal UpsertArgument get_UpsertArgument();
    public string get_ColumnName();
    public void set_ColumnName(string value);
    [CompilerGeneratedAttribute]
internal QueryableMember get_InnerMember();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MemberName();
    [CompilerGeneratedAttribute]
public string get_PgType();
    [CompilerGeneratedAttribute]
public void set_PgType(string value);
    public sealed virtual string get_RawLocator();
    public object GetValueForCompiledQueryParameter(Expression valueExpression);
    private sealed virtual override string Marten.Linq.Members.IQueryableMember.SelectorForDuplication(string pgType);
    public sealed virtual ISqlFragment CreateComparison(string op, ConstantExpression constant);
    [CompilerGeneratedAttribute]
public sealed virtual string get_JSONBLocator();
    [CompilerGeneratedAttribute]
public void set_JSONBLocator(string value);
    public sealed virtual string get_LocatorForIncludedDocumentId();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TypedLocator();
    [CompilerGeneratedAttribute]
public void set_TypedLocator(string value);
    private sealed virtual override void Weasel.Postgresql.SqlGeneration.ISqlFragment.Apply(ICommandBuilder builder);
    public sealed virtual Type get_MemberType();
    public string UpdateSqlFragment();
    public static DuplicatedField For(StoreOptions options, Expression`1<Func`2<T, object>> expression, bool useTimestampWithoutTimeZoneForDateTime);
    public virtual TableColumn ToColumn();
    public sealed virtual IQueryableMember FindMember(MemberInfo member);
    public sealed virtual void ReplaceMember(MemberInfo member, IQueryableMember queryableMember);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.Members.EnumAsIntegerMember : QueryableMember {
    [CompilerGeneratedAttribute]
private string <PgType>k__BackingField;
    public string PgType { get; public set; }
    public EnumAsIntegerMember(IQueryableMember parent, Casing casing, MemberInfo member);
    [CompilerGeneratedAttribute]
public string get_PgType();
    [CompilerGeneratedAttribute]
public void set_PgType(string value);
    public virtual ISqlFragment CreateComparison(string op, ConstantExpression constant);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.Members.EnumAsStringMember : QueryableMember {
    public EnumAsStringMember(IQueryableMember parent, Casing casing, MemberInfo member);
    public virtual ISqlFragment CreateComparison(string op, ConstantExpression constant);
    public virtual string SelectorForDuplication(string pgType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.HasValueMember : object {
    private string _isNotNullSql;
    private string _isNullSql;
    [CompilerGeneratedAttribute]
private IQueryableMember <Inner>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <MemberType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypedLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JSONBLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryableMember[] <Ancestors>k__BackingField;
    public IQueryableMember Inner { get; }
    public string NullTestLocator { get; }
    public string JsonPathSegment { get; }
    public string MemberName { get; }
    public Type MemberType { get; }
    public string TypedLocator { get; }
    public string RawLocator { get; }
    public string JSONBLocator { get; }
    public IQueryableMember[] Ancestors { get; }
    private string Marten.Linq.Members.IQueryableMember.LocatorForIncludedDocumentId { get; }
    public HasValueMember(IQueryableMember inner);
    [CompilerGeneratedAttribute]
public IQueryableMember get_Inner();
    public sealed virtual ISqlFragment BuildIsTrueFragment();
    public sealed virtual ISqlFragment CreateComparison(string op, ConstantExpression constant);
    public sealed virtual string get_NullTestLocator();
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual string get_JsonPathSegment();
    public sealed virtual string get_MemberName();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_MemberType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TypedLocator();
    [CompilerGeneratedAttribute]
public sealed virtual string get_RawLocator();
    [CompilerGeneratedAttribute]
public sealed virtual string get_JSONBLocator();
    public sealed virtual string BuildOrderingExpression(Ordering ordering, CasingRule casingRule);
    [CompilerGeneratedAttribute]
public sealed virtual IQueryableMember[] get_Ancestors();
    public sealed virtual Dictionary`2<string, object> FindOrPlaceChildDictionaryForContainment(Dictionary`2<string, object> dict);
    public sealed virtual void PlaceValueInDictionaryForContainment(Dictionary`2<string, object> dict, ConstantExpression constant);
    private sealed virtual override string Marten.Linq.Members.IQueryableMember.get_LocatorForIncludedDocumentId();
    public sealed virtual string SelectorForDuplication(string pgType);
}
[NullableContextAttribute("1")]
internal interface Marten.Linq.Members.IBooleanMember {
    public abstract virtual ISqlFragment BuildIsTrueFragment();
}
[NullableContextAttribute("1")]
public interface Marten.Linq.Members.ICollectionMember {
    public Type ElementType { get; }
    public string ExplodeLocator { get; }
    public string ArrayLocator { get; }
    public ISqlFragment IsEmpty { get; }
    public ISqlFragment NotEmpty { get; }
    public abstract virtual Type get_ElementType();
    public abstract virtual string get_ExplodeLocator();
    public abstract virtual string get_ArrayLocator();
    public abstract virtual Statement AttachSelectManyStatement(CollectionUsage collectionUsage, IMartenSession session, SelectorStatement parentStatement, QueryStatistics statistics);
    public abstract virtual ISelectClause BuildSelectClauseForExplosion(string fromObject);
    public abstract virtual ISqlFragment ParseWhereForAny(Expression body, IReadOnlyStoreOptions options);
    public abstract virtual IComparableMember ParseComparableForCount(Expression body);
    public abstract virtual ISqlFragment ParseWhereForAll(MethodCallExpression body, IReadOnlyStoreOptions options);
    public abstract virtual ISqlFragment ParseWhereForContains(MethodCallExpression body, IReadOnlyStoreOptions options);
    public abstract virtual ISqlFragment get_IsEmpty();
    public abstract virtual ISqlFragment get_NotEmpty();
}
[NullableContextAttribute("1")]
public interface Marten.Linq.Members.IComparableMember {
    public abstract virtual ISqlFragment CreateComparison(string op, ConstantExpression constant);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.Members.IdMember : object {
    private static string _orderDescending;
    [CompilerGeneratedAttribute]
private MemberInfo <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <MemberType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JSONBLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryableMember[] <Ancestors>k__BackingField;
    public MemberInfo Member { get; }
    public string MemberName { get; }
    public string NullTestLocator { get; }
    public string JsonPathSegment { get; }
    public Type MemberType { get; }
    public string TypedLocator { get; }
    public string RawLocator { get; }
    public string JSONBLocator { get; public set; }
    public IQueryableMember[] Ancestors { get; }
    private string Marten.Linq.Members.IQueryableMember.LocatorForIncludedDocumentId { get; }
    public IdMember(MemberInfo member);
    [CompilerGeneratedAttribute]
public MemberInfo get_Member();
    public virtual ISqlFragment CreateComparison(string op, ConstantExpression constant);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MemberName();
    public sealed virtual string get_NullTestLocator();
    public sealed virtual string SelectorForDuplication(string pgType);
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual string get_JsonPathSegment();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_MemberType();
    public sealed virtual string get_TypedLocator();
    public sealed virtual string get_RawLocator();
    [CompilerGeneratedAttribute]
public sealed virtual string get_JSONBLocator();
    [CompilerGeneratedAttribute]
public void set_JSONBLocator(string value);
    public sealed virtual string BuildOrderingExpression(Ordering ordering, CasingRule casingRule);
    [CompilerGeneratedAttribute]
public sealed virtual IQueryableMember[] get_Ancestors();
    private sealed virtual override Dictionary`2<string, object> Marten.Linq.Members.IQueryableMember.FindOrPlaceChildDictionaryForContainment(Dictionary`2<string, object> dict);
    private sealed virtual override void Marten.Linq.Members.IQueryableMember.PlaceValueInDictionaryForContainment(Dictionary`2<string, object> dict, ConstantExpression constant);
    private sealed virtual override string Marten.Linq.Members.IQueryableMember.get_LocatorForIncludedDocumentId();
}
[NullableContextAttribute("1")]
public interface Marten.Linq.Members.IHasChildrenMembers {
    public abstract virtual IQueryableMember FindMember(MemberInfo member);
    public abstract virtual void ReplaceMember(MemberInfo member, IQueryableMember queryableMember);
}
[NullableContextAttribute("1")]
public interface Marten.Linq.Members.IMemberSource {
    public abstract virtual bool TryResolve(IQueryableMember parent, StoreOptions options, MemberInfo memberInfo, Type memberType, IQueryableMember& member);
}
[NullableContextAttribute("1")]
public interface Marten.Linq.Members.IQueryableMember {
    public Type MemberType { get; }
    public string JsonPathSegment { get; }
    public string MemberName { get; }
    public string TypedLocator { get; }
    public string RawLocator { get; }
    public string JSONBLocator { get; }
    public IQueryableMember[] Ancestors { get; }
    public string LocatorForIncludedDocumentId { get; }
    public string NullTestLocator { get; }
    public abstract virtual Type get_MemberType();
    public abstract virtual string get_JsonPathSegment();
    public abstract virtual string get_MemberName();
    public abstract virtual string get_TypedLocator();
    public abstract virtual string get_RawLocator();
    public abstract virtual string get_JSONBLocator();
    public abstract virtual IQueryableMember[] get_Ancestors();
    public abstract virtual string get_LocatorForIncludedDocumentId();
    public abstract virtual string get_NullTestLocator();
    public abstract virtual string BuildOrderingExpression(Ordering ordering, CasingRule casingRule);
    public abstract virtual Dictionary`2<string, object> FindOrPlaceChildDictionaryForContainment(Dictionary`2<string, object> dict);
    public abstract virtual void PlaceValueInDictionaryForContainment(Dictionary`2<string, object> dict, ConstantExpression constant);
    public abstract virtual string SelectorForDuplication(string pgType);
}
public interface Marten.Linq.Members.IQueryableMemberCollection {
    [NullableAttribute("1")]
public Type ElementType { get; }
    [NullableContextAttribute("1")]
public abstract virtual Type get_ElementType();
}
[NullableContextAttribute("1")]
internal interface Marten.Linq.Members.IStrongTypedIdGeneration {
    public abstract virtual Func`2<object, T> BuildInnerValueSource();
    public abstract virtual ISelectClause BuildSelectClause(string fromObject);
}
public interface Marten.Linq.Members.IValueTypeMember {
    [NullableContextAttribute("1")]
public abstract virtual object ConvertFromWrapperArray(object values);
    [NullableContextAttribute("1")]
public abstract virtual ISelectClause BuildSelectClause(string fromObject);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.ModuloOperator : object {
    private ISqlFragment _left;
    private ISqlFragment _right;
    private string _op;
    private CommandParameter _value;
    public ModuloOperator(BinaryExpression expression, IQueryableMemberCollection members);
    public sealed virtual ISqlFragment CreateComparison(string op, ConstantExpression value);
    public sealed virtual void Apply(ICommandBuilder builder);
    private ISqlFragment analyze(Expression expression, IQueryableMemberCollection members);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.NotMember : object {
    [CompilerGeneratedAttribute]
private IComparableMember <Inner>k__BackingField;
    public IComparableMember Inner { get; }
    public NotMember(IComparableMember inner);
    [CompilerGeneratedAttribute]
public IComparableMember get_Inner();
    public sealed virtual ISqlFragment CreateComparison(string op, ConstantExpression constant);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Marten.Linq.Members.QueryableMember : object {
    [NullableAttribute("2")]
private HasValueMember _hasValue;
    [NullableAttribute("2")]
private string _nullTestLocator;
    [CompilerGeneratedAttribute]
private MemberInfo <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JsonPathSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryableMember[] <Ancestors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypedLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JSONBLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <MemberType>k__BackingField;
    public MemberInfo Member { get; }
    public string JsonPathSegment { get; protected set; }
    public string MemberName { get; }
    public IQueryableMember[] Ancestors { get; }
    public string RawLocator { get; protected internal set; }
    public string NullTestLocator { get; protected set; }
    public string TypedLocator { get; protected internal set; }
    public string JSONBLocator { get; public set; }
    public Type MemberType { get; protected set; }
    public string LocatorForIncludedDocumentId { get; }
    protected QueryableMember(IQueryableMember parent, Casing casing, MemberInfo member);
    protected QueryableMember(IQueryableMember parent, string memberName, Type memberType);
    [CompilerGeneratedAttribute]
public MemberInfo get_Member();
    public virtual IQueryableMember FindMember(MemberInfo member);
    public virtual void ReplaceMember(MemberInfo member, IQueryableMember queryableMember);
    [CompilerGeneratedAttribute]
public sealed virtual string get_JsonPathSegment();
    [CompilerGeneratedAttribute]
protected void set_JsonPathSegment(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MemberName();
    [CompilerGeneratedAttribute]
public sealed virtual IQueryableMember[] get_Ancestors();
    [CompilerGeneratedAttribute]
public sealed virtual string get_RawLocator();
    [CompilerGeneratedAttribute]
protected internal void set_RawLocator(string value);
    public sealed virtual string get_NullTestLocator();
    protected void set_NullTestLocator(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TypedLocator();
    [CompilerGeneratedAttribute]
protected internal void set_TypedLocator(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_JSONBLocator();
    [CompilerGeneratedAttribute]
public void set_JSONBLocator(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_MemberType();
    [CompilerGeneratedAttribute]
protected void set_MemberType(Type value);
    public virtual string BuildOrderingExpression(Ordering ordering, CasingRule casingRule);
    private sealed virtual override void Weasel.Postgresql.SqlGeneration.ISqlFragment.Apply(ICommandBuilder builder);
    public virtual Dictionary`2<string, object> FindOrPlaceChildDictionaryForContainment(Dictionary`2<string, object> dict);
    public virtual void PlaceValueInDictionaryForContainment(Dictionary`2<string, object> dict, ConstantExpression constant);
    public virtual string get_LocatorForIncludedDocumentId();
    public virtual string SelectorForDuplication(string pgType);
    public virtual ISqlFragment CreateComparison(string op, ConstantExpression constant);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.RootMember : object {
    [CompilerGeneratedAttribute]
private IQueryableMember[] <Ancestors>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <MemberType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JSONBLocator>k__BackingField;
    public IQueryableMember[] Ancestors { get; public set; }
    public string NullTestLocator { get; }
    public string JsonPathSegment { get; }
    public string MemberName { get; }
    public Type MemberType { get; }
    public string TypedLocator { get; }
    public string RawLocator { get; }
    public string JSONBLocator { get; public set; }
    private string Marten.Linq.Members.IQueryableMember.LocatorForIncludedDocumentId { get; }
    public RootMember(Type sourceType);
    [CompilerGeneratedAttribute]
public sealed virtual IQueryableMember[] get_Ancestors();
    [CompilerGeneratedAttribute]
public void set_Ancestors(IQueryableMember[] value);
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual string SelectorForDuplication(string pgType);
    public sealed virtual string get_NullTestLocator();
    public sealed virtual string get_JsonPathSegment();
    public sealed virtual string get_MemberName();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_MemberType();
    public sealed virtual string get_TypedLocator();
    public sealed virtual string get_RawLocator();
    [CompilerGeneratedAttribute]
public sealed virtual string get_JSONBLocator();
    [CompilerGeneratedAttribute]
public void set_JSONBLocator(string value);
    public sealed virtual string BuildOrderingExpression(Ordering ordering, CasingRule casingRule);
    private sealed virtual override Dictionary`2<string, object> Marten.Linq.Members.IQueryableMember.FindOrPlaceChildDictionaryForContainment(Dictionary`2<string, object> dict);
    private sealed virtual override void Marten.Linq.Members.IQueryableMember.PlaceValueInDictionaryForContainment(Dictionary`2<string, object> dict, ConstantExpression constant);
    private sealed virtual override string Marten.Linq.Members.IQueryableMember.get_LocatorForIncludedDocumentId();
}
internal class Marten.Linq.Members.ScalarSelectManyStatement`1 : SelectorStatement {
    [NullableContextAttribute("1")]
public ScalarSelectManyStatement`1(SelectorStatement parent, ISerializer serializer);
    [NullableContextAttribute("1")]
public static string ToLocator(ISerializer serializer);
}
internal class Marten.Linq.Members.ScalarSelectManyStringStatement : SelectorStatement {
    [NullableContextAttribute("1")]
public ScalarSelectManyStringStatement(SelectorStatement parent);
}
public class Marten.Linq.Members.SimpleCastMember : QueryableMember {
    [NullableContextAttribute("1")]
public SimpleCastMember(IQueryableMember parent, Casing casing, MemberInfo member, string pgType);
    [NullableContextAttribute("1")]
internal static SimpleCastMember ForArrayIndex(ValueCollectionMember parent, ArrayIndexMember member);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.Members.StringMember : QueryableMember {
    private string _lowerLocator;
    public StringMember(IQueryableMember parent, Casing casing, MemberInfo member);
    internal static StringMember ForArrayIndex(ValueCollectionMember parent, ArrayIndexMember member);
    public virtual IQueryableMember FindMember(MemberInfo member);
    public virtual string BuildOrderingExpression(Ordering ordering, CasingRule casingRule);
    public virtual string SelectorForDuplication(string pgType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.Members.StringValueTypeMember`1 : StringMember {
    private Func`2<T, string> _valueSource;
    private IScalarSelectClause _selector;
    public StringValueTypeMember`1(IQueryableMember parent, Casing casing, MemberInfo member, ValueTypeInfo valueTypeInfo);
    public virtual void PlaceValueInDictionaryForContainment(Dictionary`2<string, object> dict, ConstantExpression constant);
    public virtual ISqlFragment CreateComparison(string op, ConstantExpression constant);
    public sealed virtual object ConvertFromWrapperArray(object values);
    public sealed virtual ISelectClause BuildSelectClause(string fromObject);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.StrongTypedIdMember`2 : IdMember {
    private IStrongTypedIdGeneration _idGeneration;
    private Func`2<object, TInner> _innerValue;
    public StrongTypedIdMember`2(MemberInfo member, IStrongTypedIdGeneration idGeneration);
    public sealed virtual object ConvertFromWrapperArray(object values);
    public virtual ISqlFragment CreateComparison(string op, ConstantExpression constant);
    public sealed virtual ISelectClause BuildSelectClause(string fromObject);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.ValueCollections.ArrayIndexMember : MemberInfo {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public int Index { get; }
    public Type DeclaringType { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public ArrayIndexMember(int index);
    [CompilerGeneratedAttribute]
public int get_Index();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type get_DeclaringType();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.ValueCollections.ElementComparisonFilter : object {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Op>k__BackingField;
    public object Value { get; }
    public string Op { get; }
    public ElementComparisonFilter(object value, string op);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public string get_Op();
    [IteratorStateMachineAttribute("Marten.Linq.Members.ValueCollections.ElementComparisonFilter/<Values>d__7")]
public sealed virtual IEnumerable`1<DictionaryValueUsage> Values();
    private sealed virtual override bool Marten.Linq.SqlGeneration.Filters.ICollectionAware.CanReduceInChildCollection();
    private sealed virtual override ICollectionAwareFilter Marten.Linq.SqlGeneration.Filters.ICollectionAware.BuildFragment(ICollectionMember member, ISerializer serializer);
    private sealed virtual override bool Marten.Linq.SqlGeneration.Filters.ICollectionAware.SupportsContainment();
    private sealed virtual override void Marten.Linq.SqlGeneration.Filters.ICollectionAware.PlaceIntoContainmentFilter(ContainmentWhereFilter filter);
    public sealed virtual bool CanBeJsonPathFilter();
    public sealed virtual void BuildJsonPathFilter(ICommandBuilder builder, Dictionary`2<string, object> parameters);
    private sealed virtual override void Weasel.Postgresql.SqlGeneration.ISqlFragment.Apply(ICommandBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.ValueCollections.ElementMember : MemberInfo {
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ReflectedType>k__BackingField;
    public Type DeclaringType { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public ElementMember(MemberInfo parent, Type elementType);
    public ElementMember(Type declaringType, Type reflectedType);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    [CompilerGeneratedAttribute]
public virtual Type get_DeclaringType();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual Type get_ReflectedType();
}
internal interface Marten.Linq.Members.ValueCollections.IValueCollectionMember {
    [NullableAttribute("1")]
public IQueryableMember Element { get; }
    [NullableContextAttribute("1")]
public abstract virtual IQueryableMember get_Element();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.ValueCollections.SelectManyValueCollection : object {
    private StoreOptions _options;
    private RootMember _root;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryableMember <Element>k__BackingField;
    public Type ElementType { get; }
    public IQueryableMember Element { get; }
    public SelectManyValueCollection(ValueCollectionMember valueCollectionMember, MemberInfo parentMember, Type elementType, StoreOptions options);
    public SelectManyValueCollection(Type elementType, IQueryableMember parentMember, StoreOptions options);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ElementType();
    [CompilerGeneratedAttribute]
public sealed virtual IQueryableMember get_Element();
    public sealed virtual IQueryableMember FindMember(MemberInfo member);
    public sealed virtual void ReplaceMember(MemberInfo member, IQueryableMember queryableMember);
    public sealed virtual IEnumerator`1<IQueryableMember> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.ValueCollections.SimpleElementMember : object {
    [CompilerGeneratedAttribute]
private string <PgType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <MemberType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JsonPathSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypedLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JSONBLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryableMember[] <Ancestors>k__BackingField;
    public string PgType { get; }
    public string MemberName { get; }
    public Type MemberType { get; }
    public string NullTestLocator { get; }
    public string JsonPathSegment { get; }
    public string TypedLocator { get; }
    public string RawLocator { get; }
    public string JSONBLocator { get; }
    public IQueryableMember[] Ancestors { get; }
    public string LocatorForIncludedDocumentId { get; }
    public SimpleElementMember(Type memberType, string pgType);
    [CompilerGeneratedAttribute]
public string get_PgType();
    public sealed virtual ISqlFragment CreateComparison(string op, ConstantExpression constant);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MemberName();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_MemberType();
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual string get_NullTestLocator();
    [CompilerGeneratedAttribute]
public sealed virtual string get_JsonPathSegment();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TypedLocator();
    [CompilerGeneratedAttribute]
public sealed virtual string get_RawLocator();
    [CompilerGeneratedAttribute]
public sealed virtual string get_JSONBLocator();
    public sealed virtual string BuildOrderingExpression(Ordering ordering, CasingRule casingRule);
    [CompilerGeneratedAttribute]
public sealed virtual IQueryableMember[] get_Ancestors();
    public sealed virtual Dictionary`2<string, object> FindOrPlaceChildDictionaryForContainment(Dictionary`2<string, object> dict);
    public sealed virtual void PlaceValueInDictionaryForContainment(Dictionary`2<string, object> dict, ConstantExpression constant);
    public sealed virtual string get_LocatorForIncludedDocumentId();
    public virtual string SelectorForDuplication(string pgType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.ValueCollections.ValueCollectionMember : QueryableMember {
    private IQueryableMember _count;
    private WholeDataMember _wholeDataMember;
    [CompilerGeneratedAttribute]
private string <SimpleLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private ISqlFragment <IsEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private ISqlFragment <NotEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private SelectManyValueCollection <SelectManyUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryableMember <Element>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ArrayLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocatorForIncludedDocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExplodeLocator>k__BackingField;
    public string SimpleLocator { get; }
    public ISqlFragment IsEmpty { get; }
    public ISqlFragment NotEmpty { get; }
    public SelectManyValueCollection SelectManyUsage { get; }
    public IQueryableMember Element { get; }
    public string ArrayLocator { get; public set; }
    public string LocatorForIncludedDocumentId { get; }
    public Type ElementType { get; }
    public string ExplodeLocator { get; }
    public ValueCollectionMember(StoreOptions storeOptions, IQueryableMember parent, Casing casing, MemberInfo member);
    [CompilerGeneratedAttribute]
public string get_SimpleLocator();
    [CompilerGeneratedAttribute]
public sealed virtual ISqlFragment get_IsEmpty();
    [CompilerGeneratedAttribute]
public sealed virtual ISqlFragment get_NotEmpty();
    [CompilerGeneratedAttribute]
public SelectManyValueCollection get_SelectManyUsage();
    [CompilerGeneratedAttribute]
public sealed virtual IQueryableMember get_Element();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ArrayLocator();
    [CompilerGeneratedAttribute]
public void set_ArrayLocator(string value);
    public sealed virtual IComparableMember ParseComparableForCount(Expression body);
    public sealed virtual ISqlFragment ParseWhereForAll(MethodCallExpression expression, IReadOnlyStoreOptions options);
    public sealed virtual ISqlFragment ParseWhereForContains(MethodCallExpression body, IReadOnlyStoreOptions options);
    [CompilerGeneratedAttribute]
public sealed virtual string get_LocatorForIncludedDocumentId();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ElementType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExplodeLocator();
    public sealed virtual ISqlFragment ParseWhereForAny(Expression body, IReadOnlyStoreOptions options);
    public sealed virtual Statement AttachSelectManyStatement(CollectionUsage collectionUsage, IMartenSession session, SelectorStatement parentStatement, QueryStatistics statistics);
    public sealed virtual ISelectClause BuildSelectClauseForExplosion(string fromObject);
    public virtual void PlaceValueInDictionaryForContainment(Dictionary`2<string, object> dict, ConstantExpression constant);
    public virtual Dictionary`2<string, object> FindOrPlaceChildDictionaryForContainment(Dictionary`2<string, object> dict);
    public virtual string SelectorForDuplication(string pgType);
    public virtual IQueryableMember FindMember(MemberInfo member);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<IQueryableMember> GetEnumerator();
    public sealed virtual void Apply(ICommandBuilder builder, ISerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.Members.ValueTypeMember`2 : SimpleCastMember {
    private Func`2<TOuter, TInner> _valueSource;
    private IScalarSelectClause _selector;
    public ValueTypeMember`2(IQueryableMember parent, Casing casing, MemberInfo member, ValueTypeInfo valueTypeInfo);
    public virtual void PlaceValueInDictionaryForContainment(Dictionary`2<string, object> dict, ConstantExpression constant);
    public virtual ISqlFragment CreateComparison(string op, ConstantExpression constant);
    public sealed virtual object ConvertFromWrapperArray(object values);
    public sealed virtual ISelectClause BuildSelectClause(string fromObject);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Members.WholeDataMember : object {
    [CompilerGeneratedAttribute]
private IQueryableMember[] <Ancestors>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <MemberType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JSONBLocator>k__BackingField;
    public IQueryableMember[] Ancestors { get; }
    public string MemberName { get; }
    public string JsonPathSegment { get; }
    public string NullTestLocator { get; }
    public Type MemberType { get; }
    public string TypedLocator { get; }
    public string RawLocator { get; }
    public string JSONBLocator { get; public set; }
    private string Marten.Linq.Members.IQueryableMember.LocatorForIncludedDocumentId { get; }
    public WholeDataMember(Type sourceType);
    [CompilerGeneratedAttribute]
public sealed virtual IQueryableMember[] get_Ancestors();
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual string get_MemberName();
    public sealed virtual string get_JsonPathSegment();
    public sealed virtual string get_NullTestLocator();
    public sealed virtual string SelectorForDuplication(string pgType);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_MemberType();
    public sealed virtual string get_TypedLocator();
    public sealed virtual string get_RawLocator();
    [CompilerGeneratedAttribute]
public sealed virtual string get_JSONBLocator();
    [CompilerGeneratedAttribute]
public void set_JSONBLocator(string value);
    public sealed virtual string BuildOrderingExpression(Ordering ordering, CasingRule casingRule);
    private sealed virtual override Dictionary`2<string, object> Marten.Linq.Members.IQueryableMember.FindOrPlaceChildDictionaryForContainment(Dictionary`2<string, object> dict);
    private sealed virtual override void Marten.Linq.Members.IQueryableMember.PlaceValueInDictionaryForContainment(Dictionary`2<string, object> dict, ConstantExpression constant);
    private sealed virtual override string Marten.Linq.Members.IQueryableMember.get_LocatorForIncludedDocumentId();
}
public enum Marten.Linq.OrderingDirection : Enum {
    public int value__;
    public static OrderingDirection Asc;
    public static OrderingDirection Desc;
}
[NullableContextAttribute("1")]
public interface Marten.Linq.Parsing.IMethodCallParser {
    public abstract virtual bool Matches(MethodCallExpression expression);
    public abstract virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
public interface Marten.Linq.Parsing.ISelectableMember {
    public abstract virtual void Apply(ICommandBuilder builder, ISerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Marten.Linq.Parsing.LinqInternalExtensions : object {
    private static List`1<Type> _valueTypes;
    private static Type[] valueExpressionTypes;
    private static LinqInternalExtensions();
    [NullableContextAttribute("0")]
private static void addValueType();
    [ExtensionAttribute]
public static string CorrectJsonPathOperator(string op);
    [ExtensionAttribute]
public static bool IsValueTypeForQuerying(Type type);
    [ExtensionAttribute]
public static IQueryableMember MemberFor(IQueryableMemberCollection collection, Expression`1<Func`2<T, object>> propertyExpression);
    [ExtensionAttribute]
public static IQueryableMember MemberFor(IQueryableMemberCollection collection, string memberName);
    [ExtensionAttribute]
public static IQueryableMember MemberFor(IHasChildrenMembers collection, Expression expression);
    [ExtensionAttribute]
public static IQueryableMember MemberFor(IHasChildrenMembers collection, Expression expression, string invalidExpression);
    [ExtensionAttribute]
public static IQueryableMember MemberFor(IHasChildrenMembers collection, MemberInfo[] members);
    [ExtensionAttribute]
public static ISqlFragment ReduceToValue(IQueryableMemberCollection collection, Expression expression);
    [ExtensionAttribute]
public static bool IsCompilableExpression(MemberExpression node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryToParseConstant(Expression expression, ConstantExpression& constant);
    [ExtensionAttribute]
public static void WriteJsonPath(IQueryableMember member, ICommandBuilder builder);
    [IteratorStateMachineAttribute("Marten.Linq.Parsing.LinqInternalExtensions/<JsonPathSegments>d__14")]
[ExtensionAttribute]
public static IEnumerable`1<string> JsonPathSegments(IQueryableMember member);
    [ExtensionAttribute]
public static string WriteJsonPath(IQueryableMember member);
    [ExtensionAttribute]
public static string AddJsonPathParameter(IDictionary`2<string, object> dict, object value);
    [ExtensionAttribute]
public static object Value(Expression expression);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsValueExpression(Expression expression);
    [ExtensionAttribute]
public static ConstantExpression ReduceToConstant(Expression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Parsing.LinqQueryParser : ExpressionVisitor {
    private static OperatorLibrary _operators;
    private List`1<CollectionUsage> _collectionUsages;
    private MartenLinqQueryProvider _provider;
    private bool _hasParsedIncludes;
    [CompilerGeneratedAttribute]
private Nullable`1<SingleValueMode> <ValueMode>k__BackingField;
    [CompilerGeneratedAttribute]
private IMartenSession <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private CollectionUsage <CurrentUsage>k__BackingField;
    public Nullable`1<SingleValueMode> ValueMode { get; }
    public IMartenSession Session { get; }
    public CollectionUsage CurrentUsage { get; private set; }
    public LinqQueryParser(MartenLinqQueryProvider provider, IMartenSession session, Expression expression, Nullable`1<SingleValueMode> valueMode);
    private static LinqQueryParser();
    [CompilerGeneratedAttribute]
public Nullable`1<SingleValueMode> get_ValueMode();
    [CompilerGeneratedAttribute]
public IMartenSession get_Session();
    public sealed virtual CollectionUsage CollectionUsageFor(MethodCallExpression expression);
    public sealed virtual CollectionUsage CollectionUsageForArgument(Expression argument);
    public sealed virtual CollectionUsage StartNewCollectionUsageFor(MethodCallExpression expression);
    public sealed virtual CollectionUsage CollectionUsageFor(Type elementType);
    [CompilerGeneratedAttribute]
public sealed virtual CollectionUsage get_CurrentUsage();
    [CompilerGeneratedAttribute]
private void set_CurrentUsage(CollectionUsage value);
    [IteratorStateMachineAttribute("Marten.Linq.Parsing.LinqQueryParser/<DocumentTypes>d__19")]
public IEnumerable`1<Type> DocumentTypes();
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    public static IQueryHandler`1<TResult> BuildHandler(ISelector`1<TDocument> selector, ISqlFragment statement);
    public IQueryHandler`1<TResult> BuildHandler();
    private IQueryHandler`1<TResult> buildHandlerForCurrentStatement(Statement top, SelectorStatement selector);
    public IQueryHandler`1<IReadOnlyList`1<T>> BuildListHandler();
    public void BuildDiagnosticCommand(FetchType fetchType, CommandBuilder sql);
    internal StatementQuery BuildStatements();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IIncludeReader <BuildHandler>b__22_1(IIncludePlan x);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IIncludeReader <BuildListHandler>b__24_1(IIncludePlan x);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.Parsing.MemberFinder : ExpressionVisitor {
    public List`1<ExpressionType> InvalidNodeTypes;
    public IList`1<MemberInfo> Members;
    [CompilerGeneratedAttribute]
private bool <FoundParameterAtFront>k__BackingField;
    public bool FoundParameterAtFront { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_FoundParameterAtFront();
    [CompilerGeneratedAttribute]
private void set_FoundParameterAtFront(bool value);
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitBinary(BinaryExpression node);
    protected virtual Expression VisitParameter(ParameterExpression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected sealed virtual Expression VisitUnary(UnaryExpression node);
    public static MemberInfo[] Determine(Expression expression);
    public static MemberInfo[] Determine(Expression expression, string invalidMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Parsing.Methods.AllMethodParser : object {
    public sealed virtual bool Matches(MethodCallExpression expression);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
    private static bool typeMatches(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Parsing.Methods.AnySubQueryParser : object {
    public sealed virtual bool Matches(MethodCallExpression expression);
    private bool hasAny(object value);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
    private static bool typeMatches(Type type);
}
internal class Marten.Linq.Parsing.Methods.AnyTenant : WhereFragment {
    [NullableContextAttribute("1")]
public sealed virtual bool Matches(MethodCallExpression expression);
    [NullableContextAttribute("1")]
public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Parsing.Methods.EnumerableContains : object {
    public sealed virtual bool Matches(MethodCallExpression expression);
    private static bool matches(Type memberType);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
internal enum Marten.Linq.Parsing.Methods.FullText.FullTextSearchFunction : Enum {
    public int value__;
    public static FullTextSearchFunction to_tsquery;
    public static FullTextSearchFunction plainto_tsquery;
    public static FullTextSearchFunction phraseto_tsquery;
    public static FullTextSearchFunction websearch_to_tsquery;
    public static FullTextSearchFunction mt_ngram_tsvector;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Marten.Linq.Parsing.Methods.FullText.FullTextSearchMethodCallParser : object {
    private string methodName;
    private FullTextSearchFunction searchFunction;
    protected FullTextSearchMethodCallParser(string methodName, FullTextSearchFunction searchFunction);
    public sealed virtual bool Matches(MethodCallExpression expression);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
public class Marten.Linq.Parsing.Methods.FullText.NgramSearch : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Matches(MethodCallExpression expression);
    [NullableContextAttribute("1")]
public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
internal class Marten.Linq.Parsing.Methods.FullText.PhraseSearch : FullTextSearchMethodCallParser {
}
internal class Marten.Linq.Parsing.Methods.FullText.PlainTextSearch : FullTextSearchMethodCallParser {
}
internal class Marten.Linq.Parsing.Methods.FullText.Search : FullTextSearchMethodCallParser {
}
internal class Marten.Linq.Parsing.Methods.FullText.WebStyleSearch : FullTextSearchMethodCallParser {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Parsing.Methods.HashSetEnumerableContains : object {
    public sealed virtual bool Matches(MethodCallExpression expression);
    private static bool matches(Type memberType);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
    private object correctToArray(object constantValue);
}
internal class Marten.Linq.Parsing.Methods.IsEmpty : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Matches(MethodCallExpression expression);
    [NullableContextAttribute("1")]
public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
internal class Marten.Linq.Parsing.Methods.IsNotOneOf : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Matches(MethodCallExpression expression);
    [NullableContextAttribute("1")]
public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
internal class Marten.Linq.Parsing.Methods.IsOneOf : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Matches(MethodCallExpression expression);
    [NullableContextAttribute("1")]
public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Parsing.Methods.IsOneOfFilter : object {
    private ISqlFragment _member;
    private CommandParameter _parameter;
    public IsOneOfFilter(ISqlFragment member, CommandParameter parameter);
    public sealed virtual void Apply(ICommandBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Parsing.Methods.IsSubsetOf : object {
    public sealed virtual bool Matches(MethodCallExpression expression);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
    private static bool isMartenLinqExtension(MethodInfo method);
    private static bool isISetMethod(MethodInfo method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Parsing.Methods.IsSupersetOf : object {
    public sealed virtual bool Matches(MethodCallExpression expression);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
    private static bool isMartenLinqExtension(MethodInfo method);
    private static bool isISetMethod(MethodInfo method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Parsing.Methods.SimpleEqualsParser : object {
    private static List`1<Type> SupportedTypes;
    private string _equalsOperator;
    private string _isOperator;
    private bool _supportContainment;
    private static SimpleEqualsParser();
    public SimpleEqualsParser(string equalsOperator, string isOperator, bool supportContainment);
    public sealed virtual bool Matches(MethodCallExpression expression);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
internal class Marten.Linq.Parsing.Methods.SimpleNotEqualsParser : SimpleEqualsParser {
}
internal class Marten.Linq.Parsing.Methods.Strings.EqualsIgnoreCaseParser : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Matches(MethodCallExpression expression);
    [NullableContextAttribute("1")]
public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Marten.Linq.Parsing.Methods.Strings.StringComparisonParser : object {
    public static string CaseSensitiveLike;
    public static string CaseInSensitiveLike;
    public static StringComparison[] CaseInSensitiveComparisons;
    private MethodInfo[] _supportedMethods;
    public StringComparisonParser(MethodInfo[] supportedMethods);
    private static StringComparisonParser();
    public sealed virtual bool Matches(MethodCallExpression expression);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
    protected abstract virtual ISqlFragment buildFilter(bool caseInsensitive, IQueryableMember member, CommandParameter value);
    protected bool AreMethodsEqual(MethodInfo method1, MethodInfo method2);
    public static string EscapeValue(string raw);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Parsing.Methods.Strings.StringContains : StringComparisonParser {
    private static MethodInfo[] GetContainsMethods();
    protected virtual ISqlFragment buildFilter(bool caseInsensitive, IQueryableMember member, CommandParameter value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Parsing.Methods.Strings.StringContainsFilter : object {
    private bool _caseInsensitive;
    private IQueryableMember _member;
    private string _rawValue;
    private MemberInfo _queryMember;
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; private set; }
    public StringContainsFilter(bool caseInsensitive, IQueryableMember member, CommandParameter value);
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual bool TryMatchValue(object value, MemberInfo member);
    public sealed virtual void GenerateCode(GeneratedMethod method, int parameterIndex, string parametersVariableName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ParameterName();
    [CompilerGeneratedAttribute]
private void set_ParameterName(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Parsing.Methods.Strings.StringEndsWith : StringComparisonParser {
    private static StringComparison[] CaseInsensitiveComparisons;
    private static StringEndsWith();
    protected virtual ISqlFragment buildFilter(bool caseInsensitive, IQueryableMember member, CommandParameter value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Parsing.Methods.Strings.StringEndsWithFilter : object {
    private IQueryableMember _member;
    private string _operator;
    private object _rawValue;
    private MemberInfo _queryMember;
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; private set; }
    public StringEndsWithFilter(bool caseInsensitive, IQueryableMember member, CommandParameter value);
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual bool TryMatchValue(object value, MemberInfo member);
    public sealed virtual void GenerateCode(GeneratedMethod method, int parameterIndex, string parametersVariableName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ParameterName();
    [CompilerGeneratedAttribute]
private void set_ParameterName(string value);
}
internal class Marten.Linq.Parsing.Methods.Strings.StringEquals : StringComparisonParser {
    [NullableContextAttribute("1")]
protected virtual ISqlFragment buildFilter(bool caseInsensitive, IQueryableMember member, CommandParameter value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Parsing.Methods.Strings.StringEqualsIgnoreCaseFilter : object {
    [CompilerGeneratedAttribute]
private IQueryableMember <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandParameter <Value>k__BackingField;
    public IQueryableMember Member { get; }
    public CommandParameter Value { get; }
    public StringEqualsIgnoreCaseFilter(IQueryableMember member, CommandParameter value);
    [CompilerGeneratedAttribute]
public IQueryableMember get_Member();
    [CompilerGeneratedAttribute]
public CommandParameter get_Value();
    public sealed virtual void Apply(ICommandBuilder builder);
}
internal class Marten.Linq.Parsing.Methods.Strings.StringIsNullOrEmpty : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Matches(MethodCallExpression expression);
    [NullableContextAttribute("1")]
public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
internal class Marten.Linq.Parsing.Methods.Strings.StringIsNullOrWhiteSpace : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Matches(MethodCallExpression expression);
    [NullableContextAttribute("1")]
public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
internal class Marten.Linq.Parsing.Methods.Strings.StringStartsWith : StringComparisonParser {
    [NullableContextAttribute("1")]
protected virtual ISqlFragment buildFilter(bool caseInsensitive, IQueryableMember member, CommandParameter value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Parsing.Methods.Strings.StringStartsWithFilter : object {
    private IQueryableMember _member;
    private string _operator;
    private string _rawValue;
    private MemberInfo _queryMember;
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; private set; }
    public StringStartsWithFilter(bool caseInsensitive, IQueryableMember member, CommandParameter value);
    public sealed virtual void Apply(ICommandBuilder builder);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ParameterName();
    [CompilerGeneratedAttribute]
private void set_ParameterName(string value);
    public sealed virtual bool TryMatchValue(object value, MemberInfo member);
    public sealed virtual void GenerateCode(GeneratedMethod method, int parameterIndex, string parametersVariableName);
}
internal class Marten.Linq.Parsing.Methods.TenantIsOneOf : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Matches(MethodCallExpression expression);
    [NullableContextAttribute("1")]
public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
internal class Marten.Linq.Parsing.NewObject : object {
    private ISerializer _serializer;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ISqlFragment> <Members>k__BackingField;
    public Dictionary`2<string, ISqlFragment> Members { get; }
    public NewObject(ISerializer serializer);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ISqlFragment> get_Members();
    public sealed virtual void Apply(ICommandBuilder builder);
    private void writeMember(ICommandBuilder builder, KeyValuePair`2<string, ISqlFragment> pair);
}
internal class Marten.Linq.Parsing.Operators.AnyOperator : LinqOperator {
    [NullableContextAttribute("1")]
public virtual void Apply(ILinqQuery query, MethodCallExpression expression);
}
public enum Marten.Linq.Parsing.Operators.CasingRule : Enum {
    public int value__;
    public static CasingRule CaseSensitive;
    public static CasingRule CaseInsensitive;
}
internal class Marten.Linq.Parsing.Operators.DistinctOperator : LinqOperator {
    [NullableContextAttribute("1")]
public virtual void Apply(ILinqQuery query, MethodCallExpression expression);
}
internal class Marten.Linq.Parsing.Operators.IncludeOperator : LinqOperator {
    [NullableContextAttribute("1")]
public virtual void Apply(ILinqQuery query, MethodCallExpression expression);
}
internal class Marten.Linq.Parsing.Operators.IncludePlanOperator : LinqOperator {
    [NullableContextAttribute("1")]
public virtual void Apply(ILinqQuery query, MethodCallExpression expression);
}
public class Marten.Linq.Parsing.Operators.LastOperator : LinqOperator {
    [NullableContextAttribute("1")]
public virtual void Apply(ILinqQuery query, MethodCallExpression expression);
}
public class Marten.Linq.Parsing.Operators.LastOrDefaultOperator : LinqOperator {
    [NullableContextAttribute("1")]
public virtual void Apply(ILinqQuery query, MethodCallExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Marten.Linq.Parsing.Operators.LinqOperator : object {
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    public string MethodName { get; }
    public LinqOperator(string methodName);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    public abstract virtual void Apply(ILinqQuery query, MethodCallExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Parsing.Operators.OperatorLibrary : object {
    private ImHashMap`2<string, LinqOperator> _operators;
    [NullableContextAttribute("0")]
public void Add();
    private void addSingleValueMode(SingleValueMode mode);
    public void AddOrdering(string methodName, OrderingDirection direction);
    public bool TryFind(string methodName, LinqOperator& op);
}
internal class Marten.Linq.Parsing.Operators.OrderBySqlOperator : LinqOperator {
    [NullableContextAttribute("1")]
public virtual void Apply(ILinqQuery query, MethodCallExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.Parsing.Operators.Ordering : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [NullableAttribute("2")]
private string _literal;
    [CompilerGeneratedAttribute]
private Expression <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderingDirection <Direction>k__BackingField;
    [CompilerGeneratedAttribute]
private CasingRule <CasingRule>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTransformed>k__BackingField;
    [NullableAttribute("2")]
public string MemberName { get; public set; }
    [NullableAttribute("2")]
public string Literal { get; }
    public Expression Expression { get; }
    public OrderingDirection Direction { get; public set; }
    public CasingRule CasingRule { get; public set; }
    public bool IsTransformed { get; public set; }
    public Ordering(Expression expression, OrderingDirection direction);
    public Ordering(string literal);
    public Ordering(string memberName, OrderingDirection direction);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_MemberName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_MemberName(string value);
    [NullableContextAttribute("2")]
public string get_Literal();
    [CompilerGeneratedAttribute]
public Expression get_Expression();
    [CompilerGeneratedAttribute]
public OrderingDirection get_Direction();
    [CompilerGeneratedAttribute]
public void set_Direction(OrderingDirection value);
    [CompilerGeneratedAttribute]
public CasingRule get_CasingRule();
    [CompilerGeneratedAttribute]
public void set_CasingRule(CasingRule value);
    [CompilerGeneratedAttribute]
public bool get_IsTransformed();
    [CompilerGeneratedAttribute]
public void set_IsTransformed(bool value);
    public string BuildExpression(IQueryableMemberCollection collection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.Parsing.Operators.OrderingOperator : LinqOperator {
    [CompilerGeneratedAttribute]
private OrderingDirection <Direction>k__BackingField;
    public OrderingDirection Direction { get; }
    public OrderingOperator(string methodName, OrderingDirection direction);
    [CompilerGeneratedAttribute]
public OrderingDirection get_Direction();
    public virtual void Apply(ILinqQuery query, MethodCallExpression expression);
}
public class Marten.Linq.Parsing.Operators.SelectManyOperator : LinqOperator {
    [NullableContextAttribute("1")]
public virtual void Apply(ILinqQuery query, MethodCallExpression expression);
}
public class Marten.Linq.Parsing.Operators.SelectOperator : LinqOperator {
    [NullableContextAttribute("1")]
public virtual void Apply(ILinqQuery query, MethodCallExpression expression);
}
internal class Marten.Linq.Parsing.Operators.SingleValueOperator : LinqOperator {
    private bool _isMathOperator;
    [CompilerGeneratedAttribute]
private SingleValueMode <Mode>k__BackingField;
    public SingleValueMode Mode { get; }
    public SingleValueOperator(SingleValueMode mode);
    [CompilerGeneratedAttribute]
public SingleValueMode get_Mode();
    [NullableContextAttribute("1")]
public virtual void Apply(ILinqQuery query, MethodCallExpression expression);
}
public class Marten.Linq.Parsing.Operators.SkipOperator : LinqOperator {
    [NullableContextAttribute("1")]
public virtual void Apply(ILinqQuery query, MethodCallExpression expression);
}
public class Marten.Linq.Parsing.Operators.TakeOperator : LinqOperator {
    [NullableContextAttribute("1")]
public virtual void Apply(ILinqQuery query, MethodCallExpression expression);
}
internal class Marten.Linq.Parsing.Operators.ThenBySqlOperator : LinqOperator {
    [NullableContextAttribute("1")]
public virtual void Apply(ILinqQuery query, MethodCallExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.Parsing.Operators.WhereOperator : LinqOperator {
    private Cache`2<Type, object> _always;
    public virtual void Apply(ILinqQuery query, MethodCallExpression expression);
}
public class Marten.Linq.Parsing.SelectorVisitor : ExpressionVisitor {
    private IQueryableMemberCollection _collection;
    private ISerializer _serializer;
    private SelectorStatement _statement;
    public SelectorVisitor(SelectorStatement statement, IQueryableMemberCollection collection, ISerializer serializer);
    public virtual Expression Visit(Expression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected virtual Expression VisitUnary(UnaryExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitMemberInit(MemberInitExpression node);
    protected virtual Expression VisitNew(NewExpression node);
    public void ToScalar(Expression selectClauseSelector);
    public void ToSelectTransform(Expression selectExpression, ISerializer serializer);
}
internal class Marten.Linq.Parsing.SelectParser : ExpressionVisitor {
    private ISerializer _serializer;
    private IQueryableMemberCollection _members;
    private string _currentField;
    [CompilerGeneratedAttribute]
private NewObject <NewObject>k__BackingField;
    private bool _hasStarted;
    public NewObject NewObject { get; private set; }
    public SelectParser(ISerializer serializer, IQueryableMemberCollection members, Expression expression);
    [CompilerGeneratedAttribute]
public NewObject get_NewObject();
    [CompilerGeneratedAttribute]
private void set_NewObject(NewObject value);
    public virtual Expression Visit(Expression node);
    protected virtual Expression VisitBinary(BinaryExpression node);
    protected virtual Expression VisitConstant(ConstantExpression node);
    protected virtual Expression VisitMemberInit(MemberInitExpression node);
    public void ReadBinding(MemberAssignment binding);
    protected virtual MemberBinding VisitMemberBinding(MemberBinding node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitNew(NewExpression node);
}
internal class Marten.Linq.Parsing.SimpleExpression : ExpressionVisitor {
    private Expression _expression;
    private IQueryableMemberCollection _queryableMembers;
    public List`1<MemberInfo> Members;
    [CompilerGeneratedAttribute]
private ConstantExpression <Constant>k__BackingField;
    [CompilerGeneratedAttribute]
private IQueryableMember <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private IComparableMember <Comparable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FoundParameterAtStart>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ISqlFragment> <Filters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasConstant>k__BackingField;
    public ConstantExpression Constant { get; public set; }
    public IQueryableMember Member { get; private set; }
    public IComparableMember Comparable { get; private set; }
    public bool FoundParameterAtStart { get; private set; }
    public List`1<ISqlFragment> Filters { get; }
    public bool HasConstant { get; public set; }
    public SimpleExpression(IQueryableMemberCollection queryableMembers, Expression expression);
    public virtual Expression Visit(Expression node);
    [CompilerGeneratedAttribute]
public ConstantExpression get_Constant();
    [CompilerGeneratedAttribute]
public void set_Constant(ConstantExpression value);
    [CompilerGeneratedAttribute]
public IQueryableMember get_Member();
    [CompilerGeneratedAttribute]
private void set_Member(IQueryableMember value);
    [CompilerGeneratedAttribute]
public IComparableMember get_Comparable();
    [CompilerGeneratedAttribute]
private void set_Comparable(IComparableMember value);
    [CompilerGeneratedAttribute]
public bool get_FoundParameterAtStart();
    [CompilerGeneratedAttribute]
private void set_FoundParameterAtStart(bool value);
    [CompilerGeneratedAttribute]
public List`1<ISqlFragment> get_Filters();
    [CompilerGeneratedAttribute]
public bool get_HasConstant();
    [CompilerGeneratedAttribute]
public void set_HasConstant(bool value);
    private ISqlFragment compareConstants(SimpleExpression right, string op);
    public ISqlFragment CompareTo(SimpleExpression right, string op);
    protected virtual Expression VisitBinary(BinaryExpression node);
    protected virtual Expression VisitUnary(UnaryExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitParameter(ParameterExpression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    public ISqlFragment FindValueFragment();
}
public enum Marten.Linq.Parsing.SingleValueMode : Enum {
    public int value__;
    public static SingleValueMode First;
    public static SingleValueMode FirstOrDefault;
    public static SingleValueMode Single;
    public static SingleValueMode SingleOrDefault;
    public static SingleValueMode Count;
    public static SingleValueMode LongCount;
    public static SingleValueMode Any;
    public static SingleValueMode Average;
    public static SingleValueMode Sum;
    public static SingleValueMode Max;
    public static SingleValueMode Min;
}
public class Marten.Linq.Parsing.WhereClauseParser : ExpressionVisitor {
    private static Dictionary`2<ExpressionType, string> _operators;
    private IQueryableMemberCollection _members;
    private StoreOptions _options;
    private IWhereFragmentHolder _holder;
    public WhereClauseParser(StoreOptions options, IQueryableMemberCollection members, IWhereFragmentHolder holder);
    private static WhereClauseParser();
    public virtual Expression Visit(Expression node);
    protected virtual Expression VisitLambda(Expression`1<T> node);
    protected virtual Expression VisitInvocation(InvocationExpression node);
    protected virtual Expression VisitConstant(ConstantExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected virtual Expression VisitBinary(BinaryExpression node);
    private void buildCompoundWhereFragment(BinaryExpression node, string separator);
    protected virtual Expression VisitUnary(UnaryExpression node);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Marten.Linq.QueryHandlers.AdvancedSqlQueryHandler`1 : AdvancedSqlQueryHandlerBase`1<T> {
    public AdvancedSqlQueryHandler`1(IMartenSession session, string sql, Object[] parameters);
    public sealed virtual IReadOnlyList`1<T> Handle(DbDataReader reader, IMartenSession session);
    [AsyncIteratorStateMachineAttribute("Marten.Linq.QueryHandlers.AdvancedSqlQueryHandler`1/<EnumerateResults>d__2")]
public virtual IAsyncEnumerable`1<T> EnumerateResults(DbDataReader reader, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Marten.Linq.QueryHandlers.AdvancedSqlQueryHandler`2 : AdvancedSqlQueryHandlerBase`1<ValueTuple`2<T1, T2>> {
    public AdvancedSqlQueryHandler`2(IMartenSession session, string sql, Object[] parameters);
    public sealed virtual IReadOnlyList`1<ValueTuple`2<T1, T2>> Handle(DbDataReader reader, IMartenSession session);
    [AsyncIteratorStateMachineAttribute("Marten.Linq.QueryHandlers.AdvancedSqlQueryHandler`2/<EnumerateResults>d__2")]
public virtual IAsyncEnumerable`1<ValueTuple`2<T1, T2>> EnumerateResults(DbDataReader reader, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Marten.Linq.QueryHandlers.AdvancedSqlQueryHandler`3 : AdvancedSqlQueryHandlerBase`1<ValueTuple`3<T1, T2, T3>> {
    public AdvancedSqlQueryHandler`3(IMartenSession session, string sql, Object[] parameters);
    public sealed virtual IReadOnlyList`1<ValueTuple`3<T1, T2, T3>> Handle(DbDataReader reader, IMartenSession session);
    [AsyncIteratorStateMachineAttribute("Marten.Linq.QueryHandlers.AdvancedSqlQueryHandler`3/<EnumerateResults>d__2")]
public virtual IAsyncEnumerable`1<ValueTuple`3<T1, T2, T3>> EnumerateResults(DbDataReader reader, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Marten.Linq.QueryHandlers.AdvancedSqlQueryHandlerBase`1 : object {
    protected Object[] Parameters;
    protected string Sql;
    protected List`1<ISelector> Selectors;
    [CompilerGeneratedAttribute]
private List`1<Type> <DocumentTypes>k__BackingField;
    public List`1<Type> DocumentTypes { get; }
    protected AdvancedSqlQueryHandlerBase`1(string sql, Object[] parameters);
    [CompilerGeneratedAttribute]
public List`1<Type> get_DocumentTypes();
    public sealed virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    [AsyncStateMachineAttribute("Marten.Linq.QueryHandlers.AdvancedSqlQueryHandlerBase`1/<ReadNestedRowAsync>d__8`1")]
protected Task`1<T> ReadNestedRowAsync(DbDataReader reader, int rowIndex, CancellationToken token);
    protected T ReadNestedRow(DbDataReader reader, int rowIndex);
    protected ISelectClause GetSelectClause(IMartenSession session);
    protected void RegisterResultType(IMartenSession session);
    public sealed virtual Task`1<int> StreamJson(Stream stream, DbDataReader reader, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Linq.QueryHandlers.AdvancedSqlQueryHandlerBase`1/<HandleAsync>d__13")]
public sealed virtual Task`1<IReadOnlyList`1<TResult>> HandleAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
    public abstract virtual IAsyncEnumerable`1<TResult> EnumerateResults(DbDataReader reader, CancellationToken token);
}
[NullableContextAttribute("1")]
public interface Marten.Linq.QueryHandlers.IMaybeStatefulHandler {
    public abstract virtual bool DependsOnDocumentSelector();
    public abstract virtual IQueryHandler CloneForSession(IMartenSession session, QueryStatistics statistics);
    public abstract virtual Task`1<int> StreamJson(Stream stream, DbDataReader reader, CancellationToken token);
}
[NullableContextAttribute("1")]
public interface Marten.Linq.QueryHandlers.IQueryHandler {
    public abstract virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
}
[NullableContextAttribute("1")]
public interface Marten.Linq.QueryHandlers.IQueryHandler`1 {
    public abstract virtual T Handle(DbDataReader reader, IMartenSession session);
    public abstract virtual Task`1<T> HandleAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
    public abstract virtual Task`1<int> StreamJson(Stream stream, DbDataReader reader, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.QueryHandlers.LinqConstants : object {
    internal static string StatsColumn;
    internal static string IdListTableName;
    internal static ISelector`1<string> StringValueSelector;
    internal static string CONTAINS;
    internal static string ANY;
    internal static string ALL;
    internal static PropertyInfo ArrayLength;
    private static LinqConstants();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.QueryHandlers.ListQueryHandler`1 : object {
    [NullableAttribute("2")]
private ISqlFragment _statement;
    [CompilerGeneratedAttribute]
private ISelector`1<T> <Selector>k__BackingField;
    public ISelector`1<T> Selector { get; }
    public ListQueryHandler`1(ISqlFragment statement, ISelector`1<T> selector);
    [CompilerGeneratedAttribute]
public ISelector`1<T> get_Selector();
    public sealed virtual bool DependsOnDocumentSelector();
    public sealed virtual IQueryHandler CloneForSession(IMartenSession session, QueryStatistics statistics);
    [AsyncStateMachineAttribute("Marten.Linq.QueryHandlers.ListQueryHandler`1/<Marten-Linq-QueryHandlers-IQueryHandler<System-Collections-Generic-IEnumerable<T>>-HandleAsync>d__7")]
private sealed virtual override Task`1<IEnumerable`1<T>> Marten.Linq.QueryHandlers.IQueryHandler<System.Collections.Generic.IEnumerable<T>>.HandleAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
    private sealed virtual override IEnumerable`1<T> Marten.Linq.QueryHandlers.IQueryHandler<System.Collections.Generic.IEnumerable<T>>.Handle(DbDataReader reader, IMartenSession session);
    public sealed virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual IReadOnlyList`1<T> Handle(DbDataReader reader, IMartenSession session);
    public sealed virtual Task`1<int> StreamJson(Stream stream, DbDataReader reader, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Linq.QueryHandlers.ListQueryHandler`1/<HandleAsync>d__12")]
public sealed virtual Task`1<IReadOnlyList`1<T>> HandleAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.QueryHandlers.ListWithStatsQueryHandler`1 : object {
    private int _countIndex;
    private ISelector`1<T> _selector;
    [NullableAttribute("2")]
private ISqlFragment _statement;
    private QueryStatistics _statistics;
    public ListWithStatsQueryHandler`1(int countIndex, ISqlFragment statement, ISelector`1<T> selector, QueryStatistics statistics);
    public sealed virtual bool DependsOnDocumentSelector();
    public sealed virtual IQueryHandler CloneForSession(IMartenSession session, QueryStatistics statistics);
    [AsyncStateMachineAttribute("Marten.Linq.QueryHandlers.ListWithStatsQueryHandler`1/<Marten-Linq-QueryHandlers-IQueryHandler<System-Collections-Generic-IEnumerable<T>>-HandleAsync>d__7")]
private sealed virtual override Task`1<IEnumerable`1<T>> Marten.Linq.QueryHandlers.IQueryHandler<System.Collections.Generic.IEnumerable<T>>.HandleAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
    private sealed virtual override IEnumerable`1<T> Marten.Linq.QueryHandlers.IQueryHandler<System.Collections.Generic.IEnumerable<T>>.Handle(DbDataReader reader, IMartenSession session);
    public sealed virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual IReadOnlyList`1<T> Handle(DbDataReader reader, IMartenSession session);
    [AsyncStateMachineAttribute("Marten.Linq.QueryHandlers.ListWithStatsQueryHandler`1/<StreamJson>d__11")]
public sealed virtual Task`1<int> StreamJson(Stream stream, DbDataReader reader, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Linq.QueryHandlers.ListWithStatsQueryHandler`1/<HandleAsync>d__12")]
public sealed virtual Task`1<IReadOnlyList`1<T>> HandleAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.QueryHandlers.LoadByIdArrayHandler`2 : object {
    private TKey[] _ids;
    private IDocumentStorage`1<T> storage;
    public LoadByIdArrayHandler`2(IDocumentStorage`1<T> documentStorage, TKey[] ids);
    public sealed virtual void ConfigureCommand(ICommandBuilder sql, IMartenSession session);
    public sealed virtual IReadOnlyList`1<T> Handle(DbDataReader reader, IMartenSession session);
    [AsyncStateMachineAttribute("Marten.Linq.QueryHandlers.LoadByIdArrayHandler`2/<HandleAsync>d__5")]
public sealed virtual Task`1<IReadOnlyList`1<T>> HandleAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
    public sealed virtual Task`1<int> StreamJson(Stream stream, DbDataReader reader, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.QueryHandlers.LoadByIdHandler`2 : object {
    private TId _id;
    private IDocumentStorage`1<T> storage;
    public LoadByIdHandler`2(IDocumentStorage`2<T, TId> documentStorage, TId id);
    public sealed virtual void ConfigureCommand(ICommandBuilder sql, IMartenSession session);
    public sealed virtual T Handle(DbDataReader reader, IMartenSession session);
    [AsyncStateMachineAttribute("Marten.Linq.QueryHandlers.LoadByIdHandler`2/<HandleAsync>d__5")]
public sealed virtual Task`1<T> HandleAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
    public sealed virtual Task`1<int> StreamJson(Stream stream, DbDataReader reader, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.QueryHandlers.OneResultHandler`1 : object {
    private static string NoElementsMessage;
    private static string MoreThanOneElementMessage;
    private bool _canBeMultiples;
    private bool _canBeNull;
    private ISelector`1<T> _selector;
    [NullableAttribute("2")]
private ISqlFragment _statement;
    public OneResultHandler`1(ISqlFragment statement, ISelector`1<T> selector, bool canBeNull, bool canBeMultiples);
    public sealed virtual bool DependsOnDocumentSelector();
    public sealed virtual IQueryHandler CloneForSession(IMartenSession session, QueryStatistics statistics);
    public sealed virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual T Handle(DbDataReader reader, IMartenSession session);
    [AsyncStateMachineAttribute("Marten.Linq.QueryHandlers.OneResultHandler`1/<HandleAsync>d__11")]
public sealed virtual Task`1<T> HandleAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Linq.QueryHandlers.OneResultHandler`1/<StreamJson>d__12")]
public sealed virtual Task`1<int> StreamJson(Stream stream, DbDataReader reader, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.QueryHandlers.UserSuppliedQueryHandler`1 : object {
    private Object[] _parameters;
    private ISelectClause _selectClause;
    private ISelector`1<T> _selector;
    private string _sql;
    [CompilerGeneratedAttribute]
private bool <SqlContainsCustomSelect>k__BackingField;
    public bool SqlContainsCustomSelect { get; }
    public UserSuppliedQueryHandler`1(IMartenSession session, string sql, Object[] parameters);
    [CompilerGeneratedAttribute]
public bool get_SqlContainsCustomSelect();
    public sealed virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual IReadOnlyList`1<T> Handle(DbDataReader reader, IMartenSession session);
    [AsyncStateMachineAttribute("Marten.Linq.QueryHandlers.UserSuppliedQueryHandler`1/<HandleAsync>d__10")]
public sealed virtual Task`1<IReadOnlyList`1<T>> HandleAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
    public sealed virtual Task`1<int> StreamJson(Stream stream, DbDataReader reader, CancellationToken token);
    private ISelectClause GetSelectClause(IMartenSession session);
    private static bool IsWithFollowedBySelect(string sql);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.QueryPlan : object {
    [CompilerGeneratedAttribute]
private string <NodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RelationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <StartupCost>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <TotalCost>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PlanRows>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PlanWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ParallelAware>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <ActualStartupTime>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <ActualTotalTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ActualRows>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ActualLoops>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <SortKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SortMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private double <SortSpaceUsed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SortSpaceType>k__BackingField;
    [CompilerGeneratedAttribute]
private QueryPlan[] <Plans>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <PlanningTime>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <ExecutionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private NpgsqlCommand <Command>k__BackingField;
    [JsonPropertyNameAttribute("Node Type")]
[JsonPropertyAttribute]
public string NodeType { get; public set; }
    [JsonPropertyNameAttribute("Relation Name")]
[JsonPropertyAttribute]
public string RelationName { get; public set; }
    public string Alias { get; public set; }
    [JsonPropertyNameAttribute("Startup Cost")]
[JsonPropertyAttribute]
public decimal StartupCost { get; public set; }
    [JsonPropertyNameAttribute("Total Cost")]
[JsonPropertyAttribute]
public decimal TotalCost { get; public set; }
    [JsonPropertyNameAttribute("Plan Rows")]
[JsonPropertyAttribute]
public int PlanRows { get; public set; }
    [JsonPropertyNameAttribute("Plan Width")]
[JsonPropertyAttribute]
public int PlanWidth { get; public set; }
    [JsonPropertyNameAttribute("Parallel Aware")]
[JsonPropertyAttribute]
public bool ParallelAware { get; public set; }
    [JsonPropertyNameAttribute("Actual Startup Time")]
[JsonPropertyAttribute]
public decimal ActualStartupTime { get; public set; }
    [JsonPropertyNameAttribute("Actual Total Time")]
[JsonPropertyAttribute]
public decimal ActualTotalTime { get; public set; }
    [JsonPropertyNameAttribute("Actual Rows")]
[JsonPropertyAttribute]
public int ActualRows { get; public set; }
    [JsonPropertyNameAttribute("Actual Loops")]
[JsonPropertyAttribute]
public int ActualLoops { get; public set; }
    [JsonPropertyNameAttribute("Output")]
[JsonPropertyAttribute]
public String[] Output { get; public set; }
    [JsonPropertyNameAttribute("Sort Key")]
[JsonPropertyAttribute]
public String[] SortKey { get; public set; }
    [JsonPropertyNameAttribute("Sort Method")]
[JsonPropertyAttribute]
public string SortMethod { get; public set; }
    [JsonPropertyNameAttribute("Sort Space Used")]
[JsonPropertyAttribute]
public double SortSpaceUsed { get; public set; }
    [JsonPropertyNameAttribute("Sort Space Type")]
[JsonPropertyAttribute]
public string SortSpaceType { get; public set; }
    [JsonPropertyNameAttribute("Plans")]
[JsonPropertyAttribute]
public QueryPlan[] Plans { get; public set; }
    public decimal PlanningTime { get; public set; }
    public decimal ExecutionTime { get; public set; }
    public NpgsqlCommand Command { get; public set; }
    [CompilerGeneratedAttribute]
public string get_NodeType();
    [CompilerGeneratedAttribute]
public void set_NodeType(string value);
    [CompilerGeneratedAttribute]
public string get_RelationName();
    [CompilerGeneratedAttribute]
public void set_RelationName(string value);
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
public void set_Alias(string value);
    [CompilerGeneratedAttribute]
public decimal get_StartupCost();
    [CompilerGeneratedAttribute]
public void set_StartupCost(decimal value);
    [CompilerGeneratedAttribute]
public decimal get_TotalCost();
    [CompilerGeneratedAttribute]
public void set_TotalCost(decimal value);
    [CompilerGeneratedAttribute]
public int get_PlanRows();
    [CompilerGeneratedAttribute]
public void set_PlanRows(int value);
    [CompilerGeneratedAttribute]
public int get_PlanWidth();
    [CompilerGeneratedAttribute]
public void set_PlanWidth(int value);
    [CompilerGeneratedAttribute]
public bool get_ParallelAware();
    [CompilerGeneratedAttribute]
public void set_ParallelAware(bool value);
    [CompilerGeneratedAttribute]
public decimal get_ActualStartupTime();
    [CompilerGeneratedAttribute]
public void set_ActualStartupTime(decimal value);
    [CompilerGeneratedAttribute]
public decimal get_ActualTotalTime();
    [CompilerGeneratedAttribute]
public void set_ActualTotalTime(decimal value);
    [CompilerGeneratedAttribute]
public int get_ActualRows();
    [CompilerGeneratedAttribute]
public void set_ActualRows(int value);
    [CompilerGeneratedAttribute]
public int get_ActualLoops();
    [CompilerGeneratedAttribute]
public void set_ActualLoops(int value);
    [CompilerGeneratedAttribute]
public String[] get_Output();
    [CompilerGeneratedAttribute]
public void set_Output(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_SortKey();
    [CompilerGeneratedAttribute]
public void set_SortKey(String[] value);
    [CompilerGeneratedAttribute]
public string get_SortMethod();
    [CompilerGeneratedAttribute]
public void set_SortMethod(string value);
    [CompilerGeneratedAttribute]
public double get_SortSpaceUsed();
    [CompilerGeneratedAttribute]
public void set_SortSpaceUsed(double value);
    [CompilerGeneratedAttribute]
public string get_SortSpaceType();
    [CompilerGeneratedAttribute]
public void set_SortSpaceType(string value);
    [CompilerGeneratedAttribute]
public QueryPlan[] get_Plans();
    [CompilerGeneratedAttribute]
public void set_Plans(QueryPlan[] value);
    [CompilerGeneratedAttribute]
public decimal get_PlanningTime();
    [CompilerGeneratedAttribute]
public void set_PlanningTime(decimal value);
    [CompilerGeneratedAttribute]
public decimal get_ExecutionTime();
    [CompilerGeneratedAttribute]
public void set_ExecutionTime(decimal value);
    [CompilerGeneratedAttribute]
public NpgsqlCommand get_Command();
    [CompilerGeneratedAttribute]
public void set_Command(NpgsqlCommand value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.QueryPlanContainer : object {
    [CompilerGeneratedAttribute]
private QueryPlan <Plan>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <PlanningTime>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <ExecutionTime>k__BackingField;
    public QueryPlan Plan { get; public set; }
    [JsonPropertyNameAttribute("Planning Time")]
[JsonPropertyAttribute]
public decimal PlanningTime { get; public set; }
    [JsonPropertyNameAttribute("Execution Time")]
[JsonPropertyAttribute]
public decimal ExecutionTime { get; public set; }
    [CompilerGeneratedAttribute]
public QueryPlan get_Plan();
    [CompilerGeneratedAttribute]
public void set_Plan(QueryPlan value);
    [CompilerGeneratedAttribute]
public decimal get_PlanningTime();
    [CompilerGeneratedAttribute]
public void set_PlanningTime(decimal value);
    [CompilerGeneratedAttribute]
public decimal get_ExecutionTime();
    [CompilerGeneratedAttribute]
public void set_ExecutionTime(decimal value);
}
public class Marten.Linq.QueryStatistics : object {
    [CompilerGeneratedAttribute]
private long <TotalResults>k__BackingField;
    public long TotalResults { get; public set; }
    [CompilerGeneratedAttribute]
public long get_TotalResults();
    [CompilerGeneratedAttribute]
public void set_TotalResults(long value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Selectors.CastingSelector`2 : object {
    private ISelector`1<TRoot> _inner;
    public CastingSelector`2(ISelector`1<TRoot> inner);
    public sealed virtual T Resolve(DbDataReader reader);
    [AsyncStateMachineAttribute("Marten.Linq.Selectors.CastingSelector`2/<ResolveAsync>d__3")]
public sealed virtual Task`1<T> ResolveAsync(DbDataReader reader, CancellationToken token);
}
public interface Marten.Linq.Selectors.ISelector {
}
[NullableContextAttribute("1")]
public interface Marten.Linq.Selectors.ISelector`1 {
    public abstract virtual T Resolve(DbDataReader reader);
    public abstract virtual Task`1<T> ResolveAsync(DbDataReader reader, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.Selectors.SerializationSelector`1 : object {
    private ISerializer _serializer;
    public SerializationSelector`1(ISerializer serializer);
    public sealed virtual T Resolve(DbDataReader reader);
    [AsyncStateMachineAttribute("Marten.Linq.Selectors.SerializationSelector`1/<ResolveAsync>d__3")]
public sealed virtual Task`1<T> ResolveAsync(DbDataReader reader, CancellationToken token);
}
internal class Marten.Linq.Selectors.TimeSpanSelector : object {
    [NullableContextAttribute("1")]
public sealed virtual TimeSpan Resolve(DbDataReader reader);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Marten.Linq.Selectors.TimeSpanSelector/<ResolveAsync>d__1")]
public sealed virtual Task`1<TimeSpan> ResolveAsync(DbDataReader reader, CancellationToken token);
}
internal class Marten.Linq.SoftDeletes.DeletedBeforeFilter : object {
    private DateTimeOffset _time;
    [NullableAttribute("1")]
private static string _sql;
    public DeletedBeforeFilter(DateTimeOffset time);
    private static DeletedBeforeFilter();
    [NullableContextAttribute("1")]
public sealed virtual void Apply(ICommandBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SoftDeletes.DeletedBeforeParser : object {
    private static MethodInfo _method;
    private static DeletedBeforeParser();
    public sealed virtual bool Matches(MethodCallExpression expression);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
internal class Marten.Linq.SoftDeletes.DeletedSinceFilter : object {
    private DateTimeOffset _time;
    [NullableAttribute("1")]
private static string _sql;
    public DeletedSinceFilter(DateTimeOffset time);
    private static DeletedSinceFilter();
    [NullableContextAttribute("1")]
public sealed virtual void Apply(ICommandBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SoftDeletes.DeletedSinceParser : object {
    private static MethodInfo _method;
    private static DeletedSinceParser();
    public sealed virtual bool Matches(MethodCallExpression expression);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
internal class Marten.Linq.SoftDeletes.IsDeletedFilter : object {
    [NullableAttribute("1")]
public static IsDeletedFilter Instance;
    [NullableAttribute("1")]
private static string _sql;
    private static IsDeletedFilter();
    [NullableContextAttribute("1")]
public sealed virtual void Apply(ICommandBuilder builder);
    [NullableContextAttribute("1")]
public sealed virtual ISqlFragment Reverse();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SoftDeletes.IsDeletedParser : object {
    private static MethodInfo _method;
    private static IsDeletedParser();
    public sealed virtual bool Matches(MethodCallExpression expression);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
}
internal class Marten.Linq.SoftDeletes.IsNotDeletedFilter : object {
    [NullableAttribute("1")]
public static IsNotDeletedFilter Instance;
    [NullableAttribute("1")]
private static string _sql;
    private static IsNotDeletedFilter();
    [NullableContextAttribute("1")]
public sealed virtual void Apply(ICommandBuilder builder);
    [NullableContextAttribute("1")]
public sealed virtual ISqlFragment Reverse();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.SoftDeletes.IsSoftDeletedMember : object {
    private static string _locator;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    public Type MemberType { get; }
    public string JsonPathSegment { get; }
    public string MemberName { get; }
    public string TypedLocator { get; }
    public string RawLocator { get; }
    public string JSONBLocator { get; }
    public IQueryableMember[] Ancestors { get; }
    public string LocatorForIncludedDocumentId { get; }
    public string NullTestLocator { get; }
    public IsSoftDeletedMember(MemberInfo member);
    private static IsSoftDeletedMember();
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual ISqlFragment CreateComparison(string op, ConstantExpression constant);
    public sealed virtual Type get_MemberType();
    public sealed virtual string get_JsonPathSegment();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MemberName();
    public sealed virtual string get_TypedLocator();
    public sealed virtual string get_RawLocator();
    public sealed virtual string get_JSONBLocator();
    public sealed virtual IQueryableMember[] get_Ancestors();
    public sealed virtual string get_LocatorForIncludedDocumentId();
    public sealed virtual string get_NullTestLocator();
    public sealed virtual string BuildOrderingExpression(Ordering ordering, CasingRule casingRule);
    public sealed virtual Dictionary`2<string, object> FindOrPlaceChildDictionaryForContainment(Dictionary`2<string, object> dict);
    public sealed virtual void PlaceValueInDictionaryForContainment(Dictionary`2<string, object> dict, ConstantExpression constant);
    public sealed virtual string SelectorForDuplication(string pgType);
    public sealed virtual ISqlFragment BuildIsTrueFragment();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SoftDeletes.MaybeDeletedParser : object {
    private static MethodInfo _method;
    private static string _sql;
    private static MaybeDeletedParser();
    public sealed virtual bool Matches(MethodCallExpression expression);
    public sealed virtual ISqlFragment Parse(IQueryableMemberCollection memberCollection, IReadOnlyStoreOptions options, MethodCallExpression expression);
    public sealed virtual void Apply(ICommandBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Marten.Linq.SoftDeletes.SoftDeletedExtensions : object {
    [ExtensionAttribute]
public static bool MaybeDeleted(object doc);
    [ExtensionAttribute]
public static bool IsDeleted(object doc);
    [ExtensionAttribute]
public static bool DeletedSince(object doc, DateTimeOffset time);
    [ExtensionAttribute]
public static bool DeletedBefore(object doc, DateTimeOffset time);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.SqlGeneration.AnySelectClause : object {
    private ISqlFragment _topStatement;
    [CompilerGeneratedAttribute]
private string <FromObject>k__BackingField;
    public string FromObject { get; }
    public Type SelectedType { get; }
    public AnySelectClause(string from);
    public sealed virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual bool Handle(DbDataReader reader, IMartenSession session);
    [AsyncStateMachineAttribute("Marten.Linq.SqlGeneration.AnySelectClause/<HandleAsync>d__4")]
public sealed virtual Task`1<bool> HandleAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
    public sealed virtual Task`1<int> StreamJson(Stream stream, DbDataReader reader, CancellationToken token);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FromObject();
    public sealed virtual Type get_SelectedType();
    public sealed virtual void Apply(ICommandBuilder sql);
    public sealed virtual String[] SelectFields();
    public sealed virtual ISelector BuildSelector(IMartenSession session);
    public sealed virtual IQueryHandler`1<T> BuildHandler(IMartenSession session, ISqlFragment topStatement, ISqlFragment currentStatement);
    public sealed virtual ISelectClause UseStatistics(QueryStatistics statistics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.SqlGeneration.CountClause`1 : object {
    private ISqlFragment _topStatement;
    [CompilerGeneratedAttribute]
private string <FromObject>k__BackingField;
    public Type SelectedType { get; }
    public string FromObject { get; public set; }
    public CountClause`1(string from);
    public sealed virtual void OverrideFromObject(Statement parent);
    public sealed virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    public sealed virtual T Handle(DbDataReader reader, IMartenSession session);
    [AsyncStateMachineAttribute("Marten.Linq.SqlGeneration.CountClause`1/<HandleAsync>d__5")]
public sealed virtual Task`1<T> HandleAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
    public sealed virtual Task`1<int> StreamJson(Stream stream, DbDataReader reader, CancellationToken token);
    public sealed virtual Type get_SelectedType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FromObject();
    [CompilerGeneratedAttribute]
public void set_FromObject(string value);
    public sealed virtual void Apply(ICommandBuilder sql);
    public sealed virtual String[] SelectFields();
    public sealed virtual ISelector BuildSelector(IMartenSession session);
    public sealed virtual IQueryHandler`1<TResult> BuildHandler(IMartenSession session, ISqlFragment topStatement, ISqlFragment currentStatement);
    public sealed virtual ISelectClause UseStatistics(QueryStatistics statistics);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.DataSelectClause`1 : object {
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FromObject>k__BackingField;
    public string MemberName { get; public set; }
    public Type SelectedType { get; }
    public string FromObject { get; public set; }
    public DataSelectClause`1(string from);
    public DataSelectClause`1(string from, string field);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MemberName();
    [CompilerGeneratedAttribute]
public void set_MemberName(string value);
    public sealed virtual ISelectClause CloneToOtherTable(string tableName);
    public sealed virtual void ApplyOperator(string op);
    public sealed virtual ISelectClause CloneToDouble();
    public sealed virtual Type get_SelectedType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FromObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FromObject(string value);
    public sealed virtual void Apply(ICommandBuilder sql);
    public sealed virtual String[] SelectFields();
    public sealed virtual ISelector BuildSelector(IMartenSession session);
    public sealed virtual IQueryHandler`1<TResult> BuildHandler(IMartenSession session, ISqlFragment statement, ISqlFragment currentStatement);
    public sealed virtual ISelectClause UseStatistics(QueryStatistics statistics);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.Deletion : StatementOperation {
    [CompilerGeneratedAttribute]
private object <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Id>k__BackingField;
    public object Document { get; public set; }
    public object Id { get; public set; }
    public Deletion(IDocumentStorage storage, IOperationFragment operation, ISqlFragment where);
    public Deletion(IDocumentStorage storage, IOperationFragment operation);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Document();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Document(object value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Id(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.DistinctSelectionStatement : Statement {
    public DistinctSelectionStatement(SelectorStatement parent, ICountClause selectClause, IMartenSession session);
    protected virtual void configure(ICommandBuilder sql);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.ExplodeCollectionStatement : Statement {
    private string _locator;
    private string _sourceTable;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ISqlFragment <Where>k__BackingField;
    [NullableAttribute("2")]
public ISqlFragment Where { get; public set; }
    public ExplodeCollectionStatement(Statement parent, string locator, IMartenSession session);
    public ExplodeCollectionStatement(IMartenSession session, SelectorStatement selectorStatement, string locator);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ISqlFragment get_Where();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Where(ISqlFragment value);
    protected virtual void configure(ICommandBuilder sql);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.Filters.AllValuesAreNullFilter : object {
    private static ISqlFragment _filter;
    [NullableAttribute("2")]
private string _exportName;
    [CompilerGeneratedAttribute]
private ICollectionMember <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Not>k__BackingField;
    public ICollectionMember Member { get; }
    public bool Not { get; public set; }
    public AllValuesAreNullFilter(ICollectionMember member);
    private static AllValuesAreNullFilter();
    [CompilerGeneratedAttribute]
public ICollectionMember get_Member();
    public sealed virtual void Apply(ICommandBuilder builder);
    [CompilerGeneratedAttribute]
public bool get_Not();
    [CompilerGeneratedAttribute]
public void set_Not(bool value);
    public sealed virtual ISqlFragment Reverse();
    public sealed virtual void PlaceUnnestAbove(IMartenSession session, SelectorStatement statement, ISqlFragment topLevelWhere);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.Filters.AllValuesEqualFilter : object {
    private ConstantExpression _constant;
    private ICollectionMember _member;
    public AllValuesEqualFilter(ConstantExpression constant, ICollectionMember member);
    public sealed virtual void Apply(ICommandBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.Filters.ArrayContainer : object {
    private IDictionaryPart _inner;
    public ArrayContainer(IDictionaryPart inner);
    public sealed virtual string Write();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.Filters.ArrayDeclaration : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private DictionaryDeclaration <Inner>k__BackingField;
    public string Key { get; }
    public DictionaryDeclaration Inner { get; }
    public ArrayDeclaration(string key);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public DictionaryDeclaration get_Inner();
    public sealed virtual string Write();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.Filters.ArrayScalarValue : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <Member>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Key { get; public set; }
    public MemberInfo Member { get; public set; }
    public ArrayScalarValue(string Key, MemberInfo Member);
    [CompilerGeneratedAttribute]
protected ArrayScalarValue(ArrayScalarValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Key(string value);
    [CompilerGeneratedAttribute]
public MemberInfo get_Member();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Member(MemberInfo value);
    public sealed virtual string Write();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ArrayScalarValue left, ArrayScalarValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ArrayScalarValue left, ArrayScalarValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ArrayScalarValue other);
    [CompilerGeneratedAttribute]
public virtual ArrayScalarValue <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Key, MemberInfo& Member);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.SqlGeneration.Filters.BooleanFieldIsFalse : object {
    private IQueryableMember _member;
    public BooleanFieldIsFalse(IQueryableMember member);
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual ISqlFragment Reverse();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.SqlGeneration.Filters.BooleanFieldIsTrue : object {
    private IQueryableMember _member;
    public BooleanFieldIsTrue(IQueryableMember member);
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual ISqlFragment Reverse();
}
public class Marten.Linq.SqlGeneration.Filters.ByGuidFilter : ByIdFilter`1<Guid> {
    public ByGuidFilter(Guid value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.SqlGeneration.Filters.ByIdFilter : object {
    private CommandParameter _parameter;
    public ByIdFilter(object value, NpgsqlDbType dbType);
    public sealed virtual void Apply(ICommandBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.SqlGeneration.Filters.ByIdFilter`1 : object {
    private CommandParameter _parameter;
    public ByIdFilter`1(T value, NpgsqlDbType dbType);
    public sealed virtual void Apply(ICommandBuilder builder);
}
public class Marten.Linq.SqlGeneration.Filters.ByIntFilter : ByIdFilter`1<int> {
    public ByIntFilter(int value);
}
public class Marten.Linq.SqlGeneration.Filters.ByLongFilter : ByIdFilter`1<long> {
    public ByLongFilter(long value);
    public ByLongFilter(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Marten.Linq.SqlGeneration.Filters.ByStringFilter : ByIdFilter`1<string> {
    public ByStringFilter(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.Filters.CollectionIsEmpty : object {
    private ICollectionMember _member;
    private string _text;
    public CollectionIsEmpty(ICollectionMember member);
    public sealed virtual ISqlFragment Reverse();
    public sealed virtual void Apply(ICommandBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.Filters.CollectionIsNotEmpty : object {
    private string _text;
    [CompilerGeneratedAttribute]
private ICollectionMember <CollectionMember>k__BackingField;
    public ICollectionMember CollectionMember { get; }
    public CollectionIsNotEmpty(ICollectionMember member);
    public sealed virtual bool CanReduceInChildCollection();
    public sealed virtual ICollectionAwareFilter BuildFragment(ICollectionMember member, ISerializer serializer);
    public sealed virtual bool SupportsContainment();
    public sealed virtual void PlaceIntoContainmentFilter(ContainmentWhereFilter filter);
    public sealed virtual bool CanBeJsonPathFilter();
    public sealed virtual void BuildJsonPathFilter(ICommandBuilder builder, Dictionary`2<string, object> parameters);
    [IteratorStateMachineAttribute("Marten.Linq.SqlGeneration.Filters.CollectionIsNotEmpty/<Values>d__8")]
public sealed virtual IEnumerable`1<DictionaryValueUsage> Values();
    [CompilerGeneratedAttribute]
public sealed virtual ICollectionMember get_CollectionMember();
    public sealed virtual ISqlFragment MoveUnder(ICollectionMember ancestorCollection);
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual ISqlFragment Reverse();
}
public enum Marten.Linq.SqlGeneration.Filters.ContainmentUsage : Enum {
    public int value__;
    public static ContainmentUsage Singular;
    public static ContainmentUsage Collection;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.SqlGeneration.Filters.ContainmentWhereFilter : object {
    private string _locator;
    private ISerializer _serializer;
    private Dictionary`2<string, object> _data;
    private List`1<DictionaryValueUsage> _usages;
    [CompilerGeneratedAttribute]
private bool <IsNot>k__BackingField;
    [CompilerGeneratedAttribute]
private ContainmentUsage <Usage>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollectionMember <CollectionMember>k__BackingField;
    private bool _hasGenerated;
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public bool IsNot { get; public set; }
    public ContainmentUsage Usage { get; public set; }
    public ICollectionMember CollectionMember { get; }
    public string ParameterName { get; private set; }
    public ContainmentWhereFilter(IQueryableMember member, ConstantExpression constant, ISerializer serializer);
    public ContainmentWhereFilter(ICollectionMember collection, ISerializer serializer);
    public static ContainmentWhereFilter ForValue(ICollectionMember member, object value, ISerializer serializer);
    public sealed virtual ISqlFragment MoveUnder(ICollectionMember ancestorCollection);
    [CompilerGeneratedAttribute]
public bool get_IsNot();
    [CompilerGeneratedAttribute]
public void set_IsNot(bool value);
    [CompilerGeneratedAttribute]
public ContainmentUsage get_Usage();
    [CompilerGeneratedAttribute]
public void set_Usage(ContainmentUsage value);
    private sealed virtual override bool Marten.Linq.SqlGeneration.Filters.ICollectionAware.CanReduceInChildCollection();
    private sealed virtual override ICollectionAwareFilter Marten.Linq.SqlGeneration.Filters.ICollectionAware.BuildFragment(ICollectionMember member, ISerializer serializer);
    private sealed virtual override bool Marten.Linq.SqlGeneration.Filters.ICollectionAware.SupportsContainment();
    private sealed virtual override void Marten.Linq.SqlGeneration.Filters.ICollectionAware.PlaceIntoContainmentFilter(ContainmentWhereFilter filter);
    public sealed virtual bool CanBeJsonPathFilter();
    public sealed virtual void BuildJsonPathFilter(ICommandBuilder builder, Dictionary`2<string, object> parameters);
    [CompilerGeneratedAttribute]
public sealed virtual ICollectionMember get_CollectionMember();
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual ISqlFragment Reverse();
    public void PlaceMemberValue(IQueryableMember member, ConstantExpression constant);
    public sealed virtual bool TryMatchValue(object value, MemberInfo member);
    public sealed virtual void GenerateCode(GeneratedMethod method, int parameterIndex, string parametersVariableName);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ParameterName();
    [CompilerGeneratedAttribute]
private void set_ParameterName(string value);
    public sealed virtual IEnumerable`1<DictionaryValueUsage> Values();
}
public class Marten.Linq.SqlGeneration.Filters.CurrentTenantFilter : object {
    [NullableAttribute("1")]
public static CurrentTenantFilter Instance;
    private static CurrentTenantFilter();
    [NullableContextAttribute("1")]
public sealed virtual void Apply(ICommandBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.Filters.DeepCollectionIsNotEmpty : object {
    [CompilerGeneratedAttribute]
private List`1<IQueryableMember> <Path>k__BackingField;
    public List`1<IQueryableMember> Path { get; }
    public DeepCollectionIsNotEmpty(List`1<IQueryableMember> path);
    [CompilerGeneratedAttribute]
public List`1<IQueryableMember> get_Path();
    public sealed virtual void Apply(ICommandBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.Filters.DefaultTenantFilter : object {
    private string _tenantId;
    public DefaultTenantFilter(string tenantId);
    public sealed virtual void Apply(ICommandBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.Filters.DictionaryDeclaration : object {
    [CompilerGeneratedAttribute]
private List`1<IDictionaryPart> <Parts>k__BackingField;
    public List`1<IDictionaryPart> Parts { get; }
    [CompilerGeneratedAttribute]
public List`1<IDictionaryPart> get_Parts();
    public sealed virtual string Write();
    public void ReadDictionary(Dictionary`2<string, object> data, List`1<DictionaryValueUsage> usages);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.Filters.DictionaryValue : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <QueryMember>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Key { get; public set; }
    public MemberInfo QueryMember { get; public set; }
    public DictionaryValue(string Key, MemberInfo QueryMember);
    [CompilerGeneratedAttribute]
protected DictionaryValue(DictionaryValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Key(string value);
    [CompilerGeneratedAttribute]
public MemberInfo get_QueryMember();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_QueryMember(MemberInfo value);
    public sealed virtual string Write();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(DictionaryValue left, DictionaryValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(DictionaryValue left, DictionaryValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(DictionaryValue other);
    [CompilerGeneratedAttribute]
public virtual DictionaryValue <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Key, MemberInfo& QueryMember);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.SqlGeneration.Filters.DictionaryValueUsage : object {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private MemberInfo <QueryMember>k__BackingField;
    public object Value { get; }
    [NullableAttribute("2")]
public MemberInfo QueryMember { get; public set; }
    public DictionaryValueUsage(object value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public MemberInfo get_QueryMember();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_QueryMember(MemberInfo value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.SqlGeneration.Filters.EqualsFilter : object {
    [CompilerGeneratedAttribute]
private string <Locator>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Locator { get; public set; }
    public object Value { get; public set; }
    public EqualsFilter(string Locator, object Value);
    [CompilerGeneratedAttribute]
protected EqualsFilter(EqualsFilter original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Locator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Locator(string value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(object value);
    public sealed virtual void Apply(ICommandBuilder builder);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(EqualsFilter left, EqualsFilter right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(EqualsFilter left, EqualsFilter right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(EqualsFilter other);
    [CompilerGeneratedAttribute]
public virtual EqualsFilter <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Locator, Object& Value);
}
internal class Marten.Linq.SqlGeneration.Filters.ExcludeSoftDeletedFilter : object {
    [NullableAttribute("1")]
public static ExcludeSoftDeletedFilter Instance;
    [NullableAttribute("1")]
private static string _sql;
    private static ExcludeSoftDeletedFilter();
    [NullableContextAttribute("1")]
public sealed virtual void Apply(ICommandBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.Filters.FullTextWhereFragment : object {
    private string _dataConfig;
    private string _regConfig;
    private FullTextSearchFunction _searchFunction;
    private string _searchTerm;
    private string Sql { get; }
    public FullTextWhereFragment(DocumentMapping mapping, FullTextSearchFunction searchFunction, string searchTerm, string regConfig);
    private string get_Sql();
    public sealed virtual void Apply(ICommandBuilder builder);
    private static string GetDataConfig(DocumentMapping mapping, string regConfig);
}
[NullableContextAttribute("1")]
public interface Marten.Linq.SqlGeneration.Filters.ICollectionAware {
    public abstract virtual bool CanReduceInChildCollection();
    public abstract virtual ICollectionAwareFilter BuildFragment(ICollectionMember member, ISerializer serializer);
    public abstract virtual bool SupportsContainment();
    public abstract virtual void PlaceIntoContainmentFilter(ContainmentWhereFilter filter);
    public abstract virtual bool CanBeJsonPathFilter();
    public abstract virtual void BuildJsonPathFilter(ICommandBuilder builder, Dictionary`2<string, object> parameters);
    public abstract virtual IEnumerable`1<DictionaryValueUsage> Values();
}
[NullableContextAttribute("1")]
public interface Marten.Linq.SqlGeneration.Filters.ICollectionAwareFilter {
    public ICollectionMember CollectionMember { get; }
    public abstract virtual ICollectionMember get_CollectionMember();
    public abstract virtual ISqlFragment MoveUnder(ICollectionMember ancestorCollection);
}
[NullableContextAttribute("1")]
internal interface Marten.Linq.SqlGeneration.Filters.IDictionaryPart {
    public abstract virtual string Write();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.SqlGeneration.Filters.IsNotNullFilter : object {
    [CompilerGeneratedAttribute]
private IQueryableMember <Member>k__BackingField;
    public IQueryableMember Member { get; }
    public IsNotNullFilter(IQueryableMember member);
    [CompilerGeneratedAttribute]
public IQueryableMember get_Member();
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual ISqlFragment Reverse();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.SqlGeneration.Filters.IsNullFilter : object {
    [CompilerGeneratedAttribute]
private IQueryableMember <Member>k__BackingField;
    public IQueryableMember Member { get; }
    public IsNullFilter(IQueryableMember member);
    [CompilerGeneratedAttribute]
public IQueryableMember get_Member();
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual ISqlFragment Reverse();
}
internal interface Marten.Linq.SqlGeneration.Filters.ISoftDeletedFilter {
}
internal interface Marten.Linq.SqlGeneration.Filters.ISubQueryFilter {
    [NullableContextAttribute("1")]
public abstract virtual void PlaceUnnestAbove(IMartenSession session, SelectorStatement statement, ISqlFragment topLevelWhere);
}
public interface Marten.Linq.SqlGeneration.Filters.ITenantFilter {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.SqlGeneration.Filters.MemberComparisonFilter : ComparisonFilter {
    [CompilerGeneratedAttribute]
private IQueryableMember <Member>k__BackingField;
    public IQueryableMember Member { get; }
    public MemberComparisonFilter(IQueryableMember member, ISqlFragment right, string op);
    [CompilerGeneratedAttribute]
public IQueryableMember get_Member();
    public sealed virtual bool CanReduceInChildCollection();
    public sealed virtual ICollectionAwareFilter BuildFragment(ICollectionMember member, ISerializer serializer);
    public sealed virtual bool SupportsContainment();
    public sealed virtual void PlaceIntoContainmentFilter(ContainmentWhereFilter filter);
    public sealed virtual bool CanBeJsonPathFilter();
    public sealed virtual void BuildJsonPathFilter(ICommandBuilder builder, Dictionary`2<string, object> parameters);
    [IteratorStateMachineAttribute("Marten.Linq.SqlGeneration.Filters.MemberComparisonFilter/<Values>d__10")]
public sealed virtual IEnumerable`1<DictionaryValueUsage> Values();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.Filters.SpecificTenantFilter : object {
    private string _tenantId;
    public SpecificTenantFilter(string tenantId);
    public sealed virtual void Apply(ICommandBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.Filters.SubQueryFilter : object {
    [NullableAttribute("2")]
private string _exportName;
    [CompilerGeneratedAttribute]
private ICollectionMember <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private ISqlFragment <Inner>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Not>k__BackingField;
    public ICollectionMember Member { get; }
    public ISqlFragment Inner { get; }
    public bool Not { get; public set; }
    public SubQueryFilter(ICollectionMember member, ISqlFragment inner);
    [CompilerGeneratedAttribute]
public ICollectionMember get_Member();
    [CompilerGeneratedAttribute]
public ISqlFragment get_Inner();
    [CompilerGeneratedAttribute]
public bool get_Not();
    [CompilerGeneratedAttribute]
public void set_Not(bool value);
    public sealed virtual ISqlFragment Reverse();
    private sealed virtual override void Weasel.Postgresql.SqlGeneration.ISqlFragment.Apply(ICommandBuilder builder);
    public sealed virtual void PlaceUnnestAbove(IMartenSession session, SelectorStatement statement, ISqlFragment topLevelWhere);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.Filters.TenantIsOneOfFilter : object {
    private static string _filter;
    private String[] _values;
    public TenantIsOneOfFilter(String[] values);
    private static TenantIsOneOfFilter();
    public sealed virtual void Apply(ICommandBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.Filters.WriteSerializedJsonParameterFrame : SyncFrame {
    private string _parametersVariableName;
    private int _parameterIndex;
    private IDictionaryPart _declaration;
    public WriteSerializedJsonParameterFrame(string parametersVariableName, int parameterIndex, IDictionaryPart declaration);
    public virtual void GenerateCode(GeneratedMethod method, ISourceWriter writer);
}
internal class Marten.Linq.SqlGeneration.FilterStatement : SelectorStatement {
    [NullableContextAttribute("1")]
public FilterStatement(IMartenSession session, Statement parent, ISqlFragment where);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.FromFragment : object {
    private string _text;
    public FromFragment(DbObjectName name, string alias);
    public sealed virtual void Apply(ICommandBuilder builder);
}
internal class Marten.Linq.SqlGeneration.HardDelete : object {
    [NullableAttribute("1")]
private string _sql;
    [NullableContextAttribute("1")]
public HardDelete(IDocumentStorage storage);
    [NullableContextAttribute("1")]
public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual OperationRole Role();
}
public interface Marten.Linq.SqlGeneration.ICountClause {
    [NullableContextAttribute("1")]
public abstract virtual void OverrideFromObject(Statement parent);
}
[NullableContextAttribute("1")]
public interface Marten.Linq.SqlGeneration.IModifyableFromObject {
    public string FromObject { get; public set; }
    public abstract virtual string get_FromObject();
    public abstract virtual void set_FromObject(string value);
}
public interface Marten.Linq.SqlGeneration.IOperationFragment {
    public abstract virtual OperationRole Role();
}
[NullableContextAttribute("1")]
internal interface Marten.Linq.SqlGeneration.IScalarSelectClause {
    public string MemberName { get; }
    public abstract virtual string get_MemberName();
    public abstract virtual void ApplyOperator(string op);
    public abstract virtual ISelectClause CloneToDouble();
    public abstract virtual ISelectClause CloneToOtherTable(string tableName);
}
[NullableContextAttribute("1")]
public interface Marten.Linq.SqlGeneration.ISelectClause {
    public string FromObject { get; }
    public Type SelectedType { get; }
    public abstract virtual string get_FromObject();
    public abstract virtual Type get_SelectedType();
    public abstract virtual String[] SelectFields();
    public abstract virtual ISelector BuildSelector(IMartenSession session);
    public abstract virtual IQueryHandler`1<T> BuildHandler(IMartenSession session, ISqlFragment topStatement, ISqlFragment currentStatement);
    public abstract virtual ISelectClause UseStatistics(QueryStatistics statistics);
}
[NullableContextAttribute("1")]
internal interface Marten.Linq.SqlGeneration.IStatsSelectClause {
    public ISelectClause Inner { get; }
    public abstract virtual ISelectClause get_Inner();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.SqlGeneration.LiteralSql : object {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Text { get; public set; }
    public LiteralSql(string Text);
    [CompilerGeneratedAttribute]
protected LiteralSql(LiteralSql original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Text(string value);
    public sealed virtual void Apply(ICommandBuilder builder);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(LiteralSql left, LiteralSql right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(LiteralSql left, LiteralSql right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(LiteralSql other);
    [CompilerGeneratedAttribute]
public virtual LiteralSql <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.NewScalarSelectClause`1 : object {
    private static string NullResultMessage;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FromObject>k__BackingField;
    public string MemberName { get; private set; }
    public Type SelectedType { get; }
    public string FromObject { get; public set; }
    public NewScalarSelectClause`1(string locator, string from);
    public NewScalarSelectClause`1(IQueryableMember member, string from);
    private static NewScalarSelectClause`1();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MemberName();
    [CompilerGeneratedAttribute]
private void set_MemberName(string value);
    public sealed virtual ISelectClause CloneToOtherTable(string tableName);
    public sealed virtual void ApplyOperator(string op);
    public sealed virtual ISelectClause CloneToDouble();
    public sealed virtual Type get_SelectedType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FromObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FromObject(string value);
    public sealed virtual void Apply(ICommandBuilder sql);
    public sealed virtual String[] SelectFields();
    public sealed virtual ISelector BuildSelector(IMartenSession session);
    public sealed virtual IQueryHandler`1<TResult> BuildHandler(IMartenSession session, ISqlFragment statement, ISqlFragment currentStatement);
    public sealed virtual ISelectClause UseStatistics(QueryStatistics statistics);
    [AsyncStateMachineAttribute("Marten.Linq.SqlGeneration.NewScalarSelectClause`1/<Marten-Linq-Selectors-ISelector<T?>-ResolveAsync>d__21")]
private sealed virtual override Task`1<Nullable`1<T>> Marten.Linq.Selectors.ISelector<T?>.ResolveAsync(DbDataReader reader, CancellationToken token);
    [NullableContextAttribute("0")]
private sealed virtual override Nullable`1<T> Marten.Linq.Selectors.ISelector<T?>.Resolve(DbDataReader reader);
    [NullableContextAttribute("0")]
public sealed virtual T Resolve(DbDataReader reader);
    [AsyncStateMachineAttribute("Marten.Linq.SqlGeneration.NewScalarSelectClause`1/<ResolveAsync>d__24")]
public sealed virtual Task`1<T> ResolveAsync(DbDataReader reader, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.NewScalarStringSelectClause : object {
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FromObject>k__BackingField;
    public string MemberName { get; private set; }
    public Type SelectedType { get; }
    public string FromObject { get; public set; }
    public NewScalarStringSelectClause(string member, string from);
    public NewScalarStringSelectClause(IQueryableMember member, string from);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MemberName();
    [CompilerGeneratedAttribute]
private void set_MemberName(string value);
    public sealed virtual ISelectClause CloneToOtherTable(string tableName);
    public sealed virtual void ApplyOperator(string op);
    public sealed virtual ISelectClause CloneToDouble();
    public sealed virtual Type get_SelectedType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FromObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FromObject(string value);
    public sealed virtual void Apply(ICommandBuilder sql);
    public sealed virtual String[] SelectFields();
    public sealed virtual ISelector BuildSelector(IMartenSession session);
    public sealed virtual IQueryHandler`1<TResult> BuildHandler(IMartenSession session, ISqlFragment statement, ISqlFragment currentStatement);
    public sealed virtual ISelectClause UseStatistics(QueryStatistics statistics);
    public sealed virtual string Resolve(DbDataReader reader);
    [AsyncStateMachineAttribute("Marten.Linq.SqlGeneration.NewScalarStringSelectClause/<ResolveAsync>d__21")]
public sealed virtual Task`1<string> ResolveAsync(DbDataReader reader, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.SqlGeneration.OrderByFragment : object {
    [CompilerGeneratedAttribute]
private List`1<string> <Expressions>k__BackingField;
    public List`1<string> Expressions { get; }
    [CompilerGeneratedAttribute]
public List`1<string> get_Expressions();
    public sealed virtual void Apply(ICommandBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.ScalarSelectClause`1 : object {
    private static string NullResultMessage;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FromObject>k__BackingField;
    public string MemberName { get; private set; }
    public Type SelectedType { get; }
    public string FromObject { get; }
    public ScalarSelectClause`1(string locator, string from);
    public ScalarSelectClause`1(IQueryableMember field, string from);
    private static ScalarSelectClause`1();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MemberName();
    [CompilerGeneratedAttribute]
private void set_MemberName(string value);
    public sealed virtual ISelectClause CloneToOtherTable(string tableName);
    public sealed virtual void ApplyOperator(string op);
    public sealed virtual ISelectClause CloneToDouble();
    public sealed virtual Type get_SelectedType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FromObject();
    public sealed virtual void Apply(ICommandBuilder sql);
    public sealed virtual String[] SelectFields();
    public sealed virtual ISelector BuildSelector(IMartenSession session);
    public sealed virtual IQueryHandler`1<TResult> BuildHandler(IMartenSession session, ISqlFragment statement, ISqlFragment currentStatement);
    public sealed virtual ISelectClause UseStatistics(QueryStatistics statistics);
    [AsyncStateMachineAttribute("Marten.Linq.SqlGeneration.ScalarSelectClause`1/<Marten-Linq-Selectors-ISelector<T?>-ResolveAsync>d__20")]
private sealed virtual override Task`1<Nullable`1<T>> Marten.Linq.Selectors.ISelector<T?>.ResolveAsync(DbDataReader reader, CancellationToken token);
    [NullableContextAttribute("0")]
private sealed virtual override Nullable`1<T> Marten.Linq.Selectors.ISelector<T?>.Resolve(DbDataReader reader);
    [NullableContextAttribute("0")]
public sealed virtual T Resolve(DbDataReader reader);
    [AsyncStateMachineAttribute("Marten.Linq.SqlGeneration.ScalarSelectClause`1/<ResolveAsync>d__23")]
public sealed virtual Task`1<T> ResolveAsync(DbDataReader reader, CancellationToken token);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.ScalarStringSelectClause : object {
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FromObject>k__BackingField;
    public string MemberName { get; private set; }
    public Type SelectedType { get; }
    public string FromObject { get; }
    public ScalarStringSelectClause(string field, string from);
    public ScalarStringSelectClause(IQueryableMember field, string from);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MemberName();
    [CompilerGeneratedAttribute]
private void set_MemberName(string value);
    public sealed virtual ISelectClause CloneToOtherTable(string tableName);
    public sealed virtual void ApplyOperator(string op);
    public sealed virtual ISelectClause CloneToDouble();
    public sealed virtual Type get_SelectedType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FromObject();
    public sealed virtual void Apply(ICommandBuilder sql);
    public sealed virtual String[] SelectFields();
    public sealed virtual ISelector BuildSelector(IMartenSession session);
    public sealed virtual IQueryHandler`1<TResult> BuildHandler(IMartenSession session, ISqlFragment statement, ISqlFragment currentStatement);
    public sealed virtual ISelectClause UseStatistics(QueryStatistics statistics);
    public sealed virtual string Resolve(DbDataReader reader);
    [AsyncStateMachineAttribute("Marten.Linq.SqlGeneration.ScalarStringSelectClause/<ResolveAsync>d__20")]
public sealed virtual Task`1<string> ResolveAsync(DbDataReader reader, CancellationToken token);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.SelectCtidSelectClause : object {
    [CompilerGeneratedAttribute]
private string <FromObject>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SelectedType>k__BackingField;
    public string FromObject { get; }
    public Type SelectedType { get; }
    public SelectCtidSelectClause(Statement parent);
    public sealed virtual void Apply(ICommandBuilder builder);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FromObject();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_SelectedType();
    public sealed virtual String[] SelectFields();
    public sealed virtual ISelector BuildSelector(IMartenSession session);
    public sealed virtual IQueryHandler`1<T> BuildHandler(IMartenSession session, ISqlFragment topStatement, ISqlFragment currentStatement);
    public sealed virtual ISelectClause UseStatistics(QueryStatistics statistics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.SelectDataSelectClause`1 : object {
    [CompilerGeneratedAttribute]
private ISqlFragment <Selector>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FromObject>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Operator>k__BackingField;
    public ISqlFragment Selector { get; }
    public Type SelectedType { get; }
    public string FromObject { get; public set; }
    public string MemberName { get; }
    [NullableAttribute("2")]
public string Operator { get; public set; }
    public SelectDataSelectClause`1(string from, ISqlFragment selector);
    [CompilerGeneratedAttribute]
public ISqlFragment get_Selector();
    public sealed virtual Type get_SelectedType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FromObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FromObject(string value);
    public sealed virtual void Apply(ICommandBuilder sql);
    public sealed virtual String[] SelectFields();
    public sealed virtual ISelector BuildSelector(IMartenSession session);
    public sealed virtual IQueryHandler`1<TResult> BuildHandler(IMartenSession session, ISqlFragment statement, ISqlFragment currentStatement);
    public sealed virtual ISelectClause UseStatistics(QueryStatistics statistics);
    public virtual string ToString();
    public sealed virtual string get_MemberName();
    public sealed virtual void ApplyOperator(string op);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Operator();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Operator(string value);
    public sealed virtual ISelectClause CloneToDouble();
    public sealed virtual ISelectClause CloneToOtherTable(string tableName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Linq.SqlGeneration.SelectorStatement : Statement {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Limit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private OrderByFragment <Ordering>k__BackingField;
    [CompilerGeneratedAttribute]
private ISelectClause <SelectClause>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDistinct>k__BackingField;
    public Nullable`1<int> Limit { get; public set; }
    public Nullable`1<int> Offset { get; public set; }
    public OrderByFragment Ordering { get; internal set; }
    public ISelectClause SelectClause { get; internal set; }
    public string FromObject { get; }
    public bool IsDistinct { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Limit();
    [CompilerGeneratedAttribute]
public void set_Limit(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public OrderByFragment get_Ordering();
    [CompilerGeneratedAttribute]
internal void set_Ordering(OrderByFragment value);
    [CompilerGeneratedAttribute]
public ISelectClause get_SelectClause();
    [CompilerGeneratedAttribute]
internal void set_SelectClause(ISelectClause value);
    public virtual string get_FromObject();
    [CompilerGeneratedAttribute]
public bool get_IsDistinct();
    [CompilerGeneratedAttribute]
public void set_IsDistinct(bool value);
    public sealed virtual void Register(ISqlFragment fragment);
    protected virtual void configure(ICommandBuilder sql);
    public void ToAny();
    [NullableContextAttribute("2")]
public void ToCount();
    public void ApplyAggregateOperator(string databaseOperator);
    public void ApplySqlOperator(string databaseOperator);
    public IQueryHandler`1<TResult> BuildSingleResultHandler(IMartenSession session, Statement topStatement);
    public virtual string ToString();
    protected virtual void compileAnySubQueries(IMartenSession session);
}
internal class Marten.Linq.SqlGeneration.SoftDelete : object {
    [NullableAttribute("1")]
private string _sql;
    [NullableContextAttribute("1")]
public SoftDelete(IDocumentStorage storage);
    [NullableContextAttribute("1")]
public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual OperationRole Role();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Marten.Linq.SqlGeneration.Statement : object {
    [CompilerGeneratedAttribute]
private Statement <Next>k__BackingField;
    [CompilerGeneratedAttribute]
private Statement <Previous>k__BackingField;
    [CompilerGeneratedAttribute]
private StatementMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExportName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SingleValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnDefaultWhenEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanBeMultiples>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ISqlFragment> <Wheres>k__BackingField;
    public Statement Next { get; public set; }
    public Statement Previous { get; public set; }
    public StatementMode Mode { get; public set; }
    public string ExportName { get; protected internal set; }
    public bool SingleValue { get; public set; }
    public bool ReturnDefaultWhenEmpty { get; public set; }
    public bool CanBeMultiples { get; public set; }
    public List`1<ISqlFragment> Wheres { get; }
    [CompilerGeneratedAttribute]
public Statement get_Next();
    [CompilerGeneratedAttribute]
public void set_Next(Statement value);
    [CompilerGeneratedAttribute]
public Statement get_Previous();
    [CompilerGeneratedAttribute]
public void set_Previous(Statement value);
    [CompilerGeneratedAttribute]
public StatementMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(StatementMode value);
    [CompilerGeneratedAttribute]
public string get_ExportName();
    [CompilerGeneratedAttribute]
protected internal void set_ExportName(string value);
    [CompilerGeneratedAttribute]
public bool get_SingleValue();
    [CompilerGeneratedAttribute]
public void set_SingleValue(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReturnDefaultWhenEmpty();
    [CompilerGeneratedAttribute]
public void set_ReturnDefaultWhenEmpty(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanBeMultiples();
    [CompilerGeneratedAttribute]
public void set_CanBeMultiples(bool value);
    public sealed virtual void Apply(ICommandBuilder builder);
    public void InsertAfter(Statement descendent);
    public void AddToEnd(Statement descendent);
    public void InsertBefore(Statement antecedent);
    public Statement Top();
    public SelectorStatement SelectorStatement();
    public void ConvertToCommonTableExpression(IMartenSession session);
    protected abstract virtual void configure(ICommandBuilder sql);
    protected void startCommonTableExpression(ICommandBuilder sql);
    protected void endCommonTableExpression(ICommandBuilder sql, string suffix);
    public NpgsqlCommand BuildCommand(IMartenSession session);
    [CompilerGeneratedAttribute]
public List`1<ISqlFragment> get_Wheres();
    public ISqlFragment[] AllFilters();
    private ISqlFragment[] enumerateWheres(ISqlFragment where);
    private sealed virtual override void Weasel.Postgresql.SqlGeneration.IWhereFragmentHolder.Register(ISqlFragment filter);
    public void ParseWhereClause(IReadOnlyList`1<Expression> wheres, IMartenSession session, IQueryableMemberCollection collection, IDocumentStorage storage);
    protected virtual void compileAnySubQueries(IMartenSession session);
}
public enum Marten.Linq.SqlGeneration.StatementMode : Enum {
    public int value__;
    public static StatementMode Select;
    public static StatementMode CommonTableExpression;
    public static StatementMode Inner;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.StatementOperation : Statement {
    private IOperationFragment _operation;
    private IDocumentStorage _storage;
    [CompilerGeneratedAttribute]
private Type <DocumentType>k__BackingField;
    public Type DocumentType { get; }
    public StatementOperation(IDocumentStorage storage, IOperationFragment operation);
    public StatementOperation(IDocumentStorage storage, IOperationFragment operation, ISqlFragment where);
    public sealed virtual void ConfigureCommand(ICommandBuilder builder, IMartenSession session);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_DocumentType();
    public sealed virtual void Postprocess(DbDataReader reader, IList`1<Exception> exceptions);
    public sealed virtual Task PostprocessAsync(DbDataReader reader, IList`1<Exception> exceptions, CancellationToken token);
    public sealed virtual OperationRole Role();
    protected virtual void configure(ICommandBuilder sql);
    protected void writeWhereClause(ICommandBuilder sql);
    public ISqlFragment ApplyFiltering(DocumentSessionBase session, Expression`1<Func`2<T, bool>> expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Linq.SqlGeneration.StatsSelectClause`1 : object {
    private QueryStatistics _statistics;
    [CompilerGeneratedAttribute]
private ISelectClause <Inner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FromObject>k__BackingField;
    public ISelectClause Inner { get; }
    public Type SelectedType { get; }
    public string FromObject { get; public set; }
    public StatsSelectClause`1(ISelectClause inner, QueryStatistics statistics);
    [CompilerGeneratedAttribute]
public sealed virtual ISelectClause get_Inner();
    public sealed virtual Type get_SelectedType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FromObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FromObject(string value);
    public sealed virtual void Apply(ICommandBuilder sql);
    public sealed virtual String[] SelectFields();
    public sealed virtual ISelector BuildSelector(IMartenSession session);
    public sealed virtual IQueryHandler`1<TResult> BuildHandler(IMartenSession session, ISqlFragment topStatement, ISqlFragment currentStatement);
    public sealed virtual ISelectClause UseStatistics(QueryStatistics statistics);
}
internal class Marten.Linq.SqlGeneration.UnSoftDelete : object {
    [NullableAttribute("1")]
private string _sql;
    [NullableContextAttribute("1")]
public UnSoftDelete(IDocumentStorage storage);
    [NullableContextAttribute("1")]
public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual OperationRole Role();
}
public class Marten.Linq.SqlGeneration.ValueTypeSelectClause`2 : object {
    [CompilerGeneratedAttribute]
private Func`2<TInner, TOuter> <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FromObject>k__BackingField;
    public Func`2<TInner, TOuter> Converter { get; }
    public string MemberName { get; public set; }
    public Type SelectedType { get; }
    public string FromObject { get; public set; }
    public ValueTypeSelectClause`2(string memberName, Func`2<TInner, TOuter> converter);
    [CompilerGeneratedAttribute]
public Func`2<TInner, TOuter> get_Converter();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MemberName();
    [CompilerGeneratedAttribute]
public void set_MemberName(string value);
    public sealed virtual ISelectClause CloneToOtherTable(string tableName);
    public sealed virtual void ApplyOperator(string op);
    public sealed virtual ISelectClause CloneToDouble();
    public sealed virtual Type get_SelectedType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FromObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FromObject(string value);
    public sealed virtual void Apply(ICommandBuilder sql);
    public sealed virtual String[] SelectFields();
    public sealed virtual ISelector BuildSelector(IMartenSession session);
    public sealed virtual IQueryHandler`1<TResult> BuildHandler(IMartenSession session, ISqlFragment statement, ISqlFragment currentStatement);
    public sealed virtual ISelectClause UseStatistics(QueryStatistics statistics);
    public sealed virtual TOuter Resolve(DbDataReader reader);
    [AsyncStateMachineAttribute("Marten.Linq.SqlGeneration.ValueTypeSelectClause`2/<Marten-Linq-Selectors-ISelector<TOuter?>-ResolveAsync>d__23")]
private sealed virtual override Task`1<Nullable`1<TOuter>> Marten.Linq.Selectors.ISelector<TOuter?>.ResolveAsync(DbDataReader reader, CancellationToken token);
    private sealed virtual override Nullable`1<TOuter> Marten.Linq.Selectors.ISelector<TOuter?>.Resolve(DbDataReader reader);
    [AsyncStateMachineAttribute("Marten.Linq.SqlGeneration.ValueTypeSelectClause`2/<ResolveAsync>d__25")]
public sealed virtual Task`1<TOuter> ResolveAsync(DbDataReader reader, CancellationToken token);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Marten.Linq.SqlGeneration.WhereFragmentExtensions : object {
    [ExtensionAttribute]
public static bool SpecifiesTenant(ISqlFragment fragment);
    [ExtensionAttribute]
public static bool TryFindTenantAwareFilter(ISqlFragment fragment, ITenantFilter& tenantFilter);
    [ExtensionAttribute]
public static bool SpecifiesEventArchivalStatus(ISqlFragment query);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Marten.LinqExtensions : object {
    [ExtensionAttribute]
public static bool IsOneOf(T variable, T[] matches);
    [ExtensionAttribute]
public static bool IsOneOf(T variable, IList`1<T> matches);
    [ExtensionAttribute]
public static bool In(T variable, T[] matches);
    [ExtensionAttribute]
public static bool In(T variable, IList`1<T> matches);
    [ExtensionAttribute]
public static bool IsSupersetOf(IEnumerable`1<T> enumerable, T[] items);
    [ExtensionAttribute]
public static bool IsSubsetOf(IEnumerable`1<T> enumerable, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static bool IsSubsetOf(IEnumerable`1<T> enumerable, T[] items);
    [ExtensionAttribute]
public static bool IsSupersetOf(IEnumerable`1<T> enumerable, IEnumerable`1<T> items);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEmpty(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static bool AnyTenant(T variable);
    [ExtensionAttribute]
public static bool TenantIsOneOf(T variable, String[] tenantIds);
    [ExtensionAttribute]
public static bool Search(T variable, string searchTerm);
    [ExtensionAttribute]
public static bool Search(T variable, string searchTerm, string regConfig);
    [ExtensionAttribute]
public static bool PlainTextSearch(T variable, string searchTerm);
    [ExtensionAttribute]
public static bool PlainTextSearch(T variable, string searchTerm, string regConfig);
    [ExtensionAttribute]
public static bool PhraseSearch(T variable, string searchTerm);
    [ExtensionAttribute]
public static bool PhraseSearch(T variable, string searchTerm, string regConfig);
    [ExtensionAttribute]
public static bool WebStyleSearch(T variable, string searchTerm);
    [ExtensionAttribute]
public static bool WebStyleSearch(T variable, string searchTerm, string regConfig);
    [ExtensionAttribute]
public static bool NgramSearch(T variable, string searchTerm);
}
public class Marten.LinqParsing : object {
    private static IList`1<IMethodCallParser> _parsers;
    private StoreOptions _options;
    public IList`1<IMethodCallParser> MethodCallParsers;
    private ImHashMap`2<Module, ImHashMap`2<int, IMethodCallParser>> _methodParsersByModule;
    [CompilerGeneratedAttribute]
private IList`1<IMemberSource> <MemberSources>k__BackingField;
    private List`1<IMemberSource> _defaultSources;
    public IList`1<IMemberSource> MemberSources { get; }
    private IReadOnlyList`1<IMemberSource> Marten.IReadOnlyLinqParsing.FieldSources { get; }
    private IReadOnlyList`1<IMethodCallParser> Marten.IReadOnlyLinqParsing.MethodCallParsers { get; }
    internal LinqParsing(StoreOptions options);
    private static LinqParsing();
    [CompilerGeneratedAttribute]
public IList`1<IMemberSource> get_MemberSources();
    private sealed virtual override IReadOnlyList`1<IMemberSource> Marten.IReadOnlyLinqParsing.get_FieldSources();
    [IteratorStateMachineAttribute("Marten.LinqParsing/<allMemberSources>d__11")]
internal IEnumerable`1<IMemberSource> allMemberSources();
    private sealed virtual override IReadOnlyList`1<IMethodCallParser> Marten.IReadOnlyLinqParsing.get_MethodCallParsers();
    internal IMethodCallParser FindMethodParser(MethodCallExpression expression);
    private IMethodCallParser determineMethodParser(MethodCallExpression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.MappedType : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    public Type Type { get; public set; }
    [NullableAttribute("2")]
public string Alias { get; public set; }
    public MappedType(Type type, string alias);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Alias();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Alias(string value);
    public static MappedType op_Implicit(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.MartenRegistry : object {
    private StoreOptions _storeOptions;
    internal MartenRegistry(StoreOptions storeOptions);
    [NullableContextAttribute("0")]
public void Include();
    public void Include(MartenRegistry registry);
    public DocumentMappingExpression`1<T> For();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Marten.MartenServiceCollectionExtensions : object {
    [ExtensionAttribute]
public static IServiceCollection ConfigureMartenWithServices(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection ConfigureMarten(IServiceCollection services, Action`1<StoreOptions> configure);
    [ExtensionAttribute]
public static IServiceCollection ConfigureMarten(IServiceCollection services, Action`2<IServiceProvider, StoreOptions> configure);
    [ExtensionAttribute]
public static IServiceCollection ConfigureMarten(IServiceCollection services, Action`2<IServiceProvider, StoreOptions> configure);
    [ExtensionAttribute]
public static IServiceCollection ConfigureMarten(IServiceCollection services, Action`1<StoreOptions> configure);
    [ExtensionAttribute]
public static MartenConfigurationExpression AddMarten(IServiceCollection services);
    [ExtensionAttribute]
public static MartenConfigurationExpression AddMarten(IServiceCollection services, string connectionString);
    [ExtensionAttribute]
public static MartenConfigurationExpression AddMarten(IServiceCollection services, StoreOptions options);
    [ExtensionAttribute]
public static MartenConfigurationExpression AddMarten(IServiceCollection services, Func`2<IServiceProvider, StoreOptions> optionSource);
    [ExtensionAttribute]
public static MartenConfigurationExpression AddMarten(IServiceCollection services, Action`1<StoreOptions> configure);
    [ExtensionAttribute]
public static MartenStoreExpression`1<T> AddMartenStore(IServiceCollection services, Action`1<StoreOptions> configure);
    [ExtensionAttribute]
public static MartenStoreExpression`1<T> AddMartenStore(IServiceCollection services, Func`2<IServiceProvider, StoreOptions> configure);
    [ExtensionAttribute]
internal static IReadOnlyList`1<IDocumentStore> AllDocumentStores(IHost host);
    [ExtensionAttribute]
public static IReadOnlyList`1<IDocumentStore> AllDocumentStores(IServiceProvider services);
    [ExtensionAttribute]
internal static void EnsureAsyncConfigureMartenApplicationIsRegistered(IServiceCollection services);
    [ExtensionAttribute]
internal static void EnsureMartenActivatorIsRegistered(IServiceCollection services);
    [ExtensionAttribute]
internal static void EnsureMartenActivatorIsRegistered(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection InitializeMartenWith(IServiceCollection services, IInitialData[] data);
    [ExtensionAttribute]
public static IServiceCollection InitializeMartenWith(IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection InitializeMartenWith(IServiceCollection services, IInitialData[] data);
    [ExtensionAttribute]
public static IServiceCollection InitializeMartenWith(IServiceCollection services);
}
[ExtensionAttribute]
public static class Marten.MasterTableMultiTenancyExtensions : object {
    [ExtensionAttribute]
public static Task ClearAllTenantDatabaseRecordsAsync(IHost host);
    [ExtensionAttribute]
public static Task AddTenantDatabaseAsync(IHost host, string tenantId, string connectionString);
}
public interface Marten.Metadata.IRevisioned {
    public int Version { get; public set; }
    public abstract virtual int get_Version();
    public abstract virtual void set_Version(int value);
}
public interface Marten.Metadata.ISoftDeleted {
    public bool Deleted { get; public set; }
    public Nullable`1<DateTimeOffset> DeletedAt { get; public set; }
    public abstract virtual bool get_Deleted();
    public abstract virtual void set_Deleted(bool value);
    public abstract virtual Nullable`1<DateTimeOffset> get_DeletedAt();
    public abstract virtual void set_DeletedAt(Nullable`1<DateTimeOffset> value);
}
[NullableContextAttribute("1")]
public interface Marten.Metadata.ITenanted {
    public string TenantId { get; public set; }
    public abstract virtual string get_TenantId();
    public abstract virtual void set_TenantId(string value);
}
[NullableContextAttribute("1")]
public interface Marten.Metadata.ITracked {
    public string CorrelationId { get; public set; }
    public string CausationId { get; public set; }
    public string LastModifiedBy { get; public set; }
    public abstract virtual string get_CorrelationId();
    public abstract virtual void set_CorrelationId(string value);
    public abstract virtual string get_CausationId();
    public abstract virtual void set_CausationId(string value);
    public abstract virtual string get_LastModifiedBy();
    public abstract virtual void set_LastModifiedBy(string value);
}
public interface Marten.Metadata.IVersioned {
    public Guid Version { get; public set; }
    public abstract virtual Guid get_Version();
    public abstract virtual void set_Version(Guid value);
}
internal class Marten.Metadata.SoftDeletedPolicy : object {
    [NullableContextAttribute("1")]
public sealed virtual void Apply(DocumentMapping mapping);
}
internal class Marten.Metadata.TenancyPolicy : object {
    [NullableContextAttribute("1")]
public sealed virtual void Apply(DocumentMapping mapping);
}
internal class Marten.Metadata.TrackedPolicy : object {
    [NullableContextAttribute("1")]
public sealed virtual void Apply(DocumentMapping mapping);
}
internal class Marten.Metadata.VersionedPolicy : object {
    [NullableContextAttribute("1")]
public sealed virtual void Apply(DocumentMapping mapping);
}
public class Marten.MultiHostSettings : object {
    [CompilerGeneratedAttribute]
private TargetSessionAttributes <ReadSessionPreference>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetSessionAttributes <WriteSessionPreference>k__BackingField;
    public TargetSessionAttributes ReadSessionPreference { get; public set; }
    public TargetSessionAttributes WriteSessionPreference { get; public set; }
    [CompilerGeneratedAttribute]
public TargetSessionAttributes get_ReadSessionPreference();
    [CompilerGeneratedAttribute]
public void set_ReadSessionPreference(TargetSessionAttributes value);
    [CompilerGeneratedAttribute]
public TargetSessionAttributes get_WriteSessionPreference();
    [CompilerGeneratedAttribute]
public void set_WriteSessionPreference(TargetSessionAttributes value);
}
[FlagsAttribute]
public enum Marten.NonPublicMembersStorage : Enum {
    public int value__;
    public static NonPublicMembersStorage Default;
    public static NonPublicMembersStorage NonPublicSetters;
    public static NonPublicMembersStorage NonPublicDefaultConstructor;
    public static NonPublicMembersStorage NonPublicConstructor;
    public static NonPublicMembersStorage All;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.NullChangeListener : object {
    [CompilerGeneratedAttribute]
private static IChangeListener <Instance>k__BackingField;
    public static IChangeListener Instance { get; }
    private static NullChangeListener();
    [CompilerGeneratedAttribute]
public static IChangeListener get_Instance();
    public sealed virtual Task AfterCommitAsync(IDocumentSession session, IChangeSet commit, CancellationToken token);
    public sealed virtual Task BeforeCommitAsync(IDocumentSession session, IChangeSet commit, CancellationToken token);
}
internal class Marten.NulloLogger : object {
    public sealed virtual void Dispose();
    public sealed virtual void Log(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func`3<TState, Exception, string> formatter);
    public sealed virtual bool IsEnabled(LogLevel logLevel);
    public sealed virtual IDisposable BeginScope(TState state);
}
internal class Marten.NulloMartenLogger : DefaultMartenLogger {
    [CompilerGeneratedAttribute]
private static IMartenSessionLogger <Flyweight>k__BackingField;
    public static IMartenSessionLogger Flyweight { get; }
    private static NulloMartenLogger();
    [CompilerGeneratedAttribute]
public static IMartenSessionLogger get_Flyweight();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.OptimizedArtifactsWorkflow : object {
    private string _developmentEnvironment;
    private TypeLoadMode _productionMode;
    public OptimizedArtifactsWorkflow(TypeLoadMode productionMode);
    public OptimizedArtifactsWorkflow(TypeLoadMode productionMode, string developmentEnvironment);
    public sealed virtual void Configure(IServiceProvider services, StoreOptions options);
}
internal class Marten.OptimizedArtifactsWorkflow`1 : OptimizedArtifactsWorkflow {
    public OptimizedArtifactsWorkflow`1(TypeLoadMode productionMode);
    [NullableContextAttribute("1")]
public OptimizedArtifactsWorkflow`1(TypeLoadMode productionMode, string developmentEnvironment);
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface Marten.Pagination.IPagedList`1 {
    public T Item { get; }
    public long Count { get; }
    public long PageNumber { get; }
    public long PageSize { get; }
    public long PageCount { get; }
    public long TotalItemCount { get; }
    public bool HasPreviousPage { get; }
    public bool HasNextPage { get; }
    public bool IsFirstPage { get; }
    public bool IsLastPage { get; }
    public long FirstItemOnPage { get; }
    public long LastItemOnPage { get; }
    public abstract virtual T get_Item(int index);
    public abstract virtual long get_Count();
    public abstract virtual long get_PageNumber();
    public abstract virtual long get_PageSize();
    public abstract virtual long get_PageCount();
    public abstract virtual long get_TotalItemCount();
    public abstract virtual bool get_HasPreviousPage();
    public abstract virtual bool get_HasNextPage();
    public abstract virtual bool get_IsFirstPage();
    public abstract virtual bool get_IsLastPage();
    public abstract virtual long get_FirstItemOnPage();
    public abstract virtual long get_LastItemOnPage();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Marten.Pagination.PagedList`1 : object {
    private List`1<T> _items;
    [CompilerGeneratedAttribute]
private long <PageNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PageCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalItemCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasPreviousPage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasNextPage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFirstPage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastPage>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FirstItemOnPage>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LastItemOnPage>k__BackingField;
    public T Item { get; }
    public long Count { get; }
    public long PageNumber { get; protected set; }
    public long PageSize { get; protected set; }
    public long PageCount { get; protected set; }
    public long TotalItemCount { get; protected set; }
    public bool HasPreviousPage { get; protected set; }
    public bool HasNextPage { get; protected set; }
    public bool IsFirstPage { get; protected set; }
    public bool IsLastPage { get; protected set; }
    public long FirstItemOnPage { get; protected set; }
    public long LastItemOnPage { get; protected set; }
    public sealed virtual T get_Item(int index);
    public sealed virtual long get_Count();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual long get_PageNumber();
    [CompilerGeneratedAttribute]
protected void set_PageNumber(long value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_PageSize();
    [CompilerGeneratedAttribute]
protected void set_PageSize(long value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_PageCount();
    [CompilerGeneratedAttribute]
protected void set_PageCount(long value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_TotalItemCount();
    [CompilerGeneratedAttribute]
protected void set_TotalItemCount(long value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasPreviousPage();
    [CompilerGeneratedAttribute]
protected void set_HasPreviousPage(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasNextPage();
    [CompilerGeneratedAttribute]
protected void set_HasNextPage(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsFirstPage();
    [CompilerGeneratedAttribute]
protected void set_IsFirstPage(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsLastPage();
    [CompilerGeneratedAttribute]
protected void set_IsLastPage(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_FirstItemOnPage();
    [CompilerGeneratedAttribute]
protected void set_FirstItemOnPage(long value);
    [CompilerGeneratedAttribute]
public sealed virtual long get_LastItemOnPage();
    [CompilerGeneratedAttribute]
protected void set_LastItemOnPage(long value);
    public static PagedList`1<T> Create(IQueryable`1<T> queryable, int pageNumber, int pageSize);
    [AsyncStateMachineAttribute("Marten.Pagination.PagedList`1/<CreateAsync>d__49")]
public static Task`1<PagedList`1<T>> CreateAsync(IQueryable`1<T> queryable, int pageNumber, int pageSize, CancellationToken token);
    public void Init(IQueryable`1<T> queryable, int pageNumber, int pageSize);
    [AsyncStateMachineAttribute("Marten.Pagination.PagedList`1/<InitAsync>d__51")]
public Task InitAsync(IQueryable`1<T> queryable, int pageNumber, int pageSize, CancellationToken token);
    private IQueryable`1<T> PrepareQuery(IQueryable`1<T> queryable, int pageNumber, int pageSize, QueryStatistics& statistics);
    private void ProcessResults(int pageSize, IReadOnlyList`1<T> items, QueryStatistics statistics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Marten.Pagination.PagedListQueryableExtensions : object {
    [ExtensionAttribute]
public static IPagedList`1<T> ToPagedList(IQueryable`1<T> queryable, int pageNumber, int pageSize);
    [AsyncStateMachineAttribute("Marten.Pagination.PagedListQueryableExtensions/<ToPagedListAsync>d__1`1")]
[ExtensionAttribute]
public static Task`1<IPagedList`1<T>> ToPagedListAsync(IQueryable`1<T> queryable, int pageNumber, int pageSize, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.PartitioningExpression : object {
    private DocumentMapping _mapping;
    private String[] _columnNames;
    public PartitioningExpression(DocumentMapping mapping, String[] columnNames);
    public HashPartitioning ByHash(String[] suffixes);
    public void ByExternallyManagedListPartitions();
    public ListPartitioning ByList();
    public void ByExternallyManagedRangePartitions();
    public RangePartitioning ByRange();
}
[NullableContextAttribute("1")]
public interface Marten.Patching.IPatchExpression`1 {
    public abstract virtual IPatchExpression`1<T> Set(string name, TValue value);
    public abstract virtual IPatchExpression`1<T> Set(string name, Expression`1<Func`2<T, TParent>> expression, TValue value);
    public abstract virtual IPatchExpression`1<T> Set(Expression`1<Func`2<T, TValue>> expression, TValue value);
    public abstract virtual IPatchExpression`1<T> Duplicate(Expression`1<Func`2<T, TElement>> expression, Expression`1[] destinations);
    public abstract virtual IPatchExpression`1<T> Increment(Expression`1<Func`2<T, int>> expression, int increment);
    public abstract virtual IPatchExpression`1<T> Increment(Expression`1<Func`2<T, long>> expression, long increment);
    public abstract virtual IPatchExpression`1<T> Increment(Expression`1<Func`2<T, double>> expression, double increment);
    public abstract virtual IPatchExpression`1<T> Increment(Expression`1<Func`2<T, float>> expression, float increment);
    public abstract virtual IPatchExpression`1<T> Append(Expression`1<Func`2<T, IEnumerable`1<TElement>>> expression, TElement element);
    public abstract virtual IPatchExpression`1<T> AppendIfNotExists(Expression`1<Func`2<T, IEnumerable`1<TElement>>> expression, TElement element);
    public abstract virtual IPatchExpression`1<T> Insert(Expression`1<Func`2<T, IEnumerable`1<TElement>>> expression, TElement element, Nullable`1<int> index);
    public abstract virtual IPatchExpression`1<T> InsertIfNotExists(Expression`1<Func`2<T, IEnumerable`1<TElement>>> expression, TElement element, Nullable`1<int> index);
    public abstract virtual IPatchExpression`1<T> Remove(Expression`1<Func`2<T, IEnumerable`1<TElement>>> expression, TElement element, RemoveAction action);
    public abstract virtual IPatchExpression`1<T> Rename(string oldName, Expression`1<Func`2<T, object>> expression);
    public abstract virtual IPatchExpression`1<T> Delete(string name);
    public abstract virtual IPatchExpression`1<T> Delete(string name, Expression`1<Func`2<T, TParent>> expression);
    public abstract virtual IPatchExpression`1<T> Delete(Expression`1<Func`2<T, TElement>> expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Patching.PatchData : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PossiblyPolymorphic>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public IDictionary`2<string, object> Items { get; public set; }
    public bool PossiblyPolymorphic { get; public set; }
    public PatchData(IDictionary`2<string, object> Items, bool PossiblyPolymorphic);
    [CompilerGeneratedAttribute]
protected PatchData(PatchData original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Items();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Items(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public bool get_PossiblyPolymorphic();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PossiblyPolymorphic(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(PatchData left, PatchData right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(PatchData left, PatchData right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(PatchData other);
    [CompilerGeneratedAttribute]
public virtual PatchData <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(IDictionary`2& Items, Boolean& PossiblyPolymorphic);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Patching.PatchExpression`1 : object {
    private DocumentSessionBase _session;
    private List`1<PatchData> _patchSet;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IDictionary`2<string, object> Patch { get; }
    private DbObjectName PatchFunction { get; }
    public PatchExpression`1(ISqlFragment filter, DocumentSessionBase session);
    public PatchExpression`1(Expression`1<Func`2<T, bool>> filterExpression, DocumentSessionBase session);
    internal IDictionary`2<string, object> get_Patch();
    public sealed virtual IPatchExpression`1<T> Set(string name, TValue value);
    public sealed virtual IPatchExpression`1<T> Set(string name, Expression`1<Func`2<T, TParent>> expression, TValue value);
    public sealed virtual IPatchExpression`1<T> Set(Expression`1<Func`2<T, TValue>> expression, TValue value);
    public sealed virtual IPatchExpression`1<T> Duplicate(Expression`1<Func`2<T, TElement>> expression, Expression`1[] destinations);
    public sealed virtual IPatchExpression`1<T> Increment(Expression`1<Func`2<T, int>> expression, int increment);
    public sealed virtual IPatchExpression`1<T> Increment(Expression`1<Func`2<T, long>> expression, long increment);
    public sealed virtual IPatchExpression`1<T> Increment(Expression`1<Func`2<T, double>> expression, double increment);
    public sealed virtual IPatchExpression`1<T> Increment(Expression`1<Func`2<T, float>> expression, float increment);
    public sealed virtual IPatchExpression`1<T> Append(Expression`1<Func`2<T, IEnumerable`1<TElement>>> expression, TElement element);
    public sealed virtual IPatchExpression`1<T> AppendIfNotExists(Expression`1<Func`2<T, IEnumerable`1<TElement>>> expression, TElement element);
    public sealed virtual IPatchExpression`1<T> Insert(Expression`1<Func`2<T, IEnumerable`1<TElement>>> expression, TElement element, Nullable`1<int> index);
    public sealed virtual IPatchExpression`1<T> InsertIfNotExists(Expression`1<Func`2<T, IEnumerable`1<TElement>>> expression, TElement element, Nullable`1<int> index);
    public sealed virtual IPatchExpression`1<T> Remove(Expression`1<Func`2<T, IEnumerable`1<TElement>>> expression, TElement element, RemoveAction action);
    public sealed virtual IPatchExpression`1<T> Rename(string oldName, Expression`1<Func`2<T, object>> expression);
    public sealed virtual IPatchExpression`1<T> Delete(string name);
    public sealed virtual IPatchExpression`1<T> Delete(string name, Expression`1<Func`2<T, TParent>> expression);
    public sealed virtual IPatchExpression`1<T> Delete(Expression`1<Func`2<T, TElement>> expression);
    private IPatchExpression`1<T> set(string path, TValue value);
    private IPatchExpression`1<T> delete(string path);
    private string toPath(Expression expression);
    private DbObjectName get_PatchFunction();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private string <toPath>b__25_0(MemberInfo x);
}
internal class Marten.Patching.PatchFragment : object {
    private static string VALUE_LOOKUP;
    private ISerializer _serializer;
    private IDocumentStorage _storage;
    private DbObjectName _function;
    private DocumentSessionBase _session;
    private List`1<PatchData> _patchSet;
    public PatchFragment(DocumentSessionBase session, List`1<PatchData> patchSet, ISerializer serializer, DbObjectName function, IDocumentStorage storage);
    public sealed virtual void Apply(ICommandBuilder builder);
    public sealed virtual OperationRole Role();
}
[ExtensionAttribute]
public static class Marten.Patching.PatchingExtensions : object {
    private static IPatchExpression`1<T> patchById(IDocumentOperations operations, object id);
    [ExtensionAttribute]
public static IPatchExpression`1<T> Patch(IDocumentOperations operations, int id);
    [ExtensionAttribute]
public static IPatchExpression`1<T> Patch(IDocumentOperations operations, long id);
    [ExtensionAttribute]
public static IPatchExpression`1<T> Patch(IDocumentOperations operations, string id);
    [ExtensionAttribute]
public static IPatchExpression`1<T> Patch(IDocumentOperations operations, Guid id);
    [ExtensionAttribute]
public static IPatchExpression`1<T> Patch(IDocumentOperations operations, Expression`1<Func`2<T, bool>> filter);
    [ExtensionAttribute]
public static IPatchExpression`1<T> Patch(IDocumentOperations operations, ISqlFragment fragment);
}
internal class Marten.Patching.PatchOperation : StatementOperation {
    private ISqlFragment _fragment;
    private IDocumentStorage _storage;
    private List`1<PatchData> _patchSet;
    public PatchOperation(DocumentSessionBase session, DbObjectName function, IDocumentStorage storage, List`1<PatchData> patchSet, ISerializer serializer);
    public OperationRole Role();
    protected virtual void configure(ICommandBuilder builder);
    private void applyUpdates(ICommandBuilder builder);
}
public enum Marten.Patching.RemoveAction : Enum {
    public int value__;
    public static RemoveAction RemoveFirst;
    public static RemoveAction RemoveAll;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Marten.QueryableExtensions : object {
    internal static MethodInfo OrderByFieldNameAndComparerMethod;
    private static MethodInfo _orderBySqlMethod;
    private static MethodInfo _thenBySqlMethod;
    internal static MethodInfo IncludePlanMethod;
    private static QueryableExtensions();
    [ExtensionAttribute]
public static QueryPlan Explain(IQueryable`1<T> queryable, Action`1<IConfigureExplainExpressions> configureExplain);
    [ExtensionAttribute]
public static Task`1<IReadOnlyList`1<T>> ToListAsync(IQueryable`1<T> queryable, CancellationToken token);
    [ExtensionAttribute]
public static NpgsqlCommand ToCommand(IQueryable`1<T> queryable, FetchType fetchType);
    [ExtensionAttribute]
public static IMartenQueryable`1<T> Include(IQueryable`1<T> queryable, Expression`1<Func`2<T, object>> idSource, Action`1<TInclude> callback);
    [ExtensionAttribute]
public static IMartenQueryable`1<T> Include(IQueryable`1<T> queryable, Expression`1<Func`2<T, object>> idSource, IList`1<TInclude> list);
    [ExtensionAttribute]
public static IMartenQueryable`1<T> Include(IQueryable`1<T> queryable, Expression`1<Func`2<T, object>> idSource, IDictionary`2<TKey, TInclude> dictionary);
    [ExtensionAttribute]
public static IMartenQueryableIncludeBuilder`2<T, TInclude> Include(IQueryable`1<T> queryable, Action`1<TInclude> callback);
    [ExtensionAttribute]
public static IMartenQueryableIncludeBuilder`2<T, TInclude> Include(IQueryable`1<T> queryable, IList`1<TInclude> list);
    [ExtensionAttribute]
public static IMartenQueryableIncludeBuilder`3<T, TKey, TInclude> Include(IQueryable`1<T> queryable, IDictionary`2<TKey, TInclude> dictionary);
    [ExtensionAttribute]
public static IMartenQueryableIncludeBuilder`3<T, TKey, TInclude> Include(IQueryable`1<T> queryable, IDictionary`2<TKey, IList`1<TInclude>> dictionary);
    [ExtensionAttribute]
public static IMartenQueryableIncludeBuilder`3<T, TKey, TInclude> Include(IQueryable`1<T> queryable, IDictionary`2<TKey, List`1<TInclude>> dictionary);
    [ExtensionAttribute]
public static IAsyncEnumerable`1<T> ToAsyncEnumerable(IQueryable`1<T> queryable, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<int> StreamJsonArray(IQueryable`1<T> queryable, Stream destination, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<string> ToJsonArray(IQueryable`1<T> queryable, CancellationToken token);
    [ExtensionAttribute]
public static Task StreamJsonFirst(IQueryable`1<T> queryable, Stream destination, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.QueryableExtensions/<StreamJsonFirstOrDefault>d__15`1")]
[ExtensionAttribute]
public static Task`1<bool> StreamJsonFirstOrDefault(IQueryable`1<T> queryable, Stream destination, CancellationToken token);
    [ExtensionAttribute]
public static Task StreamJsonSingle(IQueryable`1<T> queryable, Stream destination, CancellationToken token);
    [ExtensionAttribute]
public static Task StreamJsonSingleOrDefault(IQueryable`1<T> queryable, Stream destination, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<string> ToJsonFirst(IQueryable`1<T> queryable, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<string> ToJsonFirstOrDefault(IQueryable`1<T> queryable, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<string> ToJsonSingle(IQueryable`1<T> queryable, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<string> ToJsonSingleOrDefault(IQueryable`1<T> queryable, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<bool> AnyAsync(IQueryable`1<TSource> source, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<bool> AnyAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<TResult> SumAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> expression, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<TResult> MaxAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> expression, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<TResult> MinAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TResult>> expression, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<double> AverageAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, TMember>> expression, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<int> CountAsync(IQueryable`1<TSource> source, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<int> CountAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<long> LongCountAsync(IQueryable`1<TSource> source, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<long> LongCountAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<TSource> FirstAsync(IQueryable`1<TSource> source, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<TSource> FirstAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<TSource> FirstOrDefaultAsync(IQueryable`1<TSource> source, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<TSource> FirstOrDefaultAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<TSource> SingleAsync(IQueryable`1<TSource> source, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<TSource> SingleAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<TSource> SingleOrDefaultAsync(IQueryable`1<TSource> source, CancellationToken token);
    [ExtensionAttribute]
public static Task`1<TSource> SingleOrDefaultAsync(IQueryable`1<TSource> source, Expression`1<Func`2<TSource, bool>> predicate, CancellationToken token);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderBy(IQueryable`1<T> queryable, String[] properties);
    [ExtensionAttribute]
public static IBatchedOrderedQueryable`1<T> OrderBy(IBatchedQueryable`1<T> queryable, String[] properties);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderBy(IQueryable`1<T> queryable, string property);
    internal static void GetSortProperty(String& property, String& sortOrder);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderBy(IQueryable`1<T> queryable, string property, StringComparer comparer);
    [ExtensionAttribute]
public static IBatchedOrderedQueryable`1<T> OrderBy(IBatchedQueryable`1<T> queryable, string property);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> OrderByDescending(IQueryable`1<T> queryable, string property);
    [ExtensionAttribute]
public static IBatchedOrderedQueryable`1<T> OrderByDescending(IBatchedQueryable`1<T> queryable, string property);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> ThenBy(IOrderedQueryable`1<T> queryable, string property);
    [ExtensionAttribute]
public static IBatchedOrderedQueryable`1<T> ThenBy(IBatchedOrderedQueryable`1<T> queryable, string property);
    [ExtensionAttribute]
public static IOrderedQueryable`1<T> ThenByDescending(IOrderedQueryable`1<T> queryable, string property);
    [ExtensionAttribute]
public static IBatchedOrderedQueryable`1<T> ThenByDescending(IBatchedOrderedQueryable`1<T> queryable, string property);
    private static IOrderedQueryable`1<T> ApplyOrder(IQueryable`1<T> queryable, string property, string methodName);
    private static IBatchedOrderedQueryable`1<T> ApplyOrder(IBatchedQueryable`1<T> queryable, string property, string methodName);
    internal static LambdaExpression CompileOrderBy(string property, Type& targetType);
    [ExtensionAttribute]
public static IQueryable`1<T> OrderBySql(IQueryable`1<T> queryable, string sql);
    [ExtensionAttribute]
public static IQueryable`1<T> ThenBySql(IQueryable`1<T> queryable, string sql);
    [ExtensionAttribute]
public static IMartenQueryable`1<T> Stats(IQueryable`1<T> queryable, QueryStatistics& stats);
    [ExtensionAttribute]
internal static IMartenQueryable`1<T> IncludePlan(IQueryable`1<T> queryable, IIncludePlan include);
    [ExtensionAttribute]
public static T ExplicitSql(object target, string sql);
}
public abstract class Marten.QueryListPlan`1 : object {
    public abstract virtual IQueryable`1<T> Query(IQuerySession session);
    private sealed virtual override Task`1<IReadOnlyList`1<T>> Marten.IQueryPlan<System.Collections.Generic.IReadOnlyList<T>>.Fetch(IQuerySession session, CancellationToken token);
    private sealed virtual override Task`1<IReadOnlyList`1<T>> Marten.IBatchQueryPlan<System.Collections.Generic.IReadOnlyList<T>>.Fetch(IBatchedQuery query);
}
[ExtensionAttribute]
public static class Marten.QuerySessionExtensions : object {
    private static MethodInfo QueryMethod;
    private static MethodInfo QueryMethodAsync;
    private static Ref`1<ImHashMap`2<Type, MethodInfo>> QueryMethods;
    private static Ref`1<ImHashMap`2<Type, MethodInfo>> QueryAsyncMethods;
    private static QuerySessionExtensions();
    [ExtensionAttribute]
public static IReadOnlyList`1<object> Query(IQuerySession session, Type type, string sql, Object[] parameters);
    private static MethodInfo QueryFor(Type type);
    [AsyncStateMachineAttribute("Marten.QuerySessionExtensions/<QueryAsync>d__6")]
[ExtensionAttribute]
public static Task`1<IReadOnlyList`1<object>> QueryAsync(IQuerySession session, Type type, string sql, CancellationToken token, Object[] parameters);
    private static MethodInfo QueryAsyncFor(Type type);
}
internal class Marten.Schema.Arguments.CurrentVersionArgument : UpsertArgument {
    public virtual void GenerateCodeToSetDbParameterValue(GeneratedMethod method, GeneratedType type, int i, Argument parameters, DocumentMapping mapping, StoreOptions options);
}
internal class Marten.Schema.Arguments.DocJsonBodyArgument : UpsertArgument {
    public virtual void GenerateBulkWriterCode(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
    public virtual void GenerateBulkWriterCodeAsync(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
    public virtual void GenerateCodeToSetDbParameterValue(GeneratedMethod method, GeneratedType type, int i, Argument parameters, DocumentMapping mapping, StoreOptions options);
}
internal class Marten.Schema.Arguments.DocTypeArgument : UpsertArgument {
    private static MethodInfo _getAlias;
    private static MethodInfo _getType;
    private static DocTypeArgument();
    public virtual void GenerateCodeToModifyDocument(GeneratedMethod method, GeneratedType type, int i, Argument parameters, DocumentMapping mapping, StoreOptions options);
    public virtual void GenerateCodeToSetDbParameterValue(GeneratedMethod method, GeneratedType type, int i, Argument parameters, DocumentMapping mapping, StoreOptions options);
    public virtual void GenerateBulkWriterCode(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
    public virtual void GenerateBulkWriterCodeAsync(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
}
internal class Marten.Schema.Arguments.DotNetTypeArgument : UpsertArgument {
    private static MethodInfo _getType;
    private static MethodInfo _fullName;
    private static DotNetTypeArgument();
    public virtual void GenerateCodeToSetDbParameterValue(GeneratedMethod method, GeneratedType type, int i, Argument parameters, DocumentMapping mapping, StoreOptions options);
    public virtual void GenerateBulkWriterCode(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
    public virtual void GenerateBulkWriterCodeAsync(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
}
internal class Marten.Schema.Arguments.RevisionArgument : UpsertArgument {
    public virtual void GenerateCodeToSetDbParameterValue(GeneratedMethod method, GeneratedType type, int i, Argument parameters, DocumentMapping mapping, StoreOptions options);
    public virtual void GenerateBulkWriterCode(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
    public virtual void GenerateBulkWriterCodeAsync(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
}
public class Marten.Schema.Arguments.TenantIdArgument : UpsertArgument {
    public static string ArgName;
    private static string TenantIdFieldName;
    public virtual void GenerateCodeToModifyDocument(GeneratedMethod method, GeneratedType type, int i, Argument parameters, DocumentMapping mapping, StoreOptions options);
    public virtual void GenerateCodeToSetDbParameterValue(GeneratedMethod method, GeneratedType type, int i, Argument parameters, DocumentMapping mapping, StoreOptions options);
    public virtual void GenerateBulkWriterCode(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
    public virtual void GenerateBulkWriterCodeAsync(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
}
public class Marten.Schema.Arguments.UpsertArgument : object {
    protected static MethodInfo writeMethod;
    private MemberInfo[] _members;
    private string _postgresType;
    [CompilerGeneratedAttribute]
private string <Arg>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DotNetType>k__BackingField;
    [CompilerGeneratedAttribute]
private NpgsqlDbType <DbType>k__BackingField;
    public string Arg { get; public set; }
    public string PostgresType { get; public set; }
    public string Column { get; public set; }
    public MemberInfo[] Members { get; public set; }
    public string ParameterValue { get; public set; }
    public Type DotNetType { get; private set; }
    public NpgsqlDbType DbType { get; public set; }
    private static UpsertArgument();
    [CompilerGeneratedAttribute]
public string get_Arg();
    [CompilerGeneratedAttribute]
public void set_Arg(string value);
    public string get_PostgresType();
    public void set_PostgresType(string value);
    [CompilerGeneratedAttribute]
public string get_Column();
    [CompilerGeneratedAttribute]
public void set_Column(string value);
    public MemberInfo[] get_Members();
    public void set_Members(MemberInfo[] value);
    [CompilerGeneratedAttribute]
public string get_ParameterValue();
    [CompilerGeneratedAttribute]
public void set_ParameterValue(string value);
    [CompilerGeneratedAttribute]
public Type get_DotNetType();
    [CompilerGeneratedAttribute]
private void set_DotNetType(Type value);
    [CompilerGeneratedAttribute]
public NpgsqlDbType get_DbType();
    [CompilerGeneratedAttribute]
public void set_DbType(NpgsqlDbType value);
    public string ArgumentDeclaration();
    public virtual void GenerateCodeToModifyDocument(GeneratedMethod method, GeneratedType type, int i, Argument parameters, DocumentMapping mapping, StoreOptions options);
    public virtual void GenerateCodeToSetDbParameterValue(GeneratedMethod method, GeneratedType type, int i, Argument parameters, DocumentMapping mapping, StoreOptions options);
    private void writeEnumerationValues(GeneratedMethod method, int i, Argument parameters, StoreOptions options, string memberPath);
    public virtual void GenerateBulkWriterCode(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
    public virtual void GenerateBulkWriterCodeAsync(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
}
internal class Marten.Schema.Arguments.VersionArgument : UpsertArgument {
    public static string ArgName;
    private static MethodInfo _newGuid;
    private static VersionArgument();
    public virtual void GenerateCodeToModifyDocument(GeneratedMethod method, GeneratedType type, int i, Argument parameters, DocumentMapping mapping, StoreOptions options);
    public virtual void GenerateCodeToSetDbParameterValue(GeneratedMethod method, GeneratedType type, int i, Argument parameters, DocumentMapping mapping, StoreOptions options);
    public virtual void GenerateBulkWriterCode(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
    public virtual void GenerateBulkWriterCodeAsync(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
}
public interface Marten.Schema.BulkLoading.IBulkLoader`1 {
    public abstract virtual void Load(Tenant tenant, ISerializer serializer, NpgsqlConnection conn, IEnumerable`1<T> documents);
    public abstract virtual Task LoadAsync(Tenant tenant, ISerializer serializer, NpgsqlConnection conn, IEnumerable`1<T> documents, CancellationToken cancellation);
    public abstract virtual string CreateTempTableForCopying();
    public abstract virtual void LoadIntoTempTable(Tenant tenant, ISerializer serializer, NpgsqlConnection conn, IEnumerable`1<T> documents);
    public abstract virtual Task LoadIntoTempTableAsync(Tenant tenant, ISerializer serializer, NpgsqlConnection conn, IEnumerable`1<T> documents, CancellationToken cancellation);
    public abstract virtual string CopyNewDocumentsFromTempTable();
    public abstract virtual string OverwriteDuplicatesFromTempTable();
}
public class Marten.Schema.ColumnValue : object {
    [CompilerGeneratedAttribute]
private string <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FunctionValue>k__BackingField;
    public string Column { get; }
    public string FunctionValue { get; }
    public ColumnValue(string column, string functionValue);
    [CompilerGeneratedAttribute]
public string get_Column();
    [CompilerGeneratedAttribute]
public string get_FunctionValue();
}
public class Marten.Schema.ComputedIndex : IndexDefinition {
    private DocumentMapping _mapping;
    private MemberInfo[][] _members;
    [CompilerGeneratedAttribute]
private Casings <Casing>k__BackingField;
    [CompilerGeneratedAttribute]
private TenancyScope <TenancyScope>k__BackingField;
    public Casings Casing { get; public set; }
    public TenancyScope TenancyScope { get; public set; }
    public String[] Columns { get; public set; }
    public ComputedIndex(DocumentMapping mapping, MemberInfo[] memberPath);
    public ComputedIndex(DocumentMapping mapping, MemberInfo[][] members);
    [CompilerGeneratedAttribute]
public Casings get_Casing();
    [CompilerGeneratedAttribute]
public void set_Casing(Casings value);
    [CompilerGeneratedAttribute]
public TenancyScope get_TenancyScope();
    [CompilerGeneratedAttribute]
public void set_TenancyScope(TenancyScope value);
    public virtual String[] get_Columns();
    public virtual void set_Columns(String[] value);
    protected virtual string deriveIndexName();
    [IteratorStateMachineAttribute("Marten.Schema.ComputedIndex/<buildColumns>d__17")]
private IEnumerable`1<string> buildColumns();
}
[AttributeUsageAttribute("384")]
public class Marten.Schema.CreatedAtMetadataAttribute : MartenAttribute {
    [NullableContextAttribute("1")]
public virtual void Modify(DocumentMapping mapping, MemberInfo member);
}
public class Marten.Schema.DatabaseGenerator : object {
    private Dictionary`2<string, TenantDatabaseCreationExpressions> _configurationPerTenant;
    private string _maintenanceDbConnectionString;
    public sealed virtual IDatabaseCreationExpressions MaintenanceDatabase(string maintenanceDbConnectionString);
    public sealed virtual ITenantDatabaseCreationExpressions ForTenant(string tenantId);
    [AsyncStateMachineAttribute("Marten.Schema.DatabaseGenerator/<CreateDatabasesAsync>d__4")]
public Task CreateDatabasesAsync(ITenancy tenancy, Action`1<IDatabaseCreationExpressions> configure, CancellationToken ct);
    [AsyncStateMachineAttribute("Marten.Schema.DatabaseGenerator/<createDbAsync>d__5")]
private Task createDbAsync(Tenant tenant, TenantDatabaseCreationExpressions config, CancellationToken ct);
    [AsyncStateMachineAttribute("Marten.Schema.DatabaseGenerator/<IsNotInPgDatabase>d__6")]
private Task`1<bool> IsNotInPgDatabase(string catalog, string maintenanceDb, CancellationToken ct);
    [AsyncStateMachineAttribute("Marten.Schema.DatabaseGenerator/<cannotConnectDueToInvalidCatalog>d__7")]
private static Task`1<bool> cannotConnectDueToInvalidCatalog(NpgsqlConnection t, CancellationToken ct);
    [AsyncStateMachineAttribute("Marten.Schema.DatabaseGenerator/<CreateDbAsync>d__8")]
private Task CreateDbAsync(string catalog, TenantDatabaseCreationExpressions config, bool dropExisting, string maintenanceDb, CancellationToken ct);
    [AsyncStateMachineAttribute("Marten.Schema.DatabaseGenerator/<dropCurrentDatabaseAsync>d__9")]
private static Task dropCurrentDatabaseAsync(string catalog, TenantDatabaseCreationExpressions config, string maintenanceDb, CancellationToken ct);
}
[AttributeUsageAttribute("4")]
public class Marten.Schema.DatabaseSchemaNameAttribute : MartenDocumentAttribute {
    private string _name;
    public DatabaseSchemaNameAttribute(string name);
    public virtual void Modify(DocumentMapping mapping);
}
[AttributeUsageAttribute("4")]
public class Marten.Schema.DdlTemplateAttribute : MartenAttribute {
    private string _templateName;
    public DdlTemplateAttribute(string templateName);
    public virtual void Modify(DocumentMapping mapping);
}
public enum Marten.Schema.DeleteStyle : Enum {
    public int value__;
    public static DeleteStyle Remove;
    public static DeleteStyle SoftDelete;
}
[AttributeUsageAttribute("4")]
public class Marten.Schema.DocumentAliasAttribute : MartenDocumentAttribute {
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    public string Alias { get; }
    public DocumentAliasAttribute(string alias);
    [CompilerGeneratedAttribute]
public string get_Alias();
    public virtual void Modify(DocumentMapping mapping);
}
public class Marten.Schema.DocumentCodeGen : object {
    [CompilerGeneratedAttribute]
private string <AccessId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterValue>k__BackingField;
    public string AccessId { get; }
    public string ParameterValue { get; }
    public DocumentCodeGen(DocumentMapping mapping);
    [CompilerGeneratedAttribute]
public string get_AccessId();
    [CompilerGeneratedAttribute]
public string get_ParameterValue();
}
public class Marten.Schema.DocumentForeignKey : ForeignKey {
    [CompilerGeneratedAttribute]
private Type <ReferenceDocumentType>k__BackingField;
    public Type ReferenceDocumentType { get; }
    public DocumentForeignKey(string columnName, DocumentMapping parent, DocumentMapping reference);
    [CompilerGeneratedAttribute]
public Type get_ReferenceDocumentType();
    private static string toKeyName(DocumentMapping parent, DocumentMapping reference, string columnName);
}
public class Marten.Schema.DocumentIndex : IndexDefinition {
    private String[] _columns;
    private DocumentMapping _parent;
    [CompilerGeneratedAttribute]
private TenancyScope <TenancyScope>k__BackingField;
    public TenancyScope TenancyScope { get; public set; }
    public String[] Columns { get; public set; }
    public DocumentIndex(DocumentMapping parent, String[] columns);
    [CompilerGeneratedAttribute]
public TenancyScope get_TenancyScope();
    [CompilerGeneratedAttribute]
public void set_TenancyScope(TenancyScope value);
    public virtual String[] get_Columns();
    public virtual void set_Columns(String[] value);
    public virtual string ToString();
    protected virtual string deriveIndexName();
}
public class Marten.Schema.DocumentMapping : object {
    private static Regex _aliasSanitizer;
    internal static Type[] ValidIdTypes;
    private List`1<DuplicatedField> _duplicates;
    private Lazy`1<DocumentSchema> _schema;
    private string _alias;
    private string _databaseSchemaName;
    private HiloSettings _hiloSettings;
    private MemberInfo _idMember;
    [CompilerGeneratedAttribute]
private PrimaryKeyTenancyOrdering <PrimaryKeyTenancyOrdering>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisablePartitioningIfAny>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IPartitionStrategy <Partitioning>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DocumentCodeGen <CodeGen>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentQueryableMemberCollection <QueryMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <IgnoredIndexes>k__BackingField;
    [CompilerGeneratedAttribute]
private StoreOptions <StoreOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseVersionFromMatchingStream>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipSchemaGeneration>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DocumentType>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentMetadataCollection <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseOptimisticConcurrency>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseNumericRevisions>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<IndexDefinition> <Indexes>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ForeignKey> <ForeignKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private SubClasses <SubClasses>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertySearching <PropertySearching>k__BackingField;
    [CompilerGeneratedAttribute]
private DeleteStyle <DeleteStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private IIdGeneration <IdStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StructuralTyped>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DdlTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyHiloSettings <Marten.Schema.IDocumentType.HiloSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private TenancyStyle <TenancyStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnorePartitions>k__BackingField;
    public PrimaryKeyTenancyOrdering PrimaryKeyTenancyOrdering { get; public set; }
    public bool DisablePartitioningIfAny { get; public set; }
    [NullableAttribute("2")]
public IPartitionStrategy Partitioning { get; public set; }
    [NullableAttribute("2")]
public DocumentCodeGen CodeGen { get; private set; }
    internal DocumentQueryableMemberCollection QueryMembers { get; }
    public IList`1<string> IgnoredIndexes { get; }
    internal StoreOptions StoreOptions { get; }
    internal DocumentSchema Schema { get; }
    public bool UseVersionFromMatchingStream { get; public set; }
    public HiloSettings HiloSettings { get; public set; }
    internal bool SkipSchemaGeneration { get; internal set; }
    public MemberInfo IdMember { get; public set; }
    public Type IdType { get; }
    private IDocumentMapping Marten.Schema.IDocumentMapping.Root { get; }
    public Type DocumentType { get; }
    public DbObjectName TableName { get; }
    public DocumentMetadataCollection Metadata { get; }
    public bool UseOptimisticConcurrency { get; public set; }
    public bool UseNumericRevisions { get; public set; }
    public IList`1<IndexDefinition> Indexes { get; }
    public IList`1<ForeignKey> ForeignKeys { get; }
    public SubClasses SubClasses { get; }
    public DbObjectName UpsertFunction { get; }
    public DbObjectName InsertFunction { get; }
    public DbObjectName UpdateFunction { get; }
    public DbObjectName OverwriteFunction { get; }
    public string DatabaseSchemaName { get; public set; }
    public EnumStorage EnumStorage { get; }
    public Casing Casing { get; }
    public string Alias { get; public set; }
    public PropertySearching PropertySearching { get; public set; }
    public DeleteStyle DeleteStyle { get; public set; }
    public IIdGeneration IdStrategy { get; public set; }
    public bool StructuralTyped { get; public set; }
    public string DdlTemplate { get; public set; }
    private IReadOnlyHiloSettings Marten.Schema.IDocumentType.HiloSettings { get; }
    public TenancyStyle TenancyStyle { get; public set; }
    private IDocumentType Marten.Schema.IDocumentType.Root { get; }
    public IReadOnlyList`1<DuplicatedField> DuplicatedFields { get; }
    public bool IgnorePartitions { get; public set; }
    public DocumentMapping(Type documentType, StoreOptions storeOptions);
    private static DocumentMapping();
    internal static bool IsValidIdentityType(Type identityType);
    [CompilerGeneratedAttribute]
public PrimaryKeyTenancyOrdering get_PrimaryKeyTenancyOrdering();
    [CompilerGeneratedAttribute]
public void set_PrimaryKeyTenancyOrdering(PrimaryKeyTenancyOrdering value);
    [CompilerGeneratedAttribute]
public bool get_DisablePartitioningIfAny();
    [CompilerGeneratedAttribute]
public void set_DisablePartitioningIfAny(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IPartitionStrategy get_Partitioning();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Partitioning(IPartitionStrategy value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public DocumentCodeGen get_CodeGen();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_CodeGen(DocumentCodeGen value);
    [CompilerGeneratedAttribute]
internal DocumentQueryableMemberCollection get_QueryMembers();
    [CompilerGeneratedAttribute]
public IList`1<string> get_IgnoredIndexes();
    [CompilerGeneratedAttribute]
internal StoreOptions get_StoreOptions();
    internal DocumentSchema get_Schema();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseVersionFromMatchingStream();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UseVersionFromMatchingStream(bool value);
    public HiloSettings get_HiloSettings();
    public void set_HiloSettings(HiloSettings value);
    [CompilerGeneratedAttribute]
internal bool get_SkipSchemaGeneration();
    [CompilerGeneratedAttribute]
internal void set_SkipSchemaGeneration(bool value);
    public sealed virtual MemberInfo get_IdMember();
    public void set_IdMember(MemberInfo value);
    public sealed virtual Type get_IdType();
    private sealed virtual override IDocumentMapping Marten.Schema.IDocumentMapping.get_Root();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_DocumentType();
    public virtual DbObjectName get_TableName();
    [CompilerGeneratedAttribute]
public sealed virtual DocumentMetadataCollection get_Metadata();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseOptimisticConcurrency();
    [CompilerGeneratedAttribute]
public void set_UseOptimisticConcurrency(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseNumericRevisions();
    [CompilerGeneratedAttribute]
public void set_UseNumericRevisions(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<IndexDefinition> get_Indexes();
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<ForeignKey> get_ForeignKeys();
    [CompilerGeneratedAttribute]
public sealed virtual SubClasses get_SubClasses();
    public sealed virtual DbObjectName get_UpsertFunction();
    public sealed virtual DbObjectName get_InsertFunction();
    public sealed virtual DbObjectName get_UpdateFunction();
    public sealed virtual DbObjectName get_OverwriteFunction();
    public sealed virtual string get_DatabaseSchemaName();
    public sealed virtual void set_DatabaseSchemaName(string value);
    public sealed virtual EnumStorage get_EnumStorage();
    public sealed virtual Casing get_Casing();
    public sealed virtual string get_Alias();
    public sealed virtual void set_Alias(string value);
    [CompilerGeneratedAttribute]
public sealed virtual PropertySearching get_PropertySearching();
    [CompilerGeneratedAttribute]
public void set_PropertySearching(PropertySearching value);
    [CompilerGeneratedAttribute]
public sealed virtual DeleteStyle get_DeleteStyle();
    [CompilerGeneratedAttribute]
public void set_DeleteStyle(DeleteStyle value);
    [CompilerGeneratedAttribute]
public sealed virtual IIdGeneration get_IdStrategy();
    [CompilerGeneratedAttribute]
public void set_IdStrategy(IIdGeneration value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_StructuralTyped();
    [CompilerGeneratedAttribute]
public void set_StructuralTyped(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_DdlTemplate();
    [CompilerGeneratedAttribute]
public void set_DdlTemplate(string value);
    [CompilerGeneratedAttribute]
private sealed virtual override IReadOnlyHiloSettings Marten.Schema.IDocumentType.get_HiloSettings();
    [CompilerGeneratedAttribute]
public sealed virtual TenancyStyle get_TenancyStyle();
    [CompilerGeneratedAttribute]
public void set_TenancyStyle(TenancyStyle value);
    private sealed virtual override IDocumentType Marten.Schema.IDocumentType.get_Root();
    public sealed virtual IReadOnlyList`1<DuplicatedField> get_DuplicatedFields();
    [CompilerGeneratedAttribute]
public bool get_IgnorePartitions();
    [CompilerGeneratedAttribute]
public void set_IgnorePartitions(bool value);
    public sealed virtual bool IsHierarchy();
    public sealed virtual IEnumerable`1<DocumentIndex> IndexesFor(string column);
    public sealed virtual string AliasFor(Type subclassType);
    public sealed virtual Type TypeFor(string alias);
    public void IgnoreIndex(string indexName);
    private void applyAnyMartenAttributes(Type documentType);
    public IEnumerable`1<Type> ReferencedTypes();
    public static DocumentMapping`1<T> For(string databaseSchemaName);
    public static MemberInfo FindIdMember(Type documentType);
    private static PropertyInfo[] GetProperties(Type type);
    public DocumentIndex AddGinIndexToData();
    public DocumentIndex AddLastModifiedIndex(Action`1<DocumentIndex> configure);
    public DocumentIndex AddCreatedAtIndex(Action`1<DocumentIndex> configure);
    public DocumentIndex AddDeletedAtIndex(Action`1<DocumentIndex> configure);
    public DocumentIndex AddIndex(String[] columns);
    public IndexDefinition AddUniqueIndex(MemberInfo[][] members, UniqueIndexType indexType, string indexName, IndexMethod indexMethod, TenancyScope tenancyScope);
    public FullTextIndexDefinition AddFullTextIndex(string regConfig, Action`1<FullTextIndexDefinition> configure);
    public FullTextIndexDefinition AddFullTextIndex(MemberInfo[][] members, string regConfig, string indexName);
    private FullTextIndexDefinition AddFullTextIndexIfDoesNotExist(FullTextIndexDefinition index);
    public NgramIndex AddNgramIndex(Action`1<NgramIndex> configure);
    public NgramIndex AddNgramIndex(MemberInfo[] members, string indexName);
    private NgramIndex AddNgramIndexIfDoesNotExist(NgramIndex index);
    public DocumentForeignKey AddForeignKey(string memberName, Type referenceType);
    public DocumentForeignKey AddForeignKey(MemberInfo[] members, Type referenceType);
    private static string defaultDocumentAliasName(Type documentType);
    public DuplicatedField DuplicateField(string memberName, string pgType, bool notNull);
    public DuplicatedField DuplicateField(MemberInfo[] members, string pgType, string columnName, bool notNull);
    internal void CompileAndValidate();
    public virtual string ToString();
    internal Type InnerIdType();
    internal void PartitionByDeleted();
    [CompilerGeneratedAttribute]
private DocumentSchema <.ctor>b__9_0();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <applyAnyMartenAttributes>b__138_0(MartenAttribute att);
    [CompilerGeneratedAttribute]
private void <applyAnyMartenAttributes>b__138_2(PropertyInfo prop);
    [CompilerGeneratedAttribute]
private void <applyAnyMartenAttributes>b__138_4(FieldInfo fieldInfo);
    [CompilerGeneratedAttribute]
private void <applyAnyMartenAttributes>b__138_6(PropertyInfo prop);
    [CompilerGeneratedAttribute]
private void <applyAnyMartenAttributes>b__138_8(FieldInfo fieldInfo);
    [CompilerGeneratedAttribute]
private bool <ReferencedTypes>b__139_1(Type x);
    [CompilerGeneratedAttribute]
private DuplicatedField <AddUniqueIndex>b__148_0(MemberInfo[] memberPath);
}
public class Marten.Schema.DocumentMapping`1 : DocumentMapping {
    public DocumentMapping`1(StoreOptions storeOptions);
    public void Duplicate(Expression`1<Func`2<T, object>> expression, string pgType, Nullable`1<NpgsqlDbType> dbType, Action`1<DocumentIndex> configure, bool notNull);
    public void Index(Expression`1<Func`2<T, object>> expression, Action`1<ComputedIndex> configure);
    public void Index(IReadOnlyCollection`1<Expression`1<Func`2<T, object>>> expressions, Action`1<ComputedIndex> configure);
    public void UniqueIndex(UniqueIndexType indexType, string indexName, Expression`1[] expressions);
    public void UniqueIndex(UniqueIndexType indexType, string indexName, TenancyScope tenancyScope, Expression`1[] expressions);
    public FullTextIndexDefinition FullTextIndex(string regConfig, Expression`1[] expressions);
    public NgramIndex NgramIndex(Expression`1<Func`2<T, object>> expression);
    public NgramIndex NgramIndex(Action`1<NgramIndex> configure, Expression`1<Func`2<T, object>> expression);
}
public class Marten.Schema.DocumentMetadataCollection : object {
    [CompilerGeneratedAttribute]
private MetadataColumn <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataColumn <Revision>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataColumn <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataColumn <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataColumn <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataColumn <IsSoftDeleted>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataColumn <SoftDeletedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataColumn <DocumentType>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataColumn <DotNetType>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataColumn <CausationId>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataColumn <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataColumn <LastModifiedBy>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataColumn <Headers>k__BackingField;
    public MetadataColumn Version { get; }
    public MetadataColumn Revision { get; }
    public MetadataColumn LastModified { get; }
    public MetadataColumn CreatedAt { get; }
    public MetadataColumn TenantId { get; }
    public MetadataColumn IsSoftDeleted { get; }
    public MetadataColumn SoftDeletedAt { get; }
    public MetadataColumn DocumentType { get; }
    public MetadataColumn DotNetType { get; }
    public MetadataColumn CausationId { get; }
    public MetadataColumn CorrelationId { get; }
    public MetadataColumn LastModifiedBy { get; }
    public MetadataColumn Headers { get; }
    public DocumentMetadataCollection(DocumentMapping parent);
    [CompilerGeneratedAttribute]
public MetadataColumn get_Version();
    [CompilerGeneratedAttribute]
public MetadataColumn get_Revision();
    [CompilerGeneratedAttribute]
public MetadataColumn get_LastModified();
    [CompilerGeneratedAttribute]
public MetadataColumn get_CreatedAt();
    [CompilerGeneratedAttribute]
public MetadataColumn get_TenantId();
    [CompilerGeneratedAttribute]
public MetadataColumn get_IsSoftDeleted();
    [CompilerGeneratedAttribute]
public MetadataColumn get_SoftDeletedAt();
    [CompilerGeneratedAttribute]
public MetadataColumn get_DocumentType();
    [CompilerGeneratedAttribute]
public MetadataColumn get_DotNetType();
    [CompilerGeneratedAttribute]
public MetadataColumn get_CausationId();
    [CompilerGeneratedAttribute]
public MetadataColumn get_CorrelationId();
    [CompilerGeneratedAttribute]
public MetadataColumn get_LastModifiedBy();
    [CompilerGeneratedAttribute]
public MetadataColumn get_Headers();
}
internal class Marten.Schema.DocumentSchema : object {
    private DocumentMapping _mapping;
    [CompilerGeneratedAttribute]
private OverwriteFunction <Overwrite>k__BackingField;
    [CompilerGeneratedAttribute]
private UpdateFunction <Update>k__BackingField;
    [CompilerGeneratedAttribute]
private InsertFunction <Insert>k__BackingField;
    [CompilerGeneratedAttribute]
private UpsertFunction <Upsert>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentTable <Table>k__BackingField;
    public OverwriteFunction Overwrite { get; }
    public UpdateFunction Update { get; }
    public InsertFunction Insert { get; }
    public UpsertFunction Upsert { get; }
    public DocumentTable Table { get; }
    public ISchemaObject[] Objects { get; }
    public Type StorageType { get; }
    public string Identifier { get; }
    public Migrator Migrator { get; }
    public DocumentSchema(DocumentMapping mapping);
    [CompilerGeneratedAttribute]
public OverwriteFunction get_Overwrite();
    [CompilerGeneratedAttribute]
public UpdateFunction get_Update();
    [CompilerGeneratedAttribute]
public InsertFunction get_Insert();
    [CompilerGeneratedAttribute]
public UpsertFunction get_Upsert();
    [CompilerGeneratedAttribute]
public DocumentTable get_Table();
    [IteratorStateMachineAttribute("Marten.Schema.DocumentSchema/<DependentTypes>d__17")]
public sealed virtual IEnumerable`1<Type> DependentTypes();
    public sealed virtual ISchemaObject[] get_Objects();
    public sealed virtual Type get_StorageType();
    public sealed virtual string get_Identifier();
    public sealed virtual Migrator get_Migrator();
    public sealed virtual void WritePermissions(Migrator rules, TextWriter writer);
    public bool IsActive(StoreOptions options);
    [IteratorStateMachineAttribute("Marten.Schema.DocumentSchema/<toSchemaObjects>d__28")]
private IEnumerable`1<ISchemaObject> toSchemaObjects();
}
[AttributeUsageAttribute("384")]
public class Marten.Schema.DocumentTypeMetadataAttribute : MartenAttribute {
    [NullableContextAttribute("1")]
public virtual void Modify(DocumentMapping mapping, MemberInfo member);
}
[AttributeUsageAttribute("4")]
public class Marten.Schema.DoNotPartitionAttribute : MartenAttribute {
    [NullableContextAttribute("1")]
public virtual void Modify(DocumentMapping mapping);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("384")]
public class Marten.Schema.DuplicateFieldAttribute : MartenAttribute {
    [CompilerGeneratedAttribute]
private string <PgType>k__BackingField;
    [CompilerGeneratedAttribute]
private NpgsqlDbType <DbType>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexMethod <IndexMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    [CompilerGeneratedAttribute]
private SortOrder <IndexSortOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NotNull>k__BackingField;
    public string PgType { get; public set; }
    public NpgsqlDbType DbType { get; public set; }
    public IndexMethod IndexMethod { get; public set; }
    public string IndexName { get; public set; }
    public SortOrder IndexSortOrder { get; public set; }
    public bool NotNull { get; public set; }
    [CompilerGeneratedAttribute]
public string get_PgType();
    [CompilerGeneratedAttribute]
public void set_PgType(string value);
    [CompilerGeneratedAttribute]
public NpgsqlDbType get_DbType();
    [CompilerGeneratedAttribute]
public void set_DbType(NpgsqlDbType value);
    [CompilerGeneratedAttribute]
public IndexMethod get_IndexMethod();
    [CompilerGeneratedAttribute]
public void set_IndexMethod(IndexMethod value);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    [CompilerGeneratedAttribute]
public SortOrder get_IndexSortOrder();
    [CompilerGeneratedAttribute]
public void set_IndexSortOrder(SortOrder value);
    [CompilerGeneratedAttribute]
public bool get_NotNull();
    [CompilerGeneratedAttribute]
public void set_NotNull(bool value);
    [NullableContextAttribute("1")]
public virtual void Modify(DocumentMapping mapping, MemberInfo member);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("384")]
public class Marten.Schema.ForeignKeyAttribute : MartenAttribute {
    private Type _referenceType;
    public ForeignKeyAttribute(Type referenceType);
    public virtual void Modify(DocumentMapping mapping, MemberInfo member);
}
public class Marten.Schema.ForeignKeyConstraint : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TableName>k__BackingField;
    public string Name { get; }
    public string Schema { get; }
    public string TableName { get; }
    public ForeignKeyConstraint(string name, string schema, string tableName);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Schema();
    [CompilerGeneratedAttribute]
public string get_TableName();
    public virtual string ToString();
}
[AttributeUsageAttribute("388")]
public class Marten.Schema.FullTextIndexAttribute : MartenAttribute {
    public string RegConfig;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    public string IndexName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    public virtual void Modify(DocumentMapping mapping);
    public virtual void Modify(DocumentMapping mapping, MemberInfo member);
    [CompilerGeneratedAttribute]
private void <Modify>b__5_0(FullTextIndexDefinition index);
}
[AttributeUsageAttribute("4")]
public class Marten.Schema.GinIndexedAttribute : MartenAttribute {
    [NullableContextAttribute("1")]
public virtual void Modify(DocumentMapping mapping);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class Marten.Schema.HiloSequenceAttribute : MartenAttribute {
    [NullableAttribute("1")]
private HiloSettings _settings;
    public int MaxLo { get; public set; }
    public string SequenceName { get; public set; }
    public void set_MaxLo(int value);
    public int get_MaxLo();
    public void set_SequenceName(string value);
    public string get_SequenceName();
    [NullableContextAttribute("1")]
public virtual void Modify(DocumentMapping mapping);
}
[NullableContextAttribute("1")]
public interface Marten.Schema.IDatabaseCreationExpressions {
    public abstract virtual ITenantDatabaseCreationExpressions ForTenant(string tenantId);
    public abstract virtual IDatabaseCreationExpressions MaintenanceDatabase(string maintenanceDbConnectionString);
}
public class Marten.Schema.Identity.CombGuidIdGeneration : object {
    private static int NumDateBytes;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IEnumerable`1<Type> <KeyTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresSequences>k__BackingField;
    [NullableAttribute("1")]
public IEnumerable`1<Type> KeyTypes { get; }
    public bool RequiresSequences { get; }
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Type> get_KeyTypes();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequiresSequences();
    [NullableContextAttribute("1")]
public sealed virtual void GenerateCode(GeneratedMethod method, DocumentMapping mapping);
    public static Guid NewGuid(DateTimeOffset timestamp);
    public static Guid NewGuid();
    private static void WriteDateTime(Span`1<byte> destination, DateTimeOffset timestamp);
    private static DateTimeOffset BytesToDateTime(ReadOnlySpan`1<byte> value);
    public static Guid Create(Guid value, DateTimeOffset timestamp);
    public static DateTimeOffset GetTimestamp(Guid comb);
}
public class Marten.Schema.Identity.FSharpDiscriminatedUnionIdGeneration : ValueTypeInfo {
    private IScalarSelectClause _selector;
    public IEnumerable`1<Type> KeyTypes { get; }
    public bool RequiresSequences { get; }
    private FSharpDiscriminatedUnionIdGeneration(Type outerType, PropertyInfo valueProperty, Type simpleType, ConstructorInfo ctor);
    private FSharpDiscriminatedUnionIdGeneration(Type outerType, PropertyInfo valueProperty, Type simpleType, MethodInfo builder);
    public sealed virtual IEnumerable`1<Type> get_KeyTypes();
    public sealed virtual bool get_RequiresSequences();
    public sealed virtual void GenerateCode(GeneratedMethod method, DocumentMapping mapping);
    public sealed virtual ISelectClause BuildSelectClause(string tableName);
    public static bool IsFSharpSingleCaseDiscriminatedUnion(Type type);
    public static bool IsCandidate(Type idType, FSharpDiscriminatedUnionIdGeneration& idGeneration);
    public string ParameterValue(DocumentMapping mapping);
    public void GenerateCodeForFetchingId(int index, GeneratedMethod sync, GeneratedMethod async, DocumentMapping mapping);
    public sealed virtual Func`2<object, T> BuildInnerValueSource();
    public void WriteBulkWriterCode(GeneratedMethod load, DocumentMapping mapping);
    public void WriteBulkWriterCodeAsync(GeneratedMethod load, DocumentMapping mapping);
}
internal class Marten.Schema.Identity.FSharpDiscriminatedUnionIdSelectClause`2 : object {
    [CompilerGeneratedAttribute]
private Func`2<TInner, TOuter> <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FromObject>k__BackingField;
    public Func`2<TInner, TOuter> Converter { get; }
    public string MemberName { get; public set; }
    public Type SelectedType { get; }
    public string FromObject { get; public set; }
    public FSharpDiscriminatedUnionIdSelectClause`2(FSharpDiscriminatedUnionIdGeneration typedIdGeneration);
    public FSharpDiscriminatedUnionIdSelectClause`2(Func`2<TInner, TOuter> converter);
    [CompilerGeneratedAttribute]
public Func`2<TInner, TOuter> get_Converter();
    [CompilerGeneratedAttribute]
public sealed virtual string get_MemberName();
    [CompilerGeneratedAttribute]
public void set_MemberName(string value);
    public sealed virtual ISelectClause CloneToOtherTable(string tableName);
    public sealed virtual void ApplyOperator(string op);
    public sealed virtual ISelectClause CloneToDouble();
    public sealed virtual Type get_SelectedType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FromObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FromObject(string value);
    public sealed virtual void Apply(ICommandBuilder sql);
    public sealed virtual String[] SelectFields();
    public sealed virtual ISelector BuildSelector(IMartenSession session);
    public sealed virtual IQueryHandler`1<TResult> BuildHandler(IMartenSession session, ISqlFragment statement, ISqlFragment currentStatement);
    public sealed virtual ISelectClause UseStatistics(QueryStatistics statistics);
    public sealed virtual TOuter Resolve(DbDataReader reader);
    [AsyncStateMachineAttribute("Marten.Schema.Identity.FSharpDiscriminatedUnionIdSelectClause`2/<ResolveAsync>d__24")]
public sealed virtual Task`1<TOuter> ResolveAsync(DbDataReader reader, CancellationToken token);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Schema.Identity.GuidIdGeneration : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <KeyTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresSequences>k__BackingField;
    public IEnumerable`1<Type> KeyTypes { get; }
    public bool RequiresSequences { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Type> get_KeyTypes();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequiresSequences();
    public sealed virtual void GenerateCode(GeneratedMethod method, DocumentMapping mapping);
}
[NullableContextAttribute("1")]
public interface Marten.Schema.Identity.IIdGeneration {
    [ObsoleteAttribute("Will be removed in Marten 8.0")]
public IEnumerable`1<Type> KeyTypes { get; }
    public bool RequiresSequences { get; }
    public abstract virtual IEnumerable`1<Type> get_KeyTypes();
    public abstract virtual bool get_RequiresSequences();
    public abstract virtual void GenerateCode(GeneratedMethod method, DocumentMapping mapping);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Schema.Identity.NoOpIdGeneration : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <KeyTypes>k__BackingField;
    public IEnumerable`1<Type> KeyTypes { get; }
    public bool RequiresSequences { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Type> get_KeyTypes();
    public sealed virtual bool get_RequiresSequences();
    public sealed virtual void GenerateCode(GeneratedMethod method, DocumentMapping mapping);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Schema.Identity.Sequences.HiloIdGeneration : object {
    private HiloSettings _hiloSettings;
    [CompilerGeneratedAttribute]
private Type <DocumentType>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <KeyTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresSequences>k__BackingField;
    public Type DocumentType { get; }
    public int MaxLo { get; }
    public IEnumerable`1<Type> KeyTypes { get; }
    public bool RequiresSequences { get; }
    public HiloIdGeneration(Type documentType, HiloSettings hiloSettings);
    [CompilerGeneratedAttribute]
public Type get_DocumentType();
    public int get_MaxLo();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Type> get_KeyTypes();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequiresSequences();
    public sealed virtual void GenerateCode(GeneratedMethod method, DocumentMapping mapping);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Schema.Identity.Sequences.HiloSequence : object {
    private IMartenDatabase _database;
    private object _lock;
    private StoreOptions _options;
    private HiloSettings _settings;
    [CompilerGeneratedAttribute]
private string <EntityName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <CurrentHi>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentLo>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxLo>k__BackingField;
    private DbObjectName GetNextFunction { get; }
    public string EntityName { get; }
    public long CurrentHi { get; private set; }
    public int CurrentLo { get; private set; }
    public int MaxLo { get; }
    public HiloSequence(IMartenDatabase database, StoreOptions options, string entityName, HiloSettings settings);
    private DbObjectName get_GetNextFunction();
    [CompilerGeneratedAttribute]
public string get_EntityName();
    [CompilerGeneratedAttribute]
public long get_CurrentHi();
    [CompilerGeneratedAttribute]
private void set_CurrentHi(long value);
    [CompilerGeneratedAttribute]
public int get_CurrentLo();
    [CompilerGeneratedAttribute]
private void set_CurrentLo(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxLo();
    [AsyncStateMachineAttribute("Marten.Schema.Identity.Sequences.HiloSequence/<SetFloor>d__21")]
public sealed virtual Task SetFloor(long floor);
    public sealed virtual int NextInt();
    public sealed virtual long NextLong();
    [AsyncStateMachineAttribute("Marten.Schema.Identity.Sequences.HiloSequence/<AdvanceToNextHi>d__24")]
public Task AdvanceToNextHi(CancellationToken ct);
    public void AdvanceToNextHiSync();
    [NullableContextAttribute("2")]
private bool TrySetCurrentHi(object raw);
    private NpgsqlCommand GetNexFunctionCommand(NpgsqlConnection conn);
    public long AdvanceValue();
    public bool ShouldAdvanceHi();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Marten.Schema.Identity.Sequences.HiloSettings : object {
    [CompilerGeneratedAttribute]
private int <MaxLo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SequenceName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxAdvanceToNextHiAttempts>k__BackingField;
    public int MaxLo { get; public set; }
    public string SequenceName { get; public set; }
    public int MaxAdvanceToNextHiAttempts { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxLo();
    [CompilerGeneratedAttribute]
public void set_MaxLo(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SequenceName();
    [CompilerGeneratedAttribute]
public void set_SequenceName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_MaxAdvanceToNextHiAttempts();
    [CompilerGeneratedAttribute]
public void set_MaxAdvanceToNextHiAttempts(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Schema.Identity.Sequences.IdentityKeyGeneration : object {
    private HiloSettings _hiloSettings;
    private DocumentMapping _mapping;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <KeyTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresSequences>k__BackingField;
    public int MaxLo { get; }
    public IEnumerable`1<Type> KeyTypes { get; }
    public bool RequiresSequences { get; }
    public IdentityKeyGeneration(DocumentMapping mapping, HiloSettings hiloSettings);
    public int get_MaxLo();
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Type> get_KeyTypes();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequiresSequences();
    public sealed virtual void GenerateCode(GeneratedMethod method, DocumentMapping mapping);
    public Type[] DependentFeatures();
}
[NullableContextAttribute("2")]
public interface Marten.Schema.Identity.Sequences.IReadOnlyHiloSettings {
    public int MaxLo { get; }
    public string SequenceName { get; }
    public int MaxAdvanceToNextHiAttempts { get; }
    public abstract virtual int get_MaxLo();
    public abstract virtual string get_SequenceName();
    public abstract virtual int get_MaxAdvanceToNextHiAttempts();
}
[NullableContextAttribute("1")]
public interface Marten.Schema.Identity.Sequences.ISequence {
    public int MaxLo { get; }
    public abstract virtual int get_MaxLo();
    public abstract virtual int NextInt();
    public abstract virtual long NextLong();
    public abstract virtual Task SetFloor(long floor);
}
[NullableContextAttribute("1")]
public interface Marten.Schema.Identity.Sequences.ISequences {
    public abstract virtual ISequence Hilo(Type documentType, HiloSettings settings);
    public abstract virtual ISequence SequenceFor(Type documentType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Schema.Identity.Sequences.SequenceFactory : object {
    private IMartenDatabase _database;
    private StoreOptions _options;
    private ConcurrentDictionary`2<string, ISequence> _sequences;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <StorageType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    public string Name { get; }
    public ISchemaObject[] Objects { get; }
    public Type StorageType { get; }
    public string Identifier { get; }
    private Migrator Weasel.Core.Migrations.IFeatureSchema.Migrator { get; }
    public SequenceFactory(StoreOptions options, IMartenDatabase database);
    [CompilerGeneratedAttribute]
public string get_Name();
    [IteratorStateMachineAttribute("Marten.Schema.Identity.Sequences.SequenceFactory/<DependentTypes>d__7")]
public sealed virtual IEnumerable`1<Type> DependentTypes();
    public sealed virtual ISchemaObject[] get_Objects();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_StorageType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Identifier();
    private sealed virtual override Migrator Weasel.Core.Migrations.IFeatureSchema.get_Migrator();
    public sealed virtual void WritePermissions(Migrator rules, TextWriter writer);
    public sealed virtual ISequence SequenceFor(Type documentType);
    public sealed virtual ISequence Hilo(Type documentType, HiloSettings settings);
    public bool IsActive(StoreOptions options);
    private string GetSequenceName(Type documentType, HiloSettings settings);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Schema.Identity.StringIdGeneration : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <KeyTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresSequences>k__BackingField;
    public IEnumerable`1<Type> KeyTypes { get; }
    public bool RequiresSequences { get; }
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<Type> get_KeyTypes();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RequiresSequences();
    public sealed virtual void GenerateCode(GeneratedMethod method, DocumentMapping mapping);
}
public class Marten.Schema.Identity.ValueTypeIdGeneration : ValueTypeInfo {
    private IScalarSelectClause _selector;
    public IEnumerable`1<Type> KeyTypes { get; }
    public bool RequiresSequences { get; }
    private ValueTypeIdGeneration(Type outerType, PropertyInfo valueProperty, Type simpleType, ConstructorInfo ctor);
    private ValueTypeIdGeneration(Type outerType, PropertyInfo valueProperty, Type simpleType, MethodInfo builder);
    public sealed virtual IEnumerable`1<Type> get_KeyTypes();
    public sealed virtual bool get_RequiresSequences();
    public sealed virtual void GenerateCode(GeneratedMethod method, DocumentMapping mapping);
    private void generateStringWrapper(GeneratedMethod method, DocumentMapping mapping, Use document);
    private void generateLongWrapper(GeneratedMethod method, DocumentMapping mapping, Use document);
    private void generateIntWrapper(GeneratedMethod method, DocumentMapping mapping, Use document);
    private void generateGuidWrapper(GeneratedMethod method, DocumentMapping mapping, Use document);
    public sealed virtual ISelectClause BuildSelectClause(string tableName);
    public static bool IsCandidate(Type idType, ValueTypeIdGeneration& idGeneration);
    public string ParameterValue(DocumentMapping mapping);
    public void GenerateCodeForFetchingId(int index, GeneratedMethod sync, GeneratedMethod async, DocumentMapping mapping);
    public sealed virtual Func`2<object, T> BuildInnerValueSource();
    public void WriteBulkWriterCode(GeneratedMethod load, DocumentMapping mapping);
    public void WriteBulkWriterCodeAsync(GeneratedMethod load, DocumentMapping mapping);
}
public class Marten.Schema.Identity.ValueTypeIdSelectClause`2 : ValueTypeSelectClause`2<TOuter, TInner> {
    public ValueTypeIdSelectClause`2(ValueTypeIdGeneration idGeneration);
}
[AttributeUsageAttribute("384")]
public class Marten.Schema.IdentityAttribute : MartenAttribute {
}
[NullableContextAttribute("1")]
public interface Marten.Schema.IDocumentCleaner {
    [ObsoleteAttribute("Use async method instead.")]
public abstract virtual void DeleteAllDocuments();
    public abstract virtual Task DeleteAllDocumentsAsync(CancellationToken ct);
    [ObsoleteAttribute("Use async method instead.")]
public abstract virtual void DeleteDocumentsByType(Type documentType);
    public abstract virtual Task DeleteDocumentsByTypeAsync(Type documentType, CancellationToken ct);
    [ObsoleteAttribute("Use async method instead.")]
public abstract virtual void DeleteDocumentsExcept(Type[] documentTypes);
    public virtual Task DeleteDocumentsExceptAsync(Type[] documentTypes);
    public abstract virtual Task DeleteDocumentsExceptAsync(CancellationToken ct, Type[] documentTypes);
    [ObsoleteAttribute("Use async method instead.")]
public abstract virtual void CompletelyRemove(Type documentType);
    public abstract virtual Task CompletelyRemoveAsync(Type documentType, CancellationToken ct);
    [ObsoleteAttribute("Use async method instead.")]
public abstract virtual void CompletelyRemoveAll();
    public abstract virtual Task CompletelyRemoveAllAsync(CancellationToken ct);
    [ObsoleteAttribute("Use async method instead.")]
public abstract virtual void DeleteAllEventData();
    public abstract virtual Task DeleteAllEventDataAsync(CancellationToken ct);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use async method instead.")]
public abstract virtual void DeleteSingleEventStream(Guid streamId, string tenantId);
    public abstract virtual Task DeleteSingleEventStreamAsync(Guid streamId, string tenantId, CancellationToken ct);
    [ObsoleteAttribute("Use async method instead.")]
public abstract virtual void DeleteSingleEventStream(string streamId, string tenantId);
    public abstract virtual Task DeleteSingleEventStreamAsync(string streamId, string tenantId, CancellationToken ct);
}
internal interface Marten.Schema.IDocumentMapping {
    public IDocumentMapping Root { get; }
    public MemberInfo IdMember { get; }
    public Type DocumentType { get; }
    public Type IdType { get; }
    public DbObjectName TableName { get; }
    public PropertySearching PropertySearching { get; }
    public DeleteStyle DeleteStyle { get; }
    public bool UseVersionFromMatchingStream { get; public set; }
    public abstract virtual IDocumentMapping get_Root();
    public abstract virtual MemberInfo get_IdMember();
    public abstract virtual Type get_DocumentType();
    public abstract virtual Type get_IdType();
    public abstract virtual DbObjectName get_TableName();
    public abstract virtual PropertySearching get_PropertySearching();
    public abstract virtual DeleteStyle get_DeleteStyle();
    public abstract virtual bool get_UseVersionFromMatchingStream();
    public abstract virtual void set_UseVersionFromMatchingStream(bool value);
}
public interface Marten.Schema.IDocumentType {
    public IDocumentType Root { get; }
    public Type DocumentType { get; }
    public Type IdType { get; }
    public DbObjectName TableName { get; }
    public DocumentMetadataCollection Metadata { get; }
    public bool UseOptimisticConcurrency { get; }
    public IList`1<IndexDefinition> Indexes { get; }
    public IList`1<ForeignKey> ForeignKeys { get; }
    public SubClasses SubClasses { get; }
    public DbObjectName UpsertFunction { get; }
    public DbObjectName InsertFunction { get; }
    public DbObjectName UpdateFunction { get; }
    public DbObjectName OverwriteFunction { get; }
    public string DatabaseSchemaName { get; public set; }
    public EnumStorage EnumStorage { get; }
    public Casing Casing { get; }
    public string Alias { get; public set; }
    public IIdGeneration IdStrategy { get; }
    public MemberInfo IdMember { get; }
    public bool StructuralTyped { get; }
    public string DdlTemplate { get; }
    public IReadOnlyHiloSettings HiloSettings { get; }
    public TenancyStyle TenancyStyle { get; }
    public IReadOnlyList`1<DuplicatedField> DuplicatedFields { get; }
    public abstract virtual IDocumentType get_Root();
    public abstract virtual Type get_DocumentType();
    public abstract virtual Type get_IdType();
    public abstract virtual DbObjectName get_TableName();
    public abstract virtual DocumentMetadataCollection get_Metadata();
    public abstract virtual bool get_UseOptimisticConcurrency();
    public abstract virtual IList`1<IndexDefinition> get_Indexes();
    public abstract virtual IList`1<ForeignKey> get_ForeignKeys();
    public abstract virtual SubClasses get_SubClasses();
    public abstract virtual DbObjectName get_UpsertFunction();
    public abstract virtual DbObjectName get_InsertFunction();
    public abstract virtual DbObjectName get_UpdateFunction();
    public abstract virtual DbObjectName get_OverwriteFunction();
    public abstract virtual string get_DatabaseSchemaName();
    public abstract virtual void set_DatabaseSchemaName(string value);
    public abstract virtual EnumStorage get_EnumStorage();
    public abstract virtual Casing get_Casing();
    public abstract virtual string get_Alias();
    public abstract virtual void set_Alias(string value);
    public abstract virtual IIdGeneration get_IdStrategy();
    public abstract virtual MemberInfo get_IdMember();
    public abstract virtual bool get_StructuralTyped();
    public abstract virtual string get_DdlTemplate();
    public abstract virtual IReadOnlyHiloSettings get_HiloSettings();
    public abstract virtual TenancyStyle get_TenancyStyle();
    public abstract virtual IReadOnlyList`1<DuplicatedField> get_DuplicatedFields();
    public abstract virtual bool IsHierarchy();
    public abstract virtual IEnumerable`1<DocumentIndex> IndexesFor(string column);
    public abstract virtual string AliasFor(Type subclassType);
    public abstract virtual Type TypeFor(string alias);
}
[NullableContextAttribute("1")]
public interface Marten.Schema.IInitialData {
    public abstract virtual Task Populate(IDocumentStore store, CancellationToken cancellation);
}
[AttributeUsageAttribute("4")]
public class Marten.Schema.IndexedCreatedAtAttribute : MartenAttribute {
    [NullableContextAttribute("1")]
public virtual void Modify(DocumentMapping mapping);
}
[AttributeUsageAttribute("4")]
public class Marten.Schema.IndexedLastModifiedAttribute : MartenAttribute {
    [NullableContextAttribute("1")]
public virtual void Modify(DocumentMapping mapping);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Marten.Schema.Indexing.FullText.FullTextIndexDefinitionFactory : object {
    [NullableContextAttribute("2")]
public static FullTextIndexDefinition From(DocumentMapping mapping, string regConfig, string dataConfig, string indexName);
    public static FullTextIndexDefinition From(DocumentMapping mapping, MemberInfo[][] members, string regConfig);
    private static string GetDataConfig(DocumentMapping mapping, MemberInfo[][] members);
}
public enum Marten.Schema.Indexing.Unique.TenancyScope : Enum {
    public int value__;
    public static TenancyScope Global;
    public static TenancyScope PerTenant;
}
public class Marten.Schema.InsertExceptionTransform`1 : object {
    private static string ExpectedMessage;
    private object id;
    private string tableName;
    public InsertExceptionTransform`1(object id, string tableName);
    public sealed virtual bool TryTransform(Exception original, Exception& transformed);
}
[AttributeUsageAttribute("384")]
public class Marten.Schema.IsSoftDeletedMetadataAttributeAttribute : MartenAttribute {
    [NullableContextAttribute("1")]
public virtual void Modify(DocumentMapping mapping, MemberInfo member);
}
[NullableContextAttribute("1")]
public interface Marten.Schema.ITenantDatabaseCreationExpressions {
    public abstract virtual ITenantDatabaseCreationExpressions DropExisting(bool killConnections);
    public abstract virtual ITenantDatabaseCreationExpressions WithEncoding(string encoding);
    public abstract virtual ITenantDatabaseCreationExpressions WithOwner(string owner);
    public abstract virtual ITenantDatabaseCreationExpressions ConnectionLimit(int limit);
    public abstract virtual ITenantDatabaseCreationExpressions LcCollate(string lcCollate);
    public abstract virtual ITenantDatabaseCreationExpressions LcType(string lcType);
    public abstract virtual ITenantDatabaseCreationExpressions TableSpace(string tableSpace);
    public abstract virtual ITenantDatabaseCreationExpressions CheckAgainstPgDatabase();
    public abstract virtual ITenantDatabaseCreationExpressions OnDatabaseCreated(Action`1<NpgsqlConnection> onDbCreated);
}
[AttributeUsageAttribute("384")]
public class Marten.Schema.LastModifiedMetadataAttribute : MartenAttribute {
    [NullableContextAttribute("1")]
public virtual void Modify(DocumentMapping mapping, MemberInfo member);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Marten.Schema.MartenAttribute : Attribute {
    public virtual void Modify(DocumentMapping mapping);
    public virtual void Modify(DocumentMapping mapping, MemberInfo member);
    public virtual void Register(Type discoveredType, StoreOptions options);
}
[AttributeUsageAttribute("4")]
public class Marten.Schema.MartenDocumentAttribute : MartenAttribute {
    [NullableContextAttribute("1")]
public virtual void Register(Type discoveredType, StoreOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class Marten.Schema.MartenEventAttribute : MartenAttribute {
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    public string Alias { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
public void set_Alias(string value);
    [NullableContextAttribute("1")]
public virtual void Register(Type discoveredType, StoreOptions options);
}
public class Marten.Schema.MartenManagedTenantListPartitions : object {
    private StoreOptions _options;
    public static string TableName;
    [CompilerGeneratedAttribute]
private ManagedListPartitions <Partitions>k__BackingField;
    public ManagedListPartitions Partitions { get; }
    public MartenManagedTenantListPartitions(StoreOptions options, string schemaName);
    [CompilerGeneratedAttribute]
public ManagedListPartitions get_Partitions();
    public sealed virtual void Apply(DocumentMapping mapping);
}
[AttributeUsageAttribute("4")]
public class Marten.Schema.MultiTenantedAttribute : MartenAttribute {
    [NullableContextAttribute("1")]
public virtual void Modify(DocumentMapping mapping);
}
public class Marten.Schema.NgramIndex : IndexDefinition {
    public static string DefaultRegConfig;
    public static string DefaultDataConfig;
    private DbObjectName _table;
    private string _databaseSchemaName;
    private string _dataConfig;
    private string _indexName;
    public string DataConfig { get; public set; }
    public String[] Columns { get; public set; }
    public NgramIndex(DocumentMapping mapping, string dataConfig, string indexName);
    public NgramIndex(DocumentMapping mapping, MemberInfo[] member);
    public string get_DataConfig();
    public void set_DataConfig(string value);
    public virtual String[] get_Columns();
    public virtual void set_Columns(String[] value);
    protected virtual string deriveIndexName();
    private static string GetDataConfig(DocumentMapping mapping, MemberInfo[] members);
}
public enum Marten.Schema.PrimaryKeyTenancyOrdering : Enum {
    public int value__;
    public static PrimaryKeyTenancyOrdering TenantId_Then_Id;
    public static PrimaryKeyTenancyOrdering Id_Then_TenantId;
}
public enum Marten.Schema.PropertySearching : Enum {
    public int value__;
    public static PropertySearching JSON_Locator_Only;
    public static PropertySearching ContainmentOperator;
}
[AttributeUsageAttribute("4")]
public class Marten.Schema.PropertySearchingAttribute : MartenAttribute {
    private PropertySearching _searching;
    public PropertySearchingAttribute(PropertySearching searching);
    [NullableContextAttribute("1")]
public virtual void Modify(DocumentMapping mapping);
}
[ExtensionAttribute]
internal static class Marten.Schema.SchemaBuilder : object {
    public static string GetSqlScript(string databaseSchemaName, string script);
    public static string GetJavascript(StoreOptions options, string jsfile, string namespace);
    [ExtensionAttribute]
public static StringWriter WriteSql(StringWriter writer, string databaseSchemaName, string scriptName);
    internal static string ReadFromStream(string name, string databaseSchemaName);
}
internal class Marten.Schema.SchemaConstants : object {
    public static string BaseAlias;
    public static string TablePrefix;
    public static string UpsertPrefix;
    public static string InsertPrefix;
    public static string UpdatePrefix;
    public static string OverwritePrefix;
    public static string DocumentTypeColumn;
    public static string MartenPrefix;
    public static string LastModifiedColumn;
    public static string DotNetTypeColumn;
    public static string VersionColumn;
    public static string CreatedAtColumn;
    public static string DeletedColumn;
    public static string DeletedAtColumn;
    public static string MartenGeneratedNamespace;
    public static string DefaultSchema;
}
[AttributeUsageAttribute("4")]
public class Marten.Schema.SingleTenantedAttribute : MartenAttribute {
    [NullableContextAttribute("1")]
public virtual void Modify(DocumentMapping mapping);
}
[AttributeUsageAttribute("384")]
public class Marten.Schema.SoftDeletedAtMetadataAttribute : MartenAttribute {
    [NullableContextAttribute("1")]
public virtual void Modify(DocumentMapping mapping, MemberInfo member);
}
[AttributeUsageAttribute("4")]
public class Marten.Schema.SoftDeletedAttribute : MartenDocumentAttribute {
    [CompilerGeneratedAttribute]
private bool <Indexed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsePartitioning>k__BackingField;
    public bool Indexed { get; public set; }
    public bool UsePartitioning { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Indexed();
    [CompilerGeneratedAttribute]
public void set_Indexed(bool value);
    [CompilerGeneratedAttribute]
public bool get_UsePartitioning();
    [CompilerGeneratedAttribute]
public void set_UsePartitioning(bool value);
    [NullableContextAttribute("1")]
public virtual void Modify(DocumentMapping mapping);
}
[AttributeUsageAttribute("4")]
public class Marten.Schema.StructuralTypedAttribute : MartenAttribute {
    [NullableContextAttribute("1")]
public virtual void Modify(DocumentMapping mapping);
}
public class Marten.Schema.SubClasses : object {
    private StoreOptions _options;
    private DocumentMapping _parent;
    private IList`1<SubClassMapping> _subClasses;
    public SubClasses(DocumentMapping parent, StoreOptions options);
    public sealed virtual IEnumerator`1<SubClassMapping> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add(Type subclassType, IEnumerable`1<MappedType> otherSubclassTypes, string alias);
    public void Add(Type subclassType, string alias);
    private void VerifyIsSubclass(Type subclassType);
    public void AddHierarchy();
    public void AddHierarchy(MappedType[] allSubclassTypes);
}
public class Marten.Schema.SubClassMapping : object {
    [CompilerGeneratedAttribute]
private IQueryableMemberCollection <QueryMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentMapping <Inner>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentMapping <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Aliases>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseVersionFromMatchingStream>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DocumentType>k__BackingField;
    public PropertySearching PropertySearching { get; }
    public IQueryableMemberCollection QueryMembers { get; }
    public DocumentMapping Inner { get; }
    public DocumentMapping Parent { get; }
    public String[] Aliases { get; }
    public string Alias { get; public set; }
    public DeleteStyle DeleteStyle { get; }
    public bool UseVersionFromMatchingStream { get; public set; }
    public MemberInfo IdMember { get; }
    private IDocumentMapping Marten.Schema.IDocumentMapping.Root { get; }
    public Type DocumentType { get; }
    public DbObjectName TableName { get; }
    public Type IdType { get; }
    public SubClassMapping(Type documentType, DocumentMapping parent, StoreOptions storeOptions, string alias);
    public SubClassMapping(Type documentType, DocumentMapping parent, StoreOptions storeOptions, IEnumerable`1<MappedType> otherSubclassTypes, string alias);
    public sealed virtual PropertySearching get_PropertySearching();
    [CompilerGeneratedAttribute]
public IQueryableMemberCollection get_QueryMembers();
    [CompilerGeneratedAttribute]
public DocumentMapping get_Inner();
    [CompilerGeneratedAttribute]
public DocumentMapping get_Parent();
    [CompilerGeneratedAttribute]
public String[] get_Aliases();
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
public void set_Alias(string value);
    public sealed virtual DeleteStyle get_DeleteStyle();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseVersionFromMatchingStream();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UseVersionFromMatchingStream(bool value);
    public sealed virtual MemberInfo get_IdMember();
    private sealed virtual override IDocumentMapping Marten.Schema.IDocumentMapping.get_Root();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_DocumentType();
    public sealed virtual DbObjectName get_TableName();
    public sealed virtual Type get_IdType();
    private static string GetTypeMartenAlias(Type documentType);
    private static string GetTypeMartenAlias(MappedType documentType);
}
[AttributeUsageAttribute("384")]
public class Marten.Schema.TenantIdMetadataAttribute : MartenAttribute {
    [NullableContextAttribute("1")]
public virtual void Modify(DocumentMapping mapping, MemberInfo member);
}
[AttributeUsageAttribute("384")]
public class Marten.Schema.UniqueIndexAttribute : MartenAttribute {
    public UniqueIndexType IndexType;
    public TenancyScope TenancyScope;
    [CompilerGeneratedAttribute]
private bool <IsConcurrent>k__BackingField;
    [CompilerGeneratedAttribute]
private IndexMethod <IndexMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IndexName>k__BackingField;
    public bool IsConcurrent { get; public set; }
    public IndexMethod IndexMethod { get; public set; }
    public string IndexName { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsConcurrent();
    [CompilerGeneratedAttribute]
public void set_IsConcurrent(bool value);
    [CompilerGeneratedAttribute]
public IndexMethod get_IndexMethod();
    [CompilerGeneratedAttribute]
public void set_IndexMethod(IndexMethod value);
    [CompilerGeneratedAttribute]
public string get_IndexName();
    [CompilerGeneratedAttribute]
public void set_IndexName(string value);
    public virtual void Modify(DocumentMapping mapping, MemberInfo member);
}
public enum Marten.Schema.UniqueIndexType : Enum {
    public int value__;
    public static UniqueIndexType DuplicatedField;
    public static UniqueIndexType Computed;
}
[AttributeUsageAttribute("4")]
public class Marten.Schema.UseOptimisticConcurrencyAttribute : MartenDocumentAttribute {
    [NullableContextAttribute("1")]
public virtual void Modify(DocumentMapping mapping);
}
[AttributeUsageAttribute("384")]
public class Marten.Schema.VersionAttribute : MartenAttribute {
    [NullableContextAttribute("1")]
public virtual void Modify(DocumentMapping mapping, MemberInfo member);
}
public interface Marten.Services.AssertsOnCallback {
}
internal class Marten.Services.BatchQuerying.BatchedOrderedQueryable`1 : BatchedQueryable`1<T> {
    public BatchedOrderedQueryable`1(BatchedQuery parent, IMartenQueryable`1<T> inner);
    public sealed virtual IBatchedOrderedQueryable`1<T> ThenBy(Expression`1<Func`2<T, TKey>> expression);
    public sealed virtual IBatchedOrderedQueryable`1<T> ThenByDescending(Expression`1<Func`2<T, TKey>> expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Services.BatchQuerying.BatchedQuery : object {
    private List`1<Type> _documentTypes;
    private IList`1<IBatchQueryItem> _items;
    [CompilerGeneratedAttribute]
private QuerySession <Parent>k__BackingField;
    public QuerySession Parent { get; }
    public IBatchEvents Events { get; }
    public BatchedQuery(QuerySession parent);
    [CompilerGeneratedAttribute]
public sealed virtual QuerySession get_Parent();
    public sealed virtual IBatchEvents get_Events();
    public sealed virtual Task`1<T> Load(string id);
    public sealed virtual Task`1<T> Load(int id);
    public sealed virtual Task`1<T> Load(long id);
    public sealed virtual Task`1<T> Load(Guid id);
    public sealed virtual IBatchLoadByKeys`1<TDoc> LoadMany();
    public sealed virtual Task`1<IReadOnlyList`1<T>> Query(string sql, Object[] parameters);
    public sealed virtual IBatchedQueryable`1<T> Query();
    [AsyncStateMachineAttribute("Marten.Services.BatchQuerying.BatchedQuery/<Execute>d__15")]
public sealed virtual Task Execute(CancellationToken token);
    public sealed virtual void ExecuteSynchronously();
    public sealed virtual Task`1<TResult> Query(ICompiledQuery`2<TDoc, TResult> query);
    public sealed virtual Task`1<IEvent> Load(Guid id);
    public sealed virtual Task`1<StreamState> FetchStreamState(Guid streamId);
    public sealed virtual Task`1<StreamState> FetchStreamState(string streamKey);
    public sealed virtual Task`1<IReadOnlyList`1<IEvent>> FetchStream(Guid streamId, long version, Nullable`1<DateTime> timestamp, long fromVersion);
    public sealed virtual Task`1<IReadOnlyList`1<IEvent>> FetchStream(string streamKey, long version, Nullable`1<DateTime> timestamp, long fromVersion);
    public sealed virtual Task`1<T> AddItem(IQueryHandler`1<T> handler);
    public sealed virtual Task`1<T> QueryByPlan(IBatchQueryPlan`1<T> plan);
    private Task`1<T> load(TId id);
    private Task`1<TResult> addItem(IQueryable`1<TDoc> queryable, Nullable`1<SingleValueMode> op);
    public Task`1<bool> Any(IMartenQueryable`1<TDoc> queryable);
    public Task`1<long> Count(IMartenQueryable`1<TDoc> queryable);
    internal Task`1<IReadOnlyList`1<T>> Query(IMartenQueryable`1<T> queryable);
    public Task`1<T> First(IMartenQueryable`1<T> queryable);
    public Task`1<T> FirstOrDefault(IMartenQueryable`1<T> queryable);
    public Task`1<T> Single(IMartenQueryable`1<T> queryable);
    public Task`1<T> SingleOrDefault(IMartenQueryable`1<T> queryable);
    public Task`1<TResult> Min(IQueryable`1<TResult> queryable);
    public Task`1<TResult> Max(IQueryable`1<TResult> queryable);
    public Task`1<TResult> Sum(IQueryable`1<TResult> queryable);
    public Task`1<double> Average(IQueryable`1<T> queryable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Services.BatchQuerying.BatchedQueryable`1 : object {
    private BatchedQuery _parent;
    [CompilerGeneratedAttribute]
private IMartenQueryable`1<T> <Inner>k__BackingField;
    internal IMartenQueryable`1<T> Inner { get; internal set; }
    public BatchedQueryable`1(BatchedQuery parent, IMartenQueryable`1<T> inner);
    [CompilerGeneratedAttribute]
internal IMartenQueryable`1<T> get_Inner();
    [CompilerGeneratedAttribute]
internal void set_Inner(IMartenQueryable`1<T> value);
    public sealed virtual IBatchedQueryable`1<T> Stats(QueryStatistics& stats);
    public sealed virtual IBatchedQueryable`1<T> Where(Expression`1<Func`2<T, bool>> predicate);
    public sealed virtual IBatchedQueryable`1<T> Skip(int count);
    public sealed virtual IBatchedQueryable`1<T> Take(int count);
    public sealed virtual IBatchedOrderedQueryable`1<T> OrderBy(Expression`1<Func`2<T, TKey>> expression);
    public sealed virtual IBatchedOrderedQueryable`1<T> OrderByDescending(Expression`1<Func`2<T, TKey>> expression);
    public sealed virtual ITransformedBatchQueryable`1<TValue> Select(Expression`1<Func`2<T, TValue>> selection);
    public IBatchedQueryable`1<T> OrderBy(string property, StringComparer comparer);
    public sealed virtual IBatchedQueryable`1<T> Include(Expression`1<Func`2<T, object>> idSource, Action`1<TInclude> callback);
    public sealed virtual IBatchedQueryable`1<T> Include(Expression`1<Func`2<T, object>> idSource, IList`1<TInclude> list);
    public sealed virtual IBatchedQueryable`1<T> Include(Expression`1<Func`2<T, object>> idSource, IDictionary`2<TKey, TInclude> dictionary);
    public sealed virtual IBatchedQueryableIncludeBuilder`2<T, TInclude> Include(Action`1<TInclude> callback);
    public sealed virtual IBatchedQueryableIncludeBuilder`2<T, TInclude> Include(IList`1<TInclude> list);
    public sealed virtual IBatchedQueryableIncludeBuilder`3<T, TKey, TInclude> Include(IDictionary`2<TKey, TInclude> dictionary);
    public sealed virtual IBatchedQueryableIncludeBuilder`3<T, TKey, TInclude> Include(IDictionary`2<TKey, IList`1<TInclude>> dictionary);
    public sealed virtual IBatchedQueryableIncludeBuilder`3<T, TKey, TInclude> Include(IDictionary`2<TKey, List`1<TInclude>> dictionary);
    public sealed virtual Task`1<long> Count();
    public sealed virtual Task`1<long> Count(Expression`1<Func`2<T, bool>> filter);
    public sealed virtual Task`1<bool> Any();
    public sealed virtual Task`1<bool> Any(Expression`1<Func`2<T, bool>> filter);
    public sealed virtual Task`1<IReadOnlyList`1<T>> ToList();
    public sealed virtual Task`1<T> First();
    public sealed virtual Task`1<T> First(Expression`1<Func`2<T, bool>> filter);
    public sealed virtual Task`1<T> FirstOrDefault();
    public sealed virtual Task`1<T> FirstOrDefault(Expression`1<Func`2<T, bool>> filter);
    public sealed virtual Task`1<T> Single();
    public sealed virtual Task`1<T> Single(Expression`1<Func`2<T, bool>> filter);
    public sealed virtual Task`1<T> SingleOrDefault();
    public sealed virtual Task`1<T> SingleOrDefault(Expression`1<Func`2<T, bool>> filter);
    public sealed virtual Task`1<TResult> Min(Expression`1<Func`2<T, TResult>> expression);
    public sealed virtual Task`1<TResult> Max(Expression`1<Func`2<T, TResult>> expression);
    public sealed virtual Task`1<TResult> Sum(Expression`1<Func`2<T, TResult>> expression);
    public sealed virtual Task`1<double> Average(Expression`1<Func`2<T, object>> expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Services.BatchQuerying.BatchedQueryableIncludeDictionaryBuilder`3 : object {
    private BatchedQueryable`1<T> _batchedQueryable;
    private IDictionary`2<TKey, TInclude> _dictionary;
    public BatchedQueryableIncludeDictionaryBuilder`3(BatchedQueryable`1<T> batchedQueryable, IDictionary`2<TKey, TInclude> dictionary);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, object>> idSource);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, object>> idSource, Expression`1<Func`2<TInclude, bool>> filter);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, TKey>> idSource, Expression`1<Func`2<TInclude, TKey>> idMapping);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, TKey>> idSource, Expression`1<Func`2<TInclude, TKey>> idMapping, Expression`1<Func`2<TInclude, bool>> filter);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, Nullable`1<TId>>> idSource, Expression`1<Func`2<TInclude, Nullable`1<TId>>> idMapping);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, Nullable`1<TId>>> idSource, Expression`1<Func`2<TInclude, Nullable`1<TId>>> idMapping, Expression`1<Func`2<TInclude, bool>> filter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Services.BatchQuerying.BatchedQueryableIncludeDictionaryIListBuilder`3 : object {
    private BatchedQueryable`1<T> _batchedQueryable;
    private IDictionary`2<TKey, IList`1<TInclude>> _dictionary;
    public BatchedQueryableIncludeDictionaryIListBuilder`3(BatchedQueryable`1<T> batchedQueryable, IDictionary`2<TKey, IList`1<TInclude>> dictionary);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, object>> idSource);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, object>> idSource, Expression`1<Func`2<TInclude, bool>> filter);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, TKey>> idSource, Expression`1<Func`2<TInclude, TKey>> idMapping);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, TKey>> idSource, Expression`1<Func`2<TInclude, TKey>> idMapping, Expression`1<Func`2<TInclude, bool>> filter);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, Nullable`1<TId>>> idSource, Expression`1<Func`2<TInclude, Nullable`1<TId>>> idMapping);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, Nullable`1<TId>>> idSource, Expression`1<Func`2<TInclude, Nullable`1<TId>>> idMapping, Expression`1<Func`2<TInclude, bool>> filter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Services.BatchQuerying.BatchedQueryableIncludeDictionaryListBuilder`3 : object {
    private BatchedQueryable`1<T> _batchedQueryable;
    private IDictionary`2<TKey, List`1<TInclude>> _dictionary;
    public BatchedQueryableIncludeDictionaryListBuilder`3(BatchedQueryable`1<T> batchedQueryable, IDictionary`2<TKey, List`1<TInclude>> dictionary);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, object>> idSource);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, object>> idSource, Expression`1<Func`2<TInclude, bool>> filter);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, TKey>> idSource, Expression`1<Func`2<TInclude, TKey>> idMapping);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, TKey>> idSource, Expression`1<Func`2<TInclude, TKey>> idMapping, Expression`1<Func`2<TInclude, bool>> filter);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, Nullable`1<TId>>> idSource, Expression`1<Func`2<TInclude, Nullable`1<TId>>> idMapping);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, Nullable`1<TId>>> idSource, Expression`1<Func`2<TInclude, Nullable`1<TId>>> idMapping, Expression`1<Func`2<TInclude, bool>> filter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Services.BatchQuerying.BatchQueryableIncludeBuilder`2 : object {
    private BatchedQueryable`1<T> _batchedQueryable;
    private Action`1<TInclude> _callback;
    public BatchQueryableIncludeBuilder`2(BatchedQueryable`1<T> batchedQueryable, Action`1<TInclude> callback);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, object>> idSource);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, object>> idSource, Expression`1<Func`2<TInclude, bool>> filter);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, TId>> idSource, Expression`1<Func`2<TInclude, TId>> idMapping);
    public sealed virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, TId>> idSource, Expression`1<Func`2<TInclude, TId>> idMapping, Expression`1<Func`2<TInclude, bool>> filter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Services.BatchQuerying.BatchQueryItem`1 : object {
    private IQueryHandler`1<T> _handler;
    [CompilerGeneratedAttribute]
private TaskCompletionSource`1<T> <Completion>k__BackingField;
    public TaskCompletionSource`1<T> Completion { get; }
    public Task`1<T> Result { get; }
    public IQueryHandler Handler { get; }
    public BatchQueryItem`1(IQueryHandler`1<T> handler);
    [CompilerGeneratedAttribute]
public TaskCompletionSource`1<T> get_Completion();
    public Task`1<T> get_Result();
    public sealed virtual IQueryHandler get_Handler();
    [AsyncStateMachineAttribute("Marten.Services.BatchQuerying.BatchQueryItem`1/<ReadAsync>d__9")]
public sealed virtual Task ReadAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
    public sealed virtual void Read(DbDataReader reader, IMartenSession session);
}
[NullableContextAttribute("1")]
public interface Marten.Services.BatchQuerying.IBatchedFetcher`1 {
    public abstract virtual Task`1<long> Count();
    public abstract virtual Task`1<long> Count(Expression`1<Func`2<T, bool>> filter);
    public abstract virtual Task`1<bool> Any();
    public abstract virtual Task`1<bool> Any(Expression`1<Func`2<T, bool>> filter);
    public abstract virtual Task`1<IReadOnlyList`1<T>> ToList();
    public abstract virtual Task`1<T> First();
    public abstract virtual Task`1<T> First(Expression`1<Func`2<T, bool>> filter);
    public abstract virtual Task`1<T> FirstOrDefault();
    public abstract virtual Task`1<T> FirstOrDefault(Expression`1<Func`2<T, bool>> filter);
    public abstract virtual Task`1<T> Single();
    public abstract virtual Task`1<T> Single(Expression`1<Func`2<T, bool>> filter);
    public abstract virtual Task`1<T> SingleOrDefault();
    public abstract virtual Task`1<T> SingleOrDefault(Expression`1<Func`2<T, bool>> filter);
}
public interface Marten.Services.BatchQuerying.IBatchedOrderedQueryable`1 {
    public abstract virtual IBatchedOrderedQueryable`1<T> ThenBy(Expression`1<Func`2<T, TKey>> expression);
    public abstract virtual IBatchedOrderedQueryable`1<T> ThenByDescending(Expression`1<Func`2<T, TKey>> expression);
}
[NullableContextAttribute("1")]
public interface Marten.Services.BatchQuerying.IBatchedQuery {
    public IBatchEvents Events { get; }
    public QuerySession Parent { get; }
    public abstract virtual IBatchEvents get_Events();
    public abstract virtual QuerySession get_Parent();
    public abstract virtual Task`1<T> Load(string id);
    public abstract virtual Task`1<T> Load(int id);
    public abstract virtual Task`1<T> Load(long id);
    public abstract virtual Task`1<T> Load(Guid id);
    public abstract virtual IBatchLoadByKeys`1<T> LoadMany();
    public abstract virtual Task`1<IReadOnlyList`1<T>> Query(string sql, Object[] parameters);
    public abstract virtual Task Execute(CancellationToken token);
    public abstract virtual IBatchedQueryable`1<T> Query();
    public abstract virtual Task`1<TResult> Query(ICompiledQuery`2<TDoc, TResult> query);
    public abstract virtual void ExecuteSynchronously();
    public abstract virtual Task`1<T> AddItem(IQueryHandler`1<T> handler);
    public abstract virtual Task`1<T> QueryByPlan(IBatchQueryPlan`1<T> plan);
}
[NullableContextAttribute("1")]
public interface Marten.Services.BatchQuerying.IBatchedQueryable`1 {
    public abstract virtual IBatchedQueryable`1<T> Stats(QueryStatistics& stats);
    public abstract virtual IBatchedQueryable`1<T> Where(Expression`1<Func`2<T, bool>> predicate);
    public abstract virtual IBatchedQueryable`1<T> Skip(int count);
    public abstract virtual IBatchedQueryable`1<T> Take(int count);
    public abstract virtual IBatchedOrderedQueryable`1<T> OrderBy(Expression`1<Func`2<T, TKey>> expression);
    public abstract virtual IBatchedOrderedQueryable`1<T> OrderByDescending(Expression`1<Func`2<T, TKey>> expression);
    public abstract virtual ITransformedBatchQueryable`1<TValue> Select(Expression`1<Func`2<T, TValue>> selection);
    public abstract virtual IBatchedQueryable`1<T> Include(Expression`1<Func`2<T, object>> idSource, Action`1<TInclude> callback);
    public abstract virtual IBatchedQueryable`1<T> Include(Expression`1<Func`2<T, object>> idSource, IList`1<TInclude> list);
    public abstract virtual IBatchedQueryable`1<T> Include(Expression`1<Func`2<T, object>> idSource, IDictionary`2<TKey, TInclude> dictionary);
    public abstract virtual IBatchedQueryableIncludeBuilder`2<T, TInclude> Include(Action`1<TInclude> callback);
    public abstract virtual IBatchedQueryableIncludeBuilder`2<T, TInclude> Include(IList`1<TInclude> list);
    public abstract virtual IBatchedQueryableIncludeBuilder`3<T, TKey, TInclude> Include(IDictionary`2<TKey, TInclude> dictionary);
    public abstract virtual IBatchedQueryableIncludeBuilder`3<T, TKey, TInclude> Include(IDictionary`2<TKey, IList`1<TInclude>> dictionary);
    public abstract virtual IBatchedQueryableIncludeBuilder`3<T, TKey, TInclude> Include(IDictionary`2<TKey, List`1<TInclude>> dictionary);
    public abstract virtual Task`1<TResult> Min(Expression`1<Func`2<T, TResult>> expression);
    public abstract virtual Task`1<TResult> Max(Expression`1<Func`2<T, TResult>> expression);
    public abstract virtual Task`1<TResult> Sum(Expression`1<Func`2<T, TResult>> expression);
    public abstract virtual Task`1<double> Average(Expression`1<Func`2<T, object>> expression);
}
[NullableContextAttribute("1")]
public interface Marten.Services.BatchQuerying.IBatchedQueryableIncludeBuilder`2 {
    public abstract virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, object>> idSource);
    public abstract virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, object>> idSource, Expression`1<Func`2<TInclude, bool>> filter);
    public abstract virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, TId>> idSource, Expression`1<Func`2<TInclude, TId>> idMapping);
    public abstract virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, TId>> idSource, Expression`1<Func`2<TInclude, TId>> idMapping, Expression`1<Func`2<TInclude, bool>> filter);
}
[NullableContextAttribute("1")]
public interface Marten.Services.BatchQuerying.IBatchedQueryableIncludeBuilder`3 {
    public abstract virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, object>> idSource);
    public abstract virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, object>> idSource, Expression`1<Func`2<TInclude, bool>> filter);
    public abstract virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, TKey>> idSource, Expression`1<Func`2<TInclude, TKey>> idMapping);
    public abstract virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, TKey>> idSource, Expression`1<Func`2<TInclude, TKey>> idMapping, Expression`1<Func`2<TInclude, bool>> filter);
    public abstract virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, Nullable`1<TId>>> idSource, Expression`1<Func`2<TInclude, Nullable`1<TId>>> idMapping);
    public abstract virtual IBatchedQueryable`1<T> On(Expression`1<Func`2<T, Nullable`1<TId>>> idSource, Expression`1<Func`2<TInclude, Nullable`1<TId>>> idMapping, Expression`1<Func`2<TInclude, bool>> filter);
}
[NullableContextAttribute("1")]
public interface Marten.Services.BatchQuerying.IBatchEvents {
    public abstract virtual Task`1<IEvent> Load(Guid id);
    public abstract virtual Task`1<StreamState> FetchStreamState(Guid streamId);
    public abstract virtual Task`1<StreamState> FetchStreamState(string streamKey);
    public abstract virtual Task`1<IReadOnlyList`1<IEvent>> FetchStream(Guid streamId, long version, Nullable`1<DateTime> timestamp, long fromVersion);
    public abstract virtual Task`1<IReadOnlyList`1<IEvent>> FetchStream(string streamKey, long version, Nullable`1<DateTime> timestamp, long fromVersion);
}
[NullableContextAttribute("1")]
public interface Marten.Services.BatchQuerying.IBatchLoadByKeys`1 {
    public abstract virtual Task`1<IReadOnlyList`1<TDoc>> ById(TKey[] keys);
    public abstract virtual Task`1<IReadOnlyList`1<TDoc>> ByIdList(IEnumerable`1<TKey> keys);
}
[NullableContextAttribute("1")]
internal interface Marten.Services.BatchQuerying.IBatchQueryItem {
    public IQueryHandler Handler { get; }
    public abstract virtual IQueryHandler get_Handler();
    public abstract virtual Task ReadAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
    public abstract virtual void Read(DbDataReader reader, IMartenSession session);
}
[NullableContextAttribute("1")]
public interface Marten.Services.BatchQuerying.ITransformedBatchQueryable`1 {
    public abstract virtual Task`1<IReadOnlyList`1<TValue>> ToList();
    public abstract virtual Task`1<TValue> First();
    public abstract virtual Task`1<TValue> FirstOrDefault();
    public abstract virtual Task`1<TValue> Single();
    public abstract virtual Task`1<TValue> SingleOrDefault();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Services.BatchQuerying.TransformedBatchQueryable`1 : object {
    private IMartenQueryable`1<TValue> _inner;
    private BatchedQuery _parent;
    public TransformedBatchQueryable`1(BatchedQuery parent, IMartenQueryable`1<TValue> inner);
    public sealed virtual Task`1<IReadOnlyList`1<TValue>> ToList();
    public sealed virtual Task`1<TValue> First();
    public sealed virtual Task`1<TValue> FirstOrDefault();
    public sealed virtual Task`1<TValue> Single();
    public sealed virtual Task`1<TValue> SingleOrDefault();
    public Task`1<TValue> First(Expression`1<Func`2<TValue, bool>> filter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Marten.Services.CommandRunnerExtensions : object {
    [ExtensionAttribute]
public static QueryPlan ExplainQuery(NpgsqlConnection conn, ISerializer serializer, NpgsqlCommand cmd, Action`1<IConfigureExplainExpressions> configureExplain);
    [ExtensionAttribute]
public static T QueryScalar(IQuerySession runner, string sql);
    [ExtensionAttribute]
public static T QueryScalar(IQuerySession runner, NpgsqlCommand cmd);
}
public enum Marten.Services.CommandRunnerMode : Enum {
    public int value__;
    public static CommandRunnerMode Transactional;
    public static CommandRunnerMode ReadOnly;
    public static CommandRunnerMode External;
}
public enum Marten.Services.ConcurrencyChecks : Enum {
    public int value__;
    public static ConcurrencyChecks Enabled;
    public static ConcurrencyChecks Disabled;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Services.Diagnostics : object {
    private DocumentStore _store;
    [NullableAttribute("2")]
private Version _postgreSqlVersion;
    public Diagnostics(DocumentStore store);
    public sealed virtual NpgsqlCommand PreviewCommand(ICompiledQuery`2<TDoc, TReturn> query, DocumentTracking trackingMode);
    public sealed virtual QueryPlan ExplainPlan(ICompiledQuery`2<TDoc, TReturn> query);
    public sealed virtual Version GetPostgresVersion();
    private QuerySession OpenQuerySession(DocumentTracking tracking);
}
internal class Marten.Services.EventStreamUnexpectedMaxEventIdExceptionTransform : object {
    private static string ExpectedMessage;
    private static string DetailsRedactedMessage;
    private static string StreamId;
    private static string Version;
    private static Regex EventStreamUniqueExceptionDetailsRegex;
    private static EventStreamUnexpectedMaxEventIdExceptionTransform();
    public sealed virtual bool TryTransform(Exception original, Exception& transformed);
    private static bool Matches(Exception e);
}
[NullableContextAttribute("1")]
public interface Marten.Services.IChangeSet {
    public IEnumerable`1<object> Updated { get; }
    public IEnumerable`1<object> Inserted { get; }
    public IEnumerable`1<IDeletion> Deleted { get; }
    public abstract virtual IEnumerable`1<object> get_Updated();
    public abstract virtual IEnumerable`1<object> get_Inserted();
    public abstract virtual IEnumerable`1<IDeletion> get_Deleted();
    public abstract virtual IEnumerable`1<IEvent> GetEvents();
    public abstract virtual IEnumerable`1<StreamAction> GetStreams();
    public abstract virtual IChangeSet Clone();
}
[NullableContextAttribute("1")]
public interface Marten.Services.IDeletion {
    public object Document { get; public set; }
    public object Id { get; public set; }
    public abstract virtual object get_Document();
    public abstract virtual void set_Document(object value);
    public abstract virtual object get_Id();
    public abstract virtual void set_Id(object value);
}
internal interface Marten.Services.ISessionWorkTracker {
    public List`1<StreamAction> Streams { get; }
    public IReadOnlyList`1<IStorageOperation> AllOperations { get; }
    public abstract virtual List`1<StreamAction> get_Streams();
    public abstract virtual IReadOnlyList`1<IStorageOperation> get_AllOperations();
    public abstract virtual void Reset();
    public abstract virtual void Add(IStorageOperation operation);
    public abstract virtual void Sort(StoreOptions options);
    public abstract virtual void Eject(T document);
    public abstract virtual void EjectAllOfType(Type type);
    public abstract virtual bool TryFindStream(string streamKey, StreamAction& stream);
    public abstract virtual bool TryFindStream(Guid streamId, StreamAction& stream);
    public abstract virtual bool HasOutstandingWork();
    public abstract virtual void EjectAll();
    public abstract virtual void PurgeOperations(TId id);
}
public interface Marten.Services.ISingleQueryHandler`1 {
    public abstract virtual NpgsqlCommand BuildCommand();
    public abstract virtual Task`1<T> HandleAsync(DbDataReader reader, CancellationToken token);
}
internal interface Marten.Services.ISingleQueryRunner {
    public abstract virtual Task`1<T> Query(ISingleQueryHandler`1<T> handler, CancellationToken cancellation);
    public abstract virtual Task SingleCommit(DbCommand command, CancellationToken cancellation);
}
[NullableContextAttribute("1")]
public interface Marten.Services.IUnitOfWork {
    public abstract virtual IEnumerable`1<IDeletion> Deletions();
    public abstract virtual IEnumerable`1<IDeletion> DeletionsFor();
    public abstract virtual IEnumerable`1<IDeletion> DeletionsFor(Type documentType);
    public abstract virtual IEnumerable`1<object> Updates();
    public abstract virtual IEnumerable`1<object> Inserts();
    public abstract virtual IEnumerable`1<T> UpdatesFor();
    public abstract virtual IEnumerable`1<T> InsertsFor();
    public abstract virtual IEnumerable`1<T> AllChangedFor();
    public abstract virtual IList`1<StreamAction> Streams();
    public abstract virtual IEnumerable`1<IStorageOperation> Operations();
    public abstract virtual IEnumerable`1<IStorageOperation> OperationsFor();
    public abstract virtual IEnumerable`1<IStorageOperation> OperationsFor(Type documentType);
}
public class Marten.Services.Json.JsonNetCollectionToArrayJsonConverter : JsonConverter {
    public static JsonNetCollectionToArrayJsonConverter Instance;
    private static List`1<Type> _types;
    private static JsonNetCollectionToArrayJsonConverter();
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
public class Marten.Services.Json.JsonNetContractResolver : DefaultContractResolver {
    [CompilerGeneratedAttribute]
private Casing <Casing>k__BackingField;
    [CompilerGeneratedAttribute]
private CollectionStorage <CollectionStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private NonPublicMembersStorage <NonPublicMembersStorage>k__BackingField;
    public Casing Casing { get; }
    public CollectionStorage CollectionStorage { get; }
    public NonPublicMembersStorage NonPublicMembersStorage { get; }
    public JsonNetContractResolver(Casing casing, CollectionStorage collectionStorage, NonPublicMembersStorage nonPublicMembersStorage);
    [CompilerGeneratedAttribute]
public Casing get_Casing();
    [CompilerGeneratedAttribute]
public CollectionStorage get_CollectionStorage();
    [CompilerGeneratedAttribute]
public NonPublicMembersStorage get_NonPublicMembersStorage();
    protected virtual JsonObjectContract CreateObjectContract(Type objectType);
    protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization);
    private void SetNamingStrategy(Casing casing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Marten.Services.Json.JsonNetObjectContractProvider : object {
    private static Type ConstructorAttributeType;
    private static Ref`1<ImHashMap`2<string, JsonObjectContract>> Constructors;
    private static JsonNetObjectContractProvider();
    public static JsonObjectContract UsingNonDefaultConstructor(JsonObjectContract contract, Type objectType, Func`3<ConstructorInfo, JsonPropertyCollection, IList`1<JsonProperty>> createConstructorParameters);
    private static JsonObjectContract OnUsingNonDefaultConstructor(JsonObjectContract contract, Type objectType, Func`3<ConstructorInfo, JsonPropertyCollection, IList`1<JsonProperty>> createConstructorParameters);
    private static ObjectConstructor`1<object> GetObjectConstructor(MethodBase method);
    private static ConstructorInfo GetNonDefaultConstructor(Type objectType);
    private static ConstructorInfo GetAttributeConstructor(Type objectType);
    private static ConstructorInfo GetTheMostSpecificConstructor(Type objectType);
}
[ExtensionAttribute]
public static class Marten.Services.Json.JsonSerializerExtensions : object {
    [ExtensionAttribute]
public static void EnableDynamicTypes(JsonSerializerOptions options);
}
internal static class Marten.Services.Json.SerializerFactory : object {
    [CompilerGeneratedAttribute]
private static SerializerType <DefaultSerializerType>k__BackingField;
    public static SerializerType DefaultSerializerType { get; public set; }
    [CompilerGeneratedAttribute]
public static SerializerType get_DefaultSerializerType();
    [CompilerGeneratedAttribute]
public static void set_DefaultSerializerType(SerializerType value);
    public static ISerializer New(Nullable`1<SerializerType> serializerType, SerializerOptions options);
}
public class Marten.Services.Json.SerializerOptions : object {
    [CompilerGeneratedAttribute]
private EnumStorage <EnumStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private Casing <Casing>k__BackingField;
    [CompilerGeneratedAttribute]
private CollectionStorage <CollectionStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private NonPublicMembersStorage <NonPublicMembersStorage>k__BackingField;
    public EnumStorage EnumStorage { get; public set; }
    public Casing Casing { get; public set; }
    public CollectionStorage CollectionStorage { get; public set; }
    public NonPublicMembersStorage NonPublicMembersStorage { get; public set; }
    [CompilerGeneratedAttribute]
public EnumStorage get_EnumStorage();
    [CompilerGeneratedAttribute]
public void set_EnumStorage(EnumStorage value);
    [CompilerGeneratedAttribute]
public Casing get_Casing();
    [CompilerGeneratedAttribute]
public void set_Casing(Casing value);
    [CompilerGeneratedAttribute]
public CollectionStorage get_CollectionStorage();
    [CompilerGeneratedAttribute]
public void set_CollectionStorage(CollectionStorage value);
    [CompilerGeneratedAttribute]
public NonPublicMembersStorage get_NonPublicMembersStorage();
    [CompilerGeneratedAttribute]
public void set_NonPublicMembersStorage(NonPublicMembersStorage value);
}
public enum Marten.Services.Json.SerializerType : Enum {
    public int value__;
    public static SerializerType Newtonsoft;
    public static SerializerType SystemTextJson;
}
internal class Marten.Services.Json.SystemObjectNewtonsoftCompatibleConverter : JsonConverter`1<object> {
    public virtual object Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, object value, JsonSerializerOptions options);
}
internal class Marten.Services.Json.SystemTextJsonBigIntegerConverter : JsonConverter`1<BigInteger> {
    public virtual BigInteger Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, BigInteger value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Marten.Services.Json.Transformations.AsyncOnlyEventUpcaster`2 : EventUpcaster`1<TEvent> {
    public string EventTypeName { get; }
    public virtual string get_EventTypeName();
    public virtual object FromDbDataReader(ISerializer serializer, DbDataReader dbDataReader, int index);
    public virtual ValueTask`1<object> FromDbDataReaderAsync(ISerializer serializer, DbDataReader dbDataReader, int index, CancellationToken ct);
    protected abstract virtual Task`1<TEvent> UpcastAsync(TOldEvent oldEvent, CancellationToken ct);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Marten.Services.Json.Transformations.EventUpcaster : object {
    public Type EventType { get; }
    public string EventTypeName { get; }
    public abstract virtual Type get_EventType();
    public virtual string get_EventTypeName();
    public abstract virtual object FromDbDataReader(ISerializer serializer, DbDataReader dbDataReader, int index);
    public virtual ValueTask`1<object> FromDbDataReaderAsync(ISerializer serializer, DbDataReader dbDataReader, int index, CancellationToken ct);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Marten.Services.Json.Transformations.EventUpcaster`1 : EventUpcaster {
    public Type EventType { get; }
    public virtual Type get_EventType();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Marten.Services.Json.Transformations.EventUpcaster`2 : EventUpcaster`1<TEvent> {
    public string EventTypeName { get; }
    public virtual string get_EventTypeName();
    public virtual object FromDbDataReader(ISerializer serializer, DbDataReader dbDataReader, int index);
    public virtual ValueTask`1<object> FromDbDataReaderAsync(ISerializer serializer, DbDataReader dbDataReader, int index, CancellationToken ct);
    protected abstract virtual TEvent Upcast(TOldEvent oldEvent);
}
[NullableContextAttribute("1")]
public interface Marten.Services.Json.Transformations.IEventUpcaster {
    public string EventTypeName { get; }
    public Type EventType { get; }
    public abstract virtual string get_EventTypeName();
    public abstract virtual Type get_EventType();
    public abstract virtual object FromDbDataReader(ISerializer serializer, DbDataReader dbDataReader, int index);
    public abstract virtual ValueTask`1<object> FromDbDataReaderAsync(ISerializer serializer, DbDataReader dbDataReader, int index, CancellationToken ct);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Marten.Services.Json.Transformations.JsonNet.AsyncOnlyEventUpcaster`1 : EventUpcaster`1<TEvent> {
    public virtual object FromDbDataReader(ISerializer serializer, DbDataReader dbDataReader, int index);
    [AsyncStateMachineAttribute("Marten.Services.Json.Transformations.JsonNet.AsyncOnlyEventUpcaster`1/<FromDbDataReaderAsync>d__1")]
public virtual ValueTask`1<object> FromDbDataReaderAsync(ISerializer serializer, DbDataReader dbDataReader, int index, CancellationToken ct);
    protected abstract virtual Task`1<TEvent> UpcastAsync(JObject oldEvent, CancellationToken ct);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Marten.Services.Json.Transformations.JsonNet.EventUpcaster`1 : EventUpcaster`1<TEvent> {
    public virtual object FromDbDataReader(ISerializer serializer, DbDataReader dbDataReader, int index);
    protected abstract virtual TEvent Upcast(JObject oldEvent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Marten.Services.Json.Transformations.JsonNet.JsonTransformations : object {
    public static JsonTransformation Upcast(Func`2<JObject, TEvent> transform);
    public static JsonTransformation AsyncOnlyUpcast(Func`3<JObject, CancellationToken, Task`1<TEvent>> transform);
    internal static Func`4<ISerializer, DbDataReader, int, object> FromDbDataReader(Func`2<JObject, TEvent> transform);
    internal static Func`5<ISerializer, DbDataReader, int, CancellationToken, Task`1<TEvent>> FromDbDataReaderAsync(Func`3<JObject, CancellationToken, Task`1<TEvent>> transform);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Services.Json.Transformations.JsonTransformation : object {
    [CompilerGeneratedAttribute]
private Func`4<ISerializer, DbDataReader, int, object> <FromDbDataReader>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`5<ISerializer, DbDataReader, int, CancellationToken, ValueTask`1<object>> <FromDbDataReaderAsync>k__BackingField;
    public Func`4<ISerializer, DbDataReader, int, object> FromDbDataReader { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`5<ISerializer, DbDataReader, int, CancellationToken, ValueTask`1<object>> FromDbDataReaderAsync { get; }
    public JsonTransformation(Func`4<ISerializer, DbDataReader, int, object> fromDbDataReader, Func`5<ISerializer, DbDataReader, int, CancellationToken, ValueTask`1<object>> transformDbDataReaderAsync);
    [CompilerGeneratedAttribute]
public Func`4<ISerializer, DbDataReader, int, object> get_FromDbDataReader();
    [CompilerGeneratedAttribute]
public Func`5<ISerializer, DbDataReader, int, CancellationToken, ValueTask`1<object>> get_FromDbDataReaderAsync();
    [CompilerGeneratedAttribute]
private ValueTask`1<object> <.ctor>b__0_0(ISerializer serializer, DbDataReader reader, int index, CancellationToken _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Marten.Services.Json.Transformations.JsonTransformations : object {
    public static JsonTransformation Upcast(Func`2<TOldEvent, TEvent> transform);
    public static JsonTransformation Upcast(Func`3<TOldEvent, CancellationToken, Task`1<TEvent>> transform);
    internal static Func`4<ISerializer, DbDataReader, int, object> FromDbDataReader(Func`2<TOldEvent, TEvent> transform);
    internal static Func`5<ISerializer, DbDataReader, int, CancellationToken, ValueTask`1<object>> FromDbDataReaderAsync(Func`3<TOldEvent, CancellationToken, Task`1<TEvent>> transform);
    internal static Func`5<ISerializer, DbDataReader, int, CancellationToken, ValueTask`1<object>> FromDbDataReaderAsync(Func`2<TOldEvent, TEvent> transform);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Marten.Services.Json.Transformations.SystemTextJson.AsyncOnlyEventUpcaster`1 : EventUpcaster`1<TEvent> {
    public virtual object FromDbDataReader(ISerializer serializer, DbDataReader dbDataReader, int index);
    [AsyncStateMachineAttribute("Marten.Services.Json.Transformations.SystemTextJson.AsyncOnlyEventUpcaster`1/<FromDbDataReaderAsync>d__1")]
public virtual ValueTask`1<object> FromDbDataReaderAsync(ISerializer serializer, DbDataReader dbDataReader, int index, CancellationToken ct);
    protected abstract virtual Task`1<TEvent> UpcastAsync(JsonDocument oldEvent, CancellationToken ct);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Marten.Services.Json.Transformations.SystemTextJson.EventUpcaster`1 : EventUpcaster`1<TEvent> {
    public virtual object FromDbDataReader(ISerializer serializer, DbDataReader dbDataReader, int index);
    protected abstract virtual TEvent Upcast(JsonDocument oldEvent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Marten.Services.Json.Transformations.SystemTextJson.JsonTransformations : object {
    public static JsonTransformation Upcast(Func`2<JsonDocument, TEvent> transform);
    public static JsonTransformation AsyncOnlyUpcast(Func`3<JsonDocument, CancellationToken, Task`1<TEvent>> transform);
    internal static Func`4<ISerializer, DbDataReader, int, object> FromDbDataReader(Func`2<JsonDocument, TEvent> transform);
    internal static Func`5<ISerializer, DbDataReader, int, CancellationToken, Task`1<TEvent>> FromDbDataReaderAsync(Func`3<JsonDocument, CancellationToken, Task`1<TEvent>> transform);
}
internal class Marten.Services.JsonArrayPool`1 : object {
    private ArrayPool`1<T> _inner;
    public JsonArrayPool`1(ArrayPool`1<T> inner);
    public sealed virtual T[] Rent(int minimumLength);
    public sealed virtual void Return(T[] array);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Services.JsonNetSerializer : object {
    private ArrayPool`1<char> _charPool;
    private JsonSerializerSettings _cleanSettings;
    private Lazy`1<JsonSerializer> _clean;
    private JsonArrayPool`1<char> _jsonArrayPool;
    private JsonSerializerSettings _serializerSettings;
    private Lazy`1<JsonSerializer> _serializer;
    private JsonSerializerSettings _withTypesSettings;
    private Lazy`1<JsonSerializer> _withTypes;
    private Casing _casing;
    private CollectionStorage _collectionStorage;
    private EnumStorage _enumStorage;
    private NonPublicMembersStorage _nonPublicMembersStorage;
    public CollectionStorage CollectionStorage { get; public set; }
    public NonPublicMembersStorage NonPublicMembersStorage { get; public set; }
    public EnumStorage EnumStorage { get; public set; }
    public Casing Casing { get; public set; }
    public ValueCasting ValueCasting { get; }
    public CollectionStorage get_CollectionStorage();
    public void set_CollectionStorage(CollectionStorage value);
    public NonPublicMembersStorage get_NonPublicMembersStorage();
    public void set_NonPublicMembersStorage(NonPublicMembersStorage value);
    public sealed virtual string ToJson(object document);
    public sealed virtual T FromJson(Stream stream);
    public sealed virtual T FromJson(DbDataReader reader, int index);
    public sealed virtual ValueTask`1<T> FromJsonAsync(Stream stream, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<T> FromJsonAsync(DbDataReader reader, int index, CancellationToken cancellationToken);
    public sealed virtual object FromJson(Type type, Stream stream);
    public sealed virtual object FromJson(Type type, DbDataReader reader, int index);
    public sealed virtual ValueTask`1<object> FromJsonAsync(Type type, Stream stream, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<object> FromJsonAsync(Type type, DbDataReader reader, int index, CancellationToken cancellationToken);
    public sealed virtual string ToCleanJson(object document);
    public sealed virtual string ToJsonWithTypes(object document);
    public sealed virtual EnumStorage get_EnumStorage();
    public void set_EnumStorage(EnumStorage value);
    public sealed virtual Casing get_Casing();
    public void set_Casing(Casing value);
    public sealed virtual ValueCasting get_ValueCasting();
    [ObsoleteAttribute("Use Configure(Action<JsonSerializerSettings> configure) instead. This overload will be removed in the next major release.")]
public void Customize(Action`1<JsonSerializer> configure);
    public void Configure(Action`1<JsonSerializerSettings> configure);
    private void ToJson(object document, TextWriter writer);
    public JObject JObjectFromJson(Stream stream);
    public JObject JObjectFromJson(DbDataReader reader, int index);
    private JsonTextReader GetJsonTextReader(Stream stream);
    private JsonTextReader GetJsonTextReader(TextReader textReader);
    [CompilerGeneratedAttribute]
private JsonSerializer <.ctor>b__12_0();
    [CompilerGeneratedAttribute]
private JsonSerializer <.ctor>b__12_1();
    [CompilerGeneratedAttribute]
private JsonSerializer <.ctor>b__12_2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Marten.Services.JsonStreamingExtensions : object {
    internal static Byte[] LeftBracket;
    internal static Byte[] RightBracket;
    internal static Byte[] Comma;
    private static JsonStreamingExtensions();
    [AsyncStateMachineAttribute("Marten.Services.JsonStreamingExtensions/<StreamOne>d__3")]
[ExtensionAttribute]
internal static Task`1<int> StreamOne(NpgsqlDataReader reader, Stream stream, CancellationToken token);
    [ExtensionAttribute]
internal static ValueTask WriteBytes(Stream stream, Byte[] bytes, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Services.JsonStreamingExtensions/<StreamMany>d__5")]
[ExtensionAttribute]
internal static Task`1<int> StreamMany(NpgsqlDataReader reader, Stream stream, CancellationToken token);
}
internal class Marten.Services.MartenActivator : object {
    private ILogger`1<MartenActivator> _logger;
    [CompilerGeneratedAttribute]
private DocumentStore <Store>k__BackingField;
    public DocumentStore Store { get; }
    public MartenActivator(IDocumentStore store, ILogger`1<MartenActivator> logger);
    [CompilerGeneratedAttribute]
public DocumentStore get_Store();
    [AsyncStateMachineAttribute("Marten.Services.MartenActivator/<TryAttainLock>d__5")]
public sealed virtual Task`1<AttainLockResult> TryAttainLock(NpgsqlConnection conn, CancellationToken ct);
    public sealed virtual Task ReleaseLock(NpgsqlConnection conn, CancellationToken ct);
    [AsyncStateMachineAttribute("Marten.Services.MartenActivator/<StartAsync>d__7")]
public sealed virtual Task StartAsync(CancellationToken cancellationToken);
    public sealed virtual Task StopAsync(CancellationToken cancellationToken);
}
internal class Marten.Services.MartenActivator`1 : MartenActivator {
    public MartenActivator`1(T store, ILogger`1<MartenActivator> logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Services.MartenCommitMetrics : DocumentSessionListenerBase {
    [CompilerGeneratedAttribute]
private ILogger <Logger>P;
    [CompilerGeneratedAttribute]
private List`1<Action`1<IChangeSet>> <Applications>k__BackingField;
    public List`1<Action`1<IChangeSet>> Applications { get; }
    public MartenCommitMetrics(ILogger Logger, List`1<Action`1<IChangeSet>> applications);
    [CompilerGeneratedAttribute]
public List`1<Action`1<IChangeSet>> get_Applications();
    public virtual void AfterCommit(IDocumentSession session, IChangeSet commit);
    public virtual Task AfterCommitAsync(IDocumentSession session, IChangeSet commit, CancellationToken token);
}
public interface Marten.Services.NoDataReturnedCall {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Services.OpenTelemetryOptions : object {
    [CompilerGeneratedAttribute]
private TrackLevel <TrackConnections>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Action`1<IChangeSet>> <Applications>k__BackingField;
    [CompilerGeneratedAttribute]
private Meter <Meter>k__BackingField;
    public TrackLevel TrackConnections { get; public set; }
    internal List`1<Action`1<IChangeSet>> Applications { get; }
    public Meter Meter { get; }
    [CompilerGeneratedAttribute]
public TrackLevel get_TrackConnections();
    [CompilerGeneratedAttribute]
public void set_TrackConnections(TrackLevel value);
    [CompilerGeneratedAttribute]
internal List`1<Action`1<IChangeSet>> get_Applications();
    public void ExportCounterOnChangeSets(string name, string units, Action`2<Counter`1<T>, IChangeSet> recordAction);
    public void TrackEventCounters();
    [CompilerGeneratedAttribute]
public Meter get_Meter();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Services.SessionOptions : object {
    public IList`1<IDocumentSessionListener> Listeners;
    [CompilerGeneratedAttribute]
private CommandRunnerMode <Mode>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Tenant <Tenant>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentTracking <Tracking>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private IsolationLevel <IsolationLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrencyChecks <ConcurrencyChecks>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private NpgsqlConnection <Connection>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private NpgsqlTransaction <Transaction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OwnsTransactionLifecycle>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Transaction <DotNetTransaction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OwnsConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAnyTenant>k__BackingField;
    internal CommandRunnerMode Mode { get; private set; }
    [NullableAttribute("2")]
internal Tenant Tenant { get; internal set; }
    public DocumentTracking Tracking { get; public set; }
    public Nullable`1<int> Timeout { get; public set; }
    public IsolationLevel IsolationLevel { get; public set; }
    public string TenantId { get; public set; }
    public ConcurrencyChecks ConcurrencyChecks { get; public set; }
    [NullableAttribute("2")]
public NpgsqlConnection Connection { get; internal set; }
    [NullableAttribute("2")]
public NpgsqlTransaction Transaction { get; private set; }
    public bool OwnsTransactionLifecycle { get; private set; }
    [NullableAttribute("2")]
public Transaction DotNetTransaction { get; private set; }
    internal bool OwnsConnection { get; internal set; }
    public bool AllowAnyTenant { get; public set; }
    [CompilerGeneratedAttribute]
internal CommandRunnerMode get_Mode();
    [CompilerGeneratedAttribute]
private void set_Mode(CommandRunnerMode value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal Tenant get_Tenant();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Tenant(Tenant value);
    [CompilerGeneratedAttribute]
public DocumentTracking get_Tracking();
    [CompilerGeneratedAttribute]
public void set_Tracking(DocumentTracking value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Timeout();
    [CompilerGeneratedAttribute]
public void set_Timeout(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IsolationLevel get_IsolationLevel();
    [CompilerGeneratedAttribute]
public void set_IsolationLevel(IsolationLevel value);
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
public void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public ConcurrencyChecks get_ConcurrencyChecks();
    [CompilerGeneratedAttribute]
public void set_ConcurrencyChecks(ConcurrencyChecks value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public NpgsqlConnection get_Connection();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Connection(NpgsqlConnection value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public NpgsqlTransaction get_Transaction();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Transaction(NpgsqlTransaction value);
    [CompilerGeneratedAttribute]
public bool get_OwnsTransactionLifecycle();
    [CompilerGeneratedAttribute]
private void set_OwnsTransactionLifecycle(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Transaction get_DotNetTransaction();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_DotNetTransaction(Transaction value);
    [CompilerGeneratedAttribute]
internal bool get_OwnsConnection();
    [CompilerGeneratedAttribute]
internal void set_OwnsConnection(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAnyTenant();
    [CompilerGeneratedAttribute]
public void set_AllowAnyTenant(bool value);
    internal IConnectionLifetime Initialize(DocumentStore store, CommandRunnerMode mode, OpenTelemetryOptions telemetryOptions);
    private IConnectionLifetime buildConnectionLifetime(DocumentStore store, CommandRunnerMode mode);
    [AsyncStateMachineAttribute("Marten.Services.SessionOptions/<InitializeAsync>d__55")]
internal Task`1<IConnectionLifetime> InitializeAsync(DocumentStore store, CommandRunnerMode mode, CancellationToken token);
    public static SessionOptions ForConnectionString(string connectionString);
    public static SessionOptions ForDatabase(IMartenDatabase database);
    public static SessionOptions ForDatabase(string tenantId, IMartenDatabase database);
    public SessionOptions WithTracking(DocumentTracking tracking);
    public SessionOptions ListenAt(IDocumentSessionListener listener);
    public static SessionOptions ForTransaction(NpgsqlTransaction transaction, bool shouldAutoCommit);
    public static SessionOptions ForCurrentTransaction();
    public SessionOptions EnlistInAmbientTransactionScope();
    public static SessionOptions ForConnection(NpgsqlConnection connection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Services.SystemTextJsonSerializer : object {
    private JsonSerializerOptions _clean;
    private JsonSerializerOptions _options;
    private JsonSerializerOptions _optionsDeserialize;
    private JsonSerializerOptions _withTypes;
    private Casing _casing;
    private EnumStorage _enumStorage;
    private JsonDocumentOptions _optionsJsonDocumentDeserialize;
    public ValueCasting ValueCasting { get; }
    public EnumStorage EnumStorage { get; public set; }
    public Casing Casing { get; public set; }
    [NullableContextAttribute("2")]
public SystemTextJsonSerializer(JsonSerializerOptions options);
    public sealed virtual string ToJson(object document);
    public sealed virtual T FromJson(Stream stream);
    public sealed virtual T FromJson(DbDataReader reader, int index);
    [AsyncStateMachineAttribute("Marten.Services.SystemTextJsonSerializer/<FromJsonAsync>d__12`1")]
public sealed virtual ValueTask`1<T> FromJsonAsync(Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Marten.Services.SystemTextJsonSerializer/<FromJsonAsync>d__13`1")]
public sealed virtual ValueTask`1<T> FromJsonAsync(DbDataReader reader, int index, CancellationToken cancellationToken);
    public sealed virtual object FromJson(Type type, Stream stream);
    public sealed virtual object FromJson(Type type, DbDataReader reader, int index);
    [AsyncStateMachineAttribute("Marten.Services.SystemTextJsonSerializer/<FromJsonAsync>d__16")]
public sealed virtual ValueTask`1<object> FromJsonAsync(Type type, Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Marten.Services.SystemTextJsonSerializer/<FromJsonAsync>d__17")]
public sealed virtual ValueTask`1<object> FromJsonAsync(Type type, DbDataReader reader, int index, CancellationToken cancellationToken);
    public sealed virtual string ToCleanJson(object document);
    public sealed virtual string ToJsonWithTypes(object document);
    public sealed virtual ValueCasting get_ValueCasting();
    public sealed virtual EnumStorage get_EnumStorage();
    public void set_EnumStorage(EnumStorage value);
    public sealed virtual Casing get_Casing();
    public void set_Casing(Casing value);
    [ObsoleteAttribute("Use Configure(Action<JsonSerializerOptions> configure) instead.")]
public void Customize(Action`1<JsonSerializerOptions> configure);
    public void Configure(Action`1<JsonSerializerOptions> configure);
    private void syncDocumentDeserializeOptions();
    public JsonDocument JsonDocumentFromJson(Stream stream);
    public JsonDocument JsonDocumentFromJson(DbDataReader reader, int index);
}
public enum Marten.Services.TrackLevel : Enum {
    public int value__;
    public static TrackLevel None;
    public static TrackLevel Normal;
    public static TrackLevel Verbose;
}
public class Marten.Services.VersionTracker : object {
    private IDictionary`2<Type, IDictionary`2<object, Guid>> _versions;
    public void Store(object id, Guid version);
    public void Store(Type documentType, object id, Guid version);
    public Nullable`1<Guid> Version(object id);
    public void ClearAll();
}
public abstract class Marten.SessionFactoryBase : object {
    private IDocumentStore _store;
    protected SessionFactoryBase(IDocumentStore store);
    public abstract virtual SessionOptions BuildOptions();
    public virtual IQuerySession QuerySession();
    public sealed virtual IDocumentSession OpenSession();
    public virtual void ApplyMetadata(IDocumentSession documentSession);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Sessions.DefaultSessionFactory : object {
    private IDocumentStore _store;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ILogger`1<DefaultSessionFactory> _logger;
    public DefaultSessionFactory(IDocumentStore store, ILogger`1<DefaultSessionFactory> logger);
    public sealed virtual IQuerySession QuerySession();
    public sealed virtual IDocumentSession OpenSession();
}
internal class Marten.Sessions.DirtyTrackedSessionFactory : object {
    private IDocumentStore _store;
    public DirtyTrackedSessionFactory(IDocumentStore store);
    public sealed virtual IQuerySession QuerySession();
    public sealed virtual IDocumentSession OpenSession();
}
internal class Marten.Sessions.IdentitySessionFactory : SessionFactoryBase {
    public IdentitySessionFactory(IDocumentStore store);
    public virtual SessionOptions BuildOptions();
}
internal class Marten.Sessions.LightweightSessionFactory : SessionFactoryBase {
    public LightweightSessionFactory(IDocumentStore store);
    public virtual SessionOptions BuildOptions();
}
[ExtensionAttribute]
internal static class Marten.Sessions.TenantedSessionFactory : object {
    [ExtensionAttribute]
internal static DocumentSessionBase UseTenancyBasedOnSliceAndStorage(DocumentSessionBase session, IDocumentStorage storage, IEventSlice slice);
    [ExtensionAttribute]
private static DocumentSessionBase WithTenant(IDocumentSession session, string tenantId);
    [ExtensionAttribute]
private static DocumentSessionBase WithDefaultTenant(IDocumentSession session);
}
internal class Marten.Storage.BulkInsertion : object {
    private Tenant _tenant;
    [CompilerGeneratedAttribute]
private ISerializer <Serializer>k__BackingField;
    public ISerializer Serializer { get; }
    public BulkInsertion(Tenant tenant, StoreOptions options);
    [CompilerGeneratedAttribute]
public ISerializer get_Serializer();
    public sealed virtual void Dispose();
    public void BulkInsert(IReadOnlyCollection`1<T> documents, BulkInsertMode mode, int batchSize);
    public void BulkInsertEnlistTransaction(IReadOnlyCollection`1<T> documents, Transaction transaction, BulkInsertMode mode, int batchSize);
    [AsyncStateMachineAttribute("Marten.Storage.BulkInsertion/<BulkInsertAsync>d__8`1")]
public Task BulkInsertAsync(IReadOnlyCollection`1<T> documents, BulkInsertMode mode, int batchSize, CancellationToken cancellation);
    [AsyncStateMachineAttribute("Marten.Storage.BulkInsertion/<BulkInsertEnlistTransactionAsync>d__9`1")]
public Task BulkInsertEnlistTransactionAsync(IReadOnlyCollection`1<T> documents, Transaction transaction, BulkInsertMode mode, int batchSize, CancellationToken cancellation);
    public void BulkInsertDocuments(IEnumerable`1<object> documents, BulkInsertMode mode, int batchSize);
    public void BulkInsertDocumentsEnlistTransaction(IEnumerable`1<object> documents, Transaction transaction, BulkInsertMode mode, int batchSize);
    private static Type[] documentTypes(IEnumerable`1<object> documents);
    private static IBulkInserter[] bulkInserters(IEnumerable`1<object> documents);
    [AsyncStateMachineAttribute("Marten.Storage.BulkInsertion/<BulkInsertDocumentsAsync>d__14")]
public Task BulkInsertDocumentsAsync(IEnumerable`1<object> documents, BulkInsertMode mode, int batchSize, CancellationToken cancellation);
    [AsyncStateMachineAttribute("Marten.Storage.BulkInsertion/<BulkInsertDocumentsEnlistTransactionAsync>d__15")]
public Task BulkInsertDocumentsEnlistTransactionAsync(IEnumerable`1<object> documents, Transaction transaction, BulkInsertMode mode, int batchSize, CancellationToken cancellation);
    private void bulkInsertDocuments(IReadOnlyCollection`1<T> documents, int batchSize, NpgsqlConnection conn, BulkInsertMode mode);
    [AsyncStateMachineAttribute("Marten.Storage.BulkInsertion/<bulkInsertDocumentsAsync>d__17`1")]
private Task bulkInsertDocumentsAsync(IReadOnlyCollection`1<T> documents, int batchSize, NpgsqlConnection conn, BulkInsertMode mode, CancellationToken cancellation);
    private void loadDocuments(IEnumerable`1<T> documents, IBulkLoader`1<T> loader, BulkInsertMode mode, NpgsqlConnection conn);
    [AsyncStateMachineAttribute("Marten.Storage.BulkInsertion/<loadDocumentsAsync>d__19`1")]
private Task loadDocumentsAsync(IReadOnlyCollection`1<T> documents, IBulkLoader`1<T> loader, BulkInsertMode mode, NpgsqlConnection conn, CancellationToken cancellation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Storage.CompositeDocumentCleaner : object {
    private ITenancy _tenancy;
    private StoreOptions _options;
    public CompositeDocumentCleaner(ITenancy tenancy, StoreOptions options);
    public sealed virtual void DeleteAllDocuments();
    public sealed virtual Task DeleteAllDocumentsAsync(CancellationToken ct);
    public sealed virtual void DeleteDocumentsByType(Type documentType);
    public sealed virtual Task DeleteDocumentsByTypeAsync(Type documentType, CancellationToken ct);
    public sealed virtual void DeleteDocumentsExcept(Type[] documentTypes);
    public sealed virtual Task DeleteDocumentsExceptAsync(CancellationToken ct, Type[] documentTypes);
    public sealed virtual void CompletelyRemove(Type documentType);
    public sealed virtual Task CompletelyRemoveAsync(Type documentType, CancellationToken ct);
    public sealed virtual void CompletelyRemoveAll();
    public sealed virtual Task CompletelyRemoveAllAsync(CancellationToken ct);
    public sealed virtual void DeleteAllEventData();
    public sealed virtual Task DeleteAllEventDataAsync(CancellationToken ct);
    [NullableContextAttribute("2")]
public sealed virtual void DeleteSingleEventStream(Guid streamId, string tenantId);
    [AsyncStateMachineAttribute("Marten.Storage.CompositeDocumentCleaner/<DeleteSingleEventStreamAsync>d__16")]
public sealed virtual Task DeleteSingleEventStreamAsync(Guid streamId, string tenantId, CancellationToken ct);
    public sealed virtual void DeleteSingleEventStream(string streamId, string tenantId);
    [AsyncStateMachineAttribute("Marten.Storage.CompositeDocumentCleaner/<DeleteSingleEventStreamAsync>d__18")]
public sealed virtual Task DeleteSingleEventStreamAsync(string streamId, string tenantId, CancellationToken ct);
    [AsyncStateMachineAttribute("Marten.Storage.CompositeDocumentCleaner/<applyToAll>d__19")]
private Task applyToAll(Func`2<IMartenDatabase, Task> func);
}
public enum Marten.Storage.ConnectionUsage : Enum {
    public int value__;
    public static ConnectionUsage Read;
    public static ConnectionUsage ReadWrite;
}
internal class Marten.Storage.DataColumn : TableColumn {
    public sealed virtual void GenerateCode(StorageStyle storageStyle, GeneratedType generatedType, GeneratedMethod async, GeneratedMethod sync, int index, DocumentMapping mapping);
    public sealed virtual bool ShouldSelect(DocumentMapping mapping, StorageStyle storageStyle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Marten.Storage.DefaultTenancy : Tenancy {
    private NpgsqlDataSource _dataSource;
    private StoreOptions _options;
    [CompilerGeneratedAttribute]
private Tenant <Default>k__BackingField;
    public Tenant Default { get; private set; }
    public IDocumentCleaner Cleaner { get; }
    public DefaultTenancy(NpgsqlDataSource dataSource, StoreOptions options);
    public sealed virtual Tenant GetTenant(string tenantId);
    [CompilerGeneratedAttribute]
public sealed virtual Tenant get_Default();
    [CompilerGeneratedAttribute]
private void set_Default(Tenant value);
    public sealed virtual IDocumentCleaner get_Cleaner();
    public sealed virtual ValueTask`1<Tenant> GetTenantAsync(string tenantId);
    public sealed virtual ValueTask`1<IMartenDatabase> FindOrCreateDatabase(string tenantIdOrDatabaseIdentifier);
    public sealed virtual bool IsTenantStoredInCurrentDatabase(IMartenDatabase database, string tenantId);
    public sealed virtual ValueTask`1<IReadOnlyList`1<IDatabase>> BuildDatabases();
    internal void Initialize();
    public sealed virtual void Dispose();
}
internal class Marten.Storage.DocumentTable : Table {
    private DocumentMapping _mapping;
    public Type DocumentType { get; }
    public DocumentTable(DocumentMapping mapping);
    public Type get_DocumentType();
    public void AddIfActive(MetadataColumn column);
    public string BuildTemplate(string template);
    public void WriteTemplate(SqlTemplate template, TextWriter writer);
    protected bool Equals(DocumentTable other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal ISelectableColumn[] SelectColumns(StorageStyle style);
}
internal class Marten.Storage.DuplicatedFieldColumn : TableColumn {
    private static string NullConstraint;
    private static string NotNullConstraint;
    private DuplicatedField _field;
    public DuplicatedFieldColumn(DuplicatedField field);
    public virtual string AddColumnSql(Table table);
    public virtual string AlterColumnTypeSql(Table table, TableColumn changeActual);
}
public interface Marten.Storage.IDatabaseExpression {
    public abstract virtual DatabaseExpression ForTenants(String[] tenantIds);
}
internal class Marten.Storage.IdColumn : TableColumn {
    private static string IdentityMapCode;
    public IdColumn(DocumentMapping mapping);
    public sealed virtual void GenerateCode(StorageStyle storageStyle, GeneratedType generatedType, GeneratedMethod async, GeneratedMethod sync, int index, DocumentMapping mapping);
    public sealed virtual bool ShouldSelect(DocumentMapping mapping, StorageStyle storageStyle);
}
[NullableContextAttribute("1")]
public interface Marten.Storage.IMartenDatabase {
    public ISequences Sequences { get; }
    public IProviderGraph Providers { get; }
    public ShardStateTracker Tracker { get; }
    public abstract virtual ISequences get_Sequences();
    public abstract virtual IProviderGraph get_Providers();
    public abstract virtual ShardStateTracker get_Tracker();
    public abstract virtual void EnsureStorageExists(Type documentType);
    public abstract virtual ValueTask EnsureStorageExistsAsync(Type featureType, CancellationToken token);
    public abstract virtual Task ResetHiloSequenceFloor(long floor);
    public abstract virtual Task`1<IReadOnlyList`1<DbObjectName>> DocumentTables();
    public abstract virtual Task`1<IReadOnlyList`1<DbObjectName>> Functions();
    public abstract virtual Task`1<Table> ExistingTableFor(Type type);
    public abstract virtual Task`1<IReadOnlyList`1<DbObjectName>> SchemaTables(CancellationToken ct);
    public abstract virtual Task`1<EventStoreStatistics> FetchEventStoreStatistics(CancellationToken token);
    public abstract virtual Task`1<IReadOnlyList`1<ShardState>> AllProjectionProgress(CancellationToken token);
    public abstract virtual Task`1<long> ProjectionProgressFor(ShardName name, CancellationToken token);
    public abstract virtual NpgsqlConnection CreateConnection(ConnectionUsage connectionUsage);
    public abstract virtual Task`1<Nullable`1<long>> FindEventStoreFloorAtTimeAsync(DateTimeOffset timestamp, CancellationToken token);
}
internal class Marten.Storage.InsertFunction : UpsertFunction {
    public InsertFunction(DocumentMapping mapping);
    protected virtual void writeFunction(TextWriter writer, string argList, string securityDeclaration, string inserts, string valueList, string updates);
    private void writeFunctionForGuidVersion(TextWriter writer, string argList, string securityDeclaration, string inserts, string valueList);
    private void writeFunctionForIntRevision(TextWriter writer, string argList, string securityDeclaration, string inserts, string valueList);
}
internal interface Marten.Storage.ISelectableColumn {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual void GenerateCode(StorageStyle storageStyle, GeneratedType generatedType, GeneratedMethod async, GeneratedMethod sync, int index, DocumentMapping mapping);
    public abstract virtual bool ShouldSelect(DocumentMapping mapping, StorageStyle storageStyle);
}
public interface Marten.Storage.ISingleServerMultiTenancy {
    public abstract virtual ISingleServerMultiTenancy WithTenants(String[] tenantIds);
    public abstract virtual ISingleServerMultiTenancy InDatabaseNamed(string databaseName);
}
public interface Marten.Storage.IStaticMultiTenancy {
    public abstract virtual IDatabaseExpression AddMultipleTenantDatabase(string connectionString, string databaseIdentifier);
    public abstract virtual void AddSingleTenantDatabase(string connectionString, string tenantId);
}
public interface Marten.Storage.ITenancy {
    public Tenant Default { get; }
    public IDocumentCleaner Cleaner { get; }
    public abstract virtual Tenant get_Default();
    public abstract virtual IDocumentCleaner get_Cleaner();
    public abstract virtual Tenant GetTenant(string tenantId);
    public abstract virtual ValueTask`1<Tenant> GetTenantAsync(string tenantId);
    public abstract virtual ValueTask`1<IMartenDatabase> FindOrCreateDatabase(string tenantIdOrDatabaseIdentifier);
    public abstract virtual bool IsTenantStoredInCurrentDatabase(IMartenDatabase database, string tenantId);
}
public interface Marten.Storage.ITenancyWithMasterDatabase {
    public PostgresqlDatabase TenantDatabase { get; }
    public abstract virtual PostgresqlDatabase get_TenantDatabase();
}
public class Marten.Storage.MartenDatabase : PostgresqlDatabase {
    private StorageFeatures _features;
    private Lazy`1<SequenceFactory> _sequences;
    [CompilerGeneratedAttribute]
private StoreOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private IProviderGraph <Providers>k__BackingField;
    [NullableAttribute("1")]
public static string DropAllFunctionSql;
    [NullableAttribute("1")]
public static string DropFunctionSql;
    [NullableAttribute("1")]
public static string DropAllSequencesSql;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ShardStateTracker <Tracker>k__BackingField;
    public StoreOptions Options { get; }
    public ISequences Sequences { get; }
    public IProviderGraph Providers { get; }
    [NullableAttribute("1")]
public ShardStateTracker Tracker { get; private set; }
    public MartenDatabase(StoreOptions options, NpgsqlDataSource npgsqlDataSource, string identifier);
    private static MartenDatabase();
    [CompilerGeneratedAttribute]
public StoreOptions get_Options();
    public sealed virtual ISequences get_Sequences();
    [CompilerGeneratedAttribute]
public sealed virtual IProviderGraph get_Providers();
    public sealed virtual Task ResetHiloSequenceFloor(long floor);
    [AsyncStateMachineAttribute("Marten.Storage.MartenDatabase/<DocumentTables>d__12")]
public sealed virtual Task`1<IReadOnlyList`1<DbObjectName>> DocumentTables();
    [AsyncStateMachineAttribute("Marten.Storage.MartenDatabase/<Functions>d__13")]
public sealed virtual Task`1<IReadOnlyList`1<DbObjectName>> Functions();
    [AsyncStateMachineAttribute("Marten.Storage.MartenDatabase/<ExistingTableFor>d__14")]
public sealed virtual Task`1<Table> ExistingTableFor(Type type);
    public virtual IFeatureSchema[] BuildFeatureSchemas();
    public virtual void ResetSchemaExistenceChecks();
    public virtual IFeatureSchema FindFeature(Type featureType);
    private void resetSequences();
    public sealed virtual void Dispose();
    public sealed virtual void DeleteAllDocuments();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Marten.Storage.MartenDatabase/<DeleteAllDocumentsAsync>d__24")]
public sealed virtual Task DeleteAllDocumentsAsync(CancellationToken ct);
    [NullableContextAttribute("1")]
public sealed virtual void DeleteDocumentsByType(Type documentType);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Marten.Storage.MartenDatabase/<DeleteDocumentsByTypeAsync>d__26")]
public sealed virtual Task DeleteDocumentsByTypeAsync(Type documentType, CancellationToken ct);
    [NullableContextAttribute("1")]
public sealed virtual void DeleteDocumentsExcept(Type[] documentTypes);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Marten.Storage.MartenDatabase/<DeleteDocumentsExceptAsync>d__28")]
public sealed virtual Task DeleteDocumentsExceptAsync(CancellationToken ct, Type[] documentTypes);
    [NullableContextAttribute("1")]
public sealed virtual void CompletelyRemove(Type documentType);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Marten.Storage.MartenDatabase/<CompletelyRemoveAsync>d__30")]
public sealed virtual Task CompletelyRemoveAsync(Type documentType, CancellationToken ct);
    public sealed virtual void CompletelyRemoveAll();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Marten.Storage.MartenDatabase/<CompletelyRemoveAllAsync>d__32")]
public sealed virtual Task CompletelyRemoveAllAsync(CancellationToken ct);
    public sealed virtual void DeleteAllEventData();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Marten.Storage.MartenDatabase/<DeleteAllEventDataAsync>d__34")]
public sealed virtual Task DeleteAllEventDataAsync(CancellationToken ct);
    [NullableContextAttribute("2")]
public sealed virtual void DeleteSingleEventStream(Guid streamId, string tenantId);
    [NullableContextAttribute("1")]
public sealed virtual void DeleteSingleEventStream(string streamId, string tenantId);
    [NullableContextAttribute("1")]
public sealed virtual Task DeleteSingleEventStreamAsync(Guid streamId, string tenantId, CancellationToken ct);
    [NullableContextAttribute("1")]
public sealed virtual Task DeleteSingleEventStreamAsync(string streamId, string tenantId, CancellationToken ct);
    [NullableContextAttribute("1")]
private string toDeleteEventDataSql();
    [NullableContextAttribute("2")]
private void DeleteSingleEventStream(T streamId, string tenantId);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Marten.Storage.MartenDatabase/<DeleteSingleEventStreamAsync>d__41`1")]
private Task DeleteSingleEventStreamAsync(T streamId, string tenantId, CancellationToken ct);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Marten.Storage.MartenDatabase/<FindEventStoreFloorAtTimeAsync>d__42")]
public sealed virtual Task`1<Nullable`1<long>> FindEventStoreFloorAtTimeAsync(DateTimeOffset timestamp, CancellationToken token);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Marten.Storage.MartenDatabase/<FetchEventStoreStatistics>d__43")]
public sealed virtual Task`1<EventStoreStatistics> FetchEventStoreStatistics(CancellationToken token);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Marten.Storage.MartenDatabase/<AllProjectionProgress>d__44")]
public sealed virtual Task`1<IReadOnlyList`1<ShardState>> AllProjectionProgress(CancellationToken token);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Marten.Storage.MartenDatabase/<ProjectionProgressFor>d__45")]
public sealed virtual Task`1<long> ProjectionProgressFor(ShardName name, CancellationToken token);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual ShardStateTracker get_Tracker();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void set_Tracker(ShardStateTracker value);
    [NullableContextAttribute("1")]
internal IProjectionDaemon StartProjectionDaemon(DocumentStore store, ILogger logger);
    public sealed virtual Task`1<T> Query(ISingleQueryHandler`1<T> handler, CancellationToken cancellation);
    [AsyncStateMachineAttribute("Marten.Storage.MartenDatabase/<SingleCommit>d__53")]
public sealed virtual Task SingleCommit(DbCommand command, CancellationToken cancellation);
    public sealed virtual NpgsqlConnection CreateConnection(ConnectionUsage connectionUsage);
    private sealed virtual override void Marten.Storage.IMartenDatabase.EnsureStorageExists(Type documentType);
    private sealed virtual override ValueTask Marten.Storage.IMartenDatabase.EnsureStorageExistsAsync(Type featureType, CancellationToken token);
    private sealed virtual override Task`1<IReadOnlyList`1<DbObjectName>> Marten.Storage.IMartenDatabase.SchemaTables(CancellationToken ct);
    [CompilerGeneratedAttribute]
private SequenceFactory <resetSequences>b__18_0();
}
public class Marten.Storage.MasterTableTenancy : object {
    private MasterTableTenancyOptions _configuration;
    private Lazy`1<NpgsqlDataSource> _dataSource;
    private StoreOptions _options;
    private string _schemaName;
    private Lazy`1<TenantLookupDatabase> _tenantDatabase;
    private ImHashMap`2<string, MartenDatabase> _databases;
    private bool _hasAppliedChanges;
    private bool _hasAppliedDefaults;
    [CompilerGeneratedAttribute]
private IDocumentCleaner <Cleaner>k__BackingField;
    public Tenant Default { get; }
    public IDocumentCleaner Cleaner { get; }
    public PostgresqlDatabase TenantDatabase { get; }
    public MasterTableTenancy(StoreOptions options, string connectionString, string schemaName);
    public MasterTableTenancy(StoreOptions options, MasterTableTenancyOptions tenancyOptions);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Marten.Storage.MasterTableTenancy/<BuildDatabases>d__11")]
public sealed virtual ValueTask`1<IReadOnlyList`1<IDatabase>> BuildDatabases();
    public sealed virtual Tenant get_Default();
    [CompilerGeneratedAttribute]
public sealed virtual IDocumentCleaner get_Cleaner();
    public sealed virtual Tenant GetTenant(string tenantId);
    [AsyncStateMachineAttribute("Marten.Storage.MasterTableTenancy/<GetTenantAsync>d__18")]
public sealed virtual ValueTask`1<Tenant> GetTenantAsync(string tenantId);
    [AsyncStateMachineAttribute("Marten.Storage.MasterTableTenancy/<FindOrCreateDatabase>d__19")]
public sealed virtual ValueTask`1<IMartenDatabase> FindOrCreateDatabase(string tenantIdOrDatabaseIdentifier);
    public sealed virtual bool IsTenantStoredInCurrentDatabase(IMartenDatabase database, string tenantId);
    public sealed virtual PostgresqlDatabase get_TenantDatabase();
    [AsyncStateMachineAttribute("Marten.Storage.MasterTableTenancy/<DeleteDatabaseRecordAsync>d__23")]
public Task DeleteDatabaseRecordAsync(string tenantId);
    [AsyncStateMachineAttribute("Marten.Storage.MasterTableTenancy/<ClearAllDatabaseRecordsAsync>d__24")]
public Task ClearAllDatabaseRecordsAsync();
    [AsyncStateMachineAttribute("Marten.Storage.MasterTableTenancy/<AddDatabaseRecordAsync>d__25")]
public Task AddDatabaseRecordAsync(string tenantId, string connectionString);
    [AsyncStateMachineAttribute("Marten.Storage.MasterTableTenancy/<maybeApplyChanges>d__26")]
private Task maybeApplyChanges(TenantLookupDatabase tenantDatabase);
    [AsyncStateMachineAttribute("Marten.Storage.MasterTableTenancy/<seedDatabasesAsync>d__27")]
private Task seedDatabasesAsync(NpgsqlConnection conn);
    [AsyncStateMachineAttribute("Marten.Storage.MasterTableTenancy/<tryFindTenantDatabase>d__28")]
private Task`1<MartenDatabase> tryFindTenantDatabase(string tenantId);
}
public class Marten.Storage.MasterTableTenancyOptions : object {
    internal Dictionary`2<string, string> SeedDatabases;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ConnectionString>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private NpgsqlDataSource <DataSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SchemaName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<AutoCreate> <AutoCreate>k__BackingField;
    [NullableAttribute("2")]
public string ConnectionString { get; public set; }
    [NullableAttribute("2")]
public NpgsqlDataSource DataSource { get; public set; }
    public string SchemaName { get; public set; }
    public string ApplicationName { get; public set; }
    public Nullable`1<AutoCreate> AutoCreate { get; public set; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ConnectionString();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_ConnectionString(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public NpgsqlDataSource get_DataSource();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_DataSource(NpgsqlDataSource value);
    [CompilerGeneratedAttribute]
public string get_SchemaName();
    [CompilerGeneratedAttribute]
public void set_SchemaName(string value);
    [CompilerGeneratedAttribute]
public string get_ApplicationName();
    [CompilerGeneratedAttribute]
public void set_ApplicationName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<AutoCreate> get_AutoCreate();
    [CompilerGeneratedAttribute]
public void set_AutoCreate(Nullable`1<AutoCreate> value);
    public void RegisterDatabase(string tenantId, string connectionString);
    internal string CorrectedConnectionString();
    internal string CorrectConnectionString(string connectionString);
}
internal class Marten.Storage.Metadata.CausationIdArgument : UpsertArgument {
    public virtual void GenerateCodeToModifyDocument(GeneratedMethod method, GeneratedType type, int i, Argument parameters, DocumentMapping mapping, StoreOptions options);
    public virtual void GenerateCodeToSetDbParameterValue(GeneratedMethod method, GeneratedType type, int i, Argument parameters, DocumentMapping mapping, StoreOptions options);
    public virtual void GenerateBulkWriterCode(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
    public virtual void GenerateBulkWriterCodeAsync(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
    public string ValueSql(EventGraph graph, AppendMode mode);
}
internal class Marten.Storage.Metadata.CausationIdColumn : MetadataColumn`1<string> {
    public static string ColumnName;
    private static CausationIdColumn();
    public sealed virtual void GenerateSelectorCodeSync(GeneratedMethod method, EventGraph graph, int index);
    public sealed virtual void GenerateSelectorCodeAsync(GeneratedMethod method, EventGraph graph, int index);
    public sealed virtual void GenerateAppendCode(GeneratedMethod method, EventGraph graph, int index, AppendMode full);
    public sealed virtual void GenerateCode(StorageStyle storageStyle, GeneratedType generatedType, GeneratedMethod async, GeneratedMethod sync, int index, DocumentMapping mapping);
    public sealed virtual bool ShouldSelect(DocumentMapping mapping, StorageStyle storageStyle);
    internal virtual UpsertArgument ToArgument();
    public virtual void WriteMetadataInUpdateStatement(ICommandBuilder builder, DocumentSessionBase session);
    public sealed virtual string ValueSql(EventGraph graph, AppendMode mode);
}
internal class Marten.Storage.Metadata.CorrelationIdArgument : UpsertArgument {
    public virtual void GenerateCodeToModifyDocument(GeneratedMethod method, GeneratedType type, int i, Argument parameters, DocumentMapping mapping, StoreOptions options);
    public virtual void GenerateCodeToSetDbParameterValue(GeneratedMethod method, GeneratedType type, int i, Argument parameters, DocumentMapping mapping, StoreOptions options);
    public virtual void GenerateBulkWriterCode(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
    public virtual void GenerateBulkWriterCodeAsync(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
}
internal class Marten.Storage.Metadata.CorrelationIdColumn : MetadataColumn`1<string> {
    public static string ColumnName;
    private static CorrelationIdColumn();
    public sealed virtual void GenerateSelectorCodeSync(GeneratedMethod method, EventGraph graph, int index);
    public sealed virtual void GenerateSelectorCodeAsync(GeneratedMethod method, EventGraph graph, int index);
    public sealed virtual void GenerateAppendCode(GeneratedMethod method, EventGraph graph, int index, AppendMode full);
    public sealed virtual void GenerateCode(StorageStyle storageStyle, GeneratedType generatedType, GeneratedMethod async, GeneratedMethod sync, int index, DocumentMapping mapping);
    public sealed virtual bool ShouldSelect(DocumentMapping mapping, StorageStyle storageStyle);
    internal virtual UpsertArgument ToArgument();
    public virtual void WriteMetadataInUpdateStatement(ICommandBuilder builder, DocumentSessionBase session);
    public sealed virtual string ValueSql(EventGraph graph, AppendMode mode);
}
internal class Marten.Storage.Metadata.CreatedAtColumn : MetadataColumn`1<DateTimeOffset> {
    public sealed virtual void GenerateCode(StorageStyle storageStyle, GeneratedType generatedType, GeneratedMethod async, GeneratedMethod sync, int index, DocumentMapping mapping);
    public sealed virtual bool ShouldSelect(DocumentMapping mapping, StorageStyle storageStyle);
}
internal class Marten.Storage.Metadata.DeletedAtColumn : MetadataColumn`1<Nullable`1<DateTimeOffset>> {
    public sealed virtual void GenerateCode(StorageStyle storageStyle, GeneratedType generatedType, GeneratedMethod async, GeneratedMethod sync, int index, DocumentMapping mapping);
    public sealed virtual bool ShouldSelect(DocumentMapping mapping, StorageStyle storageStyle);
}
public class Marten.Storage.Metadata.DocumentMetadata : object {
    [CompilerGeneratedAttribute]
private object <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CreatedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <CurrentVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentRevision>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DotNetType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocumentType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Deleted>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <DeletedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CausationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastModifiedBy>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Headers>k__BackingField;
    public object Id { get; }
    public DateTimeOffset CreatedAt { get; internal set; }
    public Guid CurrentVersion { get; internal set; }
    public int CurrentRevision { get; internal set; }
    public DateTimeOffset LastModified { get; internal set; }
    public string DotNetType { get; internal set; }
    public string DocumentType { get; internal set; }
    public bool Deleted { get; internal set; }
    public Nullable`1<DateTimeOffset> DeletedAt { get; internal set; }
    public string TenantId { get; internal set; }
    public string CausationId { get; public set; }
    public string CorrelationId { get; public set; }
    public string LastModifiedBy { get; public set; }
    public Dictionary`2<string, object> Headers { get; public set; }
    public DocumentMetadata(object id);
    [CompilerGeneratedAttribute]
public object get_Id();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_CreatedAt();
    [CompilerGeneratedAttribute]
internal void set_CreatedAt(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public Guid get_CurrentVersion();
    [CompilerGeneratedAttribute]
internal void set_CurrentVersion(Guid value);
    [CompilerGeneratedAttribute]
public int get_CurrentRevision();
    [CompilerGeneratedAttribute]
internal void set_CurrentRevision(int value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastModified();
    [CompilerGeneratedAttribute]
internal void set_LastModified(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public string get_DotNetType();
    [CompilerGeneratedAttribute]
internal void set_DotNetType(string value);
    [CompilerGeneratedAttribute]
public string get_DocumentType();
    [CompilerGeneratedAttribute]
internal void set_DocumentType(string value);
    [CompilerGeneratedAttribute]
public bool get_Deleted();
    [CompilerGeneratedAttribute]
internal void set_Deleted(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_DeletedAt();
    [CompilerGeneratedAttribute]
internal void set_DeletedAt(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
internal void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public string get_CausationId();
    [CompilerGeneratedAttribute]
public void set_CausationId(string value);
    [CompilerGeneratedAttribute]
public string get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(string value);
    [CompilerGeneratedAttribute]
public string get_LastModifiedBy();
    [CompilerGeneratedAttribute]
public void set_LastModifiedBy(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(Dictionary`2<string, object> value);
}
internal class Marten.Storage.Metadata.DocumentTypeColumn : MetadataColumn`1<string> {
    public DocumentTypeColumn(DocumentMapping mapping);
    public sealed virtual void GenerateCode(StorageStyle storageStyle, GeneratedType generatedType, GeneratedMethod async, GeneratedMethod sync, int index, DocumentMapping mapping);
    public sealed virtual bool ShouldSelect(DocumentMapping mapping, StorageStyle storageStyle);
}
internal class Marten.Storage.Metadata.DotNetTypeColumn : MetadataColumn`1<string> {
    public sealed virtual void GenerateSelectorCodeSync(GeneratedMethod method, EventGraph graph, int index);
    public sealed virtual void GenerateSelectorCodeAsync(GeneratedMethod method, EventGraph graph, int index);
    public sealed virtual void GenerateAppendCode(GeneratedMethod method, EventGraph graph, int index, AppendMode full);
    public sealed virtual string ValueSql(EventGraph graph, AppendMode mode);
}
internal class Marten.Storage.Metadata.EntityMetadataQueryHandler : object {
    private MetadataColumn[] _columns;
    private object _id;
    private IDocumentStorage _storage;
    [CompilerGeneratedAttribute]
private Type <SourceType>k__BackingField;
    public Type SourceType { get; }
    public EntityMetadataQueryHandler(object id, IDocumentStorage storage);
    [CompilerGeneratedAttribute]
public Type get_SourceType();
    public sealed virtual void ConfigureCommand(ICommandBuilder sql, IMartenSession session);
    public sealed virtual DocumentMetadata Handle(DbDataReader reader, IMartenSession session);
    [AsyncStateMachineAttribute("Marten.Storage.Metadata.EntityMetadataQueryHandler/<HandleAsync>d__9")]
public sealed virtual Task`1<DocumentMetadata> HandleAsync(DbDataReader reader, IMartenSession session, CancellationToken token);
    public sealed virtual Task`1<int> StreamJson(Stream stream, DbDataReader reader, CancellationToken token);
}
internal class Marten.Storage.Metadata.HeadersArgument : UpsertArgument {
    public virtual void GenerateCodeToModifyDocument(GeneratedMethod method, GeneratedType type, int i, Argument parameters, DocumentMapping mapping, StoreOptions options);
    public virtual void GenerateCodeToSetDbParameterValue(GeneratedMethod method, GeneratedType type, int i, Argument parameters, DocumentMapping mapping, StoreOptions options);
    public virtual void GenerateBulkWriterCode(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
    public virtual void GenerateBulkWriterCodeAsync(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
}
internal class Marten.Storage.Metadata.HeadersColumn : MetadataColumn`1<Dictionary`2<string, object>> {
    public static string ColumnName;
    private static HeadersColumn();
    public sealed virtual void GenerateSelectorCodeSync(GeneratedMethod method, EventGraph graph, int index);
    public sealed virtual void GenerateSelectorCodeAsync(GeneratedMethod method, EventGraph graph, int index);
    public sealed virtual void GenerateAppendCode(GeneratedMethod method, EventGraph graph, int index, AppendMode full);
    [AsyncStateMachineAttribute("Marten.Storage.Metadata.HeadersColumn/<ApplyAsync>d__5")]
internal virtual Task ApplyAsync(IMartenSession martenSession, DocumentMetadata metadata, int index, DbDataReader reader, CancellationToken token);
    internal virtual void Apply(IMartenSession martenSession, DocumentMetadata metadata, int index, DbDataReader reader);
    internal virtual void RegisterForLinqSearching(DocumentMapping mapping);
    internal virtual UpsertArgument ToArgument();
    public sealed virtual string ValueSql(EventGraph graph, AppendMode mode);
}
internal class Marten.Storage.Metadata.LastModifiedByArgument : UpsertArgument {
    public virtual void GenerateCodeToModifyDocument(GeneratedMethod method, GeneratedType type, int i, Argument parameters, DocumentMapping mapping, StoreOptions options);
    public virtual void GenerateCodeToSetDbParameterValue(GeneratedMethod method, GeneratedType type, int i, Argument parameters, DocumentMapping mapping, StoreOptions options);
    public virtual void GenerateBulkWriterCode(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
    public virtual void GenerateBulkWriterCodeAsync(GeneratedType type, GeneratedMethod load, DocumentMapping mapping);
}
internal class Marten.Storage.Metadata.LastModifiedByColumn : MetadataColumn`1<string> {
    public static string ColumnName;
    private static LastModifiedByColumn();
    public sealed virtual void GenerateCode(StorageStyle storageStyle, GeneratedType generatedType, GeneratedMethod async, GeneratedMethod sync, int index, DocumentMapping mapping);
    public sealed virtual bool ShouldSelect(DocumentMapping mapping, StorageStyle storageStyle);
    internal virtual UpsertArgument ToArgument();
    public virtual void WriteMetadataInUpdateStatement(ICommandBuilder builder, DocumentSessionBase session);
}
internal class Marten.Storage.Metadata.LastModifiedColumn : MetadataColumn`1<DateTimeOffset> {
    public sealed virtual void GenerateCode(StorageStyle storageStyle, GeneratedType generatedType, GeneratedMethod async, GeneratedMethod sync, int index, DocumentMapping mapping);
    public sealed virtual bool ShouldSelect(DocumentMapping mapping, StorageStyle storageStyle);
    public virtual void WriteMetadataInUpdateStatement(ICommandBuilder builder, DocumentSessionBase session);
}
public abstract class Marten.Storage.Metadata.MetadataColumn : TableColumn {
    [CompilerGeneratedAttribute]
private Type <DotNetType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldUpdatePartials>k__BackingField;
    public Type DotNetType { get; }
    public MemberInfo Member { get; public set; }
    public bool Enabled { get; public set; }
    public bool ShouldUpdatePartials { get; protected set; }
    protected MetadataColumn(string name, string type, Type dotNetType);
    [CompilerGeneratedAttribute]
public Type get_DotNetType();
    public abstract virtual MemberInfo get_Member();
    public abstract virtual void set_Member(MemberInfo value);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShouldUpdatePartials();
    [CompilerGeneratedAttribute]
protected void set_ShouldUpdatePartials(bool value);
    internal abstract virtual Task ApplyAsync(IMartenSession martenSession, DocumentMetadata metadata, int index, DbDataReader reader, CancellationToken token);
    internal abstract virtual void Apply(IMartenSession martenSession, DocumentMetadata metadata, int index, DbDataReader reader);
    internal virtual void RegisterForLinqSearching(DocumentMapping mapping);
    public bool EnabledWithMember();
    internal virtual UpsertArgument ToArgument();
    protected void setMemberFromReader(GeneratedType generatedType, GeneratedMethod async, GeneratedMethod sync, int index, DocumentMapping mapping);
    public virtual void WriteMetadataInUpdateStatement(ICommandBuilder builder, DocumentSessionBase session);
}
internal abstract class Marten.Storage.Metadata.MetadataColumn`1 : MetadataColumn {
    private string _memberName;
    private Action`2<DocumentMetadata, T> _setter;
    private MemberInfo _member;
    public MemberInfo Member { get; public set; }
    protected MetadataColumn`1(string name, Expression`1<Func`2<DocumentMetadata, T>> property);
    public virtual MemberInfo get_Member();
    public virtual void set_Member(MemberInfo value);
    [AsyncStateMachineAttribute("Marten.Storage.Metadata.MetadataColumn`1/<ApplyAsync>d__7")]
internal virtual Task ApplyAsync(IMartenSession martenSession, DocumentMetadata metadata, int index, DbDataReader reader, CancellationToken token);
    internal virtual void Apply(IMartenSession martenSession, DocumentMetadata metadata, int index, DbDataReader reader);
}
internal class Marten.Storage.Metadata.RevisionColumn : MetadataColumn`1<int> {
    internal virtual UpsertArgument ToArgument();
    public sealed virtual void GenerateCode(StorageStyle storageStyle, GeneratedType generatedType, GeneratedMethod async, GeneratedMethod sync, int index, DocumentMapping mapping);
    public sealed virtual bool ShouldSelect(DocumentMapping mapping, StorageStyle storageStyle);
    public virtual string AlterColumnTypeSql(Table table, TableColumn changeActual);
    public virtual bool CanAlter(TableColumn actual);
    public virtual void WriteMetadataInUpdateStatement(ICommandBuilder builder, DocumentSessionBase session);
}
internal class Marten.Storage.Metadata.SoftDeletedColumn : MetadataColumn`1<bool> {
    public sealed virtual void GenerateCode(StorageStyle storageStyle, GeneratedType generatedType, GeneratedMethod async, GeneratedMethod sync, int index, DocumentMapping mapping);
    public sealed virtual bool ShouldSelect(DocumentMapping mapping, StorageStyle storageStyle);
    internal virtual void RegisterForLinqSearching(DocumentMapping mapping);
}
internal class Marten.Storage.Metadata.TenantIdColumn : MetadataColumn`1<string> {
    public static string Name;
    private bool Marten.Events.Schema.IStreamTableColumn.Reads { get; }
    private bool Marten.Events.Schema.IStreamTableColumn.Writes { get; }
    private static TenantIdColumn();
    public sealed virtual void GenerateSelectorCodeSync(GeneratedMethod method, EventGraph graph, int index);
    public sealed virtual void GenerateSelectorCodeAsync(GeneratedMethod method, EventGraph graph, int index);
    public sealed virtual void GenerateAppendCode(GeneratedMethod method, EventGraph graph, int index, AppendMode full);
    public sealed virtual void GenerateCode(StorageStyle storageStyle, GeneratedType generatedType, GeneratedMethod async, GeneratedMethod sync, int index, DocumentMapping mapping);
    public sealed virtual bool ShouldSelect(DocumentMapping mapping, StorageStyle storageStyle);
    private sealed virtual override void Marten.Events.Schema.IStreamTableColumn.GenerateAppendCode(GeneratedMethod method, int index);
    private sealed virtual override void Marten.Events.Schema.IStreamTableColumn.GenerateSelectorCodeAsync(GeneratedMethod method, int index);
    private sealed virtual override void Marten.Events.Schema.IStreamTableColumn.GenerateSelectorCodeSync(GeneratedMethod method, int index);
    private sealed virtual override bool Marten.Events.Schema.IStreamTableColumn.get_Reads();
    private sealed virtual override bool Marten.Events.Schema.IStreamTableColumn.get_Writes();
    public sealed virtual string ValueSql(EventGraph graph, AppendMode mode);
}
internal class Marten.Storage.Metadata.VersionColumn : MetadataColumn`1<Guid> {
    public sealed virtual void GenerateCode(StorageStyle storageStyle, GeneratedType generatedType, GeneratedMethod async, GeneratedMethod sync, int index, DocumentMapping mapping);
    public sealed virtual bool ShouldSelect(DocumentMapping mapping, StorageStyle storageStyle);
    public virtual void WriteMetadataInUpdateStatement(ICommandBuilder builder, DocumentSessionBase session);
}
[ExtensionAttribute]
internal static class Marten.Storage.OriginWriter : object {
    private static string MartenFqn;
    private static OriginWriter();
    public static string OriginStatement(string objectType, string objectName);
    [ExtensionAttribute]
public static string OriginStatement(Table definition);
}
internal class Marten.Storage.OverwriteFunction : UpsertFunction {
    public OverwriteFunction(DocumentMapping mapping);
    protected virtual void writeFunction(TextWriter writer, string argList, string securityDeclaration, string inserts, string valueList, string updates);
}
internal class Marten.Storage.SingleServerMultiTenancy : SingleServerDatabaseCollection`1<MartenDatabase> {
    private StoreOptions _options;
    private Dictionary`2<string, string> _tenantToDatabase;
    private Tenant _default;
    private String[] _lastTenantIds;
    private ImHashMap`2<string, Tenant> _tenants;
    private Lazy`1<NpgsqlDataSource> _masterDataSource;
    private PostgresqlDatabase _tenantDatabase;
    [CompilerGeneratedAttribute]
private IDocumentCleaner <Cleaner>k__BackingField;
    public PostgresqlDatabase TenantDatabase { get; }
    public Tenant Default { get; }
    public IDocumentCleaner Cleaner { get; }
    public SingleServerMultiTenancy(INpgsqlDataSourceFactory dataSourceFactory, string masterConnectionString, StoreOptions options);
    public sealed virtual PostgresqlDatabase get_TenantDatabase();
    public sealed virtual void Dispose();
    public sealed virtual ISingleServerMultiTenancy WithTenants(String[] tenantIds);
    public sealed virtual ISingleServerMultiTenancy InDatabaseNamed(string databaseName);
    public sealed virtual Tenant GetTenant(string tenantId);
    public sealed virtual bool IsTenantStoredInCurrentDatabase(IMartenDatabase database, string tenantId);
    [AsyncStateMachineAttribute("Marten.Storage.SingleServerMultiTenancy/<GetTenantAsync>d__16")]
public sealed virtual ValueTask`1<Tenant> GetTenantAsync(string tenantId);
    [AsyncStateMachineAttribute("Marten.Storage.SingleServerMultiTenancy/<FindOrCreateDatabase>d__17")]
public sealed virtual ValueTask`1<IMartenDatabase> FindOrCreateDatabase(string tenantIdOrDatabaseIdentifier);
    public sealed virtual Tenant get_Default();
    [CompilerGeneratedAttribute]
public sealed virtual IDocumentCleaner get_Cleaner();
    [AsyncStateMachineAttribute("Marten.Storage.SingleServerMultiTenancy/<BuildDatabases>d__23")]
public sealed virtual ValueTask`1<IReadOnlyList`1<IDatabase>> BuildDatabases();
    protected virtual MartenDatabase buildDatabase(string databaseName, NpgsqlDataSource npgsqlDataSource);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private ValueTask`1<MartenDatabase> <>n__0(string databaseName, CancellationToken ct);
}
internal class Marten.Storage.StandinDatabase : object {
    [CompilerGeneratedAttribute]
private AutoCreate <AutoCreate>k__BackingField;
    [CompilerGeneratedAttribute]
private Migrator <Migrator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private ISequences <Sequences>k__BackingField;
    [CompilerGeneratedAttribute]
private IProviderGraph <Providers>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ShardStateTracker <Tracker>k__BackingField;
    public AutoCreate AutoCreate { get; }
    public Migrator Migrator { get; }
    public string Identifier { get; }
    public ISequences Sequences { get; }
    public IProviderGraph Providers { get; }
    [NullableAttribute("2")]
public ShardStateTracker Tracker { get; }
    public StandinDatabase(StoreOptions options);
    public sealed virtual IFeatureSchema[] BuildFeatureSchemas();
    public sealed virtual String[] AllSchemaNames();
    public sealed virtual IEnumerable`1<ISchemaObject> AllObjects();
    public sealed virtual Task`1<SchemaMigration> CreateMigrationAsync(IFeatureSchema group, CancellationToken ct);
    public sealed virtual string ToDatabaseScript();
    public sealed virtual Task WriteCreationScriptToFileAsync(string filename, CancellationToken ct);
    public sealed virtual Task WriteScriptsByTypeAsync(string directory, CancellationToken ct);
    public sealed virtual Task`1<SchemaMigration> CreateMigrationAsync(CancellationToken ct);
    public sealed virtual Task`1<SchemaPatchDifference> ApplyAllConfiguredChangesToDatabaseAsync(Nullable`1<AutoCreate> override, ReconnectionOptions reconnectionOptions, CancellationToken ct);
    public sealed virtual Task AssertDatabaseMatchesConfigurationAsync(CancellationToken ct);
    public sealed virtual Task AssertConnectivityAsync(CancellationToken ct);
    [CompilerGeneratedAttribute]
public sealed virtual AutoCreate get_AutoCreate();
    [CompilerGeneratedAttribute]
public sealed virtual Migrator get_Migrator();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Identifier();
    public sealed virtual NpgsqlConnection CreateConnection();
    public sealed virtual void DeleteAllDocuments();
    public sealed virtual Task DeleteAllDocumentsAsync(CancellationToken ct);
    public sealed virtual void DeleteDocumentsByType(Type documentType);
    public sealed virtual Task DeleteDocumentsByTypeAsync(Type documentType, CancellationToken ct);
    public sealed virtual void DeleteDocumentsExcept(Type[] documentTypes);
    public sealed virtual Task DeleteDocumentsExceptAsync(CancellationToken ct, Type[] documentTypes);
    public sealed virtual void CompletelyRemove(Type documentType);
    public sealed virtual Task CompletelyRemoveAsync(Type documentType, CancellationToken ct);
    public sealed virtual void CompletelyRemoveAll();
    public sealed virtual Task CompletelyRemoveAllAsync(CancellationToken ct);
    public sealed virtual void DeleteAllEventData();
    public sealed virtual Task DeleteAllEventDataAsync(CancellationToken ct);
    [NullableContextAttribute("2")]
public sealed virtual void DeleteSingleEventStream(Guid streamId, string tenantId);
    public sealed virtual Task DeleteSingleEventStreamAsync(Guid streamId, string tenantId, CancellationToken ct);
    public sealed virtual void DeleteSingleEventStream(string streamId, string tenantId);
    public sealed virtual Task DeleteSingleEventStreamAsync(string streamId, string tenantId, CancellationToken ct);
    public sealed virtual void EnsureStorageExists(Type documentType);
    public sealed virtual ValueTask EnsureStorageExistsAsync(Type featureType, CancellationToken token);
    public sealed virtual Task ResetHiloSequenceFloor(long floor);
    [CompilerGeneratedAttribute]
public sealed virtual ISequences get_Sequences();
    [CompilerGeneratedAttribute]
public sealed virtual IProviderGraph get_Providers();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual ShardStateTracker get_Tracker();
    public sealed virtual Task`1<IReadOnlyList`1<DbObjectName>> DocumentTables();
    public sealed virtual Task`1<IReadOnlyList`1<DbObjectName>> Functions();
    public sealed virtual Task`1<Table> ExistingTableFor(Type type);
    public sealed virtual Task`1<IReadOnlyList`1<DbObjectName>> SchemaTables(CancellationToken ct);
    public sealed virtual Task`1<EventStoreStatistics> FetchEventStoreStatistics(CancellationToken token);
    public sealed virtual Task`1<IReadOnlyList`1<ShardState>> AllProjectionProgress(CancellationToken token);
    public sealed virtual Task`1<long> ProjectionProgressFor(ShardName name, CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Storage.StandinDatabase/<FindEventStoreFloorAtTimeAsync>d__57")]
public sealed virtual Task`1<Nullable`1<long>> FindEventStoreFloorAtTimeAsync(DateTimeOffset timestamp, CancellationToken token);
    public sealed virtual NpgsqlConnection CreateConnection(ConnectionUsage connectionUsage);
    public sealed virtual void Dispose();
}
public class Marten.Storage.StaticMultiTenancy : Tenancy {
    private INpgsqlDataSourceFactory _dataSourceFactory;
    private ImHashMap`2<string, MartenDatabase> _databases;
    private ImHashMap`2<string, Tenant> _tenants;
    [CompilerGeneratedAttribute]
private Tenant <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private IDocumentCleaner <Cleaner>k__BackingField;
    public Tenant Default { get; private set; }
    public IDocumentCleaner Cleaner { get; }
    public StaticMultiTenancy(INpgsqlDataSourceFactory dataSourceFactory, StoreOptions options);
    public sealed virtual void Dispose();
    public sealed virtual bool IsTenantStoredInCurrentDatabase(IMartenDatabase database, string tenantId);
    public sealed virtual IDatabaseExpression AddMultipleTenantDatabase(string connectionString, string databaseIdentifier);
    public sealed virtual void AddSingleTenantDatabase(string connectionString, string tenantId);
    public sealed virtual ValueTask`1<IReadOnlyList`1<IDatabase>> BuildDatabases();
    public sealed virtual Tenant GetTenant(string tenantId);
    [CompilerGeneratedAttribute]
public sealed virtual Tenant get_Default();
    [CompilerGeneratedAttribute]
private void set_Default(Tenant value);
    [CompilerGeneratedAttribute]
public sealed virtual IDocumentCleaner get_Cleaner();
    public sealed virtual ValueTask`1<Tenant> GetTenantAsync(string tenantId);
    public sealed virtual ValueTask`1<IMartenDatabase> FindOrCreateDatabase(string tenantIdOrDatabaseIdentifier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.Storage.StorageFeatures : object {
    private Ref`1<ImHashMap`2<Type, IDocumentMappingBuilder>> _builders;
    private ThreadLocal`1<IList`1<Type>> _buildingList;
    private Ref`1<ImHashMap`2<Type, DocumentMapping>> _documentMappings;
    private Ref`1<ImHashMap`2<Type, IFeatureSchema>> _features;
    private Ref`1<ImHashMap`2<Type, IDocumentMapping>> _mappings;
    private StoreOptions _options;
    private ImHashMap`2<Type, IEnumerable`1<Type>> _typeDependencies;
    [CompilerGeneratedAttribute]
private List`1<ISchemaObject> <ExtendedSchemaObjects>k__BackingField;
    [CompilerGeneratedAttribute]
private SystemFunctions <SystemFunctions>k__BackingField;
    public List`1<ISchemaObject> ExtendedSchemaObjects { get; }
    internal SystemFunctions SystemFunctions { get; }
    internal IEnumerable`1<DocumentMapping> AllDocumentMappings { get; }
    internal IEnumerable`1<DocumentMapping> DocumentMappingsWithSchema { get; }
    private ISchemaObject[] Weasel.Core.Migrations.IFeatureSchema.Objects { get; }
    private string Weasel.Core.Migrations.IFeatureSchema.Identifier { get; }
    private Migrator Weasel.Core.Migrations.IFeatureSchema.Migrator { get; }
    private Type Weasel.Core.Migrations.IFeatureSchema.StorageType { get; }
    internal StorageFeatures(StoreOptions options);
    [CompilerGeneratedAttribute]
public List`1<ISchemaObject> get_ExtendedSchemaObjects();
    [CompilerGeneratedAttribute]
internal SystemFunctions get_SystemFunctions();
    internal IEnumerable`1<DocumentMapping> get_AllDocumentMappings();
    internal IEnumerable`1<DocumentMapping> get_DocumentMappingsWithSchema();
    private sealed virtual override void Weasel.Core.Migrations.IFeatureSchema.WritePermissions(Migrator rules, TextWriter writer);
    [IteratorStateMachineAttribute("Marten.Storage.StorageFeatures/<Weasel-Core-Migrations-IFeatureSchema-DependentTypes>d__19")]
private sealed virtual override IEnumerable`1<Type> Weasel.Core.Migrations.IFeatureSchema.DependentTypes();
    private sealed virtual override ISchemaObject[] Weasel.Core.Migrations.IFeatureSchema.get_Objects();
    private sealed virtual override string Weasel.Core.Migrations.IFeatureSchema.get_Identifier();
    private sealed virtual override Migrator Weasel.Core.Migrations.IFeatureSchema.get_Migrator();
    private sealed virtual override Type Weasel.Core.Migrations.IFeatureSchema.get_StorageType();
    internal DocumentMapping Build(Type type, StoreOptions options);
    internal void RegisterDocumentType(Type documentType);
    internal DocumentMappingBuilder`1<T> BuilderFor();
    internal void BuildAllMappings();
    public void Add(IFeatureSchema feature);
    [NullableContextAttribute("0")]
public void Add();
    internal DocumentMapping MappingFor(Type documentType);
    internal IDocumentMapping FindMapping(Type documentType);
    internal void AddMapping(IDocumentMapping mapping);
    private void assertNoDuplicateDocumentAliases();
    public IFeatureSchema FindFeature(Type featureType);
    internal void PostProcessConfiguration();
    [IteratorStateMachineAttribute("Marten.Storage.StorageFeatures/<AllActiveFeatures>d__40")]
internal IEnumerable`1<IFeatureSchema> AllActiveFeatures(IMartenDatabase database);
    internal bool SequenceIsRequired();
    internal IEnumerable`1<Type> GetTypeDependencies(Type type);
    private IEnumerable`1<Type> determineTypeDependencies(Type type);
    internal void IncludeDocumentMappingBuilders(StorageFeatures includedStorage);
    [CompilerGeneratedAttribute]
private ImHashMap`2<Type, IFeatureSchema> <PostProcessConfiguration>b__39_0(ImHashMap`2<Type, IFeatureSchema> d);
    [CompilerGeneratedAttribute]
private ImHashMap`2<Type, IFeatureSchema> <PostProcessConfiguration>b__39_1(ImHashMap`2<Type, IFeatureSchema> d);
    [CompilerGeneratedAttribute]
private ImHashMap`2<Type, IFeatureSchema> <PostProcessConfiguration>b__39_2(ImHashMap`2<Type, IFeatureSchema> d);
    [CompilerGeneratedAttribute]
private ImHashMap`2<Type, IDocumentMapping> <PostProcessConfiguration>b__39_3(ImHashMap`2<Type, IDocumentMapping> d);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IEnumerable`1<DocumentMapping> <AllActiveFeatures>b__40_1(DocumentMapping m);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <AllActiveFeatures>b__40_3(IFeatureSchema x);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IEnumerable`1<Type> <determineTypeDependencies>b__43_0(Type keyDefinition);
}
internal class Marten.Storage.SystemFunction : Function {
    private string _args;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public SystemFunction(StoreOptions options, string functionName, string args, bool isRemoved);
    public SystemFunction(string schema, string functionName, string args, bool isRemoved);
    [CompilerGeneratedAttribute]
public string get_Name();
    public virtual void WriteCreateStatement(Migrator rules, TextWriter writer);
}
internal class Marten.Storage.SystemFunctions : object {
    private bool _isActive;
    private StoreOptions _options;
    private IDictionary`2<string, SystemFunction> _systemFunctions;
    [CompilerGeneratedAttribute]
private Type <StorageType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    public Migrator Migrator { get; }
    public ISchemaObject[] Objects { get; }
    public Type StorageType { get; }
    public string Identifier { get; }
    public SystemFunctions(StoreOptions options);
    public sealed virtual Migrator get_Migrator();
    [IteratorStateMachineAttribute("Marten.Storage.SystemFunctions/<DependentTypes>d__6")]
public sealed virtual IEnumerable`1<Type> DependentTypes();
    public sealed virtual ISchemaObject[] get_Objects();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_StorageType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Identifier();
    public sealed virtual void WritePermissions(Migrator rules, TextWriter writer);
    public void AddSystemFunction(StoreOptions options, string name, string args);
    public bool IsActive(StoreOptions options);
}
public abstract class Marten.Storage.Tenancy : object {
    public static string DefaultTenantId;
    [CompilerGeneratedAttribute]
private StoreOptions <Options>k__BackingField;
    internal StoreOptions Options { get; }
    protected Tenancy(StoreOptions options);
    [CompilerGeneratedAttribute]
internal StoreOptions get_Options();
}
public enum Marten.Storage.TenancyStyle : Enum {
    public int value__;
    public static TenancyStyle Single;
    public static TenancyStyle Conjoined;
}
public class Marten.Storage.Tenant : object {
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private IMartenDatabase <Database>k__BackingField;
    public string TenantId { get; }
    public IMartenDatabase Database { get; }
    public Tenant(string tenantId, IMartenDatabase inner);
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
public IMartenDatabase get_Database();
    public static Tenant ForDatabase(IMartenDatabase database);
}
public class Marten.Storage.UnknownTenantIdException : MartenException {
    public UnknownTenantIdException(string tenantId);
}
internal class Marten.Storage.UpdateFunction : UpsertFunction {
    public UpdateFunction(DocumentMapping mapping);
    protected virtual void writeFunction(TextWriter writer, string argList, string securityDeclaration, string inserts, string valueList, string updates);
}
internal class Marten.Storage.UpsertFunction : Function {
    protected string _andTenantWhereClause;
    private bool _disableConcurrency;
    protected DocumentMapping _mapping;
    protected DbObjectName _tableName;
    protected string _tenantWhereClause;
    public IList`1<UpsertArgument> Arguments;
    protected string _primaryKeyFields;
    protected string _versionSourceTable;
    protected string _versionColumnName;
    protected string _tenantVersionWhereClause;
    protected string _andTenantVersionWhereClause;
    public UpsertFunction(DocumentMapping mapping, DbObjectName identifier, bool disableConcurrency);
    public void AddIfActive(MetadataColumn column);
    public virtual void WriteCreateStatement(Migrator rules, TextWriter writer);
    protected virtual void writeFunction(TextWriter writer, string argList, string securityDeclaration, string inserts, string valueList, string updates);
    public UpsertArgument[] OrderedArguments();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Marten.StoreOptions : object {
    public static int DefaultTimeout;
    [NullableAttribute("2")]
internal static string NoConnectionMessage;
    internal static Func`2<string, NpgsqlDataSourceBuilder> DefaultNpgsqlDataSourceBuilderFactory;
    internal List`1<Action`1<ISerializer>> SerializationConfigurations;
    private List`1<IDocumentPolicy> _policies;
    private List`1<IDocumentPolicy> _postPolicies;
    internal List`1<IInitialData> InitialData;
    [CompilerGeneratedAttribute]
private TenantIdStyle <TenantIdStyle>k__BackingField;
    public List`1<IDocumentSessionListener> Listeners;
    [CompilerGeneratedAttribute]
private OpenTelemetryOptions <OpenTelemetry>k__BackingField;
    public MartenRegistry Schema;
    private string _databaseSchemaName;
    private IMartenLogger _logger;
    [NullableAttribute("2")]
private ISerializer _serializer;
    public AutoCreate AutoCreateSchemaObjects;
    [CompilerGeneratedAttribute]
private bool <DisableNpgsqlLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseStickyConnectionLifetimes>k__BackingField;
    [CompilerGeneratedAttribute]
private ResiliencePipeline <ResiliencePipeline>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<ITenancy> _tenancy;
    private Func`2<string, NpgsqlDataSourceBuilder> _npgsqlDataSourceBuilderFactory;
    private INpgsqlDataSourceFactory _npgsqlDataSourceFactory;
    private List`1<Type> _compiledQueryTypes;
    private int _applyChangesLockId;
    private bool _shouldApplyChangesOnStartup;
    private bool _shouldAssertDatabaseMatchesConfigurationOnStartup;
    private ProjectionOptions _projections;
    private TypeLoadMode _generatedCodeMode;
    private StorageFeatures _storage;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<IDatabaseCreationExpressions> _createDatabases;
    private IProviderGraph _providers;
    private AdvancedOptions _advanced;
    private EventGraph _eventGraph;
    private LinqParsing _linq;
    private int _updateBatchSize;
    [CompilerGeneratedAttribute]
private int <CommandTimeout>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ILoggerFactory <LogFactory>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ILogger <DotNetLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private MartenManagedTenantListPartitions <TenantPartitions>k__BackingField;
    [NullableAttribute("0")]
private GenerationRules _rules;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private Assembly <ApplicationAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SourceCodeWritingEnabled>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private string <StoreName>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private string <GeneratedCodeOutputPath>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private string <JasperFx.CodeGeneration.ICodeFileCollection.ChildNamespace>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private List`1<ValueTypeInfo> <ValueTypes>k__BackingField;
    internal Func`2<string, NpgsqlDataSourceBuilder> NpgsqlDataSourceBuilderFactory { get; private set; }
    internal INpgsqlDataSourceFactory NpgsqlDataSourceFactory { get; private set; }
    public TenantIdStyle TenantIdStyle { get; public set; }
    public OpenTelemetryOptions OpenTelemetry { get; }
    public bool DisableNpgsqlLogging { get; public set; }
    public bool UseStickyConnectionLifetimes { get; public set; }
    internal ResiliencePipeline ResiliencePipeline { get; internal set; }
    public int ApplyChangesLockId { get; public set; }
    internal bool ShouldApplyChangesOnStartup { get; internal set; }
    internal bool ShouldAssertDatabaseMatchesConfigurationOnStartup { get; internal set; }
    public ProjectionOptions Projections { get; }
    public TypeLoadMode GeneratedCodeMode { get; public set; }
    public StorageFeatures Storage { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Action`1<IDatabaseCreationExpressions> CreateDatabases { get; internal set; }
    internal IProviderGraph Providers { get; }
    public AdvancedOptions Advanced { get; }
    internal EventGraph EventGraph { get; }
    public IEventStoreOptions Events { get; }
    public LinqParsing Linq { get; }
    public PoliciesExpression Policies { get; }
    private IReadOnlyAdvancedOptions Marten.IReadOnlyStoreOptions.Advanced { get; }
    public string DatabaseSchemaName { get; public set; }
    public int NameDataLength { get; public set; }
    public EnumStorage EnumStorage { get; }
    public int UpdateBatchSize { get; public set; }
    public ITenancy Tenancy { get; public set; }
    private IReadOnlyEventStoreOptions Marten.IReadOnlyStoreOptions.Events { get; }
    private IReadOnlyLinqParsing Marten.IReadOnlyStoreOptions.Linq { get; }
    public int CommandTimeout { get; public set; }
    [NullableAttribute("2")]
internal ILoggerFactory LogFactory { get; internal set; }
    [NullableAttribute("2")]
internal ILogger DotNetLogger { get; internal set; }
    private IDocumentSchemaResolver Marten.IReadOnlyStoreOptions.Schema { get; }
    private string Marten.IDocumentSchemaResolver.EventsSchemaName { get; }
    internal MartenManagedTenantListPartitions TenantPartitions { get; internal set; }
    [NullableAttribute("0")]
public Assembly ApplicationAssembly { get; public set; }
    public bool SourceCodeWritingEnabled { get; public set; }
    [NullableAttribute("0")]
public string StoreName { get; public set; }
    [NullableAttribute("0")]
public string GeneratedCodeOutputPath { get; public set; }
    [NullableAttribute("0")]
private GenerationRules JasperFx.CodeGeneration.ICodeFileCollection.Rules { get; }
    [NullableAttribute("0")]
private string JasperFx.CodeGeneration.ICodeFileCollection.ChildNamespace { get; }
    [NullableAttribute("0")]
internal List`1<ValueTypeInfo> ValueTypes { get; }
    [NullableAttribute("0")]
internal List`1<Type> CompiledQueryTypes { get; }
    private static StoreOptions();
    internal Func`2<string, NpgsqlDataSourceBuilder> get_NpgsqlDataSourceBuilderFactory();
    private void set_NpgsqlDataSourceBuilderFactory(Func`2<string, NpgsqlDataSourceBuilder> value);
    internal INpgsqlDataSourceFactory get_NpgsqlDataSourceFactory();
    private void set_NpgsqlDataSourceFactory(INpgsqlDataSourceFactory value);
    [CompilerGeneratedAttribute]
public TenantIdStyle get_TenantIdStyle();
    [CompilerGeneratedAttribute]
public void set_TenantIdStyle(TenantIdStyle value);
    [CompilerGeneratedAttribute]
public OpenTelemetryOptions get_OpenTelemetry();
    public sealed virtual string MaybeCorrectTenantId(string tenantId);
    [CompilerGeneratedAttribute]
public bool get_DisableNpgsqlLogging();
    [CompilerGeneratedAttribute]
public void set_DisableNpgsqlLogging(bool value);
    public void ConfigurePolly(Action`1<ResiliencePipelineBuilder> configure);
    public void ExtendPolly(Action`1<ResiliencePipelineBuilder> configure);
    [CompilerGeneratedAttribute]
public bool get_UseStickyConnectionLifetimes();
    [CompilerGeneratedAttribute]
public void set_UseStickyConnectionLifetimes(bool value);
    [CompilerGeneratedAttribute]
internal ResiliencePipeline get_ResiliencePipeline();
    [CompilerGeneratedAttribute]
internal void set_ResiliencePipeline(ResiliencePipeline value);
    public int get_ApplyChangesLockId();
    public void set_ApplyChangesLockId(int value);
    internal bool get_ShouldApplyChangesOnStartup();
    internal void set_ShouldApplyChangesOnStartup(bool value);
    internal bool get_ShouldAssertDatabaseMatchesConfigurationOnStartup();
    internal void set_ShouldAssertDatabaseMatchesConfigurationOnStartup(bool value);
    public ProjectionOptions get_Projections();
    public TypeLoadMode get_GeneratedCodeMode();
    public void set_GeneratedCodeMode(TypeLoadMode value);
    public StorageFeatures get_Storage();
    internal Action`1<IDatabaseCreationExpressions> get_CreateDatabases();
    internal void set_CreateDatabases(Action`1<IDatabaseCreationExpressions> value);
    internal IProviderGraph get_Providers();
    public AdvancedOptions get_Advanced();
    internal EventGraph get_EventGraph();
    public IEventStoreOptions get_Events();
    public LinqParsing get_Linq();
    public PoliciesExpression get_Policies();
    private sealed virtual override void Weasel.Core.Migrations.IMigrationLogger.SchemaChange(string sql);
    private sealed virtual override void Weasel.Core.Migrations.IMigrationLogger.OnFailure(DbCommand command, Exception ex);
    private sealed virtual override IReadOnlyAdvancedOptions Marten.IReadOnlyStoreOptions.get_Advanced();
    public sealed virtual string get_DatabaseSchemaName();
    public sealed virtual void set_DatabaseSchemaName(string value);
    public sealed virtual int get_NameDataLength();
    public void set_NameDataLength(int value);
    public sealed virtual EnumStorage get_EnumStorage();
    public sealed virtual int get_UpdateBatchSize();
    public void set_UpdateBatchSize(int value);
    public sealed virtual ISerializer Serializer();
    public sealed virtual IMartenLogger Logger();
    private sealed virtual override IReadOnlyList`1<IDocumentType> Marten.IReadOnlyStoreOptions.AllKnownDocumentTypes();
    private sealed virtual override IDocumentType Marten.IReadOnlyStoreOptions.FindOrResolveDocumentType(Type documentType);
    private sealed virtual override void Marten.IReadOnlyStoreOptions.AssertDocumentTypeIsSoftDeleted(Type documentType);
    public sealed virtual ITenancy get_Tenancy();
    public void set_Tenancy(ITenancy value);
    private sealed virtual override IReadOnlyEventStoreOptions Marten.IReadOnlyStoreOptions.get_Events();
    private sealed virtual override IReadOnlyLinqParsing Marten.IReadOnlyStoreOptions.get_Linq();
    [CompilerGeneratedAttribute]
public int get_CommandTimeout();
    [CompilerGeneratedAttribute]
public void set_CommandTimeout(int value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal ILoggerFactory get_LogFactory();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_LogFactory(ILoggerFactory value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal ILogger get_DotNetLogger();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_DotNetLogger(ILogger value);
    public void CreateDatabasesForTenants(Action`1<IDatabaseCreationExpressions> configure);
    public void DataSourceFactory(INpgsqlDataSourceFactory dataSourceFactory, string connectionString);
    public void Connection(string connectionString);
    [ObsoleteAttribute("Use version with connection string. This will be removed in Marten 8")]
public void Connection(Func`1<string> connectionSource);
    [ObsoleteAttribute("Use one of the overloads that takes a connection string, an NpgsqlDataSource, or an INpgsqlDataSourceFactory. This will be removed in Marten 8")]
public void Connection(Func`1<NpgsqlConnection> source);
    public void Connection(NpgsqlDataSource dataSource);
    public void Connection(Func`2<string, NpgsqlDataSourceBuilder> dataSourceBuilderFactory, NpgsqlDataSource dataSource);
    public void Serializer(ISerializer serializer);
    [ObsoleteAttribute("Prefer UseNewtonsoftForSerialization or UseSystemTextJsonForSerialization to configure JSON options")]
public void UseDefaultSerialization(EnumStorage enumStorage, Casing casing, CollectionStorage collectionStorage, NonPublicMembersStorage nonPublicMembersStorage, SerializerType serializerType);
    public void UseNewtonsoftForSerialization(EnumStorage enumStorage, Casing casing, CollectionStorage collectionStorage, NonPublicMembersStorage nonPublicMembersStorage, Action`1<JsonSerializerSettings> configure);
    public void UseSystemTextJsonForSerialization(EnumStorage enumStorage, Casing casing, Action`1<JsonSerializerOptions> configure);
    [NullableContextAttribute("2")]
public void UseSystemTextJsonForSerialization(JsonSerializerOptions options, EnumStorage enumStorage, Casing casing, Action`1<JsonSerializerOptions> configure);
    [NullableContextAttribute("0")]
public void Serializer();
    public void Logger(IMartenLogger logger);
    internal void ApplyConfiguration();
    internal void applyPolicies(DocumentMapping mapping);
    internal void applyPostPolicies(DocumentMapping mapping);
    internal void Validate();
    public void SetApplicationProject(Assembly assembly, string hintPath);
    public void MultiTenantedWithSingleServer(string masterConnectionString, Action`1<ISingleServerMultiTenancy> configure);
    public void MultiTenantedDatabases(Action`1<IStaticMultiTenancy> configure);
    public void MultiTenantedDatabasesWithMasterDatabaseTable(string connectionString, string schemaName);
    public void MultiTenantedDatabasesWithMasterDatabaseTable(Action`1<MasterTableTenancyOptions> configure);
    private sealed virtual override IDocumentSchemaResolver Marten.IReadOnlyStoreOptions.get_Schema();
    private sealed virtual override string Marten.IDocumentSchemaResolver.get_EventsSchemaName();
    [CompilerGeneratedAttribute]
internal MartenManagedTenantListPartitions get_TenantPartitions();
    [CompilerGeneratedAttribute]
internal void set_TenantPartitions(MartenManagedTenantListPartitions value);
    private sealed virtual override string Marten.IDocumentSchemaResolver.For(bool qualified);
    public sealed virtual string For(Type documentType, bool qualified);
    private sealed virtual override string Marten.IDocumentSchemaResolver.ForEvents(bool qualified);
    private sealed virtual override string Marten.IDocumentSchemaResolver.ForStreams(bool qualified);
    private sealed virtual override string Marten.IDocumentSchemaResolver.ForEventProgression(bool qualified);
    internal void ApplyMetricsIfAny();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public Assembly get_ApplicationAssembly();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public void set_ApplicationAssembly(Assembly value);
    [CompilerGeneratedAttribute]
public bool get_SourceCodeWritingEnabled();
    [CompilerGeneratedAttribute]
public void set_SourceCodeWritingEnabled(bool value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public string get_StoreName();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public void set_StoreName(string value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public string get_GeneratedCodeOutputPath();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public void set_GeneratedCodeOutputPath(string value);
    [NullableContextAttribute("0")]
public sealed virtual IReadOnlyList`1<ICodeFile> BuildFiles();
    [NullableContextAttribute("0")]
private sealed virtual override GenerationRules JasperFx.CodeGeneration.ICodeFileCollection.get_Rules();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private sealed virtual override string JasperFx.CodeGeneration.ICodeFileCollection.get_ChildNamespace();
    [NullableContextAttribute("0")]
internal void ReadHostEnvironment(IHostEnvironment environment);
    [NullableContextAttribute("0")]
internal GenerationRules CreateGenerationRules();
    [NullableContextAttribute("0")]
internal IIdGeneration DetermineIdStrategy(Type documentType, MemberInfo idMember);
    [NullableContextAttribute("0")]
private bool idMemberIsSettable(MemberInfo idMember);
    [NullableContextAttribute("0")]
internal ValueTypeInfo TryFindValueType(Type idType);
    [NullableContextAttribute("0")]
public ValueTypeInfo RegisterValueType(Type type);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal List`1<ValueTypeInfo> get_ValueTypes();
    internal IQueryableMember CreateQueryableMember(MemberInfo member, IQueryableMember parent);
    internal IQueryableMember CreateQueryableMember(MemberInfo member, IQueryableMember parent, Type memberType);
    private static bool isEnumerable(Type fieldType);
    [NullableContextAttribute("0")]
internal List`1<Type> get_CompiledQueryTypes();
    [NullableContextAttribute("0")]
public void RegisterDocumentType();
    [NullableContextAttribute("0")]
public void RegisterDocumentType(Type documentType);
    [NullableContextAttribute("0")]
public void AutoRegister(Action`1<MartenAssemblyScanner> configure);
    public void AutoRegister();
    [NullableContextAttribute("0")]
public void RegisterDocumentTypes(IEnumerable`1<Type> documentTypes);
    [NullableContextAttribute("0")]
public void RegisterCompiledQueryType(Type queryType);
    [CompilerGeneratedAttribute]
private NpgsqlDataSourceBuilder <.ctor>b__26_0(string connectionString);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private DocumentProviderBuilder <BuildFiles>b__183_0(DocumentMapping x);
}
public interface Marten.Subscriptions.ISubscription {
    public abstract virtual Task`1<IChangeListener> ProcessEventsAsync(EventRange page, ISubscriptionController controller, IDocumentOperations operations, CancellationToken cancellationToken);
}
public interface Marten.Subscriptions.ISubscriptionOptions {
    public string SubscriptionName { get; public set; }
    public UInt32 SubscriptionVersion { get; public set; }
    public AsyncOptions Options { get; }
    public abstract virtual string get_SubscriptionName();
    public abstract virtual void set_SubscriptionName(string value);
    public abstract virtual UInt32 get_SubscriptionVersion();
    public abstract virtual void set_SubscriptionVersion(UInt32 value);
    public abstract virtual AsyncOptions get_Options();
}
public interface Marten.Subscriptions.ISubscriptionSource {
    public AsyncOptions Options { get; }
    public string SubscriptionName { get; }
    public UInt32 SubscriptionVersion { get; }
    public abstract virtual AsyncOptions get_Options();
    public abstract virtual IReadOnlyList`1<AsyncProjectionShard> AsyncProjectionShards(DocumentStore store);
    public abstract virtual ISubscription Build(DocumentStore store);
    public abstract virtual string get_SubscriptionName();
    public abstract virtual UInt32 get_SubscriptionVersion();
}
internal class Marten.Subscriptions.ScopedSubscriptionServiceWrapper`1 : SubscriptionBase {
    private IServiceProvider _provider;
    public ScopedSubscriptionServiceWrapper`1(IServiceProvider provider);
    [AsyncStateMachineAttribute("Marten.Subscriptions.ScopedSubscriptionServiceWrapper`1/<ProcessEventsAsync>d__2")]
public virtual Task`1<IChangeListener> ProcessEventsAsync(EventRange page, ISubscriptionController controller, IDocumentOperations operations, CancellationToken cancellationToken);
}
public abstract class Marten.Subscriptions.SubscriptionBase : EventFilterable {
    [CompilerGeneratedAttribute]
private string <SubscriptionName>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <SubscriptionVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncOptions <Options>k__BackingField;
    public string SubscriptionName { get; public set; }
    public UInt32 SubscriptionVersion { get; public set; }
    public AsyncOptions Options { get; protected set; }
    public virtual ValueTask DisposeAsync();
    public abstract virtual Task`1<IChangeListener> ProcessEventsAsync(EventRange page, ISubscriptionController controller, IDocumentOperations operations, CancellationToken cancellationToken);
    private sealed virtual override ISubscription Marten.Subscriptions.ISubscriptionSource.Build(DocumentStore store);
    protected virtual ISubscription buildSubscription(DocumentStore store);
    private sealed virtual override IReadOnlyList`1<AsyncProjectionShard> Marten.Subscriptions.ISubscriptionSource.AsyncProjectionShards(DocumentStore store);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SubscriptionName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SubscriptionName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_SubscriptionVersion();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SubscriptionVersion(UInt32 value);
    [CompilerGeneratedAttribute]
public sealed virtual AsyncOptions get_Options();
    [CompilerGeneratedAttribute]
protected void set_Options(AsyncOptions value);
}
internal class Marten.Subscriptions.SubscriptionExecution : object {
    private ISubscription _subscription;
    private DocumentStore _store;
    private IMartenDatabase _database;
    private ILogger _logger;
    private CancellationTokenSource _cancellation;
    private ActionBlock`1<EventRange> _executionBlock;
    private SubscriptionMetrics _metrics;
    [CompilerGeneratedAttribute]
private string <ShardIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private ShardExecutionMode <Mode>k__BackingField;
    public string ShardIdentity { get; }
    public string DatabaseName { get; }
    public ShardExecutionMode Mode { get; public set; }
    public SubscriptionExecution(ShardName shard, ISubscription subscription, DocumentStore store, IMartenDatabase database, ILogger logger);
    [AsyncStateMachineAttribute("Marten.Subscriptions.SubscriptionExecution/<executeRange>d__8")]
private Task executeRange(EventRange range);
    [CompilerGeneratedAttribute]
public string get_ShardIdentity();
    [AsyncStateMachineAttribute("Marten.Subscriptions.SubscriptionExecution/<DisposeAsync>d__12")]
public sealed virtual ValueTask DisposeAsync();
    public sealed virtual void Enqueue(EventPage page, ISubscriptionAgent subscriptionAgent);
    [AsyncStateMachineAttribute("Marten.Subscriptions.SubscriptionExecution/<StopAndDrainAsync>d__14")]
public sealed virtual Task StopAndDrainAsync(CancellationToken token);
    [AsyncStateMachineAttribute("Marten.Subscriptions.SubscriptionExecution/<HardStopAsync>d__15")]
public sealed virtual Task HardStopAsync();
    public sealed virtual Task EnsureStorageExists();
    public sealed virtual string get_DatabaseName();
    [CompilerGeneratedAttribute]
public sealed virtual ShardExecutionMode get_Mode();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Mode(ShardExecutionMode value);
}
internal class Marten.Subscriptions.SubscriptionWrapper : SubscriptionBase {
    private ISubscription _subscription;
    public SubscriptionWrapper(ISubscription subscription);
    public virtual Task`1<IChangeListener> ProcessEventsAsync(EventRange page, ISubscriptionController controller, IDocumentOperations operations, CancellationToken cancellationToken);
}
public enum Marten.TenantIdStyle : Enum {
    public int value__;
    public static TenantIdStyle CaseSensitive;
    public static TenantIdStyle ForceUpperCase;
    public static TenantIdStyle ForceLowerCase;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Marten.Util.CommandExtensions : object {
    [ExtensionAttribute]
public static NpgsqlBatch BuildCommand(IMartenSession session, ISqlFragment statement);
    [ExtensionAttribute]
public static NpgsqlBatch BuildCommand(IMartenSession session, IQueryHandler handler);
    [ExtensionAttribute]
public static NpgsqlBatch BuildCommand(IMartenSession session, IEnumerable`1<IQueryHandler> handlers);
}
[ExtensionAttribute]
internal static class Marten.Util.ReflectionExtensions : object {
    [ExtensionAttribute]
public static string ToTableAlias(MemberInfo[] members);
    [ExtensionAttribute]
public static string ToTableAlias(MemberInfo member);
    [ExtensionAttribute]
public static string ToTableAlias(string name);
}
[ExtensionAttribute]
internal static class Marten.Util.ResilientPipelineBuilderExtensions : object {
    [ExtensionAttribute]
public static ResiliencePipelineBuilder AddMartenDefaults(ResiliencePipelineBuilder builder);
}
[IsReadOnlyAttribute]
internal class Marten.Util.SharedBuffer : ValueType {
    private ArraySegment`1<byte> _buffer;
    private SharedBuffer(ArraySegment`1<byte> buffer);
    public static SharedBuffer RentAndCopy(SOHSkippingStream stream);
    public sealed virtual void Dispose();
    public static ReadOnlySpan`1<byte> op_Implicit(SharedBuffer self);
    public static ReadOnlySequence`1<byte> op_Implicit(SharedBuffer self);
}
internal class Marten.Util.SOHSkippingStream : Stream {
    private Stream _inner;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public SOHSkippingStream(Stream inner);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("Marten.Util.SOHSkippingStream/<ReadAsync>d__15")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Marten.Util.SOHSkippingStream/<ReadAsync>d__16")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int Read(Span`1<byte> buffer);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Marten.Util.StreamExtensions : object {
    private static int BufferSize;
    private static Encoding UTF8NoBOM;
    private static StreamExtensions();
    [ExtensionAttribute]
public static SOHSkippingStream ToSOHSkippingStream(Stream stream);
    [AsyncStateMachineAttribute("Marten.Util.StreamExtensions/<CopyStreamSkippingSOHAsync>d__3")]
[ExtensionAttribute]
public static Task CopyStreamSkippingSOHAsync(Stream input, Stream output, CancellationToken token);
    [ExtensionAttribute]
public static StreamReader GetStreamReader(Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Marten.Util.StringExtensionMethods : object {
    private static SnakeCaseNamingStrategy _snakeCaseNamingStrategy;
    private static StringExtensionMethods();
    [ExtensionAttribute]
public static string ToSnakeCase(string s);
    [ExtensionAttribute]
public static string FormatCase(string s, Casing casing);
    [ExtensionAttribute]
public static string ToJsonKey(MemberInfo member, Casing casing);
}
public enum Marten.ValueCasting : Enum {
    public int value__;
    public static ValueCasting Strict;
    public static ValueCasting Relaxed;
}
internal class Marten.ValueTypeMemberSource : object {
    [NullableContextAttribute("1")]
public sealed virtual bool TryResolve(IQueryableMember parent, StoreOptions options, MemberInfo memberInfo, Type memberType, IQueryableMember& member);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
